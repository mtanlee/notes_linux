tTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 *
 *          kvImageLeaveAlphaUnchanged    Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return The following error codes may be returned
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF. 
 */
vImage_Error
vImageEqualization_ARGBFFFF( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    void *tempBuffer, 
    unsigned int histogram_entries,  
    Pixel_F minVal, 
    Pixel_F maxVal, 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );


/*!
 * @functiongroup Histogram Specification
 * @discussion These functions cause the source image pixel distribution to conform to the
 *             desired histogram.
 */
    
/*!
 * @function vImageHistogramSpecification_Planar8
 *
 * @abstract Performs a histogram specification operation on a Planar8 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Compute the histogram of the input image;
 *      Calculate normalized sum of the input histogram and the desired_histogram
 *      Generate the inverse transform
 *      Transform final image using inv_hist as a LUT. For each pixel, do the following:
 *          dest[x] = inv_histogram[src[x]];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * @param src               A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest              A pointer to a vImage buffer that references the destination pixels
 *
 * @param desired_histogram A pointer to the desired histogram for the transformed image.
 *                          The histogram should be an array with 256 elements.
 *
 * @param flags             The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile         Turns off internal multithreading. You may
 *                                   wish to do this if you have your own
 *                                   multithreading scheme to avoid having the
 *                                   two interfere with one another.
 * @/textblock</pre>
 *
 * @return  The following error codes may occur:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src, dest or desired_histogram pointer is NULL.
 * @/textblock</pre>
 */
vImage_Error
vImageHistogramSpecification_Planar8( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    const vImagePixelCount *desired_histogram, 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2,3) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 * @function vImageHistogramSpecification_PlanarF
 *
 * @abstract Performs a histogram specification operation on a PlanarF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Compute the histogram of the input image:
 *          For each pixel, do the following:
 *              val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
 *              i = clip val between 0 and histogram_entries-1
 *              histogram[i]++;
 *      Calculate normalized sum of the input histogram and the desired_histogram
 *      Generate the inverse transform
 *      Transform final image using inverse transform as a LUT. For each pixel, do the following:
 *          val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
 *          i = clip val between 0 and histogram_entries-1
 *          dest[x] = inv_histogram[i];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself,
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param desired_histogram A pointer the desired histogram for the transformed image.
 *                      The histogram should be an array with histogram_entries elements.
 *
 * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be
 *                      clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the first histogram entry.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will
 *                      be clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the last histogram entry.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src, dest or desired_histogram pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock</pre>
 */
vImage_Error 
vImageHistogramSpecification_PlanarF( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    void *tempBuffer, 
    const vImagePixelCount *desired_histogram, 
    unsigned int histogram_entries, 
    Pixel_F minVal, 
    Pixel_F maxVal, 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2,4) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );


/*!
 * @function vImageHistogramSpecification_ARGB8888
 *
 * @abstract Performs a histogram specification operation on an ARGB8888 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each channel:
 *          Compute the histogram of the input image;
 *          Calculate normalized sum of the input histogram and the desired_histogram
 *          Generate the inverse transform
 *          Transform final image using inv_hist as a LUT. For each pixel, do the following:
 *              dest[x] = inv_histogram[src[x]];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *    The ordering of the desired_histogram must match the channel order of the image.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param desired_histogram A pointer to an array of four histograms, one each for
 *                      alpha, red, green, and blue (in that order).
 *                      These are the desired histograms for the transformed image.
 *                      Each histogram should be an array with 256 elements.
 *                      This function does not allocate storage for the histograms. You must allocate
 *                      storage for each of the four histograms, create an array and populate it with
 *                      pointers to the histograms before calling the function. The contents of the 
 *                      histograms are generally obtained from vImageHistogramCalculation_<fmt> from
 *                      another image, but need not be so.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return The following values may be returned:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src, dest or any of the desired_histogram pointers is NULL.
 * @/textblock</pre>
 */
vImage_Error 
vImageHistogramSpecification_ARGB8888( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    const vImagePixelCount *desired_histogram[4], 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2,3) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );


/*!
 * @function vImageHistogramSpecification_ARGBFFFF
 *
 * @abstract Performs a histogram specification operation on an ARGBFFFF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each channel do:
 *          Compute the histogram of the input image:
 *              For each pixel, do the following:
 *                  val = histogram_entries * (src[x] - minVal) / (maxVal - minVal);
 *                  i = clip val between 0 and histogram_entries-1
 *                  histogram[ch][i]++;
 *          Calculate normalized sum of the input histogram and the desired_histogram
 *          Generate the inverse transform
 *          Transform final image using inverse transform as a LUT. For each pixel, do the following:
 *              val = histogram_entries * (src[ch][x] - minVal) / (maxVal - minVal);
 *              i = clip val between 0 and histogram_entries-1
 *              dest[ch][x] = inv_histogram[ch][i];
 * @/textblock </pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *    The ordering of the desired_histogram must match the channel order of the image.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself, 
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information 
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param desired_histogram A pointer to an array of four histograms, one each for
 *                      alpha, red, green, and blue (in that order).                
 *                      These are the desired histograms for the transformed image.
 *                      Each histogram should be an array with histogram_entries elements..
 *                      This function does not allocate storage for the histograms. You must allocate
 *                      storage for each of the four histograms, create an array and populate it with
 *                      pointers to the histograms before calling the function. The contents of the
 *                      histograms are generally obtained from vImageHistogramCalculation_<fmt> from
 *                      another image, but need not be so.
 *
 * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the first histogram entry.
 *                      This minimum value is applied to each of the four channels separately.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the last histogram entry. 
 *                      This maximum value is applied to each of the four channels separately.
 *
 * @param flags The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return  The following error codes may be returned:
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src, dest or any of desired_histogram pointers is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock</pre>
 */
vImage_Error
vImageHistogramSpecification_ARGBFFFF( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    void *tempBuffer, 
    const vImagePixelCount *desired_histogram[4], 
    unsigned int histogram_entries, 
    Pixel_F minVal, 
    Pixel_F maxVal, 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 * @functiongroup Contrast Stretch
 * @discussion Some images do not make enough use of the light and dark ends of the spectrum.
 *             vImageContrastStretch functions widen the pixel value distribution to use a wider
 *             range of values.
 */

/*!
 * @function vImageContrastStretch_Planar8
 *
 * @abstract Stretches the contrast of a Planar8 source image.
 * @discussion This function performs the following operation:
 *   <pre>@textblock
 *      Compute the histogram of the input image;
 *      Generate LookUp table based on the histogram
 *      Transform final image using the LUT. For each pixel, do the following:
 *          dest[x] = LUT[src[x]];
 *   @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * vImageEndsInContrastStretch_Planar8 or vImageTableLookUp_Planar8 may be used instead when more control
 * over the stretch is desired.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param flags         The following flags are allowed:
 *   <pre>@textblock
 *          kvImageDoNotTile         Turns off internal multithreading. You may
 *                                   wish to do this if you have your own
 *                                   multithreading scheme to avoid having the
 *                                   two interfere with one another.
 *   @/textblock</pre>
 *
 * @return The following error codes may be returned:
 *   <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   @/textblock</pre>
 */
vImage_Error 
vImageContrastStretch_Planar8( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 * @function vImageContrastStretch_PlanarF
 *
 * @abstract Stretches the contrast of a PlanarF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Find minimum and maximum value of the input image: loVal, hiVal;
 *      scale_factor = ( maxVal - minVal ) / (float) ( hiVal - loVal );
 *      Transfer the image. For each pixel do:
 *          dest[x] = (src[x] - loVal) * scale_factor + minVal;
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * vImageEndsInContrastStretch_PlanarF or vImageInterpolatedLookupTable_PlanarF may be used instead when more control
 * over the stretch is desired.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself, 
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information 
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param histogram_entries The number of histogram entries, or bins to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be
 *                      clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the first histogram entry.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will
 *                      be clipped to this value (for the purposes of histogram calculation),
 *                      and assigned to the last histogram entry.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 * @/textblock</pre>
 *
 * @return The following error codes may be returned
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock</pre>
 */
vImage_Error 
vImageContrastStretch_PlanarF( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    void *tempBuffer, 
    unsigned int histogram_entries, 
    Pixel_F minVal, 
    Pixel_F maxVal, 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 * @function vImageContrastStretch_ARGB8888
 * @abstract Stretches the contrast of an ARGB8888 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each channel:
 *          Compute the histogram of the input image;
 *          Generate LookUp table based on the histogram
 *          Transform final image using the LUT. For each pixel, do the following:
 *              dest[x] = LUT[src[x]];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *
 * vImageEndsInContrastStretch_ARGB8888 or vImageTableLookUp_ARGB8888 may be used instead when more control
 * over the stretch is desired.
 *
 * @param src       A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest      A pointer to a vImage buffer that references the destination pixels
 *
 * @param flags     The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 * @/textblock</pre>
 */
vImage_Error 
vImageContrastStretch_ARGB8888( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 * @function vImageContrastStretch_ARGBFFFF
 *
 * @abstract Stretches the contrast of  an ARGBFFFF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *        For each channel:
 *            Find minimum and maximum value of the input image: loVal, hiVal;
 *            scale_factor = ( maxVal - minVal ) / (float) ( hiVal - loVal );
 *            Transfer the image. For each pixel do:
 *                dest[x] = (src[x] - loVal) * scale_factor + minVal;
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself, 
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information 
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the first histogram entry.
 *                      This minimum value is applied to each of the four channels separately.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the last histogram entry. 
 *                      This maximum value is applied to each of the four channels separately.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal or histogram_entries is 0 
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 * @/textblock<pre>
 */
vImage_Error 
vImageContrastStretch_ARGBFFFF( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    void *tempBuffer, 
    unsigned int histogram_entries, 
    Pixel_F minVal, 
    Pixel_F maxVal, 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );


/*!
 *  @functiongroup Ends-In Contrast Stretch
 *  @discussion Readjust the image pixel value distribution to use only some of the range of available intensities.
 */

/*!
 * @function vImageEndsInContrastStretch_Planar8
 *
 * @abstract Performs an ends-in contrast stretch operation on a Planar8 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      Compute the histogram of the input image;
 *      Generate LookUp table based on the histogram and percentage parameters
 *      Transform final image using the LookUp table. For each pixel, do the following:
 *          dest[x] = LUT[src[x]];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param percent_low   A percentage value.
 *                      The number of pixels that map to the lowest end of the histogram of the
 *                      transformed image should represent this percentage of the total pixels.
 *    
 * @param percent_high  A percentage value.
 *                      The number of pixels that map to the highest end of the histogram of the 
 *                      transformed image should represent this percentage of the total pixels.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile         Turns off internal multithreading. You may
 *                                   wish to do this if you have your own
 *                                   multithreading scheme to avoid having the
 *                                   two interfere with one another.
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   kvImageInvalidParameter         percent_low + percent_high is greater than 100.
 * @/textblock</pre>
 */
vImage_Error 
vImageEndsInContrastStretch_Planar8( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    unsigned int percent_low, 
    unsigned int percent_high, 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 * @function vImageEndsInContrastStretch_PlanarF
 *
 * @abstract Performs an ends-in contrast stretch operation on a PlanarF source image.
 * @discussion 
 * <pre>@textblock
 *      Compute the histogram of the input image;
 *      Generate LookUp table based on the histogram and percentage parameters
 *      Transform final image using the LookUp table. For each pixel, do the following:
 *          val = histogram_entries * (src[x] - minVal) / ( maxVal - minVal );
 *          i = clip val between 0 and histogram_entries-1
 *          dest[x] = LUT[i];
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself, 
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information 
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param percent_low   A percentage value.
 *                      The number of pixels that map to the lowest end of the histogram of the
 *                      transformed image should represent this percentage of the total pixels.
 *    
 * @param percent_high  A percentage value.
 *                      The number of pixels that map to the highest end of the histogram of the 
 *                      transformed image should represent this percentage of the total pixels.
 *
 * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value, the low end of the histogram.
 *                      Any pixel value less than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the first histogram entry.
 *
 * @param maxVal        A maximum pixel value, the high end of the histogram.
 *                      Any pixel value greater than this will be clipped to this value 
 *                      (for the purposes of histogram calculation), and assigned to the last histogram entry.
 *
 * @param    flags      The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal, histogram_entries is 0 or
 *                                   percent_low + percent_high is greater than 100.
 *   kvImageNullPointerArgument      src or dest pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock </pre>
 */
vImage_Error
vImageEndsInContrastStretch_PlanarF( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    void *tempBuffer, 
    unsigned int percent_low, 
    unsigned int percent_high, 
    unsigned int histogram_entries, 
    Pixel_F minVal, 
    Pixel_F maxVal, 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 * @function vImageEndsInContrastStretch_ARGB8888
 *
 * @abstract Performs an ends-in contrast stretch operation on an ARGB8888 source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each channel:
 *          Compute the histogram of the input image;
 *          Generate LookUp table based on the histogram and percentage parameters
 *          Transform final image using the LookUp table. For each pixel, do the following:
 *              dest[x] = LUT[src[x]];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *    The ordering of the percent_low and percent_high parameters match the order of the channels.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param percent_low   An array of four percentage values, one each for alpha, red, green, and blue.
 *                      The number of pixels that map to the lowest end of the histogram of the
 *                      transformed image should represent this percentage of the total pixels.
 *    
 * @param percent_high  An array of four percentage values, one each for alpha, red, green, and blue.
 *                      The number of pixels that map to the highest end of the histogram of the 
 *                      transformed image should represent this percentage of the total pixels.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 *
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   kvImageNoError                  Success!
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *   kvImageNullPointerArgument      src, dest, percent_low or percent_high pointer is NULL.
 *   kvImageInvalidParameter         Some of percent_low[i]+percent_high[i] is greater than 100.
 * @/textblock</pre>
 */
vImage_Error 
vImageEndsInContrastStretch_ARGB8888( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    const unsigned int percent_low[4], 
    const unsigned int percent_high[4], 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2,3,4) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );


/*!
 * @function vImageEndsInContrastStretch_ARGBFFFF
 *
 * @abstract Performs a histogram specification operation on an ARGBFFFF source image.
 * @discussion This function performs the following operation:
 * <pre>@textblock
 *      For each channel do:
 *          Compute the histogram of the input image;
 *          Generate LookUp table based on the histogram and percentage parameters
 *          Transform final image using the LookUp table. For each pixel, do the following:
 *              val = histogram_entries * (src[x] - minVal) / ( maxVal - minVal );
 *              i = clip val between 0 and histogram_entries-1
 *              dest[x] = LUT[i];
 * @/textblock</pre>
 *
 * This routine will work in place provided that src.data == dest.data and src.rowBytes >= dest.rowBytes.
 *    if src.rowBytes > dest.rowBytes and src.data == dest.data, the function will only work if you pass
 *    kvImageDoNotTile
 *
 * All four channel histogram functions (i.e. those that support ARGB8888 or ARGBFFFF images)
 *    work equally well on four channel images with other channel orderings such as RGBA8888 or BGRAFFFF.
 *    The ordering of the percent_low and percent_high parameters match the order of the channels.
 *
 * @param src           A pointer to a vImage_Buffer that references the source pixels
 *
 * @param dest          A pointer to a vImage buffer that references the destination pixels
 *
 * @param tempBuffer    A pointer to a temporary buffer. If you pass NULL, the function allocates the buffer,
 *                      then deallocates it before returning. Alternatively, you can allocate the buffer yourself, 
 *                      in which case you are responsible for deallocating it when you is no longer need it.
 *                      If you want to allocate the buffer yourself, see the documentation for information 
 *                      on how to determine the minimum size that you must allocate.
 *
 * @param percent_low   An array of four percentage values, one each for alpha, red, green, and blue.
 *                      The number of pixels that map to the lowest end of the histogram of the
 *                      transformed image should represent this percentage of the total pixels.
 *    
 * @param percent_high  An array of four percentage values, one each for alpha, red, green, and blue.
 *                      The number of pixels that map to the highest end of the histogram of the 
 *                      transformed image should represent this percentage of the total pixels.
 *
 * @param histogram_entries The number of histogram entries, or bins, to be used in histograms for this operation
 *
 * @param minVal        A minimum pixel value. Any pixel value less than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the first histogram entry.
 *                      This minimum value is applied to each of the four channels separately.
 *
 * @param maxVal        A maximum pixel value. Any pixel value greater than this will be clipped to this value
 *                      (for the purposes of histogram calculation), and assigned to the last histogram entry. 
 *                      This maximum value is applied to each of the four channels separately.
 *
 * @param flags         The following flags are allowed:
 * <pre>@textblock
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    If this is passed, then the size of a temp
 *                                      buffer is returned from the left hand side
 *                                      of the function and no other work is done.
 *                                      An error may still be returned in this case.
 *                                      All vImage errors are < 0.  0 may also be
 *                                      returned, indicating that the temp buffer
 *                                      size is 0 for this set of parameters on
 *                                      this device with this operating system at
 *                                      this time of day. 
 *
 *          kvImageLeaveAlphaUnchanged  Copy the alpha channel to the destination image unchanged
 * @/textblock</pre>
 * @return The following error codes may be returned:
 * <pre>@textblock
 *   >= 0                            Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *   kvImageNoError                  Success!
 *   kvImageInvalidParameter         maxVal is less than minVal, histogram_entries is 0 or 
 *                                   some of percent_low[i]+percent_high[i] is greater than 100.
 *   kvImageNullPointerArgument      src, dest, percent_low or percent_high pointer is NULL.
 *   kvImageBufferSizeMismatch       Sizes of the src and dest images do not match.
 *   kvImageMemoryAllocationError    Can not allocate memory for the buffer.
 * @/textblock</pre>
 */
vImage_Error 
vImageEndsInContrastStretch_ARGBFFFF( 
    const vImage_Buffer *src, 
    const vImage_Buffer *dest, 
    void *tempBuffer, 
    const unsigned int percent_low[4], 
    const unsigned int percent_high[4], 
    unsigned int histogram_entries, 
    Pixel_F minVal, 
    Pixel_F maxVal, 
    vImage_Flags flags ) VIMAGE_NON_NULL(1,2,4,5) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );


#ifdef __cplusplus
}
#endif

#endif

    Morphology.h                                                                                        0100644 0001750 0001750 00000237262 12566216025 043511  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/Headers                           /*!
 *  @header Morphology.h
 *  vImage_Framework
 *
 *  See vImage/vImage.h for more on how to view the headerdoc documentation for functions declared herein.
 *
 *  @copyright Copyright (c) 2002-2015 by Apple Inc. All rights reserved.
 *
 *  @discussion Morphology functions modify the shape of dark and light elements in an image.  They can enlarge
 *              light structural elements (Dilate) or make them smaller by making the darker regions larger (Erode).
 *              The filters can be used in combination fill in holes (Dilate then Erode) or remove fine structure
 *              (Erode then Dilate).  The Erode and Dilate filters can themselves have structure. For example, you
 *              can Dilate in the shape of a star, in which case single pixel bright signal (such as stars in a night 
 *              sky) assume a star shape.  Larger structure elements assume something of a star-like shape, but generally will
 *              not become fully recognizable as such until the size of the filter exceeds the size of the image
 *              structure element. A small circular filter can turn a rectangle into a larger rectangle with round corners.
 *              Many other examples abound.
 *
 *              Min is a special case for an Erode function with a rectangular kernel that contains all the same value.
 *              Max is a special case for a Dilate function with a rectangular kernel that contains all the same value.
 *              Min and Max make use of a faster algorithm that can operate at much reduced cost.
 *
 *  @ignorefuncmacro VIMAGE_NON_NULL
 */

#ifndef VIMAGE_MORPHOLOGY_H
#define VIMAGE_MORPHOLOGY_H

#include <vImage/vImage_Types.h>


#ifdef __cplusplus
extern "C" {
#endif

    
/*!
 *  @functiongroup Dilate
 *  @discussion  A dilate filter uses a shaped probe to trace a 3D surface. Imagine the kernel to define a 2D surface with
 *               the third dimension the values in the kernel.  This is then lowered down over the image, itself treated
 *               as a 3D surface. The result image is the height at which the surface makes contact with the image for 
 *               each pixel in the image. In this respect it operates like a scanning electron microscope with an adjustable
 *               probe shape. In code:
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int r = 0;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = CLIP( r );
 *                  }
 *               @/textblock </pre>
 *               The ARGB variants apply the filter to the four channels in parallel. It should be noted that the application
 *               of the filter to the image causes the structure elements in the filter to be reflected into the image, reversed 
 *               top to bottom and left to right. Also, if the center of the kernel is not 0, a general lightening of the image
 *               will occur. Some functions will run much faster if the center of the kernel is 0.
 */

/*!
 *  @function vImageDilate_Planar8
 *  @abstract Apply a dilate filter to a Planar8 image
 *  @discussion  This is a general purpose dilate filter for Planar8 data. It is optimized to handle the special cases that occur
 *               in image masks -- large contiguous regions of all 0xff or 0x0. If your filter is all 0's, you should use vImageMax_Planar8
 *               instead. 
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int r = 0;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = CLIP( r );
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image. 
 *
 *                Does not work in place.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the 
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageDilate_Planar8( const vImage_Buffer *src, const vImage_Buffer *dest, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  const unsigned char *kernel, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2,5) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );


    
/*!
 *  @function vImageDilate_PlanarF
 *  @abstract Apply a dilate filter to a PlanarF image
 *  @discussion  This is a general purpose dilate filter for Planar8 data. If your filter is all 0's, you should use vImageMax_PlanarF
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float r = -INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place. Floating-point values have host endianness.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageDilate_PlanarF( const vImage_Buffer *src, const vImage_Buffer *dest, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  const float *kernel, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2,5) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 *  @function vImageDilate_ARGB8888
 *  @abstract Apply a dilate filter to a ARGB8888 image
 *  @discussion  This is a general purpose dilate filter for ARGB8888 data. If your filter is all 0's, you should use vImageMax_ARGB8888
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int a = 0;
 *                      int r = 0;
 *                      int g = 0;
 *                      int b = 0;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
 *                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
 *                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : CLIP( a );
 *                      result[i][j][1] = CLIP( r );
 *                      result[i][j][2] = CLIP( g );
 *                      result[i][j][3] = CLIP( b );
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place. If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first. 
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a dilate filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageDilate_ARGB8888( const vImage_Buffer *src, const vImage_Buffer *dest, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  const unsigned char *kernel, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2,5) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 *  @function vImageDilate_ARGBFFFF
 *  @abstract Apply a dilate filter to a ARGBFFFF image
 *  @discussion  This is a general purpose dilate filter for ARGBFFFF data. If your filter is all 0's, you should use vImageMax_ARGBFFFF
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float a = -INFINITY;
 *                      float r = -INFINITY;
 *                      float g = -INFINITY;
 *                      float b = -INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
 *                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
 *                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the dilate filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place.  If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first. Floating-point values have host
 *                endianness.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the dilate filter.
 *                              It allows the dilate filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first float in pixel in memory) is copied to the destination
 *                                          without modification, instead of having a dilate filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageDilate_ARGBFFFF( const vImage_Buffer *src, const vImage_Buffer *dest, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  const float *kernel, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2,5) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

    
/*!
 *  @functiongroup Erode
 *  @discussion  An erode filter uses a shaped probe to trace a 3D surface. Imagine the kernel to define a 2D surface with
 *               the third dimension the values in the kernel.  This is then elevated from underneath the image, itself treated
 *               as a 3D surface. The result image is the height at which the surface makes contact with the image for
 *               each pixel in the image. 
 *
 *               In code:
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int r = MAX_CHANNEL_VALUE;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = CLIP( r );
 *                  }
 *               @/textblock </pre>
 *               The ARGB variants apply the filter to the four channels in parallel. It should be noted that the application
 *               of the filter to the image causes the structure elements in the filter to be reflected into the image, reversed
 *               top to bottom and left to right. Also, if the center of the kernel is not 0, a general lightening of the image
 *               will occur. Some functions will run much faster if the center of the kernel is 0.
 */


/*!
 *  @function vImageErode_Planar8
 *  @abstract Apply a erode filter to a Planar8 image
 *  @discussion  This is a general purpose erode filter for Planar8 data. If your filter is all 0's, you should use vImageMin_Planar8
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int r = MAX_CHANNEL_VALUE;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = CLIP( r );
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageErode_Planar8( const vImage_Buffer *src, const vImage_Buffer *dest, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  const unsigned char *kernel, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2,5) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 *  @function vImageErode_PlanarF
 *  @abstract Apply a erode filter to a PlanarF image
 *  @discussion  This is a general purpose erode filter for Planar8 data. If your filter is all 0's, you should use vImageMin_PlanarF
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float r = INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place. Floating-point values have host endianness.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageErode_PlanarF( const vImage_Buffer *src, const vImage_Buffer *dest, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  const float *kernel, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2,5) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

    
/*!
 *  @function vImageErode_ARGB8888
 *  @abstract Apply a erode filter to a ARGB8888 image
 *  @discussion  This is a general purpose erode filter for ARGB8888 data. If your filter is all 0's, you should use vImageMin_ARGB8888
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int a = 255;
 *                      int r = 255;
 *                      int g = 255;
 *                      int b = 255;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
 *                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
 *                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : CLIP( a );
 *                      result[i][j][1] = CLIP( r );
 *                      result[i][j][2] = CLIP( g );
 *                      result[i][j][3] = CLIP( b );
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place. If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a erode filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageErode_ARGB8888( const vImage_Buffer *src, const vImage_Buffer *dest, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  const unsigned char *kernel, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2,5) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

    
/*!
 *  @function vImageErode_ARGBFFFF
 *  @abstract Apply a erode filter to a ARGBFFFF image
 *  @discussion  This is a general purpose erode filter for ARGBFFFF data. If your filter is all 0's, you should use vImageMin_ARGBFFFF
 *               instead.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float a = INFINITY;
 *                      float r = INFINITY;
 *                      float g = INFINITY;
 *                      float b = INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] - k[y*kernel_width+x] )
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] - k[y*kernel_width+x] )
 *                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] - k[y*kernel_width+x] )
 *                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] - k[y*kernel_width+x] )
 *                          }
 *                      }
 *
 *                      // normalize for kernel center not 0
 *                      a += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      r += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      g += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *                      b += k[y * (kernel_height/2) * kernel_width + kernel_width/2 ];
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the erode filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place.  If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first. Floating-point values have host
 *                endianness.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the erode filter.
 *                              It allows the erode filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel               A pointer to a array of filter values of dimension kernel_height x kernel_width.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first float in pixel in memory) is copied to the destination
 *                                          without modification, instead of having a erode filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                  0                           If kvImageGetTempBufferSize was among the flags, then no work was done.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageErode_ARGBFFFF( const vImage_Buffer *src, const vImage_Buffer *dest, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  const float *kernel, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2,5) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

    
/*!
 *  @functiongroup Max
 *  @discussion     A max filter is a special case of a dilate filter, in which the filter elements are all 0. 
 *                  This allows a much, much faster algorithm to be used.
 */
    
/*!
 *  @function   vImageMax_Planar8
 *  @abstract   Apply a max filter to a Planar8 image.
 *  @discussion A max filter is a special case dilate filter, in which the filter elements are all 0. It is much faster than the normal dilate.
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int r = 0;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *                If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place, unless the kvImageDoNotTile flag is used.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed 
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of 
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread. It also
 *                                          allows the function to work in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageMax_Planar8( const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 *  @function   vImageMax_PlanarF
 *  @abstract   Apply a max filter to a PlanarF image.
 *  @discussion A max filter is a special case dilate filter, in which the filter elements are all 0. It is much faster than the normal dilate.
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float r = -INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *                If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place, unless the kvImageDoNotTile flag is used.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size 
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread. It also
 *                                          allows the function to work in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return the size of the temp buffer needed.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageMax_PlanarF( const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 *  @function vImageMax_ARGB8888
 *  @abstract Apply a max filter to a ARGB8888 image
 *  @discussion  This is a special purpose dilate filter for ARGB8888 data, for rectangular kernels with value 0. It is much faster than the normal dilate.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int a = 0;
 *                      int r = 0;
 *                      int g = 0;
 *                      int b = 0;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
 *                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
 *                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
 *                Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably 
 *                run more slowly.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread. 
 *                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a max filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageMax_ARGB8888( const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

    
/*!
 *  @function vImageMax_ARGBFFFF
 *  @abstract Apply a max filter to a ARGBFFFF image
 *  @discussion  This is a special purpose dilate filter for ARGBFFFF data, for rectangular kernels with value 0. It is much faster than the normal dilate.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float a = -INFINITY;
 *                      float r = -INFINITY;
 *                      float g = -INFINITY;
 *                      float b = -INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MAX( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
 *                              r = MAX( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
 *                              g = MAX( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
 *                              b = MAX( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the max filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
 *                Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
 *                run more slowly.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the max filter.
 *                              It allows the max filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a max filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageMax_ARGBFFFF( const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 *  @functiongroup Min
 *  @discussion     A min filter is a special case of an erode filter, in which the filter elements are all 0.
 *                  This allows a much, much faster algorithm to be used.
 */

/*!
 *  @function   vImageMin_Planar8
 *  @abstract   Apply a min filter to a Planar8 image.
 *  @discussion A min filter is a special case erode filter, in which the filter elements are all 0.  It is much faster than the normal erode.
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int r = MAX_CHANNEL_VALUE;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *                If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place, unless the kvImageDoNotTile flag is used.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread. It also
 *                                          allows the function to work in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageMin_Planar8( const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 *  @function   vImageMin_PlanarF
 *  @abstract   Apply a min filter to a PlanarF image.
 *  @discussion A min filter is a special case erode filter, in which the filter elements are all 0. It is much faster than the normal erode.
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float r = INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j] = r;
 *                  }
 *               @/textblock </pre>
 *                If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                Does not work in place, unless the kvImageDoNotTile flag is used.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread. It also
 *                                          allows the function to work in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageMin_PlanarF( const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

/*!
 *  @function vImageMin_ARGB8888
 *  @abstract Apply a min filter to a ARGB8888 image
 *  @discussion  This is a special purpose erode filter for ARGB8888 data, for rectangular kernels with value 0. It is much faster than the normal erode.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      int a = MAX_CHANNEL_VALUE;
 *                      int r = MAX_CHANNEL_VALUE;
 *                      int g = MAX_CHANNEL_VALUE;
 *                      int b = MAX_CHANNEL_VALUE;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
 *                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
 *                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
 *                Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
 *                run more slowly.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a min filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageMin_ARGB8888( const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );

    
/*!
 *  @function vImageMin_ARGBFFFF
 *  @abstract Apply a min filter to a ARGBFFFF image
 *  @discussion  This is a special purpose erode filter for ARGBFFFF data, for rectangular kernels with value 0. It is much faster than the normal erode.
 *
 *               <pre> @textblock
 *                  for each pixel result[i][j] in the image{
 *                      float a = INFINITY;
 *                      float r = INFINITY;
 *                      float g = INFINITY;
 *                      float b = INFINITY;
 *                      for( y = 0; y < kernel_height; y++ ){
 *                          for( x = 0; x < kernel_width; x++ ){
 *                              a = MIN( a, src[i+y-kernel_height/2][j+x-kernel_width/2][0] )
 *                              r = MIN( r, src[i+y-kernel_height/2][j+x-kernel_width/2][1] )
 *                              g = MIN( g, src[i+y-kernel_height/2][j+x-kernel_width/2][2] )
 *                              b = MIN( b, src[i+y-kernel_height/2][j+x-kernel_width/2][3] )
 *                          }
 *                      }
 *
 *                      // saturate overflow to representable range
 *                      result[i][j][0] = (flags & kvImageLeaveAlphaUnchanged) ? src[i][j] : a;
 *                      result[i][j][1] = r;
 *                      result[i][j][2] = g;
 *                      result[i][j][3] = b;
 *                  }
 *               @/textblock </pre>
 *
 *                If only part of the min filter of the entire image is desired, use srcOffsetToROI_X/Y to set the positioning
 *                of the result tile relative to the src image.
 *
 *                If kvImageLeaveAlphaUnchanged is not used, it works for any channel order.
 *                If kvImageLeaveAlphaUnchanged is used, then the alpha must be first.
 *                Does not work in place, unless the kvImageDoNotTile flag is used, in which case it will probably
 *                run more slowly.
 *
 *  @param src                  The input image
 *  @param dest                 A preallocated buffer to contain the result image
 *  @param tempBuffer           May be NULL. An optional temp buffer in which to store temporary computation. To find the size
 *                              of the temp buffer, call the function with the desired parameters and pass the kvImageGetTempBufferSize
 *                              flag. The size of the temp buffer will be returned from the left hand side of the function in
 *                              place of an error code, and no work will be done on the image data. A temp buffer can provide a speed
 *                              improvement, if it can be allocated once and reused. This saves a bunch of VM faults on first use of
 *                              the newly allocated temp buffer.
 *  @param srcOffsetToROI_X     An offset added to the horizontal position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              left edge of the source image.
 *  @param srcOffsetToROI_Y     An offset added to the vertical position in the src image when calculating the min filter.
 *                              It allows the min filter to operate in a tiled fashion for tiles that do not start on the
 *                              top edge of the source image.
 *  @param kernel_height        The height of the rectangular kernel. Must be an odd number.
 *  @param kernel_width         The width of the rectangular kernel. Must be an odd number.
 *  @param flags                The following flags values are allowed:
 *      <pre> @textblock
 *             kvImageNoFlags               Default operation
 *
 *             kvImageDoNotTile             Turn off internal multithreading. Useful if, for example, you are doing your own
 *                                          multithreading and just want the filter to run local to the current thread.
 *                                          kvImageDoNotTile will also allow the filter to run in place, though more slowly.
 *
 *             kvImageGetTempBufferSize     Return 0.  Do no work.
 *
 *             kvImageLeaveAlphaUnchanged   The alpha channel (first byte of pixel in memory) is copied to the destination
 *                                          without modification, instead of having a min filter applied to it.
 *      @/textblock </pre>
 *  @return The following error codes may result:
 *      <pre> @textblock
 *             kvImageNoError                   Success.
 *                 >=0                          If kvImageGetTempBufferSize was among the flags, then no work was done.
 *                                              Instead, the size of the temp buffer needed is returned.
 *
 *             kvImageRoiLargerThanInputBuffer  dest->width and dest->height must be less than or equal to the corresponding
 *                                              dimensions in the src image
 *
 *             kvImageInvalidKernelSize         The kernel_height and kernel_width must not be evenly divisible by 2.
 *      @/textblock </pre>
 */
vImage_Error vImageMin_ARGBFFFF( const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y,  vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 );


#ifdef __cplusplus
}
#endif

#endif /* MORPHOLOGY_H */
                                                                                                                                                                                                                                                                                                                                              Transform.h                                                                                         0100644 0001750 0001750 00000250103 12566216025 043312  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/Headers                           /*!
 *  @header Transform.h
 *  vImage Framework
 *
 *  See vImage/vImage.h for more on how to better view the headerdoc documentation for functions declared herein.
 *
 *  @copyright Copyright (c) 2003-2015 by Apple Inc. All rights reserved.
 *
 *  @discussion   Transform.h defines a number of interfaces that do linear and nonlinear operations
 *                to images.  Matrix multiply operations treat each pixel as a short vector and 
 *                multiply the vector by a matrix. Typically these are used to do colorspace conversion
 *                and color twisting.  There are a series of gamma functions that apply a power function
 *                to an image. The power operation is C2 symmetric around the origin such that negative values
 *                are not NaN (unlike pow(-x, y)), but instead -pow(|x|, y) for negative x). 
 *                In addition a series of polynomial and rational evaluators are available. Many complex
 *                functions can be approximated as a polynomial or rational and evaluated more 
 *                cheaply that way. Finally there are single and multi-dimensional interpolated lookup
 *                tables, also commonly used in colorspace conversion.
 *
 *  @ignorefuncmacro VIMAGE_NON_NULL
 */

#ifndef VIMAGE_TRANSFORM_H
#define VIMAGE_TRANSFORM_H	

#include <vImage/vImage_Types.h>

#ifdef __cplusplus
extern "C" {
#endif


/*!
 *  @functiongroup Image Matrix multiplication
 */

/*
 * vImageMatrixMultiply_Planar16S
 *
 * Transform M source planes to N destination planes by multiplying the
 * M x N transformation matrix by the source planes.  A pre-bias may
 * optionally be added to the source planes before the transformation.  A 
 * post-bias may optionally be added to the resulting destination planes. As 
 * a final step the destination planes are divided by a given divisor. 
 *
 * if (pre_bias)
 *   { bA, bR, bG, ... } = { A + pre_bias[0], R + pre_bias[1],
 *                           G + pre_bias[2], ... }
 * else 
 *   { bA, bR, bG, ... } = { A, R, G, ... }
 *
 *
 *                                            { a00  a01  a02  ... }
 * { A', R', G', ...} = { bA, bR, bG, ... } * { a10  a11  a12  ... }
 *                                            { a20  a21  a22  ... }
 *                                            { ...  ...  ...  ... }
 *
 * if (post_bias)
 *    { A', R', G', ... } += { post_bias[0], post_bias[1], post_bias[2], ... }
 * else // correct value for normal rounding: divisor/2
 *    { A', R', G', ... } += { divisor/2, divisor/2, divisor/2, ... }
 *
 * { A', R', G', ... } /= divisor
 *
 * where the values are:
 * { A', R', ... }	Resulting destination planes (dests).  For a concrete 
 *					example of the multiply step for one plane:
 *					A' = bA * a00 + bR * a10 + bG * a20 + ... * ...
 *
 * { A, R, ... }    Source planes (srcs).
 *
 * { bA, bR, ... }	Pre-biased source planes. (for demonstration only, never
 *					actually exists)
 *
 * a00, a01, ...    Elements in the transformation matrix (matrix).
 *
 * pre_bias         Pre-bias values corresponding to the source channels.
 *					Value is zero when NULL.
 *
 * post_bias 		Post-bias values corresponding to the destination channels.
 *					When NULL, the correct value for normal rounding if used,
 *					which is divisor/2.
 *
 * divisor			Divisor to normalize the destination planes.	
 *
 * Operands:
 * ---------
 * srcs				A pointer to an array of vImage_Buffer pointers that
 *					reference the source planes. This array must contain
 *					src_planes number of vImage_Buffer pointers.
 *
 * dests			A pointer to an array of vImage_Buffer pointers that 
 *					reference where to write the destination planes. Only 
 *					the image data pointed to by each vImage_Buffer is modified
 *					(i.e. dests[0]->data), everything else remains unchanged.
 *					This array must contain dest_planes number of vImage_Buffer
 *					pointers.
 *
 * src_planes		The number of source planes.  Must be less than 256.
 *
 * dest_planes		The number of destination planes.  Must be less than 256.
 *                         
 * matrix			The row major transformation matrix with dest_planes number 
 *					of columns and src_planes number of rows.  Be aware that if
 *					any column of this matrix sums to a value larger than 
 *					+-65538 this function may silently overflow.
 *
 * divisor			Division by this value occurs as the last step, in effect
 *					normalizing the output planes.
 *
 * pre_bias			An optional array of length src_planes consisting of int16_t
 *					values. Each value will be added to the corresponding
 *					source plane in srcs.  Pass NULL for no pre_bias.
 *
 * post_bias		An optional array of length dest_planes consisting of 
 *					int16_t values.  Each value will be added to the 
 *					corresponding destination planes in dests.  The post_bias
 *					is added before any clipping, rounding or division.  Pass 
 *					NULL the correct value for for normal rounding (divisor/2).
 *
 * flags			The following flags are allowed:
 *
 *		kvImageDoNotTile			Turns off internal multithreading. You may
 * 									wish to do this if you have your own
 *									multithreading scheme to avoid having the
 *									two interfere with one another.
 *
 * Return Value:
 * -------------
 * kvImageInvalidKernelSize			Either src_planes or dest_planes is 0.
 * kvImageBufferSizeMismatch		All buffers in dests must have the same
 *									width and height.
 * kvImageROILargerThanSourceBuffer The destination buffer size (width, or
 *									height) is larger than the source buffer.
 * kvImageUnknownFlagsBit			Unexpected flag was passed.		
 * kvImageNoError					Success!
 *
 *
 * Comments:
 * ---------
 * Be aware that 32-bit signed accumulators are used in this operation with no
 * overflow protection. To avoid the possibility of overflow, limit the sum
 * of any column in the transformation matrix to values less than +-65536.
 * 
 * The 32-bit accumulated results out of 16-bit range (+-32767) will be subject  
 * clipping before writing to the destination buffer.
 *
 * This routine will work in place provided all of the following are true:
 * src.data == dest.data
 * src.rowBytes == dest.rowBytes
 * kvImageDoNotTile is passed
 *
 *  Some matrix based color transforms, such as that obtained using kColorSyncConversionMatrix are defined differently.
 *
 *      ColorSync:      p' = M1 * p                  M1 = colorsync matrix,  p = input pixel as column vector, p' = output pixel as column vector
 *         vImage:      p'T = pT * M2                M2 = vImage matrix,T indicates transpose -- vImage pixels are row vectors
 *
 *  Given that (A*B)T = BT*AT, it can be shown that M2 = M1T. So, to use the alternative definition here, you need to transpose the matrix.
 *
 * Example:
 * --------
 * To convert RGB to YUV, one might use the following formula:
 *
 *          Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16
 *          U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128
 *          V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128
 *
 *      This translates to a matrix that looks like this:
 *
 *               66     -38     112
 *              129     -74     -94
 *               25     112     -18
 *
 *		Pass 256 as the divisor to handle the >> 8 operation.  The post_bias
 *		argument can handle the addition of { 16, 128, 128 }, however because
 *		this function performs the division last, this array must be scaled by
 *		the divisor, yielding a post_bias of:
 *			post_bias = { 16*divisor + divisor/2, 128*divisor + divisor/2, 
 *									128*divisor + divisor/2}
 *			post bias = { 4224, 32896, 32896 }
 */
    
vImage_Error vImageMatrixMultiply_Planar16S( const vImage_Buffer *srcs[],
                                             const vImage_Buffer *dests[],	
                                             uint32_t    	      src_planes,
                                             uint32_t    	      dest_planes,
                                             const int16_t    	  matrix[],
                                             int32_t              divisor,
                                             const int16_t	     *pre_bias,	
                                             const int32_t	     *post_bias,
                                             vImage_Flags 	      flags )
    										 VIMAGE_NON_NULL(1,2,5)
    										 __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    
/*
 * vImageMatrixMultiply_*
 *
 *	Multiply the M channels in the src buffers (A,R,G...) by a NxM matrix (a##) to yield N channels in the dest buffer(s)
 *	For ARGB interleaved functions, both M and N must be 4. The pre_bias (ca, cr, cg...) is added to the M input channels
 *	before the matrix is applied. The post_bias (ka, kr, kg...)  is added afterward. 
 *
 *                                                             { a00  a10  a20  ... }
 *		{ A', R', G' ...} = { A + ca, R + cr, G + cg, ... } *  { a01  a11  a21  ... } + { ka, kr, kg, ....}
 *                                                             { a02  a12  a22  ... }
 *                                                             { ...  ...  ...  ... }
 *
 *		A', R', G', ... = result channels stored into dests
 *		A, R, G, ... = input channels from srcs
 *		ca, cr, cg, ... = pre_bias elements corresponding to the input src channels, or zero if pre_bias is NULL
 *		a00, a11, a12, ... = elmenets from the matrix[]
 *		ka, kr, kg, ... = post_bias elements corresponding to the destination dest channels, or zero if post_bias is NULL
 *
 *  For integer code, there is an additional division operation that happens at the end, in effect normalizing integer matrices. 
 *  The post-bias is added before any clipping, rounding or division. If you pass NULL for the post-bias, the correct value for 
 *  normal rounding will be used:
 *
 *      integer:            divisor/2
 *      floating point:     0.0f 
 *
 *  Be aware that 32 bit signed accumulators are used for integer code. If the sum over any matrix column is larger 
 *  than +- 2**23, then overflow may occur. Generally speaking this will not happen because the matrix elements are 
 *  16 bit integers, so one would need more than 256 source buffers before it is possible to encounter trouble.
 *
 *  As an example, to convert RGB to YUV, one might use the following formula:
 *
 *          Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16
 *          U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128
 *          V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128
 *
 *  This translates to a matrix that looks like this:
 *
 *               66     -38     112
 *              129     -74     -94
 *               25     112     -18
 *
 *  There is also the >>8 operation and the extra terms to be dealt with. For integer data, you would use a divisor of 
 *  256 to account for the >>8 operation. The divisor is applied last after all other multiplications and additions. 
 *  (For floating point, there is no divisor. Just divide the whole matrix by the divisor if one is needed.) Use the
 *  post bias to handle the +128 and {+16, +128, +128} terms. Since the second set happen after the divisor in the 
 *  formula above, but our post_bias is applied before the divide, you'll need to multiply those biases by the divisor.  
 *  This will give a post_bias of:
 *
 *              {  16 * 256 + 128, 128 * 256 + 128, 128 * 256 + 128 } = { 4224, 32896, 32896 }
 *
 *  Finally, if there is an alpha component, such that you wish to convert ARGB to AYUV, leaving the alpha component
 *  unchanged then add another row and column:
 *
 *      matrix =    divisor      0       0       0
 *                      0        66     -38     112 
 *                      0       129     -74     -94 
 *                      0        25     112     -18 
 *
 *      post_bias =     { divisor/2, 4224, 32896, 32896 }
 *      divisor =       256
 *
 *  Integer results out of range of 0...255 will be subject to saturated clipping before writing to the destination buffer.
 *
 *
 *	Programming Note:
 *		The pre-bias is provided as a convenience. The pre-bias can be converted to a post bias by 
 *	multiplying it by the matrix, which is what we do behind the scenes. Pass NULL for the pre-bias if
 *	you don't want a prebias added in.
 *	
 *	These functions work in place as long as overlapping buffers overlap exactly. Buffers that partially overlap
 *	will yield undefined results. Destination buffers will be stored to in the order they appear in the dests array.
 *	The buffers all need to be the same size. They can have different rowBytes. 	
 *
 *  In cases where the number of src and dest buffers match, these functions will work in place. 
 *  The source and destination buffers may all be different sizes and have different sized rowbytes. The source buffers must 
 *  be at least as large as the dest buffers. In cases where the source buffer is larger than a dest buffer, the portion of the 
 *  source buffer that overlaps the destination buffer when their top left corners are aligned will be used.  
 *
 *  Some matrix based color transforms, such as that obtained using kColorSyncConversionMatrix are defined differently.
 *
 *      ColorSync:      p' = M1 * p                  M1 = colorsync matrix,  p = input pixel as column vector, p' = output pixel as column vector
 *         vImage:      p'T = pT * M2                M2 = vImage matrix, T indicates transpose -- vImage pixels are row vectors
 *
 *  Given that (A*B)T = BT*AT, we find that M2 = M1T. So, to use the alternatively defined matrix here, you need to transpose the matrix 
 *  before passing it to vImage.
 */

vImage_Error vImageMatrixMultiply_Planar8(          const vImage_Buffer *srcs[],	//A set of src_planes as a const array of pointers to vImage_Buffer structs that reference vImage_Buffers.
                                                    const vImage_Buffer *dests[],	//A set of src_planes as a const array of pointers to vImage_Buffer structs that reference vImage_Buffers.
                                                    uint32_t    	src_planes,
                                                    uint32_t    	dest_planes,
                                                    const int16_t    	matrix[],
                                                    int32_t             divisor,
                                                    const int16_t	*pre_bias,	//A packed array of src_plane int16_t values. NULL is okay
                                                    const int32_t	*post_bias,	//A packed array of dest_plane int32_t values. NULL is okay
                                                    vImage_Flags 	flags ) VIMAGE_NON_NULL(1,2,5) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );

vImage_Error vImageMatrixMultiply_PlanarF(          const vImage_Buffer *srcs[],        //A set of src_planes as a const array of pointers to vImage_Buffer structs that reference vImage_Buffers.
                                                    const vImage_Buffer *dests[],       //A set of src_planes as a const array of pointers to vImage_Buffer structs that reference vImage_Buffers.
                                                    uint32_t    	src_planes,
                                                    uint32_t    	dest_planes,
                                                    const float		matrix[],		
                                                    const float 	*pre_bias,	//A packed array of float values. NULL is okay
                                                    const float 	*post_bias,	//A packed array of float values. NULL is okay
                                                    vImage_Flags flags ) VIMAGE_NON_NULL(1,2,5) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );

/*
 * vImageMatrixMultiply_ARGB8888 will also work for other channel orders such as RGBA8888.  The ordering of terms in the matrix, pre_bias and 
 * post_bias should be adjusted to compensate.
 */
vImage_Error vImageMatrixMultiply_ARGB8888(         const vImage_Buffer *src,
                                                    const vImage_Buffer *dest,
                                                    const int16_t	matrix[4*4],
                                                    int32_t             divisor,
                                                    const int16_t	*pre_bias,	//Must be an array of 4 int16_t's. NULL is okay. 
                                                    const int32_t 	*post_bias,	//Must be an array of 4 int32_t's. NULL is okay. 
                                                    vImage_Flags 	flags ) VIMAGE_NON_NULL(1,2,3) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );

/*
 * vImageMatrixMultiply_ARGBFFFF will also work for other channel orders such as RGBAFFFF.  The ordering of terms in the matrix, pre_bias and 
 * post_bias should be adjusted to compensate.
 */
vImage_Error vImageMatrixMultiply_ARGBFFFF(         const vImage_Buffer *src,
                                                    const vImage_Buffer *dest,
                                                    const float		matrix[4*4],
                                                    const float		*pre_bias,	//Must be an array of 4 floats. NULL is okay. 
                                                    const float		*post_bias,	//Must be an array of 4 floats. NULL is okay. 
                                                    vImage_Flags 	flags ) VIMAGE_NON_NULL(1,2,3) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );

/*!
 * @function vImageMatrixMultiply_ARGB8888ToPlanar8
 * @abstract apply a 1d matrix to a four channel, 8-bit per component image and get a 1-channel 8-bit image as a result
 * @discussion vImageMatrixMultiply_ARGB8888ToPlanar8 is like vImageMatrixMultiply_ARGB8888, except that it produces
 *             only a single channel of output. It is intended to produce grayscale images from four channel content,
 *             but can be used for other purposes.  
 *  <pre>@textblock
 *                  for each pixel[y][x] in image:
 *                      int32_t p = (pixel[y][x][0] + pre_bias[0]) * matrix[0]  +
 *                                  (pixel[y][x][1] + pre_bias[1]) * matrix[1]  +
 *                                  (pixel[y][x][2] + pre_bias[2]) * matrix[2]  +
 *                                  (pixel[y][x][3] + pre_bias[3]) * matrix[3];
 *                      result[y][x] = CLAMP( ( p + post_bias ) / divisor, 0, 0xff);
 *  @/textblock </pre>
 *             If you intend to just extract a single channel without modification (e.g. alpha), please see 
 *             vImageExtractChannel_ARGB8888.  This function will work in place, provided that src->data = dest->data
 *             and src->rowBytes = dest->rowBytes.  
 *
 *  @param      src         A four channel, 8-bit per component input buffer. It does not have to be ARGB.
 *
 *  @param      dest        A preallocated buffer to receive the 8-bit per component monochromatic result.
 *
 *  @param      matrix      The 1D matrix by which to multiply each pixel.
 *
 *  @param      divisor     Used to renormalize the image after scaling by the matrix. Typically this is the 
 *                          sum over the matrix. If 0, 1 will be used. A faster implementation may be available
 *                          if the divisor is an integer power of 2.
 *
 *  @param      pre_bias    A set of values used to correct the input image so that 0 is encoded as 0.  For example,
 *                          if the input image is 444 AYCbCr video range, then {0, -16, -128, -128} could be used here.
 *                          If NULL, {0,0,0,0} will be used.
 *  
 *  @param      post_bias   A value added to the sum at the end to provide both for rounding control and for
 *                          allowing for a bias to be encoded into the image format.  Typically, this is just
 *                          divisor/2 to allow for round to nearest behavior. However, other values may be appropriate
 *                          if the encoding for 0.0 is not 0.  For example, for video range luminance, you might
 *                          pass 16 * divisor + divisor/2. 
 *
 *  @param      flags       The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags                      Default operation
 *          kvImageDoNotTile                    Disable internal multithreading.
 *          kvImageGetTempBufferSize            return 0, do no work
 *          kvImagePrintDiagnosticsToConsole    Might print more helpful diagnostic info to the console in the event of an
 *                                              error.
 *      @/textblock</pre>
 *
 *  @return     The following error codes may be returned:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *          0                                   If kvImageGetTempBufferSize was passed, 0 is returned and no work is done on the image.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and height must be less than or equal to the corresponding dimension of src.
 *
 *          kvImageUnknownFlagsBit              A flag not from the above list of flags was passed in.
 *      @/textblock </pre>
 */
vImage_Error vImageMatrixMultiply_ARGB8888ToPlanar8( const vImage_Buffer *src,
                                                     const vImage_Buffer *dest,
                                                     const int16_t       matrix[4],
                                                     int32_t             divisor,
                                                     const int16_t       pre_bias[4],
                                                     int32_t             post_bias,
                                                     vImage_Flags        flags )
                                                     VIMAGE_NON_NULL(1,2,3)
                                                     __OSX_AVAILABLE_STARTING( __MAC_10_11, __IPHONE_9_0 );

    
/*!
 * @function vImageMatrixMultiply_ARGBFFFFToPlanarF
 * @abstract apply a 1d matrix to a four channel, float per component image and get a 1-channel float image as a result
 * @discussion vImageMatrixMultiply_ARGBFFFFToPlanarF is like vImageMatrixMultiply_ARGBFFFF, except that it produces
 *             only a single channel of output. It is intended to produce grayscale images from four channel content,
 *             but can be used for other purposes.
 *  <pre>@textblock
 *                  for each pixel[y][x] in image:
 *                      float p =   (pixel[y][x][0] + pre_bias[0]) * matrix[0]  +
 *                                  (pixel[y][x][1] + pre_bias[1]) * matrix[1]  +
 *                                  (pixel[y][x][2] + pre_bias[2]) * matrix[2]  +
 *                                  (pixel[y][x][3] + pre_bias[3]) * matrix[3];
 *                      result[y][x] = p + post_bias;
 *  @/textblock </pre>
 *             vImage reserves the right to reorder computation from the above formulation to improve performance.
 *             If you intend to just extract a single channel without modification (e.g. alpha), please see
 *             vImageExtractChannel_ARGBFFFF. This function will work in place, provided that src->data = dest->data
 *             and src->rowBytes = dest->rowBytes.
 *
 *  @param      src         A four channel, floating-point input buffer. It does not have to be ARGB.
 *
 *  @param      dest        A preallocated buffer to receive the floating-point monochromatic result.
 *
 *  @param      matrix      The 1D matrix by which to multiply each pixel.
 *
 *  @param      pre_bias    A set of values used to correct the input image so that 0 is encoded as 0.
 *                          If NULL, {0,0,0,0} will be used.
*
 *  @param      post_bias   A value added to the sum at the end to provide both for rounding control and for
 *                          allowing for a bias to be encoded into the image format.  Typically, this is just
 *                          zero.
 *
 *  @param      flags       The following flags are allowed:
 *      <pre> @textblock
 *          kvImageNoFlags                      Default operation
 *          kvImageDoNotTile                    Disable internal multithreading.
 *          kvImageGetTempBufferSize            return 0, do no work
 *          kvImagePrintDiagnosticsToConsole    Might print more helpful diagnostic info to the console in the event of an
 *                                              error.
 *      @/textblock</pre>
 *
 *  @return     The following error codes may be returned:
 *      <pre> @textblock
 *          kvImageNoError                      Success.
 *          0                                   If kvImageGetTempBufferSize was passed, 0 is returned and no work is done on the image.
 *
 *          kvImageRoiLargerThanInputBuffer     dest->width and height must be less than or equal to the corresponding dimension of src.
 *
 *          kvImageUnknownFlagsBit              A flag not from the above list of flags was passed in.
 *      @/textblock </pre>
 */
vImage_Error vImageMatrixMultiply_ARGBFFFFToPlanarF( const vImage_Buffer *src,
                                                     const vImage_Buffer *dest,
                                                     const float         matrix[4],
                                                     const float         pre_bias[4],
                                                     float               post_bias,
                                                     vImage_Flags        flags )
                                                     VIMAGE_NON_NULL(1,2,3)
                                                     __OSX_AVAILABLE_STARTING( __MAC_10_11, __IPHONE_9_0 );

    
/*
 * The gamma calculation is at the simplest level:
 *
 *      if( value < 0) 
 *          sign = -1.0f;
 *      else
 *          sign = 1.0f;
 *
 *      result = pow( fabs( value ), gamma ) * sign;
 *
 *  i.e. negative values are treated as if they are positive, and the sign restored at the end.
 *
 * This provides for symmetric gamma curves about 0, and also solves the problem of NaN results from
 * pow( negative number, non-integer). 
 *
 * The results are available in two varieties, full and half precision. The full precision version covers
 * all pixel values and all exponents and delivers a result within a few ULPs of the IEEE-754 correct powf().
 *       
 * The half precision variant provides a precision of 1/4096: 
 *
 *          fabs((correct result - result provided)) < 1/4096
 *
 * Half-precision is intended to be used with data that will ultimately be converted to 8-bit integer data. 
 * As such, the faster half precision variants only work for floating point pixel values in the range 0.0 ... 1.0.
 * Out of range pixel values will clamp appropriately to 0.0 or 1.0 before the calculation is performed. 
 *
 * In addition, there are restrictions on range on the exponent. In general, for best performance, it should be near 1.0,
 * though a faster path exists out to +-12. If the exponent is outside the prescribed range the code will return a full 
 * precision gamma instead. (In MacOS X.4.3 and earlier, all exponents fall back on the full precision version. )  
 *
 * Half precision calculations that conform to these restrictions are likely to be much faster 
 * than the full precision gamma. Use kvImageGamma_UseGammaValue and kvImageGamma_UseGammaValue_half_precision 
 * to control whether you get a full or half precision result. kvImageGamma_UseGammaValue will never use a 
 * half-precision calculation.
 *
 * There are some additional gamma types for specific gamma curves. These are precise to 1/4096, share the same
 * restrictions as above for the half precision gamma, but execute in less time. (These fixed exponent gamma curves
 * are present in MacOS X.4, unless otherwise noted below.)
 *
 * vImageGamma_PlanarF and vImageGamma_PlanarFToPlanar8 will work in place, provided that the following are true:
 *      src->data == dest->data
 *      src->rowBytes >= dest->rowBytes
 *      if( src->rowBytes > dest->rowBytes ) kvImageDoNotTile must be passed in the flags parameter
 *
 * vImageGamma_Planar8ToPlanarF will NOT work in place. 
 *
 *  For the func
 *
 * These functions will also work for multichannel data, such as RGBAFFFF buffers by adjusting the width of the buffer to 
 * reflect the additional channels. Note that this will cause the alpha channel if there is one to become gamma corrected.
 */

/*
 * constants for use in the gamma_type
 */
enum
{
    kvImageGamma_UseGammaValue                  =   0,          /* __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
    kvImageGamma_UseGammaValue_half_precision   =   1,          /* __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
    kvImageGamma_5_over_9_half_precision        =   2,          /* gamma = 5/9. (Gamma 1/1.8) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
    kvImageGamma_9_over_5_half_precision        =   3,          /* gamma = 9/5. (Gamma 1.8)  __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
    kvImageGamma_5_over_11_half_precision       =   4,          /* gamma = 5/11. (Gamma 1/2.2) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
    kvImageGamma_11_over_5_half_precision       =   5,          /* gamma = 11/5. (Gamma 2.2) On exit, gamma = 5/11. __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
    kvImageGamma_sRGB_forward_half_precision    =   6,          /* gamma = sRGB standard 2.2. (like 2.2 but offset a bit and with a linear segment: x<0.03928?x/12.92:pow((x+0.055)/1.055,2.4) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
    kvImageGamma_sRGB_reverse_half_precision    =   7,          /* gamma = sRGB standard 1/2.2. (like 2.2 but offset a bit and with a linear segment: x<0.00304?12.92*x:1.055pow(x,1/2.4)-0.055) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
    kvImageGamma_11_over_9_half_precision       =   8,          /* gamma = 11/9 (Gamma (11/5)/(9/5)) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
    kvImageGamma_9_over_11_half_precision       =   9,          /* gamma = 9/11 (Gamma (9/5)/(11/5)) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
	kvImageGamma_BT709_forward_half_precision	=	10,			/* gamma = ITU-R BT.709 standard (like sRGB above but without the 1.125 viewing gamma for computer graphics: x<0.081?x/4.5:pow((x+0.099)/1.099, 1/0.45) ) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
	kvImageGamma_BT709_reverse_half_precision	=	11			/* gamma = ITU-R BT.709 standard *reverse* (like sRGB 1/2.2 above but without the 1.125 viewing gamma for computer graphics: x<0.018?4.5*x:1.099*pow(x,0.45)-0.099) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 ) */
};

GammaFunction   vImageCreateGammaFunction(          float           gamma,
                                                    int             gamma_type,
                                                    vImage_Flags    flags )             __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );

void            vImageDestroyGammaFunction( GammaFunction f )                           __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );

/* There is a 8 bit lookup table in Conversion.h, if you are looking for a 8bit to 8bit gamma function. */
vImage_Error    vImageGamma_Planar8toPlanarF(       const vImage_Buffer *src,
                                                    const vImage_Buffer *dest,           
                                                    const GammaFunction gamma,
                                                    vImage_Flags        flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );
                                                    
vImage_Error    vImageGamma_PlanarFtoPlanar8(       const vImage_Buffer *src,           
                                                    const vImage_Buffer *dest,          
                                                    const GammaFunction gamma,
                                                    vImage_Flags        flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );
                                                    
vImage_Error    vImageGamma_PlanarF(                const vImage_Buffer *src,           
                                                    const vImage_Buffer *dest,          
                                                    const GammaFunction gamma,
                                                    vImage_Flags        flags ) VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );
                                        
/* vImagePiecewiseGamma_Planar8
 * vImagePiecewiseGamma_Planar8toPlanar16Q12
 * vImagePiecewiseGamma_Planar8toPlanarF
 * vImagePiecewiseGamma_Planar16Q12
 * vImagePiecewiseGamma_Planar16Q12toPlanar8
 * vImagePiecewiseGamma_PlanarF
 * vImagePiecewiseGamma_PlanarFtoPlanar8
 *
 * The piecewise gamma calculation combines a linear and an exponential (gamma)
 * curve on two regions of the input interval, separated by a user-supplied
 * boundary value.  When the input is greater or equal to the boundary value,
 * the gamma curve is used to generate the output. Otherwise, the linear curve
 * is used.
 *
 * The operation can be described as follows:
 *
 *  For each source pixel value x:
 *    sign = x < 0 ? -1 : 1
 *    absx = x < 0 ? -x : x
 *    if absx < cutoff:
 *      output pixel value = sign * (linearCoeffs[0]*absx + linearCoeffs[1])
 *    else:
 *      y = exponentialCoeffs[0]*absx + exponentialCoeffs[1]
 *      output pixel value = sign * (pow(y, gamma) + exponentialCoeffs[2])
 *
 * If y is negative, the result is undefined.
 *
 * If the source format is Planar8, we multiply by 1/255.0 to get the "input"
 * value used in the expression above; if the destination format is Planar8,
 * we clamp the output value to [0, 1.0], multiply by 255.0 and round to
 * nearest to get the value stored to the destination buffer.
 *
 * If the source format is Planar16Q12, we multiply by 1/4096.0 to get the
 * input value; we clamp to [-8, 8), multiply by 4096.0, and round to nearest
 * to get the stored to the destination buffer.
 *
 * Regardless of the input or output pixel type, the parameters describing the
 * piecewise gamma function are 32-bit floats, with the single exception of the
 * boundary parameter.
 *
 *  Operands:
 *  ---------
 *      src                 A pointer to a vImage_Buffer that references the source pixels
 *
 *      dest                A pointer to a vImage_Buffer that references the destination pixels
 *
 *      exponentialCoeffs   An array of three floating point coefficients for the gamma curve
 *
 *      gamma               The exponent of a power function for calculating gamma correction
 *
 *      linearCoeffs        An array of two floating point coefficients for the linear curve
 *
 *      boundary            The boundary value for switching from linear to gamma curve
 *
 *      flags               The following flags are allowed:
 *
 *          kvImageDoNotTile            Turns off internal multithreading. You may
 *                                      wish to do this if you have your own
 *                                      multithreading scheme to avoid having the
 *                                      two interfere with one another.
 *
 *          kvImageGetTempBufferSize    Does no work and returns zero.
 *
 *  Return Value:
 *  -------------
 *      kvImageNoError                  Success!
 *      kvImageNullPointerArgument      src, dest, exponentialCoeffs, or linearCoeffs pointer is NULL.
 *      kvImageBufferSizeMismatch       The destination buffer size (width or
 *                                      height) is larger than the source buffer.
 *      kvImageUnknownFlagsBit          An unknown or invalid flag was passed. See flags above.
 *
 *  The variants of this routine that have source and dest pixel types of the
 *  same size (Planar8, Planar16Q12, and PlanarF) operate in place so long as
 *  the source and dest image scanlines overlap exactly.  The other variants
 *  (Planar8toPlanar16Q12, Planar8toPlanarF, etc) do not support in-place
 *  operation.
 */

vImage_Error vImagePiecewiseGamma_Planar8(const vImage_Buffer *src,
                                          const vImage_Buffer *dest,
                                          const float         exponentialCoeffs[3],
                                          const float         gamma,
                                          const float         linearCoeffs[2],
                                          const Pixel_8       boundary,
                                          vImage_Flags        flags) VIMAGE_NON_NULL(1,2,3,5) __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    
vImage_Error vImagePiecewiseGamma_Planar8toPlanar16Q12(const vImage_Buffer *src,
                                                       const vImage_Buffer *dest,
                                                       const float         exponentialCoeffs[3],
                                                       const float         gamma,
                                                       const float         linearCoeffs[2],
                                                       const Pixel_8       boundary,
                                                       vImage_Flags        flags) VIMAGE_NON_NULL(1,2,3,5) __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    
vImage_Error vImagePiecewiseGamma_Planar16Q12(const vImage_Buffer *src,
                                              const vImage_Buffer *dest,
                                              const float         exponentialCoeffs[3],
                                              const float         gamma,
                                              const float         linearCoeffs[2],
                                              const Pixel_16S     boundary,
                                              vImage_Flags        flags) VIMAGE_NON_NULL(1,2,3,5) __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    
vImage_Error vImagePiecewiseGamma_Planar16Q12toPlanar8(const vImage_Buffer *src,
                                                       const vImage_Buffer *dest,
                                                       const float         exponentialCoeffs[3],
                                                       const float         gamma,
                                                       const float         linearCoeffs[2],
                                                       const Pixel_16S     boundary,
                                                       vImage_Flags        flags) VIMAGE_NON_NULL(1,2,3,5) __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    
vImage_Error vImagePiecewiseGamma_Planar8toPlanarF(const vImage_Buffer *src,
                                                   const vImage_Buffer *dest,
                                                   const float         exponentialCoeffs[3],
                                                   const float         gamma,
                                                   const float         linearCoeffs[2],
                                                   const Pixel_8       boundary,
                                                   vImage_Flags        flags) VIMAGE_NON_NULL(1,2,3,5) __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );

vImage_Error vImagePiecewiseGamma_PlanarF(const vImage_Buffer *src,
                                          const vImage_Buffer *dest,
                                          const float         exponentialCoeffs[3],
                                          const float         gamma,
                                          const float         linearCoeffs[2],
                                          const float         boundary,
                                          vImage_Flags        flags) VIMAGE_NON_NULL(1,2,3,5) __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    
vImage_Error vImagePiecewiseGamma_PlanarFtoPlanar8(const vImage_Buffer *src,
                                                   const vImage_Buffer *dest,
                                                   const float         exponentialCoeffs[3],
                                                   const float         gamma,
                                                   const float         linearCoeffs[2],
                                                   const float         boundary,
                                                   vImage_Flags        flags) VIMAGE_NON_NULL(1,2,3,5) __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );

/*
 *  vImagePiecewisePolynomial*
 *
 *  Apply one or more polynomials to the input image to give the output image.  
 *
 *  vImagePiecewisePolynomial_Planar8toPlanarF uses 8 bit data on input and produces floating point data.
 *  vImagePiecewisePolynomial_PlanarFtoPlanar8 uses floating point data on input and produces 8-bit data with saturated clamping at 0 and 255 to prevent modulo overflow.
 *  vImagePiecewisePolynomial_PlanarF floating point data on both input and output.
 *  vImageTableLookUp_Planar8 uses 8 bit data and produces 8 bit data. In certain cases, the matrix multiply function may also be appropriate.
 *
 *  No other arithmetic is done. If you wish a /255 or *255 operation to be done as part of the calculation, you must incorporate that into your polynomial.
 *
 *  The arrangement of the polynomials is defined as follows:
 *      Let there be N polynomials that each cover part of the single precision floating point range that are arranged in order of area of influence from -Infinity to Infinity.
 *      The ith polynomial shall operate on the set of input pixel values that fall in the range:  
 *
 *          boundary[i] <= pixel_value < boundary[i+1]. 
 *
 *     for which:
 *
 *          boundary[0] = smallest value fit by the polynomial. Input pixels smaller than this will be clamped to this value before the calculation is done. Use -Inf for no lower limit.
 *          boundary[N] = largest value fit by the polynomial. Input pixels larger than this will be clamped to this value before the calculation is done. Use +Inf for no upper limit.
 *          boundary[1....N-1] = the boundaries separating the input ranges covered by the various polynomials provided (see below)
 *
 *     NaNs will return NaNs. The last polynomial also operates on Inf.  N must be an integer power of 2.
 *     Values found in the destination array are undefined until after the function returns.
 *	   The behavior is undefined if boundaries are NaN.
 *
 *  These functions will also work for multichannel data, such as RGBAFFFF buffers by adjusting the width of the buffer to 
 *  reflect the additional channels. Note that this will cause the alpha channel, if there is one, to become modified like the other channels.
 *  These will work in place, provided that the following are true:
 *      src->data == dest->data
 *      src->rowBytes >= dest->rowBytes
 *      if( src->rowBytes > dest->rowBytes ) kvImageDoNotTile must be passed in the flags parameter

 *
 *  The input parameters are as follows:
 *
 *      src = a pointer to a vImage_Buffer containing the input data for the function
 *      dest = a pointer to a vImage_Buffer structure that describes where to write the results
 *
 *      coefficients = a packed array of pointers to packed arrays of (order+1) polynomial coefficients ( i.e. coefficients[ N ][ order + 1 ] ). 
 *                      The polynomials must appear in order from least to greatest sorted by area of influence.
 *                      The polynomials must all be of the same order. 
 *                      The polynomial coefficients are sorted from 0th order term to highest order term 
 *
 *      boundaries = a packed array of (N+1) floating point values that mark the dividing line between one polynomial and the next. These must be sorted from most negative to most positive. 
 *						Input pixel values less than boundaries[0] will be clamped to be equal to boundaries[0] before the calculation is done
 *						Input pixel values greater than boundaries[N] will be clamped to be equal to boundaries[N] before the calculation is done
 *
 *      order = the number of coefficients minus one used for each polynomial -- all the polynomials must be of the same order
 *                  A polynomial with _two_ coefficients (y = c0 + c1 * x) is a _first_ order polynomial. Pass 1 for a first order polynomial. Pass 2 for a second order polynomial, etc. 
 *
 *      log2segments = log2(N)  
 *
 *      flags = no flags are currently honored. You must pass zero here.
 *
 *      vImagePiecewisePolynomial_PlanarF will work in place.
 *      vImagePiecewisePolynomial_Planar8toPlanarF will work in place.
 *      vImagePiecewisePolynomial_PlanarFtoPlanar8 will NOT work in place.
 *
 *  Performance advisory: 
 *      It costs much more to resolve additional polynomials than to work with higher order polynomials. 
 *      For performance, you are typically better off with one 9th order polynomial that spans the range you are 
 *      interested in than many first order polynomials that cover the area in a piecewise fashion.
 *      Vector code execution time is roughly proportional to:
 *
 *              time = (base cost to touch all the data) + polynomial order + 4 * log2segments
 *
 *      The vector code for an unsplit 13th order polynomial should be about as fast as vImageLookupTable_Planar8toPlanarF() 
 *          on a G4.
 *
 *      With data not in cache, the time may be significantly different. For sufficiently small polynomials, the 
 *      cost may be a fixed cost, dependent only on how much data is touched, and not on polynomial order.
 *
 *        This performance behavior is provided to help developers evaluate speed tradeoffs. It is not a guarantee.
 *        It is subject to change in future operating system revisions, and may be different on different hardware
 *        within the same or different operating system revisions. 
 *
 *      Vector code is not invoked for log2segments > 3.
 *
 *  Accuracy advisory:
 *      Single precision floating point arithmetic is used. While some polynomials may fit a desired curve 
 *      within prescribed error limits when using infinite precision math, limited floating point precision 
 *      may in practice cause significant error to accumulate for some sets of polynomial coefficients. It is 
 *      recommended that you test all reasonable floating point pixel values to make sure that they do indeed
 *      give results that conform to prescribed error limits. 
 *      
 *
 *  Usage Example:
 *  --------------
 *      Lets say you want to mimic the sRGB gamma curve using vImagePiecewisePolynomial_PlanarF. The sRGB gamma curve is defined as follows:
 *
 *              if( {R,G,B} < 0.00304 )
 *                  result = 12.92 * {R,G,B}
 *              else
 *                  result = -0.055 + 1.055 * Pow( {R,G,B}, 2.4 )
 *
 *      Because the power function isn't a polynomial and we need a polynomial, we will approximate it with a second order polynomial:
 *
 *              if( {R,G,B} < 0.00304 )
 *                  result = 12.92 * {R,G,B}
 *              else
 *                  result = c0 + c1 * {R,G,B} + c2 * {R,G,B}^2
 *
 *      (Finding the best values for c0, c1, c2 to approximate -0.055 + 1.055 * Pow( {R,G,B}, 2.4 ) over the range [0.00304, 1.0] is 
 *          left as an exercise for the reader.) 
 *
 *      We have two polynomials -- one for the region below 0.00304 and one for the region above, so N = 2.
 *      The highest order polynomial is a second order polynomial, so order = 2.
 *
 *              const int N = 2;        // two polynomials 
 *              const int order = 2;    // the polynomials are second order (have three terms, including zero terms)
 *
 *      The two polynomials are:
 *
 *              float linearPart[ order + 1 ] = { 0, 12.92, 0 };    // result = 0 + 12.92 * {R,G,B} + 0 * {R,G,B} * {R,G,B}
 *              float nonLinearPart[ order + 1 ] = { c0, c1, c2 };  // result = c0 + c1 * {R,G,B} + c2 * {R,G,B} * {R,G,B}
 *
 *      Here we assemble the rest of the information:
 *      
 *              float *coefficients[ N ] = { linearPart, nonLinearPart };   // sorted in order of area of influence from least to greatest. ( x < 0.00304, x >= 0.00304 )
 *              float boundaries[ N+1 ] = { 0.0f, 0.00304, 1.0f };      // sorted in order from least to greatest. 0.0f and 1.0f define the range over which the polynomials are valid. 0.00304 is the single value separating the two polynomials
 *              int log2segments = 1;   // log2(N)
 *              int flags = 0;          // no flags
 *
 *              vImage_Error error = vImagePiecewisePolynomial_PlanarF( &mySourceBuffer, &myDestinationBuffer, coefficients, boundaries, order, log2segments, flags );
 */										
vImage_Error    vImagePiecewisePolynomial_PlanarF(  const vImage_Buffer *src,       //floating point data
                                                    const vImage_Buffer *dest,      //floating point data
                                                    const float         **coefficients,
                                                    const float         *boundaries,
                                                    uint32_t            order,
                                                    uint32_t            log2segments,
                                                    vImage_Flags        flags ) VIMAGE_NON_NULL(1,2,3,4) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );



vImage_Error    vImagePiecewisePolynomial_Planar8toPlanarF( const vImage_Buffer *src,        //8-bit data
                                                            const vImage_Buffer *dest,       //floating point data
                                                            const float         **coefficients,
                                                            const float         *boundaries,
                                                            uint32_t            order,
                                                            uint32_t            log2segments,
                                                            vImage_Flags        flags ) VIMAGE_NON_NULL(1,2,3,4) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );

vImage_Error    vImagePiecewisePolynomial_PlanarFtoPlanar8( const vImage_Buffer *src,       //floating point data
                                                            const vImage_Buffer *dest,      //8-bit data
                                                            const float         **coefficients,
                                                            const float         *boundaries,	/*The 0th and Nth terms in the boundaries array are typically 0.0f and 255.0f respectively. Other values may incur additional computational cost. */
                                                            uint32_t            order,
                                                            uint32_t            log2segments,
                                                            vImage_Flags        flags ) VIMAGE_NON_NULL(1,2,3,4) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );

    
/*
 *  vImageSymmetricPiecewisePolynomial*
 *
 *  Apply one or more polynomials to the input image to give the output image.  The polynomial p(x) is provided as a 
 *  series of coefficients.  e.g.:
 *
 *      p(x,i) = coefficient[i][0] + (coefficient[i][1] + (coefficient[i][2] + coefficient[i][3]*x)*x)*x;    (assuming a 3rd order polynomial)
 *
 *  This is just like vImagePiecewisePolynomial_<fmt>.  However, when it is applied, a modified polynomial p'(x) is actually used:
 *
 *      p'(x) = p(fabsf(x)) * copysignf( 1.0f, x)
 *
 *  This makes the polynomial C2 symmetric about the origin.  That is, the negative domain looks like the positive domain, rotated 180 degrees about the origin.
 *
 *  vImageSymmetricPiecewisePolynomial_PlanarF floating point data on both input and output.
 *
 *  The arrangement of the polynomials is defined as follows:
 *      Let there be N polynomials that each cover part of the single precision floating point range that are arranged in order of area of influence from -Infinity to Infinity.
 *      The ith polynomial shall operate on the set of input pixel values that fall in the range:
 *
 *          boundary[i] <= pixel_value < boundary[i+1].
 *
 *     for which:
 *
 *          boundary[0] = smallest value fit by the polynomial. Input pixels smaller than this will be clamped to this value before the calculation is done. Use -Inf for no lower limit.
 *          boundary[N] = largest value fit by the polynomial. Input pixels larger than this will be clamped to this value before the calculation is done. Use +Inf for no upper limit.
 *          boundary[1....N-1] = the boundaries separating the input ranges covered by the various polynomials provided (see below)
 *
 *     NaNs will return NaNs. The last polynomial also operates on Inf.  N must be an integer power of 2.
 *     Values found in the destination array are undefined until after the function returns.
 *	   The behavior is undefined if boundaries are NaN.
 *
 *  These functions will also work for multichannel data, such as RGBAFFFF buffers by adjusting the width of the buffer to
 *  reflect the additional channels. Note that this will cause the alpha channel, if there is one, to become modified like the other channels.
 *  These will work in place, provided that the following are true:
 *      src->data == dest->data
 *      src->rowBytes >= dest->rowBytes
 *      if( src->rowBytes > dest->rowBytes ) kvImageDoNotTile must be passed in the flags parameter
 
 *
 *  The input parameters are as follows:
 *
 *      src = a pointer to a vImage_Buffer containing the input data for the function
 *      dest = a pointer to a vImage_Buffer structure that describes where to write the results
 *
 *      coefficients = a packed array of pointers to packed arrays of (order+1) polynomial coefficients ( i.e. coefficients[ N ][ order + 1 ] ).
 *                      The polynomials must appear in order from least to greatest sorted by area of influence.
 *                      The polynomials must all be of the same order.
 *                      The polynomial coefficients are sorted from 0th order term to highest order term
 *
 *      boundaries = a packed array of (N+1) floating point values that mark the dividing line between one polynomial and the next. These must be sorted from most negative to most positive.
 *						Input pixel values less than boundaries[0] will be clamped to be equal to boundaries[0] before the calculation is done
 *						Input pixel values greater than boundaries[N] will be clamped to be equal to boundaries[N] before the calculation is done
 *
 *      order = the number of coefficients minus one used for each polynomial -- all the polynomials must be of the same order
 *                  A polynomial with _two_ coefficients (y = c0 + c1 * x) is a _first_ order polynomial. Pass 1 for a first order polynomial. Pass 2 for a second order polynomial, etc.
 *
 *      log2segments = log2(N)
 *
 *      flags = no flags are currently honored. You must pass zero here.
 *
 *      vImagePiecewisePolynomial_PlanarF will work in place.
 *      vImagePiecewisePolynomial_Planar8toPlanarF will work in place.
 *      vImagePiecewisePolynomial_PlanarFtoPlanar8 will NOT work in place.
 *
 *  Performance advisory:
 *      It costs much more to resolve additional polynomials than to work with higher order polynomials.
 *      For performance, you are typically better off with one 9th order polynomial that spans the range you are
 *      interested in than many first order polynomials that cover the area in a piecewise fashion.
 *      Vector code execution time is roughly proportional to:
 *
 *              time = (base cost to touch all the data) + polynomial order + 4 * log2segments
 *
 *      The vector code for an unsplit 13th order polynomial should be about as fast as vImageLookupTable_Planar8toPlanarF()
 *          on a G4.
 *
 *      With data not in cache, the time may be significantly different. For sufficiently small polynomials, the
 *      cost may be a fixed cost, dependent only on how much data is touched, and not on polynomial order.
 *
 *        This performance behavior is provided to help developers evaluate speed tradeoffs. It is not a guarantee.
 *        It is subject to change in future operating system revisions, and may be different on different hardware
 *        within the same or different operating system revisions.
 *
 *      Vector code is not invoked for log2segments > 3.
 *
 *  Accuracy advisory:
 *      Single precision floating point arithmetic is used. While some polynomials may fit a desired curve
 *      within prescribed error limits when using infinite precision math, limited floating point precision
 *      may in practice cause significant error to accumulate for some sets of polynomial coefficients. It is
 *      recommended that you test all reasonable floating point pixel values to make sure that they do indeed
 *      give results that conform to prescribed error limits.
 *
 *
 *  Usage Example:
 *  --------------
 *      Lets say you want to mimic the sRGB gamma curve using vImagePiecewisePolynomial_PlanarF. The sRGB gamma curve is defined as follows:
 *
 *              if( {R,G,B} < 0.00304 )
 *                  result = 12.92 * {R,G,B}
 *              else
 *                  result = -0.055 + 1.055 * Pow( {R,G,B}, 2.4 )
 *
 *      Because the power function isn't a polynomial and we need a polynomial, we will approximate it with a second order polynomial:
 *
 *              if( {R,G,B} < 0.00304 )
 *                  result = 12.92 * {R,G,B}
 *              else
 *                  result = c0 + c1 * {R,G,B} + c2 * {R,G,B}^2
 *
 *      (Finding the best values for c0, c1, c2 to approximate -0.055 + 1.055 * Pow( {R,G,B}, 2.4 ) over the range [0.00304, 1.0] is
 *          left as an exercise for the reader.)
 *
 *      We have two polynomials -- one for the region below 0.00304 and one for the region above, so N = 2.
 *      The highest order polynomial is a second order polynomial, so order = 2.
 *
 *              const int N = 2;        // two polynomials
 *              const int order = 2;    // the polynomials are second order (have three terms, including zero terms)
 *
 *      The two polynomials are:
 *
 *              float linearPart[ order + 1 ] = { 0, 12.92, 0 };    // result = 0 + 12.92 * {R,G,B} + 0 * {R,G,B} * {R,G,B}
 *              float nonLinearPart[ order + 1 ] = { c0, c1, c2 };  // result = c0 + c1 * {R,G,B} + c2 * {R,G,B} * {R,G,B}
 *
 *      Here we assemble the rest of the information:
 *
 *              float *coefficients[ N ] = { linearPart, nonLinearPart };   // sorted in order of area of influence from least to greatest. ( x < 0.00304, x >= 0.00304 )
 *              float boundaries[ N+1 ] = { 0.0f, 0.00304, 1.0f };      // sorted in order from least to greatest. 0.0f and 1.0f define the range over which the polynomials are valid. 0.00304 is the single value separating the two polynomials
 *              int log2segments = 1;   // log2(N)
 *              int flags = 0;          // no flags
 *
 *              vImage_Error error = vImagePiecewisePolynomial_PlanarF( &mySourceBuffer, &myDestinationBuffer, coefficients, boundaries, order, log2segments, flags );
 */
vImage_Error    vImageSymmetricPiecewisePolynomial_PlanarF( const vImage_Buffer *src,   //floating point data
                                                            const vImage_Buffer *dest,  //floating point data
                                                            const float         **coefficients,
                                                            const float         *boundaries,
                                                            uint32_t            order,
                                                            uint32_t            log2segments,
                                                            vImage_Flags        flags )
                                                            VIMAGE_NON_NULL(1,2,3,4)
                                                            __OSX_AVAILABLE_STARTING( __MAC_10_11, __IPHONE_9_0 );

    
/*
 *      vImagePiecewiseRational_PlanarF is similar to vImagePiecewisePolynomial_PlanarF
 *      Except that it evaluates a piecewise rational expression in the form of:
 *
 *                      c0 + c1*x + c2*x^2 + c3*x^3...
 *          result = -----------------------------------
 *                      d0 + d1*x + d2*x^2 + d3*x^3...
 *
 *      The function is behaves nearly exactly like vImagePiecewisePolynomial_PlanarF, except that
 *      there are now two polynomials, for top and bottom of the divide shown above. Each
 *      polynomial has its own set of coefficients and its own polynomial order. The two 
 *      polynomials share the same set of segment boundaries. If the polynomials are split then 
 *      all the top polynomials must be of the same order, and all the bottom polynomials must 
 *      be of the same order. However, regardless of whether the polynomial is split or not,
 *      the top polynomials do not need to be the same order as the bottom polynomials.
 *
 *      This function does not deliver IEEE-754 correct division. The divide does not round per
 *      the IEEE-754 current rounding mode. It incurs up to 2 ulps of error. Edge cases involving 
 *      denormals, infinities, NaNs and division by zero return undefined results. (They will not 
 *      crash, but NaN is a likely result in such cases.) Denormals can be rescued on AltiVec enabled 
 *      machines by turning off the Non-Java bit in the VSCR, at the expense of taking a many-thousand 
 *      cycle kernel exception every time a denormal number is encountered. Since you can predict ahead 
 *      of time whether a given set of bounded polynomials is going to encounter these conditions, 
 *      this problem should be avoidable by wise choice of polynomials. Developers who require IEEE-754 
 *      correct results should call the polynomial evaluator above twice and do the division themselves. 
 *
 *      These functions will also work for multichannel data, such as RGBAFFFF buffers by adjusting the 
 *      width of the buffer to reflect the additional channels. Note that this will cause the alpha channel, 
 *      if there is one, to become modified like the other channels.
 *
 *      These will work in place, provided that the following are true:
 *          src->data == dest->data
 *          src->rowBytes >= dest->rowBytes
 *          if( src->rowBytes > dest->rowBytes ) kvImageDoNotTile must be passed in the flags parameter

 *      Performance Advisory:
 *        Approximate cost of evaluating a rational (in the same units as polynomial above) is:
 *
 *              time = (base cost to touch all the data) 
 *                          + top polynomial order 
 *                          + bottom polynomial order 
 *                          + 4 
 *                          + 4 * log2segments
 *
 *        With data not in cache, the time may be significantly different. For sufficiently small polynomials, the 
 *        cost may be a fixed cost, dependent only on how much data is touched, and not on polynomial order.
 *
 *        This performance behavior is provided to help developers evaluate speed tradeoffs. It is not a guaranteed. 
 *        It is subject to change in future operating system revisions, and may be different on different hardware
 *        within the same or different operating system revisions. 
 *
 */
vImage_Error    vImagePiecewiseRational_PlanarF(  const vImage_Buffer *src,         //floating point data
                                                    const vImage_Buffer *dest,       //floating point data
                                                    const float         **topCoefficients,
                                                    const float         **bottomCoefficients,
                                                    const float         *boundaries,
                                                    uint32_t            topOrder,
                                                    uint32_t            bottomOrder,
                                                    uint32_t            log2segments,
                                                    vImage_Flags        flags ) VIMAGE_NON_NULL(1,2,3,4,5) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );
    
/*  A simple lookup table:
 *
 *          Pixel_16U table[256];
 *          Pixel_16U result_pixel = table[input_8_bit_pixel];
 *
 *  The input is a buffer of 8-bit pixels. The output is a buffer of 16-bit pixels.
 *
 *	Note: It is okay to use this to convert Planar8 data to other 16 bit types as well, such as 16S or 16F,
 *  or ARGB1555 or RGB565 pixels.  Simply use an array of the appropriate type for the lookup table.
 *
 *  This function can also work for multichannel data by scaling the width of the image to compensate for the
 *  additional channels. All channels will use the same table.
 *
 *  vImageLookupTable_Planar8ToPlanar16 will not work in place.
 */
    
vImage_Error vImageLookupTable_Planar8toPlanar16(const vImage_Buffer *src,
                                                 const vImage_Buffer *dest,
                                                 const Pixel_16U      table[256],
                                                 vImage_Flags         flags)
    VIMAGE_NON_NULL(1,2,3) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0);
    
/*
 *  A simple lookup table:
 *
 *          float table[256];
 *          float result_pixel = table[ input_8_bit_pixel ];
 *
 *  The input is a buffer of 8-bit pixels. The output is a buffer of floating point pixels. 
 *
 *	Note: It is okay to use this to convert Planar8 data to other 32 bit types as well, such as a ARGB8888 pixel. 
 *			Simply pass a Pixel_8888[256] array instead of a Pixel_F[256] array.
 *
 *  This function can also work for multichannel data by scaling the width of the image to compensate for the 
 *  additional channels. All channels will use the same table.
 *  
 *  vImageLookupTable_Planar8ToPlanarF will not work in place.
 */
    
vImage_Error vImageLookupTable_Planar8toPlanarF(const vImage_Buffer *src,
                                                const vImage_Buffer *dest,
                                                const Pixel_F        table[256],
                                                vImage_Flags         flags)
    VIMAGE_NON_NULL(1,2,3) __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_5_0);


/*
 *  A simple lookup table with floating point inputs:
 *
 *          uint8_t table[4096];
 *          uint32_t index =  (uint32_t) MIN( MAX( input_float_pixel * 4096.0f, 0.0f), 4095.0f);
 *          uint8_t result_pixel = table[ index ];
 *
 *  The input is a buffer of floating-point pixels. The output is a buffer of 8-bit pixels. 
 *  This function can also work for multichannel data by scaling the width of the image to compensate for the 
 *  additional channels. All channels will use the same table.
 *
 *  vImageLookupTable_PlanarFToPlanar8 will work in place, provided that the following are true:
 *      src->data == dest->data
 *      src->rowBytes >= dest->rowBytes
 *      if( src->rowBytes > dest->rowBytes ) kvImageDoNotTile must be passed in the flags parameter
 */
vImage_Error
vImageLookupTable_PlanarFtoPlanar8(
    const vImage_Buffer *src,          /* floating point pixels */
    const vImage_Buffer *dest,         /* 8-bit pixels */
    const Pixel_8       table[4096],
    vImage_Flags        flags )
    VIMAGE_NON_NULL(1,2,3) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );


/*
 *  vImageLookupTable_8to64U
 *
 *  Use a lookup table to remap 0..255 values in the source image to a
 *  different set of 64-bit unsigned integer values in the destination.
 *
 *          uint64_t table[256];
 *          uint64_t result_pixel = table[ input_8_bit_pixel ];
 *
 *      src         A pointer to a vImage_Buffer that references the source pixels
 *
 *      dest        A pointer to a vImage_Buffer that references the destination pixels
 *
 *      table       A pointer to the lookup table. The table should be an array with 256 elements.
 *
 *      flags       The following flags are allowed:
 *
 *          kvImageDoNotTile         Turns off internal multithreading. You may
 *                                   wish to do this if you have your own
 *                                   multithreading scheme to avoid having the
 *                                   two interfere with one another.
 *
 *  Return Value:
 *  -------------
 *      kvImageNoError                  Success!
 *      kvImageBufferSizeMismatch       Sizes of the src and dest images do not match
 *      kvImageNullPointerArgument      src, dest or table pointer is NULL.
 *
 *  This routine will not work in place.
 *
 */
vImage_Error
vImageLookupTable_8to64U(
    const vImage_Buffer *src,
    const vImage_Buffer *dest,
    const uint64_t      LUT[256],
    vImage_Flags flags)
    VIMAGE_NON_NULL(1,2,3)   __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );


/*
 *  vImageInterpolatedLookupTable_PlanarF
 *
 *  Results are calculated as follows:
 *
 *	float clippedPixel = MAX( MIN( src_pixel, maxFloat ), minFloat );	//clip src_pixel to be in range
 *	float fIndex = (float) (tableEntries - 1) * (clippedPixel - minFloat ) / (maxFloat - minFloat);
 *	float fract = fIndex - floor( fIndex );
 *	unsigned long index =  fIndex;
 *	float result = table[ index ] * ( 1.0f - fract ) + table[ index + 1] * fract;
 *
 *  In English, this translates to a lookup table that contains tableEntries values, that span
 *  the input range of minFloat...maxFloat, inclusive, in an evenly spaced fashion.
 *
 *                      tableEntries
 *               <--------------------->
 *      |
 *    r |          ****
 *    e |        *      *              *
 *    s |                 *          *
 *    u |                  *       *
 *    l |                    *****  
 *    t +--------+---------------------+--------
 *            minFloat              maxFloat
 *
 *	IMPORTANT: For correct operation, the table must be allocated to contain tableEntries+1 entries. 
 *				If the table is too small or the value of table[ tableEntries ] is infinite or NaN, 
 *				behavior is undefined.
 *
 *  The function will work in place, provided that the following are true:
 *      src->data == dest->data
 *      src->rowBytes >= dest->rowBytes
 *      if( src->rowBytes > dest->rowBytes ) kvImageDoNotTile must be passed in the flags parameter
 * 
 *  This function may be used on multichannel images by scaling the width by the number of channels.
 *  The same table will be used for all the channels, including alpha, if there is an alpha channel.
 */
vImage_Error    vImageInterpolatedLookupTable_PlanarF(  const vImage_Buffer *src,
                                                        const vImage_Buffer *dest,
                                                        const Pixel_F       *table,
                                                        vImagePixelCount    tableEntries,
                                                        float               maxFloat,
                                                        float               minFloat,
                                                        vImage_Flags        flags ) VIMAGE_NON_NULL(1,2,3) __OSX_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 );

    
/*
 *  vImageMultidimensionalTable_Create
 *
 *  Creates a vImage_MultidimensionalTable for use with vImageMultiDimensionalInterpolatedLookupTable_<fmt>(). The
 *  input data is a contiguous array of N dimensional samples which define the lookup table grid points.
 *  The samples have range [0,65535] interpreted as [0, 1.0f]. (Samples have an implict divide by 65535
 *  in them, like the Planar16U format.)  
 *
 *  The vImage_MultidimensionalTable is not a CFType.
 *
 *  Example: 
 *      Suppose the multidimensional table is intended to convert RGB (3 channel) data to CMYK (4 channel).
 *      In each of the {R, G, B} dimensions, we have 17 samples. The table is then comprised of
 *      17x17x17=4913 uint16_t[4]'s, each of which contains {C,M,Y,K} for that position. The dimensions
 *      are iterated in standard C order (row major). In this case, they would be:
 * 
 *      {CMYK for  R0G0B0, CMYK for R0G0B1,  CMYK for  R0G0B2, ...  CMYK for  R0G0B16,
 *       CMYK for  R0G1B0, CMYK for R0G1B1,  CMYK for  R0G1B2, ...  CMYK for  R0G1B16,
 *       ...
 *       CMYK for R0G16B0, CMYK for R0G16B1, CMYK for R0G16B2, ...  CMYK for R0G16B16,
 *       CMYK for  R1G0B0, CMYK for R1G0B1,  CMYK for R1G0B2,  ...  CMYK for R1G0B16,
 *       ...
 *       CMYK for R1G16B0, CMYK for R1G16B1, CMYK for R1G16B2,  ...  CMYK for R1G16B16,
 *       ...
 *       CMYK for R16G16B0, CMYK for R16G16B1, CMYK for R16G16B2,  ...  CMYK for R16G16B16 }
 *
 *  Parameters:
 *      tableData                   A non-NULL pointer to the data used to build the table
 *      numSrcChannels              The number of channels in an input pixel
 *      numDestChannels             The number of channels in an output pixel
 *      table_entries_per_dimension An array containing the number of table entries for each dimension in numSrcChannels
 *                                      The entries are in the same order as the channels in the src pixel.
 *      hint                        An indication of how the table would be used.  Pass either kvImageMDTableHint_16Q12
 *                                      or kvImageMDTableHint_Float or both. If only one is passed, we will save memory
 *                                      and time skipping work to set up the table for unused formats.
 *      flags						The following flags are allowed:
 *
 *				kvImageDoNotTile	Turns off internal multithreading. You may
 * 									wish to do this if you have your own
 *									multithreading scheme to avoid having the
 *									two interfere with one another.
 *      err                         A pointer to a vImage_Error. If err != NULL, on return, the memory pointed to by error
 *                                      will be overwritten with an appropriate error or kvImageNoError. It is sufficient to 
 *                                      simply check the LHS return value against NULL to determine whether the function succeeeded.
 *
 *  Return value:
 *      On return a valid vImage_MultidimensionalTable for use with vImageMultiDimensionalInterpolatedLookupTable_<fmt>
 *      if err is not NULL, the memory it points to will be overwritten with an appropriate error code. The 
 *      vImage_MultidimensionalTable will contain a copy of the data provided in tableData. It is safe to deallocate
 *      the input tableData immediately after this call returns.
 *
 *       
 *
 *  Errors:
 *      kvImageNoError                Success
 *      kvImageInvalidParameter       hint must be kvImageMDTableHint_16Q12 or kvImageMDTableHint_Float or both
 *		kvImageInvalidParameter       numSrcChannels and numDestChannels must be non-zero.
 *      kvImageNullPointerArgument    tableData and table_entries_per_dimension must not be NULL.
 *      kvImageUnknownFlagsBit        An illegal or unknown flag was passed to the function.
 *      kvImageMemoryAllocationError  Can not allocate memory for buffer.
 *      
 *  Use vImageMultidimensionalTable_Release to destroy the vImage_MultidimensionalTable when you are done with it. 
 *  The vImage_MultidimensionalTable may be reused. The table is immutable, thread-safe and may be used by many 
 *  vImageMultiDimensionalInterpolatedLookupTable_<fmt> calls concurrently so long as care is taken that it is not 
 *  freed while it is being used. To support multithreaded concurrent access, the table follows standard retain/release 
 *  semantics. On creation the table has a retain count of 1. When the reference count drops to 0, the table is destroyed.
 *
 */

typedef struct vImage_MultidimensionalTableData * vImage_MultidimensionalTable;
    
/* Hints to describe use of vImage_MultidimensionalTableData look up table. */
typedef enum
{
    kvImageMDTableHint_16Q12 = 1,           
    kvImageMDTableHint_Float = 2,
}vImageMDTableUsageHint;
    
vImage_MultidimensionalTable vImageMultidimensionalTable_Create( const uint16_t *tableData,
                                                                 uint32_t numSrcChannels,
                                                                 uint32_t numDestChannels,
                                                                 const uint8_t table_entries_per_dimension[],   /* uint8_t[numSrcChannels] */
                                                                 vImageMDTableUsageHint hint,
                                                                 vImage_Flags flags,
                                                                 vImage_Error *err )
                                                                 VIMAGE_NON_NULL(1,4)
                                                                 __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    
/*
 *  vImageMultidimensionalTable_Retain
 *  vImageMultidimensionalTable_Release
 *
 *  A vImage_MultidimensionalTable follows Retain/Release semantics. On creation, the table has  a retain count of 1. 
 *  If you call vImageMultidimensionalTable_Retain on it, the retain count is incremented. If you call 
 *  vImageMultidimensionalTable_Release on it, the retain count is decremented. When the retain count reaches 0,
 *  the object is destroyed. If any vImage function is called on an object whose reference count has already reached 
 *  0, behavior is undefined.
 *
 *  Parameters:
 *      table       A pointer to vImage_MultidimensionalTableData. If NULL, then nothing happens.
 *
 *  Errors:
 *      kvImageNoError                  Success
 */
vImage_Error vImageMultidimensionalTable_Retain( vImage_MultidimensionalTable table ) __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
vImage_Error vImageMultidimensionalTable_Release( vImage_MultidimensionalTable table ) __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    
/*
 *  vImageMultiDimensionalLookupTable_PlanarF
 *
 *  vImageMultiDimensionalLookupTable_<fmt> uses the input color channel values (treated as a N-dimensional coordinate)
 *  to index a N-dimensional lookup table to find a new color value, possibly in a new color space. The number of color channels
 *  in the destination image does not need to match the number of color channels in the source image. The table is created using
 *  vImageMultidimensionalTable_Create. 
 *
 *  In each dimension, the table must be of size (2**K[dimension])+1. The first entry corresponds to 0 and the last to 1.0. The rest
 *  correspond to steps at 2**-K[dimension]. (K[] is the table_entries_per_dimension[] array in vImageMultidimensionalTable_Create.)
 *  Thus a 17x17x17 3D lookup table defines the vertices that delineate a grid of 16x16x16 cubes, just as a ruler marked in 16ths of an
 *  inch has 17 marks between 0 and 1 inch, inclusive. (SI units are usually awkwardly subdivided by powers of 10, rather than powers of 2
 *  so we avoid them in this example. :-)    The most significant portion of the color channel values are used to index the multidimensional 
 *  grid. Usually there will be some fractional precision left over.  That is used to do a linear interpolation between nearby gridpoints 
 *  to find the value at that position. If the vImage_InterpolationMethod is kvImageFullInterpolation, then all 2**N (for N dimensions) 
 *  nearby gridpoints are considered. If the vImage_InterpolationMethod is kvImageHalfInterpolation, then the {0,0,0...}, {1,1,1...} verticies 
 *  along the gray axis are considered along with N-1 nearest other vertices. 
 *
 *
 *  Parameters:
 *
 *      srcs                    An array of vImage_Buffers that reference the source image planes. The number of
 *                              such buffers is given by the numSrcChannels parameter passed to vImageMultidimensionalTable_Create.
 *
 *      dests                   An array of vImage_Buffers that reference the destination image planes. The number of
 *                              such buffers is given by the numDestChannels parameter passed to vImageMultidimensionalTable_Create.
 *
 *      tempBuffer              May be NULL. If non-NULL, this is a pointer to a region of memory that vImage can use as a 
 *                              scratch space for storing temporary data. The minimum size of the scratch space is obtained  
 *                              by calling the function with identical parameters and the kvImageGetTempBufferSize flag.
 *                              If vImageMultiDimensionalInterpolatedLookupTable_<fmt> can be called from multiple threads
 *                              simultaneously, the temp buffer must be different (or NULL) for each thread. 
 *
 *      table                   A valid table created by vImageMultidimensionalTable_Create
 *
 *      method                  either kvImageFullInterpolation or kvImageHalfInterpolation. See description above.
 *
 *      flags                   Must be kvImageNoFlags or one or more from this list:
 *                              
 *                                  kvImageDoNotTile            turn off internal multithreading. 
 *                                  kvImageGetTempBufferSize    Return the size of temp buffer. It may return 0. Do nothing.
 *
 *  Error Values:
 *		>= 0                        Minimum temp buffer size, if kvImageGetTempBufferSize was specified.
 *      kvImageNoError              Success
 *      kvImageNullPointerArgument  srcs, dests and table may not be NULL
 *      kvImageUnknownFlagsBit      An illegal or unknown flag was passed to the function.
 *      kvImageInvalidParameter     An unknown or illegal interpolation method was indicated
 *      kvImageInvalidParameter     The interpolation method doesn't have a table for the requested data type. 
 *                                      This happened because an incorrect vImageMDTableUsageHint was passed to
 *                                      vImageMultidimensionalTable_Create
 *      kvImageBufferSizeMismatch   Within srcs, all vImage_Buffers must have the same height and width.
 *									Similarly, within dests, all vImage_Buffers must have the same height and width.
 *									Otherwise this error is returned.
 *      kvImageBufferSizeMismatch   The src height and width must be greater than or equal to the destination height
 *									and width.
 *
 */

/* interpolation method for vImageMultiDimensionalInterpolatedLookupTable_<fmt>*/
typedef enum
{
    kvImageNoInterpolation = 0,             /* nearest neighbor. Fast but probably causes banding and will certainly quantize the histogram. */
    kvImageFullInterpolation = 1,           /* full linear interpolation */
    kvImageHalfInterpolation = 2            /* partial linear interpolation between vertices on gray axis and N-1 nearest vertices */
}vImage_InterpolationMethod;
    
vImage_Error vImageMultiDimensionalInterpolatedLookupTable_PlanarF( const vImage_Buffer srcs[],
                                                                    const vImage_Buffer dests[],
                                                                    void *tempBuffer,
                                                                    vImage_MultidimensionalTable table,
                                                                    vImage_InterpolationMethod method,
                                                                    vImage_Flags flags )
                                                                    VIMAGE_NON_NULL(1,2,4)
                                                                    __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );

/*
 *  vImageMultiDimensionalInterpolatedLookupTable_Planar16Q12
 *
 *  vImageMultiDimensionalInterpolatedLookupTable_Planar16Q12 is like vImageMultiDimensionalInterpolatedLookupTable_PlanarF
 *  except that it operates on signed fixed-point data. The 16Q12 format is a signed 16-bit fixed-point value with 12 fractional 
 *  bits, 3 non-fractional bits and one sign bit. It can represent values in the range (-8,8). However the table always describes 
 *  a region between [0,1] in each dimension. Values outside this range are clamped to the nearest in-range value by Manhattan 
 *  distance before indexing the table. See vImageConvert_Planar8to16Q12 and vImageConvert_16Q12toPlanar8 for more on the format.
 */
vImage_Error vImageMultiDimensionalInterpolatedLookupTable_Planar16Q12( const vImage_Buffer srcs[],
                                                                        const vImage_Buffer dests[],
                                                                        void *tempBuffer,
                                                                        vImage_MultidimensionalTable table,
                                                                        vImage_InterpolationMethod method, 
                                                                        vImage_Flags flags )
                                                                        VIMAGE_NON_NULL(1,2,4)
                                                                        __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    
    
    

#ifdef __cplusplus
}
#endif

#endif /* vImage_TRANSFORM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                             vImage.h                                                                                            0100644 0001750 0001750 00000051525 12566216025 042556  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/Headers                           
/****************************************************************************************************************************************************************
 *                                                                                                                                                              *
 *  The main vImage documentation is available in the vImage Programming Guide:                                                                                 *
 *                                                                                                                                                              *
 *    OS X: https://developer.apple.com/library/mac/documentation/Performance/Conceptual/vImage/Introduction/Introduction.html                                  *
 *    iOS:  https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Introduction/Introduction.html                                  *
 *                                                                                                                                                              *
 *  However, that resource, generously provided by ADC, is updated infrequently. In order to provide more timely documentation for newer vImage API, these      *
 *  headers contain additional headerdoc documentation in the comments.  The vImage headerdoc documentation can be viewed in lovely HTML as follows:            *
 *                                                                                                                                                              *
 *    /usr/bin/headerdoc2html -o ~/vImage_docs \                                                                                                                *
 *            `xcrun --sdk {iphoneos|macosx} --show-sdk-path`/System/Library/Frameworks/Accelerate.framework/Frameworks/vImage.framework/Headers                *
 *        # Select the single platform for the SDK you are working with. vImage APIs generally stay in sync between platforms.                                  *
 *        # (or using system headers from command line tools: /System/Library/Frameworks/Accelerate.framework/Frameworks/vImage.framework/Headers)              *
 *    /usr/bin/gatherheaderdoc ~/vImage_docs                                                                                                                    *
 *    open ~/vImage_docs/masterTOC.html                                                                                                                         *
 *                                                                                                                                                              *
 *  For more on using headerdoc:                                                                                                                                *
 *    https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/HeaderDoc/usage/usage.html#//apple_ref/doc/uid/TP40001215-CH337-CDEBBJJA  *
 *                                                                                                                                                              *
 *  vImage headerdoc documentation is a work in progress, and currently only covers recent additions. (Documenting old features already present in the vImage   *
 *  Programming Guide would compete for engineering time against vImage development itself.) Most functions not covered in headerdoc should be documented in    *
 *  the vImage Programming Guide. Please file a bug if you encounter a function documented in neither resource.    http://bugreporter.apple.com                 *
 *                                                                                                                                                              *
 *  Option clicking a vImage symbol in Xcode will often bring up online help with information assembled from both resources.                                    *
 *                                                                                                                                                              *
 ****************************************************************************************************************************************************************/

#ifndef VIMAGE_H
#define VIMAGE_H

/*!
 *  @header vImage.h
 *  @copyright Copyright (c) 2002-2015 by Apple Inc. All rights reserved.
 *  @compilerflag  -framework Accelerate
 *  @charset utf-8
 *
 *  @discussion
 *
 *  <pre> @textblock
 *    Data Formats
 *    ------------
 *    Most functions are available in four flavors, one for each of the four standard data formats supported
 *    by vImage. These are:
 *
 *    8 bit planar integer data  -- "Planar8":
 *        The buffer contains a single color channel (e.g. red) as an array of packed unsigned chars.
 *
 *    32 bit planar floating point data -- "PlanarF":
 *        The buffer contains a single color channel (e.g. red) as an array of packed floats.
 *
 *    8 bit ARGB interleaved integer data -- "ARGB8888":
 *        The buffer contains four interleaved color channels in the order alpha, red, green, blue, in a
 *        packed array of unsigned chars. (This is a standard 32 bit ARGB color pixel, with 8 bits per channel).
 *
 *    32 bit ARGB interleaved floating point data -- "ARGBFFFF":
 *        The buffer contains four interleaved color channels in the order alpha, red, green, blue, in a
 *        packed array of floats.
 *
 *    Many functions are also available in Planar and ARGB versions of unsigned and signed 16-bit integer, 16S and
 *    16U respectively.
 *
 *    PERFORMANCE ADVISORY: Performance of the planar versions of these functions will in some cases
 *    be *MUCH* better than their interleaved counterparts. Most operations are done in register with planar
 *    data, even if the starting data format was an interleaved format. By using planar data formats,
 *    you avoid the de-interleave, re-interleave cost in each function call. In addition, where calculation
 *    on the alpha channel is not desired, the computational cost and cache usage for planar formats is
 *    in principle 3/4 the cost of interleaved formats for four channel data. Finally planar data is a natural
 *    form of tiling that works well when used with multiple serial filters. When applying multiple filters to
 *    a image, apply them all to one channel, then repeat the sequence for the next channel and so forth until
 *    all the color channels are calculated. This will help keep key data in the caches and in some cases may
 *    produce profound performance improvements.
 *
 *    The presumed value range for 8 bit color channels is 0 to 255, with 0 being black and 255 being full intensity color.
 *    For floating point data, 0.0f is black and 1.0f is full intensity color. Values outside this range are allowed for
 *    floating point data. Except where noted, FP calculations do not clip values outside the range 0.0f ... 1.0f. In certain
 *    cases (most notably geometry operations that involve resampling and colvolutions), it is possible that input data
 *    that is entirely withing the range 0.0f ... 1.0f will produce results that are slightly outside that range. A separate
 *    floating point clipping function is provided if clipping is required.
 *
 *    Other floating point ranges (e.g. 0.0f ... 255.0f) are likely to also work since most functions in vImage are linear.
 *    However, they are not extensively tested.
 *
 *    vImage_Buffers
 *    --------------
 *    Most vImage functions attempt to fill a destination buffer with pixels drawn from an input buffer using some
 *    transformation. In some cases, the operation would require that pixels outside the area covered by the input
 *    buffer be used to fill the output buffer. The input vImage_Buffer defines the absolute limit of the area of
 *    data that may be read by the function. The function will not stray outside of this area in its attempt to
 *    fill the destination with pixels. How a function copes with edge cases when data is unavailable is dependent
 *    on the function.
 *
 *        typedef struct vImage_Buffer
 *        {
 *            void                *data;		// Pointer to the top left pixel of the buffer.
 *            vImagePixelCount	  height;		// The height (in pixels) of the buffer
 *            vImagePixelCount    width;		// The width (in pixels) of the buffer
 *            size_t              rowBytes;	    // The number of bytes in a pixel row
 *        }vImage_Buffer;
 *
 *    Some functions may operate only on a rectangular subset of pixels in the input buffer. This is useful for tiling
 *    or for when image operations are only desired to be applied to part of an image. The top left corner of the subset
 *    is provided by a X and Y offset into the vImage_Buffer passed as the input buffer. The height and width of the input
 *    region of interest is in many cases given by the height and width of the destination buffer. The geometry operators
 *    use non-rectangular input regions of interest making it difficult to predict which pixels will be used. In this case,
 *    the offsets (if any) are the offsets into the input region of interest for the case where the scale factor is 1.0 and
 *    shear and translate are 0.0f.
 *
 *    Please be aware that many functions, especially those that require kernels or which do resampling, will read
 *    outside the input region of interest. Some extra care with multithreaded code may be required in those cases to make
 *    sure nobody is changing data outside the region of interest that is read by the function while the function is operating.
 *    At no time will a function read outside the vImage_Buffer within which the region of interest resides.
 *
 *    So as to make multithreaded tiled (stripmined) algorithms easy to write, vImage makes two guarantees:
 *
 *        (1) vImage will never write data outside of the destination vImage_Buffer. vImage will not try to cheat this
 *            guarantee by reading data outside the destination buffer and writing it back unmodified.
 *
 *        (2) vImage will never read data outside of the area passed to it as the input vImage_Buffer.
 *
 *    The state of the output vImage_Buffer while a vImage function is working on it is undefined. There may be times when
 *    a pixel in the ROI is neither the starting data or the finished result, but instead the result of some
 *    intermediate calculation. The calculation is complete when the function returns.
 *
 *    Note that although a vImage_Buffer struct may be marked const, this does not mean that the pixel data that
 *    it points to is also const. It is merely an indication that it is safe to reuse the struct between function
 *    calls. Except where noted, the pixel data in the input buffers will not be changed by the function. vImage
 *    does not go to extreme lengths to guarantee this however, so for example you may pass the same buffer as input
 *    and output to a function, in which case the input buffer will be changed.
 *    Caution: except where otherwise documented, most vImage functions do not work correctly in place.
 *
 *    Performance advisory: If the rowBytes of a vImage_Buffer is a integer power of 2, performance may be adversely
 *    affected on some functions. (This is a side effect of how some machines handle address arithmetic
 *    internally. It is not something we can solve in software, except by setting rowBytes differently. ) 
 *    In some cases, it may also be advantageous to pad rowbytes out to 16 bytes. Using vImageBuffer_Init() 
 *    in vImage/vImage_Utilities.h will help sidestep this issue. It will attempt tune rowBytes to benefit the 
 *    current architecture.
 *
 *    It is not required that you do set up your buffers exactly this way, however. To protect your investment in
 *    preexisting data structures, vImage is designed to work with any (natural) data alignment and any rowBytes.
 *    Floats must be 4 byte aligned. RowBytes must of course be greater than or equal to width * bytesPerPixel.
 *    BytesPerPixel values are as follows:
 *
 *        Buffer Data Format	Size
 *        ------------------	----
 *        planar uint8		    sizeof( Pixel_8)		// 1 byte
 *        planar float		    sizeof( Pixel_F )		// 4 bytes
 *        ARGB uint8			sizeof( Pixel_8888)		// 4 bytes
 *        ARGB float			sizeof( Pixel_FFFF )	// 16 bytes
 *
 *
 *
 *    Tiling / Strip Mining and Multithreading
 *    ----------------------------------------
 *    In general, the size of the data segment that you operate on is critical to the performance of vImage. In
 *    many cases, the number of pixels that may be processed per second can be up to an order of magnitude lower
 *    for large buffers than for small ones.  A common method to fix this is to operate on small chunks of the image
 *    at a time. Typically, you would apply all the filters one after another to one chunk, before going on to the next
 *    chunk. In this way, the data is much more likely to be in the caches when you need it. This motif is easily
 *    multithreaded in principle, since different processors can work on different chunks concurrently in many
 *    cases.
 *
 *    All vImage functions are thread safe and may be called reentrantly.
 *
 *    A quick test to do to see if tiling is good for you is to measure the number of pixels that you can process
 *    per second for very large (>4 MB uncompressed) and reasonably small (< 256 kB uncompressed) images. If the
 *    number of pixels you can process per unit time is much improved for smaller images over large ones then tiling
 *    is likely to be helpful.
 *
 *    It is important to whenever possible make sure the tile fits in the caches. In general, the data processed in
 *    a single tile (including input and output buffers) should be less than 256 kB, though in some cases there may
 *    be a performance advantage to even smaller buffers. We have found that for many, 16-32 kB is a better number.
 *    In many cases, you will only see performance improvement if the tile is significantly wider than it is tall,
 *    for example 16 rows tall and 1024 horizontal bytes of pixels wide has been observed to be twice as fast as
 *    64x128. Clearly having a tile wider than the image isn't very helpful.
 *
 *    A convenience method for making a vImage_Buffer that refers to a rectangular sub-region of another vImage_Buffer:
 *
 *      // Calculate a vImage_Buffer descriptor for a sub-rectangle within an image
 *      // This function does not attempt to ensure that the tile fits in the image.
 *      vImage_Buffer   MyMakeTileFromImage( const vImage_Buffer *image,
 *                                           unsigned long startColumn, // x coordinate of top left corner of tile
 *                                           unsigned long startRow,    // y coordinate of top left corner of tile
 *                                           unsigned long tileHeight,  // number of rows in tile
 *                                           unsigned long tileWidth,   // number of columns in tile
 *                                           size_t pixelBytes ){       // number of bytes in pixel
 *          return (vImage_Buffer){
 *              .data = (void*) ((char*) image->data + startColumn * pixelBytes + startRow * image->rowBytes),
 *              .height = tileHeight,
 *              .width = tileWidth,
 *              .rowBytes = image->rowBytes
 *          };
 *      }
 *
 *    CAUTION:  This will cause vImage to believe the edges of the image are at the edges of the tile. Usually that 
 *              doesn't affect the result, but will for convolultions, morphology operations and geometry operations
 *              --  things that take a edge mode flag.  For such routines, the start of the tile is declared using
 *              a srcOffsetToROI_X/Y  and the size of the tile is inferred from the destination image size.
 *
 *    Sometimes you may want to flip an image vertically. In vImage, this can be done cheaply by adjusting the pointer
 *    to point to the last scanline of the image and setting rowBytes negative, for either the source or destination
 *    image:
 *
 *      static inline vImage_Buffer MyFlipVertical( const vImage_Buffer *b ) __attribute__ ((always_inline,nodebug));
 *      static inline vImage_Buffer MyFlipVertical( const vImage_Buffer *b ){
 *          return (vImage_Buffer){ .data = (void*) ( (char*)b->data + b->rowBytes * (b->height-1)),
 *                                  .height = b->height,
 *                                  .width = b->width,
 *                                  .rowBytes = -b->rowBytes };
 *      }
 *
 *    CAUTION:  While vImage will put up with this sort of abuse, other frameworks may not. Make sure the data is
 *              right side up before passing it to anyone else.
 *
 *    Real Time Applications
 *    ----------------------
 *    vImage attempts to avoid doing things that will damage its suitability for use in real time applications.
 *    vImage will in general never take a lock, or do things that might involve taking a lock, such as allocating
 *    memory. Functions that may take a lock will be documented as such.  Some functions take temporary buffers
 *    as arguments. If you do not provide a temporary buffer, they may call malloc.
 *
 *    Unused Flag Bits
 *    ----------------
 *    Many of the bits in the vImage_Flags datatype are currently unused. Apple reserves all bits in the flags field
 *    for their exclusive use. You must set all unused bits to 0 in the flags field. If you do not do this, in the
 *    future some of these bits may become active and your application may start doing unexpected things when image
 *    processing.
 *
 *    Getting Data in and out of vImage
 *    ---------------------------------
 *    Since vImage will simply use your data in place in your objects, interfacing with your existing image pipeline
 *    should be a simple matter of intializing the vImage_Buffer struct fields to correspond to the location and
 *    and shape of your data.  
 * 
 *    When the objects are not yours and are opaque, then getting data in and out of those objects can be a little
 *    more work.  Most image frameworks have a method to import and export raw data. These are often simple to use
 *    but the data is frequently not in the format you wanted. In such cases, please see vImage/vImage_Utilities.h for
 *    vImageConvert_AnyToAny() which can convert nearly any image format to nearly any other one with full colorspace
 *    conversion, if desired, even on iOS. This should help you convert the output of one imaging library into 
 *    something useful for another one.  (It is used by ImageIO.framework for example, to convert the many different 
 *    image buffer formats produced by PNG, JPEG, GIF, TIFF, etc. to formats more favored by CoreGraphics, CoreAnimation 
 *    and CoreImage, for example.)  The conversions are vectorized and multithreaded to minimize time and energy 
 *    consumption.
 *
 *    If the opaque image object comes from CoreGraphics (CGImageRef) or CoreVideo (CVPixelBufferRef), then high level
 *    convenience routines are provided to import and export data from those sources as vImage_Buffers. See
 *    vImage/vImage_Utilities.h and vImage/vImage_CVUtilities.h respectively for these.  Since the conversions go through
 *    the same vImageConvert_AnyToAny core, it is possible to convert all the way from a YUV 420 format out to CMYK for
 *    a printer in a single function call, or anywhere inbetween, if you want. A few formats like 565 and half float not 
 *    usually part of CG are supported as a bonus.
 *
 *   @/textblock </pre>
 */


// Types, defines, flags and error codes
#include <vImage/vImage_Types.h>

// Alpha compositing, premultiplication, unpremultiplication
#include <vImage/Alpha.h>

// Sharpen, blur, edge detection, deconvolution
#include <vImage/Convolution.h>

// Hundreds of functions to convert from one image format to another.
#include <vImage/Conversion.h>

// Change the shape of an image by resizing it, vertical/horizontal reflect, rotation, shearing and affine warp.
#include <vImage/Geometry.h>

// Get a histogram. Make an image conform to a histogram.
#include <vImage/Histogram.h>

// Reshape structure elements in an image. Enlarge dark or light features. Close holes. Erode thin structures.
#include <vImage/Morphology.h>

// some limited support for PNG encoding
#include <vImage/BasicImageTypes.h>

// Gamma, polynomials, rationals, matrix multiplication (for hue saturation and brightness)
#include <vImage/Transform.h>

// The utility headers providing CG and CV interoperability pull in higher-level system headers that assume
// objective-c support that is not availble unless you are using clang as your compiler.
#if defined __clang__
// Convert any image format to nearly any other one. Exchange data with CGImageRefs
#include <vImage/vImage_Utilities.h>

// Import and export video frames from CVPixelBufferRefs
#include <vImage/vImage_CVUtilities.h>
#endif


#endif /* VIMAGE_H */
                                                                                                                                                                           vImage_CVUtilities.h                                                                                0100644 0001750 0001750 00000240273 12566216025 045042  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/Headers                           /*!
 * @header vImage_CVUtilities.h
 *  vImage.framework
 *
 *  Created by Ian Ollmann on 12/5/13.
 *
 *  See vImage/vImage.h for more on how to view the headerdoc documentation for functions declared herein.
 *
 *  @copyright Copyright (c) 2013-2015 by Apple Inc. All rights reserved.
 *
 *  @discussion vImage_CVUtilities.h provides a suite of high level APIs to facilitate conversion between CVPixelBufferRef
 *  formats and the set of formats describable by CoreGraphics types, including the core formats used by vImage for most
 *  image filters.  The API should support nearly any CoreVideo format or Core Graphics format in a generic (format neutral)
 *  manner.  Conversions by default are color corrected as necessary.  (The recipe for the correction is taken from ColorSync
 *  but vImage does the heavy lifting, usually running from 3-156 times faster.)  High level interfaces are available to 
 *  read/write data directly to/from CVPixelBufferRefs to vImage_Buffers.  Lower level interfaces are provided to allow the
 *  process to be broken apart a bit, to either respond to errors or eliminate redundant calculation. That is, while it is 
 *  expected that the high level interfaces above will work for most, there are two common situation where more work may be required:
 *
 *  Sometimes CVPixelBuffers are missing information attached to them that is needed to convert them to other formats. The vImageCVImageFormatRef
 *  allows you to repair this problem prior to proceeding with conversions using the above high level interfaces or vImageConvert_AnyToAny.
 *  The vImageCVImageFormatRef also provides additional control over how the conversion is done.
 *
 *  In addition, when the same conversion is done repeatedly, such as when converting multiple frames from the same movie, the high level interfaces
 *  presented above may incur some unnecessary overhead because they are redundantly introspecting pixel format and creating/destroying the same
 *  objects over and over. Breaking apart the conversion process into substeps allows you to recycle work from earlier conversions to save time.
 *  Both vImageCVImageFormatRefs and vImageConverterRefs can be reused multiple times, by multiple threads concurrently, if needed.
 *
 *  In addition, please see the various RGB <-> CoreVideo basic conversions are available in vImage/Conversion.h.  These provide direct
 *  access to the fast low level conversions available here. They are useful when you know exactly what formats you are working
 *  with ahead of time and just want to do that with a minimum of fuss.
 *
 * @ignorefuncmacro VIMAGE_NON_NULL
 */
 
#ifndef vImage_CVUtilities_h
/*!
 *  @define vImage_CVUtilities_h
 *  @abstract Preprocessor symbol to make sure the header is only included once. 
 *  @discussion Set vImage_CVUtilities_h to 1 before including Accelerate headers to turn this header off. 
 *              You may wish to do that if the inclusion of CoreVideo/CVPixelBuffer.h is causing problems for your build.
 */
#define vImage_CVUtilities_h 1


#include <vImage/vImage_Utilities.h>
#include <vImage/Conversion.h>
#if defined __ASSERTMACROS__
	/*	If __ASSERTMACROS__ is defined, indicating AssertMacros.h has been
		previously included, simply include <CoreVideo/CVPixelBuffer.h>
		normally.
	*/
	#include <CoreVideo/CVPixelBuffer.h>  /* #define vImage_CVUtilities_h 1 before including Accelerate headers to turn this header off */
#else
	/*	If __ASSERTMACROS__ is not defined, we define it so that AssertMacros.h
		is suppressed while we include <CoreVideo/CVPixelBuffer.h>, and we
		undefine it afterward to restore the prior state.  This works around a
		problem caused by AssertMacros.h defining a "check" symbol, which can
		interfere with clients (source files that include vImage headers) that
		use "check" for their own purposes.
	*/
	#define __ASSERTMACROS__
	#include <CoreVideo/CVPixelBuffer.h>  /* #define vImage_CVUtilities_h 1 before including Accelerate headers to turn this header off */
	#undef __ASSERTMACROS__
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 *   CoreVideo interoperation:
 *     High Level interface
 */
    
    
/*!
 * @functiongroup vImage_Buffer Initialization
 */
    

/*!
 * @function vImageBuffer_InitWithCVPixelBuffer
 *
 * @abstract Initializes a vImage_Buffer to contain a representation of the CVPixelBufferRef provided.
 * @discussion It does the following:
 *
 *  <pre>
 *  @textblock
 *      o   Set buffer->height and buffer->width to match the size of the provided image.
 *
 *      o   set buffer->rowBytes for good performance                               (see kvImageDoNotAllocate flag below)
 *
 *      o   allocate a region of memory and assign a pointer to it to buffer->data  (see kvImageDoNotAllocate flag below)
 *
 *      o   convert the pixels contained in the image to the desired format and write to buffer->data.
 *  @/textblock
 *  </pre>
 *
 *
 * The entire image is converted. If you want to convert less, you can do so using vImageConvert_AnyToAny and a converter prepared with 
 * vImageConverter_CreateForCVToCGImageFormat.
 *
 *      @param buffer           A pointer to a vImage_Buffer structure to be initialized. The height and width fields will be overwritten
 *                              with the size of the CVPixelBuffer. Please see the kvImageDoNotAllocate flag description below for
 *                              options about how the buffer->data and buffer->rowBytes field is handled.
 *
 *      @param desiredFormat    image format for the vImage_Buffer.
 *
 *      @param cvPixelBuffer    A CVPixelBufferRef for the image. It is not necessary to lock the CVPixelBuffer before calling this function.
 *
 *      @param cvImageFormat    An optional vImageCVImageFormatRef to specify the pixel format of the CVPixelBuffer.
 *
 *                                  If NULL, vImage attempts to discover this information automatically from the CVPixelBuffer. However, sometimes
 *                                  necessary color information in the CVPixelBuffer is missing, preventing conversion.  An error will be returned.
 *                                  See kvImageCVImageFormat return codes for this function for more information. To supply vImage with complete
 *                                  color information, provide a complete vImageCVImageFormatRef here.
 *
 *                                  If not NULL, the cvImageFormat is used instead of looking to the CVPixelBufferRef for color information. If the
 *                                  cvImageFormat is also incomplete, a kvImageCVImageFormat_ error code will be returned.
 *
 *      @param backgroundColor  In cases where the vImage_Buffer format specifies opaque alpha and the cvPixelBuffer is has non-opaque alpha, the
 *                              image will be composited against a background color to remove the alpha before writing to the vImage_Buffer. The
 *                              background color is given in the colorspace of the desiredFormat.
 *
 *
 *      @param flags    The following flags are understood by this function:
 *
 *          <pre>
 *          @textblock
 *          kvImageDoNotAllocate        Under normal operation, new memory is allocated to hold the image pixels and its address is written
 *                                      to buffer->data. You are responsible for freeing that data when you are done with it, using free(). 
 *                                      When the kvImageDoNotAllocate flag is set, the buffer->data pointer and buffer->rowBytes is used unmodified.  
 *                                      This is intended to allow you to allocate the buffer yourself, or write directly into part of another image.
 *                                      Use CVPixelBufferGetHeight() and CVPixelBufferGetWidth() to find the size of the result buffer.
 *
 *          kvImageDoNotTile            Disable internal multithreading. This may be desired if you are extracting many
 *                                      such images in parallel, or are otherwise attempting to keep CPU utilization to
 *                                      a single core.
 *
 *          kvImageHighQualityResampling    For some CVPixelBuffer formats, the chroma channels are subsampled. This flag directs
 *                                          vImage to spend extra time where it can to give better image quality.
 *
 *          kvImagePrintDiagnosticsToConsole    In case of an error, print human readable error messages to the Apple System Logger (Console).
 *                                              This is useful for debugging, but probably should not be on for a shipping application.
 *          @/textblock
 *          </pre>
 *
 *  @return
 *          <pre>
 *          @textblock
 *      kvImageMemoryAllocationError            buffer->data was not able to be allocated.
 *
 *      kvImageBufferSizeMismatch               buffer and cvPixelBuffer are not the same height and width
 *
 *      kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
 *
 *      kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
 *
 *      kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the CVPixelBuffer / vImageCVImageFormatRef.
 *
 *      kvImageInvalidParameter                 buffer is NULL
 *
 *      kvImageInvalidImageObject               cvPixelBuffer is NULL or can not be locked
 *
 *      kvImageInvalidImageFormat               desiredFormat is NULL or points to an illegal CG image format
 *
 *      Note: Some CVPixelBuffers have incompletely specified color information. This makes it impossible for vImage to do the conversion.
 *            When this happens, you will get one of the kvImageCVImageFormat_ errors above. To proceed, create a vImageCVImageFormatRef, add
 *            the missing information and pass as the cvImageFormat parameter. It is possible that more than one piece of information is missing.
 *            If the vImageCVImageFormatRef is missing information, then you will also get these errors.
 *          @/textblock
 *          </pre>
 *
 * Returned image notes:
 *
 *      vImage here conforms to CoreVideo practice of substituting gamma 1/1.961 for kCVImageBufferTransferFunction_ITU_R_709_2 and
 *      kCVImageBufferTransferFunction_SMPTE_240M_1995 instead of using the ITU-R BT.709-5 specified transfer function.  You may
 *      manually set the transfer function using vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() and vImageCVImageFormat_SetColorSpace().
 *      vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() does not make this substitution.
 */
vImage_Error vImageBuffer_InitWithCVPixelBuffer( vImage_Buffer *buffer,
                                                 vImage_CGImageFormat *desiredFormat,
                                                 CVPixelBufferRef cvPixelBuffer,
                                                 vImageCVImageFormatRef cvImageFormat,
                                                 const CGFloat *backgroundColor,
                                                 vImage_Flags flags )
                                                 VIMAGE_NON_NULL(1,2,3) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );


/*!
 * @functiongroup vImageBuffer export
 */

/*!
 * @function vImageBuffer_CopyToCVPixelBuffer
 * @abstract Copies the contents of the vImage_Buffer to a CVPixelBufferRef.
 * @discussion If the format of the vImage_Buffer doesn't match the CVPixelBuffer format, the image will be converted to the CVPixelBuffer 
 *              format as part of the copy.
 *
 *  The entire CVPixelBuffer is overwritten. If you want to copy less, you can do so using vImageConvert_AnyToAny and a converter prepared
 *  with vImageConverter_CreateForCFToCVImageFormat.
 *
 *  vImage here conforms to CoreVideo practice of substituting gamma 1/1.961 for kCVImageBufferTransferFunction_ITU_R_709_2 and
 *  kCVImageBufferTransferFunction_SMPTE_240M_1995 instead of using the ITU-R BT.709-5 specified transfer function.  You may
 *  manually set the transfer function using vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() and vImageCVImageFormat_SetColorSpace().
 *  ImageCreateRGBColorSpaceWithPrimariesAndTransferFunction() does not make this substitution.
 *
 *
 *      @param buffer          A pointer to a vImage_Buffer containing the pixels to be copied (converted) to the CVPixelBuffer. May not be NULL.
 *
 *      @param bufferFormat    The format of buffer. May not be NULL.
 *
 *      @param cvPixelBuffer   The CVPixelBufferRef where the image will be written.  It should be a valid, preallocated CVPixelBufferRef
 *                      set to the desired image type (which need not match bufferFormat).  It is not necessary to lock the 
 *                      CVPixelBuffer before calling this function. May not be NULL.
 *
 *      @param cvImageFormat   An optional vImageCVImageFormatRef to specify the pixel format of the CVPixelBuffer.
 *
 *                      If NULL, vImage attempts to discover this information automatically. However, sometimes necessary color information
 *                      in the CVPixelBuffer is missing, preventing conversion.  An error will be returned. See kvImageCVImageFormat return 
 *                      codes for this function for more information. To supply vImage with complete color information, provide a complete 
 *                      vImageCVImageFormatRef here.
 *
 *                      If not NULL, the cvImageFormat is used instead of looking to the CVPixelBufferRef for color information. If the 
 *                      cvImageFormat is also incomplete, a kvImageCVImageFormat_ error code will be returned.
 *
 *                          CAUTION: In this case, it is your responsibility to make sure that the CVPixelBuffer has the right 
 *                                   attachments for matrix, chroma siting and colorspace as necessary to be properly decoded.
 *                                   vImage does not set these things for you.
 *
 *      @param backgroundColor If bufferFormat->bitmapInfo encodes kCGImageAlphaPremultipliedLast, kCGImageAlphaPremultipliedFirst,
 *                      kCGImageAlphaLast or kCGImageAlphaFirst -- that is, has a real alpha channel -- and the CVPixelBuffer
 *                      does not (most CV pixel formats don't) then the image will be flattened against a solid color to remove
 *                      the alpha information. You can select which color that is here. The background color is a CGFloat[3] 
 *                      (red, green, blue) in the RGB colorspace of the CVPixelBuffer. (YpCbCr images reference a RGB colorspace
 *                      through a matrix like ITU-709. That is the RGB colorspace we are talking about here.)  
 *
 *                      This parameter may be NULL, indicating black. 
 *
 *                      If you want to skip flattening, you can substitute in kCGImageAlphaNoneSkipFirst/Last for the encoding of
 *                      the input buffer. This may lead to undesired results in the case of premultiplied alpha however, when alpha 
 *                      is not all either 1.0 or 0. In that case, unpremultiply it first as a separate pass. Unpremultiplication may 
 *                      be more costly than just flattening it, but does not introduce regions of background color into the image.
 *
 *      @param flags           The following flags are understood by this function:
 *
 *          <pre>
 *          @textblock
 *          kvImageNoFlags                      Default operation.
 *
 *          kvImageDoNotTile                    Turn internal multithreading off. This may be helpful in cases where you already have
 *                                              many such operations going concurrently, and in cases where it is desirable to keep
 *                                              CPU utilization to a single core.
 *
 *          kvImageHighQualityResampling        For some CVPixelBuffer formats, the chroma channels are subsampled. This flag directs
 *                                              vImage to spend extra time where it can to give better image quality.
 *
 *          kvImagePrintDiagnosticsToConsole    In case of an error, print human readable error messages to the Apple System Logger (Console).
 *                                              This is useful for debugging, but probably should not be on for a shipping application.
 *          @/textblock
 *          </pre>
 *
 *      @return  
 *          <pre>
 *          @textblock
 *          kvImageNoError                          Success
 *
 *          kvImageInvalidImageFormat               bufferFormat is NULL or encodes an invalid format
 *
 *          kvImageBufferSizeMismatch               buffer and cvPixelBuffer are not the same height and width
 *
 *          kvImageNullPointerArgument              buffer and cvPixelBuffer may not be NULL
 *
 *          kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
 *
 *          kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the CVPixelBuffer / vImageCVImageFormatRef. See note below.
 *
 *          kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the CVPixelBuffer / vImageCVImageFormatRef.
 *          @/textblock
 *          </pre>
 *
 *          Note: Some CVPixelBuffers have incompletely specified color information. This makes it impossible for vImage to do the conversion.
 *            When this happens, you will get one of the kvImageCVImageFormat_ errors above. To proceed, create a vImageCVImageFormatRef, add
 *            the missing information and pass as the cvImageFormat parameter. It is possible that more than one piece of information is missing.
 *
 */
vImage_Error vImageBuffer_CopyToCVPixelBuffer( const vImage_Buffer *buffer,
                                               const vImage_CGImageFormat *bufferFormat,
                                               CVPixelBufferRef cvPixelBuffer,
                                               vImageCVImageFormatRef cvImageFormat,
                                               const CGFloat *backgroundColor,
                                               vImage_Flags flags )
                                               VIMAGE_NON_NULL( 1, 2, 3) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );


/**************************
 *  Low level interfaces: *
 **************************/
    
 
/*!
 * @functiongroup vImageCVImageFormatRef methods
 */
    
/*!
 * @function vImageCVImageFormat_CreateWithCVPixelBuffer
 * @abstract Used to create a vImageCVImageFormatRef to describe the pixel format of an existing CVPixelBufferRef.
 *
 * @discussion If the CVPixelBufferRef has incomplete pixel format information, the vImageCVImageFormatRef will also be incomplete. Not all
 * missing fields ultimately will prove to be necessary, however.  If a function that consumes a vImageCVImageFormatRef returns a
 * vImageCVImageFormatError code, please add the missing information and try again. See "vImageCVImageFormatRef Accessors" below.
 *
 * @param buffer        The CBPixelBufferRef on which to base the vImageCVImageFormatRef
 *
 * @return
 *  On success, a non-NULL vImageCVImageFormatRef is returned. The vImageCVImageFormatRef has a retain count of 1. You are responsible
 *  for releasing it when you are done with it.
 */
vImageCVImageFormatRef vImageCVImageFormat_CreateWithCVPixelBuffer( CVPixelBufferRef buffer )
                                                                    __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );


    
/*!
 * @function vImageCVImageFormat_Create
 * @abstract Create a vImageCVImageFormatRef (low level).
 * @discussion This function creates a vImageCVImageFormatRef from first principles. In most cases, vImageCVImageFormat_CreateWithCVPixelBuffer
 *              is easier, but if your video pipeline doesn't use CoreVideo, or you need absolute control then this is your alternative.
 *
 *              Other fields not given by function parameters like number of channels, channel names, and channel description are automatically 
 *              configured using the imageFormatType. User data is set separately with vImageCVImageFormat_SetUserData.
 *
 *
 * @param imageFormatType       A CVPixelFormatType such as '2vuy'. See CVPixelBuffer.h for the complete list.
 *
 * @param  matrix               A vImage_ARGBToYpCbCrMatrix showing how to convert from RGB to the YpCbCr format. This may be NULL. However, it
 *                              is required for conversions involving YpCbCr images, so for YpCbCr images you will be eventually forced to set the matrix
 *                              using vImageCVImageFormat_CopyConversionMatrix before you can make a vImageConverterRef with this object.  
 *                              There are some predefined conversion matrices in Conversion.h for Rec 601 and 709 formats.
 *
 * @param  cvImageBufferChromaLocation   See kCVImageBufferChromaLocationTopFieldKey in CVImageBuffer.h for a list of chroma locations.
 *                              kCVImageBufferChromaLocation_Center is typical.  This may be NULL. However, for YpCbCr formats with downsampled
 *                              chroma, you will be ultimately forced to set a chroma location using vImageCVImageFormat_SetChromaSiting, before
 *                              a vImageConverterRef can be made with this object.
 *
 * @param  baseColorspace       For RGB and monochrome images, this is the colorspace of the image.
 *
 *                              For YpCbCr images, this is the colorspace of the RGB image before it was converted to YpCbCr using the ARGB-to-YpCbCr
 *                              conversion matrix (see matrix parameter above). The colorspace is defined based on the YpCbCr format RGB primaries
 *                              and transfer function.
 *
 *                              This may be NULL. However, you will eventually be forced to set set a colorspace for all image types, before
 *                              a vImageConvertRef can be made with this object.
 *
 * @param  alphaIsOneHint       Typically this is 0. If your image format has an alpha channel, but you know the image is fully opaque,
 *                              or want it to be treated as opaque, you can set this to 1. This may allow for faster conversions to
 *                              opaque formats.
 *
 *
 * @return
 *   On success, a non-NULL vImageCVImageFormatRef will be returned, which encodes the information contained in the above parameters. The 
 *   vImageCVImageFormatRef has a retain count of 1.  You must release it when you are done with it.
 *
 *   On failure, NULL is returned.
 */
vImageCVImageFormatRef vImageCVImageFormat_Create( uint32_t imageFormatType,                        // see kCVPixelFormatType_ defined in enum in CVPixelBuffer.h
                                                   const vImage_ARGBToYpCbCrMatrix *matrix,         // See also predefined constants in Conversion.h for 601/709/etc.
                                                   CFStringRef cvImageBufferChromaLocation,         // e.g. kCVImageBufferChromaLocation_Center
                                                   CGColorSpaceRef baseColorspace,                  // e.g. CGColorSpaceCreateWithName(kCGColorSpaceSRGB)
                                                   int  alphaIsOneHint                              // Set to 1 if the image has an alpha channel, and all the values in there are opaque. 0 otherwise.
                                                  ) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );


/*!
 *  @function vImageCVImageFormat_Copy
 *  @abstract Makes a copy of a vImageCVImageFormatRef.
 *  @discussion The new vImageCVFormatRef is different from the old one in that:
 *
 *      o       Its reference count is 1
 *
 *      o       The userData field and destructor callback are not copied, and are initialized to NULL.
 *
 *  Usually, it is preferable to simply retain a vImageCVImageFormatRef rather than copy it. You may wish to copy a vImageCVImageFormatRef if
 *  you want to modify an existing vImageCVImageFormatRef but can't because it is being read by another thread, or to replace another software layer's
 *  userData pointer with your own.  By convention, the new vImageCVImageFormatRef is considered to have been created by the software layer that called
 *  vImageCVImageFormat_Copy.
 *
 *  @param format  The vImageCVImageFormatRef to copy.
 *
 *  @return
 *  On success, a non-NULL vImageCVImageFormatRef is returned. Its reference count is 1. You are responsible for releasing it when you are done with it.
 *  On failure, this function returns NULL.
 */
vImageCVImageFormatRef vImageCVImageFormat_Copy( vImageConstCVImageFormatRef format ) VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*!
 * @function vImageCVImageFormat_Retain
 * @abstract Retains a vImageCVImageFormatRef
 * @discussion The vImageCVImageFormatRef follows standard retain/release semantics.
 *
 * vImageCVImageFormat_Retain causes the object's reference count to be incremented.
 *
 * vImageCVImageFormat_Release causes the object's reference count to be decremented. When the reference count reaches 0, 
 * the userDataReleaseCallback (if any) is called, and the object is then destroyed. The userDataReleaseCallback can access 
 * the vImageCVImageFormatRef, but can not prevent vImageCVImageFormatRef destruction. For this reason, the 
 * userDataReleaseCallback should be careful who it hands off control to in case that software layer
 * attempts to retain the vImageCVImageFormatRef. This will result in undefined behavior.
 *
 * @param fmt   The vImageCVImageFormatRef to retain
 *
 * fmt may be NULL, in which case nothing occurs.
 */
void vImageCVImageFormat_Retain( vImageCVImageFormatRef fmt ) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*!
 * @function vImageCVImageFormat_Release
 * @abstract Releases a vImageCVImageFormatRef
 * @discussion The vImageCVImageFormatRef follows standard retain/release semantics.
 *
 * vImageCVImageFormat_Retain causes the object's reference count to be incremented.
 *
 * vImageCVImageFormat_Release causes the object's reference count to be decremented. When the reference count reaches 0,
 * the userDataReleaseCallback (if any) is called, and the object is then destroyed. The userDataReleaseCallback can access
 * the vImageCVImageFormatRef, but can not prevent vImageCVImageFormatRef destruction. For this reason, the
 * userDataReleaseCallback should be careful who it hands off control to in case that software layer
 * attempts to retain the vImageCVImageFormatRef. This will result in undefined behavior.
 *
 * @param fmt   The vImageCVImageFormatRef to release
 *
 * fmt may be NULL, in which case nothing occurs.
 */
void vImageCVImageFormat_Release( vImageCVImageFormatRef fmt ) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*! 
 *  @typedef vImageCVImageFormatError
 *  @abstract  Additional error codes for functions that use the vImageCVImageFormatRef
 *  @discussion It is possible for a vImageCVImageFormatRef to contain incomplete information. This frequently happens 
 *              when it is created from a CVPixelBufferRef which itself has incomplete formatting information. It can
 *              also happen by design as the result of something like vImageCVImageFormat_SetColorSpace(fmt, NULL). When
 *              this occurs, the vImageCVImageFormatRef may not contain enough information to perform a requested conversion
 *              (e.g. vImageBuffer_InitWithCVPixelBuffer). In such cases, a vImageCVImageFormatError will be returned
 *              from the left hand side of the function to indicate which field is absent.
 *
 *  @constant   kvImageCVImageFormat_NoError    No error. The conversion was successfully completed. 
 *
 *  @constant   kvImageCVImageFormat_ConversionMatrix The conversion matrix is absent and required. The conversion matrix
 *              provides the conversion from RGB to Y'CbCr.
 *
 *  @constant   kvImageCVImageFormat_ChromaSiting  The chroma siting information is absent.  Chroma siting indicates the position
 *              of chrominance information relative to luminance samples when chrominance is sub-sampled. 
 *
 *  @constant   kvImageCVImageFormat_ColorSpace The colorspace of the image is missing. If Y'CbCr, this is the colorspace of the
 *              RGB image from which the Y'CbCr pixels were calculated. Otherwise, it is the colorspace of the pixels themselves. 
 *              Most CVPixelBuffer formats only allow one or two colorspace models (e.g. kCGColorSpaceModelRGB)
 *
 *  @constant   kvImageCVImageFormat_VideoChannelDescription    The range and clipping information is missing. This is unlikely
 *              to occur, since the information is initialized automatically based on the imageFormatType (See vImageCVImageFormat_Create.)
 *
 *  @constant   kvImageCVImageFormat_AlphaIsOneHint    The alpha-is-one hint tells vImage that the alpha channel (if any) is opaque.
 *                                                      This hint may be used to avoid some computation to flatten the alpha channel
 *                                                      in some cases. Because it is a hint, it can not be missing.
 */
    
/* Additional error codes for functions that consume a vImageCVImageFormatRef */
typedef VIMAGE_CHOICE_ENUM( vImageCVImageFormatError, ssize_t )
{
    kvImageCVImageFormat_NoError                            VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 )  = 0,
    kvImageCVImageFormat_ConversionMatrix                   VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 )  = -21600,
    kvImageCVImageFormat_ChromaSiting                       VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 )  = -21601,
    kvImageCVImageFormat_ColorSpace                         VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 )  = -21602,
    kvImageCVImageFormat_VideoChannelDescription            VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 )  = -21603,
    kvImageCVImageFormat_AlphaIsOneHint                     VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 )  = -21604,
};

/*!
    @typedef        vImageChannelDescription
    @abstract       A description of the range and clamp limits for a pixel format
    @discussion     The vImageChannelDescription is provided to allow for "video range" formats and detailed
                    control overclamping on a per-channel basis. The min and max control clamping limits. Values 
                    outside the range [min, max] are clamped to be in that range.  The zero and full values give
                    the normal range and bias for the format. They are the encodings for 0.0 and 1.0 respectively.
                    (0.0 and 0.5 for Chroma.)
 
    @field          min     The minimum encoded value allowed. Values less than this encoding are clamped to this value.
    @field          zero    The encoding for the value 0.0.   For example, for 8-bit chroma data this would be 128. For 
                            8-bit full range Luminance, this is 0. 8-bit video range Luminance is 16. 
    @field          full    The encoding for 1.0 (0.5 for chroma). 
    @field          max     The maximum allowed encoding. Values greater than this are clamped to this value.
 
    @seealso        vImage_YpCbCrPixelRange
    @seealso        vImageCVImageFormatRef channel descriptions
 */
    
typedef struct vImageChannelDescription
{
    CGFloat           min;        /* e.g. Minimum allowed value for format. e.g. {16, 16, 16, 0} for {Y', Cb, Cr, A} 8-bit video range                                  */
    CGFloat           zero;       /* e.g. Encoded value for 0.0   e.g. {0, 128, 128, 0} for {Y', Cb, Cr, A} 8-bit video range                                           */
    CGFloat           full;       /* e.g. Encoded value for 1.0, (0.5 for Chroma).  e.g. {235, 240, 240, 255} for {Y', Cb, Cr, A} 8-bit video range, full range alpha   */
    CGFloat           max;        /* e.g. Maximum allowed value for format. e,g, {235, 240, 240, 255} to clamp to {Y', Cb, Cr, A} 8-bit video range, full range alpha   */
                                  /*                                             {0xff, 0xff, 0xff, 0xff} to clamp to full range                                        */
}vImageChannelDescription;
    
/*!
 *  @typedef    vImageMatrixType
 *  @abstract   An enumeration of RGB -> Y'CbCr conversion matrix types. 
 *  @description    Currently, only one matrix type is available. Additional formats are reserved for future expansion.
 *
 *  @constant   kvImageMatrixType_ARGBToYpCbCrMatrix    A vImage_ARGBToYpCbCrMatrix
 */
typedef VIMAGE_CHOICE_ENUM( vImageMatrixType, uint32_t )
{
    /* No matrix required for this format. NULL will be returned. Attempts to set this matrix are ignored. */
    kvImageMatrixType_None                  VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 ) = 0,

    /* A vImage_ARGBToYpCbCrMatrix */
    kvImageMatrixType_ARGBToYpCbCrMatrix    VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 ) = 1,

    /* other values are reserved for future expansion. For example, BT.2020 would probably require a new matrix type for constant luminance. */
};
    
    
/*!
 *  @function vImageCVImageFormat_GetFormatCode
 *  @abstract Return the kCVPixelFormatType_ (4 character code) that encodes the pixel format.
 *  @discussion The kCVPixelFormatType_ of a CoreVideo pixel buffer is given by a four character code (4CC), such as '2vuy'. It describes the number of channels,
 *              channel packing order, bits per component (except in one case), and usually range information like whether it is full range or
 *              video range.
 *  @param format   The vImageCVImageFormatRef for which the 4 character code is desired.
 *  @return  A 4CC in host-endian format.
 *  @seealso See CoreVideo/CVPixelBuffer.h for a list of defined 4 character image type codes.
 */
uint32_t        vImageCVImageFormat_GetFormatCode( vImageConstCVImageFormatRef format )  VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
    
/*!
 *  @function vImageCVImageFormat_GetChannelCount
 *  @abstract Return the the number of color channels in the image, including alpha.
 *  @discussion The channels may be interleaved or planar. For RGBA, the result is 4. For 'yuvs' this is 3. This does not return
 *              the same results as vImageConverter_GetNumberOfSourceBuffers / vImageConverter_GetNumberOfSourceBuffers, which
 *              instead describe the number of vImage_Buffers to pass to vImageConvert_AnyToAny. Some vImage_Buffers contain
 *              multiple channels.
 *  @param format   The vImageCVImageFormatRef for which the number of channels is desired.
 *  @return  A uint32_t containing the number of channels
 */
uint32_t        vImageCVImageFormat_GetChannelCount( vImageConstCVImageFormatRef format)  VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*!
 *  @function vImageCVImageFormat_GetChannelNames
 *  @abstract Get a const kvImageBufferTypeCode_EndOfList-terminated array indicating the names of the channels in the buffer.
 *  @discussion The array is owned by the vImageCvImageFormatRef and will cease to be valid when the object is destroyed. 
 *              This function is not useful to discover the correct vImage_Buffer order for a call to vImageConvert_AnyToAny().
 *  @param format   The vImageCVImageFormatRef for which the channel names are desired.
 *  @return  A const pointer to an array of vImageBufferTypeCodes indicating the names of the channels in the image.
 *  @seealso  vImageConverter_GetSourceBufferOrder
 *  @seealso vImageConverter_GetDestinationBufferOrder
 */
const vImageBufferTypeCode *vImageCVImageFormat_GetChannelNames( vImageConstCVImageFormatRef format)  VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*!
 *  @function vImageCVImageFormat_GetColorSpace
 *  @abstract Get the colorspace associated with the image.
 *  @discussion If the image format is a Y'CbCr image format, this is the RGB colorspace of the image after the inverse 
 *              RGB->YpCbCr conversion matrix is applied. Otherwise, it is the colorspace of the pixels in the image.
 *  @param format   The vImageCVImageFormatRef for which the colorspace is desired.
 *  @return  The colorspace (if any) that is returned is referenced by the vImageCVImageFormatRef and will be released
 *           when that object is destroyed. This function may return NULL, indicating an absence of colorspace information.
 */
CGColorSpaceRef vImageCVImageFormat_GetColorSpace( vImageConstCVImageFormatRef format) VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
    

/*!
 *  @function vImageCVImageFormat_SetColorSpace
 *  @abstract Set the colorspace associated with the image.
 *  @discussion If the image format is a Y'CbCr image format, this sets the RGB colorspace of the image before the
 *              RGB->YpCbCr conversion matrix was applied. Otherwise, it is the colorspace of the pixels in the image.
 *              A non-NULL colorspace must be present before a vImageCVImageFormatRef can be used to do a conversion.
 *  @param format       The vImageCVImageFormatRef for which the colorspace is to be set.
 *  @param colorspace   The new colorspace.  May be NULL, indicating missing colorspace information.
 *  @return  On Success, kvImageNoError. An error will be returned if the colorspace model doesn't match what is expected
 *           for the image format type. For example, a 'RGBA' image must be kCGColorSpaceModelRGB.  Y'CbCr images expect a
 *           RGB colorspace. The new colorspace will be retained and he old one will be released.
 *
 *           On failure, nothing occurs.
 */
vImage_Error    vImageCVImageFormat_SetColorSpace( vImageCVImageFormatRef format, CGColorSpaceRef colorspace ) VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
 
/*!
 *  @function vImageCVImageFormat_GetChromaSiting
 *  @abstract Get the chroma-siting for the image.
 *  @discussion When Y'CbCr images have subsampled chroma, the position of the chroma samples relative to the luminance samples needs to be
 *              specified. Chroma siting information is only needed for Y'CbCr images that are not 444.
 *  @param format       The vImageCVImageFormatRef for which the chroma siting information is desired.
 *  @return  Returns a CFStringRef that describes the positioning of the chroma samples. Eligible string return values are listed 
 *           in CoreVideo/CVImageBuffer.h.   The result is NULL if the chroma siting information is missing.
 *  @seealso kCVImageBufferChromaLocationTopFieldKey
 */
CFStringRef     vImageCVImageFormat_GetChromaSiting( vImageConstCVImageFormatRef format ) VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*!
 *  @function vImageCVImageFormat_SetChromaSiting
 *  @abstract Set the chroma-siting for the image.
 *  @discussion When Y'CbCr images have subsampled chroma, the position of the chroma samples relative to the luminance samples needs to be
 *              specified. Chroma siting information is only needed for Y'CbCr images that are not 444. The new siting name will be retained.
 *              The old siting will be released. This function has no effect for image format types that do not require siting information.
 *  @param format       The vImageCVImageFormatRef for which the chroma siting information is desired.
 *  @param siting       The new siting information for the format. May be NULL.
 *  @return  
 *      <pre>
 *      @textblock
 *          kvImageNoError                  Success
 *
 *          kvImageInvalidImageFormat       format is NULL
 *          
 *          kvImageInvalidParameter         siting is not a recognized CFStringRef from the set of values appearing in CoreVideo/CVImageBuffer.h.
 *      @/textblock
 *      </pre>
 *  @seealso kCVImageBufferChromaLocationTopFieldKey
 */
vImage_Error    vImageCVImageFormat_SetChromaSiting( vImageCVImageFormatRef format, CFStringRef siting) VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
 
/*!
 *  @function vImageCVImageFormat_GetConversionMatrix
 *  @abstract Get the RGB -> Y'CbCr conversion matrix for the image.
 *  @discussion  Y'CbCr images are defined in terms of a RGB image and a conversion matrix from that RGB format to Y'CbCr. 
 *               The conversion frequently has the form:
 *
 *          <pre>
 *          @textblock
 *              Y' =  R_Yp * R  + G_Yp * G + B_Yp * B       Y' = [0, 1.0]
 *              Cb = k0 * (B - Y')                          Cb = [-0.5, 0.5]
 *              Cr = k1 * (R - Y')                          Cr = [-0.5, 0.5]
 *          @/textblock
 *          </pre>
 *
 *      That can be reformulated as a 3x3 matrix operation. The element names here correspond to the fields in the vImage_ARGBToYpCbCrMatrix type:
 *
 *          <pre>
 *          @textblock
 *              | Y' |   | R_Yp        G_Yp     B_Yp      |   | R |
 *              | Cb | = | R_Cb        G_Cb     B_Cb_R_Cr | * | G |
 *              | Cr |   | B_Cb_R_Cr   G_Cr     B_Cr      |   | B |
 *          @/textblock
 *          </pre>
 *
 *      Most Y'CbCr conversion matrices are of this form. However, some conversion matrices, such as that proposed to ITU-R BT.2020 for 
 *      constant luminance, are more complicated.
 *
 *      It is possible for the matrix to be absent. Y'CbCr image types may not be converted without a conversion matrix.
 *
 *  @param format       The vImageCVImageFormatRef for which the matrix is desired
 *  @param outType      A pointer to a variable of type vImageMatrixType.
 *  @return  A pointer to a matrix will be returned from the left hand side of the function. The memory pointed to by outType will be
 *              overwritten with the type of the matrix returned.  The returned matrix may be NULL, indicating an absent matrix.
 *
 *          The matrix is owned by the vImageCvImageFormatRef and will cease to be valid when the vImageCvImageFormatRef is destroyed.
 *
 *  @seealso vImage_ARGBToYpCbCrMatrix and vImageMatrixType
 */
const           void * vImageCVImageFormat_GetConversionMatrix( vImageConstCVImageFormatRef format, vImageMatrixType *outType)  VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

    
/*!
 *  @function vImageCVImageFormat_CopyConversionMatrix
 *  @abstract Set the RGB -> Y'CbCr conversion matrix for the image.
 *  @discussion  matrix is copied to the vImageCVImageFormatRef's internal matrix storage.
 *
 *  Y'CbCr images are defined in terms of a RGB image and a conversion matrix from that RGB format to Y'CbCr.
 *               The conversion frequently has the form:
 *
 *          <pre>
 *          @textblock
 *              Y' =  R_Yp * R  + G_Yp * G + B_Yp * B       Y' = [0, 1.0]
 *              Cb = k0 * (B - Y')                          Cb = [-0.5, 0.5]
 *              Cr = k1 * (R - Y')                          Cr = [-0.5, 0.5]
 *          @/textblock
 *          </pre>
 *
 *      That can be reformulated as a 3x3 matrix operation. The element names here correspond to the fields in the vImage_ARGBToYpCbCrMatrix type:
 *
 *          <pre>
 *          @textblock
 *              | Y' |   | R_Yp        G_Yp     B_Yp      |   | R |
 *              | Cb | = | R_Cb        G_Cb     B_Cb_R_Cr | * | G |
 *              | Cr |   | B_Cb_R_Cr   G_Cr     B_Cr      |   | B |
 *          @/textblock
 *          </pre>
 *
 *      Most Y'CbCr conversion matrices are of this form. However, some conversion matrices, such as that proposed to ITU-R BT.2020 for
 *      constant luminance, are more complicated.
 *
 *      It is possible for the matrix to be absent. Y'CbCr image types may not be converted without a conversion matrix.
 *
 *  @param format       The vImageCVImageFormatRef for which the matrix is desired
 *  @param matrix       The matrix data to be copied to the vImageCVImageFormatRef. If the matrix is a constant predefined by vImage, 
 *                      the address shall be preserved, and returned unmodified by vImageCVImageFormat_GetConversionMatrix.
 *                      The matrix must have a matrix inverse.
 *  @param inType       The type of the matrix. The only type defined for OS X.10 and iOS 8.0 is kvImageMatrixType_ARGBToYpCbCrMatrix, which is a vImage_ARGBToYpCbCrMatrix.
 *
 *  @return  
 *          <pre>
 *          @textblock
 *           kvImageNoError             Success.
 *
 *           kvImageInvalidParameter    The matrix type did not match that required for the image format.
 *
 *           kvImageInvalidParameter    The matrix is not invertible. (See console for log in this case.)
 *          @/textblock
 *          </pre>
 *
 *  @seealso vImage_ARGBToYpCbCrMatrix 
 *  @seealso vImageMatrixType
 */
vImage_Error    vImageCVImageFormat_CopyConversionMatrix(vImageCVImageFormatRef format, const void *matrix, vImageMatrixType inType)  VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*!
 *  @function vImageCVImageFormat_GetAlphaHint
 *  @abstract Get the alpha-is-one hint from a vImageCVImageFormatRef
 *  @discussion  Some image formats have an alpha channel. Sometimes, the alpha channel for the entire image is known to be 1.0 (fully opaque).
 *               In some circumstances, that knowledge can be used to eliminate work from a conversion to make it faster, especially when converting
 *               to a format without an alpha channel.  If the alpha-is-one hint is non-zero, it indicates that the alpha channel is fully opaque. 
 *
 *               Images that do not have an alpha channel will also return non-zero.
 *
 *               There are a few image formats that have room for an alpha channel (kCVPixelFormatType_16BE555, kCVPixelFormatType_16LE555, 
 *               kCVPixelFormatType_30RGB) but which do not have an alpha channel. Setting the alpha-is-one hint to 0 does not add an alpha
 *               channel to these image types. 
 *
 *               The alpha-is-one hint is a hint.  It can not be absent in a way that will prevent conversion. If it is not set or is zero, and 
 *               the image format has alpha, then the alpha channel will be included in the calculation. If the result format has alpha, the alpha
 *               will propagate there. If the result format does not have alpha, the image will be flattened against the indicated background color
 *               for the conversion.
 *
 *  @param format       The vImageCVImageFormatRef for which the colorspace is to be set.
 *  @return  0  Alpha is not known to be opaque, or the hint has not been set.
 *
 *           non-zero  Alpha is known to be fully opaque, even if the values encoded for alpha in the image are not 1.0.
 */
int             vImageCVImageFormat_GetAlphaHint( vImageConstCVImageFormatRef format)  VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
    
/*!
 *  @function vImageCVImageFormat_SetAlphaHint
 *  @abstract Set the alpha-is-one hint for a vImageCVImageFormatRef
 *  @discussion  Some image formats have an alpha channel. Sometimes, the alpha channel for the entire image is known to be 1.0 (fully opaque).
 *               In some circumstances, that knowledge can be used to eliminate work from a conversion to make it faster, especially when converting
 *               to a format without an alpha channel.  If the alpha-is-one hint is non-zero, it indicates that the alpha channel is fully opaque.
 *
 *               The alpha-is-one hint is a hint.  It can not be absent in a way that will prevent conversion. If it is not set or is zero, and
 *               the image format has alpha, then the alpha channel will be included in the calculation. If the result format has alpha, the alpha
 *               will propagate there. If the result format does not have alpha, the image will be flattened against the indicated background color
 *               for the conversion.
 *
 *               There are a few image formats that have room for a small alpha channel (kCVPixelFormatType_16BE555, kCVPixelFormatType_16LE555,
 *               kCVPixelFormatType_30RGB) but which do not have an alpha channel. Setting the alpha-is-one hint to 0 does not add an alpha
 *               channel to these image types.  If this behavior is desired, such image formats can generally be described using a vImage_CGImageFormat.
 *               If so, you can set the vImage_CGImageFormat.bitmap info to an appropriate CGImageAlphaInfo for the desired treatment for the alpha
 *               channel and convert using vImageConverter_CreateWithCGImageFormat() + vImageConvert_AnyToAny().
 *
 *  @param format       The vImageCVImageFormatRef for which the colorspace is to be set.
 *  @parma alphaIsOne   The new value for the alpha-is-one hint.
 *  @return  kvImageNoError             Success.
 *
 *           kvImageInvalidParameter    format is NULL
 */
vImage_Error    vImageCVImageFormat_SetAlphaHint( vImageCVImageFormatRef format, int alphaIsOne)  VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
    
/*!
 *  @function vImageCVImageFormat_GetChannelDescription
 *  @abstract Get the channel description for a particular channel type
 *  @discussion  The channel description gives information about the range of values and clamping for a image color channel.
 *
 *  @param format       The vImageCVImageFormatRef that the channel description is for.
 *  @parma type         The type of the channel that you wish information about. Example: kvImageBufferTypeCode_Luminance
 *  @return  A const pointer to a vImageChannelDescription struct. The data in the structure may not be modified and belongs to the vImageCVImageFormatRef.
 *           It is destroyed when the vImageCVImageFormatRef is destroyed.
 *  @seealso vImageChannelDescription
 */
const           vImageChannelDescription *vImageCVImageFormat_GetChannelDescription( vImageConstCVImageFormatRef format, vImageBufferTypeCode type )
                                                                                    VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
    
/*!
 *  @function vImageCVImageFormat_CopyChannelDescription
 *  @abstract Set the channel description for a particular channel type
 *  @discussion  The channel description gives information about the range of values and clamping for a image color channel.
 *
 *  @param format       The vImageCVImageFormatRef that the channel description is for.
 *  @param desc         A pointer to a new vImageChannelDescription to use for the channel type.  The data is copied into the vImageCVImageFormatRef.
 *  @param type         The type of the channel that you wish to set information about. Example: kvImageBufferTypeCode_Luminance
 *  @return  kvImageNoError     Success
 *
 *           kvImageInvalidParameter    An invalid vImageBufferTypeCode, either out of range, or the channel type does not appear in the image format
 *  @seealso vImageChannelDescription
 */
vImage_Error    vImageCVImageFormat_CopyChannelDescription( vImageCVImageFormatRef format, const vImageChannelDescription *desc, vImageBufferTypeCode type )
                                                            VIMAGE_NON_NULL(1,2) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
    
/*!
 *  @function vImageCVImageFormat_GetUserData
 *  @abstract Get the user info pointer attached to the image format
 *  @discussion  There may be extra information that you wish to attach to a vImageCVImageFormatRef.  It might be a pthread_rwlock_t to help prevent
 *               concurrent access to the vImageCVImageFormatRef while it is being modified, or perhaps additional metadata about the image format 
 *               that you may need later. It may even just a pointer to an object you wrote which wraps the vImageCVImageFormatRef. 
 *
 *               The user data pointer is available for you to use to store a reference to this information. The token is opaque to vImage. vImage
 *               only returns it when asked via vImageCVImageFormat_GetUserData.  It can be set with vImageCVImageFormat_SetUserData.
 *
 *  @param format       The vImageCVImageFormatRef to get the userData from.
 *  @return  The address of the userData. It will be NULL if no userData has been set.
 *  @seealso vImageCVImageFormat_SetUserData
 */
void *          vImageCVImageFormat_GetUserData( vImageConstCVImageFormatRef format)   VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*!
 *  @function vImageCVImageFormat_SetUserData
 *  @abstract  Sets the userData pointer and a userDataReleaseCallback function
 *  @seealso vImageCVImageFormat_SetUserData
 *  @discussion  The userDataReleaseCallback is called when the vImageCVImageFormatRef is destroyed. You may access the vImageCVImageFormatRef
 *               during the callback function. However vImageCVImageFormat_Retain() will not prevent the destruction of the object in that context.
 *               The userDataReleaseCallback will also be called on the previous user data in the event that vImageCVImageFormat_SetUserData
 *               is called to replace one set of user date with another. 
 *
 *              CAUTION: vImage does not attempt to do anything smart when the old and new userData are actually the same or differ only by callback.
 *
 *              vImage does not attempt to free the user data when the vImageCVImageFormatRef is destroyed. If the userData needs to
 *              be freed/released/etc. at this time, then you should do so in your userDataReleaseCallback.
 *
 *              vImageCVImageFormat_SetUserData function is not atomic. vImageCVImageFormat_SetUserData is not safe to call reentrantly.
 *
 *              Since there can be only one userData attached to a vImageCVImageFormatRef, the userData field is reserved by convention
 *              for exclusive use by the app/framework/library that created the vImageCVImageFormatRef.  If you need to attach your own
 *              userData to a vImageCVImageFormatRef that you did not create, make a copy of it with vImageCVImageFormat_Copy.  The new 
 *              copy will not have userData attached to it.
 *
 *  @param format       The vImageCVImageFormatRef to get the userData from.
 *  @param userdata     The new userData pointer.
 *  @return  kvImageNoError - Success
 *
 *           kvImageInvalidImageFormat  -format is NULL
 *  @param     userDataReleaseCallback   The callback that is called when the vImageCVImageFormatRef is destroyed, or when the userData is replaced with
 *                                      another one.
 *  @param     callback_fmt The vImageCVImageFormatRef that the userData is attached to.
 *  @param     callback_userData    The userData field attached to callback_fmt.
 *
 */
vImage_Error    vImageCVImageFormat_SetUserData(vImageCVImageFormatRef format, void * userData, void (*userDataReleaseCallback)(vImageCVImageFormatRef callback_fmt, void *callback_userData) )   VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
    
   
/*! @functiongroup  Low level colorspace initialization */
    
typedef struct vImageTransferFunction
{
    CGFloat c0, c1, c2, c3, gamma;          // R' = c0 * pow( c1 * R + c2, gamma ) + c3,    (R >= cutoff)
    CGFloat cutoff;                         // See immediately above and below.  For no linear region (no below segment), pass -INFINITY here.
    CGFloat c4, c5;                         // R' = c4 * R + c5                             (R < cutoff)
}vImageTransferFunction;

typedef struct vImageRGBPrimaries
{
    float red_x, green_x, blue_x, white_x;
    float red_y, green_y, blue_y, white_y;
}vImageRGBPrimaries;
   
/*!
 * @function vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction
 *
 * @abstract Create a RGB colorspace based on primitives typically found in Y'CbCr specifications
 *
 * @discussion This function may be used to create a CGColorSpaceRef to correspond with a given set of color
 * primaries and transfer function. This defines a RGB colorspace. (A Y'CbCr colorspace is defined as a RGB
 * colorspace and a conversion matrix from RGB to Y'CbCr.) The color primaries give the extent of a colorspace
 * in x,y,z space and the transfer function gives the transformation from linear color to non-linear color that
 * the pixels actually reside in.
 *
 *   <pre>
 *   @textblock
 *      Example:  ITU-R BT.709-5
 *
 *          const vImageTransferFunction f709 =
 *          {  // 1.2 transfer function
 *              .c0 = 1.099,
 *              .c1 = 1.0,
 *              .c2 = 0.0,
 *              .c3 = -0.099,
 *              .gamma = 0.45,
 *              .cutoff = 0.018,
 *              .c4 = 4.5,
 *              .c5 = 0
 *          };
 *
 *          const vImageRGBPrimaries p709 =
 *          {
 *              .red_x = .64,               // 1.3 red
 *              .green_x = .30,             // 1.3 green
 *              .blue_x = .15,              // 1.3 blue
 *              .white_x = 0.3127,          // 1.4 white
 *
 *              .red_y = .33,               // 1.3 red
 *              .green_y = .60,             // 1.3 green
 *              .blue_y = .06,              // 1.3 blue
 *              .white_y = 0.3290           // 1.4 white
 *          };
 *
 *          vImage_Error err = kvImageNoError;
 *          CGColorSpaceRef colorSpace = vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction( &p709, &f709, kvImageNoFlags, &err );
 *          @/textblock
 *          </pre>
 *
 *  Other methods to create a RGB colorspace:
 *
 *      You may find it easier to use CVImageBufferCreateColorSpaceFromAttachments or CVImageBufferGetColorSpace, in some cases.
 *      If there is enough color information attached to a CVPixelBuffer, you can also get one using vImageCVImageFormat_CreateWithCVPixelBuffer().
 *      There are also many ways to create a RGB CGColorSpace in CoreGraphics/CGColorSpace.h.
 *
 *   <pre>
 *   @textblock
 *      Note: This low level function does not conform to CoreVideo practice of automatically substituting gamma 1/1.961
 *      for kCVImageBufferTransferFunction_ITU_R_709_2 and kCVImageBufferTransferFunction_SMPTE_240M_1995 instead of using
 *      the ITU-R BT.709-5 specified transfer function. (vImageBuffer_InitWithCVPixelBuffer and vImageBuffer_CopyToCVPixelBuffer
 *      do.) If you would like that behavior, you can use the following transfer function:
 *
 *      const vImageTransferFunction f709_Apple =
 *      {
 *          .c0 = 1.0,
 *          .c1 = 1.0,
 *          .c2 = 0.0,
 *          .c3 = 0,
 *          .gamma = 1.0/1.961,
 *          .cutoff = -INFINITY,
 *          .c4 = 1,
 *          .c5 = 0
 *      };
 *    @/textblock
 *    </pre>
 *
 *
 *  @param  primaries   A set of x, y tristimulus values to defined the color primaries for the RGB colorspace. Here:
 *
 *          <pre>
 *          @textblock
 *                          x = X/(X+Y+Z),  y = Y/(X+Y+Z)
 *          @/textblock
 *          </pre>
 *
 *                      where X, Y, and Z are from CIEXYZ. z is derived automatically from x and y.
 *  
 *  @param  tf          The transfer function to convert from linear RGB (using above primaries) to non-linear RGB.
 *                      The transfer function here is defined in the style of ITU-R BT.709 and is the inverse
 *                      operation of what appears in a ICC color profile.
 *
 *  @param  flags       Currently the only flag recognized here is  kvImagePrintDiagnosticsToConsole, which may be used to
 *                      debug the colorspace creation when it fails. 
 *
 *  @param  error       May be NULL. If not NULL, a vImage_Error code is written to the memory pointed to by error to
 *                      indicate success or failure of the operation.
 *
 *
 *  @result On success, a non-NULL RGB CGColorSpaceRef will be returned.  The color space has a reference count of 1.
 *          You are responsible for releasing the colorspace when you are done with it to return the memory back
 *          to the system. If error is not NULL, kvImageNoError is written to *error.
 *
 *          On failure, NULL will be returned and one of the following errors is written to *error if error is non-NULL:
 *
 *          <pre>
 *          @textblock
 *          Errors:
 *
 *              kvImageInvalidParameter         tf->gamma = 0       (transfer function is not round-trippable)
 *              kvImageInvalidParameter         primaries define XYZ <-> RGB matrix which is not invertible
 *          @/textblock
 *          </pre>
 *
 *
 */
CGColorSpaceRef vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction( const vImageRGBPrimaries *primaries,
                                                                           const vImageTransferFunction *tf,
                                                                           CGColorRenderingIntent intent,
                                                                           vImage_Flags flags,
                                                                           vImage_Error *error )
                                                                           VIMAGE_NON_NULL(1,2)
                                                                           __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

typedef struct vImageWhitePoint
{
    float white_x;
    float white_y;
}vImageWhitePoint;

CGColorSpaceRef vImageCreateMonochromeColorSpaceWithWhitePointAndTransferFunction( const vImageWhitePoint *whitePoint,
                                                                                  const vImageTransferFunction *tf,
                                                                                  CGColorRenderingIntent intent,
                                                                                  vImage_Flags flags,
                                                                                  vImage_Error *error )
                                                                                VIMAGE_NON_NULL(1,2)
                                                                                __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*! @functiongroup  vImageConverterRef creation */
    
/*!
 *  @function vImageConverter_CreateForCGToCVImageFormat
 *
 *  @abstract Create a vImageConverterRef that converts a CoreGraphics formatted image to CoreVideo formatted image
 *
 *  @discussion  This creates a vImageConverterRef which may be used with vImageConvert_AnyToAny to convert a
 *              CoreGraphics formatted image, as described by a vImage_CGImageFormat to CV image data, the format of 
 *              which is given by a vImageCVImageFormatRef.
 *
 *
 *  @param  srcFormat       The vImage_CGImageFormat that describes the pixel format associated with the source image buffers.
 *
 *  @param  destFormat      The vImageCVImageFormatRef that describes the pixel format associated with the destination buffers.
 *
 *  @param  backgroundColor In cases where the source format has an alpha channel and the destination does not (or is kCGImageAlphaNoneSkipFirst/Last)
 *                               the conversion will remove the alpha channel by flattening it against an opaque background color. The background color
 *                               is given as CGFloat[3] {red, green, blue} (sRGB).
 *
 *  @param  flags           The following flags are honored:
 *
 *          <pre>
 *          @textblock
 *              kvImagePrintDiagnosticsToConsole    cause extra information to be sent to Apple System Logger (Console) in case of failure
 *
 *              kvImageHighQualityResampling        In some cases, chroma may have to be up or downsampled as part of the conversion
 *                                                  When this flag bit is set, it instructs the converter to spend extra time to achieve better
 *                                                  image quality.
 *
 *              kvImageDoNotTile                    Disable multithreading in the conversion step when this converter is used with vImageConvert_AnyToAny.
 *          @/textblock
 *          </pre>
 *
 *
 *  @param  error           An optional pointer to a vImage_Error in which the returned error code is written.  
 *                          Error be NULL, in which case no error value will be written.
 *          
 *
 *  @result On success, a non-NULL vImageConverteRef will be returned, suitable for use with vImageConvert_AnyToAny(). If
 *          error is non-NULL, kvImageNoError will be written to *error, indicating success. You must release the 
 *          vImageConverterRef when you are done with it, to return its resources to the system.  It has a reference count of 1.
 *
 *          On failure, a NULL vImageConverteRef will be returned. If error is non-NULL, an error code will be written to 
 *          *error.  Some possible error values:
 *          
 *          <pre>
 *          @textblock
 *          kvImageNoError                      Success. No error occurred. A non-NULL vImageConverterRef will be returned.
 *
 *          kvImageInternalError                Your usage was likely correct, but something appears to be very wrong inside
 *                                              vImage. Please file a bug, with a reproducible example of this failure. Please
 *                                              also try the kvImagePrintDiagnosticsToConsole flag for more information.
 *
 *          kvImageInvalidImageFormat           The vImage_CGImageFormat is invalid. kvImagePrintDiagnosticsToConsole may provide
 *                                              more information.
 *
 *          kvImageInvalidCVImageFormat         The vImageCVImageFormatRef is invalid. Probably, the vImageCVImageFormatRef is
 *                                              incomplete. This can happen when a vImageCVImageFormatRef is created from a 
 *                                              CVPixelBufferRef and that itself has incomplete conversion information. Please 
 *                                              see "vImageCVImageFormatRef Repair" above. kvImagePrintDiagnosticsToConsole
 *                                              may provide more information.
 *
 *          kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the vImageCVImageFormatRef. Please add one.
 *          kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the vImageCVImageFormatRef. Please add.
 *          kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the vImageCVImageFormatRef.
 *          @/textblock
 *          </pre>
 *
 *  @seealso    vImageBuffer_InitForCopyToCVPixelBuffer When converting from CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains multiple data planes which are in turn represented by multiple vImage_Buffers.
 *  @seealso    vImageConverter_GetDestinationBufferOrder for manual ordering information
 */
    
 vImageConverterRef vImageConverter_CreateForCGToCVImageFormat( const vImage_CGImageFormat *srcFormat,
                                                                vImageCVImageFormatRef destFormat,
                                                                const CGFloat *backgroundColor,
                                                                vImage_Flags flags,
                                                                vImage_Error *error )
                                                                VIMAGE_NON_NULL(1,2)
                                                                __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
/*!
 *  @function vImageConverter_CreateForCVToCGImageFormat
 *
 *  @abstract Create a vImageConverterRef that converts a CoreVideo formatted image to a CoreGraphics formatted image
 *
 *  @discussion  This creates a vImageConverterRef which may be used with vImageConvert_AnyToAny to do conversions of
 *              CV image data, as described by a vImageCVImageFormatRef to CoreGraphics formatted image data, as 
 *              described by a vImage_CGImageFormat.
 *
 *
 *  @param  srcFormat       The vImageCVImageFormatRef that describes the pixel format associated with the source image buffers.
 *
 *  @param  destFormat      The vImage_CGImageFormat that describes the pixel format associated with the destination buffers.
 *
 *  @param  backgroundColor In cases where the source format has an alpha channel and the destination does not (or is kCGImageAlphaNoneSkipFirst/Last)
 *                               the conversion will remove the alpha channel by flattening it against an opaque background color. The background color
 *                               is given as CGFloat[3] {red, green, blue} (sRGB).
 *
 *  @param  flags           The following flags are honored:
 *
 *          <pre>
 *          @textblock
 *              kvImagePrintDiagnosticsToConsole    cause extra information to be sent to Apple System Logger (Console) in case of failure
 *
 *              kvImageHighQualityResampling        In some cases, chroma may have to be up or downsampled as part of the conversion
 *                                                  When this flag bit is set, it instructs the converter to spend extra time to achieve better
 *                                                  image quality.
 *
 *              kvImageDoNotTile                    Disable multithreading in the conversion step when this converter is used with vImageConvert_AnyToAny.
 *          @/textblock
 *          </pre>
 *
 *
 *  @param  error           An optional pointer to a vImage_Error in which the returned error code is written.
 *                          Error be NULL, in which case no error value will be written.
 *
 *
 *  @result On success, a non-NULL vImageConverteRef will be returned, suitable for use with vImageConvert_AnyToAny(). If
 *          error is non-NULL, kvImageNoError will be written to *error, indicating success. You must release the
 *          vImageConverterRef when you are done with it, to return its resources to the system.  It has a reference count of 1.
 *
 *          On failure, a NULL vImageConverteRef will be returned. If error is non-NULL, an error code will be written to
 *          *error.  Some possible error values:
 *
 *          <pre>
 *          @textblock
 *          kvImageNoError                      Success. No error occurred. A non-NULL vImageConverterRef will be returned.
 *
 *          kvImageInternalError                Your usage was likely correct, but something appears to be very wrong inside
 *                                              vImage. Please file a bug, with a reproducible example of this failure. Please
 *                                              also try the kvImagePrintDiagnosticsToConsole flag for more information.
 *
 *          kvImageInvalidImageFormat           The vImage_CGImageFormat is invalid. kvImagePrintDiagnosticsToConsole may provide
 *                                              more information.
 *
 *          kvImageInvalidCVImageFormat         The vImageCVImageFormatRef is invalid. Probably, the vImageCVImageFormatRef is
 *                                              incomplete. This can happen when a vImageCVImageFormatRef is created from a
 *                                              CVPixelBufferRef and that itself has incomplete conversion information. Please
 *                                              see "vImageCVImageFormatRef Repair" above. kvImagePrintDiagnosticsToConsole
 *                                              may provide more information.
 *
 *          kvImageCVImageFormat_ConversionMatrix   The conversion matrix is missing from the vImageCVImageFormatRef. Please add one.
 *          kvImageCVImageFormat_ChromaSiting       The chroma siting info is missing from the vImageCVImageFormatRef. Please add.
 *          kvImageCVImageFormat_ColorSpace         The colorspace containing primaries and transfer function is missing from the vImageCVImageFormatRef.
 *          @/textblock
 *          </pre>
 *
 *  @seealso    vImageBuffer_InitForCopyFromCVPixelBuffer When converting from CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains multiple data planes which are in turn represented by multiple vImage_Buffers.
 *  @seealso    vImageConverter_GetSourceBufferOrder for manual ordering information
 */
vImageConverterRef vImageConverter_CreateForCVToCGImageFormat( vImageCVImageFormatRef srcFormat,
                                                               const vImage_CGImageFormat *destFormat,
                                                               const CGFloat *backgroundColor,
                                                               vImage_Flags flags,
                                                               vImage_Error *error )
                                                               VIMAGE_NON_NULL(1,2)
                                                               __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

 
/*! @functiongroup  vImage_Buffer Initialization */
    

/*!
 * @function vImageBuffer_InitForCopyToCVPixelBuffer
 *
 * @abstract Initialize an array of vImage_Buffers in the right order to convert a image to a CV formatted image
 *
 * @discussion When converting to CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains 
 * multiple data planes which are in turn represented by multiple vImage_Buffers. (These are passed in as an array 
 * of vImage_Buffers to vImageConvert_AnyToAny().)  To make it easier to order the buffers correctly, we provide
 * vImageBuffer_InitForCopyToCVPixelBuffer, which initializes an array vImage_Buffer structs  in the order expected by
 * vImageConvert_AnyToAny. With appropriate flags, the conversion can be made to occur directly into the CVPixelBufferRef 
 * backing store.
 *
 * You are responsible for updating any missing / incorrect color information in the pixelBuffer after writing to it.
 *
 * @param buffers   A pointer to an array of vImage_Buffer structs to be overwritten. The buffers will be initialized 
 *                  in the correct order for use with vImageConvert_AnyToAny and the provided converter. On entry, 
 *                  buffers must point to a valid region of memory of size no smaller than number_of_buffers * 
 *                  sizeof(vImage_Buffer). The number_of_buffers is given by vImageConverter_GetNumberOfDestinationBuffers.
 *                  The buffers pointer may not be NULL.
 *
 * @param converter The converter that will be used to do the conversion.  May not be NULL.
 *
 * @param pixelBuffer   A locked (use CVPixelBufferLockBaseAddress) CVPixelBufferRef.
 *
 * @param  flags    kvImageNoAllocate must be used.  The following flags are allowed:
 *
 *          <pre>
 *          @textblock
 *              kvImageNoFlags                      Default operation.
 *
 *              kvImagePrintDiagnosticsToConsole    Print diagnostic messages to the console in the event an error occurs
 *
 *              kvImageNoAllocate                   Instructs the function to initialized the buffers to directly write to a
 *                                                  locked CVPixelBufferRef. You  may unlock the CVPixelBufferRef after 
 *                                                  vImageConvert_AnyToAny has returned. Once the pixelBuffer is unlocked, 
 *                                                  the vImage_Buffers initialized by this function are no longer valid and 
 *                                                  must be reinitialized.
 *
 *          @/textblock
 *          </pre>
 *
 * @return  The following error codes may be returned:
 *
 *          <pre>
 *          @textblock
 *      kvImageNoError                  Success
 *
 *      kvImageNullPointerArgument      buffers is NULL.
 *      kvImageNullPointerArgument      converter is NULL.
 *
 *      kvImageInvalidParameter         pixelBuffer is not NULL but kvImageNoAllocate was not passed in flags. See pixelBuffer description above.
 *
 *      kvImageUnknownFlagsBit          An unknown / unhandled flags bit was set in flags.
 *
 *      kvImageInternalError            Something is very wrong inside vImage. This shouldn't happen. Please file a bug, along with a 
 *                                      reproducible failure case.
 *          @/textblock
 *          </pre>
 *
 * @seealso ImageConverter_GetDestinationBufferOrder for another method to initialize the vImage_Buffers in the right order for vImageConvert_AnyToAny.
 *
 */
vImage_Error vImageBuffer_InitForCopyToCVPixelBuffer( vImage_Buffer *buffers,
                                                      const vImageConverterRef converter,
                                                      const CVPixelBufferRef pixelBuffer,
                                                      vImage_Flags flags )
                                                      VIMAGE_NON_NULL(1,2,3)
                                                      __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*!
 * @function vImageBuffer_InitForCopyFromCVPixelBuffer
 *
 * @abstract Initialize an array of vImage_Buffers in the right order to convert CV formatted image to another image format
 *
 * @discussion When converting from CVPixelBuffer types with vImageConvert_AnyToAny, the CV format sometimes contains
 * multiple data planes which are in turn represented by multiple vImage_Buffers. (These are passed in as an array
 * of vImage_Buffers to vImageConvert_AnyToAny().)  To make it easier to order the buffers correctly, we provide
 * vImageBuffer_InitForCopyFromCVPixelBuffer, which initializes an array vImage_Buffer structs  in the order expected by
 * vImageConvert_AnyToAny. With appropriate flags, the conversion can be made to occur directly from the CVPixelBufferRef
 * backing store.
 *
 * @param buffers   A pointer to an array of vImage_Buffer structs to be read. The buffers will be initialized
 *                  in the correct order for use with vImageConvert_AnyToAny and the provided converter. On entry,
 *                  buffers must point to a valid region of memory of size no smaller than number_of_buffers *
 *                  sizeof(vImage_Buffer). The number_of_buffers is given by vImageConverter_GetNumberOfSourceBuffers.
 *                  The buffers pointer may not be NULL.
 *
 * @param converter The converter that will be used to do the conversion.  May not be NULL.
 *
 * @param pixelBuffer   A locked (use CVPixelBufferLockBaseAddress) CVPixelBufferRef.
 *
 * @param  flags    kvImageNoAllocate must be used. The following flags are allowed:
 *
 *          <pre>
 *          @textblock
 *              kvImageNoFlags                      Default operation.
 *
 *              kvImagePrintDiagnosticsToConsole    Print diagnostic messages to the console in the event an error occurs
 *
 *              kvImageNoAllocate                   Instructs the function to initialized the buffers to directly read from a
 *                                                  locked CVPixelBufferRef. You  may unlock the CVPixelBufferRef after
 *                                                  vImageConvert_AnyToAny has returned. Once the pixelBuffer is unlocked,
 *                                                  the vImage_Buffers initialized by this function are no longer valid and
 *                                                  must be reinitialized.
 *
 *          @/textblock
 *          </pre>
 *
 * @return  The following error codes may be returned:
 *
 *          <pre>
 *          @textblock
 *      kvImageNoError                  Success
 *
 *      kvImageNullPointerArgument      buffers is NULL.
 *      kvImageNullPointerArgument      converter is NULL.
 *
 *      kvImageInvalidParameter         pixelBuffer is not NULL but kvImageNoAllocate was not passed in flags. See pixelBuffer description above.
 *
 *      kvImageUnknownFlagsBit          An unknown / unhandled flags bit was set in flags.
 *
 *      kvImageInternalError            Something is very wrong inside vImage. This shouldn't happen. Please file a bug, along with a
 *                                      reproducible failure case.
 *          @/textblock
 *          </pre>
 *
 * @seealso  vImageConverter_GetSourceBufferOrder vImageConverter_GetSourceBufferOrder for another method to initialize the vImage_Buffers in the right order for vImageConvert_AnyToAny.
 *
 */
vImage_Error vImageBuffer_InitForCopyFromCVPixelBuffer( vImage_Buffer *buffers,
                                                        const vImageConverterRef converter,
                                                        const CVPixelBufferRef pixelBuffer,
                                                        vImage_Flags flags )
                                                        VIMAGE_NON_NULL(1,2,3)
                                                        __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );



#ifdef __cplusplus
    }
#endif


#endif  /* vImage_vImage_CVUtilities_h */
                                                                                                                                                                                                                                                                                                                                     vImage_Types.h                                                                                      0100644 0001750 0001750 00000150632 12566216025 043741  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/Headers                           /*!
 *  @header vImage_Types.h
 *  vImage_Framework
 *
 *  See vImage/vImage.h for more on how to view the headerdoc documentation for types declared herein.
 *
 *  @copyright Copyright (c) 2002-2015 by Apple Inc. All rights reserved.
 *
 *  @discussion     Defines various types and constants common to vImage.
 */

#ifndef VIMAGE_TYPES_H
#define VIMAGE_TYPES_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <unistd.h>
#include <Availability.h>

/*!
 *  @define     __has_attribute
 *  @abstract   Compiler attribute detection
 *  @discussion A macro for testing whether your compiler supports a particular clang attribute.
 *  @noParse
 */

#ifndef __has_attribute          /* clang will define this. Other compilers maybe not. */
    #define __has_attribute(a)   0
#endif
    
/*!
 *  @define     VIMAGE_NON_NULL
 *  @abstract   Enumerates which parameters may not be NULL.
 *  @discussion Macro to use to decorate API for sanity checking. Many vImage pointer operands may not be NULL.
 *  @noParse
 *  @ignorefuncmacro VIMAGE_NON_NULL
 */
#if __has_attribute(nonnull)
#   define VIMAGE_NON_NULL(...)         __attribute__ ((nonnull(__VA_ARGS__)))
#else
#   define VIMAGE_NON_NULL(...)
#endif

/*!
 *  @define     __has_feature
 *  @abstract   Compiler feature detection
 *  @discussion A macro for testing whether your compiler supports a particular clang feature.
 *  @noParse
 */

#ifndef __has_feature           /* clang will define this. Other compilers maybe not. */
#   define __has_feature(f)     0
#endif
#ifndef __has_extension         /* clang will define this. Other compilers maybe not. */
#   define __has_extension(e)   0
#endif

/*!
 *  @define     CF_BRIDGED_TYPE
 *  @abstract   CoreFoundation definition detection and aliasing.
 *  @discussion A macro for annotating structs bridging to CoreFoundation types.
 *  @noParse
 */
#ifndef CF_BRIDGED_TYPE
#   if __has_feature(objc_bridge_id)
#       define CF_BRIDGED_TYPE(...) __attribute__((objc_bridge(__VA_ARGS__)))
#   else
#       define CF_BRIDGED_TYPE(...)
#   endif
#endif
    

    /* The C++'11 strongly typed enum feature turns out to be not exactly what we want because it precludes doing things like kvImageLeaveAlphaUnchanged | kvImageCopyInPlace */
    /* We are still exploring options to deliver something better than what we have today for enums. */
#if 0 /*(__cplusplus && __cplusplus >= 201103L && (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus && __has_feature(objc_fixed_enum))*/
#   define VIMAGE_CHOICE_ENUM( _name, _type)        enum _name : _type _name; enum _name : _type
#   define VIMAGE_OPTIONS_ENUM(_name, _type)        enum _name : _type _name; enum _name : _type
#else
#   define VIMAGE_CHOICE_ENUM( _name, _type)        _type _name; enum
#   define VIMAGE_OPTIONS_ENUM( _name, _type)       _type _name; enum      
#endif

/*!
 *  @availabilitymacro VIMAGE_ENUM_AVAILABLE_STARTING
 */
    
#if __has_extension(enumerator_attributes)
#   ifdef __IPHONE_OS_VERSION_MIN_REQUIRED
#       define VIMAGE_ENUM_AVAILABLE_STARTING(_osx, _ios) __AVAILABILITY_INTERNAL##_ios
#   elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
#       define VIMAGE_ENUM_AVAILABLE_STARTING(_osx, _ios) __AVAILABILITY_INTERNAL##_osx
#   else
#       define VIMAGE_ENUM_AVAILABLE_STARTING(_osx, _ios)
#   endif
#else
#   define VIMAGE_ENUM_AVAILABLE_STARTING( _a, _b )
#endif

/* Please see vImage.h and vImage documentation for the meaning of these types. */

/*!
    @typedef vImagePixelCount
    @discussion A number of pixels.  Typically, this is the height or width of an image.
 */

typedef unsigned long   vImagePixelCount;       /* Pedantic: A number of pixels. For LP64 (ppc64/x86_64) this is a 64-bit quantity.  */

    
/*!
    @typedef vImage_Buffer
    @field  data        A pointer to the top left corner of the buffer contain image pixels.
    @field  height      The number of pixels in a column of the image. 
    @field  width       The number of visible pixels in a row of an image (excluding padding at the ends of rows)
    @field  rowBytes    The number of bytes from a pixel to the next pixel down in the same column.
    @discussion The vImage_Buffer describes a rectangular region within a regular array of pixels. It may describe
                the entire image, or just a sub rectangle of it.  The vImage_Buffer struct is not a complete description
                of an image. Other aspects like pixel format, color space, channel ordering, etc. are generally given
                by the names of functions that operate on the vImage_Buffer or by parameters passed to those functions.
                A vImage_Buffer may contain multiple color channels interleaved with one another, or a single color channel
                (or alpha) as a planar buffer.  vImage_Buffers are often initialized directly by you, by setting fields
                to appropriate values to point to image data you already own. Convenience methods are also available as
                vImageBuffer_Init, vImageBuffer_InitWithCGImage and vImageBuffer_InitWithCVPixelBuffer
 */
    

typedef struct vImage_Buffer
{
    void                *data;        /* Pointer to the top left pixel of the buffer.    */
    vImagePixelCount    height;       /* The height (in pixels) of the buffer        */
    vImagePixelCount    width;        /* The width (in pixels) of the buffer         */
    size_t              rowBytes;     /* The number of bytes in a pixel row, including any unused space between one row and the next. */
}vImage_Buffer;



/*!
    @typedef vImage_AffineTransform
    @field  a        top left cell in 3x2 transform matrix
    @field  b        top right cell in 3x2 transform matrix
    @field  c        middle left cell in 3x2 transform matrix
    @field  d        middle right cell in 3x2 transform matrix
    @field  tx       The x coordinate translation
    @field  ty       The y coordinate translation
    @discussion      This 3x2 matrix generally operates the same as the CGAffineTransform, except that the fields
                     are all float, not CGFloat. If you are looking for CGAffineTransform compatibility, it is 
                     recommended that you use vImage_CGAffineTransform and associated APIs instead.
 */
 
typedef struct vImage_AffineTransform
{
    float         a, b, c, d;
    float         tx, ty;
}vImage_AffineTransform;

/*!
  @typedef vImage_AffineTransform_Double
  @field  a        top left cell in 3x2 transform matrix
  @field  b        top right cell in 3x2 transform matrix
  @field  c        middle left cell in 3x2 transform matrix
  @field  d        middle right cell in 3x2 transform matrix
  @field  tx       The x coordinate translation
  @field  ty       The y coordinate translation
  @discussion      This 3x2 matrix generally operates the same as the CGAffineTransform, except that the fields
                    are all double precision, not CGFloat. If you are looking for CGAffineTransform compatibility, it is
                    recommended that you use vImage_CGAffineTransform and associated APIs instead.
*/

     
#ifndef VIMAGE_AFFINETRANSFORM_DOUBLE_IS_AVAILABLE
    #define VIMAGE_AFFINETRANSFORM_DOUBLE_IS_AVAILABLE      1     /* defined if vImage_AffineTransform_Double type is available. undefined otherwise */
    typedef struct vImage_AffineTransform_Double 
    {
        double         a, b, c, d;
        double         tx, ty;
    }vImage_AffineTransform_Double;
#endif

 /*!
  @typedef vImage_CGAffineTransform
  @field  a        top left cell in 3x2 transform matrix
  @field  b        top right cell in 3x2 transform matrix
  @field  c        middle left cell in 3x2 transform matrix
  @field  d        middle right cell in 3x2 transform matrix
  @field  tx       The x coordinate translation
  @field  ty       The y coordinate translation
  @discussion      This type mirrors the CGAffineTransform type, and may be used interchangeably with it.
  @seealso         CGAffineTransform utilities in CoreGraphics/CGAffineTransform.h
  */
#if VIMAGE_AFFINETRANSFORM_DOUBLE_IS_AVAILABLE       /* Interfaces that use this are only available on MacOS X.6 and later */
    #define VIMAGE_CGAFFINETRANSFORM_IS_AVAILABLE			1
    #if defined( __LP64__ )
        typedef    vImage_AffineTransform_Double    vImage_CGAffineTransform;
    #else
        typedef    vImage_AffineTransform           vImage_CGAffineTransform;    
    #endif
#endif

/*!
 @typedef   Pixel_8
 @abstract   An 8-bit per component unsigned planar pixel value.
*/
typedef uint8_t     Pixel_8;            /* 8 bit planar pixel value */

/*!
 @typedef   Pixel_F
 @abstract   A single precision floating-point planar pixel value.
 @discussion Typically, these have range [0,1] though other values are generally allowed.
*/
typedef float       Pixel_F;            /* floating point planar pixel value */
  
/*!
 @typedef   Pixel_8888
 @abstract  A four channel, 8-bit per channel pixel.
 @discussion The channel order is generally given by the function that consumes the value.
 */
typedef uint8_t     Pixel_8888[4];      /* ARGB interleaved (8 bit/channel) pixel value. uint8_t[4] = { alpha, red, green, blue } */
 
/*!
 @typedef   Pixel_FFFF
 @abstract  A four channel, single precision floating-point per channel pixel. 
 @discussion The channel order is generally given by the function that consumes the value.
 */
typedef float       Pixel_FFFF[4];      /* ARGB interleaved (floating point) pixel value. float[4] = { alpha, red, green, blue } */
 
/*!
 @typedef   Pixel_16U
 @abstract  A 16-bit per channel unsigned pixel.  
 @discussion Typical range is [0,USHRT_MAX] meaning [0.0, 1.0], though most functions tolerate other ranges.
*/
typedef uint16_t    Pixel_16U;          /* 16 bit unsigned pixel */

/*!
 @typedef   Pixel_16S
 @abstract  A 16-bit per channel signed pixel.  
 @discussion Typical range is [SHRT_MIN,SHRT_MAX] meaning [-1.0, 1.0], though most functions tolerate other ranges.
*/
typedef int16_t     Pixel_16S;          /* 16 bit signed pixel */

/*!
 @typedef   Pixel_16Q12
 @abstract  A signed 16 bit fixed point number with 12 bits of fractional precision.
 @discussion Normal range is [-4096,4096] meaning [-1.0, 1.0]. Values in the range [-8.0, 8.0) are representable.
 */
typedef int16_t     Pixel_16Q12;          /* 16 bit signed pixel */

/*!
 @typedef   Pixel_ARGB_16U
 @abstract  A four channel, 16-bit unsigned per channel pixel.  
 @discussion The channel order is generally given by the function that consumes the value. It is not necessarily ARGB.
 */
typedef uint16_t    Pixel_ARGB_16U[4];  /* four-channel 16-bit unsigned pixel */

/*!
 @typedef   Pixel_ARGB_16S
 @abstract  A four channel, 16-bit signed per channel pixel.  
 @discussion The channel order is generally given by the function that consumes the value. It is not necessarily ARGB.
*/
typedef int16_t     Pixel_ARGB_16S[4];  /* four-channel 16-bit signed pixel */

/*!
 @typedef ResamplingFilter
 @abstract A ResamplingFilter is an opaque structure used by vImage to hold precalculated filter coefficients for a resampling filter,
             such as a Lanczos or Gaussian resampling filter. 
 @discussion It is created with vImageNewResamplingFilter or vImageNewResamplingFilterUsingBuffer and is consumed by various vertical 
             and horizontal shear functions in vImage/Geometry.h. When possible, for better performance, reuse ResamplingFilters over 
             multiple vImage calls, instead of allocating a new one each time.
*/
    
typedef void*       ResamplingFilter;   /* Used by certain Geometry functions.  */

    
/*!
 @typedef GammaFunction
 @discussion A GammaFunction is an opaque structure used by vImage to represent an approximation of a non-linear curve. It is created with
             vImageCreateGammaFunction, and destroyed with vImageDestroyGammaFunction. When possible, for better performance,
             reuse GammaFunctions over multiple vImage function calls, instead of creating a new one each time.
 */
    
typedef void*       GammaFunction;      /* Used by vImageGamma                  */

/* vImage Errors                                                                                */
/* ============                                                                                 */
/*   All return values < 0 indicate failure. In this case, the results in the destination       */
/*   buffer are undefined. The list of error codes may grow in the future.                      */
/*                                                                                              */
/*   Note: It is also possible for positive non-zero numbers to be returned out the LHS of a    */
/*   vImage function. This happens when the kvImageGetTempBufferSize bit is set in the flags.   */
/*   In this case, no work is done by the vImage function.  The value returned is the size of   */
/*   the temp buffer needed by the function.                                                    */
/*!
     @typedef   vImage_Error 
     @abstract  An error code returned by a vImage function.
     @discussion    All negative values are errors.
                    Positive return values are likely to be the result of kvImageGetTempBufferSize.
                    Zero indicates no error, or quasi-ambiguously a zero temp buffer size, if that
                    flag was passed. Please see the documentation for the function that returned the
                    error code for additional information about the error.
 
    @constant   kvImageNoError      Success.  If kvImageGetTempBufferSize is set in flags, then
                                    it indicates the temp buffer size is 0 and the function did
                                    nothing else.
    @constant   kvImageRoiLargerThanInputBuffer     The size or positioning of the result buffer 
                                    was such that pixels were needed in the source buffer, were
                                    found to be missing and could not be discovered using an edging
                                    process like kvImageEdgeExtend. Typically, this means that the
                                    source image was smaller than the destination image. 
    @constant   kvImageInvalidKernelSize    The size of a kernel was invalid. Typically, kernels have
                                    have an odd number of rows and columns. The kernel might also have
                                    been too large or of zero dimension. Typically only returned by
                                    convolutions and morphological operations.
 
    @constant   kvImageInvalidEdgeStyle   The edging style {kvImageBackgroundColorFill, kvImageCopyInPlace, kvImageEdgeExtend, kvImageTruncateKernel}
                                    was invalid. Typically, the edging style is either missing or the edging style 
                                    is not supported by this function.
 
    @constant   kvImageInvalidOffset_X   Some functions take an integer offset in the horizontal dimension. This indicates
                                    how far from the left edge of the vImage_Buffer we shoud consider the origin to be.
                                    The offset allows real pixel data to be used where an edging method like kvImageEdgeExtend
                                    might otherwise have to be used to generate missing pixels. An X offset is essential to
                                    obtaining correct results for tiled image processing when the tile is not at the left
                                    edge of the (whole) image and the function has a kernel or ResamplingFilter.
                                    Typically, this can happen when the offset is negative or larger than the source vImage_Buffer.width.
 
    @constant   kvImageInvalidOffset_Y   Some functions take an integer offset in the vertical dimension. This indicates
                                    how far from the top edge of the vImage_Buffer we shoud consider the origin to be.
                                    The offset allows real pixel data to be used where an edging method like kvImageEdgeExtend
                                    might otherwise have to be used to generate missing pixels. A Y offset is essential to
                                    obtaining correct results for tiled image processing when the tile is not at the top
                                    edge of the (whole) image and the function has a kernel or ResamplingFilter.
                                    Typically, this can happen when the offset is negative or larger than the source vImage_Buffer.height.
 
    @constant   kvImageMemoryAllocationError    vImage attempted to allocate memory and the allocator failed, returning NULL.
 
    @constant   kvImageNullPointerArgument      One or more arguments to the function are NULL, which are not allowed to be NULL.
                                    Typically, arguments that are not allowed to be NULL are listed in the VIMAGE_NON_NULL() attribute
                                    that follows the function declaration.
 
    @constant   kvImageInvalidParameter         A function parameter has an invalid value. This is the fallback error code when there is not
                                    an error code that more precisely describes the invalid parameter value such as kvImageNullPointerArgument,
                                    kvImageInvalidEdgeStyle, kvImageInvalidRowBytes, etc.
 
    @constant   kvImageBufferSizeMismatch       This most often occurs when a set of planar buffers are not the same size.  Most often
                                    this occurs when the destination image is planar and the destination planes are not the same size.
                                    It may also occur in rare cases when chunk sizes mismatch for some high level conversions.
 
    @constant   kvImageUnknownFlagsBit      A bit in the flags field is set, which the function does not understand or currently support.
                                    Please check flags enum availability info to make sure the flag is supported on the target OS revision.
 
    @constant   kvImageInternalError    A serious error occured inside vImage, which prevented vImage from continuing. This error is
                                    probably a problem with vImage itself, and not how it is being used. Please file a bug with a
                                    reproducible test case attached, if possible!
 
    @constant   kvImageInvalidRowBytes  The vImage_Buffer.rowBytes field is invalid. In some circumstances, rowBytes of 0 is not supported, 
                                    particularly with destination images or when vImage is asked to initialize a vImage_Buffer and the
                                    rowBytes is too small to hold a row of image data.
 
    @constant   kvImageInvalidImageFormat  Usually a vImage_CGImageFormat or vImageCVImageFormatRef contains an invalid format. It might be a
                                    NULL pointer, a description which is not allowed according to rules of CG or CV image format encodings.
 
    @constant   kvImageColorSyncIsAbsent    ColorSync.framework is completely missing. Certain operations will not work.
 
    @constant   kvImageOutOfPlaceOperationRequired   The source images and destination images may not alias the same image data. This will
                                    be returned by vImageCGConverter_MustOperateOutOfPlace(). However, there are many functions in vImage
                                    that do not work in place which do not check to see if the buffers overlap. Please inspect the documentation
                                    of each function for notes on in-place usage before using them that way.
 
    @constant   kvImageInvalidImageObject   An invalid CGImageRef or CVPixelBufferRef was passed to the function.  Typically, the object was NULL.
                                    A non-NULL invalid CGImageRef or CVPixelBufferRef will result in undefined behavior.
 
    @constant   kvImageInvalidCVImageFormat A vImageCVImageFormatRef contains an invalid format. It might be a NULL pointer, or an image format
                                    which is not allowed according to rules of CV image format encodings.
 
    @constant   kvImageUnsupportedConversion    Some lower level conversion APIs only support conversion among a sparse matrix of image formats.
 */
typedef VIMAGE_CHOICE_ENUM(vImage_Error, ssize_t)
{
    kvImageNoError                      =    0,
    kvImageRoiLargerThanInputBuffer     =    -21766,
    kvImageInvalidKernelSize            =    -21767,
    kvImageInvalidEdgeStyle             =    -21768,
    kvImageInvalidOffset_X              =    -21769,
    kvImageInvalidOffset_Y              =    -21770,
    kvImageMemoryAllocationError        =    -21771,
    kvImageNullPointerArgument          =    -21772,
    kvImageInvalidParameter             =    -21773,
    kvImageBufferSizeMismatch           =    -21774,
    kvImageUnknownFlagsBit              =    -21775,
    kvImageInternalError                =    -21776,    /* Should never see this. File a bug! */
    kvImageInvalidRowBytes              =    -21777,
    kvImageInvalidImageFormat           =    -21778,
    kvImageColorSyncIsAbsent            =    -21779,
    kvImageOutOfPlaceOperationRequired  =    -21780,
    kvImageInvalidImageObject           =    -21781,
    kvImageInvalidCVImageFormat         =    -21782,
    kvImageUnsupportedConversion        =    -21783,
    kvImageCoreVideoIsAbsent            =    -21784,
};
    
/* vImage Flags                                                                                 */
/* ============                                                                                 */
/* The values here indicate bits in a vImage_Flags bit field.                                   */
/* Other bits are reserved for future use.                                                      */
/* Some flags are mutually exclusive. You can not have more                                     */
/* than one bit from this set set at the same time:                                             */
/* { kvImageCopyInPlace, kvImageBackgroundColorFill, kvImageEdgeExtend, kvImageTruncateKernel } */
/* all unused flags bits must be set to 0                                                       */
/* Not all flags are allowed by all functions.                                                  */
/*!
 @typedef   vImage_Flags
 @abstract      vImage_Flags is a 32-bit bitfield of options of general use to vImage functions.
 @discussion    Multiple bits may be set concurrently. kvImageUnknownFlagsBit may be returned by
                a function if a flag bit is set (1) but the function does not know what the flag
                bit means (e.g. your new code on an older version of vImage) or if the flag should
                cause a behavior that is unsupported by the function, for example, kvImageHighQualityResampling
                to a function that does not do image resampling.
 @constant  kvImageNoFlags   Use the default behavior. Internal multithreading is enabled. Debug 
                messages are generally not printed to the console. No edging method is specified. 
                Normal quality resampling methods are used (Lanczos3, probably). Do the function,
                instead of returning a temp buffer size. Allocate memory as needed.
 
 @constant  kvImageLeaveAlphaUnchanged   Some functions that operate on ARGB data in place allow
                you to operate on just the RGB components and leave the alpha channel unmodified.
                These are typically histogram and gamma functions.
 
 @constant  kvImageCopyInPlace  One of four edging modes. This one tells vImage to do nothing for
                destination pixels that need source pixels that are missing. The corresponding source
                pixel is copied to the destination image. This is only used for image filters that take a
                kernel, such as convolutions. It is not allowed for Morphology filters.
 
 @constant kvImageBackgroundColorFill  One of four edging modes. This one tells vImage to use the
                backgroundColor parameter of the function as the color of any missing pixels in
                a source image. Missing pixels occur when a filter needs to read off the edge of
                a source image. 
 
 @constant kvImageEdgeExtend    One of four edging modes.  This one tells vImage to use the nearest
                existing source image pixel when it needs source data but finds it needs a non-existant
                pixel off the edge of the provided source image. 
 
 @constant kvImageDoNotTile     Do not internally subdivide the image for processing on multiple CPUs
                or other compute devices. If this flag is set, the function will run single threaded
                on the current thread. Usually this flag may be expected to cause a significant increase
                in the execution time of a vImage function. However, if you are calling the function
                from a heavily multithreaded context (such as your own tiling engine) and CPU occupancy
                is high, this may lead to small performance improvements due to reduced CPU contention.
 
 @constant kvImageHighQualityResampling  Use a more expensive image resampling method than what is available
                by default. Typically this is Lanczos5. Note that as vImage resampling already leans towards
                quality over performance -- the GPU texture unit is your friend if you just want raw performance
                -- the additional quality from kvImageHighQualityResampling may be difficult to see in some images. 
                It is best suited to background rendering tasks.
 
 @constant kvImageTruncateKernel    One of four edging modes. This one tells vImage to use only the pixels it 
                has and reweight the kernel accordingly. The reweighting process can be expensive.  It can 
                also lead to difficulties if a contiguous sub-rectangle of the kernel sums to zero. In this
                case, the area of the kernel is zero and you have formally asked vImage to do division by zero,
                in which case vImage behavior is undefined.
 
 @constant kvImageGetTempBufferSize  Instead of performing the function requested, return (as a vImage_Error)
                the size of the temp buffer requried by the function for this set of parameters. The image pixels
                are not touched. If the function does not take a temp buffer, then 0 will be returned and the 
                function will do nothing. Some functions may return a 0 sized temp buffer for some sets of parameters 
                an not others. The size of the temporary buffer may change for different parameters, and for
                different OS revisions.
 
 @constant kvImagePrintDiagnosticsToConsole Some of the high level functions in vImage_Utilities.h and 
                vImage_CVUtilities.h have complex failure modes that could prove baffling with just a 
                error code return.  This flag instructions these functions to also print a human readable
                diagnostic message to the Apple System Logger when an error is encountered. The output 
                should be visible in Console.app.
 
 @constant kvImageNoAllocate    Some vImage functions may allocate memory, possibly returning it to you.
                This flag instructs the function to use the memory provided instead. For example, instead of
                overwriting vImage_Buffer.data with a newly allocated pointer to memory, use the memory
                pointed to by vImage_Buffer.data directly. In other cases, it may cause the function to
                assume ownership of a buffer, rather than allocating a copy. You are responsible for making
                sure the buffer that you allocate instead of vImage is large enough to hold the image. Most 
                vImage functions do not allocate memory and assume that vImage_Buffer.data is already allocated, 
                and in the case of source image buffers, contain valid pixel data.
 
 @constant kvImageHDRContent    The pixels described in the input image may contain high dymanic range content.
                HDR pixels may have value outside of [-2,2.0]. This flag is generally only applicable to 
                floating-point images. Most 8- and 16-bit pixels can not represent values outside [0,1] and
                functions that operate on 16Q12 formats are designed to operate over the full range of [-8,8).
                Most floating-point functions in vImage are linear in behavior and so work equally well 
                on any float.  Some non-linear functions like polynomials (or by extension colorspace conversion)
                are only valid over a limited range (typically [-2,2]) and will return incorrect answers 
                for values outside that range.  In addition, certain IIR or FFT algorithms in convolution may
                encounter precision issues with HDR content.  For these cases, if you know you have HDR content,
                pass kvImageHDRContent and a (typically slower) alternative method will be used for these
                sources.
 */
typedef VIMAGE_OPTIONS_ENUM(vImage_Flags, uint32_t)
{
    kvImageNoFlags                                                                                  =    0,
    
     /* Operate on red, green and blue channels only. Alpha is copied from source 
        to destination. For Interleaved formats only. */
    kvImageLeaveAlphaUnchanged       VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 )     =    1,    
    
     /* Copy edge pixels. Convolution Only. */
    kvImageCopyInPlace               VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 )     =    2,
    
    /* Use the background color for missing pixels. */
    kvImageBackgroundColorFill       VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 )     =    4,
    
    /* Use the nearest pixel for missing pixels. */
    kvImageEdgeExtend                VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 )     =    8,
    
    /* Pass to turn off internal tiling and disable internal multithreading. Use this if 
       you want to do your own tiling, or to use the Min/Max filters in place. */
    kvImageDoNotTile                 VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 )     =   16,
    
    /* Use a higher quality, slower resampling filter for Geometry operations 
       (shear, scale, rotate, affine transform, etc.) */
    kvImageHighQualityResampling     VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_3, __IPHONE_5_0 )     =   32,
    
     /* Use only the part of the kernel that overlaps the image. For integer kernels, 
        real_divisor = divisor * (sum of used kernel elements) / (sum of kernel elements). 
        This should preserve image brightness at the edges. Convolution only. */
    kvImageTruncateKernel            VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 )     =   64,
    
    /* The function will return the number of bytes required for the temp buffer. 
       If this value is negative, it is an error, per standard usage. */
    kvImageGetTempBufferSize         VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_4, __IPHONE_5_0 )     =  128,
    
    /* Some functions such as vImageConverter_CreateWithCGImageFormat have so many possible error conditions 
       that developers may need more help than a simple error code to diagnose problems. When this 
       flag is set and an error is encountered, an informative error message will be logged to the Apple 
       System Logger (ASL).  The output should be visible in Console.app. */
    kvImagePrintDiagnosticsToConsole VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 )     =  256,
    
    /* Pass this flag to prevent vImage from allocating additional storage. */
    kvImageNoAllocate                VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 )     =  512,

    /* Use methods that are HDR-aware, capable of providing correct results for input images with pixel values
       outside the otherwise limited (typically [-2,2]) range. This may be slower. */
    kvImageHDRContent                VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_11, __IPHONE_9_0 )    =  1024
};
    
/*!
    @class vImageConverterRef
    @abstract   An opaque type which contains a decription of a conversion from one CoreGraphics image format to another.
 
    @discussion The vImageConverter is an opaque type which contains information needed to do a rapid conversion from
    one image type to another. Sometimes, it can take a significant amount of time to figure out how to convert
    from one format to another. It wouldn't be good to do that redundantly for a bunch of small images. The
    vImageConversionSetup allows us to set up the conversion once and reuse the information many times, to
    keep net latencies low.
 
    Note that creating a vImageConverter can at times take a while. While usually it is quick, it might have
    to do things like load other frameworks in the system (e.g. Colorsync) if they are not loaded already,
    or build a lookup table. It is a good idea to setup your conversions in advance and reuse the conversion
    objects.  The objects are thread safe. You can use the same object in multiple threads concurrently. They
    follow standard retain / release semantics and can be used as CFTypeRefs.
 
    @superclass CFTypeRef
 
    @seealso Please see vImage_Utilities.h for interfaces that operate on the vImageConverterRef
 */

typedef struct CF_BRIDGED_TYPE(id) vImageConverter * vImageConverterRef;

    
/*!
    @class vImageCVImageFormatRef
    @abstract   An opaque type which contains a decription of a conversion from a CoreGraphics image format to a CVPixelBuffer, or the reverse.
 
    @superclass CFTypeRef
    @discussion The vImageCVImageFormatRef describes how the image is encoded in a CVPixelBufferRef. vImage uses this information to construct converters that
    are capable of converting to and from this image encoding.  The format stores a description of the pixels in the image (planar/color representation/
    bit depth/number of channels, etc.) but not the image size, location of the base pointer or rowbytes. It is intended for the vImageCVImageFormatRef
    to be reused for other CVPixelBufferRefs of the same format, such as other frames from the same movie.
 
    vImageCVImageFormatRefs are capable of holding an incomplete encoding representation. You may be required to provide addition information such
    as colorspace and (YCbCr only) chroma siting or conversion matrix before the vImageCVImageFormatRef can be used for image conversion to other
    formats.
 
    The vImageCVImageFormatRef is a CFTypeRef. CFEqual does not test for equivalence of the userData field. You should use vImageCVImageFormat_Retain/Release
    when working with vImageCVImageFormatRef to manage ownership of the object.

        <pre>
        @textblock
        Thread Safety:

            The vImageCVImageFormatRef may be safely read from multiple threads concurrently.  However,
            it makes no attempt to keep its internal state coherent when multiple threads write to it,
            or when one thread writes to it while one or more threads are reading from it at the same
            time. This can be trivially handled by keeping the knowledge of the vImageCVImageFormatRef
            limited to a single thread while it is being created / configured and then treat it as
            immutable thereafter.  If necessary, you can also use a read/write lock to limit reentrant
            access.
        @/textblock
        </pre>
 
 
    Information tracked by vImageCVImageFormatRef:
 
 <pre>
 @textblock
    imageFormatType     A CVPixelFormatType such as '2vuy'. See CVPixelBuffer.h for the complete list.
 
    number_of_channels  How many  color + alpha channels are encoded in the image. An alpha channel is included in this count
                        if it takes up space in the image, even if its value is described always 1.0, for example by /Last
                        kCGImageAlphaNoneSkipFirst or kCVImageBufferAlphaChannelIsOpaque.  This field is automatically initialized
                        based on the imageFormatType (see above) and is never missing.
 
    channel_names       A list of vImageBufferTypeCodes corresponding to the channels in the image. Unlike what happens for
                        vImageConverterRefs, the type codes used here always encode a single color channel.  vImageConverterRefs
                        use the channel names to encode what is in each vImage_Buffer. Here it is used to describe each channel.
                        So, an ARGB buffer might be described as kvImageBufferTypeCode_CGFormat but will be described as
                        { kvImageBufferTypeCode_RGB_Red, kvImageBufferTypeCode_RGB_Green, kvImageBufferTypeCode_RGB_Blue,
                        kvImageBufferTypeCode_Alpha, kvImageBufferTypeCode_EndOfList }. The order of the channels in the list
                        may not match the order of the channels in the buffer.  This field is automatically initialized based on
                        the imageFormatType (see above) and is never missing.
 
   matrix               (YpCbCr only.)  A YpCbCr image has an associated 3x3 matrix that encodes how it was converted to YpCbCr from
                        a reference RGB colorspace (see colorspace below). The matrix is encoded as a NULL pointer when missing.
                        This field is ignored for non-YpCbCr formats.
 
 
   chroma_siting        Some YpCbCr formats store their chroma components as a smaller image than the luminance component.
                        This describes where the subsampled chroma samples are positioned relative to the luminance component.
                        This field is encoded as a NULL CFStringRef when missing. The field is ignored for RGB, monochrome,
                        indexed and 4:4:4 YpCbCr image formats.
 
   colorspace           For RGB, indexed and grayscale images, this is the colorspace that describes the image encoding.
                        For YpCbCr images, this is the colorspace of the RGB image that you get once the matrix (see above)
                        is unapplied. Thus, the colorspace encodes for the underlying primaries and transfer function of the
                        YpCbCr image. See also vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction.  This field is required
                        for all image formats. A colorspace of NULL indicates a missing colorspace. (This is inconsistent with
                        the shorthand used in vImage_Utilities.h where NULL maps to sRGB.)  Since vImage has no concept of
                        a current graphics device, deviceRGB maps to sRGB and device gray maps to gray 2.2. If you wish to
                        ensure no color correction / conversion, you should match this colorspace with the one in the
                        vImage_CGImageFormat to / from which you are converting.
 
   channel_description  Some CVPixelBuffer formats do not use the entire representable range of the format to encode image data.
                        For example, a 'yuvs' "video range" buffer only uses the range [16,235] for luminance and [16,240] for
                        chroma. Values outside that range are considered to have value equal to the nearest in-range value. In
                        addition, we add additionional fields to leave open the possibility that some formats can encode information
                        outside of the traditional [0,1.0] range ([-1.0,1.0] for chroma) so reference values for the encoding for 0
                        and 1.0 are also described. (See vImageChannelDescription below.) The zero/one fields are analogous in function
                        to the decode arrays provided by CG. It is possible to use the channel description to create formats that are
                        not correctly understood by CoreVideo. These are provided to allow for interoperation with custom video formats.
                        The channel description is initialized automatically for known image format types (see imageFormatType above)
                        and probably only very rarely needs to be changed. It is never missing.
 
  alpha_is_one_hint     Some images are encoded with an alpha channel. However, you may have additional information that the image is
                        really completely opaque. The "alpha is one hint" tells vImage that the alpha channel is always 1.0 (opaque)
                        across the entire image. Setting the hint to 1 may allow vImage to avoid work and run faster in some cases.
                        There is no vImageCVImageFormatRef representation for premultiplied alpha, currently. Since it is a hint,
                        the hint may never be missing from a vImageCVImageFormatRef.  The hint is ignored for image formats that do
                        not contain an alpha channel.
 
  user_data             The vImageCVImageFormatRef has a userData field to allow you to easily reference your data starting from
                        a handle to the object. vImage does  not attempt to interact with the memory pointed to by the userData
                        pointer. It simply holds on to the pointer for you and will call a destructor callback function when the
                        vImageCVImageFormatRef to allow you to free that memory, and do any other post processing needed when the
                        vImageCVImageFormatRef is destroyed. Since there is only one userData pointer, by convention its use is
                        considered private to the application/library/framework that created the vImageCVImageFormatRef, including
                        cases where the creator does not set the userData field. If you need to attach your own data to a
                        vImageCVImageFormatRef created by someone else, you can make  a copy of it or wrap it with your own object.
 @/textblock
 </pre>
 
    @seealso Please see vImage_CVUtilities.h for interfaces that operate on the vImageCVImageFormatRef
 */
typedef struct CF_BRIDGED_TYPE(id) vImageCVImageFormat * vImageCVImageFormatRef;
typedef const struct CF_BRIDGED_TYPE(id) vImageCVImageFormat * vImageConstCVImageFormatRef;



/*!
    @typedef    vImageARGBType
    @abstract   An encoding of an image format type to be used with RGB <-> Y'CbCr conversions in vImage/Conversions.h
    @discussion These formats enumerate different vImage ARGB pixel formats.
 */
typedef enum
{
        kvImageARGB8888   VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 )        = 0,   /* Any 8-bit four channel interleaved buffer [0,255]=[0,1.0]. Does not specify channel order. */
        kvImageARGB16U    VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 )        = 1,   /* Any 16-bit unsigned four channel interleaved buffer [0,65535]=[0,1.0]. Does not specify channel order. */
        kvImageARGB16Q12  VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 )        = 2    /* Any 16-bit signed fixedpoint four channel interleaved buffer [0,4096]=[0,1.0]. Does not specify channel order.  */
}vImageARGBType;
    
/*!
    @typedef    vImageYpCbCrType
    @abstract   An encoding of an image format type to be used with RGB <-> Y'CbCr conversions in vImage/Conversions.h
    @discussion These formats enumerate different vImage/CoreVideo Y'CbCr pixel formats.
    @seealso    CVPixelBuffer OSTypes in CVPixelBuffer.h
 */
typedef enum
{
        kvImage422CbYpCrYp8                  VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 0,   /* 2vuy        */
        kvImage422YpCbYpCr8                  VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 1,   /* yuvs / yuvf */
        kvImage422CbYpCrYp8_AA8              VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 2,   /* a2vy        */
        kvImage420Yp8_Cb8_Cr8                VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 3,   /* y420 / f420 */
        kvImage420Yp8_CbCr8                  VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 4,   /* 420v / 420f */
        kvImage444AYpCbCr8                   VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 5,   /* r408 / y408 */
        kvImage444CrYpCb8                    VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 6,   /* v308        */
        kvImage444CbYpCrA8                   VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 7,   /* v408        */
        kvImage444CrYpCb10                   VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 8,   /* v410        */
        kvImage422CrYpCbYpCbYpCbYpCrYpCrYp10 VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 9,   /* v210        */
        kvImage422CbYpCrYp16                 VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 13,  /* v216 16-bit */
        kvImage444AYpCbCr16                  VIMAGE_ENUM_AVAILABLE_STARTING( __MAC_10_0, __IPHONE_8_0 ) = 14   /* y416        */
}vImageYpCbCrType;
    

/*!
 @struct    vImage_YpCbCrToARGBMatrix
 
 @field Yp      matrix[0][0].  Typically 1.
 @field Cr_R    matrix[0][2].
 @field Cb_G    matrix[1][1].
 @field Cr_G    matrix[1][2].
 @field Cb_B    matrix[2][1]
 
 @abstract   A 3x3 converson matrix for converting Y'CbCr signals to RGB
 @discussion The matrix is sparse. The 3x3 matrix is given by:
 
            <pre>
            @textblock
                    | R |   | Yp    0     Cr_R |   | Y' |
                    | G | = | Yp   Cb_G   Cr_G | * | Cb |
                    | B |   | Yp   Cb_B     0  |   | Cr |
            @/textblock
            </pre>
 
            Limits on the range of the fields in the matrix may apply.
 
 @seealso    vImage_ARGBToYpCbCrMatrix, which is the inverse matrix
 */

/* Input information into vImageConvert_YpCbCrToARGB_GenerateConversion() */
typedef struct vImage_YpCbCrToARGBMatrix
{
        float                      Yp;
        float                      Cr_R;
        float                      Cr_G;
        float                      Cb_G;
        float                      Cb_B;
}vImage_YpCbCrToARGBMatrix;
 
/*! @const      kvImage_YpCbCrToARGBMatrix_ITU_R_601_4
    @abstract   Y'CbCr->RGB conversion matrix for ITU-Recommendation BT.601-4 */
extern const vImage_YpCbCrToARGBMatrix *kvImage_YpCbCrToARGBMatrix_ITU_R_601_4 __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*! @const      kvImage_YpCbCrToARGBMatrix_ITU_R_709_2
    @abstract   Y'CbCr->RGB conversion matrix for ITU-Recommendation BT.709-2 */
extern const vImage_YpCbCrToARGBMatrix *kvImage_YpCbCrToARGBMatrix_ITU_R_709_2 __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

    
    
    
/*!
 @typedef    vImage_YpCbCrToARGB
 @abstract   An opaque representation of a 3x3 converson matrix for converting Y'CbCr signals to RGB.
             It is used to do the actual conversions. Please attempt to reuse these rather than making
             new ones each time.
 @discussion The representation also includes the range of the input and output pixels from the matrix and
             clamping information.
 
 @seealso    vImage_ARGBToYpCbCr, which is the inverse matrix
 */

typedef struct vImage_YpCbCrToARGB
{
        uint8_t __attribute__ ((__aligned__(16))) opaque[128];
}vImage_YpCbCrToARGB;
    
/*!
 @typedef    vImage_ARGBToYpCbCrMatrix
 @abstract   A 3x3 converson matrix for converting RGB signals to Y'CbCr
 @discussion The matrix has one repeating parameter. The 3x3 matrix is given by:
 
 @textblock
        | Y' |   | R_Yp        G_Yp  B_Yp      |   | R |
        | Cb | = | R_Cb        G_Cb  B_Cb_R_Cr | * | G |
        | Cr |   | B_Cb_R_Cr   G_Cr  B_Cr      |   | B |
 @/textblock
 
 Typically, these matrix coefficients come from a conversion of form:
 
 @textblock
    Y' = R_Yp * R + G_Yp * G + B_Yp * B         0 <= Y' <= 1
    Cb = k0 * (B - Y')                          -0.5 <= Cb <= 0.5
    Cr = k1 * (R - Y')                          -0.5 <= Cr <= 0.5
 @/textblock
 
 {R_Yp, G_Yp, B_Yp} are typically derived from the perceived brightness for red, green and blue.
 k0 and k1 are typically scaled so that Cb and Cr have the indicated range. Because of these
 relationships, {R_Yp, G_Yp, B_Yp} are usually positive, and B_Cb_R_Cr is usually 0.5.
 Limits on the range of the fields in the matrix may apply.
 @field R_Yp    matrix[0][0]
 @field G_Yp    matrix[0][1]
 @field B_Yp    matrix[0][2]
 @field R_Cb    matrix[1][0]
 @field G_Cb    matrix[1][1]
 @field B_Cb_R_Cr matrix[1][2] and matrix[2][0]
 @field G_Cr    matrix[2][1]
 @field B_Cr    matrix[2][2]
 @seealso    vImage_YpCbCrToARGBMatrix, which is the inverse matrix
 
 */
/* Input information into vImageConvert_ARGBToYpCbCr_GenerateConversion() */
typedef struct vImage_ARGBToYpCbCrMatrix
{
        float                      R_Yp;
        float                      G_Yp;
        float                      B_Yp;
        float                      R_Cb;
        float                      G_Cb;
        float                      B_Cb_R_Cr;
        float                      G_Cr;
        float                      B_Cr;
}vImage_ARGBToYpCbCrMatrix;

/*! @const      kvImage_ARGBToYpCbCrMatrix_ITU_R_601_4
    @abstract   RGB->Y'CbCr conversion matrix for ITU-Recommendation BT.601-4 */
extern const vImage_ARGBToYpCbCrMatrix *kvImage_ARGBToYpCbCrMatrix_ITU_R_601_4 __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*! @const      kvImage_ARGBToYpCbCrMatrix_ITU_R_709_2
    @abstract   RGB->Y'CbCr conversion matrix for ITU-Recommendation BT.709-2 */
extern const vImage_ARGBToYpCbCrMatrix *kvImage_ARGBToYpCbCrMatrix_ITU_R_709_2 __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
    
/*!
 @typedef    vImage_ARGBToYpCbCr
 @abstract   An opaque representation of a 3x3 converson matrix for converting RGB signals to Y'CbCr.
 It is used to do the actual conversions. Please attempt to reuse these rather than making
 new ones each time.
 @discussion The representation also includes the range of the input and output pixels from the matrix and
 clamping information.
 
 @seealso    vImage_ARGBToYpCbCr, which is the inverse matrix
 */
typedef struct vImage_ARGBToYpCbCr
{
        uint8_t __attribute__ ((__aligned__(16))) opaque[128];
}vImage_ARGBToYpCbCr;
    
/*! 
 @typedef vImage_YpCbCrPixelRange
 @abstract  Range and clamping information for Y'CbCr pixel formats
 @discussion Y'CbCr formats frequently don't use the entire representable range available to 
             them to represent image data. While a "full range" video format does use the
             entire range, a "video range" format often leaves the extrema unused, except perhaps
             to represent values outside of the standard Y'=[0,1] CbCr = [-0.5, 0.5] range. 
             For example, a 8-bit video range format typically uses the range [16,235] for
             Y' and [16, 240] for Cb and Cr. 
 
 
             Some examples:
    
 @textblock
                (vImage_YpCbCrPixelRange){ 16, 128, 235, 240, 255, 0, 255, 1 }      // video range 8-bit, unclamped
                (vImage_YpCbCrPixelRange){ 16, 128, 235, 240, 235, 16, 240, 16 }    // video range 8-bit, clamped to video range
                (vImage_YpCbCrPixelRange){ 0, 128, 255, 255, 255, 1, 255, 0 }       // full range 8-bit, clamped to full range
 @/textblock
 
            The bias will be the prebias for YUV -> RGB and postbias for RGB -> YUV.
 
 @field Yp_bias The encoding for Y' = 0.0 for this video format (varies by bitdepth)
 @field CbCr_bias The encoding for {Cb,Cr} = 0.0 for this video format. This is usually the MIDDLE of the range of CbCr, not the low end. 
 @field YpRangeMax The encoding for Y' = 1.0 for this video format. For video range, this is typically less than the maximum representable value.
 @field CbCrRangeMax The encoding for {Cb,Cr} = 0.5 for this video format. This is usually near the high end of the encodable range (e.g. 0xf0), if not the maximum encodable value (e.g. 0xff)
 @field YpMax  The encoding for the maximum allowed Y' value. All values larger than this will be clamped to this value.
 @field YpMin   The encoding of the minimum allowed Y' value. All values less than this will be clamped to this value.
 @field CbCrMax The encoding of the maximum allowed {Cb, Cr} value. All chroma values greater than this value will be clamped to this value.
 @field CbCrMin The encoding of the minimum allowed {Cb, Cr} value. All chroma values less than this value will be clamped to this value.
 @seealso vImageChannelDescription
*/
typedef struct vImage_YpCbCrPixelRange
{
        int32_t                    Yp_bias;
        int32_t                    CbCr_bias;
        int32_t                    YpRangeMax;
        int32_t                    CbCrRangeMax;
        int32_t                    YpMax;
        int32_t                    YpMin;
        int32_t                    CbCrMax;
        int32_t                    CbCrMin;
}vImage_YpCbCrPixelRange;

    
#ifdef __cplusplus
}
#endif


#endif /* vImage_TYPES_H */
                                                                                                      vImage_Utilities.h                                                                                  0100644 0001750 0001750 00000277256 12566216025 044624  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/Headers                           /*!
 *  @header vImage_Utilities.h
 *  vImage
 *
 *  Created by Ian Ollmann on 6/7/12.
 *
 *  See vImage/vImage.h for more on how to view the headerdoc documentation for functions declared herein.
 *
 *  @copyright Copyright (c) 2012-2015 by Apple Inc. All rights reserved.
 *
 *  @discussion These interfaces provide methods to help exchange data between CoreGraphics and vImage
 *              and provides conversion routines to convert nearly any image format to nearly any 
 *              other image format.  They are intended to streamline vImage adoption, and make it possible
 *              for your application's imaging pipeline to gracefully handle a wide diversity of image formats.
 *              When conversions are necessary, they are vectorized and multithreaded to minimize cost in
 *              time and energy.
 *
 *  @ignorefuncmacro VIMAGE_NON_NULL
 *  @ignorefuncmacro VIMAGE_CHOICE_ENUM
 */

#ifndef vImage_Utilities_h
#define vImage_Utilities_h

#include <vImage/vImage_Types.h>
#include <CoreGraphics/CoreGraphics.h>  /* #define vImage_Utilities_h 1 before including Accelerate headers to turn this header off */

#ifdef __cplusplus
extern "C" {
#endif

/*!
 * @const kvImageDecodeArray_16Q12Format
 * @abstract Predefined decode array constant to use with 16Q12 formatted data
 * @discussion 16Q12 data is a signed 16-bit fixed point integer. The format is implicitly divided by 2**12
 *             to give a range of [-8,8)  (SHRT_MIN/4096,SHRT_MAX/4096). The type is present to allow 
 *             8-bit content to be converted into other colorspaces and operated on without undue
 *             loss of precision or loss of color gamut due to clamping. This constant is "magic" in the
 *             sense that it is identified by address. Copying the values here will cause a CG format to
 *             be instead interpreted as a _unsigned_ 16 bit format. 
 *
 *             16Q12 pixels do not follow CG image format conventions in two respects. The format is signed.
 *             The alpha channel is subject to the decode array transform too, meaning that 0 is transparent 
 *             and 4096 opaque. Consequently, ALL buffers that use this format must be tagged with the 
 *             kvImageDecodeArray_16Q12Format decode array.
 *
 */
extern const CGFloat * kvImageDecodeArray_16Q12Format;

/*!
 * @struct vImage_CGImageFormat
 * @abstract A pixel format
 * @discussion A vImage_CGImageFormat describes the ordering of the color channels, how many there are,
 * the size and type of the data in the color channels and whether the data is premultiplied by alpha or not.
 * This format mirrors the image format descriptors used by CoreGraphics to create things like CGImageRef and
 * CGBitmapContextRef.
 *
 * This vImage_CGImageFormat:
 *
 *  <pre>@textblock
 *      vImage_CGImageFormat format = {
 *          .bitsPerComponent = 8,
 *          .bitsPerPixel = 32,
 *          .colorSpace = CGColorSpaceCreateDeviceRGB(),                                    // don't forget to release this!
 *          .bitmapInfo = kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Little,
 *          .version = 0,                                                                   // must be 0
 *          .decode = NULL,
 *          .renderingIntent = kCGRenderingIntentDefault
 *      };
 *  @/textblock</pre>
 *
 * codes for a little endian ARGB8888 pixel, or what is called in the rest of vImage, BGRA8888. Note: for 16-
 * and 32-bits per component formats (int16_t, uint16_t, half-float, float) most vImage image filters assume
 * the data is in host-endian format. (The APIs in this header do not.) Host-endian is little endian for Intel
 * and ARM, big endian for PowerPC. If the data is not in host-endian format, then you may use
 * vImagePermuteChannels_ARGB8888 or vImageByteSwap_Planar16U to swap the image data byte ordering.
 *
 * Some examples:
 *  <pre>@textblock
 *      ARGB8888     ->  {8, 32, NULL, alpha first, 0, NULL, kCGRenderingIntentDefault}     alpha first = { kCGImageAlphaFirst, kCGImageAlphaPremultipliedFirst, kCGImageAlphaNoneSkipFirst }
 *      RGBA8888     ->  {8, 32, NULL, alpha last,  0, NULL, kCGRenderingIntentDefault}     alpha last  = { kCGImageAlphaLast,  kCGImageAlphaPremultipliedLast,  kCGImageAlphaNoneSkipLast }
 *      BGRA8888     ->  {8, 32, NULL, alpha first | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault}
 *      RGB888       ->  {8, 24, NULL, kCGImageAlphaNone | kCGBitmapByteOrderDefault, 0, NULL, kCGRenderingIntentDefault}
 *      RGB565       ->  {5, 16, NULL, kCGImageAlphaNone | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault}
 *      ARGB1555     ->  {5, 16, NULL, alpha first | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault}
 *      RGBA16F      ->  {16, 64, NULL, alpha last | kCGBitmapFloatComponents | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault }
 *      CMYK8888     ->  {8, 32, CGColorSpaceCreateDeviceCMYK(), kCGImageAlphaNone, 0, NULL, kCGRenderingIntentDefault  }
 *      ARGBFFFF premultiplied    ->  {32, 128, NULL, kCGImageAlphaPremultipliedFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }
 *      ARGBFFFF not-premultiplied -> {32, 128, NULL, kCGImageAlphaFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }
 *      ARGBFFFF, alpha = 1 ->        {32, 128, NULL, kCGImageAlphaNoneSkipFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }
 *  @/textblock</pre>
 *
 *  Note that some of these formats, particularly RGB565 and 16F formats are supported by vImage but
 *  not necessarily CoreGraphics. They will be converted to a higher precision format as necessary by
 *  vImage in vImageCreateCGImageFromBuffer().
 *
 *  By C rules, uninitialized struct parameters are set to zero. The last three parameters are usually zero, so can usually be omitted.
 *
 *  <pre>@textblock
 *      vImage_CGImageFormat srgb888 = (vImage_CGImageFormat){
 *          .bitsPerComponent = 8,
 *          .bitsPerPixel = 24,
 *          .colorSpace = NULL,
 *          .bitmapInfo = kCGImageAlphaNone | kCGBitmapByteOrderDefault };
 *  @/textblock</pre>
 *
 * To understand how these various parameters relate to one another, we can look at the process of converting from
 * one vImage_CGImageFormat format to another:
 *
 *  1) transform endianness of src format given by bitmapInfo to host endian  (except 8 bitPerComponent content)
 *  2) remove decode array transformation, and up convert to a higher range format as necessary to preserve precision / range
 *  3) convert src colorspace to reference XYZ colorspace (may cause upconvert to preserve range / precision)
 *  4) convert XYZ to destination colorspace + rendering intent
 *  5) convert to destination precision (given by bitsPerComponent)
 *  6) deal with any alpha changes (given by bitmapInfo) or flattening that needs to occur
 *  7) Apply any channel reordering requested, if it didn't happen at an earlier step. (As indicated by src and dest bitmapInfo)
 *  8) Apply destination decode array
 *  9) Apply endianness transform given by dest bitmapInfo
 *
 * Clearly, for most common transformations not all steps need to occur and multiple steps can be collapsed into a compound operation.
 *
 *  @field  bitsPerComponent    The number of bits needed to represent one channel of data in one pixel. For ARGB8888, this would be 8. Expected values: {1, 2, 4, 5, 8, 10, 12, 16, 32}
 *  @field  bitsPerPixel        The number of bits needed to represent one pixel. For ARGB8888, this would be 32.
 *                              It is possible that bitsPerPixel > bitsPerComponent * number of components, but in practice this is rare.
 *                              The number of color components is given by the colorspace and the number of alpha components (0 or 1) is given by
 *                              by the bitmapInfo.
 *  @field  colorSpace          A description of how the pixel data in the image is positioned relative to a reference XYZ color space.
 *                                  See CoreGraphics/CGColorSpace.h.  Pass NULL as a shorthand for sRGB. The vImage_CGImageFormat is not
 *                                  capable of managing the memory held by the colorSpace. If you created the colorspace, you must
 *                                  be sure to release it before all references to it disappear from scope.
 *  @field  bitmapInfo          The CGBitmapInfo describing the color channels. See CoreGraphics/CGImage.h.
 *                                  ARGB8888 is kCGImageAlphaFirst | kCGBitmapByteOrderDefault
 *                                  BGRA8888 is kCGImageAlphaFirst | kCGBitmapByteOrder32Little
 *  @field  version             The struct is versioned for future expansion.  Pass 0 here.
 *  @field  decode              Prior to transformations caused by the colorspace, color channels are subject to a linear transformation.
 *                              This allows for a different range than the typical [0,1.0]. NULL indicates default behavior of [0,1.0]
 *                              range, and is what you should use if you don't understand this parameter. See description of CGImageCreate()
 *                              for a discussion of decode arrays. See also Decode Arrays section of Chapter 4.8 of the PDF specification.
 *                              The vImage_CGImageFormat is not capable of managing the memory held by the decode array. If you created a
 *                              decode array on the heap, you must be sure to release it before all references to it disappear from scope.
 *
 *  @field renderingIntent      See CGColorSpace.h. kCGRenderingIntentDefault is typical here. By convention, rendering intent changes that
 *                              are not accompanied by a colorspace change are ignored.
 */
typedef struct vImage_CGImageFormat
{
    uint32_t                bitsPerComponent;
    uint32_t                bitsPerPixel;       
    CGColorSpaceRef         colorSpace;         
    CGBitmapInfo            bitmapInfo;         
    uint32_t                version;            
    const CGFloat *         decode;
    CGColorRenderingIntent  renderingIntent;
}vImage_CGImageFormat;


    
/*!
 *  @functiongroup vImage_Buffer utilities
 *  @discussion Convenience methods for working with vImage_Buffers.
 */
    
 /*!
 *  @function vImageBuffer_Init
 *  @abstract Convenience function to allocate a vImage_Buffer of desired size
 *  @discussion This function is a convenience method to help initialize a vImage_Buffer struct with a buffer sized
 *  and aligned for best performance. It will initialize the height, width and rowBytes fields, and allocate 
 *  the pixel storage for you. You are responsible for releasing the memory pointed to by buf->data back to 
 *  the system when you are done with it using free(). If no such allocation is desired, pass  
 *  kvImageNoAllocate in the flags to cause buf->data to be set to NULL and the preferred alignment 
 *  to be returned from the left hand side of the function.
 *
 *  Here is an example of typical usage:
 *
 *  <pre>@textblock
 *      vImage_Buffer buf;
 *      vImage_Error err = vImageBuffer_Init( &buf, height, width, 8 * sizeof(pixel), kvImageNoFlags);
 *      ...
 *  @/textblock</pre>
 *
 *  And typical usage using your own allocator (posix_memalign in this case):
 *
 *  <pre>@textblock
 *      vImage_Buffer buf;
 *      ssize_t alignment = vImageBuffer_Init( &buf, height, width, 8 * sizeof(pixel), kvImageNoAllocate);
 *      if( alignment >= 0 )  // <0 is an error
 *          error = posix_memalign( &buf.data, alignment, buf.height * buf.rowBytes );  // An allocator
 *  @/textblock</pre>
 *
 *      On return, buf is initialized to contain the provided height and width and best rowBytes for the image.
 *      buf->data will also be allocated by default. If kvImageNoAllocate is passed then allocation is skipped,
 *      buf->data is set to NULL, and the preferred alignment is returned out the left hand side of the
 *      function.
 *
 *  @param buf              A valid empty vImage_Buffer struct. On return, all fields will be initialized.
 *                          Please see behavior of kvImageNoAllocate in the flags parameter below.
 *
 *  @param height           The desired height of the image
 *  @param width            The desired width of the image
 *
 *  @param pixelBits        The number of bits in a pixel of image data. If the image is in a planar format
 *                          then this is the number of bits per color component. If pixelBits is not divisible
 *                          by 8, then vImage will pad the scanline out to a multiple of a byte so that
 *                          two scanlines can not share the same byte and all scanlines start at the start of 
 *                          a byte.
 *
 *  @param flags            Must be from the following list:
 *
 *  <pre>@textblock
 *                          kvImageNoAllocate -- on return buf->data is initialized to NULL. A preferred
 *                              alignment suitable for use with posix_memalign is returned out the left hand 
 *                              side of the function and buf->rowBytes will be set to the preferred rowBytes. 
 *                              If the left hand side return is negative, it is an error code, not a size. 
 *                          
 *                              If the kvImageNoAllocate flag is not passed, then on return buf->data will point 
 *                              to a newly allocated buffer with preferred alignment and rowBytes. An appropriate 
 *                              error code will be returned from the left hand side.
 *
 *                          kvImagePrintDiagnosticsToConsole -- directs the function to print diagnostic information
 *                              to the console in the event of failure. 
 *  @/textblock</pre>
 *
 *  @return  One of the following error codes will be returned out the left hand side.
 *
 *  <pre>@textblock
 *      >0                              kvImageNoAllocate was passed. The value returned indicates the
 *                                      preferred alignment (in bytes) for buf->data. buf->data is NULL.
 *
 *      kvImageNoError                  Success
 *
 *      kvImageMemoryAllocationError    you requested that buf->data be allocated but the allocation failed
 *
 *      kvImageUnknownFlagsBit          flags was not from the list above
 *  @/textblock</pre>
 */
    
vImage_Error  vImageBuffer_Init( vImage_Buffer *         buf,
                                 vImagePixelCount        height,
                                 vImagePixelCount        width,
                                 uint32_t                pixelBits,
                                 vImage_Flags            flags)
                                 VIMAGE_NON_NULL(1)
                                  __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    

    
/*!
 *  @function vImageBuffer_GetSize
 *  @abstract Returns size of a vImage_Buffer as a CGSize.
 *  @discussion The CGSize / NSSize is rounded down to the nearest representable
 *  CGFloat that is less than or equal to the actual size of the image. In practice
 *  the conversion will always be exact, except for really, really big images. In
 *  that case, some part of the bottom or right edge might be truncated.
 *
 *  <pre>@textblock
 *  Rationale: If you attempt your own home-made conversion to CGSize / NSSize by
 *            ordinary C rules and the value rounds, it will round up half the time.
 *            This could lead to a crash later because the height or width
 *            will be reported to be larger than it really is and an ensuing image
 *            operation will attempt to touch scanlines that don't exist.
 *  @/textblock</pre>
 *
 *  @param buf  A pointer to a valid vImage_Buffer
 *
 *  @return  The largest CGSize that will fit in the buffer. In typical usage, this
 *           is equal to the size of the buffer.
 */
CGSize vImageBuffer_GetSize( const vImage_Buffer *buf )
VIMAGE_NON_NULL(1)
__OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );

    

    
    
/*!
 * @functiongroup vImage_CGImageFormat functions
 * @discussion    A vImage_CGImageFormat describes a pixel format compatible with CoreGraphics.
 *                Most access to the vImage_CGImageFormat struct is done directly through memberwise
 *                access, but a few tasks are complicated enough to deserve their own library function.
 */
    
/*!
 * @function vImageCGImageFormat_GetComponentCount
 * @abstract Calculate the number of channels (color + alpha) for a given image format
 * @discussion  The number of channels may not be safely calculated as bitsPerPixel / bitsPerComponent.
 *              Use this routine instead. 
 * @param    format     A pointer to a valid vImage_CGImageFormat.  If format->colorspace is NULL,
 *                      the format is assumed to belong to the sRGB colorspace.
 *
 * @return   Returns the number of color + alpha channels in the image.
 */
uint32_t vImageCGImageFormat_GetComponentCount( const vImage_CGImageFormat *format )
    VIMAGE_NON_NULL(1)
    __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );

/*!
 * @function vImageCGImageFormat_IsEqual
 * @abstract Test to see if two vImage_CGImageFormats are equivalent
 * @discussion Returns nonzero if two vImage_CGImageFormats are the same
 *              If either operand is NULL, the result is false.
 *              If vImage_CGImageFormat.colorSpace is NULL, sRGB is used.
 *
 * @param f1    A pointer to the first vImage_CGImageFormat
 * @param f2    A pointer to the second vImage_CGImageFormat
 *
 * @return  nonzero if two vImage_CGImageFormats are the same
 */
Boolean vImageCGImageFormat_IsEqual( const vImage_CGImageFormat *f1,  const vImage_CGImageFormat *f2 )
    __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );

    
/*!
 *  @functiongroup vImage_Buffer CGImageRef interconversion
 *  @discussion High level routines to convert from vImage_Buffer to CGImageRef and back.
 */
    
/*!
 * @function vImageBuffer_InitWithCGImage
 * @abstract Initialize a vImage_Buffer struct with the contents of a CGImageRef
 * @discussion This function will initialize a vImage_Buffer struct with an image from a CGImageRef.
 * By default, a new region of memory to hold the image data will be allocated by this function.  You may
 * optionally allocate the memory region yourself by passing in the kvImageNoAllocate flag. 
 *
 * You may release the CGImageRef and format->colorspace upon successful return of this function.
 *
 * You are responsible for returning the memory referenced by buf->data to the system using free() when you are done with it.
 * The CGImage may have other metadata associated with it, such as camera orientiation, which may require further
 * processing downstream.  vImage just does 1:1 pixel conversions from the raw image source.
 *
 *
 * To create a CGImageRef from a image file on disk:
 *
 *  <pre>@textblock
 *     CFURLRef path = ...;  // path to image
 *     CGImageSourceRef imageSource = CGImageSourceCreateWithURL( path, optionsDictionary ); // optionsDictionary may be NULL
 *     CGImageRef imageRef = CGImageSourceCreateImageAtIndex( imageSource, imageIndex, optionsDictionary );
 *  @/textblock</pre>
 *
 * Similarly, with a chunk of compressed image data in memory:
 *
 *  <pre>@textblock
 *     CFDataRef data = ...;
 *     CGImageSourceRef imageSource = CGImageSourceCreateWithData( path, optionsDictionary );
 *     CGImageRef imageRef = CGImageSourceCreateImageAtIndex( imageSource, imageIndex, optionsDictionary );
 *  @/textblock</pre>
 *
 * You can do similar things through AppKit / UIKit with [NSImage initWithContentsOfFile:],
 * [NSImage initWithContentsOfURL:], or [NSImage initWithData:],  and use [NSImage CGImageForProposedRect:context:hints:]
 * to get out a CGImageRef.
 *
 * @param buf   A pointer to a valid vImage_Buffer struct. The fields of the structure pointed to by buf will
 *              be updated to point to a vImage_Buffer representation of the CGImage. By default, a newly
 *              allocated piece of memory will be used to hold the image. You are responsible
 *              for releasing the memory pointed to by buf->data back to the system using free().
 *
 *                  If you want to allocate the buf->data and initialize rowBytes yourself, then you may pass 
 *                  kvImageNoAllocate in the flags parameter. This will cause the buf->data and rowBytes values  
 *                  passed into the function to be used directly without modification.  You may find vImageBuffer_Init,  
 *                  vImageCGImageFormat_GetPixelBits, CGImageGetWidth and CGImageGetHeight helpful in sizing your buffer.
 *
 * @param format  A pointer to a valid vImage_CGImageFormat specifying the desired image format associated with the 
 *                  output buf. If format->colorspace is NULL, sRGB will be used.
 *
 * @param backgroundColor If the CGImageRef encodes an alpha (or mask) and the output format does not have alpha then the
 *                  result will be flattened against a background color. See vImageConverter_CreateWithCGImageFormat
 *                  and functions like vImageFlatten_ARGB8888ToRGB888 for more on flattening. The background color here is
 *                  a series of values of range [0,1] interpreted according to the colorspace passed in format. Example: If 
 *                  the format encodes for a AGBR 8-bit image (kCGImageAlphaLast, kCGBitmapByteOrder32Little), then this would be
 *                  {red, green, blue}, the canonical ordering for a RGB colorspace, as an array of three CGFloats.  
 *                  If NULL is passed, an array full of zeros is used. The backgroundColor must have at least as many
 *                  CGFloats in it as the colorspace has color channels. See CGColorSpaceGetNumberOfComponents.
 *
 * @param image     A valid CGImageRef to be used as source data.
 *
 * @param flags     You may set the following flags:
 *
 *  <pre>@textblock
 *                  kvImageNoAllocate       the buf->data and buf->rowBytes values passed in are used without modification.
 *                                          This allows you to allocate your own buffer to hold the result. See buf description
 *                                          above.
 *
 *                  kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug messages.
 *
 *                  kvImageDoNoTile         It is possible that vImage will have to do an image format conversion from the
 *                                          image native format to the desired format. This will turn off multithreading for
 *                                          that step and any other vImage work that is multithreaded. Since any such conversions
 *                                          are likely happening outside your tiling engine, use of this flag here is 
 *                                          probably counterproductive. In rare cases, it might be valuable as a method to 
 *                                          leave unoccupied some cores for other tasks, if you have other multithreaded time 
 *                                          sensitive tasks running. Likewise, if you are converting multiple images concurrently,
 *                                          it might be helpful to avoid oversubscribing the system.
 *  @/textblock </pre>
 *
 *
 *  @return If the call succeeds, kvImageNoError is returned and the memory region pointed to by buf will be initialized to
 *      describe a valid repesentation of the CGImageRef. 
 *
 *      If the call fails, then one of the following error codes will be returned and buf->data will be set to NULL.
 *
 *  <pre>@textblock
 *          kvImageUnknownFlagsBit              flags must be kvImageNoFlags or kvImageNoAllocate
 *          kvImageMemoryAllocationError        Not enough memory to allocate buf->data 
 *          kvImageInvalidParameter             format->bitmapInfo has unknown bits set
 *          kvImageInvalidParameter             format->version is not 0
 *          kvImageInvalidParameter             format->decode is not NULL
 *          kvImageInvalidParameter             format->bitsPerComponent is not in {0,1,2,4,5,8,16,32}
 *          kvImageInvalidImageFormat           format->renderingIntent is not a known value
 *          kvImageInvalidImageFormat           The format called for conversion to an input-only colorspace. Some color profiles
 *                                              (e.g. those arising from a scanner) are described as input only, because the device can
 *                                              not produce image output.
 *          kvImageNullPointerArgument          format may not be NULL
 *          kvImageNullPointerArgument          image may not be NULL
 *          kvImageInternalError                Something unexpected went wrong. Please file a bug. 
 *  @/textblock </pre>
 *
 */
    
vImage_Error vImageBuffer_InitWithCGImage(  vImage_Buffer        *  buf,            
                                            vImage_CGImageFormat *  format,         
                                            const CGFloat        *  backgroundColor,
                                            CGImageRef              image,          
                                            vImage_Flags            flags  )
                                            VIMAGE_NON_NULL(1,2,4)
                                            __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );  


        
/*!
 * @function vImageCreateCGImageFromBuffer
 * @abstract Create a CGImageRef from a vImage_Buffer.
 * @discussion This function creates a CGImageRef using the image data in a vImage_Buffer. The CGImageRef has a retain count of 1.
 * By default, a copy of the image data is made. This allows the function to convert to a CG-friendly format as necessary
 * and allows you to continue to use the vImage_Buffer without causing problems for the CGImageRef. 
 *
 *  <pre>@textblock
 * No copy mode
 * ------------
 * When the kvImageNoAllocate flag is passed, then "no-copy" operation is said to occur. Ownership of the memory region  
 * pointed to by buf->data is transferred to the CGImageRef and it becomes private to and owned by that object and will 
 * be used without modification. The memory region pointed to by buf->data will be destroyed when the CGImageRef is 
 * destroyed. Caution: CGImageRefs are defined to be immutable once created. Behavior is undefined if you create
 * a CGImageRef then modify the pixels in its backing store.
 *
 * No-copy mode can be a little fussy about formats. When a format is rejected, kvImageInvalidImageFormat will be returned. 
 * Formats that are likely to succeed are 8-bit unsigned, 16-bit unsigned and 32-bit floating-point. The image should be 
 * kCGImageAlphaNone, kCGImageAlphaLast, kCGImageAlphaPremultipliedLast or kCGImageAlphaNoneSkipLast, and decode = NULL. 
 * The image should be in host endian mode. This is kCGBitmapByteOrderDefault for 8-bit per component images, and or larger 
 * types, the endianness is given by the endianness of the host system and the size is given by the size of the pixel 
 * (bitsPerComponent < 8) or channel (bitsPerComponent > 8). For example RGB565 data should be kCGBitmapByteOrder16Little 
 * and 32-bit floating point data should be kCGBitmapByteOrder32Little on little endian processors. 
 *
 * It is recommended that if no-copy mode fails, that you try again without the kvImageNoAllocate flag. The call probably 
 * will succeed.
 *  @/textblock </pre>
 *
 * CGImage Debugging Note:
 *      The format parameter describes the image data you pass in, but there is no requirement that this is the
 *      format that is actually used to represent the image data held by the CGImage. You should be able to get
 *      back the data in any format you like with vImageBuffer_InitWithCGImage. However, understand that if you
 *      request the data through another API like CGDataProviderCopyData(), it will be formatted as described by
 *      that API -- for CGDataProviderCopyData(), that would be as described by: CGImageGetBitmapInfo, CGImageGetDecode,
 *      CGImageGetRenderingIntent, CGImageGetColorSpace, CGImageGetBytesPerRow, CGImageGetBitsPerPixel,
 *      CGImageGetBitsPerComponent, etc.  Furthermore, the format that those APIs report is also not necessarily
 *      the format of the data held by the CGImageRef.  Common image data consumers like CoreAnimation and
 *      CoreGraphics have their format preferences and vImage caters to them in order to deliver good performance.
 *
 *      CGImageRefs can also be made from vImage_Buffers using CGImageCreate() and CGDataProviderCreateWithData().
 *
 *  @param buf             The vImage_Buffer from which to make the CGImageRef
 *
 *  @param format          The image format of the vImage_Buffer. format may not be NULL.  format->colorspace may be NULL,
 *                  in which case sRGB will be used.  The colorspace is retained as needed by the new CGImage.
 *
 *  @param callback        In no-copy mode, this callback is called to destroy the buf->data when the CGImageRef no longer needs it.
 *                  If NULL is passed for the callback, then free() will be used to destroy buf->data.  userData will be 
 *                  passed to the callback function as the userData parameter and buf->data passed as the buf_data parameter.
 *
 *                  This parameter has no effect if kvImageNoAllocate is not in flags. 
 *
 *                  The callback may be called at any time from any thread. It is possible for it to be called before 
 *                  vImageCreateCGImageFromBuffer returns.  
 *
 *                  The callback will not be called if the returned CGImageRef is NULL.
 *
 *  @param userData        The value to pass to the callbacks userData parameter. If callback is NULL or kvImageNoAllocate
 *                  is passed in flags, this value is ignored.  
 *                  
 *  @param flags           The following flags are allowed:
 *  <pre>@textblock
 *                  kvImageNoAllocate                   Causes vImageCreateCGImageFromBuffer to run in no-copy mode.
 *                                                      Ownership of the memory pointed to by buf->data is transferred 
 *                                                      to the CGImageRef.  You'll need to set up a callback and userData
 *                                                      to manage releasing the memory back to the system when the CGImage
 *                                                      is done with it.
 *
 *                  kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug messages.
 *
 *                  kvImageHighQualityResampling        Sometimes the system will ask for the image to be resamled to
 *                                                      a smaller size. If that happens vImageAffineWarp_<fmt>" will be
 *                                                      called. In that case, the value of this bit will be used to
 *                                                      determine whether Lanczos3 or Lanczos5 resampling is used.
 *
 *                  kvImageDoNotTile                    Disables multithreading in any conversions that need to be done.
 *                                                      Since it seems likely any such conversions will not be running in
 *                                                      the context of your tiling engine (if you wrote one) in this case, 
 *                                                      this flag is probably counterproductive in this context. Conversions
 *                                                      can happen later, after this call returns, when the image is drawn.
 *  @/textblock </pre>
 *  @param error           if not NULL, points to a more informative error code to describe what went wrong on exit. May be NULL.
 *                  Testing the result against NULL is sufficient to detect success or failure. kvImagePrintDiagnosticsToConsole
 *                  is another way to get error information.
 *
 * @return  On success, the returned CGImageRef will be non-NULL. If error is not NULL, kvImageNoError will be written there.
 *      On failure, NULL will be returned, and if error is not NULL, a more informative error code will be written there. 
 *          
 *  <pre>@textblock
 *  Error Values:
 *      kvImageUnknownFlagsBit              flags was not from the list described in the flags parameter above
 *      kvImageMemoryAllocationError        Not enough memory to allocate the new CGImageRef
 *      kvImageInvalidParameter             format->bitmapInfo has unknown bits set
 *      kvImageInvalidParameter             format->bitsPerComponent is not in {5,8,16,32}
 *      kvImageInvalidImageFormat           format->renderingIntent is not a known value
 *      kvImageNullPointerArgument          format may not be NULL
 *      kvImageNullPointerArgument          buf may not be NULL
 *  @/textblock </pre>
 *
 */
    
CGImageRef vImageCreateCGImageFromBuffer( const vImage_Buffer *buf,
                                          const vImage_CGImageFormat *format,
                                          void (*callback)(void *userData, void *buf_data),
                                          void *userData,
                                          vImage_Flags flags,
                                          vImage_Error *error )
                                          VIMAGE_NON_NULL(1,2)
                                          __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );     
    

    
/*!
 * @functiongroup vImageConverterRef methods
 * @discussion A vImageConverterRef describes a particular pixel format to pixel format conversion. These functions
 *             create, retain, release and get information about a vImageConverterRef. vImageConvert_AnyToAny() uses
 *             a vImageConverterRef to do a image format conversion.
 */

/*!
 *  @function vImageConverter_Retain
 *  @abstract Retain a vImageConverterRef
 *  @discussion You should retain a vImageConverterRef when you receive it from elsewhere (that is, you did not 
 *              create or copy it) and you want it to persist. If you retain a vImageConverterRef you are responsible 
 *              for releasing it (see Memory Management Programming Guide for Core Foundation).
 *
 *  Like all of vImage, this interface is thread safe and may be called reentrantly.
 *
 *  @param converter  The vImageConverter to retain. If NULL, then nothing happens.
 */
void vImageConverter_Retain( vImageConverterRef converter ) __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );

/*!
 *  @function vImageConverter_Release
 *  @abstract Release a vImageConverterRef
 *  @discussion If the retain count of a vImageConverterRef becomes zero, the memory allocated to the 
 *              object is deallocated and the object is destroyed. If you create or explicitly
 *              retain (see the vImageConverter_Retain function) a vImageConverterRef, you are responsible for
 *              releasing it when you no longer need it (see Memory Management Programming Guide for Core Foundation).
 *
 *  Like all of vImage, this interface is thread safe and may be called reentrantly.
 *
 *  @param converter  The vImageConverter to release. If NULL, then nothing happens.
 */
void vImageConverter_Release( vImageConverterRef converter ) __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );


/*!
 *  @function vImageConverter_CreateWithCGImageFormat
 *  @abstract Create a vImageConverterRef to convert from ome vImage_CGImageFormat to another
 *  @discussion vImageConverter_CreateWithCGImageFormat creates a vImageConverter to convert between
 *              image formats describable with a vImage_CGImageFormat.  The vImageConverter is intended
 *              to be used (and reused, possibly reentrantly) with vImageConvert_AnyToAny() to convert 
 *              images from one format to another.
 *
 *  <pre>@textblock
 *  Image Format Notes:
 *      CG Integer images map the range [0,1.0] (black to full color intensity) to the range [0, TYPE_MAX]. A 8-bit unsigned image
 *  has a range [0,255] and a 16-bit signed image has a range [0,32767]. Floating point images map [0,1.0] to [0,1.0]. Some formats,
 *  like floating-point and signed integers are capable of representing values outside of that range. Conversions involving these
 *  formats will occasionally produce results outside of [0,1]. If the conversion causes a value to go out of the representable range
 *  for the underlying type, it will be clamped to the nearest representable value. This can happen in normal operation during color
 *  correction. You can clamp floating-point results back into [0,1] using vImageClip_PlanarF, if you like.
 *
 *      Usually, colors must be direct mapped. Indexed color is supported format->bitsPerComponent and format->.bitsPerPixel are 1,2,4
 *  or 8, and equal (i.e. grayscale) only. Indexed color is not supported for the destination image. Images with indexed color must use
 *  (kCGImageAlphaNone | kCGBitmapByteOrderDefault) as the bitmapInfo. It is usually faster with indexed color spaces to use
 *  vImageConvert_AnyToAny to convert the color table rather than the image itself when possible, because the table is usually much
 *  smaller than the image. vImageConvert_AnyToAny can not do that automatically for you behind the scenes because it does not return
 *  a modified colorspace.
 *
 *  Device Colorspaces:
 *  Because vImage has no concept of a rendering context or destination graphics device, vImage maps device RGB, device grayscale
 *  and device CMYK to a virtual device which is not your display. The virtual device uses kColorSyncGenericGrayGamma22Profile,
 *  kColorSyncSRGBProfile and kColorSyncGenericCMYKProfile respectively. If you want the image to be converted to the right colorspace
 *  for your display device, you will need to pass in the CGColorSpaceRef for that device obtained from an API like CGDisplayCopyColorSpace().
 *
 *  Black Point Compensation:
 *  By default, BPC is off for this function. If you want black point compensation or other advanced ColorSync effects, construct your
 *  own ColorSyncTransformRef and pass the associated "code fragment" to vImageConverter_CreateWithColorSyncCodeFragment.
 *  See Apple Sample Code "Converting an Image with Black Point Compensation" https://developer.apple.com/library/mac/samplecode/convertImage/Introduction/Intro.html
 *  @/textblock </pre>
 *
 *  See also vImageConverter_CreateForCGToCVImageFormat and vImageConverter_CreateForCVToCGImageFormat for converters
 *  that can operate on CoreVideo formats.
 *
 *  @param srcFormat    A pointer to a populated vImage_CGImageFormat struct describing the image format
 *                      of the source image. If the CGColorSpaceRef is NULL, sRGB will be used
 *                      as the default value. The CGColorSpaceRef will be retained by this function. It
 *                      will be released when the vImageConverter is destroyed.
 *
 *  @param destFormat   A pointer to a populated vImage_CGImageFormat struct describing the image format
 *                      of the destination image. If the CGColorSpaceRef is NULL, sRGB will be
 *                      used as the default value. The CGColorSpaceRef will be retained by this function.
 *                      It will be released when the vImageConverter is destroyed.
 *
 *  @param  backgroundColor Points to an array of floats to be used as a background color if one is needed. The
 *                      backgroundColor range is assumed to be [0,1]. The channel ordering and number of color 
 *                      channels must match the natural order of the destination colorSpace (e.g. RGB or CMYK). 
 *                      The backgroundColor may be NULL if no background color is needed. 
 *
 *                      A background color is used when the image is converted from an alpha-containing format 
 *                      to an alpha-none format, in which case the alpha is removed by compositing against the 
 *                      opaque background color pointed to by this parameter. If the image is instead converted 
 *                      from one alpha containing format to another, then the image will be premultiplied or 
 *                      unpremultiplied as necessary and no background color is necessary. (For unpremultiplication, 
 *                      the result color value for pixels with alpha 0 is 0.)  Likewise, when converting between
 *                      alpha-none formats, a background color is not use. In the case of kCGImageAlphaNone ->
 *                      kCGImageAlphaNoneSkipFirst/Last, the vacant alpha channel is filled in with 1.0. If NULL
 *                      is passed here, then 0 will be used for the color channels. 
 *
 *                      The vImageConverter will contain a copy of the data passed in this field.  
 *
 *  @param flags        Any of the following flags are allowed:
 *
 *  <pre>@textblock
 *           kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug
 *                                               messages.
 *
 *           kvImageDoNotTile                    A converter created with this flag will operate as if
 *                                               kvImageDoNotTile was passed to vImageConvert_AnyToAny
 *                                               whether it was or not.
 *  @/textblock </pre>
 *
 *  @param error        May be NULL.  If not NULL, then a vImage_Error is returned at the address pointed to by error. 
 *                      The vImage_Error will be less than 0 if an error condition occurred. Checking the vImageConverter 
 *                      returned to make sure it is non-NULL is sufficient to verify success or failure of the function.
 *
 *                      The following error values can occur:
 *  <pre>@textblock
 *      kvImageNoError                      Success.
 *
 *      kvImageNullPointerArgument          srcFormat and/or destFormat is NULL.
 *
 *      kvImageUnknownFlagsBit              Currently only kvImagePrintDiagnosticsToConsole and kvImageDoNotTile are
 *                                          allowed. All other bits in the flags field must be 0.
 *
 *      kvImageInvalidParameter             backgroundColor is NULL and the conversion needed a backgroundColor
 *
 *      kvImageInvalidImageFormat           bitsPerComponent must be in {1,2,4,5,8,12,16,32}.
 *      kvImageInvalidImageFormat           The base colorspace must be grayscale for destination images using indexed color.
 *      kvImageInvalidImageFormat           The colorspace may be indexed color for images only if it is {1,2,4,8} bitsPerComponent
 *                                          and kCGImageAlphaNone.
 *      kvImageInvalidImageFormat           vImage_CGImageFormat.bitmapInfo & kCGBitmapAlphaInfoMask  does not encode a valid alpha
 *      kvImageInvalidImageFormat           floating point formats must be 16 or 32 bits per component. 16-bit floats are
 *                                          IEEE-754-2008 binary16 interchange format  (a.k.a. OpenEXR half float). 32-bit floats
 *                                          are the standard IEEE-754-2008 binary32 interchange format. (a.k.a float in C/C++/ObjC)
 *      kvImageInvalidImageFormat           format->renderingIntent is not a known value
 *      kvImageInvalidImageFormat           The conversion called for conversion to an input-only colorspace. Some color profiles
 *                                          (e.g. those arising from a scanner) are described as input only, because the device can
 *                                          not produce image output.
 *
 *      kvImageInternalError                The converter was unable to find a path from the source format to the destination format.
 *                                          This should not happen and indicates incorrect operation of the function. Please file a bug.
 *                                          The kvImagePrintDiagnosticsToConsole flag will provide additional diagnostic info.
 *  @/textblock </pre>
 *
 *          In cases where the error code is not sufficient to quickly determine the problem, the kvImagePrintDiagnosticsToConsole flag
 *          should provide additional diagnostic info.
 *
 *  @return  A vImageConverter object with reference count of 1 is created. If the call fails due to an error, then NULL
 *  will be returned. Use vImageConverter_Release to release your reference to it and allow the resources used
 *  by the converter to be returned to the system.
 *
 *  If error is not NULL, an error code will be written to that address on return.
 */
 
vImageConverterRef vImageConverter_CreateWithCGImageFormat( const vImage_CGImageFormat *srcFormat,
                                                            const vImage_CGImageFormat *destFormat,
                                                            const CGFloat *backgroundColor,          
                                                            vImage_Flags flags,
                                                            vImage_Error *error )
                                                            VIMAGE_NON_NULL(1,2)
                                                            __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );


/*!
 * @function vImageConverter_CreateWithColorSyncCodeFragment
 * @abstract Create a vImageConverterRef substituting in a custom ColorSync transform for the one vImage usually generates for the color conversion steps.
 * @discussion vImageConverter_CreateWithColorSyncCodeFragment is like vImageConverter_CreateWithCGImageFormat, except that
 *  instead of creating its own colorspace transform for any colorspace conversions, it uses the one you pass in.
 *  This gives you greater control over the fine details of colorspace conversion, for exacting color fidelity.
 *  The colorspaces for source and destination images must refer to colorspaces that have the same number of channels
 *  as the codeFragment is designed to accept / produce.
 *
 *  See Apple Sample Code "Converting an Image with Black Point Compensation" https://developer.apple.com/library/mac/samplecode/convertImage/Introduction/Intro.html
 *  for an example of usage.
 *
 *  @param codeFragment A code fragment created with ColorSyncTransformCopyProperty( kColorSyncTransformFullConversionData,
 *                      kColorSyncTransformParametricConversionData or kColorSyncTransformSimplifiedConversionData)
 *                      May be NULL.  If NULL, no colorspace conversion / correction is done. In this case,
 *                      behavior is undefined if the colorspaces do not have the same channel order or have a
 *                      different number of channels or the colorspaces are not from the same family.
 *                      kColorSyncTransformFullConversionData is required for black point compensation.
 *                      CAUTION: vImageConverter_CreateWithColorSyncCodeFragment does not verify that the
 *                      codeFragment is actually appropriate for the srcFormat and destFormat provided. Nor
 *                      does it attempt to append additional color space transformation steps to make the 
 *                      codeFragment appropriate to the images provided. If the colorspace of the srcFormat 
 *                      and destFormat do not correspond to the ColorSyncProfileRefs used to create the 
 *                      ColorSync transform in at least colorspace model, then the behavior is undefined. 
 *                      See CGColorSpaceModel CoreGraphics/CGColorSpace.h
 *
 *  @param srcFormat    A pointer to a populated vImage_CGImageFormat struct describing the image format
 *                      of the source image. If the CGColorSpaceRef is NULL, sRGB will be used
 *                      as the default value. The CGColorSpaceRef will be retained by this function. It
 *                      will be released when the vImageConverter is destroyed.
 *
 *  @param destFormat   A pointer to a populated vImage_CGImageFormat struct describing the image format
 *                      of the destination image. If the CGColorSpaceRef is NULL, sRGB will be
 *                      used as the default value. The CGColorSpaceRef will be retained by this function.
 *                      It will be released when the vImageConverter is destroyed.
 *
 *  @param  backgroundColor Points to an array of floats to be used as a background color if one is needed. The
 *                      backgroundColor range is assumed to be [0,1]. The channel ordering and number of color
 *                      channels must match the natural order of the destination colorSpace (e.g. RGB or CMYK).
 *                      The backgroundColor may be NULL if no background color is needed.
 *
 *                      A background color is used when the image is converted from an alpha-containing format
 *                      to an alpha-none format, in which case the alpha is removed by compositing against the
 *                      opaque background color pointed to by this parameter. If the image is instead converted
 *                      from one alpha containing format to another, then the image will be premultiplied or
 *                      unpremultiplied as necessary and no background color is necessary. (For unpremultiplication,
 *                      the result color value for pixels with alpha 0 is 0.)  Likewise, when converting between
 *                      alpha-none formats, a background color is not use. In the case of kCGImageAlphaNone ->
 *                      kCGImageAlphaNoneSkipFirst/Last, the vacant alpha channel is filled in with 1.0. If NULL
 *                      is passed here, then 0 will be used for the color channels.
 *
 *                      The vImageConverter will contain a copy of the data passed in this field.
 *
 *  @param flags        Any of the following flags are allowed:
 *
 *  <pre>@textblock
 *           kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug
 *                                               messages.
 *
 *           kvImageDoNotTile                    A converter created with this flag will operate as if
 *                                               kvImageDoNotTile was passed to vImageConvert_AnyToAny
 *                                               whether it was or not.
 *  @/textblock </pre>
 *
 *  @param error        May be NULL.  If not NULL, then a vImage_Error is returned at the address pointed to by error.
 *                      The vImage_Error will be less than 0 if an error condition occurred. Checking the vImageConverter
 *                      returned to make sure it is non-NULL is sufficient to verify success or failure of the function.
 *
 *                      The following error values can occur:
 *  <pre>@textblock
 *      kvImageNoError                      Success.
 *
 *      kvImageNullPointerArgument          srcFormat and/or destFormat is NULL.
 *
 *      kvImageUnknownFlagsBit              Currently only kvImagePrintDiagnosticsToConsole and kvImageDoNotTile are
 *                                          allowed. All other bits in the flags field must be 0.
 *
 *      kvImageInvalidParameter             backgroundColor is NULL and the conversion needed a backgroundColor
 *
 *      kvImageInvalidImageFormat           bitsPerComponent must be in {1,2,4,5,8,12,16,32}.
 *      kvImageInvalidImageFormat           The base colorspace must be grayscale for destination images using indexed color.
 *      kvImageInvalidImageFormat           The colorspace may be indexed color for images only if it is {1,2,4,8} bitsPerComponent
 *                                          and kCGImageAlphaNone.
 *      kvImageInvalidImageFormat           vImage_CGImageFormat.bitmapInfo & kCGBitmapAlphaInfoMask  does not encode a valid alpha
 *      kvImageInvalidImageFormat           floating point formats must be 16 or 32 bits per component. 16-bit floats are
 *                                          IEEE-754-2008 binary16 interchange format  (a.k.a. OpenEXR half float). 32-bit floats
 *                                          are the standard IEEE-754-2008 binary32 interchange format. (a.k.a float in C/C++/ObjC)
 *      kvImageInvalidImageFormat           format->renderingIntent is not a known value
 *      kvImageInvalidImageFormat           The conversion called for conversion to an input-only colorspace. Some color profiles
 *                                          (e.g. those arising from a scanner) are described as input only, because the device can
 *                                          not produce image output.
 *
 *      kvImageInvalidImageFormat           codeFragment was found to be otherwise invalid / unusable
 *
 *      kvImageInternalError                The converter was unable to find a path from the source format to the destination format.
 *                                          This should not happen and indicates incorrect operation of the function. Please file a bug.
 *                                          The kvImagePrintDiagnosticsToConsole flag will provide additional diagnostic info.
 *  @/textblock </pre>
 *
 *          In cases where the error code is not sufficient to quickly determine the problem, the kvImagePrintDiagnosticsToConsole flag
 *          should provide additional diagnostic info.
 *
 *  @return  A vImageConverter object with reference count of 1 is created. If the call fails due to an error, then NULL
 *  will be returned. Use vImageConverter_Release to release your reference to it and allow the resources used
 *  by the converter to be returned to the system.
 *
 *  If error is not NULL, an error code will be written to that address on return.
 *
 */
    
vImageConverterRef vImageConverter_CreateWithColorSyncCodeFragment( CFTypeRef codeFragment,
                                                                    const vImage_CGImageFormat *srcFormat,
                                                                    const vImage_CGImageFormat *destFormat,
                                                                    const CGFloat *backgroundColor,         
                                                                    vImage_Flags flags,
                                                                    vImage_Error *error )
                                                                    VIMAGE_NON_NULL(1,2)
                                                                    __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );

    
/*!
 * @function  vImageConverter_MustOperateOutOfPlace
 * @abstract  Determine whether a converter is capable of operating in place. 
 * @discussion  Some conversions will work if the src and destination image buffer
 *              scanlines start at the same address. Others will not. In such cases, 
 *              you need to allocate additional storage to hold the destination buffer.
 *              This function returns kvImageOutOfPlaceOperationRequired if the conversion 
 *              requires out of place operation. 
 *
 *  <pre>@textblock
 *       In-place operation is considered to mean srcs[i].data = dests[i].data
 *       and srcs[i].rowBytes = dests[i].rowBytes. Other styles of partial buffer
 *       overlap produce undefined behavior.
 *  @/textblock </pre>
 *
 *  The list of source and destination buffers is optional. Results are as follows:
 *
 *  <pre>@textblock
 *      srcs = dests = NULL         kvImageNoError if any conversion with this converter is guaranteed to work in place,
 *                                  provided that srcs[i].data = dests[i].data and srcs[i].rowBytes = dests[i].rowBytes.
 *                                  If there exists at least one combination of height and width for which in place operation
 *                                  is not possible with this converter, then kvImageOutOfPlaceOperationRequired will be returned. 
 *
 *      srcs != NULL, dests = NULL  kvImageNullPointerArgument
 *      srcs = NULL, dests != NULL  kvImageNullPointerArgument
 *  
 *      srcs != NULL, dests != NULL kvImageNoError if the conversion will successfully operate in place for this particular 
 *                                  combination of heights, widths and rowBytes. In this case, vImage does not check to see if the 
 *                                  buffers overlap. It presumes that srcs[i].data = dests[i].data.  This is intended to allow 
 *                                  you to defer allocation until later.  If in place operation will not work, then 
 *                                  kvImageOutOfPlaceOperationRequired is returned. 
 *  @/textblock </pre>
 *
 *  In no case during this function call does vImage examine the contents of the memory pointed to by srcs[i].data or dests[i].data. 
 *
 *  @param converter           The converter to check
 *
 *  @param srcs                The list of source buffers you plan to use with vImageConvert_AnyToAny. May be NULL.
 *  @param dests               The list of destination buffers you plan to use with vImageConvert_AnyToAny. May be NULL.
 *
 *  @param flags               The flags you plan to pass to vImageConvert_AnyToAny.
 *
 *  <pre>@textblock
 *                              Note: in the case of kvImagePrintDiagnosticsToConsole, the flag means print
 *                              error information to the console for errors caught by vImageConverter_MustOperateOutOfPlace,  
 *                              not vImageConvert_AnyToAny. At times, vImageConverter_MustOperateOutOfPlace may fail because 
 *                              it detects an error condition that would cause vImageConvert_AnyToAny to fail.
 *  @/textblock </pre>
 *
 *  @return Error Codes:
 *  <pre>@textblock
 *      kvImageNoError                      In-place operation will work
 *      kvImageNullPointerArgument          The converter may not be NULL
 *      kvImageNullPointerArgument          srcs and dests must either both be NULL or neither must be NULL. 
 *      kvImageInvalidParameter             The converter is invalid
 *      kvImageUnknownFlagsBit              An unknown / unsupported flag was used
 *      kvImageOutOfPlaceOperationRequired  vImageConvert_AnyToAny requires separate buffers be used for this operation
 *  @/textblock </pre>
 */
vImage_Error vImageConverter_MustOperateOutOfPlace( const vImageConverterRef converter,
                                                    const vImage_Buffer *srcs,
                                                    const vImage_Buffer *dests,
                                                    vImage_Flags flags)
                                                    VIMAGE_NON_NULL(1)
                                                    __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    
/*!
 * @function vImageConverter_GetNumberOfSourceBuffers
 * @abstract Get the number of source buffers consumed by the converter.
 * @discussion  All formats discribed by a vImage_CGImageFormat just consume one vImage_Buffer
 *              and produce one vImage_Buffer. There are no multi-plane vImage_CGImageFormats.
 *              However, some video formats (see vImage/vImage_CVUtilities) have planar 
 *              data formats with data in more than one plane. For such conversions, it may be
 *              necessary to know how many input buffers are consumed by a converter.
 *
 *              For older operating systems, where these functions are not available, 
 *              the number of source and destination buffers is always 1.
 *
 * @param converter The conversion for which you wish to know the number of source buffers
 *
 * @return On success, the number of source buffers is returned.  On failure, 0 is returned.
 */
unsigned long vImageConverter_GetNumberOfSourceBuffers( const vImageConverterRef converter ) VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
    
/*!
 * @function vImageConverter_GetNumberOfDestinationBuffers
 * @abstract Get the number of destination buffers written to by the converter.
 * @discussion  All formats discribed by a vImage_CGImageFormat just consume one vImage_Buffer
 *              and produce one vImage_Buffer. There are no multi-plane vImage_CGImageFormats.
 *              However, some video formats (see vImage/vImage_CVUtilities) have planar
 *              data formats with data in more than one plane. For such conversions, it may be
 *              necessary to know how many out buffers are overwritten by a converter.
 *
 *              For older operating systems, where these functions are not available,
 *              the number of source and destination buffers is always 1.
 *
 * @param converter The conversion for which you wish to know the number of result buffers
 *
 * @return On success, the number of result buffers is returned.  On failure, 0 is returned.
 */
unsigned long vImageConverter_GetNumberOfDestinationBuffers( const vImageConverterRef converter ) VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );
    
/*!
 * @enum vImageBufferTypeCode
 *
 * @abstract Type codes for what is in a vImage_Buffer, such as red or luminance or chunky
 *
 * @discussion In rare circumstances, it may be necessary to introspect a vImageConverterRef that consumes
 *             or produces multiple image planes to find out which color channels go into which planes.
 *             See vImageConverter_GetSourceBufferOrder and vImageConverter_GetDestinationBufferOrder.
 *             (This is typically only necessary with video content, because no CG formatted buffers have
 *             multiple planes.)  The vImageBufferTypeCode encodes what kind of data goes into each channel.
 *
 * @constant kvImageBufferTypeCode_Alpha  The buffer contains the alpha channel / coverage component
 *
 * @constant kvImageBufferTypeCode_Indexed  The buffer contains data in an indexed colorspace. This is a 
 *                      planar buffer that is used to index a lookup table of color values. The color 
 *                      values in the table may belong to more than one color component.  Typically the
 *                      colorspace will have a color model of kCGColorSpaceModelIndexed and you will need 
 *                      use CGColorSpaceGetBaseColorSpace to find out what to what color model the lookup
 *                      table maps.
 *
 * @constant kvImageBufferTypeCode_CVPixelBuffer_YCbCr  The buffer contains luminance, and both chroma channels
 *                      interleaved according to the vImageConstCVImageFormatRef image type.
 *
 * @constant kvImageBufferTypeCode_Luminance   The buffer contains only luminance data. 
 *
 * @constant kvImageBufferTypeCode_Chroma       The buffer contains both chrominance channels, interleaved.
 *
 * @constant kvImageBufferTypeCode_Cb           The buffer contains the blue chrominance channel
 *
 * @constant kvImageBufferTypeCode_Cr           The buffer contains the red chrominance channel
 *
 * @constant kvImageBufferTypeCode_CGFormat     The buffer contains data describable as a vImage_CGImageFormat as 
 *                                              a single (likely chunky) buffer
 *
 * @constant kvImageBufferTypeCode_Chunky       The buffer contains chunky data not describable as a vImage_CGImageFormat.
 *
 * @constant kvImageBufferTypeCode_RGB_Red      If the image has a RGB color model, the buffer contains the red channel.
 *
 * @constant kvImageBufferTypeCode_RGB_Green    If the image has a RGB color model, the buffer contains the green channel.
 *
 * @constant kvImageBufferTypeCode_RGB_Blue     If the image has a RGB color model, the buffer contains the blue channel.
 *
 * @constant kvImageBufferTypeCode_CMYK_Cyan    If the image has a CMYK color model, the buffer contains the cyan channel.
 *
 * @constant kvImageBufferTypeCode_CMYK_Magenta If the image has a CMYK color model, the buffer contains the magenta channel.
 *
 * @constant kvImageBufferTypeCode_CMYK_Yellow  If the image has a CMYK color model, the buffer contains the yellow channel.
 *
 * @constant kvImageBufferTypeCode_CMYK_Black   If the image has a CMYK color model, the buffer contains the black channel.
 *
 * @constant kvImageBufferTypeCode_XYZ_X        If the image has a XYZ color model, the buffer contains the X channel.
 *
 * @constant kvImageBufferTypeCode_XYZ_Y        If the image has a XYZ color model, the buffer contains the Y channel.
 *
 * @constant kvImageBufferTypeCode_XYZ_Z        If the image has a XYZ color model, the buffer contains the Z channel.
 *
 * @constant kvImageBufferTypeCode_LAB_L        If the image has a LAB color model, the buffer contains the L* channel.
 *
 * @constant kvImageBufferTypeCode_LAB_A        If the image has a LAB color model, the buffer contains the a* channel.
 *
 * @constant kvImageBufferTypeCode_LAB_B        If the image has a LAB color model, the buffer contains the b* channel.
 */
typedef VIMAGE_CHOICE_ENUM(vImageBufferTypeCode, uint32_t)
{
    kvImageBufferTypeCode_EndOfList = 0,
    
    /* planar formats -- each buffer contains a single color channel, arising from an image described by a colorspace */
    kvImageBufferTypeCode_ColorSpaceChannel1,
    kvImageBufferTypeCode_ColorSpaceChannel2,
    kvImageBufferTypeCode_ColorSpaceChannel3,
    kvImageBufferTypeCode_ColorSpaceChannel4,
    kvImageBufferTypeCode_ColorSpaceChannel5,
    kvImageBufferTypeCode_ColorSpaceChannel6,
    kvImageBufferTypeCode_ColorSpaceChannel7,
    kvImageBufferTypeCode_ColorSpaceChannel8,
    kvImageBufferTypeCode_ColorSpaceChannel9,
    kvImageBufferTypeCode_ColorSpaceChannel10,
    kvImageBufferTypeCode_ColorSpaceChannel11,
    kvImageBufferTypeCode_ColorSpaceChannel12,
    kvImageBufferTypeCode_ColorSpaceChannel13,
    kvImageBufferTypeCode_ColorSpaceChannel14,
    kvImageBufferTypeCode_ColorSpaceChannel15,
    kvImageBufferTypeCode_ColorSpaceChannel16,
    
    /* Coverage component */
    kvImageBufferTypeCode_Alpha,

    /* indexed color spaces */
    kvImageBufferTypeCode_Indexed,

    /* YUV formats.  */
    kvImageBufferTypeCode_CVPixelBuffer_YCbCr,          /* A YCbCr packed buffer formatted according to types in CVPixelBuffer.h. May be accompanied by an alpha channel */
    kvImageBufferTypeCode_Luminance,                    /* A Luminance (Y) plane */
    kvImageBufferTypeCode_Chroma,                       /* A two-channel chroma (CbCr) plane */
    kvImageBufferTypeCode_Cb,                           /* A blue chroma (Cb) plane */
    kvImageBufferTypeCode_Cr,                           /* A red chroma (Cr) plane */
    
    /* A interleaved (chunky) format with one or more channels, encodable as a vImage_CGImageFormat */
    kvImageBufferTypeCode_CGFormat,                     /* always a singleton -- appearing as { kvImageBufferTypeCode_CGFormat, 0} */
                                                        /* prior to OS X.10 and iOS 8.0, all vImageConvert_AnyToAny buffers have this type.*/

    kvImageBufferTypeCode_Chunky,                       /* always a singleton -- appearing as { kvImageBufferTypeCode_Chunky, 0} */
                                                        /* buffer format is not encodable as vImage_CGImageFormat. Not YpCbCr. */

    /* must appear after last unique code */
    kvImageBufferTypeCode_UniqueFormatCount,
    
    /* Convenience codes for better code readability */
    kvImageBufferTypeCode_Monochrome = kvImageBufferTypeCode_ColorSpaceChannel1,
    
    
    kvImageBufferTypeCode_RGB_Red = kvImageBufferTypeCode_ColorSpaceChannel1,
    kvImageBufferTypeCode_RGB_Green = kvImageBufferTypeCode_ColorSpaceChannel2,
    kvImageBufferTypeCode_RGB_Blue = kvImageBufferTypeCode_ColorSpaceChannel3,

    kvImageBufferTypeCode_CMYK_Cyan = kvImageBufferTypeCode_ColorSpaceChannel1,
    kvImageBufferTypeCode_CMYK_Magenta = kvImageBufferTypeCode_ColorSpaceChannel2,
    kvImageBufferTypeCode_CMYK_Yellow = kvImageBufferTypeCode_ColorSpaceChannel3,
    kvImageBufferTypeCode_CMYK_Black = kvImageBufferTypeCode_ColorSpaceChannel4,

    kvImageBufferTypeCode_XYZ_X = kvImageBufferTypeCode_ColorSpaceChannel1,
    kvImageBufferTypeCode_XYZ_Y = kvImageBufferTypeCode_ColorSpaceChannel2,
    kvImageBufferTypeCode_XYZ_Z = kvImageBufferTypeCode_ColorSpaceChannel3,

    kvImageBufferTypeCode_LAB_L = kvImageBufferTypeCode_ColorSpaceChannel1,
    kvImageBufferTypeCode_LAB_A = kvImageBufferTypeCode_ColorSpaceChannel2,
    kvImageBufferTypeCode_LAB_B = kvImageBufferTypeCode_ColorSpaceChannel3,
};
    
/*!
 *  @function vImageConverter_GetSourceBufferOrder
 *
 *  @abstract Get a list of vImage_Buffer channel names specifying the order of planes
 *
 *  @discussion These functions describe the identity of each buffer passed in the srcs parameters of vImageConvert_AnyToAny,
 *  to allow you to order the buffers correctly. It is provided for informational purposes, to help wire up image 
 *  processing pipelines to vImage that are not supported through more direct means, CGImages, CVPixelBuffers, the alternative
 *  handling of which is described at the end of this comment.
 *
 *  Prior to OS X.10 and iOS 8.0, only CG Image formats are handled by vImageConvert_AnyToAny. Had these functions existed
 *  then, the result would always be {kvImageBufferTypeCode_CGFormat, kvImageBufferTypeCode_EndOfList}
 *
 *  <pre>@textblock
 *  Simplified Common Cases
 *  -----------------------
 *    CGImageRefs:
 *      CoreGraphics formats always come as a single buffer, with one or more channels. No buffer ordering is
 *      requred. The buffer order is always kvImageBufferTypeCode_CGFormat. Prior to OS X.10 and iOS 8.0, only
 *      converters to CG image formats are available, so where these functions are not available, the answer would
 *      have always been { kvImageBufferTypeCode_CGFormat, 0}. As a point of trivia, the ordering of the channels
 *      within a buffer is by convention as follows:
 *
 *              number of channels = number of channels in colorspace + (alpha != kCGImageAlphaNone)
 *              alpha is either first or last, given by the alpha component of the CGBitmapInfo
 *              The ordering of the non-alpha channels is given by the colorspace, e.g. {R,G,B} for a RGB image.
 *              For 8-bit images, the ordering of the channels may be reversed according to
 *                  kCGBitmapByteOrderLittleEndian32 or kCGBitmapByteOrderLittleEndian16, but
 *                  the pixel size must match the endian swap chunk size. This gives you access to formats
 *                  like BGRA8888. If the endian is default or big endian, then no swap occurs.
 *
 *    CVPixelBufferRefs:
 *      Though these APIs will work for this purpose, it is expected to be simpler to use vImageBuffer_InitForCopyToCVPixelBuffer
 *      or vImageBuffer_InitForCopyFromCVPixelBuffer to set up a vImage_Buffer array for srcs and dests. Pass kvImageDoNotAllocate
 *      to have it automatically alias a locked CVPixelBuffer. The conversion will then copy the data right into or out of the
 *      CVPixelBuffer without further copying or modification.  (It may still need to be copied out to the GPU, for example, however.)
 *
 *  @/textblock</pre>
 *
 *  @param converter       The conversion for which you wish to know the ordering of source or result buffers.
 *                      converter must be a valid vImageConverterRef.
 *
 *
 *  @return The function returns a kvImageBufferTypeCode_EndOfList terminated array of buffer type codes. The type codes
 *  indicate the order that the vImage_Buffers are passed in to vImageConvert_AnyToAny. The array is valid for the
 *  lifetime of the vImageConverterRef.  It belongs to the vImageConverterRef and should not be freed by you.
 */
const vImageBufferTypeCode * vImageConverter_GetSourceBufferOrder( vImageConverterRef converter )  VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

/*!
 *  @function vImageConverter_GetDestinationBufferOrder
 *
 *  @abstract Get a list of vImage_Buffer channel names specifying the order of planes
 *
 *  @discussion These functions describe the identity of each buffer passed in the dests parameters of vImageConvert_AnyToAny,
 *  to allow you to order the buffers correctly. It is provided for informational purposes, to help wire up image
 *  processing pipelines to vImage that are not supported through more direct means, CGImages, CVPixelBuffers, the alternative
 *  handling of which is described at the end of this comment.
 *
 *  Prior to OS X.10 and iOS 8.0, only CG Image formats are handled by vImageConvert_AnyToAny. Had these functions existed
 *  then, the result would always be {kvImageBufferTypeCode_CGFormat, kvImageBufferTypeCode_EndOfList}
 *
 *  <pre>@textblock
 *  Simplified Common Cases
 *  -----------------------
 *    CGImageRefs:
 *      CoreGraphics formats always come as a single buffer, with one or more channels. No buffer ordering is
 *      requred. The buffer order is always kvImageBufferTypeCode_CGFormat. Prior to OS X.10 and iOS 8.0, only
 *      converters to CG image formats are available, so where these functions are not available, the answer would
 *      have always been { kvImageBufferTypeCode_CGFormat, 0}. As a point of trivia, the ordering of the channels
 *      within a buffer is by convention as follows:
 *
 *              number of channels = number of channels in colorspace + (alpha != kCGImageAlphaNone)
 *              alpha is either first or last, given by the alpha component of the CGBitmapInfo
 *              The ordering of the non-alpha channels is given by the colorspace, e.g. {R,G,B} for a RGB image.
 *              For 8-bit images, the ordering of the channels may be reversed according to
 *                  kCGBitmapByteOrderLittleEndian32 or kCGBitmapByteOrderLittleEndian16, but
 *                  the pixel size must match the endian swap chunk size. This gives you access to formats
 *                  like BGRA8888. If the endian is default or big endian, then no swap occurs.
 *
 *    CVPixelBufferRefs:
 *      Though these APIs will work for this purpose, it is expected to be simpler to use vImageBuffer_InitForCopyToCVPixelBuffer
 *      or vImageBuffer_InitForCopyFromCVPixelBuffer to set up a vImage_Buffer array for srcs and dests. Pass kvImageDoNotAllocate
 *      to have it automatically alias a locked CVPixelBuffer. The conversion will then copy the data right into or out of the
 *      CVPixelBuffer without further copying or modification.  (It may still need to be copied out to the GPU, for example, however.)
 *
 *  @/textblock</pre>
 *
 *  @param converter       The conversion for which you wish to know the ordering of source or result buffers.
 *                      converter must be a valid vImageConverterRef.
 *
 *
 *  @return The function returns a kvImageBufferTypeCode_EndOfList terminated array of buffer type codes. The type codes
 *  indicate the order that the vImage_Buffers are passed in to vImageConvert_AnyToAny. The array is valid for the
 *  lifetime of the vImageConverterRef. It belongs to the vImageConverterRef and should not be freed by you.
 */
const vImageBufferTypeCode * vImageConverter_GetDestinationBufferOrder( vImageConverterRef converter )  VIMAGE_NON_NULL(1) __OSX_AVAILABLE_STARTING( __MAC_10_10, __IPHONE_8_0 );

    
/*!
 *  @function vImageConvert_AnyToAny
 *
 *  @abstract Use a vImageConverterRef to convert the pixels in a vImage_Buffer to another format
 *
 *  @discussion With an appropriately configured vImageConverter, convert the image channels found in srcs
 *  to the image channels found in dests. Whenever possible, conversion passes are vectorized and multithreaded
 *  to reduce the time and energy cost of the function.
 *
 *  Please use vImageConverter_MustOperateOutOfPlace() to determine whether a particular conversion can operate in place.
 *  For an in-place conversion to work, it is required that srcs[i].data = dests[i].data and srcs[i].rowBytes = dests[i].rowBytes.
 *
 *  All scanlines must start at an at least byte aligned address. (Some formats have 1, 2, 4 or 12 bits per channel/pixel and
 *  conceivably might not start at a byte aligned address.) A single byte may not span multiple rows of data. 
 *
 *  Some formats, particarly YUV 422 and 420 and those that have pixel size not evenly divisble by 8 bits, operate in chunks 
 *  containing multiple pixels. For example, a Y'CbCr 422 chunk may have {Y0, Cb, Y1, Cr} in the chunk. The chunk contains two
 *  pixels, each with an independent Y (luminance) component, but shared chrominance.  Even though the chunk width is two, 
 *  it is still possible for an image to have a width that is not divisible by two. This means that some part of the chunk on
 *  the rightmost edge of the scanline must refer to a non-existant pixel. When reading incomplete chunks, vImage will only
 *  touch the unused parts of the chunk when it knows it to be safe to do so. When writing incomplete chunks, vImage will 
 *  copy the rightmost valid pixel color into the unused part of the chunk. Thus, on reading the entire chunk doesn't have to
 *  be there, but on writing, it does. Conventions on this are varied among chunk using imaging pipelines and this conservative
 *  approach should interoperate with most. However, some care must be exercised when writing to chunk based formats (not to be
 *  confused with chunky formats which merely have several channels interleaved) to make sure that the buffer is large enough
 *  to tolerate the write policy.  If you are tiling chunk based data, care must be taken not to run tile boundaries 
 *  through the middle of a chunk.  Chunks are assumed to be indivisible.
 *
 *  @param converter  A valid vImageConverterRef indicating what conversion to do. The same vImageConverterRef
 *                  may be used concurrently from multiple threads. vImageConverterRefs may be created with
 *                  vImageConverter_CreateWithCGImageFormat, vImageConverter_CreateWithColorSyncCodeFragment,
 *                  vImageConverter_CreateForCGToCVImageFormat or vImageConverter_CreateForCVToCGImageFormat.
 *                  May not be NULL.
 *
 *  @param srcs     a pointer to an array of vImage_Buffer structs that describe the color planes that make
 *                  up the input image. Please see the description of the function that created the
 *                  vImageConverter for the ordering and number of input buffers. The ordering can also be
 *                  determined manually using vImageConverter_GetSourceBufferOrder.
 *
 *  @param dests    a pointer to an array of vImage_Buffer structs that describe the color planes that make
 *                  up the result image. Please see the description of the function that created the
 *                  vImageConverter for the ordering and number of output buffers. The ordering can also be
 *                  determined manually using vImageConverter_GetSourceBufferOrder. The destination buffer may
 *                  only alias the srcs buffers only if vImageConverter_MustOperateOutOfPlace() returns 0, and
 *                  only if the respective scanlines of the aliasing buffers start at the same address.
 *
 *  @param tempBuffer   May be NULL. If not NULL, the memory pointed to by tempBuffer will be used as scratch space
 *                  by the function. The size of the tempBuffer can be determined by passing kvImageGetTempBufferSize
 *                  to the in the flags parameter. See below. If NULL is passed here and a tempBuffer is needed '
 *                  (temp buffer size > 0) then the function will allocate one on the heap and free it before
 *                  returning. This may run more slowly, both because of the allocation cost and the cost of VM
 *                  faults to zero fill pages as they are used. NULL is the right option when the function is
 *                  used infrequently or convenience is valued.
 *
 *  @param flags    The following flags are allowed. Other flags will trigger an error.
 *
 *  <pre>@textblock
 *                  kvImagePrintDiagnosticsToConsole    In the event of a problem, print out some helpful debug messages.
 *
 *                  kvImageGetTempBufferSize            No image conversion work is done. The value returned out the
 *                                                      left hand side of the function is the an error code if it is
 *                                                      less than zero. Otherwise, it is the size of the tempBuffer
 *                                                      to be passed into the function. The size may be 0.
 *
 *                  kvImageDoNotTile                    Disables internal multithreading.  You may wish to pass this
 *                                                      flag if you are doing your own threading and think it will
 *                                                      conflict with vImage's attempts to do the same.
 *
 *                  kvImageNoFlags                      Default behavior.
 *  @/textblock </pre>
 *
 *  @return  The following error codes may be returned:
 *  <pre>@textblock
 *      kvImageNoError                      Success!
 *
 *      0                                   kvImageGetTempBufferSize was passed in flags, and no temp buffer is needed.
 *
 *      >0                                  kvImageGetTempBufferSize was passed in flags. The value indicates the size
 *                                          of the temp buffer needed.
 *
 *      kvImageMemoryAllocationError        NULL was passed in tempBuffer and vImage failed to allocate its own
 *                                              temp buffer
 *      kvImageBufferSizeMismatch           The source buffer(s) must be at least as large as the destination buffer(s)
 *                                           (src.height >= dest.height && src.width >= dest.width)
 *      kvImageUnknownFlagsBit              A flag was passed to the vImageConverter creation function which is
 *                                          unrecognized or not appropriate to this function
 *      kvImageNullPointerArgument          converter is NULL
 *      kvImageInvalidParameter             One of the buffers pointed to by srcs or dests has a NULL vImage_Buffer.data pointer
 *      kvImageUnknownFlagsBit              An unknown or unsupported flags bit was set.
 *      kvImageInvalidImageFormat           if a byte ordering is specified (e.g. kCGBitmapByteOrder16Little), the buffer.rowBytes
 *                                          must be multiple of 2 (kCGBitmapByteOrder16Little, kCGBitmapByteOrder16Big) or
 *                                          4 (kCGBitmapByteOrder32Little, kCGBitmapByteOrder32Big)
 *  @/textblock </pre>
 *
 */
vImage_Error vImageConvert_AnyToAny( const vImageConverterRef converter,
                                     const vImage_Buffer * srcs,    /* an array of vImage_Buffer structs describing source data planes */
                                     const vImage_Buffer * dests,   /* an array of vImage_Buffer structs describing destination data planes */
                                     void  *tempBuffer,             /* may be NULL */
                                     vImage_Flags  flags
                                    )
                                    VIMAGE_NON_NULL(1,2,3)
                                    __OSX_AVAILABLE_STARTING( __MAC_10_9, __IPHONE_7_0 );
    
/*
 *  General vImage alignment requirements:
 *  ======================================
 *  All scanlines must be at least byte aligned
 *      A single byte of image data may not span multiple rows of the image.  For example, if the image is 1 bit per pixel monochrome, then
 *      8 pixels fit in a byte. If the width of such an image is not divisible by 8, then the potential exists that the first part of a byte might
 *      lie in one image row and the rest of the byte in the next. It would even be possible that one byte could span up to 8 scanlines if the
 *      image width is 1 pixel! These cases are not allowed. Implicit in the design of using a rowBytes instead of a rowBits describe the image
 *      is that each row must be exactly an integral number of bytes. When the width of the image is such that it would not naturally be so, the
 *      caller must pad out the remaining bits on the image row so that the next row starts on a byte boundary. This is done by setting the rowBytes
 *      to be at least (width * bitsPerPixel + 7) / 8 bytes. When planar images are used then this becomes rowBytes = (width * bitsPerComponent + 7) / 8.
 *
 *      In many cases, images that do not pad rows out to an integral number of bytes can still be processed by vImage by setting
 *      width = height * width and height = 1. However, operating on images with a single row may defeat internal multithreading, so performance
 *      may suffer. (Please use kvImageDoNotTile to defeat internal multithreading if that is your goal. That is its purpose.)  Cleverer schemes that
 *      redivide the image into a larger number of byte aligned rows may be devised.
 *
 *  Some image formats must have 2- or 4-byte aligned scanlines and may need to be host endian
 *      Images with components that are 16-bits in size (e.g. 16U and half float images) or pixels which are 16-bits in size and which do not
 *      have channel boundaries at byte boundaries (e.g. RGB565 and ARGB1555, but not GrayscaleAlpha88) must have vImage_Buffer.data 2-byte aligned and
 *      vImage_Buffer.rowBytes a multiple of 2. Likewise, 32-bits per component (e.g. float or a putative ARGB-2-10-10-10 format) must be 4 byte aligned
 *      and rowBytes a multiple of 4. Failure to conform to 2- and 4-byte alignment restrictions may result in undefined behavior -- at minimum poor
 *      performance and on some systems it can cause a program fault.
 *
 *      Except where otherwise explicitly allowed by the vImageConverter_Create function (e.g. vImage_CGImageFormat.bitmapInfo might be kCGBitmapByteOrder16Big
 *      even on little endian systems) these cases must also conform to the native endianness of the host system. For example, floating-point data on an Intel
 *      system is normally expected to be little-endian unless the converter provides a means to say that it is not. Please see the vImageConverter_Create
 *      function that you plan to use for additional restrictions that may apply.
 *
 *  Performance tips:
 *  =================
 *
 *  Alignment
 *  ---------
 *  Performance will typically improve with even greater alignment up to cacheline aligned image rows. vImageBuffer_Init() can be used to get vImage's
 *  estimation of what sort of row padding is generally likely to work best on the current machine for a given image and pixel size. 
 *
 *  Memory reuse
 *  ------------
 *  It can also be quite helpful to reuse vImage_Buffers and operate in-place so as to avoid spending time in zero-fill faults zeroing the contents 
 *  of newly allocated buffers. (These will show up in Instruments traces as time spent in kernel VM activity.) However, caching unused buffers for 
 *  extended periods of time can contribute to degradation of overall system performance in low memory situations so recycling of buffers is usually 
 *  best done when good temporal locality is expected. LibCache may be helpful for avoiding such problems when it is not known with certainty that the 
 *  buffer will be reused immediately.
 *
 *  Tiling and multithreading
 *  -------------------------
 *  Most vImage functions, including vImageConvert_AnyToAny, will automatically split up work across multiple processors (when available) if there is 
 *  enough image data to warrant it. It can take some time to wake up other processors or redirect their attention from their current task to a new one, 
 *  so multithreading is not attempted if it seems likely the current processor can complete the work before the attention of the other cores can be 
 *  redirected to work on the problem. With some exceptions, the work is typically divided at boundaries between image rows. (To be clear, tiles can be 
 *  taller than just one row.) So, for some functions, if you break up the work to one scanline at a time, it will never multithread. Exactly which functions
 *  do that is subject to change. If you want to stop multithreading, please use kvImageDoNotTile.
 *  
 *  The size of the tile chosen by the function varies by function. Some do little computation and so need the lowest possible load/store latencies to 
 *  run at top speed. Others do more work per byte are consequently not so dependent on low memory access latencies, so may work equally well with tiles 
 *  closer to the size of the L2 or L3 caches and so may use larger tiles. Some computationally intense functions may not care if the data is in cache 
 *  at all. Each vImage function will tile its workload as it sees fit without regard to what other vImage functions may have done or plan to do. 
 *
 *  While this scheme generally works well, you can often do much better with a little work especially in cases where multiple vImage functions are called 
 *  back to back for a few reasons: 
 *
 *      First of all, if the image is larger than the caches, then as new pixels are produced, they will cause earlier result pixels from the same image 
 *  to be flushed to more remote levels of the cache or ultimately out to DRAM (or even disk in low memory situations!) to make room for the new results. When 
 *  it is time to call the next vImage function on the result, you may find that even though you just worked on it, part of the image is not in the cache and 
 *  so you have to pay some time to load it back in again when it as needed. This can happen over and over again with each new vImage filter.  A similar 
 *  story may occur for smaller images as data is flushed from level 1 to level 2 to level 3 of the cache to make room for new data. It would be faster if 
 *  you could somehow move on to the next vImage filter while a region of the image is still in the cache before it is evicted to make room for the rest 
 *  of the image. We will get to the how a little later. 
 *
 *      Second, since processor cores are usually assigned by vImage to work on parts of the image on a first-come first-served basis to keep per-call latency
 *  down, it is probably common that different cores will work on different parts of the image in each successive vImage call, even in cases where the tiling 
 *  strategies between two back to back vImage calls are otherwise similar. That is, in the first vImage function call, the top left corner might be done by 
 *  processor 1 and in the next vImage function call by processor 3. The next time you call the same code, it might be processor 2 and processor 5 that do 
 *  the work on that region. Unfortunately, in many current processor architectures, the faster cache levels (level 1 and 2) are often not shared with most 
 *  of the other cores and it can take more time for the other cores to get data from them. It would be faster if you could somehow convince the same core to 
 *  operate on the same region of the image each time, because only then do we have some guarantee that the faster cache levels are doing us any good between 
 *  back to back calls.
 *
 *      Third, just as it may take some time to get all the processors redirected to work on a particular task, you may also lose some time because 
 *  they don't all finish at the same time. Some processors end up waiting for others to finish before the vImage call can return. Here one expects this 
 *  time lost to be a tiny fraction of the overall time for large images, but for medium sized ones it may weigh against overall performance. (Smaller images
 *  may not even bother to multithread in such cases.) When you advance to the next back-to-back vImage call, some of the cores might have gone to sleep or 
 *  moved on to unrelated work waiting for other cores to finish, and now you have to wait for them to get back on task again. You could reduce overall latency
 *  if you could somehow convince the next filter to start on regions that are done without having to wait for all of the regions of the image to be done, 
 *  so that the cores stay busy and don't get distracted. 
 *
 *      Fourth, doing back-to-back-to-back vImage calls probably means having a bunch of intermediate vImage_Buffers hanging around that take up memory.
 *  In cases where the intermediate computation has to be done in some higher precision, like floating-point, some of these can be quite big. It would be
 *  very helpful to somehow make those go away, or at least go on a diet. 
 *
 *  So, how is this collection of problems fixed? Well, first of all, you don't /have/ to fix anything. Even with all of that, it should still work pretty
 *  well. If pretty well is not good enough, then the solution is to manage the threading yourself. Lets say you want to apply 4 vImage filters (A, B, C and 
 *  D) to an image in a back-to-back fashion. First you break up the result image into a bunch of smaller chunks, called tiles. These should be small enough 
 *  to fit conformably in the cache but not so small that we devote too much time doing setup tasks like parameter checking or initializing variables repeatedly. 
 *  (You can figure out the right size later when it all works. Guess for now.) Starting from the result tiles, work backward. For each tile in the output of D, 
 *  figure out which pixels from C are needed as input. This defines the set of tiles produced by C. In cases where the function needs to look at nearby pixels 
 *  to calculate a result pixel (e.g. Convolution or various Morphology filters) then it is possible that the C-produced tiles may overlap a bit. The process is 
 *  then repeated moving backward through B and A until we arrive at the starting image. We can now trace each result tile through a bunch of discrete image 
 *  fragments back up to a region in the original image. Since we know that we have all the input pixels we need to calculate a result tile at each stage, we 
 *  can apply filters A,B,C and D in series to a tile without needing to worry about what is happening in the other tiles. Thus, each tile can be operated on 
 *  by a different thread, and multithreading becomes trivial.
 *
 *  Consider the implications. Since each tile of data is operated on by a single thread and threads usually do not gratuitously hop around from core to core 
 *  (very much) the result from filter A on that tile should usually be in the right L1 or L2 cache when we call filter B to consume the result from A for that region,
 *  provided that we call filter B on that tile from that thread right away and don't run off and do other things. The same goes for filters C and D. So, you 
 *  are now probably getting better-than-good-enough temporal cache locality.  Observe also that it is generally not required that the intermediate (A,B or 
 *  C product) tiles be stored in memory that is contiguous with other tiles from the same intermediate image. They can be their own little chunks of memory 
 *  stored somewhere else. Maybe you even put them on the stack -- which probably will avoid most zero fill faults and is quick to allocate. In fact, if the 
 *  output tiles are of the same size, then as the thread finishes one tile, you can just reuse those small intermediate buffers that hold the intermediate 
 *  tiles for the next tile. The intermediate image then never exists as a whole at any given time and so you never have to allocate storage for most of it.  
 *  This gives you better-than-good-enough memory usage. Floating-point is starting to look a lot better! Next, because each tile is not waiting on its fellows, 
 *  you can begin working on filter B as soon as the thread is done with filter A. There is no more waiting for filter A to be done on the entire image before 
 *  B can be started. Threads go idle less. There is probably still bit of time lost to waiting for cores to spin up and some for the last thread to finish on 
 *  exit, but it is amortized over four filters instead of each filter. 
 *
 *  Recall that in standard opertaion, vImage will still be trying to multithread behind your back for all these little tiles. This will cause the threads to 
 *  oversubscribe the number of cores. Work that was supposed to be done by one thread is now split up to many. Threads may hop around from core to core much 
 *  more looking for a place to run, defeating cache locality. You may spend a lot of time waiting for cores to redirect to the next job with lots of little 
 *  jobs. The Instruments system trace looks like a tangled knot of threads playing musical chairs for a limited number of cores. To stop this, pass the 
 *  kvImageDoNotTile flag to make sure vImage is running only on the thread you assign to it.
 */

    
#ifdef __cplusplus
    }
#endif

#endif  /* vImage_Utilities_h */

                                                                                                                                                                                                                                                                                                                                                  Libraries/                                                                                          0040755 0001750 0001750 00000000000 12612224736 041531  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A                                   libCGInterfaces.tbd                                                                                 0100644 0001750 0001750 00000000542 12571375060 045207  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/Libraries                         ---
archs:           [ i386, x86_64, x86_64h ]
platform:        macosx
install-name:    /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/Libraries/libCGInterfaces.dylib
current-version: 317.2
exports:         
  - archs:           [ i386, x86_64, x86_64h ]
    symbols:         [ _Init_CGInterfaces ]
...
                                                                                                                                                              vImage.tbd                                                                                          0100644 0001750 0001750 00000056111 12571375060 041522  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A                                   ---
archs:           [ i386, x86_64, x86_64h ]
platform:        macosx
install-name:    /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/vImage
current-version: 317.2
exports:         
  - archs:           [ i386, x86_64, x86_64h ]
    symbols:         [ _Init_vImage, _SetvImageThreadCount, _SetvImageThreadState, 
                       _SetvImageVectorAvailable, _kvImageConstDecodeArray0, 
                       _kvImageDecodeArray_16Q12Format, _kvImage_ARGBToYpCbCrMatrix_ITU_R_601_4, 
                       _kvImage_ARGBToYpCbCrMatrix_ITU_R_709_2, _kvImage_YpCbCrToARGBMatrix_ITU_R_601_4, 
                       _kvImage_YpCbCrToARGBMatrix_ITU_R_709_2, _vImageAffineWarpCG_ARGB16S, 
                       _vImageAffineWarpCG_ARGB16U, _vImageAffineWarpCG_ARGB8888, 
                       _vImageAffineWarpCG_ARGBFFFF, _vImageAffineWarpCG_Planar8, 
                       _vImageAffineWarpCG_PlanarF, _vImageAffineWarpD_ARGB16S, 
                       _vImageAffineWarpD_ARGB16U, _vImageAffineWarpD_ARGB8888, 
                       _vImageAffineWarpD_ARGBFFFF, _vImageAffineWarpD_Planar8, 
                       _vImageAffineWarpD_PlanarF, _vImageAffineWarp_ARGB16S, 
                       _vImageAffineWarp_ARGB16U, _vImageAffineWarp_ARGB8888, 
                       _vImageAffineWarp_ARGBFFFF, _vImageAffineWarp_Planar8, 
                       _vImageAffineWarp_PlanarF, _vImageAlphaBlend_ARGB8888, 
                       _vImageAlphaBlend_ARGBFFFF, _vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGB8888, 
                       _vImageAlphaBlend_NonpremultipliedToPremultiplied_ARGBFFFF, 
                       _vImageAlphaBlend_NonpremultipliedToPremultiplied_Planar8, 
                       _vImageAlphaBlend_NonpremultipliedToPremultiplied_PlanarF, 
                       _vImageAlphaBlend_Planar8, _vImageAlphaBlend_PlanarF, 
                       _vImageBoxConvolve_ARGB8888, _vImageBoxConvolve_Planar8, 
                       _vImageBufferFill_ARGB16S, _vImageBufferFill_ARGB16U, 
                       _vImageBufferFill_ARGB8888, _vImageBufferFill_ARGBFFFF, 
                       _vImageBuffer_CopyToCVPixelBuffer, _vImageBuffer_GetSize, 
                       _vImageBuffer_Init, _vImageBuffer_InitForCopyFromCVPixelBuffer, 
                       _vImageBuffer_InitForCopyToCVPixelBuffer, _vImageBuffer_InitWithCGImage, 
                       _vImageBuffer_InitWithCVPixelBuffer, _vImageByteSwap_Planar16U, 
                       _vImageCGImageFormat_GetComponentCount, _vImageCGImageFormat_IsEqual, 
                       _vImageCVImageFormat_Copy, _vImageCVImageFormat_CopyChannelDescription, 
                       _vImageCVImageFormat_CopyConversionMatrix, _vImageCVImageFormat_Create, 
                       _vImageCVImageFormat_CreateWithCVPixelBuffer, _vImageCVImageFormat_GetAlphaHint, 
                       _vImageCVImageFormat_GetChannelCount, _vImageCVImageFormat_GetChannelDescription, 
                       _vImageCVImageFormat_GetChannelNames, _vImageCVImageFormat_GetChromaSiting, 
                       _vImageCVImageFormat_GetColorSpace, _vImageCVImageFormat_GetConversionMatrix, 
                       _vImageCVImageFormat_GetFormatCode, _vImageCVImageFormat_GetUserData, 
                       _vImageCVImageFormat_Release, _vImageCVImageFormat_Retain, 
                       _vImageCVImageFormat_SetAlphaHint, _vImageCVImageFormat_SetChromaSiting, 
                       _vImageCVImageFormat_SetColorSpace, _vImageCVImageFormat_SetUserData, 
                       _vImageClipToAlpha_ARGB8888, _vImageClipToAlpha_ARGBFFFF, 
                       _vImageClipToAlpha_Planar8, _vImageClipToAlpha_PlanarF, 
                       _vImageClipToAlpha_RGBA8888, _vImageClipToAlpha_RGBAFFFF, 
                       _vImageClip_PlanarF, _vImageContrastStretch_ARGB8888, 
                       _vImageContrastStretch_ARGBFFFF, _vImageContrastStretch_Planar8, 
                       _vImageContrastStretch_PlanarF, _vImageConvert_12UTo16U, 
                       _vImageConvert_16Fto16U, _vImageConvert_16Q12to16U, 
                       _vImageConvert_16Q12to8, _vImageConvert_16Q12toF, 
                       _vImageConvert_16SToF, _vImageConvert_16UTo12U, 
                       _vImageConvert_16UToF, _vImageConvert_16UToPlanar8, 
                       _vImageConvert_16Uto16F, _vImageConvert_16Uto16Q12, 
                       _vImageConvert_420Yp8_Cb8_Cr8ToARGB8888, _vImageConvert_420Yp8_CbCr8ToARGB8888, 
                       _vImageConvert_422CbYpCrYp16ToARGB16U, _vImageConvert_422CbYpCrYp16ToARGB8888, 
                       _vImageConvert_422CbYpCrYp8ToARGB8888, _vImageConvert_422CbYpCrYp8_AA8ToARGB8888, 
                       _vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB16Q12, 
                       _vImageConvert_422CrYpCbYpCbYpCbYpCrYpCrYp10ToARGB8888, 
                       _vImageConvert_422YpCbYpCr8ToARGB8888, _vImageConvert_444AYpCbCr16ToARGB16U, 
                       _vImageConvert_444AYpCbCr16ToARGB8888, _vImageConvert_444AYpCbCr8ToARGB8888, 
                       _vImageConvert_444CbYpCrA8ToARGB8888, _vImageConvert_444CrYpCb10ToARGB16Q12, 
                       _vImageConvert_444CrYpCb10ToARGB8888, _vImageConvert_444CrYpCb8ToARGB8888, 
                       _vImageConvert_8to16Q12, _vImageConvert_ARGB1555toARGB8888, 
                       _vImageConvert_ARGB1555toPlanar8, _vImageConvert_ARGB1555toRGB565, 
                       _vImageConvert_ARGB16Q12To422CrYpCbYpCbYpCbYpCrYpCrYp10, 
                       _vImageConvert_ARGB16Q12To444CrYpCb10, _vImageConvert_ARGB16Q12ToRGBA1010102, 
                       _vImageConvert_ARGB16UTo422CbYpCrYp16, _vImageConvert_ARGB16UTo444AYpCbCr16, 
                       _vImageConvert_ARGB16UToARGB8888, _vImageConvert_ARGB16UToRGBA1010102, 
                       _vImageConvert_ARGB16UtoPlanar16U, _vImageConvert_ARGB16UtoRGB16U, 
                       _vImageConvert_ARGB8888To420Yp8_Cb8_Cr8, _vImageConvert_ARGB8888To420Yp8_CbCr8, 
                       _vImageConvert_ARGB8888To422CbYpCrYp16, _vImageConvert_ARGB8888To422CbYpCrYp8, 
                       _vImageConvert_ARGB8888To422CbYpCrYp8_AA8, _vImageConvert_ARGB8888To422CrYpCbYpCbYpCbYpCrYpCrYp10, 
                       _vImageConvert_ARGB8888To422YpCbYpCr8, _vImageConvert_ARGB8888To444AYpCbCr16, 
                       _vImageConvert_ARGB8888To444AYpCbCr8, _vImageConvert_ARGB8888To444CbYpCrA8, 
                       _vImageConvert_ARGB8888To444CrYpCb10, _vImageConvert_ARGB8888To444CrYpCb8, 
                       _vImageConvert_ARGB8888ToARGB16U, _vImageConvert_ARGB8888ToRGB16U, 
                       _vImageConvert_ARGB8888ToRGBA1010102, _vImageConvert_ARGB8888toARGB1555, 
                       _vImageConvert_ARGB8888toARGB1555_dithered, _vImageConvert_ARGB8888toPlanar16Q12, 
                       _vImageConvert_ARGB8888toPlanar8, _vImageConvert_ARGB8888toPlanarF, 
                       _vImageConvert_ARGB8888toRGB565, _vImageConvert_ARGB8888toRGB565_dithered, 
                       _vImageConvert_ARGB8888toRGB888, _vImageConvert_ARGBFFFFtoARGB8888_dithered, 
                       _vImageConvert_ARGBFFFFtoPlanar8, _vImageConvert_ARGBFFFFtoPlanarF, 
                       _vImageConvert_ARGBFFFFtoRGBFFF, _vImageConvert_ARGBToYpCbCr_GenerateConversion, 
                       _vImageConvert_AnyToAny, _vImageConvert_BGRA16UtoRGB16U, 
                       _vImageConvert_BGRA8888toRGB565, _vImageConvert_BGRA8888toRGB565_dithered, 
                       _vImageConvert_BGRA8888toRGB888, _vImageConvert_BGRAFFFFtoRGBFFF, 
                       _vImageConvert_BGRX8888ToPlanar8, _vImageConvert_BGRXFFFFToPlanarF, 
                       _vImageConvert_ChunkyToPlanar8, _vImageConvert_ChunkyToPlanarF, 
                       _vImageConvert_FTo16S, _vImageConvert_FTo16U, _vImageConvert_Fto16Q12, 
                       _vImageConvert_Indexed1toPlanar8, _vImageConvert_Indexed2toPlanar8, 
                       _vImageConvert_Indexed4toPlanar8, _vImageConvert_Planar16FtoPlanar8, 
                       _vImageConvert_Planar16FtoPlanarF, _vImageConvert_Planar16Q12toARGB8888, 
                       _vImageConvert_Planar16Q12toRGB888, _vImageConvert_Planar16UtoARGB16U, 
                       _vImageConvert_Planar16UtoRGB16U, _vImageConvert_Planar1toPlanar8, 
                       _vImageConvert_Planar2toPlanar8, _vImageConvert_Planar4toPlanar8, 
                       _vImageConvert_Planar8To16U, _vImageConvert_Planar8ToARGBFFFF, 
                       _vImageConvert_Planar8ToBGRX8888, _vImageConvert_Planar8ToBGRXFFFF, 
                       _vImageConvert_Planar8ToXRGB8888, _vImageConvert_Planar8ToXRGBFFFF, 
                       _vImageConvert_Planar8toARGB1555, _vImageConvert_Planar8toARGB8888, 
                       _vImageConvert_Planar8toIndexed1, _vImageConvert_Planar8toIndexed2, 
                       _vImageConvert_Planar8toIndexed4, _vImageConvert_Planar8toPlanar1, 
                       _vImageConvert_Planar8toPlanar16F, _vImageConvert_Planar8toPlanar2, 
                       _vImageConvert_Planar8toPlanar4, _vImageConvert_Planar8toPlanarF, 
                       _vImageConvert_Planar8toRGB565, _vImageConvert_Planar8toRGB888, 
                       _vImageConvert_PlanarFToARGB8888, _vImageConvert_PlanarFToBGRX8888, 
                       _vImageConvert_PlanarFToBGRXFFFF, _vImageConvert_PlanarFToXRGB8888, 
                       _vImageConvert_PlanarFToXRGBFFFF, _vImageConvert_PlanarFtoARGBFFFF, 
                       _vImageConvert_PlanarFtoPlanar16F, _vImageConvert_PlanarFtoPlanar8, 
                       _vImageConvert_PlanarFtoPlanar8_dithered, _vImageConvert_PlanarFtoRGBFFF, 
                       _vImageConvert_PlanarToChunky8, _vImageConvert_PlanarToChunkyF, 
                       _vImageConvert_RGB16UToARGB8888, _vImageConvert_RGB16UtoARGB16U, 
                       _vImageConvert_RGB16UtoBGRA16U, _vImageConvert_RGB16UtoPlanar16U, 
                       _vImageConvert_RGB16UtoRGBA16U, _vImageConvert_RGB565toARGB1555, 
                       _vImageConvert_RGB565toARGB8888, _vImageConvert_RGB565toBGRA8888, 
                       _vImageConvert_RGB565toPlanar8, _vImageConvert_RGB565toRGB888, 
                       _vImageConvert_RGB565toRGBA5551, _vImageConvert_RGB565toRGBA8888, 
                       _vImageConvert_RGB888toARGB8888, _vImageConvert_RGB888toBGRA8888, 
                       _vImageConvert_RGB888toPlanar16Q12, _vImageConvert_RGB888toPlanar8, 
                       _vImageConvert_RGB888toRGB565_dithered, _vImageConvert_RGB888toRGBA8888, 
                       _vImageConvert_RGBA1010102ToARGB16Q12, _vImageConvert_RGBA1010102ToARGB16U, 
                       _vImageConvert_RGBA1010102ToARGB8888, _vImageConvert_RGBA16UtoRGB16U, 
                       _vImageConvert_RGBA5551toRGB565, _vImageConvert_RGBA5551toRGBA8888, 
                       _vImageConvert_RGBA8888toRGB565, _vImageConvert_RGBA8888toRGB565_dithered, 
                       _vImageConvert_RGBA8888toRGB888, _vImageConvert_RGBA8888toRGBA5551, 
                       _vImageConvert_RGBA8888toRGBA5551_dithered, _vImageConvert_RGBAFFFFtoRGBFFF, 
                       _vImageConvert_RGBFFFtoARGBFFFF, _vImageConvert_RGBFFFtoBGRAFFFF, 
                       _vImageConvert_RGBFFFtoPlanarF, _vImageConvert_RGBFFFtoRGB888_dithered, 
                       _vImageConvert_RGBFFFtoRGBAFFFF, _vImageConvert_XRGB8888ToPlanar8, 
                       _vImageConvert_XRGBFFFFToPlanarF, _vImageConvert_YpCbCrToARGB_GenerateConversion, 
                       _vImageConverter_CreateForCGToCVImageFormat, _vImageConverter_CreateForCVToCGImageFormat, 
                       _vImageConverter_CreateWithCGImageFormat, _vImageConverter_CreateWithColorSyncCodeFragment, 
                       _vImageConverter_GetDestinationBufferOrder, _vImageConverter_GetNumberOfDestinationBuffers, 
                       _vImageConverter_GetNumberOfSourceBuffers, _vImageConverter_GetSourceBufferOrder, 
                       _vImageConverter_MustOperateOutOfPlace, _vImageConverter_Print, 
                       _vImageConverter_Release, _vImageConverter_Retain, 
                       _vImageConvolveMultiKernel_ARGB8888, _vImageConvolveMultiKernel_ARGBFFFF, 
                       _vImageConvolveWithBias_ARGB8888, _vImageConvolveWithBias_ARGBFFFF, 
                       _vImageConvolveWithBias_Planar8, _vImageConvolveWithBias_PlanarF, 
                       _vImageConvolve_ARGB8888, _vImageConvolve_ARGBFFFF, 
                       _vImageConvolve_Planar8, _vImageConvolve_PlanarF, 
                       _vImageCopyBuffer, _vImageCreateCGImageFromBuffer, 
                       _vImageCreateGammaFunction, _vImageCreateMonochromeColorSpaceWithWhitePointAndTransferFunction, 
                       _vImageCreateRGBColorSpaceWithPrimariesAndTransferFunction, 
                       _vImageDestroyGammaFunction, _vImageDestroyResamplingFilter, 
                       _vImageDilate_ARGB8888, _vImageDilate_ARGBFFFF, 
                       _vImageDilate_Planar8, _vImageDilate_PlanarF, _vImageEndsInContrastStretch_ARGB8888, 
                       _vImageEndsInContrastStretch_ARGBFFFF, _vImageEndsInContrastStretch_Planar8, 
                       _vImageEndsInContrastStretch_PlanarF, _vImageEqualization_ARGB8888, 
                       _vImageEqualization_ARGBFFFF, _vImageEqualization_Planar8, 
                       _vImageEqualization_PlanarF, _vImageErode_ARGB8888, 
                       _vImageErode_ARGBFFFF, _vImageErode_Planar8, _vImageErode_PlanarF, 
                       _vImageExtractChannel_ARGB16U, _vImageExtractChannel_ARGB8888, 
                       _vImageExtractChannel_ARGBFFFF, _vImageFlatten_ARGB16Q12, 
                       _vImageFlatten_ARGB16U, _vImageFlatten_ARGB8888, 
                       _vImageFlatten_ARGB8888ToRGB888, _vImageFlatten_ARGBFFFF, 
                       _vImageFlatten_ARGBFFFFToRGBFFF, _vImageFlatten_BGRA8888ToRGB888, 
                       _vImageFlatten_BGRAFFFFToRGBFFF, _vImageFlatten_RGBA16Q12, 
                       _vImageFlatten_RGBA16U, _vImageFlatten_RGBA8888, 
                       _vImageFlatten_RGBA8888ToRGB888, _vImageFlatten_RGBAFFFF, 
                       _vImageFlatten_RGBAFFFFToRGBFFF, _vImageGamma_Planar8toPlanarF, 
                       _vImageGamma_PlanarF, _vImageGamma_PlanarFtoPlanar8, 
                       _vImageGetMinimumGeometryTempBufferSize, _vImageGetMinimumTempBufferSizeForConvolution, 
                       _vImageGetMinimumTempBufferSizeForHistogram, _vImageGetMinimumTempBufferSizeForMinMax, 
                       _vImageGetResamplingFilterExtent, _vImageGetResamplingFilterSize, 
                       _vImageHistogramCalculation_ARGB8888, _vImageHistogramCalculation_ARGBFFFF, 
                       _vImageHistogramCalculation_Planar8, _vImageHistogramCalculation_PlanarF, 
                       _vImageHistogramSpecification_ARGB8888, _vImageHistogramSpecification_ARGBFFFF, 
                       _vImageHistogramSpecification_Planar8, _vImageHistogramSpecification_PlanarF, 
                       _vImageHorizontalReflect_ARGB16S, _vImageHorizontalReflect_ARGB16U, 
                       _vImageHorizontalReflect_ARGB8888, _vImageHorizontalReflect_ARGBFFFF, 
                       _vImageHorizontalReflect_Planar16U, _vImageHorizontalReflect_Planar8, 
                       _vImageHorizontalReflect_PlanarF, _vImageHorizontalShearD_ARGB16S, 
                       _vImageHorizontalShearD_ARGB16U, _vImageHorizontalShearD_ARGB8888, 
                       _vImageHorizontalShearD_ARGBFFFF, _vImageHorizontalShearD_Planar8, 
                       _vImageHorizontalShearD_PlanarF, _vImageHorizontalShear_ARGB16S, 
                       _vImageHorizontalShear_ARGB16U, _vImageHorizontalShear_ARGB8888, 
                       _vImageHorizontalShear_ARGBFFFF, _vImageHorizontalShear_Planar16S, 
                       _vImageHorizontalShear_Planar16U, _vImageHorizontalShear_Planar8, 
                       _vImageHorizontalShear_PlanarF, _vImageInterpolatedLookupTable_PlanarF, 
                       _vImageInvert_16U, _vImageInvert_8, _vImageInvert_F, 
                       _vImageLinearTransform_16Q12to8, _vImageLinearTransform_16Uto8, 
                       _vImageLinearTransform_16UtoF, _vImageLinearTransform_8to16Q12, 
                       _vImageLinearTransform_8to16U, _vImageLinearTransform_8toF, 
                       _vImageLinearTransform_Fto16U, _vImageLinearTransform_Fto8, 
                       _vImageLookupTable_8to64U, _vImageLookupTable_Planar16, 
                       _vImageLookupTable_Planar8toPlanar128, _vImageLookupTable_Planar8toPlanar16, 
                       _vImageLookupTable_Planar8toPlanar24, _vImageLookupTable_Planar8toPlanar48, 
                       _vImageLookupTable_Planar8toPlanar96, _vImageLookupTable_Planar8toPlanarF, 
                       _vImageLookupTable_PlanarFtoPlanar8, _vImageMatrixMultiply_ARGB8888, 
                       _vImageMatrixMultiply_ARGB8888ToPlanar8, _vImageMatrixMultiply_ARGBFFFF, 
                       _vImageMatrixMultiply_ARGBFFFFToPlanarF, _vImageMatrixMultiply_Planar16S, 
                       _vImageMatrixMultiply_Planar8, _vImageMatrixMultiply_PlanarF, 
                       _vImageMax_ARGB8888, _vImageMax_ARGBFFFF, _vImageMax_Planar8, 
                       _vImageMax_PlanarF, _vImageMin_ARGB8888, _vImageMin_ARGBFFFF, 
                       _vImageMin_Planar8, _vImageMin_PlanarF, _vImageMultiDimensionalInterpolatedLookupTable_Planar16Q12, 
                       _vImageMultiDimensionalInterpolatedLookupTable_PlanarF, 
                       _vImageMultidimensionalTable_Create, _vImageMultidimensionalTable_Release, 
                       _vImageMultidimensionalTable_Retain, _vImageNewResamplingFilter, 
                       _vImageNewResamplingFilterForFunctionUsingBuffer, 
                       _vImageOverwriteChannelsWithPixel_ARGB16U, _vImageOverwriteChannelsWithPixel_ARGB8888, 
                       _vImageOverwriteChannelsWithPixel_ARGBFFFF, _vImageOverwriteChannelsWithScalar_ARGB8888, 
                       _vImageOverwriteChannelsWithScalar_ARGBFFFF, _vImageOverwriteChannelsWithScalar_Planar16S, 
                       _vImageOverwriteChannelsWithScalar_Planar16U, _vImageOverwriteChannelsWithScalar_Planar8, 
                       _vImageOverwriteChannelsWithScalar_PlanarF, _vImageOverwriteChannels_ARGB8888, 
                       _vImageOverwriteChannels_ARGBFFFF, _vImagePNGDecompressionFilter, 
                       _vImagePermuteChannelsWithMaskedInsert_ARGB16U, 
                       _vImagePermuteChannelsWithMaskedInsert_ARGB8888, 
                       _vImagePermuteChannelsWithMaskedInsert_ARGBFFFF, 
                       _vImagePermuteChannels_ARGB16U, _vImagePermuteChannels_ARGB8888, 
                       _vImagePermuteChannels_ARGBFFFF, _vImagePermuteChannels_RGB888, 
                       _vImagePiecewiseGamma_Planar16Q12, _vImagePiecewiseGamma_Planar16Q12toPlanar8, 
                       _vImagePiecewiseGamma_Planar8, _vImagePiecewiseGamma_Planar8toPlanar16Q12, 
                       _vImagePiecewiseGamma_Planar8toPlanarF, _vImagePiecewiseGamma_PlanarF, 
                       _vImagePiecewiseGamma_PlanarFtoPlanar8, _vImagePiecewisePolynomial_Planar8toPlanarF, 
                       _vImagePiecewisePolynomial_PlanarF, _vImagePiecewisePolynomial_PlanarFtoPlanar8, 
                       _vImagePiecewiseRational_PlanarF, _vImagePremultipliedAlphaBlendDarken_RGBA8888, 
                       _vImagePremultipliedAlphaBlendLighten_RGBA8888, 
                       _vImagePremultipliedAlphaBlendMultiply_RGBA8888, 
                       _vImagePremultipliedAlphaBlendScreen_RGBA8888, _vImagePremultipliedAlphaBlendWithPermute_ARGB8888, 
                       _vImagePremultipliedAlphaBlendWithPermute_RGBA8888, 
                       _vImagePremultipliedAlphaBlend_ARGB8888, _vImagePremultipliedAlphaBlend_ARGBFFFF, 
                       _vImagePremultipliedAlphaBlend_BGRA8888, _vImagePremultipliedAlphaBlend_BGRAFFFF, 
                       _vImagePremultipliedAlphaBlend_Planar8, _vImagePremultipliedAlphaBlend_PlanarF, 
                       _vImagePremultipliedConstAlphaBlend_ARGB8888, _vImagePremultipliedConstAlphaBlend_ARGBFFFF, 
                       _vImagePremultipliedConstAlphaBlend_Planar8, _vImagePremultipliedConstAlphaBlend_PlanarF, 
                       _vImagePremultiplyData_ARGB16Q12, _vImagePremultiplyData_ARGB16U, 
                       _vImagePremultiplyData_ARGB8888, _vImagePremultiplyData_ARGBFFFF, 
                       _vImagePremultiplyData_Planar8, _vImagePremultiplyData_PlanarF, 
                       _vImagePremultiplyData_RGBA16Q12, _vImagePremultiplyData_RGBA16U, 
                       _vImagePremultiplyData_RGBA8888, _vImagePremultiplyData_RGBAFFFF, 
                       _vImageRichardsonLucyDeConvolve_ARGB8888, _vImageRichardsonLucyDeConvolve_ARGBFFFF, 
                       _vImageRichardsonLucyDeConvolve_Planar8, _vImageRichardsonLucyDeConvolve_PlanarF, 
                       _vImageRotate90_ARGB16S, _vImageRotate90_ARGB16U, 
                       _vImageRotate90_ARGB8888, _vImageRotate90_ARGBFFFF, 
                       _vImageRotate90_Planar16U, _vImageRotate90_Planar8, 
                       _vImageRotate90_PlanarF, _vImageRotate_ARGB16S, 
                       _vImageRotate_ARGB16U, _vImageRotate_ARGB8888, _vImageRotate_ARGBFFFF, 
                       _vImageRotate_Planar8, _vImageRotate_PlanarF, _vImageScale_ARGB16S, 
                       _vImageScale_ARGB16U, _vImageScale_ARGB8888, _vImageScale_ARGBFFFF, 
                       _vImageScale_Planar16S, _vImageScale_Planar16U, 
                       _vImageScale_Planar8, _vImageScale_PlanarF, _vImageSelectChannels_ARGB8888, 
                       _vImageSelectChannels_ARGBFFFF, _vImageSymmetricPiecewisePolynomial_PlanarF, 
                       _vImageTableLookUp_ARGB8888, _vImageTableLookUp_Planar8, 
                       _vImageTentConvolve_ARGB8888, _vImageTentConvolve_Planar8, 
                       _vImageUnpremultiplyData_ARGB16Q12, _vImageUnpremultiplyData_ARGB16U, 
                       _vImageUnpremultiplyData_ARGB8888, _vImageUnpremultiplyData_ARGBFFFF, 
                       _vImageUnpremultiplyData_Planar8, _vImageUnpremultiplyData_PlanarF, 
                       _vImageUnpremultiplyData_RGBA16Q12, _vImageUnpremultiplyData_RGBA16U, 
                       _vImageUnpremultiplyData_RGBA8888, _vImageUnpremultiplyData_RGBAFFFF, 
                       _vImageVerticalReflect_ARGB16S, _vImageVerticalReflect_ARGB16U, 
                       _vImageVerticalReflect_ARGB8888, _vImageVerticalReflect_ARGBFFFF, 
                       _vImageVerticalReflect_Planar16U, _vImageVerticalReflect_Planar8, 
                       _vImageVerticalReflect_PlanarF, _vImageVerticalShearD_ARGB16S, 
                       _vImageVerticalShearD_ARGB16U, _vImageVerticalShearD_ARGB8888, 
                       _vImageVerticalShearD_ARGBFFFF, _vImageVerticalShearD_Planar8, 
                       _vImageVerticalShearD_PlanarF, _vImageVerticalShear_ARGB16S, 
                       _vImageVerticalShear_ARGB16U, _vImageVerticalShear_ARGB8888, 
                       _vImageVerticalShear_ARGBFFFF, _vImageVerticalShear_Planar16S, 
                       _vImageVerticalShear_Planar16U, _vImageVerticalShear_Planar8, 
                       _vImageVerticalShear_PlanarF ]
...
                                                                                                                                                                                                                                                                                                                                                                                                                                                       Current                                                                                             0120777 0001750 0001750 00000000000 12620245063 041074  2A                                                                                                   ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions                                     vImage.tbd                                                                                          0120777 0001750 0001750 00000000000 12620245063 044654  2Versions/Current/vImage.tbd                                                                         ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework                                              vecLib.framework/                                                                                   0040755 0001750 0001750 00000000000 12612224736 035621  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks                                                               Headers                                                                                             0120777 0001750 0001750 00000000000 12620245063 043636  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework                                              Versions/                                                                                           0040755 0001750 0001750 00000000000 12612224736 037431  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework                                              A/                                                                                                  0040755 0001750 0001750 00000000000 12612224736 037611  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions                                     Headers/                                                                                            0040755 0001750 0001750 00000000000 12612224736 041164  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A                                   LinearAlgebra/                                                                                      0040755 0001750 0001750 00000000000 12612224736 043654  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers                           LinearAlgebra.h                                                                                     0100644 0001750 0001750 00000001146 12566175205 046520  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/LinearAlgebra             /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __LINEAR_ALGEBRA_PUBLIC_HEADER__
#define __LINEAR_ALGEBRA_PUBLIC_HEADER__

#ifdef __cplusplus
extern "C" {
#endif

#include <vecLib/LinearAlgebra/base.h>
#include <vecLib/LinearAlgebra/object.h>
#include <vecLib/LinearAlgebra/matrix.h>
#include <vecLib/LinearAlgebra/vector.h>
#include <vecLib/LinearAlgebra/splat.h>
#include <vecLib/LinearAlgebra/arithmetic.h>
#include <vecLib/LinearAlgebra/linear_systems.h>
#include <vecLib/LinearAlgebra/norms.h>

#ifdef __cplusplus
}
#endif

#endif // __LINEAR_ALGEBRA_PUBLIC_HEADER__
                                                                                                                                                                                                                                                                                                                                                                                                                          arithmetic.h                                                                                        0100644 0001750 0001750 00000016653 12566175205 046172  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/LinearAlgebra             /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __LA_ARITHMETIC_HEADER__
#define __LA_ARITHMETIC_HEADER__

/*!
 @abstract
 Transpose a vector or matrix.

 @discussion
 Returns a matrix that is the transpose of the source vector or matrix.  If the
 source object is not a vector or matrix, the returned object will have status
 LA_INVALID_PARAMETER_ERROR.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_transpose(la_object_t matrix);

/*!
 @abstract
 Multiply a matrix or vector by a scalar given by a float.
 
 @discussion
 Returns a matrix whose entries are the product of the scalar and the 
 corresponding element of the source matrix.  If the source object is not
 a vector or matrix, the returned object will have status 
 LA_INVALID_PARAMETER_ERROR.
 
 If the scalar type of matrix is not float LA_PRECISION_MISMATCH_ERROR is 
 returned.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_scale_with_float(la_object_t matrix, float scalar);

/*!
 @abstract
 Multiply a matrix or vector by a scalar given by a double.

 @discussion
 Returns a matrix whose entries are the product of the scalar and the
 corresponding element of the source matrix.  If the source object is not
 a vector or matrix, the returned object will have status
 LA_INVALID_PARAMETER_ERROR.
 
 If the scalar type of matrix is not double LA_PRECISION_MISMATCH_ERROR is
 returned.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_scale_with_double(la_object_t matrix, double scalar);

/*!
 @abstract
 Compute the element-wise sum of two vectors or matrices.
 
 @discussion
 If either source operand is not a vector or matrix or splat, or if both
 operands are splats, the result has status LA_INVALID_PARAMETER_ERROR.
 
 The two operands must have the same dimensions.  If they do not, the result
 will have status LA_DIMENSION_MISMATCH_ERROR.  For simplicity, a vector
 of length n, a 1xn matrix, and an nx1 matrix are all treated as having the
 same dimensions.  If 1xn and nx1 or nx1 and 1xn vectors are passed, an nx1
 vector will be created, otherwise orientation matches input.
 
 The result has the same dimensions as the operands, and each element in
 the result is the sum of the corresponding elements in the source operands.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_sum(la_object_t obj_left, la_object_t obj_right);

/*!
 @abstract
 Compute the element-wise difference of two vectors or matrices.

 @discussion
 If either source operand is not a vector or matrix or splat, or if both
 operands are splats, the result has status LA_INVALID_PARAMETER_ERROR.

 The two operands must have the same dimensions.  If they do not, the result
 will have status LA_DIMENSION_MISMATCH_ERROR.  For simplicity, a vector
 of length n, a 1xn matrix, and an nx1 matrix are all treated as having the
 same dimensions.  If 1xn and nx1 or nx1 and 1xn vectors are passed, an nx1
 vector will be created, otherwise orientation matches input.

 The result has the same dimensions as the operands, and each element in
 the result is given by subtracting the corresponding element of obj_right
 from the corresponding element of obj_left.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_difference(la_object_t obj_left, la_object_t obj_right);

/*!
 @abstract
 Compute the element-wise product of two vectors or matrices.

 @discussion
 If either source operand is not a vector or matrix or splat, or if both
 operands are splats, the result has status LA_INVALID_PARAMETER_ERROR.

 The two operands must have the same dimensions.  If they do not, the result
 will have status LA_DIMENSION_MISMATCH_ERROR.  For simplicity, a vector
 of length n, a 1xn matrix, and an nx1 matrix are all treated as having the
 same dimensions.  If 1xn and nx1 or nx1 and 1xn vectors are passed, an nx1
 vector will be created, otherwise orientation matches input.

 The result has the same dimensions as the operands, and each element in
 the result is the product of the corresponding elements in the source operands.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_elementwise_product(la_object_t obj_left, la_object_t obj_right);

/*!
 @abstract
 Compute the inner product of two vectors.
 
 @discussion
 If either operand is a matrix that is not 1xn or nx1, the result has the
 status LA_INVALID_PARAMETER_ERROR.
 
 If either operand is not a vector or matrix or splat, or if both operands
 are splats, the result has the status LA_INVALID_PARAMETER_ERROR.

 If the lengths of the two operands do not match, the result has the status
 LA_DIMENSION_MISMATCH_ERROR.
 
 Otherwise the result is a 1x1 matrix containing the inner product:
 
        sum_{i=0...length} vector_left[i] * vector_right[i]
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_inner_product(la_object_t vector_left, la_object_t vector_right);

/*!
 @abstract
 Compute the outer product of two vectors.

 @discussion
 Splats are not supported by this function.  If either operand
 is a splat, the result has status LA_INVALID_PARAMETER_ERROR.

 If either operand is a matrix that is not 1xn or nx1, the result has the
 status LA_INVALID_PARAMETER_ERROR.

 If either operand is not a vector or matrix, the result has the status
 LA_INVALID_PARAMETER_ERROR.
 
 Otherwise the result is a matrix containg the outer product.  It has
 length(vector_left) rows and length(vector_right) columns.  The i,jth
 element of the matrix is vector_left[i] * vector_right[j].
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_outer_product(la_object_t vector_left, la_object_t vector_right);

/*!
 @abstract
 Compute a matrix product.

 @discussion
 Left splat operands are treated as 1 x rows(matrix_right) vectors and right 
 splat operands are treated as cols(matrix_left) x 1 vectors.
 
 For convenience, in certain situations vector operands may be implicitly
 transposed.  Specifically,
 
 If cols(matrix_left) == rows(matrix_right)
 	rows(matrix_left) x cols(matrix_right) = matrix_left * matrix_right
 Else if cols(matrix_left) == 1 and rows(matrix_left) == rows(matrix_right)
 	1 x cols(matrix_right) = transpose(matrix_left) * matrix_right
 Else if rows(matrix_right) == 1 and cols(matrix_left) == cols(matrix_right)
 	rows(matrix_left) x 1 = matrix_left * transpose(matrix_right)
 Else
  	result has the status LA_DIMENSION_MISMATCH_ERROR.

 If either operand is not a vector or matrix or splat, or if both operands
 are splats, the result has the status LA_INVALID_PARAMETER_ERROR.

 Otherwise the result is a matrix with 1 row if matrix_left is vector or splat 
 and rows(matrix_left) otherwise, and 1 column if matrix_right is vector or
 splat and cols(matrix_right) otherwise.
 
 If cols(matrix_left) == rows(matrix_right), the i,jth element of the matrix is:
 		sum_{k=0...cols(matrix_left)} matrix_left[i,k] * matrix_right[k,j]
 If cols(matrix_left) == 1 and rows(matrix_left) == rows(matrix_right), the 
    0,jth element of matrix is:
 		sum_{k=0...rows(matrix_right)} matrix_left[k,0] * matrix_right[k,j]
 If rows(matrix_right) == 1 and cols(matrix_left) == cols(matrix_right), the
 	i,0th element of matrix is:
 	sum_{k=0...cols(matrix_left)} matrix_left[i,k] * matrix_right[0,k]
 
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_matrix_product(la_object_t matrix_left,
                              la_object_t matrix_right);

#endif // __LA_ARITHMETIC_HEADER__
                                                                                     base.h                                                                                              0100644 0001750 0001750 00000007316 12566175205 044747  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/LinearAlgebra             /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __LA_BASE_HEADER__
#define __LA_BASE_HEADER__

#include <os/object.h>
#include <stddef.h>
#include <Availability.h>

/*  Define abstractions for a number of attributes that we wish to be able to
    consisely attach to functions in the LinearAlgebra library.             */
#define LA_AVAILABILITY  __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0)
#define LA_NONNULL1      OS_NONNULL1
#define LA_NONNULL       OS_NONNULL_ALL
#define LA_EXPORT        OS_EXPORT
#define LA_NOTHROW       OS_NOTHROW
#define LA_FUNCTION      OS_EXPORT OS_NOTHROW
#define LA_CONST         OS_CONST

/*!
 @typedef la_attribute_t

 @abstract
 Attributes to control the behavior of operations in the LinearAlgebra library.

 @discussion
 These attributes are "sticky"; created objects inherit the inclusive-or of
 the attributes set on their parents at the point that they are created.

 @constant LA_ENABLE_LOGGING
 Computations performed using objects with this attribute print debugging
 information to stderr.
 */
#define LA_DEFAULT_ATTRIBUTES           (0)
#define LA_ATTRIBUTE_ENABLE_LOGGING     (1U << 0)
typedef unsigned long la_attribute_t;

/*!
 @typedef la_status_t

 @abstract
 Status codes for la_object_t objects.

 @discussion
 Every la_object_t object has a status.  If everything has gone well in a
 computation, the status will be LA_STATUS_SUCCESS, which is defined to
 be zero.  Status codes greater than zero indicate warnings, and codes less
 than zero indicate errors.

 Errors and warnings propagate with a computation to all descendants of the
 la_object_t object that produced them.  If a la_object_t object receives an 
 error or warning from both parents, one of them will take precedence over the
 other.  The exact precedence ranking is not defined, but errors always
 supercede warnings.

 @constant LA_SUCCESS
 There are no errors or warnings associated with the la_object_t object.

 @constant LA_WARNING_POORLY_CONDITIONED
 One or more parts of the computation was poorly conditioned numerically, and
 the results are signficantly less accurate than might otherwise expected.

 @constant LA_INTERNAL_ERROR
 An error was encountered internal to the LinearAlgebra library.  For example, 
 an allocation failed, or memory was corrupted.

 @constant LA_INVALID_PARAMETER_ERROR
 An invalid parameter was passed to the function that created this object or
 one of it's ancestors.

 @constant LA_DIMENSION_MISMATCH_ERROR
 The function that created this object or one of its ancestors was passed
 arguments whose dimensions were not compatibile.  For example, this error
 might be generated by attempting to add a 63-element vector to a 135-element
 vector, or to multiply a 10x4 matrix by a 7x128 matrix.

 @constant LA_PRECISION_MISMATCH_ERROR
 The function that created this object or one of its ancestors was passed
 arguments whose underlying scalar types did not match.

 @constant LA_SINGULAR_ERROR
 One or more parts of the computation attempted to solve a singular system,
 and no correct result is possible.
 */
#define LA_SUCCESS                       (0)
#define LA_WARNING_POORLY_CONDITIONED    (1000)
#define LA_INTERNAL_ERROR                (-1000)
#define LA_INVALID_PARAMETER_ERROR       (-1001)
#define LA_DIMENSION_MISMATCH_ERROR      (-1002)
#define LA_PRECISION_MISMATCH_ERROR      (-1003)
#define LA_SINGULAR_ERROR                (-1004)
#define LA_SLICE_OUT_OF_BOUNDS_ERROR     (-1005)
typedef long la_status_t;

#define LA_SCALAR_TYPE_FLOAT  (0x8000)
#define LA_SCALAR_TYPE_DOUBLE (0x4000)
typedef unsigned int la_scalar_type_t;

typedef unsigned long la_count_t;
typedef long la_index_t;

typedef void (*la_deallocator_t)(void *ptr);

#endif // defined __LA_BASE_HEADER__
                                                                                                                                                                                                                                                                                                                  linear_systems.h                                                                                    0100644 0001750 0001750 00000004721 12566175205 047073  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/LinearAlgebra             /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __LA_LINEAR_SYSTEMS_HEADER__
#define __LA_LINEAR_SYSTEMS_HEADER__

/*!
 @abstract
 Solves a system of linear equations
 
 @param matrix_system
 A matrix describing the left-hand side of the system.
 
 @param obj_rhs
 A vector or matrix describing one or more right-hand sides for which the
 equations are to be solved.
 
 @return
 A matrix of the solution(s) of the system of equations.

 @discussion
 If matrix_system represents a matrix A, and obj_rhs represents a vector
 B, la_solve returns a vector X representing a solution to the equation
 AX = B, if such a solution exists.  If obj_rhs represents a matrix, then
 la_solve returns a matrix representing the solution of the same equation.
 
 There are several different cases, and different algorithms are chosen
 depending on the specifics:
 
 If the matrix has a special structure that allows us to solve the system
 without factoring (e.g. if the matrix is diagonal or triangular), we may
 use that structure to compute the solution.
 
 If the matrix is symmetric and all diagonal entries are positive, or if we
 know, either via a hint parameter or by how earlier computations were
 structured, that the matrix is positive definite, we attempt a Cholesky
 factorization.  If this succeeds, it is used to compute the solution via
 forward- and back-substitution.
 
 If the matrix is square, we try to perform Gaussian elimination to construct
 a triangular factorization with pivoting.  If this factorization succeeds,
 we use it to solve the system.  If it fails, the returned object has the
 error status LA_SINGULAR_ERROR.
 
 If the matrix is not square, we return a least-squares solution computed by
 performing a QR factorization of the matrix.
 
 If the number of rows of the matrix does not match the number of rows of
 the right hand side object, the returned object has status 
 LA_DIMENSION_MISMATCH_ERROR.
 
 If the object describing the matrix is not a matrix, or if the right hand
 side is not a matrix or vector, the returned object has status
 LA_INVALID_PARAMETER_ERROR.
 
 If you want to solve the system XA = B, which is less common (but still
 occurs fairly frequently), you may accomplish this by transposing A and B,
 solving, and then transposing the result of the solve.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_solve(la_object_t matrix_system, la_object_t obj_rhs);

#endif // __LA_ARITHMETIC_HEADER__
                                               matrix.h                                                                                            0100644 0001750 0001750 00000047561 12566175205 045347  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/LinearAlgebra             /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __LA_MATRIX_HEADER__
#define __LA_MATRIX_HEADER__

/*!
 @brief When creating a matrix object from existing data, these hints allow the
 user to pass useful information about the structure of the matrix.

 @discussion When creating a matrix container from an existing buffer, these
 hints allow the user to pass useful information about the traits of the
 matrix.  Increasing the amount of information known about a matrix can in some
 cases improve performance.  Consider the extreme where a matrix is a diagonal
 matrix.  When multiplying this matrix with another, if it was not known to be
 diagonal the cost would be O(N^3) but the extra information allows the cost
 to drop to O(N^2).

 In many cases, the framework can inspect the data to determine this information
 when it is not made available by hint, but for certain traits, such as
 symmetric positive definiteness, this can be a costly operation, especially if
 the user already knows the trait to be true.

 These are however hints, an incorrect hint will not break the intended
 operation, in the worst case it adds overhead.  When in doubt, it is
 recommended that rather than guessing, if no information is known, use
 LA_NO_HINT.
 */
#define LA_NO_HINT                       (0U)
#define LA_SHAPE_DIAGONAL                (1U << 0)
#define LA_SHAPE_LOWER_TRIANGULAR        (1U << 1)
#define LA_SHAPE_UPPER_TRIANGULAR        (1U << 2)
#define LA_FEATURE_SYMMETRIC             (1U << 16)
#define LA_FEATURE_POSITIVE_DEFINITE     (1U << 17)
#define LA_FEATURE_DIAGONALLY_DOMINANT   (1U << 18)
typedef unsigned long la_hint_t;

/*!
 @abstract
 Create a matrix using data from a buffer of floats.  Ownership of the buffer
 remains in control of the caller.

 @param buffer
 Pointer to float data providing the elements of the matrix.

 @param matrix_rows
 The number of rows in the matrix.

 @param matrix_cols
 The number of columns in the matrix.

 @param matrix_row_stride
 The offset in the buffer (measured in floats) between corresponding elements
 in consecutive rows of the matrix.  Must be positive.

 @param matrix_hint
 Flags describing special matrix structures.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the matrix.

 @discussion
 This function creates an object representing a matrix whose entries are
 copied out of the supplied buffer of floats.  Negative or zero strides
 are not supported by this function (but note that you can reverse the
 rows or columns using the la_matrix_slice function defined below).

 This routine assumes that the elements of the matrix are stored in the buffer
 in row-major order.  If you need to work with data that is in column-major
 order, you can do that as follows:

 1. Use this routine to create a matrix object, but pass the number of
 columns in your matrix for the matrix_rows parameter and vice-versa.  For
 the matrix_row_stride parameter, pass the column stride of your matrix.

 2. Make a new matrix transpose object from the object created in step 1.  The
 resulting object represents the matrix that you want to work with.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_matrix_from_float_buffer(const float *buffer,
                                           la_count_t matrix_rows,
                                           la_count_t matrix_cols,
                                           la_count_t matrix_row_stride,
                                           la_hint_t matrix_hint,
                                           la_attribute_t attributes);

/*!
 @abstract
 Create a matrix using data from a buffer of doubles.  Ownership of the buffer
 remains in control of the caller.

 @param buffer
 Pointer to double data providing the elements of the matrix.

 @param matrix_rows
 The number of rows in the matrix.

 @param matrix_cols
 The number of columns in the matrix.

 @param matrix_row_stride
 The offset in the buffer (measured in doubles) between corresponding elements
 in consecutive rows of the matrix.  Must be positive.

 @param matrix_hint
 Flags describing special matrix structures.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the matrix.

 @discussion
 This function creates an object representing a matrix whose entries are
 copied out of the supplied buffer of doubles.  Negative or zero strides
 are not supported by this function (but note that you can reverse the
 rows or columns using the la_matrix_slice function defined below).

 This routine assumes that the elements of the matrix are stored in the buffer
 in row-major order.  If you need to work with data that is in column-major
 order, you can do that as follows:

 1. Use this routine to create a matrix object, but pass the number of
 columns in your matrix for the matrix_rows parameter and vice-versa.  For
 the matrix_row_stride parameter, pass the column stride of your matrix.

 2. Make a new matrix transpose object from the object created in step 1.  The
 resulting object represents the matrix that you want to work with.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_matrix_from_double_buffer(const double *buffer,
                                            la_count_t matrix_rows,
                                            la_count_t matrix_cols,
                                            la_count_t matrix_row_stride,
                                            la_hint_t matrix_hint,
                                            la_attribute_t attributes);

/*!
 @abstract
 Create a matrix using data from a buffer of floats.  Ownership of the buffer
 is transferred from the caller to the returned object.

 @param buffer
 Pointer to float data providing the elements of the matrix.

 @param matrix_rows
 The number of rows in the matrix.

 @param matrix_cols
 The number of columns in the matrix.

 @param matrix_row_stride
 The offset in the buffer (measured in floats) between corresponding elements
 in consecutive rows of the matrix.  Must be positive.

 @param matrix_hint
 Flags describing special matrix structures.

 @param deallocator
 Callback to be used to deallocate the buffer when the returned matrix object
 is destroyed.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the matrix.

 @discussion
 This function creates an object representing a matrix whose entries are
 copied out of the supplied buffer of floats.  Negative or zero strides
 are not supported by this function (but note that you can reverse the
 rows or columns using the la_matrix_slice function defined below).

 This routine assumes that the elements of the matrix are stored in the buffer
 in row-major order.  If you need to work with data that is in column-major
 order, you can do that as follows:

 1. Use this routine to create a matrix object, but pass the number of
 columns in your matrix for the matrix_rows parameter and vice-versa.  For
 the matrix_row_stride parameter, pass the column stride of your matrix.

 2. Make a new matrix transpose object from the object created in step 1.  The
 resulting object represents the matrix that you want to work with.
 */
LA_FUNCTION LA_NONNULL1 LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_matrix_from_float_buffer_nocopy(float *buffer,
                                                  la_count_t matrix_rows,
                                                  la_count_t matrix_cols,
                                                  la_count_t matrix_row_stride,
                                                  la_hint_t matrix_hint,
                                                  la_deallocator_t deallocator,
                                                  la_attribute_t attributes);

/*!
 @abstract
 Create a matrix using data from a buffer of doubles.  Ownership of the buffer
 is transferred from the caller to the returned object.

 @param buffer
 Pointer to double data providing the elements of the matrix.

 @param matrix_rows
 The number of rows in the matrix.

 @param matrix_cols
 The number of columns in the matrix.

 @param matrix_row_stride
 The offset in the buffer (measured in doubles) between corresponding elements
 in consecutive rows of the matrix.  Must be positive.

 @param matrix_hint
 Flags describing special matrix structures.

 @param deallocator
 Callback to be used to deallocate the buffer when the returned matrix object
 is destroyed.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the matrix.

 @discussion
 This function creates an object representing a matrix whose entries are
 copied out of the supplied buffer of doubles.  Negative or zero strides
 are not supported by this function (but note that you can reverse
 the rows or columns using the la_matrix_slice function defined below).

 This routine assumes that the elements of the matrix are stored in the buffer
 in row-major order.  If you need to work with data that is in column-major
 order, you can do that as follows:

 1. Use this routine to create a matrix object, but pass the number of
 columns in your matrix for the matrix_rows parameter and vice-versa.  For
 the matrix_row_stride parameter, pass the column stride of your matrix.

 2. Make a new matrix transpose object from the object created in step 1.  The
 resulting object represents the matrix that you want to work with.
 */
LA_FUNCTION LA_NONNULL1 LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_matrix_from_double_buffer_nocopy(double *buffer,
                                                   la_count_t matrix_rows,
                                                   la_count_t matrix_cols,
                                                   la_count_t matrix_row_stride,
                                                   la_hint_t matrix_hint,
                                                   la_deallocator_t deallocator,
                                                   la_attribute_t attributes);

/*!
 @abstract
 Stores the elements of a matrix to a buffer.
 
 @param buffer
 Pointer to the destination buffer.
 
 @param buffer_row_stride
 Offset (measured in floats) between the destinations of corresponding elements
 of consecutive rows of the matrix.  Must be positive.
 
 @param matrix
 The matrix to store.
 
 @discussion
 The buffer must be large enough to accomodate the matrix being stored.
 Specifically, it must have sufficient space to hold
 
    buffer_row_stride*(la_matrix_rows(matrix)-1) + la_matrix_cols(matrix)
 
 float elements.
 
 This function supports storing the contents of a vector as well as a matrix.
 A vector of length n will be interpreted as a rows(matrix) x cols(matrix) by 
 this function.  If the object is a vector or matrix and does not have an error 
 status, its contents are stored to the buffer.  If it has an error status, NaNs 
 are stored to the buffer.
 
 If the object is not a matrix or vector, nothing is written to the buffer and
 LA_INVALID_PARAMETER_ERROR is returned.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY
la_status_t la_matrix_to_float_buffer(float *buffer,
                                            la_count_t buffer_row_stride,
                                            la_object_t matrix);

/*!
 @abstract
 Stores the elements of a matrix to a buffer.

 @param buffer
 Pointer to the destination buffer.

 @param buffer_row_stride
 Offset (measured in doubles) between the destinations of corresponding elements
 of consecutive rows of the matrix.  Must be positive.

 @param matrix
 The matrix to store.

 @discussion
 The buffer must be large enough to accomodate the matrix being stored.
 Specifically, it must have sufficient space to hold

    buffer_row_stride*(la_matrix_rows(matrix)-1) + la_matrix_cols(matrix)

 double elements.
 
 This function supports storing the contents of a vector as well as a matrix.
 A vector of length n will be interpreted as a rows(matrix) x cols(matrix) by
 this function.  If the object is a vector or matrix and does not have an error
 status, its contents are stored to the buffer.  If it has an error status, NaNs
 are stored to the buffer.

 If the object is not a matrix or vector, nothing is written to the buffer and
 LA_INVALID_PARAMETER_ERROR is returned.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY
la_status_t la_matrix_to_double_buffer(double *buffer,
                                             la_count_t buffer_row_stride,
                                             la_object_t matrix);

/*!
 @abstract
 Get the number of rows in a matrix.
 
 @discussion
 If the argument has an error status, zero is returned.
 If the argument is a vector, the number of rows may be 1 or length(vector) 
 depending on the orientation of the vector.
 If the argument is a matrix, the number of rows is returned.
 Otherwise, zero is returned.
 */
LA_FUNCTION LA_CONST LA_NONNULL LA_AVAILABILITY
la_count_t la_matrix_rows(la_object_t matrix);

/*!
 @abstract
 Get the number of columns in a matrix.

 @discussion
 If the argument has an error status, zero is returned.
 If the argument is a vector, the number of columns may be 1 or length(vector)
 depending on the orientation of the vector.
 If the argument is a matrix, the number of columns is returned.
 Otherwise, zero is returned.
 */
LA_FUNCTION LA_CONST LA_NONNULL LA_AVAILABILITY
la_count_t la_matrix_cols(la_object_t matrix);

/*!
 @abstract
 Create a slice of a matrix.
 
 @param matrix
 The matrix to be sliced.
 
 @param matrix_first_row
 The index of the row of the source matrix containing the first element of
 new slice matrix.
 
 @param matrix_first_col
 The index of the column of the source matrix containing the first element
 of the slice matrix.
 
 @param matrix_row_stride
 The offset in the source matrix between rows that will be consecutive in
 the slice matrix.
 
 @param matrix_col_stride
 The offset in the source matrix between columns that will be consecutve in
 the slice matrix.
 
 @param slice_rows
 The number of rows in the slice matrix.
 
 @param slice_cols
 The number of columns in the slice matrix.
 
 @return
 A new matrix with size slice_rows x slice_cols whose elements are taken
 from the source matrix.
 
 @discussion
 The result object is the slice_rows x slice_cols matrix whose i,jth entry is:
 
    matrix[matrix_first_row + i*matrix_row_stride,
           matrix_first_col + j*matrix_col_stride]
 
 Slices provide an efficient means to operate on tiles and strides.  These are
 lightweight objects that reference the storage of the matrix from which they
 originate.  In most cases, creating a slice does not require any allocation
 beyond the object representing the slice, nor require copying.  In some 
 less common cases, a copy may be required.
 
 This function supports slicing a vector (interpreted as 
 rows(matrix) x cols(matrix)) or a matrix.  If the object is not a matrix or 
 vector, the returned object will have status LA_INVALID_PARAMETER_ERROR.

 If the slice references indices that are less than zero or greater than or
 equal to the dimensions of the matrix, LA_SLICE_OUT_OF_BOUNDS_ERROR is 
 returned.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_matrix_slice(la_object_t matrix,
                                 la_index_t matrix_first_row,
                                 la_index_t matrix_first_col,
                                 la_index_t matrix_row_stride,
                                 la_index_t matrix_col_stride,
                                 la_count_t slice_rows,
                                 la_count_t slice_cols);

LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_identity_matrix(la_count_t matrix_size,
                                    la_scalar_type_t scalar_type,
                                    la_attribute_t attributes);

/*!
 @abstract
 Create a matrix with a specified diagonal provided by a vector, and zeros in
 all the other entries.
 
 @param vector
 Vector providing the data for the non-zero diagonal.
 
 @param matrix_diagonal
 The index of the non-zero diagonal.
 
 @discussion
 Creates a new matrix with entries on the specified diagonal taken from the
 vector argument, and zeros in the other entries.  The matrix is square, and
 has size length(vector) + abs(matrix_diagonal).
 
 If matrix_diagonal is zero, the main diagonal is set.  If matrix_diagonal is
 +1, the first superdiagonal is set.  If matrix_diagonal is -2, the second
 subdiagonal is set.
 
 The diagonal may be specified by a vector or by a matrix that has only one
 row or only one column.  If the provided object is not a vector or matrix,
 or is a matrix with both dimensions larger than one, the returned object
 will have status LA_INVALID_PARAMETER_ERROR.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_diagonal_matrix_from_vector(la_object_t vector,
                                            la_index_t matrix_diagonal);

/*!
 @abstract
 Creates a vector from the specified row of the matrix.
 
 @param matrix
 Matrix from which to create the row vector.
 
 @param matrix_row.
 The zero-based index of the row to create the vector from.  
 
 @return
 The resulting vector is a 1 x cols(matrix) vector.
 
 @discussion
 Creates a vector from the specified row of the matrix.  If the value for 
 matrix_row is less than zero or greater than rows(matrix)-1,
 LA_INVALID_PARAMETER_ERROR is returned.  
 
 If matrix is a splat, LA_INVALID_PARAMETER_ERROR is returned.

 Always returns a 1 x vector_length vector.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_vector_from_matrix_row(la_object_t matrix,
                                           la_count_t matrix_row);

/*!
 @abstract
 Creates a vector from the specified column of the matrix.
 
 @param matrix
 Matrix from which to create the column vector.
 
 @param matrix_col.
 The zero-based index of the column to create the vector from.
 
 @return
 The resulting vector is a rows(matrix) x 1 vector.
 
 @discussion
 Creates a vector from the specified column of the matrix.  If the value for
 matrix_col is less than zero or greater than cols(matrix)-1,
 LA_INVALID_PARAMETER_ERROR is returned.
 
 If matrix is a splat, LA_INVALID_PARAMETER_ERROR is returned.

 Always returns a vector_length x 1 vector.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_vector_from_matrix_col(la_object_t matrix,
                                           la_count_t matrix_col);

/*!
 @abstract
 Creates a vector from the specified diagonal of the matrix.
 
 @param matrix
 Matrix from which to create the vector.
 
 @param matrix_diagonal.
 The index of the diagonal to create the vector from.
 
 @return
 The resulting vector is a length x 1 vector where length is 
 min(rows(matrix),cols(matrix)-abs(matrix_diagonal)
 
 @discussion
 Creates a new vector with entries on the specified diagonal taken from the
 vector argument, and zeros in the other entries.  The matrix is square, and
 has size length(vector) + abs(matrix_diagonal).
 
 If matrix_diagonal is zero, the main diagonal is set.  If matrix_diagonal is
 +1, the first superdiagonal is set.  If matrix_diagonal is -2, the second
 subdiagonal is set.
 
 Creates a vector from the specified diagonal of the matrix.  If the value for
 matrix_diagonal is less than zero and abs(matrix_diagonal) > rows(matrix)-1,
 or if matrix_diagonal is greater than zero and matrix_diagonal > 
 cols(matrix)-1, LA_INVALID_PARAMETER_ERROR is returned.
 
 If matrix is a splat, LA_INVALID_PARAMETER_ERROR is returned.

 Always returns a vector_length x 1 vector.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_vector_from_matrix_diagonal(la_object_t matrix,
                                              la_index_t matrix_diagonal);

#endif // __LA_MATRIX_HEADER__
                                                                                                                                               norms.h                                                                                             0100644 0001750 0001750 00000002626 12566175205 045172  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/LinearAlgebra             /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __LA_NORMS_HEADER__
#define __LA_NORMS_HEADER__

#define LA_L1_NORM 1
#define LA_L2_NORM 2
#define LA_LINF_NORM 3
typedef unsigned long la_norm_t;

/*!
 @abstract
 Compute a norm of a vector or matrix.

 @discussion
 "vector" refers to the fact that this function computes the norm of its
 argument considered as a vector, and not an operator norm.  The actual
 argument may be either a vector or a matrix.  If it is not a vector or
 matrix, or if the vector_norm parameter is not a supported value, NAN is
 returned.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY
float la_norm_as_float(la_object_t vector, la_norm_t vector_norm);

LA_FUNCTION LA_NONNULL LA_AVAILABILITY
double la_norm_as_double(la_object_t vector, la_norm_t vector_norm);

/*!
 @abstract
 "Normalizes" a vector or matrix.
 
 @discussion
 The returned object has the same direction as the first operand, and has
 norm 1 in the specified vector norm.  If the input vector is zero, it cannot
 be meaningfully normalized and the returned object is also zero.  If the
 parameter vector is not a vector or matrix, or if the vector_norm parameter
 is not a supported value, the returned object has status
 LA_INVALID_PARAMETER_ERROR.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_normalized_vector(la_object_t vector, la_norm_t vector_norm);

#endif
                                                                                                          object.h                                                                                            0100644 0001750 0001750 00000013247 12566175205 045303  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/LinearAlgebra             /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __LA_OBJECT_HEADER__
#define __LA_OBJECT_HEADER__

/*!
 @class la_object_t

 @abstract
 Type used by all functions in the LinearAlgebra library.

 @discussion LinearAlgebra objects behave rather differently depending on 
 whether you are writing Objective-C or C.  For details of semantics and memory 
 management consult the appropriate section below.  For further information, 
 consult the comments in <os/object.h>.

 Objective-C with ARC:
 LinearAlgebra objects are objective-c objects.  This means that
 they participate in ARC, may be used with collections, etc.  Thus, if you are 
 using ARC, you must not retain or release LinearAlgebra objects; the compiler 
 will take care of it for you.

 Objective-C without ARC:
 If you are not using ARC, you send -[retain] and -[release] messages to
 LinearAlgebra objects, just like you would with objects of any other 
 Objective-C type.

 C:
 LinearAlgebra objects are reference counted and must be retained and released
 via the la_retain( ) and la_release( ) functions.  Do not attempt to
 call free( ) on LinearAlgebra objects; this will typically result in leaks.
 */
#if OS_OBJECT_USE_OBJC
    OS_OBJECT_DECL(la_object,);
#   define LA_RETURNS_RETAINED OS_OBJECT_RETURNS_RETAINED
#else
typedef struct la_s *la_object_t;
#   define LA_RETURNS_RETAINED
#endif

/*!
 @abstract
 Increment the reference count of a la_object_t object.

 @param object
 The object to retain.

 @result
 The retained object.

 @discussion
 On a platform with the modern Objective-C runtime this is exactly equivalent
 to sending the object the -[retain] message.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY
la_object_t la_retain(la_object_t object);
#if OS_OBJECT_USE_OBJC
#   undef la_retain
#   define la_retain(object) [object retain]
#endif

/*!
 @abstract
 Decrement the reference count of an la_object_t object.

 @param object
 The object to release.

 @discussion
 On a platform with the modern Objective-C runtime this is exactly equivalent
 to sending the object the -[release] message.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY
void la_release(la_object_t object);
#if OS_OBJECT_USE_OBJC
#   undef la_release
#   define la_release(object) [object release]
#endif

/*!
 @abstract
 Add attributes to an la_object_t object.

 @param object
 The object that will have its attributes modified.

 @param attributes
 Attributes which are to be added to the object's existing attributes
 to create its new set of attributes.  This value should be constructed by
 or'ing together LA_ATTRIBUTE_* constants.

 @discussion
 This operation does not remove any existing attributes from the LinearAlgebra 
 object, though it is possible that some attributes will override others (if so, 
 this will be documented in the discussion of those attributes above).  
 Following this function call, the specified object has all of the attributes it 
 had before the call, plus any new attributes specified by the second parameter.
 
 Adding an attribute that the object already has does not change the object.
 
 This function is not reentrant or thread-safe.  Attempting to add or remove
 attributes from multiple threads will have unpredictable results.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY
void la_add_attributes(la_object_t object, la_attribute_t attributes);

/*!
 @abstract
 Remove attributes from an la_object_t object.

 @param object
 The object that will have its attributes modified.

 @param attributes
 Attributes which are to be removed from the object's existing attributes
 to create its new set of attributes.  This value should be constructed by
 or'ing together LA_ATTRIBUTE_* constants.
 
 @discussion
 This function removes the specified attributes from the LinearAlgebra object.
 Removing an attribute that the object does not have is harmless and does not
 change the object.

 This function is not reentrant or thread-safe.  Attempting to add or remove
 attributes from multiple threads will have unpredictable results.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY
void la_remove_attributes(la_object_t object, la_attribute_t attributes);

/*!
 @abstract Query the status of an la_object.
 
 @param object
 The object whose status is being requested.
 
 @return
 The status of the supplied object.

 @discussion Returns the status of a LinearAlgebra object.  The status will be 
 one of the codes defined in LinearAlgebra/base.h.  New status codes may be
 added in the future, but the following basic principle will continue to hold: 
 zero indicates success, status codes greater than zero are warnings, and
 status codes less than zero are errors.  Thus, careful error handling
 might look like the following:

 <pre>
 @textblock
 la_status_t status = la_status(result_object);
 if (status == LA_SUCCESS) {
    // Everything is copacetic.  Get your data from result_object.
 } else if (status > 0) {
    // No errors occured, but the result does not have full accuracy due to
    // numerical considerations.  Here, you might re-compute the result using
    // a more careful or stable algorithm.
 } else {
    // An error occured.  Something is seriously amiss and you will need
    // to handle it however makes sense for your application.
 }
 @/textblock
 </pre>

 Note that errors and warnings are propagated.  In general, there is no need
 to check the status of each subcomputation.  Rather, the preferred idiom is
 to do a complete computation, then check to see if anything went wrong.
 Querying status may force evaluation of parts of your computation that might
 otherwise be deferred until their results were actually needed.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY
la_status_t la_status(la_object_t object);

#endif // __LA_OBJECTS_HEADER__
                                                                                                                                                                                                                                                                                                                                                         splat.h                                                                                             0100644 0001750 0001750 00000006023 12566175205 045152  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/LinearAlgebra             /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __LA_SPLAT_HEADER__
#define __LA_SPLAT_HEADER__

/*
 Splat objects are a feature that is relatively unique to the LinearAlgebra
 library.

 A splat object represents a matrix or vector whose entries are all equal.
 It may be used in the place of a matrix or vector in many computational
 operations in the library.

 Splat objects are effectively dimensionless matrices.  Computational
 operations that accept them interpret them as having dimensions necessary
 to be compatibile with the other operand.  Because the dimensions of a
 splat are inferred from the other operands, a single operation cannot
 have multiple splat operands.

 A partial list of operations accepting splat operands, and the rules for the
 inferred size:

 Operation                           Inferred Dimensions
 sum(A,splat)                        (rows(A), cols(A))
 sum(splat,A)                        (rows(A), cols(A))
 difference(A,splat)                 (rows(A), cols(A))
 difference(splat,A)                 (rows(A), cols(A))
 elementwise_product(A,splat)        (rows(A), cols(A))
 elementwise_product(splat,A)        (rows(A), cols(A))
 inner_product(A,splat)              (length(A), 1)
 inner_product(splat,A)              (1, length(A))
 matrix_product(A,splat)             (cols(A), 1)
 matrix_product(splat,A)             (1, rows(A))
 */

LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_splat_from_float(float scalar_value,
                                la_attribute_t attributes);

LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_splat_from_double(double scalar_value,
                                 la_attribute_t attributes);

LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_splat_from_vector_element(la_object_t vector,
                                         la_index_t vector_index);

LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_splat_from_matrix_element(la_object_t matrix,
                                         la_index_t matrix_row,
                                         la_index_t matrix_col);

/*
 It is sometimes useful to be able to just generate a matrix or vector with
 fixed dimensions from a splat object, either because the operation you want
 to perform doesn't infer the same dimensions as you would like to use, or
 if the operation you want to perform doesn't support inferring dimensions
 at all.  For this purpose, the following functions are provided.
 
 The vector returned from la_vector_from_splat is always vector_length x 1.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_vector_from_splat(la_object_t splat,
                                 la_count_t vector_length);

LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_matrix_from_splat(la_object_t splat,
                                 la_count_t matrix_rows,
                                 la_count_t matrix_cols);

#endif // __LA_SPLAT_HEADER__
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             vector.h                                                                                            0100644 0001750 0001750 00000027522 12566175205 045340  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/LinearAlgebra             /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __LA_VECTOR_HEADER__
#define __LA_VECTOR_HEADER__

/*!
 @abstract
 Create a vector using data from a buffer of floats.  Ownership of the buffer
 remains in control of the caller.

 @param buffer
 Pointer to float data providing the elements of the vector.  

 @param vector_length
 The length of the vector.

 @param buffer_stride
 The offset in the buffer (measured in floats) between consecutive elements
 of the vector.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the vector.

 @discussion
 This function creates an object representing a vector whose entries are copied
 out of the supplied buffer of floats.  Negative or zero strides are not
 supported by this function (but note that you can reverse the elements in a
 vector using the la_vector_reverse macro defined below).

 The stride determines the offset (measured in floats) between the values
 providing consecutive vector elements in the buffer.  For example, if
 buffer_stride is 1, then the vector is:

 { buffer[0], buffer[1], buffer[2], ... , buffer[vector_length-1] }

 If buffer_stride is 3, the vector is:

 { buffer[0], buffer[3], buffer[6], ... , buffer[3*(vector_length-1)] }

 Thus, the size of the buffer (in floats) should be at least

 buffer_stride*(vector_length-1) + 1.
 
 Always returns a vector_length x 1 vector.
 */
#define la_vector_from_float_buffer(buffer, vector_length, buffer_stride, attributes) \
    la_matrix_from_float_buffer(buffer, vector_length, 1, buffer_stride, LA_NO_HINT, attributes)

/*!
 @abstract
 Create a vector using data from a buffer of doubles.  Ownership of the buffer
 remains in control of the caller.

 @param buffer
 Pointer to double data providing the elements of the vector.

 @param vector_length
 The length of the vector.

 @param buffer_stride
 The offset in the buffer (measured in doubles) between consecutive elements
 of the vector.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the vector.

 @discussion
 This function creates an object representing a vector whose entries are copied
 out of the supplied buffer of doubles.  Negative or zero strides are not
 supported by this function (but note that you can reverse the elements in a
 vector using the la_vector_reverse macro defined below).

 The stride determines the offset (measured in doubles) between the values
 providing consecutive vector elements in the buffer.  For example, if
 buffer_stride is 1, then the vector is:

 { buffer[0], buffer[1], buffer[2], ... , buffer[vector_length-1] }

 If buffer_stride is 3, the vector is:

 { buffer[0], buffer[3], buffer[6], ... , buffer[3*(vector_length-1)] }

 Thus, the size of the buffer (in doubles) should be at least

 buffer_stride*(vector_length-1) + 1.
 
 Always returns a vector_length x 1 vector.
 */
#define la_vector_from_double_buffer(buffer, vector_length, buffer_stride, attributes) \
    la_matrix_from_double_buffer(buffer, vector_length, 1, buffer_stride, LA_NO_HINT, attributes)

/*!
 @abstract
 Create a vector using data from a buffer of floats.  Ownership of the buffer
 is transferred from the caller to the returned object.

 @param buffer
 Pointer to float data providing the elements of the vector.

 @param vector_length
 The length of the vector.

 @param deallocator
 Callback to be used to deallocate the buffer when the returned vector object
 is destroyed.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the vector.

 @discussion
 This function creates an object representing a vector whose entries are the
 supplied buffer of floats.  Ownership of the buffer is transferred to the new
 vector object, meaning that you must not read, modify, or destroy it after
 calling this function.

 Strides are not supported with this function, as there is no way to take
 ownership of (say) every third element in a region of memory.  Instead,
 you would create a vector with this function, then create a slice using
 la_vector_slice to achieve the same effect without copying.
 
 Always returns a vector_length x 1 vector.
 */
#define la_vector_from_float_buffer_nocopy(buffer, vector_length, deallocator, attributes) \
    la_matrix_from_float_buffer_nocopy(buffer, vector_length, 1, 1, LA_NO_HINT, deallocator, attributes)

/*!
 @abstract
 Create a vector using data from a buffer of doubles.  Ownership of the buffer
 is transferred from the caller to the returned object.

 @param buffer
 Pointer to double data providing the elements of the vector.

 @param vector_length
 The length of the vector.

 @param deallocator
 Callback to be used to deallocate the buffer when the returned vector object
 is destroyed.

 @param attributes
 Attributes to attach to the new la_object_t object.  Pass LA_DEFAULT_ATTRIBUTES
 to create a normal object.

 @return a new la_object_t object representing the vector.

 @discussion
 This function creates an object representing a vector whose entries are the
 supplied buffer of doubles.  Ownership of the buffer is transferred to the new
 vector object, meaning that you must not read, modify, or destroy it after
 calling this function.

 Strides are not supported with this function, as there is no way to take
 ownership of (say) every third element in a region of memory.  Instead,
 you would create a vector with this function, then create a slice using
 la_vector_slice to achieve the same effect without copying.
 
 Always returns a vector_length x 1 vector.
 */
#define la_vector_from_double_buffer_nocopy(buffer, vector_length, deallocator, attributes) \
    la_matrix_from_double_buffer_nocopy(buffer, vector_length, 1, 1, LA_NO_HINT, deallocator, attributes)

/*!
 @abstract
 Stores the elements of a vector to a buffer.

 @param buffer
 Pointer to the destination buffer.

 @param buffer_stride
 Offset (in floats) between the destinations of consecutive vector elements
 in the buffer.  Negative strides are not supported (you can get the same
 effect by reversing the vector before calling this function).

 @param vector
 The vector to store.

 @discussion
 The buffer must be large enough to accomodate the vector being stored.
 Specifically, it must have have sufficient space to hold

 buffer_stride*(la_vector_length(vector)-1) + 1

 float elements.  Real usage in the most common case (stride = 1) will
 look roughly like this:

 <pre>
 @textblock
 la_count_t length = la_vector_length(vector);
 if (!length) {
 	// an error occured.
 }
 float *buffer = malloc(length * sizeof buffer[0]);
 la_vector_to_float_buffer(buffer, 1, vector);
 @/textblock
 </pre>

 This function supports storing the contents of a vector, or a matrix that
 has only one row or only one column.  If the object satisfies those
 requirements, and it does not have an error status, its contents are stored
 to the buffer.  If it has an error status, NaNs are stored to the buffer.

 If the object is not a matrix or vector, or if it is a matrix with both
 dimensions larger than one, nothing is written to the buffer and
 LA_INVALID_PARAMETER_ERROR is returned.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY
la_status_t la_vector_to_float_buffer(float *buffer,
                                            la_index_t buffer_stride,
                                            la_object_t vector);

/*!
 @abstract
 Stores the elements of a vector to a buffer.

 @param buffer
 Pointer to the destination buffer.

 @param buffer_stride
 Offset (in doubles) between the destinations of consecutive vector elements
 in the buffer.  Negative strides are not supported (you can get the same
 effect by reversing the vector before calling this function).

 @param vector
 The vector to store.

 @return
 If vector is a valid vector object, its status is returned.  Otherwise
 the return value is LA_INVALID_PARAMETER_ERROR.

 @discussion
 The buffer must be large enough to accomodate the vector being stored.
 Specifically, it must have have sufficient space to hold

 buffer_stride*(la_vector_length(vector)-1) + 1

 double elements.  Real usage in the most common case (stride = 1) will
 look roughly like this:

 <pre>
 @textblock
 la_count_t length = la_vector_length(vector);
 if (!length) {
 	// an error occured.
 }
 double *buffer = malloc(length * sizeof buffer[0]);
 la_vector_to_double_buffer(buffer, 1, vector);
 @/textblock
 </pre>

 This function supports storing the contents of a vector, or a matrix that
 has only one row or only one column.  If the object satisfies those
 requirements, and it does not have an error status, its contents are stored
 to the buffer.  If it has an error status, NaNs are stored to the buffer.

 If the object is not a matrix or vector, or if it is a matrix with both
 dimensions larger than one, nothing is written to the buffer and
 LA_INVALID_PARAMETER_ERROR is returned.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY
la_status_t la_vector_to_double_buffer(double *buffer,
                                             la_index_t buffer_stride,
                                             la_object_t vector);

/*!
 @abstract
 Get the length of a vector.

 @discussion
 If the argument has an error status, zero is returned.
 If the argument is a vector, its length is returned.
 If the argument is a matrix with only one row or only one column, the other
 dimension is returned.
 Otherwise, zero is returned.
 */
LA_FUNCTION LA_CONST LA_NONNULL LA_AVAILABILITY
la_count_t la_vector_length(la_object_t vector);

/*!
 @abstract
 Create a slice of a vector.

 @param vector
 The vector to be sliced.

 @param vector_first
 The index of the source vector element that will become the first element
 of the new slice vector.

 @param vector_stride
 The offset in the source vector between elements that will be consecutive in
 the new slice vector.

 @param slice_length
 The length of the resulting slice vector.

 @return
 A new vector with length slice_length whose elements are taken from vector.

 @discussion
 The result object is the vector:

 [ vector[vector_first], vector[vector_first+vector_stride], ...
 ... , vector[vector_first + (slice_length-1)*vector_stride] ]
 
 Slices provide an efficient means to operate on subvectors and strides.
 These are lightweight objects that reference the storage of the vector from
 which they originate.  Creating a vector slice does not require any allocation
 beyond the object representing the slice, nor does it require copying.

 This function supports slicing a vector, or a matrix that has only one row
 or only one column.  If the object is not a matrix or vector, or if it is
 a matrix with both dimensions larger than one, the returned object will have
 status LA_INVALID_PARAMETER_ERROR.

 If the slice references indices that are less than zero or greater than or
 equal to the length of the vector, LA_SLICE_OUT_OF_BOUNDS_ERROR is returned.
 
 Always return a vector with the same orientation as the input.  If input is
 vector_length x 1, output is vector_length x 1 and if input is
 1 x vector_length, output is 1 x vector_length.
 */
LA_FUNCTION LA_NONNULL LA_AVAILABILITY LA_RETURNS_RETAINED
la_object_t la_vector_slice(la_object_t vector,
                               la_index_t vector_first,
                               la_index_t vector_stride,
                               la_count_t slice_length);

/*!
 @abstract
 Generate a new vector that is the reverse of the supplied vector.
 
 Always return a vector with the same orientation as the input.  If input is
 vector_length x 1, output is vector_length x 1 and if input is 
 1 x vector_length, output is 1 x vector_length.
 */
#define la_vector_reverse(vector) \
la_vector_slice(vector, la_vector_length(vector)-1, -1, la_vector_length(vector))



#endif // __LA_VECTOR_HEADER__
                                                                                                                                                                              Sparse/                                                                                             0040755 0001750 0001750 00000000000 12612224736 042421  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers                           BLAS.h                                                                                              0100644 0001750 0001750 00000215107 12566175205 043322  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/Sparse                    /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __SPARSE_BLAS_H
#define __SPARSE_BLAS_H

/*!
 @header Sparse/BLAS.h
 @discussion

 These sparse BLAS routines provide access to sparse computation while hiding
 the details of the sparse matrix storage formats.
 
 A brief note on the naming convention used.  When an operation has two 
 operands, if both operands are sparse then _sparse_ will be in the name, but if
 one operand is sparse and the other dense, then _dense_ will be in the name.  
 For example, sparse_inner_product_sparse_float is a sparse-sparse operation and 
 sparse_inner_product_dense_float is a sparse-dense operation.  Any operation that 
 has a single matrix or vector is going to be operating on sparse structures and 
 no _dense_ or _sparse_ is added to the name.
 
 This sparse BLAS package utilizes a compressed form vector where two storage 
 arrays of the same size are used, the first to store the nonzero values of the 
 vector, the other to store the index of the nonzero values.  For example, for
 the dense vector:
 
 d = [3, 0, 0, 7, 9, 0, 4, 0, 0]
 
 the sparse vector will be stored as two arrays:
 
 s =     [3, 7, 9, 4]
 
 sindx = [0, 3, 4, 6]
 
 These two arrays hold their values as consecutive elements and are referred to
 throughout the documentation as the dense storage of the sparse vector.
 
 Indices are always assumed to be stored in ascending order. Additionally, 
 indices are assumed to be unique.  Undefined behavior if either of these 
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 Due to the variety of sparse matrix representations, the details of the storage
 format are hidden from the developer.  There are however two general flavors;
 point wise and block wise storage.
 
 With a point wise format, individual elements are stored within the matrix 
 representation. Point wise formats allow for adding single (val,i,j) values,
 collections of (val,i,j) values, or sparse vectors as a row or column.
 
 With block wise storage formats, blocks of elements are stored within the 
 matrix. Block formats allow for adding blocks of values at specified block 
 indices. For example if block sizes are constant, adding the K x L block to the 
 matrix at block location bi,bj will add values to 
 matrix[bi*K:bi*K+K-1,bj*L:bj*L-1]. With block storage formats, block sizes can 
 either be uniform throughout the matrix, or variable based on row and column 
 location.
 
 Beyond selecting a point wise or block wise format, the matrix storage format 
 is hidden from the developer.
 
 Matrix objects must be memory managed.  They are created with a create routine,
 used to completion, and then must be destroyed to release any associated
 memory.  The typical work flow is as follows:
 
 <pre>
 // Create matrix object and check for error
 sparse_matrix_float A = sparse_matrix_create_float(40,40);
 if ( !A ) { // handle error }
 
 // Insert values from existing arrays values, iIndx, and jIndx
 // Then check for error
 if ( sparse_insert_entry_float( A, 12, values, iIndx, jIndx ) ) { // handle error }
 
 // Perform computation
 float nrm = sparse_matrix_norm_float( A, SPARSE_NORM_INF );
 
 // Clean up
 sparse_matrix_destroy( A );
 </pre>
 
 Since data insertion into the internal storage is very expensive, caused by data
 movement and possible memory allocation, data insertion functions do not update
 the internal storage immediately. Rather, all data insertions are put into a pending
 queue. The internal storage is then updated automatically when required by the BLAS
 operations, or explicitly triggered by calling sparse_commit().
 
 When commit is triggered automatically by the BLAS operation, expect the operation
 to take longer time. If this is undesirable, consider calling sparse_commit() in a
 less time-sensitive code segment.

 @copyright Copyright (c) 2015 Apple Inc. All rights reserved.
 */

#ifdef __cplusplus
extern "C" {
#endif
    
#ifndef CBLAS_H
#include <vecLib/cblas.h>
#endif

#ifndef __SPARSE_TYPES_H
#include <vecLib/Sparse/Types.h>
#endif

#pragma mark - Level 1 Routines -

  /* Level 1 Computational Routines */
/*!
 @functiongroup Level 1
 @abstract Level 1 routines consisting of vector-vector operations
 */

/*!
 @abstract
 Compute the inner product of sparse vector x with dense vector y.
 
 @param nz
 The number of nonzero entries in the sparse vector x.
 
 @param x
 Pointer to the dense storage for the values of the sparse vector x.  The
 corresponding entry in indx holds the index of the value.  Contains nz values.
 
 @param indx
 Pointer to the dense storage for the index values of the sparse vector x.  The
 corresponding entry in x holds the values of the vector.  Contains nz values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param y
 Pointer to the dense vector y.  Accessed as y[indx[0..nz-1]*incy], so dimension 
 must be compatible with largest index value in indx.  Behavior undefined if 
 this is not met.  Negative strides are supported.  Note, unlike dense BLAS 
 routines, the pointer points to the last element when stride is negative.
 
 @param incy
 Increment between valid values in the dense vector y.  Negative strides are
 supported.
 
 @result
 On exit the result of the inner product is returned.
 
 @discussion
 Compute the inner product of sparse vector x with dense vector y.  Returns zero 
 if nz is less than or equal to zero.
 
 */
float sparse_inner_product_dense_float( sparse_dimension nz,
                                     const float * __restrict x,
                                     const sparse_index * __restrict indx,
                                     const float * __restrict y,
                                     sparse_stride incy );
double sparse_inner_product_dense_double( sparse_dimension nz,
                                       const double * __restrict x,
                                       const sparse_index * __restrict indx,
                                       const double * __restrict y,
                                       sparse_stride incy );


/*!
 @abstract
 Compute the inner product of sparse vector x with sparse vector y.
 
 @param nzx
 The number of nonzero entries in the sparse vector x.
 
 @param nzy
 The number of nonzero entries in the sparse vector y.
 
 @param x
 Pointer to the dense storage for the values of the sparse vector x.  The
 corresponding entry in indx holds the index of the value.  Contains nzx values.
 
 @param indx
 Pointer to the dense storage for the index values of the sparse vector x.  The
 corresponding entry in x holds the values of the vector.  Contains nzx values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param y
 Pointer to the dense storage for the values of the sparse vector y.  The
 corresponding entry in indy holds the index of the value.  Contains nzy values.
 
 @param indy
 Pointer to the dense storage for the index values of the sparse vector y.  The
 corresponding entry in y holds the values of the vector.  Contains nzy values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @result
 On exit the result of the inner product is returned.
 
 @discussion
 Compute the inner product of sparse vector x with sparse vector y.  Returns
 zero if nzx or nzy is less than or equal to zero.
 
 */
float sparse_inner_product_sparse_float( sparse_dimension nzx, sparse_dimension nzy,
                                      const float * __restrict x,
                                      const sparse_index * __restrict indx,
                                      const float * __restrict y,
                                      const sparse_index * __restrict indy );
double sparse_inner_product_sparse_double( sparse_dimension nzx, sparse_dimension nzy,
                                        const double * __restrict x,
                                        const sparse_index * __restrict indx,
                                        const double * __restrict y,
                                        const sparse_index * __restrict indy );

/*!
 @abstract
 Scales the sparse vector x by alpha and adds the result to the dense vector y.
 
 y = alpha * x + y
 
 @param nz
 The number of nonzero entries in the sparse vector x.
 
 @param alpha
 Scalar multiplier of x.
 
 @param x
 Pointer to the dense storage for the values of the sparse vector x.  The
 corresponding entry in indx holds the index of the value.  Contains nz values.
 
 @param indx
 Pointer to the dense storage for the index values of the sparse vector x.  The
 corresponding entry in x holds the values of the vector.  Contains nz values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param y
 Pointer to the dense vector y.  Accessed as y[indx[0..nz-1]*incy], so dimension
 must be compatible with largest index value in indx.  Behavior undefined if
 this is not met.  Negative strides are supported.  Note, unlike dense BLAS
 routines, the pointer points to the last element when stride is negative.
 
 @param incy
 Increment between valid values in the dense vector y.  Negative strides are
 supported.
 
 @result
 On exit y has been updated as y = alpha * x + y. If nz is less than or
 equal to zero or alpha is equal to zero, y is unchanged.
 
 @discussion
 Scales the sparse vector x by alpha and adds the result to the dense vector y.
 If alpha or nz is zero, y is unchanged.
 
 If the desired operation is y = alpha * x, then an efficient option is to 
 create the y buffer of zeros as y = calloc(sizeof(..)*ySize) and then perform
 the operation with the zero filled y.
 */
void sparse_vector_add_with_scale_dense_float( sparse_dimension nz, float alpha,
                                            const float * __restrict x,
                                            const sparse_index * __restrict indx,
                                            float * __restrict y,
                                            sparse_stride incy );
void sparse_vector_add_with_scale_dense_double( sparse_dimension nz, double alpha,
                                             const double * __restrict x,
                                             const sparse_index * __restrict indx,
                                             double * __restrict y,
                                             sparse_stride incy );

/*!
 @abstract
 Compute the specified norm of the sparse vector x.
 
 @param nz
 The number of nonzero values in the sparse vector x.
 
 @param x
 Pointer to the dense storage for the values of the sparse vector x.  The
 corresponding entry in indx holds the index of the value.  Contains nz values.
 
 @param indx
 Pointer to the dense storage for the index values of the sparse vector x.  The
 corresponding entry in x holds the values of the vector.  Contains nz values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param norm
 Specify the norm to be computed.  Must be one of SPARSE_NORM_ONE, SPARSE_NORM_TWO,
 or SPARSE_NORM_INF.  See discussion for further details.
 
 @result
 Upon success, return the requested norm.
 
 @discussion
 Compute the specified norm of the sparse vector x.  Specify one of:
 1) SPARSE_NORM_ONE : sum over i ( | x[i] | )
 2) SPARSE_NORM_TWO : sqrt( sum over i (x[i])^2 )
 3) SPARSE_NORM_INF : max over i ( | x[i] | )
 4) SPARSE_NORM_R1  : Not supported, undefined.
 
 If norm is not one of the enumerated norm types, the default value is
 SPARSE_NORM_INF.
 
 */
float sparse_vector_norm_float( sparse_dimension nz, const float * __restrict x,
                             const sparse_index * __restrict indx, sparse_norm norm );
double sparse_vector_norm_double( sparse_dimension nz, const double * __restrict x,
                               const sparse_index * __restrict indx, sparse_norm norm );



#pragma mark - Level 2 Routines -

               /* Level 2 Computational Routines */
/*!
 @functiongroup Level 2
 @abstract Level 2 routines consisting of matrix-vector operations
 */

/*!
 @abstract
 Multiplies the dense vector x by the sparse matrix A and adds the result to
 the dense vector y.
 
 y = alpha * op(A) * x + y; where op(A) is either A or the transpose of A
 
 @param transa 
 Specifies whether to perform the operation with A or the transpose of A.
 Must be one of CblasNoTrans or CblasTrans.
 
 @param alpha
 Scalar multiplier of A.
 
 @param A
 The sparse matrix.
 
 @param x
 Pointer to the dense vector x. The dimension must be the number of columns of
 the matrix A when transa is no transpose or the number of rows of the matrix A
 when transa is transpose.  Behavior undefined if this is not met.  Negative 
 strides are supported.  Note, unlike dense BLAS routines, the pointer points to 
 the last element when stride is negative. 
 
 @param incx
 Increment between valid values in the dense vector x. Negative strides are
 supported.
 
 @param y
 Pointer to the dense vector y. The dimension must be the number of rows of
 the matrix A when transa is no transpose or the number of columns of the matrix 
 A when transa is transpose.  Behavior undefined if this is not met.  Negative
 strides are supported.  Note, unlike dense BLAS routines, the pointer points to
 the last element when stride is negative.
 
 @param incy
 Increment between valid values in the dense vector y.  Negative strides are
 supported.

 @result
 On success return SPARSE_SUCCESS and y has been updated with result of the 
 operation.  Will return SPARSE_ILLEGAL_PARAMETER if transa is invalid and y will 
 be unchanged.

 @discussion
 Multiplies the dense vector x by the sparse matrix A and adds the result to
 the dense vector y (y = alpha * op(A) * x + y, where op(A) is either A
 or the transpose of A).
 
 If the desired operation is y = A * x, then an efficient option is to create
 the y buffer of zeros as y = calloc(sizeof(..)*ySize) and then perform
 the operation with the zero filled y.
 */
sparse_status sparse_matrix_vector_product_dense_float( enum CBLAS_TRANSPOSE transa,
                                                  float alpha,
                                                  sparse_matrix_float A,
                                                  const float * __restrict x,
                                                  sparse_stride incx,
                                                  float * __restrict y,
                                                  sparse_stride incy );
sparse_status sparse_matrix_vector_product_dense_double( enum CBLAS_TRANSPOSE transa,
                                                   double alpha,
                                                   sparse_matrix_double A,
                                                   const double * __restrict x,
                                                   sparse_stride incx,
                                                   double * __restrict y,
                                                   sparse_stride incy );

/*!
 @abstract
 Solve the system of equations x = alpha * T^{-1} * x for x where x is a dense
 vector and T is a triangular sparse matrix.
 
 @param transt
 Specifies whether to perform the operation with T or the transpose of T.
 Must be one of CblasNoTrans or CblasTrans.
 
 @param alpha
 Scalar multiplier of T.
 
 @param T
 The sparse triangular matrix.  Must be upper or lower triangular matrix.
 Will return SPARSE_ILLEGAL_PARAMETER if not a triangular matrix.
 
 @param x
 Pointer to the dense vector x. The dimension must match the dimension of the
 triangular matrix T. Behavior undefined if this is not met.  Negative
 strides are supported.  Note, unlike dense BLAS routines, the pointer points to
 the last element when stride is negative.  On exit holds the solution to the
 system of equations.
 
 @param incx
 Increment between valid values in the dense vector x. Negative strides are
 supported.
 
 @result
 On success, SPARSE_SUCCESS is returned and x has been updated with result of the 
 operation.  Will return SPARSE_ILLEGAL_PARAMETER if transt is invalid or if the
 matrix T is not triangular and x will be unchanged.
 
 @discussion
 Solve the system of equations x = alpha * T^{-1} * x for x where x is a dense
 vector and T is a triangular sparse matrix.  The matrix T must be an upper or
 lower triangular matrix.
 
 */
sparse_status sparse_vector_triangular_solve_dense_float( enum CBLAS_TRANSPOSE transt,
                                              float alpha, sparse_matrix_float T,
                                              float * __restrict x,
                                              sparse_stride incx );
sparse_status sparse_vector_triangular_solve_dense_double( enum CBLAS_TRANSPOSE transt,
                                               double alpha,
                                               sparse_matrix_double T,
                                               double * __restrict x,
                                               sparse_stride incx );


/*!
 @abstract
 Compute the outer product of the dense vector x and the sparse vector y and
 return a new sparse matrix in the uninitialized pointer sparse matrix pointer 
 C.  C = alpha * x * y'
 
 @param M
 The number of rows of x and the resulting matrix.
 
 @param N
 The number of columns of the resulting matrix.  The number of nonzero values 
 must be less than or equal to N.
 
 @param nz
 The number of nonzero values in the sparse vector y.  Must be less than or
 equal to N.
 
 @param alpha
 Scalar multiplier of x.
 
 @param x
 Pointer to the dense vector x.  Must be M number of elements.  Negative strides 
 are supported.  Note, unlike dense BLAS routines, the pointer points to the 
 last element when stride is negative.
 
 @param incx
 Increment between valid values in the dense vector x.  Negative strides are
 supported.
 
 @param y
 Pointer to the dense storage for the values of the sparse vector y.  The
 corresponding entry in indy holds the index of the value.  Contains nz values.
 
 @param indy
 Pointer to the dense storage for the index values of the sparse vector y.  The
 corresponding entry in y holds the values of the vector.  Contains nz values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param C
 Pointer to an uninitialized sparse matrix object.  On success a newly allocated
 sparse matrix object is returned in this pointer.  On error, this set to NULL.
 Caller is responsible for calling sparse_matrix_destroy on this matrix object.
 
 @result
 On success SPARSE_SUCCESS is returned an C is valid matrix object.  The caller is 
 responsible for cleaning up the sparse matrix object with sparse_matrix_destroy.
 Will return SPARSE_ILLEGAL_PARAMETER if nz > N, and C will be unchanged.
 
 @discussion
 Compute the outer product of the dense vector x and the sparse vector y and
 return a new sparse matrix in the uninitialized pointer sparse matrix pointer 
 C.  C = alpha * x * y'.  Caller responsible for calling sparse_matrix_destroy on 
 the returned matrix.
 
 The matrix object returned on success is a point wise based sparse matrix.
 
 */
sparse_status sparse_outer_product_dense_float( sparse_dimension M, sparse_dimension N,
                                    sparse_dimension nz, float alpha,
                                    const float * __restrict x, sparse_stride incx,
                                    const float * __restrict y,
                                    const sparse_index * __restrict indy,
                                    sparse_matrix_float * __restrict C);
sparse_status sparse_outer_product_dense_double( sparse_dimension M, sparse_dimension N,
                                     sparse_dimension nz, double alpha,
                                     const double * __restrict x,
                                     sparse_stride incx, const double * __restrict y,
                                     const sparse_index * __restrict indy,
                                     sparse_matrix_double * __restrict C);

/*!
 @abstract
 Permute the rows of the sparse matrix A based on the provided permutation
 array.
 
 @param A
 The sparse matrix.
 
 @param perm
 The permutation array.  Holds number of rows in A values indicating the
 permutation of the matrix.  The indices in perm are expected to be 0 based 
 (first element of pointer is ptr[0]).  The indices in perm are expected to
 be within bounds of the matrix.  Undefined behavior if not met.
 
 @result
 On successful return, A has been permuted and SPARSE_SUCCESS is returned.
 
 @discussion
 Permute the rows of the sparse matrix A based on the provided permutation
 array.  For each row in A, swap rows as:
 
 tmp[:] = A[i,:];
 A[i,:] = A[perm[i],:];
 A[perm[i],:] = tmp[:];
 
 */
sparse_status sparse_permute_rows_float( sparse_matrix_float A,
                             const sparse_index * __restrict perm );
sparse_status sparse_permute_rows_double( sparse_matrix_double A,
                              const sparse_index * __restrict perm );

/*!
 @abstract
 Permute the columns of the sparse matrix A based on the provided permutation
 array.
 
 @param A
 The sparse matrix.
 
 @param perm
 The permutation array.  Holds number of columns in A values indicating the
 permutation of the matrix.  The indices in perm are expected to be 0 based
 (first element of pointer is ptr[0]).  The indices in perm are expected to
 be within bounds of the matrix.  Undefined behavior if not met.
 
 @result
 On successful return, A has been permuted and SPARSE_SUCCESS is returned.
 
 @discussion
 Permute the columns of the sparse matrix A based on the provided permutation
 array.  For each column in A, swap columns as:
 
 tmp[:] = A[:,j];
 A[:,j] = A[:,perm[j]];
 A[:,perm[j]] = tmp[:];
 
 */
sparse_status sparse_permute_cols_float( sparse_matrix_float A,
                             const sparse_index * __restrict perm );
sparse_status sparse_permute_cols_double( sparse_matrix_double A,
                              const sparse_index * __restrict perm );


/*!
 @abstract
 Compute the specified elementwise norm of the sparse matrix A.  This is the 
 norm of the matrix treated as a vector, not the operator norm.
 
 @param A
 The sparse matrix.
 
 @param norm
 Specify the norm to be computed.  Must be one of SPARSE_NORM_ONE, SPARSE_NORM_TWO,
 SPARSE_NORM_INF, or SPARSE_NORM_R1.  See discussion for further details.
 
 @result
 Upon success, resulting norm is returned.
 
 @discussion
 Compute the specified norm of the sparse matrix A.  This is the norm of the
 matrix treated as a vector, not the operator norm.  Specify one of:
 1) SPARSE_NORM_ONE : sum over i,j ( | A[i,j] | )
 2) SPARSE_NORM_TWO : sqrt( sum over i,j (A[i,j])^2 )
 3) SPARSE_NORM_INF : max over i,j ( | A[i,j] | )
 4) SPARSE_NORM_R1  : sum over j ( sqrt ( sum over i ( A[i,j]^2 ) ) )
 
 If norm is not one of the enumerated norm types, the default value is
 SPARSE_NORM_INF.
 
 */
float sparse_elementwise_norm_float( sparse_matrix_float A, sparse_norm norm );
double sparse_elementwise_norm_double( sparse_matrix_double A, sparse_norm norm );

/*!
 @abstract
 Compute the specified operator norm of the sparse matrix A.  For elementwise
 norm use elementwise_norm routines.
 
 @param A
 The sparse matrix.
 
 @param norm
 Specify the norm to be computed.  Must be one of SPARSE_NORM_ONE, SPARSE_NORM_TWO,
 or SPARSE_NORM_INF.  See discussion for further details.
 
 @result
 Upon success, resulting norm is returned.
 
 @discussion
 Compute the specified norm of the sparse matrix A.  This is the norm of the
 matrix treated as an linear operator, not the elementwise norm.  Specify one of:
 1) SPARSE_NORM_ONE : max over j ( sum over i ( | A[i,j] | ) )
 2) SPARSE_NORM_TWO : Maximum singular value. This is significantly more
                      expensive to compute than the other norms.
 3) SPARSE_NORM_INF : max over i ( sum over j ( | A[i,j] | ) )
 4) SPARSE_NORM_R1  : Not supported, undefined.
 
 If norm is not one of the enumerated norm types, the default value is
 SPARSE_NORM_INF.
 
 */
float sparse_operator_norm_float( sparse_matrix_float A, sparse_norm norm );
double sparse_operator_norm_double( sparse_matrix_double A, sparse_norm norm );
    
/*!
 @abstract
 Compute the sum along the specified diagonal of the sparse matrix A.
 
 @param A
 The sparse matrix.
 
 @param offset
 Specifies the diagonal to sum.  A zero value will sum the main diagonal
 (A[i,i]), a value greater than zero will sum diagonals above the main diagonal
 (A[i,i+offset]), and a values less than zero will sum diagonals below the main
 diagonal (A[i-offset,i]).  If offset is out of the bounds of the matrix A, 0 
 is returned.
 
 @result
 On success, the resulting trace is returned.
 
 @discussion
 Compute the sum along the specified diagonal of the sparse matrix A.  The
 diagonal is specified by the parameter offset where zero is the main diagonal,
 values greater than one refer to diagonals above the main diagonal
 (A[i,i+offset]), and values less than one refer to diagonals below the main
 diagonal (A[i-offset, i]).

 If offset is out of the bounds of the matrix A, 0 is returned.
 
 */
float sparse_matrix_trace_float( sparse_matrix_float A, sparse_index offset );
double sparse_matrix_trace_double( sparse_matrix_double A, sparse_index offset );





#pragma mark - Level 3 Routines -

               /* Level 3 Computational Routines */
/*!
 @functiongroup Level 3
 @abstract Level 3 routines consisting of matrix-matrix operations
 */
/*!
 @abstract
 Multiplies the dense matrix B by the sparse matrix A and adds the result to
 the dense matrix C.
 
 C = alpha * op(A) * B + C; where op(A) is either A or the transpose of A
 
 @param order
 Specified the storage order for the dense matrices B and C. Must be one of
 CblasRowMajor or CblasColMajor.
 
 @param transa
 Specifies whether to perform the operation with A or the transpose of A.
 Must be one of CblasNoTrans or CblasTrans.
 
 @param n
 The number of columns of the matrices B and C.
 
 @param alpha
 Scalar multiplier of A.
 
 @param A
 The sparse matrix.
 
 @param B
 Pointer to the dense matrix B. The number of rows must be equal to the number
 of columns of A and the number of columns is n.  Behavior undefined if this 
 is not met. The argument ldb describes how many elements to move between one
 row (row major) or column (column major).
 
 @param ldb
 Increment in elements between rows (row major) or columns (column major) of B. 
 Must be greater than or equal to n when row major, or number of columns of 
 A when column major.
 
 @param C
 Pointer to the dense matrix C. The number of rows must be equal to the number
 of rows of A and the number of columns is n.  Behavior undefined if this
 is not met. The argument ldc describes how many elements to move between one
 row (row major) or column (column major).  C is updated with the result of the
 operation.
 
 @param ldc
 Increment in elements between rows (row major) or columns (column major) of C.
 Must be greater than or equal to n when row major, or number of rows of
 A when column major.
 
 @result
 On success, SPARSE_SUCCESS is returned and C has been updated with result of the 
 operation.  Will return SPARSE_ILLEGAL_PARAMETER if order or transa is not valid 
 or the leading dimension parameters do not meet their dimension requirements.  
 On error, C is unchanged.
 
 @discussion
 Multiplies the dense matrix B by the sparse matrix A and adds the result to
 the dense matrix C (C = alpha * op(A) * B + C, where op(A) is either A
 or the transpose of A). If A is of size M x N, then B is of size N x n and C is 
 of size M x n.
 
 If the desired operation is C = A * B, then an efficient option is to create
 the C buffer of zeros as C = calloc(sizeof(..)*rows*cols) and then perform
 the operation with the zero filled C.
 */
sparse_status sparse_matrix_product_dense_float( enum CBLAS_ORDER order,
                                           enum CBLAS_TRANSPOSE transa,
                                           sparse_dimension n, float alpha,
                                           sparse_matrix_float A,
                                           const float * __restrict B,
                                           sparse_dimension ldb,
                                           float * __restrict C,
                                           sparse_dimension ldc );
sparse_status sparse_matrix_product_dense_double( enum CBLAS_ORDER order,
                                            enum CBLAS_TRANSPOSE transa,
                                            sparse_dimension n, double alpha,
                                            sparse_matrix_double A,
                                            const double * __restrict B,
                                            sparse_dimension ldb,
                                            double * __restrict C,
                                            sparse_dimension ldc );

/*!
 @abstract
 Solve the system of equations B = alpha * T^{-1} * B for B where B is a dense
 matrix and T is a triangular sparse matrix.
 
 @param order
 Specified the storage order for the dense matrix B. Must be one of
 CblasRowMajor or CblasColMajor.
 
 @param transt
 Specifies whether to perform the operation with T or the transpose of T.
 Must be one of CblasNoTrans or CblasTrans.
 
 @param nrhs
 The number of columns of the matrix B.
 
 @param alpha
 Scalar multiplier of T.
 
 @param T
 The sparse triangular matrix.  Must be upper or lower triangular matrix.
 Will return SPARSE_ILLEGAL_PARAMETER if not a triangular matrix.
 
 @param B
 Pointer to the dense matrix B. The number of rows must be equal to the number
 of columns of T and the number of columns is nrhs.  Behavior undefined if this
 is not met. The argument ldb describes how many elements to move between one
 row (row major) or column (column major). On exit holds the solution to the
 system of equations.
 
 @param ldb
 Increment in elements between rows (row major) or columns (column major) of B.
 Must be greater than or equal to nrhs when row major, or number of columns of
 A when column major.
 
 @result
 On success, SPARSE_SUCCESS is returned and B has been updated with result of the
 operation.  Will return SPARSE_ILLEGAL_PARAMETER if either of order or trant are
 invalid or the ldb does not meet its dimension requirements.  On error
 B is unchanged.
 
 @discussion
 Solve the system of equations B = alpha * T^{-1} * B for B where B is a dense
 vector and T is a triangular sparse matrix.  If T is of size N x N, then B must
 be of size N x nrhs.  The matrix T must be an upper or lower triangular matrix.
 
 */
sparse_status sparse_matrix_triangular_solve_dense_float( enum CBLAS_ORDER order,
                                   enum CBLAS_TRANSPOSE transt,
                                   sparse_dimension nrhs, float alpha,
                                   sparse_matrix_float T,
                                   float * __restrict B, sparse_dimension ldb );
sparse_status sparse_matrix_triangular_solve_dense_double( enum CBLAS_ORDER order,
                                    enum CBLAS_TRANSPOSE transt,
                                    sparse_dimension nrhs, double alpha,
                                    sparse_matrix_double T,
                                    double * __restrict B, sparse_dimension ldb );




#pragma mark - Point Wise Sparse Matrix Routines -

               /* Point Wise Matrix Routines */
/*!
 @functiongroup Point Wise Matrix Routines
 @abstract Routines to create and insert values in a point wise sparse matrix.
 */

/*!
 @abstract
 Create a sparse matrix object that is stored in point wise format and is ready
 to receive values from the various insert routines.
 
 @param M
 The number of rows of the matrix.  Must be greater than 0.
 
 @param N
 The number of columns of the matrix.  Must be greater than 0.
 
 @result
 On success, returns a matrix object that is ready for receiving entries.  If an
 error occurs, NULL is returned.
 
 @discussion
 Create a sparse matrix object that is stored in point wise format and is ready
 to receive values from the various insert routines.  Point wise format means
 individual values are stored for a given i,j location as opposed to blocks of
 values.  For block support use the block_create routines.  See the various
 insert routines for details on inserting entries into this matrix object.
 
 The dimensions M and N must be greater than 0.  On success a valid matrix
 object is returned, otherwise NULL is returned.
 
 */
sparse_matrix_float sparse_matrix_create_float( sparse_dimension M, sparse_dimension N );
sparse_matrix_double sparse_matrix_create_double( sparse_dimension M, sparse_dimension N );

/*!
 @abstract
 Use to build a sparse matrix by inserting one scalar entry at a time.  Update
 A[i,j] = val.  A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.

 @param A
 The sparse matrix.  A must have been created with one of sparse_matrix_create_float
 or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
 
 @param val
 The scalar value to insert into the sparse matrix.
 
 @param i
 The row location to insert the value.  Indices are 0 based (first element of 
 pointer is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param j
 The column location to insert the value.  Indices are 0 based (first element of
 pointer is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @result
 On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
 returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
 returned and A is unchanged.
 
 @discussion
 Use to build a sparse matrix by inserting one scalar entry at a time.  Update
 A[i,j] = val.
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 Note that matrix properties cannot be modified after value insertion begins.
 This includes properties such as specifying a triangular matrix.
 
 Insertion can be expensive, generally speaking it is best to do a batch update.
 Inserted values may be temporarily held internally within the object and only
 inserted into the sparse format when a later computation triggers a need to
 insert.
 
 */
sparse_status sparse_insert_entry_float( sparse_matrix_float A, float val,
                                   sparse_index i, sparse_index j );
sparse_status sparse_insert_entry_double( sparse_matrix_double A, double val,
                                    sparse_index i, sparse_index j );

/*!
 @abstract
 Use to build a sparse matrix by providing a list of point entries.  For each
 entry provided, update A[indx[i],jndx[i]] = val[i].  A must have been created
 with one of sparse_matrix_create_float or sparse_matrix_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of sparse_matrix_create_float
 or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
 
 @param N
 The number of values to insert into A.  Each of indx, jndx and val are of size
 N.
 
 @param val
 Pointer to list of scalar values to insert into the sparse matrix.  The value
 is inserted into the location specified by the corresponding indices in indx
 and jndx.  Must hold N values.
 
 @param indx
 An array of row indices that correspond to the values in val. Must hold N
 values.
 
 Indices are assumed to be unique.  Additionally, indices are assumed to be in the
 bounds of the matrix.  Undefined behavior if any of these assumptions are not 
 met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param jndx
 An array of column indices that correspond to the values in val. Must hold N
 values.
 
 Indices are assumed to be unique.  Additionally, indices are assumed to be in the
 bounds of the matrix.  Undefined behavior if any of these assumptions are not
 met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @result
 On successful insertion, A has been updated with the values and SPARSE_SUCCESS is
 returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
 returned and A is unchanged.
 
 @discussion
 Use to build a sparse matrix by providing a list of point entries.  For each
 entry provided, update A[indx[i],jndx[i]] = val[i].
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 Note that matrix properties cannot be modified after value insertion begins.
 This includes properties such as specifying a triangular matrix.
 
 Insertion can be expensive, generally speaking it is best to do a batch update.
 Inserted values may be temporarily held internally within the object and only
 inserted into the sparse format when a later computation triggers a need to
 insert.
 
 */
sparse_status sparse_insert_entries_float( sparse_matrix_float A, sparse_dimension N,
                                     const float * __restrict val,
                                     const sparse_index * __restrict indx,
                                     const sparse_index * __restrict jndx );
sparse_status sparse_insert_entries_double( sparse_matrix_double A, sparse_dimension N,
                                      const double * __restrict val,
                                      const sparse_index * __restrict indx,
                                      const sparse_index * __restrict jndx );

/*!
 @abstract
 Use to build a sparse matrix by providing a list of point entries for a single
 column.  For each entry provided, update A[indx[i],j] = val[i].  A must have
 been created with one of sparse_matrix_create_float or sparse_matrix_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of sparse_matrix_create_float
 or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
 
 @param j
 The column for value insertion.  Indices are 0 based (first element of pointer
 is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param nz
 The number of values to insert into A.  Each of indx and val are of size
 nz.
 
 @param val
 Pointer to list of scalar values to insert into the sparse matrix.  The value
 is inserted into the location specified by the corresponding indices of indx
 and j.  Must hold nz values.
 
 @param indx
 An array of column indices that correspond to the values in val. Must hold nz
 values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Finally, indices are assumed to be in the
 bounds of the matrix.  Undefined behavior if any of these assumptions are not
 met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @result
 On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
 returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
 returned and A is unchanged.
 
 @discussion
 Use to build a sparse matrix by providing a list of point entries for a single
 column.  For each entry provided, update A[indx[i],j] = val[i].  This will not
 replace the existing contents of the column, it appends new values and
 overwrites overlapping values.
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 Note that matrix properties cannot be modified after value insertion begins.
 This includes properties such as specifying a triangular matrix.
 
 Insertion can be expensive, generally speaking it is best to do a batch update.
 Inserted values may be temporarily held internally within the object and only
 inserted into the sparse format when a later computation triggers a need to
 insert.
 
 */
sparse_status sparse_insert_col_float( sparse_matrix_float A, sparse_index j,
                                 sparse_dimension nz, const float * __restrict val,
                                 const sparse_index * __restrict indx );
sparse_status sparse_insert_col_double( sparse_matrix_double A, sparse_index j,
                                  sparse_dimension nz, const double * __restrict val,
                                  const sparse_index * __restrict indx );

/*!
 @abstract
 Use to build a sparse matrix by providing a list of point entries for a single
 row.  For each entry provided, update A[i,jndx[i]] = val[i].  A must have been
 created with one of sparse_matrix_create_float or sparse_matrix_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of sparse_matrix_create_float
 or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if not met.
 
 @param i
 The row for value insertion.  Indices are 0 based (first element of pointer is
 ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param nz
 The number of values to insert into A.  Each of jndx and val are of size
 nz.
 
 @param val
 Pointer to list of scalar values to insert into the sparse matrix.  The value
 is inserted into the location specified by the corresponding indices of i and
 jndx.  Must hold nz values.
 
 @param jndx
 An array of column indices that correspond to the values in val. Must hold nz
 values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Finally, indices are assumed to be in the
 bounds of the matrix.  Undefined behavior if any of these assumptions are not
 met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @result
 On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
 returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
 returned and A is unchanged.
 
 @discussion
 Use to build a sparse matrix by providing a list of point entries for a single
 row.  For each entry provided, update A[i,jndx[i]] = val[i].  This will not
 replace the existing contents of the row, it appends new values and
 overwrites overlapping values.
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 Note that matrix properties cannot be modified after value insertion begins.
 This includes properties such as specifying a triangular matrix.
 
 Insertion can be expensive, generally speaking it is best to do a batch update.
 Inserted values may be temporarily held internally within the object and only
 inserted into the sparse format when a later computation triggers a need to
 insert.
 
 */
sparse_status sparse_insert_row_float( sparse_matrix_float A, sparse_index i,
                                 sparse_dimension nz, const float * __restrict val,
                                 const sparse_index * __restrict jndx );
sparse_status sparse_insert_row_double( sparse_matrix_double A, sparse_index i,
                                  sparse_dimension nz, const double * __restrict val,
                                  const sparse_index * __restrict jndx );


/*!
 @abstract
 Extract the first nz values of the row begining at A[row,column_start] for the
 sparse matrix A.  A must have been created with one of sparse_matrix_create_float 
 or sparse_matrix_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of 
 sparse_matrix_create_float or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is 
 returned if not met.
 
 @param row
 The row for value extraction.  Indices are 0 based (first element of pointer is
 ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param column_start
 The index of the column to start extraction.  Indices are 0 based (first 
 element of pointer is ptr[0]).  Indices expected to be in the bounds of matrix 
 dimensions, undefined behavior if not met.
 
 @param column_end
 On return, holds the column index of the next nonzero value.If there is no
 next nonzero value (because all of them have been copied into the sparse
 vector), it holds the number of columns in the matrix.
 Indices are 0 based (first element of pointer is ptr[0]).
 Indices expected to be in the bounds of matrix dimensions, undefined behavior 
 if not met.
 
 @param nz
 The number of values to extract from A.  Each of jndx and val are of size
 nz.
 
 @param val
 Pointer to array to hold the values extracted from the sparse matrix.  The
 value is extracted from the location specified by the corresponding indices of 
 row and jndx.  Must be of size nz elements.  If less than nz nonzero values are
 found, then the last nz - actual_nonzero_count elements of val are untouched.
 
 @param jndx
 An array to hold the extracted column indices that correspond to the values in 
 val. Note that these indices are relative to the matrix row and not the
 starting column index specified by column_start.  Returned indices are 0 based 
 (first element of pointer is ptr[0]).  Must be of size nz elements.
 
 @result
 On success val and jndx have been updated with the nonzero values of the row'th
 row, column_end holds the column index of the next nonzero value, and
 the number of nonzero values written are returned.  If A creation requirements 
 are not met, SPARSE_ILLEGAL_PARAMETER is returned and val and jndx are unchanged.
 
 @discussion
 Extract the first nz values of the row begining at A[row,column_start] for the
 sparse matrix A.  The number of nonzero values extracted is limited by nz, and
 the number of nonzero's written to jndx and val are returned.  Additionally, 
 the column index of the next nonzero value is returned in column_end.
 For example if nz is returned, not all nonzero values have been extracted,
 and a second extract can start from column_end.
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 */
sparse_status sparse_extract_sparse_row_float( sparse_matrix_float A, sparse_index row,
                                  sparse_index column_start, sparse_index *column_end,
                                  sparse_dimension nz, float * __restrict val,
                                  sparse_index * __restrict jndx );
sparse_status sparse_extract_sparse_row_double( sparse_matrix_double A, sparse_index row,
                                  sparse_index column_start, sparse_index *column_end,
                                  sparse_dimension nz, double * __restrict val,
                                  sparse_index * __restrict jndx );

/*!
 @abstract
 Extract the first nz values of the column begining at A[row_start,column] for 
 the sparse matrix A.  A must have been created with one of 
 sparse_matrix_create_float or sparse_matrix_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of 
 sparse_matrix_create_float or sparse_matrix_create_double.  SPARSE_ILLEGAL_PARAMETER is 
 returned if not met.
 
 @param column
 The column for value extraction.  Indices are 0 based (first element of pointer 
 is ptr[0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param row_start
 The index of the row to start extraction.  Indices are 0 based (first
 element of pointer is ptr[0]).  Indices expected to be in the bounds of matrix 
 dimensions, undefined behavior if not met.
 
 @param row_end
 On return, holds the row index of the next nonzero value.If there is no
 next nonzero value (because all of them have been copied into the sparse
 vector), it holds the number of rows in the matrix.
 Indices are 0 based (first element of pointer is ptr[0]).
 Indices expected to be in the bounds of matrix dimensions, undefined behavior 
 if not met.
 
 @param nz
 The number of values to extract from A.  Each of indx and val are of size
 nz.
 
 @param val
 Pointer to array to hold the values extracted from the sparse matrix.  The
 value is extracted from the location specified by the corresponding indices of 
 column and indx.  Must be of size nz elements.  If less than nz nonzero values 
 are found, then the last nz - actual_nonzero_count elements of val are 
 untouched.
 
 @param indx
 An array to hold the extracted row indices that correspond to the values in
 val. Note that these indices are relative to the matrix column and not the
 starting row index specified by row_start.  Returned indices are 0 based
 (first element of pointer is ptr[0]).  Must be of size nz elements.
 
 @result
 On success val and indx have been updated with the nonzero values of the 
 column'th column, row_end holds the row index of the next nonzero value,
 and the number of nonzero values written are returned.  If A creation
 requirements are not met, SPARSE_ILLEGAL_PARAMETER is returned and val and indx 
 are unchanged.
 
 @discussion
 Extract the first nz values of the column begining at A[column,row_start] for 
 the sparse matrix A.  The number of nonzero values extracted is limited by nz, 
 and the number of nonzero's written to indx and val are returned.  
 Additionally, the row index of the next nonzero value is returned in
 row_end.  For example if nz is returned, not all nonzero values have been
 extracted, and a second extract can start from row_end.
 
 A must have been created with one of sparse_matrix_create_float or
 sparse_matrix_create_double.
 
 */
sparse_status sparse_extract_sparse_column_float( sparse_matrix_float A,
                                            sparse_index column,
                                            sparse_index row_start,
                                            sparse_index *row_end,
                                            sparse_dimension nz,
                                            float * __restrict val,
                                            sparse_index * __restrict indx );
sparse_status sparse_extract_sparse_column_double( sparse_matrix_double A,
                                             sparse_index column,
                                             sparse_index row_start,
                                             sparse_index *row_end,
                                             sparse_dimension nz,
                                             double * __restrict val,
                                             sparse_index * __restrict indx );



#pragma mark - Block Wise Matrix Routines -

				/* Block Wise Matrix Routines */
/*!
 @functiongroup Block Wise Matrix Routines
 @abstract Routines to create and insert values in a block wise sparse matrix.
 */

 /*!
 @abstract
 Create a sparse matrix object that is stored in block-entry format and is ready
 to receive values from the various block insert routines.  Blocks are of fixed
 dimension k x l.
 
 @param Mb
 The number of rows in terms of blocks of the matrix.  There are a total of
 Mb * k rows in the matrix.  Must be greater than 0.
 
 @param Nb
 The number of columns in terms of blocks of the matrix.  There are a total of
 Nb * l columns in the matrix.  Must be greater than 0.
 
 @param k
 The row dimension of a block in the sparse matrix.  Must be greater than 0.
 
 @param l
 The column dimension of a block in the sparse matrix.  Must be greater than 0.
 
 @result
 On success, returns a matrix object that is ready for receiving entries.  If an
 error occurs, NULL is returned.
 
 @discussion
 Create a sparse matrix object that is stored in block-entry format and is ready
 to receive values from the various block insert routines.  Blocks are are of
 fixed dimensions k x l.  Block-entry format means blocks of dense regions will 
 be stored at block indices i,j.  For point wise format use non block version of
 create. See the various insert routines for details on inserting values into
 this matrix object.
 
 The dimensions Mb, Nb, k, and l must be greater than 0.  On success a valid 
 matrix object is returned, otherwise NULL is returned.
  
 */
sparse_matrix_float sparse_matrix_block_create_float( sparse_dimension Mb,
                                                sparse_dimension Nb,
                                                sparse_dimension k,
                                                sparse_dimension l );
sparse_matrix_double sparse_matrix_block_create_double( sparse_dimension Mb,
                                                  sparse_dimension Nb,
                                                  sparse_dimension k,
                                                  sparse_dimension l );

/*!
 @abstract
 Create a sparse matrix object that is stored in block-entry format and is ready
 to receive values from the various block insert routines.  Blocks are of 
 variable dimensions where the i,j'th block has dimensions K[i] x L[j].
 
 @param Mb
 The number of rows in terms of blocks of the matrix.  Must be greater than 0.
 
 @param Nb
 The number of columns in terms of blocks of the matrix.  Must be greater 
 than 0.
 
 @param K
 Array containing row dimensions of the blocks.  The i'th row in terms of blocks
 will have a dimension K[i].  K is expected to hold Mb elements.  All values of
 K are expected to be greater than 0.
 
 @param L
 Array containing column dimensions of the blocks.  The j'th column in terms of 
 blocks will have a dimension L[j].  L is expected to hold Nb elements.  All 
 values of L are expected to be greater than 0.
 
 @result
 On success, returns a matrix object that is ready for receiving entries.  If an
 error occurs, NULL is returned.
 
 @discussion
 Create a sparse matrix object that is stored in block-entry format and is ready
 to receive values from the various block insert routines.  Blocks are are of
 variable dimension where the i,j'th block index has a dimension K[i] x L[j].  
 Block-entry format means blocks of dense regions will be stored at block 
 indices i,j.  For point wise format use non block version of create. See the 
 various insert routines for details on inserting values into this matrix
 object.
 
 The dimensions Mb, Nb and all values in K and L must be greater than 0.  On 
 success a valid matrix object is returned, otherwise NULL is returned.
 
 */
sparse_matrix_float sparse_matrix_variable_block_create_float( sparse_dimension Mb,
                                                         sparse_dimension Nb,
                                                         const sparse_dimension *K,
                                                         const sparse_dimension *L );
sparse_matrix_double sparse_matrix_variable_block_create_double( sparse_dimension Mb,
                                                           sparse_dimension Nb,
                                                           const sparse_dimension *K,
                                                           const sparse_dimension *L );
/*!
 @abstract
 Use to build a sparse matrix by providing a dense block for entry at block
 location A[bi,bj].  Block size is determined at object creation time.  A must
 have been created with one of sparse_matrix_block_create_float,
 sparse_matrix_block_create_double, sparse_matrix_variable_block_create_float, or
 sparse_matrix_variable_block_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of 
 sparse_matrix_block_create_float, sparse_matrix_block_create_double, 
 sparse_matrix_variable_block_create_float, or 
 sparse_matrix_variable_block_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if 
 not met.  A holds block dimensions (fixed or variable) set with matrix object 
 creation routine.
 
 @param val
 Pointer to block to be inserted at block index location A[bi,bj].  The block is
 of dimension k x l where k and l are set for bi,bj at object creation time.  
 The strides between elements for rows and columns are provided in row_stride 
 and col_stride.
 
 @param row_stride
 The row stride in number of elements to move from one row to the next for the
 block val.
 
 @param col_stride
 The column stride in number of elements to move from one column to the next for
 the block val.
 
 @param bi
 The block row index where val is to be inserted.  Indexing is zero based, the
 first block is located at 0,0.  Index is assumed to be within the bounds of the
 matrix object, undefined behavior if not met.
 
 @param bj
 The block column index where val is to be inserted.  Indexing is zero based, the
 first block is located at 0,0.  Index is assumed to be within the bounds of the
 matrix object, undefined behavior if not met.
 
 @result
 On successful insertion, A has been updated with the value and SPARSE_SUCCESS is
 returned.  If A creation requirements are not met, SPARSE_ILLEGAL_PARAMETER is
 returned and A is unchanged.
 
 @discussion
 Use to build a sparse matrix by providing a dense block for entry at block
 location A[bi,bj].  Block size is determined at object creation time.  Given a
 block dimension of k x l and for location bi,bj, update as:
 A[bi,bj][i,j] = val[i*row_stride + j*col_stride] for each i in k and each j in
 l.  
 
 A must have been created with one of sparse_matrix_block_create_float,
 sparse_matrix_block_create_double, sparse_matrix_variable_block_create_float, or
 sparse_matrix_variable_block_create_double.
 
 Note that matrix properties cannot be modified after value insertion begins.
 This includes properties such as specifying a triangular matrix.
 
 Insertion can be expensive, generally speaking it is best to do a batch update.
 Inserted values may be temporarily held internally within the object and only
 inserted into the sparse format when a later computation triggers a need to
 insert.
 
 */
sparse_status sparse_insert_block_float( sparse_matrix_float A,
                                   const float * __restrict val,
                                   sparse_dimension row_stride,
                                   sparse_dimension col_stride,
                                   sparse_index bi, sparse_index bj );
sparse_status sparse_insert_block_double( sparse_matrix_double A,
                                    const double * __restrict val,
                                    sparse_dimension row_stride,
                                    sparse_dimension col_stride,
                                    sparse_index bi, sparse_index bj );


/*!
 @abstract
 Extract the bi,bj'th block from the sparse matrix A.  A must have been created
 with one of sparse_matrix_block_create_float, sparse_matrix_block_create_double, 
 sparse_matrix_variable_block_create_float, or 
 sparse_matrix_variable_block_create_double.
 
 @param A
 The sparse matrix.  A must have been created with one of
 sparse_matrix_block_create_float, sparse_matrix_block_create_double,
 sparse_matrix_variable_block_create_float, or
 sparse_matrix_variable_block_create_double.  SPARSE_ILLEGAL_PARAMETER is returned if
 not met.  A holds block dimensions (fixed or variable) set with matrix object
 creation routine.
 
 @param bi
 The block row index for value extraction.  Indices are 0 based (first block of 
 matrix is A[0,0]).  Indices expected to be in the bounds of matrix dimensions,
 undefined behavior if not met.
 
 @param bj
 The block column index for value extraction.  Indices are 0 based (first block 
 of matrix is A[0,0]).  Indices expected to be in the bounds of matrix 
 dimensions, undefined behavior if not met.
 
 @param row_stride
 The row stride in number of elements to move from one row to the next for the
 block val.
 
 @param col_stride
 The column stride in number of elements to move from one column to the next for
 the block val.
 
 @param val
 Pointer to dense block to place the extracted values.  Expected to be of size
 K x L where K x L is the block size for the matrix object at block index bi,bj.
 This dimensions is set at matrix object creation time.
 
 @result
 On success SPARSE_SUCCESS is return and val has been updated with the block from
 block index bi,bj. If A creation requirements are not met, 
 SPARSE_ILLEGAL_PARAMETER is returned and val is unchanged.
 
 @discussion
 Extract the bi,bj'th block from the sparse matrix A.  
 
 A must have been created with one of sparse_matrix_block_create_float, 
 sparse_matrix_block_create_double, sparse_matrix_variable_block_create_float, or
 sparse_matrix_variable_block_create_double.
 
 */
sparse_status sparse_extract_block_float( sparse_matrix_float A, sparse_index bi,
                                    sparse_index bj, sparse_dimension row_stride,
                                    sparse_dimension col_stride,
                                    float * __restrict val );
sparse_status sparse_extract_block_double( sparse_matrix_double A, sparse_index bi,
                                     sparse_index bj, sparse_dimension row_stride,
                                     sparse_dimension col_stride,
                                     double * __restrict val );

/*!
 @abstract
 Return the dimension of the block for the i'th row of a sparse block matrix. 
 Returns 0 if the matrix was not created with a block create routine.
 */
long sparse_get_block_dimension_for_row( void *A, sparse_index i );

/*!
 @abstract
 Return the dimension of the block for the j'th column of a sparse block matrix.
 Returns 0 if the matrix was not created with a block create routine.
 */
long sparse_get_block_dimension_for_col( void *A, sparse_index j );



#pragma mark - General Sparse Matrix Management Routines -

			/* General Sparse Matrix Management Routines */
/*!
 @functiongroup General Sparse Matrix Management Routines
 @abstract Routines to manage and work with sparse matrix properties.
 */

/*!
 @abstract
 Force any recently added values to the matrix to be put into the internal
 sparse storage format.
 
 @param A
 The sparse matrix, which has had values recently inserted into the object.
 
 @result
 On success, A has all values inserted into the internal sparse representation.
 
 @discussion
 Force any recently added values to the matrix to be put into the internal
 sparse storage format.  Values inserted into a matrix object will may not go 
 directly into the sparse representation until needed, for example when a 
 computation occurs.  In some cases is may be beneficial to the caller to know 
 when the cost of the update will occur.  This routine allows the caller to 
 trigger adding values to the internal sparse format.
 
 Adding values to the sparse format can be costly, and batch updates to the 
 matrices are recommended.  Similarly, use of this routine may be expensive, so
 it is best to insert all values of a batch and call this routine once.
 
 */
sparse_status sparse_commit( void *A );


/*!
 @abstract
 Returns the value of the given property name.
 
 @param A
 The sparse matrix object.
 
 @param pname
 The property name to get the value of.  See matrix properties enumeration for
 options.
 
 @result
 Returns the value of the property for a valid object and property, or 0 
 otherwise.
 
 @discussion
 Returns the value of the given property name. See matrix properties enumeration
 for further property details.

 */
long sparse_get_matrix_property( void *A, sparse_matrix_property pname );

/*!
 @abstract
 Set the given property for a matrix object that has not had any values 
 inserted.
 
 @param A
 The sparse matrix object.  Note that after elements have been inserted
 properties cannot be changed.
 
 @param pname
 The property name to set true.  See matrix properties enumeration for options.
 
 @result
 Returns SPARSE_SUCCESS when property is successfully set, otherwise return
 SPARSE_CANNOT_SET_PROPERTY.
 
 @discussion
 Set the given property for the matrix object.  The matrix object must not have
 had values inserted, else SPARSE_CANNOT_SET_PROPERTY is returned and the 
 property is not set.
 
 Certain groups of properties are mutually exclusive and setting multiple values
 within a group is undefined.
 
 */
sparse_status sparse_set_matrix_property( void *A, sparse_matrix_property pname );


/*!
 @abstract
 Return the number of rows of the matrix.
 */
sparse_dimension sparse_get_matrix_number_of_rows( void *A );

/*!
 @abstract
 Return the number of columns of the matrix.
 */
sparse_dimension sparse_get_matrix_number_of_columns( void *A );

/*!
 @abstract
 Return the number of nonzero values in the matrix.
 */
long sparse_get_matrix_nonzero_count( void *A );

/*!
 @abstract
 Return the number of nonzero values for the i'th row.  If index is out of
 bounds of the matrix, 0 is returned.
 */
long sparse_get_matrix_nonzero_count_for_row( void *A, sparse_index i );

/*!
 @abstract
 Return the number of nonzero values for the j'th column.  If index is out of
 bounds of the matrix, 0 is returned.
 */
long sparse_get_matrix_nonzero_count_for_column( void *A, sparse_index j );



/*!
 @abstract
 Release any memory associated with the matrix object.
 
 @param A
 The sparse matrix object.
 
 @result
 All memory associated with the matrix object is released and returns 
 SPARSE_SUCCESS.
 
 @discussion
 Release any memory associated with the matrix object.  Upon return the object 
 is no longer valid and any use of the object is undefined.
 
 */
sparse_status sparse_matrix_destroy( void *A );




#pragma mark - Sparse Utilities -
	/* Sparse Utility Routines */
/*!
 @functiongroup Sparse Utilities
 @abstract Various utility routines for creating and working with sparse 
 structures.
 */

/*!
 @abstract
 Return the number of nonzero values in the dense vector x.
 
 @param N
 The number of elements in the dense vector x.
 
 @param x
 Pointer to the vector x.
 
 @param incx
 Increment between valid values in the dense vector x.  Negative strides are
 supported.
 
 @result
 Return the count of the nonzero values in the vector x.
 
 */
long sparse_get_vector_nonzero_count_float( sparse_dimension N,
                                         const float * __restrict x,
                                         sparse_stride incx );
long sparse_get_vector_nonzero_count_double( sparse_dimension N,
                                          const double * __restrict x,
                                          sparse_stride incx );

/*!
 @abstract
 Pack the first nz nonzero values and indices from the dense vector x and
 place them in y and indy.
 
 @param N
 The number of elements in the dense vector x.
 
 @param nz
 The number of nonzero values to collect.  If less than nz nonzero elements are
 found in the N elements of x, then the last nz - actual_nonzero_count of y and
 indy are unused.
 
 @param x
 Pointer to the dense vector x.
 
 @param incx
 Increment between valid values in the dense vector x.  Negative strides are
 supported.
 
 @param y
 The destination dense storage of nonzero values of y.  Expected to be of size
 nz elements.  On return, any nonzero values are placed in this array, if the 
 actual number of nonzero values is less than nz, then the last 
 nz - actual_nonzero_count elements are unused.
 
 @param indy
 The destination dense storage of nonzero indices of y.  Expected to be of size 
 nz elements.  On return, any nonzero indices are placed in this array, if the 
 actual number of nonzero values is less than nz, then the last 
 nz - actual_nonzero_count elements are unused.  Returned indices are 0 based 
 (the first element of a pointer is ptr[0]).
 
 @result
 On success, y and indy are updated with up to the first nz nonzero indices.  
 The number of nonzero values written is returned.
 
 @discussion
 Pack the first nz nonzero values and indices from the dense vector x and
 place them in y and indy.  If less than nz nonzero elements are found in the N 
 elements of x, then the last nz - actual_nonzero_count elements of y and indy 
 are unused.  The number of indices written can range from 0 to nz values and 
 the number written is returned.
 
 */
long sparse_pack_vector_float( sparse_dimension N, sparse_dimension nz,
                                  const float * __restrict x,
                                  sparse_stride incx, float * __restrict y,
                                  sparse_index * __restrict indy );
long sparse_pack_vector_double( sparse_dimension N, sparse_dimension nz,
                                   const double * __restrict x,
                                   sparse_stride incx, double * __restrict y,
                                   sparse_index * __restrict indy );


/*!
 @abstract
 Extract elements from the sparse vector x into the corresponding location in
 the dense vector y.  Optionally zero the unused values of y.
 
 @param N
 The number of elements in the dense vector y.
 
 @param nz
 The number of nonzero entries in the sparse vector x.
 
 @param zero
 When true, zero the elements of y which do not have nonzero values written to
 them.  When false ignore the elements of y which do not have nonzero values
 written to them.
 
 @param x
 Pointer to the dense storage for the values of the sparse vector x.  The
 corresponding entry in indx holds the index of the value.  Contains nz values.
 
 @param indx
 Pointer to the dense storage for the index values of the sparse vector x.  The
 corresponding entry in x holds the values of the vector.  Contains nz values.
 
 Indices are always assumed to be stored in ascending order. Additionally,
 indices are assumed to be unique.  Undefined behavior if either of these
 assumptions are not met.
 
 All indices are 0 based (the first element of a pointer is ptr[0]).
 
 @param y
 Pointer to the dense vector y.  Expected to be of size N*abs(incy) elements.  
 Negative strides are supported.  Note, unlike dense BLAS routines, the pointer 
 points to the last element when stride is negative. On exit, the entries 
 described by the indices in indx will be filled with the corresponding values 
 in x and all other values will be unchanged if parameter zero is false, or set 
 to zero if parameter zero is true.
 
 @param incy
 Increment between valid values in the dense vector y.  Negative strides are
 supported.
 
 @result
 On exit y has been updated with the nonzero values. If nz is less than or
 equal to zero y is unchanged.
 
 @discussion
 Extract elements from the sparse vector x into the corresponding location in
 the dense vector y.  Optionally zero the unused values of y.
 
 if (zero) for (i in 0 .. N-1) y[i*incy] = 0;
 
 for (i in 0 .. nz-1) if (indx[i] < N) y[indx[i]*incy] = x[i];
 */
void sparse_unpack_vector_float( sparse_dimension N, sparse_dimension nz, bool zero,
                               const float * __restrict x,
                               const sparse_index * __restrict indx,
                               float * __restrict y, sparse_stride incy );
void sparse_unpack_vector_double( sparse_dimension N, sparse_dimension nz, bool zero,
                                const double * __restrict x,
                                const sparse_index * __restrict indx,
                                double * __restrict y, sparse_stride incy );

#ifdef __cplusplus
}
#endif

#endif
  /* __SPARSE_BLAS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                         Sparse.h                                                                                            0100644 0001750 0001750 00000000352 12566175205 044030  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/Sparse                    /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __SPARSE_HEADER__
#define __SPARSE_HEADER__

#include <vecLib/Sparse/Types.h>
#include <vecLib/Sparse/BLAS.h>

#endif
  /* __SPARSE_HEADER__ */
                                                                                                                                                                                                                                                                                      Types.h                                                                                             0100644 0001750 0001750 00000005616 12566175205 043707  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers/Sparse                    /*  Copyright (c) 2014 Apple Inc.  All rights reserved.                       */

#ifndef __SPARSE_TYPES_H
#define __SPARSE_TYPES_H

#pragma mark - Type defines -

/*!
 @header Sparse/Types.h
 @discussion
 Types supporting Sparse BLAS routines.
 
 @copyright Copyright (c) 2014 Apple Inc. All rights reserved.
*/

#include <stdint.h>
#include <stdbool.h>

/*!
 @abstract Sparse matrix type for float.  Opaque structure
 */
typedef struct sparse_m_float* sparse_matrix_float;
/*!
 @abstract Sparse matrix type for double.  Opaque structure
 */
typedef struct sparse_m_double* sparse_matrix_double;

/*!
 @abstract The dimension type. All dimensions are positive values.
 */
typedef uint64_t sparse_dimension;

/*!
 @abstract The stride type.  Supports negative strides for the dense vectors.
 */
typedef int64_t sparse_stride;

/*!
 @abstract The index type.  All indices including those in a sparse vectors 
 index array are positive values.
 */
typedef int64_t sparse_index;

/*!
 @abstract The type reflecting the status of an operations.
 
 @constant SPARSE_SUCCESS
 Operation was a success
 
 @constant SPARSE_ILLEGAL_PARAMETER
 Operation was not completed because one or more of the arguments had an illegal
 value.
 
 @constant SPARSE_CANNOT_SET_PROPERTY
 Matrix properties can only be set before any values are inserted into the
 matrix.  This error occurs if that order is not repsected.
 
 @constant SPARSE_SYSTEM_ERROR
 An internal error has occured, such as non enough memory.
 */
typedef enum {
    SPARSE_SUCCESS = 0,
    SPARSE_ILLEGAL_PARAMETER = -1000,
    SPARSE_CANNOT_SET_PROPERTY = -1001,
    SPARSE_SYSTEM_ERROR = -1002,
} sparse_status;

/*!
 @abstract The matrix property type
 */
typedef enum {
    SPARSE_UPPER_TRIANGULAR = 1,
    SPARSE_LOWER_TRIANGULAR = 2,
    
    SPARSE_UPPER_SYMMETRIC = 4,
    SPARSE_LOWER_SYMMETRIC = 8,
} sparse_matrix_property;


/*!
 @abstract The norm specifier
 @constant SPARSE_NORM_ONE
 Matrix element wise: sum over i,j ( | A[i,j] | )
 
 Matrix operator    : max over j ( sum over i ( | A[i,j] | )
 
 Vector element wise: sum over i ( | x[i] | )
 
 @constant SPARSE_NORM_TWO
 Matrix element wise: sqrt( sum over i,j (A[i,j])^2 )
 
 Matrix operator    : Largest singular value of matrix, note that the operator
 SPARSE_NORM_TWO is significantly more expensive than other norm operations.
 
 Vector element wise: sqrt( sum over i (x[i])^2 )
 
 @constant SPARSE_NORM_INF
 Matrix element wise: max over i,j ( | A[i,j] | )
 
 Matrix operator    : max over i ( sum over j ( | A[i,j] | )
 
 Vector element wise: max over i ( | x[i] | )
 
 @constant SPARSE_NORM_R1
 Matrix element wise: sum over j ( sqrt ( sum over i ( A[i,j]^2 ) ) )
 
 Matrix operator    : Not supported. Undefined
 
 Vector element wise: Not supported. Undefined
 */
typedef enum {
    SPARSE_NORM_ONE = 171,
    SPARSE_NORM_TWO = 173,
    SPARSE_NORM_INF = 175,
    SPARSE_NORM_R1 =  179
} sparse_norm;

#endif
   /* __SPARSE_TYPES_H */
                                                                                                                  cblas.h                                                                                             0100644 0001750 0001750 00000134620 12566174663 042437  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers                           /* cblas.h
 *
 * This header defines C bindings for the Basic Linear Algebra Subprograms,
 * providing optimized basic operations on vectors and matrices.  Single-
 * and double-precision, real and complex data formats are supported by this
 * library.
 *
 * A note on complex data layouts:
 *
 * In order to allow straightforward interoperation with other libraries and
 * complex types in C and C++, complex data in BLAS is passed through an opaque
 * pointer (void *).  The layout requirements on this complex data are that
 * the real and imaginary parts are stored consecutively in memory, and have
 * the alignment of the corresponding real type (float or double).  The BLAS
 * complex interfaces are compatible with the following types:
 *
 *     - The C complex types, defined in <complex.h>.
 *     - The C++ std::complex types, defined in <complex>.
 *     - The LAPACK complex types, defined in <Accelerate/vecLib/clapack.h>.
 *     - The vDSP types DSPComplex and DSPDoubleComplex, defined in <Accelerate/vecLib/vDSP.h>.
 *     - An array of size two of the corresponding real type.
 *     - A structure containing two elements, each of the corresponding real type.
 * 
 */

#ifndef CBLAS_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef CBLAS_ENUM_DEFINED_H
#define CBLAS_ENUM_DEFINED_H
enum CBLAS_ORDER {CblasRowMajor=101, CblasColMajor=102 };
enum CBLAS_TRANSPOSE {CblasNoTrans=111, CblasTrans=112, CblasConjTrans=113,
	AtlasConj=114};
enum CBLAS_UPLO  {CblasUpper=121, CblasLower=122};
enum CBLAS_DIAG  {CblasNonUnit=131, CblasUnit=132};
enum CBLAS_SIDE  {CblasLeft=141, CblasRight=142};
#endif  /* CBLAS_ENUM_DEFINED_H */

#ifndef CBLAS_ENUM_ONLY
#define CBLAS_H
#define CBLAS_INDEX int

#include <Availability.h>

int cblas_errprn(int __ierr, int __info, char *__form, ...) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_xerbla(int __p, char *__rout, char *__form, ...) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

/*
 * ===========================================================================
 * Prototypes for level 1 BLAS functions (complex are recast as routines)
 * ===========================================================================
 */
float  cblas_sdsdot(const int __N, const float __alpha, const float *__X,
        const int __incX, const float *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
double cblas_dsdot(const int __N, const float *__X, const int __incX,
        const float *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
float  cblas_sdot(const int __N, const float *__X, const int __incX,
        const float *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
double cblas_ddot(const int __N, const double *__X, const int __incX,
        const double *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
/*
 * Functions having prefixes Z and C only
 */
void   cblas_cdotu_sub(const int __N, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__dotu) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void   cblas_cdotc_sub(const int __N, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__dotc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void   cblas_zdotu_sub(const int __N, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__dotu) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void   cblas_zdotc_sub(const int __N, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__dotc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);


/*
 * Functions having prefixes S D SC DZ
 */
float  cblas_snrm2(const int __N, const float *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
float  cblas_sasum(const int __N, const float *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

double cblas_dnrm2(const int __N, const double *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
double cblas_dasum(const int __N, const double *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

float  cblas_scnrm2(const int __N, const void *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
float  cblas_scasum(const int __N, const void *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

double cblas_dznrm2(const int __N, const void *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
double cblas_dzasum(const int __N, const void *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);


/*
 * Functions having standard 4 prefixes (S D C Z)
 */
CBLAS_INDEX cblas_isamax(const int __N, const float *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
CBLAS_INDEX cblas_idamax(const int __N, const double *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
CBLAS_INDEX cblas_icamax(const int __N, const void *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
CBLAS_INDEX cblas_izamax(const int __N, const void *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

/*
 * ===========================================================================
 * Prototypes for level 1 BLAS routines
 * ===========================================================================
 */

/*
 * Routines with standard 4 prefixes (s, d, c, z)
 */
void cblas_sswap(const int __N, float *__X, const int __incX, float *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_scopy(const int __N, const float *__X, const int __incX, float *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_saxpy(const int __N, const float __alpha, const float *__X,
        const int __incX, float *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void catlas_saxpby(const int __N, const float __alpha, const float *__X,
        const int __incX, const float __beta, float *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void catlas_sset(const int __N, const float __alpha, float *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_dswap(const int __N, double *__X, const int __incX, double *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dcopy(const int __N, const double *__X, const int __incX,
        double *__Y, const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_daxpy(const int __N, const double __alpha, const double *__X,
        const int __incX, double *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void catlas_daxpby(const int __N, const double __alpha, const double *__X,
        const int __incX, const double __beta, double *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void catlas_dset(const int __N, const double __alpha, double *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_cswap(const int __N, void *__X, const int __incX, void *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ccopy(const int __N, const void *__X, const int __incX, void *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_caxpy(const int __N, const void *__alpha, const void *__X,
        const int __incX, void *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void catlas_caxpby(const int __N, const void *__alpha, const void *__X,
        const int __incX, const void *__beta, void *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void catlas_cset(const int __N, const void *__alpha, void *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_zswap(const int __N, void *__X, const int __incX, void *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zcopy(const int __N, const void *__X, const int __incX, void *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zaxpy(const int __N, const void *__alpha, const void *__X,
        const int __incX, void *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void catlas_zaxpby(const int __N, const void *__alpha, const void *__X,
        const int __incX, const void *__beta, void *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void catlas_zset(const int __N, const void *__alpha, void *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);


/*
 * Routines with S and D prefix only
 */
void cblas_srotg(float *__a, float *__b, float *__c, float *__s) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_srotmg(float *__d1, float *__d2, float *__b1, const float __b2,
        float *__P) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_srot(const int __N, float *__X, const int __incX, float *__Y,
        const int __incY, const float __c, const float __s) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_srotm(const int __N, float *__X, const int __incX, float *__Y,
        const int __incY, const float *__P) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_drotg(double *__a, double *__b, double *__c, double *__s) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_drotmg(double *__d1, double *__d2, double *__b1, const double __b2,
        double *__P) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_drot(const int __N, double *__X, const int __incX, double *__Y,
        const int __incY, const double __c, const double __s) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_drotm(const int __N, double *__X, const int __incX, double *__Y,
        const int __incY, const double *__P) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);


/*
 * Routines with S D C Z CS and ZD prefixes
 */
void cblas_sscal(const int __N, const float __alpha, float *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dscal(const int __N, const double __alpha, double *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_cscal(const int __N, const void *__alpha, void *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zscal(const int __N, const void *__alpha, void *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_csscal(const int __N, const float __alpha, void *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zdscal(const int __N, const double __alpha, void *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

/*
 * Extra reference routines provided by ATLAS, but not mandated by the standard
 */
void cblas_crotg(void *__a, void *__b, void *__c, void *__s) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zrotg(void *__a, void *__b, void *__c, void *__s) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_csrot(const int __N, void *__X, const int __incX, void *__Y,
        const int __incY, const float __c, const float __s) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zdrot(const int __N, void *__X, const int __incX, void *__Y,
        const int __incY, const double __c, const double __s) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

/*
 * ===========================================================================
 * Prototypes for level 2 BLAS
 * ===========================================================================
 */

/*
 * Routines with standard 4 prefixes (S, D, C, Z)
 */
void cblas_sgemv(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA, const int __M, const int __N,
        const float __alpha, const float *__A, const int __lda,
        const float *__X, const int __incX, const float __beta, float *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_sgbmv(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA, const int __M, const int __N,
        const int __KL, const int __KU, const float __alpha, const float *__A,
        const int __lda, const float *__X, const int __incX,
        const float __beta, float *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_strmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const float *__A, const int __lda, float *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_stbmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const int __K, const float *__A, const int __lda,
        float *__X, const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_stpmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const float *__Ap, float *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_strsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const float *__A, const int __lda, float *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_stbsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const int __K, const float *__A, const int __lda,
        float *__X, const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_stpsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const float *__Ap, float *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_dgemv(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA, const int __M, const int __N,
        const double __alpha, const double *__A, const int __lda,
        const double *__X, const int __incX, const double __beta, double *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dgbmv(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA, const int __M, const int __N,
        const int __KL, const int __KU, const double __alpha,
        const double *__A, const int __lda, const double *__X,
        const int __incX, const double __beta, double *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dtrmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const double *__A, const int __lda, double *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dtbmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const int __K, const double *__A, const int __lda,
        double *__X, const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_dtpmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const double *__Ap, double *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dtrsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const double *__A, const int __lda, double *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dtbsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const int __K, const double *__A, const int __lda,
        double *__X, const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_dtpsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const double *__Ap, double *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_cgemv(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA, const int __M, const int __N,
        const void *__alpha, const void *__A, const int __lda, const void *__X,
        const int __incX, const void *__beta, void *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_cgbmv(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA, const int __M, const int __N,
        const int __KL, const int __KU, const void *__alpha, const void *__A,
        const int __lda, const void *__X, const int __incX, const void *__beta,
        void *__Y, const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_ctrmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const void *__A, const int __lda, void *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ctbmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const int __K, const void *__A, const int __lda,
        void *__X, const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_ctpmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const void *__Ap, void *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ctrsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const void *__A, const int __lda, void *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ctbsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const int __K, const void *__A, const int __lda,
        void *__X, const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_ctpsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const void *__Ap, void *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_zgemv(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA, const int __M, const int __N,
        const void *__alpha, const void *__A, const int __lda, const void *__X,
        const int __incX, const void *__beta, void *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zgbmv(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA, const int __M, const int __N,
        const int __KL, const int __KU, const void *__alpha, const void *__A,
        const int __lda, const void *__X, const int __incX, const void *__beta,
        void *__Y, const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_ztrmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const void *__A, const int __lda, void *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ztbmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const int __K, const void *__A, const int __lda,
        void *__X, const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_ztpmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const void *__Ap, void *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ztrsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const void *__A, const int __lda, void *__X,
        const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ztbsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const int __K, const void *__A, const int __lda,
        void *__X, const int __incX) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_ztpsv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __TransA, const enum CBLAS_DIAG __Diag,
        const int __N, const void *__Ap, void *__X, const int __incX) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);


/*
 * Routines with S and D prefixes only
 */
void cblas_ssymv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const float __alpha, const float *__A, const int __lda,
        const float *__X, const int __incX, const float __beta, float *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ssbmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const int __K, const float __alpha, const float *__A,
        const int __lda, const float *__X, const int __incX,
        const float __beta, float *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_sspmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const float __alpha, const float *__Ap,
        const float *__X, const int __incX, const float __beta, float *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_sger(const enum CBLAS_ORDER __Order, const int __M, const int __N,
        const float __alpha, const float *__X, const int __incX,
        const float *__Y, const int __incY, float *__A, const int __lda) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ssyr(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const float __alpha, const float *__X, const int __incX,
        float *__A, const int __lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_sspr(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const float __alpha, const float *__X, const int __incX,
        float *__Ap) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ssyr2(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const float __alpha, const float *__X, const int __incX,
        const float *__Y, const int __incY, float *__A, const int __lda) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_sspr2(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const float __alpha, const float *__X, const int __incX,
        const float *__Y, const int __incY, float *__A) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_dsymv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const double __alpha, const double *__A,
        const int __lda, const double *__X, const int __incX,
        const double __beta, double *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dsbmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const int __K, const double __alpha, const double *__A,
        const int __lda, const double *__X, const int __incX,
        const double __beta, double *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dspmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const double __alpha, const double *__Ap,
        const double *__X, const int __incX, const double __beta, double *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dger(const enum CBLAS_ORDER __Order, const int __M, const int __N,
        const double __alpha, const double *__X, const int __incX,
        const double *__Y, const int __incY, double *__A, const int __lda) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dsyr(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const double __alpha, const double *__X,
        const int __incX, double *__A, const int __lda) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dspr(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const double __alpha, const double *__X,
        const int __incX, double *__Ap) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_dsyr2(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const double __alpha, const double *__X,
        const int __incX, const double *__Y, const int __incY, double *__A,
        const int __lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dspr2(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const double __alpha, const double *__X,
        const int __incX, const double *__Y, const int __incY, double *__A) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);


/*
 * Routines with C and Z prefixes only
 */
void cblas_chemv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const void *__alpha, const void *__A, const int __lda,
        const void *__X, const int __incX, const void *__beta, void *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_chbmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const int __K, const void *__alpha, const void *__A,
        const int __lda, const void *__X, const int __incX, const void *__beta,
        void *__Y, const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_chpmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const void *__alpha, const void *__Ap, const void *__X,
        const int __incX, const void *__beta, void *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_cgeru(const enum CBLAS_ORDER __Order, const int __M, const int __N,
        const void *__alpha, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__A, const int __lda) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_cgerc(const enum CBLAS_ORDER __Order, const int __M, const int __N,
        const void *__alpha, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__A, const int __lda) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_cher(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const float __alpha, const void *__X, const int __incX,
        void *__A, const int __lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_chpr(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const float __alpha, const void *__X, const int __incX,
        void *__A) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_cher2(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const void *__alpha, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__A, const int __lda) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_chpr2(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const void *__alpha, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__Ap) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_zhemv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const void *__alpha, const void *__A, const int __lda,
        const void *__X, const int __incX, const void *__beta, void *__Y,
        const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zhbmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const int __K, const void *__alpha, const void *__A,
        const int __lda, const void *__X, const int __incX, const void *__beta,
        void *__Y, const int __incY) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_zhpmv(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const void *__alpha, const void *__Ap, const void *__X,
        const int __incX, const void *__beta, void *__Y, const int __incY) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zgeru(const enum CBLAS_ORDER __Order, const int __M, const int __N,
        const void *__alpha, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__A, const int __lda) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zgerc(const enum CBLAS_ORDER __Order, const int __M, const int __N,
        const void *__alpha, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__A, const int __lda) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zher(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const double __alpha, const void *__X, const int __incX,
        void *__A, const int __lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);
void cblas_zhpr(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const double __alpha, const void *__X, const int __incX,
        void *__A) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zher2(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const void *__alpha, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__A, const int __lda) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zhpr2(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const int __N, const void *__alpha, const void *__X, const int __incX,
        const void *__Y, const int __incY, void *__Ap) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

/*
 * ===========================================================================
 * Prototypes for level 3 BLAS
 * ===========================================================================
 */

/*
 * Routines with standard 4 prefixes (S, D, C, Z)
 */
void cblas_sgemm(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_TRANSPOSE __TransB, const int __M, const int __N,
        const int __K, const float __alpha, const float *__A, const int __lda,
        const float *__B, const int __ldb, const float __beta, float *__C,
        const int __ldc) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ssymm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const int __M, const int __N,
        const float __alpha, const float *__A, const int __lda,
        const float *__B, const int __ldb, const float __beta, float *__C,
        const int __ldc) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ssyrk(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const float __alpha, const float *__A, const int __lda,
        const float __beta, float *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ssyr2k(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const float __alpha, const float *__A, const int __lda,
        const float *__B, const int __ldb, const float __beta, float *__C,
        const int __ldc) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_strmm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_DIAG __Diag, const int __M, const int __N,
        const float __alpha, const float *__A, const int __lda, float *__B,
        const int __ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_strsm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_DIAG __Diag, const int __M, const int __N,
        const float __alpha, const float *__A, const int __lda, float *__B,
        const int __ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_dgemm(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_TRANSPOSE __TransB, const int __M, const int __N,
        const int __K, const double __alpha, const double *__A,
        const int __lda, const double *__B, const int __ldb,
        const double __beta, double *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dsymm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const int __M, const int __N,
        const double __alpha, const double *__A, const int __lda,
        const double *__B, const int __ldb, const double __beta, double *__C,
        const int __ldc) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dsyrk(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const double __alpha, const double *__A, const int __lda,
        const double __beta, double *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dsyr2k(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const double __alpha, const double *__A, const int __lda,
        const double *__B, const int __ldb, const double __beta, double *__C,
        const int __ldc) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dtrmm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_DIAG __Diag, const int __M, const int __N,
        const double __alpha, const double *__A, const int __lda, double *__B,
        const int __ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_dtrsm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_DIAG __Diag, const int __M, const int __N,
        const double __alpha, const double *__A, const int __lda, double *__B,
        const int __ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_cgemm(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_TRANSPOSE __TransB, const int __M, const int __N,
        const int __K, const void *__alpha, const void *__A, const int __lda,
        const void *__B, const int __ldb, const void *__beta, void *__C,
        const int __ldc) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_csymm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const int __M, const int __N,
        const void *__alpha, const void *__A, const int __lda, const void *__B,
        const int __ldb, const void *__beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_csyrk(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const void *__alpha, const void *__A, const int __lda,
        const void *__beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_csyr2k(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const void *__alpha, const void *__A, const int __lda, const void *__B,
        const int __ldb, const void *__beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ctrmm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_DIAG __Diag, const int __M, const int __N,
        const void *__alpha, const void *__A, const int __lda, void *__B,
        const int __ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ctrsm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_DIAG __Diag, const int __M, const int __N,
        const void *__alpha, const void *__A, const int __lda, void *__B,
        const int __ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cblas_zgemm(const enum CBLAS_ORDER __Order,
        const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_TRANSPOSE __TransB, const int __M, const int __N,
        const int __K, const void *__alpha, const void *__A, const int __lda,
        const void *__B, const int __ldb, const void *__beta, void *__C,
        const int __ldc) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zsymm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const int __M, const int __N,
        const void *__alpha, const void *__A, const int __lda, const void *__B,
        const int __ldb, const void *__beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zsyrk(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const void *__alpha, const void *__A, const int __lda,
        const void *__beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zsyr2k(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const void *__alpha, const void *__A, const int __lda, const void *__B,
        const int __ldb, const void *__beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ztrmm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_DIAG __Diag, const int __M, const int __N,
        const void *__alpha, const void *__A, const int __lda, void *__B,
        const int __ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_ztrsm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const enum CBLAS_TRANSPOSE __TransA,
        const enum CBLAS_DIAG __Diag, const int __M, const int __N,
        const void *__alpha, const void *__A, const int __lda, void *__B,
        const int __ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);


/*
 * Routines with prefixes C and Z only
 */
void cblas_chemm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const int __M, const int __N,
        const void *__alpha, const void *__A, const int __lda, const void *__B,
        const int __ldb, const void *__beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_cherk(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const float __alpha, const void *__A, const int __lda,
        const float __beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_cher2k(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const void *__alpha, const void *__A, const int __lda, const void *__B,
        const int __ldb, const float __beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zhemm(const enum CBLAS_ORDER __Order, const enum CBLAS_SIDE __Side,
        const enum CBLAS_UPLO __Uplo, const int __M, const int __N,
        const void *__alpha, const void *__A, const int __lda, const void *__B,
        const int __ldb, const void *__beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zherk(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const double __alpha, const void *__A, const int __lda,
        const double __beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);
void cblas_zher2k(const enum CBLAS_ORDER __Order, const enum CBLAS_UPLO __Uplo,
        const enum CBLAS_TRANSPOSE __Trans, const int __N, const int __K,
        const void *__alpha, const void *__A, const int __lda, const void *__B,
        const int __ldb, const double __beta, void *__C, const int __ldc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

/* Apple extensions to the BLAS interface. */

/* These routines perform linear operations (scalar multiplication and addition)
 * on matrices, with optional transposition.  Specifically, the operation is:
 *
 *      C = alpha * A + beta * B
 *
 * where A and B are optionally transposed as indicated by the value of transA
 * and transB.  This is a surprisingly useful operation; although its function
 * is fairly trivial, efficient implementation has enough subtlety to justify
 * a library interface.
 *
 * As an added convenience, this function supports in-place operation for
 * square matrices; in-place operation for non-square matrices in the face of
 * transposition is a subtle problem outside the scope of this interface.
 * In-place operation is only supported if the leading dimensions match as well
 * as the pointers.  If C overlaps A or B but does not have equal leading
 * dimension, or does not exactly match the source that it overlaps, the
 * behavior of this function is undefined.
 *
 * If alpha or beta is zero, then A (or B, respectively) is ignored entirely,
 * meaning that the memory is not accessed and the data does not contribute
 * to the result (meaning you can pass B == NULL if beta is zero).
 *
 * Note that m and n are the number of rows and columns of C, respectively.
 * If either A or B is transposed, then they are interpreted as n x m matrices.
 */

extern void appleblas_sgeadd(const enum CBLAS_ORDER __order,
        const enum CBLAS_TRANSPOSE __transA,
        const enum CBLAS_TRANSPOSE __transB, const int __m, const int __n,
        const float __alpha, const float *__A, const int __lda,
        const float __beta, const float *__B, const int __ldb, float *__C,
        const int __ldc) __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);

extern void appleblas_dgeadd(const enum CBLAS_ORDER __order,
        const enum CBLAS_TRANSPOSE __transA,
        const enum CBLAS_TRANSPOSE __transB, const int __m, const int __n,
        const double __alpha, const double *__A, const int __lda,
        const double __beta, const double *__B, const int __ldb, double *__C,
        const int __ldc) __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);

/* Historically, the ATLAS-based BLAS in OS X allocated thread-local temp
 * buffers, and this routine existed to free that memory.  The Apple BLAS
 * is no longer based on ATLAS, and there are no scratch buffers to release,
 * so this routine has been deprecated.  It has been a no-op since OS X
 * 10.7, and calls to it may be safely removed.
 *
 * On iOS, this routine has never done anything, so there is no risk in
 * removing these calls.                                                      */

extern void ATLU_DestroyThreadMemory() 
        __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2, __MAC_10_9, __IPHONE_4_0,
        __IPHONE_7_0);

/* The BLAS standard defines a function, cblas_xerbla( ), and suggests that
 * programs provide their own implementation in order to override default
 * error handling.  This scheme is incompatible with the shared library /
 * framework environment of OS X and iOS.
 *
 * Instead, if you wish to change the default BLAS error handling (which is to
 * print an english error message and exit( )), you need to install your own
 * error handlger by calling SetBLASParamErrorProc.
 *
 * Your error handler should adhere to the BLASParamErrorProc interface; it
 * need to terminate program execution.  If your error handler returns normally,
 * then the BLAS call will return normally following its execution without
 * performing any further processing.                                         */

typedef void (*BLASParamErrorProc)(const char *funcName, const char *paramName,
                                   const int *paramPos,  const int *paramValue);
void SetBLASParamErrorProc(BLASParamErrorProc __ErrorProc) 
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

#endif /* CBLAS_ENUM_ONLY */

#ifdef __cplusplus
}
#endif

#endif /* CBLAS_H */
                                                                                                                clapack.h                                                                                           0100644 0001750 0001750 00002004156 12566175202 042741  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/Headers                           /*
 =================================================================================================
 Definitions and prototypes for LAPACK v3.2.1 as provided Apple Computer.

 Documentation of the LAPACK interfaces, including reference implementations, can be found on
 the web starting from the LAPACK FAQ page at this URL (verified live as of January 2010):
 http://netlib.org/lapack/faq.html

 A hardcopy maanual is:
 LAPACK Users' Guide, Third Edition. 
 @BOOK{laug,
 AUTHOR = {Anderson, E. and Bai, Z. and Bischof, C. and
 Blackford, S. and Demmel, J. and Dongarra, J. and
 Du Croz, J. and Greenbaum, A. and Hammarling, S. and
 McKenney, A. and Sorensen, D.},
 TITLE = {{LAPACK} Users' Guide},
 EDITION = {Third},
 PUBLISHER = {Society for Industrial and Applied Mathematics},
 YEAR = {1999},
 ADDRESS = {Philadelphia, PA},
 ISBN = {0-89871-447-8 (paperback)} }

 =================================================================================================
 */

#ifndef __CLAPACK_H
#define __CLAPACK_H

#ifdef __cplusplus
extern "C" {
#endif

#if defined(__LP64__) /* In LP64 match sizes with the 32 bit ABI */
    typedef int 		__CLPK_integer;
    typedef int 		__CLPK_logical;
    typedef float 		__CLPK_real;
    typedef double 		__CLPK_doublereal;
    typedef __CLPK_logical 	(*__CLPK_L_fp)();
    typedef int 		__CLPK_ftnlen;
#else
    typedef long int 	__CLPK_integer;
    typedef long int 	__CLPK_logical;
    typedef float 		__CLPK_real;
    typedef double 		__CLPK_doublereal;
    typedef __CLPK_logical 	(*__CLPK_L_fp)();
    typedef long int 	__CLPK_ftnlen;
#endif

typedef struct { __CLPK_real r, i; } __CLPK_complex;
typedef struct { __CLPK_doublereal r, i; } __CLPK_doublecomplex;

#include <Availability.h>

int cbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt,
        __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_complex *__vt, __CLPK_integer *__ldvt,
        __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku,
        __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq,
        __CLPK_complex *__pt, __CLPK_integer *__ldpt, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd,
        __CLPK_real *__colcnd, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd,
        __CLPK_real *__colcnd, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab,
        __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb,
        __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr,
        __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku,
        __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n,
        __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs,
        __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_complex *__afb,
        __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed,
        __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_complex *__ab,
        __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgebak_(char *__job, char *__side, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale,
        __CLPK_integer *__m, __CLPK_complex *__v, __CLPK_integer *__ldv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgebal_(char *__job, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_real *__scale,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_complex *__tauq, __CLPK_complex *__taup, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgecon_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__,
        __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__,
        __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__sdim, __CLPK_complex *__w, __CLPK_complex *__vs,
        __CLPK_integer *__ldvs, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork, __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__sdim, __CLPK_complex *__w, __CLPK_complex *__vs,
        __CLPK_integer *__ldvs, __CLPK_real *__rconde, __CLPK_real *__rcondv,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__w,
        __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr,
        __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__w, __CLPK_complex *__vl, __CLPK_integer *__ldvl,
        __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo,
        __CLPK_integer *__ihi, __CLPK_real *__scale, __CLPK_real *__abnrm,
        __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_complex *__work,
        __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta,
        __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr,
        __CLPK_integer *__ldvsr, __CLPK_complex *__work,
        __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta,
        __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr,
        __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond,
        __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond,
        __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond,
        __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond,
        __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af,
        __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgesc2_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv,
        __CLPK_real *__scale) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__s,
        __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__vt,
        __CLPK_integer *__ldvt, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_real *__s, __CLPK_complex *__u, __CLPK_integer *__ldu,
        __CLPK_complex *__vt, __CLPK_integer *__ldvt, __CLPK_complex *__work,
        __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgesvx_(char *__fact, char *__trans, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv,
        char *__equed, __CLPK_real *__r__, __CLPK_real *__c__,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x,
        __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr,
        __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgetc2_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__ipiv, __CLPK_integer *__jpiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgetri_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__ipiv, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cggbak_(char *__job, char *__side, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale,
        __CLPK_real *__rscale, __CLPK_integer *__m, __CLPK_complex *__v,
        __CLPK_integer *__ldv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cggbal_(char *__job, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale,
        __CLPK_real *__rscale, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim,
        __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__vsl,
        __CLPK_integer *__ldvsl, __CLPK_complex *__vsr, __CLPK_integer *__ldvsr,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg,
        char *__sense, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__sdim, __CLPK_complex *__alpha, __CLPK_complex *__beta,
        __CLPK_complex *__vsl, __CLPK_integer *__ldvsl, __CLPK_complex *__vsr,
        __CLPK_integer *__ldvsr, __CLPK_real *__rconde, __CLPK_real *__rcondv,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta,
        __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr,
        __CLPK_integer *__ldvr, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__alpha,
        __CLPK_complex *__beta, __CLPK_complex *__vl, __CLPK_integer *__ldvl,
        __CLPK_complex *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo,
        __CLPK_integer *__ihi, __CLPK_real *__lscale, __CLPK_real *__rscale,
        __CLPK_real *__abnrm, __CLPK_real *__bbnrm, __CLPK_real *__rconde,
        __CLPK_real *__rcondv, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__d__, __CLPK_complex *__x,
        __CLPK_complex *__y, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgghrd_(char *__compq, char *__compz, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__,
        __CLPK_integer *__ldz,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__c__, __CLPK_complex *__d__,
        __CLPK_complex *__x, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__taua,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__taub,
        __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__taua,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__taub,
        __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k,
        __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__alpha,
        __CLPK_real *__beta, __CLPK_complex *__u, __CLPK_integer *__ldu,
        __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q,
        __CLPK_integer *__ldq, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m,
        __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_integer *__k,
        __CLPK_integer *__l, __CLPK_complex *__u, __CLPK_integer *__ldu,
        __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__q,
        __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_real *__rwork,
        __CLPK_complex *__tau, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_complex *__dl,
        __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__du2,
        __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond,
        __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du,
        __CLPK_complex *__dlf, __CLPK_complex *__df, __CLPK_complex *__duf,
        __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__dl,
        __CLPK_complex *__d__, __CLPK_complex *__du, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__,
        __CLPK_complex *__du, __CLPK_complex *__dlf, __CLPK_complex *__df,
        __CLPK_complex *__duf, __CLPK_complex *__du2, __CLPK_integer *__ipiv,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x,
        __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr,
        __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgttrf_(__CLPK_integer *__n, __CLPK_complex *__dl, __CLPK_complex *__d__,
        __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__dl, __CLPK_complex *__d__, __CLPK_complex *__du,
        __CLPK_complex *__du2, __CLPK_integer *__ipiv, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__dl, __CLPK_complex *__d__,
        __CLPK_complex *__du, __CLPK_complex *__du2, __CLPK_integer *__ipiv,
        __CLPK_complex *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chbev_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__lrwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__vl,
        __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w,
        __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work,
        __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chbgst_(char *__vect, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab,
        __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb,
        __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab,
        __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb,
        __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab,
        __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb,
        __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__lrwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_complex *__ab,
        __CLPK_integer *__ldab, __CLPK_complex *__bb, __CLPK_integer *__ldbb,
        __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__vl,
        __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w,
        __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work,
        __CLPK_real *__rwork, __CLPK_integer *__iwork, __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__q,
        __CLPK_integer *__ldq, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int checon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm,
        __CLPK_real *__rcond, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cheequb_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond,
        __CLPK_real *__amax, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cheev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_complex *__work,
        __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cheevd_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__w,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__lrwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cheevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__vl,
        __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w,
        __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__lrwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cheevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__vl,
        __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w,
        __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work,
        __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork,
        __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chegs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chegst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chegv_(__CLPK_integer *__itype, char *__jobz, char *__uplo,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__w,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chegvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__w,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__lrwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chegvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__vl,
        __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w,
        __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_complex *__work,
        __CLPK_integer *__lwork, __CLPK_real *__rwork, __CLPK_integer *__iwork,
        __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cherfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af,
        __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chesv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chesvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x,
        __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr,
        __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chetd2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_complex *__tau,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chetf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chetrd_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chetrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chetri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chetrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_real *__alpha, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__beta,
        __CLPK_complex *__c__) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__,
        __CLPK_integer *__ldh, __CLPK_complex *__t, __CLPK_integer *__ldt,
        __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__q,
        __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

void chla_transtype__(char *__ret_val, __CLPK_ftnlen __ret_val_len,
        __CLPK_integer *__trans) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chpcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond,
        __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chpev_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__ap, __CLPK_real *__w, __CLPK_complex *__z__,
        __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chpevd_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__ap, __CLPK_real *__w, __CLPK_complex *__z__,
        __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork, __CLPK_integer *__lrwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chpevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__ap, __CLPK_real *__vl, __CLPK_real *__vu,
        __CLPK_integer *__il, __CLPK_integer *__iu, __CLPK_real *__abstol,
        __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__,
        __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__iwork, __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chpgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__ap, __CLPK_complex *__bp,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chpgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo,
        __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp,
        __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chpgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo,
        __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp,
        __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__lrwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chpgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo,
        __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__bp,
        __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il,
        __CLPK_integer *__iu, __CLPK_real *__abstol, __CLPK_integer *__m,
        __CLPK_real *__w, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_complex *__work, __CLPK_real *__rwork, __CLPK_integer *__iwork,
        __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x,
        __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chpsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chpsvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp,
        __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_real *__d__, __CLPK_real *__e, __CLPK_complex *__tau,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_integer *__ipiv, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chsein_(char *__side, char *__eigsrc, char *__initv,
        __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_complex *__h__,
        __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__vl,
        __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr,
        __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work,
        __CLPK_real *__rwork, __CLPK_integer *__ifaill,
        __CLPK_integer *__ifailr,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int chseqr_(char *__job, char *__compz, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_complex *__h__,
        __CLPK_integer *__ldh, __CLPK_complex *__w, __CLPK_complex *__z__,
        __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_complex *__tauq, __CLPK_complex *__taup,
        __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_complex *__y,
        __CLPK_integer *__ldy) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clacgv_(__CLPK_integer *__n, __CLPK_complex *__x,
        __CLPK_integer *__incx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clacn2_(__CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__x,
        __CLPK_real *__est, __CLPK_integer *__kase,
        __CLPK_integer *__isave) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clacon_(__CLPK_integer *__n, __CLPK_complex *__v, __CLPK_complex *__x,
        __CLPK_real *__est,
        __CLPK_integer *__kase) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clacp2_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clacrm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__c__, __CLPK_integer *__ldc,
        __CLPK_real *__rwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clacrt_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx,
        __CLPK_complex *__cy, __CLPK_integer *__incy, __CLPK_complex *__c__,
        __CLPK_complex *__s) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

void cladiv_(__CLPK_complex *__ret_val, __CLPK_complex *__x,
        __CLPK_complex *__y) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int claed0_(__CLPK_integer *__qsiz, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_complex *__q, __CLPK_integer *__ldq,
        __CLPK_complex *__qstore, __CLPK_integer *__ldqs, __CLPK_real *__rwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claed7_(__CLPK_integer *__n, __CLPK_integer *__cutpnt,
        __CLPK_integer *__qsiz, __CLPK_integer *__tlvls,
        __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_real *__d__,
        __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__rho,
        __CLPK_integer *__indxq, __CLPK_real *__qstore, __CLPK_integer *__qptr,
        __CLPK_integer *__prmptr, __CLPK_integer *__perm,
        __CLPK_integer *__givptr, __CLPK_integer *__givcol,
        __CLPK_real *__givnum, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claed8_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__qsiz,
        __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_real *__d__,
        __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__z__,
        __CLPK_real *__dlamda, __CLPK_complex *__q2, __CLPK_integer *__ldq2,
        __CLPK_real *__w, __CLPK_integer *__indxp, __CLPK_integer *__indx,
        __CLPK_integer *__indxq, __CLPK_integer *__perm,
        __CLPK_integer *__givptr, __CLPK_integer *__givcol,
        __CLPK_real *__givnum,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit,
        __CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh,
        __CLPK_complex *__w, __CLPK_complex *__v, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_real *__rwork, __CLPK_real *__eps3,
        __CLPK_real *__smlnum,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claesy_(__CLPK_complex *__a, __CLPK_complex *__b, __CLPK_complex *__c__,
        __CLPK_complex *__rt1, __CLPK_complex *__rt2, __CLPK_complex *__evscal,
        __CLPK_complex *__cs1,
        __CLPK_complex *__sn1) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claev2_(__CLPK_complex *__a, __CLPK_complex *__b, __CLPK_complex *__c__,
        __CLPK_real *__rt1, __CLPK_real *__rt2, __CLPK_real *__cs1,
        __CLPK_complex *__sn1) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clag2z_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__sa,
        __CLPK_integer *__ldsa, __CLPK_doublecomplex *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clags2_(__CLPK_logical *__upper, __CLPK_real *__a1, __CLPK_complex *__a2,
        __CLPK_real *__a3, __CLPK_real *__b1, __CLPK_complex *__b2,
        __CLPK_real *__b3, __CLPK_real *__csu, __CLPK_complex *__snu,
        __CLPK_real *__csv, __CLPK_complex *__snv, __CLPK_real *__csq,
        __CLPK_complex *__snq) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__alpha, __CLPK_complex *__dl, __CLPK_complex *__d__,
        __CLPK_complex *__du, __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_real *__beta, __CLPK_complex *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clahef_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb,
        __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__ipiv, __CLPK_complex *__w, __CLPK_integer *__ldw,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__,
        __CLPK_integer *__ldz,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__y,
        __CLPK_integer *__ldy) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__y,
        __CLPK_integer *__ldy) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_complex *__x,
        __CLPK_real *__sest, __CLPK_complex *__w, __CLPK_complex *__gamma,
        __CLPK_real *__sestpr, __CLPK_complex *__s,
        __CLPK_complex *__c__) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl,
        __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__bx,
        __CLPK_integer *__ldbx, __CLPK_integer *__perm,
        __CLPK_integer *__givptr, __CLPK_integer *__givcol,
        __CLPK_integer *__ldgcol, __CLPK_real *__givnum,
        __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl,
        __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k,
        __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz,
        __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__bx, __CLPK_integer *__ldbx,
        __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt,
        __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr,
        __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr,
        __CLPK_integer *__givcol, __CLPK_integer *__ldgcol,
        __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__,
        __CLPK_real *__s, __CLPK_real *__rwork, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__rcond,
        __CLPK_integer *__rank, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal clangb_(char *__norm, __CLPK_integer *__n,
        __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_complex *__ab,
        __CLPK_integer *__ldab,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clange_(char *__norm, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clangt_(char *__norm, __CLPK_integer *__n,
        __CLPK_complex *__dl, __CLPK_complex *__d__,
        __CLPK_complex *__du) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal clanhb_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clanhe_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clanhf_(char *__norm, char *__transr, char *__uplo,
        __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clanhp_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__ap,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clanhs_(char *__norm, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clanht_(char *__norm, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_complex *__e) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clansb_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clansp_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__ap,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clansy_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clantb_(char *__norm, char *__uplo, char *__diag,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__ab,
        __CLPK_integer *__ldab,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clantp_(char *__norm, char *__uplo, char *__diag,
        __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal clantr_(char *__norm, char *__uplo, char *__diag,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int clapll_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx,
        __CLPK_complex *__y, __CLPK_integer *__incy,
        __CLPK_real *__ssmin) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_integer *__k) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int claqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd,
        __CLPK_real *__colcnd, __CLPK_real *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int claqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__,
        __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int claqhb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s,
        __CLPK_real *__scond, __CLPK_real *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int claqhe_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond,
        __CLPK_real *__amax, char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claqhp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int claqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt,
        __CLPK_complex *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2,
        __CLPK_complex *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset,
        __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_complex *__tau,
        __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_complex *__auxv,
        __CLPK_complex *__f,
        __CLPK_integer *__ldf) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__,
        __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claqr1_(__CLPK_integer *__n, __CLPK_complex *__h__, __CLPK_integer *__ldh,
        __CLPK_complex *__s1, __CLPK_complex *__s2,
        __CLPK_complex *__v) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int claqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot,
        __CLPK_integer *__nw, __CLPK_complex *__h__, __CLPK_integer *__ldh,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__,
        __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd,
        __CLPK_complex *__sh, __CLPK_complex *__v, __CLPK_integer *__ldv,
        __CLPK_integer *__nh, __CLPK_complex *__t, __CLPK_integer *__ldt,
        __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv,
        __CLPK_complex *__work,
        __CLPK_integer *__lwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot,
        __CLPK_integer *__nw, __CLPK_complex *__h__, __CLPK_integer *__ldh,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__,
        __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd,
        __CLPK_complex *__sh, __CLPK_complex *__v, __CLPK_integer *__ldv,
        __CLPK_integer *__nh, __CLPK_complex *__t, __CLPK_integer *__ldt,
        __CLPK_integer *__nv, __CLPK_complex *__wv, __CLPK_integer *__ldwv,
        __CLPK_complex *__work,
        __CLPK_integer *__lwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_complex *__w,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_complex *__z__,
        __CLPK_integer *__ldz, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop,
        __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_complex *__s,
        __CLPK_complex *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz,
        __CLPK_integer *__ihiz, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__u,
        __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_complex *__wv,
        __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_complex *__wh,
        __CLPK_integer *__ldwh) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s,
        __CLPK_real *__scond, __CLPK_real *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int claqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int claqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond,
        __CLPK_real *__amax, char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn,
        __CLPK_real *__lambda, __CLPK_real *__d__, __CLPK_real *__l,
        __CLPK_real *__ld, __CLPK_real *__lld, __CLPK_real *__pivmin,
        __CLPK_real *__gaptol, __CLPK_complex *__z__, __CLPK_logical *__wantnc,
        __CLPK_integer *__negcnt, __CLPK_real *__ztz, __CLPK_real *__mingma,
        __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_real *__nrminv,
        __CLPK_real *__resid, __CLPK_real *__rqcorr,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int clar2v_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_complex *__y,
        __CLPK_complex *__z__, __CLPK_integer *__incx, __CLPK_real *__c__,
        __CLPK_complex *__s,
        __CLPK_integer *__incc) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarcm_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__c__, __CLPK_integer *__ldc,
        __CLPK_real *__rwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau,
        __CLPK_complex *__c__, __CLPK_integer *__ldc,
        __CLPK_complex *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarfb_(char *__side, char *__trans, char *__direct, char *__storev,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_complex *__v, __CLPK_integer *__ldv, __CLPK_complex *__t,
        __CLPK_integer *__ldt, __CLPK_complex *__c__, __CLPK_integer *__ldc,
        __CLPK_complex *__work,
        __CLPK_integer *__ldwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarfg_(__CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x,
        __CLPK_integer *__incx,
        __CLPK_complex *__tau) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarfp_(__CLPK_integer *__n, __CLPK_complex *__alpha, __CLPK_complex *__x,
        __CLPK_integer *__incx,
        __CLPK_complex *__tau) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarft_(char *__direct, char *__storev, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv,
        __CLPK_complex *__tau, __CLPK_complex *__t,
        __CLPK_integer *__ldt) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_complex *__v, __CLPK_complex *__tau, __CLPK_complex *__c__,
        __CLPK_integer *__ldc,
        __CLPK_complex *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clargv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx,
        __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__c__,
        __CLPK_integer *__incc) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed,
        __CLPK_integer *__n,
        __CLPK_complex *__x) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int clarrv_(__CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu,
        __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__pivmin,
        __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol,
        __CLPK_integer *__dou, __CLPK_real *__minrgp, __CLPK_real *__rtol1,
        __CLPK_real *__rtol2, __CLPK_real *__w, __CLPK_real *__werr,
        __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw,
        __CLPK_real *__gers, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_complex *__x,
        __CLPK_integer *__ldx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clartg_(__CLPK_complex *__f, __CLPK_complex *__g, __CLPK_real *__cs,
        __CLPK_complex *__sn,
        __CLPK_complex *__r__) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clartv_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx,
        __CLPK_complex *__y, __CLPK_integer *__incy, __CLPK_real *__c__,
        __CLPK_complex *__s,
        __CLPK_integer *__incc) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__l, __CLPK_complex *__v, __CLPK_integer *__incv,
        __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc,
        __CLPK_complex *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarzb_(char *__side, char *__trans, char *__direct, char *__storev,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_integer *__l, __CLPK_complex *__v, __CLPK_integer *__ldv,
        __CLPK_complex *__t, __CLPK_integer *__ldt, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__work,
        __CLPK_integer *__ldwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clarzt_(char *__direct, char *__storev, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_complex *__v, __CLPK_integer *__ldv,
        __CLPK_complex *__tau, __CLPK_complex *__t,
        __CLPK_integer *__ldt) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku,
        __CLPK_real *__cfrom, __CLPK_real *__cto, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_complex *__x,
        __CLPK_integer *__ldx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_complex *__alpha, __CLPK_complex *__beta, __CLPK_complex *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_real *__c__, __CLPK_real *__s,
        __CLPK_complex *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int classq_(__CLPK_integer *__n, __CLPK_complex *__x, __CLPK_integer *__incx,
        __CLPK_real *__scale,
        __CLPK_real *__sumsq) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int claswp_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv,
        __CLPK_integer *__incx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb,
        __CLPK_integer *__kb, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__ipiv, __CLPK_complex *__w, __CLPK_integer *__ldw,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clatbs_(char *__uplo, char *__trans, char *__diag, char *__normin,
        __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_complex *__ab,
        __CLPK_integer *__ldab, __CLPK_complex *__x, __CLPK_real *__scale,
        __CLPK_real *__cnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_complex *__z__,
        __CLPK_integer *__ldz, __CLPK_complex *__rhs, __CLPK_real *__rdsum,
        __CLPK_real *__rdscal, __CLPK_integer *__ipiv,
        __CLPK_integer *__jpiv) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clatps_(char *__uplo, char *__trans, char *__diag, char *__normin,
        __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__x,
        __CLPK_real *__scale, __CLPK_real *__cnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__e,
        __CLPK_complex *__tau, __CLPK_complex *__w,
        __CLPK_integer *__ldw) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clatrs_(char *__uplo, char *__trans, char *__diag, char *__normin,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__x, __CLPK_real *__scale, __CLPK_real *__cnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_complex *__v, __CLPK_integer *__incv, __CLPK_complex *__tau,
        __CLPK_complex *__c1, __CLPK_complex *__c2, __CLPK_integer *__ldc,
        __CLPK_complex *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int clauum_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__anorm,
        __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_complex *__ab, __CLPK_integer *__ldab, __CLPK_real *__s,
        __CLPK_real *__scond, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_complex *__afb, __CLPK_integer *__ldafb, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab,
        __CLPK_integer *__ldab, __CLPK_complex *__afb, __CLPK_integer *__ldafb,
        char *__equed, __CLPK_real *__s, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_integer *__nrhs, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__a,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpftri_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__a,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpoequ_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpoequb_(__CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af,
        __CLPK_integer *__ldaf, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr,
        __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cposvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__af, __CLPK_integer *__ldaf, char *__equed,
        __CLPK_real *__s, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp,
        char *__equed, __CLPK_real *__s, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__ap, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank,
        __CLPK_real *__tol, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank,
        __CLPK_real *__tol, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cptcon_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e,
        __CLPK_real *__anorm, __CLPK_real *__rcond, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cptrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__df,
        __CLPK_complex *__ef, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr,
        __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__d__,
        __CLPK_complex *__e, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_real *__df,
        __CLPK_complex *__ef, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpttrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_complex *__e,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cpttrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__d__, __CLPK_complex *__e, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cptts2_(__CLPK_integer *__iuplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_complex *__e,
        __CLPK_complex *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int crot_(__CLPK_integer *__n, __CLPK_complex *__cx, __CLPK_integer *__incx,
        __CLPK_complex *__cy, __CLPK_integer *__incy, __CLPK_real *__c__,
        __CLPK_complex *__s) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int cspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond,
        __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cspmv_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha,
        __CLPK_complex *__ap, __CLPK_complex *__x, __CLPK_integer *__incx,
        __CLPK_complex *__beta, __CLPK_complex *__y,
        __CLPK_integer *__incy) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cspr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha,
        __CLPK_complex *__x, __CLPK_integer *__incx,
        __CLPK_complex *__ap) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__ap, __CLPK_complex *__afp, __CLPK_integer *__ipiv,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x,
        __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__afp,
        __CLPK_integer *__ipiv, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__rcond,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csptri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_integer *__ipiv, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__ap, __CLPK_integer *__ipiv, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csrscl_(__CLPK_integer *__n, __CLPK_real *__sa, __CLPK_complex *__sx,
        __CLPK_integer *__incx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cstedc_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_complex *__work, __CLPK_integer *__lwork, __CLPK_real *__rwork,
        __CLPK_integer *__lrwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cstegr_(char *__jobz, char *__range, __CLPK_integer *__n,
        __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl,
        __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_real *__abstol, __CLPK_integer *__m, __CLPK_real *__w,
        __CLPK_complex *__z__, __CLPK_integer *__ldz, __CLPK_integer *__isuppz,
        __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cstein_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_integer *__m, __CLPK_real *__w, __CLPK_integer *__iblock,
        __CLPK_integer *__isplit, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cstemr_(char *__jobz, char *__range, __CLPK_integer *__n,
        __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vl,
        __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_integer *__m, __CLPK_real *__w, __CLPK_complex *__z__,
        __CLPK_integer *__ldz, __CLPK_integer *__nzc, __CLPK_integer *__isuppz,
        __CLPK_logical *__tryrac, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csteqr_(char *__compz, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csycon_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__anorm,
        __CLPK_real *__rcond, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond,
        __CLPK_real *__amax, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csymv_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__x,
        __CLPK_integer *__incx, __CLPK_complex *__beta, __CLPK_complex *__y,
        __CLPK_integer *__incy) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csyr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__alpha,
        __CLPK_complex *__x, __CLPK_integer *__incx, __CLPK_complex *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__af,
        __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csysvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x,
        __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr,
        __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csytri_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int csytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_complex *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__rcond, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab,
        __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr,
        __CLPK_real *__berr, __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_complex *__ab,
        __CLPK_integer *__ldab, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctfsm_(char *__transr, char *__side, char *__uplo, char *__trans,
        char *__diag, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_complex *__alpha, __CLPK_complex *__a, __CLPK_complex *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_complex *__a,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctfttp_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__arf, __CLPK_complex *__ap,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctfttr_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__arf, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctgevc_(char *__side, char *__howmny, __CLPK_logical *__select,
        __CLPK_integer *__n, __CLPK_complex *__s, __CLPK_integer *__lds,
        __CLPK_complex *__p, __CLPK_integer *__ldp, __CLPK_complex *__vl,
        __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr,
        __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q,
        __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__j1,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__q,
        __CLPK_integer *__ldq, __CLPK_complex *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__ifst, __CLPK_integer *__ilst,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq,
        __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__alpha, __CLPK_complex *__beta,
        __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__z__,
        __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_real *__pl,
        __CLPK_real *__pr, __CLPK_real *__dif, __CLPK_complex *__work,
        __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m,
        __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_integer *__l, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_real *__tola,
        __CLPK_real *__tolb, __CLPK_real *__alpha, __CLPK_real *__beta,
        __CLPK_complex *__u, __CLPK_integer *__ldu, __CLPK_complex *__v,
        __CLPK_integer *__ldv, __CLPK_complex *__q, __CLPK_integer *__ldq,
        __CLPK_complex *__work, __CLPK_integer *__ncycle,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctgsna_(char *__job, char *__howmny, __CLPK_logical *__select,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__vl,
        __CLPK_integer *__ldvl, __CLPK_complex *__vr, __CLPK_integer *__ldvr,
        __CLPK_real *__s, __CLPK_real *__dif, __CLPK_integer *__mm,
        __CLPK_integer *__m, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__d__, __CLPK_integer *__ldd,
        __CLPK_complex *__e, __CLPK_integer *__lde, __CLPK_complex *__f,
        __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__rdsum,
        __CLPK_real *__rdscal,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__d__, __CLPK_integer *__ldd,
        __CLPK_complex *__e, __CLPK_integer *__lde, __CLPK_complex *__f,
        __CLPK_integer *__ldf, __CLPK_real *__scale, __CLPK_real *__dif,
        __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_complex *__ap, __CLPK_real *__rcond, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b,
        __CLPK_integer *__ldb, __CLPK_complex *__x, __CLPK_integer *__ldx,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_complex *__work,
        __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctptri_(char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_complex *__ap,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__ap, __CLPK_complex *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctpttf_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__ap, __CLPK_complex *__arf,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_real *__rcond,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrevc_(char *__side, char *__howmny, __CLPK_logical *__select,
        __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt,
        __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr,
        __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrexc_(char *__compq, __CLPK_integer *__n, __CLPK_complex *__t,
        __CLPK_integer *__ldt, __CLPK_complex *__q, __CLPK_integer *__ldq,
        __CLPK_integer *__ifst, __CLPK_integer *__ilst,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb, __CLPK_complex *__x,
        __CLPK_integer *__ldx, __CLPK_real *__ferr, __CLPK_real *__berr,
        __CLPK_complex *__work, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrsen_(char *__job, char *__compq, __CLPK_logical *__select,
        __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt,
        __CLPK_complex *__q, __CLPK_integer *__ldq, __CLPK_complex *__w,
        __CLPK_integer *__m, __CLPK_real *__s, __CLPK_real *__sep,
        __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrsna_(char *__job, char *__howmny, __CLPK_logical *__select,
        __CLPK_integer *__n, __CLPK_complex *__t, __CLPK_integer *__ldt,
        __CLPK_complex *__vl, __CLPK_integer *__ldvl, __CLPK_complex *__vr,
        __CLPK_integer *__ldvr, __CLPK_real *__s, __CLPK_real *__sep,
        __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_complex *__work,
        __CLPK_integer *__ldwork, __CLPK_real *__rwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_real *__scale,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrti2_(char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrtri_(char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrttf_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__arf,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__ap,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ctzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cung2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cung2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cungbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__tau, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cungl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cungql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cungqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cungr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cungrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cungtr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunm2l_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunm2r_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunmbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunmhr_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunml2_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunmlq_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunmql_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunmqr_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunmr2_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunmr3_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunmrq_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_complex *__a,
        __CLPK_integer *__lda, __CLPK_complex *__tau, __CLPK_complex *__c__,
        __CLPK_integer *__ldc, __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunmrz_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l,
        __CLPK_complex *__a, __CLPK_integer *__lda, __CLPK_complex *__tau,
        __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cunmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_complex *__a, __CLPK_integer *__lda,
        __CLPK_complex *__tau, __CLPK_complex *__c__, __CLPK_integer *__ldc,
        __CLPK_complex *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cupgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_complex *__ap,
        __CLPK_complex *__tau, __CLPK_complex *__q, __CLPK_integer *__ldq,
        __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int cupmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_complex *__ap, __CLPK_complex *__tau,
        __CLPK_complex *__c__, __CLPK_integer *__ldc, __CLPK_complex *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dbdsdc_(char *__uplo, char *__compq, __CLPK_integer *__n,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt,
        __CLPK_integer *__ldvt, __CLPK_doublereal *__q, __CLPK_integer *__iq,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt,
        __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt,
        __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__c__,
        __CLPK_integer *__ldc, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ddisna_(char *__job, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__sep,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku,
        __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__pt,
        __CLPK_integer *__ldpt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm,
        __CLPK_doublereal *__rcond, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__r__, __CLPK_doublereal *__c__,
        __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd,
        __CLPK_doublereal *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__r__, __CLPK_doublereal *__c__,
        __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd,
        __CLPK_doublereal *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab, __CLPK_doublereal *__afb,
        __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n,
        __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__afb, __CLPK_integer *__ldafb,
        __CLPK_integer *__ipiv, char *__equed, __CLPK_doublereal *__r__,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr,
        __CLPK_doublereal *__berr, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgebak_(char *__job, char *__side, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__scale, __CLPK_integer *__m, __CLPK_doublereal *__v,
        __CLPK_integer *__ldv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgebal_(char *__job, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__scale,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__tauq, __CLPK_doublereal *__taup,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgecon_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__anorm,
        __CLPK_doublereal *__rcond, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__r__,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd,
        __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__r__,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd,
        __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_integer *__sdim, __CLPK_doublereal *__wr,
        __CLPK_doublereal *__wi, __CLPK_doublereal *__vs,
        __CLPK_integer *__ldvs, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork, __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_integer *__sdim, __CLPK_doublereal *__wr,
        __CLPK_doublereal *__wi, __CLPK_doublereal *__vs,
        __CLPK_integer *__ldvs, __CLPK_doublereal *__rconde,
        __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork, __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__wr,
        __CLPK_doublereal *__wi, __CLPK_doublereal *__vl,
        __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__wr, __CLPK_doublereal *__wi,
        __CLPK_doublereal *__vl, __CLPK_integer *__ldvl,
        __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__ilo,
        __CLPK_integer *__ihi, __CLPK_doublereal *__scale,
        __CLPK_doublereal *__abnrm, __CLPK_doublereal *__rconde,
        __CLPK_doublereal *__rcondv, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__alphar,
        __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta,
        __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl,
        __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__alphar,
        __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta,
        __CLPK_doublereal *__vl, __CLPK_integer *__ldvl,
        __CLPK_doublereal *__vr, __CLPK_integer *__ldvr,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgejsv_(char *__joba, char *__jobu, char *__jobv, char *__jobr,
        char *__jobt, char *__jobp, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__sva,
        __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v,
        __CLPK_integer *__ldv, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__s,
        __CLPK_doublereal *__rcond, __CLPK_integer *__rank,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__s,
        __CLPK_doublereal *__rcond, __CLPK_integer *__rank,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_integer *__jpvt,
        __CLPK_doublereal *__rcond, __CLPK_integer *__rank,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_integer *__jpvt,
        __CLPK_doublereal *__rcond, __CLPK_integer *__rank,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af,
        __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgesc2_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__rhs, __CLPK_integer *__ipiv,
        __CLPK_integer *__jpiv,
        __CLPK_doublereal *__scale) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s,
        __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt,
        __CLPK_integer *__ldvt, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu,
        __CLPK_doublereal *__vt, __CLPK_integer *__ldvt,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgesvj_(char *__joba, char *__jobu, char *__jobv, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v,
        __CLPK_integer *__ldv, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgesvx_(char *__fact, char *__trans, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv,
        char *__equed, __CLPK_doublereal *__r__, __CLPK_doublereal *__c__,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__rcond,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgetc2_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_integer *__ipiv, __CLPK_integer *__jpiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgetri_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_integer *__ipiv, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dggbak_(char *__job, char *__side, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale,
        __CLPK_integer *__m, __CLPK_doublereal *__v, __CLPK_integer *__ldv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dggbal_(char *__job, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim,
        __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai,
        __CLPK_doublereal *__beta, __CLPK_doublereal *__vsl,
        __CLPK_integer *__ldvsl, __CLPK_doublereal *__vsr,
        __CLPK_integer *__ldvsr, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork, __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg,
        char *__sense, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__sdim, __CLPK_doublereal *__alphar,
        __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta,
        __CLPK_doublereal *__vsl, __CLPK_integer *__ldvsl,
        __CLPK_doublereal *__vsr, __CLPK_integer *__ldvsr,
        __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__alphar,
        __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta,
        __CLPK_doublereal *__vl, __CLPK_integer *__ldvl,
        __CLPK_doublereal *__vr, __CLPK_integer *__ldvr,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai,
        __CLPK_doublereal *__beta, __CLPK_doublereal *__vl,
        __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__lscale, __CLPK_doublereal *__rscale,
        __CLPK_doublereal *__abnrm, __CLPK_doublereal *__bbnrm,
        __CLPK_doublereal *__rconde, __CLPK_doublereal *__rcondv,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__d__, __CLPK_doublereal *__x,
        __CLPK_doublereal *__y, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgghrd_(char *__compq, char *__compz, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__,
        __CLPK_integer *__ldz,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__c__,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__x,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p,
        __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__taua, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__taub,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__taua, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__taub,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k,
        __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta,
        __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v,
        __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m,
        __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb,
        __CLPK_integer *__k, __CLPK_integer *__l, __CLPK_doublereal *__u,
        __CLPK_integer *__ldu, __CLPK_doublereal *__v, __CLPK_integer *__ldv,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__iwork,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgsvj0_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__sva, __CLPK_integer *__mv, __CLPK_doublereal *__v,
        __CLPK_integer *__ldv, __CLPK_doublereal *__eps,
        __CLPK_doublereal *__sfmin, __CLPK_doublereal *__tol,
        __CLPK_integer *__nsweep, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgsvj1_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__n1, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__sva,
        __CLPK_integer *__mv, __CLPK_doublereal *__v, __CLPK_integer *__ldv,
        __CLPK_doublereal *__eps, __CLPK_doublereal *__sfmin,
        __CLPK_doublereal *__tol, __CLPK_integer *__nsweep,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_doublereal *__dl,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__du,
        __CLPK_doublereal *__du2, __CLPK_integer *__ipiv,
        __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__dl, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__du, __CLPK_doublereal *__dlf,
        __CLPK_doublereal *__df, __CLPK_doublereal *__duf,
        __CLPK_doublereal *__du2, __CLPK_integer *__ipiv,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__ferr,
        __CLPK_doublereal *__berr, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__dl,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__du,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__dl,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__du,
        __CLPK_doublereal *__dlf, __CLPK_doublereal *__df,
        __CLPK_doublereal *__duf, __CLPK_doublereal *__du2,
        __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr,
        __CLPK_doublereal *__berr, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgttrf_(__CLPK_integer *__n, __CLPK_doublereal *__dl,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__du,
        __CLPK_doublereal *__du2, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__dl, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__du, __CLPK_doublereal *__du2,
        __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__dl,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__du,
        __CLPK_doublereal *__du2, __CLPK_integer *__ipiv,
        __CLPK_doublereal *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dhgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__,
        __CLPK_integer *__ldh, __CLPK_doublereal *__t, __CLPK_integer *__ldt,
        __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai,
        __CLPK_doublereal *__beta, __CLPK_doublereal *__q,
        __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dhsein_(char *__side, char *__eigsrc, char *__initv,
        __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_doublereal *__h__,
        __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi,
        __CLPK_doublereal *__vl, __CLPK_integer *__ldvl,
        __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm,
        __CLPK_integer *__m, __CLPK_doublereal *__work,
        __CLPK_integer *__ifaill, __CLPK_integer *__ifailr,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dhseqr_(char *__job, char *__compz, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_doublereal *__h__,
        __CLPK_integer *__ldh, __CLPK_doublereal *__wr, __CLPK_doublereal *__wi,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);


        __CLPK_logical disnan_(__CLPK_doublereal *__din) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlabad_(__CLPK_doublereal *__small,
        __CLPK_doublereal *__large) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__tauq,
        __CLPK_doublereal *__taup, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__y,
        __CLPK_integer *__ldy) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlacn2_(__CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__x,
        __CLPK_integer *__isgn, __CLPK_doublereal *__est,
        __CLPK_integer *__kase,
        __CLPK_integer *__isave) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlacon_(__CLPK_integer *__n, __CLPK_doublereal *__v, __CLPK_doublereal *__x,
        __CLPK_integer *__isgn, __CLPK_doublereal *__est,
        __CLPK_integer *__kase) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dladiv_(__CLPK_doublereal *__a, __CLPK_doublereal *__b,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__p,
        __CLPK_doublereal *__q) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlae2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__rt1,
        __CLPK_doublereal *__rt2) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaebz_(__CLPK_integer *__ijob, __CLPK_integer *__nitmax,
        __CLPK_integer *__n, __CLPK_integer *__mmax, __CLPK_integer *__minp,
        __CLPK_integer *__nbmin, __CLPK_doublereal *__abstol,
        __CLPK_doublereal *__reltol, __CLPK_doublereal *__pivmin,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__e2, __CLPK_integer *__nval,
        __CLPK_doublereal *__ab, __CLPK_doublereal *__c__,
        __CLPK_integer *__mout, __CLPK_integer *__nab,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaed0_(__CLPK_integer *__icompq, __CLPK_integer *__qsiz,
        __CLPK_integer *__n, __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq,
        __CLPK_doublereal *__qstore, __CLPK_integer *__ldqs,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaed1_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq,
        __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaed2_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq,
        __CLPK_integer *__indxq, __CLPK_doublereal *__rho,
        __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda,
        __CLPK_doublereal *__w, __CLPK_doublereal *__q2, __CLPK_integer *__indx,
        __CLPK_integer *__indxc, __CLPK_integer *__indxp,
        __CLPK_integer *__coltyp,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaed3_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq,
        __CLPK_doublereal *__rho, __CLPK_doublereal *__dlamda,
        __CLPK_doublereal *__q2, __CLPK_integer *__indx, __CLPK_integer *__ctot,
        __CLPK_doublereal *__w, __CLPK_doublereal *__s,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaed4_(__CLPK_integer *__n, __CLPK_integer *__i__,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__z__,
        __CLPK_doublereal *__delta, __CLPK_doublereal *__rho,
        __CLPK_doublereal *__dlam,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaed5_(__CLPK_integer *__i__, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__z__, __CLPK_doublereal *__delta,
        __CLPK_doublereal *__rho,
        __CLPK_doublereal *__dlam) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaed6_(__CLPK_integer *__kniter, __CLPK_logical *__orgati,
        __CLPK_doublereal *__rho, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__z__, __CLPK_doublereal *__finit,
        __CLPK_doublereal *__tau,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaed7_(__CLPK_integer *__icompq, __CLPK_integer *__n,
        __CLPK_integer *__qsiz, __CLPK_integer *__tlvls,
        __CLPK_integer *__curlvl, __CLPK_integer *__curpbm,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__q, __CLPK_integer *__ldq,
        __CLPK_integer *__indxq, __CLPK_doublereal *__rho,
        __CLPK_integer *__cutpnt, __CLPK_doublereal *__qstore,
        __CLPK_integer *__qptr, __CLPK_integer *__prmptr,
        __CLPK_integer *__perm, __CLPK_integer *__givptr,
        __CLPK_integer *__givcol, __CLPK_doublereal *__givnum,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaed8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_integer *__n,
        __CLPK_integer *__qsiz, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq,
        __CLPK_doublereal *__rho, __CLPK_integer *__cutpnt,
        __CLPK_doublereal *__z__, __CLPK_doublereal *__dlamda,
        __CLPK_doublereal *__q2, __CLPK_integer *__ldq2, __CLPK_doublereal *__w,
        __CLPK_integer *__perm, __CLPK_integer *__givptr,
        __CLPK_integer *__givcol, __CLPK_doublereal *__givnum,
        __CLPK_integer *__indxp, __CLPK_integer *__indx,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaed9_(__CLPK_integer *__k, __CLPK_integer *__kstart,
        __CLPK_integer *__kstop, __CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__rho,
        __CLPK_doublereal *__dlamda, __CLPK_doublereal *__w,
        __CLPK_doublereal *__s, __CLPK_integer *__lds,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaeda_(__CLPK_integer *__n, __CLPK_integer *__tlvls,
        __CLPK_integer *__curlvl, __CLPK_integer *__curpbm,
        __CLPK_integer *__prmptr, __CLPK_integer *__perm,
        __CLPK_integer *__givptr, __CLPK_integer *__givcol,
        __CLPK_doublereal *__givnum, __CLPK_doublereal *__q,
        __CLPK_integer *__qptr, __CLPK_doublereal *__z__,
        __CLPK_doublereal *__ztemp,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit,
        __CLPK_integer *__n, __CLPK_doublereal *__h__, __CLPK_integer *__ldh,
        __CLPK_doublereal *__wr, __CLPK_doublereal *__wi,
        __CLPK_doublereal *__vr, __CLPK_doublereal *__vi,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__work, __CLPK_doublereal *__eps3,
        __CLPK_doublereal *__smlnum, __CLPK_doublereal *__bignum,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaev2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__rt1,
        __CLPK_doublereal *__rt2, __CLPK_doublereal *__cs1,
        __CLPK_doublereal *__sn1) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaexc_(__CLPK_logical *__wantq, __CLPK_integer *__n,
        __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__q,
        __CLPK_integer *__ldq, __CLPK_integer *__j1, __CLPK_integer *__n1,
        __CLPK_integer *__n2, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlag2_(__CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__safmin, __CLPK_doublereal *__scale1,
        __CLPK_doublereal *__scale2, __CLPK_doublereal *__wr1,
        __CLPK_doublereal *__wr2,
        __CLPK_doublereal *__wi) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlag2s_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_real *__sa, __CLPK_integer *__ldsa,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlags2_(__CLPK_logical *__upper, __CLPK_doublereal *__a1,
        __CLPK_doublereal *__a2, __CLPK_doublereal *__a3,
        __CLPK_doublereal *__b1, __CLPK_doublereal *__b2,
        __CLPK_doublereal *__b3, __CLPK_doublereal *__csu,
        __CLPK_doublereal *__snu, __CLPK_doublereal *__csv,
        __CLPK_doublereal *__snv, __CLPK_doublereal *__csq,
        __CLPK_doublereal *__snq) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlagtf_(__CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_doublereal *__lambda, __CLPK_doublereal *__b,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__tol,
        __CLPK_doublereal *__d__, __CLPK_integer *__in,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__alpha, __CLPK_doublereal *__dl,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__du,
        __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__beta, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlagts_(__CLPK_integer *__job, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_doublereal *__b, __CLPK_doublereal *__c__,
        __CLPK_doublereal *__d__, __CLPK_integer *__in, __CLPK_doublereal *__y,
        __CLPK_doublereal *__tol,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlagv2_(__CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__alphar, __CLPK_doublereal *__alphai,
        __CLPK_doublereal *__beta, __CLPK_doublereal *__csl,
        __CLPK_doublereal *__snl, __CLPK_doublereal *__csr,
        __CLPK_doublereal *__snr) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__h__, __CLPK_integer *__ldh,
        __CLPK_doublereal *__wr, __CLPK_doublereal *__wi,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__y,
        __CLPK_integer *__ldy) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__y,
        __CLPK_integer *__ldy) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_doublereal *__x,
        __CLPK_doublereal *__sest, __CLPK_doublereal *__w,
        __CLPK_doublereal *__gamma, __CLPK_doublereal *__sestpr,
        __CLPK_doublereal *__s,
        __CLPK_doublereal *__c__) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_logical dlaisnan_(__CLPK_doublereal *__din1,
        __CLPK_doublereal *__din2) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaln2_(__CLPK_logical *__ltrans, __CLPK_integer *__na,
        __CLPK_integer *__nw, __CLPK_doublereal *__smin,
        __CLPK_doublereal *__ca, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__d1, __CLPK_doublereal *__d2,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__wr,
        __CLPK_doublereal *__wi, __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__scale, __CLPK_doublereal *__xnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl,
        __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__bx,
        __CLPK_integer *__ldbx, __CLPK_integer *__perm,
        __CLPK_integer *__givptr, __CLPK_integer *__givcol,
        __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum,
        __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles,
        __CLPK_doublereal *__difl, __CLPK_doublereal *__difr,
        __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__,
        __CLPK_doublereal *__s, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz,
        __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__bx, __CLPK_integer *__ldbx,
        __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt,
        __CLPK_integer *__k, __CLPK_doublereal *__difl,
        __CLPK_doublereal *__difr, __CLPK_doublereal *__z__,
        __CLPK_doublereal *__poles, __CLPK_integer *__givptr,
        __CLPK_integer *__givcol, __CLPK_integer *__ldgcol,
        __CLPK_integer *__perm, __CLPK_doublereal *__givnum,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__s,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__rcond, __CLPK_integer *__rank,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlamrg_(__CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_doublereal *__a,
        __CLPK_integer *__dtrd1, __CLPK_integer *__dtrd2,
        __CLPK_integer *__index) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer dlaneg_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__lld, __CLPK_doublereal *__sigma,
        __CLPK_doublereal *__pivmin,
        __CLPK_integer *__r__) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlangb_(char *__norm, __CLPK_integer *__n,
        __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlange_(char *__norm, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlangt_(char *__norm, __CLPK_integer *__n,
        __CLPK_doublereal *__dl, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__du) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlanhs_(char *__norm, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlansb_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlansf_(char *__norm, char *__transr, char *__uplo,
        __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlansp_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__ap,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlanst_(char *__norm, __CLPK_integer *__n,
        __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlansy_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlantb_(char *__norm, char *__uplo, char *__diag,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlantp_(char *__norm, char *__uplo, char *__diag,
        __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlantr_(char *__norm, char *__uplo, char *__diag,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlanv2_(__CLPK_doublereal *__a, __CLPK_doublereal *__b,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__rt1r, __CLPK_doublereal *__rt1i,
        __CLPK_doublereal *__rt2r, __CLPK_doublereal *__rt2i,
        __CLPK_doublereal *__cs,
        __CLPK_doublereal *__sn) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlapll_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx,
        __CLPK_doublereal *__y, __CLPK_integer *__incy,
        __CLPK_doublereal *__ssmin) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_integer *__k) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal dlapy2_(__CLPK_doublereal *__x,
        __CLPK_doublereal *__y) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dlapy3_(__CLPK_doublereal *__x, __CLPK_doublereal *__y,
        __CLPK_doublereal *__z__) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__r__, __CLPK_doublereal *__c__,
        __CLPK_doublereal *__rowcnd, __CLPK_doublereal *__colcnd,
        __CLPK_doublereal *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int dlaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__r__,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__rowcnd,
        __CLPK_doublereal *__colcnd, __CLPK_doublereal *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int dlaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__vn1,
        __CLPK_doublereal *__vn2,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset,
        __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__vn1, __CLPK_doublereal *__vn2,
        __CLPK_doublereal *__auxv, __CLPK_doublereal *__f,
        __CLPK_integer *__ldf) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__h__, __CLPK_integer *__ldh,
        __CLPK_doublereal *__wr, __CLPK_doublereal *__wi,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaqr1_(__CLPK_integer *__n, __CLPK_doublereal *__h__,
        __CLPK_integer *__ldh, __CLPK_doublereal *__sr1,
        __CLPK_doublereal *__si1, __CLPK_doublereal *__sr2,
        __CLPK_doublereal *__si2,
        __CLPK_doublereal *__v) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot,
        __CLPK_integer *__nw, __CLPK_doublereal *__h__, __CLPK_integer *__ldh,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns,
        __CLPK_integer *__nd, __CLPK_doublereal *__sr, __CLPK_doublereal *__si,
        __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh,
        __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv,
        __CLPK_doublereal *__wv, __CLPK_integer *__ldwv,
        __CLPK_doublereal *__work,
        __CLPK_integer *__lwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot,
        __CLPK_integer *__nw, __CLPK_doublereal *__h__, __CLPK_integer *__ldh,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__ns,
        __CLPK_integer *__nd, __CLPK_doublereal *__sr, __CLPK_doublereal *__si,
        __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_integer *__nh,
        __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_integer *__nv,
        __CLPK_doublereal *__wv, __CLPK_integer *__ldwv,
        __CLPK_doublereal *__work,
        __CLPK_integer *__lwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__h__, __CLPK_integer *__ldh,
        __CLPK_doublereal *__wr, __CLPK_doublereal *__wi,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop,
        __CLPK_integer *__kbot, __CLPK_integer *__nshfts,
        __CLPK_doublereal *__sr, __CLPK_doublereal *__si,
        __CLPK_doublereal *__h__, __CLPK_integer *__ldh, __CLPK_integer *__iloz,
        __CLPK_integer *__ihiz, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__u,
        __CLPK_integer *__ldu, __CLPK_integer *__nv, __CLPK_doublereal *__wv,
        __CLPK_integer *__ldwv, __CLPK_integer *__nh, __CLPK_doublereal *__wh,
        __CLPK_integer *__ldwh) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s,
        __CLPK_doublereal *__scond, __CLPK_doublereal *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int dlaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_doublereal *__s, __CLPK_doublereal *__scond,
        __CLPK_doublereal *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int dlaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__s,
        __CLPK_doublereal *__scond, __CLPK_doublereal *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int dlaqtr_(__CLPK_logical *__ltran, __CLPK_logical *__l__CLPK_real,
        __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt,
        __CLPK_doublereal *__b, __CLPK_doublereal *__w,
        __CLPK_doublereal *__scale, __CLPK_doublereal *__x,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn,
        __CLPK_doublereal *__lambda, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__l, __CLPK_doublereal *__ld,
        __CLPK_doublereal *__lld, __CLPK_doublereal *__pivmin,
        __CLPK_doublereal *__gaptol, __CLPK_doublereal *__z__,
        __CLPK_logical *__wantnc, __CLPK_integer *__negcnt,
        __CLPK_doublereal *__ztz, __CLPK_doublereal *__mingma,
        __CLPK_integer *__r__, __CLPK_integer *__isuppz,
        __CLPK_doublereal *__nrminv, __CLPK_doublereal *__resid,
        __CLPK_doublereal *__rqcorr,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlar2v_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_doublereal *__y,
        __CLPK_doublereal *__z__, __CLPK_integer *__incx,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__s,
        __CLPK_integer *__incc) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__v, __CLPK_integer *__incv,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__c__,
        __CLPK_integer *__ldc,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarfb_(char *__side, char *__trans, char *__direct, char *__storev,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_doublereal *__v, __CLPK_integer *__ldv, __CLPK_doublereal *__t,
        __CLPK_integer *__ldt, __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work,
        __CLPK_integer *__ldwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarfg_(__CLPK_integer *__n, __CLPK_doublereal *__alpha,
        __CLPK_doublereal *__x, __CLPK_integer *__incx,
        __CLPK_doublereal *__tau) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarfp_(__CLPK_integer *__n, __CLPK_doublereal *__alpha,
        __CLPK_doublereal *__x, __CLPK_integer *__incx,
        __CLPK_doublereal *__tau) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarft_(char *__direct, char *__storev, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__t,
        __CLPK_integer *__ldt) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__v, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlargv_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx,
        __CLPK_doublereal *__y, __CLPK_integer *__incy,
        __CLPK_doublereal *__c__,
        __CLPK_integer *__incc) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed,
        __CLPK_integer *__n,
        __CLPK_doublereal *__x) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarra_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__e2,
        __CLPK_doublereal *__spltol, __CLPK_doublereal *__tnrm,
        __CLPK_integer *__nsplit, __CLPK_integer *__isplit,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarrb_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__lld, __CLPK_integer *__ifirst,
        __CLPK_integer *__ilast, __CLPK_doublereal *__rtol1,
        __CLPK_doublereal *__rtol2, __CLPK_integer *__offset,
        __CLPK_doublereal *__w, __CLPK_doublereal *__wgap,
        __CLPK_doublereal *__werr, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork, __CLPK_doublereal *__pivmin,
        __CLPK_doublereal *__spdiam, __CLPK_integer *__twist,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarrc_(char *__jobt, __CLPK_integer *__n, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__vu, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__pivmin,
        __CLPK_integer *__eigcnt, __CLPK_integer *__lcnt,
        __CLPK_integer *__rcnt,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarrd_(char *__range, char *__order, __CLPK_integer *__n,
        __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il,
        __CLPK_integer *__iu, __CLPK_doublereal *__gers,
        __CLPK_doublereal *__reltol, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__e2,
        __CLPK_doublereal *__pivmin, __CLPK_integer *__nsplit,
        __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_doublereal *__w,
        __CLPK_doublereal *__werr, __CLPK_doublereal *__wl,
        __CLPK_doublereal *__wu, __CLPK_integer *__iblock,
        __CLPK_integer *__indexw, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarre_(char *__range, __CLPK_integer *__n, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__e2, __CLPK_doublereal *__rtol1,
        __CLPK_doublereal *__rtol2, __CLPK_doublereal *__spltol,
        __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m,
        __CLPK_doublereal *__w, __CLPK_doublereal *__werr,
        __CLPK_doublereal *__wgap, __CLPK_integer *__iblock,
        __CLPK_integer *__indexw, __CLPK_doublereal *__gers,
        __CLPK_doublereal *__pivmin, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__l, __CLPK_doublereal *__ld,
        __CLPK_integer *__clstrt, __CLPK_integer *__clend,
        __CLPK_doublereal *__w, __CLPK_doublereal *__wgap,
        __CLPK_doublereal *__werr, __CLPK_doublereal *__spdiam,
        __CLPK_doublereal *__clgapl, __CLPK_doublereal *__clgapr,
        __CLPK_doublereal *__pivmin, __CLPK_doublereal *__sigma,
        __CLPK_doublereal *__dplus, __CLPK_doublereal *__lplus,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarrj_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e2, __CLPK_integer *__ifirst,
        __CLPK_integer *__ilast, __CLPK_doublereal *__rtol,
        __CLPK_integer *__offset, __CLPK_doublereal *__w,
        __CLPK_doublereal *__werr, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork, __CLPK_doublereal *__pivmin,
        __CLPK_doublereal *__spdiam,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarrk_(__CLPK_integer *__n, __CLPK_integer *__iw, __CLPK_doublereal *__gl,
        __CLPK_doublereal *__gu, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e2, __CLPK_doublereal *__pivmin,
        __CLPK_doublereal *__reltol, __CLPK_doublereal *__w,
        __CLPK_doublereal *__werr,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarrr_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarrv_(__CLPK_integer *__n, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__vu, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__l, __CLPK_doublereal *__pivmin,
        __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol,
        __CLPK_integer *__dou, __CLPK_doublereal *__minrgp,
        __CLPK_doublereal *__rtol1, __CLPK_doublereal *__rtol2,
        __CLPK_doublereal *__w, __CLPK_doublereal *__werr,
        __CLPK_doublereal *__wgap, __CLPK_integer *__iblock,
        __CLPK_integer *__indexw, __CLPK_doublereal *__gers,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__isuppz, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarscl2_(__CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlartg_(__CLPK_doublereal *__f, __CLPK_doublereal *__g,
        __CLPK_doublereal *__cs, __CLPK_doublereal *__sn,
        __CLPK_doublereal *__r__) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlartv_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx,
        __CLPK_doublereal *__y, __CLPK_integer *__incy,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__s,
        __CLPK_integer *__incc) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaruv_(__CLPK_integer *__iseed, __CLPK_integer *__n,
        __CLPK_doublereal *__x) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__l, __CLPK_doublereal *__v, __CLPK_integer *__incv,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__c__,
        __CLPK_integer *__ldc,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarzb_(char *__side, char *__trans, char *__direct, char *__storev,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_integer *__l, __CLPK_doublereal *__v, __CLPK_integer *__ldv,
        __CLPK_doublereal *__t, __CLPK_integer *__ldt, __CLPK_doublereal *__c__,
        __CLPK_integer *__ldc, __CLPK_doublereal *__work,
        __CLPK_integer *__ldwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlarzt_(char *__direct, char *__storev, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_doublereal *__v, __CLPK_integer *__ldv,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__t,
        __CLPK_integer *__ldt) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlas2_(__CLPK_doublereal *__f, __CLPK_doublereal *__g,
        __CLPK_doublereal *__h__, __CLPK_doublereal *__ssmin,
        __CLPK_doublereal *__ssmax) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku,
        __CLPK_doublereal *__cfrom, __CLPK_doublereal *__cto,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__x,
        __CLPK_integer *__ldx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasd0_(__CLPK_integer *__n, __CLPK_integer *__sqre,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt,
        __CLPK_integer *__ldvt, __CLPK_integer *__smlsiz,
        __CLPK_integer *__iwork, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasd1_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__alpha,
        __CLPK_doublereal *__beta, __CLPK_doublereal *__u,
        __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt,
        __CLPK_integer *__idxq, __CLPK_integer *__iwork,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasd2_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre,
        __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__z__,
        __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta,
        __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt,
        __CLPK_integer *__ldvt, __CLPK_doublereal *__dsigma,
        __CLPK_doublereal *__u2, __CLPK_integer *__ldu2,
        __CLPK_doublereal *__vt2, __CLPK_integer *__ldvt2,
        __CLPK_integer *__idxp, __CLPK_integer *__idx, __CLPK_integer *__idxc,
        __CLPK_integer *__idxq, __CLPK_integer *__coltyp,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasd3_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre,
        __CLPK_integer *__k, __CLPK_doublereal *__d__, __CLPK_doublereal *__q,
        __CLPK_integer *__ldq, __CLPK_doublereal *__dsigma,
        __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__u2,
        __CLPK_integer *__ldu2, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt,
        __CLPK_doublereal *__vt2, __CLPK_integer *__ldvt2,
        __CLPK_integer *__idxc, __CLPK_integer *__ctot,
        __CLPK_doublereal *__z__,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasd4_(__CLPK_integer *__n, __CLPK_integer *__i__,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__z__,
        __CLPK_doublereal *__delta, __CLPK_doublereal *__rho,
        __CLPK_doublereal *__sigma, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasd5_(__CLPK_integer *__i__, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__z__, __CLPK_doublereal *__delta,
        __CLPK_doublereal *__rho, __CLPK_doublereal *__dsigma,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasd6_(__CLPK_integer *__icompq, __CLPK_integer *__nl,
        __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__vf, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta,
        __CLPK_integer *__idxq, __CLPK_integer *__perm,
        __CLPK_integer *__givptr, __CLPK_integer *__givcol,
        __CLPK_integer *__ldgcol, __CLPK_doublereal *__givnum,
        __CLPK_integer *__ldgnum, __CLPK_doublereal *__poles,
        __CLPK_doublereal *__difl, __CLPK_doublereal *__difr,
        __CLPK_doublereal *__z__, __CLPK_integer *__k, __CLPK_doublereal *__c__,
        __CLPK_doublereal *__s, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasd7_(__CLPK_integer *__icompq, __CLPK_integer *__nl,
        __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__z__,
        __CLPK_doublereal *__zw, __CLPK_doublereal *__vf,
        __CLPK_doublereal *__vfw, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__vlw, __CLPK_doublereal *__alpha,
        __CLPK_doublereal *__beta, __CLPK_doublereal *__dsigma,
        __CLPK_integer *__idx, __CLPK_integer *__idxp, __CLPK_integer *__idxq,
        __CLPK_integer *__perm, __CLPK_integer *__givptr,
        __CLPK_integer *__givcol, __CLPK_integer *__ldgcol,
        __CLPK_doublereal *__givnum, __CLPK_integer *__ldgnum,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__s,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasd8_(__CLPK_integer *__icompq, __CLPK_integer *__k,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__z__,
        __CLPK_doublereal *__vf, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__difl, __CLPK_doublereal *__difr,
        __CLPK_integer *__lddifr, __CLPK_doublereal *__dsigma,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasda_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz,
        __CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__u, __CLPK_integer *__ldu,
        __CLPK_doublereal *__vt, __CLPK_integer *__k, __CLPK_doublereal *__difl,
        __CLPK_doublereal *__difr, __CLPK_doublereal *__z__,
        __CLPK_doublereal *__poles, __CLPK_integer *__givptr,
        __CLPK_integer *__givcol, __CLPK_integer *__ldgcol,
        __CLPK_integer *__perm, __CLPK_doublereal *__givnum,
        __CLPK_doublereal *__c__, __CLPK_doublereal *__s,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasdq_(char *__uplo, __CLPK_integer *__sqre, __CLPK_integer *__n,
        __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__u,
        __CLPK_integer *__ldu, __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasdt_(__CLPK_integer *__n, __CLPK_integer *__lvl, __CLPK_integer *__nd,
        __CLPK_integer *__inode, __CLPK_integer *__ndiml,
        __CLPK_integer *__ndimr,
        __CLPK_integer *__msub) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta,
        __CLPK_doublereal *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasq1_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasq2_(__CLPK_integer *__n, __CLPK_doublereal *__z__,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasq3_(__CLPK_integer *__i0, __CLPK_integer *__n0,
        __CLPK_doublereal *__z__, __CLPK_integer *__pp,
        __CLPK_doublereal *__dmin__, __CLPK_doublereal *__sigma,
        __CLPK_doublereal *__desig, __CLPK_doublereal *__qmax,
        __CLPK_integer *__nfail, __CLPK_integer *__iter, __CLPK_integer *__ndiv,
        __CLPK_logical *__ieee, __CLPK_integer *__ttype,
        __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2,
        __CLPK_doublereal *__dn, __CLPK_doublereal *__dn1,
        __CLPK_doublereal *__dn2, __CLPK_doublereal *__g,
        __CLPK_doublereal *__tau) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasq4_(__CLPK_integer *__i0, __CLPK_integer *__n0,
        __CLPK_doublereal *__z__, __CLPK_integer *__pp, __CLPK_integer *__n0in,
        __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1,
        __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn,
        __CLPK_doublereal *__dn1, __CLPK_doublereal *__dn2,
        __CLPK_doublereal *__tau, __CLPK_integer *__ttype,
        __CLPK_doublereal *__g) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasq5_(__CLPK_integer *__i0, __CLPK_integer *__n0,
        __CLPK_doublereal *__z__, __CLPK_integer *__pp,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__dmin__,
        __CLPK_doublereal *__dmin1, __CLPK_doublereal *__dmin2,
        __CLPK_doublereal *__dn, __CLPK_doublereal *__dnm1,
        __CLPK_doublereal *__dnm2,
        __CLPK_logical *__ieee) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasq6_(__CLPK_integer *__i0, __CLPK_integer *__n0,
        __CLPK_doublereal *__z__, __CLPK_integer *__pp,
        __CLPK_doublereal *__dmin__, __CLPK_doublereal *__dmin1,
        __CLPK_doublereal *__dmin2, __CLPK_doublereal *__dn,
        __CLPK_doublereal *__dnm1,
        __CLPK_doublereal *__dnm2) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_doublereal *__c__, __CLPK_doublereal *__s,
        __CLPK_doublereal *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasrt_(char *__id, __CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlassq_(__CLPK_integer *__n, __CLPK_doublereal *__x, __CLPK_integer *__incx,
        __CLPK_doublereal *__scale,
        __CLPK_doublereal *__sumsq) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasv2_(__CLPK_doublereal *__f, __CLPK_doublereal *__g,
        __CLPK_doublereal *__h__, __CLPK_doublereal *__ssmin,
        __CLPK_doublereal *__ssmax, __CLPK_doublereal *__snr,
        __CLPK_doublereal *__csr, __CLPK_doublereal *__snl,
        __CLPK_doublereal *__csl) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlaswp_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv,
        __CLPK_integer *__incx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasy2_(__CLPK_logical *__ltranl, __CLPK_logical *__ltranr,
        __CLPK_integer *__isgn, __CLPK_integer *__n1, __CLPK_integer *__n2,
        __CLPK_doublereal *__tl, __CLPK_integer *__ldtl,
        __CLPK_doublereal *__tr, __CLPK_integer *__ldtr, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__scale,
        __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__xnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb,
        __CLPK_integer *__kb, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_integer *__ipiv, __CLPK_doublereal *__w, __CLPK_integer *__ldw,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlat2s_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_real *__sa, __CLPK_integer *__ldsa,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlatbs_(char *__uplo, char *__trans, char *__diag, char *__normin,
        __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab, __CLPK_doublereal *__x,
        __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__rhs, __CLPK_doublereal *__rdsum,
        __CLPK_doublereal *__rdscal, __CLPK_integer *__ipiv,
        __CLPK_integer *__jpiv) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlatps_(char *__uplo, char *__trans, char *__diag, char *__normin,
        __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__x,
        __CLPK_doublereal *__scale, __CLPK_doublereal *__cnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__e,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__w,
        __CLPK_integer *__ldw) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlatrs_(char *__uplo, char *__trans, char *__diag, char *__normin,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__x, __CLPK_doublereal *__scale,
        __CLPK_doublereal *__cnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__v, __CLPK_integer *__incv,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__c1,
        __CLPK_doublereal *__c2, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dlauum_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dopgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__q, __CLPK_integer *__ldq,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dopmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorg2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorg2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorgbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorgl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorgql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorgqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorgr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorgrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorm2l_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorm2r_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dormbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dormhr_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dorml2_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dormlq_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dormql_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dormqr_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dormr2_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dormr3_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dormrq_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dormrz_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dormtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__c__,
        __CLPK_integer *__ldc, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_doublereal *__ab, __CLPK_integer *__ldab, __CLPK_doublereal *__s,
        __CLPK_doublereal *__scond, __CLPK_doublereal *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__afb, __CLPK_integer *__ldafb,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__ferr,
        __CLPK_doublereal *__berr, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab, __CLPK_doublereal *__afb,
        __CLPK_integer *__ldafb, char *__equed, __CLPK_doublereal *__s,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__rcond,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpbtf2_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpbtrf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpbtrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpftrf_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__a,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpftri_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__a,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpftrs_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpocon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__anorm,
        __CLPK_doublereal *__rcond, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpoequ_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__s, __CLPK_doublereal *__scond,
        __CLPK_doublereal *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpoequb_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__s, __CLPK_doublereal *__scond,
        __CLPK_doublereal *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dporfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af,
        __CLPK_integer *__ldaf, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dposvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__af, __CLPK_integer *__ldaf, char *__equed,
        __CLPK_doublereal *__s, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__rcond, __CLPK_doublereal *__ferr,
        __CLPK_doublereal *__berr, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpotf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpotrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpotri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpotrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dppcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dppequ_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_doublereal *__s, __CLPK_doublereal *__scond,
        __CLPK_doublereal *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__ap, __CLPK_doublereal *__afp,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__ferr,
        __CLPK_doublereal *__berr, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dppsvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__ap,
        __CLPK_doublereal *__afp, char *__equed, __CLPK_doublereal *__s,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__rcond,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpstf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank,
        __CLPK_doublereal *__tol, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpstrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__piv, __CLPK_integer *__rank,
        __CLPK_doublereal *__tol, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dptcon_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__anorm,
        __CLPK_doublereal *__rcond, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dptrfs_(__CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__df, __CLPK_doublereal *__ef,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__ferr,
        __CLPK_doublereal *__berr, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dptsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dptsvx_(char *__fact, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__df, __CLPK_doublereal *__ef,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__rcond,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpttrf_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dpttrs_(__CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dptts2_(__CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int drscl_(__CLPK_integer *__n, __CLPK_doublereal *__sa,
        __CLPK_doublereal *__sx,
        __CLPK_integer *__incx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsbev_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsbevd_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsbevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_doublereal *__abstol, __CLPK_integer *__m,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsbgst_(char *__vect, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb,
        __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsbgv_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsbgvd_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsbgvx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__ka, __CLPK_integer *__kb, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab, __CLPK_doublereal *__bb, __CLPK_integer *__ldbb,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_doublereal *__abstol, __CLPK_integer *__m,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsbtrd_(char *__vect, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsfrk_(char *__transr, char *__uplo, char *__trans, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_doublereal *__alpha, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__beta,
        __CLPK_doublereal *__c__) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__work, __CLPK_real *__swork, __CLPK_integer *__iter,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dspcon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_integer *__ipiv, __CLPK_doublereal *__anorm,
        __CLPK_doublereal *__rcond, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dspev_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__ap, __CLPK_doublereal *__w,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dspevd_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__ap, __CLPK_doublereal *__w,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dspevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__ap, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_doublereal *__abstol, __CLPK_integer *__m,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dspgst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__ap, __CLPK_doublereal *__bp,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dspgv_(__CLPK_integer *__itype, char *__jobz, char *__uplo,
        __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dspgvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo,
        __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dspgvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo,
        __CLPK_integer *__n, __CLPK_doublereal *__ap, __CLPK_doublereal *__bp,
        __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il,
        __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsposv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__work, __CLPK_real *__swork, __CLPK_integer *__iter,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsprfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__ap, __CLPK_doublereal *__afp,
        __CLPK_integer *__ipiv, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dspsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dspsvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__ap,
        __CLPK_doublereal *__afp, __CLPK_integer *__ipiv,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__rcond,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsptrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__tau,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsptrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsptri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_integer *__ipiv, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsptrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__ap, __CLPK_integer *__ipiv, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dstebz_(char *__range, char *__order, __CLPK_integer *__n,
        __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il,
        __CLPK_integer *__iu, __CLPK_doublereal *__abstol,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e, __CLPK_integer *__m,
        __CLPK_integer *__nsplit, __CLPK_doublereal *__w,
        __CLPK_integer *__iblock, __CLPK_integer *__isplit,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dstedc_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dstegr_(char *__jobz, char *__range, __CLPK_integer *__n,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il,
        __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__isuppz, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dstein_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_integer *__m, __CLPK_doublereal *__w,
        __CLPK_integer *__iblock, __CLPK_integer *__isplit,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dstemr_(char *__jobz, char *__range, __CLPK_integer *__n,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il,
        __CLPK_integer *__iu, __CLPK_integer *__m, __CLPK_doublereal *__w,
        __CLPK_doublereal *__z__, __CLPK_integer *__ldz, __CLPK_integer *__nzc,
        __CLPK_integer *__isuppz, __CLPK_logical *__tryrac,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsteqr_(char *__compz, __CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsterf_(__CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dstev_(char *__jobz, __CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dstevd_(char *__jobz, __CLPK_integer *__n, __CLPK_doublereal *__d__,
        __CLPK_doublereal *__e, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dstevr_(char *__jobz, char *__range, __CLPK_integer *__n,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il,
        __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__isuppz, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dstevx_(char *__jobz, char *__range, __CLPK_integer *__n,
        __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__vl, __CLPK_doublereal *__vu, __CLPK_integer *__il,
        __CLPK_integer *__iu, __CLPK_doublereal *__abstol, __CLPK_integer *__m,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsycon_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_doublereal *__anorm, __CLPK_doublereal *__rcond,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsyequb_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__s,
        __CLPK_doublereal *__scond, __CLPK_doublereal *__amax,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsyev_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsyevd_(char *__jobz, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsyevr_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_doublereal *__abstol, __CLPK_integer *__m,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__isuppz, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsyevx_(char *__jobz, char *__range, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_doublereal *__abstol, __CLPK_integer *__m,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsygs2_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsygst_(__CLPK_integer *__itype, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsygv_(__CLPK_integer *__itype, char *__jobz, char *__uplo,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsygvd_(__CLPK_integer *__itype, char *__jobz, char *__uplo,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__w,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsygvx_(__CLPK_integer *__itype, char *__jobz, char *__range, char *__uplo,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl,
        __CLPK_doublereal *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_doublereal *__abstol, __CLPK_integer *__m,
        __CLPK_doublereal *__w, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__ifail,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsyrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__af,
        __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsysv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsysvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__rcond,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsytd2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__tau,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsytf2_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsytrd_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__d__, __CLPK_doublereal *__e,
        __CLPK_doublereal *__tau, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsytrf_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsytri_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dsytrs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtbcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_doublereal *__ab, __CLPK_integer *__ldab,
        __CLPK_doublereal *__rcond, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtbrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtbtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_doublereal *__ab,
        __CLPK_integer *__ldab, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtfsm_(char *__transr, char *__side, char *__uplo, char *__trans,
        char *__diag, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__alpha, __CLPK_doublereal *__a,
        __CLPK_doublereal *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtftri_(char *__transr, char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_doublereal *__a,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtfttp_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__arf, __CLPK_doublereal *__ap,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtfttr_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__arf, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtgevc_(char *__side, char *__howmny, __CLPK_logical *__select,
        __CLPK_integer *__n, __CLPK_doublereal *__s, __CLPK_integer *__lds,
        __CLPK_doublereal *__p, __CLPK_integer *__ldp, __CLPK_doublereal *__vl,
        __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr,
        __CLPK_integer *__mm, __CLPK_integer *__m, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtgex2_(__CLPK_logical *__wantq, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q,
        __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtgexc_(__CLPK_logical *__wantq, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__q,
        __CLPK_integer *__ldq, __CLPK_doublereal *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__ifst, __CLPK_integer *__ilst,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtgsen_(__CLPK_integer *__ijob, __CLPK_logical *__wantq,
        __CLPK_logical *__wantz, __CLPK_logical *__select, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__alphar,
        __CLPK_doublereal *__alphai, __CLPK_doublereal *__beta,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__z__,
        __CLPK_integer *__ldz, __CLPK_integer *__m, __CLPK_doublereal *__pl,
        __CLPK_doublereal *__pr, __CLPK_doublereal *__dif,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtgsja_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m,
        __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_integer *__l, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__tola, __CLPK_doublereal *__tolb,
        __CLPK_doublereal *__alpha, __CLPK_doublereal *__beta,
        __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__v,
        __CLPK_integer *__ldv, __CLPK_doublereal *__q, __CLPK_integer *__ldq,
        __CLPK_doublereal *__work, __CLPK_integer *__ncycle,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtgsna_(char *__job, char *__howmny, __CLPK_logical *__select,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__vl,
        __CLPK_integer *__ldvl, __CLPK_doublereal *__vr, __CLPK_integer *__ldvr,
        __CLPK_doublereal *__s, __CLPK_doublereal *__dif, __CLPK_integer *__mm,
        __CLPK_integer *__m, __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtgsy2_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__,
        __CLPK_integer *__ldc, __CLPK_doublereal *__d__, __CLPK_integer *__ldd,
        __CLPK_doublereal *__e, __CLPK_integer *__lde, __CLPK_doublereal *__f,
        __CLPK_integer *__ldf, __CLPK_doublereal *__scale,
        __CLPK_doublereal *__rdsum, __CLPK_doublereal *__rdscal,
        __CLPK_integer *__iwork, __CLPK_integer *__pq,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtgsyl_(char *__trans, __CLPK_integer *__ijob, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__c__,
        __CLPK_integer *__ldc, __CLPK_doublereal *__d__, __CLPK_integer *__ldd,
        __CLPK_doublereal *__e, __CLPK_integer *__lde, __CLPK_doublereal *__f,
        __CLPK_integer *__ldf, __CLPK_doublereal *__scale,
        __CLPK_doublereal *__dif, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtpcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_doublereal *__ap, __CLPK_doublereal *__rcond,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtprfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb, __CLPK_doublereal *__x, __CLPK_integer *__ldx,
        __CLPK_doublereal *__ferr, __CLPK_doublereal *__berr,
        __CLPK_doublereal *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtptri_(char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_doublereal *__ap,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtptrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtpttf_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__ap, __CLPK_doublereal *__arf,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtpttr_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__ap,
        __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrcon_(char *__norm, char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__rcond, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrevc_(char *__side, char *__howmny, __CLPK_logical *__select,
        __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt,
        __CLPK_doublereal *__vl, __CLPK_integer *__ldvl,
        __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_integer *__mm,
        __CLPK_integer *__m, __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrexc_(char *__compq, __CLPK_integer *__n, __CLPK_doublereal *__t,
        __CLPK_integer *__ldt, __CLPK_doublereal *__q, __CLPK_integer *__ldq,
        __CLPK_integer *__ifst, __CLPK_integer *__ilst,
        __CLPK_doublereal *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrrfs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__x,
        __CLPK_integer *__ldx, __CLPK_doublereal *__ferr,
        __CLPK_doublereal *__berr, __CLPK_doublereal *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrsen_(char *__job, char *__compq, __CLPK_logical *__select,
        __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt,
        __CLPK_doublereal *__q, __CLPK_integer *__ldq, __CLPK_doublereal *__wr,
        __CLPK_doublereal *__wi, __CLPK_integer *__m, __CLPK_doublereal *__s,
        __CLPK_doublereal *__sep, __CLPK_doublereal *__work,
        __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__liwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrsna_(char *__job, char *__howmny, __CLPK_logical *__select,
        __CLPK_integer *__n, __CLPK_doublereal *__t, __CLPK_integer *__ldt,
        __CLPK_doublereal *__vl, __CLPK_integer *__ldvl,
        __CLPK_doublereal *__vr, __CLPK_integer *__ldvr, __CLPK_doublereal *__s,
        __CLPK_doublereal *__sep, __CLPK_integer *__mm, __CLPK_integer *__m,
        __CLPK_doublereal *__work, __CLPK_integer *__ldwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrsyl_(char *__trana, char *__tranb, __CLPK_integer *__isgn,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_doublereal *__c__, __CLPK_integer *__ldc,
        __CLPK_doublereal *__scale,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrti2_(char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrtri_(char *__uplo, char *__diag, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrtrs_(char *__uplo, char *__trans, char *__diag, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_doublereal *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrttf_(char *__transr, char *__uplo, __CLPK_integer *__n,
        __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__arf,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtrttp_(char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__ap,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtzrqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int dtzrzf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a,
        __CLPK_integer *__lda, __CLPK_doublereal *__tau,
        __CLPK_doublereal *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal dzsum1_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx,
        __CLPK_integer *__incx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer icmax1_(__CLPK_integer *__n, __CLPK_complex *__cx,
        __CLPK_integer *__incx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer ieeeck_(__CLPK_integer *__ispec, __CLPK_real *__zero,
        __CLPK_real *__one) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_integer ilaclc_(__CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_complex *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer ilaclr_(__CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_complex *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer iladiag_(char *__diag) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer iladlc_(__CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer iladlr_(__CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublereal *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer ilaenv_(__CLPK_integer *__ispec, char *__name__, char *__opts,
        __CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_integer *__n3,
        __CLPK_integer *__n4) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer ilaprec_(char *__prec) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer ilaslc_(__CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer ilaslr_(__CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer ilatrans_(char *__trans) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer ilauplo_(char *__uplo) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int ilaver_(__CLPK_integer *__vers_major__, __CLPK_integer *__vers_minor__,
        __CLPK_integer *__vers_patch__) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer ilazlc_(__CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublecomplex *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer ilazlr_(__CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_doublecomplex *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer iparmq_(__CLPK_integer *__ispec, char *__name__, char *__opts,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_integer *__lwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer izmax1_(__CLPK_integer *__n, __CLPK_doublecomplex *__cx,
        __CLPK_integer *__incx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_logical lsamen_(__CLPK_integer *__n, char *__ca,
        char *__cb) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_integer smaxloc_(__CLPK_real *__a,
        __CLPK_integer *__dimm) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sbdsdc_(char *__uplo, char *__compq, __CLPK_integer *__n,
        __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__u,
        __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt,
        __CLPK_real *__q, __CLPK_integer *__iq, __CLPK_real *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sbdsqr_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__ncvt,
        __CLPK_integer *__nru, __CLPK_integer *__ncc, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_real *__vt, __CLPK_integer *__ldvt,
        __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal scsum1_(__CLPK_integer *__n, __CLPK_complex *__cx,
        __CLPK_integer *__incx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sdisna_(char *__job, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__d__, __CLPK_real *__sep,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgbbrd_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__ncc, __CLPK_integer *__kl, __CLPK_integer *__ku,
        __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_real *__q, __CLPK_integer *__ldq,
        __CLPK_real *__pt, __CLPK_integer *__ldpt, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgbcon_(char *__norm, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond,
        __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgbequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd,
        __CLPK_real *__colcnd, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgbequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd,
        __CLPK_real *__colcnd, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgbrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab,
        __CLPK_integer *__ldab, __CLPK_real *__afb, __CLPK_integer *__ldafb,
        __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__ferr,
        __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgbsv_(__CLPK_integer *__n, __CLPK_integer *__kl, __CLPK_integer *__ku,
        __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgbsvx_(char *__fact, char *__trans, __CLPK_integer *__n,
        __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_integer *__nrhs,
        __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__afb,
        __CLPK_integer *__ldafb, __CLPK_integer *__ipiv, char *__equed,
        __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx,
        __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr,
        __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgbtf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgbtrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgbtrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_integer *__nrhs, __CLPK_real *__ab,
        __CLPK_integer *__ldab, __CLPK_integer *__ipiv, __CLPK_real *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgebak_(char *__job, char *__side, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale,
        __CLPK_integer *__m, __CLPK_real *__v, __CLPK_integer *__ldv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgebal_(char *__job, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_real *__scale,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgebd2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgebrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_real *__tauq, __CLPK_real *__taup, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgecon_(char *__norm, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__anorm, __CLPK_real *__rcond,
        __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgeequ_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__,
        __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgeequb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__,
        __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgees_(char *__jobvs, char *__sort, __CLPK_L_fp __select,
        __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_integer *__sdim, __CLPK_real *__wr, __CLPK_real *__wi,
        __CLPK_real *__vs, __CLPK_integer *__ldvs, __CLPK_real *__work,
        __CLPK_integer *__lwork, __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgeesx_(char *__jobvs, char *__sort, __CLPK_L_fp __select, char *__sense,
        __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_integer *__sdim, __CLPK_real *__wr, __CLPK_real *__wi,
        __CLPK_real *__vs, __CLPK_integer *__ldvs, __CLPK_real *__rconde,
        __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgeev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__wr, __CLPK_real *__wi,
        __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr,
        __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgeevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense,
        __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vl,
        __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__scale,
        __CLPK_real *__abnrm, __CLPK_real *__rconde, __CLPK_real *__rcondv,
        __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgegs_(char *__jobvsl, char *__jobvsr, __CLPK_integer *__n,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai,
        __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl,
        __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgegv_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta,
        __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr,
        __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgehd2_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgehrd_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgejsv_(char *__joba, char *__jobu, char *__jobv, char *__jobr,
        char *__jobt, char *__jobp, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__sva,
        __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__v,
        __CLPK_integer *__ldv, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgelq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgelqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgelsd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond,
        __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgelss_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__s, __CLPK_real *__rcond,
        __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgelsx_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond,
        __CLPK_integer *__rank, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgelsy_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_integer *__jpvt, __CLPK_real *__rcond,
        __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgeql2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgeqlf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgeqp3_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau,
        __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgeqpf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgeqr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgeqrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgerfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__af,
        __CLPK_integer *__ldaf, __CLPK_integer *__ipiv, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgerq2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgerqf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgesc2_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__rhs, __CLPK_integer *__ipiv, __CLPK_integer *__jpiv,
        __CLPK_real *__scale) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__s,
        __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt,
        __CLPK_integer *__ldvt, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgesv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_real *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__s, __CLPK_real *__u, __CLPK_integer *__ldu,
        __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgesvj_(char *__joba, char *__jobu, char *__jobv, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v,
        __CLPK_integer *__ldv, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgesvx_(char *__fact, char *__trans, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__af, __CLPK_integer *__ldaf, __CLPK_integer *__ipiv,
        char *__equed, __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx,
        __CLPK_real *__rcond, __CLPK_real *__ferr, __CLPK_real *__berr,
        __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgetc2_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_integer *__ipiv, __CLPK_integer *__jpiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgetf2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgetri_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_integer *__ipiv, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgetrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv,
        __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sggbak_(char *__job, char *__side, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale,
        __CLPK_real *__rscale, __CLPK_integer *__m, __CLPK_real *__v,
        __CLPK_integer *__ldv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sggbal_(char *__job, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale,
        __CLPK_real *__rscale, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgges_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg,
        __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_integer *__sdim,
        __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta,
        __CLPK_real *__vsl, __CLPK_integer *__ldvsl, __CLPK_real *__vsr,
        __CLPK_integer *__ldvsr, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sggesx_(char *__jobvsl, char *__jobvsr, char *__sort, __CLPK_L_fp __selctg,
        char *__sense, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__sdim, __CLPK_real *__alphar, __CLPK_real *__alphai,
        __CLPK_real *__beta, __CLPK_real *__vsl, __CLPK_integer *__ldvsl,
        __CLPK_real *__vsr, __CLPK_integer *__ldvsr, __CLPK_real *__rconde,
        __CLPK_real *__rcondv, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__iwork, __CLPK_integer *__liwork,
        __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sggev_(char *__jobvl, char *__jobvr, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta,
        __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr,
        __CLPK_integer *__ldvr, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sggevx_(char *__balanc, char *__jobvl, char *__jobvr, char *__sense,
        __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alphar,
        __CLPK_real *__alphai, __CLPK_real *__beta, __CLPK_real *__vl,
        __CLPK_integer *__ldvl, __CLPK_real *__vr, __CLPK_integer *__ldvr,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__lscale,
        __CLPK_real *__rscale, __CLPK_real *__abnrm, __CLPK_real *__bbnrm,
        __CLPK_real *__rconde, __CLPK_real *__rcondv, __CLPK_real *__work,
        __CLPK_integer *__lwork, __CLPK_integer *__iwork,
        __CLPK_logical *__bwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sggglm_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__d__, __CLPK_real *__x,
        __CLPK_real *__y, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgghrd_(char *__compq, char *__compz, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__,
        __CLPK_integer *__ldz,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgglse_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__p,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__c__, __CLPK_real *__d__,
        __CLPK_real *__x, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sggqrf_(__CLPK_integer *__n, __CLPK_integer *__m, __CLPK_integer *__p,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__taua,
        __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__taub,
        __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sggrqf_(__CLPK_integer *__m, __CLPK_integer *__p, __CLPK_integer *__n,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__taua,
        __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__taub,
        __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sggsvd_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__p, __CLPK_integer *__k,
        __CLPK_integer *__l, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__alpha,
        __CLPK_real *__beta, __CLPK_real *__u, __CLPK_integer *__ldu,
        __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q,
        __CLPK_integer *__ldq, __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sggsvp_(char *__jobu, char *__jobv, char *__jobq, __CLPK_integer *__m,
        __CLPK_integer *__p, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_real *__tola, __CLPK_real *__tolb, __CLPK_integer *__k,
        __CLPK_integer *__l, __CLPK_real *__u, __CLPK_integer *__ldu,
        __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__q,
        __CLPK_integer *__ldq, __CLPK_integer *__iwork, __CLPK_real *__tau,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgsvj0_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__,
        __CLPK_real *__sva, __CLPK_integer *__mv, __CLPK_real *__v,
        __CLPK_integer *__ldv, __CLPK_real *__eps, __CLPK_real *__sfmin,
        __CLPK_real *__tol, __CLPK_integer *__nsweep, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgsvj1_(char *__jobv, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__n1, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__d__, __CLPK_real *__sva, __CLPK_integer *__mv,
        __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__eps,
        __CLPK_real *__sfmin, __CLPK_real *__tol, __CLPK_integer *__nsweep,
        __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgtcon_(char *__norm, __CLPK_integer *__n, __CLPK_real *__dl,
        __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__du2,
        __CLPK_integer *__ipiv, __CLPK_real *__anorm, __CLPK_real *__rcond,
        __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgtrfs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du,
        __CLPK_real *__dlf, __CLPK_real *__df, __CLPK_real *__duf,
        __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgtsv_(__CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__dl,
        __CLPK_real *__d__, __CLPK_real *__du, __CLPK_real *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgtsvx_(char *__fact, char *__trans, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__,
        __CLPK_real *__du, __CLPK_real *__dlf, __CLPK_real *__df,
        __CLPK_real *__duf, __CLPK_real *__du2, __CLPK_integer *__ipiv,
        __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__x,
        __CLPK_integer *__ldx, __CLPK_real *__rcond, __CLPK_real *__ferr,
        __CLPK_real *__berr, __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgttrf_(__CLPK_integer *__n, __CLPK_real *__dl, __CLPK_real *__d__,
        __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgttrs_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__dl, __CLPK_real *__d__, __CLPK_real *__du,
        __CLPK_real *__du2, __CLPK_integer *__ipiv, __CLPK_real *__b,
        __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sgtts2_(__CLPK_integer *__itrans, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_real *__dl, __CLPK_real *__d__,
        __CLPK_real *__du, __CLPK_real *__du2, __CLPK_integer *__ipiv,
        __CLPK_real *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int shgeqz_(char *__job, char *__compq, char *__compz, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__,
        __CLPK_integer *__ldh, __CLPK_real *__t, __CLPK_integer *__ldt,
        __CLPK_real *__alphar, __CLPK_real *__alphai, __CLPK_real *__beta,
        __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__z__,
        __CLPK_integer *__ldz, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int shsein_(char *__side, char *__eigsrc, char *__initv,
        __CLPK_logical *__select, __CLPK_integer *__n, __CLPK_real *__h__,
        __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi,
        __CLPK_real *__vl, __CLPK_integer *__ldvl, __CLPK_real *__vr,
        __CLPK_integer *__ldvr, __CLPK_integer *__mm, __CLPK_integer *__m,
        __CLPK_real *__work, __CLPK_integer *__ifaill, __CLPK_integer *__ifailr,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int shseqr_(char *__job, char *__compz, __CLPK_integer *__n,
        __CLPK_integer *__ilo, __CLPK_integer *__ihi, __CLPK_real *__h__,
        __CLPK_integer *__ldh, __CLPK_real *__wr, __CLPK_real *__wi,
        __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);


        __CLPK_logical sisnan_(__CLPK_real *__sin__) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slabad_(__CLPK_real *__small,
        __CLPK_real *__large) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slabrd_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nb,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_real *__tauq, __CLPK_real *__taup,
        __CLPK_real *__x, __CLPK_integer *__ldx, __CLPK_real *__y,
        __CLPK_integer *__ldy) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slacn2_(__CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__x,
        __CLPK_integer *__isgn, __CLPK_real *__est, __CLPK_integer *__kase,
        __CLPK_integer *__isave) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slacon_(__CLPK_integer *__n, __CLPK_real *__v, __CLPK_real *__x,
        __CLPK_integer *__isgn, __CLPK_real *__est,
        __CLPK_integer *__kase) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slacpy_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sladiv_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__,
        __CLPK_real *__d__, __CLPK_real *__p,
        __CLPK_real *__q) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slae2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__,
        __CLPK_real *__rt1,
        __CLPK_real *__rt2) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaebz_(__CLPK_integer *__ijob, __CLPK_integer *__nitmax,
        __CLPK_integer *__n, __CLPK_integer *__mmax, __CLPK_integer *__minp,
        __CLPK_integer *__nbmin, __CLPK_real *__abstol, __CLPK_real *__reltol,
        __CLPK_real *__pivmin, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_real *__e2, __CLPK_integer *__nval, __CLPK_real *__ab,
        __CLPK_real *__c__, __CLPK_integer *__mout, __CLPK_integer *__nab,
        __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaed0_(__CLPK_integer *__icompq, __CLPK_integer *__qsiz,
        __CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__qstore,
        __CLPK_integer *__ldqs, __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaed1_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__q,
        __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho,
        __CLPK_integer *__cutpnt, __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaed2_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1,
        __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq,
        __CLPK_integer *__indxq, __CLPK_real *__rho, __CLPK_real *__z__,
        __CLPK_real *__dlamda, __CLPK_real *__w, __CLPK_real *__q2,
        __CLPK_integer *__indx, __CLPK_integer *__indxc,
        __CLPK_integer *__indxp, __CLPK_integer *__coltyp,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaed3_(__CLPK_integer *__k, __CLPK_integer *__n, __CLPK_integer *__n1,
        __CLPK_real *__d__, __CLPK_real *__q, __CLPK_integer *__ldq,
        __CLPK_real *__rho, __CLPK_real *__dlamda, __CLPK_real *__q2,
        __CLPK_integer *__indx, __CLPK_integer *__ctot, __CLPK_real *__w,
        __CLPK_real *__s,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaed4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_real *__d__,
        __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho,
        __CLPK_real *__dlam,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaed5_(__CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__,
        __CLPK_real *__delta, __CLPK_real *__rho,
        __CLPK_real *__dlam) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaed6_(__CLPK_integer *__kniter, __CLPK_logical *__orgati,
        __CLPK_real *__rho, __CLPK_real *__d__, __CLPK_real *__z__,
        __CLPK_real *__finit, __CLPK_real *__tau,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaed7_(__CLPK_integer *__icompq, __CLPK_integer *__n,
        __CLPK_integer *__qsiz, __CLPK_integer *__tlvls,
        __CLPK_integer *__curlvl, __CLPK_integer *__curpbm, __CLPK_real *__d__,
        __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_integer *__indxq,
        __CLPK_real *__rho, __CLPK_integer *__cutpnt, __CLPK_real *__qstore,
        __CLPK_integer *__qptr, __CLPK_integer *__prmptr,
        __CLPK_integer *__perm, __CLPK_integer *__givptr,
        __CLPK_integer *__givcol, __CLPK_real *__givnum, __CLPK_real *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaed8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_integer *__n,
        __CLPK_integer *__qsiz, __CLPK_real *__d__, __CLPK_real *__q,
        __CLPK_integer *__ldq, __CLPK_integer *__indxq, __CLPK_real *__rho,
        __CLPK_integer *__cutpnt, __CLPK_real *__z__, __CLPK_real *__dlamda,
        __CLPK_real *__q2, __CLPK_integer *__ldq2, __CLPK_real *__w,
        __CLPK_integer *__perm, __CLPK_integer *__givptr,
        __CLPK_integer *__givcol, __CLPK_real *__givnum,
        __CLPK_integer *__indxp, __CLPK_integer *__indx,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaed9_(__CLPK_integer *__k, __CLPK_integer *__kstart,
        __CLPK_integer *__kstop, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_real *__q, __CLPK_integer *__ldq, __CLPK_real *__rho,
        __CLPK_real *__dlamda, __CLPK_real *__w, __CLPK_real *__s,
        __CLPK_integer *__lds,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaeda_(__CLPK_integer *__n, __CLPK_integer *__tlvls,
        __CLPK_integer *__curlvl, __CLPK_integer *__curpbm,
        __CLPK_integer *__prmptr, __CLPK_integer *__perm,
        __CLPK_integer *__givptr, __CLPK_integer *__givcol,
        __CLPK_real *__givnum, __CLPK_real *__q, __CLPK_integer *__qptr,
        __CLPK_real *__z__, __CLPK_real *__ztemp,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaein_(__CLPK_logical *__rightv, __CLPK_logical *__noinit,
        __CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh,
        __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__vr,
        __CLPK_real *__vi, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_real *__work, __CLPK_real *__eps3, __CLPK_real *__smlnum,
        __CLPK_real *__bignum,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaev2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__,
        __CLPK_real *__rt1, __CLPK_real *__rt2, __CLPK_real *__cs1,
        __CLPK_real *__sn1) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaexc_(__CLPK_logical *__wantq, __CLPK_integer *__n, __CLPK_real *__t,
        __CLPK_integer *__ldt, __CLPK_real *__q, __CLPK_integer *__ldq,
        __CLPK_integer *__j1, __CLPK_integer *__n1, __CLPK_integer *__n2,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slag2_(__CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__safmin, __CLPK_real *__scale1,
        __CLPK_real *__scale2, __CLPK_real *__wr1, __CLPK_real *__wr2,
        __CLPK_real *__wi) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slag2d_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__sa,
        __CLPK_integer *__ldsa, __CLPK_doublereal *__a, __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slags2_(__CLPK_logical *__upper, __CLPK_real *__a1, __CLPK_real *__a2,
        __CLPK_real *__a3, __CLPK_real *__b1, __CLPK_real *__b2,
        __CLPK_real *__b3, __CLPK_real *__csu, __CLPK_real *__snu,
        __CLPK_real *__csv, __CLPK_real *__snv, __CLPK_real *__csq,
        __CLPK_real *__snq) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slagtf_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_real *__lambda,
        __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__tol,
        __CLPK_real *__d__, __CLPK_integer *__in,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slagtm_(char *__trans, __CLPK_integer *__n, __CLPK_integer *__nrhs,
        __CLPK_real *__alpha, __CLPK_real *__dl, __CLPK_real *__d__,
        __CLPK_real *__du, __CLPK_real *__x, __CLPK_integer *__ldx,
        __CLPK_real *__beta, __CLPK_real *__b,
        __CLPK_integer *__ldb) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slagts_(__CLPK_integer *__job, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_real *__b, __CLPK_real *__c__, __CLPK_real *__d__,
        __CLPK_integer *__in, __CLPK_real *__y, __CLPK_real *__tol,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slagv2_(__CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__alphar, __CLPK_real *__alphai,
        __CLPK_real *__beta, __CLPK_real *__csl, __CLPK_real *__snl,
        __CLPK_real *__csr,
        __CLPK_real *__snr) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slahqr_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr,
        __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz,
        __CLPK_real *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slahr2_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__y,
        __CLPK_integer *__ldy) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slahrd_(__CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__nb,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__y,
        __CLPK_integer *__ldy) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaic1_(__CLPK_integer *__job, __CLPK_integer *__j, __CLPK_real *__x,
        __CLPK_real *__sest, __CLPK_real *__w, __CLPK_real *__gamma,
        __CLPK_real *__sestpr, __CLPK_real *__s,
        __CLPK_real *__c__) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_logical slaisnan_(__CLPK_real *__sin1,
        __CLPK_real *__sin2) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaln2_(__CLPK_logical *__ltrans, __CLPK_integer *__na,
        __CLPK_integer *__nw, __CLPK_real *__smin, __CLPK_real *__ca,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__d1,
        __CLPK_real *__d2, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_real *__wr, __CLPK_real *__wi, __CLPK_real *__x,
        __CLPK_integer *__ldx, __CLPK_real *__scale, __CLPK_real *__xnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slals0_(__CLPK_integer *__icompq, __CLPK_integer *__nl,
        __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__nrhs,
        __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__bx,
        __CLPK_integer *__ldbx, __CLPK_integer *__perm,
        __CLPK_integer *__givptr, __CLPK_integer *__givcol,
        __CLPK_integer *__ldgcol, __CLPK_real *__givnum,
        __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl,
        __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k,
        __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slalsa_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz,
        __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__bx, __CLPK_integer *__ldbx,
        __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt,
        __CLPK_integer *__k, __CLPK_real *__difl, __CLPK_real *__difr,
        __CLPK_real *__z__, __CLPK_real *__poles, __CLPK_integer *__givptr,
        __CLPK_integer *__givcol, __CLPK_integer *__ldgcol,
        __CLPK_integer *__perm, __CLPK_real *__givnum, __CLPK_real *__c__,
        __CLPK_real *__s, __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slalsd_(char *__uplo, __CLPK_integer *__smlsiz, __CLPK_integer *__n,
        __CLPK_integer *__nrhs, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_real *__b, __CLPK_integer *__ldb, __CLPK_real *__rcond,
        __CLPK_integer *__rank, __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slamrg_(__CLPK_integer *__n1, __CLPK_integer *__n2, __CLPK_real *__a,
        __CLPK_integer *__strd1, __CLPK_integer *__strd2,
        __CLPK_integer *__index) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_integer slaneg_(__CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_real *__lld, __CLPK_real *__sigma, __CLPK_real *__pivmin,
        __CLPK_integer *__r__) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

__CLPK_doublereal slangb_(char *__norm, __CLPK_integer *__n,
        __CLPK_integer *__kl, __CLPK_integer *__ku, __CLPK_real *__ab,
        __CLPK_integer *__ldab,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slange_(char *__norm, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slangt_(char *__norm, __CLPK_integer *__n, __CLPK_real *__dl,
        __CLPK_real *__d__,
        __CLPK_real *__du) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slanhs_(char *__norm, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slansb_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_real *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slansf_(char *__norm, char *__transr, char *__uplo,
        __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slansp_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_real *__ap,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slanst_(char *__norm, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_real *__e) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slansy_(char *__norm, char *__uplo, __CLPK_integer *__n,
        __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slantb_(char *__norm, char *__uplo, char *__diag,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__ab,
        __CLPK_integer *__ldab,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slantp_(char *__norm, char *__uplo, char *__diag,
        __CLPK_integer *__n, __CLPK_real *__ap,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slantr_(char *__norm, char *__uplo, char *__diag,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slanv2_(__CLPK_real *__a, __CLPK_real *__b, __CLPK_real *__c__,
        __CLPK_real *__d__, __CLPK_real *__rt1r, __CLPK_real *__rt1i,
        __CLPK_real *__rt2r, __CLPK_real *__rt2i, __CLPK_real *__cs,
        __CLPK_real *__sn) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slapll_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx,
        __CLPK_real *__y, __CLPK_integer *__incy,
        __CLPK_real *__ssmin) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slapmt_(__CLPK_logical *__forwrd, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__x, __CLPK_integer *__ldx,
        __CLPK_integer *__k) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slapy2_(__CLPK_real *__x,
        __CLPK_real *__y) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

__CLPK_doublereal slapy3_(__CLPK_real *__x, __CLPK_real *__y,
        __CLPK_real *__z__) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaqgb_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__kl,
        __CLPK_integer *__ku, __CLPK_real *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__r__, __CLPK_real *__c__, __CLPK_real *__rowcnd,
        __CLPK_real *__colcnd, __CLPK_real *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaqge_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__r__, __CLPK_real *__c__,
        __CLPK_real *__rowcnd, __CLPK_real *__colcnd, __CLPK_real *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaqp2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_integer *__jpvt,
        __CLPK_real *__tau, __CLPK_real *__vn1, __CLPK_real *__vn2,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaqps_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__offset,
        __CLPK_integer *__nb, __CLPK_integer *__kb, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_integer *__jpvt, __CLPK_real *__tau,
        __CLPK_real *__vn1, __CLPK_real *__vn2, __CLPK_real *__auxv,
        __CLPK_real *__f,
        __CLPK_integer *__ldf) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaqr0_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr,
        __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz,
        __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaqr1_(__CLPK_integer *__n, __CLPK_real *__h__, __CLPK_integer *__ldh,
        __CLPK_real *__sr1, __CLPK_real *__si1, __CLPK_real *__sr2,
        __CLPK_real *__si2,
        __CLPK_real *__v) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaqr2_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot,
        __CLPK_integer *__nw, __CLPK_real *__h__, __CLPK_integer *__ldh,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__,
        __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd,
        __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__v,
        __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_real *__t,
        __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_real *__wv,
        __CLPK_integer *__ldwv, __CLPK_real *__work,
        __CLPK_integer *__lwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaqr3_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ktop, __CLPK_integer *__kbot,
        __CLPK_integer *__nw, __CLPK_real *__h__, __CLPK_integer *__ldh,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__,
        __CLPK_integer *__ldz, __CLPK_integer *__ns, __CLPK_integer *__nd,
        __CLPK_real *__sr, __CLPK_real *__si, __CLPK_real *__v,
        __CLPK_integer *__ldv, __CLPK_integer *__nh, __CLPK_real *__t,
        __CLPK_integer *__ldt, __CLPK_integer *__nv, __CLPK_real *__wv,
        __CLPK_integer *__ldwv, __CLPK_real *__work,
        __CLPK_integer *__lwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaqr4_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_real *__h__, __CLPK_integer *__ldh, __CLPK_real *__wr,
        __CLPK_real *__wi, __CLPK_integer *__iloz, __CLPK_integer *__ihiz,
        __CLPK_real *__z__, __CLPK_integer *__ldz, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaqr5_(__CLPK_logical *__wantt, __CLPK_logical *__wantz,
        __CLPK_integer *__kacc22, __CLPK_integer *__n, __CLPK_integer *__ktop,
        __CLPK_integer *__kbot, __CLPK_integer *__nshfts, __CLPK_real *__sr,
        __CLPK_real *__si, __CLPK_real *__h__, __CLPK_integer *__ldh,
        __CLPK_integer *__iloz, __CLPK_integer *__ihiz, __CLPK_real *__z__,
        __CLPK_integer *__ldz, __CLPK_real *__v, __CLPK_integer *__ldv,
        __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_integer *__nv,
        __CLPK_real *__wv, __CLPK_integer *__ldwv, __CLPK_integer *__nh,
        __CLPK_real *__wh,
        __CLPK_integer *__ldwh) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaqsb_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__s,
        __CLPK_real *__scond, __CLPK_real *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaqsp_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap,
        __CLPK_real *__s, __CLPK_real *__scond, __CLPK_real *__amax,
        char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaqsy_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__s, __CLPK_real *__scond,
        __CLPK_real *__amax, char *__equed) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaqtr_(__CLPK_logical *__ltran, __CLPK_logical *__l__CLPK_real,
        __CLPK_integer *__n, __CLPK_real *__t, __CLPK_integer *__ldt,
        __CLPK_real *__b, __CLPK_real *__w, __CLPK_real *__scale,
        __CLPK_real *__x, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slar1v_(__CLPK_integer *__n, __CLPK_integer *__b1, __CLPK_integer *__bn,
        __CLPK_real *__lambda, __CLPK_real *__d__, __CLPK_real *__l,
        __CLPK_real *__ld, __CLPK_real *__lld, __CLPK_real *__pivmin,
        __CLPK_real *__gaptol, __CLPK_real *__z__, __CLPK_logical *__wantnc,
        __CLPK_integer *__negcnt, __CLPK_real *__ztz, __CLPK_real *__mingma,
        __CLPK_integer *__r__, __CLPK_integer *__isuppz, __CLPK_real *__nrminv,
        __CLPK_real *__resid, __CLPK_real *__rqcorr,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slar2v_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_real *__y,
        __CLPK_real *__z__, __CLPK_integer *__incx, __CLPK_real *__c__,
        __CLPK_real *__s,
        __CLPK_integer *__incc) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarf_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau,
        __CLPK_real *__c__, __CLPK_integer *__ldc,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slarfb_(char *__side, char *__trans, char *__direct, char *__storev,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_real *__v, __CLPK_integer *__ldv, __CLPK_real *__t,
        __CLPK_integer *__ldt, __CLPK_real *__c__, __CLPK_integer *__ldc,
        __CLPK_real *__work,
        __CLPK_integer *__ldwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarfg_(__CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__x,
        __CLPK_integer *__incx,
        __CLPK_real *__tau) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slarfp_(__CLPK_integer *__n, __CLPK_real *__alpha, __CLPK_real *__x,
        __CLPK_integer *__incx,
        __CLPK_real *__tau) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slarft_(char *__direct, char *__storev, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv,
        __CLPK_real *__tau, __CLPK_real *__t,
        __CLPK_integer *__ldt) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarfx_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__v, __CLPK_real *__tau, __CLPK_real *__c__,
        __CLPK_integer *__ldc,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slargv_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx,
        __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__c__,
        __CLPK_integer *__incc) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarnv_(__CLPK_integer *__idist, __CLPK_integer *__iseed,
        __CLPK_integer *__n,
        __CLPK_real *__x) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slarra_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_real *__e2, __CLPK_real *__spltol, __CLPK_real *__tnrm,
        __CLPK_integer *__nsplit, __CLPK_integer *__isplit,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarrb_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__lld,
        __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_real *__rtol1,
        __CLPK_real *__rtol2, __CLPK_integer *__offset, __CLPK_real *__w,
        __CLPK_real *__wgap, __CLPK_real *__werr, __CLPK_real *__work,
        __CLPK_integer *__iwork, __CLPK_real *__pivmin, __CLPK_real *__spdiam,
        __CLPK_integer *__twist,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarrc_(char *__jobt, __CLPK_integer *__n, __CLPK_real *__vl,
        __CLPK_real *__vu, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_real *__pivmin, __CLPK_integer *__eigcnt, __CLPK_integer *__lcnt,
        __CLPK_integer *__rcnt,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarrd_(char *__range, char *__order, __CLPK_integer *__n,
        __CLPK_real *__vl, __CLPK_real *__vu, __CLPK_integer *__il,
        __CLPK_integer *__iu, __CLPK_real *__gers, __CLPK_real *__reltol,
        __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2,
        __CLPK_real *__pivmin, __CLPK_integer *__nsplit,
        __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_real *__w,
        __CLPK_real *__werr, __CLPK_real *__wl, __CLPK_real *__wu,
        __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarre_(char *__range, __CLPK_integer *__n, __CLPK_real *__vl,
        __CLPK_real *__vu, __CLPK_integer *__il, __CLPK_integer *__iu,
        __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__e2,
        __CLPK_real *__rtol1, __CLPK_real *__rtol2, __CLPK_real *__spltol,
        __CLPK_integer *__nsplit, __CLPK_integer *__isplit, __CLPK_integer *__m,
        __CLPK_real *__w, __CLPK_real *__werr, __CLPK_real *__wgap,
        __CLPK_integer *__iblock, __CLPK_integer *__indexw, __CLPK_real *__gers,
        __CLPK_real *__pivmin, __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarrf_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__l,
        __CLPK_real *__ld, __CLPK_integer *__clstrt, __CLPK_integer *__clend,
        __CLPK_real *__w, __CLPK_real *__wgap, __CLPK_real *__werr,
        __CLPK_real *__spdiam, __CLPK_real *__clgapl, __CLPK_real *__clgapr,
        __CLPK_real *__pivmin, __CLPK_real *__sigma, __CLPK_real *__dplus,
        __CLPK_real *__lplus, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarrj_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e2,
        __CLPK_integer *__ifirst, __CLPK_integer *__ilast, __CLPK_real *__rtol,
        __CLPK_integer *__offset, __CLPK_real *__w, __CLPK_real *__werr,
        __CLPK_real *__work, __CLPK_integer *__iwork, __CLPK_real *__pivmin,
        __CLPK_real *__spdiam,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarrk_(__CLPK_integer *__n, __CLPK_integer *__iw, __CLPK_real *__gl,
        __CLPK_real *__gu, __CLPK_real *__d__, __CLPK_real *__e2,
        __CLPK_real *__pivmin, __CLPK_real *__reltol, __CLPK_real *__w,
        __CLPK_real *__werr,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarrr_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarrv_(__CLPK_integer *__n, __CLPK_real *__vl, __CLPK_real *__vu,
        __CLPK_real *__d__, __CLPK_real *__l, __CLPK_real *__pivmin,
        __CLPK_integer *__isplit, __CLPK_integer *__m, __CLPK_integer *__dol,
        __CLPK_integer *__dou, __CLPK_real *__minrgp, __CLPK_real *__rtol1,
        __CLPK_real *__rtol2, __CLPK_real *__w, __CLPK_real *__werr,
        __CLPK_real *__wgap, __CLPK_integer *__iblock, __CLPK_integer *__indexw,
        __CLPK_real *__gers, __CLPK_real *__z__, __CLPK_integer *__ldz,
        __CLPK_integer *__isuppz, __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarscl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_real *__x,
        __CLPK_integer *__ldx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slartg_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__cs,
        __CLPK_real *__sn,
        __CLPK_real *__r__) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slartv_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx,
        __CLPK_real *__y, __CLPK_integer *__incy, __CLPK_real *__c__,
        __CLPK_real *__s,
        __CLPK_integer *__incc) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaruv_(__CLPK_integer *__iseed, __CLPK_integer *__n,
        __CLPK_real *__x) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slarz_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__l, __CLPK_real *__v, __CLPK_integer *__incv,
        __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slarzb_(char *__side, char *__trans, char *__direct, char *__storev,
        __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_integer *__l, __CLPK_real *__v, __CLPK_integer *__ldv,
        __CLPK_real *__t, __CLPK_integer *__ldt, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__ldwork) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slarzt_(char *__direct, char *__storev, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_real *__v, __CLPK_integer *__ldv,
        __CLPK_real *__tau, __CLPK_real *__t,
        __CLPK_integer *__ldt) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slas2_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__h__,
        __CLPK_real *__ssmin,
        __CLPK_real *__ssmax) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slascl_(char *__type__, __CLPK_integer *__kl, __CLPK_integer *__ku,
        __CLPK_real *__cfrom, __CLPK_real *__cto, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slascl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_real *__x,
        __CLPK_integer *__ldx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasd0_(__CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu,
        __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_integer *__smlsiz,
        __CLPK_integer *__iwork, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasd1_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre,
        __CLPK_real *__d__, __CLPK_real *__alpha, __CLPK_real *__beta,
        __CLPK_real *__u, __CLPK_integer *__ldu, __CLPK_real *__vt,
        __CLPK_integer *__ldvt, __CLPK_integer *__idxq, __CLPK_integer *__iwork,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasd2_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre,
        __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__z__,
        __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__u,
        __CLPK_integer *__ldu, __CLPK_real *__vt, __CLPK_integer *__ldvt,
        __CLPK_real *__dsigma, __CLPK_real *__u2, __CLPK_integer *__ldu2,
        __CLPK_real *__vt2, __CLPK_integer *__ldvt2, __CLPK_integer *__idxp,
        __CLPK_integer *__idx, __CLPK_integer *__idxc, __CLPK_integer *__idxq,
        __CLPK_integer *__coltyp,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasd3_(__CLPK_integer *__nl, __CLPK_integer *__nr, __CLPK_integer *__sqre,
        __CLPK_integer *__k, __CLPK_real *__d__, __CLPK_real *__q,
        __CLPK_integer *__ldq, __CLPK_real *__dsigma, __CLPK_real *__u,
        __CLPK_integer *__ldu, __CLPK_real *__u2, __CLPK_integer *__ldu2,
        __CLPK_real *__vt, __CLPK_integer *__ldvt, __CLPK_real *__vt2,
        __CLPK_integer *__ldvt2, __CLPK_integer *__idxc, __CLPK_integer *__ctot,
        __CLPK_real *__z__,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasd4_(__CLPK_integer *__n, __CLPK_integer *__i__, __CLPK_real *__d__,
        __CLPK_real *__z__, __CLPK_real *__delta, __CLPK_real *__rho,
        __CLPK_real *__sigma, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasd5_(__CLPK_integer *__i__, __CLPK_real *__d__, __CLPK_real *__z__,
        __CLPK_real *__delta, __CLPK_real *__rho, __CLPK_real *__dsigma,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slasd6_(__CLPK_integer *__icompq, __CLPK_integer *__nl,
        __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_real *__d__,
        __CLPK_real *__vf, __CLPK_real *__vl, __CLPK_real *__alpha,
        __CLPK_real *__beta, __CLPK_integer *__idxq, __CLPK_integer *__perm,
        __CLPK_integer *__givptr, __CLPK_integer *__givcol,
        __CLPK_integer *__ldgcol, __CLPK_real *__givnum,
        __CLPK_integer *__ldgnum, __CLPK_real *__poles, __CLPK_real *__difl,
        __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_integer *__k,
        __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasd7_(__CLPK_integer *__icompq, __CLPK_integer *__nl,
        __CLPK_integer *__nr, __CLPK_integer *__sqre, __CLPK_integer *__k,
        __CLPK_real *__d__, __CLPK_real *__z__, __CLPK_real *__zw,
        __CLPK_real *__vf, __CLPK_real *__vfw, __CLPK_real *__vl,
        __CLPK_real *__vlw, __CLPK_real *__alpha, __CLPK_real *__beta,
        __CLPK_real *__dsigma, __CLPK_integer *__idx, __CLPK_integer *__idxp,
        __CLPK_integer *__idxq, __CLPK_integer *__perm,
        __CLPK_integer *__givptr, __CLPK_integer *__givcol,
        __CLPK_integer *__ldgcol, __CLPK_real *__givnum,
        __CLPK_integer *__ldgnum, __CLPK_real *__c__, __CLPK_real *__s,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasd8_(__CLPK_integer *__icompq, __CLPK_integer *__k, __CLPK_real *__d__,
        __CLPK_real *__z__, __CLPK_real *__vf, __CLPK_real *__vl,
        __CLPK_real *__difl, __CLPK_real *__difr, __CLPK_integer *__lddifr,
        __CLPK_real *__dsigma, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasda_(__CLPK_integer *__icompq, __CLPK_integer *__smlsiz,
        __CLPK_integer *__n, __CLPK_integer *__sqre, __CLPK_real *__d__,
        __CLPK_real *__e, __CLPK_real *__u, __CLPK_integer *__ldu,
        __CLPK_real *__vt, __CLPK_integer *__k, __CLPK_real *__difl,
        __CLPK_real *__difr, __CLPK_real *__z__, __CLPK_real *__poles,
        __CLPK_integer *__givptr, __CLPK_integer *__givcol,
        __CLPK_integer *__ldgcol, __CLPK_integer *__perm, __CLPK_real *__givnum,
        __CLPK_real *__c__, __CLPK_real *__s, __CLPK_real *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasdq_(char *__uplo, __CLPK_integer *__sqre, __CLPK_integer *__n,
        __CLPK_integer *__ncvt, __CLPK_integer *__nru, __CLPK_integer *__ncc,
        __CLPK_real *__d__, __CLPK_real *__e, __CLPK_real *__vt,
        __CLPK_integer *__ldvt, __CLPK_real *__u, __CLPK_integer *__ldu,
        __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasdt_(__CLPK_integer *__n, __CLPK_integer *__lvl, __CLPK_integer *__nd,
        __CLPK_integer *__inode, __CLPK_integer *__ndiml,
        __CLPK_integer *__ndimr,
        __CLPK_integer *__msub) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slaset_(char *__uplo, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__alpha, __CLPK_real *__beta, __CLPK_real *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasq1_(__CLPK_integer *__n, __CLPK_real *__d__, __CLPK_real *__e,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasq2_(__CLPK_integer *__n, __CLPK_real *__z__,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasq3_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__,
        __CLPK_integer *__pp, __CLPK_real *__dmin__, __CLPK_real *__sigma,
        __CLPK_real *__desig, __CLPK_real *__qmax, __CLPK_integer *__nfail,
        __CLPK_integer *__iter, __CLPK_integer *__ndiv, __CLPK_logical *__ieee,
        __CLPK_integer *__ttype, __CLPK_real *__dmin1, __CLPK_real *__dmin2,
        __CLPK_real *__dn, __CLPK_real *__dn1, __CLPK_real *__dn2,
        __CLPK_real *__g,
        __CLPK_real *__tau) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slasq4_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__,
        __CLPK_integer *__pp, __CLPK_integer *__n0in, __CLPK_real *__dmin__,
        __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn,
        __CLPK_real *__dn1, __CLPK_real *__dn2, __CLPK_real *__tau,
        __CLPK_integer *__ttype,
        __CLPK_real *__g) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slasq5_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__,
        __CLPK_integer *__pp, __CLPK_real *__tau, __CLPK_real *__dmin__,
        __CLPK_real *__dmin1, __CLPK_real *__dmin2, __CLPK_real *__dn,
        __CLPK_real *__dnm1, __CLPK_real *__dnm2,
        __CLPK_logical *__ieee) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasq6_(__CLPK_integer *__i0, __CLPK_integer *__n0, __CLPK_real *__z__,
        __CLPK_integer *__pp, __CLPK_real *__dmin__, __CLPK_real *__dmin1,
        __CLPK_real *__dmin2, __CLPK_real *__dn, __CLPK_real *__dnm1,
        __CLPK_real *__dnm2) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slasr_(char *__side, char *__pivot, char *__direct, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_real *__c__, __CLPK_real *__s,
        __CLPK_real *__a,
        __CLPK_integer *__lda) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasrt_(char *__id, __CLPK_integer *__n, __CLPK_real *__d__,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slassq_(__CLPK_integer *__n, __CLPK_real *__x, __CLPK_integer *__incx,
        __CLPK_real *__scale,
        __CLPK_real *__sumsq) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasv2_(__CLPK_real *__f, __CLPK_real *__g, __CLPK_real *__h__,
        __CLPK_real *__ssmin, __CLPK_real *__ssmax, __CLPK_real *__snr,
        __CLPK_real *__csr, __CLPK_real *__snl,
        __CLPK_real *__csl) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slaswp_(__CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_integer *__k1, __CLPK_integer *__k2, __CLPK_integer *__ipiv,
        __CLPK_integer *__incx) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasy2_(__CLPK_logical *__ltranl, __CLPK_logical *__ltranr,
        __CLPK_integer *__isgn, __CLPK_integer *__n1, __CLPK_integer *__n2,
        __CLPK_real *__tl, __CLPK_integer *__ldtl, __CLPK_real *__tr,
        __CLPK_integer *__ldtr, __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_real *__scale, __CLPK_real *__x, __CLPK_integer *__ldx,
        __CLPK_real *__xnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slasyf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb,
        __CLPK_integer *__kb, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_integer *__ipiv, __CLPK_real *__w, __CLPK_integer *__ldw,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slatbs_(char *__uplo, char *__trans, char *__diag, char *__normin,
        __CLPK_integer *__n, __CLPK_integer *__kd, __CLPK_real *__ab,
        __CLPK_integer *__ldab, __CLPK_real *__x, __CLPK_real *__scale,
        __CLPK_real *__cnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slatdf_(__CLPK_integer *__ijob, __CLPK_integer *__n, __CLPK_real *__z__,
        __CLPK_integer *__ldz, __CLPK_real *__rhs, __CLPK_real *__rdsum,
        __CLPK_real *__rdscal, __CLPK_integer *__ipiv,
        __CLPK_integer *__jpiv) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slatps_(char *__uplo, char *__trans, char *__diag, char *__normin,
        __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__x,
        __CLPK_real *__scale, __CLPK_real *__cnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slatrd_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nb,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__e,
        __CLPK_real *__tau, __CLPK_real *__w,
        __CLPK_integer *__ldw) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slatrs_(char *__uplo, char *__trans, char *__diag, char *__normin,
        __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__x, __CLPK_real *__scale, __CLPK_real *__cnorm,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slatrz_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__l,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slatzm_(char *__side, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_real *__v, __CLPK_integer *__incv, __CLPK_real *__tau,
        __CLPK_real *__c1, __CLPK_real *__c2, __CLPK_integer *__ldc,
        __CLPK_real *__work) __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_4_0);

int slauu2_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int slauum_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sopgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__ap,
        __CLPK_real *__tau, __CLPK_real *__q, __CLPK_integer *__ldq,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sopmtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_real *__ap, __CLPK_real *__tau,
        __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorg2l_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorg2r_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorgbr_(char *__vect, __CLPK_integer *__m, __CLPK_integer *__n,
        __CLPK_integer *__k, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__tau, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorghr_(__CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorgl2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorglq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorgql_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorgqr_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorgr2_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorgrq_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__k,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorgtr_(char *__uplo, __CLPK_integer *__n, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorm2l_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorm2r_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sormbr_(char *__vect, char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sormhr_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__ilo, __CLPK_integer *__ihi,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sorml2_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sormlq_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sormql_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sormqr_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sormr2_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sormr3_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sormrq_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_real *__a,
        __CLPK_integer *__lda, __CLPK_real *__tau, __CLPK_real *__c__,
        __CLPK_integer *__ldc, __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sormrz_(char *__side, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_integer *__k, __CLPK_integer *__l,
        __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__tau,
        __CLPK_real *__c__, __CLPK_integer *__ldc, __CLPK_real *__work,
        __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int sormtr_(char *__side, char *__uplo, char *__trans, __CLPK_integer *__m,
        __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda,
        __CLPK_real *__tau, __CLPK_real *__c__, __CLPK_integer *__ldc,
        __CLPK_real *__work, __CLPK_integer *__lwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int spbcon_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__anorm,
        __CLPK_real *__rcond, __CLPK_real *__work, __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int spbequ_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_real *__ab, __CLPK_integer *__ldab, __CLPK_real *__s,
        __CLPK_real *__scond, __CLPK_real *__amax,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int spbrfs_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__afb, __CLPK_integer *__ldafb, __CLPK_real *__b,
        __CLPK_integer *__ldb, __CLPK_real *__x, __CLPK_integer *__ldx,
        __CLPK_real *__ferr, __CLPK_real *__berr, __CLPK_real *__work,
        __CLPK_integer *__iwork,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int spbstf_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_real *__ab, __CLPK_integer *__ldab,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int spbsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__kd,
        __CLPK_integer *__nrhs, __CLPK_real *__ab, __CLPK_integer *__ldab,
        __CLPK_real *__b, __CLPK_integer *__ldb,
        __CLPK_integer *__info) __OSX_AVAILABLE_STARTING(__MAC_10_2,
        __IPHONE_4_0);

int spbsvx_(char *__fact, char *__uplo, __CLPK_integer *__n,
        __CLPK_integer *__kd, __CLPK_integer *__nrhs, __CLPK_real *__ab,
        __CLPK_integer *__lda