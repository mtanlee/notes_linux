ChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetSecurityMgrSite_EnableModeless_Proxy(
    IInternetSecurityMgrSite* This,
    WINBOOL fEnable);
void __RPC_STUB IInternetSecurityMgrSite_EnableModeless_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IInternetSecurityMgrSite_INTERFACE_DEFINED__ */

#endif

#ifndef _LPINTERNETSECURITYMANANGER_DEFINED
#define _LPINTERNETSECURITYMANANGER_DEFINED

/*****************************************************************************
 * IInternetSecurityManager interface
 */
#ifndef __IInternetSecurityManager_INTERFACE_DEFINED__
#define __IInternetSecurityManager_INTERFACE_DEFINED__


#define MUTZ_NOSAVEDFILECHECK 0x1
#define MUTZ_ISFILE 0x2
#define MUTZ_ACCEPT_WILDCARD_SCHEME 0x80
#define MUTZ_ENFORCERESTRICTED 0x100
#define MUTZ_RESERVED 0x200
#define MUTZ_REQUIRESAVEDFILECHECK 0x400
#define MUTZ_DONT_UNESCAPE 0x800
#define MUTZ_DONT_USE_CACHE 0x1000
#define MUTZ_FORCE_INTRANET_FLAGS 0x2000
#define MUTZ_IGNORE_ZONE_MAPPINGS 0x4000


#define MAX_SIZE_SECURITY_ID 512


typedef enum __WIDL_urlmon_generated_name_0000000C {
    PUAF_DEFAULT = 0x0,
    PUAF_NOUI = 0x1,
    PUAF_ISFILE = 0x2,
    PUAF_WARN_IF_DENIED = 0x4,
    PUAF_FORCEUI_FOREGROUND = 0x8,
    PUAF_CHECK_TIFS = 0x10,
    PUAF_DONTCHECKBOXINDIALOG = 0x20,
    PUAF_TRUSTED = 0x40,
    PUAF_ACCEPT_WILDCARD_SCHEME = 0x80,
    PUAF_ENFORCERESTRICTED = 0x100,
    PUAF_NOSAVEDFILECHECK = 0x200,
    PUAF_REQUIRESAVEDFILECHECK = 0x400,
    PUAF_DONT_USE_CACHE = 0x1000,
    PUAF_RESERVED1 = 0x2000,
    PUAF_RESERVED2 = 0x4000,
    PUAF_LMZ_UNLOCKED = 0x10000,
    PUAF_LMZ_LOCKED = 0x20000,
    PUAF_DEFAULTZONEPOL = 0x40000,
    PUAF_NPL_USE_LOCKED_IF_RESTRICTED = 0x80000,
    PUAF_NOUIIFLOCKED = 0x100000,
    PUAF_DRAGPROTOCOLCHECK = 0x200000
} PUAF;
typedef enum __WIDL_urlmon_generated_name_0000000D {
    PUAFOUT_DEFAULT = 0x0,
    PUAFOUT_ISLOCKZONEPOLICY = 0x1
} PUAFOUT;


typedef enum __WIDL_urlmon_generated_name_0000000E {
    SZM_CREATE = 0x0,
    SZM_DELETE = 0x1
} SZM_FLAGS;

DEFINE_GUID(IID_IInternetSecurityManager, 0x79eac9ee, 0xbaf9, 0x11ce, 0x8c,0x82, 0x00,0xaa,0x00,0x4b,0xa9,0x0b);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("79eac9ee-baf9-11ce-8c82-00aa004ba90b")
IInternetSecurityManager : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetSecuritySite(
        IInternetSecurityMgrSite *pSite) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetSecuritySite(
        IInternetSecurityMgrSite **ppSite) = 0;

    virtual HRESULT STDMETHODCALLTYPE MapUrlToZone(
        LPCWSTR pwszUrl,
        DWORD *pdwZone,
        DWORD dwFlags) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetSecurityId(
        LPCWSTR pwszUrl,
        BYTE *pbSecurityId,
        DWORD *pcbSecurityId,
        DWORD_PTR dwReserved) = 0;

    virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction(
        LPCWSTR pwszUrl,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved) = 0;

    virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy(
        LPCWSTR pwszUrl,
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwReserved) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetZoneMapping(
        DWORD dwZone,
        LPCWSTR lpszPattern,
        DWORD dwFlags) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetZoneMappings(
        DWORD dwZone,
        IEnumString **ppenumString,
        DWORD dwFlags) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IInternetSecurityManager, 0x79eac9ee, 0xbaf9, 0x11ce, 0x8c,0x82, 0x00,0xaa,0x00,0x4b,0xa9,0x0b)
#endif
#else
typedef struct IInternetSecurityManagerVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IInternetSecurityManager* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IInternetSecurityManager* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IInternetSecurityManager* This);

    /*** IInternetSecurityManager methods ***/
    HRESULT (STDMETHODCALLTYPE *SetSecuritySite)(
        IInternetSecurityManager* This,
        IInternetSecurityMgrSite *pSite);

    HRESULT (STDMETHODCALLTYPE *GetSecuritySite)(
        IInternetSecurityManager* This,
        IInternetSecurityMgrSite **ppSite);

    HRESULT (STDMETHODCALLTYPE *MapUrlToZone)(
        IInternetSecurityManager* This,
        LPCWSTR pwszUrl,
        DWORD *pdwZone,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *GetSecurityId)(
        IInternetSecurityManager* This,
        LPCWSTR pwszUrl,
        BYTE *pbSecurityId,
        DWORD *pcbSecurityId,
        DWORD_PTR dwReserved);

    HRESULT (STDMETHODCALLTYPE *ProcessUrlAction)(
        IInternetSecurityManager* This,
        LPCWSTR pwszUrl,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved);

    HRESULT (STDMETHODCALLTYPE *QueryCustomPolicy)(
        IInternetSecurityManager* This,
        LPCWSTR pwszUrl,
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwReserved);

    HRESULT (STDMETHODCALLTYPE *SetZoneMapping)(
        IInternetSecurityManager* This,
        DWORD dwZone,
        LPCWSTR lpszPattern,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *GetZoneMappings)(
        IInternetSecurityManager* This,
        DWORD dwZone,
        IEnumString **ppenumString,
        DWORD dwFlags);

    END_INTERFACE
} IInternetSecurityManagerVtbl;
interface IInternetSecurityManager {
    CONST_VTBL IInternetSecurityManagerVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IInternetSecurityManager_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IInternetSecurityManager_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IInternetSecurityManager_Release(This) (This)->lpVtbl->Release(This)
/*** IInternetSecurityManager methods ***/
#define IInternetSecurityManager_SetSecuritySite(This,pSite) (This)->lpVtbl->SetSecuritySite(This,pSite)
#define IInternetSecurityManager_GetSecuritySite(This,ppSite) (This)->lpVtbl->GetSecuritySite(This,ppSite)
#define IInternetSecurityManager_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) (This)->lpVtbl->MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)
#define IInternetSecurityManager_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) (This)->lpVtbl->GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)
#define IInternetSecurityManager_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) (This)->lpVtbl->ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)
#define IInternetSecurityManager_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) (This)->lpVtbl->QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)
#define IInternetSecurityManager_SetZoneMapping(This,dwZone,lpszPattern,dwFlags) (This)->lpVtbl->SetZoneMapping(This,dwZone,lpszPattern,dwFlags)
#define IInternetSecurityManager_GetZoneMappings(This,dwZone,ppenumString,dwFlags) (This)->lpVtbl->GetZoneMappings(This,dwZone,ppenumString,dwFlags)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IInternetSecurityManager_QueryInterface(IInternetSecurityManager* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IInternetSecurityManager_AddRef(IInternetSecurityManager* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IInternetSecurityManager_Release(IInternetSecurityManager* This) {
    return This->lpVtbl->Release(This);
}
/*** IInternetSecurityManager methods ***/
static FORCEINLINE HRESULT IInternetSecurityManager_SetSecuritySite(IInternetSecurityManager* This,IInternetSecurityMgrSite *pSite) {
    return This->lpVtbl->SetSecuritySite(This,pSite);
}
static FORCEINLINE HRESULT IInternetSecurityManager_GetSecuritySite(IInternetSecurityManager* This,IInternetSecurityMgrSite **ppSite) {
    return This->lpVtbl->GetSecuritySite(This,ppSite);
}
static FORCEINLINE HRESULT IInternetSecurityManager_MapUrlToZone(IInternetSecurityManager* This,LPCWSTR pwszUrl,DWORD *pdwZone,DWORD dwFlags) {
    return This->lpVtbl->MapUrlToZone(This,pwszUrl,pdwZone,dwFlags);
}
static FORCEINLINE HRESULT IInternetSecurityManager_GetSecurityId(IInternetSecurityManager* This,LPCWSTR pwszUrl,BYTE *pbSecurityId,DWORD *pcbSecurityId,DWORD_PTR dwReserved) {
    return This->lpVtbl->GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved);
}
static FORCEINLINE HRESULT IInternetSecurityManager_ProcessUrlAction(IInternetSecurityManager* This,LPCWSTR pwszUrl,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,BYTE *pContext,DWORD cbContext,DWORD dwFlags,DWORD dwReserved) {
    return This->lpVtbl->ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved);
}
static FORCEINLINE HRESULT IInternetSecurityManager_QueryCustomPolicy(IInternetSecurityManager* This,LPCWSTR pwszUrl,REFGUID guidKey,BYTE **ppPolicy,DWORD *pcbPolicy,BYTE *pContext,DWORD cbContext,DWORD dwReserved) {
    return This->lpVtbl->QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved);
}
static FORCEINLINE HRESULT IInternetSecurityManager_SetZoneMapping(IInternetSecurityManager* This,DWORD dwZone,LPCWSTR lpszPattern,DWORD dwFlags) {
    return This->lpVtbl->SetZoneMapping(This,dwZone,lpszPattern,dwFlags);
}
static FORCEINLINE HRESULT IInternetSecurityManager_GetZoneMappings(IInternetSecurityManager* This,DWORD dwZone,IEnumString **ppenumString,DWORD dwFlags) {
    return This->lpVtbl->GetZoneMappings(This,dwZone,ppenumString,dwFlags);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IInternetSecurityManager_SetSecuritySite_Proxy(
    IInternetSecurityManager* This,
    IInternetSecurityMgrSite *pSite);
void __RPC_STUB IInternetSecurityManager_SetSecuritySite_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetSecurityManager_GetSecuritySite_Proxy(
    IInternetSecurityManager* This,
    IInternetSecurityMgrSite **ppSite);
void __RPC_STUB IInternetSecurityManager_GetSecuritySite_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetSecurityManager_MapUrlToZone_Proxy(
    IInternetSecurityManager* This,
    LPCWSTR pwszUrl,
    DWORD *pdwZone,
    DWORD dwFlags);
void __RPC_STUB IInternetSecurityManager_MapUrlToZone_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetSecurityManager_GetSecurityId_Proxy(
    IInternetSecurityManager* This,
    LPCWSTR pwszUrl,
    BYTE *pbSecurityId,
    DWORD *pcbSecurityId,
    DWORD_PTR dwReserved);
void __RPC_STUB IInternetSecurityManager_GetSecurityId_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetSecurityManager_ProcessUrlAction_Proxy(
    IInternetSecurityManager* This,
    LPCWSTR pwszUrl,
    DWORD dwAction,
    BYTE *pPolicy,
    DWORD cbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwFlags,
    DWORD dwReserved);
void __RPC_STUB IInternetSecurityManager_ProcessUrlAction_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetSecurityManager_QueryCustomPolicy_Proxy(
    IInternetSecurityManager* This,
    LPCWSTR pwszUrl,
    REFGUID guidKey,
    BYTE **ppPolicy,
    DWORD *pcbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwReserved);
void __RPC_STUB IInternetSecurityManager_QueryCustomPolicy_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetSecurityManager_SetZoneMapping_Proxy(
    IInternetSecurityManager* This,
    DWORD dwZone,
    LPCWSTR lpszPattern,
    DWORD dwFlags);
void __RPC_STUB IInternetSecurityManager_SetZoneMapping_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetSecurityManager_GetZoneMappings_Proxy(
    IInternetSecurityManager* This,
    DWORD dwZone,
    IEnumString **ppenumString,
    DWORD dwFlags);
void __RPC_STUB IInternetSecurityManager_GetZoneMappings_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IInternetSecurityManager_INTERFACE_DEFINED__ */

#endif

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETSECURITYMANANGEREX_DEFINED
#define _LPINTERNETSECURITYMANANGEREX_DEFINED

/*****************************************************************************
 * IInternetSecurityManagerEx interface
 */
#ifndef __IInternetSecurityManagerEx_INTERFACE_DEFINED__
#define __IInternetSecurityManagerEx_INTERFACE_DEFINED__

DEFINE_GUID(IID_IInternetSecurityManagerEx, 0xf164edf1, 0xcc7c, 0x4f0d, 0x9a,0x94, 0x34,0x22,0x26,0x25,0xc3,0x93);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("f164edf1-cc7c-4f0d-9a94-34222625c393")
IInternetSecurityManagerEx : public IInternetSecurityManager
{
    virtual HRESULT STDMETHODCALLTYPE ProcessUrlActionEx(
        LPCWSTR pwszUrl,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved,
        DWORD *pdwOutFlags) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IInternetSecurityManagerEx, 0xf164edf1, 0xcc7c, 0x4f0d, 0x9a,0x94, 0x34,0x22,0x26,0x25,0xc3,0x93)
#endif
#else
typedef struct IInternetSecurityManagerExVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IInternetSecurityManagerEx* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IInternetSecurityManagerEx* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IInternetSecurityManagerEx* This);

    /*** IInternetSecurityManager methods ***/
    HRESULT (STDMETHODCALLTYPE *SetSecuritySite)(
        IInternetSecurityManagerEx* This,
        IInternetSecurityMgrSite *pSite);

    HRESULT (STDMETHODCALLTYPE *GetSecuritySite)(
        IInternetSecurityManagerEx* This,
        IInternetSecurityMgrSite **ppSite);

    HRESULT (STDMETHODCALLTYPE *MapUrlToZone)(
        IInternetSecurityManagerEx* This,
        LPCWSTR pwszUrl,
        DWORD *pdwZone,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *GetSecurityId)(
        IInternetSecurityManagerEx* This,
        LPCWSTR pwszUrl,
        BYTE *pbSecurityId,
        DWORD *pcbSecurityId,
        DWORD_PTR dwReserved);

    HRESULT (STDMETHODCALLTYPE *ProcessUrlAction)(
        IInternetSecurityManagerEx* This,
        LPCWSTR pwszUrl,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved);

    HRESULT (STDMETHODCALLTYPE *QueryCustomPolicy)(
        IInternetSecurityManagerEx* This,
        LPCWSTR pwszUrl,
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwReserved);

    HRESULT (STDMETHODCALLTYPE *SetZoneMapping)(
        IInternetSecurityManagerEx* This,
        DWORD dwZone,
        LPCWSTR lpszPattern,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *GetZoneMappings)(
        IInternetSecurityManagerEx* This,
        DWORD dwZone,
        IEnumString **ppenumString,
        DWORD dwFlags);

    /*** IInternetSecurityManagerEx methods ***/
    HRESULT (STDMETHODCALLTYPE *ProcessUrlActionEx)(
        IInternetSecurityManagerEx* This,
        LPCWSTR pwszUrl,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved,
        DWORD *pdwOutFlags);

    END_INTERFACE
} IInternetSecurityManagerExVtbl;
interface IInternetSecurityManagerEx {
    CONST_VTBL IInternetSecurityManagerExVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IInternetSecurityManagerEx_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IInternetSecurityManagerEx_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IInternetSecurityManagerEx_Release(This) (This)->lpVtbl->Release(This)
/*** IInternetSecurityManager methods ***/
#define IInternetSecurityManagerEx_SetSecuritySite(This,pSite) (This)->lpVtbl->SetSecuritySite(This,pSite)
#define IInternetSecurityManagerEx_GetSecuritySite(This,ppSite) (This)->lpVtbl->GetSecuritySite(This,ppSite)
#define IInternetSecurityManagerEx_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) (This)->lpVtbl->MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)
#define IInternetSecurityManagerEx_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) (This)->lpVtbl->GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)
#define IInternetSecurityManagerEx_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) (This)->lpVtbl->ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)
#define IInternetSecurityManagerEx_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) (This)->lpVtbl->QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)
#define IInternetSecurityManagerEx_SetZoneMapping(This,dwZone,lpszPattern,dwFlags) (This)->lpVtbl->SetZoneMapping(This,dwZone,lpszPattern,dwFlags)
#define IInternetSecurityManagerEx_GetZoneMappings(This,dwZone,ppenumString,dwFlags) (This)->lpVtbl->GetZoneMappings(This,dwZone,ppenumString,dwFlags)
/*** IInternetSecurityManagerEx methods ***/
#define IInternetSecurityManagerEx_ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) (This)->lpVtbl->ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IInternetSecurityManagerEx_QueryInterface(IInternetSecurityManagerEx* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IInternetSecurityManagerEx_AddRef(IInternetSecurityManagerEx* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IInternetSecurityManagerEx_Release(IInternetSecurityManagerEx* This) {
    return This->lpVtbl->Release(This);
}
/*** IInternetSecurityManager methods ***/
static FORCEINLINE HRESULT IInternetSecurityManagerEx_SetSecuritySite(IInternetSecurityManagerEx* This,IInternetSecurityMgrSite *pSite) {
    return This->lpVtbl->SetSecuritySite(This,pSite);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx_GetSecuritySite(IInternetSecurityManagerEx* This,IInternetSecurityMgrSite **ppSite) {
    return This->lpVtbl->GetSecuritySite(This,ppSite);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx_MapUrlToZone(IInternetSecurityManagerEx* This,LPCWSTR pwszUrl,DWORD *pdwZone,DWORD dwFlags) {
    return This->lpVtbl->MapUrlToZone(This,pwszUrl,pdwZone,dwFlags);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx_GetSecurityId(IInternetSecurityManagerEx* This,LPCWSTR pwszUrl,BYTE *pbSecurityId,DWORD *pcbSecurityId,DWORD_PTR dwReserved) {
    return This->lpVtbl->GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx_ProcessUrlAction(IInternetSecurityManagerEx* This,LPCWSTR pwszUrl,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,BYTE *pContext,DWORD cbContext,DWORD dwFlags,DWORD dwReserved) {
    return This->lpVtbl->ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx_QueryCustomPolicy(IInternetSecurityManagerEx* This,LPCWSTR pwszUrl,REFGUID guidKey,BYTE **ppPolicy,DWORD *pcbPolicy,BYTE *pContext,DWORD cbContext,DWORD dwReserved) {
    return This->lpVtbl->QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx_SetZoneMapping(IInternetSecurityManagerEx* This,DWORD dwZone,LPCWSTR lpszPattern,DWORD dwFlags) {
    return This->lpVtbl->SetZoneMapping(This,dwZone,lpszPattern,dwFlags);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx_GetZoneMappings(IInternetSecurityManagerEx* This,DWORD dwZone,IEnumString **ppenumString,DWORD dwFlags) {
    return This->lpVtbl->GetZoneMappings(This,dwZone,ppenumString,dwFlags);
}
/*** IInternetSecurityManagerEx methods ***/
static FORCEINLINE HRESULT IInternetSecurityManagerEx_ProcessUrlActionEx(IInternetSecurityManagerEx* This,LPCWSTR pwszUrl,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,BYTE *pContext,DWORD cbContext,DWORD dwFlags,DWORD dwReserved,DWORD *pdwOutFlags) {
    return This->lpVtbl->ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IInternetSecurityManagerEx_ProcessUrlActionEx_Proxy(
    IInternetSecurityManagerEx* This,
    LPCWSTR pwszUrl,
    DWORD dwAction,
    BYTE *pPolicy,
    DWORD cbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwFlags,
    DWORD dwReserved,
    DWORD *pdwOutFlags);
void __RPC_STUB IInternetSecurityManagerEx_ProcessUrlActionEx_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IInternetSecurityManagerEx_INTERFACE_DEFINED__ */

#endif
#endif

#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPINTERNETSECURITYMANANGEREx2_DEFINED
#define _LPINTERNETSECURITYMANANGEREx2_DEFINED

/*****************************************************************************
 * IInternetSecurityManagerEx2 interface
 */
#ifndef __IInternetSecurityManagerEx2_INTERFACE_DEFINED__
#define __IInternetSecurityManagerEx2_INTERFACE_DEFINED__

DEFINE_GUID(IID_IInternetSecurityManagerEx2, 0xf1e50292, 0xa795, 0x4117, 0x8e,0x09, 0x2b,0x56,0x0a,0x72,0xac,0x60);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("f1e50292-a795-4117-8e09-2b560a72ac60")
IInternetSecurityManagerEx2 : public IInternetSecurityManagerEx
{
    virtual HRESULT STDMETHODCALLTYPE MapUrlToZoneEx2(
        IUri *pUri,
        DWORD *pdwZone,
        DWORD dwFlags,
        LPWSTR *ppwszMappedUrl,
        DWORD *pdwOutFlags) = 0;

    virtual HRESULT STDMETHODCALLTYPE ProcessUrlActionEx2(
        IUri *pUri,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD_PTR dwReserved,
        DWORD *pdwOutFlags) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetSecurityIdEx2(
        IUri *pUri,
        BYTE *pbSecurityId,
        DWORD *pcbSecurityId,
        DWORD_PTR dwReserved) = 0;

    virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicyEx2(
        IUri *pUri,
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD_PTR dwReserved) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IInternetSecurityManagerEx2, 0xf1e50292, 0xa795, 0x4117, 0x8e,0x09, 0x2b,0x56,0x0a,0x72,0xac,0x60)
#endif
#else
typedef struct IInternetSecurityManagerEx2Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IInternetSecurityManagerEx2* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IInternetSecurityManagerEx2* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IInternetSecurityManagerEx2* This);

    /*** IInternetSecurityManager methods ***/
    HRESULT (STDMETHODCALLTYPE *SetSecuritySite)(
        IInternetSecurityManagerEx2* This,
        IInternetSecurityMgrSite *pSite);

    HRESULT (STDMETHODCALLTYPE *GetSecuritySite)(
        IInternetSecurityManagerEx2* This,
        IInternetSecurityMgrSite **ppSite);

    HRESULT (STDMETHODCALLTYPE *MapUrlToZone)(
        IInternetSecurityManagerEx2* This,
        LPCWSTR pwszUrl,
        DWORD *pdwZone,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *GetSecurityId)(
        IInternetSecurityManagerEx2* This,
        LPCWSTR pwszUrl,
        BYTE *pbSecurityId,
        DWORD *pcbSecurityId,
        DWORD_PTR dwReserved);

    HRESULT (STDMETHODCALLTYPE *ProcessUrlAction)(
        IInternetSecurityManagerEx2* This,
        LPCWSTR pwszUrl,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved);

    HRESULT (STDMETHODCALLTYPE *QueryCustomPolicy)(
        IInternetSecurityManagerEx2* This,
        LPCWSTR pwszUrl,
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwReserved);

    HRESULT (STDMETHODCALLTYPE *SetZoneMapping)(
        IInternetSecurityManagerEx2* This,
        DWORD dwZone,
        LPCWSTR lpszPattern,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *GetZoneMappings)(
        IInternetSecurityManagerEx2* This,
        DWORD dwZone,
        IEnumString **ppenumString,
        DWORD dwFlags);

    /*** IInternetSecurityManagerEx methods ***/
    HRESULT (STDMETHODCALLTYPE *ProcessUrlActionEx)(
        IInternetSecurityManagerEx2* This,
        LPCWSTR pwszUrl,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved,
        DWORD *pdwOutFlags);

    /*** IInternetSecurityManagerEx2 methods ***/
    HRESULT (STDMETHODCALLTYPE *MapUrlToZoneEx2)(
        IInternetSecurityManagerEx2* This,
        IUri *pUri,
        DWORD *pdwZone,
        DWORD dwFlags,
        LPWSTR *ppwszMappedUrl,
        DWORD *pdwOutFlags);

    HRESULT (STDMETHODCALLTYPE *ProcessUrlActionEx2)(
        IInternetSecurityManagerEx2* This,
        IUri *pUri,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD_PTR dwReserved,
        DWORD *pdwOutFlags);

    HRESULT (STDMETHODCALLTYPE *GetSecurityIdEx2)(
        IInternetSecurityManagerEx2* This,
        IUri *pUri,
        BYTE *pbSecurityId,
        DWORD *pcbSecurityId,
        DWORD_PTR dwReserved);

    HRESULT (STDMETHODCALLTYPE *QueryCustomPolicyEx2)(
        IInternetSecurityManagerEx2* This,
        IUri *pUri,
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD_PTR dwReserved);

    END_INTERFACE
} IInternetSecurityManagerEx2Vtbl;
interface IInternetSecurityManagerEx2 {
    CONST_VTBL IInternetSecurityManagerEx2Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IInternetSecurityManagerEx2_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IInternetSecurityManagerEx2_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IInternetSecurityManagerEx2_Release(This) (This)->lpVtbl->Release(This)
/*** IInternetSecurityManager methods ***/
#define IInternetSecurityManagerEx2_SetSecuritySite(This,pSite) (This)->lpVtbl->SetSecuritySite(This,pSite)
#define IInternetSecurityManagerEx2_GetSecuritySite(This,ppSite) (This)->lpVtbl->GetSecuritySite(This,ppSite)
#define IInternetSecurityManagerEx2_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) (This)->lpVtbl->MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)
#define IInternetSecurityManagerEx2_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) (This)->lpVtbl->GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)
#define IInternetSecurityManagerEx2_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) (This)->lpVtbl->ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)
#define IInternetSecurityManagerEx2_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) (This)->lpVtbl->QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)
#define IInternetSecurityManagerEx2_SetZoneMapping(This,dwZone,lpszPattern,dwFlags) (This)->lpVtbl->SetZoneMapping(This,dwZone,lpszPattern,dwFlags)
#define IInternetSecurityManagerEx2_GetZoneMappings(This,dwZone,ppenumString,dwFlags) (This)->lpVtbl->GetZoneMappings(This,dwZone,ppenumString,dwFlags)
/*** IInternetSecurityManagerEx methods ***/
#define IInternetSecurityManagerEx2_ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) (This)->lpVtbl->ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)
/*** IInternetSecurityManagerEx2 methods ***/
#define IInternetSecurityManagerEx2_MapUrlToZoneEx2(This,pUri,pdwZone,dwFlags,ppwszMappedUrl,pdwOutFlags) (This)->lpVtbl->MapUrlToZoneEx2(This,pUri,pdwZone,dwFlags,ppwszMappedUrl,pdwOutFlags)
#define IInternetSecurityManagerEx2_ProcessUrlActionEx2(This,pUri,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) (This)->lpVtbl->ProcessUrlActionEx2(This,pUri,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)
#define IInternetSecurityManagerEx2_GetSecurityIdEx2(This,pUri,pbSecurityId,pcbSecurityId,dwReserved) (This)->lpVtbl->GetSecurityIdEx2(This,pUri,pbSecurityId,pcbSecurityId,dwReserved)
#define IInternetSecurityManagerEx2_QueryCustomPolicyEx2(This,pUri,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) (This)->lpVtbl->QueryCustomPolicyEx2(This,pUri,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_QueryInterface(IInternetSecurityManagerEx2* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IInternetSecurityManagerEx2_AddRef(IInternetSecurityManagerEx2* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IInternetSecurityManagerEx2_Release(IInternetSecurityManagerEx2* This) {
    return This->lpVtbl->Release(This);
}
/*** IInternetSecurityManager methods ***/
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_SetSecuritySite(IInternetSecurityManagerEx2* This,IInternetSecurityMgrSite *pSite) {
    return This->lpVtbl->SetSecuritySite(This,pSite);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_GetSecuritySite(IInternetSecurityManagerEx2* This,IInternetSecurityMgrSite **ppSite) {
    return This->lpVtbl->GetSecuritySite(This,ppSite);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_MapUrlToZone(IInternetSecurityManagerEx2* This,LPCWSTR pwszUrl,DWORD *pdwZone,DWORD dwFlags) {
    return This->lpVtbl->MapUrlToZone(This,pwszUrl,pdwZone,dwFlags);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_GetSecurityId(IInternetSecurityManagerEx2* This,LPCWSTR pwszUrl,BYTE *pbSecurityId,DWORD *pcbSecurityId,DWORD_PTR dwReserved) {
    return This->lpVtbl->GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_ProcessUrlAction(IInternetSecurityManagerEx2* This,LPCWSTR pwszUrl,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,BYTE *pContext,DWORD cbContext,DWORD dwFlags,DWORD dwReserved) {
    return This->lpVtbl->ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_QueryCustomPolicy(IInternetSecurityManagerEx2* This,LPCWSTR pwszUrl,REFGUID guidKey,BYTE **ppPolicy,DWORD *pcbPolicy,BYTE *pContext,DWORD cbContext,DWORD dwReserved) {
    return This->lpVtbl->QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_SetZoneMapping(IInternetSecurityManagerEx2* This,DWORD dwZone,LPCWSTR lpszPattern,DWORD dwFlags) {
    return This->lpVtbl->SetZoneMapping(This,dwZone,lpszPattern,dwFlags);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_GetZoneMappings(IInternetSecurityManagerEx2* This,DWORD dwZone,IEnumString **ppenumString,DWORD dwFlags) {
    return This->lpVtbl->GetZoneMappings(This,dwZone,ppenumString,dwFlags);
}
/*** IInternetSecurityManagerEx methods ***/
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_ProcessUrlActionEx(IInternetSecurityManagerEx2* This,LPCWSTR pwszUrl,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,BYTE *pContext,DWORD cbContext,DWORD dwFlags,DWORD dwReserved,DWORD *pdwOutFlags) {
    return This->lpVtbl->ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags);
}
/*** IInternetSecurityManagerEx2 methods ***/
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_MapUrlToZoneEx2(IInternetSecurityManagerEx2* This,IUri *pUri,DWORD *pdwZone,DWORD dwFlags,LPWSTR *ppwszMappedUrl,DWORD *pdwOutFlags) {
    return This->lpVtbl->MapUrlToZoneEx2(This,pUri,pdwZone,dwFlags,ppwszMappedUrl,pdwOutFlags);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_ProcessUrlActionEx2(IInternetSecurityManagerEx2* This,IUri *pUri,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,BYTE *pContext,DWORD cbContext,DWORD dwFlags,DWORD_PTR dwReserved,DWORD *pdwOutFlags) {
    return This->lpVtbl->ProcessUrlActionEx2(This,pUri,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_GetSecurityIdEx2(IInternetSecurityManagerEx2* This,IUri *pUri,BYTE *pbSecurityId,DWORD *pcbSecurityId,DWORD_PTR dwReserved) {
    return This->lpVtbl->GetSecurityIdEx2(This,pUri,pbSecurityId,pcbSecurityId,dwReserved);
}
static FORCEINLINE HRESULT IInternetSecurityManagerEx2_QueryCustomPolicyEx2(IInternetSecurityManagerEx2* This,IUri *pUri,REFGUID guidKey,BYTE **ppPolicy,DWORD *pcbPolicy,BYTE *pContext,DWORD cbContext,DWORD_PTR dwReserved) {
    return This->lpVtbl->QueryCustomPolicyEx2(This,pUri,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IInternetSecurityManagerEx2_MapUrlToZoneEx2_Proxy(
    IInternetSecurityManagerEx2* This,
    IUri *pUri,
    DWORD *pdwZone,
    DWORD dwFlags,
    LPWSTR *ppwszMappedUrl,
    DWORD *pdwOutFlags);
void __RPC_STUB IInternetSecurityManagerEx2_MapUrlToZoneEx2_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetSecurityManagerEx2_ProcessUrlActionEx2_Proxy(
    IInternetSecurityManagerEx2* This,
    IUri *pUri,
    DWORD dwAction,
    BYTE *pPolicy,
    DWORD cbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwFlags,
    DWORD_PTR dwReserved,
    DWORD *pdwOutFlags);
void __RPC_STUB IInternetSecurityManagerEx2_ProcessUrlActionEx2_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetSecurityManagerEx2_GetSecurityIdEx2_Proxy(
    IInternetSecurityManagerEx2* This,
    IUri *pUri,
    BYTE *pbSecurityId,
    DWORD *pcbSecurityId,
    DWORD_PTR dwReserved);
void __RPC_STUB IInternetSecurityManagerEx2_GetSecurityIdEx2_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetSecurityManagerEx2_QueryCustomPolicyEx2_Proxy(
    IInternetSecurityManagerEx2* This,
    IUri *pUri,
    REFGUID guidKey,
    BYTE **ppPolicy,
    DWORD *pcbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD_PTR dwReserved);
void __RPC_STUB IInternetSecurityManagerEx2_QueryCustomPolicyEx2_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IInternetSecurityManagerEx2_INTERFACE_DEFINED__ */

#endif
#endif

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
/*****************************************************************************
 * IZoneIdentifier interface
 */
#ifndef __IZoneIdentifier_INTERFACE_DEFINED__
#define __IZoneIdentifier_INTERFACE_DEFINED__

DEFINE_GUID(IID_IZoneIdentifier, 0xcd45f185, 0x1b21, 0x48e2, 0x96,0x7b, 0xea,0xd7,0x43,0xa8,0x91,0x4e);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("cd45f185-1b21-48e2-967b-ead743a8914e")
IZoneIdentifier : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetId(
        DWORD *pdwZone) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetId(
        DWORD dwZone) = 0;

    virtual HRESULT STDMETHODCALLTYPE Remove(
        ) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IZoneIdentifier, 0xcd45f185, 0x1b21, 0x48e2, 0x96,0x7b, 0xea,0xd7,0x43,0xa8,0x91,0x4e)
#endif
#else
typedef struct IZoneIdentifierVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IZoneIdentifier* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IZoneIdentifier* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IZoneIdentifier* This);

    /*** IZoneIdentifier methods ***/
    HRESULT (STDMETHODCALLTYPE *GetId)(
        IZoneIdentifier* This,
        DWORD *pdwZone);

    HRESULT (STDMETHODCALLTYPE *SetId)(
        IZoneIdentifier* This,
        DWORD dwZone);

    HRESULT (STDMETHODCALLTYPE *Remove)(
        IZoneIdentifier* This);

    END_INTERFACE
} IZoneIdentifierVtbl;
interface IZoneIdentifier {
    CONST_VTBL IZoneIdentifierVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IZoneIdentifier_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IZoneIdentifier_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IZoneIdentifier_Release(This) (This)->lpVtbl->Release(This)
/*** IZoneIdentifier methods ***/
#define IZoneIdentifier_GetId(This,pdwZone) (This)->lpVtbl->GetId(This,pdwZone)
#define IZoneIdentifier_SetId(This,dwZone) (This)->lpVtbl->SetId(This,dwZone)
#define IZoneIdentifier_Remove(This) (This)->lpVtbl->Remove(This)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IZoneIdentifier_QueryInterface(IZoneIdentifier* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IZoneIdentifier_AddRef(IZoneIdentifier* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IZoneIdentifier_Release(IZoneIdentifier* This) {
    return This->lpVtbl->Release(This);
}
/*** IZoneIdentifier methods ***/
static FORCEINLINE HRESULT IZoneIdentifier_GetId(IZoneIdentifier* This,DWORD *pdwZone) {
    return This->lpVtbl->GetId(This,pdwZone);
}
static FORCEINLINE HRESULT IZoneIdentifier_SetId(IZoneIdentifier* This,DWORD dwZone) {
    return This->lpVtbl->SetId(This,dwZone);
}
static FORCEINLINE HRESULT IZoneIdentifier_Remove(IZoneIdentifier* This) {
    return This->lpVtbl->Remove(This);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IZoneIdentifier_GetId_Proxy(
    IZoneIdentifier* This,
    DWORD *pdwZone);
void __RPC_STUB IZoneIdentifier_GetId_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IZoneIdentifier_SetId_Proxy(
    IZoneIdentifier* This,
    DWORD dwZone);
void __RPC_STUB IZoneIdentifier_SetId_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IZoneIdentifier_Remove_Proxy(
    IZoneIdentifier* This);
void __RPC_STUB IZoneIdentifier_Remove_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IZoneIdentifier_INTERFACE_DEFINED__ */

#endif

#ifndef _LPINTERNETHOSTSECURITYMANANGER_DEFINED
#define _LPINTERNETHOSTSECURITYMANANGER_DEFINED

/*****************************************************************************
 * IInternetHostSecurityManager interface
 */
#ifndef __IInternetHostSecurityManager_INTERFACE_DEFINED__
#define __IInternetHostSecurityManager_INTERFACE_DEFINED__

DEFINE_GUID(IID_IInternetHostSecurityManager, 0x3af280b6, 0xcb3f, 0x11d0, 0x89,0x1e, 0x00,0xc0,0x4f,0xb6,0xbf,0xc4);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("3af280b6-cb3f-11d0-891e-00c04fb6bfc4")
IInternetHostSecurityManager : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetSecurityId(
        BYTE *pbSecurityId,
        DWORD *pcbSecurityId,
        DWORD_PTR dwReserved) = 0;

    virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction(
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved) = 0;

    virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy(
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwReserved) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IInternetHostSecurityManager, 0x3af280b6, 0xcb3f, 0x11d0, 0x89,0x1e, 0x00,0xc0,0x4f,0xb6,0xbf,0xc4)
#endif
#else
typedef struct IInternetHostSecurityManagerVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IInternetHostSecurityManager* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IInternetHostSecurityManager* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IInternetHostSecurityManager* This);

    /*** IInternetHostSecurityManager methods ***/
    HRESULT (STDMETHODCALLTYPE *GetSecurityId)(
        IInternetHostSecurityManager* This,
        BYTE *pbSecurityId,
        DWORD *pcbSecurityId,
        DWORD_PTR dwReserved);

    HRESULT (STDMETHODCALLTYPE *ProcessUrlAction)(
        IInternetHostSecurityManager* This,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwFlags,
        DWORD dwReserved);

    HRESULT (STDMETHODCALLTYPE *QueryCustomPolicy)(
        IInternetHostSecurityManager* This,
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        BYTE *pContext,
        DWORD cbContext,
        DWORD dwReserved);

    END_INTERFACE
} IInternetHostSecurityManagerVtbl;
interface IInternetHostSecurityManager {
    CONST_VTBL IInternetHostSecurityManagerVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IInternetHostSecurityManager_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IInternetHostSecurityManager_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IInternetHostSecurityManager_Release(This) (This)->lpVtbl->Release(This)
/*** IInternetHostSecurityManager methods ***/
#define IInternetHostSecurityManager_GetSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved) (This)->lpVtbl->GetSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)
#define IInternetHostSecurityManager_ProcessUrlAction(This,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) (This)->lpVtbl->ProcessUrlAction(This,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)
#define IInternetHostSecurityManager_QueryCustomPolicy(This,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) (This)->lpVtbl->QueryCustomPolicy(This,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IInternetHostSecurityManager_QueryInterface(IInternetHostSecurityManager* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IInternetHostSecurityManager_AddRef(IInternetHostSecurityManager* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IInternetHostSecurityManager_Release(IInternetHostSecurityManager* This) {
    return This->lpVtbl->Release(This);
}
/*** IInternetHostSecurityManager methods ***/
static FORCEINLINE HRESULT IInternetHostSecurityManager_GetSecurityId(IInternetHostSecurityManager* This,BYTE *pbSecurityId,DWORD *pcbSecurityId,DWORD_PTR dwReserved) {
    return This->lpVtbl->GetSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved);
}
static FORCEINLINE HRESULT IInternetHostSecurityManager_ProcessUrlAction(IInternetHostSecurityManager* This,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,BYTE *pContext,DWORD cbContext,DWORD dwFlags,DWORD dwReserved) {
    return This->lpVtbl->ProcessUrlAction(This,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved);
}
static FORCEINLINE HRESULT IInternetHostSecurityManager_QueryCustomPolicy(IInternetHostSecurityManager* This,REFGUID guidKey,BYTE **ppPolicy,DWORD *pcbPolicy,BYTE *pContext,DWORD cbContext,DWORD dwReserved) {
    return This->lpVtbl->QueryCustomPolicy(This,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IInternetHostSecurityManager_GetSecurityId_Proxy(
    IInternetHostSecurityManager* This,
    BYTE *pbSecurityId,
    DWORD *pcbSecurityId,
    DWORD_PTR dwReserved);
void __RPC_STUB IInternetHostSecurityManager_GetSecurityId_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetHostSecurityManager_ProcessUrlAction_Proxy(
    IInternetHostSecurityManager* This,
    DWORD dwAction,
    BYTE *pPolicy,
    DWORD cbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwFlags,
    DWORD dwReserved);
void __RPC_STUB IInternetHostSecurityManager_ProcessUrlAction_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetHostSecurityManager_QueryCustomPolicy_Proxy(
    IInternetHostSecurityManager* This,
    REFGUID guidKey,
    BYTE **ppPolicy,
    DWORD *pcbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwReserved);
void __RPC_STUB IInternetHostSecurityManager_QueryCustomPolicy_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IInternetHostSecurityManager_INTERFACE_DEFINED__ */

#endif

#define URLACTION_MIN 0x1000

#define URLACTION_DOWNLOAD_MIN 0x1000
#define URLACTION_DOWNLOAD_SIGNED_ACTIVEX 0x1001
#define URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX 0x1004
#define URLACTION_DOWNLOAD_CURR_MAX 0x1004
#define URLACTION_DOWNLOAD_MAX 0x11FF

#define URLACTION_ACTIVEX_MIN 0x1200
#define URLACTION_ACTIVEX_RUN 0x1200
#define URLPOLICY_ACTIVEX_CHECK_LIST 0x10000
#define URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY 0x1201
#define URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY 0x1202
#define URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY 0x1203
#define URLACTION_SCRIPT_OVERRIDE_SAFETY 0x1401
#define URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY 0x1204
#define URLACTION_ACTIVEX_TREATASUNTRUSTED 0x1205
#define URLACTION_ACTIVEX_NO_WEBOC_SCRIPT 0x1206
#define URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION 0x1207
#define URLACTION_ACTIVEX_OVERRIDE_OPTIN 0x1208
#define URLACTION_ACTIVEX_SCRIPTLET_RUN 0x1209
#define URLACTION_ACTIVEX_DYNSRC_VIDEO_AND_ANIMATION 0x120A
#define URLACTION_ACTIVEX_OVERRIDE_DOMAINLIST 0x120B
#define URLACTION_ACTIVEX_CURR_MAX 0x120B
#define URLACTION_ACTIVEX_MAX 0x13ff

#define URLACTION_SCRIPT_MIN 0x1400
#define URLACTION_SCRIPT_RUN 0x1400
#define URLACTION_SCRIPT_JAVA_USE 0x1402
#define URLACTION_SCRIPT_SAFE_ACTIVEX 0x1405
#define URLACTION_CROSS_DOMAIN_DATA 0x1406
#define URLACTION_SCRIPT_PASTE 0x1407
#define URLACTION_ALLOW_XDOMAIN_SUBFRAME_RESIZE 0x1408
#define URLACTION_SCRIPT_XSSFILTER 0x1409
#define URLACTION_SCRIPT_NAVIGATE 0x140A
#define URLACTION_PLUGGABLE_PROTOCOL_XHR 0x140B
#define URLACTION_SCRIPT_CURR_MAX 0x140B
#define URLACTION_SCRIPT_MAX 0x15ff

#define URLACTION_HTML_MIN 0x1600
#define URLACTION_HTML_SUBMIT_FORMS 0x1601
#define URLACTION_HTML_SUBMIT_FORMS_FROM 0x1602
#define URLACTION_HTML_SUBMIT_FORMS_TO 0x1603
#define URLACTION_HTML_FONT_DOWNLOAD 0x1604
#define URLACTION_HTML_JAVA_RUN 0x1605
#define URLACTION_HTML_USERDATA_SAVE 0x1606
#define URLACTION_HTML_SUBFRAME_NAVIGATE 0x1607
#define URLACTION_HTML_META_REFRESH 0x1608
#define URLACTION_HTML_MIXED_CONTENT 0x1609
#define URLACTION_HTML_INCLUDE_FILE_PATH 0x160A
#define URLACTION_HTML_ALLOW_INJECTED_DYNAMIC_HTML 0x160B
#define URLACTION_HTML_REQUIRE_UTF8_DOCUMENT_CODEPAGE 0x160C
#define URLACTION_HTML_ALLOW_CROSS_DOMAIN_CANVAS 0x160D
#define URLACTION_HTML_ALLOW_WINDOW_CLOSE 0x160E
#define URLACTION_HTML_ALLOW_CROSS_DOMAIN_WEBWORKER 0x160F
#define URLACTION_HTML_ALLOW_CROSS_DOMAIN_TEXTTRACK 0x1610
#define URLACTION_HTML_ALLOW_INDEXEDDB 0x1611

#define URLACTION_HTML_MAX 0x17ff

#define URLACTION_SHELL_MIN 0x1800
#define URLACTION_SHELL_INSTALL_DTITEMS 0x1800
#define URLACTION_SHELL_MOVE_OR_COPY 0x1802
#define URLACTION_SHELL_FILE_DOWNLOAD 0x1803
#define URLACTION_SHELL_VERB 0x1804
#define URLACTION_SHELL_WEBVIEW_VERB 0x1805
#define URLACTION_SHELL_SHELLEXECUTE 0x1806

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLACTION_SHELL_EXECUTE_HIGHRISK 0x1806
#define URLACTION_SHELL_EXECUTE_MODRISK 0x1807
#define URLACTION_SHELL_EXECUTE_LOWRISK 0x1808
#define URLACTION_SHELL_POPUPMGR 0x1809
#define URLACTION_SHELL_RTF_OBJECTS_LOAD 0x180A
#define URLACTION_SHELL_ENHANCED_DRAGDROP_SECURITY 0x180B
#define URLACTION_SHELL_EXTENSIONSECURITY 0x180C
#define URLACTION_SHELL_SECURE_DRAGSOURCE 0x180D
#endif
#if (_WIN32_IE >= _WIN32_IE_WIN7)
#define URLACTION_SHELL_REMOTEQUERY 0x180E
#define URLACTION_SHELL_PREVIEW 0x180F
#define URLACTION_SHELL_SHARE 0x1810
#define URLACTION_SHELL_ALLOW_CROSS_SITE_SHARE 0x1811
#endif
#define URLACTION_SHELL_CURR_MAX 0x1811
#define URLACTION_SHELL_MAX 0x19ff

#define URLACTION_NETWORK_MIN 0x1A00

#define URLACTION_CREDENTIALS_USE 0x1A00
#define URLPOLICY_CREDENTIALS_SILENT_LOGON_OK 0x0
#define URLPOLICY_CREDENTIALS_MUST_PROMPT_USER 0x10000
#define URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT 0x20000
#define URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY 0x30000

#define URLACTION_AUTHENTICATE_CLIENT 0x1A01
#define URLPOLICY_AUTHENTICATE_CLEARTEXT_OK 0x0
#define URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE 0x10000
#define URLPOLICY_AUTHENTICATE_MUTUAL_ONLY 0x30000

#define URLACTION_COOKIES 0x1A02
#define URLACTION_COOKIES_SESSION 0x1A03

#define URLACTION_CLIENT_CERT_PROMPT 0x1A04

#define URLACTION_COOKIES_THIRD_PARTY 0x1A05
#define URLACTION_COOKIES_SESSION_THIRD_PARTY 0x1A06

#define URLACTION_COOKIES_ENABLED 0x1A10

#define URLACTION_NETWORK_CURR_MAX 0x1A10
#define URLACTION_NETWORK_MAX 0x1Bff

#define URLACTION_JAVA_MIN 0x1C00
#define URLACTION_JAVA_PERMISSIONS 0x1C00
#define URLPOLICY_JAVA_PROHIBIT 0x0
#define URLPOLICY_JAVA_HIGH 0x10000
#define URLPOLICY_JAVA_MEDIUM 0x20000
#define URLPOLICY_JAVA_LOW 0x30000
#define URLPOLICY_JAVA_CUSTOM 0x800000
#define URLACTION_JAVA_CURR_MAX 0x1C00
#define URLACTION_JAVA_MAX 0x1Cff

#define URLACTION_INFODELIVERY_MIN 0x1D00
#define URLACTION_INFODELIVERY_NO_ADDING_CHANNELS 0x1D00
#define URLACTION_INFODELIVERY_NO_EDITING_CHANNELS 0x1D01
#define URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS 0x1D02
#define URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS 0x1D03
#define URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS 0x1D04
#define URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS 0x1D05
#define URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING 0x1D06
#define URLACTION_INFODELIVERY_CURR_MAX 0x1D06
#define URLACTION_INFODELIVERY_MAX 0x1Dff
#define URLACTION_CHANNEL_SOFTDIST_MIN 0x1E00
#define URLACTION_CHANNEL_SOFTDIST_PERMISSIONS 0x1E05
#define URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT 0x10000
#define URLPOLICY_CHANNEL_SOFTDIST_PRECACHE 0x20000
#define URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL 0x30000
#define URLACTION_CHANNEL_SOFTDIST_MAX 0x1Eff
#if (_WIN32_IE >= _WIN32_IE_IE80)
#define URLACTION_DOTNET_USERCONTROLS 0x2005
#endif

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLACTION_BEHAVIOR_MIN 0x2000
#define URLACTION_BEHAVIOR_RUN 0x2000
#define URLPOLICY_BEHAVIOR_CHECK_LIST 0x10000

#define URLACTION_FEATURE_MIN 0x2100
#define URLACTION_FEATURE_MIME_SNIFFING 0x2100
#define URLACTION_FEATURE_ZONE_ELEVATION 0x2101
#define URLACTION_FEATURE_WINDOW_RESTRICTIONS 0x2102
#define URLACTION_FEATURE_SCRIPT_STATUS_BAR 0x2103
#define URLACTION_FEATURE_FORCE_ADDR_AND_STATUS 0x2104
#define URLACTION_FEATURE_BLOCK_INPUT_PROMPTS 0x2105
#define URLACTION_FEATURE_DATA_BINDING 0x2106
#define URLACTION_FEATURE_CROSSDOMAIN_FOCUS_CHANGE 0x2107

#define URLACTION_AUTOMATIC_DOWNLOAD_UI_MIN 0x2200
#define URLACTION_AUTOMATIC_DOWNLOAD_UI 0x2200
#define URLACTION_AUTOMATIC_ACTIVEX_UI 0x2201

#define URLACTION_ALLOW_RESTRICTEDPROTOCOLS 0x2300
#endif
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define URLACTION_ALLOW_APEVALUATION 0x2301
#define URLACTION_ALLOW_XHR_EVALUATION 0x2302
#define URLACTION_WINDOWS_BROWSER_APPLICATIONS 0x2400
#define URLACTION_XPS_DOCUMENTS 0x2401
#define URLACTION_LOOSE_XAML 0x2402
#define URLACTION_LOWRIGHTS 0x2500
#define URLACTION_WINFX_SETUP 0x2600
#define URLACTION_INPRIVATE_BLOCKING 0x2700
#endif
#define URLACTION_ALLOW_AUDIO_VIDEO 0x2701
#define URLACTION_ALLOW_ACTIVEX_FILTERING 0x2702
#define URLACTION_ALLOW_STRUCTURED_STORAGE_SNIFFING 0x2703
#define URLACTION_ALLOW_AUDIO_VIDEO_PLUGINS 0x2704
#define URLACTION_ALLOW_ZONE_ELEVATION_VIA_OPT_OUT 0x2705
#define URLACTION_ALLOW_ZONE_ELEVATION_OPT_OUT_ADDITION 0x2706
#define URLACTION_ALLOW_CROSSDOMAIN_DROP_WITHIN_WINDOW 0x2708
#define URLACTION_ALLOW_CROSSDOMAIN_DROP_ACROSS_WINDOWS 0x2709
#define URLACTION_ALLOW_CROSSDOMAIN_APPCACHE_MANIFEST 0x270A
#define URLACTION_ALLOW_RENDER_LEGACY_DXTFILTERS 0x270B

#define URLPOLICY_ALLOW 0x0
#define URLPOLICY_QUERY 0x1
#define URLPOLICY_DISALLOW 0x3
#define URLPOLICY_NOTIFY_ON_ALLOW 0x10
#define URLPOLICY_NOTIFY_ON_DISALLOW 0x20
#define URLPOLICY_LOG_ON_ALLOW 0x40
#define URLPOLICY_LOG_ON_DISALLOW 0x80

#define URLPOLICY_MASK_PERMISSIONS 0x0f
#define GetUrlPolicyPermissions(dw) (dw & URLPOLICY_MASK_PERMISSIONS)
#define SetUrlPolicyPermissions(dw,dw2) ((dw) = ((dw) & ~(URLPOLICY_MASK_PERMISSIONS)) | (dw2))

#define URLPOLICY_DONTCHECKDLGBOX 0x100

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
EXTERN_C const GUID GUID_CUSTOM_LOCALMACHINEZONEUNLOCKED;
#endif

#ifndef _LPINTERNETZONEMANAGER_DEFINED
#define _LPINTERNETZONEMANAGER_DEFINED

/*****************************************************************************
 * IInternetZoneManager interface
 */
#ifndef __IInternetZoneManager_INTERFACE_DEFINED__
#define __IInternetZoneManager_INTERFACE_DEFINED__

typedef IInternetZoneManager *LPURLZONEMANAGER;

typedef enum tagURLZONE {
    URLZONE_INVALID = -1,
    URLZONE_PREDEFINED_MIN = 0,
    URLZONE_LOCAL_MACHINE = 0,
    URLZONE_INTRANET = 1,
    URLZONE_TRUSTED = 2,
    URLZONE_INTERNET = 3,
    URLZONE_UNTRUSTED = 4,
    URLZONE_PREDEFINED_MAX = 999,
    URLZONE_USER_MIN = 1000,
    URLZONE_USER_MAX = 10000
} URLZONE;

#define URLZONE_ESC_FLAG 0x100

typedef enum tagURLTEMPLATE {
    URLTEMPLATE_CUSTOM = 0x0,
    URLTEMPLATE_PREDEFINED_MIN = 0x10000,
    URLTEMPLATE_LOW = 0x10000,
    URLTEMPLATE_MEDLOW = 0x10500,
    URLTEMPLATE_MEDIUM = 0x11000,
    URLTEMPLATE_MEDHIGH = 0x11500,
    URLTEMPLATE_HIGH = 0x12000,
    URLTEMPLATE_PREDEFINED_MAX = 0x20000
} URLTEMPLATE;

enum {
    MAX_ZONE_PATH = 260,
    MAX_ZONE_DESCRIPTION = 200
};


typedef enum __WIDL_urlmon_generated_name_0000000F {
    ZAFLAGS_CUSTOM_EDIT = 0x1,
    ZAFLAGS_ADD_SITES = 0x2,
    ZAFLAGS_REQUIRE_VERIFICATION = 0x4,
    ZAFLAGS_INCLUDE_PROXY_OVERRIDE = 0x8,
    ZAFLAGS_INCLUDE_INTRANET_SITES = 0x10,
    ZAFLAGS_NO_UI = 0x20,
    ZAFLAGS_SUPPORTS_VERIFICATION = 0x40,
    ZAFLAGS_UNC_AS_INTRANET = 0x80,
    ZAFLAGS_DETECT_INTRANET = 0x100,
    ZAFLAGS_USE_LOCKED_ZONES = 0x10000,
    ZAFLAGS_VERIFY_TEMPLATE_SETTINGS = 0x20000,
    ZAFLAGS_NO_CACHE = 0x40000
} ZAFLAGS;

typedef struct _ZONEATTRIBUTES {
    ULONG cbSize;
    WCHAR szDisplayName[260];
    WCHAR szDescription[200];
    WCHAR szIconPath[260];
    DWORD dwTemplateMinLevel;
    DWORD dwTemplateRecommended;
    DWORD dwTemplateCurrentLevel;
    DWORD dwFlags;
} ZONEATTRIBUTES;
typedef struct _ZONEATTRIBUTES *LPZONEATTRIBUTES;


typedef enum _URLZONEREG {
    URLZONEREG_DEFAULT = 0,
    URLZONEREG_HKLM = 1,
    URLZONEREG_HKCU = 2
} URLZONEREG;

DEFINE_GUID(IID_IInternetZoneManager, 0x79eac9ef, 0xbaf9, 0x11ce, 0x8c,0x82, 0x00,0xaa,0x00,0x4b,0xa9,0x0b);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("79eac9ef-baf9-11ce-8c82-00aa004ba90b")
IInternetZoneManager : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetZoneAttributes(
        DWORD dwZone,
        ZONEATTRIBUTES *pZoneAttributes) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetZoneAttributes(
        DWORD dwZone,
        ZONEATTRIBUTES *pZoneAttributes) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetZoneCustomPolicy(
        DWORD dwZone,
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        URLZONEREG urlZoneReg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetZoneCustomPolicy(
        DWORD dwZone,
        REFGUID guidKey,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetZoneActionPolicy(
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetZoneActionPolicy(
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PromptAction(
        DWORD dwAction,
        HWND hwndParent,
        LPCWSTR pwszUrl,
        LPCWSTR pwszText,
        DWORD dwPromptFlags) = 0;

    virtual HRESULT STDMETHODCALLTYPE LogAction(
        DWORD dwAction,
        LPCWSTR pwszUrl,
        LPCWSTR pwszText,
        DWORD dwLogFlags) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateZoneEnumerator(
        DWORD *pdwEnum,
        DWORD *pdwCount,
        DWORD dwFlags) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetZoneAt(
        DWORD dwEnum,
        DWORD dwIndex,
        DWORD *pdwZone) = 0;

    virtual HRESULT STDMETHODCALLTYPE DestroyZoneEnumerator(
        DWORD dwEnum) = 0;

    virtual HRESULT STDMETHODCALLTYPE CopyTemplatePoliciesToZone(
        DWORD dwTemplate,
        DWORD dwZone,
        DWORD dwReserved) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IInternetZoneManager, 0x79eac9ef, 0xbaf9, 0x11ce, 0x8c,0x82, 0x00,0xaa,0x00,0x4b,0xa9,0x0b)
#endif
#else
typedef struct IInternetZoneManagerVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IInternetZoneManager* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IInternetZoneManager* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IInternetZoneManager* This);

    /*** IInternetZoneManager methods ***/
    HRESULT (STDMETHODCALLTYPE *GetZoneAttributes)(
        IInternetZoneManager* This,
        DWORD dwZone,
        ZONEATTRIBUTES *pZoneAttributes);

    HRESULT (STDMETHODCALLTYPE *SetZoneAttributes)(
        IInternetZoneManager* This,
        DWORD dwZone,
        ZONEATTRIBUTES *pZoneAttributes);

    HRESULT (STDMETHODCALLTYPE *GetZoneCustomPolicy)(
        IInternetZoneManager* This,
        DWORD dwZone,
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *SetZoneCustomPolicy)(
        IInternetZoneManager* This,
        DWORD dwZone,
        REFGUID guidKey,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *GetZoneActionPolicy)(
        IInternetZoneManager* This,
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *SetZoneActionPolicy)(
        IInternetZoneManager* This,
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *PromptAction)(
        IInternetZoneManager* This,
        DWORD dwAction,
        HWND hwndParent,
        LPCWSTR pwszUrl,
        LPCWSTR pwszText,
        DWORD dwPromptFlags);

    HRESULT (STDMETHODCALLTYPE *LogAction)(
        IInternetZoneManager* This,
        DWORD dwAction,
        LPCWSTR pwszUrl,
        LPCWSTR pwszText,
        DWORD dwLogFlags);

    HRESULT (STDMETHODCALLTYPE *CreateZoneEnumerator)(
        IInternetZoneManager* This,
        DWORD *pdwEnum,
        DWORD *pdwCount,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *GetZoneAt)(
        IInternetZoneManager* This,
        DWORD dwEnum,
        DWORD dwIndex,
        DWORD *pdwZone);

    HRESULT (STDMETHODCALLTYPE *DestroyZoneEnumerator)(
        IInternetZoneManager* This,
        DWORD dwEnum);

    HRESULT (STDMETHODCALLTYPE *CopyTemplatePoliciesToZone)(
        IInternetZoneManager* This,
        DWORD dwTemplate,
        DWORD dwZone,
        DWORD dwReserved);

    END_INTERFACE
} IInternetZoneManagerVtbl;
interface IInternetZoneManager {
    CONST_VTBL IInternetZoneManagerVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IInternetZoneManager_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IInternetZoneManager_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IInternetZoneManager_Release(This) (This)->lpVtbl->Release(This)
/*** IInternetZoneManager methods ***/
#define IInternetZoneManager_GetZoneAttributes(This,dwZone,pZoneAttributes) (This)->lpVtbl->GetZoneAttributes(This,dwZone,pZoneAttributes)
#define IInternetZoneManager_SetZoneAttributes(This,dwZone,pZoneAttributes) (This)->lpVtbl->SetZoneAttributes(This,dwZone,pZoneAttributes)
#define IInternetZoneManager_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) (This)->lpVtbl->GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)
#define IInternetZoneManager_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) (This)->lpVtbl->SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)
#define IInternetZoneManager_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) (This)->lpVtbl->GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)
#define IInternetZoneManager_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) (This)->lpVtbl->SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)
#define IInternetZoneManager_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) (This)->lpVtbl->PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)
#define IInternetZoneManager_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) (This)->lpVtbl->LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)
#define IInternetZoneManager_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) (This)->lpVtbl->CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)
#define IInternetZoneManager_GetZoneAt(This,dwEnum,dwIndex,pdwZone) (This)->lpVtbl->GetZoneAt(This,dwEnum,dwIndex,pdwZone)
#define IInternetZoneManager_DestroyZoneEnumerator(This,dwEnum) (This)->lpVtbl->DestroyZoneEnumerator(This,dwEnum)
#define IInternetZoneManager_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) (This)->lpVtbl->CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IInternetZoneManager_QueryInterface(IInternetZoneManager* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IInternetZoneManager_AddRef(IInternetZoneManager* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IInternetZoneManager_Release(IInternetZoneManager* This) {
    return This->lpVtbl->Release(This);
}
/*** IInternetZoneManager methods ***/
static FORCEINLINE HRESULT IInternetZoneManager_GetZoneAttributes(IInternetZoneManager* This,DWORD dwZone,ZONEATTRIBUTES *pZoneAttributes) {
    return This->lpVtbl->GetZoneAttributes(This,dwZone,pZoneAttributes);
}
static FORCEINLINE HRESULT IInternetZoneManager_SetZoneAttributes(IInternetZoneManager* This,DWORD dwZone,ZONEATTRIBUTES *pZoneAttributes) {
    return This->lpVtbl->SetZoneAttributes(This,dwZone,pZoneAttributes);
}
static FORCEINLINE HRESULT IInternetZoneManager_GetZoneCustomPolicy(IInternetZoneManager* This,DWORD dwZone,REFGUID guidKey,BYTE **ppPolicy,DWORD *pcbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManager_SetZoneCustomPolicy(IInternetZoneManager* This,DWORD dwZone,REFGUID guidKey,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManager_GetZoneActionPolicy(IInternetZoneManager* This,DWORD dwZone,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManager_SetZoneActionPolicy(IInternetZoneManager* This,DWORD dwZone,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManager_PromptAction(IInternetZoneManager* This,DWORD dwAction,HWND hwndParent,LPCWSTR pwszUrl,LPCWSTR pwszText,DWORD dwPromptFlags) {
    return This->lpVtbl->PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags);
}
static FORCEINLINE HRESULT IInternetZoneManager_LogAction(IInternetZoneManager* This,DWORD dwAction,LPCWSTR pwszUrl,LPCWSTR pwszText,DWORD dwLogFlags) {
    return This->lpVtbl->LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags);
}
static FORCEINLINE HRESULT IInternetZoneManager_CreateZoneEnumerator(IInternetZoneManager* This,DWORD *pdwEnum,DWORD *pdwCount,DWORD dwFlags) {
    return This->lpVtbl->CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags);
}
static FORCEINLINE HRESULT IInternetZoneManager_GetZoneAt(IInternetZoneManager* This,DWORD dwEnum,DWORD dwIndex,DWORD *pdwZone) {
    return This->lpVtbl->GetZoneAt(This,dwEnum,dwIndex,pdwZone);
}
static FORCEINLINE HRESULT IInternetZoneManager_DestroyZoneEnumerator(IInternetZoneManager* This,DWORD dwEnum) {
    return This->lpVtbl->DestroyZoneEnumerator(This,dwEnum);
}
static FORCEINLINE HRESULT IInternetZoneManager_CopyTemplatePoliciesToZone(IInternetZoneManager* This,DWORD dwTemplate,DWORD dwZone,DWORD dwReserved) {
    return This->lpVtbl->CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IInternetZoneManager_GetZoneAttributes_Proxy(
    IInternetZoneManager* This,
    DWORD dwZone,
    ZONEATTRIBUTES *pZoneAttributes);
void __RPC_STUB IInternetZoneManager_GetZoneAttributes_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManager_SetZoneAttributes_Proxy(
    IInternetZoneManager* This,
    DWORD dwZone,
    ZONEATTRIBUTES *pZoneAttributes);
void __RPC_STUB IInternetZoneManager_SetZoneAttributes_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManager_GetZoneCustomPolicy_Proxy(
    IInternetZoneManager* This,
    DWORD dwZone,
    REFGUID guidKey,
    BYTE **ppPolicy,
    DWORD *pcbPolicy,
    URLZONEREG urlZoneReg);
void __RPC_STUB IInternetZoneManager_GetZoneCustomPolicy_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManager_SetZoneCustomPolicy_Proxy(
    IInternetZoneManager* This,
    DWORD dwZone,
    REFGUID guidKey,
    BYTE *pPolicy,
    DWORD cbPolicy,
    URLZONEREG urlZoneReg);
void __RPC_STUB IInternetZoneManager_SetZoneCustomPolicy_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManager_GetZoneActionPolicy_Proxy(
    IInternetZoneManager* This,
    DWORD dwZone,
    DWORD dwAction,
    BYTE *pPolicy,
    DWORD cbPolicy,
    URLZONEREG urlZoneReg);
void __RPC_STUB IInternetZoneManager_GetZoneActionPolicy_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManager_SetZoneActionPolicy_Proxy(
    IInternetZoneManager* This,
    DWORD dwZone,
    DWORD dwAction,
    BYTE *pPolicy,
    DWORD cbPolicy,
    URLZONEREG urlZoneReg);
void __RPC_STUB IInternetZoneManager_SetZoneActionPolicy_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManager_PromptAction_Proxy(
    IInternetZoneManager* This,
    DWORD dwAction,
    HWND hwndParent,
    LPCWSTR pwszUrl,
    LPCWSTR pwszText,
    DWORD dwPromptFlags);
void __RPC_STUB IInternetZoneManager_PromptAction_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManager_LogAction_Proxy(
    IInternetZoneManager* This,
    DWORD dwAction,
    LPCWSTR pwszUrl,
    LPCWSTR pwszText,
    DWORD dwLogFlags);
void __RPC_STUB IInternetZoneManager_LogAction_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManager_CreateZoneEnumerator_Proxy(
    IInternetZoneManager* This,
    DWORD *pdwEnum,
    DWORD *pdwCount,
    DWORD dwFlags);
void __RPC_STUB IInternetZoneManager_CreateZoneEnumerator_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManager_GetZoneAt_Proxy(
    IInternetZoneManager* This,
    DWORD dwEnum,
    DWORD dwIndex,
    DWORD *pdwZone);
void __RPC_STUB IInternetZoneManager_GetZoneAt_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManager_DestroyZoneEnumerator_Proxy(
    IInternetZoneManager* This,
    DWORD dwEnum);
void __RPC_STUB IInternetZoneManager_DestroyZoneEnumerator_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManager_CopyTemplatePoliciesToZone_Proxy(
    IInternetZoneManager* This,
    DWORD dwTemplate,
    DWORD dwZone,
    DWORD dwReserved);
void __RPC_STUB IInternetZoneManager_CopyTemplatePoliciesToZone_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IInternetZoneManager_INTERFACE_DEFINED__ */

#endif

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETZONEMANAGEREX_DEFINED
#define _LPINTERNETZONEMANAGEREX_DEFINED

/*****************************************************************************
 * IInternetZoneManagerEx interface
 */
#ifndef __IInternetZoneManagerEx_INTERFACE_DEFINED__
#define __IInternetZoneManagerEx_INTERFACE_DEFINED__

DEFINE_GUID(IID_IInternetZoneManagerEx, 0xa4c23339, 0x8e06, 0x431e, 0x9b,0xf4, 0x7e,0x71,0x1c,0x08,0x56,0x48);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("a4c23339-8e06-431e-9bf4-7e711c085648")
IInternetZoneManagerEx : public IInternetZoneManager
{
    virtual HRESULT STDMETHODCALLTYPE GetZoneActionPolicyEx(
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg,
        DWORD dwFlags) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetZoneActionPolicyEx(
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg,
        DWORD dwFlags) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IInternetZoneManagerEx, 0xa4c23339, 0x8e06, 0x431e, 0x9b,0xf4, 0x7e,0x71,0x1c,0x08,0x56,0x48)
#endif
#else
typedef struct IInternetZoneManagerExVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IInternetZoneManagerEx* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IInternetZoneManagerEx* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IInternetZoneManagerEx* This);

    /*** IInternetZoneManager methods ***/
    HRESULT (STDMETHODCALLTYPE *GetZoneAttributes)(
        IInternetZoneManagerEx* This,
        DWORD dwZone,
        ZONEATTRIBUTES *pZoneAttributes);

    HRESULT (STDMETHODCALLTYPE *SetZoneAttributes)(
        IInternetZoneManagerEx* This,
        DWORD dwZone,
        ZONEATTRIBUTES *pZoneAttributes);

    HRESULT (STDMETHODCALLTYPE *GetZoneCustomPolicy)(
        IInternetZoneManagerEx* This,
        DWORD dwZone,
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *SetZoneCustomPolicy)(
        IInternetZoneManagerEx* This,
        DWORD dwZone,
        REFGUID guidKey,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *GetZoneActionPolicy)(
        IInternetZoneManagerEx* This,
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *SetZoneActionPolicy)(
        IInternetZoneManagerEx* This,
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *PromptAction)(
        IInternetZoneManagerEx* This,
        DWORD dwAction,
        HWND hwndParent,
        LPCWSTR pwszUrl,
        LPCWSTR pwszText,
        DWORD dwPromptFlags);

    HRESULT (STDMETHODCALLTYPE *LogAction)(
        IInternetZoneManagerEx* This,
        DWORD dwAction,
        LPCWSTR pwszUrl,
        LPCWSTR pwszText,
        DWORD dwLogFlags);

    HRESULT (STDMETHODCALLTYPE *CreateZoneEnumerator)(
        IInternetZoneManagerEx* This,
        DWORD *pdwEnum,
        DWORD *pdwCount,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *GetZoneAt)(
        IInternetZoneManagerEx* This,
        DWORD dwEnum,
        DWORD dwIndex,
        DWORD *pdwZone);

    HRESULT (STDMETHODCALLTYPE *DestroyZoneEnumerator)(
        IInternetZoneManagerEx* This,
        DWORD dwEnum);

    HRESULT (STDMETHODCALLTYPE *CopyTemplatePoliciesToZone)(
        IInternetZoneManagerEx* This,
        DWORD dwTemplate,
        DWORD dwZone,
        DWORD dwReserved);

    /*** IInternetZoneManagerEx methods ***/
    HRESULT (STDMETHODCALLTYPE *GetZoneActionPolicyEx)(
        IInternetZoneManagerEx* This,
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *SetZoneActionPolicyEx)(
        IInternetZoneManagerEx* This,
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg,
        DWORD dwFlags);

    END_INTERFACE
} IInternetZoneManagerExVtbl;
interface IInternetZoneManagerEx {
    CONST_VTBL IInternetZoneManagerExVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IInternetZoneManagerEx_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IInternetZoneManagerEx_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IInternetZoneManagerEx_Release(This) (This)->lpVtbl->Release(This)
/*** IInternetZoneManager methods ***/
#define IInternetZoneManagerEx_GetZoneAttributes(This,dwZone,pZoneAttributes) (This)->lpVtbl->GetZoneAttributes(This,dwZone,pZoneAttributes)
#define IInternetZoneManagerEx_SetZoneAttributes(This,dwZone,pZoneAttributes) (This)->lpVtbl->SetZoneAttributes(This,dwZone,pZoneAttributes)
#define IInternetZoneManagerEx_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) (This)->lpVtbl->GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)
#define IInternetZoneManagerEx_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) (This)->lpVtbl->SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)
#define IInternetZoneManagerEx_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) (This)->lpVtbl->GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)
#define IInternetZoneManagerEx_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) (This)->lpVtbl->SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)
#define IInternetZoneManagerEx_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) (This)->lpVtbl->PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)
#define IInternetZoneManagerEx_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) (This)->lpVtbl->LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)
#define IInternetZoneManagerEx_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) (This)->lpVtbl->CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)
#define IInternetZoneManagerEx_GetZoneAt(This,dwEnum,dwIndex,pdwZone) (This)->lpVtbl->GetZoneAt(This,dwEnum,dwIndex,pdwZone)
#define IInternetZoneManagerEx_DestroyZoneEnumerator(This,dwEnum) (This)->lpVtbl->DestroyZoneEnumerator(This,dwEnum)
#define IInternetZoneManagerEx_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) (This)->lpVtbl->CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)
/*** IInternetZoneManagerEx methods ***/
#define IInternetZoneManagerEx_GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) (This)->lpVtbl->GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)
#define IInternetZoneManagerEx_SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) (This)->lpVtbl->SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IInternetZoneManagerEx_QueryInterface(IInternetZoneManagerEx* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IInternetZoneManagerEx_AddRef(IInternetZoneManagerEx* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IInternetZoneManagerEx_Release(IInternetZoneManagerEx* This) {
    return This->lpVtbl->Release(This);
}
/*** IInternetZoneManager methods ***/
static FORCEINLINE HRESULT IInternetZoneManagerEx_GetZoneAttributes(IInternetZoneManagerEx* This,DWORD dwZone,ZONEATTRIBUTES *pZoneAttributes) {
    return This->lpVtbl->GetZoneAttributes(This,dwZone,pZoneAttributes);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_SetZoneAttributes(IInternetZoneManagerEx* This,DWORD dwZone,ZONEATTRIBUTES *pZoneAttributes) {
    return This->lpVtbl->SetZoneAttributes(This,dwZone,pZoneAttributes);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_GetZoneCustomPolicy(IInternetZoneManagerEx* This,DWORD dwZone,REFGUID guidKey,BYTE **ppPolicy,DWORD *pcbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_SetZoneCustomPolicy(IInternetZoneManagerEx* This,DWORD dwZone,REFGUID guidKey,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_GetZoneActionPolicy(IInternetZoneManagerEx* This,DWORD dwZone,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_SetZoneActionPolicy(IInternetZoneManagerEx* This,DWORD dwZone,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_PromptAction(IInternetZoneManagerEx* This,DWORD dwAction,HWND hwndParent,LPCWSTR pwszUrl,LPCWSTR pwszText,DWORD dwPromptFlags) {
    return This->lpVtbl->PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_LogAction(IInternetZoneManagerEx* This,DWORD dwAction,LPCWSTR pwszUrl,LPCWSTR pwszText,DWORD dwLogFlags) {
    return This->lpVtbl->LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_CreateZoneEnumerator(IInternetZoneManagerEx* This,DWORD *pdwEnum,DWORD *pdwCount,DWORD dwFlags) {
    return This->lpVtbl->CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_GetZoneAt(IInternetZoneManagerEx* This,DWORD dwEnum,DWORD dwIndex,DWORD *pdwZone) {
    return This->lpVtbl->GetZoneAt(This,dwEnum,dwIndex,pdwZone);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_DestroyZoneEnumerator(IInternetZoneManagerEx* This,DWORD dwEnum) {
    return This->lpVtbl->DestroyZoneEnumerator(This,dwEnum);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_CopyTemplatePoliciesToZone(IInternetZoneManagerEx* This,DWORD dwTemplate,DWORD dwZone,DWORD dwReserved) {
    return This->lpVtbl->CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved);
}
/*** IInternetZoneManagerEx methods ***/
static FORCEINLINE HRESULT IInternetZoneManagerEx_GetZoneActionPolicyEx(IInternetZoneManagerEx* This,DWORD dwZone,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg,DWORD dwFlags) {
    return This->lpVtbl->GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx_SetZoneActionPolicyEx(IInternetZoneManagerEx* This,DWORD dwZone,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg,DWORD dwFlags) {
    return This->lpVtbl->SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IInternetZoneManagerEx_GetZoneActionPolicyEx_Proxy(
    IInternetZoneManagerEx* This,
    DWORD dwZone,
    DWORD dwAction,
    BYTE *pPolicy,
    DWORD cbPolicy,
    URLZONEREG urlZoneReg,
    DWORD dwFlags);
void __RPC_STUB IInternetZoneManagerEx_GetZoneActionPolicyEx_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManagerEx_SetZoneActionPolicyEx_Proxy(
    IInternetZoneManagerEx* This,
    DWORD dwZone,
    DWORD dwAction,
    BYTE *pPolicy,
    DWORD cbPolicy,
    URLZONEREG urlZoneReg,
    DWORD dwFlags);
void __RPC_STUB IInternetZoneManagerEx_SetZoneActionPolicyEx_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IInternetZoneManagerEx_INTERFACE_DEFINED__ */

#endif
#endif

#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPINTERNETZONEMANAGEREX2_DEFINED
#define _LPINTERNETZONEMANAGEREX2_DEFINED

#define SECURITY_IE_STATE_GREEN 0x0
#define SECURITY_IE_STATE_RED 0x1

/*****************************************************************************
 * IInternetZoneManagerEx2 interface
 */
#ifndef __IInternetZoneManagerEx2_INTERFACE_DEFINED__
#define __IInternetZoneManagerEx2_INTERFACE_DEFINED__

DEFINE_GUID(IID_IInternetZoneManagerEx2, 0xedc17559, 0xdd5d, 0x4846, 0x8e,0xef, 0x8b,0xec,0xba,0x5a,0x4a,0xbf);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("edc17559-dd5d-4846-8eef-8becba5a4abf")
IInternetZoneManagerEx2 : public IInternetZoneManagerEx
{
    virtual HRESULT STDMETHODCALLTYPE GetZoneAttributesEx(
        DWORD dwZone,
        ZONEATTRIBUTES *pZoneAttributes,
        DWORD dwFlags) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetZoneSecurityState(
        DWORD dwZoneIndex,
        WINBOOL fRespectPolicy,
        LPDWORD pdwState,
        WINBOOL *pfPolicyEncountered) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetIESecurityState(
        WINBOOL fRespectPolicy,
        LPDWORD pdwState,
        WINBOOL *pfPolicyEncountered,
        WINBOOL fNoCache) = 0;

    virtual HRESULT STDMETHODCALLTYPE FixUnsecureSettings(
        ) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IInternetZoneManagerEx2, 0xedc17559, 0xdd5d, 0x4846, 0x8e,0xef, 0x8b,0xec,0xba,0x5a,0x4a,0xbf)
#endif
#else
typedef struct IInternetZoneManagerEx2Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IInternetZoneManagerEx2* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IInternetZoneManagerEx2* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IInternetZoneManagerEx2* This);

    /*** IInternetZoneManager methods ***/
    HRESULT (STDMETHODCALLTYPE *GetZoneAttributes)(
        IInternetZoneManagerEx2* This,
        DWORD dwZone,
        ZONEATTRIBUTES *pZoneAttributes);

    HRESULT (STDMETHODCALLTYPE *SetZoneAttributes)(
        IInternetZoneManagerEx2* This,
        DWORD dwZone,
        ZONEATTRIBUTES *pZoneAttributes);

    HRESULT (STDMETHODCALLTYPE *GetZoneCustomPolicy)(
        IInternetZoneManagerEx2* This,
        DWORD dwZone,
        REFGUID guidKey,
        BYTE **ppPolicy,
        DWORD *pcbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *SetZoneCustomPolicy)(
        IInternetZoneManagerEx2* This,
        DWORD dwZone,
        REFGUID guidKey,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *GetZoneActionPolicy)(
        IInternetZoneManagerEx2* This,
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *SetZoneActionPolicy)(
        IInternetZoneManagerEx2* This,
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg);

    HRESULT (STDMETHODCALLTYPE *PromptAction)(
        IInternetZoneManagerEx2* This,
        DWORD dwAction,
        HWND hwndParent,
        LPCWSTR pwszUrl,
        LPCWSTR pwszText,
        DWORD dwPromptFlags);

    HRESULT (STDMETHODCALLTYPE *LogAction)(
        IInternetZoneManagerEx2* This,
        DWORD dwAction,
        LPCWSTR pwszUrl,
        LPCWSTR pwszText,
        DWORD dwLogFlags);

    HRESULT (STDMETHODCALLTYPE *CreateZoneEnumerator)(
        IInternetZoneManagerEx2* This,
        DWORD *pdwEnum,
        DWORD *pdwCount,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *GetZoneAt)(
        IInternetZoneManagerEx2* This,
        DWORD dwEnum,
        DWORD dwIndex,
        DWORD *pdwZone);

    HRESULT (STDMETHODCALLTYPE *DestroyZoneEnumerator)(
        IInternetZoneManagerEx2* This,
        DWORD dwEnum);

    HRESULT (STDMETHODCALLTYPE *CopyTemplatePoliciesToZone)(
        IInternetZoneManagerEx2* This,
        DWORD dwTemplate,
        DWORD dwZone,
        DWORD dwReserved);

    /*** IInternetZoneManagerEx methods ***/
    HRESULT (STDMETHODCALLTYPE *GetZoneActionPolicyEx)(
        IInternetZoneManagerEx2* This,
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *SetZoneActionPolicyEx)(
        IInternetZoneManagerEx2* This,
        DWORD dwZone,
        DWORD dwAction,
        BYTE *pPolicy,
        DWORD cbPolicy,
        URLZONEREG urlZoneReg,
        DWORD dwFlags);

    /*** IInternetZoneManagerEx2 methods ***/
    HRESULT (STDMETHODCALLTYPE *GetZoneAttributesEx)(
        IInternetZoneManagerEx2* This,
        DWORD dwZone,
        ZONEATTRIBUTES *pZoneAttributes,
        DWORD dwFlags);

    HRESULT (STDMETHODCALLTYPE *GetZoneSecurityState)(
        IInternetZoneManagerEx2* This,
        DWORD dwZoneIndex,
        WINBOOL fRespectPolicy,
        LPDWORD pdwState,
        WINBOOL *pfPolicyEncountered);

    HRESULT (STDMETHODCALLTYPE *GetIESecurityState)(
        IInternetZoneManagerEx2* This,
        WINBOOL fRespectPolicy,
        LPDWORD pdwState,
        WINBOOL *pfPolicyEncountered,
        WINBOOL fNoCache);

    HRESULT (STDMETHODCALLTYPE *FixUnsecureSettings)(
        IInternetZoneManagerEx2* This);

    END_INTERFACE
} IInternetZoneManagerEx2Vtbl;
interface IInternetZoneManagerEx2 {
    CONST_VTBL IInternetZoneManagerEx2Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IInternetZoneManagerEx2_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IInternetZoneManagerEx2_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IInternetZoneManagerEx2_Release(This) (This)->lpVtbl->Release(This)
/*** IInternetZoneManager methods ***/
#define IInternetZoneManagerEx2_GetZoneAttributes(This,dwZone,pZoneAttributes) (This)->lpVtbl->GetZoneAttributes(This,dwZone,pZoneAttributes)
#define IInternetZoneManagerEx2_SetZoneAttributes(This,dwZone,pZoneAttributes) (This)->lpVtbl->SetZoneAttributes(This,dwZone,pZoneAttributes)
#define IInternetZoneManagerEx2_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) (This)->lpVtbl->GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)
#define IInternetZoneManagerEx2_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) (This)->lpVtbl->SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)
#define IInternetZoneManagerEx2_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) (This)->lpVtbl->GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)
#define IInternetZoneManagerEx2_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) (This)->lpVtbl->SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)
#define IInternetZoneManagerEx2_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) (This)->lpVtbl->PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)
#define IInternetZoneManagerEx2_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) (This)->lpVtbl->LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)
#define IInternetZoneManagerEx2_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) (This)->lpVtbl->CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)
#define IInternetZoneManagerEx2_GetZoneAt(This,dwEnum,dwIndex,pdwZone) (This)->lpVtbl->GetZoneAt(This,dwEnum,dwIndex,pdwZone)
#define IInternetZoneManagerEx2_DestroyZoneEnumerator(This,dwEnum) (This)->lpVtbl->DestroyZoneEnumerator(This,dwEnum)
#define IInternetZoneManagerEx2_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) (This)->lpVtbl->CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)
/*** IInternetZoneManagerEx methods ***/
#define IInternetZoneManagerEx2_GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) (This)->lpVtbl->GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)
#define IInternetZoneManagerEx2_SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) (This)->lpVtbl->SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)
/*** IInternetZoneManagerEx2 methods ***/
#define IInternetZoneManagerEx2_GetZoneAttributesEx(This,dwZone,pZoneAttributes,dwFlags) (This)->lpVtbl->GetZoneAttributesEx(This,dwZone,pZoneAttributes,dwFlags)
#define IInternetZoneManagerEx2_GetZoneSecurityState(This,dwZoneIndex,fRespectPolicy,pdwState,pfPolicyEncountered) (This)->lpVtbl->GetZoneSecurityState(This,dwZoneIndex,fRespectPolicy,pdwState,pfPolicyEncountered)
#define IInternetZoneManagerEx2_GetIESecurityState(This,fRespectPolicy,pdwState,pfPolicyEncountered,fNoCache) (This)->lpVtbl->GetIESecurityState(This,fRespectPolicy,pdwState,pfPolicyEncountered,fNoCache)
#define IInternetZoneManagerEx2_FixUnsecureSettings(This) (This)->lpVtbl->FixUnsecureSettings(This)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IInternetZoneManagerEx2_QueryInterface(IInternetZoneManagerEx2* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IInternetZoneManagerEx2_AddRef(IInternetZoneManagerEx2* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IInternetZoneManagerEx2_Release(IInternetZoneManagerEx2* This) {
    return This->lpVtbl->Release(This);
}
/*** IInternetZoneManager methods ***/
static FORCEINLINE HRESULT IInternetZoneManagerEx2_GetZoneAttributes(IInternetZoneManagerEx2* This,DWORD dwZone,ZONEATTRIBUTES *pZoneAttributes) {
    return This->lpVtbl->GetZoneAttributes(This,dwZone,pZoneAttributes);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_SetZoneAttributes(IInternetZoneManagerEx2* This,DWORD dwZone,ZONEATTRIBUTES *pZoneAttributes) {
    return This->lpVtbl->SetZoneAttributes(This,dwZone,pZoneAttributes);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_GetZoneCustomPolicy(IInternetZoneManagerEx2* This,DWORD dwZone,REFGUID guidKey,BYTE **ppPolicy,DWORD *pcbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_SetZoneCustomPolicy(IInternetZoneManagerEx2* This,DWORD dwZone,REFGUID guidKey,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_GetZoneActionPolicy(IInternetZoneManagerEx2* This,DWORD dwZone,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_SetZoneActionPolicy(IInternetZoneManagerEx2* This,DWORD dwZone,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg) {
    return This->lpVtbl->SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_PromptAction(IInternetZoneManagerEx2* This,DWORD dwAction,HWND hwndParent,LPCWSTR pwszUrl,LPCWSTR pwszText,DWORD dwPromptFlags) {
    return This->lpVtbl->PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_LogAction(IInternetZoneManagerEx2* This,DWORD dwAction,LPCWSTR pwszUrl,LPCWSTR pwszText,DWORD dwLogFlags) {
    return This->lpVtbl->LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_CreateZoneEnumerator(IInternetZoneManagerEx2* This,DWORD *pdwEnum,DWORD *pdwCount,DWORD dwFlags) {
    return This->lpVtbl->CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_GetZoneAt(IInternetZoneManagerEx2* This,DWORD dwEnum,DWORD dwIndex,DWORD *pdwZone) {
    return This->lpVtbl->GetZoneAt(This,dwEnum,dwIndex,pdwZone);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_DestroyZoneEnumerator(IInternetZoneManagerEx2* This,DWORD dwEnum) {
    return This->lpVtbl->DestroyZoneEnumerator(This,dwEnum);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_CopyTemplatePoliciesToZone(IInternetZoneManagerEx2* This,DWORD dwTemplate,DWORD dwZone,DWORD dwReserved) {
    return This->lpVtbl->CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved);
}
/*** IInternetZoneManagerEx methods ***/
static FORCEINLINE HRESULT IInternetZoneManagerEx2_GetZoneActionPolicyEx(IInternetZoneManagerEx2* This,DWORD dwZone,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg,DWORD dwFlags) {
    return This->lpVtbl->GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_SetZoneActionPolicyEx(IInternetZoneManagerEx2* This,DWORD dwZone,DWORD dwAction,BYTE *pPolicy,DWORD cbPolicy,URLZONEREG urlZoneReg,DWORD dwFlags) {
    return This->lpVtbl->SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags);
}
/*** IInternetZoneManagerEx2 methods ***/
static FORCEINLINE HRESULT IInternetZoneManagerEx2_GetZoneAttributesEx(IInternetZoneManagerEx2* This,DWORD dwZone,ZONEATTRIBUTES *pZoneAttributes,DWORD dwFlags) {
    return This->lpVtbl->GetZoneAttributesEx(This,dwZone,pZoneAttributes,dwFlags);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_GetZoneSecurityState(IInternetZoneManagerEx2* This,DWORD dwZoneIndex,WINBOOL fRespectPolicy,LPDWORD pdwState,WINBOOL *pfPolicyEncountered) {
    return This->lpVtbl->GetZoneSecurityState(This,dwZoneIndex,fRespectPolicy,pdwState,pfPolicyEncountered);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_GetIESecurityState(IInternetZoneManagerEx2* This,WINBOOL fRespectPolicy,LPDWORD pdwState,WINBOOL *pfPolicyEncountered,WINBOOL fNoCache) {
    return This->lpVtbl->GetIESecurityState(This,fRespectPolicy,pdwState,pfPolicyEncountered,fNoCache);
}
static FORCEINLINE HRESULT IInternetZoneManagerEx2_FixUnsecureSettings(IInternetZoneManagerEx2* This) {
    return This->lpVtbl->FixUnsecureSettings(This);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IInternetZoneManagerEx2_GetZoneAttributesEx_Proxy(
    IInternetZoneManagerEx2* This,
    DWORD dwZone,
    ZONEATTRIBUTES *pZoneAttributes,
    DWORD dwFlags);
void __RPC_STUB IInternetZoneManagerEx2_GetZoneAttributesEx_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManagerEx2_GetZoneSecurityState_Proxy(
    IInternetZoneManagerEx2* This,
    DWORD dwZoneIndex,
    WINBOOL fRespectPolicy,
    LPDWORD pdwState,
    WINBOOL *pfPolicyEncountered);
void __RPC_STUB IInternetZoneManagerEx2_GetZoneSecurityState_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManagerEx2_GetIESecurityState_Proxy(
    IInternetZoneManagerEx2* This,
    WINBOOL fRespectPolicy,
    LPDWORD pdwState,
    WINBOOL *pfPolicyEncountered,
    WINBOOL fNoCache);
void __RPC_STUB IInternetZoneManagerEx2_GetIESecurityState_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IInternetZoneManagerEx2_FixUnsecureSettings_Proxy(
    IInternetZoneManagerEx2* This);
void __RPC_STUB IInternetZoneManagerEx2_FixUnsecureSettings_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IInternetZoneManagerEx2_INTERFACE_DEFINED__ */

#endif
#endif

EXTERN_C const IID CLSID_SoftDistExt;

#ifndef _LPSOFTDISTEXT_DEFINED
#define _LPSOFTDISTEXT_DEFINED

#define SOFTDIST_FLAG_USAGE_EMAIL 0x1
#define SOFTDIST_FLAG_USAGE_PRECACHE 0x2
#define SOFTDIST_FLAG_USAGE_AUTOINSTALL 0x4
#define SOFTDIST_FLAG_DELETE_SUBSCRIPTION 0x8

#define SOFTDIST_ADSTATE_NONE 0x0
#define SOFTDIST_ADSTATE_AVAILABLE 0x1
#define SOFTDIST_ADSTATE_DOWNLOADED 0x2
#define SOFTDIST_ADSTATE_INSTALLED 0x3

typedef struct _tagCODEBASEHOLD {
    ULONG cbSize;
    LPWSTR szDistUnit;
    LPWSTR szCodeBase;
    DWORD dwVersionMS;
    DWORD dwVersionLS;
    DWORD dwStyle;
} CODEBASEHOLD;
typedef struct _tagCODEBASEHOLD *LPCODEBASEHOLD;

typedef struct _tagSOFTDISTINFO {
    ULONG cbSize;
    DWORD dwFlags;
    DWORD dwAdState;
    LPWSTR szTitle;
    LPWSTR szAbstract;
    LPWSTR szHREF;
    DWORD dwInstalledVersionMS;
    DWORD dwInstalledVersionLS;
    DWORD dwUpdateVersionMS;
    DWORD dwUpdateVersionLS;
    DWORD dwAdvertisedVersionMS;
    DWORD dwAdvertisedVersionLS;
    DWORD dwReserved;
} SOFTDISTINFO;
typedef struct _tagSOFTDISTINFO *LPSOFTDISTINFO;

/*****************************************************************************
 * ISoftDistExt interface
 */
#ifndef __ISoftDistExt_INTERFACE_DEFINED__
#define __ISoftDistExt_INTERFACE_DEFINED__

DEFINE_GUID(IID_ISoftDistExt, 0xb15b8dc1, 0xc7e1, 0x11d0, 0x86,0x80, 0x00,0xaa,0x00,0xbd,0xcb,0x71);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("b15b8dc1-c7e1-11d0-8680-00aa00bdcb71")
ISoftDistExt : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE ProcessSoftDist(
        LPCWSTR szCDFURL,
        IXMLElement *pSoftDistElement,
        LPSOFTDISTINFO lpsdi) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetFirstCodeBase(
        LPWSTR *szCodeBase,
        LPDWORD dwMaxSize) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetNextCodeBase(
        LPWSTR *szCodeBase,
        LPDWORD dwMaxSize) = 0;

    virtual HRESULT STDMETHODCALLTYPE AsyncInstallDistributionUnit(
        IBindCtx *pbc,
        LPVOID pvReserved,
        DWORD flags,
        LPCODEBASEHOLD lpcbh) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(ISoftDistExt, 0xb15b8dc1, 0xc7e1, 0x11d0, 0x86,0x80, 0x00,0xaa,0x00,0xbd,0xcb,0x71)
#endif
#else
typedef struct ISoftDistExtVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        ISoftDistExt* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        ISoftDistExt* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        ISoftDistExt* This);

    /*** ISoftDistExt methods ***/
    HRESULT (STDMETHODCALLTYPE *ProcessSoftDist)(
        ISoftDistExt* This,
        LPCWSTR szCDFURL,
        IXMLElement *pSoftDistElement,
        LPSOFTDISTINFO lpsdi);

    HRESULT (STDMETHODCALLTYPE *GetFirstCodeBase)(
        ISoftDistExt* This,
        LPWSTR *szCodeBase,
        LPDWORD dwMaxSize);

    HRESULT (STDMETHODCALLTYPE *GetNextCodeBase)(
        ISoftDistExt* This,
        LPWSTR *szCodeBase,
        LPDWORD dwMaxSize);

    HRESULT (STDMETHODCALLTYPE *AsyncInstallDistributionUnit)(
        ISoftDistExt* This,
        IBindCtx *pbc,
        LPVOID pvReserved,
        DWORD flags,
        LPCODEBASEHOLD lpcbh);

    END_INTERFACE
} ISoftDistExtVtbl;
interface ISoftDistExt {
    CONST_VTBL ISoftDistExtVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define ISoftDistExt_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define ISoftDistExt_AddRef(This) (This)->lpVtbl->AddRef(This)
#define ISoftDistExt_Release(This) (This)->lpVtbl->Release(This)
/*** ISoftDistExt methods ***/
#define ISoftDistExt_ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi) (This)->lpVtbl->ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi)
#define ISoftDistExt_GetFirstCodeBase(This,szCodeBase,dwMaxSize) (This)->lpVtbl->GetFirstCodeBase(This,szCodeBase,dwMaxSize)
#define ISoftDistExt_GetNextCodeBase(This,szCodeBase,dwMaxSize) (This)->lpVtbl->GetNextCodeBase(This,szCodeBase,dwMaxSize)
#define ISoftDistExt_AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh) (This)->lpVtbl->AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT ISoftDistExt_QueryInterface(ISoftDistExt* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG ISoftDistExt_AddRef(ISoftDistExt* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG ISoftDistExt_Release(ISoftDistExt* This) {
    return This->lpVtbl->Release(This);
}
/*** ISoftDistExt methods ***/
static FORCEINLINE HRESULT ISoftDistExt_ProcessSoftDist(ISoftDistExt* This,LPCWSTR szCDFURL,IXMLElement *pSoftDistElement,LPSOFTDISTINFO lpsdi) {
    return This->lpVtbl->ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi);
}
static FORCEINLINE HRESULT ISoftDistExt_GetFirstCodeBase(ISoftDistExt* This,LPWSTR *szCodeBase,LPDWORD dwMaxSize) {
    return This->lpVtbl->GetFirstCodeBase(This,szCodeBase,dwMaxSize);
}
static FORCEINLINE HRESULT ISoftDistExt_GetNextCodeBase(ISoftDistExt* This,LPWSTR *szCodeBase,LPDWORD dwMaxSize) {
    return This->lpVtbl->GetNextCodeBase(This,szCodeBase,dwMaxSize);
}
static FORCEINLINE HRESULT ISoftDistExt_AsyncInstallDistributionUnit(ISoftDistExt* This,IBindCtx *pbc,LPVOID pvReserved,DWORD flags,LPCODEBASEHOLD lpcbh) {
    return This->lpVtbl->AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE ISoftDistExt_ProcessSoftDist_Proxy(
    ISoftDistExt* This,
    LPCWSTR szCDFURL,
    IXMLElement *pSoftDistElement,
    LPSOFTDISTINFO lpsdi);
void __RPC_STUB ISoftDistExt_ProcessSoftDist_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE ISoftDistExt_GetFirstCodeBase_Proxy(
    ISoftDistExt* This,
    LPWSTR *szCodeBase,
    LPDWORD dwMaxSize);
void __RPC_STUB ISoftDistExt_GetFirstCodeBase_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE ISoftDistExt_GetNextCodeBase_Proxy(
    ISoftDistExt* This,
    LPWSTR *szCodeBase,
    LPDWORD dwMaxSize);
void __RPC_STUB ISoftDistExt_GetNextCodeBase_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE ISoftDistExt_AsyncInstallDistributionUnit_Proxy(
    ISoftDistExt* This,
    IBindCtx *pbc,
    LPVOID pvReserved,
    DWORD flags,
    LPCODEBASEHOLD lpcbh);
void __RPC_STUB ISoftDistExt_AsyncInstallDistributionUnit_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __ISoftDistExt_INTERFACE_DEFINED__ */


STDAPI GetSoftwareUpdateInfo(LPCWSTR szDistUnit, LPSOFTDISTINFO psdi);
STDAPI SetSoftwareUpdateAdvertisementState(LPCWSTR szDistUnit, DWORD dwAdState, DWORD dwAdvertisedVersionMS, DWORD dwAdvertisedVersionLS);
#endif

#ifndef _LPCATALOGFILEINFO_DEFINED
#define _LPCATALOGFILEINFO_DEFINED

/*****************************************************************************
 * ICatalogFileInfo interface
 */
#ifndef __ICatalogFileInfo_INTERFACE_DEFINED__
#define __ICatalogFileInfo_INTERFACE_DEFINED__

typedef ICatalogFileInfo *LPCATALOGFILEINFO;

DEFINE_GUID(IID_ICatalogFileInfo, 0x711c7600, 0x6b48, 0x11d1, 0xb4,0x03, 0x00,0xaa,0x00,0xb9,0x2a,0xf1);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("711c7600-6b48-11d1-b403-00aa00b92af1")
ICatalogFileInfo : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetCatalogFile(
        LPSTR *ppszCatalogFile) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetJavaTrust(
        void **ppJavaTrust) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(ICatalogFileInfo, 0x711c7600, 0x6b48, 0x11d1, 0xb4,0x03, 0x00,0xaa,0x00,0xb9,0x2a,0xf1)
#endif
#else
typedef struct ICatalogFileInfoVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        ICatalogFileInfo* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        ICatalogFileInfo* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        ICatalogFileInfo* This);

    /*** ICatalogFileInfo methods ***/
    HRESULT (STDMETHODCALLTYPE *GetCatalogFile)(
        ICatalogFileInfo* This,
        LPSTR *ppszCatalogFile);

    HRESULT (STDMETHODCALLTYPE *GetJavaTrust)(
        ICatalogFileInfo* This,
        void **ppJavaTrust);

    END_INTERFACE
} ICatalogFileInfoVtbl;
interface ICatalogFileInfo {
    CONST_VTBL ICatalogFileInfoVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define ICatalogFileInfo_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define ICatalogFileInfo_AddRef(This) (This)->lpVtbl->AddRef(This)
#define ICatalogFileInfo_Release(This) (This)->lpVtbl->Release(This)
/*** ICatalogFileInfo methods ***/
#define ICatalogFileInfo_GetCatalogFile(This,ppszCatalogFile) (This)->lpVtbl->GetCatalogFile(This,ppszCatalogFile)
#define ICatalogFileInfo_GetJavaTrust(This,ppJavaTrust) (This)->lpVtbl->GetJavaTrust(This,ppJavaTrust)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT ICatalogFileInfo_QueryInterface(ICatalogFileInfo* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG ICatalogFileInfo_AddRef(ICatalogFileInfo* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG ICatalogFileInfo_Release(ICatalogFileInfo* This) {
    return This->lpVtbl->Release(This);
}
/*** ICatalogFileInfo methods ***/
static FORCEINLINE HRESULT ICatalogFileInfo_GetCatalogFile(ICatalogFileInfo* This,LPSTR *ppszCatalogFile) {
    return This->lpVtbl->GetCatalogFile(This,ppszCatalogFile);
}
static FORCEINLINE HRESULT ICatalogFileInfo_GetJavaTrust(ICatalogFileInfo* This,void **ppJavaTrust) {
    return This->lpVtbl->GetJavaTrust(This,ppJavaTrust);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE ICatalogFileInfo_GetCatalogFile_Proxy(
    ICatalogFileInfo* This,
    LPSTR *ppszCatalogFile);
void __RPC_STUB ICatalogFileInfo_GetCatalogFile_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE ICatalogFileInfo_GetJavaTrust_Proxy(
    ICatalogFileInfo* This,
    void **ppJavaTrust);
void __RPC_STUB ICatalogFileInfo_GetJavaTrust_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __ICatalogFileInfo_INTERFACE_DEFINED__ */

#endif

#ifndef _LPDATAFILTER_DEFINED
#define _LPDATAFILTER_DEFINED

/*****************************************************************************
 * IDataFilter interface
 */
#ifndef __IDataFilter_INTERFACE_DEFINED__
#define __IDataFilter_INTERFACE_DEFINED__

typedef IDataFilter *LPDATAFILTER;

DEFINE_GUID(IID_IDataFilter, 0x69d14c80, 0xc18e, 0x11d0, 0xa9,0xce, 0x00,0x60,0x97,0x94,0x23,0x11);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("69d14c80-c18e-11d0-a9ce-006097942311")
IDataFilter : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE DoEncode(
        DWORD dwFlags,
        LONG lInBufferSize,
        BYTE *pbInBuffer,
        LONG lOutBufferSize,
        BYTE *pbOutBuffer,
        LONG lInBytesAvailable,
        LONG *plInBytesRead,
        LONG *plOutBytesWritten,
        DWORD dwReserved) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoDecode(
        DWORD dwFlags,
        LONG lInBufferSize,
        BYTE *pbInBuffer,
        LONG lOutBufferSize,
        BYTE *pbOutBuffer,
        LONG lInBytesAvailable,
        LONG *plInBytesRead,
        LONG *plOutBytesWritten,
        DWORD dwReserved) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetEncodingLevel(
        DWORD dwEncLevel) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IDataFilter, 0x69d14c80, 0xc18e, 0x11d0, 0xa9,0xce, 0x00,0x60,0x97,0x94,0x23,0x11)
#endif
#else
typedef struct IDataFilterVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IDataFilter* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IDataFilter* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IDataFilter* This);

    /*** IDataFilter methods ***/
    HRESULT (STDMETHODCALLTYPE *DoEncode)(
        IDataFilter* This,
        DWORD dwFlags,
        LONG lInBufferSize,
        BYTE *pbInBuffer,
        LONG lOutBufferSize,
        BYTE *pbOutBuffer,
        LONG lInBytesAvailable,
        LONG *plInBytesRead,
        LONG *plOutBytesWritten,
        DWORD dwReserved);

    HRESULT (STDMETHODCALLTYPE *DoDecode)(
        IDataFilter* This,
        DWORD dwFlags,
        LONG lInBufferSize,
        BYTE *pbInBuffer,
        LONG lOutBufferSize,
        BYTE *pbOutBuffer,
        LONG lInBytesAvailable,
        LONG *plInBytesRead,
        LONG *plOutBytesWritten,
        DWORD dwReserved);

    HRESULT (STDMETHODCALLTYPE *SetEncodingLevel)(
        IDataFilter* This,
        DWORD dwEncLevel);

    END_INTERFACE
} IDataFilterVtbl;
interface IDataFilter {
    CONST_VTBL IDataFilterVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IDataFilter_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IDataFilter_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IDataFilter_Release(This) (This)->lpVtbl->Release(This)
/*** IDataFilter methods ***/
#define IDataFilter_DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved) (This)->lpVtbl->DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)
#define IDataFilter_DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved) (This)->lpVtbl->DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)
#define IDataFilter_SetEncodingLevel(This,dwEncLevel) (This)->lpVtbl->SetEncodingLevel(This,dwEncLevel)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IDataFilter_QueryInterface(IDataFilter* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IDataFilter_AddRef(IDataFilter* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IDataFilter_Release(IDataFilter* This) {
    return This->lpVtbl->Release(This);
}
/*** IDataFilter methods ***/
static FORCEINLINE HRESULT IDataFilter_DoEncode(IDataFilter* This,DWORD dwFlags,LONG lInBufferSize,BYTE *pbInBuffer,LONG lOutBufferSize,BYTE *pbOutBuffer,LONG lInBytesAvailable,LONG *plInBytesRead,LONG *plOutBytesWritten,DWORD dwReserved) {
    return This->lpVtbl->DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved);
}
static FORCEINLINE HRESULT IDataFilter_DoDecode(IDataFilter* This,DWORD dwFlags,LONG lInBufferSize,BYTE *pbInBuffer,LONG lOutBufferSize,BYTE *pbOutBuffer,LONG lInBytesAvailable,LONG *plInBytesRead,LONG *plOutBytesWritten,DWORD dwReserved) {
    return This->lpVtbl->DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved);
}
static FORCEINLINE HRESULT IDataFilter_SetEncodingLevel(IDataFilter* This,DWORD dwEncLevel) {
    return This->lpVtbl->SetEncodingLevel(This,dwEncLevel);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IDataFilter_DoEncode_Proxy(
    IDataFilter* This,
    DWORD dwFlags,
    LONG lInBufferSize,
    BYTE *pbInBuffer,
    LONG lOutBufferSize,
    BYTE *pbOutBuffer,
    LONG lInBytesAvailable,
    LONG *plInBytesRead,
    LONG *plOutBytesWritten,
    DWORD dwReserved);
void __RPC_STUB IDataFilter_DoEncode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IDataFilter_DoDecode_Proxy(
    IDataFilter* This,
    DWORD dwFlags,
    LONG lInBufferSize,
    BYTE *pbInBuffer,
    LONG lOutBufferSize,
    BYTE *pbOutBuffer,
    LONG lInBytesAvailable,
    LONG *plInBytesRead,
    LONG *plOutBytesWritten,
    DWORD dwReserved);
void __RPC_STUB IDataFilter_DoDecode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IDataFilter_SetEncodingLevel_Proxy(
    IDataFilter* This,
    DWORD dwEncLevel);
void __RPC_STUB IDataFilter_SetEncodingLevel_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IDataFilter_INTERFACE_DEFINED__ */

#endif

#ifndef _LPENCODINGFILTERFACTORY_DEFINED
#define _LPENCODINGFILTERFACTORY_DEFINED

typedef struct _tagPROTOCOLFILTERDATA {
    DWORD cbSize;
    IInternetProtocolSink *pProtocolSink;
    IInternetProtocol *pProtocol;
    IUnknown *pUnk;
    DWORD dwFilterFlags;
} PROTOCOLFILTERDATA;

/*****************************************************************************
 * IEncodingFilterFactory interface
 */
#ifndef __IEncodingFilterFactory_INTERFACE_DEFINED__
#define __IEncodingFilterFactory_INTERFACE_DEFINED__

typedef IEncodingFilterFactory *LPENCODINGFILTERFACTORY;

typedef struct _tagDATAINFO {
    ULONG ulTotalSize;
    ULONG ulavrPacketSize;
    ULONG ulConnectSpeed;
    ULONG ulProcessorSpeed;
} DATAINFO;

DEFINE_GUID(IID_IEncodingFilterFactory, 0x70bdde00, 0xc18e, 0x11d0, 0xa9,0xce, 0x00,0x60,0x97,0x94,0x23,0x11);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("70bdde00-c18e-11d0-a9ce-006097942311")
IEncodingFilterFactory : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE FindBestFilter(
        LPCWSTR pwzCodeIn,
        LPCWSTR pwzCodeOut,
        DATAINFO info,
        IDataFilter **ppDF) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetDefaultFilter(
        LPCWSTR pwzCodeIn,
        LPCWSTR pwzCodeOut,
        IDataFilter **ppDF) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IEncodingFilterFactory, 0x70bdde00, 0xc18e, 0x11d0, 0xa9,0xce, 0x00,0x60,0x97,0x94,0x23,0x11)
#endif
#else
typedef struct IEncodingFilterFactoryVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IEncodingFilterFactory* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IEncodingFilterFactory* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IEncodingFilterFactory* This);

    /*** IEncodingFilterFactory methods ***/
    HRESULT (STDMETHODCALLTYPE *FindBestFilter)(
        IEncodingFilterFactory* This,
        LPCWSTR pwzCodeIn,
        LPCWSTR pwzCodeOut,
        DATAINFO info,
        IDataFilter **ppDF);

    HRESULT (STDMETHODCALLTYPE *GetDefaultFilter)(
        IEncodingFilterFactory* This,
        LPCWSTR pwzCodeIn,
        LPCWSTR pwzCodeOut,
        IDataFilter **ppDF);

    END_INTERFACE
} IEncodingFilterFactoryVtbl;
interface IEncodingFilterFactory {
    CONST_VTBL IEncodingFilterFactoryVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IEncodingFilterFactory_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IEncodingFilterFactory_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IEncodingFilterFactory_Release(This) (This)->lpVtbl->Release(This)
/*** IEncodingFilterFactory methods ***/
#define IEncodingFilterFactory_FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF) (This)->lpVtbl->FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF)
#define IEncodingFilterFactory_GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF) (This)->lpVtbl->GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IEncodingFilterFactory_QueryInterface(IEncodingFilterFactory* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IEncodingFilterFactory_AddRef(IEncodingFilterFactory* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IEncodingFilterFactory_Release(IEncodingFilterFactory* This) {
    return This->lpVtbl->Release(This);
}
/*** IEncodingFilterFactory methods ***/
static FORCEINLINE HRESULT IEncodingFilterFactory_FindBestFilter(IEncodingFilterFactory* This,LPCWSTR pwzCodeIn,LPCWSTR pwzCodeOut,DATAINFO info,IDataFilter **ppDF) {
    return This->lpVtbl->FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF);
}
static FORCEINLINE HRESULT IEncodingFilterFactory_GetDefaultFilter(IEncodingFilterFactory* This,LPCWSTR pwzCodeIn,LPCWSTR pwzCodeOut,IDataFilter **ppDF) {
    return This->lpVtbl->GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IEncodingFilterFactory_FindBestFilter_Proxy(
    IEncodingFilterFactory* This,
    LPCWSTR pwzCodeIn,
    LPCWSTR pwzCodeOut,
    DATAINFO info,
    IDataFilter **ppDF);
void __RPC_STUB IEncodingFilterFactory_FindBestFilter_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IEncodingFilterFactory_GetDefaultFilter_Proxy(
    IEncodingFilterFactory* This,
    LPCWSTR pwzCodeIn,
    LPCWSTR pwzCodeOut,
    IDataFilter **ppDF);
void __RPC_STUB IEncodingFilterFactory_GetDefaultFilter_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IEncodingFilterFactory_INTERFACE_DEFINED__ */

#endif

#ifndef _HITLOGGING_DEFINED
#define _HITLOGGING_DEFINED

WINBOOL WINAPI IsLoggingEnabledA(LPCSTR pszUrl);
WINBOOL WINAPI IsLoggingEnabledW(LPCWSTR pwszUrl);

#define IsLoggingEnabled __MINGW_NAME_AW(IsLoggingEnabled)
typedef struct _tagHIT_LOGGING_INFO {
    DWORD dwStructSize;
    LPSTR lpszLoggedUrlName;
    SYSTEMTIME StartTime;
    SYSTEMTIME EndTime;
    LPSTR lpszExtendedInfo;
} HIT_LOGGING_INFO;
typedef struct _tagHIT_LOGGING_INFO *LPHIT_LOGGING_INFO;

WINBOOL WINAPI WriteHitLogging(LPHIT_LOGGING_INFO lpLogginginfo);

#define CONFIRMSAFETYACTION_LOADOBJECT 0x1

struct CONFIRMSAFETY {
    CLSID clsid;
    IUnknown *pUnk;
    DWORD dwFlags;
};


EXTERN_C const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY;
#endif

#ifndef _LPIWRAPPEDPROTOCOL_DEFINED
#define _LPIWRAPPEDPROTOCOL_DEFINED

/*****************************************************************************
 * IWrappedProtocol interface
 */
#ifndef __IWrappedProtocol_INTERFACE_DEFINED__
#define __IWrappedProtocol_INTERFACE_DEFINED__

typedef IWrappedProtocol *LPIWRAPPEDPROTOCOL;

DEFINE_GUID(IID_IWrappedProtocol, 0x53c84785, 0x8425, 0x4dc5, 0x97,0x1b, 0xe5,0x8d,0x9c,0x19,0xf9,0xb6);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("53c84785-8425-4dc5-971b-e58d9c19f9b6")
IWrappedProtocol : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetWrapperCode(
        LONG *pnCode,
        DWORD_PTR dwReserved) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWrappedProtocol, 0x53c84785, 0x8425, 0x4dc5, 0x97,0x1b, 0xe5,0x8d,0x9c,0x19,0xf9,0xb6)
#endif
#else
typedef struct IWrappedProtocolVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWrappedProtocol* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWrappedProtocol* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWrappedProtocol* This);

    /*** IWrappedProtocol methods ***/
    HRESULT (STDMETHODCALLTYPE *GetWrapperCode)(
        IWrappedProtocol* This,
        LONG *pnCode,
        DWORD_PTR dwReserved);

    END_INTERFACE
} IWrappedProtocolVtbl;
interface IWrappedProtocol {
    CONST_VTBL IWrappedProtocolVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWrappedProtocol_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWrappedProtocol_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWrappedProtocol_Release(This) (This)->lpVtbl->Release(This)
/*** IWrappedProtocol methods ***/
#define IWrappedProtocol_GetWrapperCode(This,pnCode,dwReserved) (This)->lpVtbl->GetWrapperCode(This,pnCode,dwReserved)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWrappedProtocol_QueryInterface(IWrappedProtocol* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWrappedProtocol_AddRef(IWrappedProtocol* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWrappedProtocol_Release(IWrappedProtocol* This) {
    return This->lpVtbl->Release(This);
}
/*** IWrappedProtocol methods ***/
static FORCEINLINE HRESULT IWrappedProtocol_GetWrapperCode(IWrappedProtocol* This,LONG *pnCode,DWORD_PTR dwReserved) {
    return This->lpVtbl->GetWrapperCode(This,pnCode,dwReserved);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWrappedProtocol_GetWrapperCode_Proxy(
    IWrappedProtocol* This,
    LONG *pnCode,
    DWORD_PTR dwReserved);
void __RPC_STUB IWrappedProtocol_GetWrapperCode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWrappedProtocol_INTERFACE_DEFINED__ */

#endif

#ifndef _LPGETBINDHANDLE_DEFINED
#define _LPGETBINDHANDLE_DEFINED

/*****************************************************************************
 * IGetBindHandle interface
 */
#ifndef __IGetBindHandle_INTERFACE_DEFINED__
#define __IGetBindHandle_INTERFACE_DEFINED__

typedef IGetBindHandle *LPGETBINDHANDLE;

typedef enum __WIDL_urlmon_generated_name_00000010 {
    BINDHANDLETYPES_APPCACHE = 0x0,
    BINDHANDLETYPES_DEPENDENCY = 0x1,
    BINDHANDLETYPES_COUNT = 0x2
} BINDHANDLETYPES;

DEFINE_GUID(IID_IGetBindHandle, 0xaf0ff408, 0x129d, 0x4b20, 0x91,0xf0, 0x02,0xbd,0x23,0xd8,0x83,0x52);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("af0ff408-129d-4b20-91f0-02bd23d88352")
IGetBindHandle : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetBindHandle(
        BINDHANDLETYPES enumRequestedHandle,
        HANDLE *pRetHandle) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IGetBindHandle, 0xaf0ff408, 0x129d, 0x4b20, 0x91,0xf0, 0x02,0xbd,0x23,0xd8,0x83,0x52)
#endif
#else
typedef struct IGetBindHandleVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IGetBindHandle* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IGetBindHandle* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IGetBindHandle* This);

    /*** IGetBindHandle methods ***/
    HRESULT (STDMETHODCALLTYPE *GetBindHandle)(
        IGetBindHandle* This,
        BINDHANDLETYPES enumRequestedHandle,
        HANDLE *pRetHandle);

    END_INTERFACE
} IGetBindHandleVtbl;
interface IGetBindHandle {
    CONST_VTBL IGetBindHandleVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IGetBindHandle_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IGetBindHandle_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IGetBindHandle_Release(This) (This)->lpVtbl->Release(This)
/*** IGetBindHandle methods ***/
#define IGetBindHandle_GetBindHandle(This,enumRequestedHandle,pRetHandle) (This)->lpVtbl->GetBindHandle(This,enumRequestedHandle,pRetHandle)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IGetBindHandle_QueryInterface(IGetBindHandle* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IGetBindHandle_AddRef(IGetBindHandle* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IGetBindHandle_Release(IGetBindHandle* This) {
    return This->lpVtbl->Release(This);
}
/*** IGetBindHandle methods ***/
static FORCEINLINE HRESULT IGetBindHandle_GetBindHandle(IGetBindHandle* This,BINDHANDLETYPES enumRequestedHandle,HANDLE *pRetHandle) {
    return This->lpVtbl->GetBindHandle(This,enumRequestedHandle,pRetHandle);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IGetBindHandle_GetBindHandle_Proxy(
    IGetBindHandle* This,
    BINDHANDLETYPES enumRequestedHandle,
    HANDLE *pRetHandle);
void __RPC_STUB IGetBindHandle_GetBindHandle_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IGetBindHandle_INTERFACE_DEFINED__ */

#endif

#ifndef _XHRPLUGGABLEPROTOCOL_DEFINED
#define _XHRPLUGGABLEPROTOCOL_DEFINED

typedef struct _tagPROTOCOL_ARGUMENT {
    LPCWSTR szMethod;
    LPCWSTR szTargetUrl;
} PROTOCOL_ARGUMENT;
typedef struct _tagPROTOCOL_ARGUMENT *LPPROTOCOL_ARGUMENT;
#endif

#ifndef _LPBINDCALLBACKREDIRECT_DEFINED
#define _LPBINDCALLBACKREDIRECT_DEFINED

/*****************************************************************************
 * IBindCallbackRedirect interface
 */
#ifndef __IBindCallbackRedirect_INTERFACE_DEFINED__
#define __IBindCallbackRedirect_INTERFACE_DEFINED__

typedef IBindCallbackRedirect *LPBINDCALLBACKREDIRECT;

DEFINE_GUID(IID_IBindCallbackRedirect, 0x11c81bc2, 0x121e, 0x4ed5, 0xb9,0xc4, 0xb4,0x30,0xbd,0x54,0xf2,0xc0);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("11c81bc2-121e-4ed5-b9c4-b430bd54f2c0")
IBindCallbackRedirect : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE Redirect(
        LPCWSTR lpcUrl,
        VARIANT_BOOL *vbCancel) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IBindCallbackRedirect, 0x11c81bc2, 0x121e, 0x4ed5, 0xb9,0xc4, 0xb4,0x30,0xbd,0x54,0xf2,0xc0)
#endif
#else
typedef struct IBindCallbackRedirectVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IBindCallbackRedirect* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IBindCallbackRedirect* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IBindCallbackRedirect* This);

    /*** IBindCallbackRedirect methods ***/
    HRESULT (STDMETHODCALLTYPE *Redirect)(
        IBindCallbackRedirect* This,
        LPCWSTR lpcUrl,
        VARIANT_BOOL *vbCancel);

    END_INTERFACE
} IBindCallbackRedirectVtbl;
interface IBindCallbackRedirect {
    CONST_VTBL IBindCallbackRedirectVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IBindCallbackRedirect_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IBindCallbackRedirect_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IBindCallbackRedirect_Release(This) (This)->lpVtbl->Release(This)
/*** IBindCallbackRedirect methods ***/
#define IBindCallbackRedirect_Redirect(This,lpcUrl,vbCancel) (This)->lpVtbl->Redirect(This,lpcUrl,vbCancel)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IBindCallbackRedirect_QueryInterface(IBindCallbackRedirect* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IBindCallbackRedirect_AddRef(IBindCallbackRedirect* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IBindCallbackRedirect_Release(IBindCallbackRedirect* This) {
    return This->lpVtbl->Release(This);
}
/*** IBindCallbackRedirect methods ***/
static FORCEINLINE HRESULT IBindCallbackRedirect_Redirect(IBindCallbackRedirect* This,LPCWSTR lpcUrl,VARIANT_BOOL *vbCancel) {
    return This->lpVtbl->Redirect(This,lpcUrl,vbCancel);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IBindCallbackRedirect_Redirect_Proxy(
    IBindCallbackRedirect* This,
    LPCWSTR lpcUrl,
    VARIANT_BOOL *vbCancel);
void __RPC_STUB IBindCallbackRedirect_Redirect_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IBindCallbackRedirect_INTERFACE_DEFINED__ */

#endif

#endif
/* Begin additional prototypes for all interfaces */

ULONG           __RPC_USER STGMEDIUM_UserSize     (ULONG *, ULONG, STGMEDIUM *);
unsigned char * __RPC_USER STGMEDIUM_UserMarshal  (ULONG *, unsigned char *, STGMEDIUM *);
unsigned char * __RPC_USER STGMEDIUM_UserUnmarshal(ULONG *, unsigned char *, STGMEDIUM *);
void            __RPC_USER STGMEDIUM_UserFree     (ULONG *, STGMEDIUM *);
ULONG           __RPC_USER CLIPFORMAT_UserSize     (ULONG *, ULONG, CLIPFORMAT *);
unsigned char * __RPC_USER CLIPFORMAT_UserMarshal  (ULONG *, unsigned char *, CLIPFORMAT *);
unsigned char * __RPC_USER CLIPFORMAT_UserUnmarshal(ULONG *, unsigned char *, CLIPFORMAT *);
void            __RPC_USER CLIPFORMAT_UserFree     (ULONG *, CLIPFORMAT *);
ULONG           __RPC_USER HWND_UserSize     (ULONG *, ULONG, HWND *);
unsigned char * __RPC_USER HWND_UserMarshal  (ULONG *, unsigned char *, HWND *);
unsigned char * __RPC_USER HWND_UserUnmarshal(ULONG *, unsigned char *, HWND *);
void            __RPC_USER HWND_UserFree     (ULONG *, HWND *);
ULONG           __RPC_USER BSTR_UserSize     (ULONG *, ULONG, BSTR *);
unsigned char * __RPC_USER BSTR_UserMarshal  (ULONG *, unsigned char *, BSTR *);
unsigned char * __RPC_USER BSTR_UserUnmarshal(ULONG *, unsigned char *, BSTR *);
void            __RPC_USER BSTR_UserFree     (ULONG *, BSTR *);

/* End additional prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __urlmon_h__ */
                                                                                                                                                                                                                                            usr/share/mingw-w64/include/usb.h                                                                   0100644 0000000 0000000 00000046703 12404413016 015311  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * usb.h
 *
 * This file is part of the ReactOS PSDK package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#ifdef OSR21_COMPAT
#pragma message("WARNING: OSR21_COMPAT SWITCH NOT SUPPORTED")
#endif

#ifndef _NTDDK_
#ifndef _WDMDDK_
typedef PVOID PIRP;
typedef PVOID PMDL;
#endif
#endif

#define USBDI_VERSION    0x00000600

#include "usb200.h"

#define USB_PORTATTR_NO_CONNECTOR                       0x00000001
#define USB_PORTATTR_SHARED_USB2                        0x00000002
#define USB_PORTATTR_MINI_CONNECTOR                     0x00000004
#define USB_PORTATTR_OEM_CONNECTOR                      0x00000008
#define USB_PORTATTR_OWNED_BY_CC                        0x01000000
#define USB_PORTATTR_NO_OVERCURRENT_UI                  0x02000000

typedef enum _USB_CONTROLLER_FLAVOR {
  USB_HcGeneric = 0,
  OHCI_Generic = 100,
  OHCI_Hydra,
  OHCI_NEC,
  UHCI_Generic = 200,
  UHCI_Piix4 = 201,
  UHCI_Piix3 = 202,
  UHCI_Ich2 = 203,
  UHCI_Reserved204 = 204,
  UHCI_Ich1 = 205,
  UHCI_Ich3m = 206,
  UHCI_Ich4 = 207,
  UHCI_Ich5 = 208,
  UHCI_Ich6 = 209,
  UHCI_Intel = 249,
  UHCI_VIA = 250,
  UHCI_VIA_x01 = 251,
  UHCI_VIA_x02 = 252,
  UHCI_VIA_x03 = 253,
  UHCI_VIA_x04 = 254,
  UHCI_VIA_x0E_FIFO = 264,
  EHCI_Generic = 1000,
  EHCI_NEC = 2000,
  EHCI_Lucent = 3000
} USB_CONTROLLER_FLAVOR;


#define USB_DEFAULT_DEVICE_ADDRESS                      0
#define USB_DEFAULT_ENDPOINT_ADDRESS                    0
#define USB_DEFAULT_MAX_PACKET                          64
#define URB_FROM_IRP(Irp)                               ((IoGetCurrentIrpStackLocation(Irp))->Parameters.Others.Argument1)
#define URB_FUNCTION_SELECT_CONFIGURATION               0x0000
#define URB_FUNCTION_SELECT_INTERFACE                   0x0001
#define URB_FUNCTION_ABORT_PIPE                         0x0002
#define URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL          0x0003
#define URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL       0x0004
#define URB_FUNCTION_GET_FRAME_LENGTH                   0x0005
#define URB_FUNCTION_SET_FRAME_LENGTH                   0x0006
#define URB_FUNCTION_GET_CURRENT_FRAME_NUMBER           0x0007
#define URB_FUNCTION_CONTROL_TRANSFER                   0x0008
#define URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER         0x0009
#define URB_FUNCTION_ISOCH_TRANSFER                     0x000A
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE         0x000B
#define URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE           0x000C
#define URB_FUNCTION_SET_FEATURE_TO_DEVICE              0x000D
#define URB_FUNCTION_SET_FEATURE_TO_INTERFACE           0x000E
#define URB_FUNCTION_SET_FEATURE_TO_ENDPOINT            0x000F
#define URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE            0x0010
#define URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE         0x0011
#define URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT          0x0012
#define URB_FUNCTION_GET_STATUS_FROM_DEVICE             0x0013
#define URB_FUNCTION_GET_STATUS_FROM_INTERFACE          0x0014
#define URB_FUNCTION_GET_STATUS_FROM_ENDPOINT           0x0015
#define URB_FUNCTION_RESERVED_0X0016                    0x0016
#define URB_FUNCTION_VENDOR_DEVICE                      0x0017
#define URB_FUNCTION_VENDOR_INTERFACE                   0x0018
#define URB_FUNCTION_VENDOR_ENDPOINT                    0x0019
#define URB_FUNCTION_CLASS_DEVICE                       0x001A
#define URB_FUNCTION_CLASS_INTERFACE                    0x001B
#define URB_FUNCTION_CLASS_ENDPOINT                     0x001C
#define URB_FUNCTION_RESERVE_0X001D                     0x001D
#define URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL    0x001E
#define URB_FUNCTION_CLASS_OTHER                        0x001F
#define URB_FUNCTION_VENDOR_OTHER                       0x0020
#define URB_FUNCTION_GET_STATUS_FROM_OTHER              0x0021
#define URB_FUNCTION_CLEAR_FEATURE_TO_OTHER             0x0022
#define URB_FUNCTION_SET_FEATURE_TO_OTHER               0x0023
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT       0x0024
#define URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT         0x0025
#define URB_FUNCTION_GET_CONFIGURATION                  0x0026
#define URB_FUNCTION_GET_INTERFACE                      0x0027
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE      0x0028
#define URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE        0x0029

#if (_WIN32_WINNT >= 0x0501)

#define URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR          0x002A
#define URB_FUNCTION_SYNC_RESET_PIPE                    0x0030
#define URB_FUNCTION_SYNC_CLEAR_STALL                   0x0031

#endif

#if (_WIN32_WINNT >= 0x0600)

#define URB_FUNCTION_CONTROL_TRANSFER_EX             0x0032
#define URB_FUNCTION_RESERVE_0X0033                  0x0033
#define URB_FUNCTION_RESERVE_0X0034                  0x0034

#endif

#define URB_FUNCTION_RESERVE_0X002B                     0x002B
#define URB_FUNCTION_RESERVE_0X002C                     0x002C
#define URB_FUNCTION_RESERVE_0X002D                     0x002D
#define URB_FUNCTION_RESERVE_0X002E                     0x002E
#define URB_FUNCTION_RESERVE_0X002F                     0x002F

#define URB_FUNCTION_RESET_PIPE                         URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL

#define USBD_TRANSFER_DIRECTION                         0x00000001
#define USBD_SHORT_TRANSFER_OK                          0x00000002
#define USBD_START_ISO_TRANSFER_ASAP                    0x00000004
#define USBD_DEFAULT_PIPE_TRANSFER                      0x00000008
#define USBD_TRANSFER_DIRECTION_FLAG(flags)             ((flags) & USBD_TRANSFER_DIRECTION)

#define USBD_TRANSFER_DIRECTION_OUT                     0
#define USBD_TRANSFER_DIRECTION_IN                      1
#define VALID_TRANSFER_FLAGS_MASK                       (USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION | \
                                                         USBD_START_ISO_TRANSFER_ASAP | USBD_DEFAULT_PIPE_TRANSFER)
#define USBD_ISO_START_FRAME_RANGE                      1024

typedef LONG USBD_STATUS;

#define USBD_SUCCESS(Status)                            ((USBD_STATUS)(Status) >= 0)
#define USBD_PENDING(Status)                            ((ULONG)(Status) >> 30 == 1)
#define USBD_ERROR(Status)                              ((USBD_STATUS)(Status) < 0)
#define USBD_STATUS_SUCCESS                             ((USBD_STATUS)0x00000000)
#define USBD_STATUS_PENDING                             ((USBD_STATUS)0x40000000)
#define USBD_STATUS_CRC                                 ((USBD_STATUS)0xC0000001)
#define USBD_STATUS_BTSTUFF                             ((USBD_STATUS)0xC0000002)
#define USBD_STATUS_DATA_TOGGLE_MISMATCH                ((USBD_STATUS)0xC0000003)
#define USBD_STATUS_STALL_PID                           ((USBD_STATUS)0xC0000004)
#define USBD_STATUS_DEV_NOT_RESPONDING                  ((USBD_STATUS)0xC0000005)
#define USBD_STATUS_PID_CHECK_FAILURE                   ((USBD_STATUS)0xC0000006)
#define USBD_STATUS_UNEXPECTED_PID                      ((USBD_STATUS)0xC0000007)
#define USBD_STATUS_DATA_OVERRUN                        ((USBD_STATUS)0xC0000008)
#define USBD_STATUS_DATA_UNDERRUN                       ((USBD_STATUS)0xC0000009)
#define USBD_STATUS_RESERVED1                           ((USBD_STATUS)0xC000000A)
#define USBD_STATUS_RESERVED2                           ((USBD_STATUS)0xC000000B)
#define USBD_STATUS_BUFFER_OVERRUN                      ((USBD_STATUS)0xC000000C)
#define USBD_STATUS_BUFFER_UNDERRUN                     ((USBD_STATUS)0xC000000D)
#define USBD_STATUS_NOT_ACCESSED                        ((USBD_STATUS)0xC000000F)
#define USBD_STATUS_FIFO                                ((USBD_STATUS)0xC0000010)
#define USBD_STATUS_XACT_ERROR                          ((USBD_STATUS)0xC0000011)
#define USBD_STATUS_BABBLE_DETECTED                     ((USBD_STATUS)0xC0000012)
#define USBD_STATUS_DATA_BUFFER_ERROR                   ((USBD_STATUS)0xC0000013)
#define USBD_STATUS_ENDPOINT_HALTED                     ((USBD_STATUS)0xC0000030)
#define USBD_STATUS_INVALID_URB_FUNCTION                ((USBD_STATUS)0x80000200)
#define USBD_STATUS_INVALID_PARAMETER                   ((USBD_STATUS)0x80000300)
#define USBD_STATUS_ERROR_BUSY                          ((USBD_STATUS)0x80000400)
#define USBD_STATUS_INVALID_PIPE_HANDLE                 ((USBD_STATUS)0x80000600)
#define USBD_STATUS_NO_BANDWIDTH                        ((USBD_STATUS)0x80000700)
#define USBD_STATUS_INTERNAL_HC_ERROR                   ((USBD_STATUS)0x80000800)
#define USBD_STATUS_ERROR_SHORT_TRANSFER                ((USBD_STATUS)0x80000900)
#define USBD_STATUS_BAD_START_FRAME                     ((USBD_STATUS)0xC0000A00)
#define USBD_STATUS_ISOCH_REQUEST_FAILED                ((USBD_STATUS)0xC0000B00)
#define USBD_STATUS_FRAME_CONTROL_OWNED                 ((USBD_STATUS)0xC0000C00)
#define USBD_STATUS_FRAME_CONTROL_NOT_OWNED             ((USBD_STATUS)0xC0000D00)
#define USBD_STATUS_NOT_SUPPORTED                       ((USBD_STATUS)0xC0000E00)
#define USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR    ((USBD_STATUS)0xC0000F00)
#define USBD_STATUS_INSUFFICIENT_RESOURCES              ((USBD_STATUS)0xC0001000)
#define USBD_STATUS_SET_CONFIG_FAILED                   ((USBD_STATUS)0xC0002000)
#define USBD_STATUS_BUFFER_TOO_SMALL                    ((USBD_STATUS)0xC0003000)
#define USBD_STATUS_INTERFACE_NOT_FOUND                 ((USBD_STATUS)0xC0004000)
#define USBD_STATUS_INAVLID_PIPE_FLAGS                  ((USBD_STATUS)0xC0005000)
#define USBD_STATUS_TIMEOUT                             ((USBD_STATUS)0xC0006000)
#define USBD_STATUS_DEVICE_GONE                         ((USBD_STATUS)0xC0007000)
#define USBD_STATUS_STATUS_NOT_MAPPED                   ((USBD_STATUS)0xC0008000)
#define USBD_STATUS_HUB_INTERNAL_ERROR                  ((USBD_STATUS)0xC0009000)
#define USBD_STATUS_CANCELED                            ((USBD_STATUS)0xC0010000)
#define USBD_STATUS_ISO_NOT_ACCESSED_BY_HW              ((USBD_STATUS)0xC0020000)
#define USBD_STATUS_ISO_TD_ERROR                        ((USBD_STATUS)0xC0030000)
#define USBD_STATUS_ISO_NA_LATE_USBPORT                 ((USBD_STATUS)0xC0040000)
#define USBD_STATUS_ISO_NOT_ACCESSED_LATE               ((USBD_STATUS)0xC0050000)
#define USBD_STATUS_BAD_DESCRIPTOR                      ((USBD_STATUS)0xC0100000)
#define USBD_STATUS_BAD_DESCRIPTOR_BLEN                 ((USBD_STATUS)0xC0100001)
#define USBD_STATUS_BAD_DESCRIPTOR_TYPE                 ((USBD_STATUS)0xC0100002)
#define USBD_STATUS_BAD_INTERFACE_DESCRIPTOR            ((USBD_STATUS)0xC0100003)
#define USBD_STATUS_BAD_ENDPOINT_DESCRIPTOR             ((USBD_STATUS)0xC0100004)
#define USBD_STATUS_BAD_INTERFACE_ASSOC_DESCRIPTOR      ((USBD_STATUS)0xC0100005)
#define USBD_STATUS_BAD_CONFIG_DESC_LENGTH              ((USBD_STATUS)0xC0100006)
#define USBD_STATUS_BAD_NUMBER_OF_INTERFACES            ((USBD_STATUS)0xC0100007)
#define USBD_STATUS_BAD_NUMBER_OF_ENDPOINTS             ((USBD_STATUS)0xC0100008)
#define USBD_STATUS_BAD_ENDPOINT_ADDRESS                ((USBD_STATUS)0xC0100009)

typedef PVOID USBD_PIPE_HANDLE;
typedef PVOID USBD_CONFIGURATION_HANDLE;
typedef PVOID USBD_INTERFACE_HANDLE;

#if (_WIN32_WINNT >= 0x0501)
#define USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE              0xFFFFFFFF
#else
#define USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE  PAGE_SIZE
#endif

typedef struct _USBD_VERSION_INFORMATION {
  ULONG USBDI_Version;
  ULONG Supported_USB_Version;
} USBD_VERSION_INFORMATION, *PUSBD_VERSION_INFORMATION;

typedef enum _USBD_PIPE_TYPE {
  UsbdPipeTypeControl,
  UsbdPipeTypeIsochronous,
  UsbdPipeTypeBulk,
  UsbdPipeTypeInterrupt
} USBD_PIPE_TYPE;

#define USBD_PIPE_DIRECTION_IN(pipeInformation)         ((pipeInformation)->EndpointAddress & USB_ENDPOINT_DIRECTION_MASK)

typedef struct _USBD_DEVICE_INFORMATION {
  ULONG OffsetNext;
  PVOID UsbdDeviceHandle;
  USB_DEVICE_DESCRIPTOR DeviceDescriptor;
} USBD_DEVICE_INFORMATION, *PUSBD_DEVICE_INFORMATION;

typedef struct _USBD_PIPE_INFORMATION {
  USHORT MaximumPacketSize;
  UCHAR EndpointAddress;
  UCHAR Interval;
  USBD_PIPE_TYPE PipeType;
  USBD_PIPE_HANDLE PipeHandle;
  ULONG MaximumTransferSize;
  ULONG PipeFlags;
} USBD_PIPE_INFORMATION, *PUSBD_PIPE_INFORMATION;

#define USBD_PF_CHANGE_MAX_PACKET                       0x00000001
#define USBD_PF_SHORT_PACKET_OPT                        0x00000002
#define USBD_PF_ENABLE_RT_THREAD_ACCESS                 0x00000004
#define USBD_PF_MAP_ADD_TRANSFERS                       0x00000008
#define USBD_PF_VALID_MASK                              (USBD_PF_CHANGE_MAX_PACKET | USBD_PF_SHORT_PACKET_OPT | \
                                                         USBD_PF_ENABLE_RT_THREAD_ACCESS | USBD_PF_MAP_ADD_TRANSFERS)

typedef struct _USBD_INTERFACE_INFORMATION {
  USHORT Length;
  UCHAR InterfaceNumber;
  UCHAR AlternateSetting;
  UCHAR Class;
  UCHAR SubClass;
  UCHAR Protocol;
  UCHAR Reserved;
  USBD_INTERFACE_HANDLE InterfaceHandle;
  ULONG NumberOfPipes;
  USBD_PIPE_INFORMATION Pipes[1];
} USBD_INTERFACE_INFORMATION, *PUSBD_INTERFACE_INFORMATION;

struct _URB_HCD_AREA {
  PVOID Reserved8[8];
};

struct _URB_HEADER {
  USHORT Length;
  USHORT Function;
  USBD_STATUS Status;
  PVOID UsbdDeviceHandle;
  ULONG UsbdFlags;
};

struct _URB_SELECT_INTERFACE {
  struct _URB_HEADER Hdr;
  USBD_CONFIGURATION_HANDLE ConfigurationHandle;
  USBD_INTERFACE_INFORMATION Interface;
};

struct _URB_SELECT_CONFIGURATION {
  struct _URB_HEADER Hdr;
  PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;
  USBD_CONFIGURATION_HANDLE ConfigurationHandle;
  USBD_INTERFACE_INFORMATION Interface;
};

struct _URB_PIPE_REQUEST {
  struct _URB_HEADER Hdr;
  USBD_PIPE_HANDLE PipeHandle;
  ULONG Reserved;
};

struct _URB_FRAME_LENGTH_CONTROL {
  struct _URB_HEADER Hdr;
};

struct _URB_GET_FRAME_LENGTH {
  struct _URB_HEADER Hdr;
  ULONG FrameLength;
  ULONG FrameNumber;
};

struct _URB_SET_FRAME_LENGTH {
  struct _URB_HEADER Hdr;
  LONG FrameLengthDelta;
};

struct _URB_GET_CURRENT_FRAME_NUMBER {
  struct _URB_HEADER Hdr;
  ULONG FrameNumber;
};

struct _URB_CONTROL_DESCRIPTOR_REQUEST {
  struct _URB_HEADER Hdr;
  PVOID Reserved;
  ULONG Reserved0;
  ULONG TransferBufferLength;
  PVOID TransferBuffer;
  PMDL TransferBufferMDL;
  struct _URB *UrbLink;
  struct _URB_HCD_AREA hca;
  USHORT Reserved1;
  UCHAR Index;
  UCHAR DescriptorType;
  USHORT LanguageId;
  USHORT Reserved2;
};

struct _URB_CONTROL_GET_STATUS_REQUEST {
  struct _URB_HEADER Hdr;
  PVOID Reserved;
  ULONG Reserved0;
  ULONG TransferBufferLength;
  PVOID TransferBuffer;
  PMDL TransferBufferMDL;
  struct _URB *UrbLink;
  struct _URB_HCD_AREA hca;
  UCHAR Reserved1[4];
  USHORT Index;
  USHORT Reserved2;
};

struct _URB_CONTROL_FEATURE_REQUEST {
  struct _URB_HEADER Hdr;
  PVOID Reserved;
  ULONG Reserved2;
  ULONG Reserved3;
  PVOID Reserved4;
  PMDL Reserved5;
  struct _URB *UrbLink;
  struct _URB_HCD_AREA hca;
  USHORT Reserved0;
  USHORT FeatureSelector;
  USHORT Index;
  USHORT Reserved1;
};

struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST {
  struct _URB_HEADER Hdr;
  PVOID Reserved;
  ULONG TransferFlags;
  ULONG TransferBufferLength;
  PVOID TransferBuffer;
  PMDL TransferBufferMDL;
  struct _URB *UrbLink;
  struct _URB_HCD_AREA hca;
  UCHAR RequestTypeReservedBits;
  UCHAR Request;
  USHORT Value;
  USHORT Index;
  USHORT Reserved1;
};

struct _URB_CONTROL_GET_INTERFACE_REQUEST {
  struct _URB_HEADER Hdr;
  PVOID Reserved;
  ULONG Reserved0;
  ULONG TransferBufferLength;
  PVOID TransferBuffer;
  PMDL TransferBufferMDL;
  struct _URB *UrbLink;
  struct _URB_HCD_AREA hca;
  UCHAR Reserved1[4];
  USHORT Interface;
  USHORT Reserved2;
};

struct _URB_CONTROL_GET_CONFIGURATION_REQUEST {
  struct _URB_HEADER Hdr;
  PVOID Reserved;
  ULONG Reserved0;
  ULONG TransferBufferLength;
  PVOID TransferBuffer;
  PMDL TransferBufferMDL;
  struct _URB *UrbLink;
  struct _URB_HCD_AREA hca;
  UCHAR Reserved1[8];
};

#if (_WIN32_WINNT >= 0x0501)

#define OS_STRING_DESCRIPTOR_INDEX                      0xEE
#define MS_GENRE_DESCRIPTOR_INDEX                       0x0001
#define MS_POWER_DESCRIPTOR_INDEX                       0x0002
#define MS_OS_STRING_SIGNATURE                          L"MSFT100"
#define MS_OS_FLAGS_CONTAINERID                         0x02

typedef struct _OS_STRING {
  UCHAR bLength;
  UCHAR bDescriptorType;
  WCHAR MicrosoftString[7];
  UCHAR bVendorCode;
  __C89_NAMELESS union {
    UCHAR bPad;
    UCHAR bFlags;
  };
} OS_STRING, *POS_STRING;

struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST {
  struct _URB_HEADER Hdr;
  PVOID Reserved;
  ULONG Reserved0;
  ULONG TransferBufferLength;
  PVOID TransferBuffer;
  PMDL TransferBufferMDL;
  struct _URB *UrbLink;
  struct _URB_HCD_AREA hca;
  UCHAR Recipient:5;
  UCHAR Reserved1:3;
  UCHAR Reserved2;
  UCHAR InterfaceNumber;
  UCHAR MS_PageIndex;
  USHORT MS_FeatureDescriptorIndex;
  USHORT Reserved3;
};

#endif

struct _URB_CONTROL_TRANSFER {
  struct _URB_HEADER Hdr;
  USBD_PIPE_HANDLE PipeHandle;
  ULONG TransferFlags;
  ULONG TransferBufferLength;
  PVOID TransferBuffer;
  PMDL TransferBufferMDL;
  struct _URB *UrbLink;
  struct _URB_HCD_AREA hca;
  UCHAR SetupPacket[8];
};

#if (_WIN32_WINNT >= 0x0600)

struct _URB_CONTROL_TRANSFER_EX {
  struct _URB_HEADER Hdr;
  USBD_PIPE_HANDLE PipeHandle;
  ULONG TransferFlags;
  ULONG TransferBufferLength;
  PVOID TransferBuffer;
  PMDL TransferBufferMDL;
  ULONG Timeout;
#ifdef _WIN64
  ULONG Pad;
#endif
  struct _URB_HCD_AREA hca;
  UCHAR SetupPacket[8];
};

#endif

struct _URB_BULK_OR_INTERRUPT_TRANSFER {
  struct _URB_HEADER Hdr;
  USBD_PIPE_HANDLE PipeHandle;
  ULONG TransferFlags;
  ULONG TransferBufferLength;
  PVOID TransferBuffer;
  PMDL TransferBufferMDL;
  struct _URB *UrbLink;
  struct _URB_HCD_AREA hca;
};

typedef struct _USBD_ISO_PACKET_DESCRIPTOR {
  ULONG Offset;
  ULONG Length;
  USBD_STATUS Status;
} USBD_ISO_PACKET_DESCRIPTOR, *PUSBD_ISO_PACKET_DESCRIPTOR;

struct _URB_ISOCH_TRANSFER {
  struct _URB_HEADER Hdr;
  USBD_PIPE_HANDLE PipeHandle;
  ULONG TransferFlags;
  ULONG TransferBufferLength;
  PVOID TransferBuffer;
  PMDL TransferBufferMDL;
  struct _URB *UrbLink;
  struct _URB_HCD_AREA hca;
  ULONG StartFrame;
  ULONG NumberOfPackets;
  ULONG ErrorCount;
  USBD_ISO_PACKET_DESCRIPTOR IsoPacket[1];
};

typedef struct _URB {
  __C89_NAMELESS union {
    struct _URB_HEADER UrbHeader;
    struct _URB_SELECT_INTERFACE UrbSelectInterface;
    struct _URB_SELECT_CONFIGURATION UrbSelectConfiguration;
    struct _URB_PIPE_REQUEST UrbPipeRequest;
    struct _URB_FRAME_LENGTH_CONTROL UrbFrameLengthControl;
    struct _URB_GET_FRAME_LENGTH UrbGetFrameLength;
    struct _URB_SET_FRAME_LENGTH UrbSetFrameLength;
    struct _URB_GET_CURRENT_FRAME_NUMBER UrbGetCurrentFrameNumber;
    struct _URB_CONTROL_TRANSFER UrbControlTransfer;
#if (_WIN32_WINNT >= 0x0600)
    struct _URB_CONTROL_TRANSFER_EX UrbControlTransferEx;
#endif
    struct _URB_BULK_OR_INTERRUPT_TRANSFER UrbBulkOrInterruptTransfer;
    struct _URB_ISOCH_TRANSFER UrbIsochronousTransfer;
    struct _URB_CONTROL_DESCRIPTOR_REQUEST UrbControlDescriptorRequest;
    struct _URB_CONTROL_GET_STATUS_REQUEST UrbControlGetStatusRequest;
    struct _URB_CONTROL_FEATURE_REQUEST UrbControlFeatureRequest;
    struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST UrbControlVendorClassRequest;
    struct _URB_CONTROL_GET_INTERFACE_REQUEST UrbControlGetInterfaceRequest;
    struct _URB_CONTROL_GET_CONFIGURATION_REQUEST UrbControlGetConfigurationRequest;
#if (_WIN32_WINNT >= 0x0501)
    struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST UrbOSFeatureDescriptorRequest;
#endif
  };
} URB, *PURB;

                                                             usr/share/mingw-w64/include/usb100.h                                                                0100644 0000000 0000000 00000015371 12404413016 015527  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * usb100.h
 *
 * USB 1.0 support
 *
 * This file is part of the ReactOS PSDK package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <pshpack1.h>

#define BMREQUEST_HOST_TO_DEVICE          0
#define BMREQUEST_DEVICE_TO_HOST          1

#define BMREQUEST_STANDARD                0
#define BMREQUEST_CLASS                   1
#define BMREQUEST_VENDOR                  2

#define BMREQUEST_TO_DEVICE               0
#define BMREQUEST_TO_INTERFACE            1
#define BMREQUEST_TO_ENDPOINT             2
#define BMREQUEST_TO_OTHER                3

#define MAXIMUM_USB_STRING_LENGTH         255

#define USB_GETSTATUS_SELF_POWERED            0x01
#define USB_GETSTATUS_REMOTE_WAKEUP_ENABLED   0x02

/* USB_COMMON_DESCRIPTOR.bDescriptorType constants */
#define USB_DEVICE_DESCRIPTOR_TYPE        0x01
#define USB_CONFIGURATION_DESCRIPTOR_TYPE 0x02
#define USB_STRING_DESCRIPTOR_TYPE        0x03
#define USB_INTERFACE_DESCRIPTOR_TYPE     0x04
#define USB_ENDPOINT_DESCRIPTOR_TYPE      0x05
#define USB_RESERVED_DESCRIPTOR_TYPE        0x06
#define USB_CONFIG_POWER_DESCRIPTOR_TYPE    0x07
#define USB_INTERFACE_POWER_DESCRIPTOR_TYPE 0x08

#define USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(d, i) ((USHORT)((USHORT)d << 8 | i))

/* USB_ENDPOINT_DESCRIPTOR.bmAttributes constants */
#define USB_ENDPOINT_TYPE_MASK            0x03
#define USB_ENDPOINT_TYPE_CONTROL         0x00
#define USB_ENDPOINT_TYPE_ISOCHRONOUS     0x01
#define USB_ENDPOINT_TYPE_BULK            0x02
#define USB_ENDPOINT_TYPE_INTERRUPT       0x03

/* USB_CONFIGURATION_DESCRIPTOR.bmAttributes constants */
#define USB_CONFIG_POWERED_MASK           0xc0
#define USB_CONFIG_BUS_POWERED            0x80
#define USB_CONFIG_SELF_POWERED           0x40
#define USB_CONFIG_REMOTE_WAKEUP          0x20

#define USB_ENDPOINT_DIRECTION_MASK       0x80

#define USB_ENDPOINT_DIRECTION_OUT(x) (!((x) & USB_ENDPOINT_DIRECTION_MASK))
#define USB_ENDPOINT_DIRECTION_IN(x) ((x) & USB_ENDPOINT_DIRECTION_MASK)

#define USB_REQUEST_GET_STATUS            0x00
#define USB_REQUEST_CLEAR_FEATURE         0x01
#define USB_REQUEST_SET_FEATURE           0x03
#define USB_REQUEST_SET_ADDRESS           0x05
#define USB_REQUEST_GET_DESCRIPTOR        0x06
#define USB_REQUEST_SET_DESCRIPTOR        0x07
#define USB_REQUEST_GET_CONFIGURATION     0x08
#define USB_REQUEST_SET_CONFIGURATION     0x09
#define USB_REQUEST_GET_INTERFACE         0x0A
#define USB_REQUEST_SET_INTERFACE         0x0B
#define USB_REQUEST_SYNC_FRAME            0x0C

#define USB_DEVICE_CLASS_RESERVED           0x00
#define USB_DEVICE_CLASS_AUDIO              0x01
#define USB_DEVICE_CLASS_COMMUNICATIONS     0x02
#define USB_DEVICE_CLASS_HUMAN_INTERFACE    0x03
#define USB_DEVICE_CLASS_MONITOR            0x04
#define USB_DEVICE_CLASS_PHYSICAL_INTERFACE 0x05
#define USB_DEVICE_CLASS_POWER              0x06
#define USB_DEVICE_CLASS_PRINTER            0x07
#define USB_DEVICE_CLASS_STORAGE            0x08
#define USB_DEVICE_CLASS_HUB                0x09
#define USB_DEVICE_CLASS_VENDOR_SPECIFIC    0xFF

#define USB_FEATURE_ENDPOINT_STALL        0x0000
#define USB_FEATURE_REMOTE_WAKEUP         0x0001

#define USB_FEATURE_INTERFACE_POWER_D0    0x0002
#define USB_FEATURE_INTERFACE_POWER_D1    0x0003
#define USB_FEATURE_INTERFACE_POWER_D2    0x0004
#define USB_FEATURE_INTERFACE_POWER_D3    0x0005

typedef struct _USB_DEVICE_DESCRIPTOR {
  UCHAR bLength;
  UCHAR bDescriptorType;
  USHORT bcdUSB;
  UCHAR bDeviceClass;
  UCHAR bDeviceSubClass;
  UCHAR bDeviceProtocol;
  UCHAR bMaxPacketSize0;
  USHORT idVendor;
  USHORT idProduct;
  USHORT bcdDevice;
  UCHAR iManufacturer;
  UCHAR iProduct;
  UCHAR iSerialNumber;
  UCHAR bNumConfigurations;
} USB_DEVICE_DESCRIPTOR, *PUSB_DEVICE_DESCRIPTOR;

typedef struct _USB_ENDPOINT_DESCRIPTOR {
  UCHAR bLength;
  UCHAR bDescriptorType;
  UCHAR bEndpointAddress;
  UCHAR bmAttributes;
  USHORT wMaxPacketSize;
  UCHAR bInterval;
} USB_ENDPOINT_DESCRIPTOR, *PUSB_ENDPOINT_DESCRIPTOR;

typedef struct _USB_CONFIGURATION_DESCRIPTOR {
  UCHAR bLength;
  UCHAR bDescriptorType;
  USHORT wTotalLength;
  UCHAR bNumInterfaces;
  UCHAR bConfigurationValue;
  UCHAR iConfiguration;
  UCHAR bmAttributes;
  UCHAR MaxPower;
} USB_CONFIGURATION_DESCRIPTOR, *PUSB_CONFIGURATION_DESCRIPTOR;

typedef struct _USB_INTERFACE_DESCRIPTOR {
  UCHAR bLength;
  UCHAR bDescriptorType;
  UCHAR bInterfaceNumber;
  UCHAR bAlternateSetting;
  UCHAR bNumEndpoints;
  UCHAR bInterfaceClass;
  UCHAR bInterfaceSubClass;
  UCHAR bInterfaceProtocol;
  UCHAR iInterface;
} USB_INTERFACE_DESCRIPTOR, *PUSB_INTERFACE_DESCRIPTOR;

typedef struct _USB_STRING_DESCRIPTOR {
  UCHAR bLength;
  UCHAR bDescriptorType;
  WCHAR bString[1];
} USB_STRING_DESCRIPTOR, *PUSB_STRING_DESCRIPTOR;

typedef struct _USB_COMMON_DESCRIPTOR {
  UCHAR bLength;
  UCHAR bDescriptorType;
} USB_COMMON_DESCRIPTOR, *PUSB_COMMON_DESCRIPTOR;

typedef struct _USB_HUB_DESCRIPTOR {
  UCHAR bDescriptorLength;
  UCHAR bDescriptorType;
  UCHAR bNumberOfPorts;
  USHORT wHubCharacteristics;
  UCHAR bPowerOnToPowerGood;
  UCHAR bHubControlCurrent;
  UCHAR bRemoveAndPowerMask[64];
} USB_HUB_DESCRIPTOR, *PUSB_HUB_DESCRIPTOR;

#define USB_SUPPORT_D0_COMMAND            0x01
#define USB_SUPPORT_D1_COMMAND            0x02
#define USB_SUPPORT_D2_COMMAND            0x04
#define USB_SUPPORT_D3_COMMAND            0x08

#define USB_SUPPORT_D1_WAKEUP             0x10
#define USB_SUPPORT_D2_WAKEUP             0x20

typedef struct _USB_CONFIGURATION_POWER_DESCRIPTOR {
  UCHAR bLength;
  UCHAR bDescriptorType;
  UCHAR SelfPowerConsumedD0[3];
  UCHAR bPowerSummaryId;
  UCHAR bBusPowerSavingD1;
  UCHAR bSelfPowerSavingD1;
  UCHAR bBusPowerSavingD2;
  UCHAR bSelfPowerSavingD2;
  UCHAR bBusPowerSavingD3;
  UCHAR bSelfPowerSavingD3;
  USHORT TransitionTimeFromD1;
  USHORT TransitionTimeFromD2;
  USHORT TransitionTimeFromD3;
} USB_CONFIGURATION_POWER_DESCRIPTOR, *PUSB_CONFIGURATION_POWER_DESCRIPTOR;

typedef struct _USB_INTERFACE_POWER_DESCRIPTOR {
  UCHAR bLength;
  UCHAR bDescriptorType;
  UCHAR bmCapabilitiesFlags;
  UCHAR bBusPowerSavingD1;
  UCHAR bSelfPowerSavingD1;
  UCHAR bBusPowerSavingD2;
  UCHAR bSelfPowerSavingD2;
  UCHAR bBusPowerSavingD3;
  UCHAR bSelfPowerSavingD3;
  USHORT TransitionTimeFromD1;
  USHORT TransitionTimeFromD2;
  USHORT TransitionTimeFromD3;
} USB_INTERFACE_POWER_DESCRIPTOR, *PUSB_INTERFACE_POWER_DESCRIPTOR;

#include <poppack.h>

#ifdef __cplusplus
}
#endif
                                                                                                                                                                                                                                                                       usr/share/mingw-w64/include/usb200.h                                                                0100644 0000000 0000000 00000005651 12404413016 015530  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * usb200.h
 *
 * This file is part of the ReactOS PSDK package.
 *
 * Contributors:
 *   Magnus Olsen.
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#include "usb100.h"

#include <pshpack1.h>

typedef enum _USB_DEVICE_TYPE {
  Usb11Device = 0,
  Usb20Device
} USB_DEVICE_TYPE;

typedef enum _USB_DEVICE_SPEED {
  UsbLowSpeed = 0,
  UsbFullSpeed,
  UsbHighSpeed
} USB_DEVICE_SPEED;

#define USB_PORT_STATUS_CONNECT                       0x0001
#define USB_PORT_STATUS_ENABLE                        0x0002
#define USB_PORT_STATUS_SUSPEND                       0x0004
#define USB_PORT_STATUS_OVER_CURRENT                  0x0008
#define USB_PORT_STATUS_RESET                         0x0010
#define USB_PORT_STATUS_POWER                         0x0100
#define USB_PORT_STATUS_LOW_SPEED                     0x0200
#define USB_PORT_STATUS_HIGH_SPEED                    0x0400


typedef union _BM_REQUEST_TYPE {
  struct _BM {
    UCHAR Recipient:2;
    UCHAR Reserved:3;
    UCHAR Type:2;
    UCHAR Dir:1;
  } _BM;
  UCHAR B;
} BM_REQUEST_TYPE, *PBM_REQUEST_TYPE;

typedef struct _USB_DEFAULT_PIPE_SETUP_PACKET {
  BM_REQUEST_TYPE bmRequestType;
  UCHAR bRequest;
  union _wValue {
    __C89_NAMELESS struct {
      UCHAR LowByte;
      UCHAR HiByte;
    };
    USHORT W;
  } wValue;
  union _wIndex {
    __C89_NAMELESS struct {
      UCHAR LowByte;
      UCHAR HiByte;
    };
    USHORT W;
  } wIndex;
  USHORT wLength;
} USB_DEFAULT_PIPE_SETUP_PACKET, *PUSB_DEFAULT_PIPE_SETUP_PACKET;

C_ASSERT(sizeof(USB_DEFAULT_PIPE_SETUP_PACKET) == 8);

#define USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE          0x06
#define USB_OTHER_SPEED_CONFIGURATION_DESCRIPTOR_TYPE 0x07

typedef struct _USB_DEVICE_QUALIFIER_DESCRIPTOR {
  UCHAR bLength;
  UCHAR bDescriptorType;
  USHORT bcdUSB;
  UCHAR bDeviceClass;
  UCHAR bDeviceSubClass;
  UCHAR bDeviceProtocol;
  UCHAR bMaxPacketSize0;
  UCHAR bNumConfigurations;
  UCHAR bReserved;
} USB_DEVICE_QUALIFIER_DESCRIPTOR, *PUSB_DEVICE_QUALIFIER_DESCRIPTOR;

typedef union _USB_HIGH_SPEED_MAXPACKET {
  struct _MP {
    USHORT MaxPacket:11;
    USHORT HSmux:2;
    USHORT Reserved:3;
  } _MP;
  USHORT us;
} USB_HIGH_SPEED_MAXPACKET, *PUSB_HIGH_SPEED_MAXPACKET;

#define USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE     0x0B

typedef struct _USB_INTERFACE_ASSOCIATION_DESCRIPTOR {
  UCHAR bLength;
  UCHAR bDescriptorType;
  UCHAR bFirstInterface;
  UCHAR bInterfaceCount;
  UCHAR bFunctionClass;
  UCHAR bFunctionSubClass;
  UCHAR bFunctionProtocol;
  UCHAR iFunction;
} USB_INTERFACE_ASSOCIATION_DESCRIPTOR, *PUSB_INTERFACE_ASSOCIATION_DESCRIPTOR;

#include <poppack.h>

                                                                                       usr/share/mingw-w64/include/usbcamdi.h                                                              0100644 0000000 0000000 00000022601 12404413016 016276  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * usbcamdi.h
 *
 * USB Camera driver interface.
 *
 * This file is part of the ReactOS PSDK package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_BATTERYCLASS_)
# define USBCAMAPI
#else
# define USBCAMAPI DECLSPEC_IMPORT
#endif

typedef struct _pipe_config_descriptor {
  CHAR StreamAssociation;
  UCHAR PipeConfigFlags;
} USBCAMD_Pipe_Config_Descriptor, *PUSBCAMD_Pipe_Config_Descriptor;

#define USBCAMD_DATA_PIPE                 0x0001
#define USBCAMD_MULTIPLEX_PIPE            0x0002
#define USBCAMD_SYNC_PIPE                 0x0004
#define USBCAMD_DONT_CARE_PIPE            0x0008

#define USBCAMD_VIDEO_STREAM              0x1
#define USBCAMD_STILL_STREAM              0x2
#define USBCAMD_VIDEO_STILL_STREAM        (USBCAMD_VIDEO_STREAM | USBCAMD_STILL_STREAM)

#define USBCAMD_PROCESSPACKETEX_DropFrame             0x0002
#define USBCAMD_PROCESSPACKETEX_NextFrameIsStill      0x0004
#define USBCAMD_PROCESSPACKETEX_CurrentFrameIsStill   0x0008

#define USBCAMD_STOP_STREAM               0x00000001
#define USBCAMD_START_STREAM              0x00000000

typedef enum {
  USBCAMD_CamControlFlag_NoVideoRawProcessing = 1,
  USBCAMD_CamControlFlag_NoStillRawProcessing = 2,
  USBCAMD_CamControlFlag_AssociatedFormat = 4,
  USBCAMD_CamControlFlag_EnableDeviceEvents = 8
} USBCAMD_CamControlFlags;

typedef NTSTATUS
(NTAPI *PCOMMAND_COMPLETE_FUNCTION)(
  PVOID DeviceContext,
  PVOID CommandContext,
  NTSTATUS NtStatus);

typedef VOID
(NTAPI *PSTREAM_RECEIVE_PACKET)(
  PVOID Srb,
  PVOID DeviceContext,
  PBOOLEAN Completed);

typedef NTSTATUS
(NTAPI *PCAM_INITIALIZE_ROUTINE)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext);

typedef NTSTATUS
(NTAPI *PCAM_CONFIGURE_ROUTINE)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext,
  PUSBD_INTERFACE_INFORMATION Interface,
  PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
  PLONG DataPipeIndex,
  PLONG SyncPipeIndex);

typedef NTSTATUS
(NTAPI *PCAM_CONFIGURE_ROUTINE_EX)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext,
  PUSBD_INTERFACE_INFORMATION Interface,
  PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
  ULONG PipeConfigListSize,
  PUSBCAMD_Pipe_Config_Descriptor PipeConfig,
  PUSB_DEVICE_DESCRIPTOR DeviceDescriptor);

typedef NTSTATUS
(NTAPI *PCAM_START_CAPTURE_ROUTINE)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext);

typedef NTSTATUS
(NTAPI *PCAM_START_CAPTURE_ROUTINE_EX)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext,
  ULONG StreamNumber);

typedef NTSTATUS
(NTAPI *PCAM_ALLOCATE_BW_ROUTINE)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext,
  PULONG RawFrameLength,
  PVOID Format);

typedef NTSTATUS
(NTAPI *PCAM_ALLOCATE_BW_ROUTINE_EX)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext,
  PULONG RawFrameLength,
  PVOID Format,
  ULONG StreamNumber);

typedef NTSTATUS
(NTAPI *PCAM_FREE_BW_ROUTINE)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext);

typedef NTSTATUS
(NTAPI *PCAM_FREE_BW_ROUTINE_EX)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext,
  ULONG StreamNumber);

typedef VOID
(NTAPI *PADAPTER_RECEIVE_PACKET_ROUTINE)(
  PHW_STREAM_REQUEST_BLOCK Srb);

typedef NTSTATUS
(NTAPI *PCAM_STOP_CAPTURE_ROUTINE)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext);

typedef NTSTATUS
(NTAPI *PCAM_STOP_CAPTURE_ROUTINE_EX)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext,
  ULONG StreamNumber);

typedef ULONG
(NTAPI *PCAM_PROCESS_PACKET_ROUTINE)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext,
  PVOID CurrentFrameContext,
  PUSBD_ISO_PACKET_DESCRIPTOR SyncPacket,
  PVOID SyncBuffer,
  PUSBD_ISO_PACKET_DESCRIPTOR DataPacket,
  PVOID DataBuffer,
  PBOOLEAN FrameComplete,
  PBOOLEAN NextFrameIsStill);

typedef ULONG
(NTAPI *PCAM_PROCESS_PACKET_ROUTINE_EX)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext,
  PVOID CurrentFrameContext,
  PUSBD_ISO_PACKET_DESCRIPTOR SyncPacket,
  PVOID SyncBuffer,
  PUSBD_ISO_PACKET_DESCRIPTOR DataPacket,
  PVOID DataBuffer,
  PBOOLEAN FrameComplete,
  PULONG PacketFlag,
  PULONG ValidDataOffset);

typedef VOID
(NTAPI *PCAM_NEW_FRAME_ROUTINE)(
  PVOID DeviceContext,
  PVOID FrameContext);

typedef VOID
(NTAPI *PCAM_NEW_FRAME_ROUTINE_EX)(
  PVOID DeviceContext,
  PVOID FrameContext,
  ULONG StreamNumber,
  PULONG FrameLength);

typedef NTSTATUS
(NTAPI *PCAM_PROCESS_RAW_FRAME_ROUTINE)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext,
  PVOID FrameContext,
  PVOID FrameBuffer,
  ULONG FrameLength,
  PVOID RawFrameBuffer,
  ULONG RawFrameLength,
  ULONG NumberOfPackets,
  PULONG BytesReturned);

typedef NTSTATUS
(NTAPI *PCAM_PROCESS_RAW_FRAME_ROUTINE_EX)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext,
  PVOID FrameContext,
  PVOID FrameBuffer,
  ULONG FrameLength,
  PVOID RawFrameBuffer,
  ULONG RawFrameLength,
  ULONG NumberOfPackets,
  PULONG BytesReturned,
  ULONG ActualRawFrameLength,
  ULONG StreamNumber);

typedef NTSTATUS
(NTAPI *PCAM_STATE_ROUTINE)(
  PDEVICE_OBJECT BusDeviceObject,
  PVOID DeviceContext);

#if defined(DEBUG_LOG)

USBCAMAPI
VOID
NTAPI
USBCAMD_Debug_LogEntry(
  CHAR *Name,
  ULONG Info1,
  ULONG Info2,
  ULONG Info3);

#define ILOGENTRY(sig, info1, info2, info3) \
  USBCAMD_Debug_LogEntry(sig, (ULONG)info1, (ULONG)info2, (ULONG)info3)

#else

#define ILOGENTRY(sig, info1, info2, info3)

#endif /* DEBUG_LOG */

typedef struct _USBCAMD_DEVICE_DATA {
  ULONG Sig;
  PCAM_INITIALIZE_ROUTINE CamInitialize;
  PCAM_INITIALIZE_ROUTINE CamUnInitialize;
  PCAM_PROCESS_PACKET_ROUTINE CamProcessUSBPacket;
  PCAM_NEW_FRAME_ROUTINE CamNewVideoFrame;
  PCAM_PROCESS_RAW_FRAME_ROUTINE CamProcessRawVideoFrame;
  PCAM_START_CAPTURE_ROUTINE CamStartCapture;
  PCAM_STOP_CAPTURE_ROUTINE CamStopCapture;
  PCAM_CONFIGURE_ROUTINE CamConfigure;
  PCAM_STATE_ROUTINE CamSaveState;
  PCAM_STATE_ROUTINE CamRestoreState;
  PCAM_ALLOCATE_BW_ROUTINE CamAllocateBandwidth;
  PCAM_FREE_BW_ROUTINE CamFreeBandwidth;
} USBCAMD_DEVICE_DATA, *PUSBCAMD_DEVICE_DATA;

typedef struct _USBCAMD_DEVICE_DATA2 {
  ULONG Sig;
  PCAM_INITIALIZE_ROUTINE CamInitialize;
  PCAM_INITIALIZE_ROUTINE CamUnInitialize;
  PCAM_PROCESS_PACKET_ROUTINE_EX CamProcessUSBPacketEx;
  PCAM_NEW_FRAME_ROUTINE_EX CamNewVideoFrameEx;
  PCAM_PROCESS_RAW_FRAME_ROUTINE_EX CamProcessRawVideoFrameEx;
  PCAM_START_CAPTURE_ROUTINE_EX CamStartCaptureEx;
  PCAM_STOP_CAPTURE_ROUTINE_EX CamStopCaptureEx;
  PCAM_CONFIGURE_ROUTINE_EX CamConfigureEx;
  PCAM_STATE_ROUTINE CamSaveState;
  PCAM_STATE_ROUTINE CamRestoreState;
  PCAM_ALLOCATE_BW_ROUTINE_EX CamAllocateBandwidthEx;
  PCAM_FREE_BW_ROUTINE_EX CamFreeBandwidthEx;
} USBCAMD_DEVICE_DATA2, *PUSBCAMD_DEVICE_DATA2;

DEFINE_GUID(GUID_USBCAMD_INTERFACE,
  0x2bcb75c0, 0xb27f, 0x11d1, 0xba, 0x41, 0x0, 0xa0, 0xc9, 0xd, 0x2b, 0x5);

typedef NTSTATUS
(NTAPI *PFNUSBCAMD_SetVideoFormat)(
  PVOID DeviceContext,
  PHW_STREAM_REQUEST_BLOCK pSrb);

typedef NTSTATUS
(NTAPI *PFNUSBCAMD_WaitOnDeviceEvent)(
  PVOID DeviceContext,
  ULONG PipeIndex,
  PVOID Buffer,
  ULONG BufferLength,
  PCOMMAND_COMPLETE_FUNCTION EventComplete,
  PVOID EventContext,
  BOOLEAN LoopBack);

typedef NTSTATUS
(NTAPI *PFNUSBCAMD_CancelBulkReadWrite)(
  PVOID DeviceContext,
  ULONG PipeIndex);

typedef NTSTATUS
(NTAPI *PFNUSBCAMD_SetIsoPipeState)(
  PVOID DeviceContext,
  ULONG PipeStateFlags);

typedef NTSTATUS
(NTAPI *PFNUSBCAMD_BulkReadWrite)(
  PVOID DeviceContext,
  USHORT PipeIndex,
  PVOID Buffer,
  ULONG BufferLength,
  PCOMMAND_COMPLETE_FUNCTION CommandComplete,
  PVOID CommandContext);

#define USBCAMD_VERSION_200               0x200

typedef struct _USBCAMD_INTERFACE {
  INTERFACE Interface;
  PFNUSBCAMD_WaitOnDeviceEvent USBCAMD_WaitOnDeviceEvent;
  PFNUSBCAMD_BulkReadWrite USBCAMD_BulkReadWrite;
  PFNUSBCAMD_SetVideoFormat USBCAMD_SetVideoFormat;
  PFNUSBCAMD_SetIsoPipeState USBCAMD_SetIsoPipeState;
  PFNUSBCAMD_CancelBulkReadWrite USBCAMD_CancelBulkReadWrite;
} USBCAMD_INTERFACE, *PUSBCAMD_INTERFACE;

/* FIXME : Do we need USBCAMAPI here ? */

USBCAMAPI
ULONG
NTAPI
USBCAMD_DriverEntry(
  PVOID Context1,
  PVOID Context2,
  ULONG DeviceContextSize,
  ULONG FrameContextSize,
  PADAPTER_RECEIVE_PACKET_ROUTINE ReceivePacket);

USBCAMAPI
PVOID
NTAPI
USBCAMD_AdapterReceivePacket(
  PHW_STREAM_REQUEST_BLOCK Srb,
  PUSBCAMD_DEVICE_DATA DeviceData,
  PDEVICE_OBJECT *DeviceObject,
  BOOLEAN NeedsCompletion);

USBCAMAPI
NTSTATUS
NTAPI
USBCAMD_ControlVendorCommand(
  PVOID DeviceContext,
  UCHAR Request,
  USHORT Value,
  USHORT Index,
  PVOID Buffer,
  PULONG BufferLength,
  BOOLEAN GetData,
  PCOMMAND_COMPLETE_FUNCTION CommandComplete,
  PVOID CommandContext);

USBCAMAPI
NTSTATUS
NTAPI
USBCAMD_SelectAlternateInterface(
  PVOID DeviceContext,
  PUSBD_INTERFACE_INFORMATION RequestInterface);

USBCAMAPI
NTSTATUS
NTAPI
USBCAMD_GetRegistryKeyValue(
  HANDLE Handle,
  PWCHAR KeyNameString,
  ULONG KeyNameStringLength,
  PVOID Data,
  ULONG DataLength);

USBCAMAPI
ULONG
NTAPI
USBCAMD_InitializeNewInterface(
  PVOID DeviceContext,
  PVOID DeviceData,
  ULONG Version,
  ULONG CamControlFlag);

#ifdef __cplusplus
}
#endif

#endif /* !defined(__USB_H) && !defined(__USBDI_H) */
                                                                                                                               usr/share/mingw-w64/include/usbdi.h                                                                 0100644 0000000 0000000 00000004017 12404413016 015616  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * usbdi.h
 *
 * USBD and USB device driver definitions
 *
 * FIXME : Obsolete header.. Use usb.h instead.
 *
 * This file is part of the ReactOS PSDK package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#include <usb.h>
#include <usbioctl.h>

#ifdef __cplusplus
extern "C" {
#endif

#define USBD_STATUS_CANCELLING      ((USBD_STATUS)0x00020000)
#define USBD_STATUS_CANCELING       ((USBD_STATUS)0x00020000)
#define USBD_STATUS_NO_MEMORY       ((USBD_STATUS)0x80000100)
#define USBD_STATUS_ERROR           ((USBD_STATUS)0x80000000)
#define USBD_STATUS_REQUEST_FAILED  ((USBD_STATUS)0x80000500)
#define USBD_STATUS_HALTED          ((USBD_STATUS)0xC0000000)


#define USBD_HALTED(Status)  ((ULONG)(Status) >> 30 == 3)
#define USBD_STATUS(Status) ((ULONG)(Status) & __MSABI_LONG(0x0FFFFFFF))

#define URB_FUNCTION_RESERVED0                      0x0016
#define URB_FUNCTION_RESERVED                       0x001D
#define URB_FUNCTION_LAST                           0x0029

#define USBD_PF_DOUBLE_BUFFER           0x00000002

#ifdef USBD_PF_VALID_MASK
#undef USBD_PF_VALID_MASK
#endif

#define USBD_PF_VALID_MASK    (USBD_PF_CHANGE_MAX_PACKET | USBD_PF_DOUBLE_BUFFER | \
                              USBD_PF_ENABLE_RT_THREAD_ACCESS | USBD_PF_MAP_ADD_TRANSFERS)

#define USBD_TRANSFER_DIRECTION_BIT             0
#define USBD_SHORT_TRANSFER_OK_BIT              1
#define USBD_START_ISO_TRANSFER_ASAP_BIT        2

#ifdef USBD_TRANSFER_DIRECTION
#undef USBD_TRANSFER_DIRECTION
#endif

#define USBD_TRANSFER_DIRECTION(x)      ((x) & USBD_TRANSFER_DIRECTION_IN)

#ifdef __cplusplus
}
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/share/mingw-w64/include/usbioctl.h                                                              0100644 0000000 0000000 00000046341 12404413016 016342  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * usbioctl.h
 *
 * USB IOCTL interface.
 *
 * This file is part of the ReactOS PSDK package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#include "usb100.h"
#include "usbiodef.h"

#define IOCTL_INTERNAL_USB_SUBMIT_URB  \
  CTL_CODE(FILE_DEVICE_USB, USB_SUBMIT_URB, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_RESET_PORT \
  CTL_CODE(FILE_DEVICE_USB, USB_RESET_PORT, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_ROOTHUB_PDO, METHOD_NEITHER, FILE_ANY_ACCESS)

#define USBD_PORT_ENABLED                 1
#define USBD_PORT_CONNECTED               2

#define IOCTL_INTERNAL_USB_GET_PORT_STATUS \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_PORT_STATUS, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_ENABLE_PORT \
  CTL_CODE(FILE_DEVICE_USB, USB_ENABLE_PORT, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_HUB_COUNT \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_HUB_COUNT, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_CYCLE_PORT \
  CTL_CODE(FILE_DEVICE_USB, USB_CYCLE_PORT, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_HUB_NAME \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_HUB_NAME, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_BUS_INFO \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_BUS_INFO, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_CONTROLLER_NAME, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_BUSGUID_INFO \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_BUSGUID_INFO, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_PARENT_HUB_INFO, METHOD_BUFFERED, FILE_ANY_ACCESS)

#if (_WIN32_WINNT >= 0x0501)

#define IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION \
  CTL_CODE(FILE_DEVICE_USB, USB_IDLE_NOTIFICATION, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_DEVICE_HANDLE, METHOD_NEITHER, FILE_ANY_ACCESS)

#endif

#if (_WIN32_WINNT >= 0x0600)

#define IOCTL_INTERNAL_USB_NOTIFY_IDLE_READY \
  CTL_CODE(FILE_DEVICE_USB, USB_IDLE_NOTIFICATION_EX, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_REQ_GLOBAL_SUSPEND \
  CTL_CODE(FILE_DEVICE_USB, USB_REQ_GLOBAL_SUSPEND, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_REQ_GLOBAL_RESUME \
  CTL_CODE(FILE_DEVICE_USB, USB_REQ_GLOBAL_RESUME, METHOD_NEITHER, FILE_ANY_ACCESS)

#ifdef USB20_API
typedef struct _USB_START_FAILDATA {
  ULONG LengthInBytes;
  NTSTATUS NtStatus;
  USBD_STATUS UsbdStatus;
  ULONG ConnectStatus;
  UCHAR DriverData[4];
} USB_START_FAILDATA, *PUSB_START_FAILDATA;
#endif

#define IOCTL_INTERNAL_USB_RECORD_FAILURE \
  CTL_CODE(FILE_DEVICE_USB, USB_RECORD_FAILURE, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE_EX \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_DEVICE_HANDLE_EX, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_TT_DEVICE_HANDLE \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_TT_DEVICE_HANDLE, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct _USB_TOPOLOGY_ADDRESS {
  ULONG PciBusNumber;
  ULONG PciDeviceNumber;
  ULONG PciFunctionNumber;
  ULONG Reserved;
  USHORT RootHubPortNumber;
  USHORT HubPortNumber[5];
  USHORT Reserved2;
} USB_TOPOLOGY_ADDRESS, *PUSB_TOPOLOGY_ADDRESS;

#define IOCTL_INTERNAL_USB_GET_TOPOLOGY_ADDRESS \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_TOPOLOGY_ADDRESS, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_USB_GET_DEVICE_CONFIG_INFO \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_HUB_CONFIG_INFO, METHOD_NEITHER, FILE_ANY_ACCESS)

#endif /* _WIN32_WINNT >= 0x0600 */

#ifndef USB_KERNEL_IOCTL

#define IOCTL_USB_HCD_GET_STATS_1 \
  CTL_CODE(FILE_DEVICE_USB, HCD_GET_STATS_1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_HCD_GET_STATS_2 \
  CTL_CODE(FILE_DEVICE_USB, HCD_GET_STATS_2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_HCD_DISABLE_PORT \
  CTL_CODE(FILE_DEVICE_USB, HCD_DISABLE_PORT, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_HCD_ENABLE_PORT \
  CTL_CODE(FILE_DEVICE_USB, HCD_ENABLE_PORT, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_HCD_DISABLE_PORT \
  CTL_CODE(FILE_DEVICE_USB, HCD_DISABLE_PORT, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_HCD_ENABLE_PORT \
  CTL_CODE(FILE_DEVICE_USB, HCD_ENABLE_PORT, METHOD_BUFFERED, FILE_ANY_ACCESS)

#ifndef IOCTL_USB_DIAGNOSTIC_MODE_OFF
#define IOCTL_USB_DIAGNOSTIC_MODE_OFF \
  CTL_CODE(FILE_DEVICE_USB, HCD_DIAGNOSTIC_MODE_OFF, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#ifndef IOCTL_USB_DIAGNOSTIC_MODE_ON
#define IOCTL_USB_DIAGNOSTIC_MODE_ON \
  CTL_CODE(FILE_DEVICE_USB, HCD_DIAGNOSTIC_MODE_ON, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#ifndef IOCTL_USB_GET_ROOT_HUB_NAME
#define IOCTL_USB_GET_ROOT_HUB_NAME \
  CTL_CODE(FILE_DEVICE_USB, HCD_GET_ROOT_HUB_NAME, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#ifndef IOCTL_GET_HCD_DRIVERKEY_NAME
#define IOCTL_GET_HCD_DRIVERKEY_NAME \
  CTL_CODE(FILE_DEVICE_USB, HCD_GET_DRIVERKEY_NAME, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#define IOCTL_USB_GET_NODE_INFORMATION \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_NODE_INFORMATION, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_GET_NODE_CONNECTION_INFORMATION \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_NODE_CONNECTION_INFORMATION, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_GET_NODE_CONNECTION_NAME \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_NODE_CONNECTION_NAME, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_DIAG_IGNORE_HUBS_ON \
  CTL_CODE(FILE_DEVICE_USB, USB_DIAG_IGNORE_HUBS_ON, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_DIAG_IGNORE_HUBS_OFF \
  CTL_CODE(FILE_DEVICE_USB, USB_DIAG_IGNORE_HUBS_OFF, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_NODE_CONNECTION_DRIVERKEY_NAME, METHOD_BUFFERED, FILE_ANY_ACCESS)

#if (_WIN32_WINNT >= 0x0501)

#define IOCTL_USB_GET_HUB_CAPABILITIES \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_HUB_CAPABILITIES, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_HUB_CYCLE_PORT \
  CTL_CODE(FILE_DEVICE_USB, USB_HUB_CYCLE_PORT, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_GET_NODE_CONNECTION_ATTRIBUTES \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_NODE_CONNECTION_ATTRIBUTES, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_NODE_CONNECTION_INFORMATION_EX, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif /* _WIN32_WINNT >= 0x0501 */

#if (_WIN32_WINNT >= 0x0600)

#define IOCTL_USB_RESET_HUB \
  CTL_CODE(FILE_DEVICE_USB, USB_RESET_HUB, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_USB_GET_HUB_CAPABILITIES_EX \
  CTL_CODE(FILE_DEVICE_USB, USB_GET_HUB_CAPABILITIES_EX, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif /* _WIN32_WINNT >= 0x0600 */

#include <pshpack1.h>

typedef enum _USB_HUB_NODE {
  UsbHub,
  UsbMIParent
} USB_HUB_NODE;

typedef struct _USB_HUB_INFORMATION {
  USB_HUB_DESCRIPTOR HubDescriptor;
  BOOLEAN HubIsBusPowered;
} USB_HUB_INFORMATION, *PUSB_HUB_INFORMATION;

typedef struct _USB_MI_PARENT_INFORMATION {
  ULONG NumberOfInterfaces;
} USB_MI_PARENT_INFORMATION, *PUSB_MI_PARENT_INFORMATION;

typedef struct _USB_NODE_INFORMATION {
  USB_HUB_NODE NodeType;
  union {
    USB_HUB_INFORMATION HubInformation;
    USB_MI_PARENT_INFORMATION MiParentInformation;
  } u;
} USB_NODE_INFORMATION, *PUSB_NODE_INFORMATION;

typedef struct _USB_PIPE_INFO {
  USB_ENDPOINT_DESCRIPTOR EndpointDescriptor;
  ULONG ScheduleOffset;
} USB_PIPE_INFO, *PUSB_PIPE_INFO;

#if (_WIN32_WINNT >= 0x0600)

typedef enum _USB_CONNECTION_STATUS {
  NoDeviceConnected,
  DeviceConnected,
  DeviceFailedEnumeration,
  DeviceGeneralFailure,
  DeviceCausedOvercurrent,
  DeviceNotEnoughPower,
  DeviceNotEnoughBandwidth,
  DeviceHubNestedTooDeeply,
  DeviceInLegacyHub,
  DeviceEnumerating,
  DeviceReset
} USB_CONNECTION_STATUS, *PUSB_CONNECTION_STATUS;

#elif (_WIN32_WINNT >= 0x0501)

typedef enum _USB_CONNECTION_STATUS {
  NoDeviceConnected,
  DeviceConnected,
  DeviceFailedEnumeration,
  DeviceGeneralFailure,
  DeviceCausedOvercurrent,
  DeviceNotEnoughPower,
  DeviceNotEnoughBandwidth,
  DeviceHubNestedTooDeeply,
  DeviceInLegacyHub
} USB_CONNECTION_STATUS, *PUSB_CONNECTION_STATUS;

#else /* _WIN32_WINNT >= 0x0501 */

typedef enum _USB_CONNECTION_STATUS {
  NoDeviceConnected,
  DeviceConnected,
  DeviceFailedEnumeration,
  DeviceGeneralFailure,
  DeviceCausedOvercurrent,
  DeviceNotEnoughPower,
  DeviceNotEnoughBandwidth
} USB_CONNECTION_STATUS, *PUSB_CONNECTION_STATUS;

#endif /* _WIN32_WINNT >= 0x0501 */

typedef struct _USB_NODE_CONNECTION_INFORMATION {
  ULONG ConnectionIndex;
  USB_DEVICE_DESCRIPTOR DeviceDescriptor;
  UCHAR CurrentConfigurationValue;
  BOOLEAN LowSpeed;
  BOOLEAN DeviceIsHub;
  USHORT DeviceAddress;
  ULONG NumberOfOpenPipes;
  USB_CONNECTION_STATUS ConnectionStatus;
  USB_PIPE_INFO PipeList[0];
} USB_NODE_CONNECTION_INFORMATION, *PUSB_NODE_CONNECTION_INFORMATION;

typedef struct _USB_NODE_CONNECTION_DRIVERKEY_NAME {
  ULONG ConnectionIndex;
  ULONG ActualLength;
  WCHAR DriverKeyName[1];
} USB_NODE_CONNECTION_DRIVERKEY_NAME, *PUSB_NODE_CONNECTION_DRIVERKEY_NAME;

typedef struct _USB_NODE_CONNECTION_NAME {
  ULONG ConnectionIndex;
  ULONG ActualLength;
  WCHAR NodeName[1];
} USB_NODE_CONNECTION_NAME, *PUSB_NODE_CONNECTION_NAME;

typedef struct _USB_HUB_NAME {
  ULONG ActualLength;
  WCHAR HubName[1];
} USB_HUB_NAME, *PUSB_HUB_NAME;

typedef struct _USB_ROOT_HUB_NAME {
  ULONG ActualLength;
  WCHAR RootHubName[1];
} USB_ROOT_HUB_NAME, *PUSB_ROOT_HUB_NAME;

typedef struct _USB_HCD_DRIVERKEY_NAME {
  ULONG ActualLength;
  WCHAR DriverKeyName[1];
} USB_HCD_DRIVERKEY_NAME, *PUSB_HCD_DRIVERKEY_NAME;

typedef struct _USB_DESCRIPTOR_REQUEST {
  ULONG ConnectionIndex;
  struct {
    UCHAR bmRequest;
    UCHAR bRequest;
    USHORT wValue;
    USHORT wIndex;
    USHORT wLength;
  } SetupPacket;
  UCHAR Data[0];
} USB_DESCRIPTOR_REQUEST, *PUSB_DESCRIPTOR_REQUEST;

#if (_WIN32_WINNT >= 0x0501)

typedef struct _USB_HUB_CAPABILITIES {
  ULONG  HubIs2xCapable:1;
} USB_HUB_CAPABILITIES, *PUSB_HUB_CAPABILITIES;

typedef struct _USB_NODE_CONNECTION_ATTRIBUTES {
  ULONG ConnectionIndex;
  USB_CONNECTION_STATUS ConnectionStatus;
  ULONG PortAttributes;
} USB_NODE_CONNECTION_ATTRIBUTES, *PUSB_NODE_CONNECTION_ATTRIBUTES;

typedef struct _USB_NODE_CONNECTION_INFORMATION_EX {
  ULONG ConnectionIndex;
  USB_DEVICE_DESCRIPTOR DeviceDescriptor;
  UCHAR CurrentConfigurationValue;
  UCHAR Speed;
  BOOLEAN DeviceIsHub;
  USHORT DeviceAddress;
  ULONG NumberOfOpenPipes;
  USB_CONNECTION_STATUS ConnectionStatus;
  USB_PIPE_INFO PipeList[0];
} USB_NODE_CONNECTION_INFORMATION_EX, *PUSB_NODE_CONNECTION_INFORMATION_EX;

C_ASSERT(sizeof(USB_NODE_CONNECTION_INFORMATION_EX) == sizeof(USB_NODE_CONNECTION_INFORMATION));

#endif /* _WIN32_WINNT >= 0x0501 */

#if (_WIN32_WINNT >= 0x0600)

typedef union _USB_HUB_CAP_FLAGS {
  ULONG ul;
  __C89_NAMELESS struct {
    ULONG HubIsHighSpeedCapable:1;
    ULONG HubIsHighSpeed:1;
    ULONG HubIsMultiTtCapable:1;
    ULONG HubIsMultiTt:1;
    ULONG HubIsRoot:1;
    ULONG HubIsArmedWakeOnConnect:1;
    ULONG HubIsBusPowered:1;
    ULONG ReservedMBZ:25;
  };
} USB_HUB_CAP_FLAGS, *PUSB_HUB_CAP_FLAGS;

C_ASSERT(sizeof(USB_HUB_CAP_FLAGS) == sizeof(ULONG));

typedef struct _USB_HUB_CAPABILITIES_EX {
  USB_HUB_CAP_FLAGS CapabilityFlags;
} USB_HUB_CAPABILITIES_EX, *PUSB_HUB_CAPABILITIES_EX;

typedef struct _USB_CYCLE_PORT_PARAMS {
  ULONG ConnectionIndex;
  ULONG StatusReturned;
} USB_CYCLE_PORT_PARAMS, *PUSB_CYCLE_PORT_PARAMS;

typedef struct _USB_ID_STRING {
  USHORT LanguageId;
  USHORT Pad;
  ULONG LengthInBytes;
  PWCHAR Buffer;
} USB_ID_STRING, *PUSB_ID_STRING;

typedef struct _USB_HUB_DEVICE_UXD_SETTINGS {
  ULONG Version;
  GUID PnpGuid;
  GUID OwnerGuid;
  ULONG DeleteOnShutdown;
  ULONG DeleteOnReload;
  ULONG DeleteOnDisconnect;
  ULONG Reserved[5];
} USB_HUB_DEVICE_UXD_SETTINGS, *PUSB_HUB_DEVICE_UXD_SETTINGS;

typedef struct _HUB_DEVICE_CONFIG_INFO_V1 {
  ULONG Version;
  ULONG Length;
  USB_HUB_CAP_FLAGS HubFlags;
  USB_ID_STRING HardwareIds;
  USB_ID_STRING CompatibleIds;
  USB_ID_STRING DeviceDescription;
  ULONG Reserved[19];
  USB_HUB_DEVICE_UXD_SETTINGS UxdSettings;
} HUB_DEVICE_CONFIG_INFO, *PHUB_DEVICE_CONFIG_INFO;

#endif /* _WIN32_WINNT >= 0x0600 */

typedef struct _HCD_ISO_STAT_COUNTERS {
  USHORT LateUrbs;
  USHORT DoubleBufferedPackets;
  USHORT TransfersCF_5ms;
  USHORT TransfersCF_2ms;
  USHORT TransfersCF_1ms;
  USHORT MaxInterruptLatency;
  USHORT BadStartFrame;
  USHORT StaleUrbs;
  USHORT IsoPacketNotAccesed;
  USHORT IsoPacketHWError;
  USHORT SmallestUrbPacketCount;
  USHORT LargestUrbPacketCount;
  USHORT IsoCRC_Error;
  USHORT IsoOVERRUN_Error;
  USHORT IsoINTERNAL_Error;
  USHORT IsoUNKNOWN_Error;
  ULONG IsoBytesTransferred;
  USHORT LateMissedCount;
  USHORT HWIsoMissedCount;
  ULONG Reserved7[8];
} HCD_ISO_STAT_COUNTERS, *PHCD_ISO_STAT_COUNTERS;

typedef struct _HCD_STAT_COUNTERS {
  ULONG BytesTransferred;
  USHORT IsoMissedCount;
  USHORT DataOverrunErrorCount;
  USHORT CrcErrorCount;
  USHORT ScheduleOverrunCount;
  USHORT TimeoutErrorCount;
  USHORT InternalHcErrorCount;
  USHORT BufferOverrunErrorCount;
  USHORT SWErrorCount;
  USHORT StallPidCount;
  USHORT PortDisableCount;
} HCD_STAT_COUNTERS, *PHCD_STAT_COUNTERS;

typedef struct _HCD_STAT_INFORMATION_1 {
  ULONG Reserved1;
  ULONG Reserved2;
  ULONG ResetCounters;
  LARGE_INTEGER TimeRead;
  HCD_STAT_COUNTERS Counters;
} HCD_STAT_INFORMATION_1, *PHCD_STAT_INFORMATION_1;

typedef struct _HCD_STAT_INFORMATION_2 {
  ULONG Reserved1;
  ULONG Reserved2;
  ULONG ResetCounters;
  LARGE_INTEGER TimeRead;
  LONG LockedMemoryUsed;
  HCD_STAT_COUNTERS Counters;
  HCD_ISO_STAT_COUNTERS IsoCounters;
} HCD_STAT_INFORMATION_2, *PHCD_STAT_INFORMATION_2;

#define WMI_USB_DRIVER_INFORMATION        0
#define WMI_USB_DRIVER_NOTIFICATION       1
#define WMI_USB_POWER_DEVICE_ENABLE       2
#define WMI_USB_HUB_NODE_INFORMATION      4

#define WMI_USB_PERFORMANCE_INFORMATION   1
#define WMI_USB_DEVICE_NODE_INFORMATION   2

#if (_WIN32_WINNT >= 0x0501)

typedef enum _USB_NOTIFICATION_TYPE {
  EnumerationFailure = 0,
  InsufficentBandwidth,
  InsufficentPower,
  OverCurrent,
  ResetOvercurrent,
  AcquireBusInfo,
  AcquireHubName,
  AcquireControllerName,
  HubOvercurrent,
  HubPowerChange,
  HubNestedTooDeeply,
  ModernDeviceInLegacyHub
} USB_NOTIFICATION_TYPE;

#else /* _WIN32_WINNT >= 0x0501 */

typedef enum _USB_NOTIFICATION_TYPE {
  EnumerationFailure = 0,
  InsufficentBandwidth,
  InsufficentPower,
  OverCurrent,
  ResetOvercurrent,
  AcquireBusInfo,
  AcquireHubName,
  AcquireControllerName,
  HubOvercurrent,
  HubPowerChange
} USB_NOTIFICATION_TYPE;

#endif /* _WIN32_WINNT >= 0x0501 */

typedef struct _USB_NOTIFICATION {
  USB_NOTIFICATION_TYPE NotificationType;
} USB_NOTIFICATION, *PUSB_NOTIFICATION;

typedef struct _USB_CONNECTION_NOTIFICATION {
  USB_NOTIFICATION_TYPE NotificationType;
  ULONG ConnectionNumber;
  ULONG RequestedBandwidth;
  ULONG EnumerationFailReason;
  ULONG PowerRequested;
  ULONG HubNameLength;
} USB_CONNECTION_NOTIFICATION, *PUSB_CONNECTION_NOTIFICATION;

typedef struct _USB_BUS_NOTIFICATION {
  USB_NOTIFICATION_TYPE NotificationType;
  ULONG TotalBandwidth;
  ULONG ConsumedBandwidth;
  ULONG ControllerNameLength;
} USB_BUS_NOTIFICATION, *PUSB_BUS_NOTIFICATION;

typedef struct _USB_ACQUIRE_INFO {
  USB_NOTIFICATION_TYPE NotificationType;
  ULONG TotalSize;
  WCHAR Buffer[1];
} USB_ACQUIRE_INFO, *PUSB_ACQUIRE_INFO;

#if (_WIN32_WINNT >= 0x0600)

#define USB_NODE_INFO_SIG 'USBN'

typedef enum _USB_WMI_DEVICE_NODE_TYPE {
  UsbDevice,
  HubDevice,
  CompositeDevice,
  UsbController
} USB_WMI_DEVICE_NODE_TYPE, *PUSB_WMI_DEVICE_NODE_TYPE;

typedef struct _USB_DEVICE_STATE {
  ULONG DeviceConnected:1;
  ULONG DeviceStarted:1;
} USB_DEVICE_STATE, *PUSB_DEVICE_STATE;

typedef struct _USB_HUB_PORT_INFORMATION {
  USB_DEVICE_STATE DeviceState;
  USHORT PortNumber;
  USHORT DeviceAddress;
  ULONG ConnectionIndex;
  USB_CONNECTION_STATUS ConnectionStatus;
} USB_HUB_PORT_INFORMATION, *PUSB_HUB_PORT_INFORMATION;

typedef struct _USB_HUB_DEVICE_INFO {
  USB_HUB_DESCRIPTOR HubDescriptor;
  ULONG HubNumber;
  USHORT DeviceAddress;
  BOOLEAN HubIsSelfPowered;
  BOOLEAN HubIsRootHub;
  USB_HUB_CAPABILITIES HubCapabilities;
  ULONG NumberOfHubPorts;
  USB_HUB_PORT_INFORMATION PortInfo[1];
} USB_HUB_DEVICE_INFO, *PUSB_HUB_DEVICE_INFO;

typedef struct _USB_COMPOSITE_FUNCTION_INFO {
  UCHAR FunctionNumber;
  UCHAR BaseInterfaceNumber;
  UCHAR NumberOfInterfaces;
  BOOLEAN FunctionIsIdle;
} USB_COMPOSITE_FUNCTION_INFO, *PUSB_COMPOSITE_FUNCTION_INFO;

typedef struct _USB_COMPOSITE_DEVICE_INFO {
  USB_DEVICE_DESCRIPTOR DeviceDescriptor;
  USB_CONFIGURATION_DESCRIPTOR CurrentConfigDescriptor;
  UCHAR CurrentConfigurationValue;
  UCHAR NumberOfFunctions;
  USB_COMPOSITE_FUNCTION_INFO FunctionInfo[1];
} USB_COMPOSITE_DEVICE_INFO, *PUSB_COMPOSITE_DEVICE_INFO;

typedef struct _USB_CONTROLLER_DEVICE_INFO {
  ULONG PciVendorId;
  ULONG PciDeviceId;
  ULONG PciRevision;
  ULONG NumberOfRootPorts;
  ULONG HcFeatureFlags;
} USB_CONTROLLER_DEVICE_INFO, *PUSB_CONTROLLER_DEVICE_INFO;

typedef struct _USB_DEVICE_INFO {
  USB_DEVICE_STATE DeviceState;
  USHORT PortNumber;
  USB_DEVICE_DESCRIPTOR DeviceDescriptor;
  UCHAR CurrentConfigurationValue;
  USB_DEVICE_SPEED Speed;
  USHORT DeviceAddress;
  ULONG ConnectionIndex;
  USB_CONNECTION_STATUS ConnectionStatus;
  WCHAR PnpHardwareId[128];
  WCHAR PnpCompatibleId[128];
  WCHAR SerialNumberId[128];
  WCHAR PnpDeviceDescription[128];
  ULONG NumberOfOpenPipes;
  USB_PIPE_INFO PipeList[1];
} USB_DEVICE_INFO, *PUSB_DEVICE_INFO;

typedef struct _USB_DEVICE_NODE_INFO {
  ULONG Sig;
  ULONG LengthInBytes;
  WCHAR DeviceDescription[40];
  USB_WMI_DEVICE_NODE_TYPE NodeType;
  USB_TOPOLOGY_ADDRESS BusAddress;
  __C89_NAMELESS union {
    USB_DEVICE_INFO UsbDeviceInfo;
    USB_HUB_DEVICE_INFO HubDeviceInfo;
    USB_COMPOSITE_DEVICE_INFO CompositeDeviceInfo;
    USB_CONTROLLER_DEVICE_INFO ControllerDeviceInfo;
    UCHAR DeviceInformation[4];
  };
} USB_DEVICE_NODE_INFO, *PUSB_DEVICE_NODE_INFO;

typedef struct _USB_DEVICE_PERFORMANCE_INFO {
  ULONG BulkBytes;
  ULONG ControlDataBytes;
  ULONG IsoBytes;
  ULONG InterruptBytes;
  ULONG BulkUrbCount;
  ULONG ControlUrbCount;
  ULONG IsoUrbCount;
  ULONG InterruptUrbCount;
  ULONG AllocedInterrupt[6];
  ULONG AllocedIso;
  ULONG Total32secBandwidth;
  ULONG TotalTtBandwidth;
  WCHAR DeviceDescription[60];
  USB_DEVICE_SPEED DeviceSpeed;
  ULONG TotalIsoLatency;
  ULONG DroppedIsoPackets;
  ULONG TransferErrors;
  ULONG PciInterruptCount;
  ULONG HcIdleState;
  ULONG HcAsyncIdleState;
  ULONG HcAsyncCacheFlushCount;
  ULONG HcPeriodicIdleState;
  ULONG HcPeriodicCacheFlushCount;
} USB_DEVICE_PERFORMANCE_INFO, *PUSB_DEVICE_PERFORMANCE_INFO;

#endif /* _WIN32_WINNT >= 0x0600 */

#include <poppack.h>

#endif /* USB_KERNEL_IOCTL */

                                                                                                                                                                                                                                                                                               usr/share/mingw-w64/include/usbiodef.h                                                              0100644 0000000 0000000 00000010313 12404413016 016304  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * usbiodef.h
 *
 * This file is part of the ReactOS PSDK package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#define USB_SUBMIT_URB 0
#define USB_RESET_PORT 1
#define USB_GET_ROOTHUB_PDO 3
#define USB_GET_PORT_STATUS 4
#define USB_ENABLE_PORT 5
#define USB_GET_HUB_COUNT 6
#define USB_CYCLE_PORT 7
#define USB_GET_HUB_NAME 8
#define USB_IDLE_NOTIFICATION 9
#define USB_RECORD_FAILURE 10
#define USB_GET_BUS_INFO 264
#define USB_GET_CONTROLLER_NAME 265
#define USB_GET_BUSGUID_INFO 266
#define USB_GET_PARENT_HUB_INFO 267
#define USB_GET_DEVICE_HANDLE 268
#define USB_GET_DEVICE_HANDLE_EX 269
#define USB_GET_TT_DEVICE_HANDLE 270
#define USB_GET_TOPOLOGY_ADDRESS 271
#define USB_IDLE_NOTIFICATION_EX 272
#define USB_REQ_GLOBAL_SUSPEND 273
#define USB_REQ_GLOBAL_RESUME 274
#define USB_GET_HUB_CONFIG_INFO 275

#define USB_GET_NODE_INFORMATION 258
#define USB_GET_NODE_CONNECTION_INFORMATION 259
#define USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION 260
#define USB_GET_NODE_CONNECTION_NAME 261
#define USB_DIAG_IGNORE_HUBS_ON 262
#define USB_DIAG_IGNORE_HUBS_OFF 263
#define USB_GET_NODE_CONNECTION_DRIVERKEY_NAME 264
#define USB_GET_HUB_CAPABILITIES 271
#define USB_GET_NODE_CONNECTION_ATTRIBUTES 272
#define USB_HUB_CYCLE_PORT 273
#define USB_GET_NODE_CONNECTION_INFORMATION_EX 274
#define USB_RESET_HUB 275
#define USB_GET_HUB_CAPABILITIES_EX 276

#define HCD_GET_STATS_1 255
#define HCD_DIAGNOSTIC_MODE_ON 256
#define HCD_DIAGNOSTIC_MODE_OFF 257
#define HCD_GET_ROOT_HUB_NAME 258
#define HCD_GET_DRIVERKEY_NAME 265
#define HCD_GET_STATS_2 266
#define HCD_DISABLE_PORT 268
#define HCD_ENABLE_PORT 269
#define HCD_USER_REQUEST 270
#define HCD_TRACE_READ_REQUEST 275

#define FILE_DEVICE_USB         FILE_DEVICE_UNKNOWN
#define USB_CTL(id)  CTL_CODE(FILE_DEVICE_USB, (id), METHOD_BUFFERED, FILE_ANY_ACCESS)
#define USB_KERNEL_CTL(id)  CTL_CODE(FILE_DEVICE_USB, (id), METHOD_NEITHER, FILE_ANY_ACCESS)
#define USB_KERNEL_CTL_BUFFERED(id)  CTL_CODE(FILE_DEVICE_USB, (id), METHOD_BUFFERED, FILE_ANY_ACCESS)

DEFINE_GUID(GUID_DEVINTERFACE_USB_HUB, 0xF18A0E88, 0xc30C, 0x11D0, 0x88, 0x15, 0x00, 0xA0, 0xC9, 0x06, 0xBE, 0xD8);
DEFINE_GUID(GUID_DEVINTERFACE_USB_DEVICE, 0xA5DCBF10, 0x6530, 0x11D2, 0x90, 0x1F, 0x00, 0xC0, 0x4F, 0xB9, 0x51, 0xED);
DEFINE_GUID(GUID_DEVINTERFACE_USB_HOST_CONTROLLER, 0x3ABF6F2D, 0x71C4, 0x462A, 0x8A, 0x92, 0x1E, 0x68, 0x61, 0xE6, 0xAF, 0x27);
DEFINE_GUID(GUID_USB_WMI_STD_DATA, 0x4E623B20, 0xCB14, 0x11D1, 0xB3, 0x31, 0x00, 0xA0, 0xC9, 0x59, 0xBB, 0xD2);
DEFINE_GUID(GUID_USB_WMI_STD_NOTIFICATION, 0x4E623B20, 0xCB14, 0x11D1, 0xB3, 0x31, 0x00, 0xA0, 0xC9, 0x59, 0xBB, 0xD2);

#if (_WIN32_WINNT >= 0x0600)
DEFINE_GUID(GUID_USB_WMI_DEVICE_PERF_INFO, 0x66c1aa3c, 0x499f, 0x49a0, 0xa9, 0xa5, 0x61, 0xe2, 0x35, 0x9f, 0x64, 0x7);
DEFINE_GUID(GUID_USB_WMI_NODE_INFO, 0x9c179357, 0xdc7a, 0x4f41, 0xb6, 0x6b, 0x32, 0x3b, 0x9d, 0xdc, 0xb5, 0xb1);
DEFINE_GUID(GUID_USB_WMI_HUB_DIAGNOSTICS, 0xad0379e4, 0x72db, 0x42ed, 0xba, 0x6e, 0x67, 0x57, 0x4, 0x79, 0x7, 0xd);
DEFINE_GUID(GUID_USB_WMI_TRACING, 0x3a61881b, 0xb4e6, 0x4bf9, 0xae, 0xf, 0x3c, 0xd8, 0xf3, 0x94, 0xe5, 0x2f);
DEFINE_GUID(GUID_USB_TRANSFER_TRACING, 0x681eb8aa, 0x403d, 0x452c, 0x9f, 0x8a, 0xf0, 0x61, 0x6f, 0xac, 0x95, 0x40);
DEFINE_GUID(GUID_USB_PERFORMANCE_TRACING, 0xd5de77a6, 0x6ae9, 0x425c, 0xb1, 0xe2, 0xf5, 0x61, 0x5f, 0xd3, 0x48, 0xa9);
#endif /* _WIN32_WINNT >= 0x0600 */

#define GUID_CLASS_USBHUB GUID_DEVINTERFACE_USB_HUB
#define GUID_CLASS_USB_DEVICE GUID_DEVINTERFACE_USB_DEVICE
#define GUID_CLASS_USB_HOST_CONTROLLER GUID_DEVINTERFACE_USB_HOST_CONTROLLER

#if (_WIN32_WINNT >= 0x0501)
typedef VOID
(NTAPI *USB_IDLE_CALLBACK)(
  PVOID Context);

typedef struct _USB_IDLE_CALLBACK_INFO {
  USB_IDLE_CALLBACK IdleCallback;
  PVOID IdleContext;
} USB_IDLE_CALLBACK_INFO, *PUSB_IDLE_CALLBACK_INFO;
#endif /* _WIN32_WINNT >= 0x0501 */

                                                                                                                                                                                                                                                                                                                     usr/share/mingw-w64/include/usbrpmif.h                                                              0100644 0000000 0000000 00000003461 12404413016 016341  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * usbrpmif.h
 *
 * This file is part of the ReactOS PSDK package.
 *
 * Contributors:
 *   Created by Amine Khaldi <amine.khaldi@reactos.org>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#include "windef.h"
#include "usb100.h"

#if !defined(_USBRPM_DRIVER_)
#define USBRPMAPI DECLSPEC_IMPORT
#else
#define USBRPMAPI
#endif

typedef struct _USBRPM_DEVICE_INFORMATION {
  ULONG64 HubId;
  ULONG ConnectionIndex;
  UCHAR DeviceClass;
  USHORT VendorId;
  USHORT ProductId;
  WCHAR ManufacturerString[MAXIMUM_USB_STRING_LENGTH];
  WCHAR ProductString[MAXIMUM_USB_STRING_LENGTH];
  WCHAR HubSymbolicLinkName[MAX_PATH];
} USBRPM_DEVICE_INFORMATION, *PUSBRPM_DEVICE_INFORMATION;

typedef struct _USBRPM_DEVICE_LIST {
  ULONG NumberOfDevices;
  USBRPM_DEVICE_INFORMATION Device[0];
} USBRPM_DEVICE_LIST, *PUSBRPM_DEVICE_LIST;

USBRPMAPI
NTSTATUS
NTAPI
RPMRegisterAlternateDriver(
  PDRIVER_OBJECT  DriverObject,
  LPCWSTR CompatibleId, 
  PHANDLE RegisteredDriver);

USBRPMAPI
NTSTATUS
NTAPI
RPMUnregisterAlternateDriver(
  HANDLE RegisteredDriver);

USBRPMAPI
NTSTATUS
RPMGetAvailableDevices(
  HANDLE RegisteredDriver,
  USHORT Locale,
  PUSBRPM_DEVICE_LIST *DeviceList);

USBRPMAPI
NTSTATUS
NTAPI
RPMLoadAlternateDriverForDevice(
  HANDLE RegisteredDriver,
  ULONG64 HubID,
  ULONG ConnectionIndex,
  REFGUID OwnerGuid);

USBRPMAPI
NTSTATUS
NTAPI
RPMUnloadAlternateDriverForDevice(
  HANDLE RegisteredDriver,
  ULONG64 HubID,
  ULONG ConnectionIndex);
                                                                                                                                                                                                               usr/share/mingw-w64/include/usbuser.h                                                               0100644 0000000 0000000 00000025110 12404413016 016175  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * usbuser.h
 *
 * USB user mode IOCTL interface
 *
 * This file is part of the ReactOS PSDK package.
 *
 * Contributors:
 *   Created by Casper S. Hornstrup <chorns@users.sourceforge.net>
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * This source code is offered for use in the public domain. You may
 * use, modify or distribute it freely.
 *
 * This code is distributed in the hope that it will be useful but
 * WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 * DISCLAIMED. This includes but is not limited to warranties of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#if (_WIN32_WINNT >= 0x0501)

#include "usbiodef.h"

#include <pshpack1.h>

#define USBUSER_VERSION                   0x0004

#define IOCTL_USB_USER_REQUEST            USB_CTL(HCD_USER_REQUEST)

#ifndef IOCTL_USB_DIAGNOSTIC_MODE_ON
#define IOCTL_USB_DIAGNOSTIC_MODE_ON      USB_CTL(HCD_DIAGNOSTIC_MODE_ON)
#endif
#ifndef IOCTL_USB_DIAGNOSTIC_MODE_OFF
#define IOCTL_USB_DIAGNOSTIC_MODE_OFF     USB_CTL(HCD_DIAGNOSTIC_MODE_OFF)
#endif

#ifndef IOCTL_USB_GET_ROOT_HUB_NAME
#define IOCTL_USB_GET_ROOT_HUB_NAME       USB_CTL(HCD_GET_ROOT_HUB_NAME)
#endif
#ifndef IOCTL_GET_HCD_DRIVERKEY_NAME
#define IOCTL_GET_HCD_DRIVERKEY_NAME      USB_CTL(HCD_GET_DRIVERKEY_NAME)
#endif

typedef enum _USB_USER_ERROR_CODE {
  UsbUserSuccess = 0,
  UsbUserNotSupported,
  UsbUserInvalidRequestCode,
  UsbUserFeatureDisabled,
  UsbUserInvalidHeaderParameter,
  UsbUserInvalidParameter,
  UsbUserMiniportError,
  UsbUserBufferTooSmall,
  UsbUserErrorNotMapped,
  UsbUserDeviceNotStarted,
  UsbUserNoDeviceConnected
} USB_USER_ERROR_CODE;

#define USBUSER_GET_CONTROLLER_INFO_0     0x00000001
#define USBUSER_GET_CONTROLLER_DRIVER_KEY 0x00000002
#define USBUSER_PASS_THRU                 0x00000003
#define USBUSER_GET_POWER_STATE_MAP       0x00000004
#define USBUSER_GET_BANDWIDTH_INFORMATION 0x00000005
#define USBUSER_GET_BUS_STATISTICS_0      0x00000006
#define USBUSER_GET_ROOTHUB_SYMBOLIC_NAME 0x00000007
#define USBUSER_GET_USB_DRIVER_VERSION    0x00000008
#define USBUSER_GET_USB2_HW_VERSION       0x00000009
#define USBUSER_USB_REFRESH_HCT_REG       0x0000000a

#define USBUSER_OP_SEND_ONE_PACKET        0x10000001
#define USBUSER_OP_RAW_RESET_PORT         0x20000001
#define USBUSER_OP_OPEN_RAW_DEVICE        0x20000002
#define USBUSER_OP_CLOSE_RAW_DEVICE       0x20000003
#define USBUSER_OP_SEND_RAW_COMMAND       0x20000004
#define USBUSER_SET_ROOTPORT_FEATURE      0x20000005
#define USBUSER_CLEAR_ROOTPORT_FEATURE    0x20000006
#define USBUSER_GET_ROOTPORT_STATUS       0x20000007

#define USBUSER_INVALID_REQUEST           0xFFFFFFF0
#define USBUSER_OP_MASK_DEVONLY_API       0x10000000
#define USBUSER_OP_MASK_HCTEST_API        0x20000000

#define USB_PACKETFLAG_LOW_SPEED          0x00000001
#define USB_PACKETFLAG_FULL_SPEED         0x00000002
#define USB_PACKETFLAG_HIGH_SPEED         0x00000004
#define USB_PACKETFLAG_ASYNC_IN           0x00000008
#define USB_PACKETFLAG_ASYNC_OUT          0x00000010
#define USB_PACKETFLAG_ISO_IN             0x00000020
#define USB_PACKETFLAG_ISO_OUT            0x00000040
#define USB_PACKETFLAG_SETUP              0x00000080
#define USB_PACKETFLAG_TOGGLE0            0x00000100
#define USB_PACKETFLAG_TOGGLE1            0x00000200

/* USB_CONTROLLER_INFO_0.HcFeatureFlags constants */
#define USB_HC_FEATURE_FLAG_PORT_POWER_SWITCHING  0x00000001
#define USB_HC_FEATURE_FLAG_SEL_SUSPEND           0x00000002
#define USB_HC_FEATURE_LEGACY_BIOS                0x00000004

typedef struct _USBUSER_REQUEST_HEADER {
  ULONG UsbUserRequest;
  USB_USER_ERROR_CODE UsbUserStatusCode;
  ULONG RequestBufferLength;
  ULONG ActualBufferLength;
} USBUSER_REQUEST_HEADER, *PUSBUSER_REQUEST_HEADER;

typedef struct _PACKET_PARAMETERS {
  UCHAR DeviceAddress;
  UCHAR EndpointAddress;
  USHORT MaximumPacketSize;
  ULONG Timeout;
  ULONG Flags;
  ULONG DataLength;
  USHORT HubDeviceAddress;
  USHORT PortTTNumber;
  UCHAR ErrorCount;
  UCHAR Pad[3];
  USBD_STATUS UsbdStatusCode;
  UCHAR Data[4];
} PACKET_PARAMETERS, *PPACKET_PARAMETERS;

typedef struct _USBUSER_SEND_ONE_PACKET {
  USBUSER_REQUEST_HEADER Header;
  PACKET_PARAMETERS PacketParameters;
} USBUSER_SEND_ONE_PACKET, *PUSBUSER_SEND_ONE_PACKET;

typedef struct _RAW_RESET_PORT_PARAMETERS {
  USHORT PortNumber;
  USHORT PortStatus;
} RAW_RESET_PORT_PARAMETERS, *PRAW_RESET_PORT_PARAMETERS;

typedef struct _USBUSER_RAW_RESET_ROOT_PORT {
  USBUSER_REQUEST_HEADER Header;
  RAW_RESET_PORT_PARAMETERS Parameters;
} USBUSER_RAW_RESET_ROOT_PORT, *PUSBUSER_RAW_RESET_ROOT_PORT;

typedef struct _RAW_ROOTPORT_FEATURE {
  USHORT PortNumber;
  USHORT PortFeature;
  USHORT PortStatus;
} RAW_ROOTPORT_FEATURE, *PRAW_ROOTPORT_FEATURE;

typedef struct _USBUSER_ROOTPORT_FEATURE_REQUEST {
  USBUSER_REQUEST_HEADER Header;
  RAW_ROOTPORT_FEATURE Parameters;
} USBUSER_ROOTPORT_FEATURE_REQUEST, *PUSBUSER_ROOTPORT_FEATURE_REQUEST;

typedef struct _RAW_ROOTPORT_PARAMETERS {
  USHORT PortNumber;
  USHORT PortStatus;
} RAW_ROOTPORT_PARAMETERS, *PRAW_ROOTPORT_PARAMETERS;

typedef struct _USBUSER_ROOTPORT_PARAMETERS {
  USBUSER_REQUEST_HEADER Header;
  RAW_ROOTPORT_PARAMETERS Parameters;
} USBUSER_ROOTPORT_PARAMETERS, *PUSBUSER_ROOTPORT_PARAMETERS;

typedef struct _USB_CONTROLLER_INFO_0 {
  ULONG PciVendorId;
  ULONG PciDeviceId;
  ULONG PciRevision;
  ULONG NumberOfRootPorts;
  USB_CONTROLLER_FLAVOR ControllerFlavor;
  ULONG HcFeatureFlags;
} USB_CONTROLLER_INFO_0 , *PUSB_CONTROLLER_INFO_0;

typedef struct _USBUSER_CONTROLLER_INFO_0 {
  USBUSER_REQUEST_HEADER Header;
  USB_CONTROLLER_INFO_0 Info0;
} USBUSER_CONTROLLER_INFO_0, *PUSBUSER_CONTROLLER_INFO_0;

typedef struct _USB_UNICODE_NAME {
  ULONG Length;
  WCHAR String[1];
} USB_UNICODE_NAME, *PUSB_UNICODE_NAME;

typedef struct _USBUSER_CONTROLLER_UNICODE_NAME {
  USBUSER_REQUEST_HEADER Header;
  USB_UNICODE_NAME UnicodeName;
} USBUSER_CONTROLLER_UNICODE_NAME, *PUSBUSER_CONTROLLER_UNICODE_NAME;

typedef struct _USB_PASS_THRU_PARAMETERS {
  GUID FunctionGUID;
  ULONG ParameterLength;
  UCHAR Parameters[4];
} USB_PASS_THRU_PARAMETERS, *PUSB_PASS_THRU_PARAMETERS;

typedef struct _USBUSER_PASS_THRU_REQUEST {
  USBUSER_REQUEST_HEADER Header;
  USB_PASS_THRU_PARAMETERS PassThru;
} USBUSER_PASS_THRU_REQUEST, *PUSBUSER_PASS_THRU_REQUEST;

typedef enum _WDMUSB_POWER_STATE {
  WdmUsbPowerNotMapped = 0,
  WdmUsbPowerSystemUnspecified = 100,
  WdmUsbPowerSystemWorking,
  WdmUsbPowerSystemSleeping1,
  WdmUsbPowerSystemSleeping2,
  WdmUsbPowerSystemSleeping3,
  WdmUsbPowerSystemHibernate,
  WdmUsbPowerSystemShutdown,
  WdmUsbPowerDeviceUnspecified = 200,
  WdmUsbPowerDeviceD0,
  WdmUsbPowerDeviceD1,
  WdmUsbPowerDeviceD2,
  WdmUsbPowerDeviceD3
} WDMUSB_POWER_STATE;

typedef struct _USB_POWER_INFO {
  WDMUSB_POWER_STATE SystemState;
  WDMUSB_POWER_STATE HcDevicePowerState;
  WDMUSB_POWER_STATE HcDeviceWake;
  WDMUSB_POWER_STATE HcSystemWake;
  WDMUSB_POWER_STATE RhDevicePowerState;
  WDMUSB_POWER_STATE RhDeviceWake;
  WDMUSB_POWER_STATE RhSystemWake;
  WDMUSB_POWER_STATE LastSystemSleepState;
  BOOLEAN CanWakeup;
  BOOLEAN IsPowered;
} USB_POWER_INFO, *PUSB_POWER_INFO;

typedef struct _USBUSER_POWER_INFO_REQUEST {
  USBUSER_REQUEST_HEADER Header;
  USB_POWER_INFO PowerInformation;
} USBUSER_POWER_INFO_REQUEST, *PUSBUSER_POWER_INFO_REQUEST;

typedef struct _USB_OPEN_RAW_DEVICE_PARAMETERS {
  USHORT PortStatus;
  USHORT MaxPacketEp0;
} USB_OPEN_RAW_DEVICE_PARAMETERS , *PUSB_OPEN_RAW_DEVICE_PARAMETERS;

typedef struct _USBUSER_OPEN_RAW_DEVICE {
  USBUSER_REQUEST_HEADER Header;
  USB_OPEN_RAW_DEVICE_PARAMETERS Parameters;
} USBUSER_OPEN_RAW_DEVICE, *PUSBUSER_OPEN_RAW_DEVICE;

typedef struct _USB_CLOSE_RAW_DEVICE_PARAMETERS {
  ULONG xxx;
} USB_CLOSE_RAW_DEVICE_PARAMETERS , *PUSB_CLOSE_RAW_DEVICE_PARAMETERS;

typedef struct _USBUSER_CLOSE_RAW_DEVICE {
  USBUSER_REQUEST_HEADER Header;
  USB_CLOSE_RAW_DEVICE_PARAMETERS Parameters;
} USBUSER_CLOSE_RAW_DEVICE, *PUSBUSER_CLOSE_RAW_DEVICE;

typedef struct _USB_SEND_RAW_COMMAND_PARAMETERS {
  UCHAR Usb_bmRequest;
  UCHAR Usb_bRequest;
  USHORT Usb_wVlaue;
  USHORT Usb_wIndex;
  USHORT Usb_wLength;
  USHORT DeviceAddress;
  USHORT MaximumPacketSize;
  ULONG Timeout;
  ULONG DataLength;
  USBD_STATUS UsbdStatusCode;
  UCHAR Data[4];
} USB_SEND_RAW_COMMAND_PARAMETERS, *PUSB_SEND_RAW_COMMAND_PARAMETERS;

typedef struct _USBUSER_SEND_RAW_COMMAND {
  USBUSER_REQUEST_HEADER Header;
  USB_SEND_RAW_COMMAND_PARAMETERS Parameters;
} USBUSER_SEND_RAW_COMMAND, *PUSBUSER_SEND_RAW_COMMAND;

typedef struct _USB_BANDWIDTH_INFO {
  ULONG DeviceCount;
  ULONG TotalBusBandwidth;
  ULONG Total32secBandwidth;
  ULONG AllocedBulkAndControl;
  ULONG AllocedIso;
  ULONG AllocedInterrupt_1ms;
  ULONG AllocedInterrupt_2ms;
  ULONG AllocedInterrupt_4ms;
  ULONG AllocedInterrupt_8ms;
  ULONG AllocedInterrupt_16ms;
  ULONG AllocedInterrupt_32ms;
} USB_BANDWIDTH_INFO, *PUSB_BANDWIDTH_INFO;

typedef struct _USBUSER_BANDWIDTH_INFO_REQUEST {
  USBUSER_REQUEST_HEADER Header;
  USB_BANDWIDTH_INFO BandwidthInformation;
} USBUSER_BANDWIDTH_INFO_REQUEST, *PUSBUSER_BANDWIDTH_INFO_REQUEST;

typedef struct _USB_BUS_STATISTICS_0 {
  ULONG DeviceCount;
  LARGE_INTEGER CurrentSystemTime;
  ULONG CurrentUsbFrame;
  ULONG BulkBytes;
  ULONG IsoBytes;
  ULONG InterruptBytes;
  ULONG ControlDataBytes;
  ULONG PciInterruptCount;
  ULONG HardResetCount;
  ULONG WorkerSignalCount;
  ULONG CommonBufferBytes;
  ULONG WorkerIdleTimeMs;
  BOOLEAN RootHubEnabled;
  UCHAR RootHubDevicePowerState;
  UCHAR Unused;
  UCHAR NameIndex;
} USB_BUS_STATISTICS_0, *PUSB_BUS_STATISTICS_0;

typedef struct _USBUSER_BUS_STATISTICS_0_REQUEST {
  USBUSER_REQUEST_HEADER Header;
  USB_BUS_STATISTICS_0 BusStatistics0;
} USBUSER_BUS_STATISTICS_0_REQUEST, *PUSBUSER_BUS_STATISTICS_0_REQUEST;

typedef struct _USB_DRIVER_VERSION_PARAMETERS {
  ULONG DriverTrackingCode;
  ULONG USBDI_Version;
  ULONG USBUSER_Version;
  BOOLEAN CheckedPortDriver;
  BOOLEAN CheckedMiniportDriver;
  USHORT USB_Version;
} USB_DRIVER_VERSION_PARAMETERS , *PUSB_DRIVER_VERSION_PARAMETERS;

typedef struct _USBUSER_GET_DRIVER_VERSION {
  USBUSER_REQUEST_HEADER Header;
  USB_DRIVER_VERSION_PARAMETERS Parameters;
} USBUSER_GET_DRIVER_VERSION, *PUSBUSER_GET_DRIVER_VERSION;

typedef struct _USB_USB2HW_VERSION_PARAMETERS {
  UCHAR Usb2HwRevision;
} USB_USB2HW_VERSION_PARAMETERS, *PUSB_USB2HW_VERSION_PARAMETERS;

typedef struct _USBUSER_GET_USB2HW_VERSION {
  USBUSER_REQUEST_HEADER Header;
  USB_USB2HW_VERSION_PARAMETERS Parameters;
} USBUSER_GET_USB2HW_VERSION, *PUSBUSER_GET_USB2HW_VERSION;

typedef struct _USBUSER_REFRESH_HCT_REG {
  USBUSER_REQUEST_HEADER Header;
  ULONG Flags;
} USBUSER_REFRESH_HCT_REG, *PUSBUSER_REFRESH_HCT_REG;

#include <poppack.h>

#endif /* _WIN32_WINNT >= 0x0501 */

#ifdef __cplusplus
}
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/share/mingw-w64/include/userenv.h                                                               0100644 0000000 0000000 00000023624 12404413016 016204  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _USERENV_H_
#define _USERENV_H_

#include <_mingw_unicode.h>
#include <wbemcli.h>
#include <profinfo.h>

#if !defined(_USERENV_)
#define USERENVAPI DECLSPEC_IMPORT
#else
#define USERENVAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define PI_NOUI 0x00000001
#define PI_APPLYPOLICY 0x00000002

#define LoadUserProfile __MINGW_NAME_AW(LoadUserProfile)
#define GetProfilesDirectory __MINGW_NAME_AW(GetProfilesDirectory)
#define DeleteProfile __MINGW_NAME_AW(DeleteProfile)
#define GetDefaultUserProfileDirectory __MINGW_NAME_AW(GetDefaultUserProfileDirectory)
#define GetAllUsersProfileDirectory __MINGW_NAME_AW(GetAllUsersProfileDirectory)
#define GetUserProfileDirectory __MINGW_NAME_AW(GetUserProfileDirectory)
#define ExpandEnvironmentStringsForUser __MINGW_NAME_AW(ExpandEnvironmentStringsForUser)

  USERENVAPI WINBOOL WINAPI LoadUserProfileA(HANDLE hToken,LPPROFILEINFOA lpProfileInfo);
  USERENVAPI WINBOOL WINAPI LoadUserProfileW(HANDLE hToken,LPPROFILEINFOW lpProfileInfo);
  USERENVAPI WINBOOL WINAPI UnloadUserProfile(HANDLE hToken,HANDLE hProfile);
  USERENVAPI WINBOOL WINAPI GetProfilesDirectoryA(LPSTR lpProfilesDir,LPDWORD lpcchSize);
  USERENVAPI WINBOOL WINAPI GetProfilesDirectoryW(LPWSTR lpProfilesDir,LPDWORD lpcchSize);

#define PT_TEMPORARY 0x00000001
#define PT_ROAMING 0x00000002
#define PT_MANDATORY 0x00000004

  USERENVAPI WINBOOL WINAPI GetProfileType(DWORD *dwFlags);
  USERENVAPI WINBOOL WINAPI DeleteProfileA(LPCSTR lpSidString,LPCSTR lpProfilePath,LPCSTR lpComputerName);
  USERENVAPI WINBOOL WINAPI DeleteProfileW(LPCWSTR lpSidString,LPCWSTR lpProfilePath,LPCWSTR lpComputerName);
  USERENVAPI WINBOOL WINAPI GetDefaultUserProfileDirectoryA(LPSTR lpProfileDir,LPDWORD lpcchSize);
  USERENVAPI WINBOOL WINAPI GetDefaultUserProfileDirectoryW(LPWSTR lpProfileDir,LPDWORD lpcchSize);
  USERENVAPI WINBOOL WINAPI GetAllUsersProfileDirectoryA(LPSTR lpProfileDir,LPDWORD lpcchSize);
  USERENVAPI WINBOOL WINAPI GetAllUsersProfileDirectoryW(LPWSTR lpProfileDir,LPDWORD lpcchSize);
  USERENVAPI WINBOOL WINAPI GetUserProfileDirectoryA(HANDLE hToken,LPSTR lpProfileDir,LPDWORD lpcchSize);
  USERENVAPI WINBOOL WINAPI GetUserProfileDirectoryW(HANDLE hToken,LPWSTR lpProfileDir,LPDWORD lpcchSize);
  USERENVAPI WINBOOL WINAPI CreateEnvironmentBlock(LPVOID *lpEnvironment,HANDLE hToken,WINBOOL bInherit);
  USERENVAPI WINBOOL WINAPI DestroyEnvironmentBlock(LPVOID lpEnvironment);
  USERENVAPI WINBOOL WINAPI ExpandEnvironmentStringsForUserA(HANDLE hToken,LPCSTR lpSrc,LPSTR lpDest,DWORD dwSize);
  USERENVAPI WINBOOL WINAPI ExpandEnvironmentStringsForUserW(HANDLE hToken,LPCWSTR lpSrc,LPWSTR lpDest,DWORD dwSize);
  USERENVAPI WINBOOL WINAPI RefreshPolicy(WINBOOL bMachine);

#define RP_FORCE 1

  USERENVAPI WINBOOL WINAPI RefreshPolicyEx(WINBOOL bMachine,DWORD dwOptions);
  USERENVAPI HANDLE WINAPI EnterCriticalPolicySection(WINBOOL bMachine);
  USERENVAPI WINBOOL WINAPI LeaveCriticalPolicySection(HANDLE hSection);
  USERENVAPI WINBOOL WINAPI RegisterGPNotification(HANDLE hEvent,WINBOOL bMachine);
  USERENVAPI WINBOOL WINAPI UnregisterGPNotification(HANDLE hEvent);

#define GPC_BLOCK_POLICY 0x00000001

#define GPO_FLAG_DISABLE 0x00000001
#define GPO_FLAG_FORCE 0x00000002

  typedef enum _GPO_LINK {
    GPLinkUnknown = 0,GPLinkMachine,GPLinkSite,GPLinkDomain,GPLinkOrganizationalUnit
  } GPO_LINK,*PGPO_LINK;

  typedef struct _GROUP_POLICY_OBJECTA {
    DWORD dwOptions;
    DWORD dwVersion;
    LPSTR lpDSPath;
    LPSTR lpFileSysPath;
    LPSTR lpDisplayName;
    CHAR szGPOName[50];
    GPO_LINK GPOLink;
    LPARAM lParam;
    struct _GROUP_POLICY_OBJECTA *pNext;
    struct _GROUP_POLICY_OBJECTA *pPrev;
    LPSTR lpExtensions;
    LPARAM lParam2;
    LPSTR lpLink;
  } GROUP_POLICY_OBJECTA,*PGROUP_POLICY_OBJECTA;

  typedef struct _GROUP_POLICY_OBJECTW {
    DWORD dwOptions;
    DWORD dwVersion;
    LPWSTR lpDSPath;
    LPWSTR lpFileSysPath;
    LPWSTR lpDisplayName;
    WCHAR szGPOName[50];
    GPO_LINK GPOLink;
    LPARAM lParam;
    struct _GROUP_POLICY_OBJECTW *pNext;
    struct _GROUP_POLICY_OBJECTW *pPrev;
    LPWSTR lpExtensions;
    LPARAM lParam2;
    LPWSTR lpLink;
  } GROUP_POLICY_OBJECTW,*PGROUP_POLICY_OBJECTW;

  __MINGW_TYPEDEF_AW(GROUP_POLICY_OBJECT)
  __MINGW_TYPEDEF_AW(PGROUP_POLICY_OBJECT)

#define GPO_LIST_FLAG_MACHINE 0x00000001
#define GPO_LIST_FLAG_SITEONLY 0x00000002
#define GPO_LIST_FLAG_NO_WMIFILTERS 0x00000004

#define GetGPOList __MINGW_NAME_AW(GetGPOList)
#define FreeGPOList __MINGW_NAME_AW(FreeGPOList)
#define GetAppliedGPOList __MINGW_NAME_AW(GetAppliedGPOList)

  USERENVAPI WINBOOL WINAPI GetGPOListA(HANDLE hToken,LPCSTR lpName,LPCSTR lpHostName,LPCSTR lpComputerName,DWORD dwFlags,PGROUP_POLICY_OBJECTA *pGPOList);
  USERENVAPI WINBOOL WINAPI GetGPOListW(HANDLE hToken,LPCWSTR lpName,LPCWSTR lpHostName,LPCWSTR lpComputerName,DWORD dwFlags,PGROUP_POLICY_OBJECTW *pGPOList);
  USERENVAPI WINBOOL WINAPI FreeGPOListA(PGROUP_POLICY_OBJECTA pGPOList);
  USERENVAPI WINBOOL WINAPI FreeGPOListW(PGROUP_POLICY_OBJECTW pGPOList);
  USERENVAPI DWORD WINAPI GetAppliedGPOListA(DWORD dwFlags,LPCSTR pMachineName,PSID pSidUser,GUID *pGuidExtension,PGROUP_POLICY_OBJECTA *ppGPOList);
  USERENVAPI DWORD WINAPI GetAppliedGPOListW(DWORD dwFlags,LPCWSTR pMachineName,PSID pSidUser,GUID *pGuidExtension,PGROUP_POLICY_OBJECTW *ppGPOList);

#define GP_DLLNAME TEXT("DllName")
#define GP_ENABLEASYNCHRONOUSPROCESSING TEXT("EnableAsynchronousProcessing")
#define GP_MAXNOGPOLISTCHANGESINTERVAL TEXT("MaxNoGPOListChangesInterval")
#define GP_NOBACKGROUNDPOLICY TEXT("NoBackgroundPolicy")
#define GP_NOGPOLISTCHANGES TEXT("NoGPOListChanges")
#define GP_NOMACHINEPOLICY TEXT("NoMachinePolicy")
#define GP_NOSLOWLINK TEXT("NoSlowLink")
#define GP_NOTIFYLINKTRANSITION TEXT("NotifyLinkTransition")
#define GP_NOUSERPOLICY TEXT("NoUserPolicy")
#define GP_PERUSERLOCALSETTINGS TEXT("PerUserLocalSettings")
#define GP_PROCESSGROUPPOLICY TEXT("ProcessGroupPolicy")
#define GP_REQUIRESSUCCESSFULREGISTRY TEXT("RequiresSuccessfulRegistry")

#define GPO_INFO_FLAG_MACHINE 0x00000001
#define GPO_INFO_FLAG_BACKGROUND 0x00000010
#define GPO_INFO_FLAG_SLOWLINK 0x00000020
#define GPO_INFO_FLAG_VERBOSE 0x00000040
#define GPO_INFO_FLAG_NOCHANGES 0x00000080
#define GPO_INFO_FLAG_LINKTRANSITION 0x00000100

#define GPO_INFO_FLAG_LOGRSOP_TRANSITION 0x00000200

#define GPO_INFO_FLAG_FORCED_REFRESH 0x00000400
#define GPO_INFO_FLAG_SAFEMODE_BOOT 0x00000800
#define GPO_INFO_FLAG_ASYNC_FOREGROUND 0x00001000
#define GPO_INFO_FLAG_REPORT 0x00002000

  typedef UINT_PTR ASYNCCOMPLETIONHANDLE;
  typedef DWORD (*PFNSTATUSMESSAGECALLBACK)(WINBOOL bVerbose,LPWSTR lpMessage);
  typedef DWORD(*PFNPROCESSGROUPPOLICY)(DWORD dwFlags,HANDLE hToken,HKEY hKeyRoot,PGROUP_POLICY_OBJECT pDeletedGPOList,PGROUP_POLICY_OBJECT pChangedGPOList,ASYNCCOMPLETIONHANDLE pHandle,WINBOOL *pbAbort,PFNSTATUSMESSAGECALLBACK pStatusCallback);
  typedef DWORD(*PFNPROCESSGROUPPOLICYEX)(DWORD dwFlags,HANDLE hToken,HKEY hKeyRoot,PGROUP_POLICY_OBJECT pDeletedGPOList,PGROUP_POLICY_OBJECT pChangedGPOList,ASYNCCOMPLETIONHANDLE pHandle,WINBOOL *pbAbort,PFNSTATUSMESSAGECALLBACK pStatusCallback,IWbemServices *pWbemServices,HRESULT *pRsopStatus);
  typedef PVOID PRSOPTOKEN;

  typedef struct _RSOP_TARGET {
    WCHAR *pwszAccountName;
    WCHAR *pwszNewSOM;
    SAFEARRAY *psaSecurityGroups;
    PRSOPTOKEN pRsopToken;
    PGROUP_POLICY_OBJECT pGPOList;
    IWbemServices *pWbemServices;
  } RSOP_TARGET,*PRSOP_TARGET;

  typedef DWORD(*PFNGENERATEGROUPPOLICY)(DWORD dwFlags,WINBOOL *pbAbort,WCHAR *pwszSite,PRSOP_TARGET pComputerTarget,PRSOP_TARGET pUserTarget);

#define REGISTRY_EXTENSION_GUID { 0x35378EAC,0x683F,0x11D2,0xA8,0x9A,0x00,0xC0,0x4F,0xBB,0xCF,0xA2 }

  typedef GUID *REFGPEXTENSIONID;

  USERENVAPI DWORD WINAPI ProcessGroupPolicyCompleted(REFGPEXTENSIONID extensionId,ASYNCCOMPLETIONHANDLE pAsyncHandle,DWORD dwStatus);
  USERENVAPI DWORD WINAPI ProcessGroupPolicyCompletedEx(REFGPEXTENSIONID extensionId,ASYNCCOMPLETIONHANDLE pAsyncHandle,DWORD dwStatus,HRESULT RsopStatus);
  USERENVAPI HRESULT WINAPI RsopAccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor,PSID pPrincipalSelfSid,PRSOPTOKEN pRsopToken,DWORD dwDesiredAccessMask,POBJECT_TYPE_LIST pObjectTypeList,DWORD ObjectTypeListLength,PGENERIC_MAPPING pGenericMapping,PPRIVILEGE_SET pPrivilegeSet,LPDWORD pdwPrivilegeSetLength,LPDWORD pdwGrantedAccessMask,LPBOOL pbAccessStatus);
  USERENVAPI HRESULT WINAPI RsopFileAccessCheck(LPWSTR pszFileName,PRSOPTOKEN pRsopToken,DWORD dwDesiredAccessMask,LPDWORD pdwGrantedAccessMask,LPBOOL pbAccessStatus);

  typedef enum _SETTINGSTATUS {
    RSOPUnspecified = 0,RSOPApplied,RSOPIgnored,RSOPFailed,RSOPSubsettingFailed
  } SETTINGSTATUS;

  typedef struct _POLICYSETTINGSTATUSINFO {
    LPWSTR szKey;
    LPWSTR szEventSource;
    LPWSTR szEventLogName;
    DWORD dwEventID;
    DWORD dwErrorCode;
    SETTINGSTATUS status;
    SYSTEMTIME timeLogged;
  } POLICYSETTINGSTATUSINFO,*LPPOLICYSETTINGSTATUSINFO;

  USERENVAPI HRESULT WINAPI RsopSetPolicySettingStatus(DWORD dwFlags,IWbemServices *pServices,IWbemClassObject *pSettingInstance,DWORD nInfo,POLICYSETTINGSTATUSINFO *pStatus);
  USERENVAPI HRESULT WINAPI RsopResetPolicySettingStatus(DWORD dwFlags,IWbemServices *pServices,IWbemClassObject *pSettingInstance);

#define FLAG_NO_GPO_FILTER 0x80000000
#define FLAG_NO_CSE_INVOKE 0x40000000
#define FLAG_ASSUME_SLOW_LINK 0x20000000
#define FLAG_LOOPBACK_MERGE 0x10000000
#define FLAG_LOOPBACK_REPLACE 0x08000000

#define FLAG_ASSUME_USER_WQLFILTER_TRUE 0x04000000
#define FLAG_ASSUME_COMP_WQLFILTER_TRUE 0x02000000

#define FLAG_PLANNING_MODE 0x01000000

#define FLAG_NO_USER 0x00000001
#define FLAG_NO_COMPUTER 0x00000002
#define FLAG_FORCE_CREATENAMESPACE 0x00000004

#define RSOP_USER_ACCESS_DENIED 0x00000001

#define RSOP_COMPUTER_ACCESS_DENIED 0x00000002

#define RSOP_TEMPNAMESPACE_EXISTS 0x00000004

#ifdef __cplusplus
}
#endif

#endif /* _USERENV_H_ */
                                                                                                            usr/share/mingw-w64/include/usp10.h                                                                 0100644 0000000 0000000 00000026451 12404413016 015466  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __usp10__
#define __usp10__

#include <windows.h>
#ifdef __cplusplus
extern "C" {
#endif

#define USPBUILD 0400
#define SCRIPT_UNDEFINED 0

#define USP_E_SCRIPT_NOT_IN_FONT MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x200)

  typedef void *SCRIPT_CACHE;

  typedef ULONG OPENTYPE_TAG;

  HRESULT WINAPI ScriptFreeCache(SCRIPT_CACHE *psc);

  typedef struct tag_SCRIPT_CONTROL {
    DWORD uDefaultLanguage :16;
    DWORD fContextDigits :1;

    DWORD fInvertPreBoundDir :1;
    DWORD fInvertPostBoundDir :1;
    DWORD fLinkStringBefore :1;
    DWORD fLinkStringAfter :1;
    DWORD fNeutralOverride :1;
    DWORD fNumericOverride :1;
    DWORD fLegacyBidiClass :1;
    DWORD fMergeNeutralItems :1;
    DWORD fUseStandardBidi :1;
    DWORD fReserved :6;
  } SCRIPT_CONTROL;

  typedef struct tag_SCRIPT_STATE {
    WORD uBidiLevel :5;
    WORD fOverrideDirection :1;
    WORD fInhibitSymSwap :1;
    WORD fCharShape :1;
    WORD fDigitSubstitute :1;
    WORD fInhibitLigate :1;
    WORD fDisplayZWG :1;
    WORD fArabicNumContext :1;
    WORD fGcpClusters :1;
    WORD fReserved :1;
    WORD fEngineReserved :2;
  } SCRIPT_STATE;

  typedef struct tag_SCRIPT_ANALYSIS {
    WORD eScript :10;
    WORD fRTL :1;
    WORD fLayoutRTL :1;
    WORD fLinkBefore :1;
    WORD fLinkAfter :1;
    WORD fLogicalOrder :1;
    WORD fNoGlyphIndex :1;
    SCRIPT_STATE s;
  } SCRIPT_ANALYSIS;

  typedef struct tag_SCRIPT_ITEM {
    int iCharPos;
    SCRIPT_ANALYSIS a;
  } SCRIPT_ITEM;

  HRESULT WINAPI ScriptItemize(const WCHAR *pwcInChars,int cInChars,int cMaxItems,const SCRIPT_CONTROL *psControl,const SCRIPT_STATE *psState,SCRIPT_ITEM *pItems,int *pcItems);
  HRESULT WINAPI ScriptLayout(int cRuns,const BYTE *pbLevel,int *piVisualToLogical,int *piLogicalToVisual);

  typedef enum tag_SCRIPT_JUSTIFY {
    SCRIPT_JUSTIFY_NONE = 0,SCRIPT_JUSTIFY_ARABIC_BLANK = 1,SCRIPT_JUSTIFY_CHARACTER = 2,SCRIPT_JUSTIFY_RESERVED1 = 3,SCRIPT_JUSTIFY_BLANK = 4,
    SCRIPT_JUSTIFY_RESERVED2 = 5,SCRIPT_JUSTIFY_RESERVED3 = 6,SCRIPT_JUSTIFY_ARABIC_NORMAL = 7,SCRIPT_JUSTIFY_ARABIC_KASHIDA = 8,
    SCRIPT_JUSTIFY_ARABIC_ALEF = 9,SCRIPT_JUSTIFY_ARABIC_HA = 10,SCRIPT_JUSTIFY_ARABIC_RA = 11,SCRIPT_JUSTIFY_ARABIC_BA = 12,
    SCRIPT_JUSTIFY_ARABIC_BARA = 13,SCRIPT_JUSTIFY_ARABIC_SEEN = 14,SCRIPT_JUSTIFY_RESERVED4 = 15
  } SCRIPT_JUSTIFY;

  typedef struct tag_SCRIPT_VISATTR {
    WORD uJustification :4;
    WORD fClusterStart :1;
    WORD fDiacritic :1;
    WORD fZeroWidth :1;
    WORD fReserved :1;
    WORD fShapeReserved :8;
  } SCRIPT_VISATTR;

  HRESULT WINAPI ScriptShape(HDC hdc,SCRIPT_CACHE *psc,const WCHAR *pwcChars,int cChars,int cMaxGlyphs,SCRIPT_ANALYSIS *psa,WORD *pwOutGlyphs,WORD *pwLogClust,SCRIPT_VISATTR *psva,int *pcGlyphs);

#ifndef LSDEFS_DEFINED
  typedef struct tagGOFFSET {
    LONG du;
    LONG dv;
  } GOFFSET;
#endif

  HRESULT WINAPI ScriptPlace(HDC hdc,SCRIPT_CACHE *psc,const WORD *pwGlyphs,int cGlyphs,const SCRIPT_VISATTR *psva,SCRIPT_ANALYSIS *psa,int *piAdvance,GOFFSET *pGoffset,ABC *pABC);
  HRESULT WINAPI ScriptTextOut(const HDC hdc,SCRIPT_CACHE *psc,int x,int y,UINT fuOptions,const RECT *lprc,const SCRIPT_ANALYSIS *psa,const WCHAR *pwcReserved,int iReserved,const WORD *pwGlyphs,int cGlyphs,const int *piAdvance,const int *piJustify,const GOFFSET *pGoffset);
  HRESULT WINAPI ScriptJustify(const SCRIPT_VISATTR *psva,const int *piAdvance,int cGlyphs,int iDx,int iMinKashida,int *piJustify);

  typedef struct tag_SCRIPT_LOGATTR {
    BYTE fSoftBreak :1;
    BYTE fWhiteSpace :1;
    BYTE fCharStop :1;
    BYTE fWordStop :1;
    BYTE fInvalid :1;
    BYTE fReserved :3;
  } SCRIPT_LOGATTR;

  HRESULT WINAPI ScriptBreak(const WCHAR *pwcChars,int cChars,const SCRIPT_ANALYSIS *psa,SCRIPT_LOGATTR *psla);
  HRESULT WINAPI ScriptCPtoX(int iCP,WINBOOL fTrailing,int cChars,int cGlyphs,const WORD *pwLogClust,const SCRIPT_VISATTR *psva,const int *piAdvance,const SCRIPT_ANALYSIS *psa,int *piX);
  HRESULT WINAPI ScriptXtoCP(int iX,int cChars,int cGlyphs,const WORD *pwLogClust,const SCRIPT_VISATTR *psva,const int *piAdvance,const SCRIPT_ANALYSIS *psa,int *piCP,int *piTrailing);
  HRESULT WINAPI ScriptGetLogicalWidths(const SCRIPT_ANALYSIS *psa,int cChars,int cGlyphs,const int *piGlyphWidth,const WORD *pwLogClust,const SCRIPT_VISATTR *psva,int *piDx);
  HRESULT WINAPI ScriptApplyLogicalWidth(const int *piDx,int cChars,int cGlyphs,const WORD *pwLogClust,const SCRIPT_VISATTR *psva,const int *piAdvance,const SCRIPT_ANALYSIS *psa,ABC *pABC,int *piJustify);

#define SGCM_RTL 0x00000001

  HRESULT WINAPI ScriptGetCMap(HDC hdc,SCRIPT_CACHE *psc,const WCHAR *pwcInChars,int cChars,DWORD dwFlags,WORD *pwOutGlyphs);
  HRESULT WINAPI ScriptGetGlyphABCWidth(HDC hdc,SCRIPT_CACHE *psc,WORD wGlyph,ABC *pABC);

  typedef struct {
    DWORD langid :16;
    DWORD fNumeric :1;
    DWORD fComplex :1;
    DWORD fNeedsWordBreaking :1;
    DWORD fNeedsCaretInfo :1;
    DWORD bCharSet :8;
    DWORD fControl :1;
    DWORD fPrivateUseArea :1;
    DWORD fNeedsCharacterJustify :1;
    DWORD fInvalidGlyph :1;
    DWORD fInvalidLogAttr :1;
    DWORD fCDM :1;
    DWORD fAmbiguousCharSet :1;
    DWORD fClusterSizeVaries :1;
    DWORD fRejectInvalid :1;
  } SCRIPT_PROPERTIES;

  HRESULT WINAPI ScriptGetProperties(const SCRIPT_PROPERTIES ***ppSp,int *piNumScripts);

  typedef struct {
    int cBytes;
    WORD wgBlank;
    WORD wgDefault;
    WORD wgInvalid;
    WORD wgKashida;
    int iKashidaWidth;
  } SCRIPT_FONTPROPERTIES;

  HRESULT WINAPI ScriptGetFontProperties(HDC hdc,SCRIPT_CACHE *psc,SCRIPT_FONTPROPERTIES *sfp);
  HRESULT WINAPI ScriptCacheGetHeight(HDC hdc,SCRIPT_CACHE *psc,__LONG32 *tmHeight);

#define SSA_PASSWORD 0x00000001
#define SSA_TAB 0x00000002
#define SSA_CLIP 0x00000004
#define SSA_FIT 0x00000008
#define SSA_DZWG 0x00000010
#define SSA_FALLBACK 0x00000020
#define SSA_BREAK 0x00000040
#define SSA_GLYPHS 0x00000080
#define SSA_RTL 0x00000100
#define SSA_GCP 0x00000200
#define SSA_HOTKEY 0x00000400
#define SSA_METAFILE 0x00000800
#define SSA_LINK 0x00001000
#define SSA_HIDEHOTKEY 0x00002000
#define SSA_HOTKEYONLY 0x00002400

#define SSA_FULLMEASURE 0x04000000
#define SSA_LPKANSIFALLBACK 0x08000000
#define SSA_PIDX 0x10000000
#define SSA_LAYOUTRTL 0x20000000
#define SSA_DONTGLYPH 0x40000000
#define SSA_NOKASHIDA 0x80000000

  typedef struct tag_SCRIPT_TABDEF {
    int cTabStops;
    int iScale;
    int *pTabStops;
    int iTabOrigin;
  } SCRIPT_TABDEF;

  typedef void *SCRIPT_STRING_ANALYSIS;

  HRESULT WINAPI ScriptStringAnalyse(HDC hdc,const void *pString,int cString,int cGlyphs,int iCharset,DWORD dwFlags,int iReqWidth,SCRIPT_CONTROL *psControl,SCRIPT_STATE *psState,const int *piDx,SCRIPT_TABDEF *pTabdef,const BYTE *pbInClass,SCRIPT_STRING_ANALYSIS *pssa);
  HRESULT WINAPI ScriptStringFree(SCRIPT_STRING_ANALYSIS *pssa);
  const SIZE *WINAPI ScriptString_pSize(SCRIPT_STRING_ANALYSIS ssa);
  const int *WINAPI ScriptString_pcOutChars(SCRIPT_STRING_ANALYSIS ssa);
  const SCRIPT_LOGATTR *WINAPI ScriptString_pLogAttr(SCRIPT_STRING_ANALYSIS ssa);
  HRESULT WINAPI ScriptStringGetOrder(SCRIPT_STRING_ANALYSIS ssa,UINT *puOrder);
  HRESULT WINAPI ScriptStringCPtoX(SCRIPT_STRING_ANALYSIS ssa,int icp,WINBOOL fTrailing,int *pX);
  HRESULT WINAPI ScriptStringXtoCP(SCRIPT_STRING_ANALYSIS ssa,int iX,int *piCh,int *piTrailing);
  HRESULT WINAPI ScriptStringGetLogicalWidths(SCRIPT_STRING_ANALYSIS ssa,int *piDx);
  HRESULT WINAPI ScriptStringValidate(SCRIPT_STRING_ANALYSIS ssa);
  HRESULT WINAPI ScriptStringOut(SCRIPT_STRING_ANALYSIS ssa,int iX,int iY,UINT uOptions,const RECT *prc,int iMinSel,int iMaxSel,WINBOOL fDisabled);

#define SIC_COMPLEX 1
#define SIC_ASCIIDIGIT 2
#define SIC_NEUTRAL 4

  HRESULT WINAPI ScriptIsComplex(const WCHAR *pwcInChars,int cInChars,DWORD dwFlags);

  typedef struct tag_SCRIPT_DIGITSUBSTITUTE {
    DWORD NationalDigitLanguage :16;
    DWORD TraditionalDigitLanguage :16;
    DWORD DigitSubstitute :8;
    DWORD dwReserved;
  } SCRIPT_DIGITSUBSTITUTE;

  HRESULT WINAPI ScriptRecordDigitSubstitution(LCID Locale,SCRIPT_DIGITSUBSTITUTE *psds);

#define SCRIPT_DIGITSUBSTITUTE_CONTEXT 0
#define SCRIPT_DIGITSUBSTITUTE_NONE 1
#define SCRIPT_DIGITSUBSTITUTE_NATIONAL 2
#define SCRIPT_DIGITSUBSTITUTE_TRADITIONAL 3

  HRESULT WINAPI ScriptApplyDigitSubstitution(const SCRIPT_DIGITSUBSTITUTE *psds,SCRIPT_CONTROL *psc,SCRIPT_STATE *pss);

#if (_WIN32_WINNT >= 0x0600)
typedef struct opentype_feature_record {
  OPENTYPE_TAG tagFeature;
  LONG         lParameter;
} OPENTYPE_FEATURE_RECORD;

typedef struct script_charprop {
  WORD fCanGlyphAlone  :1;
  WORD reserved  :15;
} SCRIPT_CHARPROP;

typedef struct textrange_properties {
  OPENTYPE_FEATURE_RECORD *potfRecords;
  int                     cotfRecords;
} TEXTRANGE_PROPERTIES;

typedef struct script_glyphprop {
  SCRIPT_VISATTR sva;
  WORD           reserved;
} SCRIPT_GLYPHPROP;

HRESULT WINAPI ScriptGetFontAlternateGlyphs(
  HDC hdc,
  SCRIPT_CACHE *psc,
  SCRIPT_ANALYSIS *psa,
  OPENTYPE_TAG tagScript,
  OPENTYPE_TAG tagLangSys,
  OPENTYPE_TAG tagFeature,
  WORD wGlyphId,
  int cMaxAlternates,
  WORD *pAlternateGlyphs,
  int *pcAlternates
);

HRESULT WINAPI ScriptGetFontFeatureTags(
  HDC hdc,
  SCRIPT_CACHE *psc,
  SCRIPT_ANALYSIS *psa,
  OPENTYPE_TAG tagScript,
  OPENTYPE_TAG tagLangSys,
  int cMaxTags,
  OPENTYPE_TAG *pFeatureTags,
  int *pcTags
);

HRESULT WINAPI ScriptGetFontLanguageTags(
  HDC hdc,
  SCRIPT_CACHE *psc,
  SCRIPT_ANALYSIS *psa,
  OPENTYPE_TAG tagScript,
  int cMaxTags,
  OPENTYPE_TAG *pLangSysTags,
  int *pcTags
);

HRESULT WINAPI ScriptGetFontScriptTags(
  HDC hdc,
  SCRIPT_CACHE *psc,
  SCRIPT_ANALYSIS *psa,
  int cMaxTags,
  OPENTYPE_TAG *pScriptTags,
  int *pcTags
);

HRESULT WINAPI ScriptItemizeOpenType(
  const WCHAR *pwcInChars,
  int cInChars,
  int cMaxItems,
  const SCRIPT_CONTROL *psControl,
  const SCRIPT_STATE *psState,
  SCRIPT_ITEM *pItems,
  OPENTYPE_TAG *pScriptTags,
  int *pcItems
);

HRESULT WINAPI ScriptPlaceOpenType(
  HDC hdc,
  SCRIPT_CACHE *psc,
  SCRIPT_ANALYSIS *psa,
  OPENTYPE_TAG tagScript,
  OPENTYPE_TAG tagLangSys,
  int *rcRangeChars,
  TEXTRANGE_PROPERTIES **rpRangeProperties,
  int cRanges,
  const WCHAR *pwcChars,
  WORD *pwLogClust,
  SCRIPT_CHARPROP *pCharProps,
  int cChars,
  const WORD *pwGlyphs,
  const SCRIPT_GLYPHPROP *pGlyphProps,
  int cGlyphs,
  int *piAdvance,
  GOFFSET *pGoffset,
  ABC *pABC
);

HRESULT WINAPI ScriptPositionSingleGlyph(
  HDC hdc,
  SCRIPT_CACHE *psc,
  SCRIPT_ANALYSIS *psa,
  OPENTYPE_TAG tagScript,
  OPENTYPE_TAG tagLangSys,
  OPENTYPE_TAG tagFeature,
  LONG lParameter,
  WORD wGlyphId,
  int iAdvance,
  GOFFSET Goffset,
  int *piOutAdvance,
  GOFFSET *pOutGoffset
);

HRESULT WINAPI ScriptShapeOpenType(
  HDC hdc,
  SCRIPT_CACHE *psc,
  SCRIPT_ANALYSIS *psa,
  OPENTYPE_TAG tagScript,
  OPENTYPE_TAG tagLangSys,
  int *rcRangeChars,
  TEXTRANGE_PROPERTIES **rpRangeProperties,
  int cRanges,
  const WCHAR *pwcChars,
  int cChars,
  int cMaxGlyphs,
  WORD *pwLogClust,
  SCRIPT_CHARPROP *pCharProps,
  WORD *pwOutGlyphs,
  SCRIPT_GLYPHPROP *pOutGlyphProps,
  int *pcGlyphs
);

HRESULT ScriptSubstituteSingleGlyph(
  HDC hdc,
  SCRIPT_CACHE *psc,
  SCRIPT_ANALYSIS *psa,
  OPENTYPE_TAG tagScript,
  OPENTYPE_TAG tagLangSys,
  OPENTYPE_TAG tagFeature,
  LONG lParameter,
  WORD wGlyphId,
  WORD *pwOutGlyphId
);

#endif /*(_WIN32_WINNT >= 0x0600)*/

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                       usr/share/mingw-w64/include/utilapiset.h                                                            0100644 0000000 0000000 00000001342 12404413016 016671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER within this package.
 */
#ifndef _APISETUTIL_
#define _APISETUTIL_

#include <apiset.h>
#include <apisetcconv.h>
#include <minwindef.h>

#ifdef __cplusplus
extern "C" {
#endif

#if WINAPI_FAMILY_PARTITION (WINAPI_PARTITION_APP)
  WINBASEAPI PVOID WINAPI EncodePointer (PVOID Ptr);
  WINBASEAPI PVOID WINAPI DecodePointer (PVOID Ptr);
#endif

#if WINAPI_FAMILY_PARTITION (WINAPI_PARTITION_DESKTOP)
  WINBASEAPI PVOID WINAPI EncodeSystemPointer (PVOID Ptr);
  WINBASEAPI PVOID WINAPI DecodeSystemPointer (PVOID Ptr);
  WINBASEAPI WINBOOL WINAPI Beep (DWORD dwFreq, DWORD dwDuration);
#endif

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                              usr/share/mingw-w64/include/utime.h                                                                 0100644 0000000 0000000 00000000357 12404413015 015635  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#include <sys/utime.h>
                                                                                                                                                                                                                                                                                 usr/share/mingw-w64/include/uuids.h                                                                 0100644 0000000 0000000 00000107116 12404413016 015645  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef OUR_GUID_ENTRY
#define OUR_GUID_ENTRY(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8);
#endif

#define MEDIATYPE_NULL GUID_NULL
#define MEDIASUBTYPE_NULL GUID_NULL

OUR_GUID_ENTRY(MEDIASUBTYPE_None,0xe436eb8e,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIATYPE_Video,0x73646976,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIATYPE_Audio,0x73647561,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIATYPE_Text,0x73747874,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIATYPE_Midi,0x7364696D,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIATYPE_Stream,0xe436eb83,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIATYPE_Interleaved,0x73766169,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIATYPE_File,0x656c6966,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIATYPE_ScriptCommand,0x73636d64,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIATYPE_AUXLine21Data,0x670aea80,0x3a82,0x11d0,0xb7,0x9b,0x0,0xaa,0x0,0x37,0x67,0xa7)
OUR_GUID_ENTRY(MEDIATYPE_VBI,0xf72a76e1,0xeb0a,0x11d0,0xac,0xe4,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(MEDIATYPE_Timecode,0x482dee3,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIATYPE_LMRT,0x74726c6d,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIATYPE_URL_STREAM,0x736c7275,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_CLPL,0x4C504C43,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_YUYV,0x56595559,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_I420,0x30323449,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_IYUV,0x56555949,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_YVU9,0x39555659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_Y411,0x31313459,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_Y41P,0x50313459,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_YUY2,0x32595559,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_YVYU,0x55595659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_UYVY,0x59565955,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_Y211,0x31313259,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_CLJR,0x524a4c43,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_IF09,0x39304649,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_CPLA,0x414c5043,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_MJPG,0x47504A4D,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_TVMJ,0x4A4D5654,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_WAKE,0x454B4157,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_CFCC,0x43434643,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_IJPG,0x47504A49,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_Plum,0x6D756C50,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_DVCS,0x53435644,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_DVSD,0x44535644,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_MDVF,0x4656444D,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB1,0xe436eb78,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB4,0xe436eb79,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB8,0xe436eb7a,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB565,0xe436eb7b,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB555,0xe436eb7c,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB24,0xe436eb7d,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32,0xe436eb7e,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555,0x297c55af,0xe209,0x4cb3,0xb7,0x57,0xc7,0x6d,0x6b,0x9c,0x88,0xa8)
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444,0x6e6415e6,0x5c24,0x425f,0x93,0xcd,0x80,0x10,0x2b,0x3d,0x1c,0xca)
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32,0x773c9ac0,0x3274,0x11d0,0xb7,0x24,0x0,0xaa,0x0,0x6c,0x1a,0x1)
OUR_GUID_ENTRY(MEDIASUBTYPE_A2R10G10B10,0x2f8bb76d,0xb644,0x4550,0xac,0xf3,0xd3,0x0c,0xaa,0x65,0xd5,0xc5)
OUR_GUID_ENTRY(MEDIASUBTYPE_A2B10G10R10,0x576f7893,0xbdf6,0x48c4,0x87,0x5f,0xae,0x7b,0x81,0x83,0x45,0x67)
OUR_GUID_ENTRY(MEDIASUBTYPE_AYUV,0x56555941,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_AI44,0x34344941,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_IA44,0x34344149,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32_D3D_DX7_RT,0x32335237,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB16_D3D_DX7_RT,0x36315237,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32_D3D_DX7_RT,0x38384137,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444_D3D_DX7_RT,0x34344137,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555_D3D_DX7_RT,0x35314137,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32_D3D_DX9_RT,0x32335239,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB16_D3D_DX9_RT,0x36315239,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32_D3D_DX9_RT,0x38384139,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444_D3D_DX9_RT,0x34344139,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555_D3D_DX9_RT,0x35314139,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)

#define MEDIASUBTYPE_HASALPHA(mt) (((mt).subtype==MEDIASUBTYPE_ARGB4444) || ((mt).subtype==MEDIASUBTYPE_ARGB32) || ((mt).subtype==MEDIASUBTYPE_AYUV) || ((mt).subtype==MEDIASUBTYPE_AI44) || ((mt).subtype==MEDIASUBTYPE_IA44) || ((mt).subtype==MEDIASUBTYPE_ARGB1555) || ((mt).subtype==MEDIASUBTYPE_ARGB32_D3D_DX7_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB32_D3D_DX9_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB1555_D3D_DX9_RT))
#define MEDIASUBTYPE_HASALPHA7(mt) (((mt).subtype==MEDIASUBTYPE_ARGB32_D3D_DX7_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB1555_D3D_DX7_RT))
#define MEDIASUBTYPE_D3D_DX7_RT(mt) (((mt).subtype==MEDIASUBTYPE_ARGB32_D3D_DX7_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) || ((mt).subtype==MEDIASUBTYPE_RGB32_D3D_DX7_RT) || ((mt).subtype==MEDIASUBTYPE_RGB16_D3D_DX7_RT))
#define MEDIASUBTYPE_HASALPHA9(mt) (((mt).subtype==MEDIASUBTYPE_ARGB32_D3D_DX9_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB1555_D3D_DX9_RT))
#define MEDIASUBTYPE_D3D_DX9_RT(mt) (((mt).subtype==MEDIASUBTYPE_ARGB32_D3D_DX9_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || ((mt).subtype==MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) || ((mt).subtype==MEDIASUBTYPE_RGB32_D3D_DX9_RT) || ((mt).subtype==MEDIASUBTYPE_RGB16_D3D_DX9_RT))

OUR_GUID_ENTRY(MEDIASUBTYPE_YV12,0x32315659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_NV12,0x3231564E,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC1,0x31434D49,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC2,0x32434D49,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC3,0x33434D49,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC4,0x34434D49,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_S340,0x30343353,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_S342,0x32343353,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_Overlay,0xe436eb7f,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Packet,0xe436eb80,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Payload,0xe436eb81,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1AudioPayload,0x00000050,0x0000,0x0010,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71)
OUR_GUID_ENTRY(MEDIATYPE_MPEG1SystemStream,0xe436eb82,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1System,0xe436eb84,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1VideoCD,0xe436eb85,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Video,0xe436eb86,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Audio,0xe436eb87,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_Avi,0xe436eb88,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_Asf,0x3db80f90,0x9412,0x11d1,0xad,0xed,0x0,0x0,0xf8,0x75,0x4b,0x99)
OUR_GUID_ENTRY(MEDIASUBTYPE_QTMovie,0xe436eb89,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRpza,0x617a7072,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_QTSmc,0x20636d73,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRle,0x20656c72,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_QTJpeg,0x6765706a,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_PCMAudio_Obsolete,0xe436eb8a,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_PCM,0x00000001,0x0000,0x0010,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_WAVE,0xe436eb8b,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_AU,0xe436eb8c,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_AIFF,0xe436eb8d,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsd,0x64737664,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_dvhd,0x64687664,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsl,0x6c737664,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_dv25,0x35327664,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_dv50,0x30357664,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_dvh1,0x31687664,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_BytePair,0x6e8d4a22,0x310c,0x11d0,0xb7,0x9a,0x0,0xaa,0x0,0x37,0x67,0xa7)
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_GOPPacket,0x6e8d4a23,0x310c,0x11d0,0xb7,0x9a,0x0,0xaa,0x0,0x37,0x67,0xa7)
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_VBIRawData,0x6e8d4a24,0x310c,0x11d0,0xb7,0x9a,0x0,0xaa,0x0,0x37,0x67,0xa7)
OUR_GUID_ENTRY(MEDIASUBTYPE_TELETEXT,0xf72a76e3,0xeb0a,0x11d0,0xac,0xe4,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(MEDIASUBTYPE_WSS,0x2791D576,0x8E7A,0x466F,0x9E,0x90,0x5D,0x3F,0x30,0x83,0x73,0x8B)
OUR_GUID_ENTRY(MEDIASUBTYPE_VPS,0xa1b3f620,0x9792,0x4d8d,0x81,0xa4,0x86,0xaf,0x25,0x77,0x20,0x90)
OUR_GUID_ENTRY(MEDIASUBTYPE_DRM_Audio,0x00000009,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_IEEE_FLOAT,0x00000003,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3_SPDIF,0x00000092,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_RAW_SPORT,0x00000240,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_SPDIF_TAG_241h,0x00000241,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71)
OUR_GUID_ENTRY(MEDIASUBTYPE_DssVideo,0xa0af4f81,0xe163,0x11d0,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a)
OUR_GUID_ENTRY(MEDIASUBTYPE_DssAudio,0xa0af4f82,0xe163,0x11d0,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a)
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVideo,0x5a9b6a40,0x1a22,0x11d1,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a)
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVBI,0x5a9b6a41,0x1a22,0x11d1,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a)
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder,0xBF87B6E0,0x8C27,0x11d0,0xB3,0xF0,0x0,0xAA,0x00,0x37,0x61,0xC5)
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder2,0xBF87B6E1,0x8C27,0x11d0,0xB3,0xF0,0x0,0xAA,0x00,0x37,0x61,0xC5)
OUR_GUID_ENTRY(CLSID_ProtoFilterGraph,0xe436ebb0,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(CLSID_SystemClock,0xe436ebb1,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(CLSID_FilterMapper,0xe436ebb2,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(CLSID_FilterGraph,0xe436ebb3,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(CLSID_FilterGraphNoThread,0xe436ebb8,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(CLSID_MPEG1Doc,0xe4bbd160,0x4269,0x11ce,0x83,0x8d,0x0,0xaa,0x0,0x55,0x59,0x5a)
OUR_GUID_ENTRY(CLSID_FileSource,0x701722e0,0x8ae3,0x11ce,0xa8,0x5c,0x00,0xaa,0x00,0x2f,0xea,0xb5)
OUR_GUID_ENTRY(CLSID_MPEG1PacketPlayer,0x26c25940,0x4ca9,0x11ce,0xa8,0x28,0x0,0xaa,0x0,0x2f,0xea,0xb5)
OUR_GUID_ENTRY(CLSID_MPEG1Splitter,0x336475d0,0x942a,0x11ce,0xa8,0x70,0x00,0xaa,0x00,0x2f,0xea,0xb5)
OUR_GUID_ENTRY(CLSID_CMpegVideoCodec,0xfeb50740,0x7bef,0x11ce,0x9b,0xd9,0x0,0x0,0xe2,0x2,0x59,0x9c)
OUR_GUID_ENTRY(CLSID_CMpegAudioCodec,0x4a2286e0,0x7bef,0x11ce,0x9b,0xd9,0x0,0x0,0xe2,0x2,0x59,0x9c)
OUR_GUID_ENTRY(CLSID_TextRender,0xe30629d3,0x27e5,0x11ce,0x87,0x5d,0x0,0x60,0x8c,0xb7,0x80,0x66)
OUR_GUID_ENTRY(CLSID_InfTee,0xf8388a40,0xd5bb,0x11d0,0xbe,0x5a,0x0,0x80,0xc7,0x6,0x56,0x8e)
OUR_GUID_ENTRY(CLSID_AviSplitter,0x1b544c20,0xfd0b,0x11ce,0x8c,0x63,0x0,0xaa,0x00,0x44,0xb5,0x1e)
OUR_GUID_ENTRY(CLSID_AviReader,0x1b544c21,0xfd0b,0x11ce,0x8c,0x63,0x0,0xaa,0x00,0x44,0xb5,0x1e)
OUR_GUID_ENTRY(CLSID_VfwCapture,0x1b544c22,0xfd0b,0x11ce,0x8c,0x63,0x0,0xaa,0x00,0x44,0xb5,0x1e)
OUR_GUID_ENTRY(CLSID_CaptureProperties,0x1B544c22,0xFD0B,0x11ce,0x8C,0x63,0x00,0xAA,0x00,0x44,0xB5,0x1F)
OUR_GUID_ENTRY(CLSID_FGControl,0xe436ebb4,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(CLSID_MOVReader,0x44584800,0xf8ee,0x11ce,0xb2,0xd4,0x00,0xdd,0x1,0x10,0x1b,0x85)
OUR_GUID_ENTRY(CLSID_QuickTimeParser,0xd51bd5a0,0x7548,0x11cf,0xa5,0x20,0x0,0x80,0xc7,0x7e,0xf5,0x8a)
OUR_GUID_ENTRY(CLSID_QTDec,0xfdfe9681,0x74a3,0x11d0,0xaf,0xa7,0x0,0xaa,0x0,0xb6,0x7a,0x42)
OUR_GUID_ENTRY(CLSID_AVIDoc,0xd3588ab0,0x0781,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0xb,0xa7,0x70)
OUR_GUID_ENTRY(CLSID_VideoRenderer,0x70e102b0,0x5556,0x11ce,0x97,0xc0,0x00,0xaa,0x00,0x55,0x59,0x5a)
OUR_GUID_ENTRY(CLSID_Colour,0x1643e180,0x90f5,0x11ce,0x97,0xd5,0x00,0xaa,0x00,0x55,0x59,0x5a)
OUR_GUID_ENTRY(CLSID_Dither,0x1da08500,0x9edc,0x11cf,0xbc,0x10,0x00,0xaa,0x00,0xac,0x74,0xf6)
OUR_GUID_ENTRY(CLSID_ModexRenderer,0x7167665,0x5011,0x11cf,0xbf,0x33,0x0,0xaa,0x0,0x55,0x59,0x5a)
OUR_GUID_ENTRY(CLSID_AudioRender,0xe30629d1,0x27e5,0x11ce,0x87,0x5d,0x0,0x60,0x8c,0xb7,0x80,0x66)
OUR_GUID_ENTRY(CLSID_AudioProperties,0x05589faf,0xc356,0x11ce,0xbf,0x01,0x0,0xaa,0x0,0x55,0x59,0x5a)
OUR_GUID_ENTRY(CLSID_DSoundRender,0x79376820,0x07D0,0x11CF,0xA2,0x4D,0x0,0x20,0xAF,0xD7,0x97,0x67)
OUR_GUID_ENTRY(CLSID_AudioRecord,0xe30629d2,0x27e5,0x11ce,0x87,0x5d,0x0,0x60,0x8c,0xb7,0x80,0x66)
OUR_GUID_ENTRY(CLSID_AudioInputMixerProperties,0x2ca8ca52,0x3c3f,0x11d2,0xb7,0x3d,0x0,0xc0,0x4f,0xb6,0xbd,0x3d)
OUR_GUID_ENTRY(CLSID_AVIDec,0xcf49d4e0,0x1115,0x11ce,0xb0,0x3a,0x0,0x20,0xaf,0xb,0xa7,0x70)
OUR_GUID_ENTRY(CLSID_AVIDraw,0xa888df60,0x1e90,0x11cf,0xac,0x98,0x0,0xaa,0x0,0x4c,0xf,0xa9)
OUR_GUID_ENTRY(CLSID_ACMWrapper,0x6a08cf80,0x0e18,0x11cf,0xa2,0x4d,0x0,0x20,0xaf,0xd7,0x97,0x67)
OUR_GUID_ENTRY(CLSID_AsyncReader,0xe436ebb5,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(CLSID_URLReader,0xe436ebb6,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(CLSID_PersistMonikerPID,0xe436ebb7,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70)
OUR_GUID_ENTRY(CLSID_AVICo,0xd76e2820,0x1563,0x11cf,0xac,0x98,0x0,0xaa,0x0,0x4c,0xf,0xa9)
OUR_GUID_ENTRY(CLSID_FileWriter,0x8596e5f0,0xda5,0x11d0,0xbd,0x21,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_AviDest,0xe2510970,0xf137,0x11ce,0x8b,0x67,0x0,0xaa,0x0,0xa3,0xf1,0xa6)
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage,0xc647b5c0,0x157c,0x11d0,0xbd,0x23,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage1,0xa9ae910,0x85c0,0x11d0,0xbd,0x42,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_AVIMIDIRender,0x07b65360,0xc445,0x11ce,0xaf,0xde,0x00,0xaa,0x00,0x6c,0x14,0xf4)
OUR_GUID_ENTRY(CLSID_WMAsfReader,0x187463a0,0x5bb7,0x11d3,0xac,0xbe,0x0,0x80,0xc7,0x5e,0x24,0x6e)
OUR_GUID_ENTRY(CLSID_WMAsfWriter,0x7c23220e,0x55bb,0x11d3,0x8b,0x16,0x0,0xc0,0x4f,0xb6,0xbd,0x3d)
OUR_GUID_ENTRY(CLSID_MPEG2Demultiplexer,0xafb6c280,0x2c41,0x11d3,0x8a,0x60,0x00,0x00,0xf8,0x1e,0x0e,0x4a)
OUR_GUID_ENTRY(CLSID_MMSPLITTER,0x3ae86b20,0x7be8,0x11d1,0xab,0xe6,0x00,0xa0,0xc9,0x05,0xf3,0x75)
OUR_GUID_ENTRY(CLSID_StreamBufferSink,0x2db47ae5,0xcf39,0x43c2,0xb4,0xd6,0xc,0xd8,0xd9,0x9,0x46,0xf4)
OUR_GUID_ENTRY(CLSID_StreamBufferSource,0xc9f5fe02,0xf851,0x4eb5,0x99,0xee,0xad,0x60,0x2a,0xf1,0xe6,0x19)
OUR_GUID_ENTRY(CLSID_StreamBufferConfig,0xfa8a68b2,0xc864,0x4ba2,0xad,0x53,0xd3,0x87,0x6a,0x87,0x49,0x4b)
OUR_GUID_ENTRY(CLSID_Mpeg2VideoStreamAnalyzer,0x6cfad761,0x735d,0x4aa5,0x8a,0xfc,0xaf,0x91,0xa7,0xd6,0x1e,0xba)
OUR_GUID_ENTRY(CLSID_StreamBufferRecordingAttributes,0xccaa63ac,0x1057,0x4778,0xae,0x92,0x12,0x6,0xab,0x9a,0xce,0xe6)
OUR_GUID_ENTRY(CLSID_StreamBufferComposeRecording,0xd682c4ba,0xa90a,0x42fe,0xb9,0xe1,0x3,0x10,0x98,0x49,0xc4,0x23)
OUR_GUID_ENTRY(CLSID_DVVideoCodec,0xb1b77c00,0xc3e4,0x11cf,0xaf,0x79,0x0,0xaa,0x0,0xb6,0x7a,0x42)
OUR_GUID_ENTRY(CLSID_DVVideoEnc,0x13aa3650,0xbb6f,0x11d0,0xaf,0xb9,0x0,0xaa,0x0,0xb6,0x7a,0x42)
OUR_GUID_ENTRY(CLSID_DVSplitter,0x4eb31670,0x9fc6,0x11cf,0xaf,0x6e,0x0,0xaa,0x0,0xb6,0x7a,0x42)
OUR_GUID_ENTRY(CLSID_DVMux,0x129d7e40,0xc10d,0x11d0,0xaf,0xb9,0x0,0xaa,0x0,0xb6,0x7a,0x42)
OUR_GUID_ENTRY(CLSID_SeekingPassThru,0x60af76c,0x68dd,0x11d0,0x8f,0xc1,0x0,0xc0,0x4f,0xd9,0x18,0x9d)
OUR_GUID_ENTRY(CLSID_Line21Decoder,0x6e8d4a20,0x310c,0x11d0,0xb7,0x9a,0x0,0xaa,0x0,0x37,0x67,0xa7)
OUR_GUID_ENTRY(CLSID_Line21Decoder2,0xe4206432,0x01a1,0x4bee,0xb3,0xe1,0x37,0x02,0xc8,0xed,0xc5,0x74)
OUR_GUID_ENTRY(CLSID_OverlayMixer,0xcd8743a1,0x3736,0x11d0,0x9e,0x69,0x0,0xc0,0x4f,0xd7,0xc1,0x5b)
OUR_GUID_ENTRY(CLSID_VBISurfaces,0x814b9800,0x1c88,0x11d1,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a)
OUR_GUID_ENTRY(CLSID_WSTDecoder,0x70bc06e0,0x5666,0x11d3,0xa1,0x84,0x0,0x10,0x5a,0xef,0x9f,0x33)
OUR_GUID_ENTRY(CLSID_MjpegDec,0x301056d0,0x6dff,0x11d2,0x9e,0xeb,0x0,0x60,0x8,0x3,0x9e,0x37)
OUR_GUID_ENTRY(CLSID_MJPGEnc,0xb80ab0a0,0x7416,0x11d2,0x9e,0xeb,0x0,0x60,0x8,0x3,0x9e,0x37)
OUR_GUID_ENTRY(CLSID_SystemDeviceEnum,0x62BE5D10,0x60EB,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CDeviceMoniker,0x4315D437,0x5B8C,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_VideoInputDeviceCategory,0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CVidCapClassManager,0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_LegacyAmFilterCategory,0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CQzFilterClassManager,0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_VideoCompressorCategory,0x33d9a760,0x90c8,0x11d0,0xbd,0x43,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_CIcmCoClassManager,0x33d9a760,0x90c8,0x11d0,0xbd,0x43,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_AudioCompressorCategory,0x33d9a761,0x90c8,0x11d0,0xbd,0x43,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_CAcmCoClassManager,0x33d9a761,0x90c8,0x11d0,0xbd,0x43,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_AudioInputDeviceCategory,0x33d9a762,0x90c8,0x11d0,0xbd,0x43,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_CWaveinClassManager,0x33d9a762,0x90c8,0x11d0,0xbd,0x43,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_AudioRendererCategory,0xe0f158e1,0xcb04,0x11d0,0xbd,0x4e,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_CWaveOutClassManager,0xe0f158e1,0xcb04,0x11d0,0xbd,0x4e,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_MidiRendererCategory,0x4EfE2452,0x168A,0x11d1,0xBC,0x76,0x0,0xc0,0x4F,0xB9,0x45,0x3B)
OUR_GUID_ENTRY(CLSID_CMidiOutClassManager,0x4EfE2452,0x168A,0x11d1,0xBC,0x76,0x0,0xc0,0x4F,0xB9,0x45,0x3B)
OUR_GUID_ENTRY(CLSID_TransmitCategory,0xcc7bfb41,0xf175,0x11d1,0xa3,0x92,0x0,0xe0,0x29,0x1f,0x39,0x59)
OUR_GUID_ENTRY(CLSID_DeviceControlCategory,0xcc7bfb46,0xf175,0x11d1,0xa3,0x92,0x0,0xe0,0x29,0x1f,0x39,0x59)
OUR_GUID_ENTRY(CLSID_ActiveMovieCategories,0xda4e3da0,0xd07d,0x11d0,0xbd,0x50,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_DVDHWDecodersCategory,0x2721AE20,0x7E70,0x11D0,0xA5,0xD6,0x28,0xDB,0x04,0xC1,0x00,0x00)
OUR_GUID_ENTRY(CLSID_MediaEncoderCategory,0x7D22E920,0x5CA9,0x4787,0x8C,0x2B,0xA6,0x77,0x9B,0xD1,0x17,0x81)
OUR_GUID_ENTRY(CLSID_MediaMultiplexerCategory,0x236C9559,0xADCE,0x4736,0xBF,0x72,0xBA,0xB3,0x4E,0x39,0x21,0x96)
OUR_GUID_ENTRY(CLSID_FilterMapper2,0xcda42200,0xbd88,0x11d0,0xbd,0x4e,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_MemoryAllocator,0x1e651cc0,0xb199,0x11d0,0x82,0x12,0x00,0xc0,0x4f,0xc3,0x2c,0x45)
OUR_GUID_ENTRY(CLSID_MediaPropertyBag,0xcdbd8d00,0xc193,0x11d0,0xbd,0x4e,0x0,0xa0,0xc9,0x11,0xce,0x86)
OUR_GUID_ENTRY(CLSID_DvdGraphBuilder,0xFCC152B7,0xF372,0x11d0,0x8E,0x00,0x00,0xC0,0x4F,0xD7,0xC0,0x8B)
OUR_GUID_ENTRY(CLSID_DVDNavigator,0x9b8c4620,0x2c1a,0x11d0,0x84,0x93,0x0,0xa0,0x24,0x38,0xad,0x48)
OUR_GUID_ENTRY(CLSID_DVDState,0xf963c5cf,0xa659,0x4a93,0x96,0x38,0xca,0xf3,0xcd,0x27,0x7d,0x13)
OUR_GUID_ENTRY(CLSID_SmartTee,0xcc58e280,0x8aa1,0x11d1,0xb3,0xf1,0x0,0xaa,0x0,0x37,0x61,0xc5)
OUR_GUID_ENTRY(FORMAT_None,0x0F6417D6,0xc318,0x11d0,0xa4,0x3f,0x00,0xa0,0xc9,0x22,0x31,0x96)
OUR_GUID_ENTRY(FORMAT_VideoInfo,0x05589f80,0xc356,0x11ce,0xbf,0x01,0x00,0xaa,0x00,0x55,0x59,0x5a)
OUR_GUID_ENTRY(FORMAT_VideoInfo2,0xf72a76A0,0xeb0a,0x11d0,0xac,0xe4,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(FORMAT_WaveFormatEx,0x05589f81,0xc356,0x11ce,0xbf,0x01,0x00,0xaa,0x00,0x55,0x59,0x5a)
OUR_GUID_ENTRY(FORMAT_MPEGVideo,0x05589f82,0xc356,0x11ce,0xbf,0x01,0x00,0xaa,0x00,0x55,0x59,0x5a)
OUR_GUID_ENTRY(FORMAT_MPEGStreams,0x05589f83,0xc356,0x11ce,0xbf,0x01,0x00,0xaa,0x00,0x55,0x59,0x5a)
OUR_GUID_ENTRY(FORMAT_DvInfo,0x05589f84,0xc356,0x11ce,0xbf,0x01,0x00,0xaa,0x00,0x55,0x59,0x5a)
OUR_GUID_ENTRY(CLSID_DirectDrawProperties,0x944d4c00,0xdd52,0x11ce,0xbf,0x0e,0x00,0xaa,0x00,0x55,0x59,0x5a)
OUR_GUID_ENTRY(CLSID_PerformanceProperties,0x59ce6880,0xacf8,0x11cf,0xb5,0x6e,0x00,0x80,0xc7,0xc4,0xb6,0x8a)
OUR_GUID_ENTRY(CLSID_QualityProperties,0x418afb70,0xf8b8,0x11ce,0xaa,0xc6,0x00,0x20,0xaf,0x0b,0x99,0xa3)
OUR_GUID_ENTRY(IID_IBaseVideoMixer,0x61ded640,0xe912,0x11ce,0xa0,0x99,0x00,0xaa,0x00,0x47,0x9a,0x58)
OUR_GUID_ENTRY(IID_IDirectDrawVideo,0x36d39eb0,0xdd75,0x11ce,0xbf,0x0e,0x00,0xaa,0x00,0x55,0x59,0x5a)
OUR_GUID_ENTRY(IID_IQualProp,0x1bd0ecb0,0xf8e2,0x11ce,0xaa,0xc6,0x00,0x20,0xaf,0x0b,0x99,0xa3)
OUR_GUID_ENTRY(CLSID_VPObject,0xce292861,0xfc88,0x11d0,0x9e,0x69,0x0,0xc0,0x4f,0xd7,0xc1,0x5b)
OUR_GUID_ENTRY(IID_IVPObject,0xce292862,0xfc88,0x11d0,0x9e,0x69,0x0,0xc0,0x4f,0xd7,0xc1,0x5b)
OUR_GUID_ENTRY(IID_IVPControl,0x25df12c1,0x3de0,0x11d1,0x9e,0x69,0x0,0xc0,0x4f,0xd7,0xc1,0x5b)
OUR_GUID_ENTRY(CLSID_VPVBIObject,0x814b9801,0x1c88,0x11d1,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a)
OUR_GUID_ENTRY(IID_IVPVBIObject,0x814b9802,0x1c88,0x11d1,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a)
OUR_GUID_ENTRY(IID_IVPConfig,0xbc29a660,0x30e3,0x11d0,0x9e,0x69,0x0,0xc0,0x4f,0xd7,0xc1,0x5b)
OUR_GUID_ENTRY(IID_IVPNotify,0xc76794a1,0xd6c5,0x11d0,0x9e,0x69,0x0,0xc0,0x4f,0xd7,0xc1,0x5b)
OUR_GUID_ENTRY(IID_IVPNotify2,0xebf47183,0x8764,0x11d1,0x9e,0x69,0x0,0xc0,0x4f,0xd7,0xc1,0x5b)
OUR_GUID_ENTRY(IID_IVPVBIConfig,0xec529b00,0x1a1f,0x11d1,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a)
OUR_GUID_ENTRY(IID_IVPVBINotify,0xec529b01,0x1a1f,0x11d1,0xba,0xd9,0x0,0x60,0x97,0x44,0x11,0x1a)
OUR_GUID_ENTRY(IID_IMixerPinConfig,0x593cdde1,0x759,0x11d1,0x9e,0x69,0x0,0xc0,0x4f,0xd7,0xc1,0x5b)
OUR_GUID_ENTRY(IID_IMixerPinConfig2,0xebf47182,0x8764,0x11d1,0x9e,0x69,0x0,0xc0,0x4f,0xd7,0xc1,0x5b)
#ifndef __DDRAW_INCLUDED__
OUR_GUID_ENTRY(CLSID_DirectDraw,0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35)
OUR_GUID_ENTRY(CLSID_DirectDrawClipper,0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDraw,0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDraw2,0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDrawSurface,0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawSurface2,0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27)
OUR_GUID_ENTRY(IID_IDirectDrawSurface3,0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB)
OUR_GUID_ENTRY(IID_IDirectDrawSurface4,0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B)
OUR_GUID_ENTRY(IID_IDirectDrawSurface7,0x06675a80,0x3b9b,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b)
OUR_GUID_ENTRY(IID_IDirectDrawPalette,0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawClipper,0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawColorControl,0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif
#ifndef __DVP_INCLUDED__
OUR_GUID_ENTRY(IID_IDDVideoPortContainer,0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
#endif
#ifndef __DDKM_INCLUDED__
OUR_GUID_ENTRY(IID_IDirectDrawKernel,0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
OUR_GUID_ENTRY(IID_IDirectDrawSurfaceKernel,0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif
OUR_GUID_ENTRY(CLSID_ModexProperties,0x0618aa30,0x6bc4,0x11cf,0xbf,0x36,0x00,0xaa,0x00,0x55,0x59,0x5a)
OUR_GUID_ENTRY(IID_IFullScreenVideo,0xdd1d7110,0x7836,0x11cf,0xbf,0x47,0x00,0xaa,0x00,0x55,0x59,0x5a)
OUR_GUID_ENTRY(IID_IFullScreenVideoEx,0x53479470,0xf1dd,0x11cf,0xbc,0x42,0x00,0xaa,0x00,0xac,0x74,0xf6)
OUR_GUID_ENTRY(CLSID_DVDecPropertiesPage,0x101193c0,0xbfe,0x11d0,0xaf,0x91,0x0,0xaa,0x0,0xb6,0x7a,0x42)
OUR_GUID_ENTRY(CLSID_DVEncPropertiesPage,0x4150f050,0xbb6f,0x11d0,0xaf,0xb9,0x0,0xaa,0x0,0xb6,0x7a,0x42)
OUR_GUID_ENTRY(CLSID_DVMuxPropertyPage,0x4db880e0,0xc10d,0x11d0,0xaf,0xb9,0x0,0xaa,0x0,0xb6,0x7a,0x42)
OUR_GUID_ENTRY(IID_IAMDirectSound,0x546f4260,0xd53e,0x11cf,0xb3,0xf0,0x0,0xaa,0x0,0x37,0x61,0xc5)
OUR_GUID_ENTRY(IID_IMpegAudioDecoder,0xb45dd570,0x3c77,0x11d1,0xab,0xe1,0x00,0xa0,0xc9,0x05,0xf3,0x75)
OUR_GUID_ENTRY(IID_IAMLine21Decoder,0x6e8d4a21,0x310c,0x11d0,0xb7,0x9a,0x0,0xaa,0x0,0x37,0x67,0xa7)
OUR_GUID_ENTRY(IID_IAMWstDecoder,0xc056de21,0x75c2,0x11d3,0xa1,0x84,0x0,0x10,0x5a,0xef,0x9f,0x33)
OUR_GUID_ENTRY(CLSID_WstDecoderPropertyPage,0x4e27f80,0x91e4,0x11d3,0xa1,0x84,0x0,0x10,0x5a,0xef,0x9f,0x33)
OUR_GUID_ENTRY(FORMAT_AnalogVideo,0x482dde0,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIATYPE_AnalogVideo,0x482dde1,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_NTSC_M,0x482dde2,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_B,0x482dde5,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_D,0x482dde6,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_G,0x482dde7,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_H,0x482dde8,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_I,0x482dde9,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_M,0x482ddea,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N,0x482ddeb,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N_COMBO,0x482ddec,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_B,0x482ddf0,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_D,0x482ddf1,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_G,0x482ddf2,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_H,0x482ddf3,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K,0x482ddf4,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K1,0x482ddf5,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_L,0x482ddf6,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(MEDIATYPE_AnalogAudio,0x482dee1,0x7817,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)

#include "ksuuids.h"

OUR_GUID_ENTRY(TIME_FORMAT_NONE,0,0,0,0,0,0,0,0,0,0,0)
OUR_GUID_ENTRY(TIME_FORMAT_FRAME,0x7b785570,0x8c82,0x11cf,0xbc,0xc,0x0,0xaa,0x0,0xac,0x74,0xf6)
OUR_GUID_ENTRY(TIME_FORMAT_BYTE,0x7b785571,0x8c82,0x11cf,0xbc,0xc,0x0,0xaa,0x0,0xac,0x74,0xf6)
OUR_GUID_ENTRY(TIME_FORMAT_SAMPLE,0x7b785572,0x8c82,0x11cf,0xbc,0xc,0x0,0xaa,0x0,0xac,0x74,0xf6)
OUR_GUID_ENTRY(TIME_FORMAT_FIELD,0x7b785573,0x8c82,0x11cf,0xbc,0xc,0x0,0xaa,0x0,0xac,0x74,0xf6)
OUR_GUID_ENTRY(TIME_FORMAT_MEDIA_TIME,0x7b785574,0x8c82,0x11cf,0xbc,0xc,0x0,0xaa,0x0,0xac,0x74,0xf6)
OUR_GUID_ENTRY(AMPROPSETID_Pin,0x9b00f101,0x1567,0x11d1,0xb3,0xf1,0x0,0xaa,0x0,0x37,0x61,0xc5)
OUR_GUID_ENTRY(PIN_CATEGORY_CAPTURE,0xfb6c4281,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(PIN_CATEGORY_PREVIEW,0xfb6c4282,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(PIN_CATEGORY_ANALOGVIDEOIN,0xfb6c4283,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(PIN_CATEGORY_VBI,0xfb6c4284,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT,0xfb6c4285,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(PIN_CATEGORY_NABTS,0xfb6c4286,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(PIN_CATEGORY_EDS,0xfb6c4287,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(PIN_CATEGORY_TELETEXT,0xfb6c4288,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(PIN_CATEGORY_CC,0xfb6c4289,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(PIN_CATEGORY_STILL,0xfb6c428a,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(PIN_CATEGORY_TIMECODE,0xfb6c428b,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT_VBI,0xfb6c428c,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba)
OUR_GUID_ENTRY(LOOK_UPSTREAM_ONLY,0xac798be0,0x98e3,0x11d1,0xb3,0xf1,0x0,0xaa,0x0,0x37,0x61,0xc5)
OUR_GUID_ENTRY(LOOK_DOWNSTREAM_ONLY,0xac798be1,0x98e3,0x11d1,0xb3,0xf1,0x0,0xaa,0x0,0x37,0x61,0xc5)
OUR_GUID_ENTRY(CLSID_TVTunerFilterPropertyPage,0x266eee41,0x6c63,0x11cf,0x8a,0x3,0x0,0xaa,0x0,0x6e,0xcb,0x65)
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,0x71f96461,0x78f3,0x11d0,0xa1,0x8c,0x0,0xa0,0xc9,0x11,0x89,0x56)
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,0x71f96463,0x78f3,0x11d0,0xa1,0x8c,0x0,0xa0,0xc9,0x11,0x89,0x56)
OUR_GUID_ENTRY(CLSID_VideoProcAmpPropertyPage,0x71f96464,0x78f3,0x11d0,0xa1,0x8c,0x0,0xa0,0xc9,0x11,0x89,0x56)
OUR_GUID_ENTRY(CLSID_CameraControlPropertyPage,0x71f96465,0x78f3,0x11d0,0xa1,0x8c,0x0,0xa0,0xc9,0x11,0x89,0x56)
OUR_GUID_ENTRY(CLSID_AnalogVideoDecoderPropertyPage,0x71f96466,0x78f3,0x11d0,0xa1,0x8c,0x0,0xa0,0xc9,0x11,0x89,0x56)
OUR_GUID_ENTRY(CLSID_VideoStreamConfigPropertyPage,0x71f96467,0x78f3,0x11d0,0xa1,0x8c,0x0,0xa0,0xc9,0x11,0x89,0x56)
OUR_GUID_ENTRY(CLSID_AudioRendererAdvancedProperties,0x37e92a92,0xd9aa,0x11d2,0xbf,0x84,0x8e,0xf2,0xb1,0x55,0x5a,0xed)
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer,0xB87BEB7B,0x8D29,0x423f,0xAE,0x4D,0x65,0x82,0xC1,0x01,0x75,0xAC)
OUR_GUID_ENTRY(CLSID_VideoRendererDefault,0x6BC1CFFA,0x8FC1,0x4261,0xAC,0x22,0xCF,0xB4,0xCC,0x38,0xDB,0x50)
OUR_GUID_ENTRY(CLSID_AllocPresenter,0x99d54f63,0x1a69,0x41ae,0xaa,0x4d,0xc9,0x76,0xeb,0x3f,0x07,0x13)
OUR_GUID_ENTRY(CLSID_AllocPresenterDDXclMode,0x4444ac9e,0x242e,0x471b,0xa3,0xc7,0x45,0xdc,0xd4,0x63,0x52,0xbc)
OUR_GUID_ENTRY(CLSID_VideoPortManager,0x6f26a6cd,0x967b,0x47fd,0x87,0x4a,0x7a,0xed,0x2c,0x9d,0x25,0xa2)
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer9,0x51b4abf3,0x748f,0x4e3b,0xa2,0x76,0xc8,0x28,0x33,0x0e,0x92,0x6a)
OUR_GUID_ENTRY(CLSID_ATSCNetworkProvider,0x0dad2fdd,0x5fd7,0x11d3,0x8f,0x50,0x00,0xc0,0x4f,0x79,0x71,0xe2)
OUR_GUID_ENTRY(CLSID_ATSCNetworkPropertyPage,0xe3444d16,0x5ac4,0x4386,0x88,0xdf,0x13,0xfd,0x23,0x0e,0x1d,0xda)
OUR_GUID_ENTRY(CLSID_DVBSNetworkProvider,0xfa4b375a,0x45b4,0x4d45,0x84,0x40,0x26,0x39,0x57,0xb1,0x16,0x23)
OUR_GUID_ENTRY(CLSID_DVBTNetworkProvider,0x216c62df,0x6d7f,0x4e9a,0x85,0x71,0x5,0xf1,0x4e,0xdb,0x76,0x6a)
OUR_GUID_ENTRY(CLSID_DVBCNetworkProvider,0xdc0c0fe7,0x485,0x4266,0xb9,0x3f,0x68,0xfb,0xf8,0xe,0xd8,0x34)
OUR_GUID_ENTRY(CLSID_DShowTVEFilter,0x05500280,0xFAA5,0x4DF9,0x82,0x46,0xBF,0xC2,0x3A,0xC5,0xCE,0xA8)
OUR_GUID_ENTRY(CLSID_TVEFilterTuneProperties,0x05500281,0xFAA5,0x4DF9,0x82,0x46,0xBF,0xC2,0x3A,0xC5,0xCE,0xA8)
OUR_GUID_ENTRY(CLSID_TVEFilterCCProperties,0x05500282,0xFAA5,0x4DF9,0x82,0x46,0xBF,0xC2,0x3A,0xC5,0xCE,0xA8)
OUR_GUID_ENTRY(CLSID_TVEFilterStatsProperties,0x05500283,0xFAA5,0x4DF9,0x82,0x46,0xBF,0xC2,0x3A,0xC5,0xCE,0xA8)
OUR_GUID_ENTRY(CLSID_IVideoEncoderProxy,0xb43c4eec,0x8c32,0x4791,0x91,0x2,0x50,0x8a,0xda,0x5e,0xe8,0xe7)
OUR_GUID_ENTRY(CLSID_ICodecAPIProxy,0x7ff0997a,0x1999,0x4286,0xa7,0x3c,0x62,0x2b,0x88,0x14,0xe7,0xeb)
OUR_GUID_ENTRY(CLSID_IVideoEncoderCodecAPIProxy,0xb05dabd9,0x56e5,0x4fdc,0xaf,0xa4,0x8a,0x47,0xe9,0x1f,0x1c,0x9c)

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE,0x49cc4c43,0xca83,0x4ad4,0xa9,0xaf,0xf3,0x69,0x6a,0xf6,0x66,0xdf)
OUR_GUID_ENTRY(ENCAPIPARAM_PEAK_BITRATE,0x703f16a9,0x3d48,0x44a1,0xb0,0x77,0x1,0x8d,0xff,0x91,0x5d,0x19)
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE_MODE,0xee5fb25c,0xc713,0x40d1,0x9d,0x58,0xc0,0xd7,0x24,0x1e,0x25,0xf)
OUR_GUID_ENTRY(CODECAPI_CHANGELISTS,0x62b12acf,0xf6b0,0x47d9,0x94,0x56,0x96,0xf2,0x2c,0x4e,0x0b,0x9d)
OUR_GUID_ENTRY(CODECAPI_VIDEO_ENCODER,0x7112e8e1,0x3d03,0x47ef,0x8e,0x60,0x03,0xf1,0xcf,0x53,0x73,0x01)
OUR_GUID_ENTRY(CODECAPI_AUDIO_ENCODER,0xb9d19a3e,0xf897,0x429c,0xbc,0x46,0x81,0x38,0xb7,0x27,0x2b,0x2d)
OUR_GUID_ENTRY(CODECAPI_SETALLDEFAULTS,0x6c5e6a7c,0xacf8,0x4f55,0xa9,0x99,0x1a,0x62,0x81,0x09,0x05,0x1b)
OUR_GUID_ENTRY(CODECAPI_ALLSETTINGS,0x6a577e92,0x83e1,0x4113,0xad,0xc2,0x4f,0xce,0xc3,0x2f,0x83,0xa1)
OUR_GUID_ENTRY(CODECAPI_SUPPORTSEVENTS,0x0581af97,0x7693,0x4dbd,0x9d,0xca,0x3f,0x9e,0xbd,0x65,0x85,0xa1)
OUR_GUID_ENTRY(CODECAPI_CURRENTCHANGELIST,0x1cb14e83,0x7d72,0x4657,0x83,0xfd,0x47,0xa2,0xc5,0xb9,0xd1,0x3d)
#endif

#undef OUR_GUID_ENTRY
                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/share/mingw-w64/include/uxtheme.h                                                               0100644 0000000 0000000 00000031204 12404413016 016165  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _UXTHEME_H_
#define _UXTHEME_H_

#include <commctrl.h>

#ifndef THEMEAPI
#if !defined(_UXTHEME_)
#define THEMEAPI EXTERN_C DECLSPEC_IMPORT HRESULT WINAPI
#define THEMEAPI_(type) EXTERN_C DECLSPEC_IMPORT type WINAPI
#else
#define THEMEAPI STDAPI
#define THEMEAPI_(type) STDAPI_(type)
#endif
#endif

typedef HANDLE HTHEME;

#if (NTDDI_VERSION >= NTDDI_WIN7)
WINBOOL WINAPI BeginPanningFeedback(HWND hwnd);
WINBOOL WINAPI UpdatePanningFeedback(HWND hwnd,LONG lTotalOverpanOffsetX,LONG lTotalOverpanOffsetY,WINBOOL fInInertia);
WINBOOL WINAPI EndPanningFeedback(HWND hwnd,WINBOOL fAnimateBack);
#endif

#if _WIN32_WINNT >= 0x0600

#define GBF_DIRECT 0x00000001
#define GBF_COPY 0x00000002
#define GBF_VALIDBITS (GBF_DIRECT | GBF_COPY)

THEMEAPI GetThemeBitmap(HTHEME hTheme,int iPartId,int iStateId,int iPropId,ULONG dwFlags,HBITMAP *phBitmap);
THEMEAPI GetThemeStream(HTHEME hTheme,int iPartId,int iStateId,int iPropId,VOID **ppvStream,DWORD *pcbStream,HINSTANCE hInst);
THEMEAPI GetThemeTransitionDuration(HTHEME hTheme,int iPartId,int iStateIdFrom,int iStateIdTo,int iPropId,DWORD *pdwDuration);

DECLARE_HANDLE(HPAINTBUFFER);

typedef enum _BP_BUFFERFORMAT {
    BPBF_COMPATIBLEBITMAP, BPBF_DIB, BPBF_TOPDOWNDIB, BPBF_TOPDOWNMONODIB
} BP_BUFFERFORMAT;

#define BPPF_ERASE     0x00000001
#define BPPF_NOCLIP    0x00000002
#define BPPF_NONCLIENT 0x00000004

typedef struct _BP_PAINTPARAMS {
    DWORD cbSize;
    DWORD dwFlags;
    const RECT *prcExclude;
    const BLENDFUNCTION *pBlendFunction;
} BP_PAINTPARAMS, *PBP_PAINTPARAMS;

THEMEAPI_(HPAINTBUFFER) BeginBufferedPaint(HDC hdcTarget,const RECT *prcTarget,BP_BUFFERFORMAT dwFormat,BP_PAINTPARAMS *pPaintParams,HDC *phdc);
THEMEAPI_(HRESULT) EndBufferedPaint(HPAINTBUFFER hBufferedPaint,WINBOOL fUpdateTarget);
THEMEAPI_(HRESULT) GetBufferedPaintTargetRect(HPAINTBUFFER hBufferedPaint,RECT *prc);
THEMEAPI_(HDC) GetBufferedPaintTargetDC(HPAINTBUFFER hBufferedPaint);
THEMEAPI_(HDC) GetBufferedPaintDC(HPAINTBUFFER hBufferedPaint);
THEMEAPI_(HRESULT) GetBufferedPaintBits(HPAINTBUFFER hBufferedPaint,RGBQUAD **ppbBuffer,int *pcxRow);
THEMEAPI_(HRESULT) BufferedPaintClear(HPAINTBUFFER hBufferedPaint,const RECT *prc);
THEMEAPI_(HRESULT) BufferedPaintSetAlpha(HPAINTBUFFER hBufferedPaint,const RECT *prc,BYTE alpha);
THEMEAPI_(HRESULT) BufferedPaintInit(VOID);
THEMEAPI_(HRESULT) BufferedPaintUnInit(VOID);

DECLARE_HANDLE(HANIMATIONBUFFER);

typedef enum _BP_ANIMATIONSTYLE {
    BPAS_NONE, BPAS_LINEAR, BPAS_CUBIC, BPAS_SINE
} BP_ANIMATIONSTYLE;

typedef struct _BP_ANIMATIONPARAMS {
    DWORD cbSize;
    DWORD  dwFlags;
    BP_ANIMATIONSTYLE style;
    DWORD dwDuration;
} BP_ANIMATIONPARAMS, *PBP_ANIMATIONPARAMS;

THEMEAPI_(HANIMATIONBUFFER) BeginBufferedAnimation(HWND hwnd,HDC hdcTarget,const RECT *rcTarget,BP_BUFFERFORMAT dwFormat,BP_PAINTPARAMS *pPaintParams,BP_ANIMATIONPARAMS *pAnimationParams,HDC *phdcFrom,HDC *phdcTo);
THEMEAPI EndBufferedAnimation(HANIMATIONBUFFER hbpAnimation,WINBOOL fUpdateTarget);
THEMEAPI_(WINBOOL) BufferedPaintRenderAnimation(HWND hwnd,HDC hdcTarget);
THEMEAPI BufferedPaintStopAllAnimations(HWND hwnd);
THEMEAPI_(WINBOOL) IsCompositionActive(void);

typedef enum WINDOWTHEMEATTRIBUTETYPE {
    WTA_NONCLIENT = 1 
} WINDOWTHEMEATTRIBUTETYPE;

typedef struct WTA_OPTIONS {
    DWORD dwFlags;
    DWORD dwMask;
} WTA_OPTIONS, *PWTA_OPTIONS;

#define WTNCA_NODRAWCAPTION 0x00000001
#define WTNCA_NODRAWICON 0x00000002
#define WTNCA_NOSYSMENU 0x00000004
#define WTNCA_NOMIRRORHELP 0x00000008
#define WTNCA_VALIDBITS (WTNCA_NODRAWCAPTION | WTNCA_NODRAWICON | WTNCA_NOSYSMENU | WTNCA_NOMIRRORHELP)

THEMEAPI SetWindowThemeAttribute(HWND hwnd,enum WINDOWTHEMEATTRIBUTETYPE eAttribute,PVOID pvAttribute,DWORD cbAttribute);

static __inline HRESULT SetWindowThemeNonClientAttributes(HWND hwnd,DWORD dwMask,DWORD dwAttributes)
{
    WTA_OPTIONS wta = { dwAttributes, dwMask };
    return SetWindowThemeAttribute(hwnd, WTA_NONCLIENT, &wta, sizeof(WTA_OPTIONS));
}

#endif

THEMEAPI_(HTHEME) OpenThemeData(HWND hwnd,LPCWSTR pszClassList);

#if (_WIN32_WINNT >= 0x0600)
#define OTD_FORCE_RECT_SIZING 0x00000001
#define OTD_NONCLIENT 0x00000002
#define OTD_VALIDBITS (OTD_FORCE_RECT_SIZING | OTD_NONCLIENT)
THEMEAPI_(HTHEME) OpenThemeDataEx(HWND hwnd,LPCWSTR pszClassList,DWORD dwFlags);
#endif

THEMEAPI CloseThemeData(HTHEME hTheme);
THEMEAPI DrawThemeBackground(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,const RECT *pRect,const RECT *pClipRect);

#define DTT_GRAYED 0x1

THEMEAPI DrawThemeText(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,LPCWSTR pszText,int iCharCount,DWORD dwTextFlags,DWORD dwTextFlags2,const RECT *pRect);

#if (_WIN32_WINNT >= 0x0600)

#define DTT_TEXTCOLOR (__MSABI_LONG(1U) << 0)
#define DTT_BORDERCOLOR (__MSABI_LONG(1U) << 1)
#define DTT_SHADOWCOLOR (__MSABI_LONG(1U) << 2)
#define DTT_SHADOWTYPE (__MSABI_LONG(1U) << 3)
#define DTT_SHADOWOFFSET (__MSABI_LONG(1U) << 4)
#define DTT_BORDERSIZE (__MSABI_LONG(1U) << 5)
#define DTT_FONTPROP (__MSABI_LONG(1U) << 6)
#define DTT_COLORPROP (__MSABI_LONG(1U) << 7)
#define DTT_STATEID (__MSABI_LONG(1U) << 8)
#define DTT_CALCRECT (__MSABI_LONG(1U) << 9)
#define DTT_APPLYOVERLAY (__MSABI_LONG(1U) << 10)
#define DTT_GLOWSIZE (__MSABI_LONG(1U) << 11)
#define DTT_CALLBACK (__MSABI_LONG(1U) << 12)
#define DTT_COMPOSITED (__MSABI_LONG(1U) << 13)
#define DTT_VALIDBITS (DTT_TEXTCOLOR | DTT_BORDERCOLOR | DTT_SHADOWCOLOR | DTT_SHADOWTYPE | DTT_SHADOWOFFSET | DTT_BORDERSIZE | \
                       DTT_FONTPROP | DTT_COLORPROP | DTT_STATEID | DTT_CALCRECT | DTT_APPLYOVERLAY | DTT_GLOWSIZE | DTT_COMPOSITED)

typedef int (WINAPI *DTT_CALLBACK_PROC)(HDC hdc,LPWSTR pszText,int cchText,LPRECT prc,UINT dwFlags,LPARAM lParam);

typedef struct _DTTOPTS {
    DWORD dwSize;
    DWORD dwFlags;
    COLORREF crText;
    COLORREF crBorder;
    COLORREF crShadow;
    int iTextShadowType;
    POINT ptShadowOffset;
    int iBorderSize;
    int iFontPropId;
    int iColorPropId;
    int iStateId;
    WINBOOL fApplyOverlay;
    int iGlowSize;
    DTT_CALLBACK_PROC pfnDrawTextCallback;
    LPARAM lParam;
} DTTOPTS, *PDTTOPTS;

THEMEAPI DrawThemeTextEx(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,LPCWSTR pszText,int iCharCount,DWORD dwFlags,LPRECT pRect,const DTTOPTS *pOptions);
#endif

THEMEAPI GetThemeBackgroundContentRect(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,const RECT *pBoundingRect,RECT *pContentRect);
THEMEAPI GetThemeBackgroundExtent(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,const RECT *pContentRect,RECT *pExtentRect);

typedef enum THEMESIZE {
  TS_MIN,TS_TRUE,TS_DRAW
} THEMESIZE;

THEMEAPI GetThemePartSize(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,RECT *prc,enum THEMESIZE eSize,SIZE *psz);
THEMEAPI GetThemeTextExtent(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,LPCWSTR pszText,int iCharCount,DWORD dwTextFlags,const RECT *pBoundingRect,RECT *pExtentRect);
THEMEAPI GetThemeTextMetrics(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,TEXTMETRIC *ptm);
THEMEAPI GetThemeBackgroundRegion(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,const RECT *pRect,HRGN *pRegion);

#define HTTB_BACKGROUNDSEG 0x0000
#define HTTB_FIXEDBORDER 0x0002
#define HTTB_CAPTION 0x0004
#define HTTB_RESIZINGBORDER_LEFT 0x0010
#define HTTB_RESIZINGBORDER_TOP 0x0020
#define HTTB_RESIZINGBORDER_RIGHT 0x0040
#define HTTB_RESIZINGBORDER_BOTTOM 0x0080

#define HTTB_RESIZINGBORDER (HTTB_RESIZINGBORDER_LEFT|HTTB_RESIZINGBORDER_TOP| HTTB_RESIZINGBORDER_RIGHT|HTTB_RESIZINGBORDER_BOTTOM)

#define HTTB_SIZINGTEMPLATE 0x0100
#define HTTB_SYSTEMSIZINGMARGINS 0x0200

THEMEAPI HitTestThemeBackground(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,DWORD dwOptions,const RECT *pRect,HRGN hrgn,POINT ptTest,WORD *pwHitTestCode);
THEMEAPI DrawThemeEdge(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,const RECT *pDestRect,UINT uEdge,UINT uFlags,RECT *pContentRect);
THEMEAPI DrawThemeIcon(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,const RECT *pRect,HIMAGELIST himl,int iImageIndex);
THEMEAPI_(WINBOOL) IsThemePartDefined(HTHEME hTheme,int iPartId,int iStateId);
THEMEAPI_(WINBOOL) IsThemeBackgroundPartiallyTransparent(HTHEME hTheme,int iPartId,int iStateId);
THEMEAPI GetThemeColor(HTHEME hTheme,int iPartId,int iStateId,int iPropId,COLORREF *pColor);
THEMEAPI GetThemeMetric(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,int iPropId,int *piVal);
THEMEAPI GetThemeString(HTHEME hTheme,int iPartId,int iStateId,int iPropId,LPWSTR pszBuff,int cchMaxBuffChars);
THEMEAPI GetThemeBool(HTHEME hTheme,int iPartId,int iStateId,int iPropId,WINBOOL *pfVal);
THEMEAPI GetThemeInt(HTHEME hTheme,int iPartId,int iStateId,int iPropId,int *piVal);
THEMEAPI GetThemeEnumValue(HTHEME hTheme,int iPartId,int iStateId,int iPropId,int *piVal);
THEMEAPI GetThemePosition(HTHEME hTheme,int iPartId,int iStateId,int iPropId,POINT *pPoint);
THEMEAPI GetThemeFont(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,int iPropId,LOGFONT *pFont);
THEMEAPI GetThemeRect(HTHEME hTheme,int iPartId,int iStateId,int iPropId,RECT *pRect);

typedef struct _MARGINS {
  int cxLeftWidth;
  int cxRightWidth;
  int cyTopHeight;
  int cyBottomHeight;
} MARGINS,*PMARGINS;

THEMEAPI GetThemeMargins(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,int iPropId,RECT *prc,MARGINS *pMargins);

#if (_WIN32_WINNT >= 0x0600)
#define MAX_INTLIST_COUNT 402
#else
#define MAX_INTLIST_COUNT 10
#endif

typedef struct _INTLIST {
  int iValueCount;
  int iValues[MAX_INTLIST_COUNT];
} INTLIST,*PINTLIST;

THEMEAPI GetThemeIntList(HTHEME hTheme,int iPartId,int iStateId,int iPropId,INTLIST *pIntList);

typedef enum PROPERTYORIGIN {
  PO_STATE,PO_PART,PO_CLASS,PO_GLOBAL,PO_NOTFOUND
} PROPERTYORIGIN;

THEMEAPI GetThemePropertyOrigin(HTHEME hTheme,int iPartId,int iStateId,int iPropId,enum PROPERTYORIGIN *pOrigin);
THEMEAPI SetWindowTheme(HWND hwnd,LPCWSTR pszSubAppName,LPCWSTR pszSubIdList);
THEMEAPI GetThemeFilename(HTHEME hTheme,int iPartId,int iStateId,int iPropId,LPWSTR pszThemeFileName,int cchMaxBuffChars);
THEMEAPI_(COLORREF) GetThemeSysColor(HTHEME hTheme,int iColorId);
THEMEAPI_(HBRUSH) GetThemeSysColorBrush(HTHEME hTheme,int iColorId);
THEMEAPI_(WINBOOL) GetThemeSysBool(HTHEME hTheme,int iBoolId);
THEMEAPI_(int) GetThemeSysSize(HTHEME hTheme,int iSizeId);
THEMEAPI GetThemeSysFont(HTHEME hTheme,int iFontId,LOGFONT *plf);
THEMEAPI GetThemeSysString(HTHEME hTheme,int iStringId,LPWSTR pszStringBuff,int cchMaxStringChars);
THEMEAPI GetThemeSysInt(HTHEME hTheme,int iIntId,int *piValue);
THEMEAPI_(WINBOOL) IsThemeActive();
THEMEAPI_(WINBOOL) IsAppThemed();
THEMEAPI_(HTHEME) GetWindowTheme(HWND hwnd);

#define ETDT_DISABLE 0x00000001
#define ETDT_ENABLE 0x00000002
#define ETDT_USETABTEXTURE 0x00000004
#define ETDT_ENABLETAB (ETDT_ENABLE | ETDT_USETABTEXTURE)
#if (_WIN32_WINNT >= 0x0600)
#define ETDT_USEAEROWIZARDTABTEXTURE 0x00000008
#define ETDT_ENABLEAEROWIZARDTAB (ETDT_ENABLE | ETDT_USEAEROWIZARDTABTEXTURE)
#define ETDT_VALIDBITS (ETDT_DISABLE | ETDT_ENABLE | ETDT_USETABTEXTURE | ETDT_USEAEROWIZARDTABTEXTURE)
#endif

THEMEAPI EnableThemeDialogTexture(HWND hwnd,DWORD dwFlags);
THEMEAPI_(WINBOOL) IsThemeDialogTextureEnabled(HWND hwnd);

#define STAP_ALLOW_NONCLIENT (1 << 0)
#define STAP_ALLOW_CONTROLS (1 << 1)
#define STAP_ALLOW_WEBCONTENT (1 << 2)

THEMEAPI_(DWORD) GetThemeAppProperties();
THEMEAPI_(void) SetThemeAppProperties(DWORD dwFlags);
THEMEAPI GetCurrentThemeName(LPWSTR pszThemeFileName,int cchMaxNameChars,LPWSTR pszColorBuff,int cchMaxColorChars,LPWSTR pszSizeBuff,int cchMaxSizeChars);

#define SZ_THDOCPROP_DISPLAYNAME L"DisplayName"
#define SZ_THDOCPROP_CANONICALNAME L"ThemeName"
#define SZ_THDOCPROP_TOOLTIP L"ToolTip"
#define SZ_THDOCPROP_AUTHOR L"author"

THEMEAPI GetThemeDocumentationProperty(LPCWSTR pszThemeName,LPCWSTR pszPropertyName,LPWSTR pszValueBuff,int cchMaxValChars);
THEMEAPI DrawThemeParentBackground(HWND hwnd,HDC hdc,RECT *prc);

#if (_WIN32_WINNT >= 0x0600)
#define DTPB_WINDOWDC 0x00000001
#define DTPB_USECTLCOLORSTATIC 0x00000002
#define DTPB_USEERASEBKGND 0x00000004

THEMEAPI DrawThemeParentBackgroundEx(HWND hwnd,HDC hdc,DWORD dwFlags,const RECT *prc);
#endif

THEMEAPI EnableTheming(WINBOOL fEnable);

#define DTBG_CLIPRECT 0x00000001
#define DTBG_DRAWSOLID 0x00000002
#define DTBG_OMITBORDER 0x00000004
#define DTBG_OMITCONTENT 0x00000008
#define DTBG_COMPUTINGREGION 0x00000010
#define DTBG_MIRRORDC 0x00000020
#define DTBG_NOMIRROR 0x00000040
#define DTBG_VALIDBITS (DTBG_CLIPRECT | DTBG_DRAWSOLID | DTBG_OMITBORDER | DTBG_OMITCONTENT | DTBG_COMPUTINGREGION | DTBG_MIRRORDC | DTBG_NOMIRROR)

typedef struct _DTBGOPTS {
  DWORD dwSize;
  DWORD dwFlags;
  RECT rcClip;
} DTBGOPTS,*PDTBGOPTS;

THEMEAPI DrawThemeBackgroundEx(HTHEME hTheme,HDC hdc,int iPartId,int iStateId,const RECT *pRect,const DTBGOPTS *pOptions);
#endif
                                                                                                                                                                                                                                                                                                                                                                                            usr/share/mingw-w64/include/vadefs.h                                                                0100644 0000000 0000000 00000005245 12404413015 015763  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_VADEFS
#define _INC_VADEFS

#include <_mingw.h>

#ifndef __WIDL__
#pragma pack(push,_CRT_PACKING)
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined (__GNUC__)
#ifndef __GNUC_VA_LIST
#define __GNUC_VA_LIST
  typedef __builtin_va_list __gnuc_va_list;
#endif
#endif /* __GNUC__ */

#ifndef _VA_LIST_DEFINED	/* if stdargs.h didn't define it */
#define _VA_LIST_DEFINED
#if defined(__GNUC__)
  typedef __gnuc_va_list va_list;
#elif defined(_MSC_VER)
  typedef char *  va_list;
#elif !defined(__WIDL__)
#error VARARGS not implemented for this compiler
#endif
#endif /* _VA_LIST_DEFINED */

#ifdef __cplusplus
#define _ADDRESSOF(v) (&reinterpret_cast<const char &>(v))
#else
#define _ADDRESSOF(v) (&(v))
#endif

#if defined (__GNUC__)
/* Use GCC builtins */

#define _crt_va_start(v,l)	__builtin_va_start(v,l)
#define _crt_va_arg(v,l)	__builtin_va_arg(v,l)
#define _crt_va_end(v)		__builtin_va_end(v)
#define _crt_va_copy(d,s)	__builtin_va_copy(d,s)

#elif defined(_MSC_VER)
/* MSVC specific */

#if defined(_M_IA64)
#define _VA_ALIGN 8
#define _SLOTSIZEOF(t) ((sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1))
#define _VA_STRUCT_ALIGN 16
#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) - (ap))
#define _APALIGN(t,ap) (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)
#else
#define _SLOTSIZEOF(t) (sizeof(t))
#define _APALIGN(t,ap) (__alignof(t))
#endif

#if defined(_M_IX86)

#define _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1))
#define _crt_va_start(v,l)	((v) = (va_list)_ADDRESSOF(l) + _INTSIZEOF(l))
#define _crt_va_arg(v,l)	(*(l *)(((v) += _INTSIZEOF(l)) - _INTSIZEOF(l)))
#define _crt_va_end(v)		((v) = (va_list)0)
#define _crt_va_copy(d,s)	((d) = (s))

#elif defined(_M_AMD64)

#define _PTRSIZEOF(n) ((sizeof(n) + sizeof(void*) - 1) & ~(sizeof(void*) - 1))
#define _ISSTRUCT(t)  ((sizeof(t) > sizeof(void*)) || (sizeof(t) & (sizeof(t) - 1)) != 0)
#define _crt_va_start(v,l)	((v) = (va_list)_ADDRESSOF(l) + _PTRSIZEOF(l))
#define _crt_va_arg(v,t)	_ISSTRUCT(t) ?						\
				 (**(t**)(((v) += sizeof(void*)) - sizeof(void*))) :	\
				 ( *(t *)(((v) += sizeof(void*)) - sizeof(void*)))
#define _crt_va_end(v)		((v) = (va_list)0)
#define _crt_va_copy(d,s)	((d) = (s))

#elif defined(_M_IA64)

#error VARARGS not implemented for IA64

#else

#error VARARGS not implemented for this TARGET

#endif /* cpu ifdefs */

#endif /* compiler ifdefs */

#ifdef __cplusplus
}
#endif

#ifndef __WIDL__
#pragma pack(pop)
#endif

#endif /* _INC_VADEFS */

                                                                                                                                                                                                                                                                                                                                                           usr/share/mingw-w64/include/varargs.h                                                               0100644 0000000 0000000 00000000543 12404413015 016154  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _VARARGS_H
#define _VARARGS_H

#error "GCC no longer implements <varargs.h>."
#error "Revise your code to use <stdarg.h>."

#endif
                                                                                                                                                             usr/share/mingw-w64/include/vcr.h                                                                   0100644 0000000 0000000 00000032171 12404413016 015304  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __VCR_H__
#define __VCR_H__

#define MCI_VCR_OFFSET 1280

#define MCI_LIST 0x0878
#define MCI_SETAUDIO 0x0873
#define MCI_SETVIDEO 0x0876
#define MCI_SIGNAL 0x0875

#define MCI_MARK (MCI_USER_MESSAGES + 0)
#define MCI_INDEX (MCI_USER_MESSAGES + 1)
#define MCI_SETTUNER (MCI_USER_MESSAGES + 2)
#define MCI_SETVCR (MCI_USER_MESSAGES + 3)
#define MCI_SETTIMECODE (MCI_USER_MESSAGES + 4)

#define MCI_TEST __MSABI_LONG(0x00000020)

#define MCI_VCR_GETDEVCAPS_CAN_DETECT_LENGTH __MSABI_LONG(0x00004001)
#define MCI_VCR_GETDEVCAPS_SEEK_ACCURACY __MSABI_LONG(0x00004002)
#define MCI_VCR_GETDEVCAPS_HAS_CLOCK __MSABI_LONG(0x00004003)
#define MCI_VCR_GETDEVCAPS_CAN_REVERSE __MSABI_LONG(0x00004004)
#define MCI_VCR_GETDEVCAPS_NUMBER_OF_MARKS __MSABI_LONG(0x00004005)
#define MCI_VCR_GETDEVCAPS_CAN_TEST __MSABI_LONG(0x00004006)
#define MCI_VCR_GETDEVCAPS_CAN_PREROLL __MSABI_LONG(0x00004007)
#define MCI_VCR_GETDEVCAPS_CAN_PREVIEW __MSABI_LONG(0x00004008)
#define MCI_VCR_GETDEVCAPS_CAN_MONITOR_SOURCES __MSABI_LONG(0x00004009)
#define MCI_VCR_GETDEVCAPS_HAS_TIMECODE __MSABI_LONG(0x0000400A)
#define MCI_VCR_GETDEVCAPS_CAN_FREEZE __MSABI_LONG(0x0000401B)
#define MCI_VCR_GETDEVCAPS_CLOCK_INCREMENT_RATE __MSABI_LONG(0x0000401C)

#define MCI_VCR_INFO_VERSION __MSABI_LONG(0x00010000)

#define MCI_VCR_PLAY_REVERSE __MSABI_LONG(0x00010000)
#define MCI_VCR_PLAY_AT __MSABI_LONG(0x00020000)
#define MCI_VCR_PLAY_SCAN __MSABI_LONG(0x00040000)

#define MCI_VCR_RECORD_INITIALIZE __MSABI_LONG(0x00010000)
#define MCI_VCR_RECORD_AT __MSABI_LONG(0x00020000)
#define MCI_VCR_RECORD_PREVIEW __MSABI_LONG(0x00040000)

#define MCI_VCR_CUE_INPUT __MSABI_LONG(0x00010000)
#define MCI_VCR_CUE_OUTPUT __MSABI_LONG(0x00020000)
#define MCI_VCR_CUE_PREROLL __MSABI_LONG(0x00040000)
#define MCI_VCR_CUE_REVERSE __MSABI_LONG(0x00080000)

#define MCI_VCR_SEEK_REVERSE __MSABI_LONG(0x00010000)
#define MCI_VCR_SEEK_MARK __MSABI_LONG(0x00020000)
#define MCI_VCR_SEEK_AT __MSABI_LONG(0x00040000)

#define MCI_VCR_SETTUNER_CHANNEL __MSABI_LONG(0x00010000)
#define MCI_VCR_SETTUNER_CHANNEL_UP __MSABI_LONG(0x00020000)
#define MCI_VCR_SETTUNER_CHANNEL_DOWN __MSABI_LONG(0x00040000)
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_UP __MSABI_LONG(0x00080000)
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_DOWN __MSABI_LONG(0x00100000)
#define MCI_VCR_SETTUNER_NUMBER __MSABI_LONG(0x00200000)

#define MCI_VCR_SET_TIME_MODE __MSABI_LONG(0x00010000)
#define MCI_VCR_SET_POWER __MSABI_LONG(0x00020000)
#define MCI_VCR_SET_RECORD_FORMAT __MSABI_LONG(0x00040000)
#define MCI_VCR_SET_COUNTER_FORMAT __MSABI_LONG(0x00080000)
#define MCI_VCR_SET_INDEX __MSABI_LONG(0x00100000)
#define MCI_VCR_SET_ASSEMBLE_RECORD __MSABI_LONG(0x00200000)
#define MCI_VCR_SET_TRACKING __MSABI_LONG(0x00400000)
#define MCI_VCR_SET_SPEED __MSABI_LONG(0x00800000)
#define MCI_VCR_SET_TAPE_LENGTH __MSABI_LONG(0x01000000)
#define MCI_VCR_SET_COUNTER_VALUE __MSABI_LONG(0x02000000)
#define MCI_VCR_SET_CLOCK __MSABI_LONG(0x04000000)
#define MCI_VCR_SET_PAUSE_TIMEOUT __MSABI_LONG(0x08000000)
#define MCI_VCR_SET_PREROLL_DURATION __MSABI_LONG(0x10000000)
#define MCI_VCR_SET_POSTROLL_DURATION __MSABI_LONG(0x20000000)

#define MCI_VCR_SETTIMECODE_RECORD __MSABI_LONG(0x00010000)

#define MCI_VCR_STATUS_FRAME_RATE __MSABI_LONG(0x00004001)
#define MCI_VCR_STATUS_SPEED __MSABI_LONG(0x00004002)
#define MCI_VCR_STATUS_MEDIA_TYPE __MSABI_LONG(0x00004003)
#define MCI_VCR_STATUS_RECORD_FORMAT __MSABI_LONG(0x00004004)
#define MCI_VCR_STATUS_PLAY_FORMAT __MSABI_LONG(0x00004005)
#define MCI_VCR_STATUS_AUDIO_SOURCE __MSABI_LONG(0x00004006)
#define MCI_VCR_STATUS_AUDIO_SOURCE_NUMBER __MSABI_LONG(0x00004007)
#define MCI_VCR_STATUS_VIDEO_SOURCE __MSABI_LONG(0x00004008)
#define MCI_VCR_STATUS_VIDEO_SOURCE_NUMBER __MSABI_LONG(0x00004009)
#define MCI_VCR_STATUS_AUDIO_MONITOR __MSABI_LONG(0x0000400A)
#define MCI_VCR_STATUS_AUDIO_MONITOR_NUMBER __MSABI_LONG(0x0000400B)
#define MCI_VCR_STATUS_VIDEO_MONITOR __MSABI_LONG(0x0000400C)
#define MCI_VCR_STATUS_VIDEO_MONITOR_NUMBER __MSABI_LONG(0x0000400D)
#define MCI_VCR_STATUS_INDEX_ON __MSABI_LONG(0x0000400E)
#define MCI_VCR_STATUS_INDEX __MSABI_LONG(0x0000400F)
#define MCI_VCR_STATUS_COUNTER_FORMAT __MSABI_LONG(0x00004010)
#define MCI_VCR_STATUS_COUNTER_RESOLUTION __MSABI_LONG(0x00004011)
#define MCI_VCR_STATUS_TIMECODE_TYPE __MSABI_LONG(0x00004012)
#define MCI_VCR_STATUS_COUNTER_VALUE __MSABI_LONG(0x00004013)
#define MCI_VCR_STATUS_TUNER_CHANNEL __MSABI_LONG(0x00004014)
#define MCI_VCR_STATUS_WRITE_PROTECTED __MSABI_LONG(0x00004015)
#define MCI_VCR_STATUS_TIMECODE_RECORD __MSABI_LONG(0x00004016)
#define MCI_VCR_STATUS_VIDEO_RECORD __MSABI_LONG(0x00004017)
#define MCI_VCR_STATUS_AUDIO_RECORD __MSABI_LONG(0x00004018)
#define MCI_VCR_STATUS_TIME_TYPE __MSABI_LONG(0x00004019)
#define MCI_VCR_STATUS_TIME_MODE __MSABI_LONG(0x0000401A)
#define MCI_VCR_STATUS_POWER_ON __MSABI_LONG(0x0000401B)
#define MCI_VCR_STATUS_CLOCK __MSABI_LONG(0x0000401C)
#define MCI_VCR_STATUS_ASSEMBLE_RECORD __MSABI_LONG(0x0000401D)
#define MCI_VCR_STATUS_TIMECODE_PRESENT __MSABI_LONG(0x0000401E)
#define MCI_VCR_STATUS_NUMBER_OF_VIDEO_TRACKS __MSABI_LONG(0x0000401F)
#define MCI_VCR_STATUS_NUMBER_OF_AUDIO_TRACKS __MSABI_LONG(0x00004020)
#define MCI_VCR_STATUS_CLOCK_ID __MSABI_LONG(0x00004021)
#define MCI_VCR_STATUS_PAUSE_TIMEOUT __MSABI_LONG(0x00004022)
#define MCI_VCR_STATUS_PREROLL_DURATION __MSABI_LONG(0x00004023)
#define MCI_VCR_STATUS_POSTROLL_DURATION __MSABI_LONG(0x00004024)
#define MCI_VCR_STATUS_VIDEO __MSABI_LONG(0x00004025)
#define MCI_VCR_STATUS_AUDIO __MSABI_LONG(0x00004026)

#define MCI_VCR_STATUS_NUMBER __MSABI_LONG(0x00080000)

#define MCI_VCR_ESCAPE_STRING __MSABI_LONG(0x00000100)

#define MCI_VCR_LIST_VIDEO_SOURCE __MSABI_LONG(0x00010000)
#define MCI_VCR_LIST_AUDIO_SOURCE __MSABI_LONG(0x00020000)
#define MCI_VCR_LIST_COUNT __MSABI_LONG(0x00040000)
#define MCI_VCR_LIST_NUMBER __MSABI_LONG(0x00080000)

#define MCI_VCR_MARK_WRITE __MSABI_LONG(0x00010000)
#define MCI_VCR_MARK_ERASE __MSABI_LONG(0x00020000)

#define MCI_VCR_SETAUDIO_RECORD __MSABI_LONG(0x00010000)
#define MCI_VCR_SETAUDIO_SOURCE __MSABI_LONG(0x00020000)
#define MCI_VCR_SETAUDIO_MONITOR __MSABI_LONG(0x00040000)
#define MCI_VCR_SETAUDIO_TO __MSABI_LONG(0x00200000)
#define MCI_VCR_SETAUDIO_NUMBER __MSABI_LONG(0x00400000)

#define MCI_VCR_SETVIDEO_RECORD __MSABI_LONG(0x00010000)
#define MCI_VCR_SETVIDEO_SOURCE __MSABI_LONG(0x00020000)
#define MCI_VCR_SETVIDEO_MONITOR __MSABI_LONG(0x00040000)
#define MCI_VCR_SETVIDEO_TO __MSABI_LONG(0x00100000)
#define MCI_VCR_SETVIDEO_NUMBER __MSABI_LONG(0x00200000)

#define SEND_VCRSIGNAL(dwFlags,dwCallback,hDriver,wDeviceID,dwUser,dwPos) DriverCallback((dwCallback),DCB_WINDOW,(HANDLE)(wDeviceID),MM_MCISIGNAL,hDriver,((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwPos):(dwUser),((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwUser):(dwPos))

#define MM_MCISIGNAL 0x3CB

#define MCI_VCR_SIGNAL_AT __MSABI_LONG(0x00010000)
#define MCI_VCR_SIGNAL_EVERY __MSABI_LONG(0x00020000)
#define MCI_VCR_SIGNAL_USERVAL __MSABI_LONG(0x00040000)
#define MCI_VCR_SIGNAL_CANCEL __MSABI_LONG(0x00080000)
#define MCI_VCR_SIGNAL_POSITION __MSABI_LONG(0x00100000)

#define MCI_VCR_STEP_FRAMES __MSABI_LONG(0x00010000)
#define MCI_VCR_STEP_REVERSE __MSABI_LONG(0x00020000)

#define MCI_VCR_FREEZE_INPUT __MSABI_LONG(0x00010000)
#define MCI_VCR_FREEZE_OUTPUT __MSABI_LONG(0x00020000)
#define MCI_VCR_FREEZE_FIELD __MSABI_LONG(0x00040000)
#define MCI_VCR_FREEZE_FRAME __MSABI_LONG(0x00080000)

#define MCI_VCR_UNFREEZE_INPUT __MSABI_LONG(0x00010000)
#define MCI_VCR_UNFREEZE_OUTPUT __MSABI_LONG(0x00020000)

#define MCI_VCR_MEDIA_8MM (MCI_VCR_OFFSET + 1)
#define MCI_VCR_MEDIA_HI8 (MCI_VCR_OFFSET + 2)
#define MCI_VCR_MEDIA_VHS (MCI_VCR_OFFSET + 3)
#define MCI_VCR_MEDIA_SVHS (MCI_VCR_OFFSET + 4)
#define MCI_VCR_MEDIA_BETA (MCI_VCR_OFFSET + 5)
#define MCI_VCR_MEDIA_EDBETA (MCI_VCR_OFFSET + 6)
#define MCI_VCR_MEDIA_OTHER (MCI_VCR_OFFSET + 7)

#define MCI_VCR_FORMAT_SP (MCI_VCR_OFFSET + 8)
#define MCI_VCR_FORMAT_LP (MCI_VCR_OFFSET + 9)
#define MCI_VCR_FORMAT_EP (MCI_VCR_OFFSET + 10)
#define MCI_VCR_FORMAT_OTHER (MCI_VCR_OFFSET + 11)

#define MCI_VCR_TIME_TIMECODE (MCI_VCR_OFFSET + 12)
#define MCI_VCR_TIME_COUNTER (MCI_VCR_OFFSET + 13)
#define MCI_VCR_TIME_DETECT (MCI_VCR_OFFSET + 14)

#define MCI_VCR_SRC_TYPE_TUNER (MCI_VCR_OFFSET + 15)
#define MCI_VCR_SRC_TYPE_LINE (MCI_VCR_OFFSET + 16)
#define MCI_VCR_SRC_TYPE_SVIDEO (MCI_VCR_OFFSET + 17)
#define MCI_VCR_SRC_TYPE_RGB (MCI_VCR_OFFSET + 18)
#define MCI_VCR_SRC_TYPE_AUX (MCI_VCR_OFFSET + 19)
#define MCI_VCR_SRC_TYPE_GENERIC (MCI_VCR_OFFSET + 20)
#define MCI_VCR_SRC_TYPE_MUTE (MCI_VCR_OFFSET + 21)
#define MCI_VCR_SRC_TYPE_OUTPUT (MCI_VCR_OFFSET + 22)

#define MCI_VCR_INDEX_TIMECODE (MCI_VCR_OFFSET + 23)
#define MCI_VCR_INDEX_COUNTER (MCI_VCR_OFFSET + 24)
#define MCI_VCR_INDEX_DATE (MCI_VCR_OFFSET + 25)
#define MCI_VCR_INDEX_TIME (MCI_VCR_OFFSET + 26)

#define MCI_VCR_COUNTER_RES_SECONDS (MCI_VCR_OFFSET + 27)
#define MCI_VCR_COUNTER_RES_FRAMES (MCI_VCR_OFFSET + 28)

#define MCI_VCR_TIMECODE_TYPE_SMPTE (MCI_VCR_OFFSET + 29)
#define MCI_VCR_TIMECODE_TYPE_SMPTE_DROP (MCI_VCR_OFFSET + 30)
#define MCI_VCR_TIMECODE_TYPE_OTHER (MCI_VCR_OFFSET + 31)
#define MCI_VCR_TIMECODE_TYPE_NONE (MCI_VCR_OFFSET + 32)

#define MCI_VCR_PLUS (MCI_VCR_OFFSET + 33)
#define MCI_VCR_MINUS (MCI_VCR_OFFSET + 34)
#define MCI_VCR_RESET (MCI_VCR_OFFSET + 35)

#ifndef RC_INVOKED

typedef struct tagMCI_VCR_SEEK_PARMS {
  DWORD dwCallback;
  DWORD dwTo;
  DWORD dwMark;
  DWORD dwAt;
} MCI_VCR_SEEK_PARMS;
typedef MCI_VCR_SEEK_PARMS *LPMCI_VCR_SEEK_PARMS;

typedef struct tagMCI_VCR_SET_PARMS {
  DWORD dwCallback;
  DWORD dwTimeFormat;
  DWORD dwAudio;
  DWORD dwTimeMode;
  DWORD dwRecordFormat;
  DWORD dwCounterFormat;
  DWORD dwIndex;
  DWORD dwTracking;
  DWORD dwSpeed;
  DWORD dwLength;
  DWORD dwCounter;
  DWORD dwClock;
  DWORD dwPauseTimeout;
  DWORD dwPrerollDuration;
  DWORD dwPostrollDuration;
} MCI_VCR_SET_PARMS;
typedef MCI_VCR_SET_PARMS *LPMCI_VCR_SET_PARMS;

typedef struct tagMCI_VCR_SETTUNER_PARMS {
  DWORD dwCallback;
  DWORD dwChannel;
  DWORD dwNumber;
} MCI_VCR_SETTUNER_PARMS;
typedef MCI_VCR_SETTUNER_PARMS *LPMCI_VCR_SETTUNER_PARMS;

typedef struct tagMCI_VCR_ESCAPE_PARMS {
  DWORD dwCallback;
  LPCSTR lpstrCommand;
} MCI_VCR_ESCAPE_PARMS;
typedef MCI_VCR_ESCAPE_PARMS *LPMCI_VCR_ESCAPE_PARMS;

typedef struct tagMCI_VCR_LIST_PARMS {
  DWORD dwCallback;
  DWORD dwReturn;
  DWORD dwNumber;
} MCI_VCR_LIST_PARMS;
typedef MCI_VCR_LIST_PARMS *LPMCI_VCR_LIST_PARMS;

typedef struct tagMCI_VCR_RECORD_PARMS {
  DWORD dwCallback;
  DWORD dwFrom;
  DWORD dwTo;
  DWORD dwAt;
} MCI_VCR_RECORD_PARMS;
typedef MCI_VCR_RECORD_PARMS *LPMCI_VCR_RECORD_PARMS;

typedef struct tagMCI_VCR_PLAY_PARMS {
  DWORD dwCallback;
  DWORD dwFrom;
  DWORD dwTo;
  DWORD dwAt;
} MCI_VCR_PLAY_PARMS;
typedef MCI_VCR_PLAY_PARMS *LPMCI_VCR_PLAY_PARMS;

typedef struct tagMCI_VCR_SETAUDIO_PARMS {
  DWORD dwCallback;
  DWORD dwTrack;
  DWORD dwTo;
  DWORD dwNumber;
} MCI_VCR_SETAUDIO_PARMS;
typedef MCI_VCR_SETAUDIO_PARMS *LPMCI_VCR_SETAUDIO_PARMS;

typedef struct tagMCI_VCR_SIGNAL_PARMS {
  DWORD dwCallback;
  DWORD dwPosition;
  DWORD dwPeriod;
  DWORD dwUserParm;
} MCI_VCR_SIGNAL_PARMS;
typedef MCI_VCR_SIGNAL_PARMS *LPMCI_VCR_SIGNAL_PARMS;

typedef struct tagMCI_VCR_STATUS_PARMS {
  DWORD dwCallback;
  DWORD dwReturn;
  DWORD dwItem;
  DWORD dwTrack;
  DWORD dwNumber;
} MCI_VCR_STATUS_PARMS;
typedef MCI_VCR_STATUS_PARMS *LPMCI_VCR_STATUS_PARMS;

typedef struct tagMCI_VCR_SETVIDEO_PARMS {
  DWORD dwCallback;
  DWORD dwTrack;
  DWORD dwTo;
  DWORD dwNumber;
} MCI_VCR_SETVIDEO_PARMS;
typedef MCI_VCR_SETVIDEO_PARMS *LPMCI_VCR_SETVIDEO_PARMS;

typedef struct tagMCI_VCR_STEP_PARMS {
  DWORD dwCallback;
  DWORD dwFrames;
} MCI_VCR_STEP_PARMS;
typedef MCI_VCR_STEP_PARMS *LPMCI_VCR_STEP_PARMS;

typedef struct tagMCI_VCR_CUE_PARMS {
  DWORD dwCallback;
  DWORD dwFrom;
  DWORD dwTo;
} MCI_VCR_CUE_PARMS;
typedef MCI_VCR_CUE_PARMS *LPMCI_VCR_CUE_PARMS;
#endif

#define MCIERR_VCR_CANNOT_OPEN_COMM (MCIERR_CUSTOM_DRIVER_BASE + 1)
#define MCIERR_VCR_CANNOT_WRITE_COMM (MCIERR_CUSTOM_DRIVER_BASE + 2)
#define MCIERR_VCR_READ_TIMEOUT (MCIERR_CUSTOM_DRIVER_BASE + 3)
#define MCIERR_VCR_COMMAND_BUFFER_FULL (MCIERR_CUSTOM_DRIVER_BASE + 4)
#define MCIERR_VCR_COMMAND_CANCELLED (MCIERR_CUSTOM_DRIVER_BASE + 5)
#define MCIERR_VCR_POWER_OFF (MCIERR_CUSTOM_DRIVER_BASE + 6)
#define MCIERR_VCR_COMMAND_FAILED (MCIERR_CUSTOM_DRIVER_BASE + 7)
#define MCIERR_VCR_SEARCH (MCIERR_CUSTOM_DRIVER_BASE + 8)
#define MCIERR_VCR_CONDITION (MCIERR_CUSTOM_DRIVER_BASE + 9)
#define MCIERR_VCR_CAMERA_MODE (MCIERR_CUSTOM_DRIVER_BASE + 10)
#define MCIERR_VCR_VCR_MODE (MCIERR_CUSTOM_DRIVER_BASE + 11)
#define MCIERR_VCR_COUNTER_TYPE (MCIERR_CUSTOM_DRIVER_BASE + 12)
#define MCIERR_VCR_TUNER (MCIERR_CUSTOM_DRIVER_BASE + 13)
#define MCIERR_VCR_EMERGENCY_STOP (MCIERR_CUSTOM_DRIVER_BASE + 14)
#define MCIERR_VCR_MEDIA_UNMOUNTED (MCIERR_CUSTOM_DRIVER_BASE + 15)
#define MCIERR_VCR_REGISTER (MCIERR_CUSTOM_DRIVER_BASE + 16)
#define MCIERR_VCR_TRACK_FAILURE (MCIERR_CUSTOM_DRIVER_BASE + 17)
#define MCIERR_VCR_CUE_FAILED_FLAGS (MCIERR_CUSTOM_DRIVER_BASE + 18)
#define MCIERR_VCR_ISWRITEPROTECTED (MCIERR_CUSTOM_DRIVER_BASE + 19)
#endif
                                                                                                                                                                                                                                                                                                                                                                                                       usr/share/mingw-w64/include/vdmdbg.h                                                                0100644 0000000 0000000 00000025623 12404413016 015761  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _VDMDBG_
#define _VDMDBG_

#ifdef __cplusplus
extern "C" {
#endif

#include <pshpack4.h>

#define STATUS_VDM_EVENT STATUS_SEGMENT_NOTIFICATION

#ifndef DBG_SEGLOAD
#define DBG_SEGLOAD 0
#define DBG_SEGMOVE 1
#define DBG_SEGFREE 2
#define DBG_MODLOAD 3
#define DBG_MODFREE 4
#define DBG_SINGLESTEP 5
#define DBG_BREAK 6
#define DBG_GPFAULT 7
#define DBG_DIVOVERFLOW 8
#define DBG_INSTRFAULT 9
#define DBG_TASKSTART 10
#define DBG_TASKSTOP 11
#define DBG_DLLSTART 12
#define DBG_DLLSTOP 13
#define DBG_ATTACH 14
#define DBG_TOOLHELP 15
#define DBG_STACKFAULT 16
#define DBG_WOWINIT 17
#define DBG_TEMPBP 18
#define DBG_MODMOVE 19
#define DBG_INIT 20
#define DBG_GPFAULT2 21
#endif

#define VDMEVENT_NEEDS_INTERACTIVE 0x8000
#define VDMEVENT_VERBOSE 0x4000
#define VDMEVENT_PE 0x2000
#define VDMEVENT_ALLFLAGS 0xe000

#define VDMEVENT_V86 0x0001
#define VDMEVENT_PM16 0x0002

#define VDMCONTEXT_i386 0x00010000
#define VDMCONTEXT_i486 0x00010000

#define VDMCONTEXT_CONTROL (VDMCONTEXT_i386 | __MSABI_LONG(0x00000001))
#define VDMCONTEXT_INTEGER (VDMCONTEXT_i386 | __MSABI_LONG(0x00000002))
#define VDMCONTEXT_SEGMENTS (VDMCONTEXT_i386 | __MSABI_LONG(0x00000004))
#define VDMCONTEXT_FLOATING_POINT (VDMCONTEXT_i386 | __MSABI_LONG(0x00000008))
#define VDMCONTEXT_DEBUG_REGISTERS (VDMCONTEXT_i386 | __MSABI_LONG(0x00000010))
#define VDMCONTEXT_EXTENDED_REGISTERS (VDMCONTEXT_i386 | __MSABI_LONG(0x00000020))

#define VDMCONTEXT_FULL (VDMCONTEXT_CONTROL | VDMCONTEXT_INTEGER | VDMCONTEXT_SEGMENTS)

#ifdef _X86_

  typedef struct _CONTEXT VDMCONTEXT;
  typedef struct _LDT_ENTRY VDMLDT_ENTRY;
#else

#define SIZE_OF_80387_REGISTERS 80

  typedef struct _FLOATING_SAVE_AREA {
    ULONG ControlWord;
    ULONG StatusWord;
    ULONG TagWord;
    ULONG ErrorOffset;
    ULONG ErrorSelector;
    ULONG DataOffset;
    ULONG DataSelector;
    UCHAR RegisterArea[SIZE_OF_80387_REGISTERS];
    ULONG Cr0NpxState;
  } FLOATING_SAVE_AREA;

  typedef struct _VDMCONTEXT {
    ULONG ContextFlags;

    ULONG Dr0;
    ULONG Dr1;
    ULONG Dr2;
    ULONG Dr3;
    ULONG Dr6;
    ULONG Dr7;

    FLOATING_SAVE_AREA FloatSave;
    ULONG SegGs;
    ULONG SegFs;
    ULONG SegEs;
    ULONG SegDs;
    ULONG Edi;
    ULONG Esi;
    ULONG Ebx;
    ULONG Edx;
    ULONG Ecx;
    ULONG Eax;
    ULONG Ebp;
    ULONG Eip;
    ULONG SegCs;
    ULONG EFlags;
    ULONG Esp;
    ULONG SegSs;
  } VDMCONTEXT;

  typedef struct _VDMLDT_ENTRY {
    USHORT LimitLow;
    USHORT BaseLow;
    union {
      struct {
	UCHAR BaseMid;
	UCHAR Flags1;
	UCHAR Flags2;
	UCHAR BaseHi;
      } Bytes;
      struct {
	ULONG BaseMid : 8;
	ULONG Type : 5;
	ULONG Dpl : 2;
	ULONG Pres : 1;
	ULONG LimitHi : 4;
	ULONG Sys : 1;
	ULONG Reserved_0 : 1;
	ULONG Default_Big : 1;
	ULONG Granularity : 1;
	ULONG BaseHi : 8;
      } Bits;
    } HighWord;
  } VDMLDT_ENTRY;
#endif

  typedef VDMCONTEXT *LPVDMCONTEXT;
  typedef VDMLDT_ENTRY *LPVDMLDT_ENTRY;

#define VDMCONTEXT_TO_PROGRAM_COUNTER(Context) (PVOID)((Context)->Eip)

#define VDMCONTEXT_LENGTH (sizeof(VDMCONTEXT))
#define VDMCONTEXT_ALIGN (sizeof(ULONG))
#define VDMCONTEXT_ROUND (VDMCONTEXT_ALIGN - 1)

#define V86FLAGS_CARRY 0x00001
#define V86FLAGS_PARITY 0x00004
#define V86FLAGS_AUXCARRY 0x00010
#define V86FLAGS_ZERO 0x00040
#define V86FLAGS_SIGN 0x00080
#define V86FLAGS_TRACE 0x00100
#define V86FLAGS_INTERRUPT 0x00200
#define V86FLAGS_DIRECTION 0x00400
#define V86FLAGS_OVERFLOW 0x00800
#define V86FLAGS_IOPL 0x03000
#define V86FLAGS_IOPL_BITS 0x12
#define V86FLAGS_RESUME 0x10000
#define V86FLAGS_V86 0x20000
#define V86FLAGS_ALIGNMENT 0x40000

#define MAX_MODULE_NAME 8 + 1
#define MAX_PATH16 255

  typedef struct _SEGMENT_NOTE {
    WORD Selector1;
    WORD Selector2;
    WORD Segment;
    CHAR Module[MAX_MODULE_NAME+1];
    CHAR FileName[MAX_PATH16+1];
    WORD Type;
    DWORD Length;
  } SEGMENT_NOTE;

  typedef struct _IMAGE_NOTE {
    CHAR Module[MAX_MODULE_NAME+1];
    CHAR FileName[MAX_PATH16+1];
    WORD hModule;
    WORD hTask;
  } IMAGE_NOTE;

  typedef struct {
    DWORD dwSize;
    char szModule[MAX_MODULE_NAME+1];
    HANDLE hModule;
    WORD wcUsage;
    char szExePath[MAX_PATH16+1];
    WORD wNext;
  } MODULEENTRY,*LPMODULEENTRY;

#define SN_CODE 0
#define SN_DATA 1
#define SN_V86 2

  typedef struct _TEMP_BP_NOTE {
    WORD Seg;
    DWORD Offset;
    WINBOOL bPM;
  } TEMP_BP_NOTE;

  typedef struct _VDM_SEGINFO {
    WORD Selector;
    WORD SegNumber;
    DWORD Length;
    WORD Type;
    CHAR ModuleName[MAX_MODULE_NAME];
    CHAR FileName[MAX_PATH16];
  } VDM_SEGINFO;

#define GLOBAL_ALL 0
#define GLOBAL_LRU 1
#define GLOBAL_FREE 2

#define GT_UNKNOWN 0
#define GT_DGROUP 1
#define GT_DATA 2
#define GT_CODE 3
#define GT_TASK 4
#define GT_RESOURCE 5
#define GT_MODULE 6
#define GT_FREE 7
#define GT_INTERNAL 8
#define GT_SENTINEL 9
#define GT_BURGERMASTER 10

#define GD_USERDEFINED 0
#define GD_CURSORCOMPONENT 1
#define GD_BITMAP 2
#define GD_ICONCOMPONENT 3
#define GD_MENU 4
#define GD_DIALOG 5
#define GD_STRING 6
#define GD_FONTDIR 7
#define GD_FONT 8
#define GD_ACCELERATORS 9
#define GD_RCDATA 10
#define GD_ERRTABLE 11
#define GD_CURSOR 12
#define GD_ICON 14
#define GD_NAMETABLE 15
#define GD_MAX_RESOURCE 15

  typedef struct {
    DWORD dwSize;
    DWORD dwAddress;
    DWORD dwBlockSize;
    HANDLE hBlock;
    WORD wcLock;
    WORD wcPageLock;
    WORD wFlags;
    WINBOOL wHeapPresent;
    HANDLE hOwner;
    WORD wType;
    WORD wData;
    DWORD dwNext;
    DWORD dwNextAlt;
  } GLOBALENTRY,*LPGLOBALENTRY;

  typedef DWORD (CALLBACK *DEBUGEVENTPROC)(LPDEBUG_EVENT,LPVOID);

#define W1(x) ((USHORT)(x.ExceptionInformation[0]))
#define W2(x) ((USHORT)(x.ExceptionInformation[0] >> 16))
#define W3(x) ((USHORT)(x.ExceptionInformation[1]))
#define W4(x) ((USHORT)(x.ExceptionInformation[1] >> 16))
#define DW3(x) (x.ExceptionInformation[2])
#define DW4(x) (x.ExceptionInformation[3])

#include <poppack.h>

  WINBOOL WINAPI VDMProcessException(LPDEBUG_EVENT lpDebugEvent);
  WINBOOL WINAPI VDMGetThreadSelectorEntry(HANDLE hProcess,HANDLE hThread,WORD wSelector,LPVDMLDT_ENTRY lpSelectorEntry);
  ULONG WINAPI VDMGetPointer(HANDLE hProcess,HANDLE hThread,WORD wSelector,DWORD dwOffset,WINBOOL fProtMode);
  WINBOOL WINAPI VDMGetContext(HANDLE hProcess,HANDLE hThread,LPVDMCONTEXT lpVDMContext);
  WINBOOL WINAPI VDMSetContext(HANDLE hProcess,HANDLE hThread,LPVDMCONTEXT lpVDMContext);
  WINBOOL WINAPI VDMGetSelectorModule(HANDLE hProcess,HANDLE hThread,WORD wSelector,PUINT lpSegmentNumber,LPSTR lpModuleName,UINT nNameSize,LPSTR lpModulePath,UINT nPathSize);
  WINBOOL WINAPI VDMGetModuleSelector(HANDLE hProcess,HANDLE hThread,UINT wSegmentNumber,LPSTR lpModuleName,LPWORD lpSelector);
  WINBOOL WINAPI VDMModuleFirst(HANDLE hProcess,HANDLE hThread,LPMODULEENTRY lpModuleEntry,DEBUGEVENTPROC lpEventProc,LPVOID lpData);
  WINBOOL WINAPI VDMModuleNext(HANDLE hProcess,HANDLE hThread,LPMODULEENTRY lpModuleEntry,DEBUGEVENTPROC lpEventProc,LPVOID lpData);
  WINBOOL WINAPI VDMGlobalFirst(HANDLE hProcess,HANDLE hThread,LPGLOBALENTRY lpGlobalEntry,WORD wFlags,DEBUGEVENTPROC lpEventProc,LPVOID lpData);
  WINBOOL WINAPI VDMGlobalNext(HANDLE hProcess,HANDLE hThread,LPGLOBALENTRY lpGlobalEntry,WORD wFlags,DEBUGEVENTPROC lpEventProc,LPVOID lpData);

  typedef WINBOOL (WINAPI *PROCESSENUMPROC)(DWORD dwProcessId,DWORD dwAttributes,LPARAM lpUserDefined);
  typedef WINBOOL (WINAPI *TASKENUMPROC)(DWORD dwThreadId,WORD hMod16,WORD hTask16,LPARAM lpUserDefined);
  typedef WINBOOL (WINAPI *TASKENUMPROCEX)(DWORD dwThreadId,WORD hMod16,WORD hTask16,PSZ pszModName,PSZ pszFileName,LPARAM lpUserDefined);

#define WOW_SYSTEM (DWORD)0x0001

  INT WINAPI VDMEnumProcessWOW(PROCESSENUMPROC fp,LPARAM lparam);
  INT WINAPI VDMEnumTaskWOW(DWORD dwProcessId,TASKENUMPROC fp,LPARAM lparam);
  INT WINAPI VDMEnumTaskWOWEx(DWORD dwProcessId,TASKENUMPROCEX fp,LPARAM lparam);
  WINBOOL WINAPI VDMTerminateTaskWOW(DWORD dwProcessId,WORD htask);
  WINBOOL WINAPI VDMStartTaskInWOW(DWORD dwProcessId,LPSTR lpCommandLine,WORD wShow);
  WINBOOL WINAPI VDMKillWOW(VOID);
  WINBOOL WINAPI VDMDetectWOW(VOID);
  WINBOOL WINAPI VDMBreakThread(HANDLE hProcess,HANDLE hThread);
  DWORD WINAPI VDMGetDbgFlags(HANDLE hProcess);
  WINBOOL WINAPI VDMSetDbgFlags(HANDLE hProcess,DWORD dwFlags);

#define VDMDBG_BREAK_DOSTASK 0x00000001
#define VDMDBG_BREAK_WOWTASK 0x00000002
#define VDMDBG_BREAK_LOADDLL 0x00000004
#define VDMDBG_BREAK_EXCEPTIONS 0x00000008
#define VDMDBG_BREAK_DEBUGGER 0x00000010
#define VDMDBG_TRACE_HISTORY 0x00000080

  WINBOOL WINAPI VDMIsModuleLoaded(LPSTR szPath);
  WINBOOL WINAPI VDMGetSegmentInfo(WORD Selector,ULONG Offset,WINBOOL bProtectMode,VDM_SEGINFO *pSegInfo);
  WINBOOL WINAPI VDMGetSymbol(LPSTR szModule,WORD SegNumber,DWORD Offset,WINBOOL bProtectMode,WINBOOL bNextSymbol,LPSTR szSymbolName,PDWORD pDisplacement);
  WINBOOL WINAPI VDMGetAddrExpression(LPSTR szModule,LPSTR szSymbol,PWORD Selector,PDWORD Offset,PWORD Type);

#define VDMADDR_V86 2
#define VDMADDR_PM16 4
#define VDMADDR_PM32 16

  typedef WINBOOL (WINAPI *VDMPROCESSEXCEPTIONPROC)(LPDEBUG_EVENT);
  typedef WINBOOL (WINAPI *VDMGETTHREADSELECTORENTRYPROC)(HANDLE,HANDLE,DWORD,LPVDMLDT_ENTRY);
  typedef ULONG (WINAPI *VDMGETPOINTERPROC)(HANDLE,HANDLE,WORD,DWORD,WINBOOL);
  typedef WINBOOL (WINAPI *VDMGETCONTEXTPROC)(HANDLE,HANDLE,LPVDMCONTEXT);
  typedef WINBOOL (WINAPI *VDMSETCONTEXTPROC)(HANDLE,HANDLE,LPVDMCONTEXT);
  typedef WINBOOL (WINAPI *VDMKILLWOWPROC)(VOID);
  typedef WINBOOL (WINAPI *VDMDETECTWOWPROC)(VOID);
  typedef WINBOOL (WINAPI *VDMBREAKTHREADPROC)(HANDLE);
  typedef WINBOOL (WINAPI *VDMGETSELECTORMODULEPROC)(HANDLE,HANDLE,WORD,PUINT,LPSTR,UINT,LPSTR,UINT);
  typedef WINBOOL (WINAPI *VDMGETMODULESELECTORPROC)(HANDLE,HANDLE,UINT,LPSTR,LPWORD);
  typedef WINBOOL (WINAPI *VDMMODULEFIRSTPROC)(HANDLE,HANDLE,LPMODULEENTRY,DEBUGEVENTPROC,LPVOID);
  typedef WINBOOL (WINAPI *VDMMODULENEXTPROC)(HANDLE,HANDLE,LPMODULEENTRY,DEBUGEVENTPROC,LPVOID);
  typedef WINBOOL (WINAPI *VDMGLOBALFIRSTPROC)(HANDLE,HANDLE,LPGLOBALENTRY,WORD,DEBUGEVENTPROC,LPVOID);
  typedef WINBOOL (WINAPI *VDMGLOBALNEXTPROC)(HANDLE,HANDLE,LPGLOBALENTRY,WORD,DEBUGEVENTPROC,LPVOID);
  typedef INT (WINAPI *VDMENUMPROCESSWOWPROC)(PROCESSENUMPROC,LPARAM);
  typedef INT (WINAPI *VDMENUMTASKWOWPROC)(DWORD,TASKENUMPROC,LPARAM);
  typedef INT (WINAPI *VDMENUMTASKWOWEXPROC)(DWORD,TASKENUMPROCEX,LPARAM);
  typedef WINBOOL (WINAPI *VDMTERMINATETASKINWOWPROC)(DWORD,WORD);
  typedef WINBOOL (WINAPI *VDMSTARTTASKINWOWPROC)(DWORD,LPSTR,WORD);
  typedef DWORD (WINAPI *VDMGETDBGFLAGSPROC)(HANDLE);
  typedef WINBOOL (WINAPI *VDMSETDBGFLAGSPROC)(HANDLE,DWORD);
  typedef WINBOOL (WINAPI *VDMISMODULELOADEDPROC)(LPSTR);
  typedef WINBOOL (WINAPI *VDMGETSEGMENTINFOPROC)(WORD,ULONG,WINBOOL,VDM_SEGINFO);
  typedef WINBOOL (WINAPI *VDMGETSYMBOLPROC)(LPSTR,WORD,DWORD,WINBOOL,WINBOOL,LPSTR,PDWORD);
  typedef WINBOOL (WINAPI *VDMGETADDREXPRESSIONPROC)(LPSTR,LPSTR,PWORD,PDWORD,PWORD);

#ifdef __cplusplus
}
#endif
#endif
                                                                                                             usr/share/mingw-w64/include/vds.h                                                                   0100644 0000000 0000000 00000141561 12404413016 015312  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_VDS
#define _INC_VDS

#if (_WIN32_WINNT >= 0x0600)
#include <diskguid.h>
#include <winioctl.h>

#ifdef __cplusplus
extern "C" {
#endif

#define GPT_PARTITION_NAME_LENGTH 36

  typedef GUID VDS_OBJECT_ID;
  typedef UINT64 VDS_PATH_ID;

  typedef enum _VDS_PARTITION_STYLE {
    VDS_PST_UNKNOWN   = 0,
    VDS_PST_MBR       = 1,
    VDS_PST_GPT       = 2 
  } VDS_PARTITION_STYLE;

  typedef enum tag_VDS_PARTITION_STYLE {
    VDS_PARTITION_STYLE_MBR,
    VDS_PARTITION_STYLE_GPT,
    VDS_PARTITION_STYLE_RAW 
  } __VDS_PARTITION_STYLE;

  typedef enum _VDS_ASYNC_OUTPUT_TYPE {
    VDS_ASYNCOUT_UNKNOWN             = 0,
    VDS_ASYNCOUT_CREATEVOLUME        = 1,
    VDS_ASYNCOUT_EXTENDVOLUME        = 2,
    VDS_ASYNCOUT_SHRINKVOLUME        = 3,
    VDS_ASYNCOUT_ADDVOLUMEPLEX       = 4,
    VDS_ASYNCOUT_BREAKVOLUMEPLEX     = 5,
    VDS_ASYNCOUT_REMOVEVOLUMEPLEX    = 6,
    VDS_ASYNCOUT_REPAIRVOLUMEPLEX    = 7,
    VDS_ASYNCOUT_RECOVERPACK         = 8,
    VDS_ASYNCOUT_REPLACEDISK         = 9,
    VDS_ASYNCOUT_CREATEPARTITION     = 10,
    VDS_ASYNCOUT_CLEAN               = 11,
    VDS_ASYNCOUT_CREATELUN           = 50,
    VDS_ASYNCOUT_ADDLUNPLEX          = 52,
    VDS_ASYNCOUT_REMOVELUNPLEX       = 53,
    VDS_ASYNCOUT_EXTENDLUN           = 54,
    VDS_ASYNCOUT_SHRINKLUN           = 55,
    VDS_ASYNCOUT_RECOVERLUN          = 56,
    VDS_ASYNCOUT_LOGINTOTARGET       = 60,
    VDS_ASYNCOUT_LOGOUTFROMTARGET    = 61,
    VDS_ASYNCOUT_CREATETARGET        = 62,
    VDS_ASYNCOUT_CREATEPORTALGROUP   = 63,
    VDS_ASYNCOUT_DELETETARGET        = 64,
    VDS_ASYNCOUT_ADDPORTAL           = 65,
    VDS_ASYNCOUT_REMOVEPORTAL        = 66,
    VDS_ASYNCOUT_DELETEPORTALGROUP   = 67,
    VDS_ASYNCOUT_FORMAT              = 101,
    VDS_ASYNCOUT_CREATE_VDISK        = 200,
    VDS_ASYNCOUT_ATTACH_VDISK        = 201,
    VDS_ASYNCOUT_COMPACT_VDISK       = 202,
    VDS_ASYNCOUT_MERGE_VDISK         = 203,
    VDS_ASYNCOUT_EXPAND_VDISK        = 204 
  } VDS_ASYNC_OUTPUT_TYPE;

  typedef enum _VDS_HEALTH {
    VDS_H_UNKNOWN                     = 0,
    VDS_H_HEALTHY                     = 1,
    VDS_H_REBUILDING                  = 2,
    VDS_H_STALE                       = 3,
    VDS_H_FAILING                     = 4,
    VDS_H_FAILING_REDUNDANCY          = 5,
    VDS_H_FAILED_REDUNDANCY           = 6,
    VDS_H_FAILED_REDUNDANCY_FAILING   = 7,
    VDS_H_FAILED                      = 8,
    VDS_H_REPLACED                    = 9,
    VDS_H_PENDING_FAILURE             = 10,
    VDS_H_DEGRADED                    = 11 
  } VDS_HEALTH;

  typedef enum _VDS_CONTROLLER_STATUS {
    VDS_CS_UNKNOWN     = 0,
    VDS_CS_ONLINE      = 1,
    VDS_CS_NOT_READY   = 2,
    VDS_CS_OFFLINE     = 4,
    VDS_CS_FAILED      = 5,
    VDS_CS_REMOVED     = 8 
  } VDS_CONTROLLER_STATUS;

  typedef enum _VDS_DISK_EXTENT_TYPE {
    VDS_DET_UNKNOWN    = 0,
    VDS_DET_FREE       = 1,
    VDS_DET_DATA       = 2,
    VDS_DET_OEM        = 3,
    VDS_DET_ESP        = 4,
    VDS_DET_MSR        = 5,
    VDS_DET_LDM        = 6,
    VDS_DET_CLUSTER    = 7,
    VDS_DET_UNUSABLE   = 0x7FFF 
  } VDS_DISK_EXTENT_TYPE;

  typedef enum _VDS_DISK_FLAG {
    VDS_DF_AUDIO_CD               = 0x1,
    VDS_DF_HOTSPARE               = 0x2,
    VDS_DF_RESERVE_CAPABLE        = 0x4,
    VDS_DF_MASKED                 = 0x8,
    VDS_DF_STYLE_CONVERTIBLE      = 0x10,
    VDS_DF_CLUSTERED              = 0x20,
    VDS_DF_READ_ONLY              = 0x40,
    VDS_DF_SYSTEM_DISK            = 0x80,
    VDS_DF_BOOT_DISK              = 0x100,
    VDS_DF_PAGEFILE_DISK          = 0x200,
    VDS_DF_HIBERNATIONFILE_DISK   = 0x400,
    VDS_DF_CRASHDUMP_DISK         = 0x800,
    VDS_DF_HAS_ARC_PATH           = 0x1000,
    VDS_DF_DYNAMIC                = 0x2000,
    VDS_DF_BOOT_FROM_DISK         = 0x4000,
    VDS_DF_CURRENT_READ_ONLY      = 0x8000 
  } VDS_DISK_FLAG;

  typedef enum _VDS_NOTIFICATION_TARGET_TYPE {
    VDS_NTT_UNKNOWN        = 0,
    VDS_NTT_PACK           = 10,
    VDS_NTT_VOLUME         = 11,
    VDS_NTT_DISK           = 13,
    VDS_NTT_PARTITION      = 60,
    VDS_NTT_DRIVE_LETTER   = 61,
    VDS_NTT_FILE_SYSTEM    = 62,
    VDS_NTT_MOUNT_POINT    = 63,
    VDS_NTT_SUB_SYSTEM     = 30,
    VDS_NTT_CONTROLLER     = 31,
    VDS_NTT_DRIVE          = 32,
    VDS_NTT_LUN            = 33,
    VDS_NTT_PORT           = 35,
    VDS_NTT_PORTAL         = 36,
    VDS_NTT_TARGET         = 37,
    VDS_NTT_PORTAL_GROUP   = 38,
    VDS_NTT_SERVICE        = 200 
  } VDS_NOTIFICATION_TARGET_TYPE;

  typedef enum _VDS_OBJECT_TYPE {
    VDS_OT_UNKNOWN        = 0,
    VDS_OT_PROVIDER       = 1,
    VDS_OT_PACK           = 10,
    VDS_OT_VOLUME         = 11,
    VDS_OT_VOLUME_PLEX    = 12,
    VDS_OT_DISK           = 13,
    VDS_OT_SUB_SYSTEM     = 30,
    VDS_OT_CONTROLLER     = 31,
    VDS_OT_DRIVE          = 32,
    VDS_OT_LUN            = 33,
    VDS_OT_LUN_PLEX       = 34,
    VDS_OT_PORT           = 35,
    VDS_OT_PORTAL         = 36,
    VDS_OT_TARGET         = 37,
    VDS_OT_PORTAL_GROUP   = 38,
    VDS_OT_STORAGE_POOL   = 39,
    VDS_OT_HBAPORT        = 90,
    VDS_OT_INIT_ADAPTER   = 91,
    VDS_OT_INIT_PORTAL    = 92,
    VDS_OT_ASYNC          = 100,
    VDS_OT_ENUM           = 101,
    VDS_OT_VDISK          = 200,
    VDS_OT_OPEN_VDISK     = 201 
  } VDS_OBJECT_TYPE;

  typedef enum _VDS_STORAGE_BUS_TYPE {
    VDSBusTypeUnknown = 0x00,
    VDSBusTypeScsi = 0x01,
    VDSBusTypeAtapi = 0x02,
    VDSBusTypeAta = 0x03,
    VDSBusType1394 = 0x04,
    VDSBusTypeSsa = 0x05,
    VDSBusTypeFibre = 0x06,
    VDSBusTypeUsb = 0x07,
    VDSBusTypeRAID = 0x08,
    VDSBusTypeiScsi = 0x09,
    VDSBusTypeMaxReserved = 0x7F
  } VDS_STORAGE_BUS_TYPE;

  typedef enum _VDS_DISK_STATUS {
    VDS_DS_UNKNOWN     = 0,
    VDS_DS_ONLINE      = 1,
    VDS_DS_NOT_READY   = 2,
    VDS_DS_NO_MEDIA    = 3,
    VDS_DS_OFFLINE     = 4,
    VDS_DS_FAILED      = 5,
    VDS_DS_MISSING     = 6 
  } VDS_DISK_STATUS;

  typedef enum _VDS_DRIVE_FLAG {
    VDS_DRF_HOTSPARE           = 0x1,
    VDS_DRF_ASSIGNED           = 0x2,
    VDS_DRF_UNASSIGNED         = 0x4,
    VDS_DRF_HOTSPARE_IN_USE    = 0x8,
    VDS_DRF_HOTSPARE_STANDBY   = 0x10 
  } VDS_DRIVE_FLAG;

  typedef enum _VDS_DRIVE_LETTER_FLAG {
    VDS_DLF_NON_PERSISTENT   = 0x1 
  } VDS_DRIVE_LETTER_FLAG;

  typedef enum _VDS_DRIVE_STATUS {
    VDS_DRS_UNKNOWN     = 0,
    VDS_DRS_ONLINE      = 1,
    VDS_DRS_NOT_READY   = 2,
    VDS_DRS_OFFLINE     = 4,
    VDS_DRS_FAILED      = 5,
    VDS_DRS_REMOVED     = 8 
  } VDS_DRIVE_STATUS;

  typedef enum _VDS_FILE_SYSTEM_FLAG {
    VDS_FSF_SUPPORT_FORMAT            = 0x1,
    VDS_FSF_SUPPORT_QUICK_FORMAT      = 0x2,
    VDS_FSF_SUPPORT_COMPRESS          = 0x4,
    VDS_FSF_SUPPORT_SPECIFY_LABEL     = 0x8,
    VDS_FSF_SUPPORT_MOUNT_POINT       = 0x10,
    VDS_FSF_SUPPORT_REMOVABLE_MEDIA   = 0x20,
    VDS_FSF_SUPPORT_EXTEND            = 0x40,
    VDS_FSF_ALLOCATION_UNIT_512       = 0x10000,
    VDS_FSF_ALLOCATION_UNIT_1K        = 0x20000,
    VDS_FSF_ALLOCATION_UNIT_2K        = 0x40000,
    VDS_FSF_ALLOCATION_UNIT_4K        = 0x80000,
    VDS_FSF_ALLOCATION_UNIT_8K        = 0x100000,
    VDS_FSF_ALLOCATION_UNIT_16K       = 0x200000,
    VDS_FSF_ALLOCATION_UNIT_32K       = 0x400000,
    VDS_FSF_ALLOCATION_UNIT_64K       = 0x800000,
    VDS_FSF_ALLOCATION_UNIT_128K      = 0x1000000,
    VDS_FSF_ALLOCATION_UNIT_256K      = 0x2000000 
  } VDS_FILE_SYSTEM_FLAG;

  typedef enum _VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG {
    VDS_FSS_DEFAULT             = 0x00000001,
    VDS_FSS_PREVIOUS_REVISION   = 0x00000002,
    VDS_FSS_RECOMMENDED         = 0x00000004 
  } VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG;

  typedef enum _VDS_FILE_SYSTEM_PROP_FLAG {
    VDS_FPF_COMPRESSED   = 0x1 
  } VDS_FILE_SYSTEM_PROP_FLAG;

  typedef enum _VDS_FILE_SYSTEM_TYPE {
    VDS_FST_UNKNOWN   = 0,
    VDS_FST_RAW       = 1,
    VDS_FST_FAT       = 2,
    VDS_FST_FAT32     = 3,
    VDS_FST_NTFS      = 4,
    VDS_FST_CDFS      = 5,
    VDS_FST_UDF       = 6,
    VDS_FST_EXFAT     = 7 
  } VDS_FILE_SYSTEM_TYPE;

  typedef enum _VDS_HBAPORT_SPEED_FLAG {
    VDS_HSF_UNKNOWN          = 0,
    VDS_HSF_1GBIT            = 0x1,
    VDS_HSF_2GBIT            = 0x2,
    VDS_HSF_10GBIT           = 0x4,
    VDS_HSF_4GBIT            = 0x8,
    VDS_HSF_NOT_NEGOTIATED   = 0x8000 
  } VDS_HBAPORT_SPEED_FLAG;

  typedef enum _VDS_HBAPORT_STATUS {
    VDS_HPS_UNKNOWN       = 1,
    VDS_HPS_ONLINE        = 2,
    VDS_HPS_OFFLINE       = 3,
    VDS_HPS_BYPASSED      = 4,
    VDS_HPS_DIAGNOSTICS   = 5,
    VDS_HPS_LINKDOWN      = 6,
    VDS_HPS_ERROR         = 7,
    VDS_HPS_LOOPBACK      = 8 
  } VDS_HBAPORT_STATUS;

  typedef enum _VDS_HBAPORT_TYPE {
    VDS_HPT_UNKNOWN      = 1,
    VDS_HPT_OTHER        = 2,
    VDS_HPT_NOTPRESENT   = 3,
    VDS_HPT_NPORT        = 5,
    VDS_HPT_NLPORT       = 6,
    VDS_HPT_FLPORT       = 7,
    VDS_HPT_FPORT        = 8,
    VDS_HPT_EPORT        = 9,
    VDS_HPT_GPORT        = 10,
    VDS_HPT_LPORT        = 20,
    VDS_HPT_PTP          = 21 
  } VDS_HBAPORT_TYPE;

  typedef enum _VDS_HWPROVIDER_TYPE {
    VDS_HWT_UNKNOWN         = 0,
    VDS_HWT_PCI_RAID        = 1,
    VDS_HWT_FIBRE_CHANNEL   = 2,
    VDS_HWT_ISCSI           = 3,
    VDS_HWT_SAS             = 4,
    VDS_HWT_HYBRID          = 5 
  } VDS_HWPROVIDER_TYPE;

  typedef enum _VDS_INTERCONNECT_ADDRESS_TYPE {
    VDS_IA_UNKNOWN = 0,
    VDS_IA_FCFS = 1,
    VDS_IA_FCPH = 2,
    VDS_IA_FCPH3 = 3,
    VDS_IA_MAC = 4,
    VDS_IA_SCSI = 5
  } VDS_INTERCONNECT_ADDRESS_TYPE;

  typedef enum VDS_IPADDRESS_TYPE {
    VDS_IPT_TEXT    = 0,
    VDS_IPT_IPV4    = 1,
    VDS_IPT_IPV6    = 2,
    VDS_IPT_EMPTY   = 3 
  } VDS_IPADDRESS_TYPE;

  typedef enum _VDS_ISCSI_AUTH_TYPE {
    VDS_IAT_NONE          = 0,
    VDS_IAT_CHAP          = 1,
    VDS_IAT_MUTUAL_CHAP   = 2 
  } VDS_ISCSI_AUTH_TYPE;

  typedef enum _VDS_ISCSI_LOGIN_FLAG {
    VDS_ILF_REQUIRE_IPSEC       = 0x1,
    VDS_ILF_MULTIPATH_ENABLED   = 0x2 
  } VDS_ISCSI_LOGIN_FLAG;

  typedef enum _VDS_ISCSI_LOGIN_TYPE {
    VDS_ILT_MANUAL       = 0,
    VDS_ILT_PERSISTENT   = 1,
    VDS_ILT_BOOT         = 2 
  } VDS_ISCSI_LOGIN_TYPE;

  typedef enum _VDS_ISCSI_PORTAL_STATUS {
    VDS_IPS_UNKNOWN     = 0,
    VDS_IPS_ONLINE      = 1,
    VDS_IPS_NOT_READY   = 2,
    VDS_IPS_OFFLINE     = 4,
    VDS_IPS_FAILED      = 5 
  } VDS_ISCSI_PORTAL_STATUS;

  typedef enum _VDS_LOADBALANCE_POLICY_ENUM {
    VDS_LBP_UNKNOWN                   = 0,
    VDS_LBP_FAILOVER                  = 1,
    VDS_LBP_ROUND_ROBIN               = 2,
    VDS_LBP_ROUND_ROBIN_WITH_SUBSET   = 3,
    VDS_LBP_DYN_LEAST_QUEUE_DEPTH     = 4,
    VDS_LBP_WEIGHTED_PATHS            = 5,
    VDS_LBP_LEAST_BLOCKS              = 6,
    VDS_LBP_VENDOR_SPECIFIC           = 7 
  } VDS_LOADBALANCE_POLICY_ENUM;

  typedef enum _VDS_LUN_FLAG {
    VDS_LF_LBN_REMAP_ENABLED               = 0x01,
    VDS_LF_READ_BACK_VERIFY_ENABLED        = 0x02,
    VDS_LF_WRITE_THROUGH_CACHING_ENABLED   = 0x04,
    VDS_LF_HARDWARE_CHECKSUM_ENABLED       = 0x08,
    VDS_LF_READ_CACHE_ENABLED              = 0x10,
    VDS_LF_WRITE_CACHE_ENABLED             = 0x20,
    VDS_LF_MEDIA_SCAN_ENABLED              = 0x40,
    VDS_LF_CONSISTENCY_CHECK_ENABLED       = 0x80,
    VDS_LF_SNAPSHOT                        = 0x100 
  } VDS_LUN_FLAG;

  typedef enum _VDS_LUN_PLEX_FLAG  {
    VDS_LPF_LBN_REMAP_ENABLED   = 0x1 
  } VDS_LUN_PLEX_FLAG;

  typedef enum _VDS_TRANSITION_STATE {
    VDS_TS_UNKNOWN       = 0,
    VDS_TS_STABLE        = 1,
    VDS_TS_EXTENDING     = 2,
    VDS_TS_SHRINKING     = 3,
    VDS_TS_RECONFIGING   = 4,
    VDS_TS_RESTRIPING    = 8 
  } VDS_TRANSITION_STATE;

  typedef enum _VDS_LUN_PLEX_STATUS {
    VDS_LPS_UNKNOWN     = 0,
    VDS_LPS_ONLINE      = 1,
    VDS_LPS_NOT_READY   = 2,
    VDS_LPS_OFFLINE     = 4,
    VDS_LPS_FAILED      = 5 
  } VDS_LUN_PLEX_STATUS;

  typedef enum _VDS_LUN_PLEX_TYPE {
    VDS_LPT_UNKNOWN   = 0,
    VDS_LPT_SIMPLE    = 10,
    VDS_LPT_SPAN      = 11,
    VDS_LPT_STRIPE    = 12,
    VDS_LPT_PARITY    = 14,
    VDS_LPT_RAID2     = 15,
    VDS_LPT_RAID3     = 16,
    VDS_LPT_RAID4     = 17,
    VDS_LPT_RAID5     = 18,
    VDS_LPT_RAID6     = 19,
    VDS_LPT_RAID03    = 21,
    VDS_LPT_RAID05    = 22,
    VDS_LPT_RAID10    = 23,
    VDS_LPT_RAID15    = 24,
    VDS_LPT_RAID30    = 25,
    VDS_LPT_RAID50    = 26,
    VDS_LPT_RAID53    = 28,
    VDS_LPT_RAID60    = 29 
  } VDS_LUN_PLEX_TYPE;

  typedef enum _VDS_LUN_STATUS {
    VDS_LS_UNKNOWN     = 0,
    VDS_LS_ONLINE      = 1,
    VDS_LS_NOT_READY   = 2,
    VDS_LS_OFFLINE     = 4,
    VDS_LS_FAILED      = 5 
  } VDS_LUN_STATUS;

  typedef enum _VDS_LUN_TYPE {
    VDS_LT_UNKNOWN              = 0,
    VDS_LT_DEFAULT              = 1,
    VDS_LT_FAULT_TOLERANT       = 2,
    VDS_LT_NON_FAULT_TOLERANT   = 3,
    VDS_LT_SIMPLE               = 10,
    VDS_LT_SPAN                 = 11,
    VDS_LT_STRIPE               = 12,
    VDS_LT_MIRROR               = 13,
    VDS_LT_PARITY               = 14,
    VDS_LT_RAID2                = 15,
    VDS_LT_RAID3                = 16,
    VDS_LT_RAID4                = 17,
    VDS_LT_RAID5                = 18,
    VDS_LT_RAID6                = 19,
    VDS_LT_RAID01               = 20,
    VDS_LT_RAID03               = 21,
    VDS_LT_RAID05               = 22,
    VDS_LT_RAID10               = 23,
    VDS_LT_RAID15               = 24,
    VDS_LT_RAID30               = 25,
    VDS_LT_RAID50               = 26,
    VDS_LT_RAID51               = 27,
    VDS_LT_RAID53               = 28,
    VDS_LT_RAID60               = 29,
    VDS_LT_RAID61               = 30 
  } VDS_LUN_TYPE;

  typedef enum _VDS_MAINTENANCE_OPERATION {
    BlinkLight   = 1,
    BeepAlarm    = 2,
    SpinDown     = 3,
    SpinUp       = 4,
    Ping         = 5 
  } VDS_MAINTENANCE_OPERATION;

  typedef enum _VDS_PACK_FLAG {
    VDS_PKF_FOREIGN        = 0x1,
    VDS_PKF_NOQUORUM       = 0x2,
    VDS_PKF_POLICY         = 0x4,
    VDS_PKF_CORRUPTED      = 0x8,
    VDS_PKF_ONLINE_ERROR   = 0x10 
  } VDS_PACK_FLAG;

  typedef enum _VDS_PACK_STATUS {
    VDS_PS_UNKNOWN   = 0,
    VDS_PS_ONLINE    = 1,
    VDS_PS_OFFLINE   = 4 
  } VDS_PACK_STATUS;

  typedef enum _VDS_PARTITION_FLAG {
    VDS_PTF_SYSTEM   = 0x1 
  } VDS_PARTITION_FLAG;

  typedef enum _VDS_PATH_STATUS {
    VDS_MPS_UNKNOWN   = 0,
    VDS_MPS_ONLINE    = 1,
    VDS_MPS_FAILED    = 5,
    VDS_MPS_STANDBY   = 7 
  } VDS_PATH_STATUS;

  typedef enum _VDS_PORT_STATUS {
    VDS_PRS_UNKNOWN     = 0,
    VDS_PRS_ONLINE      = 1,
    VDS_PRS_NOT_READY   = 2,
    VDS_PRS_OFFLINE     = 4,
    VDS_PRS_FAILED      = 5,
    VDS_PRS_REMOVED     = 8 
  } VDS_PORT_STATUS;

  typedef enum _VDS_PROVIDER_FLAG {
    VDS_PF_DYNAMIC                           = 0x00000001,
    VDS_PF_INTERNAL_HARDWARE_PROVIDER        = 0x00000002,
    VDS_PF_ONE_DISK_ONLY_PER_PACK            = 0x00000004,
    VDS_PF_ONE_PACK_ONLINE_ONLY              = 0x00000008,
    VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS   = 0x00000010,
    VDS_PF_SUPPORT_DYNAMIC                   = 0x80000000,
    VDS_PF_SUPPORT_FAULT_TOLERANT            = 0x40000000,
    VDS_PF_SUPPORT_DYNAMIC_1394              = 0x20000000,
    VDS_PF_SUPPORT_MIRROR                    = 0x00000020,
    VDS_PF_SUPPORT_RAID5                     = 0x00000040 
  } VDS_PROVIDER_FLAG;

  typedef enum _VDS_PROVIDER_LBSUPPORT_FLAG {
    VDS_LBF_FAILOVER                  = 0x1,
    VDS_LBF_ROUND_ROBIN               = 0x2,
    VDS_LBF_ROUND_ROBIN_WITH_SUBSET   = 0x4,
    VDS_LBF_DYN_LEAST_QUEUE_DEPTH     = 0x8,
    VDS_LBF_WEIGHTED_PATHS            = 0x10,
    VDS_LBF_LEAST_BLOCKS              = 0x20,
    VDS_LBF_VENDOR_SPECIFIC           = 0x40 
  } VDS_PROVIDER_LBSUPPORT_FLAG;

  typedef enum _VDS_PROVIDER_TYPE {
    VDS_PT_UNKNOWN       = 0,
    VDS_PT_SOFTWARE      = 1,
    VDS_PT_HARDWARE      = 2,
    VDS_PT_VIRTUALDISK   = 3,
    VDS_PT_MAX           = 4 
  } VDS_PROVIDER_TYPE;

  typedef enum _VDS_QUERY_PROVIDER_FLAG {
    VDS_QUERY_SOFTWARE_PROVIDERS   = 0x1,
    VDS_QUERY_HARDWARE_PROVIDERS   = 0x2 
  } VDS_QUERY_PROVIDER_FLAG;

  typedef enum _VDS_SAN_POLICY {
    VDS_SP_UNKNOWN          = 0x0,
    VDS_SP_ONLINE           = 0x1,
    VDS_SP_OFFLINE_SHARED   = 0x2,
    VDS_SP_OFFLINE          = 0x3 
  } VDS_SAN_POLICY;

  typedef enum _VDS_SERVICE_FLAG {
    VDS_SVF_SUPPORT_DYNAMIC              = 0x1,
    VDS_SVF_SUPPORT_FAULT_TOLERANT       = 0x2,
    VDS_SVF_SUPPORT_GPT                  = 0x4,
    VDS_SVF_SUPPORT_DYNAMIC_1394         = 0x8,
    VDS_SVF_CLUSTER_SERVICE_CONFIGURED   = 0x10,
    VDS_SVF_AUTO_MOUNT_OFF               = 0x20,
    VDS_SVF_OS_UNINSTALL_VALID           = 0x40,
    VDS_SVF_EFI                          = 0x80,
    VDS_SVF_SUPPORT_MIRROR               = 0x100,
    VDS_SVF_SUPPORT_RAID5                = 0x200 
  } VDS_SERVICE_FLAG;

  typedef enum _VDS_STORAGE_IDENTIFIER_CODE_SET {
    VDSStorageIdCodeSetReserved = 0,
    VDSStorageIdCodeSetBinary = 1,
    VDSStorageIdCodeSetAscii = 2
  } VDS_STORAGE_IDENTIFIER_CODE_SET;

  typedef enum VDS_STORAGE_IDENTIFIER_TYPE {
    VDSStorageIdTypeVendorSpecific = 0,
    VDSStorageIdTypeVendorId = 1,
    VDSStorageIdTypeEUI64 = 2,
    VDSStorageIdTypeFCPHName = 3,
    VDSStorageIdTypeSCSINameString = 8
  } VDS_STORAGE_IDENTIFIER_TYPE;

  typedef enum _VDS_SUB_SYSTEM_FLAG {
    VDS_SF_LUN_MASKING_CAPABLE                = 0x1,
    VDS_SF_LUN_PLEXING_CAPABLE                = 0x2,
    VDS_SF_LUN_REMAPPING_CAPABLE              = 0x4,
    VDS_SF_DRIVE_EXTENT_CAPABLE               = 0x8,
    VDS_SF_HARDWARE_CHECKSUM_CAPABLE          = 0x10,
    VDS_SF_RADIUS_CAPABLE                     = 0x20,
    VDS_SF_READ_BACK_VERIFY_CAPABLE           = 0x40,
    VDS_SF_WRITE_THROUGH_CACHING_CAPABLE      = 0x80,
    VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS       = 0x200,
    VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS   = 0x400,
    VDS_SF_SUPPORTS_SIMPLE_LUNS               = 0x800,
    VDS_SF_SUPPORTS_SPAN_LUNS                 = 0x1000,
    VDS_SF_SUPPORTS_STRIPE_LUNS               = 0x2000,
    VDS_SF_SUPPORTS_MIRROR_LUNS               = 0x4000,
    VDS_SF_SUPPORTS_PARITY_LUNS               = 0x8000,
    VDS_SF_SUPPORTS_AUTH_CHAP                 = 0x10000,
    VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP          = 0x20000,
    VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG      = 0x40000,
    VDS_SF_SUPPORTS_LUN_NUMBER                = 0x80000,
    VDS_SF_SUPPORTS_MIRRORED_CACHE            = 0x100000,
    VDS_SF_READ_CACHING_CAPABLE               = 0x200000,
    VDS_SF_WRITE_CACHING_CAPABLE              = 0x400000,
    VDS_SF_MEDIA_SCAN_CAPABLE                 = 0x800000,
    VDS_SF_CONSISTENCY_CHECK_CAPABLE          = 0x1000000 
  } VDS_SUB_SYSTEM_FLAG;

  typedef enum _VDS_SUB_SYSTEM_STATUS {
    VDS_SSS_UNKNOWN             = 0,
    VDS_SSS_ONLINE              = 1,
    VDS_SSS_NOT_READY           = 2,
    VDS_SSS_OFFLINE             = 4,
    VDS_SSS_FAILED              = 5,
    VDS_SSS_PARTIALLY_MANAGED   = 9 
  } VDS_SUB_SYSTEM_STATUS;

  typedef enum _VDS_VERSION_SUPPORT_FLAG {
    VDS_VSF_1_0   = 0x1,
    VDS_VSF_1_1   = 0x2,
    VDS_VSF_2_0   = 0x4,
    VDS_VSF_2_1   = 0x8,
    VDS_VSF_3_0   = 0x10 
  } VDS_VERSION_SUPPORT_FLAG;

  typedef enum _VDS_VOLUME_FLAG {
    VDS_VF_SYSTEM_VOLUME                  = 0x1,
    VDS_VF_BOOT_VOLUME                    = 0x2,
    VDS_VF_ACTIVE                         = 0x4,
    VDS_VF_READONLY                       = 0x8,
    VDS_VF_HIDDEN                         = 0x10,
    VDS_VF_CAN_EXTEND                     = 0x20,
    VDS_VF_CAN_SHRINK                     = 0x40,
    VDS_VF_PAGEFILE                       = 0x80,
    VDS_VF_HIBERNATION                    = 0x100,
    VDS_VF_CRASHDUMP                      = 0x200,
    VDS_VF_INSTALLABLE                    = 0x400,
    VDS_VF_LBN_REMAP_ENABLED              = 0x800,
    VDS_VF_FORMATTING                     = 0x1000,
    VDS_VF_NOT_FORMATTABLE                = 0x2000,
    VDS_VF_NTFS_NOT_SUPPORTED             = 0x4000,
    VDS_VF_FAT32_NOT_SUPPORTED            = 0x8000,
    VDS_VF_FAT_NOT_SUPPORTED              = 0x10000,
    VDS_VF_NO_DEFAULT_DRIVE_LETTER        = 0x20000,
    VDS_VF_PERMANENTLY_DISMOUNTED         = 0x40000,
    VDS_VF_PERMANENT_DISMOUNT_SUPPORTED   = 0x80000,
    VDS_VF_SHADOW_COPY                    = 0x100000,
    VDS_VF_FVE_ENABLED                    = 0x200000,
    VDS_VF_DIRTY                          = 0x400000 
  } VDS_VOLUME_FLAG;

  typedef enum _VDS_VOLUME_PLEX_STATUS {
    VDS_VPS_UNKNOWN    = 0,
    VDS_VPS_ONLINE     = 1,
    VDS_VPS_NO_MEDIA   = 3,
    VDS_VPS_FAILED     = 5 
  } VDS_VOLUME_PLEX_STATUS;

  typedef enum _VDS_VOLUME_PLEX_TYPE {
    VDS_VPT_UNKNOWN   = 0,
    VDS_VPT_SIMPLE    = 10,
    VDS_VPT_SPAN      = 11,
    VDS_VPT_STRIPE    = 12,
    VDS_VPT_PARITY    = 14 
  } VDS_VOLUME_PLEX_TYPE;

  typedef enum _VDS_VOLUME_STATUS {
    VDS_VS_UNKNOWN    = 0,
    VDS_VS_ONLINE     = 1,
    VDS_VS_NO_MEDIA   = 3,
    VDS_VS_FAILED     = 5,
    VDS_VS_OFFLINE    = 4 
  } VDS_VOLUME_STATUS;

  typedef enum _VDS_VOLUME_TYPE {
    VDS_VT_UNKNOWN   = 0,
    VDS_VT_SIMPLE    = 10,
    VDS_VT_SPAN      = 11,
    VDS_VT_STRIPE    = 12,
    VDS_VT_MIRROR    = 13,
    VDS_VT_PARITY    = 14 
  } VDS_VOLUME_TYPE;

  typedef struct _VDS_PARTITION_INFO_GPT {
    GUID      partitionType;
    GUID      partitionId;
    ULONGLONG attributes;
    WCHAR     name[GPT_PARTITION_NAME_LENGTH];
  } VDS_PARTITION_INFO_GPT;

  typedef struct _CHANGE_ATTRIBUTES_PARAMETERS {
    VDS_PARTITION_STYLE style;
    __C89_NAMELESS union {
      struct {
	BOOLEAN bootIndicator;
      } MbrPartInfo;
      struct {
	ULONGLONG attributes;
      } GptPartInfo;
    };
  } CHANGE_ATTRIBUTES_PARAMETERS;

  typedef struct _CHANGE_PARTITION_TYPE_PARAMETERS {
    VDS_PARTITION_STYLE style;
    __C89_NAMELESS union {
      struct {
        BYTE partitionType;
      } MbrPartInfo;
      struct {
        GUID partitionType;
      } GptPartInfo;
    } ;
  } CHANGE_PARTITION_TYPE_PARAMETERS, *PCHANGE_PARTITION_TYPE_PARAMETERS;


  typedef struct _CREATE_PARTITION_PARAMETERS {
    VDS_PARTITION_STYLE style;
    __C89_NAMELESS union {
      struct {
	BYTE    partitionType;
	BOOLEAN bootIndicator;
      } MbrPartInfo;
      struct {
	GUID      partitionType;
	GUID      partitionId;
	ULONGLONG attributes;
	WCHAR     name[GPT_PARTITION_NAME_LENGTH];
      } GptPartInfo;
    };
  } CREATE_PARTITION_PARAMETERS;

  typedef struct _VDS_ASYNC_OUTPUT {
    VDS_ASYNC_OUTPUT_TYPE type;
    /*[switch(type)] */__C89_NAMELESS union {
      /*[case(VDS_ASYNCOUT_CREATEPARTITION)]*/
      struct {
	ULONGLONG     ullOffset;
	VDS_OBJECT_ID volumeId;
      } cp;
      /*[case(VDS_ASYNCOUT_CREATEVOLUME)]*/
      struct {
	IUnknown *pVolumeUnk;
      } cv;
      /*[case(VDS_ASYNCOUT_BREAKVOLUMEPLEX)]*/
      struct {
	IUnknown *pVolumeUnk;
      } bvp;
      /*[case(VDS_ASYNCOUT_CREATELUN)]*/
      struct {
	IUnknown *pLunUnk;
      } cl;
      /*[case(VDS_ASYNCOUT_CREATETARGET)]*/
      struct {
	IUnknown *pTargetUnk;
      } ct;
      /*[case(VDS_ASYNCOUT_CREATEPORTALGROUP)]*/
      struct {
	IUnknown *pPortalGroupUnk;
      } cpg;
      /*[case(VDS_ASYNCOUT_CREATE_VDISK)]*/
      struct {
	IUnknown *pVDiskUnk;
      } cvd;
    };
  }  VDS_ASYNC_OUTPUT;

#define VDS_NF_CONTROLLER_ARRIVE 103
#define VDS_NF_CONTROLLER_DEPART 104
#define VDS_NF_CONTROLLER_MODIFY 350
#define VDS_NF_CONTROLLER_REMOVED 351

  typedef struct _VDS_CONTROLLER_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID controllerId;
  } VDS_CONTROLLER_NOTIFICATION;

  typedef struct _VDS_CONTROLLER_PROP {
    VDS_OBJECT_ID         id;
    LPWSTR                pwszFriendlyName;
    LPWSTR                pwszIdentification;
    VDS_CONTROLLER_STATUS status;
    VDS_HEALTH            health;
    SHORT                 sNumberOfPorts;
  } VDS_CONTROLLER_PROP;

  typedef struct _VDS_DISK_EXTENT {
    VDS_OBJECT_ID        diskId;
    VDS_DISK_EXTENT_TYPE type;
    ULONGLONG            ullOffset;
    ULONGLONG            ullSize;
    VDS_OBJECT_ID        volumeId;
    VDS_OBJECT_ID        plexId;
    ULONG                memberIdx;
  } VDS_DISK_EXTENT, *PVDS_DISK_EXTENT;

  typedef struct _VDS_DISK_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID diskId;
  } VDS_DISK_NOTIFICATION;

  typedef struct _VDS_PACK_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID packId;
  } VDS_PACK_NOTIFICATION;

  typedef struct _VDS_VOLUME_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID volumeId;
    VDS_OBJECT_ID plexId;
    ULONG         ulPercentCompleted;
  } VDS_VOLUME_NOTIFICATION;

  typedef struct _VDS_PARTITION_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID diskId;
    ULONGLONG     ullOffset;
  } VDS_PARTITION_NOTIFICATION;

  typedef struct _VDS_DRIVE_LETTER_NOTIFICATION {
    ULONG         ulEvent;
    WCHAR         wcLetter;
    VDS_OBJECT_ID volumeId;
  } VDS_DRIVE_LETTER_NOTIFICATION;

  typedef struct _VDS_FILE_SYSTEM_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID volumeId;
    DWORD         dwPercentCompleted;
  } VDS_FILE_SYSTEM_NOTIFICATION;

  typedef struct _VDS_MOUNT_POINT_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID volumeId;
  } VDS_MOUNT_POINT_NOTIFICATION;

  typedef struct _VDS_SUB_SYSTEM_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID subSystemId;
  } VDS_SUB_SYSTEM_NOTIFICATION;

  typedef struct _VDS_DRIVE_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID driveId;
  } VDS_DRIVE_NOTIFICATION;

  typedef struct _VDS_LUN_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID LunId;
  } VDS_LUN_NOTIFICATION;

  typedef struct _VDS_PORT_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID portId;
  } VDS_PORT_NOTIFICATION;

  typedef struct _VDS_PORTAL_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID portalId;
  } VDS_PORTAL_NOTIFICATION;

  typedef struct _VDS_TARGET_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID targetId;
  } VDS_TARGET_NOTIFICATION;

  typedef struct _VDS_PORTAL_GROUP_NOTIFICATION {
    ULONG         ulEvent;
    VDS_OBJECT_ID portalGroupId;
  } VDS_PORTAL_GROUP_NOTIFICATION;

  typedef struct _VDS_NOTIFICATION {
    VDS_NOTIFICATION_TARGET_TYPE objectType;
    __C89_NAMELESS union {
      VDS_PACK_NOTIFICATION         Pack;
      VDS_DISK_NOTIFICATION         Disk;
      VDS_VOLUME_NOTIFICATION       Volume;
      VDS_PARTITION_NOTIFICATION    Partition;
      VDS_DRIVE_LETTER_NOTIFICATION Letter;
      VDS_FILE_SYSTEM_NOTIFICATION  FileSystem;
      VDS_MOUNT_POINT_NOTIFICATION  MountPoint;
      VDS_SUB_SYSTEM_NOTIFICATION   SubSystem;
      VDS_CONTROLLER_NOTIFICATION   Controller;
      VDS_DRIVE_NOTIFICATION        Drive;
      VDS_LUN_NOTIFICATION          Lun;
      VDS_PORT_NOTIFICATION         Port;
      VDS_PORTAL_NOTIFICATION       Portal;
      VDS_TARGET_NOTIFICATION       Target;
      VDS_PORTAL_GROUP_NOTIFICATION PortalGroup;
    };
  } VDS_NOTIFICATION;

  typedef enum _VDS_LUN_RESERVE_MODE {
    VDS_LRM_NONE = 0x00000000,
    VDS_LRM_EXCLUSIVE_RW = 0x00000001,
    VDS_LRM_EXCLUSIVE_RO = 0x00000002,
    VDS_LRM_SHARED_RO = 0x00000003,
    VDS_LRM_SHARED_RW = 0x00000004
  } VDS_LUN_RESERVE_MODE;

  typedef struct _VDS_DISK_PROP {
    VDS_OBJECT_ID        id;
    VDS_DISK_STATUS      status;
    VDS_LUN_RESERVE_MODE ReserveMode;
    VDS_HEALTH           health;
    DWORD                dwDeviceType;
    DWORD                dwMediaType;
    ULONGLONG            ullSize;
    ULONG                ulBytesPerSector;
    ULONG                ulSectorsPerTrack;
    ULONG                ulTracksPerCylinder;
    ULONG                ulFlags;
    VDS_STORAGE_BUS_TYPE BusType;
    VDS_PARTITION_STYLE  PartitionStyle;
    __C89_NAMELESS union {
      DWORD dwSignature;
      GUID  DiskGuid;
    };
    LPWSTR               pwszDiskAddress;
    LPWSTR               pwszName;
    LPWSTR               pwszFriendlyName;
    LPWSTR               pwszAdaptorName;
    LPWSTR               pwszDevicePath;
  } VDS_DISK_PROP, *PVDS_DISK_PROP;

  typedef struct _VDS_DRIVE_EXTENT {
    VDS_OBJECT_ID id;
    VDS_OBJECT_ID LunId;
    ULONGLONG     ullSize;
    WINBOOL       bUsed;
  } VDS_DRIVE_EXTENT;

#define VDS_NF_DRIVE_LETTER_FREE 201
#define VDS_NF_DRIVE_LETTER_ASSIGN 202

  typedef struct _VDS_DRIVE_LETTER_PROP {
    WCHAR         wcLetter;
    VDS_OBJECT_ID volumeId;
    ULONG         ulFlags;
    WINBOOL       bUsed;
  } VDS_DRIVE_LETTER_PROP, *PVDS_DRIVE_LETTER_PROP;

#define VDS_NF_DRIVE_ARRIVE 105
#define VDS_NF_DRIVE_DEPART 106
#define VDS_NF_DRIVE_MODIFY 107
#define VDS_NF_DRIVE_REMOVED 354

  typedef struct _VDS_DRIVE_PROP {
    VDS_OBJECT_ID    id;
    ULONGLONG        ullSize;
    LPWSTR           pwszFriendlyName;
    LPWSTR           pwszIdentification;
    ULONG            ulFlags;
    VDS_DRIVE_STATUS status;
    VDS_HEALTH       health;
    SHORT            sInternalBusNumber;
    SHORT            sSlotNumber;
  } VDS_DRIVE_PROP;

  typedef struct _VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP {
    ULONG  ulFlags;
    USHORT usRevision;
    ULONG  ulDefaultUnitAllocationSize;
    ULONG  rgulAllowedUnitAllocationSizes;
    WCHAR  wszName;
  } VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP, *PVDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP;

#define VDS_NF_FILE_SYSTEM_MODIFY 203
#define VDS_NF_FILE_SYSTEM_FORMAT_PROGRESS 204

  typedef struct _VDS_FILE_SYSTEM_PROP {
    VDS_FILE_SYSTEM_TYPE type;
    VDS_OBJECT_ID        volumeId;
    ULONG                ulFlags;
    ULONGLONG            ullTotalAllocationUnits;
    ULONGLONG            ullAvailableAllocationUnits;
    ULONG                ulAllocationUnitSize;
    LPWSTR               pwszLabel;
  } VDS_FILE_SYSTEM_PROP, *PVDS_FILE_SYSTEM_PROP;

#define MAX_FS_NAME_SIZE 8

  typedef struct _VDS_FILE_SYSTEM_TYPE_PROP {
    VDS_FILE_SYSTEM_TYPE type;
    WCHAR                wszName[MAX_FS_NAME_SIZE];
    ULONG                ulFlags;
    ULONG                ulCompressionFlags;
    ULONG                ulMaxLableLength;
    LPWSTR               pwszIllegalLabelCharSet;
  } VDS_FILE_SYSTEM_TYPE_PROP, *PVDS_FILE_SYSTEM_TYPE_PROP;

  typedef struct _VDS_WWN {
    UCHAR rguchWwn[8];
  } VDS_WWN;

  typedef struct _VDS_HBAPORT_PROP {
    VDS_OBJECT_ID      id;
    VDS_WWN            wwnNode;
    VDS_WWN            wwnPort;
    VDS_HBAPORT_TYPE   type;
    VDS_HBAPORT_STATUS status;
    ULONG              ulPortSpeed;
    ULONG              ulSupportedPortSpeed;
  } VDS_HBAPORT_PROP;

#define VDS_HINT_FASTCRASHRECOVERYREQUIRED   0x0000000000000001ULL
#define VDS_HINT_MOSTLYREADS                 0x0000000000000002ULL
#define VDS_HINT_OPTIMIZEFORSEQUENTIALREADS  0x0000000000000004ULL
#define VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES 0x0000000000000008ULL
#define VDS_HINT_READBACKVERIFYENABLED       0x0000000000000010ULL
#define VDS_HINT_REMAPENABLED                0x0000000000000020ULL
#define VDS_HINT_WRITETHROUGHCACHINGENABLED  0x0000000000000040ULL
#define VDS_HINT_HARDWARECHECKSUMENABLED     0x0000000000000080ULL
#define VDS_HINT_ISYANKABLE                  0x0000000000000100ULL
#define VDS_HINT_ALLOCATEHOTSPARE            0x0000000000000200ULL
#define VDS_HINT_BUSTYPE                     0x0000000000000400ULL
#define VDS_HINT_USEMIRROREDCACHE            0x0000000000000800ULL
#define VDS_HINT_READCACHINGENABLED          0x0000000000001000ULL
#define VDS_HINT_WRITECACHINGENABLED         0x0000000000002000ULL
#define VDS_HINT_MEDIASCANENABLED            0x0000000000004000ULL
#define VDS_HINT_CONSISTENCYCHECKENABLED     0x0000000000008000ULL

  typedef struct _VDS_HINTS {
    ULONGLONG ullHintMask;
    ULONGLONG ullExpectedMaximumSize;
    ULONG     ulOptimalReadSize;
    ULONG     ulOptimalReadAlignment;
    ULONG     ulOptimalWriteSize;
    ULONG     ulOptimalWriteAlignment;
    ULONG     ulMaximumDriveCount;
    ULONG     ulStripeSize;
    WINBOOL   bFastCrashRecoveryRequired;
    WINBOOL   bMostlyReads;
    WINBOOL   bOptimizeForSequentialReads;
    WINBOOL   bOptimizeForSequentialWrites;
    WINBOOL   bRemapEnabled;
    WINBOOL   bReadBackVerifyEnabled;
    WINBOOL   bWriteThroughCachingEnabled;
    WINBOOL   bHardwareChecksumEnabled;
    WINBOOL   bIsYankable;
    SHORT     sRebuildPriority;
  } VDS_HINTS, *PVDS_HINTS;

  typedef struct _VDS_INPUT_DISK {
    VDS_OBJECT_ID diskId;
    ULONGLONG     ullSize;
    VDS_OBJECT_ID plexId;
    ULONG         memberIdx;
  } VDS_INPUT_DISK;

  typedef struct _VDS_IPADDRESS {
    VDS_IPADDRESS_TYPE type;
    ULONG              ipv4Address;
    UCHAR              ipv6Address[16];
    ULONG              ulIpv6FlowInfo;
    ULONG              ulIpv6ScopeId;
    WCHAR              wszTextAddress[256 + 1];
    ULONG              ulPort;
  } VDS_IPADDRESS;

  typedef struct _VDS_ISCSI_INITIATOR_ADAPTER_PROP {
    VDS_OBJECT_ID id;
    LPWSTR        pwszName;
  } VDS_ISCSI_INITIATOR_ADAPTER_PROP;

  typedef struct _VDS_ISCSI_INITIATOR_PORTAL_PROP {
    VDS_OBJECT_ID id;
    VDS_IPADDRESS address;
    ULONG         ulPortIndex;
  } VDS_ISCSI_INITIATOR_PORTAL_PROP;

  typedef struct _VDS_ISCSI_PORTAL_PROP {
    VDS_OBJECT_ID           id;
    VDS_IPADDRESS           address;
    VDS_ISCSI_PORTAL_STATUS status;
  } VDS_ISCSI_PORTAL_PROP;

  typedef USHORT VDS_ISCSI_PORTALGROUP_TAG;

  typedef struct _VDS_ISCSI_PORTALGROUP_PROP {
    VDS_OBJECT_ID             id;
    VDS_ISCSI_PORTALGROUP_TAG tag;
  } VDS_ISCSI_PORTALGROUP_PROP;

  typedef struct _VDS_ISCSI_SHARED_SECRET {
    UCHAR *pSharedSecret;
    ULONG ulSharedSecretSize;
  } VDS_ISCSI_SHARED_SECRET;

  typedef struct _VDS_ISCSI_TARGET_PROP {
    VDS_OBJECT_ID id;
    LPWSTR        pwszIscsiName;
    LPWSTR        pwszFriendlyName;
    WINBOOL       bChapEnabled;
  } VDS_ISCSI_TARGET_PROP;

  typedef struct _VDS_STORAGE_IDENTIFIER {
    VDS_STORAGE_IDENTIFIER_CODE_SET m_CodeSet;
    VDS_STORAGE_IDENTIFIER_TYPE m_Type;
    ULONG m_cbIdentifier;
    BYTE* m_rgbIdentifier;
  } VDS_STORAGE_IDENTIFIER;

  typedef struct _VDS_STORAGE_DEVICE_ID_DESCRIPTOR {
    ULONG m_version;
    ULONG m_cIdentifiers;
    VDS_STORAGE_IDENTIFIER* m_rgIdentifiers;
  } VDS_STORAGE_DEVICE_ID_DESCRIPTOR;

#define VDS_NF_LUN_ARRIVE 108
#define VDS_NF_LUN_DEPART 109
#define VDS_NF_LUN_MODIFY 110

  typedef struct _VDS_LUN_PLEX_PROP {
    VDS_OBJECT_ID        id;
    ULONGLONG            ullSize;
    VDS_LUN_PLEX_TYPE    type;
    VDS_LUN_PLEX_STATUS  status;
    VDS_HEALTH           health;
    VDS_TRANSITION_STATE TransitionState;
    ULONG                ulFlags;
    ULONG                ulStripeSize;
    SHORT                sRebuildPriority;
  } VDS_LUN_PLEX_PROP;

  typedef struct _VDS_LUN_PROP {
    VDS_OBJECT_ID        id;
    ULONGLONG            ullSize;
    LPWSTR               pwszFriendlyName;
    LPWSTR               pwszIdentification;
    LPWSTR               pwszUnmaskingList;
    ULONG                ulFlags;
    VDS_LUN_TYPE         type;
    VDS_LUN_STATUS       status;
    VDS_HEALTH           health;
    VDS_TRANSITION_STATE TransitionState;
    SHORT                sRebuildPriority;
  } VDS_LUN_PROP, *PVDS_LUN_PROP;

#define VDS_NF_MOUNT_POINTS_CHANGE 205

#define VDS_NF_PACK_ARRIVE 1
#define VDS_NF_PACK_DEPART 2
#define VDS_NF_PACK_MODIFY 3

  typedef struct _VDS_PACK_PROP {
    VDS_OBJECT_ID   id;
    LPWSTR          pwszName;
    VDS_PACK_STATUS status;
    ULONG           ulFlags;
  } VDS_PACK_PROP, *PVDS_PACK_PROP;

  typedef struct _VDS_PARTITION_INFO_MBR {
    BYTE    partitionType;
    BOOLEAN bootIndicator;
    BOOLEAN recognizedPartition;
    DWORD   hiddenSectors;
  } VDS_PARTITION_INFO_MBR;

#define VDS_NF_PARTITION_ARRIVE 11
#define VDS_NF_PARTITION_DEPART 12
#define VDS_NF_PARTITION_MODIFY 13

  typedef struct _VDS_PARTITION_PROP {
    VDS_PARTITION_STYLE PartitionStyle;
    ULONG               ulFlags;
    ULONG               ulPartitionNumber;
    ULONGLONG           ullOffset;
    ULONGLONG           ullSize;
    __C89_NAMELESS union {
      VDS_PARTITION_INFO_MBR Mbr;
      VDS_PARTITION_INFO_GPT Gpt;
    };
  } VDS_PARTITION_PROP;

  typedef struct _VDS_PATH_INFO {
    VDS_PATH_ID         pathId;
    VDS_HWPROVIDER_TYPE type;
    VDS_PATH_STATUS     status;
    __C89_NAMELESS union {
      VDS_OBJECT_ID controllerPortId;
      VDS_OBJECT_ID targetPortalId;
    };
    __C89_NAMELESS union {
      VDS_OBJECT_ID hbaPortId;
      VDS_OBJECT_ID initiatorAdapterId;
    };
    __C89_NAMELESS union {
      VDS_HBAPORT_PROP *pHbaPortProp;
      VDS_IPADDRESS    *pInitiatorPortalIpAddr;
    };
  } VDS_PATH_INFO;

  typedef struct _VDS_PATH_POLICY {
    VDS_PATH_ID pathId;
    BOOL        bPrimaryPath;
    ULONG       ulWeight;
  } VDS_PATH_POLICY;

#define VDS_NF_PORT_ARRIVE 121
#define VDS_NF_PORT_DEPART 122
#define VDS_NF_PORT_MODIFY 352
#define VDS_NF_PORT_REMOVED 353

  typedef struct _VDS_PORT_PROP {
    VDS_OBJECT_ID   id;
    LPWSTR          pwszFriendlyName;
    LPWSTR          pwszIdentification;
    VDS_PORT_STATUS status;
  } VDS_PORT_PROP;

#define VDS_NF_PORTAL_GROUP_ARRIVE 129
#define VDS_NF_PORTAL_GROUP_DEPART 130
#define VDS_NF_PORTAL_GROUP_MODIFY 131
#define VDS_NF_PORTAL_ARRIVE 123
#define VDS_NF_PORTAL_DEPART 124
#define VDS_NF_PORTAL_MODIFY 125

  typedef struct _VDS_PROVIDER_PROP {
    VDS_OBJECT_ID     id;
    LPWSTR            pwszName;
    GUID              guidVersionId;
    LPWSTR            pwszVersion;
    VDS_PROVIDER_TYPE type;
    ULONG             ulFlags;
    ULONG             ulStripeSizeFlags;
    SHORT             sRebuildPriority;
  } VDS_PROVIDER_PROP;

  typedef struct VDS_REPARSE_POINT_PROP {
    VDS_OBJECT_ID SourceVolumeId;
    LPWSTR        pwszPath;
  } VDS_REPARSE_POINT_PROP, *PVDS_REPARSE_POINT_PROP;

  typedef struct _VDS_SERVICE_PROP {
    LPWSTR pwszVersion;
    ULONG  ulFlags;
  } VDS_SERVICE_PROP;

#define VDS_NF_SUB_SYSTEM_ARRIVE 101
#define VDS_NF_SUB_SYSTEM_DEPART 102
#define VDS_NF_SUB_SYSTEM_MODIFY 151

  typedef struct _VDS_SUB_SYSTEM_PROP {
    VDS_OBJECT_ID         id;
    LPWSTR                pwszFriendlyName;
    LPWSTR                pwszIdentification;
    ULONG                 ulFlags;
    ULONG                 ulStripeSizeFlags;
    VDS_SUB_SYSTEM_STATUS status;
    VDS_HEALTH            health;
    SHORT                 sNumberOfInternalBuses;
    SHORT                 sMaxNumberOfSlotsEachBus;
    SHORT                 sMaxNumberOfControllers;
    SHORT                 sRebuildPriority;
  } VDS_SUB_SYSTEM_PROP;

#define VDS_NF_TARGET_ARRIVE 126
#define VDS_NF_TARGET_DEPART 127
#define VDS_NF_TARGET_MODIFY 128
#define VDS_NF_VOLUME_ARRIVE 4
#define VDS_NF_VOLUME_DEPART 5
#define VDS_NF_VOLUME_MODIFY 6
#define VDS_NF_VOLUME_REBUILDING 7

  typedef struct _VDS_VOLUME_PLEX_PROP {
    VDS_OBJECT_ID          id;
    VDS_VOLUME_PLEX_TYPE   type;
    VDS_VOLUME_PLEX_STATUS status;
    VDS_HEALTH             health;
    VDS_TRANSITION_STATE   TransitionState;
    ULONGLONG              ullSize;
    ULONG                  ulStripeSize;
    ULONG                  ulNumberOfMembers;
  } VDS_VOLUME_PLEX_PROP, *PVDS_VOLUME_PLEX_PROP;

  typedef struct _VDS_VOLUME_PROP {
    VDS_OBJECT_ID        id;
    VDS_VOLUME_TYPE      type;
    VDS_VOLUME_STATUS    status;
    VDS_HEALTH           health;
    VDS_TRANSITION_STATE TransitionState;
    ULONGLONG            ullSize;
    ULONG                ulFlags;
    VDS_FILE_SYSTEM_TYPE RecommendedFileSystemType;
    LPWSTR               pwszName;
  } VDS_VOLUME_PROP, *PVDS_VOLUME_PROP;

#ifdef __cplusplus
}
#endif

#endif /*(_WIN32_WINNT >= 0x0600)*/

#include <vdslun.h>

#if (_WIN32_WINNT >= 0x0601)
#ifdef __cplusplus
extern "C" {
#endif
typedef enum _VDS_DISK_OFFLINE_REASON {
  VDSDiskOfflineReasonNone            = 0,
  VDSDiskOfflineReasonPolicy          = 1,
  VDSDiskOfflineReasonRedundantPath   = 2,
  VDSDiskOfflineReasonSnapshot        = 3,
  VDSDiskOfflineReasonCollision       = 4 
} VDS_DISK_OFFLINE_REASON;

typedef enum _VDS_STORAGE_POOL_STATUS {
  VDS_SPS_UNKNOWN     = 0,
  VDS_SPS_ONLINE      = 1,
  VDS_SPS_NOT_READY   = 2,
  VDS_SPS_OFFLINE     = 4 
} VDS_STORAGE_POOL_STATUS;

typedef enum _VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG {
  VDS_SF_SUPPORTS_RAID2_LUNS    = 0x1,
  VDS_SF_SUPPORTS_RAID3_LUNS    = 0x2,
  VDS_SF_SUPPORTS_RAID4_LUNS    = 0x4,
  VDS_SF_SUPPORTS_RAID5_LUNS    = 0x8,
  VDS_SF_SUPPORTS_RAID6_LUNS    = 0x10,
  VDS_SF_SUPPORTS_RAID01_LUNS   = 0x20,
  VDS_SF_SUPPORTS_RAID03_LUNS   = 0x40,
  VDS_SF_SUPPORTS_RAID05_LUNS   = 0x80,
  VDS_SF_SUPPORTS_RAID10_LUNS   = 0x100,
  VDS_SF_SUPPORTS_RAID15_LUNS   = 0x200,
  VDS_SF_SUPPORTS_RAID30_LUNS   = 0x400,
  VDS_SF_SUPPORTS_RAID50_LUNS   = 0x800,
  VDS_SF_SUPPORTS_RAID51_LUNS   = 0x1000,
  VDS_SF_SUPPORTS_RAID53_LUNS   = 0x2000,
  VDS_SF_SUPPORTS_RAID60_LUNS   = 0x4000,
  VDS_SF_SUPPORTS_RAID61_LUNS   = 0x8000 
} VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG;

typedef enum VDS_FORMAT_OPTION_FLAGS {
  VDS_FSOF_NONE                 = 0x00000000,
  VDS_FSOF_FORCE                = 0x00000001,
  VDS_FSOF_QUICK                = 0x00000002,
  VDS_FSOF_COMPRESSION          = 0x00000004,
  VDS_FSOF_DUPLICATE_METADATA   = 0x00000008 
} VDS_FORMAT_OPTION_FLAGS;

typedef enum _VDS_INTERCONNECT_FLAG {
  VDS_ITF_PCI_RAID        = 0x1,
  VDS_ITF_FIBRE_CHANNEL   = 0x2,
  VDS_ITF_ISCSI           = 0x4,
  VDS_ITF_SAS             = 0x8 
} VDS_INTERCONNECT_FLAG;

typedef enum _VDS_RAID_TYPE {
  VDS_RT_UNKNOWN   = 0,
  VDS_RT_RAID0     = 10,
  VDS_RT_RAID1     = 11,
  VDS_RT_RAID2     = 12,
  VDS_RT_RAID3     = 13,
  VDS_RT_RAID4     = 14,
  VDS_RT_RAID5     = 15,
  VDS_RT_RAID6     = 16,
  VDS_RT_RAID01    = 17,
  VDS_RT_RAID03    = 18,
  VDS_RT_RAID05    = 19,
  VDS_RT_RAID10    = 20,
  VDS_RT_RAID15    = 21,
  VDS_RT_RAID30    = 22,
  VDS_RT_RAID50    = 23,
  VDS_RT_RAID51    = 24,
  VDS_RT_RAID53    = 25,
  VDS_RT_RAID60    = 26,
  VDS_RT_RAID61    = 27 
} VDS_RAID_TYPE;

typedef enum _VDS_STORAGE_POOL_TYPE {
  VDS_SPT_UNKNOWN      = 0,
  VDS_SPT_PRIMORDIAL   = 0x1,
  VDS_SPT_CONCRETE     = 0x2 
} VDS_STORAGE_POOL_TYPE;

typedef enum _VDS_VDISK_STATE {
  VDS_VST_UNKNOWN             = 0,
  VDS_VST_ADDED               = 1,
  VDS_VST_OPEN                = 2,
  VDS_VST_ATTACH_PENDING      = 3,
  VDS_VST_ATTACHED_NOT_OPEN   = 4,
  VDS_VST_ATTACHED            = 5,
  VDS_VST_DETACH_PENDING      = 6,
  VDS_VST_COMPACTING          = 7,
  VDS_VST_MERGING             = 8,
  VDS_VST_EXPANDING           = 9,
  VDS_VST_DELETED             = 10,
  VDS_VST_MAX                 = 11 
} VDS_VDISK_STATE;

typedef struct _VDS_CREATE_VDISK_PARAMETERS {
  GUID      UniqueId;
  ULONGLONG MaximumSize;
  ULONG     BlockSizeInBytes;
  ULONG     SectorSizeInBytes;
  LPWSTR    pParentPath;
  LPWSTR    pSourcePath;
} VDS_CREATE_VDISK_PARAMETERS, *PVDS_CREATE_VDISK_PARAMETERS;

typedef struct _VDS_DISK_FREE_EXTENT {
  VDS_OBJECT_ID diskId;
  ULONGLONG     ullOffset;
  ULONGLONG     ullSize;
} VDS_DISK_FREE_EXTENT, *PVDS_DISK_FREE_EXTENT;

typedef struct _VDS_DISK_PROP2 {
  VDS_OBJECT_ID           id;
  VDS_DISK_STATUS         status;
  VDS_DISK_OFFLINE_REASON OfflineReason;
  VDS_LUN_RESERVE_MODE    ReserveMode;
  VDS_HEALTH              health;
  DWORD                   dwDeviceType;
  DWORD                   dwMediaType;
  ULONGLONG               ullSize;
  ULONG                   ulBytesPerSector;
  ULONG                   ulSectorsPerTrack;
  ULONG                   ulTracksPerCylinder;
  ULONG                   ulFlags;
  VDS_STORAGE_BUS_TYPE    BusType;
  VDS_PARTITION_STYLE     PartitionStyle;
  __C89_NAMELESS union {
    DWORD dwSignature;
    GUID  DiskGuid;
  };
  LPWSTR                  pwszDiskAddress;
  LPWSTR                  pwszName;
  LPWSTR                  pwszFriendlyName;
  LPWSTR                  pwszAdaptorName;
  LPWSTR                  pwszDevicePath;
  LPWSTR                  pwszLocationPath;
} VDS_DISK_PROP2, *PVDS_DISK_PROP2;

typedef struct _VDS_DRIVE_PROP2 {
  VDS_OBJECT_ID        id;
  ULONGLONG            ullSize;
  LPWSTR               pwszFriendlyName;
  LPWSTR               pwszIdentification;
  ULONG                ulFlags;
  VDS_DRIVE_STATUS     status;
  VDS_HEALTH           health;
  SHORT                sInternalBusNumber;
  SHORT                sSlotNumber;
  ULONG                ulEnclosureNumber;
  VDS_STORAGE_BUS_TYPE busType;
  ULONG                ulSpindleSpeed;
} VDS_DRIVE_PROP2, *PVDS_DRIVE_PROP2;

typedef struct _VDS_HINTS2 {
  ULONGLONG            ullHintMask;
  ULONGLONG            ullExpectedMaximumSize;
  ULONG                ulOptimalReadSize;
  ULONG                ulOptimalReadAlignment;
  ULONG                ulOptimalWriteSize;
  ULONG                ulOptimalWriteAlignment;
  ULONG                ulMaximumDriveCount;
  ULONG                ulStripeSize;
  ULONG                ulReserved1;
  ULONG                ulReserved2;
  ULONG                ulReserved3;
  WINBOOL              bFastCrashRecoveryRequired;
  WINBOOL              bMostlyReads;
  WINBOOL              bOptimizeForSequentialReads;
  WINBOOL              bOptimizeForSequentialWrites;
  WINBOOL              bRemapEnabled;
  WINBOOL              bReadBackVerifyEnabled;
  WINBOOL              bWriteThroughCachingEnabled;
  WINBOOL              bHardwareChecksumEnabled;
  WINBOOL              bIsYankable;
  WINBOOL              bAllocateHotSpare;
  WINBOOL              bUseMirroredCache;
  WINBOOL              bReadCachingEnabled;
  WINBOOL              bWriteCachingEnabled;
  WINBOOL              bMediaScanEnabled;
  WINBOOL              bConsistencyCheckEnabled;
  VDS_STORAGE_BUS_TYPE BusType;
  WINBOOL              bReserved1;
  WINBOOL              bReserved2;
  WINBOOL              bReserved3;
  SHORT                sRebuildPriority;
} VDS_HINTS2, *PVDS_HINTS2;

typedef struct _VDS_POOL_CUSTOM_ATTRIBUTES {
  LPWSTR pwszName;
  LPWSTR pwszValue;
} VDS_POOL_CUSTOM_ATTRIBUTES, *PVDS_POOL_CUSTOM_ATTRIBUTES;

typedef struct _VDS_POOL_ATTRIBUTES {
  ULONGLONG                  ullAttributeMask;
  VDS_RAID_TYPE              raidType;
  VDS_STORAGE_BUS_TYPE       busType;
  LPWSTR                     pwszIntendedUsage;
  WINBOOL                    bSpinDown;
  WINBOOL                    bIsThinProvisioned;
  ULONGLONG                  ullProvisionedSpace;
  WINBOOL                    bNoSinglePointOfFailure;
  ULONG                      ulDataRedundancyMax;
  ULONG                      ulDataRedundancyMin;
  ULONG                      ulDataRedundancyDefault;
  ULONG                      ulPackageRedundancyMax;
  ULONG                      ulPackageRedundancyMin;
  ULONG                      ulPackageRedundancyDefault;
  ULONG                      ulStripeSize;
  ULONG                      ulStripeSizeMax;
  ULONG                      ulStripeSizeMin;
  ULONG                      ulDefaultStripeSize;
  ULONG                      ulNumberOfColumns;
  ULONG                      ulNumberOfColumnsMax;
  ULONG                      ulNumberOfColumnsMin;
  ULONG                      ulDefaultNumberofColumns;
  ULONG                      ulDataAvailabilityHint;
  ULONG                      ulAccessRandomnessHint;
  ULONG                      ulAccessDirectionHint;
  ULONG                      ulAccessSizeHint;
  ULONG                      ulAccessLatencyHint;
  ULONG                      ulAccessBandwidthWeightHint;
  ULONG                      ulStorageCostHint;
  ULONG                      ulStorageEfficiencyHint;
  ULONG                      ulNumOfCustomAttributes;
  VDS_POOL_CUSTOM_ATTRIBUTES *pPoolCustomAttributes;
  WINBOOL                    bReserved1;
  WINBOOL                    bReserved2;
  ULONG                      ulReserved1;
  ULONG                      ulReserved2;
  ULONGLONG                  ullReserved1;
  ULONGLONG                  ullReserved2;
} VDS_POOL_ATTRIBUTES, *PVDS_POOL_ATTRIBUTES;

typedef struct _VDS_STORAGE_POOL_DRIVE_EXTENT {
  VDS_OBJECT_ID id;
  ULONGLONG     ullSize;
  WINBOOL       bUsed;
} VDS_STORAGE_POOL_DRIVE_EXTENT, *PVDS_STORAGE_POOL_DRIVE_EXTENT;

typedef struct _VDS_STORAGE_POOL_PROP {
  VDS_OBJECT_ID           id;
  VDS_STORAGE_POOL_STATUS status;
  VDS_HEALTH              health;
  VDS_STORAGE_POOL_TYPE   type;
  LPWSTR                  pwszName;
  LPWSTR                  pwszDescription;
  ULONGLONG               ullTotalConsumedSpace;
  ULONGLONG               ullTotalManagedSpace;
  ULONGLONG               ullRemainingFreeSpace;
} VDS_STORAGE_POOL_PROP, *PVDS_STORAGE_POOL_PROP;

typedef struct _VDS_SUB_SYSTEM_PROP2 {
  VDS_OBJECT_ID         id;
  LPWSTR                pwszFriendlyName;
  LPWSTR                pwszIdentification;
  ULONG                 ulFlags;
  ULONG                 ulStripeSizeFlags;
  ULONG                 ulSupportedRaidTypeFlags;
  VDS_SUB_SYSTEM_STATUS status;
  VDS_HEALTH            health;
  SHORT                 sNumberOfInternalBuses;
  SHORT                 sMaxNumberOfSlotsEachBus;
  SHORT                 sMaxNumberOfControllers;
  SHORT                 sRebuildPriority;
  ULONG                 ulNumberOfEnclosures;
} VDS_SUB_SYSTEM_PROP2, *PVDS_SUB_SYSTEM_PROP2;

typedef struct _VDS_VDISK_PROPERTIES {
  VDS_OBJECT_ID        Id;
  VDS_VDISK_STATE      State;
  VIRTUAL_STORAGE_TYPE VirtualDeviceType;
  ULONGLONG            VirtualSize;
  ULONGLONG            PhysicalSize;
  LPWSTR               pPath;
  LPWSTR               pDeviceName;
  DEPENDENT_DISK_FLAG  DiskFlag;
  WINBOOL              bIsChild;
  LPWSTR               pParentPath;
} VDS_VDISK_PROPERTIES, *PVDS_VDISK_PROPERTIES;

typedef struct _VDS_VOLUME_PROP2 {
  VDS_OBJECT_ID        id;
  VDS_VOLUME_TYPE      type;
  VDS_VOLUME_STATUS    status;
  VDS_HEALTH           health;
  VDS_TRANSITION_STATE TransitionState;
  ULONGLONG            ullSize;
  ULONG                ulFlags;
  VDS_FILE_SYSTEM_TYPE RecommendedFileSystemType;
  ULONG                cbUniqueId;
  LPWSTR               pwszName;
  BYTE                 *pUniqueId;
} VDS_VOLUME_PROP2, *PVDS_VOLUME_PROP2;

#ifdef __cplusplus
}
#endif
#endif /*(_WIN32_WINNT >= 0x0601)*/

#endif /*_INC_VDS*/
                                                                                                                                               usr/share/mingw-w64/include/vdslun.h                                                                0100644 0000000 0000000 00000001605 12404413016 016023  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_VDSLUN
#define _INC_VDSLUN

typedef struct _VDS_INTERCONNECT {
  VDS_INTERCONNECT_ADDRESS_TYPE m_addressType;
  ULONG m_cbPort;  BYTE* m_pbPort;
  ULONG m_cbAddress;
  BYTE *m_pbAddress;
} VDS_INTERCONNECT;

typedef struct _VDS_LUN_INFORMATION {
  ULONG m_version;
  BYTE m_DeviceType;
  BYTE m_DeviceTypeModifier;
  WINBOOL m_bCommandQueueing;
  VDS_STORAGE_BUS_TYPE m_BusType;
  char* m_szVendorId;
  char* m_szProductId;
  char* m_szProductRevision;
  char* m_szSerialNumber;
  GUID m_diskSignature;
  VDS_STORAGE_DEVICE_ID_DESCRIPTOR m_deviceIdDescriptor;
  ULONG m_cInterconnects;
  VDS_INTERCONNECT *m_rgInterconnects;
} VDS_LUN_INFORMATION;

#endif /*_INC_VDSLUN*/
                                                                                                                           usr/share/mingw-w64/include/vfw.h                                                                   0100644 0000000 0000000 00000225774 12404413016 015331  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_VFW
#define _INC_VFW

#include <_mingw_unicode.h>

#ifdef __cplusplus
extern "C" {
#endif

#define VFWAPI WINAPI
#define VFWAPIV WINAPIV
#define VFWAPI_INLINE WINAPI

  DWORD WINAPI VideoForWindowsVersion(void);
  LONG WINAPI InitVFW(void);
  LONG WINAPI TermVFW(void);

#ifdef __cplusplus
}
#endif

#if !defined(_INC_MMSYSTEM) && (!defined(NOVIDEO) || !defined(NOAVICAP))
#include <mmsystem.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MKFOURCC
#define MKFOURCC(ch0,ch1,ch2,ch3) ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) | ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24))
#endif

#if !defined(_INC_MMSYSTEM)
#define mmioFOURCC MKFOURCC
#endif

#ifndef NOCOMPMAN

#define ICVERSION 0x0104

  DECLARE_HANDLE(HIC);

#define BI_1632 0x32333631

#ifndef mmioFOURCC
#define mmioFOURCC(ch0,ch1,ch2,ch3) ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) | ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24))
#endif

#ifndef aviTWOCC
#define aviTWOCC(ch0,ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO mmioFOURCC('v','i','d','c')
#define ICTYPE_AUDIO mmioFOURCC('a','u','d','c')
#endif

#ifndef ICERR_OK
#define ICERR_OK __MSABI_LONG(0)
#define ICERR_DONTDRAW __MSABI_LONG(1)
#define ICERR_NEWPALETTE __MSABI_LONG(2)
#define ICERR_GOTOKEYFRAME __MSABI_LONG(3)
#define ICERR_STOPDRAWING __MSABI_LONG(4)

#define ICERR_UNSUPPORTED __MSABI_LONG(-1)
#define ICERR_BADFORMAT __MSABI_LONG(-2)
#define ICERR_MEMORY __MSABI_LONG(-3)
#define ICERR_INTERNAL __MSABI_LONG(-4)
#define ICERR_BADFLAGS __MSABI_LONG(-5)
#define ICERR_BADPARAM __MSABI_LONG(-6)
#define ICERR_BADSIZE __MSABI_LONG(-7)
#define ICERR_BADHANDLE __MSABI_LONG(-8)
#define ICERR_CANTUPDATE __MSABI_LONG(-9)
#define ICERR_ABORT __MSABI_LONG(-10)
#define ICERR_ERROR __MSABI_LONG(-100)
#define ICERR_BADBITDEPTH __MSABI_LONG(-200)
#define ICERR_BADIMAGESIZE __MSABI_LONG(-201)

#define ICERR_CUSTOM __MSABI_LONG(-400)
#endif

#ifndef ICMODE_COMPRESS
#define ICMODE_COMPRESS 1
#define ICMODE_DECOMPRESS 2
#define ICMODE_FASTDECOMPRESS 3
#define ICMODE_QUERY 4
#define ICMODE_FASTCOMPRESS 5
#define ICMODE_DRAW 8
#endif

#define AVIIF_LIST __MSABI_LONG(0x00000001)
#define AVIIF_TWOCC __MSABI_LONG(0x00000002)
#define AVIIF_KEYFRAME __MSABI_LONG(0x00000010)

#define ICQUALITY_LOW 0
#define ICQUALITY_HIGH 10000
#define ICQUALITY_DEFAULT -1

#define ICM_USER (DRV_USER+0x0000)

#define ICM_RESERVED ICM_RESERVED_LOW
#define ICM_RESERVED_LOW (DRV_USER+0x1000)
#define ICM_RESERVED_HIGH (DRV_USER+0x2000)

#define ICM_GETSTATE (ICM_RESERVED+0)
#define ICM_SETSTATE (ICM_RESERVED+1)
#define ICM_GETINFO (ICM_RESERVED+2)

#define ICM_CONFIGURE (ICM_RESERVED+10)
#define ICM_ABOUT (ICM_RESERVED+11)

#define ICM_GETERRORTEXT (ICM_RESERVED+12)
#define ICM_GETFORMATNAME (ICM_RESERVED+20)
#define ICM_ENUMFORMATS (ICM_RESERVED+21)

#define ICM_GETDEFAULTQUALITY (ICM_RESERVED+30)
#define ICM_GETQUALITY (ICM_RESERVED+31)
#define ICM_SETQUALITY (ICM_RESERVED+32)

#define ICM_SET (ICM_RESERVED+40)
#define ICM_GET (ICM_RESERVED+41)

#define ICM_FRAMERATE mmioFOURCC('F','r','m','R')
#define ICM_KEYFRAMERATE mmioFOURCC('K','e','y','R')

#define ICM_COMPRESS_GET_FORMAT (ICM_USER+4)
#define ICM_COMPRESS_GET_SIZE (ICM_USER+5)
#define ICM_COMPRESS_QUERY (ICM_USER+6)
#define ICM_COMPRESS_BEGIN (ICM_USER+7)
#define ICM_COMPRESS (ICM_USER+8)
#define ICM_COMPRESS_END (ICM_USER+9)

#define ICM_DECOMPRESS_GET_FORMAT (ICM_USER+10)
#define ICM_DECOMPRESS_QUERY (ICM_USER+11)
#define ICM_DECOMPRESS_BEGIN (ICM_USER+12)
#define ICM_DECOMPRESS (ICM_USER+13)
#define ICM_DECOMPRESS_END (ICM_USER+14)
#define ICM_DECOMPRESS_SET_PALETTE (ICM_USER+29)
#define ICM_DECOMPRESS_GET_PALETTE (ICM_USER+30)

#define ICM_DRAW_QUERY (ICM_USER+31)
#define ICM_DRAW_BEGIN (ICM_USER+15)
#define ICM_DRAW_GET_PALETTE (ICM_USER+16)
#define ICM_DRAW_UPDATE (ICM_USER+17)
#define ICM_DRAW_START (ICM_USER+18)
#define ICM_DRAW_STOP (ICM_USER+19)
#define ICM_DRAW_BITS (ICM_USER+20)
#define ICM_DRAW_END (ICM_USER+21)
#define ICM_DRAW_GETTIME (ICM_USER+32)
#define ICM_DRAW (ICM_USER+33)
#define ICM_DRAW_WINDOW (ICM_USER+34)
#define ICM_DRAW_SETTIME (ICM_USER+35)
#define ICM_DRAW_REALIZE (ICM_USER+36)
#define ICM_DRAW_FLUSH (ICM_USER+37)
#define ICM_DRAW_RENDERBUFFER (ICM_USER+38)

#define ICM_DRAW_START_PLAY (ICM_USER+39)
#define ICM_DRAW_STOP_PLAY (ICM_USER+40)

#define ICM_DRAW_SUGGESTFORMAT (ICM_USER+50)
#define ICM_DRAW_CHANGEPALETTE (ICM_USER+51)

#define ICM_DRAW_IDLE (ICM_USER+52)

#define ICM_GETBUFFERSWANTED (ICM_USER+41)

#define ICM_GETDEFAULTKEYFRAMERATE (ICM_USER+42)

#define ICM_DECOMPRESSEX_BEGIN (ICM_USER+60)
#define ICM_DECOMPRESSEX_QUERY (ICM_USER+61)
#define ICM_DECOMPRESSEX (ICM_USER+62)
#define ICM_DECOMPRESSEX_END (ICM_USER+63)

#define ICM_COMPRESS_FRAMES_INFO (ICM_USER+70)
#define ICM_COMPRESS_FRAMES (ICM_USER+71)
#define ICM_SET_STATUS_PROC (ICM_USER+72)

  typedef struct {
    DWORD dwSize;
    DWORD fccType;
    DWORD fccHandler;
    DWORD dwVersion;
    DWORD dwFlags;
    LRESULT dwError;
    LPVOID pV1Reserved;
    LPVOID pV2Reserved;
    DWORD dnDevNode;
  } ICOPEN;

  typedef struct {
    DWORD dwSize;
    DWORD fccType;
    DWORD fccHandler;
    DWORD dwFlags;
    DWORD dwVersion;
    DWORD dwVersionICM;

    WCHAR szName[16];
    WCHAR szDescription[128];
    WCHAR szDriver[128];
  } ICINFO;

#define VIDCF_QUALITY 0x0001
#define VIDCF_CRUNCH 0x0002
#define VIDCF_TEMPORAL 0x0004
#define VIDCF_COMPRESSFRAMES 0x0008
#define VIDCF_DRAW 0x0010
#define VIDCF_FASTTEMPORALC 0x0020
#define VIDCF_QUALITYTIME   0x0040
#define VIDCF_FASTTEMPORALD 0x0080
#define VIDCF_FASTTEMPORAL	(VIDCF_FASTTEMPORALC|VIDCF_FASTTEMPORALD)

#define ICCOMPRESS_KEYFRAME __MSABI_LONG(0x00000001)

  typedef struct {
    DWORD dwFlags;
    LPBITMAPINFOHEADER lpbiOutput;
    LPVOID lpOutput;

    LPBITMAPINFOHEADER lpbiInput;
    LPVOID lpInput;
    LPDWORD lpckid;
    LPDWORD lpdwFlags;
    LONG lFrameNum;
    DWORD dwFrameSize;
    DWORD dwQuality;
    LPBITMAPINFOHEADER lpbiPrev;
    LPVOID lpPrev;
  } ICCOMPRESS;

#define ICCOMPRESSFRAMES_PADDING 0x00000001

  typedef struct {
    DWORD dwFlags;
    LPBITMAPINFOHEADER lpbiOutput;
    LPARAM lOutput;
    LPBITMAPINFOHEADER lpbiInput;
    LPARAM lInput;
    LONG lStartFrame;
    LONG lFrameCount;
    LONG lQuality;
    LONG lDataRate;
    LONG lKeyRate;
    DWORD dwRate;
    DWORD dwScale;
    DWORD dwOverheadPerFrame;
    DWORD dwReserved2;
    LONG (CALLBACK *GetData)(LPARAM lInput,LONG lFrame,LPVOID lpBits,LONG len);
    LONG (CALLBACK *PutData)(LPARAM lOutput,LONG lFrame,LPVOID lpBits,LONG len);
  } ICCOMPRESSFRAMES;

#define ICSTATUS_START 0
#define ICSTATUS_STATUS 1
#define ICSTATUS_END 2
#define ICSTATUS_ERROR 3
#define ICSTATUS_YIELD 4

  typedef struct {
    DWORD dwFlags;
    LPARAM lParam;
    LONG (CALLBACK *Status)(LPARAM lParam,UINT message,LONG l);
  } ICSETSTATUSPROC;

#define ICDECOMPRESS_HURRYUP __MSABI_LONG(0x80000000)
#define ICDECOMPRESS_UPDATE __MSABI_LONG(0x40000000)
#define ICDECOMPRESS_PREROLL __MSABI_LONG(0x20000000)
#define ICDECOMPRESS_NULLFRAME __MSABI_LONG(0x10000000)
#define ICDECOMPRESS_NOTKEYFRAME __MSABI_LONG(0x08000000)

  typedef struct {
    DWORD dwFlags;
    LPBITMAPINFOHEADER lpbiInput;
    LPVOID lpInput;
    LPBITMAPINFOHEADER lpbiOutput;
    LPVOID lpOutput;
    DWORD ckid;
  } ICDECOMPRESS;

  typedef struct {
    DWORD dwFlags;
    LPBITMAPINFOHEADER lpbiSrc;
    LPVOID lpSrc;
    LPBITMAPINFOHEADER lpbiDst;
    LPVOID lpDst;
    int xDst;
    int yDst;
    int dxDst;
    int dyDst;

    int xSrc;
    int ySrc;
    int dxSrc;
    int dySrc;
  } ICDECOMPRESSEX;

#define ICDRAW_QUERY __MSABI_LONG(0x00000001)
#define ICDRAW_FULLSCREEN __MSABI_LONG(0x00000002)
#define ICDRAW_HDC __MSABI_LONG(0x00000004)
#define ICDRAW_ANIMATE __MSABI_LONG(0x00000008)
#define ICDRAW_CONTINUE __MSABI_LONG(0x00000010)
#define ICDRAW_MEMORYDC __MSABI_LONG(0x00000020)
#define ICDRAW_UPDATING __MSABI_LONG(0x00000040)
#define ICDRAW_RENDER __MSABI_LONG(0x00000080)
#define ICDRAW_BUFFER __MSABI_LONG(0x00000100)

  typedef struct {
    DWORD dwFlags;
    HPALETTE hpal;
    HWND hwnd;
    HDC hdc;
    int xDst;
    int yDst;
    int dxDst;
    int dyDst;
    LPBITMAPINFOHEADER lpbi;
    int xSrc;
    int ySrc;
    int dxSrc;
    int dySrc;
    DWORD dwRate;
    DWORD dwScale;
  } ICDRAWBEGIN;

#define ICDRAW_HURRYUP __MSABI_LONG(0x80000000)
#define ICDRAW_UPDATE __MSABI_LONG(0x40000000)
#define ICDRAW_PREROLL __MSABI_LONG(0x20000000)
#define ICDRAW_NULLFRAME __MSABI_LONG(0x10000000)
#define ICDRAW_NOTKEYFRAME __MSABI_LONG(0x08000000)

  typedef struct {
    DWORD dwFlags;
    LPVOID lpFormat;
    LPVOID lpData;
    DWORD cbData;
    LONG lTime;
  } ICDRAW;

  typedef struct {
    LPBITMAPINFOHEADER lpbiIn;
    LPBITMAPINFOHEADER lpbiSuggest;
    int dxSrc;
    int dySrc;
    int dxDst;
    int dyDst;
    HIC hicDecompressor;
  } ICDRAWSUGGEST;

  typedef struct {
    DWORD dwFlags;
    int iStart;
    int iLen;
    LPPALETTEENTRY lppe;
  } ICPALETTE;

  WINBOOL WINAPI ICInfo(DWORD fccType,DWORD fccHandler,ICINFO *lpicinfo);
  WINBOOL WINAPI ICInstall(DWORD fccType,DWORD fccHandler,LPARAM lParam,LPSTR szDesc,UINT wFlags);
  WINBOOL WINAPI ICRemove(DWORD fccType,DWORD fccHandler,UINT wFlags);
  LRESULT WINAPI ICGetInfo(HIC hic,ICINFO *picinfo,DWORD cb);
  HIC WINAPI ICOpen(DWORD fccType,DWORD fccHandler,UINT wMode);
  HIC WINAPI ICOpenFunction(DWORD fccType,DWORD fccHandler,UINT wMode,FARPROC lpfnHandler);
  LRESULT WINAPI ICClose(HIC hic);
  LRESULT WINAPI ICSendMessage(HIC hic,UINT msg,DWORD_PTR dw1,DWORD_PTR dw2);

#define ICINSTALL_UNICODE 0x8000
#define ICINSTALL_FUNCTION 0x0001
#define ICINSTALL_DRIVER 0x0002
#define ICINSTALL_HDRV 0x0004
#define ICINSTALL_DRIVERW 0x8002

#define ICMF_CONFIGURE_QUERY 0x00000001
#define ICMF_ABOUT_QUERY 0x00000001

#define ICQueryAbout(hic) (ICSendMessage(hic,ICM_ABOUT,(DWORD_PTR) -1,ICMF_ABOUT_QUERY)==ICERR_OK)
#define ICAbout(hic,hwnd) ICSendMessage(hic,ICM_ABOUT,(DWORD_PTR)(UINT_PTR)(hwnd),(DWORD_PTR)0)
#define ICQueryConfigure(hic) (ICSendMessage(hic,ICM_CONFIGURE,(DWORD_PTR) -1,ICMF_CONFIGURE_QUERY)==ICERR_OK)
#define ICConfigure(hic,hwnd) ICSendMessage(hic,ICM_CONFIGURE,(DWORD_PTR)(UINT_PTR)(hwnd),(DWORD_PTR)0)
#define ICGetState(hic,pv,cb) ICSendMessage(hic,ICM_GETSTATE,(DWORD_PTR)(LPVOID)(pv),(DWORD_PTR)(cb))
#define ICSetState(hic,pv,cb) ICSendMessage(hic,ICM_SETSTATE,(DWORD_PTR)(LPVOID)(pv),(DWORD_PTR)(cb))
#define ICGetStateSize(hic) (DWORD) ICGetState(hic,NULL,0)

  static DWORD dwICValue;

#define ICGetDefaultQuality(hic) (ICSendMessage(hic,ICM_GETDEFAULTQUALITY,(DWORD_PTR)(LPVOID)&dwICValue,sizeof(DWORD)),dwICValue)
#define ICGetDefaultKeyFrameRate(hic) (ICSendMessage(hic,ICM_GETDEFAULTKEYFRAMERATE,(DWORD_PTR)(LPVOID)&dwICValue,sizeof(DWORD)),dwICValue)
#define ICDrawWindow(hic,prc) ICSendMessage(hic,ICM_DRAW_WINDOW,(DWORD_PTR)(LPVOID)(prc),sizeof(RECT))

  DWORD WINAPIV ICCompress(HIC hic,DWORD dwFlags,LPBITMAPINFOHEADER lpbiOutput,LPVOID lpData,LPBITMAPINFOHEADER lpbiInput,LPVOID lpBits,LPDWORD lpckid,LPDWORD lpdwFlags,LONG lFrameNum,DWORD dwFrameSize,DWORD dwQuality,LPBITMAPINFOHEADER lpbiPrev,LPVOID lpPrev);

#define ICCompressBegin(hic,lpbiInput,lpbiOutput) ICSendMessage(hic,ICM_COMPRESS_BEGIN,(DWORD_PTR)(LPVOID)(lpbiInput),(DWORD_PTR)(LPVOID)(lpbiOutput))
#define ICCompressQuery(hic,lpbiInput,lpbiOutput) ICSendMessage(hic,ICM_COMPRESS_QUERY,(DWORD_PTR)(LPVOID)(lpbiInput),(DWORD_PTR)(LPVOID)(lpbiOutput))
#define ICCompressGetFormat(hic,lpbiInput,lpbiOutput) ICSendMessage(hic,ICM_COMPRESS_GET_FORMAT,(DWORD_PTR)(LPVOID)(lpbiInput),(DWORD_PTR)(LPVOID)(lpbiOutput))
#define ICCompressGetFormatSize(hic,lpbi) (DWORD) ICCompressGetFormat(hic,lpbi,NULL)
#define ICCompressGetSize(hic,lpbiInput,lpbiOutput) (DWORD) ICSendMessage(hic,ICM_COMPRESS_GET_SIZE,(DWORD_PTR)(LPVOID)(lpbiInput),(DWORD_PTR)(LPVOID)(lpbiOutput))
#define ICCompressEnd(hic) ICSendMessage(hic,ICM_COMPRESS_END,(DWORD_PTR)0,(DWORD_PTR)0)
#define ICDECOMPRESS_HURRYUP __MSABI_LONG(0x80000000)

  DWORD WINAPIV ICDecompress(HIC hic,DWORD dwFlags,LPBITMAPINFOHEADER lpbiFormat,LPVOID lpData,LPBITMAPINFOHEADER lpbi,LPVOID lpBits);

#define ICDecompressBegin(hic,lpbiInput,lpbiOutput) ICSendMessage(hic,ICM_DECOMPRESS_BEGIN,(DWORD_PTR)(LPVOID)(lpbiInput),(DWORD_PTR)(LPVOID)(lpbiOutput))
#define ICDecompressQuery(hic,lpbiInput,lpbiOutput) ICSendMessage(hic,ICM_DECOMPRESS_QUERY,(DWORD_PTR)(LPVOID)(lpbiInput),(DWORD_PTR)(LPVOID)(lpbiOutput))
#define ICDecompressGetFormat(hic,lpbiInput,lpbiOutput) ((LONG) ICSendMessage(hic,ICM_DECOMPRESS_GET_FORMAT,(DWORD_PTR)(LPVOID)(lpbiInput),(DWORD_PTR)(LPVOID)(lpbiOutput)))
#define ICDecompressGetFormatSize(hic,lpbi) ICDecompressGetFormat(hic,lpbi,NULL)
#define ICDecompressGetPalette(hic,lpbiInput,lpbiOutput) ICSendMessage(hic,ICM_DECOMPRESS_GET_PALETTE,(DWORD_PTR)(LPVOID)(lpbiInput),(DWORD_PTR)(LPVOID)(lpbiOutput))
#define ICDecompressSetPalette(hic,lpbiPalette) ICSendMessage(hic,ICM_DECOMPRESS_SET_PALETTE,(DWORD_PTR)(LPVOID)(lpbiPalette),(DWORD_PTR)0)
#define ICDecompressEnd(hic) ICSendMessage(hic,ICM_DECOMPRESS_END,(DWORD_PTR)0,(DWORD_PTR)0)

#ifndef __CRT__NO_INLINE
  __CRT_INLINE LRESULT WINAPI ICDecompressEx(HIC hic,DWORD dwFlags,LPBITMAPINFOHEADER lpbiSrc,LPVOID lpSrc,int xSrc,int ySrc,int dxSrc,int dySrc,LPBITMAPINFOHEADER lpbiDst,LPVOID lpDst,int xDst,int yDst,int dxDst,int dyDst) {
    ICDECOMPRESSEX ic;
    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;
    return ICSendMessage(hic,ICM_DECOMPRESSEX,(DWORD_PTR)&ic,sizeof(ic));
  }

  __CRT_INLINE LRESULT WINAPI ICDecompressExBegin(HIC hic,DWORD dwFlags,LPBITMAPINFOHEADER lpbiSrc,LPVOID lpSrc,int xSrc,int ySrc,int dxSrc,int dySrc,LPBITMAPINFOHEADER lpbiDst,LPVOID lpDst,int xDst,int yDst,int dxDst,int dyDst) {
    ICDECOMPRESSEX ic;
    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;
    return ICSendMessage(hic,ICM_DECOMPRESSEX_BEGIN,(DWORD_PTR)&ic,sizeof(ic));
  }

  __CRT_INLINE LRESULT WINAPI ICDecompressExQuery(HIC hic,DWORD dwFlags,LPBITMAPINFOHEADER lpbiSrc,LPVOID lpSrc,int xSrc,int ySrc,int dxSrc,int dySrc,LPBITMAPINFOHEADER lpbiDst,LPVOID lpDst,int xDst,int yDst,int dxDst,int dyDst) {
    ICDECOMPRESSEX ic;
    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;
    return ICSendMessage(hic,ICM_DECOMPRESSEX_QUERY,(DWORD_PTR)&ic,sizeof(ic));
  }
#endif /* !__CRT__NO_INLINE */

#define ICDecompressExEnd(hic) ICSendMessage(hic,ICM_DECOMPRESSEX_END,(DWORD_PTR)0,(DWORD_PTR)0)

#define ICDRAW_QUERY __MSABI_LONG(0x00000001)
#define ICDRAW_FULLSCREEN __MSABI_LONG(0x00000002)
#define ICDRAW_HDC __MSABI_LONG(0x00000004)

  DWORD WINAPIV ICDrawBegin(HIC hic,DWORD dwFlags,HPALETTE hpal,HWND hwnd,HDC hdc,int xDst,int yDst,int dxDst,int dyDst,LPBITMAPINFOHEADER lpbi,int xSrc,int ySrc,int dxSrc,int dySrc,DWORD dwRate,DWORD dwScale);

#define ICDRAW_HURRYUP __MSABI_LONG(0x80000000)
#define ICDRAW_UPDATE __MSABI_LONG(0x40000000)

  DWORD WINAPIV ICDraw(HIC hic,DWORD dwFlags,LPVOID lpFormat,LPVOID lpData,DWORD cbData,LONG lTime);

#ifndef __CRT__NO_INLINE
  __CRT_INLINE LRESULT WINAPI ICDrawSuggestFormat(HIC hic,LPBITMAPINFOHEADER lpbiIn,LPBITMAPINFOHEADER lpbiOut,int dxSrc,int dySrc,int dxDst,int dyDst,HIC hicDecomp) {
    ICDRAWSUGGEST ic;
    ic.lpbiIn = lpbiIn;
    ic.lpbiSuggest = lpbiOut;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;
    ic.hicDecompressor = hicDecomp;
    return ICSendMessage(hic,ICM_DRAW_SUGGESTFORMAT,(DWORD_PTR)&ic,sizeof(ic));
  }
#endif /* !__CRT__NO_INLINE */

#define ICDrawQuery(hic,lpbiInput) ICSendMessage(hic,ICM_DRAW_QUERY,(DWORD_PTR)(LPVOID)(lpbiInput),(DWORD)0)
#define ICDrawChangePalette(hic,lpbiInput) ICSendMessage(hic,ICM_DRAW_CHANGEPALETTE,(DWORD_PTR)(LPVOID)(lpbiInput),(DWORD)0)
#define ICGetBuffersWanted(hic,lpdwBuffers) ICSendMessage(hic,ICM_GETBUFFERSWANTED,(DWORD_PTR)(LPVOID)(lpdwBuffers),(DWORD_PTR)0)
#define ICDrawEnd(hic) ICSendMessage(hic,ICM_DRAW_END,(DWORD_PTR)0,(DWORD_PTR)0)
#define ICDrawStart(hic) ICSendMessage(hic,ICM_DRAW_START,(DWORD_PTR)0,(DWORD_PTR)0)
#define ICDrawStartPlay(hic,lFrom,lTo) ICSendMessage(hic,ICM_DRAW_START_PLAY,(DWORD_PTR)(lFrom),(DWORD_PTR)(lTo))
#define ICDrawStop(hic) ICSendMessage(hic,ICM_DRAW_STOP,(DWORD_PTR)0,(DWORD_PTR)0)
#define ICDrawStopPlay(hic) ICSendMessage(hic,ICM_DRAW_STOP_PLAY,(DWORD_PTR)0,(DWORD_PTR)0)
#define ICDrawGetTime(hic,lplTime) ICSendMessage(hic,ICM_DRAW_GETTIME,(DWORD_PTR)(LPVOID)(lplTime),(DWORD_PTR)0)
#define ICDrawSetTime(hic,lTime) ICSendMessage(hic,ICM_DRAW_SETTIME,(DWORD_PTR)lTime,(DWORD_PTR)0)
#define ICDrawRealize(hic,hdc,fBackground) ICSendMessage(hic,ICM_DRAW_REALIZE,(DWORD_PTR)(UINT_PTR)(HDC)(hdc),(DWORD_PTR)(WINBOOL)(fBackground))
#define ICDrawFlush(hic) ICSendMessage(hic,ICM_DRAW_FLUSH,(DWORD_PTR)0,(DWORD_PTR)0)
#define ICDrawRenderBuffer(hic) ICSendMessage(hic,ICM_DRAW_RENDERBUFFER,(DWORD_PTR)0,(DWORD_PTR)0)

#ifndef __CRT__NO_INLINE
  __CRT_INLINE LRESULT WINAPI ICSetStatusProc(HIC hic,DWORD dwFlags,LRESULT lParam,LONG (CALLBACK *fpfnStatus)(LPARAM,UINT,LONG)) {
    ICSETSTATUSPROC ic;
    ic.dwFlags = dwFlags;
    ic.lParam = lParam;
    ic.Status = fpfnStatus;
    return ICSendMessage(hic,ICM_SET_STATUS_PROC,(DWORD_PTR)&ic,sizeof(ic));
  }
#endif /* !__CRT__NO_INLINE */

#define ICDecompressOpen(fccType,fccHandler,lpbiIn,lpbiOut) ICLocate(fccType,fccHandler,lpbiIn,lpbiOut,ICMODE_DECOMPRESS)
#define ICDrawOpen(fccType,fccHandler,lpbiIn) ICLocate(fccType,fccHandler,lpbiIn,NULL,ICMODE_DRAW)

  HIC WINAPI ICLocate(DWORD fccType,DWORD fccHandler,LPBITMAPINFOHEADER lpbiIn,LPBITMAPINFOHEADER lpbiOut,WORD wFlags);
  HIC WINAPI ICGetDisplayFormat(HIC hic,LPBITMAPINFOHEADER lpbiIn,LPBITMAPINFOHEADER lpbiOut,int BitDepth,int dx,int dy);
  HANDLE WINAPI ICImageCompress(HIC hic,UINT uiFlags,LPBITMAPINFO lpbiIn,LPVOID lpBits,LPBITMAPINFO lpbiOut,LONG lQuality,LONG *plSize);
  HANDLE WINAPI ICImageDecompress(HIC hic,UINT uiFlags,LPBITMAPINFO lpbiIn,LPVOID lpBits,LPBITMAPINFO lpbiOut);

  typedef struct {
    LONG cbSize;
    DWORD dwFlags;
    HIC hic;
    DWORD fccType;
    DWORD fccHandler;
    LPBITMAPINFO lpbiIn;
    LPBITMAPINFO lpbiOut;
    LPVOID lpBitsOut;
    LPVOID lpBitsPrev;
    LONG lFrame;
    LONG lKey;
    LONG lDataRate;
    LONG lQ;
    LONG lKeyCount;
    LPVOID lpState;
    LONG cbState;
  } COMPVARS,*PCOMPVARS;

#define ICMF_COMPVARS_VALID 0x00000001

  WINBOOL WINAPI ICCompressorChoose(HWND hwnd,UINT uiFlags,LPVOID pvIn,LPVOID lpData,PCOMPVARS pc,LPSTR lpszTitle);

#define ICMF_CHOOSE_KEYFRAME 0x0001
#define ICMF_CHOOSE_DATARATE 0x0002
#define ICMF_CHOOSE_PREVIEW 0x0004
#define ICMF_CHOOSE_ALLCOMPRESSORS 0x0008

  WINBOOL WINAPI ICSeqCompressFrameStart(PCOMPVARS pc,LPBITMAPINFO lpbiIn);
  void WINAPI ICSeqCompressFrameEnd(PCOMPVARS pc);
  LPVOID WINAPI ICSeqCompressFrame(PCOMPVARS pc,UINT uiFlags,LPVOID lpBits,WINBOOL *pfKey,LONG *plSize);
  void WINAPI ICCompressorFree(PCOMPVARS pc);
#endif

#ifndef NODRAWDIB

  typedef HANDLE HDRAWDIB;

#define DDF_0001 0x0001
#define DDF_UPDATE 0x0002
#define DDF_SAME_HDC 0x0004
#define DDF_SAME_DRAW 0x0008
#define DDF_DONTDRAW 0x0010
#define DDF_ANIMATE 0x0020
#define DDF_BUFFER 0x0040
#define DDF_JUSTDRAWIT 0x0080
#define DDF_FULLSCREEN 0x0100
#define DDF_BACKGROUNDPAL 0x0200
#define DDF_NOTKEYFRAME 0x0400
#define DDF_HURRYUP 0x0800
#define DDF_HALFTONE 0x1000
#define DDF_2000 0x2000

#define DDF_PREROLL DDF_DONTDRAW
#define DDF_SAME_DIB DDF_SAME_DRAW
#define DDF_SAME_SIZE DDF_SAME_DRAW

  extern WINBOOL WINAPI DrawDibInit(void);
  extern HDRAWDIB WINAPI DrawDibOpen(void);
  extern WINBOOL WINAPI DrawDibClose(HDRAWDIB hdd);
  extern LPVOID WINAPI DrawDibGetBuffer(HDRAWDIB hdd,LPBITMAPINFOHEADER lpbi,DWORD dwSize,DWORD dwFlags);
  extern UINT WINAPI DrawDibError(HDRAWDIB hdd);
  extern HPALETTE WINAPI DrawDibGetPalette(HDRAWDIB hdd);
  extern WINBOOL WINAPI DrawDibSetPalette(HDRAWDIB hdd,HPALETTE hpal);
  extern WINBOOL WINAPI DrawDibChangePalette(HDRAWDIB hdd,int iStart,int iLen,LPPALETTEENTRY lppe);
  extern UINT WINAPI DrawDibRealize(HDRAWDIB hdd,HDC hdc,WINBOOL fBackground);
  extern WINBOOL WINAPI DrawDibStart(HDRAWDIB hdd,DWORD rate);
  extern WINBOOL WINAPI DrawDibStop(HDRAWDIB hdd);
  extern WINBOOL WINAPI DrawDibBegin(HDRAWDIB hdd,HDC hdc,int dxDst,int dyDst,LPBITMAPINFOHEADER lpbi,int dxSrc,int dySrc,UINT wFlags);
  extern WINBOOL WINAPI DrawDibDraw(HDRAWDIB hdd,HDC hdc,int xDst,int yDst,int dxDst,int dyDst,LPBITMAPINFOHEADER lpbi,LPVOID lpBits,int xSrc,int ySrc,int dxSrc,int dySrc,UINT wFlags);

#define DrawDibUpdate(hdd,hdc,x,y) DrawDibDraw(hdd,hdc,x,y,0,0,NULL,NULL,0,0,0,0,DDF_UPDATE)

  extern WINBOOL WINAPI DrawDibEnd(HDRAWDIB hdd);

  typedef struct {
    LONG timeCount;
    LONG timeDraw;
    LONG timeDecompress;
    LONG timeDither;
    LONG timeStretch;
    LONG timeBlt;
    LONG timeSetDIBits;
  } DRAWDIBTIME,*LPDRAWDIBTIME;

  WINBOOL WINAPI DrawDibTime(HDRAWDIB hdd,LPDRAWDIBTIME lpddtime);

#define PD_CAN_DRAW_DIB 0x0001
#define PD_CAN_STRETCHDIB 0x0002
#define PD_STRETCHDIB_1_1_OK 0x0004
#define PD_STRETCHDIB_1_2_OK 0x0008
#define PD_STRETCHDIB_1_N_OK 0x0010

  LRESULT WINAPI DrawDibProfileDisplay(LPBITMAPINFOHEADER lpbi);

#ifdef DRAWDIB_INCLUDE_STRETCHDIB
  void WINAPI StretchDIB(LPBITMAPINFOHEADER biDst,LPVOID lpDst,int DstX,int DstY,int DstXE,int DstYE,LPBITMAPINFOHEADER biSrc,LPVOID lpSrc,int SrcX,int SrcY,int SrcXE,int SrcYE);
#endif
#endif

#ifndef NOAVIFMT
#ifndef _INC_MMSYSTEM
  typedef DWORD FOURCC;
#endif

/* This part of the file is duplicated in avifmt.h */
#ifndef mmioFOURCC
#define mmioFOURCC(ch0,ch1,ch2,ch3) ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) | ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24))
#endif

#ifndef aviTWOCC
#define aviTWOCC(ch0,ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

  typedef WORD TWOCC;

#define formtypeAVI mmioFOURCC('A','V','I',' ')
#define listtypeAVIHEADER mmioFOURCC('h','d','r','l')
#define ckidAVIMAINHDR mmioFOURCC('a','v','i','h')
#define listtypeSTREAMHEADER mmioFOURCC('s','t','r','l')
#define ckidSTREAMHEADER mmioFOURCC('s','t','r','h')
#define ckidSTREAMFORMAT mmioFOURCC('s','t','r','f')
#define ckidSTREAMHANDLERDATA mmioFOURCC('s','t','r','d')
#define ckidSTREAMNAME mmioFOURCC('s','t','r','n')

#define listtypeAVIMOVIE mmioFOURCC('m','o','v','i')
#define listtypeAVIRECORD mmioFOURCC('r','e','c',' ')

#define ckidAVINEWINDEX mmioFOURCC('i','d','x','1')

#define streamtypeANY __MSABI_LONG(0U)
#define streamtypeVIDEO mmioFOURCC('v','i','d','s')
#define streamtypeAUDIO mmioFOURCC('a','u','d','s')
#define streamtypeMIDI mmioFOURCC('m','i','d','s')
#define streamtypeTEXT mmioFOURCC('t','x','t','s')

#define cktypeDIBbits aviTWOCC('d','b')
#define cktypeDIBcompressed aviTWOCC('d','c')
#define cktypePALchange aviTWOCC('p','c')
#define cktypeWAVEbytes aviTWOCC('w','b')

#define ckidAVIPADDING mmioFOURCC('J','U','N','K')

#define FromHex(n) (((n) >= 'A') ? ((n) + 10 - 'A') : ((n) - '0'))
#define StreamFromFOURCC(fcc) ((WORD) ((FromHex(LOBYTE(LOWORD(fcc))) << 4) + (FromHex(HIBYTE(LOWORD(fcc))))))

#define TWOCCFromFOURCC(fcc) HIWORD(fcc)

#define ToHex(n) ((BYTE) (((n) > 9) ? ((n) - 10 + 'A') : ((n) + '0')))
#define MAKEAVICKID(tcc,stream) MAKELONG((ToHex((stream) & 0x0f) << 8) | (ToHex(((stream) & 0xf0) >> 4)),tcc)

#define AVIF_HASINDEX 0x00000010
#define AVIF_MUSTUSEINDEX 0x00000020
#define AVIF_ISINTERLEAVED 0x00000100
#define AVIF_TRUSTCKTYPE 0x00000800
#define AVIF_WASCAPTUREFILE 0x00010000
#define AVIF_COPYRIGHTED 0x00020000

#define AVI_HEADERSIZE 2048

  typedef struct {
    DWORD dwMicroSecPerFrame;
    DWORD dwMaxBytesPerSec;
    DWORD dwPaddingGranularity;
    DWORD dwFlags;
    DWORD dwTotalFrames;
    DWORD dwInitialFrames;
    DWORD dwStreams;
    DWORD dwSuggestedBufferSize;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwReserved[4];
  } MainAVIHeader;

#define AVISF_DISABLED 0x00000001
#define AVISF_VIDEO_PALCHANGES 0x00010000

  typedef struct {
    FOURCC fccType;
    FOURCC fccHandler;
    DWORD dwFlags;
    WORD wPriority;
    WORD wLanguage;
    DWORD dwInitialFrames;
    DWORD dwScale;
    DWORD dwRate;
    DWORD dwStart;
    DWORD dwLength;
    DWORD dwSuggestedBufferSize;
    DWORD dwQuality;
    DWORD dwSampleSize;
    RECT rcFrame;
  } AVIStreamHeader;

#define AVIIF_LIST __MSABI_LONG(0x00000001)
#define AVIIF_KEYFRAME __MSABI_LONG(0x00000010)
#define AVIIF_FIRSTPART __MSABI_LONG(0x00000020)
#define AVIIF_LASTPART __MSABI_LONG(0x00000040)
#define AVIIF_MIDPART (AVIIF_LASTPART|AVIIF_FIRSTPART)

#define AVIIF_NOTIME __MSABI_LONG(0x00000100)
#define AVIIF_COMPUSE __MSABI_LONG(0x0FFF0000)

  typedef struct {
    DWORD ckid;
    DWORD dwFlags;
    DWORD dwChunkOffset;
    DWORD dwChunkLength;
  } AVIINDEXENTRY;

  typedef struct {
    BYTE bFirstEntry;
    BYTE bNumEntries;
    WORD wFlags;
    PALETTEENTRY peNew[];
  } AVIPALCHANGE;
#endif
/* End of duplication */

#ifdef __cplusplus
}
#endif

#ifndef RC_INVOKED
#include "pshpack8.h"
#endif

#ifndef NOMMREG
#include <mmreg.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NOAVIFILE
#ifndef mmioFOURCC
#define mmioFOURCC(ch0,ch1,ch2,ch3) ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) | ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24))
#endif

#ifndef streamtypeVIDEO
#define streamtypeANY __MSABI_LONG(0U)
#define streamtypeVIDEO mmioFOURCC('v','i','d','s')
#define streamtypeAUDIO mmioFOURCC('a','u','d','s')
#define streamtypeMIDI mmioFOURCC('m','i','d','s')
#define streamtypeTEXT mmioFOURCC('t','x','t','s')
#endif

#ifndef AVIIF_KEYFRAME
#define AVIIF_KEYFRAME __MSABI_LONG(0x00000010)
#endif

#define AVIGETFRAMEF_BESTDISPLAYFMT 1

  typedef struct _AVISTREAMINFOW {
    DWORD fccType;
    DWORD fccHandler;
    DWORD dwFlags;
    DWORD dwCaps;
    WORD wPriority;
    WORD wLanguage;
    DWORD dwScale;
    DWORD dwRate;
    DWORD dwStart;
    DWORD dwLength;
    DWORD dwInitialFrames;
    DWORD dwSuggestedBufferSize;
    DWORD dwQuality;
    DWORD dwSampleSize;
    RECT rcFrame;
    DWORD dwEditCount;
    DWORD dwFormatChangeCount;
    WCHAR szName[64];
  } AVISTREAMINFOW,*LPAVISTREAMINFOW;

  typedef struct _AVISTREAMINFOA {
    DWORD fccType;
    DWORD fccHandler;
    DWORD dwFlags;
    DWORD dwCaps;
    WORD wPriority;
    WORD wLanguage;
    DWORD dwScale;
    DWORD dwRate;
    DWORD dwStart;
    DWORD dwLength;
    DWORD dwInitialFrames;
    DWORD dwSuggestedBufferSize;
    DWORD dwQuality;
    DWORD dwSampleSize;
    RECT rcFrame;
    DWORD dwEditCount;
    DWORD dwFormatChangeCount;
    char szName[64];
  } AVISTREAMINFOA,*LPAVISTREAMINFOA;

#define AVISTREAMINFO __MINGW_NAME_AW(AVISTREAMINFO)
#define LPAVISTREAMINFO __MINGW_NAME_AW(LPAVISTREAMINFO)

#define AVISTREAMINFO_DISABLED 0x00000001
#define AVISTREAMINFO_FORMATCHANGES 0x00010000

  typedef struct _AVIFILEINFOW {
    DWORD dwMaxBytesPerSec;
    DWORD dwFlags;
    DWORD dwCaps;
    DWORD dwStreams;
    DWORD dwSuggestedBufferSize;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwScale;
    DWORD dwRate;
    DWORD dwLength;
    DWORD dwEditCount;
    WCHAR szFileType[64];
  } AVIFILEINFOW,*LPAVIFILEINFOW;

  typedef struct _AVIFILEINFOA {
    DWORD dwMaxBytesPerSec;
    DWORD dwFlags;
    DWORD dwCaps;
    DWORD dwStreams;
    DWORD dwSuggestedBufferSize;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwScale;
    DWORD dwRate;
    DWORD dwLength;
    DWORD dwEditCount;
    char szFileType[64];
  } AVIFILEINFOA,*LPAVIFILEINFOA;

#define AVIFILEINFO __MINGW_NAME_AW(AVIFILEINFO)
#define LPAVIFILEINFO __MINGW_NAME_AW(LPAVIFILEINFO)

#define AVIFILEINFO_HASINDEX 0x00000010
#define AVIFILEINFO_MUSTUSEINDEX 0x00000020
#define AVIFILEINFO_ISINTERLEAVED 0x00000100
#define AVIFILEINFO_TRUSTCKTYPE 0x00000800
#define AVIFILEINFO_WASCAPTUREFILE 0x00010000
#define AVIFILEINFO_COPYRIGHTED 0x00020000

#define AVIFILECAPS_CANREAD 0x00000001
#define AVIFILECAPS_CANWRITE 0x00000002
#define AVIFILECAPS_ALLKEYFRAMES 0x00000010
#define AVIFILECAPS_NOCOMPRESSION 0x00000020

  typedef WINBOOL (WINAPI *AVISAVECALLBACK)(int);

  typedef struct {
    DWORD fccType;
    DWORD fccHandler;
    DWORD dwKeyFrameEvery;
    DWORD dwQuality;
    DWORD dwBytesPerSecond;
    DWORD dwFlags;
    LPVOID lpFormat;
    DWORD cbFormat;
    LPVOID lpParms;
    DWORD cbParms;
    DWORD dwInterleaveEvery;
  } AVICOMPRESSOPTIONS, FAR *LPAVICOMPRESSOPTIONS;

#define AVICOMPRESSF_INTERLEAVE 0x00000001
#define AVICOMPRESSF_DATARATE 0x00000002
#define AVICOMPRESSF_KEYFRAMES 0x00000004
#define AVICOMPRESSF_VALID 0x00000008

#ifdef __cplusplus
}
#endif

#include <ole2.h>

#ifdef __cplusplus
extern "C" {
#endif

#undef INTERFACE
#define INTERFACE IAVIStream
  DECLARE_INTERFACE_(IAVIStream,IUnknown) {
    STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Create) (THIS_ LPARAM lParam1,LPARAM lParam2) PURE;
    STDMETHOD(Info) (THIS_ AVISTREAMINFOW *psi,LONG lSize) PURE;
    STDMETHOD_(LONG,FindSample)(THIS_ LONG lPos,LONG lFlags) PURE;
    STDMETHOD(ReadFormat) (THIS_ LONG lPos,LPVOID lpFormat,LONG *lpcbFormat) PURE;
    STDMETHOD(SetFormat) (THIS_ LONG lPos,LPVOID lpFormat,LONG cbFormat) PURE;
    STDMETHOD(Read) (THIS_ LONG lStart,LONG lSamples,LPVOID lpBuffer,LONG cbBuffer,LONG *plBytes,LONG *plSamples) PURE;
    STDMETHOD(Write) (THIS_ LONG lStart,LONG lSamples,LPVOID lpBuffer,LONG cbBuffer,DWORD dwFlags,LONG *plSampWritten,LONG *plBytesWritten) PURE;
    STDMETHOD(Delete) (THIS_ LONG lStart,LONG lSamples) PURE;
    STDMETHOD(ReadData) (THIS_ DWORD fcc,LPVOID lp,LONG *lpcb) PURE;
    STDMETHOD(WriteData) (THIS_ DWORD fcc,LPVOID lp,LONG cb) PURE;
    STDMETHOD(SetInfo) (THIS_ AVISTREAMINFOW *lpInfo,LONG cbInfo) PURE;
  };

  typedef IAVIStream *PAVISTREAM;

#undef INTERFACE
#define INTERFACE IAVIStreaming
  DECLARE_INTERFACE_(IAVIStreaming,IUnknown) {
    STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Begin) (THIS_ LONG lStart,LONG lEnd,LONG lRate) PURE;
    STDMETHOD(End) (THIS) PURE;
  };

  typedef IAVIStreaming *PAVISTREAMING;

#undef INTERFACE
#define INTERFACE IAVIEditStream
  DECLARE_INTERFACE_(IAVIEditStream,IUnknown) {
    STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Cut) (THIS_ LONG *plStart,LONG *plLength,PAVISTREAM *ppResult) PURE;
    STDMETHOD(Copy) (THIS_ LONG *plStart,LONG *plLength,PAVISTREAM *ppResult) PURE;
    STDMETHOD(Paste) (THIS_ LONG *plPos,LONG *plLength,PAVISTREAM pstream,LONG lStart,LONG lEnd) PURE;
    STDMETHOD(Clone) (THIS_ PAVISTREAM *ppResult) PURE;
    STDMETHOD(SetInfo) (THIS_ AVISTREAMINFOW *lpInfo,LONG cbInfo) PURE;
  };

  typedef IAVIEditStream *PAVIEDITSTREAM;

#undef INTERFACE
#define INTERFACE IAVIPersistFile
  DECLARE_INTERFACE_(IAVIPersistFile,IPersistFile) {
    STDMETHOD(Reserved1)(THIS) PURE;
  };

  typedef IAVIPersistFile *PAVIPERSISTFILE;

#undef INTERFACE
#define INTERFACE IAVIFile
#define PAVIFILE IAVIFile *
  DECLARE_INTERFACE_(IAVIFile,IUnknown) {
    STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Info) (THIS_ AVIFILEINFOW *pfi,LONG lSize) PURE;
    STDMETHOD(GetStream) (THIS_ PAVISTREAM *ppStream,DWORD fccType,LONG lParam) PURE;
    STDMETHOD(CreateStream) (THIS_ PAVISTREAM *ppStream,AVISTREAMINFOW *psi) PURE;
    STDMETHOD(WriteData) (THIS_ DWORD ckid,LPVOID lpData,LONG cbData) PURE;
    STDMETHOD(ReadData) (THIS_ DWORD ckid,LPVOID lpData,LONG *lpcbData) PURE;
    STDMETHOD(EndRecord) (THIS) PURE;
    STDMETHOD(DeleteStream) (THIS_ DWORD fccType,LONG lParam) PURE;
  };

#undef PAVIFILE
  typedef IAVIFile *PAVIFILE;

#undef INTERFACE
#define INTERFACE IGetFrame
#define PGETFRAME IGetFrame *
  DECLARE_INTERFACE_(IGetFrame,IUnknown) {
    STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD_(LPVOID,GetFrame) (THIS_ LONG lPos) PURE;
    STDMETHOD(Begin) (THIS_ LONG lStart,LONG lEnd,LONG lRate) PURE;
    STDMETHOD(End) (THIS) PURE;
    STDMETHOD(SetFormat) (THIS_ LPBITMAPINFOHEADER lpbi,LPVOID lpBits,int x,int y,int dx,int dy) PURE;
  };

#undef PGETFRAME
  typedef IGetFrame *PGETFRAME;

#define DEFINE_AVIGUID(name,l,w1,w2) DEFINE_GUID(name,l,w1,w2,0xC0,0,0,0,0,0,0,0x46)

  DEFINE_AVIGUID(IID_IAVIFile,0x00020020,0,0);
  DEFINE_AVIGUID(IID_IAVIStream,0x00020021,0,0);
  DEFINE_AVIGUID(IID_IAVIStreaming,0x00020022,0,0);
  DEFINE_AVIGUID(IID_IGetFrame,0x00020023,0,0);
  DEFINE_AVIGUID(IID_IAVIEditStream,0x00020024,0,0);
  DEFINE_AVIGUID(IID_IAVIPersistFile,0x00020025,0,0);
#if !defined(UNICODE)
  DEFINE_AVIGUID(CLSID_AVISimpleUnMarshal,0x00020009,0,0);
#endif

  DEFINE_AVIGUID(CLSID_AVIFile,0x00020000,0,0);

#define AVIFILEHANDLER_CANREAD 0x0001
#define AVIFILEHANDLER_CANWRITE 0x0002
#define AVIFILEHANDLER_CANACCEPTNONRGB 0x0004

#define AVIFileOpen __MINGW_NAME_AW(AVIFileOpen)
#define AVIFileInfo __MINGW_NAME_AW(AVIFileInfo)
#define AVIFileCreateStream __MINGW_NAME_AW(AVIFileCreateStream)
#define AVIStreamInfo __MINGW_NAME_AW(AVIStreamInfo)
#define AVIStreamOpenFromFile __MINGW_NAME_AW(AVIStreamOpenFromFile)

  STDAPI_(void) AVIFileInit(void);
  STDAPI_(void) AVIFileExit(void);
  STDAPI_(ULONG) AVIFileAddRef (PAVIFILE pfile);
  STDAPI_(ULONG) AVIFileRelease (PAVIFILE pfile);
  STDAPI AVIFileOpenA (PAVIFILE *ppfile,LPCSTR szFile,UINT uMode,LPCLSID lpHandler);
  STDAPI AVIFileOpenW (PAVIFILE *ppfile,LPCWSTR szFile,UINT uMode,LPCLSID lpHandler);
  STDAPI AVIFileInfoW (PAVIFILE pfile,LPAVIFILEINFOW pfi,LONG lSize);
  STDAPI AVIFileInfoA (PAVIFILE pfile,LPAVIFILEINFOA pfi,LONG lSize);
  STDAPI AVIFileGetStream (PAVIFILE pfile,PAVISTREAM *ppavi,DWORD fccType,LONG lParam);
  STDAPI AVIFileCreateStreamW (PAVIFILE pfile,PAVISTREAM *ppavi,AVISTREAMINFOW *psi);
  STDAPI AVIFileCreateStreamA (PAVIFILE pfile,PAVISTREAM *ppavi,AVISTREAMINFOA *psi);
  STDAPI AVIFileWriteData (PAVIFILE pfile,DWORD ckid,LPVOID lpData,LONG cbData);
  STDAPI AVIFileReadData (PAVIFILE pfile,DWORD ckid,LPVOID lpData,LONG *lpcbData);
  STDAPI AVIFileEndRecord (PAVIFILE pfile);
  STDAPI_(ULONG) AVIStreamAddRef (PAVISTREAM pavi);
  STDAPI_(ULONG) AVIStreamRelease (PAVISTREAM pavi);
  STDAPI AVIStreamInfoW (PAVISTREAM pavi,LPAVISTREAMINFOW psi,LONG lSize);
  STDAPI AVIStreamInfoA (PAVISTREAM pavi,LPAVISTREAMINFOA psi,LONG lSize);
  STDAPI_(LONG) AVIStreamFindSample(PAVISTREAM pavi,LONG lPos,LONG lFlags);
  STDAPI AVIStreamReadFormat (PAVISTREAM pavi,LONG lPos,LPVOID lpFormat,LONG *lpcbFormat);
  STDAPI AVIStreamSetFormat (PAVISTREAM pavi,LONG lPos,LPVOID lpFormat,LONG cbFormat);
  STDAPI AVIStreamReadData (PAVISTREAM pavi,DWORD fcc,LPVOID lp,LONG *lpcb);
  STDAPI AVIStreamWriteData (PAVISTREAM pavi,DWORD fcc,LPVOID lp,LONG cb);
  STDAPI AVIStreamRead (PAVISTREAM pavi,LONG lStart,LONG lSamples,LPVOID lpBuffer,LONG cbBuffer,LONG *plBytes,LONG *plSamples);
#define AVISTREAMREAD_CONVENIENT (__MSABI_LONG(-1))
  STDAPI AVIStreamWrite (PAVISTREAM pavi,LONG lStart,LONG lSamples,LPVOID lpBuffer,LONG cbBuffer,DWORD dwFlags,LONG *plSampWritten,LONG *plBytesWritten);
  STDAPI_(LONG) AVIStreamStart (PAVISTREAM pavi);
  STDAPI_(LONG) AVIStreamLength (PAVISTREAM pavi);
  STDAPI_(LONG) AVIStreamTimeToSample (PAVISTREAM pavi,LONG lTime);
  STDAPI_(LONG) AVIStreamSampleToTime (PAVISTREAM pavi,LONG lSample);
  STDAPI AVIStreamBeginStreaming(PAVISTREAM pavi,LONG lStart,LONG lEnd,LONG lRate);
  STDAPI AVIStreamEndStreaming(PAVISTREAM pavi);
  STDAPI_(PGETFRAME) AVIStreamGetFrameOpen(PAVISTREAM pavi,LPBITMAPINFOHEADER lpbiWanted);
  STDAPI_(LPVOID) AVIStreamGetFrame(PGETFRAME pg,LONG lPos);
  STDAPI AVIStreamGetFrameClose(PGETFRAME pg);
  STDAPI AVIStreamOpenFromFileA(PAVISTREAM *ppavi,LPCSTR szFile,DWORD fccType,LONG lParam,UINT mode,CLSID *pclsidHandler);
  STDAPI AVIStreamOpenFromFileW(PAVISTREAM *ppavi,LPCWSTR szFile,DWORD fccType,LONG lParam,UINT mode,CLSID *pclsidHandler);
  STDAPI AVIStreamCreate(PAVISTREAM *ppavi,LONG lParam1,LONG lParam2,CLSID *pclsidHandler);

#define FIND_DIR __MSABI_LONG(0x0000000F)
#define FIND_NEXT __MSABI_LONG(0x00000001)
#define FIND_PREV __MSABI_LONG(0x00000004)
#define FIND_FROM_START __MSABI_LONG(0x00000008)

#define FIND_TYPE __MSABI_LONG(0x000000F0)
#define FIND_KEY __MSABI_LONG(0x00000010)
#define FIND_ANY __MSABI_LONG(0x00000020)
#define FIND_FORMAT __MSABI_LONG(0x00000040)

#define FIND_RET __MSABI_LONG(0x0000F000)
#define FIND_POS __MSABI_LONG(0x00000000)
#define FIND_LENGTH __MSABI_LONG(0x00001000)
#define FIND_OFFSET __MSABI_LONG(0x00002000)
#define FIND_SIZE __MSABI_LONG(0x00003000)
#define FIND_INDEX __MSABI_LONG(0x00004000)

#define AVIStreamFindKeyFrame AVIStreamFindSample
#define FindKeyFrame FindSample

#define AVIStreamClose AVIStreamRelease
#define AVIFileClose AVIFileRelease
#define AVIStreamInit AVIFileInit
#define AVIStreamExit AVIFileExit

#define SEARCH_NEAREST FIND_PREV
#define SEARCH_BACKWARD FIND_PREV
#define SEARCH_FORWARD FIND_NEXT
#define SEARCH_KEY FIND_KEY
#define SEARCH_ANY FIND_ANY

#define AVIStreamSampleToSample(pavi1,pavi2,l) AVIStreamTimeToSample(pavi1,AVIStreamSampleToTime(pavi2,l))
#define AVIStreamNextSample(pavi,l) AVIStreamFindSample(pavi,l+1,FIND_NEXT|FIND_ANY)
#define AVIStreamPrevSample(pavi,l) AVIStreamFindSample(pavi,l-1,FIND_PREV|FIND_ANY)
#define AVIStreamNearestSample(pavi,l) AVIStreamFindSample(pavi,l,FIND_PREV|FIND_ANY)
#define AVIStreamNextKeyFrame(pavi,l) AVIStreamFindSample(pavi,l+1,FIND_NEXT|FIND_KEY)
#define AVIStreamPrevKeyFrame(pavi,l) AVIStreamFindSample(pavi,l-1,FIND_PREV|FIND_KEY)
#define AVIStreamNearestKeyFrame(pavi,l) AVIStreamFindSample(pavi,l,FIND_PREV|FIND_KEY)
#define AVIStreamIsKeyFrame(pavi,l) (AVIStreamNearestKeyFrame(pavi,l)==l)
#define AVIStreamPrevSampleTime(pavi,t) AVIStreamSampleToTime(pavi,AVIStreamPrevSample(pavi,AVIStreamTimeToSample(pavi,t)))
#define AVIStreamNextSampleTime(pavi,t) AVIStreamSampleToTime(pavi,AVIStreamNextSample(pavi,AVIStreamTimeToSample(pavi,t)))
#define AVIStreamNearestSampleTime(pavi,t) AVIStreamSampleToTime(pavi,AVIStreamNearestSample(pavi,AVIStreamTimeToSample(pavi,t)))
#define AVIStreamNextKeyFrameTime(pavi,t) AVIStreamSampleToTime(pavi,AVIStreamNextKeyFrame(pavi,AVIStreamTimeToSample(pavi,t)))
#define AVIStreamPrevKeyFrameTime(pavi,t) AVIStreamSampleToTime(pavi,AVIStreamPrevKeyFrame(pavi,AVIStreamTimeToSample(pavi,t)))
#define AVIStreamNearestKeyFrameTime(pavi,t) AVIStreamSampleToTime(pavi,AVIStreamNearestKeyFrame(pavi,AVIStreamTimeToSample(pavi,t)))
#define AVIStreamStartTime(pavi) AVIStreamSampleToTime(pavi,AVIStreamStart(pavi))
#define AVIStreamLengthTime(pavi) AVIStreamSampleToTime(pavi,AVIStreamLength(pavi))
#define AVIStreamEnd(pavi) (AVIStreamStart(pavi) + AVIStreamLength(pavi))
#define AVIStreamEndTime(pavi) AVIStreamSampleToTime(pavi,AVIStreamEnd(pavi))
#define AVIStreamSampleSize(pavi,lPos,plSize) AVIStreamRead(pavi,lPos,1,NULL,(LONG)0,plSize,NULL)
#define AVIStreamFormatSize(pavi,lPos,plSize) AVIStreamReadFormat(pavi,lPos,NULL,plSize)
#define AVIStreamDataSize(pavi,fcc,plSize) AVIStreamReadData(pavi,fcc,NULL,plSize)

#define AVStreamNextKeyFrame(pavi,pos) AVIStreamFindSample(pavi, pos + 1, FIND_NEXT | FIND_KEY)
#define AVStreamPrevKeyFrame(pavi,pos) AVIStreamFindSample(pavi, pos - 1, FIND_NEXT | FIND_KEY)

#ifndef comptypeDIB
#define comptypeDIB mmioFOURCC('D','I','B',' ')
#endif

#define AVISave __MINGW_NAME_AW(AVISave)
#define AVISaveV __MINGW_NAME_AW(AVISaveV)
#define AVIBuildFilter __MINGW_NAME_AW(AVIBuildFilter)
#define EditStreamSetInfo __MINGW_NAME_AW(EditStreamSetInfo)
#define EditStreamSetName __MINGW_NAME_AW(EditStreamSetName)

  STDAPI AVIMakeCompressedStream(PAVISTREAM *ppsCompressed,PAVISTREAM ppsSource,AVICOMPRESSOPTIONS *lpOptions,CLSID *pclsidHandler);
  EXTERN_C HRESULT CDECL AVISaveA (LPCSTR szFile,CLSID *pclsidHandler,AVISAVECALLBACK lpfnCallback,int nStreams,PAVISTREAM pfile,LPAVICOMPRESSOPTIONS lpOptions,...);
  STDAPI AVISaveVA(LPCSTR szFile,CLSID *pclsidHandler,AVISAVECALLBACK lpfnCallback,int nStreams,PAVISTREAM *ppavi,LPAVICOMPRESSOPTIONS *plpOptions);
  EXTERN_C HRESULT CDECL AVISaveW (LPCWSTR szFile,CLSID *pclsidHandler,AVISAVECALLBACK lpfnCallback,int nStreams,PAVISTREAM pfile,LPAVICOMPRESSOPTIONS lpOptions,...);
  STDAPI AVISaveVW(LPCWSTR szFile,CLSID *pclsidHandler,AVISAVECALLBACK lpfnCallback,int nStreams,PAVISTREAM *ppavi,LPAVICOMPRESSOPTIONS *plpOptions);
  STDAPI_(INT_PTR) AVISaveOptions(HWND hwnd,UINT uiFlags,int nStreams,PAVISTREAM *ppavi,LPAVICOMPRESSOPTIONS *plpOptions);
  STDAPI AVISaveOptionsFree(int nStreams,LPAVICOMPRESSOPTIONS *plpOptions);
  STDAPI AVIBuildFilterW(LPWSTR lpszFilter,LONG cbFilter,WINBOOL fSaving);
  STDAPI AVIBuildFilterA(LPSTR lpszFilter,LONG cbFilter,WINBOOL fSaving);
  STDAPI AVIMakeFileFromStreams(PAVIFILE *ppfile,int nStreams,PAVISTREAM *papStreams);
  STDAPI AVIMakeStreamFromClipboard(UINT cfFormat,HANDLE hGlobal,PAVISTREAM *ppstream);
  STDAPI AVIPutFileOnClipboard(PAVIFILE pf);
  STDAPI AVIGetFromClipboard(PAVIFILE *lppf);
  STDAPI AVIClearClipboard(void);
  STDAPI CreateEditableStream(PAVISTREAM *ppsEditable,PAVISTREAM psSource);
  STDAPI EditStreamCut(PAVISTREAM pavi,LONG *plStart,LONG *plLength,PAVISTREAM *ppResult);
  STDAPI EditStreamCopy(PAVISTREAM pavi,LONG *plStart,LONG *plLength,PAVISTREAM *ppResult);
  STDAPI EditStreamPaste(PAVISTREAM pavi,LONG *plPos,LONG *plLength,PAVISTREAM pstream,LONG lStart,LONG lEnd);
  STDAPI EditStreamClone(PAVISTREAM pavi,PAVISTREAM *ppResult);
  STDAPI EditStreamSetNameA(PAVISTREAM pavi,LPCSTR lpszName);
  STDAPI EditStreamSetNameW(PAVISTREAM pavi,LPCWSTR lpszName);
  STDAPI EditStreamSetInfoW(PAVISTREAM pavi,LPAVISTREAMINFOW lpInfo,LONG cbInfo);
  STDAPI EditStreamSetInfoA(PAVISTREAM pavi,LPAVISTREAMINFOA lpInfo,LONG cbInfo);

#ifndef AVIERR_OK
#define AVIERR_OK __MSABI_LONG(0)

#define MAKE_AVIERR(error) MAKE_SCODE(SEVERITY_ERROR,FACILITY_ITF,0x4000 + error)

#define AVIERR_UNSUPPORTED MAKE_AVIERR(101)
#define AVIERR_BADFORMAT MAKE_AVIERR(102)
#define AVIERR_MEMORY MAKE_AVIERR(103)
#define AVIERR_INTERNAL MAKE_AVIERR(104)
#define AVIERR_BADFLAGS MAKE_AVIERR(105)
#define AVIERR_BADPARAM MAKE_AVIERR(106)
#define AVIERR_BADSIZE MAKE_AVIERR(107)
#define AVIERR_BADHANDLE MAKE_AVIERR(108)
#define AVIERR_FILEREAD MAKE_AVIERR(109)
#define AVIERR_FILEWRITE MAKE_AVIERR(110)
#define AVIERR_FILEOPEN MAKE_AVIERR(111)
#define AVIERR_COMPRESSOR MAKE_AVIERR(112)
#define AVIERR_NOCOMPRESSOR MAKE_AVIERR(113)
#define AVIERR_READONLY MAKE_AVIERR(114)
#define AVIERR_NODATA MAKE_AVIERR(115)
#define AVIERR_BUFFERTOOSMALL MAKE_AVIERR(116)
#define AVIERR_CANTCOMPRESS MAKE_AVIERR(117)
#define AVIERR_USERABORT MAKE_AVIERR(198)
#define AVIERR_ERROR MAKE_AVIERR(199)
#endif
#endif

#ifndef NOMCIWND

#ifdef __cplusplus
#define MCIWndSM ::SendMessage
#else
#define MCIWndSM SendMessage
#endif

#define MCIWND_WINDOW_CLASS TEXT("MCIWndClass")

#define MCIWndCreate __MINGW_NAME_AW(MCIWndCreate)

  HWND WINAPIV MCIWndCreateA(HWND hwndParent,HINSTANCE hInstance,DWORD dwStyle,LPCSTR szFile);
  HWND WINAPIV MCIWndCreateW(HWND hwndParent,HINSTANCE hInstance,DWORD dwStyle,LPCWSTR szFile);
  WINBOOL WINAPIV MCIWndRegisterClass(void);

#define MCIWNDOPENF_NEW 0x0001

#define MCIWNDF_NOAUTOSIZEWINDOW 0x0001
#define MCIWNDF_NOPLAYBAR 0x0002
#define MCIWNDF_NOAUTOSIZEMOVIE 0x0004
#define MCIWNDF_NOMENU 0x0008
#define MCIWNDF_SHOWNAME 0x0010
#define MCIWNDF_SHOWPOS 0x0020
#define MCIWNDF_SHOWMODE 0x0040
#define MCIWNDF_SHOWALL 0x0070

#define MCIWNDF_NOTIFYMODE 0x0100
#define MCIWNDF_NOTIFYPOS 0x0200
#define MCIWNDF_NOTIFYSIZE 0x0400
#define MCIWNDF_NOTIFYERROR 0x1000
#define MCIWNDF_NOTIFYALL 0x1F00

#define MCIWNDF_NOTIFYANSI 0x0080

#define MCIWNDF_NOTIFYMEDIAA 0x0880
#define MCIWNDF_NOTIFYMEDIAW 0x0800

#define MCIWNDF_NOTIFYMEDIA __MINGW_NAME_AW(MCIWNDF_NOTIFYMEDIA)

#define MCIWNDF_RECORD 0x2000
#define MCIWNDF_NOERRORDLG 0x4000
#define MCIWNDF_NOOPEN 0x8000

#define MCIWndCanPlay(hwnd) (WINBOOL)MCIWndSM(hwnd,MCIWNDM_CAN_PLAY,(WPARAM)0,(LPARAM)0)
#define MCIWndCanRecord(hwnd) (WINBOOL)MCIWndSM(hwnd,MCIWNDM_CAN_RECORD,(WPARAM)0,(LPARAM)0)
#define MCIWndCanSave(hwnd) (WINBOOL)MCIWndSM(hwnd,MCIWNDM_CAN_SAVE,(WPARAM)0,(LPARAM)0)
#define MCIWndCanWindow(hwnd) (WINBOOL)MCIWndSM(hwnd,MCIWNDM_CAN_WINDOW,(WPARAM)0,(LPARAM)0)
#define MCIWndCanEject(hwnd) (WINBOOL)MCIWndSM(hwnd,MCIWNDM_CAN_EJECT,(WPARAM)0,(LPARAM)0)
#define MCIWndCanConfig(hwnd) (WINBOOL)MCIWndSM(hwnd,MCIWNDM_CAN_CONFIG,(WPARAM)0,(LPARAM)0)
#define MCIWndPaletteKick(hwnd) (WINBOOL)MCIWndSM(hwnd,MCIWNDM_PALETTEKICK,(WPARAM)0,(LPARAM)0)

#define MCIWndSave(hwnd,szFile) (LONG)MCIWndSM(hwnd,MCI_SAVE,(WPARAM)0,(LPARAM)(LPVOID)(szFile))
#define MCIWndSaveDialog(hwnd) MCIWndSave(hwnd,-1)

#define MCIWndNew(hwnd,lp) (LONG)MCIWndSM(hwnd,MCIWNDM_NEW,(WPARAM)0,(LPARAM)(LPVOID)(lp))

#define MCIWndRecord(hwnd) (LONG)MCIWndSM(hwnd,MCI_RECORD,(WPARAM)0,(LPARAM)0)
#define MCIWndOpen(hwnd,sz,f) (LONG)MCIWndSM(hwnd,MCIWNDM_OPEN,(WPARAM)(UINT)(f),(LPARAM)(LPVOID)(sz))
#define MCIWndOpenDialog(hwnd) MCIWndOpen(hwnd,-1,0)
#define MCIWndClose(hwnd) (LONG)MCIWndSM(hwnd,MCI_CLOSE,(WPARAM)0,(LPARAM)0)
#define MCIWndPlay(hwnd) (LONG)MCIWndSM(hwnd,MCI_PLAY,(WPARAM)0,(LPARAM)0)
#define MCIWndStop(hwnd) (LONG)MCIWndSM(hwnd,MCI_STOP,(WPARAM)0,(LPARAM)0)
#define MCIWndPause(hwnd) (LONG)MCIWndSM(hwnd,MCI_PAUSE,(WPARAM)0,(LPARAM)0)
#define MCIWndResume(hwnd) (LONG)MCIWndSM(hwnd,MCI_RESUME,(WPARAM)0,(LPARAM)0)
#define MCIWndSeek(hwnd,lPos) (LONG)MCIWndSM(hwnd,MCI_SEEK,(WPARAM)0,(LPARAM)(LONG)(lPos))
#define MCIWndEject(hwnd) (LONG)MCIWndSM(hwnd,MCIWNDM_EJECT,(WPARAM)0,(LPARAM)0)

#define MCIWndHome(hwnd) MCIWndSeek(hwnd,MCIWND_START)
#define MCIWndEnd(hwnd) MCIWndSeek(hwnd,MCIWND_END)

#define MCIWndGetSource(hwnd,prc) (LONG)MCIWndSM(hwnd,MCIWNDM_GET_SOURCE,(WPARAM)0,(LPARAM)(LPRECT)(prc))
#define MCIWndPutSource(hwnd,prc) (LONG)MCIWndSM(hwnd,MCIWNDM_PUT_SOURCE,(WPARAM)0,(LPARAM)(LPRECT)(prc))

#define MCIWndGetDest(hwnd,prc) (LONG)MCIWndSM(hwnd,MCIWNDM_GET_DEST,(WPARAM)0,(LPARAM)(LPRECT)(prc))
#define MCIWndPutDest(hwnd,prc) (LONG)MCIWndSM(hwnd,MCIWNDM_PUT_DEST,(WPARAM)0,(LPARAM)(LPRECT)(prc))

#define MCIWndPlayReverse(hwnd) (LONG)MCIWndSM(hwnd,MCIWNDM_PLAYREVERSE,(WPARAM)0,(LPARAM)0)
#define MCIWndPlayFrom(hwnd,lPos) (LONG)MCIWndSM(hwnd,MCIWNDM_PLAYFROM,(WPARAM)0,(LPARAM)(LONG)(lPos))
#define MCIWndPlayTo(hwnd,lPos) (LONG)MCIWndSM(hwnd,MCIWNDM_PLAYTO,(WPARAM)0,(LPARAM)(LONG)(lPos))
#define MCIWndPlayFromTo(hwnd,lStart,lEnd) (MCIWndSeek(hwnd,lStart),MCIWndPlayTo(hwnd,lEnd))

#define MCIWndGetDeviceID(hwnd) (UINT)MCIWndSM(hwnd,MCIWNDM_GETDEVICEID,(WPARAM)0,(LPARAM)0)
#define MCIWndGetAlias(hwnd) (UINT)MCIWndSM(hwnd,MCIWNDM_GETALIAS,(WPARAM)0,(LPARAM)0)
#define MCIWndGetMode(hwnd,lp,len) (LONG)MCIWndSM(hwnd,MCIWNDM_GETMODE,(WPARAM)(UINT)(len),(LPARAM)(LPTSTR)(lp))
#define MCIWndGetPosition(hwnd) (LONG)MCIWndSM(hwnd,MCIWNDM_GETPOSITION,(WPARAM)0,(LPARAM)0)
#define MCIWndGetPositionString(hwnd,lp,len) (LONG)MCIWndSM(hwnd,MCIWNDM_GETPOSITION,(WPARAM)(UINT)(len),(LPARAM)(LPTSTR)(lp))
#define MCIWndGetStart(hwnd) (LONG)MCIWndSM(hwnd,MCIWNDM_GETSTART,(WPARAM)0,(LPARAM)0)
#define MCIWndGetLength(hwnd) (LONG)MCIWndSM(hwnd,MCIWNDM_GETLENGTH,(WPARAM)0,(LPARAM)0)
#define MCIWndGetEnd(hwnd) (LONG)MCIWndSM(hwnd,MCIWNDM_GETEND,(WPARAM)0,(LPARAM)0)

#define MCIWndStep(hwnd,n) (LONG)MCIWndSM(hwnd,MCI_STEP,(WPARAM)0,(LPARAM)(__LONG32)(n))

#define MCIWndDestroy(hwnd) (VOID)MCIWndSM(hwnd,WM_CLOSE,(WPARAM)0,(LPARAM)0)
#define MCIWndSetZoom(hwnd,iZoom) (VOID)MCIWndSM(hwnd,MCIWNDM_SETZOOM,(WPARAM)0,(LPARAM)(UINT)(iZoom))
#define MCIWndGetZoom(hwnd) (UINT)MCIWndSM(hwnd,MCIWNDM_GETZOOM,(WPARAM)0,(LPARAM)0)
#define MCIWndSetVolume(hwnd,iVol) (LONG)MCIWndSM(hwnd,MCIWNDM_SETVOLUME,(WPARAM)0,(LPARAM)(UINT)(iVol))
#define MCIWndGetVolume(hwnd) (LONG)MCIWndSM(hwnd,MCIWNDM_GETVOLUME,(WPARAM)0,(LPARAM)0)
#define MCIWndSetSpeed(hwnd,iSpeed) (LONG)MCIWndSM(hwnd,MCIWNDM_SETSPEED,(WPARAM)0,(LPARAM)(UINT)(iSpeed))
#define MCIWndGetSpeed(hwnd) (LONG)MCIWndSM(hwnd,MCIWNDM_GETSPEED,(WPARAM)0,(LPARAM)0)
#define MCIWndSetTimeFormat(hwnd,lp) (LONG)MCIWndSM(hwnd,MCIWNDM_SETTIMEFORMAT,(WPARAM)0,(LPARAM)(LPTSTR)(lp))
#define MCIWndGetTimeFormat(hwnd,lp,len) (LONG)MCIWndSM(hwnd,MCIWNDM_GETTIMEFORMAT,(WPARAM)(UINT)(len),(LPARAM)(LPTSTR)(lp))
#define MCIWndValidateMedia(hwnd) (VOID)MCIWndSM(hwnd,MCIWNDM_VALIDATEMEDIA,(WPARAM)0,(LPARAM)0)

#define MCIWndSetRepeat(hwnd,f) (void)MCIWndSM(hwnd,MCIWNDM_SETREPEAT,(WPARAM)0,(LPARAM)(WINBOOL)(f))
#define MCIWndGetRepeat(hwnd) (WINBOOL)MCIWndSM(hwnd,MCIWNDM_GETREPEAT,(WPARAM)0,(LPARAM)0)

#define MCIWndUseFrames(hwnd) MCIWndSetTimeFormat(hwnd,TEXT("frames"))
#define MCIWndUseTime(hwnd) MCIWndSetTimeFormat(hwnd,TEXT("ms"))

#define MCIWndSetActiveTimer(hwnd,active) (VOID)MCIWndSM(hwnd,MCIWNDM_SETACTIVETIMER,(WPARAM)(UINT)(active),(LPARAM)0)
#define MCIWndSetInactiveTimer(hwnd,inactive) (VOID)MCIWndSM(hwnd,MCIWNDM_SETINACTIVETIMER,(WPARAM)(UINT)(inactive),(LPARAM)0)
#define MCIWndSetTimers(hwnd,active,inactive) (VOID)MCIWndSM(hwnd,MCIWNDM_SETTIMERS,(WPARAM)(UINT)(active),(LPARAM)(UINT)(inactive))
#define MCIWndGetActiveTimer(hwnd) (UINT)MCIWndSM(hwnd,MCIWNDM_GETACTIVETIMER,(WPARAM)0,(LPARAM)0);
#define MCIWndGetInactiveTimer(hwnd) (UINT)MCIWndSM(hwnd,MCIWNDM_GETINACTIVETIMER,(WPARAM)0,(LPARAM)0);

#define MCIWndRealize(hwnd,fBkgnd) (LONG)MCIWndSM(hwnd,MCIWNDM_REALIZE,(WPARAM)(WINBOOL)(fBkgnd),(LPARAM)0)

#define MCIWndSendString(hwnd,sz) (LONG)MCIWndSM(hwnd,MCIWNDM_SENDSTRING,(WPARAM)0,(LPARAM)(LPTSTR)(sz))
#define MCIWndReturnString(hwnd,lp,len) (LONG)MCIWndSM(hwnd,MCIWNDM_RETURNSTRING,(WPARAM)(UINT)(len),(LPARAM)(LPVOID)(lp))
#define MCIWndGetError(hwnd,lp,len) (LONG)MCIWndSM(hwnd,MCIWNDM_GETERROR,(WPARAM)(UINT)(len),(LPARAM)(LPVOID)(lp))

#define MCIWndGetPalette(hwnd) (HPALETTE)MCIWndSM(hwnd,MCIWNDM_GETPALETTE,(WPARAM)0,(LPARAM)0)
#define MCIWndSetPalette(hwnd,hpal) (LONG)MCIWndSM(hwnd,MCIWNDM_SETPALETTE,(WPARAM)(HPALETTE)(hpal),(LPARAM)0)

#define MCIWndGetFileName(hwnd,lp,len) (LONG)MCIWndSM(hwnd,MCIWNDM_GETFILENAME,(WPARAM)(UINT)(len),(LPARAM)(LPVOID)(lp))
#define MCIWndGetDevice(hwnd,lp,len) (LONG)MCIWndSM(hwnd,MCIWNDM_GETDEVICE,(WPARAM)(UINT)(len),(LPARAM)(LPVOID)(lp))

#define MCIWndGetStyles(hwnd) (UINT)MCIWndSM(hwnd,MCIWNDM_GETSTYLES,(WPARAM)0,(LPARAM)0)
#define MCIWndChangeStyles(hwnd,mask,value) (LONG)MCIWndSM(hwnd,MCIWNDM_CHANGESTYLES,(WPARAM)(UINT)(mask),(LPARAM)(LONG)(value))

#define MCIWndOpenInterface(hwnd,pUnk) (LONG)MCIWndSM(hwnd,MCIWNDM_OPENINTERFACE,(WPARAM)0,(LPARAM)(LPUNKNOWN)(pUnk))

#define MCIWndSetOwner(hwnd,hwndP) (LONG)MCIWndSM(hwnd,MCIWNDM_SETOWNER,(WPARAM)(hwndP),(LPARAM)0)

#define MCIWNDM_GETDEVICEID (WM_USER + 100)
#define MCIWNDM_GETSTART (WM_USER + 103)
#define MCIWNDM_GETLENGTH (WM_USER + 104)
#define MCIWNDM_GETEND (WM_USER + 105)
#define MCIWNDM_EJECT (WM_USER + 107)
#define MCIWNDM_SETZOOM (WM_USER + 108)
#define MCIWNDM_GETZOOM (WM_USER + 109)
#define MCIWNDM_SETVOLUME (WM_USER + 110)
#define MCIWNDM_GETVOLUME (WM_USER + 111)
#define MCIWNDM_SETSPEED (WM_USER + 112)
#define MCIWNDM_GETSPEED (WM_USER + 113)
#define MCIWNDM_SETREPEAT (WM_USER + 114)
#define MCIWNDM_GETREPEAT (WM_USER + 115)
#define MCIWNDM_REALIZE (WM_USER + 118)
#define MCIWNDM_VALIDATEMEDIA (WM_USER + 121)
#define MCIWNDM_PLAYFROM (WM_USER + 122)
#define MCIWNDM_PLAYTO (WM_USER + 123)
#define MCIWNDM_GETPALETTE (WM_USER + 126)
#define MCIWNDM_SETPALETTE (WM_USER + 127)
#define MCIWNDM_SETTIMERS (WM_USER + 129)
#define MCIWNDM_SETACTIVETIMER (WM_USER + 130)
#define MCIWNDM_SETINACTIVETIMER (WM_USER + 131)
#define MCIWNDM_GETACTIVETIMER (WM_USER + 132)
#define MCIWNDM_GETINACTIVETIMER (WM_USER + 133)
#define MCIWNDM_CHANGESTYLES (WM_USER + 135)
#define MCIWNDM_GETSTYLES (WM_USER + 136)
#define MCIWNDM_GETALIAS (WM_USER + 137)
#define MCIWNDM_PLAYREVERSE (WM_USER + 139)
#define MCIWNDM_GET_SOURCE (WM_USER + 140)
#define MCIWNDM_PUT_SOURCE (WM_USER + 141)
#define MCIWNDM_GET_DEST (WM_USER + 142)
#define MCIWNDM_PUT_DEST (WM_USER + 143)
#define MCIWNDM_CAN_PLAY (WM_USER + 144)
#define MCIWNDM_CAN_WINDOW (WM_USER + 145)
#define MCIWNDM_CAN_RECORD (WM_USER + 146)
#define MCIWNDM_CAN_SAVE (WM_USER + 147)
#define MCIWNDM_CAN_EJECT (WM_USER + 148)
#define MCIWNDM_CAN_CONFIG (WM_USER + 149)
#define MCIWNDM_PALETTEKICK (WM_USER + 150)
#define MCIWNDM_OPENINTERFACE (WM_USER + 151)
#define MCIWNDM_SETOWNER (WM_USER + 152)

#define MCIWNDM_SENDSTRINGA (WM_USER + 101)
#define MCIWNDM_GETPOSITIONA (WM_USER + 102)
#define MCIWNDM_GETMODEA (WM_USER + 106)
#define MCIWNDM_SETTIMEFORMATA (WM_USER + 119)
#define MCIWNDM_GETTIMEFORMATA (WM_USER + 120)
#define MCIWNDM_GETFILENAMEA (WM_USER + 124)
#define MCIWNDM_GETDEVICEA (WM_USER + 125)
#define MCIWNDM_GETERRORA (WM_USER + 128)
#define MCIWNDM_NEWA (WM_USER + 134)
#define MCIWNDM_RETURNSTRINGA (WM_USER + 138)
#define MCIWNDM_OPENA (WM_USER + 153)

#define MCIWNDM_SENDSTRINGW (WM_USER + 201)
#define MCIWNDM_GETPOSITIONW (WM_USER + 202)
#define MCIWNDM_GETMODEW (WM_USER + 206)
#define MCIWNDM_SETTIMEFORMATW (WM_USER + 219)
#define MCIWNDM_GETTIMEFORMATW (WM_USER + 220)
#define MCIWNDM_GETFILENAMEW (WM_USER + 224)
#define MCIWNDM_GETDEVICEW (WM_USER + 225)
#define MCIWNDM_GETERRORW (WM_USER + 228)
#define MCIWNDM_NEWW (WM_USER + 234)
#define MCIWNDM_RETURNSTRINGW (WM_USER + 238)
#define MCIWNDM_OPENW (WM_USER + 252)

#define MCIWNDM_SENDSTRING __MINGW_NAME_AW(MCIWNDM_SENDSTRING)
#define MCIWNDM_GETPOSITION __MINGW_NAME_AW(MCIWNDM_GETPOSITION)
#define MCIWNDM_GETMODE __MINGW_NAME_AW(MCIWNDM_GETMODE)
#define MCIWNDM_SETTIMEFORMAT __MINGW_NAME_AW(MCIWNDM_SETTIMEFORMAT)
#define MCIWNDM_GETTIMEFORMAT __MINGW_NAME_AW(MCIWNDM_GETTIMEFORMAT)
#define MCIWNDM_GETFILENAME __MINGW_NAME_AW(MCIWNDM_GETFILENAME)
#define MCIWNDM_GETDEVICE __MINGW_NAME_AW(MCIWNDM_GETDEVICE)
#define MCIWNDM_GETERROR __MINGW_NAME_AW(MCIWNDM_GETERROR)
#define MCIWNDM_NEW __MINGW_NAME_AW(MCIWNDM_NEW)
#define MCIWNDM_RETURNSTRING __MINGW_NAME_AW(MCIWNDM_RETURNSTRING)
#define MCIWNDM_OPEN __MINGW_NAME_AW(MCIWNDM_OPEN)

#define MCIWNDM_NOTIFYMODE (WM_USER + 200)
#define MCIWNDM_NOTIFYPOS (WM_USER + 201)
#define MCIWNDM_NOTIFYSIZE (WM_USER + 202)
#define MCIWNDM_NOTIFYMEDIA (WM_USER + 203)
#define MCIWNDM_NOTIFYERROR (WM_USER + 205)

#define MCIWND_START -1
#define MCIWND_END -2

#ifndef MCI_PLAY
#define MCI_CLOSE 0x0804
#define MCI_PLAY 0x0806
#define MCI_SEEK 0x0807
#define MCI_STOP 0x0808
#define MCI_PAUSE 0x0809
#define MCI_STEP 0x080E
#define MCI_RECORD 0x080F
#define MCI_SAVE 0x0813
#define MCI_CUT 0x0851
#define MCI_COPY 0x0852
#define MCI_PASTE 0x0853
#define MCI_RESUME 0x0855
#define MCI_DELETE 0x0856
#endif

#ifndef MCI_MODE_NOT_READY

#define MCI_MODE_NOT_READY (524)
#define MCI_MODE_STOP (525)
#define MCI_MODE_PLAY (526)
#define MCI_MODE_RECORD (527)
#define MCI_MODE_SEEK (528)
#define MCI_MODE_PAUSE (529)
#define MCI_MODE_OPEN (530)
#endif
#endif

#if !defined(NOAVICAP) || !defined(NOVIDEO)

#ifndef _RCINVOKED

  DECLARE_HANDLE(HVIDEO);
  typedef HVIDEO *LPHVIDEO;
#endif

  DWORD WINAPI VideoForWindowsVersion(void);

#define DV_ERR_OK (0)
#define DV_ERR_BASE (1)
#define DV_ERR_NONSPECIFIC (DV_ERR_BASE)
#define DV_ERR_BADFORMAT (DV_ERR_BASE + 1)

#define DV_ERR_STILLPLAYING (DV_ERR_BASE + 2)

#define DV_ERR_UNPREPARED (DV_ERR_BASE + 3)

#define DV_ERR_SYNC (DV_ERR_BASE + 4)

#define DV_ERR_TOOMANYCHANNELS (DV_ERR_BASE + 5)

#define DV_ERR_NOTDETECTED (DV_ERR_BASE + 6)
#define DV_ERR_BADINSTALL (DV_ERR_BASE + 7)
#define DV_ERR_CREATEPALETTE (DV_ERR_BASE + 8)
#define DV_ERR_SIZEFIELD (DV_ERR_BASE + 9)
#define DV_ERR_PARAM1 (DV_ERR_BASE + 10)
#define DV_ERR_PARAM2 (DV_ERR_BASE + 11)
#define DV_ERR_CONFIG1 (DV_ERR_BASE + 12)
#define DV_ERR_CONFIG2 (DV_ERR_BASE + 13)
#define DV_ERR_FLAGS (DV_ERR_BASE + 14)
#define DV_ERR_13 (DV_ERR_BASE + 15)

#define DV_ERR_NOTSUPPORTED (DV_ERR_BASE + 16)
#define DV_ERR_NOMEM (DV_ERR_BASE + 17)
#define DV_ERR_ALLOCATED (DV_ERR_BASE + 18)
#define DV_ERR_BADDEVICEID (DV_ERR_BASE + 19)
#define DV_ERR_INVALHANDLE (DV_ERR_BASE + 20)
#define DV_ERR_BADERRNUM (DV_ERR_BASE + 21)
#define DV_ERR_NO_BUFFERS (DV_ERR_BASE + 22)

#define DV_ERR_MEM_CONFLICT (DV_ERR_BASE + 23)
#define DV_ERR_IO_CONFLICT (DV_ERR_BASE + 24)
#define DV_ERR_DMA_CONFLICT (DV_ERR_BASE + 25)
#define DV_ERR_INT_CONFLICT (DV_ERR_BASE + 26)
#define DV_ERR_PROTECT_ONLY (DV_ERR_BASE + 27)
#define DV_ERR_LASTERROR (DV_ERR_BASE + 27)

#define DV_ERR_USER_MSG (DV_ERR_BASE + 1000)

#ifndef _RCINVOKED

#ifndef MM_DRVM_OPEN
#define MM_DRVM_OPEN 0x3D0
#define MM_DRVM_CLOSE 0x3D1
#define MM_DRVM_DATA 0x3D2
#define MM_DRVM_ERROR 0x3D3
#endif

#define DV_VM_OPEN MM_DRVM_OPEN
#define DV_VM_CLOSE MM_DRVM_CLOSE
#define DV_VM_DATA MM_DRVM_DATA
#define DV_VM_ERROR MM_DRVM_ERROR

  typedef struct videohdr_tag {
    LPBYTE lpData;
    DWORD dwBufferLength;
    DWORD dwBytesUsed;
    DWORD dwTimeCaptured;
    DWORD_PTR dwUser;
    DWORD dwFlags;
    DWORD_PTR dwReserved[4];
  } VIDEOHDR, NEAR *PVIDEOHDR, FAR * LPVIDEOHDR;

#define VHDR_DONE 0x00000001
#define VHDR_PREPARED 0x00000002
#define VHDR_INQUEUE 0x00000004
#define VHDR_KEYFRAME 0x00000008
#define VHDR_VALID 0x0000000F

  typedef struct channel_caps_tag {
    DWORD dwFlags;
    DWORD dwSrcRectXMod;
    DWORD dwSrcRectYMod;
    DWORD dwSrcRectWidthMod;
    DWORD dwSrcRectHeightMod;
    DWORD dwDstRectXMod;
    DWORD dwDstRectYMod;
    DWORD dwDstRectWidthMod;
    DWORD dwDstRectHeightMod;
  } CHANNEL_CAPS,NEAR *PCHANNEL_CAPS,*LPCHANNEL_CAPS;

#define VCAPS_OVERLAY 0x00000001
#define VCAPS_SRC_CAN_CLIP 0x00000002
#define VCAPS_DST_CAN_CLIP 0x00000004
#define VCAPS_CAN_SCALE 0x00000008

#define VIDEO_EXTERNALIN 0x0001
#define VIDEO_EXTERNALOUT 0x0002
#define VIDEO_IN 0x0004
#define VIDEO_OUT 0x0008

#define VIDEO_DLG_QUERY 0x0010

#define VIDEO_CONFIGURE_QUERY 0x8000

#define VIDEO_CONFIGURE_SET 0x1000

#define VIDEO_CONFIGURE_GET 0x2000
#define VIDEO_CONFIGURE_QUERYSIZE 0x0001

#define VIDEO_CONFIGURE_CURRENT 0x0010
#define VIDEO_CONFIGURE_NOMINAL 0x0020
#define VIDEO_CONFIGURE_MIN 0x0040
#define VIDEO_CONFIGURE_MAX 0x0080

#define DVM_USER 0X4000

#define DVM_CONFIGURE_START 0x1000
#define DVM_CONFIGURE_END 0x1FFF

#define DVM_PALETTE (DVM_CONFIGURE_START + 1)
#define DVM_FORMAT (DVM_CONFIGURE_START + 2)
#define DVM_PALETTERGB555 (DVM_CONFIGURE_START + 3)
#define DVM_SRC_RECT (DVM_CONFIGURE_START + 4)
#define DVM_DST_RECT (DVM_CONFIGURE_START + 5)
#endif
#endif

#ifndef NOAVICAP
#ifdef __cplusplus

#define AVICapSM(hwnd,m,w,l) ((::IsWindow(hwnd)) ? ::SendMessage(hwnd,m,w,l) : 0)
#else

#define AVICapSM(hwnd,m,w,l) ((IsWindow(hwnd)) ? SendMessage(hwnd,m,w,l) : 0)
#endif

#ifndef RC_INVOKED

#define WM_CAP_START WM_USER

#define WM_CAP_UNICODE_START WM_USER+100

#define WM_CAP_GET_CAPSTREAMPTR (WM_CAP_START+ 1)

#define WM_CAP_SET_CALLBACK_ERRORW (WM_CAP_UNICODE_START+ 2)
#define WM_CAP_SET_CALLBACK_STATUSW (WM_CAP_UNICODE_START+ 3)
#define WM_CAP_SET_CALLBACK_ERRORA (WM_CAP_START+ 2)
#define WM_CAP_SET_CALLBACK_STATUSA (WM_CAP_START+ 3)

#define WM_CAP_SET_CALLBACK_ERROR __MINGW_NAME_AW(WM_CAP_SET_CALLBACK_ERROR)
#define WM_CAP_SET_CALLBACK_STATUS __MINGW_NAME_AW(WM_CAP_SET_CALLBACK_STATUS)

#define WM_CAP_SET_CALLBACK_YIELD (WM_CAP_START+ 4)
#define WM_CAP_SET_CALLBACK_FRAME (WM_CAP_START+ 5)
#define WM_CAP_SET_CALLBACK_VIDEOSTREAM (WM_CAP_START+ 6)
#define WM_CAP_SET_CALLBACK_WAVESTREAM (WM_CAP_START+ 7)
#define WM_CAP_GET_USER_DATA (WM_CAP_START+ 8)
#define WM_CAP_SET_USER_DATA (WM_CAP_START+ 9)

#define WM_CAP_DRIVER_CONNECT (WM_CAP_START+ 10)
#define WM_CAP_DRIVER_DISCONNECT (WM_CAP_START+ 11)

#define WM_CAP_DRIVER_GET_NAMEA (WM_CAP_START+ 12)
#define WM_CAP_DRIVER_GET_VERSIONA (WM_CAP_START+ 13)
#define WM_CAP_DRIVER_GET_NAMEW (WM_CAP_UNICODE_START+ 12)
#define WM_CAP_DRIVER_GET_VERSIONW (WM_CAP_UNICODE_START+ 13)

#define WM_CAP_DRIVER_GET_NAME __MINGW_NAME_AW(WM_CAP_DRIVER_GET_NAME)
#define WM_CAP_DRIVER_GET_VERSION __MINGW_NAME_AW(WM_CAP_DRIVER_GET_VERSION)

#define WM_CAP_DRIVER_GET_CAPS (WM_CAP_START+ 14)

#define WM_CAP_FILE_SET_CAPTURE_FILEA (WM_CAP_START+ 20)
#define WM_CAP_FILE_GET_CAPTURE_FILEA (WM_CAP_START+ 21)
#define WM_CAP_FILE_SAVEASA (WM_CAP_START+ 23)
#define WM_CAP_FILE_SAVEDIBA (WM_CAP_START+ 25)
#define WM_CAP_FILE_SET_CAPTURE_FILEW (WM_CAP_UNICODE_START+ 20)
#define WM_CAP_FILE_GET_CAPTURE_FILEW (WM_CAP_UNICODE_START+ 21)
#define WM_CAP_FILE_SAVEASW (WM_CAP_UNICODE_START+ 23)
#define WM_CAP_FILE_SAVEDIBW (WM_CAP_UNICODE_START+ 25)

#define WM_CAP_FILE_SET_CAPTURE_FILE __MINGW_NAME_AW(WM_CAP_FILE_SET_CAPTURE_FILE)
#define WM_CAP_FILE_GET_CAPTURE_FILE __MINGW_NAME_AW(WM_CAP_FILE_GET_CAPTURE_FILE)
#define WM_CAP_FILE_SAVEAS __MINGW_NAME_AW(WM_CAP_FILE_SAVEAS)
#define WM_CAP_FILE_SAVEDIB __MINGW_NAME_AW(WM_CAP_FILE_SAVEDIB)

#define WM_CAP_FILE_ALLOCATE (WM_CAP_START+ 22)
#define WM_CAP_FILE_SET_INFOCHUNK (WM_CAP_START+ 24)

#define WM_CAP_EDIT_COPY (WM_CAP_START+ 30)

#define WM_CAP_SET_AUDIOFORMAT (WM_CAP_START+ 35)
#define WM_CAP_GET_AUDIOFORMAT (WM_CAP_START+ 36)

#define WM_CAP_DLG_VIDEOFORMAT (WM_CAP_START+ 41)
#define WM_CAP_DLG_VIDEOSOURCE (WM_CAP_START+ 42)
#define WM_CAP_DLG_VIDEODISPLAY (WM_CAP_START+ 43)
#define WM_CAP_GET_VIDEOFORMAT (WM_CAP_START+ 44)
#define WM_CAP_SET_VIDEOFORMAT (WM_CAP_START+ 45)
#define WM_CAP_DLG_VIDEOCOMPRESSION (WM_CAP_START+ 46)

#define WM_CAP_SET_PREVIEW (WM_CAP_START+ 50)
#define WM_CAP_SET_OVERLAY (WM_CAP_START+ 51)
#define WM_CAP_SET_PREVIEWRATE (WM_CAP_START+ 52)
#define WM_CAP_SET_SCALE (WM_CAP_START+ 53)
#define WM_CAP_GET_STATUS (WM_CAP_START+ 54)
#define WM_CAP_SET_SCROLL (WM_CAP_START+ 55)

#define WM_CAP_GRAB_FRAME (WM_CAP_START+ 60)
#define WM_CAP_GRAB_FRAME_NOSTOP (WM_CAP_START+ 61)

#define WM_CAP_SEQUENCE (WM_CAP_START+ 62)
#define WM_CAP_SEQUENCE_NOFILE (WM_CAP_START+ 63)
#define WM_CAP_SET_SEQUENCE_SETUP (WM_CAP_START+ 64)
#define WM_CAP_GET_SEQUENCE_SETUP (WM_CAP_START+ 65)

#define WM_CAP_SET_MCI_DEVICEA (WM_CAP_START+ 66)
#define WM_CAP_GET_MCI_DEVICEA (WM_CAP_START+ 67)
#define WM_CAP_SET_MCI_DEVICEW (WM_CAP_UNICODE_START+ 66)
#define WM_CAP_GET_MCI_DEVICEW (WM_CAP_UNICODE_START+ 67)

#define WM_CAP_SET_MCI_DEVICE __MINGW_NAME_AW(WM_CAP_SET_MCI_DEVICE)
#define WM_CAP_GET_MCI_DEVICE __MINGW_NAME_AW(WM_CAP_GET_MCI_DEVICE)

#define WM_CAP_STOP (WM_CAP_START+ 68)
#define WM_CAP_ABORT (WM_CAP_START+ 69)

#define WM_CAP_SINGLE_FRAME_OPEN (WM_CAP_START+ 70)
#define WM_CAP_SINGLE_FRAME_CLOSE (WM_CAP_START+ 71)
#define WM_CAP_SINGLE_FRAME (WM_CAP_START+ 72)

#define WM_CAP_PAL_OPENA (WM_CAP_START+ 80)
#define WM_CAP_PAL_SAVEA (WM_CAP_START+ 81)
#define WM_CAP_PAL_OPENW (WM_CAP_UNICODE_START+ 80)
#define WM_CAP_PAL_SAVEW (WM_CAP_UNICODE_START+ 81)

#define WM_CAP_PAL_OPEN __MINGW_NAME_AW(WM_CAP_PAL_OPEN)
#define WM_CAP_PAL_SAVE __MINGW_NAME_AW(WM_CAP_PAL_SAVE)

#define WM_CAP_PAL_PASTE (WM_CAP_START+ 82)
#define WM_CAP_PAL_AUTOCREATE (WM_CAP_START+ 83)
#define WM_CAP_PAL_MANUALCREATE (WM_CAP_START+ 84)

#define WM_CAP_SET_CALLBACK_CAPCONTROL (WM_CAP_START+ 85)

#define WM_CAP_UNICODE_END WM_CAP_PAL_SAVEW
#define WM_CAP_END WM_CAP_UNICODE_END

#define capSetCallbackOnError(hwnd,fpProc) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_CALLBACK_ERROR,(WPARAM)0,(LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnStatus(hwnd,fpProc) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_CALLBACK_STATUS,(WPARAM)0,(LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnYield(hwnd,fpProc) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_CALLBACK_YIELD,(WPARAM)0,(LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnFrame(hwnd,fpProc) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_CALLBACK_FRAME,(WPARAM)0,(LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnVideoStream(hwnd,fpProc) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_CALLBACK_VIDEOSTREAM,(WPARAM)0,(LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnWaveStream(hwnd,fpProc) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_CALLBACK_WAVESTREAM,(WPARAM)0,(LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnCapControl(hwnd,fpProc) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_CALLBACK_CAPCONTROL,(WPARAM)0,(LPARAM)(LPVOID)(fpProc)))

#define capSetUserData(hwnd,lUser) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_USER_DATA,(WPARAM)0,(LPARAM)lUser))
#define capGetUserData(hwnd) (AVICapSM(hwnd,WM_CAP_GET_USER_DATA,(WPARAM)0,(LPARAM)0))

#define capDriverConnect(hwnd,i) ((WINBOOL)AVICapSM(hwnd,WM_CAP_DRIVER_CONNECT,(WPARAM)(i),(LPARAM)0))
#define capDriverDisconnect(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_DRIVER_DISCONNECT,(WPARAM)0,(LPARAM)0))
#define capDriverGetName(hwnd,szName,wSize) ((WINBOOL)AVICapSM(hwnd,WM_CAP_DRIVER_GET_NAME,(WPARAM)(wSize),(LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capDriverGetVersion(hwnd,szVer,wSize) ((WINBOOL)AVICapSM(hwnd,WM_CAP_DRIVER_GET_VERSION,(WPARAM)(wSize),(LPARAM)(LPVOID)(LPTSTR)(szVer)))
#define capDriverGetCaps(hwnd,s,wSize) ((WINBOOL)AVICapSM(hwnd,WM_CAP_DRIVER_GET_CAPS,(WPARAM)(wSize),(LPARAM)(LPVOID)(LPCAPDRIVERCAPS)(s)))

#define capFileSetCaptureFile(hwnd,szName) ((WINBOOL)AVICapSM(hwnd,WM_CAP_FILE_SET_CAPTURE_FILE,(WPARAM)0,(LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileGetCaptureFile(hwnd,szName,wSize) ((WINBOOL)AVICapSM(hwnd,WM_CAP_FILE_GET_CAPTURE_FILE,(WPARAM)(wSize),(LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileAlloc(hwnd,dwSize) ((WINBOOL)AVICapSM(hwnd,WM_CAP_FILE_ALLOCATE,(WPARAM)0,(LPARAM)(DWORD)(dwSize)))
#define capFileSaveAs(hwnd,szName) ((WINBOOL)AVICapSM(hwnd,WM_CAP_FILE_SAVEAS,(WPARAM)0,(LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileSetInfoChunk(hwnd,lpInfoChunk) ((WINBOOL)AVICapSM(hwnd,WM_CAP_FILE_SET_INFOCHUNK,(WPARAM)0,(LPARAM)(LPCAPINFOCHUNK)(lpInfoChunk)))
#define capFileSaveDIB(hwnd,szName) ((WINBOOL)AVICapSM(hwnd,WM_CAP_FILE_SAVEDIB,(WPARAM)0,(LPARAM)(LPVOID)(LPTSTR)(szName)))

#define capEditCopy(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_EDIT_COPY,(WPARAM)0,(LPARAM)0))

#define capSetAudioFormat(hwnd,s,wSize) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_AUDIOFORMAT,(WPARAM)(wSize),(LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormat(hwnd,s,wSize) ((DWORD)AVICapSM(hwnd,WM_CAP_GET_AUDIOFORMAT,(WPARAM)(wSize),(LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormatSize(hwnd) ((DWORD)AVICapSM(hwnd,WM_CAP_GET_AUDIOFORMAT,(WPARAM)0,(LPARAM)0))

#define capDlgVideoFormat(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_DLG_VIDEOFORMAT,(WPARAM)0,(LPARAM)0))
#define capDlgVideoSource(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_DLG_VIDEOSOURCE,(WPARAM)0,(LPARAM)0))
#define capDlgVideoDisplay(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_DLG_VIDEODISPLAY,(WPARAM)0,(LPARAM)0))
#define capDlgVideoCompression(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_DLG_VIDEOCOMPRESSION,(WPARAM)0,(LPARAM)0))

#define capGetVideoFormat(hwnd,s,wSize) ((DWORD)AVICapSM(hwnd,WM_CAP_GET_VIDEOFORMAT,(WPARAM)(wSize),(LPARAM)(LPVOID)(s)))
#define capGetVideoFormatSize(hwnd) ((DWORD)AVICapSM(hwnd,WM_CAP_GET_VIDEOFORMAT,(WPARAM)0,(LPARAM)0))
#define capSetVideoFormat(hwnd,s,wSize) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_VIDEOFORMAT,(WPARAM)(wSize),(LPARAM)(LPVOID)(s)))

#define capPreview(hwnd,f) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_PREVIEW,(WPARAM)(WINBOOL)(f),(LPARAM)0))
#define capPreviewRate(hwnd,wMS) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_PREVIEWRATE,(WPARAM)(wMS),(LPARAM)0))
#define capOverlay(hwnd,f) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_OVERLAY,(WPARAM)(WINBOOL)(f),(LPARAM)0))
#define capPreviewScale(hwnd,f) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_SCALE,(WPARAM)(WINBOOL)f,(LPARAM)0))
#define capGetStatus(hwnd,s,wSize) ((WINBOOL)AVICapSM(hwnd,WM_CAP_GET_STATUS,(WPARAM)(wSize),(LPARAM)(LPVOID)(LPCAPSTATUS)(s)))
#define capSetScrollPos(hwnd,lpP) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_SCROLL,(WPARAM)0,(LPARAM)(LPPOINT)(lpP)))

#define capGrabFrame(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_GRAB_FRAME,(WPARAM)0,(LPARAM)0))
#define capGrabFrameNoStop(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_GRAB_FRAME_NOSTOP,(WPARAM)0,(LPARAM)0))

#define capCaptureSequence(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SEQUENCE,(WPARAM)0,(LPARAM)0))
#define capCaptureSequenceNoFile(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SEQUENCE_NOFILE,(WPARAM)0,(LPARAM)0))
#define capCaptureStop(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_STOP,(WPARAM)0,(LPARAM)0))
#define capCaptureAbort(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_ABORT,(WPARAM)0,(LPARAM)0))

#define capCaptureSingleFrameOpen(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SINGLE_FRAME_OPEN,(WPARAM)0,(LPARAM)0))
#define capCaptureSingleFrameClose(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SINGLE_FRAME_CLOSE,(WPARAM)0,(LPARAM)0))
#define capCaptureSingleFrame(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SINGLE_FRAME,(WPARAM)0,(LPARAM)0))

#define capCaptureGetSetup(hwnd,s,wSize) ((WINBOOL)AVICapSM(hwnd,WM_CAP_GET_SEQUENCE_SETUP,(WPARAM)(wSize),(LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))
#define capCaptureSetSetup(hwnd,s,wSize) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_SEQUENCE_SETUP,(WPARAM)(wSize),(LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))

#define capSetMCIDeviceName(hwnd,szName) ((WINBOOL)AVICapSM(hwnd,WM_CAP_SET_MCI_DEVICE,(WPARAM)0,(LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capGetMCIDeviceName(hwnd,szName,wSize) ((WINBOOL)AVICapSM(hwnd,WM_CAP_GET_MCI_DEVICE,(WPARAM)(wSize),(LPARAM)(LPVOID)(LPTSTR)(szName)))

#define capPaletteOpen(hwnd,szName) ((WINBOOL)AVICapSM(hwnd,WM_CAP_PAL_OPEN,(WPARAM)0,(LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capPaletteSave(hwnd,szName) ((WINBOOL)AVICapSM(hwnd,WM_CAP_PAL_SAVE,(WPARAM)0,(LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capPalettePaste(hwnd) ((WINBOOL)AVICapSM(hwnd,WM_CAP_PAL_PASTE,(WPARAM) 0,(LPARAM)0))
#define capPaletteAuto(hwnd,iFrames,iColors) ((WINBOOL)AVICapSM(hwnd,WM_CAP_PAL_AUTOCREATE,(WPARAM)(iFrames),(LPARAM)(DWORD)(iColors)))
#define capPaletteManual(hwnd,fGrab,iColors) ((WINBOOL)AVICapSM(hwnd,WM_CAP_PAL_MANUALCREATE,(WPARAM)(fGrab),(LPARAM)(DWORD)(iColors)))

  typedef struct tagCapDriverCaps {
    UINT wDeviceIndex;
    WINBOOL fHasOverlay;
    WINBOOL fHasDlgVideoSource;
    WINBOOL fHasDlgVideoFormat;
    WINBOOL fHasDlgVideoDisplay;
    WINBOOL fCaptureInitialized;
    WINBOOL fDriverSuppliesPalettes;
    HANDLE hVideoIn;
    HANDLE hVideoOut;
    HANDLE hVideoExtIn;
    HANDLE hVideoExtOut;
  } CAPDRIVERCAPS,*PCAPDRIVERCAPS,*LPCAPDRIVERCAPS;

  typedef struct tagCapStatus {
    UINT uiImageWidth;
    UINT uiImageHeight;
    WINBOOL fLiveWindow;
    WINBOOL fOverlayWindow;
    WINBOOL fScale;
    POINT ptScroll;
    WINBOOL fUsingDefaultPalette;
    WINBOOL fAudioHardware;
    WINBOOL fCapFileExists;
    DWORD dwCurrentVideoFrame;
    DWORD dwCurrentVideoFramesDropped;
    DWORD dwCurrentWaveSamples;
    DWORD dwCurrentTimeElapsedMS;
    HPALETTE hPalCurrent;
    WINBOOL fCapturingNow;
    DWORD dwReturn;
    UINT wNumVideoAllocated;
    UINT wNumAudioAllocated;
  } CAPSTATUS,*PCAPSTATUS,*LPCAPSTATUS;

  typedef struct tagCaptureParms {
    DWORD dwRequestMicroSecPerFrame;
    WINBOOL fMakeUserHitOKToCapture;
    UINT wPercentDropForError;
    WINBOOL fYield;
    DWORD dwIndexSize;
    UINT wChunkGranularity;
    WINBOOL fUsingDOSMemory;
    UINT wNumVideoRequested;
    WINBOOL fCaptureAudio;
    UINT wNumAudioRequested;
    UINT vKeyAbort;
    WINBOOL fAbortLeftMouse;
    WINBOOL fAbortRightMouse;
    WINBOOL fLimitEnabled;
    UINT wTimeLimit;
    WINBOOL fMCIControl;
    WINBOOL fStepMCIDevice;
    DWORD dwMCIStartTime;
    DWORD dwMCIStopTime;
    WINBOOL fStepCaptureAt2x;
    UINT wStepCaptureAverageFrames;
    DWORD dwAudioBufferSize;
    WINBOOL fDisableWriteCache;
    UINT AVStreamMaster;
  } CAPTUREPARMS,*PCAPTUREPARMS,*LPCAPTUREPARMS;

#define AVSTREAMMASTER_AUDIO 0
#define AVSTREAMMASTER_NONE 1

  typedef struct tagCapInfoChunk {
    FOURCC fccInfoID;
    LPVOID lpData;
    LONG cbData;
  } CAPINFOCHUNK,*PCAPINFOCHUNK,*LPCAPINFOCHUNK;

  typedef LRESULT (CALLBACK *CAPYIELDCALLBACK)(HWND hWnd);
  typedef LRESULT (CALLBACK *CAPSTATUSCALLBACKW)(HWND hWnd,int nID,LPCWSTR lpsz);
  typedef LRESULT (CALLBACK *CAPERRORCALLBACKW)(HWND hWnd,int nID,LPCWSTR lpsz);
  typedef LRESULT (CALLBACK *CAPSTATUSCALLBACKA)(HWND hWnd,int nID,LPCSTR lpsz);
  typedef LRESULT (CALLBACK *CAPERRORCALLBACKA)(HWND hWnd,int nID,LPCSTR lpsz);

#define CAPSTATUSCALLBACK __MINGW_NAME_AW(CAPSTATUSCALLBACK)
#define CAPERRORCALLBACK __MINGW_NAME_AW(CAPERRORCALLBACK)

  typedef LRESULT (CALLBACK *CAPVIDEOCALLBACK)(HWND hWnd,LPVIDEOHDR lpVHdr);
  typedef LRESULT (CALLBACK *CAPWAVECALLBACK)(HWND hWnd,LPWAVEHDR lpWHdr);
  typedef LRESULT (CALLBACK *CAPCONTROLCALLBACK)(HWND hWnd,int nState);

#define CONTROLCALLBACK_PREROLL 1
#define CONTROLCALLBACK_CAPTURING 2

  HWND WINAPI capCreateCaptureWindowA (LPCSTR lpszWindowName,DWORD dwStyle,int x,int y,int nWidth,int nHeight,HWND hwndParent,int nID);
  WINBOOL WINAPI capGetDriverDescriptionA (UINT wDriverIndex,LPSTR lpszName,int cbName,LPSTR lpszVer,int cbVer);
  HWND WINAPI capCreateCaptureWindowW (LPCWSTR lpszWindowName,DWORD dwStyle,int x,int y,int nWidth,int nHeight,HWND hwndParent,int nID);
  WINBOOL WINAPI capGetDriverDescriptionW (UINT wDriverIndex,LPWSTR lpszName,int cbName,LPWSTR lpszVer,int cbVer);

#define capCreateCaptureWindow __MINGW_NAME_AW(capCreateCaptureWindow)
#define capGetDriverDescription __MINGW_NAME_AW(capGetDriverDescription)
#endif

#define infotypeDIGITIZATION_TIME mmioFOURCC ('I','D','I','T')
#define infotypeSMPTE_TIME mmioFOURCC ('I','S','M','P')

#define IDS_CAP_BEGIN 300
#define IDS_CAP_END 301

#define IDS_CAP_INFO 401
#define IDS_CAP_OUTOFMEM 402
#define IDS_CAP_FILEEXISTS 403
#define IDS_CAP_ERRORPALOPEN 404
#define IDS_CAP_ERRORPALSAVE 405
#define IDS_CAP_ERRORDIBSAVE 406
#define IDS_CAP_DEFAVIEXT 407
#define IDS_CAP_DEFPALEXT 408
#define IDS_CAP_CANTOPEN 409
#define IDS_CAP_SEQ_MSGSTART 410
#define IDS_CAP_SEQ_MSGSTOP 411

#define IDS_CAP_VIDEDITERR 412
#define IDS_CAP_READONLYFILE 413
#define IDS_CAP_WRITEERROR 414
#define IDS_CAP_NODISKSPACE 415
#define IDS_CAP_SETFILESIZE 416
#define IDS_CAP_SAVEASPERCENT 417

#define IDS_CAP_DRIVER_ERROR 418

#define IDS_CAP_WAVE_OPEN_ERROR 419
#define IDS_CAP_WAVE_ALLOC_ERROR 420
#define IDS_CAP_WAVE_PREPARE_ERROR 421
#define IDS_CAP_WAVE_ADD_ERROR 422
#define IDS_CAP_WAVE_SIZE_ERROR 423

#define IDS_CAP_VIDEO_OPEN_ERROR 424
#define IDS_CAP_VIDEO_ALLOC_ERROR 425
#define IDS_CAP_VIDEO_PREPARE_ERROR 426
#define IDS_CAP_VIDEO_ADD_ERROR 427
#define IDS_CAP_VIDEO_SIZE_ERROR 428

#define IDS_CAP_FILE_OPEN_ERROR 429
#define IDS_CAP_FILE_WRITE_ERROR 430
#define IDS_CAP_RECORDING_ERROR 431
#define IDS_CAP_RECORDING_ERROR2 432
#define IDS_CAP_AVI_INIT_ERROR 433
#define IDS_CAP_NO_FRAME_CAP_ERROR 434
#define IDS_CAP_NO_PALETTE_WARN 435
#define IDS_CAP_MCI_CONTROL_ERROR 436
#define IDS_CAP_MCI_CANT_STEP_ERROR 437
#define IDS_CAP_NO_AUDIO_CAP_ERROR 438
#define IDS_CAP_AVI_DRAWDIB_ERROR 439
#define IDS_CAP_COMPRESSOR_ERROR 440
#define IDS_CAP_AUDIO_DROP_ERROR 441
#define IDS_CAP_AUDIO_DROP_COMPERROR 442

#define IDS_CAP_STAT_LIVE_MODE 500
#define IDS_CAP_STAT_OVERLAY_MODE 501
#define IDS_CAP_STAT_CAP_INIT 502
#define IDS_CAP_STAT_CAP_FINI 503
#define IDS_CAP_STAT_PALETTE_BUILD 504
#define IDS_CAP_STAT_OPTPAL_BUILD 505
#define IDS_CAP_STAT_I_FRAMES 506
#define IDS_CAP_STAT_L_FRAMES 507
#define IDS_CAP_STAT_CAP_L_FRAMES 508
#define IDS_CAP_STAT_CAP_AUDIO 509
#define IDS_CAP_STAT_VIDEOCURRENT 510
#define IDS_CAP_STAT_VIDEOAUDIO 511
#define IDS_CAP_STAT_VIDEOONLY 512
#define IDS_CAP_STAT_FRAMESDROPPED 513
#endif

#ifdef __cplusplus
}
#endif

#ifndef NOMSACM
#include <msacm.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef OFN_READONLY
  WINBOOL WINAPI GetOpenFileNamePreviewA(LPOPENFILENAMEA lpofn);
  WINBOOL WINAPI GetSaveFileNamePreviewA(LPOPENFILENAMEA lpofn);
  WINBOOL WINAPI GetOpenFileNamePreviewW(LPOPENFILENAMEW lpofn);
  WINBOOL WINAPI GetSaveFileNamePreviewW(LPOPENFILENAMEW lpofn);

#define GetOpenFileNamePreview __MINGW_NAME_AW(GetOpenFileNamePreview)
#define GetSaveFileNamePreview __MINGW_NAME_AW(GetSaveFileNamePreview)
#endif

#ifndef RC_INVOKED
#include "poppack.h"
#endif

#ifdef __cplusplus
}
#endif
#endif
    usr/share/mingw-w64/include/vfwmsgs.h                                                               0100644 0000000 0000000 00000023241 12404413014 016202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (C) 2002 Alexandre Julliard
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
 */

#define VFW_S_NO_MORE_ITEMS              ((HRESULT)0x00040103)
#define VFW_S_DUPLICATE_NAME             ((HRESULT)0x0004022D)
#define VFW_S_STATE_INTERMEDIATE         ((HRESULT)0x00040237)
#define VFW_S_PARTIAL_RENDER             ((HRESULT)0x00040242)
#define VFW_S_SOME_DATA_IGNORED          ((HRESULT)0x00040245)
#define VFW_S_CONNECTIONS_DEFERRED       ((HRESULT)0x00040246)
#define VFW_S_RESOURCE_NOT_NEEDED        ((HRESULT)0x00040250)
#define VFW_S_MEDIA_TYPE_IGNORED         ((HRESULT)0x00040254)
#define VFW_S_VIDEO_NOT_RENDERED         ((HRESULT)0x00040257)
#define VFW_S_AUDIO_NOT_RENDERED         ((HRESULT)0x00040258)
#define VFW_S_RPZA                       ((HRESULT)0x0004025A)
#define VFW_S_ESTIMATED                  ((HRESULT)0x00040260)
#define VFW_S_RESERVED                   ((HRESULT)0x00040263)
#define VFW_S_STREAM_OFF                 ((HRESULT)0x00040267)
#define VFW_S_CANT_CUE                   ((HRESULT)0x00040268)
#define VFW_S_NO_STOP_TIME               ((HRESULT)0x00040270)
#define VFW_S_NOPREVIEWPIN               ((HRESULT)0x0004027E)
#define VFW_S_DVD_NON_ONE_SEQUENTIAL     ((HRESULT)0x00040280)
#define VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE ((HRESULT)0x0004028C)
#define VFW_S_DVD_NOT_ACCURATE           ((HRESULT)0x0004028D)
#define VFW_E_INVALIDMEDIATYPE           ((HRESULT)0x80040200)
#define VFW_E_INVALIDSUBTYPE             ((HRESULT)0x80040201)
#define VFW_E_NEED_OWNER                 ((HRESULT)0x80040202)
#define VFW_E_ENUM_OUT_OF_SYNC           ((HRESULT)0x80040203)
#define VFW_E_ALREADY_CONNECTED          ((HRESULT)0x80040204)
#define VFW_E_FILTER_ACTIVE              ((HRESULT)0x80040205)
#define VFW_E_NO_TYPES                   ((HRESULT)0x80040206)
#define VFW_E_NO_ACCEPTABLE_TYPES        ((HRESULT)0x80040207)
#define VFW_E_INVALID_DIRECTION          ((HRESULT)0x80040208)
#define VFW_E_NOT_CONNECTED              ((HRESULT)0x80040209)
#define VFW_E_NO_ALLOCATOR               ((HRESULT)0x8004020A)
#define VFW_E_RUNTIME_ERROR              ((HRESULT)0x8004020B)
#define VFW_E_BUFFER_NOTSET              ((HRESULT)0x8004020C)
#define VFW_E_BUFFER_OVERFLOW            ((HRESULT)0x8004020D)
#define VFW_E_BADALIGN                   ((HRESULT)0x8004020E)
#define VFW_E_ALREADY_COMMITTED          ((HRESULT)0x8004020F)
#define VFW_E_BUFFERS_OUTSTANDING        ((HRESULT)0x80040210)
#define VFW_E_NOT_COMMITTED              ((HRESULT)0x80040211)
#define VFW_E_SIZENOTSET                 ((HRESULT)0x80040212)
#define VFW_E_NO_CLOCK                   ((HRESULT)0x80040213)
#define VFW_E_NO_SINK                    ((HRESULT)0x80040214)
#define VFW_E_NO_INTERFACE               ((HRESULT)0x80040215)
#define VFW_E_NOT_FOUND                  ((HRESULT)0x80040216)
#define VFW_E_CANNOT_CONNECT             ((HRESULT)0x80040217)
#define VFW_E_CANNOT_RENDER              ((HRESULT)0x80040218)
#define VFW_E_CHANGING_FORMAT            ((HRESULT)0x80040219)
#define VFW_E_NO_COLOR_KEY_SET           ((HRESULT)0x8004021A)
#define VFW_E_NOT_OVERLAY_CONNECTION     ((HRESULT)0x8004021B)
#define VFW_E_NOT_SAMPLE_CONNECTION      ((HRESULT)0x8004021C)
#define VFW_E_PALETTE_SET                ((HRESULT)0x8004021D)
#define VFW_E_COLOR_KEY_SET              ((HRESULT)0x8004021E)
#define VFW_E_NO_COLOR_KEY_FOUND         ((HRESULT)0x8004021F)
#define VFW_E_NO_PALETTE_AVAILABLE       ((HRESULT)0x80040220)
#define VFW_E_NO_DISPLAY_PALETTE         ((HRESULT)0x80040221)
#define VFW_E_TOO_MANY_COLORS            ((HRESULT)0x80040222)
#define VFW_E_STATE_CHANGED              ((HRESULT)0x80040223)
#define VFW_E_NOT_STOPPED                ((HRESULT)0x80040224)
#define VFW_E_NOT_PAUSED                 ((HRESULT)0x80040225)
#define VFW_E_NOT_RUNNING                ((HRESULT)0x80040226)
#define VFW_E_WRONG_STATE                ((HRESULT)0x80040227)
#define VFW_E_START_TIME_AFTER_END       ((HRESULT)0x80040228)
#define VFW_E_INVALID_RECT               ((HRESULT)0x80040229)
#define VFW_E_TYPE_NOT_ACCEPTED          ((HRESULT)0x8004022A)
#define VFW_E_SAMPLE_REJECTED            ((HRESULT)0x8004022B)
#define VFW_E_SAMPLE_REJECTED_EOS        ((HRESULT)0x8004022C)
#define VFW_E_DUPLICATE_NAME             ((HRESULT)0x8004022D)
#define VFW_E_TIMEOUT                    ((HRESULT)0x8004022E)
#define VFW_E_INVALID_FILE_FORMAT        ((HRESULT)0x8004022F)
#define VFW_E_ENUM_OUT_OF_RANGE          ((HRESULT)0x80040230)
#define VFW_E_CIRCULAR_GRAPH             ((HRESULT)0x80040231)
#define VFW_E_NOT_ALLOWED_TO_SAVE        ((HRESULT)0x80040232)
#define VFW_E_TIME_ALREADY_PASSED        ((HRESULT)0x80040233)
#define VFW_E_ALREADY_CANCELLED          ((HRESULT)0x80040234)
#define VFW_E_CORRUPT_GRAPH_FILE         ((HRESULT)0x80040235)
#define VFW_E_ADVISE_ALREADY_SET         ((HRESULT)0x80040236)
#define VFW_E_NO_MODEX_AVAILABLE         ((HRESULT)0x80040238)
#define VFW_E_NO_ADVISE_SET              ((HRESULT)0x80040239)
#define VFW_E_NO_FULLSCREEN              ((HRESULT)0x8004023A)
#define VFW_E_IN_FULLSCREEN_MODE         ((HRESULT)0x8004023B)
#define VFW_E_UNKNOWN_FILE_TYPE          ((HRESULT)0x80040240)
#define VFW_E_CANNOT_LOAD_SOURCE_FILTER  ((HRESULT)0x80040241)
#define VFW_E_FILE_TOO_SHORT             ((HRESULT)0x80040243)
#define VFW_E_INVALID_FILE_VERSION       ((HRESULT)0x80040244)
#define VFW_E_INVALID_CLSID              ((HRESULT)0x80040247)
#define VFW_E_INVALID_MEDIA_TYPE         ((HRESULT)0x80040248)
#define VFW_E_SAMPLE_TIME_NOT_SET        ((HRESULT)0x80040249)
#define VFW_E_MEDIA_TIME_NOT_SET         ((HRESULT)0x80040251)
#define VFW_E_NO_TIME_FORMAT_SET         ((HRESULT)0x80040252)
#define VFW_E_MONO_AUDIO_HW              ((HRESULT)0x80040253)
#define VFW_E_NO_DECOMPRESSOR            ((HRESULT)0x80040255)
#define VFW_E_NO_AUDIO_HARDWARE          ((HRESULT)0x80040256)
#define VFW_E_RPZA                       ((HRESULT)0x80040259)
#define VFW_E_PROCESSOR_NOT_SUITABLE     ((HRESULT)0x8004025B)
#define VFW_E_UNSUPPORTED_AUDIO          ((HRESULT)0x8004025C)
#define VFW_E_UNSUPPORTED_VIDEO          ((HRESULT)0x8004025D)
#define VFW_E_MPEG_NOT_CONSTRAINED       ((HRESULT)0x8004025E)
#define VFW_E_NOT_IN_GRAPH               ((HRESULT)0x8004025F)
#define VFW_E_NO_TIME_FORMAT             ((HRESULT)0x80040261)
#define VFW_E_READ_ONLY                  ((HRESULT)0x80040262)
#define VFW_E_BUFFER_UNDERFLOW           ((HRESULT)0x80040264)
#define VFW_E_UNSUPPORTED_STREAM         ((HRESULT)0x80040265)
#define VFW_E_NO_TRANSPORT               ((HRESULT)0x80040266)
#define VFW_E_BAD_VIDEOCD                ((HRESULT)0x80040269)
#define VFW_E_OUT_OF_VIDEO_MEMORY        ((HRESULT)0x80040271)
#define VFW_E_VP_NEGOTIATION_FAILED      ((HRESULT)0x80040272)
#define VFW_E_DDRAW_CAPS_NOT_SUITABLE    ((HRESULT)0x80040273)
#define VFW_E_NO_VP_HARDWARE             ((HRESULT)0x80040274)
#define VFW_E_NO_CAPTURE_HARDWARE        ((HRESULT)0x80040275)
#define VFW_E_DVD_OPERATION_INHIBITED    ((HRESULT)0x80040276)
#define VFW_E_DVD_INVALIDDOMAIN          ((HRESULT)0x80040277)
#define VFW_E_DVD_NO_BUTTON              ((HRESULT)0x80040278)
#define VFW_E_DVD_GRAPHNOTREADY          ((HRESULT)0x80040279)
#define VFW_E_DVD_RENDERFAIL             ((HRESULT)0x8004027A)
#define VFW_E_DVD_DECNOTENOUGH           ((HRESULT)0x8004027B)
#define VFW_E_DDRAW_VERSION_NOT_SUITABLE ((HRESULT)0x8004027C)
#define VFW_E_COPYPROT_FAILED            ((HRESULT)0x8004027D)
#define VFW_E_TIME_EXPIRED               ((HRESULT)0x8004027F)
#define VFW_E_DVD_WRONG_SPEED            ((HRESULT)0x80040281)
#define VFW_E_DVD_MENU_DOES_NOT_EXIST    ((HRESULT)0x80040282)
#define VFW_E_DVD_CMD_CANCELLED          ((HRESULT)0x80040283)
#define VFW_E_DVD_STATE_WRONG_VERSION    ((HRESULT)0x80040284)
#define VFW_E_DVD_STATE_CORRUPT          ((HRESULT)0x80040285)
#define VFW_E_DVD_STATE_WRONG_DISC       ((HRESULT)0x80040286)
#define VFW_E_DVD_INCOMPATIBLE_REGION    ((HRESULT)0x80040287)
#define VFW_E_DVD_NO_ATTRIBUTES          ((HRESULT)0x80040288)
#define VFW_E_DVD_NO_GOUP_PGC            ((HRESULT)0x80040289)
#define VFW_E_DVD_LOW_PARENTAL_LEVEL     ((HRESULT)0x8004028A)
#define VFW_E_DVD_NOT_IN_KARAOKE_MODE    ((HRESULT)0x8004028B)
#define VFW_E_FRAME_STEP_UNSUPPORTED     ((HRESULT)0x8004028E)
#define VFW_E_DVD_STREAM_DISABLED        ((HRESULT)0x8004028F)
#define VFW_E_DVD_TITLE_UNKNOWN          ((HRESULT)0x80040290)
#define VFW_E_DVD_INVALID_DISC           ((HRESULT)0x80040291)
#define VFW_E_DVD_NO_RESUME_INFORMATION  ((HRESULT)0x80040292)
#define VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD ((HRESULT)0x80040293)
#define VFW_E_PIN_ALREADY_BLOCKED        ((HRESULT)0x80040294)
#define VFW_E_CERTIFICATION_FAILURE      ((HRESULT)0x80040295)
#define VFW_E_VMR_NOT_IN_MIXER_MODE      ((HRESULT)0x80040296)
#define VFW_E_VMR_NO_AP_SUPPLIED         ((HRESULT)0x80040297)
#define VFW_E_VMR_NO_DEINTERLACE_HW      ((HRESULT)0x80040298)
#define VFW_E_DVD_VMR9_INCOMPATIBLEDEC   ((HRESULT)0x8004029A)
#define VFW_E_BAD_KEY                    ((HRESULT)0x800403F2)

#ifndef E_PROP_ID_UNSUPPORTED
#define E_PROP_ID_UNSUPPORTED            ((HRESULT)0x80070490)
#endif
#ifndef E_PROP_SET_UNSUPPORTED
#define E_PROP_SET_UNSUPPORTED           ((HRESULT)0x80070492)
#endif
                                                                                                                                                                                                                                                                                                                                                               usr/share/mingw-w64/include/virtdisk.h                                                              0100644 0000000 0000000 00000027121 12404413016 016350  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_VIRTDISK
#define _INC_VIRTDISK

#if (_WIN32_WINNT >= 0x0601)
#ifdef __cplusplus
extern "C" {
#endif

#define VIRTDISKAPI DECLSPEC_IMPORT

typedef enum _ATTACH_VIRTUAL_DISK_FLAG {
  ATTACH_VIRTUAL_DISK_FLAG_NONE                 = 0x00000000,
  ATTACH_VIRTUAL_DISK_FLAG_READ_ONLY            = 0x00000001,
  ATTACH_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER      = 0x00000002,
  ATTACH_VIRTUAL_DISK_FLAG_PERMANENT_LIFETIME   = 0x00000004,
  ATTACH_VIRTUAL_DISK_FLAG_NO_LOCAL_HOST        = 0x00000008 
} ATTACH_VIRTUAL_DISK_FLAG;

typedef enum _ATTACH_VIRTUAL_DISK_VERSION {
  ATTACH_VIRTUAL_DISK_VERSION_UNSPECIFIED   = 0,
  ATTACH_VIRTUAL_DISK_VERSION_1             = 1 
} ATTACH_VIRTUAL_DISK_VERSION;

typedef enum _COMPACT_VIRTUAL_DISK_FLAG {
  COMPACT_VIRTUAL_DISK_FLAG_NONE   = 0x00000000 
} COMPACT_VIRTUAL_DISK_FLAG;

typedef enum _COMPACT_VIRTUAL_DISK_VERSION {
  COMPACT_VIRTUAL_DISK_VERSION_UNSPECIFIED   = 0,
  COMPACT_VIRTUAL_DISK_VERSION_1             = 1 
} COMPACT_VIRTUAL_DISK_VERSION;

typedef enum _CREATE_VIRTUAL_DISK_FLAG {
  CREATE_VIRTUAL_DISK_FLAG_NONE                       = 0x00000000,
  CREATE_VIRTUAL_DISK_FLAG_FULL_PHYSICAL_ALLOCATION   = 0x00000001 
} CREATE_VIRTUAL_DISK_FLAG;

typedef enum _CREATE_VIRTUAL_DISK_VERSION {
  CREATE_VIRTUAL_DISK_VERSION_UNSPECIFIED   = 0,
  CREATE_VIRTUAL_DISK_VERSION_1             = 1 
} CREATE_VIRTUAL_DISK_VERSION;

typedef enum _DEPENDENT_DISK_FLAG {
  DEPENDENT_DISK_FLAG_NONE                   = 0x00000000,
  DEPENDENT_DISK_FLAG_MULT_BACKING_FILES     = 0x00000001,
  DEPENDENT_DISK_FLAG_FULLY_ALLOCATED        = 0x00000002,
  DEPENDENT_DISK_FLAG_READ_ONLY              = 0x00000004,
  DEPENDENT_DISK_FLAG_REMOTE                 = 0x00000008,
  DEPENDENT_DISK_FLAG_SYSTEM_VOLUME          = 0x00000010,
  DEPENDENT_DISK_FLAG_SYSTEM_VOLUME_PARENT   = 0x00000020,
  DEPENDENT_DISK_FLAG_REMOVABLE              = 0x00000040,
  DEPENDENT_DISK_FLAG_NO_DRIVE_LETTER        = 0x00000080,
  DEPENDENT_DISK_FLAG_PARENT                 = 0x00000100,
  DEPENDENT_DISK_FLAG_NO_HOST_DISK           = 0x00000200,
  DEPENDENT_DISK_FLAG_PERMANENT_LIFETIME     = 0x00000400 
} DEPENDENT_DISK_FLAG;

typedef enum _EXPAND_VIRTUAL_DISK_VERSION {
  EXPAND_VIRTUAL_DISK_VERSION_UNSPECIFIED   = 0,
  EXPAND_VIRTUAL_DISK_VERSION_1             = 1 
} EXPAND_VIRTUAL_DISK_VERSION;

typedef enum _DETACH_VIRTUAL_DISK_FLAG {
  DETACH_VIRTUAL_DISK_FLAG_NONE   = 0x00000000 
} DETACH_VIRTUAL_DISK_FLAG;

typedef enum _EXPAND_VIRTUAL_DISK_FLAG {
  EXPAND_VIRTUAL_DISK_FLAG_NONE   = 0x00000000 
} EXPAND_VIRTUAL_DISK_FLAG;

typedef enum _GET_STORAGE_DEPENDENCY_FLAG {
  GET_STORAGE_DEPENDENCY_FLAG_NONE           = 0x00000000,
  GET_STORAGE_DEPENDENCY_FLAG_HOST_VOLUMES   = 0x00000001,
  GET_STORAGE_DEPENDENCY_FLAG_DISK_HANDLE    = 0x00000002 
} GET_STORAGE_DEPENDENCY_FLAG;

typedef enum _GET_VIRTUAL_DISK_INFO_VERSION {
  GET_VIRTUAL_DISK_INFO_UNSPECIFIED            = 0,
  GET_VIRTUAL_DISK_INFO_SIZE                   = 1,
  GET_VIRTUAL_DISK_INFO_IDENTIFIER             = 2,
  GET_VIRTUAL_DISK_INFO_PARENT_LOCATION        = 3,
  GET_VIRTUAL_DISK_INFO_PARENT_IDENTIFIER      = 4,
  GET_VIRTUAL_DISK_INFO_PARENT_TIMESTAMP       = 5,
  GET_VIRTUAL_DISK_INFO_VIRTUAL_STORAGE_TYPE   = 6,
  GET_VIRTUAL_DISK_INFO_PROVIDER_SUBTYPE       = 7 
} GET_VIRTUAL_DISK_INFO_VERSION;

typedef enum _MERGE_VIRTUAL_DISK_FLAG {
  MERGE_VIRTUAL_DISK_FLAG_NONE   = 0x00000000 
} MERGE_VIRTUAL_DISK_FLAG;

typedef enum _MERGE_VIRTUAL_DISK_VERSION {
  MERGE_VIRTUAL_DISK_VERSION_UNSPECIFIED   = 0,
  MERGE_VIRTUAL_DISK_VERSION_1             = 1 
} MERGE_VIRTUAL_DISK_VERSION;

typedef enum _OPEN_VIRTUAL_DISK_FLAG {
  OPEN_VIRTUAL_DISK_FLAG_NONE         = 0x00000000,
  OPEN_VIRTUAL_DISK_FLAG_NO_PARENTS   = 0x00000001,
  OPEN_VIRTUAL_DISK_FLAG_BLANK_FILE   = 0x00000002,
  OPEN_VIRTUAL_DISK_FLAG_BOOT_DRIVE   = 0x00000004 
} OPEN_VIRTUAL_DISK_FLAG;

typedef enum _OPEN_VIRTUAL_DISK_VERSION {
  OPEN_VIRTUAL_DISK_VERSION_UNSPECIFIED   = 0,
  OPEN_VIRTUAL_DISK_VERSION_1             = 1 
} OPEN_VIRTUAL_DISK_VERSION;

typedef enum _SET_VIRTUAL_DISK_INFO_VERSION {
  SET_VIRTUAL_DISK_INFO_UNSPECIFIED   = 0,
  SET_VIRTUAL_DISK_INFO_PARENT_PATH   = 1,
  SET_VIRTUAL_DISK_INFO_IDENTIFIER    = 2 
} SET_VIRTUAL_DISK_INFO_VERSION;

typedef enum _STORAGE_DEPENDENCY_INFO_VERSION {
  STORAGE_DEPENDENCY_INFO_VERSION_UNSPECIFIED   = 0,
  STORAGE_DEPENDENCY_INFO_VERSION_1             = 1,
  STORAGE_DEPENDENCY_INFO_VERSION_2             = 2 
} STORAGE_DEPENDENCY_INFO_VERSION;

typedef enum _VIRTUAL_DISK_ACCESS_MASK {
  VIRTUAL_DISK_ACCESS_ATTACH_RO   = 0x00010000,
  VIRTUAL_DISK_ACCESS_ATTACH_RW   = 0x00020000,
  VIRTUAL_DISK_ACCESS_DETACH      = 0x00040000,
  VIRTUAL_DISK_ACCESS_GET_INFO    = 0x00080000,
  VIRTUAL_DISK_ACCESS_CREATE      = 0x00100000,
  VIRTUAL_DISK_ACCESS_METAOPS     = 0x00200000,
  VIRTUAL_DISK_ACCESS_READ        = 0x000d0000,
  VIRTUAL_DISK_ACCESS_ALL         = 0x003f0000,
  VIRTUAL_DISK_ACCESS_WRITABLE    = 0x00320000 
} VIRTUAL_DISK_ACCESS_MASK;

typedef struct _VIRTUAL_STORAGE_TYPE {
  ULONG DeviceId;
  GUID  VendorId;
} VIRTUAL_STORAGE_TYPE, *PVIRTUAL_STORAGE_TYPE;

typedef struct _ATTACH_VIRTUAL_DISK_PARAMETERS {
  ATTACH_VIRTUAL_DISK_VERSION Version;
  __C89_NAMELESS union {
    struct {
      ULONG Reserved;
    } Version1;
  } DUMMYUNIONNAME;
} ATTACH_VIRTUAL_DISK_PARAMETERS, *PATTACH_VIRTUAL_DISK_PARAMETERS;

typedef struct _COMPACT_VIRTUAL_DISK_PARAMETERS {
  COMPACT_VIRTUAL_DISK_VERSION Version;
  __C89_NAMELESS union {
    struct {
      ULONG Reserved;
    } Version1;
  } DUMMYUNIONNAME;
} COMPACT_VIRTUAL_DISK_PARAMETERS, *PCOMPACT_VIRTUAL_DISK_PARAMETERS;

typedef struct _CREATE_VIRTUAL_DISK_PARAMETERS {
  CREATE_VIRTUAL_DISK_VERSION Version;
  __C89_NAMELESS union {
    struct {
      GUID      UniqueId;
      ULONGLONG MaximumSize;
      ULONG     BlockSizeInBytes;
      ULONG     SectorSizeInBytes;
      PCWSTR    ParentPath;
      PCWSTR    SourcePath;
    } Version1;
  } DUMMYUNIONNAME;
} CREATE_VIRTUAL_DISK_PARAMETERS, *PCREATE_VIRTUAL_DISK_PARAMETERS;

typedef struct _EXPAND_VIRTUAL_DISK_PARAMETERS {
  EXPAND_VIRTUAL_DISK_VERSION Version;
  __C89_NAMELESS union {
    struct {
      ULONGLONG NewSize;
    } Version1;
  } DUMMYUNIONNAME;
} EXPAND_VIRTUAL_DISK_PARAMETERS, *PEXPAND_VIRTUAL_DISK_PARAMETERS;

typedef struct _GET_VIRTUAL_DISK_INFO {
  GET_VIRTUAL_DISK_INFO_VERSION Version;
  __C89_NAMELESS union {
    struct {
      ULONGLONG VirtualSize;
      ULONGLONG PhysicalSize;
      ULONG     BlockSize;
      ULONG     SectorSize;
    } Size;
    GUID                 Identifier;
    struct {
      BOOL  ParentResolved;
      WCHAR ParentLocationBuffer[1];
    } ParentLocation;
    GUID                 ParentIdentifier;
    ULONG                ParentTimestamp;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
    ULONG                ProviderSubtype;
  } DUMMYUNIONNAME;
} GET_VIRTUAL_DISK_INFO, *PGET_VIRTUAL_DISK_INFO;

typedef struct _MERGE_VIRTUAL_DISK_PARAMETERS {
  MERGE_VIRTUAL_DISK_VERSION Version;
  __C89_NAMELESS union {
    struct {
      ULONG MergeDepth;
    } Version1;
  } DUMMYUNIONNAME;
} MERGE_VIRTUAL_DISK_PARAMETERS, *PMERGE_VIRTUAL_DISK_PARAMETERS;

typedef struct _OPEN_VIRTUAL_DISK_PARAMETERS {
  OPEN_VIRTUAL_DISK_VERSION Version;
  __C89_NAMELESS union {
    struct {
      ULONG RWDepth;
    } Version1;
  } DUMMYUNIONNAME;
} OPEN_VIRTUAL_DISK_PARAMETERS, *POPEN_VIRTUAL_DISK_PARAMETERS;

typedef struct _SET_VIRTUAL_DISK_INFO {
  SET_VIRTUAL_DISK_INFO_VERSION Version;
  __C89_NAMELESS union {
    PCWSTR ParentFilePath;
    GUID   UniqueIdentifier;
  } DUMMYUNIONNAME;
} SET_VIRTUAL_DISK_INFO, *PSET_VIRTUAL_DISK_INFO;

typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_1 {
  DEPENDENT_DISK_FLAG  DependencyTypeFlags;
  ULONG                ProviderSpecificFlags;
  VIRTUAL_STORAGE_TYPE VirtualStorageType;
} STORAGE_DEPENDENCY_INFO_TYPE_1, *PSTORAGE_DEPENDENCY_INFO_TYPE_1;

typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_2 {
  DEPENDENT_DISK_FLAG  DependencyTypeFlags;
  ULONG                ProviderSpecificFlags;
  VIRTUAL_STORAGE_TYPE VirtualStorageType;
  ULONG                AncestorLevel;
  PWSTR                DependencyDeviceName;
  PWSTR                HostVolumeName;
  PWSTR                DependentVolumeName;
  PWSTR                DependentVolumeRelativePath;
} STORAGE_DEPENDENCY_INFO_TYPE_2, *PSTORAGE_DEPENDENCY_INFO_TYPE_2;

/* Fixme: Suppress GCC errors about "error: flexible array member in union" */

typedef struct _STORAGE_DEPENDENCY_INFO {
  STORAGE_DEPENDENCY_INFO_VERSION Version;
  ULONG                           NumberEntries;
  __C89_NAMELESS union {
    STORAGE_DEPENDENCY_INFO_TYPE_1 Version1Entries[1];
    STORAGE_DEPENDENCY_INFO_TYPE_2 Version2Entries[1];
  } DUMMYUNIONNAME;
} STORAGE_DEPENDENCY_INFO, *PSTORAGE_DEPENDENCY_INFO;

typedef struct _VIRTUAL_DISK_PROGRESS {
  DWORD     OperationStatus;
  ULONGLONG CurrentValue;
  ULONGLONG CompletionValue;
} VIRTUAL_DISK_PROGRESS, *PVIRTUAL_DISK_PROGRESS;

#define VIRTUAL_STORAGE_TYPE_DEVICE_UNKNOWN 0
#define VIRTUAL_STORAGE_TYPE_DEVICE_ISO 1
#define VIRTUAL_STORAGE_TYPE_DEVICE_VHD 2

DEFINE_GUID(VIRTUAL_STORAGE_TYPE_VENDOR_MICROSOFT,0xEC984AEC,0xA0F9,0x47e9,0x90,0x1F,0x71,0x41,0x5A,0x66,0x34,0x5B);

VIRTDISKAPI DWORD WINAPI AttachVirtualDisk(
  HANDLE VirtualDiskHandle,
  PSECURITY_DESCRIPTOR SecurityDescriptor,
  ATTACH_VIRTUAL_DISK_FLAG Flags,
  ULONG ProviderSpecificFlags,
  PATTACH_VIRTUAL_DISK_PARAMETERS Parameters,
  LPOVERLAPPED Overlapped
);

VIRTDISKAPI DWORD WINAPI CompactVirtualDisk(
  HANDLE VirtualDiskHandle,
  COMPACT_VIRTUAL_DISK_FLAG Flags,
  PCOMPACT_VIRTUAL_DISK_PARAMETERS Parameters,
  LPOVERLAPPED Overlapped
);

VIRTDISKAPI DWORD WINAPI CreateVirtualDisk(
  PVIRTUAL_STORAGE_TYPE VirtualStorageType,
  PCWSTR Path,
  VIRTUAL_DISK_ACCESS_MASK VirtualDiskAccessMask,
  PSECURITY_DESCRIPTOR SecurityDescriptor,
  CREATE_VIRTUAL_DISK_FLAG Flags,
  ULONG ProviderSpecificFlags,
  PCREATE_VIRTUAL_DISK_PARAMETERS Parameters,
  LPOVERLAPPED Overlapped,
  PHANDLE Handle
);

VIRTDISKAPI DWORD WINAPI DetachVirtualDisk(
  HANDLE VirtualDiskHandle,
  DETACH_VIRTUAL_DISK_FLAG Flags,
  ULONG ProviderSpecificFlags
);

VIRTDISKAPI DWORD WINAPI ExpandVirtualDisk(
  HANDLE VirtualDiskHandle,
  EXPAND_VIRTUAL_DISK_FLAG Flags,
  PEXPAND_VIRTUAL_DISK_PARAMETERS Parameters,
  LPOVERLAPPED Overlapped
);

VIRTDISKAPI DWORD WINAPI GetStorageDependencyInformation(
  HANDLE ObjectHandle,
  GET_STORAGE_DEPENDENCY_FLAG Flags,
  ULONG StorageDependencyInfoSize,
  PSTORAGE_DEPENDENCY_INFO StorageDependencyInfo,
  PULONG SizeUsed
);

VIRTDISKAPI DWORD WINAPI GetVirtualDiskInformation(
  HANDLE VirtualDiskHandle,
  PULONG VirtualDiskInfoSize,
  PGET_VIRTUAL_DISK_INFO VirtualDiskInfo,
  PULONG SizeUsed
);

VIRTDISKAPI DWORD WINAPI GetVirtualDiskOperationProgress(
  HANDLE VirtualDiskHandle,
  LPOVERLAPPED Overlapped,
  PVIRTUAL_DISK_PROGRESS Progress
);

DWORD WINAPI GetVirtualDiskPhysicalPath(
  HANDLE VirtualDiskHandle,
  PULONG DiskPathSizeInBytes,
  PWSTR DiskPath
);

VIRTDISKAPI DWORD WINAPI MergeVirtualDisk(
  HANDLE VirtualDiskHandle,
  MERGE_VIRTUAL_DISK_FLAG Flags,
  PMERGE_VIRTUAL_DISK_PARAMETERS Parameters,
  LPOVERLAPPED Overlapped
);

VIRTDISKAPI DWORD WINAPI OpenVirtualDisk(
  PVIRTUAL_STORAGE_TYPE VirtualStorageType,
  PCWSTR Path,
  VIRTUAL_DISK_ACCESS_MASK VirtualDiskAccessMask,
  OPEN_VIRTUAL_DISK_FLAG Flags,
  POPEN_VIRTUAL_DISK_PARAMETERS Parameters,
  PHANDLE Handle
);

VIRTDISKAPI DWORD WINAPI SetVirtualDiskInformation(
  HANDLE VirtualDiskHandle,
  PSET_VIRTUAL_DISK_INFO VirtualDiskInfo
);

#ifdef __cplusplus
}
#endif
#endif /*(_WIN32_WINNT >= 0x0601)*/
#endif /*_INC_VIRTDISK*/
                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/share/mingw-w64/include/vmr9.h                                                                  0100644 0000000 0000000 00000326066 12404413014 015416  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*** Autogenerated by WIDL 1.5.25 from direct-x/include/vmr9.idl - Do not edit ***/

#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include <rpc.h>
#include <rpcndr.h>

#ifndef COM_NO_WINDOWS_H
#include <windows.h>
#include <ole2.h>
#endif

#ifndef __vmr9_h__
#define __vmr9_h__

/* Forward declarations */

#ifndef __IVMRImagePresenter9_FWD_DEFINED__
#define __IVMRImagePresenter9_FWD_DEFINED__
typedef interface IVMRImagePresenter9 IVMRImagePresenter9;
#endif

#ifndef __IVMRSurfaceAllocator9_FWD_DEFINED__
#define __IVMRSurfaceAllocator9_FWD_DEFINED__
typedef interface IVMRSurfaceAllocator9 IVMRSurfaceAllocator9;
#endif

#ifndef __IVMRSurfaceAllocatorEx9_FWD_DEFINED__
#define __IVMRSurfaceAllocatorEx9_FWD_DEFINED__
typedef interface IVMRSurfaceAllocatorEx9 IVMRSurfaceAllocatorEx9;
#endif

#ifndef __IVMRSurfaceAllocatorNotify9_FWD_DEFINED__
#define __IVMRSurfaceAllocatorNotify9_FWD_DEFINED__
typedef interface IVMRSurfaceAllocatorNotify9 IVMRSurfaceAllocatorNotify9;
#endif

#ifndef __IVMRWindowlessControl9_FWD_DEFINED__
#define __IVMRWindowlessControl9_FWD_DEFINED__
typedef interface IVMRWindowlessControl9 IVMRWindowlessControl9;
#endif

#ifndef __IVMRMixerControl9_FWD_DEFINED__
#define __IVMRMixerControl9_FWD_DEFINED__
typedef interface IVMRMixerControl9 IVMRMixerControl9;
#endif

#ifndef __IVMRMixerBitmap9_FWD_DEFINED__
#define __IVMRMixerBitmap9_FWD_DEFINED__
typedef interface IVMRMixerBitmap9 IVMRMixerBitmap9;
#endif

#ifndef __IVMRSurface9_FWD_DEFINED__
#define __IVMRSurface9_FWD_DEFINED__
typedef interface IVMRSurface9 IVMRSurface9;
#endif

#ifndef __IVMRImagePresenterConfig9_FWD_DEFINED__
#define __IVMRImagePresenterConfig9_FWD_DEFINED__
typedef interface IVMRImagePresenterConfig9 IVMRImagePresenterConfig9;
#endif

#ifndef __IVMRVideoStreamControl9_FWD_DEFINED__
#define __IVMRVideoStreamControl9_FWD_DEFINED__
typedef interface IVMRVideoStreamControl9 IVMRVideoStreamControl9;
#endif

#ifndef __IVMRFilterConfig9_FWD_DEFINED__
#define __IVMRFilterConfig9_FWD_DEFINED__
typedef interface IVMRFilterConfig9 IVMRFilterConfig9;
#endif

#ifndef __IVMRAspectRatioControl9_FWD_DEFINED__
#define __IVMRAspectRatioControl9_FWD_DEFINED__
typedef interface IVMRAspectRatioControl9 IVMRAspectRatioControl9;
#endif

#ifndef __IVMRMonitorConfig9_FWD_DEFINED__
#define __IVMRMonitorConfig9_FWD_DEFINED__
typedef interface IVMRMonitorConfig9 IVMRMonitorConfig9;
#endif

#ifndef __IVMRDeinterlaceControl9_FWD_DEFINED__
#define __IVMRDeinterlaceControl9_FWD_DEFINED__
typedef interface IVMRDeinterlaceControl9 IVMRDeinterlaceControl9;
#endif

#ifndef __IVMRImageCompositor9_FWD_DEFINED__
#define __IVMRImageCompositor9_FWD_DEFINED__
typedef interface IVMRImageCompositor9 IVMRImageCompositor9;
#endif

/* Headers for imported files */

#include <unknwn.h>

#ifdef __cplusplus
extern "C" {
#endif

#if 0
#ifndef __IDirect3DSurface9_FWD_DEFINED__
#define __IDirect3DSurface9_FWD_DEFINED__
typedef interface IDirect3DSurface9 IDirect3DSurface9;
#endif

#ifndef __IDirect3DDevice9_FWD_DEFINED__
#define __IDirect3DDevice9_FWD_DEFINED__
typedef interface IDirect3DDevice9 IDirect3DDevice9;
#endif

typedef LONGLONG REFERENCE_TIME;
typedef DWORD D3DFORMAT;
typedef DWORD D3DPOOL;
typedef HANDLE HMONITOR;
typedef struct __WIDL_vmr9_generated_name_00000000 {
    char dummy;
} AM_MEDIA_TYPE;
typedef struct __WIDL_vmr9_generated_name_00000001 {
    char dummy;
} D3DCOLOR;
#endif
#ifndef __IVMRSurface9_FWD_DEFINED__
#define __IVMRSurface9_FWD_DEFINED__
typedef interface IVMRSurface9 IVMRSurface9;
#endif

#ifndef __IVMRSurfaceAllocator9_FWD_DEFINED__
#define __IVMRSurfaceAllocator9_FWD_DEFINED__
typedef interface IVMRSurfaceAllocator9 IVMRSurfaceAllocator9;
#endif

#ifndef __IVMRSurfaceAllocatorEx9_FWD_DEFINED__
#define __IVMRSurfaceAllocatorEx9_FWD_DEFINED__
typedef interface IVMRSurfaceAllocatorEx9 IVMRSurfaceAllocatorEx9;
#endif

#ifndef __IVMRSurfaceAllocatorNotify9_FWD_DEFINED__
#define __IVMRSurfaceAllocatorNotify9_FWD_DEFINED__
typedef interface IVMRSurfaceAllocatorNotify9 IVMRSurfaceAllocatorNotify9;
#endif

#ifndef __IVMRImagePresenter9_FWD_DEFINED__
#define __IVMRImagePresenter9_FWD_DEFINED__
typedef interface IVMRImagePresenter9 IVMRImagePresenter9;
#endif

#ifndef __IVMRImagePresenterConfig9_FWD_DEFINED__
#define __IVMRImagePresenterConfig9_FWD_DEFINED__
typedef interface IVMRImagePresenterConfig9 IVMRImagePresenterConfig9;
#endif

#ifndef __IVMRMonitorConfig9_FWD_DEFINED__
#define __IVMRMonitorConfig9_FWD_DEFINED__
typedef interface IVMRMonitorConfig9 IVMRMonitorConfig9;
#endif

#ifndef __IVMRWindowlessControl9_FWD_DEFINED__
#define __IVMRWindowlessControl9_FWD_DEFINED__
typedef interface IVMRWindowlessControl9 IVMRWindowlessControl9;
#endif

#ifndef __IVMRMixerControl9_FWD_DEFINED__
#define __IVMRMixerControl9_FWD_DEFINED__
typedef interface IVMRMixerControl9 IVMRMixerControl9;
#endif

#ifndef __IVMRImageCompositor9_FWD_DEFINED__
#define __IVMRImageCompositor9_FWD_DEFINED__
typedef interface IVMRImageCompositor9 IVMRImageCompositor9;
#endif

#ifndef __IVMRMixerBitmap9_FWD_DEFINED__
#define __IVMRMixerBitmap9_FWD_DEFINED__
typedef interface IVMRMixerBitmap9 IVMRMixerBitmap9;
#endif

#ifndef __IVMRFilterConfig9_FWD_DEFINED__
#define __IVMRFilterConfig9_FWD_DEFINED__
typedef interface IVMRFilterConfig9 IVMRFilterConfig9;
#endif

#ifndef __IVMRAspectRatioControl9_FWD_DEFINED__
#define __IVMRAspectRatioControl9_FWD_DEFINED__
typedef interface IVMRAspectRatioControl9 IVMRAspectRatioControl9;
#endif

#ifndef __IVMRVideoStreamControl9_FWD_DEFINED__
#define __IVMRVideoStreamControl9_FWD_DEFINED__
typedef interface IVMRVideoStreamControl9 IVMRVideoStreamControl9;
#endif

typedef enum _VMR9PresentationFlags {
    VMR9Sample_SyncPoint = 0x1,
    VMR9Sample_Preroll = 0x2,
    VMR9Sample_Discontinuity = 0x4,
    VMR9Sample_TimeValid = 0x8,
    VMR9Sample_SrcDstRectsValid = 0x10
} VMR9PresentationFlags;
typedef struct _VMR9PresentationInfo {
    DWORD dwFlags;
    IDirect3DSurface9 *lpSurf;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtEnd;
    SIZE szAspectRatio;
    RECT rcSrc;
    RECT rcDst;
    DWORD dwReserved1;
    DWORD dwReserved2;
} VMR9PresentationInfo;
/*****************************************************************************
 * IVMRImagePresenter9 interface
 */
#ifndef __IVMRImagePresenter9_INTERFACE_DEFINED__
#define __IVMRImagePresenter9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRImagePresenter9, 0x69188c61, 0x12a3, 0x40f0, 0x8f,0xfc, 0x34,0x2e,0x7b,0x43,0x3f,0xd7);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("69188c61-12a3-40f0-8ffc-342e7b433fd7")
IVMRImagePresenter9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE StartPresenting(
        DWORD_PTR id) = 0;

    virtual HRESULT STDMETHODCALLTYPE StopPresenting(
        DWORD_PTR id) = 0;

    virtual HRESULT STDMETHODCALLTYPE PresentImage(
        DWORD_PTR id,
        VMR9PresentationInfo *info) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRImagePresenter9, 0x69188c61, 0x12a3, 0x40f0, 0x8f,0xfc, 0x34,0x2e,0x7b,0x43,0x3f,0xd7)
#endif
#else
typedef struct IVMRImagePresenter9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRImagePresenter9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRImagePresenter9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRImagePresenter9* This);

    /*** IVMRImagePresenter9 methods ***/
    HRESULT (STDMETHODCALLTYPE *StartPresenting)(
        IVMRImagePresenter9* This,
        DWORD_PTR id);

    HRESULT (STDMETHODCALLTYPE *StopPresenting)(
        IVMRImagePresenter9* This,
        DWORD_PTR id);

    HRESULT (STDMETHODCALLTYPE *PresentImage)(
        IVMRImagePresenter9* This,
        DWORD_PTR id,
        VMR9PresentationInfo *info);

    END_INTERFACE
} IVMRImagePresenter9Vtbl;
interface IVMRImagePresenter9 {
    CONST_VTBL IVMRImagePresenter9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRImagePresenter9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRImagePresenter9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRImagePresenter9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRImagePresenter9 methods ***/
#define IVMRImagePresenter9_StartPresenting(This,id) (This)->lpVtbl->StartPresenting(This,id)
#define IVMRImagePresenter9_StopPresenting(This,id) (This)->lpVtbl->StopPresenting(This,id)
#define IVMRImagePresenter9_PresentImage(This,id,info) (This)->lpVtbl->PresentImage(This,id,info)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRImagePresenter9_QueryInterface(IVMRImagePresenter9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRImagePresenter9_AddRef(IVMRImagePresenter9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRImagePresenter9_Release(IVMRImagePresenter9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRImagePresenter9 methods ***/
static FORCEINLINE HRESULT IVMRImagePresenter9_StartPresenting(IVMRImagePresenter9* This,DWORD_PTR id) {
    return This->lpVtbl->StartPresenting(This,id);
}
static FORCEINLINE HRESULT IVMRImagePresenter9_StopPresenting(IVMRImagePresenter9* This,DWORD_PTR id) {
    return This->lpVtbl->StopPresenting(This,id);
}
static FORCEINLINE HRESULT IVMRImagePresenter9_PresentImage(IVMRImagePresenter9* This,DWORD_PTR id,VMR9PresentationInfo *info) {
    return This->lpVtbl->PresentImage(This,id,info);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRImagePresenter9_StartPresenting_Proxy(
    IVMRImagePresenter9* This,
    DWORD_PTR id);
void __RPC_STUB IVMRImagePresenter9_StartPresenting_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRImagePresenter9_StopPresenting_Proxy(
    IVMRImagePresenter9* This,
    DWORD_PTR id);
void __RPC_STUB IVMRImagePresenter9_StopPresenting_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRImagePresenter9_PresentImage_Proxy(
    IVMRImagePresenter9* This,
    DWORD_PTR id,
    VMR9PresentationInfo *info);
void __RPC_STUB IVMRImagePresenter9_PresentImage_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRImagePresenter9_INTERFACE_DEFINED__ */

typedef enum _VMR9SurfaceAllocationFlags {
    VMR9AllocFlag_3DRenderTarget = 0x1,
    VMR9AllocFlag_DXVATarget = 0x2,
    VMR9AllocFlag_TextureSurface = 0x4,
    VMR9AllocFlag_OffscreenSurface = 0x8,
    VMR9AllocFlag_RGBDynamicSwitch = 0x10,
    VMR9AllocFlag_UsageReserved = 0xe0,
    VMR9AllocFlag_UsageMask = 0xff
} VMR9SurfaceAllocationFlags;
typedef struct _VMR9AllocationInfo {
    DWORD dwFlags;
    DWORD dwWidth;
    DWORD dwHeight;
    D3DFORMAT Format;
    D3DPOOL Pool;
    DWORD MinBuffers;
    SIZE szAspectRatio;
    SIZE szNativeSize;
} VMR9AllocationInfo;
/*****************************************************************************
 * IVMRSurfaceAllocator9 interface
 */
#ifndef __IVMRSurfaceAllocator9_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocator9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRSurfaceAllocator9, 0x8d5148ea, 0x3f5d, 0x46cf, 0x9d,0xf1, 0xd1,0xb8,0x96,0xee,0xdb,0x1f);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("8d5148ea-3f5d-46cf-9df1-d1b896eedb1f")
IVMRSurfaceAllocator9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE InitializeDevice(
        DWORD_PTR id,
        VMR9AllocationInfo *allocinfo,
        DWORD *numbuffers) = 0;

    virtual HRESULT STDMETHODCALLTYPE TerminateDevice(
        DWORD_PTR id) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetSurface(
        DWORD_PTR id,
        DWORD surfaceindex,
        DWORD flags,
        IDirect3DSurface9 **surface) = 0;

    virtual HRESULT STDMETHODCALLTYPE AdviseNotify(
        IVMRSurfaceAllocatorNotify9 *allocnotify) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRSurfaceAllocator9, 0x8d5148ea, 0x3f5d, 0x46cf, 0x9d,0xf1, 0xd1,0xb8,0x96,0xee,0xdb,0x1f)
#endif
#else
typedef struct IVMRSurfaceAllocator9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRSurfaceAllocator9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRSurfaceAllocator9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRSurfaceAllocator9* This);

    /*** IVMRSurfaceAllocator9 methods ***/
    HRESULT (STDMETHODCALLTYPE *InitializeDevice)(
        IVMRSurfaceAllocator9* This,
        DWORD_PTR id,
        VMR9AllocationInfo *allocinfo,
        DWORD *numbuffers);

    HRESULT (STDMETHODCALLTYPE *TerminateDevice)(
        IVMRSurfaceAllocator9* This,
        DWORD_PTR id);

    HRESULT (STDMETHODCALLTYPE *GetSurface)(
        IVMRSurfaceAllocator9* This,
        DWORD_PTR id,
        DWORD surfaceindex,
        DWORD flags,
        IDirect3DSurface9 **surface);

    HRESULT (STDMETHODCALLTYPE *AdviseNotify)(
        IVMRSurfaceAllocator9* This,
        IVMRSurfaceAllocatorNotify9 *allocnotify);

    END_INTERFACE
} IVMRSurfaceAllocator9Vtbl;
interface IVMRSurfaceAllocator9 {
    CONST_VTBL IVMRSurfaceAllocator9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRSurfaceAllocator9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRSurfaceAllocator9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRSurfaceAllocator9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRSurfaceAllocator9 methods ***/
#define IVMRSurfaceAllocator9_InitializeDevice(This,id,allocinfo,numbuffers) (This)->lpVtbl->InitializeDevice(This,id,allocinfo,numbuffers)
#define IVMRSurfaceAllocator9_TerminateDevice(This,id) (This)->lpVtbl->TerminateDevice(This,id)
#define IVMRSurfaceAllocator9_GetSurface(This,id,surfaceindex,flags,surface) (This)->lpVtbl->GetSurface(This,id,surfaceindex,flags,surface)
#define IVMRSurfaceAllocator9_AdviseNotify(This,allocnotify) (This)->lpVtbl->AdviseNotify(This,allocnotify)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRSurfaceAllocator9_QueryInterface(IVMRSurfaceAllocator9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRSurfaceAllocator9_AddRef(IVMRSurfaceAllocator9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRSurfaceAllocator9_Release(IVMRSurfaceAllocator9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRSurfaceAllocator9 methods ***/
static FORCEINLINE HRESULT IVMRSurfaceAllocator9_InitializeDevice(IVMRSurfaceAllocator9* This,DWORD_PTR id,VMR9AllocationInfo *allocinfo,DWORD *numbuffers) {
    return This->lpVtbl->InitializeDevice(This,id,allocinfo,numbuffers);
}
static FORCEINLINE HRESULT IVMRSurfaceAllocator9_TerminateDevice(IVMRSurfaceAllocator9* This,DWORD_PTR id) {
    return This->lpVtbl->TerminateDevice(This,id);
}
static FORCEINLINE HRESULT IVMRSurfaceAllocator9_GetSurface(IVMRSurfaceAllocator9* This,DWORD_PTR id,DWORD surfaceindex,DWORD flags,IDirect3DSurface9 **surface) {
    return This->lpVtbl->GetSurface(This,id,surfaceindex,flags,surface);
}
static FORCEINLINE HRESULT IVMRSurfaceAllocator9_AdviseNotify(IVMRSurfaceAllocator9* This,IVMRSurfaceAllocatorNotify9 *allocnotify) {
    return This->lpVtbl->AdviseNotify(This,allocnotify);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocator9_InitializeDevice_Proxy(
    IVMRSurfaceAllocator9* This,
    DWORD_PTR id,
    VMR9AllocationInfo *allocinfo,
    DWORD *numbuffers);
void __RPC_STUB IVMRSurfaceAllocator9_InitializeDevice_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocator9_TerminateDevice_Proxy(
    IVMRSurfaceAllocator9* This,
    DWORD_PTR id);
void __RPC_STUB IVMRSurfaceAllocator9_TerminateDevice_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocator9_GetSurface_Proxy(
    IVMRSurfaceAllocator9* This,
    DWORD_PTR id,
    DWORD surfaceindex,
    DWORD flags,
    IDirect3DSurface9 **surface);
void __RPC_STUB IVMRSurfaceAllocator9_GetSurface_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocator9_AdviseNotify_Proxy(
    IVMRSurfaceAllocator9* This,
    IVMRSurfaceAllocatorNotify9 *allocnotify);
void __RPC_STUB IVMRSurfaceAllocator9_AdviseNotify_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRSurfaceAllocator9_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IVMRSurfaceAllocatorEx9 interface
 */
#ifndef __IVMRSurfaceAllocatorEx9_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocatorEx9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRSurfaceAllocatorEx9, 0x6de9a68a, 0xa928, 0x4522, 0xbf,0x57, 0x65,0x5a,0xe3,0x86,0x64,0x56);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("6de9a68a-a928-4522-bf57-655ae3866456")
IVMRSurfaceAllocatorEx9 : public IVMRSurfaceAllocator9
{
    virtual HRESULT STDMETHODCALLTYPE GetSurfaceEx(
        DWORD_PTR id,
        DWORD surfaceindex,
        DWORD flags,
        IDirect3DSurface9 **surface,
        RECT *dest) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRSurfaceAllocatorEx9, 0x6de9a68a, 0xa928, 0x4522, 0xbf,0x57, 0x65,0x5a,0xe3,0x86,0x64,0x56)
#endif
#else
typedef struct IVMRSurfaceAllocatorEx9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRSurfaceAllocatorEx9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRSurfaceAllocatorEx9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRSurfaceAllocatorEx9* This);

    /*** IVMRSurfaceAllocator9 methods ***/
    HRESULT (STDMETHODCALLTYPE *InitializeDevice)(
        IVMRSurfaceAllocatorEx9* This,
        DWORD_PTR id,
        VMR9AllocationInfo *allocinfo,
        DWORD *numbuffers);

    HRESULT (STDMETHODCALLTYPE *TerminateDevice)(
        IVMRSurfaceAllocatorEx9* This,
        DWORD_PTR id);

    HRESULT (STDMETHODCALLTYPE *GetSurface)(
        IVMRSurfaceAllocatorEx9* This,
        DWORD_PTR id,
        DWORD surfaceindex,
        DWORD flags,
        IDirect3DSurface9 **surface);

    HRESULT (STDMETHODCALLTYPE *AdviseNotify)(
        IVMRSurfaceAllocatorEx9* This,
        IVMRSurfaceAllocatorNotify9 *allocnotify);

    /*** IVMRSurfaceAllocatorEx9 methods ***/
    HRESULT (STDMETHODCALLTYPE *GetSurfaceEx)(
        IVMRSurfaceAllocatorEx9* This,
        DWORD_PTR id,
        DWORD surfaceindex,
        DWORD flags,
        IDirect3DSurface9 **surface,
        RECT *dest);

    END_INTERFACE
} IVMRSurfaceAllocatorEx9Vtbl;
interface IVMRSurfaceAllocatorEx9 {
    CONST_VTBL IVMRSurfaceAllocatorEx9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRSurfaceAllocatorEx9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRSurfaceAllocatorEx9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRSurfaceAllocatorEx9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRSurfaceAllocator9 methods ***/
#define IVMRSurfaceAllocatorEx9_InitializeDevice(This,id,allocinfo,numbuffers) (This)->lpVtbl->InitializeDevice(This,id,allocinfo,numbuffers)
#define IVMRSurfaceAllocatorEx9_TerminateDevice(This,id) (This)->lpVtbl->TerminateDevice(This,id)
#define IVMRSurfaceAllocatorEx9_GetSurface(This,id,surfaceindex,flags,surface) (This)->lpVtbl->GetSurface(This,id,surfaceindex,flags,surface)
#define IVMRSurfaceAllocatorEx9_AdviseNotify(This,allocnotify) (This)->lpVtbl->AdviseNotify(This,allocnotify)
/*** IVMRSurfaceAllocatorEx9 methods ***/
#define IVMRSurfaceAllocatorEx9_GetSurfaceEx(This,id,surfaceindex,flags,surface,dest) (This)->lpVtbl->GetSurfaceEx(This,id,surfaceindex,flags,surface,dest)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRSurfaceAllocatorEx9_QueryInterface(IVMRSurfaceAllocatorEx9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRSurfaceAllocatorEx9_AddRef(IVMRSurfaceAllocatorEx9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRSurfaceAllocatorEx9_Release(IVMRSurfaceAllocatorEx9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRSurfaceAllocator9 methods ***/
static FORCEINLINE HRESULT IVMRSurfaceAllocatorEx9_InitializeDevice(IVMRSurfaceAllocatorEx9* This,DWORD_PTR id,VMR9AllocationInfo *allocinfo,DWORD *numbuffers) {
    return This->lpVtbl->InitializeDevice(This,id,allocinfo,numbuffers);
}
static FORCEINLINE HRESULT IVMRSurfaceAllocatorEx9_TerminateDevice(IVMRSurfaceAllocatorEx9* This,DWORD_PTR id) {
    return This->lpVtbl->TerminateDevice(This,id);
}
static FORCEINLINE HRESULT IVMRSurfaceAllocatorEx9_GetSurface(IVMRSurfaceAllocatorEx9* This,DWORD_PTR id,DWORD surfaceindex,DWORD flags,IDirect3DSurface9 **surface) {
    return This->lpVtbl->GetSurface(This,id,surfaceindex,flags,surface);
}
static FORCEINLINE HRESULT IVMRSurfaceAllocatorEx9_AdviseNotify(IVMRSurfaceAllocatorEx9* This,IVMRSurfaceAllocatorNotify9 *allocnotify) {
    return This->lpVtbl->AdviseNotify(This,allocnotify);
}
/*** IVMRSurfaceAllocatorEx9 methods ***/
static FORCEINLINE HRESULT IVMRSurfaceAllocatorEx9_GetSurfaceEx(IVMRSurfaceAllocatorEx9* This,DWORD_PTR id,DWORD surfaceindex,DWORD flags,IDirect3DSurface9 **surface,RECT *dest) {
    return This->lpVtbl->GetSurfaceEx(This,id,surfaceindex,flags,surface,dest);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorEx9_GetSurfaceEx_Proxy(
    IVMRSurfaceAllocatorEx9* This,
    DWORD_PTR id,
    DWORD surfaceindex,
    DWORD flags,
    IDirect3DSurface9 **surface,
    RECT *dest);
void __RPC_STUB IVMRSurfaceAllocatorEx9_GetSurfaceEx_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRSurfaceAllocatorEx9_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IVMRSurfaceAllocatorNotify9 interface
 */
#ifndef __IVMRSurfaceAllocatorNotify9_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocatorNotify9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRSurfaceAllocatorNotify9, 0xdca3f5df, 0xbb3a, 0x4d03, 0xbd,0x81, 0x84,0x61,0x4b,0xfb,0xfa,0x0c);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("dca3f5df-bb3a-4d03-bd81-84614bfbfa0c")
IVMRSurfaceAllocatorNotify9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE AdviseSurfaceAllocator(
        DWORD_PTR id,
        IVMRSurfaceAllocator9 *alloc) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetD3DDevice(
        IDirect3DDevice9 *device,
        HMONITOR monitor) = 0;

    virtual HRESULT STDMETHODCALLTYPE ChangeD3DDevice(
        IDirect3DDevice9 *device,
        HMONITOR monitor) = 0;

    virtual HRESULT STDMETHODCALLTYPE AllocateSurfaceHelper(
        VMR9AllocationInfo *allocinfo,
        DWORD *numbuffers,
        IDirect3DSurface9 **surface) = 0;

    virtual HRESULT STDMETHODCALLTYPE NotifyEvent(
        LONG code,
        LONG_PTR param1,
        LONG_PTR param2) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRSurfaceAllocatorNotify9, 0xdca3f5df, 0xbb3a, 0x4d03, 0xbd,0x81, 0x84,0x61,0x4b,0xfb,0xfa,0x0c)
#endif
#else
typedef struct IVMRSurfaceAllocatorNotify9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRSurfaceAllocatorNotify9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRSurfaceAllocatorNotify9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRSurfaceAllocatorNotify9* This);

    /*** IVMRSurfaceAllocatorNotify9 methods ***/
    HRESULT (STDMETHODCALLTYPE *AdviseSurfaceAllocator)(
        IVMRSurfaceAllocatorNotify9* This,
        DWORD_PTR id,
        IVMRSurfaceAllocator9 *alloc);

    HRESULT (STDMETHODCALLTYPE *SetD3DDevice)(
        IVMRSurfaceAllocatorNotify9* This,
        IDirect3DDevice9 *device,
        HMONITOR monitor);

    HRESULT (STDMETHODCALLTYPE *ChangeD3DDevice)(
        IVMRSurfaceAllocatorNotify9* This,
        IDirect3DDevice9 *device,
        HMONITOR monitor);

    HRESULT (STDMETHODCALLTYPE *AllocateSurfaceHelper)(
        IVMRSurfaceAllocatorNotify9* This,
        VMR9AllocationInfo *allocinfo,
        DWORD *numbuffers,
        IDirect3DSurface9 **surface);

    HRESULT (STDMETHODCALLTYPE *NotifyEvent)(
        IVMRSurfaceAllocatorNotify9* This,
        LONG code,
        LONG_PTR param1,
        LONG_PTR param2);

    END_INTERFACE
} IVMRSurfaceAllocatorNotify9Vtbl;
interface IVMRSurfaceAllocatorNotify9 {
    CONST_VTBL IVMRSurfaceAllocatorNotify9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRSurfaceAllocatorNotify9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRSurfaceAllocatorNotify9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRSurfaceAllocatorNotify9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRSurfaceAllocatorNotify9 methods ***/
#define IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(This,id,alloc) (This)->lpVtbl->AdviseSurfaceAllocator(This,id,alloc)
#define IVMRSurfaceAllocatorNotify9_SetD3DDevice(This,device,monitor) (This)->lpVtbl->SetD3DDevice(This,device,monitor)
#define IVMRSurfaceAllocatorNotify9_ChangeD3DDevice(This,device,monitor) (This)->lpVtbl->ChangeD3DDevice(This,device,monitor)
#define IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(This,allocinfo,numbuffers,surface) (This)->lpVtbl->AllocateSurfaceHelper(This,allocinfo,numbuffers,surface)
#define IVMRSurfaceAllocatorNotify9_NotifyEvent(This,code,param1,param2) (This)->lpVtbl->NotifyEvent(This,code,param1,param2)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRSurfaceAllocatorNotify9_QueryInterface(IVMRSurfaceAllocatorNotify9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRSurfaceAllocatorNotify9_AddRef(IVMRSurfaceAllocatorNotify9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRSurfaceAllocatorNotify9_Release(IVMRSurfaceAllocatorNotify9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRSurfaceAllocatorNotify9 methods ***/
static FORCEINLINE HRESULT IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(IVMRSurfaceAllocatorNotify9* This,DWORD_PTR id,IVMRSurfaceAllocator9 *alloc) {
    return This->lpVtbl->AdviseSurfaceAllocator(This,id,alloc);
}
static FORCEINLINE HRESULT IVMRSurfaceAllocatorNotify9_SetD3DDevice(IVMRSurfaceAllocatorNotify9* This,IDirect3DDevice9 *device,HMONITOR monitor) {
    return This->lpVtbl->SetD3DDevice(This,device,monitor);
}
static FORCEINLINE HRESULT IVMRSurfaceAllocatorNotify9_ChangeD3DDevice(IVMRSurfaceAllocatorNotify9* This,IDirect3DDevice9 *device,HMONITOR monitor) {
    return This->lpVtbl->ChangeD3DDevice(This,device,monitor);
}
static FORCEINLINE HRESULT IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(IVMRSurfaceAllocatorNotify9* This,VMR9AllocationInfo *allocinfo,DWORD *numbuffers,IDirect3DSurface9 **surface) {
    return This->lpVtbl->AllocateSurfaceHelper(This,allocinfo,numbuffers,surface);
}
static FORCEINLINE HRESULT IVMRSurfaceAllocatorNotify9_NotifyEvent(IVMRSurfaceAllocatorNotify9* This,LONG code,LONG_PTR param1,LONG_PTR param2) {
    return This->lpVtbl->NotifyEvent(This,code,param1,param2);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator_Proxy(
    IVMRSurfaceAllocatorNotify9* This,
    DWORD_PTR id,
    IVMRSurfaceAllocator9 *alloc);
void __RPC_STUB IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorNotify9_SetD3DDevice_Proxy(
    IVMRSurfaceAllocatorNotify9* This,
    IDirect3DDevice9 *device,
    HMONITOR monitor);
void __RPC_STUB IVMRSurfaceAllocatorNotify9_SetD3DDevice_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorNotify9_ChangeD3DDevice_Proxy(
    IVMRSurfaceAllocatorNotify9* This,
    IDirect3DDevice9 *device,
    HMONITOR monitor);
void __RPC_STUB IVMRSurfaceAllocatorNotify9_ChangeD3DDevice_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper_Proxy(
    IVMRSurfaceAllocatorNotify9* This,
    VMR9AllocationInfo *allocinfo,
    DWORD *numbuffers,
    IDirect3DSurface9 **surface);
void __RPC_STUB IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorNotify9_NotifyEvent_Proxy(
    IVMRSurfaceAllocatorNotify9* This,
    LONG code,
    LONG_PTR param1,
    LONG_PTR param2);
void __RPC_STUB IVMRSurfaceAllocatorNotify9_NotifyEvent_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRSurfaceAllocatorNotify9_INTERFACE_DEFINED__ */

typedef enum _VMR9AspectRatioMode {
    VMR9ARMode_None = 0,
    VMR9ARMode_LetterBox = 1
} VMR9AspectRatioMode;
/*****************************************************************************
 * IVMRWindowlessControl9 interface
 */
#ifndef __IVMRWindowlessControl9_INTERFACE_DEFINED__
#define __IVMRWindowlessControl9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRWindowlessControl9, 0x8f537d09, 0xf85e, 0x4414, 0xb2,0x3b, 0x50,0x2e,0x54,0xc7,0x99,0x27);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("8f537d09-f85e-4414-b23b-502e54c79927")
IVMRWindowlessControl9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetNativeVideoSize(
        LONG *width,
        LONG *height,
        LONG *arwidth,
        LONG *arheight) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetMinIdealVideoSize(
        LONG *width,
        LONG *height) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetMaxIdealVideoSize(
        LONG *width,
        LONG *height) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetVideoPosition(
        const RECT *source,
        const RECT *dest) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetVideoPosition(
        RECT *source,
        RECT *dest) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetAspectRatioMode(
        DWORD *mode) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetAspectRatioMode(
        DWORD mode) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetVideoClippingWindow(
        HWND hwnd) = 0;

    virtual HRESULT STDMETHODCALLTYPE RepaintVideo(
        HWND hwnd,
        HDC hdc) = 0;

    virtual HRESULT STDMETHODCALLTYPE DisplayModeChanged(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetCurrentImage(
        BYTE **dib) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetBorderColor(
        COLORREF color) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBorderColor(
        COLORREF *color) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRWindowlessControl9, 0x8f537d09, 0xf85e, 0x4414, 0xb2,0x3b, 0x50,0x2e,0x54,0xc7,0x99,0x27)
#endif
#else
typedef struct IVMRWindowlessControl9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRWindowlessControl9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRWindowlessControl9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRWindowlessControl9* This);

    /*** IVMRWindowlessControl9 methods ***/
    HRESULT (STDMETHODCALLTYPE *GetNativeVideoSize)(
        IVMRWindowlessControl9* This,
        LONG *width,
        LONG *height,
        LONG *arwidth,
        LONG *arheight);

    HRESULT (STDMETHODCALLTYPE *GetMinIdealVideoSize)(
        IVMRWindowlessControl9* This,
        LONG *width,
        LONG *height);

    HRESULT (STDMETHODCALLTYPE *GetMaxIdealVideoSize)(
        IVMRWindowlessControl9* This,
        LONG *width,
        LONG *height);

    HRESULT (STDMETHODCALLTYPE *SetVideoPosition)(
        IVMRWindowlessControl9* This,
        const RECT *source,
        const RECT *dest);

    HRESULT (STDMETHODCALLTYPE *GetVideoPosition)(
        IVMRWindowlessControl9* This,
        RECT *source,
        RECT *dest);

    HRESULT (STDMETHODCALLTYPE *GetAspectRatioMode)(
        IVMRWindowlessControl9* This,
        DWORD *mode);

    HRESULT (STDMETHODCALLTYPE *SetAspectRatioMode)(
        IVMRWindowlessControl9* This,
        DWORD mode);

    HRESULT (STDMETHODCALLTYPE *SetVideoClippingWindow)(
        IVMRWindowlessControl9* This,
        HWND hwnd);

    HRESULT (STDMETHODCALLTYPE *RepaintVideo)(
        IVMRWindowlessControl9* This,
        HWND hwnd,
        HDC hdc);

    HRESULT (STDMETHODCALLTYPE *DisplayModeChanged)(
        IVMRWindowlessControl9* This);

    HRESULT (STDMETHODCALLTYPE *GetCurrentImage)(
        IVMRWindowlessControl9* This,
        BYTE **dib);

    HRESULT (STDMETHODCALLTYPE *SetBorderColor)(
        IVMRWindowlessControl9* This,
        COLORREF color);

    HRESULT (STDMETHODCALLTYPE *GetBorderColor)(
        IVMRWindowlessControl9* This,
        COLORREF *color);

    END_INTERFACE
} IVMRWindowlessControl9Vtbl;
interface IVMRWindowlessControl9 {
    CONST_VTBL IVMRWindowlessControl9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRWindowlessControl9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRWindowlessControl9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRWindowlessControl9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRWindowlessControl9 methods ***/
#define IVMRWindowlessControl9_GetNativeVideoSize(This,width,height,arwidth,arheight) (This)->lpVtbl->GetNativeVideoSize(This,width,height,arwidth,arheight)
#define IVMRWindowlessControl9_GetMinIdealVideoSize(This,width,height) (This)->lpVtbl->GetMinIdealVideoSize(This,width,height)
#define IVMRWindowlessControl9_GetMaxIdealVideoSize(This,width,height) (This)->lpVtbl->GetMaxIdealVideoSize(This,width,height)
#define IVMRWindowlessControl9_SetVideoPosition(This,source,dest) (This)->lpVtbl->SetVideoPosition(This,source,dest)
#define IVMRWindowlessControl9_GetVideoPosition(This,source,dest) (This)->lpVtbl->GetVideoPosition(This,source,dest)
#define IVMRWindowlessControl9_GetAspectRatioMode(This,mode) (This)->lpVtbl->GetAspectRatioMode(This,mode)
#define IVMRWindowlessControl9_SetAspectRatioMode(This,mode) (This)->lpVtbl->SetAspectRatioMode(This,mode)
#define IVMRWindowlessControl9_SetVideoClippingWindow(This,hwnd) (This)->lpVtbl->SetVideoClippingWindow(This,hwnd)
#define IVMRWindowlessControl9_RepaintVideo(This,hwnd,hdc) (This)->lpVtbl->RepaintVideo(This,hwnd,hdc)
#define IVMRWindowlessControl9_DisplayModeChanged(This) (This)->lpVtbl->DisplayModeChanged(This)
#define IVMRWindowlessControl9_GetCurrentImage(This,dib) (This)->lpVtbl->GetCurrentImage(This,dib)
#define IVMRWindowlessControl9_SetBorderColor(This,color) (This)->lpVtbl->SetBorderColor(This,color)
#define IVMRWindowlessControl9_GetBorderColor(This,color) (This)->lpVtbl->GetBorderColor(This,color)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRWindowlessControl9_QueryInterface(IVMRWindowlessControl9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRWindowlessControl9_AddRef(IVMRWindowlessControl9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRWindowlessControl9_Release(IVMRWindowlessControl9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRWindowlessControl9 methods ***/
static FORCEINLINE HRESULT IVMRWindowlessControl9_GetNativeVideoSize(IVMRWindowlessControl9* This,LONG *width,LONG *height,LONG *arwidth,LONG *arheight) {
    return This->lpVtbl->GetNativeVideoSize(This,width,height,arwidth,arheight);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_GetMinIdealVideoSize(IVMRWindowlessControl9* This,LONG *width,LONG *height) {
    return This->lpVtbl->GetMinIdealVideoSize(This,width,height);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_GetMaxIdealVideoSize(IVMRWindowlessControl9* This,LONG *width,LONG *height) {
    return This->lpVtbl->GetMaxIdealVideoSize(This,width,height);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_SetVideoPosition(IVMRWindowlessControl9* This,const RECT *source,const RECT *dest) {
    return This->lpVtbl->SetVideoPosition(This,source,dest);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_GetVideoPosition(IVMRWindowlessControl9* This,RECT *source,RECT *dest) {
    return This->lpVtbl->GetVideoPosition(This,source,dest);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_GetAspectRatioMode(IVMRWindowlessControl9* This,DWORD *mode) {
    return This->lpVtbl->GetAspectRatioMode(This,mode);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_SetAspectRatioMode(IVMRWindowlessControl9* This,DWORD mode) {
    return This->lpVtbl->SetAspectRatioMode(This,mode);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_SetVideoClippingWindow(IVMRWindowlessControl9* This,HWND hwnd) {
    return This->lpVtbl->SetVideoClippingWindow(This,hwnd);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_RepaintVideo(IVMRWindowlessControl9* This,HWND hwnd,HDC hdc) {
    return This->lpVtbl->RepaintVideo(This,hwnd,hdc);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_DisplayModeChanged(IVMRWindowlessControl9* This) {
    return This->lpVtbl->DisplayModeChanged(This);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_GetCurrentImage(IVMRWindowlessControl9* This,BYTE **dib) {
    return This->lpVtbl->GetCurrentImage(This,dib);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_SetBorderColor(IVMRWindowlessControl9* This,COLORREF color) {
    return This->lpVtbl->SetBorderColor(This,color);
}
static FORCEINLINE HRESULT IVMRWindowlessControl9_GetBorderColor(IVMRWindowlessControl9* This,COLORREF *color) {
    return This->lpVtbl->GetBorderColor(This,color);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_GetNativeVideoSize_Proxy(
    IVMRWindowlessControl9* This,
    LONG *width,
    LONG *height,
    LONG *arwidth,
    LONG *arheight);
void __RPC_STUB IVMRWindowlessControl9_GetNativeVideoSize_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_GetMinIdealVideoSize_Proxy(
    IVMRWindowlessControl9* This,
    LONG *width,
    LONG *height);
void __RPC_STUB IVMRWindowlessControl9_GetMinIdealVideoSize_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_GetMaxIdealVideoSize_Proxy(
    IVMRWindowlessControl9* This,
    LONG *width,
    LONG *height);
void __RPC_STUB IVMRWindowlessControl9_GetMaxIdealVideoSize_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_SetVideoPosition_Proxy(
    IVMRWindowlessControl9* This,
    const RECT *source,
    const RECT *dest);
void __RPC_STUB IVMRWindowlessControl9_SetVideoPosition_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_GetVideoPosition_Proxy(
    IVMRWindowlessControl9* This,
    RECT *source,
    RECT *dest);
void __RPC_STUB IVMRWindowlessControl9_GetVideoPosition_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_GetAspectRatioMode_Proxy(
    IVMRWindowlessControl9* This,
    DWORD *mode);
void __RPC_STUB IVMRWindowlessControl9_GetAspectRatioMode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_SetAspectRatioMode_Proxy(
    IVMRWindowlessControl9* This,
    DWORD mode);
void __RPC_STUB IVMRWindowlessControl9_SetAspectRatioMode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_SetVideoClippingWindow_Proxy(
    IVMRWindowlessControl9* This,
    HWND hwnd);
void __RPC_STUB IVMRWindowlessControl9_SetVideoClippingWindow_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_RepaintVideo_Proxy(
    IVMRWindowlessControl9* This,
    HWND hwnd,
    HDC hdc);
void __RPC_STUB IVMRWindowlessControl9_RepaintVideo_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_DisplayModeChanged_Proxy(
    IVMRWindowlessControl9* This);
void __RPC_STUB IVMRWindowlessControl9_DisplayModeChanged_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_GetCurrentImage_Proxy(
    IVMRWindowlessControl9* This,
    BYTE **dib);
void __RPC_STUB IVMRWindowlessControl9_GetCurrentImage_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_SetBorderColor_Proxy(
    IVMRWindowlessControl9* This,
    COLORREF color);
void __RPC_STUB IVMRWindowlessControl9_SetBorderColor_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRWindowlessControl9_GetBorderColor_Proxy(
    IVMRWindowlessControl9* This,
    COLORREF *color);
void __RPC_STUB IVMRWindowlessControl9_GetBorderColor_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRWindowlessControl9_INTERFACE_DEFINED__ */

typedef enum _VMR9MixerPrefs {
    MixerPref9_NoDecimation = 0x1,
    MixerPref9_DecimateOutput = 0x2,
    MixerPref9_ARAdjustXorY = 0x4,
    MixerPref9_NonSquareMixing = 0x8,
    MixerPref9_DecimateMask = 0xf,
    MixerPref9_BiLinearFiltering = 0x10,
    MixerPref9_PointFiltering = 0x20,
    MixerPref9_AnisotropicFiltering = 0x40,
    MixerPref9_PyramidalQuadFiltering = 0x80,
    MixerPref9_GaussianQuadFiltering = 0x100,
    MixerPref9_FilteringReserved = 0xe00,
    MixerPref9_FilteringMask = 0xff0,
    MixerPref9_RenderTargetRGB = 0x1000,
    MixerPref9_RenderTargetYUV = 0x2000,
    MixerPref9_RenderTargetReserved = 0xfc000,
    MixerPref9_DynamicSwitchToBOB = 0x100000,
    MixerPref9_DynamicDecimateBy2 = 0x200000,
    MixerPref9_DynamicReserved = 0xc00000,
    MixerPref9_DynamicMask = 0xf00000
} VMR9MixerPrefs;
typedef struct _VMR9NormalizedRect {
    FLOAT left;
    FLOAT top;
    FLOAT right;
    FLOAT bottom;
} VMR9NormalizedRect;
typedef enum _VMR9ProcAmpControlFlags {
    ProcAmpControl9_Brightness = 0x1,
    ProcAmpControl9_Contrast = 0x2,
    ProcAmpControl9_Hue = 0x4,
    ProcAmpControl9_Saturation = 0x8,
    ProcAmpControl9_Mask = 0xf
} VMR9ProcAmpControlFlags;
typedef struct _VMR9ProcAmpControl {
    DWORD dwSize;
    DWORD dwFlags;
    FLOAT Brightness;
    FLOAT Contrast;
    FLOAT Hue;
    FLOAT Saturation;
} VMR9ProcAmpControl;
typedef struct _VMR9ProcAmpControlRange {
    DWORD dwSize;
    VMR9ProcAmpControlFlags dwProperty;
    FLOAT MinValue;
    FLOAT MaxValue;
    FLOAT DefaultValue;
    FLOAT StepSize;
} VMR9ProcAmpControlRange;
/*****************************************************************************
 * IVMRMixerControl9 interface
 */
#ifndef __IVMRMixerControl9_INTERFACE_DEFINED__
#define __IVMRMixerControl9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRMixerControl9, 0x1a777eaa, 0x47c8, 0x4930, 0xb2,0xc9, 0x8f,0xee,0x1c,0x1b,0x0f,0x3b);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("1a777eaa-47c8-4930-b2c9-8fee1c1b0f3b")
IVMRMixerControl9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetAlpha(
        DWORD streamid,
        FLOAT alpha) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetAlpha(
        DWORD streamid,
        FLOAT *alpha) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetZOrder(
        DWORD streamid,
        DWORD zorder) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetZOrder(
        DWORD streamid,
        DWORD *zorder) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetOutputRect(
        DWORD streamid,
        const VMR9NormalizedRect *rect) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetOutputRect(
        DWORD streamid,
        VMR9NormalizedRect *rect) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetBackgroundClr(
        COLORREF back) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBackgroundClr(
        COLORREF *back) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetMixingPrefs(
        DWORD mixingprefs) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetMixingPrefs(
        DWORD *mixingprefs) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetProcAmpControl(
        DWORD streamid,
        VMR9ProcAmpControl *control) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetProcAmpControl(
        DWORD streamid,
        VMR9ProcAmpControl *control) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetProcAmpControlRange(
        DWORD streamid,
        VMR9ProcAmpControlRange *controlrange) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRMixerControl9, 0x1a777eaa, 0x47c8, 0x4930, 0xb2,0xc9, 0x8f,0xee,0x1c,0x1b,0x0f,0x3b)
#endif
#else
typedef struct IVMRMixerControl9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRMixerControl9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRMixerControl9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRMixerControl9* This);

    /*** IVMRMixerControl9 methods ***/
    HRESULT (STDMETHODCALLTYPE *SetAlpha)(
        IVMRMixerControl9* This,
        DWORD streamid,
        FLOAT alpha);

    HRESULT (STDMETHODCALLTYPE *GetAlpha)(
        IVMRMixerControl9* This,
        DWORD streamid,
        FLOAT *alpha);

    HRESULT (STDMETHODCALLTYPE *SetZOrder)(
        IVMRMixerControl9* This,
        DWORD streamid,
        DWORD zorder);

    HRESULT (STDMETHODCALLTYPE *GetZOrder)(
        IVMRMixerControl9* This,
        DWORD streamid,
        DWORD *zorder);

    HRESULT (STDMETHODCALLTYPE *SetOutputRect)(
        IVMRMixerControl9* This,
        DWORD streamid,
        const VMR9NormalizedRect *rect);

    HRESULT (STDMETHODCALLTYPE *GetOutputRect)(
        IVMRMixerControl9* This,
        DWORD streamid,
        VMR9NormalizedRect *rect);

    HRESULT (STDMETHODCALLTYPE *SetBackgroundClr)(
        IVMRMixerControl9* This,
        COLORREF back);

    HRESULT (STDMETHODCALLTYPE *GetBackgroundClr)(
        IVMRMixerControl9* This,
        COLORREF *back);

    HRESULT (STDMETHODCALLTYPE *SetMixingPrefs)(
        IVMRMixerControl9* This,
        DWORD mixingprefs);

    HRESULT (STDMETHODCALLTYPE *GetMixingPrefs)(
        IVMRMixerControl9* This,
        DWORD *mixingprefs);

    HRESULT (STDMETHODCALLTYPE *SetProcAmpControl)(
        IVMRMixerControl9* This,
        DWORD streamid,
        VMR9ProcAmpControl *control);

    HRESULT (STDMETHODCALLTYPE *GetProcAmpControl)(
        IVMRMixerControl9* This,
        DWORD streamid,
        VMR9ProcAmpControl *control);

    HRESULT (STDMETHODCALLTYPE *GetProcAmpControlRange)(
        IVMRMixerControl9* This,
        DWORD streamid,
        VMR9ProcAmpControlRange *controlrange);

    END_INTERFACE
} IVMRMixerControl9Vtbl;
interface IVMRMixerControl9 {
    CONST_VTBL IVMRMixerControl9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRMixerControl9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRMixerControl9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRMixerControl9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRMixerControl9 methods ***/
#define IVMRMixerControl9_SetAlpha(This,streamid,alpha) (This)->lpVtbl->SetAlpha(This,streamid,alpha)
#define IVMRMixerControl9_GetAlpha(This,streamid,alpha) (This)->lpVtbl->GetAlpha(This,streamid,alpha)
#define IVMRMixerControl9_SetZOrder(This,streamid,zorder) (This)->lpVtbl->SetZOrder(This,streamid,zorder)
#define IVMRMixerControl9_GetZOrder(This,streamid,zorder) (This)->lpVtbl->GetZOrder(This,streamid,zorder)
#define IVMRMixerControl9_SetOutputRect(This,streamid,rect) (This)->lpVtbl->SetOutputRect(This,streamid,rect)
#define IVMRMixerControl9_GetOutputRect(This,streamid,rect) (This)->lpVtbl->GetOutputRect(This,streamid,rect)
#define IVMRMixerControl9_SetBackgroundClr(This,back) (This)->lpVtbl->SetBackgroundClr(This,back)
#define IVMRMixerControl9_GetBackgroundClr(This,back) (This)->lpVtbl->GetBackgroundClr(This,back)
#define IVMRMixerControl9_SetMixingPrefs(This,mixingprefs) (This)->lpVtbl->SetMixingPrefs(This,mixingprefs)
#define IVMRMixerControl9_GetMixingPrefs(This,mixingprefs) (This)->lpVtbl->GetMixingPrefs(This,mixingprefs)
#define IVMRMixerControl9_SetProcAmpControl(This,streamid,control) (This)->lpVtbl->SetProcAmpControl(This,streamid,control)
#define IVMRMixerControl9_GetProcAmpControl(This,streamid,control) (This)->lpVtbl->GetProcAmpControl(This,streamid,control)
#define IVMRMixerControl9_GetProcAmpControlRange(This,streamid,controlrange) (This)->lpVtbl->GetProcAmpControlRange(This,streamid,controlrange)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRMixerControl9_QueryInterface(IVMRMixerControl9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRMixerControl9_AddRef(IVMRMixerControl9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRMixerControl9_Release(IVMRMixerControl9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRMixerControl9 methods ***/
static FORCEINLINE HRESULT IVMRMixerControl9_SetAlpha(IVMRMixerControl9* This,DWORD streamid,FLOAT alpha) {
    return This->lpVtbl->SetAlpha(This,streamid,alpha);
}
static FORCEINLINE HRESULT IVMRMixerControl9_GetAlpha(IVMRMixerControl9* This,DWORD streamid,FLOAT *alpha) {
    return This->lpVtbl->GetAlpha(This,streamid,alpha);
}
static FORCEINLINE HRESULT IVMRMixerControl9_SetZOrder(IVMRMixerControl9* This,DWORD streamid,DWORD zorder) {
    return This->lpVtbl->SetZOrder(This,streamid,zorder);
}
static FORCEINLINE HRESULT IVMRMixerControl9_GetZOrder(IVMRMixerControl9* This,DWORD streamid,DWORD *zorder) {
    return This->lpVtbl->GetZOrder(This,streamid,zorder);
}
static FORCEINLINE HRESULT IVMRMixerControl9_SetOutputRect(IVMRMixerControl9* This,DWORD streamid,const VMR9NormalizedRect *rect) {
    return This->lpVtbl->SetOutputRect(This,streamid,rect);
}
static FORCEINLINE HRESULT IVMRMixerControl9_GetOutputRect(IVMRMixerControl9* This,DWORD streamid,VMR9NormalizedRect *rect) {
    return This->lpVtbl->GetOutputRect(This,streamid,rect);
}
static FORCEINLINE HRESULT IVMRMixerControl9_SetBackgroundClr(IVMRMixerControl9* This,COLORREF back) {
    return This->lpVtbl->SetBackgroundClr(This,back);
}
static FORCEINLINE HRESULT IVMRMixerControl9_GetBackgroundClr(IVMRMixerControl9* This,COLORREF *back) {
    return This->lpVtbl->GetBackgroundClr(This,back);
}
static FORCEINLINE HRESULT IVMRMixerControl9_SetMixingPrefs(IVMRMixerControl9* This,DWORD mixingprefs) {
    return This->lpVtbl->SetMixingPrefs(This,mixingprefs);
}
static FORCEINLINE HRESULT IVMRMixerControl9_GetMixingPrefs(IVMRMixerControl9* This,DWORD *mixingprefs) {
    return This->lpVtbl->GetMixingPrefs(This,mixingprefs);
}
static FORCEINLINE HRESULT IVMRMixerControl9_SetProcAmpControl(IVMRMixerControl9* This,DWORD streamid,VMR9ProcAmpControl *control) {
    return This->lpVtbl->SetProcAmpControl(This,streamid,control);
}
static FORCEINLINE HRESULT IVMRMixerControl9_GetProcAmpControl(IVMRMixerControl9* This,DWORD streamid,VMR9ProcAmpControl *control) {
    return This->lpVtbl->GetProcAmpControl(This,streamid,control);
}
static FORCEINLINE HRESULT IVMRMixerControl9_GetProcAmpControlRange(IVMRMixerControl9* This,DWORD streamid,VMR9ProcAmpControlRange *controlrange) {
    return This->lpVtbl->GetProcAmpControlRange(This,streamid,controlrange);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRMixerControl9_SetAlpha_Proxy(
    IVMRMixerControl9* This,
    DWORD streamid,
    FLOAT alpha);
void __RPC_STUB IVMRMixerControl9_SetAlpha_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_GetAlpha_Proxy(
    IVMRMixerControl9* This,
    DWORD streamid,
    FLOAT *alpha);
void __RPC_STUB IVMRMixerControl9_GetAlpha_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_SetZOrder_Proxy(
    IVMRMixerControl9* This,
    DWORD streamid,
    DWORD zorder);
void __RPC_STUB IVMRMixerControl9_SetZOrder_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_GetZOrder_Proxy(
    IVMRMixerControl9* This,
    DWORD streamid,
    DWORD *zorder);
void __RPC_STUB IVMRMixerControl9_GetZOrder_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_SetOutputRect_Proxy(
    IVMRMixerControl9* This,
    DWORD streamid,
    const VMR9NormalizedRect *rect);
void __RPC_STUB IVMRMixerControl9_SetOutputRect_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_GetOutputRect_Proxy(
    IVMRMixerControl9* This,
    DWORD streamid,
    VMR9NormalizedRect *rect);
void __RPC_STUB IVMRMixerControl9_GetOutputRect_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_SetBackgroundClr_Proxy(
    IVMRMixerControl9* This,
    COLORREF back);
void __RPC_STUB IVMRMixerControl9_SetBackgroundClr_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_GetBackgroundClr_Proxy(
    IVMRMixerControl9* This,
    COLORREF *back);
void __RPC_STUB IVMRMixerControl9_GetBackgroundClr_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_SetMixingPrefs_Proxy(
    IVMRMixerControl9* This,
    DWORD mixingprefs);
void __RPC_STUB IVMRMixerControl9_SetMixingPrefs_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_GetMixingPrefs_Proxy(
    IVMRMixerControl9* This,
    DWORD *mixingprefs);
void __RPC_STUB IVMRMixerControl9_GetMixingPrefs_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_SetProcAmpControl_Proxy(
    IVMRMixerControl9* This,
    DWORD streamid,
    VMR9ProcAmpControl *control);
void __RPC_STUB IVMRMixerControl9_SetProcAmpControl_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_GetProcAmpControl_Proxy(
    IVMRMixerControl9* This,
    DWORD streamid,
    VMR9ProcAmpControl *control);
void __RPC_STUB IVMRMixerControl9_GetProcAmpControl_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerControl9_GetProcAmpControlRange_Proxy(
    IVMRMixerControl9* This,
    DWORD streamid,
    VMR9ProcAmpControlRange *controlrange);
void __RPC_STUB IVMRMixerControl9_GetProcAmpControlRange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRMixerControl9_INTERFACE_DEFINED__ */

typedef struct _VMR9AlphaBitmap {
    DWORD dwFlags;
    HDC hdc;
    IDirect3DSurface9 *pDDS;
    RECT rSrc;
    VMR9NormalizedRect *rDest;
    FLOAT fAlpha;
    COLORREF clrSrcKey;
    DWORD dwFilterMode;
} VMR9AlphaBitmap;
typedef enum _VMR9AlphaBitmapFlags {
    VMR9AlphaBitmap_Disable = 0x1,
    VMR9AlphaBitmap_hDC = 0x2,
    VMR9AlphaBitmap_EntireDDS = 0x4,
    VMR9AlphaBitmap_SrcColorKey = 0x8,
    VMR9AlphaBitmap_SrcRect = 0x10,
    VMR9AlphaBitmap_FilterMode = 0x20
} VMR9AlphaBitmapFlags;
/*****************************************************************************
 * IVMRMixerBitmap9 interface
 */
#ifndef __IVMRMixerBitmap9_INTERFACE_DEFINED__
#define __IVMRMixerBitmap9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRMixerBitmap9, 0xced175e5, 0x1935, 0x4820, 0x81,0xbd, 0xff,0x6a,0xd0,0x0c,0x91,0x08);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("ced175e5-1935-4820-81bd-ff6ad00c9108")
IVMRMixerBitmap9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetAlphaBitmap(
        const VMR9AlphaBitmap *bitmap) = 0;

    virtual HRESULT STDMETHODCALLTYPE UpdateAlphaBitmapParameters(
        const VMR9AlphaBitmap *bitmap) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetAlphaBitmapParameters(
        VMR9AlphaBitmap *bitmap) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRMixerBitmap9, 0xced175e5, 0x1935, 0x4820, 0x81,0xbd, 0xff,0x6a,0xd0,0x0c,0x91,0x08)
#endif
#else
typedef struct IVMRMixerBitmap9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRMixerBitmap9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRMixerBitmap9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRMixerBitmap9* This);

    /*** IVMRMixerBitmap9 methods ***/
    HRESULT (STDMETHODCALLTYPE *SetAlphaBitmap)(
        IVMRMixerBitmap9* This,
        const VMR9AlphaBitmap *bitmap);

    HRESULT (STDMETHODCALLTYPE *UpdateAlphaBitmapParameters)(
        IVMRMixerBitmap9* This,
        const VMR9AlphaBitmap *bitmap);

    HRESULT (STDMETHODCALLTYPE *GetAlphaBitmapParameters)(
        IVMRMixerBitmap9* This,
        VMR9AlphaBitmap *bitmap);

    END_INTERFACE
} IVMRMixerBitmap9Vtbl;
interface IVMRMixerBitmap9 {
    CONST_VTBL IVMRMixerBitmap9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRMixerBitmap9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRMixerBitmap9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRMixerBitmap9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRMixerBitmap9 methods ***/
#define IVMRMixerBitmap9_SetAlphaBitmap(This,bitmap) (This)->lpVtbl->SetAlphaBitmap(This,bitmap)
#define IVMRMixerBitmap9_UpdateAlphaBitmapParameters(This,bitmap) (This)->lpVtbl->UpdateAlphaBitmapParameters(This,bitmap)
#define IVMRMixerBitmap9_GetAlphaBitmapParameters(This,bitmap) (This)->lpVtbl->GetAlphaBitmapParameters(This,bitmap)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRMixerBitmap9_QueryInterface(IVMRMixerBitmap9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRMixerBitmap9_AddRef(IVMRMixerBitmap9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRMixerBitmap9_Release(IVMRMixerBitmap9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRMixerBitmap9 methods ***/
static FORCEINLINE HRESULT IVMRMixerBitmap9_SetAlphaBitmap(IVMRMixerBitmap9* This,const VMR9AlphaBitmap *bitmap) {
    return This->lpVtbl->SetAlphaBitmap(This,bitmap);
}
static FORCEINLINE HRESULT IVMRMixerBitmap9_UpdateAlphaBitmapParameters(IVMRMixerBitmap9* This,const VMR9AlphaBitmap *bitmap) {
    return This->lpVtbl->UpdateAlphaBitmapParameters(This,bitmap);
}
static FORCEINLINE HRESULT IVMRMixerBitmap9_GetAlphaBitmapParameters(IVMRMixerBitmap9* This,VMR9AlphaBitmap *bitmap) {
    return This->lpVtbl->GetAlphaBitmapParameters(This,bitmap);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRMixerBitmap9_SetAlphaBitmap_Proxy(
    IVMRMixerBitmap9* This,
    const VMR9AlphaBitmap *bitmap);
void __RPC_STUB IVMRMixerBitmap9_SetAlphaBitmap_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerBitmap9_UpdateAlphaBitmapParameters_Proxy(
    IVMRMixerBitmap9* This,
    const VMR9AlphaBitmap *bitmap);
void __RPC_STUB IVMRMixerBitmap9_UpdateAlphaBitmapParameters_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMixerBitmap9_GetAlphaBitmapParameters_Proxy(
    IVMRMixerBitmap9* This,
    VMR9AlphaBitmap *bitmap);
void __RPC_STUB IVMRMixerBitmap9_GetAlphaBitmapParameters_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRMixerBitmap9_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IVMRSurface9 interface
 */
#ifndef __IVMRSurface9_INTERFACE_DEFINED__
#define __IVMRSurface9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRSurface9, 0xdfc581a1, 0x6e1f, 0x4c3a, 0x8d,0x0a, 0x5e,0x97,0x92,0xea,0x2a,0xfc);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("dfc581a1-6e1f-4c3a-8d0a-5e9792ea2afc")
IVMRSurface9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE IsSurfaceLocked(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE LockSurface(
        BYTE **surface) = 0;

    virtual HRESULT STDMETHODCALLTYPE UnlockSurface(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetSurface(
        IDirect3DSurface9 **surface) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRSurface9, 0xdfc581a1, 0x6e1f, 0x4c3a, 0x8d,0x0a, 0x5e,0x97,0x92,0xea,0x2a,0xfc)
#endif
#else
typedef struct IVMRSurface9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRSurface9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRSurface9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRSurface9* This);

    /*** IVMRSurface9 methods ***/
    HRESULT (STDMETHODCALLTYPE *IsSurfaceLocked)(
        IVMRSurface9* This);

    HRESULT (STDMETHODCALLTYPE *LockSurface)(
        IVMRSurface9* This,
        BYTE **surface);

    HRESULT (STDMETHODCALLTYPE *UnlockSurface)(
        IVMRSurface9* This);

    HRESULT (STDMETHODCALLTYPE *GetSurface)(
        IVMRSurface9* This,
        IDirect3DSurface9 **surface);

    END_INTERFACE
} IVMRSurface9Vtbl;
interface IVMRSurface9 {
    CONST_VTBL IVMRSurface9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRSurface9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRSurface9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRSurface9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRSurface9 methods ***/
#define IVMRSurface9_IsSurfaceLocked(This) (This)->lpVtbl->IsSurfaceLocked(This)
#define IVMRSurface9_LockSurface(This,surface) (This)->lpVtbl->LockSurface(This,surface)
#define IVMRSurface9_UnlockSurface(This) (This)->lpVtbl->UnlockSurface(This)
#define IVMRSurface9_GetSurface(This,surface) (This)->lpVtbl->GetSurface(This,surface)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRSurface9_QueryInterface(IVMRSurface9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRSurface9_AddRef(IVMRSurface9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRSurface9_Release(IVMRSurface9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRSurface9 methods ***/
static FORCEINLINE HRESULT IVMRSurface9_IsSurfaceLocked(IVMRSurface9* This) {
    return This->lpVtbl->IsSurfaceLocked(This);
}
static FORCEINLINE HRESULT IVMRSurface9_LockSurface(IVMRSurface9* This,BYTE **surface) {
    return This->lpVtbl->LockSurface(This,surface);
}
static FORCEINLINE HRESULT IVMRSurface9_UnlockSurface(IVMRSurface9* This) {
    return This->lpVtbl->UnlockSurface(This);
}
static FORCEINLINE HRESULT IVMRSurface9_GetSurface(IVMRSurface9* This,IDirect3DSurface9 **surface) {
    return This->lpVtbl->GetSurface(This,surface);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRSurface9_IsSurfaceLocked_Proxy(
    IVMRSurface9* This);
void __RPC_STUB IVMRSurface9_IsSurfaceLocked_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRSurface9_LockSurface_Proxy(
    IVMRSurface9* This,
    BYTE **surface);
void __RPC_STUB IVMRSurface9_LockSurface_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRSurface9_UnlockSurface_Proxy(
    IVMRSurface9* This);
void __RPC_STUB IVMRSurface9_UnlockSurface_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRSurface9_GetSurface_Proxy(
    IVMRSurface9* This,
    IDirect3DSurface9 **surface);
void __RPC_STUB IVMRSurface9_GetSurface_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRSurface9_INTERFACE_DEFINED__ */

typedef enum _VMR9RenderPrefs {
    RenderPrefs9_DoNotRenderBorder = 0x1,
    RenderPrefs9_Mask = 0x1
} VMR9RenderPrefs;
/*****************************************************************************
 * IVMRImagePresenterConfig9 interface
 */
#ifndef __IVMRImagePresenterConfig9_INTERFACE_DEFINED__
#define __IVMRImagePresenterConfig9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRImagePresenterConfig9, 0x45c15cab, 0x6e22, 0x420a, 0x80,0x43, 0xae,0x1f,0x0a,0xc0,0x2c,0x7d);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("45c15cab-6e22-420a-8043-ae1f0ac02c7d")
IVMRImagePresenterConfig9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetRenderingPrefs(
        DWORD renderflags) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetRenderingPrefs(
        DWORD *renderflags) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRImagePresenterConfig9, 0x45c15cab, 0x6e22, 0x420a, 0x80,0x43, 0xae,0x1f,0x0a,0xc0,0x2c,0x7d)
#endif
#else
typedef struct IVMRImagePresenterConfig9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRImagePresenterConfig9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRImagePresenterConfig9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRImagePresenterConfig9* This);

    /*** IVMRImagePresenterConfig9 methods ***/
    HRESULT (STDMETHODCALLTYPE *SetRenderingPrefs)(
        IVMRImagePresenterConfig9* This,
        DWORD renderflags);

    HRESULT (STDMETHODCALLTYPE *GetRenderingPrefs)(
        IVMRImagePresenterConfig9* This,
        DWORD *renderflags);

    END_INTERFACE
} IVMRImagePresenterConfig9Vtbl;
interface IVMRImagePresenterConfig9 {
    CONST_VTBL IVMRImagePresenterConfig9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRImagePresenterConfig9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRImagePresenterConfig9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRImagePresenterConfig9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRImagePresenterConfig9 methods ***/
#define IVMRImagePresenterConfig9_SetRenderingPrefs(This,renderflags) (This)->lpVtbl->SetRenderingPrefs(This,renderflags)
#define IVMRImagePresenterConfig9_GetRenderingPrefs(This,renderflags) (This)->lpVtbl->GetRenderingPrefs(This,renderflags)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRImagePresenterConfig9_QueryInterface(IVMRImagePresenterConfig9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRImagePresenterConfig9_AddRef(IVMRImagePresenterConfig9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRImagePresenterConfig9_Release(IVMRImagePresenterConfig9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRImagePresenterConfig9 methods ***/
static FORCEINLINE HRESULT IVMRImagePresenterConfig9_SetRenderingPrefs(IVMRImagePresenterConfig9* This,DWORD renderflags) {
    return This->lpVtbl->SetRenderingPrefs(This,renderflags);
}
static FORCEINLINE HRESULT IVMRImagePresenterConfig9_GetRenderingPrefs(IVMRImagePresenterConfig9* This,DWORD *renderflags) {
    return This->lpVtbl->GetRenderingPrefs(This,renderflags);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRImagePresenterConfig9_SetRenderingPrefs_Proxy(
    IVMRImagePresenterConfig9* This,
    DWORD renderflags);
void __RPC_STUB IVMRImagePresenterConfig9_SetRenderingPrefs_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRImagePresenterConfig9_GetRenderingPrefs_Proxy(
    IVMRImagePresenterConfig9* This,
    DWORD *renderflags);
void __RPC_STUB IVMRImagePresenterConfig9_GetRenderingPrefs_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRImagePresenterConfig9_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IVMRVideoStreamControl9 interface
 */
#ifndef __IVMRVideoStreamControl9_INTERFACE_DEFINED__
#define __IVMRVideoStreamControl9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRVideoStreamControl9, 0xd0cfe38b, 0x93e7, 0x4772, 0x89,0x57, 0x04,0x00,0xc4,0x9a,0x44,0x85);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("d0cfe38b-93e7-4772-8957-0400c49a4485")
IVMRVideoStreamControl9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetStreamActiveState(
        WINBOOL active) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetStreamActiveState(
        WINBOOL *active) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRVideoStreamControl9, 0xd0cfe38b, 0x93e7, 0x4772, 0x89,0x57, 0x04,0x00,0xc4,0x9a,0x44,0x85)
#endif
#else
typedef struct IVMRVideoStreamControl9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRVideoStreamControl9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRVideoStreamControl9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRVideoStreamControl9* This);

    /*** IVMRVideoStreamControl9 methods ***/
    HRESULT (STDMETHODCALLTYPE *SetStreamActiveState)(
        IVMRVideoStreamControl9* This,
        WINBOOL active);

    HRESULT (STDMETHODCALLTYPE *GetStreamActiveState)(
        IVMRVideoStreamControl9* This,
        WINBOOL *active);

    END_INTERFACE
} IVMRVideoStreamControl9Vtbl;
interface IVMRVideoStreamControl9 {
    CONST_VTBL IVMRVideoStreamControl9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRVideoStreamControl9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRVideoStreamControl9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRVideoStreamControl9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRVideoStreamControl9 methods ***/
#define IVMRVideoStreamControl9_SetStreamActiveState(This,active) (This)->lpVtbl->SetStreamActiveState(This,active)
#define IVMRVideoStreamControl9_GetStreamActiveState(This,active) (This)->lpVtbl->GetStreamActiveState(This,active)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRVideoStreamControl9_QueryInterface(IVMRVideoStreamControl9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRVideoStreamControl9_AddRef(IVMRVideoStreamControl9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRVideoStreamControl9_Release(IVMRVideoStreamControl9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRVideoStreamControl9 methods ***/
static FORCEINLINE HRESULT IVMRVideoStreamControl9_SetStreamActiveState(IVMRVideoStreamControl9* This,WINBOOL active) {
    return This->lpVtbl->SetStreamActiveState(This,active);
}
static FORCEINLINE HRESULT IVMRVideoStreamControl9_GetStreamActiveState(IVMRVideoStreamControl9* This,WINBOOL *active) {
    return This->lpVtbl->GetStreamActiveState(This,active);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRVideoStreamControl9_SetStreamActiveState_Proxy(
    IVMRVideoStreamControl9* This,
    WINBOOL active);
void __RPC_STUB IVMRVideoStreamControl9_SetStreamActiveState_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRVideoStreamControl9_GetStreamActiveState_Proxy(
    IVMRVideoStreamControl9* This,
    WINBOOL *active);
void __RPC_STUB IVMRVideoStreamControl9_GetStreamActiveState_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRVideoStreamControl9_INTERFACE_DEFINED__ */

typedef enum _VMR9Mode {
    VMR9Mode_Windowed = 0x1,
    VMR9Mode_Windowless = 0x2,
    VMR9Mode_Renderless = 0x4,
    VMR9Mode_Mask = 0x7
} VMR9Mode;
/*****************************************************************************
 * IVMRFilterConfig9 interface
 */
#ifndef __IVMRFilterConfig9_INTERFACE_DEFINED__
#define __IVMRFilterConfig9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRFilterConfig9, 0x5a804648, 0x4f66, 0x4867, 0x9c,0x43, 0x4f,0x5c,0x82,0x2c,0xf1,0xb8);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("5a804648-4f66-4867-9c43-4f5c822cf1b8")
IVMRFilterConfig9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetImageCompositor(
        IVMRImageCompositor9 *compositor) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetNumberOfStreams(
        DWORD max) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetNumberOfStreams(
        DWORD *max) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetRenderingPrefs(
        DWORD renderflags) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetRenderingPrefs(
        DWORD *renderflags) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetRenderingMode(
        DWORD mode) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetRenderingMode(
        DWORD *mode) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRFilterConfig9, 0x5a804648, 0x4f66, 0x4867, 0x9c,0x43, 0x4f,0x5c,0x82,0x2c,0xf1,0xb8)
#endif
#else
typedef struct IVMRFilterConfig9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRFilterConfig9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRFilterConfig9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRFilterConfig9* This);

    /*** IVMRFilterConfig9 methods ***/
    HRESULT (STDMETHODCALLTYPE *SetImageCompositor)(
        IVMRFilterConfig9* This,
        IVMRImageCompositor9 *compositor);

    HRESULT (STDMETHODCALLTYPE *SetNumberOfStreams)(
        IVMRFilterConfig9* This,
        DWORD max);

    HRESULT (STDMETHODCALLTYPE *GetNumberOfStreams)(
        IVMRFilterConfig9* This,
        DWORD *max);

    HRESULT (STDMETHODCALLTYPE *SetRenderingPrefs)(
        IVMRFilterConfig9* This,
        DWORD renderflags);

    HRESULT (STDMETHODCALLTYPE *GetRenderingPrefs)(
        IVMRFilterConfig9* This,
        DWORD *renderflags);

    HRESULT (STDMETHODCALLTYPE *SetRenderingMode)(
        IVMRFilterConfig9* This,
        DWORD mode);

    HRESULT (STDMETHODCALLTYPE *GetRenderingMode)(
        IVMRFilterConfig9* This,
        DWORD *mode);

    END_INTERFACE
} IVMRFilterConfig9Vtbl;
interface IVMRFilterConfig9 {
    CONST_VTBL IVMRFilterConfig9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRFilterConfig9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRFilterConfig9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRFilterConfig9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRFilterConfig9 methods ***/
#define IVMRFilterConfig9_SetImageCompositor(This,compositor) (This)->lpVtbl->SetImageCompositor(This,compositor)
#define IVMRFilterConfig9_SetNumberOfStreams(This,max) (This)->lpVtbl->SetNumberOfStreams(This,max)
#define IVMRFilterConfig9_GetNumberOfStreams(This,max) (This)->lpVtbl->GetNumberOfStreams(This,max)
#define IVMRFilterConfig9_SetRenderingPrefs(This,renderflags) (This)->lpVtbl->SetRenderingPrefs(This,renderflags)
#define IVMRFilterConfig9_GetRenderingPrefs(This,renderflags) (This)->lpVtbl->GetRenderingPrefs(This,renderflags)
#define IVMRFilterConfig9_SetRenderingMode(This,mode) (This)->lpVtbl->SetRenderingMode(This,mode)
#define IVMRFilterConfig9_GetRenderingMode(This,mode) (This)->lpVtbl->GetRenderingMode(This,mode)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRFilterConfig9_QueryInterface(IVMRFilterConfig9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRFilterConfig9_AddRef(IVMRFilterConfig9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRFilterConfig9_Release(IVMRFilterConfig9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRFilterConfig9 methods ***/
static FORCEINLINE HRESULT IVMRFilterConfig9_SetImageCompositor(IVMRFilterConfig9* This,IVMRImageCompositor9 *compositor) {
    return This->lpVtbl->SetImageCompositor(This,compositor);
}
static FORCEINLINE HRESULT IVMRFilterConfig9_SetNumberOfStreams(IVMRFilterConfig9* This,DWORD max) {
    return This->lpVtbl->SetNumberOfStreams(This,max);
}
static FORCEINLINE HRESULT IVMRFilterConfig9_GetNumberOfStreams(IVMRFilterConfig9* This,DWORD *max) {
    return This->lpVtbl->GetNumberOfStreams(This,max);
}
static FORCEINLINE HRESULT IVMRFilterConfig9_SetRenderingPrefs(IVMRFilterConfig9* This,DWORD renderflags) {
    return This->lpVtbl->SetRenderingPrefs(This,renderflags);
}
static FORCEINLINE HRESULT IVMRFilterConfig9_GetRenderingPrefs(IVMRFilterConfig9* This,DWORD *renderflags) {
    return This->lpVtbl->GetRenderingPrefs(This,renderflags);
}
static FORCEINLINE HRESULT IVMRFilterConfig9_SetRenderingMode(IVMRFilterConfig9* This,DWORD mode) {
    return This->lpVtbl->SetRenderingMode(This,mode);
}
static FORCEINLINE HRESULT IVMRFilterConfig9_GetRenderingMode(IVMRFilterConfig9* This,DWORD *mode) {
    return This->lpVtbl->GetRenderingMode(This,mode);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRFilterConfig9_SetImageCompositor_Proxy(
    IVMRFilterConfig9* This,
    IVMRImageCompositor9 *compositor);
void __RPC_STUB IVMRFilterConfig9_SetImageCompositor_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRFilterConfig9_SetNumberOfStreams_Proxy(
    IVMRFilterConfig9* This,
    DWORD max);
void __RPC_STUB IVMRFilterConfig9_SetNumberOfStreams_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRFilterConfig9_GetNumberOfStreams_Proxy(
    IVMRFilterConfig9* This,
    DWORD *max);
void __RPC_STUB IVMRFilterConfig9_GetNumberOfStreams_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRFilterConfig9_SetRenderingPrefs_Proxy(
    IVMRFilterConfig9* This,
    DWORD renderflags);
void __RPC_STUB IVMRFilterConfig9_SetRenderingPrefs_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRFilterConfig9_GetRenderingPrefs_Proxy(
    IVMRFilterConfig9* This,
    DWORD *renderflags);
void __RPC_STUB IVMRFilterConfig9_GetRenderingPrefs_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRFilterConfig9_SetRenderingMode_Proxy(
    IVMRFilterConfig9* This,
    DWORD mode);
void __RPC_STUB IVMRFilterConfig9_SetRenderingMode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRFilterConfig9_GetRenderingMode_Proxy(
    IVMRFilterConfig9* This,
    DWORD *mode);
void __RPC_STUB IVMRFilterConfig9_GetRenderingMode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRFilterConfig9_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IVMRAspectRatioControl9 interface
 */
#ifndef __IVMRAspectRatioControl9_INTERFACE_DEFINED__
#define __IVMRAspectRatioControl9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRAspectRatioControl9, 0x00d96c29, 0xbbde, 0x4efc, 0x99,0x01, 0xbb,0x50,0x36,0x39,0x21,0x46);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("00d96c29-bbde-4efc-9901-bb5036392146")
IVMRAspectRatioControl9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetAspectRatioMode(
        DWORD *mode) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetAspectRatioMode(
        DWORD mode) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRAspectRatioControl9, 0x00d96c29, 0xbbde, 0x4efc, 0x99,0x01, 0xbb,0x50,0x36,0x39,0x21,0x46)
#endif
#else
typedef struct IVMRAspectRatioControl9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRAspectRatioControl9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRAspectRatioControl9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRAspectRatioControl9* This);

    /*** IVMRAspectRatioControl9 methods ***/
    HRESULT (STDMETHODCALLTYPE *GetAspectRatioMode)(
        IVMRAspectRatioControl9* This,
        DWORD *mode);

    HRESULT (STDMETHODCALLTYPE *SetAspectRatioMode)(
        IVMRAspectRatioControl9* This,
        DWORD mode);

    END_INTERFACE
} IVMRAspectRatioControl9Vtbl;
interface IVMRAspectRatioControl9 {
    CONST_VTBL IVMRAspectRatioControl9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRAspectRatioControl9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRAspectRatioControl9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRAspectRatioControl9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRAspectRatioControl9 methods ***/
#define IVMRAspectRatioControl9_GetAspectRatioMode(This,mode) (This)->lpVtbl->GetAspectRatioMode(This,mode)
#define IVMRAspectRatioControl9_SetAspectRatioMode(This,mode) (This)->lpVtbl->SetAspectRatioMode(This,mode)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRAspectRatioControl9_QueryInterface(IVMRAspectRatioControl9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRAspectRatioControl9_AddRef(IVMRAspectRatioControl9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRAspectRatioControl9_Release(IVMRAspectRatioControl9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRAspectRatioControl9 methods ***/
static FORCEINLINE HRESULT IVMRAspectRatioControl9_GetAspectRatioMode(IVMRAspectRatioControl9* This,DWORD *mode) {
    return This->lpVtbl->GetAspectRatioMode(This,mode);
}
static FORCEINLINE HRESULT IVMRAspectRatioControl9_SetAspectRatioMode(IVMRAspectRatioControl9* This,DWORD mode) {
    return This->lpVtbl->SetAspectRatioMode(This,mode);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRAspectRatioControl9_GetAspectRatioMode_Proxy(
    IVMRAspectRatioControl9* This,
    DWORD *mode);
void __RPC_STUB IVMRAspectRatioControl9_GetAspectRatioMode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRAspectRatioControl9_SetAspectRatioMode_Proxy(
    IVMRAspectRatioControl9* This,
    DWORD mode);
void __RPC_STUB IVMRAspectRatioControl9_SetAspectRatioMode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRAspectRatioControl9_INTERFACE_DEFINED__ */

typedef struct _VMR9MonitorInfo {
    UINT uDevID;
    RECT rcMonitor;
    HMONITOR hMon;
    DWORD dwFlags;
    WCHAR szDevice[32];
    WCHAR szDescription[512];
    LARGE_INTEGER liDriverVersion;
    DWORD dwVendorId;
    DWORD dwDeviceId;
    DWORD dwSubSysId;
    DWORD dwRevision;
} VMR9MonitorInfo;
/*****************************************************************************
 * IVMRMonitorConfig9 interface
 */
#ifndef __IVMRMonitorConfig9_INTERFACE_DEFINED__
#define __IVMRMonitorConfig9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRMonitorConfig9, 0x46c2e457, 0x8ba0, 0x4eef, 0xb8,0x0b, 0x06,0x80,0xf0,0x97,0x87,0x49);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("46c2e457-8ba0-4eef-b80b-0680f0978749")
IVMRMonitorConfig9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetMonitor(
        UINT uDev) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetMonitor(
        UINT *uDev) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetDefaultMonitor(
        UINT uDev) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetDefaultMonitor(
        UINT *uDev) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetAvailableMonitors(
        VMR9MonitorInfo *info,
        DWORD arraysize,
        DWORD *numdev) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRMonitorConfig9, 0x46c2e457, 0x8ba0, 0x4eef, 0xb8,0x0b, 0x06,0x80,0xf0,0x97,0x87,0x49)
#endif
#else
typedef struct IVMRMonitorConfig9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRMonitorConfig9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRMonitorConfig9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRMonitorConfig9* This);

    /*** IVMRMonitorConfig9 methods ***/
    HRESULT (STDMETHODCALLTYPE *SetMonitor)(
        IVMRMonitorConfig9* This,
        UINT uDev);

    HRESULT (STDMETHODCALLTYPE *GetMonitor)(
        IVMRMonitorConfig9* This,
        UINT *uDev);

    HRESULT (STDMETHODCALLTYPE *SetDefaultMonitor)(
        IVMRMonitorConfig9* This,
        UINT uDev);

    HRESULT (STDMETHODCALLTYPE *GetDefaultMonitor)(
        IVMRMonitorConfig9* This,
        UINT *uDev);

    HRESULT (STDMETHODCALLTYPE *GetAvailableMonitors)(
        IVMRMonitorConfig9* This,
        VMR9MonitorInfo *info,
        DWORD arraysize,
        DWORD *numdev);

    END_INTERFACE
} IVMRMonitorConfig9Vtbl;
interface IVMRMonitorConfig9 {
    CONST_VTBL IVMRMonitorConfig9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRMonitorConfig9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRMonitorConfig9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRMonitorConfig9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRMonitorConfig9 methods ***/
#define IVMRMonitorConfig9_SetMonitor(This,uDev) (This)->lpVtbl->SetMonitor(This,uDev)
#define IVMRMonitorConfig9_GetMonitor(This,uDev) (This)->lpVtbl->GetMonitor(This,uDev)
#define IVMRMonitorConfig9_SetDefaultMonitor(This,uDev) (This)->lpVtbl->SetDefaultMonitor(This,uDev)
#define IVMRMonitorConfig9_GetDefaultMonitor(This,uDev) (This)->lpVtbl->GetDefaultMonitor(This,uDev)
#define IVMRMonitorConfig9_GetAvailableMonitors(This,info,arraysize,numdev) (This)->lpVtbl->GetAvailableMonitors(This,info,arraysize,numdev)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRMonitorConfig9_QueryInterface(IVMRMonitorConfig9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRMonitorConfig9_AddRef(IVMRMonitorConfig9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRMonitorConfig9_Release(IVMRMonitorConfig9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRMonitorConfig9 methods ***/
static FORCEINLINE HRESULT IVMRMonitorConfig9_SetMonitor(IVMRMonitorConfig9* This,UINT uDev) {
    return This->lpVtbl->SetMonitor(This,uDev);
}
static FORCEINLINE HRESULT IVMRMonitorConfig9_GetMonitor(IVMRMonitorConfig9* This,UINT *uDev) {
    return This->lpVtbl->GetMonitor(This,uDev);
}
static FORCEINLINE HRESULT IVMRMonitorConfig9_SetDefaultMonitor(IVMRMonitorConfig9* This,UINT uDev) {
    return This->lpVtbl->SetDefaultMonitor(This,uDev);
}
static FORCEINLINE HRESULT IVMRMonitorConfig9_GetDefaultMonitor(IVMRMonitorConfig9* This,UINT *uDev) {
    return This->lpVtbl->GetDefaultMonitor(This,uDev);
}
static FORCEINLINE HRESULT IVMRMonitorConfig9_GetAvailableMonitors(IVMRMonitorConfig9* This,VMR9MonitorInfo *info,DWORD arraysize,DWORD *numdev) {
    return This->lpVtbl->GetAvailableMonitors(This,info,arraysize,numdev);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRMonitorConfig9_SetMonitor_Proxy(
    IVMRMonitorConfig9* This,
    UINT uDev);
void __RPC_STUB IVMRMonitorConfig9_SetMonitor_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMonitorConfig9_GetMonitor_Proxy(
    IVMRMonitorConfig9* This,
    UINT *uDev);
void __RPC_STUB IVMRMonitorConfig9_GetMonitor_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMonitorConfig9_SetDefaultMonitor_Proxy(
    IVMRMonitorConfig9* This,
    UINT uDev);
void __RPC_STUB IVMRMonitorConfig9_SetDefaultMonitor_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMonitorConfig9_GetDefaultMonitor_Proxy(
    IVMRMonitorConfig9* This,
    UINT *uDev);
void __RPC_STUB IVMRMonitorConfig9_GetDefaultMonitor_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRMonitorConfig9_GetAvailableMonitors_Proxy(
    IVMRMonitorConfig9* This,
    VMR9MonitorInfo *info,
    DWORD arraysize,
    DWORD *numdev);
void __RPC_STUB IVMRMonitorConfig9_GetAvailableMonitors_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRMonitorConfig9_INTERFACE_DEFINED__ */

typedef enum _VMR9DeinterlacePrefs {
    DeinterlacePref9_NextBest = 0x1,
    DeinterlacePref9_BOB = 0x2,
    DeinterlacePref9_Weave = 0x4,
    DeinterlacePref9_Mask = 0x7
} VMR9DeinterlacePrefs;
typedef enum _VMR9DeinterlaceTech {
    DeinterlaceTech9_Unknown = 0,
    DeinterlaceTech9_BOBLineReplicate = 0x1,
    DeinterlaceTech9_BOBVerticalStretch = 0x2,
    DeinterlaceTech9_MedianFiltering = 0x4,
    DeinterlaceTech9_EdgeFiltering = 0x10,
    DeinterlaceTech9_FieldAdaptive = 0x20,
    DeinterlaceTech9_PixelAdaptive = 0x40,
    DeinterlaceTech9_MotionVectorSteered = 0x80
} VMR9DeinterlaceTech;
typedef struct _VMR9Frequency {
    DWORD dwNumerator;
    DWORD dwDenominator;
} VMR9Frequency;
typedef enum _VMR9_SampleFormat {
    VMR9_SampleReserved = 1,
    VMR9_SampleProgressiveFrame = 2,
    VMR9_SampleFieldInterleavedEvenFirst = 3,
    VMR9_SampleFieldInterleavedOddFirst = 4,
    VMR9_SampleFieldSingleEven = 5,
    VMR9_SampleFieldSingleOdd = 6
} VMR9_SampleFormat;
typedef struct _VMR9VideoDesc {
    DWORD dwSize;
    DWORD dwSampleWidth;
    DWORD dwSampleHeight;
    VMR9_SampleFormat SampleFormat;
    DWORD dwFourCC;
    VMR9Frequency InputSampleFreq;
    VMR9Frequency OutputFrameFreq;
} VMR9VideoDesc;
typedef struct _VMR9DeinterlaceCaps {
    DWORD dwSize;
    DWORD dwNumPreviousOutputFrames;
    DWORD dwNumForwardRefSamples;
    DWORD dwNumBackwardRefSamples;
    VMR9DeinterlaceTech DeinterlaceTechnology;
} VMR9DeinterlaceCaps;
/*****************************************************************************
 * IVMRDeinterlaceControl9 interface
 */
#ifndef __IVMRDeinterlaceControl9_INTERFACE_DEFINED__
#define __IVMRDeinterlaceControl9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRDeinterlaceControl9, 0xa215fb8d, 0x13c2, 0x4f7f, 0x99,0x3c, 0x00,0x3d,0x62,0x71,0xa4,0x59);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("a215fb8d-13c2-4f7f-993c-003d6271a459")
IVMRDeinterlaceControl9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetNumberOfDeinterlaceModes(
        VMR9VideoDesc *desc,
        DWORD *nummodes,
        GUID *modes) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetDeinterlaceModeCaps(
        GUID *mode,
        VMR9VideoDesc *desc,
        VMR9DeinterlaceCaps *caps) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetDeinterlaceMode(
        DWORD streamid,
        GUID *mode) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetDeinterlaceMode(
        DWORD streamid,
        GUID *mode) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetDeinterlacePrefs(
        DWORD *prefs) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetDeinterlacePrefs(
        DWORD prefs) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetActualDeinterlaceMode(
        DWORD streamid,
        GUID *mode) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRDeinterlaceControl9, 0xa215fb8d, 0x13c2, 0x4f7f, 0x99,0x3c, 0x00,0x3d,0x62,0x71,0xa4,0x59)
#endif
#else
typedef struct IVMRDeinterlaceControl9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRDeinterlaceControl9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRDeinterlaceControl9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRDeinterlaceControl9* This);

    /*** IVMRDeinterlaceControl9 methods ***/
    HRESULT (STDMETHODCALLTYPE *GetNumberOfDeinterlaceModes)(
        IVMRDeinterlaceControl9* This,
        VMR9VideoDesc *desc,
        DWORD *nummodes,
        GUID *modes);

    HRESULT (STDMETHODCALLTYPE *GetDeinterlaceModeCaps)(
        IVMRDeinterlaceControl9* This,
        GUID *mode,
        VMR9VideoDesc *desc,
        VMR9DeinterlaceCaps *caps);

    HRESULT (STDMETHODCALLTYPE *GetDeinterlaceMode)(
        IVMRDeinterlaceControl9* This,
        DWORD streamid,
        GUID *mode);

    HRESULT (STDMETHODCALLTYPE *SetDeinterlaceMode)(
        IVMRDeinterlaceControl9* This,
        DWORD streamid,
        GUID *mode);

    HRESULT (STDMETHODCALLTYPE *GetDeinterlacePrefs)(
        IVMRDeinterlaceControl9* This,
        DWORD *prefs);

    HRESULT (STDMETHODCALLTYPE *SetDeinterlacePrefs)(
        IVMRDeinterlaceControl9* This,
        DWORD prefs);

    HRESULT (STDMETHODCALLTYPE *GetActualDeinterlaceMode)(
        IVMRDeinterlaceControl9* This,
        DWORD streamid,
        GUID *mode);

    END_INTERFACE
} IVMRDeinterlaceControl9Vtbl;
interface IVMRDeinterlaceControl9 {
    CONST_VTBL IVMRDeinterlaceControl9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRDeinterlaceControl9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRDeinterlaceControl9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRDeinterlaceControl9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRDeinterlaceControl9 methods ***/
#define IVMRDeinterlaceControl9_GetNumberOfDeinterlaceModes(This,desc,nummodes,modes) (This)->lpVtbl->GetNumberOfDeinterlaceModes(This,desc,nummodes,modes)
#define IVMRDeinterlaceControl9_GetDeinterlaceModeCaps(This,mode,desc,caps) (This)->lpVtbl->GetDeinterlaceModeCaps(This,mode,desc,caps)
#define IVMRDeinterlaceControl9_GetDeinterlaceMode(This,streamid,mode) (This)->lpVtbl->GetDeinterlaceMode(This,streamid,mode)
#define IVMRDeinterlaceControl9_SetDeinterlaceMode(This,streamid,mode) (This)->lpVtbl->SetDeinterlaceMode(This,streamid,mode)
#define IVMRDeinterlaceControl9_GetDeinterlacePrefs(This,prefs) (This)->lpVtbl->GetDeinterlacePrefs(This,prefs)
#define IVMRDeinterlaceControl9_SetDeinterlacePrefs(This,prefs) (This)->lpVtbl->SetDeinterlacePrefs(This,prefs)
#define IVMRDeinterlaceControl9_GetActualDeinterlaceMode(This,streamid,mode) (This)->lpVtbl->GetActualDeinterlaceMode(This,streamid,mode)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRDeinterlaceControl9_QueryInterface(IVMRDeinterlaceControl9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRDeinterlaceControl9_AddRef(IVMRDeinterlaceControl9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRDeinterlaceControl9_Release(IVMRDeinterlaceControl9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRDeinterlaceControl9 methods ***/
static FORCEINLINE HRESULT IVMRDeinterlaceControl9_GetNumberOfDeinterlaceModes(IVMRDeinterlaceControl9* This,VMR9VideoDesc *desc,DWORD *nummodes,GUID *modes) {
    return This->lpVtbl->GetNumberOfDeinterlaceModes(This,desc,nummodes,modes);
}
static FORCEINLINE HRESULT IVMRDeinterlaceControl9_GetDeinterlaceModeCaps(IVMRDeinterlaceControl9* This,GUID *mode,VMR9VideoDesc *desc,VMR9DeinterlaceCaps *caps) {
    return This->lpVtbl->GetDeinterlaceModeCaps(This,mode,desc,caps);
}
static FORCEINLINE HRESULT IVMRDeinterlaceControl9_GetDeinterlaceMode(IVMRDeinterlaceControl9* This,DWORD streamid,GUID *mode) {
    return This->lpVtbl->GetDeinterlaceMode(This,streamid,mode);
}
static FORCEINLINE HRESULT IVMRDeinterlaceControl9_SetDeinterlaceMode(IVMRDeinterlaceControl9* This,DWORD streamid,GUID *mode) {
    return This->lpVtbl->SetDeinterlaceMode(This,streamid,mode);
}
static FORCEINLINE HRESULT IVMRDeinterlaceControl9_GetDeinterlacePrefs(IVMRDeinterlaceControl9* This,DWORD *prefs) {
    return This->lpVtbl->GetDeinterlacePrefs(This,prefs);
}
static FORCEINLINE HRESULT IVMRDeinterlaceControl9_SetDeinterlacePrefs(IVMRDeinterlaceControl9* This,DWORD prefs) {
    return This->lpVtbl->SetDeinterlacePrefs(This,prefs);
}
static FORCEINLINE HRESULT IVMRDeinterlaceControl9_GetActualDeinterlaceMode(IVMRDeinterlaceControl9* This,DWORD streamid,GUID *mode) {
    return This->lpVtbl->GetActualDeinterlaceMode(This,streamid,mode);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl9_GetNumberOfDeinterlaceModes_Proxy(
    IVMRDeinterlaceControl9* This,
    VMR9VideoDesc *desc,
    DWORD *nummodes,
    GUID *modes);
void __RPC_STUB IVMRDeinterlaceControl9_GetNumberOfDeinterlaceModes_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl9_GetDeinterlaceModeCaps_Proxy(
    IVMRDeinterlaceControl9* This,
    GUID *mode,
    VMR9VideoDesc *desc,
    VMR9DeinterlaceCaps *caps);
void __RPC_STUB IVMRDeinterlaceControl9_GetDeinterlaceModeCaps_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl9_GetDeinterlaceMode_Proxy(
    IVMRDeinterlaceControl9* This,
    DWORD streamid,
    GUID *mode);
void __RPC_STUB IVMRDeinterlaceControl9_GetDeinterlaceMode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl9_SetDeinterlaceMode_Proxy(
    IVMRDeinterlaceControl9* This,
    DWORD streamid,
    GUID *mode);
void __RPC_STUB IVMRDeinterlaceControl9_SetDeinterlaceMode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl9_GetDeinterlacePrefs_Proxy(
    IVMRDeinterlaceControl9* This,
    DWORD *prefs);
void __RPC_STUB IVMRDeinterlaceControl9_GetDeinterlacePrefs_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl9_SetDeinterlacePrefs_Proxy(
    IVMRDeinterlaceControl9* This,
    DWORD prefs);
void __RPC_STUB IVMRDeinterlaceControl9_SetDeinterlacePrefs_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl9_GetActualDeinterlaceMode_Proxy(
    IVMRDeinterlaceControl9* This,
    DWORD streamid,
    GUID *mode);
void __RPC_STUB IVMRDeinterlaceControl9_GetActualDeinterlaceMode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRDeinterlaceControl9_INTERFACE_DEFINED__ */

typedef struct _VMR9VideoStreamInfo {
    IDirect3DSurface9 *pddsVideoSurface;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwStrmID;
    FLOAT fAlpha;
    VMR9NormalizedRect rNormal;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtEnd;
    VMR9_SampleFormat SampleFormat;
} VMR9VideoStreamInfo;
/*****************************************************************************
 * IVMRImageCompositor9 interface
 */
#ifndef __IVMRImageCompositor9_INTERFACE_DEFINED__
#define __IVMRImageCompositor9_INTERFACE_DEFINED__

DEFINE_GUID(IID_IVMRImageCompositor9, 0x4a5c89eb, 0xdf51, 0x4654, 0xac,0x2a, 0xe4,0x8e,0x02,0xbb,0xab,0xf6);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("4a5c89eb-df51-4654-ac2a-e48e02bbabf6")
IVMRImageCompositor9 : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE InitCompositionDevice(
        IUnknown *d3ddev) = 0;

    virtual HRESULT STDMETHODCALLTYPE TermCompositionDevice(
        IUnknown *d3ddev) = 0;

    virtual HRESULT STDMETHODCALLTYPE CompositeImage(
        IUnknown *d3ddev,
        IDirect3DSurface9 *d3dtarget,
        AM_MEDIA_TYPE *mttarget,
        REFERENCE_TIME start,
        REFERENCE_TIME stop,
        D3DCOLOR back,
        VMR9VideoStreamInfo *info,
        UINT streams) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IVMRImageCompositor9, 0x4a5c89eb, 0xdf51, 0x4654, 0xac,0x2a, 0xe4,0x8e,0x02,0xbb,0xab,0xf6)
#endif
#else
typedef struct IVMRImageCompositor9Vtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IVMRImageCompositor9* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IVMRImageCompositor9* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IVMRImageCompositor9* This);

    /*** IVMRImageCompositor9 methods ***/
    HRESULT (STDMETHODCALLTYPE *InitCompositionDevice)(
        IVMRImageCompositor9* This,
        IUnknown *d3ddev);

    HRESULT (STDMETHODCALLTYPE *TermCompositionDevice)(
        IVMRImageCompositor9* This,
        IUnknown *d3ddev);

    HRESULT (STDMETHODCALLTYPE *CompositeImage)(
        IVMRImageCompositor9* This,
        IUnknown *d3ddev,
        IDirect3DSurface9 *d3dtarget,
        AM_MEDIA_TYPE *mttarget,
        REFERENCE_TIME start,
        REFERENCE_TIME stop,
        D3DCOLOR back,
        VMR9VideoStreamInfo *info,
        UINT streams);

    END_INTERFACE
} IVMRImageCompositor9Vtbl;
interface IVMRImageCompositor9 {
    CONST_VTBL IVMRImageCompositor9Vtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IVMRImageCompositor9_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVMRImageCompositor9_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVMRImageCompositor9_Release(This) (This)->lpVtbl->Release(This)
/*** IVMRImageCompositor9 methods ***/
#define IVMRImageCompositor9_InitCompositionDevice(This,d3ddev) (This)->lpVtbl->InitCompositionDevice(This,d3ddev)
#define IVMRImageCompositor9_TermCompositionDevice(This,d3ddev) (This)->lpVtbl->TermCompositionDevice(This,d3ddev)
#define IVMRImageCompositor9_CompositeImage(This,d3ddev,d3dtarget,mttarget,start,stop,back,info,streams) (This)->lpVtbl->CompositeImage(This,d3ddev,d3dtarget,mttarget,start,stop,back,info,streams)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IVMRImageCompositor9_QueryInterface(IVMRImageCompositor9* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IVMRImageCompositor9_AddRef(IVMRImageCompositor9* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IVMRImageCompositor9_Release(IVMRImageCompositor9* This) {
    return This->lpVtbl->Release(This);
}
/*** IVMRImageCompositor9 methods ***/
static FORCEINLINE HRESULT IVMRImageCompositor9_InitCompositionDevice(IVMRImageCompositor9* This,IUnknown *d3ddev) {
    return This->lpVtbl->InitCompositionDevice(This,d3ddev);
}
static FORCEINLINE HRESULT IVMRImageCompositor9_TermCompositionDevice(IVMRImageCompositor9* This,IUnknown *d3ddev) {
    return This->lpVtbl->TermCompositionDevice(This,d3ddev);
}
static FORCEINLINE HRESULT IVMRImageCompositor9_CompositeImage(IVMRImageCompositor9* This,IUnknown *d3ddev,IDirect3DSurface9 *d3dtarget,AM_MEDIA_TYPE *mttarget,REFERENCE_TIME start,REFERENCE_TIME stop,D3DCOLOR back,VMR9VideoStreamInfo *info,UINT streams) {
    return This->lpVtbl->CompositeImage(This,d3ddev,d3dtarget,mttarget,start,stop,back,info,streams);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IVMRImageCompositor9_InitCompositionDevice_Proxy(
    IVMRImageCompositor9* This,
    IUnknown *d3ddev);
void __RPC_STUB IVMRImageCompositor9_InitCompositionDevice_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRImageCompositor9_TermCompositionDevice_Proxy(
    IVMRImageCompositor9* This,
    IUnknown *d3ddev);
void __RPC_STUB IVMRImageCompositor9_TermCompositionDevice_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IVMRImageCompositor9_CompositeImage_Proxy(
    IVMRImageCompositor9* This,
    IUnknown *d3ddev,
    IDirect3DSurface9 *d3dtarget,
    AM_MEDIA_TYPE *mttarget,
    REFERENCE_TIME start,
    REFERENCE_TIME stop,
    D3DCOLOR back,
    VMR9VideoStreamInfo *info,
    UINT streams);
void __RPC_STUB IVMRImageCompositor9_CompositeImage_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IVMRImageCompositor9_INTERFACE_DEFINED__ */

/* Begin additional prototypes for all interfaces */


/* End additional prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __vmr9_h__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/share/mingw-w64/include/vsadmin.h                                                               0100644 0000000 0000000 00000004130 12404413016 016145  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_VSADMIN
#define _INC_VSADMIN

#include <vss.h>
#if (_WIN32_WINNT >= 0x600)
#undef  INTERFACE
#define INTERFACE IVssAdmin
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssAdmin,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssAdmin methods */
    STDMETHOD_(HRESULT,RegisterProvider)(THIS_ VSS_ID pProviderId,CLSID ClassId,VSS_PWSZ pwszProviderName,VSS_PROVIDER_TYPE eProviderType,VSS_PWSZ pwszProviderVersion,VSS_ID ProviderVersionId) PURE;
    STDMETHOD_(HRESULT,UnregisterProvider)(THIS_ VSS_ID ProviderId) PURE;
    STDMETHOD_(HRESULT,QueryProviders)(THIS_ IVssEnumObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,AbortAllSnapshotsInProgress)(THIS) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssAdmin_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssAdmin_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssAdmin_Release(This) (This)->lpVtbl->Release(This)
#define IVssAdmin_RegisterProvider(This,pProviderId,ClassId,pwszProviderName,eProviderType,pwszProviderVersion,ProviderVersionId) (This)->lpVtbl->RegisterProvider(This,pProviderId,ClassId,pwszProviderName,eProviderType,pwszProviderVersion,ProviderVersionId)
#define IVssAdmin_UnregisterProvider(This,ProviderId) (This)->lpVtbl->UnregisterProvider(This,ProviderId)
#define IVssAdmin_QueryProviders(This,ppEnum) (This)->lpVtbl->QueryProviders(This,ppEnum)
#define IVssAdmin_AbortAllSnapshotsInProgress() (This)->lpVtbl->AbortAllSnapshotsInProgress(This)
#endif /*COBJMACROS*/
#endif /*(_WIN32_WINNT >= 0x600)*/
#endif /*_INC_VSWRITER*/
                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/share/mingw-w64/include/vsbackup.h                                                              0100644 0000000 0000000 00000202664 12404413016 016336  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_VSBACKUP
#define _INC_VSBACKUP

#include <vss.h>
#include <vswriter.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct VSS_COMPONENTINFO {
  VSS_COMPONENT_TYPE type;
  BSTR               bstrLogicalPath;
  BSTR               bstrComponentName;
  BSTR               bstrCaption;
  BYTE               *pbIcon;
  UINT               cbIcon;
  BOOLEAN            bRestoreMetadata;
  BOOLEAN            bNotifyOnBackupComplete;
  BOOLEAN            bSelectable;
  BOOLEAN            bSelectableForRestore;
  DWORD              dwComponentFlags;
  UINT               cFileCount;
  UINT               cDatabases;
  UINT               cLogFiles;
  UINT               cDependencies;
} VSS_COMPONENTINFO, *PVSSCOMPONENTINFO;

HRESULT WINAPI CreateVssBackupComponentsInternal(
  IVssBackupComponents **ppBackup
);

FORCEINLINE
HRESULT WINAPI CreateVssBackupComponents(
  IVssBackupComponents **ppBackup
){return CreateVssBackupComponentsInternal(ppBackup);}

HRESULT WINAPI CreateVssExamineWriterMetadataInternal(
  BSTR bstrXML,
  IVssExamineWriterMetadata **ppMetadata
);

FORCEINLINE
HRESULT WINAPI CreateVssExamineWriterMetadata(
  BSTR bstrXML,
  IVssExamineWriterMetadata **ppMetadata
){return CreateVssExamineWriterMetadataInternal(bstrXML,ppMetadata);}

HRESULT WINAPI IsVolumeSnapshottedInternal(
  VSS_PWSZ pwszVolumeName,
  BOOLEAN *pbSnapshotsPresent,
  LONG *plSnapshotCapability
);

FORCEINLINE
HRESULT WINAPI IsVolumeSnapshotted(
  VSS_PWSZ pwszVolumeName,
  BOOLEAN *pbSnapshotsPresent,
  LONG *plSnapshotCapability
){return IsVolumeSnapshottedInternal(pwszVolumeName,pbSnapshotsPresent,plSnapshotCapability);}

HRESULT WINAPI ShouldBlockRevertInternal(
  LPCWSTR wszVolumeName,
  BOOLEAN *pbBlock
);

FORCEINLINE
HRESULT WINAPI ShouldBlockRevert(
  LPCWSTR wszVolumeName,
  BOOLEAN *pbBlock
){return ShouldBlockRevertInternal(wszVolumeName,pbBlock);}

void WINAPI VssFreeSnapshotPropertiesInternal(
  VSS_SNAPSHOT_PROP *pProp
);

FORCEINLINE
void WINAPI VssFreeSnapshotProperties(
  VSS_SNAPSHOT_PROP *pProp
){VssFreeSnapshotPropertiesInternal(pProp);}

HRESULT WINAPI GetProviderMgmtInterfaceInternal(
  VSS_ID ProviderId,
  IID InterfaceId,
  IUnknown** ppItf
);

FORCEINLINE
HRESULT WINAPI GetProviderMgmtInterface(
  VSS_ID ProviderId,
  IID InterfaceId,
  IUnknown** ppItf
){return GetProviderMgmtInterfaceInternal(ProviderId,InterfaceId,ppItf);}

#ifdef __cplusplus
}
#endif

#undef  INTERFACE
#define INTERFACE IVssBackupComponents
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssBackupComponents,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssBackupComponents methods */
    STDMETHOD_(HRESULT,GetWriterComponentsCount)(THIS_ UINT *pcComponents) PURE;
    STDMETHOD_(HRESULT,GetWriterComponents)(THIS_ UINT iWriter,IVssWriterComponentsExt **pWriterComponents) PURE;
    STDMETHOD_(HRESULT,InitializeForBackup)(THIS_ BSTR bstrXML) PURE;
    STDMETHOD_(HRESULT,SetBackupState)(THIS_ BOOLEAN bSelectComponents,BOOLEAN bBackupBootableSystemState,VSS_BACKUP_TYPE backupType,BOOLEAN bPartialFileSupport) PURE;
    STDMETHOD_(HRESULT,InitializeForRestore)(THIS_ BSTR bstrXML) PURE;
    STDMETHOD_(HRESULT,SetRestoreState)(THIS_ VSS_RESTORE_TYPE restoreType) PURE;
    STDMETHOD_(HRESULT,GatherWriterMetadata)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,GetWriterMetadataCount)(THIS_ UINT *pcWriters) PURE;
    STDMETHOD_(HRESULT,GetWriterMetadata)(THIS_ UINT iWriter,VSS_ID *pidWriterInstance,IVssExamineWriterMetadata **ppMetadata) PURE;
    STDMETHOD_(HRESULT,FreeWriterMetadata)(THIS) PURE;
    STDMETHOD_(HRESULT,AddComponent)(THIS_ VSS_ID instanceId,VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName) PURE;
    STDMETHOD_(HRESULT,PrepareForBackup)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,AbortBackup)(THIS) PURE;
    STDMETHOD_(HRESULT,GatherWriterStatus)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,GetWriterStatusCount)(THIS_ UINT *pcWriters) PURE;
    STDMETHOD_(HRESULT,FreeWriterStatus)(THIS) PURE;
    STDMETHOD_(HRESULT,GetWriterStatus)(THIS_ UINT iWriter,VSS_ID *pidInstance,VSS_ID *pidWriter,BSTR *pbstrWriter,VSS_WRITER_STATE *pState,HRESULT *pHrResultFailure) PURE;
    STDMETHOD_(HRESULT,SetBackupSucceeded)(THIS_ VSS_ID instanceId,VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bSucceeded) PURE;
    STDMETHOD_(HRESULT,SetBackupOptions)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszBackupOptions) PURE;
    STDMETHOD_(HRESULT,SetSelectedForRestore)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bSelectedForRestore) PURE;
    STDMETHOD_(HRESULT,SetRestoreOptions)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszRestoreOptions) PURE;
    STDMETHOD_(HRESULT,SetAdditionalRestores)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bAdditionalResources) PURE;
    STDMETHOD_(HRESULT,SetPreviousBackupStamp)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPreviousBackupStamp) PURE;
    STDMETHOD_(HRESULT,SaveAsXML)(THIS_ BSTR *pbstrXML) PURE;
    STDMETHOD_(HRESULT,BackupComplete)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,AddAlternativeLocationMapping)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive,LPCWSTR wszDestination) PURE;
    STDMETHOD_(HRESULT,AddRestoreSubcomponent)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszSubComponentLogicalPath,LPCWSTR wszSubComponentName,BOOLEAN bRepair) PURE;
    STDMETHOD_(HRESULT,SetFileRestoreStatus)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,VSS_FILE_RESTORE_STATUS status) PURE;
    STDMETHOD_(HRESULT,AddNewTarget)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPath,LPCWSTR wszFileName,BOOLEAN bRecursive,LPCWSTR wszAlternatePath) PURE;
    STDMETHOD_(HRESULT,SetRangesFilePath)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,UINT iPartialFile,LPCWSTR wszRangesFile) PURE;
    STDMETHOD_(HRESULT,PreRestore)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,PostRestore)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,SetContext)(THIS_ LONG lContext) PURE;
    STDMETHOD_(HRESULT,StartSnapshotSet)(THIS_ VSS_ID *pSnapshotSetId) PURE;
    STDMETHOD_(HRESULT,AddToSnapshotSet)(THIS_ VSS_PWSZ pwszVolumeName,VSS_ID ProviderId,VSS_ID *pidSnapshot) PURE;
    STDMETHOD_(HRESULT,DoSnapshotSet)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,DeleteSnapshots)(THIS_ VSS_ID SourceObjectId,VSS_OBJECT_TYPE eSourceObjectType,BOOLEAN bForceDelete,LONG *plDeletedSnapshots,VSS_ID *pNondeletedSnapshotID) PURE;
    STDMETHOD_(HRESULT,ImportSnapshots)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,BreakSnapshotSet)(THIS_ VSS_ID SnapshotSetId) PURE;
    STDMETHOD_(HRESULT,GetSnapshotProperties)(THIS_ VSS_ID SnapshotId,VSS_SNAPSHOT_PROP *pProp) PURE;
    STDMETHOD_(HRESULT,Query)(THIS_ VSS_ID QueriedObjectId,VSS_OBJECT_TYPE eQueriedObjectType,VSS_OBJECT_TYPE eReturnedObjectsType,IVssEnumObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,IsVolumeSupported)(THIS_ VSS_ID ProviderId,VSS_PWSZ pwszVolumeName,BOOLEAN *pbSupportedByThisProvider) PURE;
    STDMETHOD_(HRESULT,DisableWriterClasses)(THIS_ const VSS_ID *rgWriterClassId,UINT cClassId) PURE;
    STDMETHOD_(HRESULT,EnableWriterClasses)(THIS_ const VSS_ID *rgWriterClassId,UINT cClassId) PURE;
    STDMETHOD_(HRESULT,DisableWriterInstances)(THIS_ const VSS_ID *rgWriterInstanceId,UINT cInstanceId) PURE;
    STDMETHOD_(HRESULT,ExposeSnapshot)(THIS_ VSS_ID SnapshotId,VSS_PWSZ wszPathFromRoot,LONG lAttributes,VSS_PWSZ wszExpose,VSS_PWSZ *pwszExposed) PURE;
    STDMETHOD_(HRESULT,RevertToSnapshot)(THIS_ VSS_ID SnapshotId,BOOLEAN bForceDismount) PURE;
    STDMETHOD_(HRESULT,QueryRevertStatus)(THIS_ VSS_PWSZ pwszVolume,IVssAsync **ppAsync) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssBackupComponents_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssBackupComponents_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssBackupComponents_Release(This) (This)->lpVtbl->Release(This)
#define IVssBackupComponents_GetWriterComponentsCount(This,pcComponents) (This)->lpVtbl->GetWriterComponentsCount(This,pcComponents)
#define IVssBackupComponents_GetWriterComponents(This,iWriter,pWriterComponents) (This)->lpVtbl->GetWriterComponents(This,iWriter,pWriterComponents)
#define IVssBackupComponents_InitializeForBackup(This,bstrXML) (This)->lpVtbl->InitializeForBackup(This,bstrXML)
#define IVssBackupComponents_SetBackupState(This,bSelectComponents,bBackupBootableSystemState,backupType,bPartialFileSupport) (This)->lpVtbl->SetBackupState(This,bSelectComponents,bBackupBootableSystemState,backupType,bPartialFileSupport)
#define IVssBackupComponents_InitializeForRestore(This,bstrXML) (This)->lpVtbl->InitializeForRestore(This,bstrXML)
#define IVssBackupComponents_SetRestoreState(This,restoreType) (This)->lpVtbl->SetRestoreState(This,restoreType)
#define IVssBackupComponents_GatherWriterMetadata(This,ppAsync) (This)->lpVtbl->GatherWriterMetadata(This,ppAsync)
#define IVssBackupComponents_GetWriterMetadataCount(This,pcWriters) (This)->lpVtbl->GetWriterMetadataCount(This,pcWriters)
#define IVssBackupComponents_GetWriterMetadata(This,iWriter,pidWriterInstance,ppMetadata) (This)->lpVtbl->GetWriterMetadata(This,iWriter,pidWriterInstance,ppMetadata)
#define IVssBackupComponents_FreeWriterMetadata() (This)->lpVtbl->FreeWriterMetadata(This)
#define IVssBackupComponents_AddComponent(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName) (This)->lpVtbl->AddComponent(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName)
#define IVssBackupComponents_PrepareForBackup(This,ppAsync) (This)->lpVtbl->PrepareForBackup(This,ppAsync)
#define IVssBackupComponents_AbortBackup() (This)->lpVtbl->AbortBackup(This)
#define IVssBackupComponents_GatherWriterStatus(This,ppAsync) (This)->lpVtbl->GatherWriterStatus(This,ppAsync)
#define IVssBackupComponents_GetWriterStatusCount(This,pcWriters) (This)->lpVtbl->GetWriterStatusCount(This,pcWriters)
#define IVssBackupComponents_FreeWriterStatus() (This)->lpVtbl->FreeWriterStatus(This)
#define IVssBackupComponents_GetWriterStatus(This,iWriter,pidInstance,pidWriter,pbstrWriter,pState,pHrResultFailure) (This)->lpVtbl->GetWriterStatus(This,iWriter,pidInstance,pidWriter,pbstrWriter,pState,pHrResultFailure)
#define IVssBackupComponents_SetBackupSucceeded(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName,bSucceeded) (This)->lpVtbl->SetBackupSucceeded(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName,bSucceeded)
#define IVssBackupComponents_SetBackupOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszBackupOptions) (This)->lpVtbl->SetBackupOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszBackupOptions)
#define IVssBackupComponents_SetSelectedForRestore(This,writerId,componentType,wszLogicalPath,wszComponentName,bSelectedForRestore) (This)->lpVtbl->SetSelectedForRestore(This,writerId,componentType,wszLogicalPath,wszComponentName,bSelectedForRestore)
#define IVssBackupComponents_SetRestoreOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszRestoreOptions) (This)->lpVtbl->SetRestoreOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszRestoreOptions)
#define IVssBackupComponents_SetAdditionalRestores(This,writerId,componentType,wszLogicalPath,wszComponentName,bAdditionalResources) (This)->lpVtbl->SetAdditionalRestores(This,writerId,componentType,wszLogicalPath,wszComponentName,bAdditionalResources)
#define IVssBackupComponents_SetPreviousBackupStamp(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPreviousBackupStamp) (This)->lpVtbl->SetPreviousBackupStamp(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPreviousBackupStamp)
#define IVssBackupComponents_SaveAsXML(This,pbstrXML) (This)->lpVtbl->SaveAsXML(This,pbstrXML)
#define IVssBackupComponents_BackupComplete(This,ppAsync) (This)->lpVtbl->BackupComplete(This,ppAsync)
#define IVssBackupComponents_AddAlternativeLocationMapping(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPath,wszFilespec,bRecursive,wszDestination) (This)->lpVtbl->AddAlternativeLocationMapping(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPath,wszFilespec,bRecursive,wszDestination)
#define IVssBackupComponents_AddRestoreSubcomponent(This,writerId,componentType,wszLogicalPath,wszComponentName,wszSubComponentLogicalPath,wszSubComponentName,bRepair) (This)->lpVtbl->AddRestoreSubcomponent(This,writerId,componentType,wszLogicalPath,wszComponentName,wszSubComponentLogicalPath,wszSubComponentName,bRepair)
#define IVssBackupComponents_SetFileRestoreStatus(This,writerId,componentType,wszLogicalPath,wszComponentName,status) (This)->lpVtbl->SetFileRestoreStatus(This,writerId,componentType,wszLogicalPath,wszComponentName,status)
#define IVssBackupComponents_AddNewTarget(This,writerId,ct,wszLogicalPath,wszComponentName,wszPath,wszFileName,bRecursive,wszAlternatePath) (This)->lpVtbl->AddNewTarget(This,writerId,ct,wszLogicalPath,wszComponentName,wszPath,wszFileName,bRecursive,wszAlternatePath)
#define IVssBackupComponents_SetRangesFilePath(This,writerId,ct,wszLogicalPath,wszComponentName,iPartialFile,wszRangesFile) (This)->lpVtbl->SetRangesFilePath(This,writerId,ct,wszLogicalPath,wszComponentName,iPartialFile,wszRangesFile)
#define IVssBackupComponents_PreRestore(This,ppAsync) (This)->lpVtbl->PreRestore(This,ppAsync)
#define IVssBackupComponents_PostRestore(This,ppAsync) (This)->lpVtbl->PostRestore(This,ppAsync)
#define IVssBackupComponents_SetContext(This,lContext) (This)->lpVtbl->SetContext(This,lContext)
#define IVssBackupComponents_StartSnapshotSet(This,pSnapshotSetId) (This)->lpVtbl->StartSnapshotSet(This,pSnapshotSetId)
#define IVssBackupComponents_AddToSnapshotSet(This,pwszVolumeName,ProviderId,pidSnapshot) (This)->lpVtbl->AddToSnapshotSet(This,pwszVolumeName,ProviderId,pidSnapshot)
#define IVssBackupComponents_DoSnapshotSet(This,ppAsync) (This)->lpVtbl->DoSnapshotSet(This,ppAsync)
#define IVssBackupComponents_DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID) (This)->lpVtbl->DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID)
#define IVssBackupComponents_ImportSnapshots(This,ppAsync) (This)->lpVtbl->ImportSnapshots(This,ppAsync)
#define IVssBackupComponents_BreakSnapshotSet(This,SnapshotSetId) (This)->lpVtbl->BreakSnapshotSet(This,SnapshotSetId)
#define IVssBackupComponents_GetSnapshotProperties(This,SnapshotId,pProp) (This)->lpVtbl->GetSnapshotProperties(This,SnapshotId,pProp)
#define IVssBackupComponents_Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum) (This)->lpVtbl->Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum)
#define IVssBackupComponents_IsVolumeSupported(This,ProviderId,pwszVolumeName,pbSupportedByThisProvider) (This)->lpVtbl->IsVolumeSupported(This,ProviderId,pwszVolumeName,pbSupportedByThisProvider)
#define IVssBackupComponents_DisableWriterClasses(This,rgWriterClassId,cClassId) (This)->lpVtbl->DisableWriterClasses(This,rgWriterClassId,cClassId)
#define IVssBackupComponents_EnableWriterClasses(This,rgWriterClassId,cClassId) (This)->lpVtbl->EnableWriterClasses(This,rgWriterClassId,cClassId)
#define IVssBackupComponents_DisableWriterInstances(This,rgWriterInstanceId,cInstanceId) (This)->lpVtbl->DisableWriterInstances(This,rgWriterInstanceId,cInstanceId)
#define IVssBackupComponents_ExposeSnapshot(This,SnapshotId,wszPathFromRoot,lAttributes,wszExpose,pwszExposed) (This)->lpVtbl->ExposeSnapshot(This,SnapshotId,wszPathFromRoot,lAttributes,wszExpose,pwszExposed)
#define IVssBackupComponents_RevertToSnapshot(This,SnapshotId,bForceDismount) (This)->lpVtbl->RevertToSnapshot(This,SnapshotId,bForceDismount)
#define IVssBackupComponents_QueryRevertStatus(This,pwszVolume,ppAsync) (This)->lpVtbl->QueryRevertStatus(This,pwszVolume,ppAsync)
#endif /*COBJMACROS*/

#if (_WIN32_WINNT >= 0x0600)
#undef  INTERFACE
#define INTERFACE IVssBackupComponentsEx
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssBackupComponentsEx,IVssBackupComponents)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssBackupComponents methods */
    STDMETHOD_(HRESULT,GetWriterComponentsCount)(THIS_ UINT *pcComponents) PURE;
    STDMETHOD_(HRESULT,GetWriterComponents)(THIS_ UINT iWriter,IVssWriterComponentsExt **pWriterComponents) PURE;
    STDMETHOD_(HRESULT,InitializeForBackup)(THIS_ BSTR bstrXML) PURE;
    STDMETHOD_(HRESULT,SetBackupState)(THIS_ BOOLEAN bSelectComponents,BOOLEAN bBackupBootableSystemState,VSS_BACKUP_TYPE backupType,BOOLEAN bPartialFileSupport) PURE;
    STDMETHOD_(HRESULT,InitializeForRestore)(THIS_ BSTR bstrXML) PURE;
    STDMETHOD_(HRESULT,SetRestoreState)(THIS_ VSS_RESTORE_TYPE restoreType) PURE;
    STDMETHOD_(HRESULT,GatherWriterMetadata)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,GetWriterMetadataCount)(THIS_ UINT *pcWriters) PURE;
    STDMETHOD_(HRESULT,GetWriterMetadata)(THIS_ UINT iWriter,VSS_ID *pidWriterInstance,IVssExamineWriterMetadata **ppMetadata) PURE;
    STDMETHOD_(HRESULT,FreeWriterMetadata)(THIS) PURE;
    STDMETHOD_(HRESULT,AddComponent)(THIS_ VSS_ID instanceId,VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName) PURE;
    STDMETHOD_(HRESULT,PrepareForBackup)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,AbortBackup)(THIS) PURE;
    STDMETHOD_(HRESULT,GatherWriterStatus)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,GetWriterStatusCount)(THIS_ UINT *pcWriters) PURE;
    STDMETHOD_(HRESULT,FreeWriterStatus)(THIS) PURE;
    STDMETHOD_(HRESULT,GetWriterStatus)(THIS_ UINT iWriter,VSS_ID *pidInstance,VSS_ID *pidWriter,BSTR *pbstrWriter,VSS_WRITER_STATE *pState,HRESULT *pHrResultFailure) PURE;
    STDMETHOD_(HRESULT,SetBackupSucceeded)(THIS_ VSS_ID instanceId,VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bSucceeded) PURE;
    STDMETHOD_(HRESULT,SetBackupOptions)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszBackupOptions) PURE;
    STDMETHOD_(HRESULT,SetSelectedForRestore)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bSelectedForRestore) PURE;
    STDMETHOD_(HRESULT,SetRestoreOptions)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszRestoreOptions) PURE;
    STDMETHOD_(HRESULT,SetAdditionalRestores)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bAdditionalResources) PURE;
    STDMETHOD_(HRESULT,SetPreviousBackupStamp)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPreviousBackupStamp) PURE;
    STDMETHOD_(HRESULT,SaveAsXML)(THIS_ BSTR *pbstrXML) PURE;
    STDMETHOD_(HRESULT,BackupComplete)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,AddAlternativeLocationMapping)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive,LPCWSTR wszDestination) PURE;
    STDMETHOD_(HRESULT,AddRestoreSubcomponent)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszSubComponentLogicalPath,LPCWSTR wszSubComponentName,BOOLEAN bRepair) PURE;
    STDMETHOD_(HRESULT,SetFileRestoreStatus)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,VSS_FILE_RESTORE_STATUS status) PURE;
    STDMETHOD_(HRESULT,AddNewTarget)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPath,LPCWSTR wszFileName,BOOLEAN bRecursive,LPCWSTR wszAlternatePath) PURE;
    STDMETHOD_(HRESULT,SetRangesFilePath)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,UINT iPartialFile,LPCWSTR wszRangesFile) PURE;
    STDMETHOD_(HRESULT,PreRestore)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,PostRestore)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,SetContext)(THIS_ LONG lContext) PURE;
    STDMETHOD_(HRESULT,StartSnapshotSet)(THIS_ VSS_ID *pSnapshotSetId) PURE;
    STDMETHOD_(HRESULT,AddToSnapshotSet)(THIS_ VSS_PWSZ pwszVolumeName,VSS_ID ProviderId,VSS_ID *pidSnapshot) PURE;
    STDMETHOD_(HRESULT,DoSnapshotSet)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,DeleteSnapshots)(THIS_ VSS_ID SourceObjectId,VSS_OBJECT_TYPE eSourceObjectType,BOOLEAN bForceDelete,LONG *plDeletedSnapshots,VSS_ID *pNondeletedSnapshotID) PURE;
    STDMETHOD_(HRESULT,ImportSnapshots)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,BreakSnapshotSet)(THIS_ VSS_ID SnapshotSetId) PURE;
    STDMETHOD_(HRESULT,GetSnapshotProperties)(THIS_ VSS_ID SnapshotId,VSS_SNAPSHOT_PROP *pProp) PURE;
    STDMETHOD_(HRESULT,Query)(THIS_ VSS_ID QueriedObjectId,VSS_OBJECT_TYPE eQueriedObjectType,VSS_OBJECT_TYPE eReturnedObjectsType,IVssEnumObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,IsVolumeSupported)(THIS_ VSS_ID ProviderId,VSS_PWSZ pwszVolumeName,BOOLEAN *pbSupportedByThisProvider) PURE;
    STDMETHOD_(HRESULT,DisableWriterClasses)(THIS_ const VSS_ID *rgWriterClassId,UINT cClassId) PURE;
    STDMETHOD_(HRESULT,EnableWriterClasses)(THIS_ const VSS_ID *rgWriterClassId,UINT cClassId) PURE;
    STDMETHOD_(HRESULT,DisableWriterInstances)(THIS_ const VSS_ID *rgWriterInstanceId,UINT cInstanceId) PURE;
    STDMETHOD_(HRESULT,ExposeSnapshot)(THIS_ VSS_ID SnapshotId,VSS_PWSZ wszPathFromRoot,LONG lAttributes,VSS_PWSZ wszExpose,VSS_PWSZ *pwszExposed) PURE;
    STDMETHOD_(HRESULT,RevertToSnapshot)(THIS_ VSS_ID SnapshotId,BOOLEAN bForceDismount) PURE;
    STDMETHOD_(HRESULT,QueryRevertStatus)(THIS_ VSS_PWSZ pwszVolume,IVssAsync **ppAsync) PURE;

    /* IVssBackupComponentsEx methods */
    STDMETHOD_(HRESULT,GetWriterMetadataEx)(THIS_ UINT iWriter,VSS_ID *pidInstance,IVssExamineWriterMetadataEx **ppMetadata) PURE;
    STDMETHOD_(HRESULT,SetSelectedForRestoreEx)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bSelectedForRestore,VSS_ID instanceId) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssBackupComponentsEx_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssBackupComponentsEx_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssBackupComponentsEx_Release(This) (This)->lpVtbl->Release(This)
#define IVssBackupComponentsEx_GetWriterComponentsCount(This,pcComponents) (This)->lpVtbl->GetWriterComponentsCount(This,pcComponents)
#define IVssBackupComponentsEx_GetWriterComponents(This,iWriter,pWriterComponents) (This)->lpVtbl->GetWriterComponents(This,iWriter,pWriterComponents)
#define IVssBackupComponentsEx_InitializeForBackup(This,bstrXML) (This)->lpVtbl->InitializeForBackup(This,bstrXML)
#define IVssBackupComponentsEx_SetBackupState(This,bSelectComponents,bBackupBootableSystemState,backupType,bPartialFileSupport) (This)->lpVtbl->SetBackupState(This,bSelectComponents,bBackupBootableSystemState,backupType,bPartialFileSupport)
#define IVssBackupComponentsEx_InitializeForRestore(This,bstrXML) (This)->lpVtbl->InitializeForRestore(This,bstrXML)
#define IVssBackupComponentsEx_SetRestoreState(This,restoreType) (This)->lpVtbl->SetRestoreState(This,restoreType)
#define IVssBackupComponentsEx_GatherWriterMetadata(This,ppAsync) (This)->lpVtbl->GatherWriterMetadata(This,ppAsync)
#define IVssBackupComponentsEx_GetWriterMetadataCount(This,pcWriters) (This)->lpVtbl->GetWriterMetadataCount(This,pcWriters)
#define IVssBackupComponentsEx_GetWriterMetadata(This,iWriter,pidWriterInstance,ppMetadata) (This)->lpVtbl->GetWriterMetadata(This,iWriter,pidWriterInstance,ppMetadata)
#define IVssBackupComponentsEx_FreeWriterMetadata() (This)->lpVtbl->FreeWriterMetadata(This)
#define IVssBackupComponentsEx_AddComponent(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName) (This)->lpVtbl->AddComponent(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName)
#define IVssBackupComponentsEx_PrepareForBackup(This,ppAsync) (This)->lpVtbl->PrepareForBackup(This,ppAsync)
#define IVssBackupComponentsEx_AbortBackup() (This)->lpVtbl->AbortBackup(This)
#define IVssBackupComponentsEx_GatherWriterStatus(This,ppAsync) (This)->lpVtbl->GatherWriterStatus(This,ppAsync)
#define IVssBackupComponentsEx_GetWriterStatusCount(This,pcWriters) (This)->lpVtbl->GetWriterStatusCount(This,pcWriters)
#define IVssBackupComponentsEx_FreeWriterStatus() (This)->lpVtbl->FreeWriterStatus(This)
#define IVssBackupComponentsEx_GetWriterStatus(This,iWriter,pidInstance,pidWriter,pbstrWriter,pState,pHrResultFailure) (This)->lpVtbl->GetWriterStatus(This,iWriter,pidInstance,pidWriter,pbstrWriter,pState,pHrResultFailure)
#define IVssBackupComponentsEx_SetBackupSucceeded(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName,bSucceeded) (This)->lpVtbl->SetBackupSucceeded(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName,bSucceeded)
#define IVssBackupComponentsEx_SetBackupOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszBackupOptions) (This)->lpVtbl->SetBackupOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszBackupOptions)
#define IVssBackupComponentsEx_SetSelectedForRestore(This,writerId,componentType,wszLogicalPath,wszComponentName,bSelectedForRestore) (This)->lpVtbl->SetSelectedForRestore(This,writerId,componentType,wszLogicalPath,wszComponentName,bSelectedForRestore)
#define IVssBackupComponentsEx_SetRestoreOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszRestoreOptions) (This)->lpVtbl->SetRestoreOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszRestoreOptions)
#define IVssBackupComponentsEx_SetAdditionalRestores(This,writerId,componentType,wszLogicalPath,wszComponentName,bAdditionalResources) (This)->lpVtbl->SetAdditionalRestores(This,writerId,componentType,wszLogicalPath,wszComponentName,bAdditionalResources)
#define IVssBackupComponentsEx_SetPreviousBackupStamp(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPreviousBackupStamp) (This)->lpVtbl->SetPreviousBackupStamp(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPreviousBackupStamp)
#define IVssBackupComponentsEx_SaveAsXML(This,pbstrXML) (This)->lpVtbl->SaveAsXML(This,pbstrXML)
#define IVssBackupComponentsEx_BackupComplete(This,ppAsync) (This)->lpVtbl->BackupComplete(This,ppAsync)
#define IVssBackupComponentsEx_AddAlternativeLocationMapping(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPath,wszFilespec,bRecursive,wszDestination) (This)->lpVtbl->AddAlternativeLocationMapping(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPath,wszFilespec,bRecursive,wszDestination)
#define IVssBackupComponentsEx_AddRestoreSubcomponent(This,writerId,componentType,wszLogicalPath,wszComponentName,wszSubComponentLogicalPath,wszSubComponentName,bRepair) (This)->lpVtbl->AddRestoreSubcomponent(This,writerId,componentType,wszLogicalPath,wszComponentName,wszSubComponentLogicalPath,wszSubComponentName,bRepair)
#define IVssBackupComponentsEx_SetFileRestoreStatus(This,writerId,componentType,wszLogicalPath,wszComponentName,status) (This)->lpVtbl->SetFileRestoreStatus(This,writerId,componentType,wszLogicalPath,wszComponentName,status)
#define IVssBackupComponentsEx_AddNewTarget(This,writerId,ct,wszLogicalPath,wszComponentName,wszPath,wszFileName,bRecursive,wszAlternatePath) (This)->lpVtbl->AddNewTarget(This,writerId,ct,wszLogicalPath,wszComponentName,wszPath,wszFileName,bRecursive,wszAlternatePath)
#define IVssBackupComponentsEx_SetRangesFilePath(This,writerId,ct,wszLogicalPath,wszComponentName,iPartialFile,wszRangesFile) (This)->lpVtbl->SetRangesFilePath(This,writerId,ct,wszLogicalPath,wszComponentName,iPartialFile,wszRangesFile)
#define IVssBackupComponentsEx_PreRestore(This,ppAsync) (This)->lpVtbl->PreRestore(This,ppAsync)
#define IVssBackupComponentsEx_PostRestore(This,ppAsync) (This)->lpVtbl->PostRestore(This,ppAsync)
#define IVssBackupComponentsEx_SetContext(This,lContext) (This)->lpVtbl->SetContext(This,lContext)
#define IVssBackupComponentsEx_StartSnapshotSet(This,pSnapshotSetId) (This)->lpVtbl->StartSnapshotSet(This,pSnapshotSetId)
#define IVssBackupComponentsEx_AddToSnapshotSet(This,pwszVolumeName,ProviderId,pidSnapshot) (This)->lpVtbl->AddToSnapshotSet(This,pwszVolumeName,ProviderId,pidSnapshot)
#define IVssBackupComponentsEx_DoSnapshotSet(This,ppAsync) (This)->lpVtbl->DoSnapshotSet(This,ppAsync)
#define IVssBackupComponentsEx_DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID) (This)->lpVtbl->DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID)
#define IVssBackupComponentsEx_ImportSnapshots(This,ppAsync) (This)->lpVtbl->ImportSnapshots(This,ppAsync)
#define IVssBackupComponentsEx_BreakSnapshotSet(This,SnapshotSetId) (This)->lpVtbl->BreakSnapshotSet(This,SnapshotSetId)
#define IVssBackupComponentsEx_GetSnapshotProperties(This,SnapshotId,pProp) (This)->lpVtbl->GetSnapshotProperties(This,SnapshotId,pProp)
#define IVssBackupComponentsEx_Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum) (This)->lpVtbl->Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum)
#define IVssBackupComponentsEx_IsVolumeSupported(This,ProviderId,pwszVolumeName,pbSupportedByThisProvider) (This)->lpVtbl->IsVolumeSupported(This,ProviderId,pwszVolumeName,pbSupportedByThisProvider)
#define IVssBackupComponentsEx_DisableWriterClasses(This,rgWriterClassId,cClassId) (This)->lpVtbl->DisableWriterClasses(This,rgWriterClassId,cClassId)
#define IVssBackupComponentsEx_EnableWriterClasses(This,rgWriterClassId,cClassId) (This)->lpVtbl->EnableWriterClasses(This,rgWriterClassId,cClassId)
#define IVssBackupComponentsEx_DisableWriterInstances(This,rgWriterInstanceId,cInstanceId) (This)->lpVtbl->DisableWriterInstances(This,rgWriterInstanceId,cInstanceId)
#define IVssBackupComponentsEx_ExposeSnapshot(This,SnapshotId,wszPathFromRoot,lAttributes,wszExpose,pwszExposed) (This)->lpVtbl->ExposeSnapshot(This,SnapshotId,wszPathFromRoot,lAttributes,wszExpose,pwszExposed)
#define IVssBackupComponentsEx_RevertToSnapshot(This,SnapshotId,bForceDismount) (This)->lpVtbl->RevertToSnapshot(This,SnapshotId,bForceDismount)
#define IVssBackupComponentsEx_QueryRevertStatus(This,pwszVolume,ppAsync) (This)->lpVtbl->QueryRevertStatus(This,pwszVolume,ppAsync)
#define IVssBackupComponentsEx_GetWriterMetadataEx(This,iWriter,pidInstance,ppMetadata) (This)->lpVtbl->GetWriterMetadataEx(This,iWriter,pidInstance,ppMetadata)
#define IVssBackupComponentsEx_SetSelectedForRestoreEx(This,writerId,ct,wszLogicalPath,wszComponentName,bSelectedForRestore,instanceId) (This)->lpVtbl->SetSelectedForRestoreEx(This,writerId,ct,wszLogicalPath,wszComponentName,bSelectedForRestore,instanceId)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IVssBackupComponentsEx2
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssBackupComponentsEx2,IVssBackupComponentsEx)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssBackupComponents methods */
    STDMETHOD_(HRESULT,GetWriterComponentsCount)(THIS_ UINT *pcComponents) PURE;
    STDMETHOD_(HRESULT,GetWriterComponents)(THIS_ UINT iWriter,IVssWriterComponentsExt **pWriterComponents) PURE;
    STDMETHOD_(HRESULT,InitializeForBackup)(THIS_ BSTR bstrXML) PURE;
    STDMETHOD_(HRESULT,SetBackupState)(THIS_ BOOLEAN bSelectComponents,BOOLEAN bBackupBootableSystemState,VSS_BACKUP_TYPE backupType,BOOLEAN bPartialFileSupport) PURE;
    STDMETHOD_(HRESULT,InitializeForRestore)(THIS_ BSTR bstrXML) PURE;
    STDMETHOD_(HRESULT,SetRestoreState)(THIS_ VSS_RESTORE_TYPE restoreType) PURE;
    STDMETHOD_(HRESULT,GatherWriterMetadata)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,GetWriterMetadataCount)(THIS_ UINT *pcWriters) PURE;
    STDMETHOD_(HRESULT,GetWriterMetadata)(THIS_ UINT iWriter,VSS_ID *pidWriterInstance,IVssExamineWriterMetadata **ppMetadata) PURE;
    STDMETHOD_(HRESULT,FreeWriterMetadata)(THIS) PURE;
    STDMETHOD_(HRESULT,AddComponent)(THIS_ VSS_ID instanceId,VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName) PURE;
    STDMETHOD_(HRESULT,PrepareForBackup)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,AbortBackup)(THIS) PURE;
    STDMETHOD_(HRESULT,GatherWriterStatus)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,GetWriterStatusCount)(THIS_ UINT *pcWriters) PURE;
    STDMETHOD_(HRESULT,FreeWriterStatus)(THIS) PURE;
    STDMETHOD_(HRESULT,GetWriterStatus)(THIS_ UINT iWriter,VSS_ID *pidInstance,VSS_ID *pidWriter,BSTR *pbstrWriter,VSS_WRITER_STATE *pState,HRESULT *pHrResultFailure) PURE;
    STDMETHOD_(HRESULT,SetBackupSucceeded)(THIS_ VSS_ID instanceId,VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bSucceeded) PURE;
    STDMETHOD_(HRESULT,SetBackupOptions)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszBackupOptions) PURE;
    STDMETHOD_(HRESULT,SetSelectedForRestore)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bSelectedForRestore) PURE;
    STDMETHOD_(HRESULT,SetRestoreOptions)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszRestoreOptions) PURE;
    STDMETHOD_(HRESULT,SetAdditionalRestores)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bAdditionalResources) PURE;
    STDMETHOD_(HRESULT,SetPreviousBackupStamp)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPreviousBackupStamp) PURE;
    STDMETHOD_(HRESULT,SaveAsXML)(THIS_ BSTR *pbstrXML) PURE;
    STDMETHOD_(HRESULT,BackupComplete)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,AddAlternativeLocationMapping)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive,LPCWSTR wszDestination) PURE;
    STDMETHOD_(HRESULT,AddRestoreSubcomponent)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszSubComponentLogicalPath,LPCWSTR wszSubComponentName,BOOLEAN bRepair) PURE;
    STDMETHOD_(HRESULT,SetFileRestoreStatus)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,VSS_FILE_RESTORE_STATUS status) PURE;
    STDMETHOD_(HRESULT,AddNewTarget)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPath,LPCWSTR wszFileName,BOOLEAN bRecursive,LPCWSTR wszAlternatePath) PURE;
    STDMETHOD_(HRESULT,SetRangesFilePath)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,UINT iPartialFile,LPCWSTR wszRangesFile) PURE;
    STDMETHOD_(HRESULT,PreRestore)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,PostRestore)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,SetContext)(THIS_ LONG lContext) PURE;
    STDMETHOD_(HRESULT,StartSnapshotSet)(THIS_ VSS_ID *pSnapshotSetId) PURE;
    STDMETHOD_(HRESULT,AddToSnapshotSet)(THIS_ VSS_PWSZ pwszVolumeName,VSS_ID ProviderId,VSS_ID *pidSnapshot) PURE;
    STDMETHOD_(HRESULT,DoSnapshotSet)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,DeleteSnapshots)(THIS_ VSS_ID SourceObjectId,VSS_OBJECT_TYPE eSourceObjectType,BOOLEAN bForceDelete,LONG *plDeletedSnapshots,VSS_ID *pNondeletedSnapshotID) PURE;
    STDMETHOD_(HRESULT,ImportSnapshots)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,BreakSnapshotSet)(THIS_ VSS_ID SnapshotSetId) PURE;
    STDMETHOD_(HRESULT,GetSnapshotProperties)(THIS_ VSS_ID SnapshotId,VSS_SNAPSHOT_PROP *pProp) PURE;
    STDMETHOD_(HRESULT,Query)(THIS_ VSS_ID QueriedObjectId,VSS_OBJECT_TYPE eQueriedObjectType,VSS_OBJECT_TYPE eReturnedObjectsType,IVssEnumObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,IsVolumeSupported)(THIS_ VSS_ID ProviderId,VSS_PWSZ pwszVolumeName,BOOLEAN *pbSupportedByThisProvider) PURE;
    STDMETHOD_(HRESULT,DisableWriterClasses)(THIS_ const VSS_ID *rgWriterClassId,UINT cClassId) PURE;
    STDMETHOD_(HRESULT,EnableWriterClasses)(THIS_ const VSS_ID *rgWriterClassId,UINT cClassId) PURE;
    STDMETHOD_(HRESULT,DisableWriterInstances)(THIS_ const VSS_ID *rgWriterInstanceId,UINT cInstanceId) PURE;
    STDMETHOD_(HRESULT,ExposeSnapshot)(THIS_ VSS_ID SnapshotId,VSS_PWSZ wszPathFromRoot,LONG lAttributes,VSS_PWSZ wszExpose,VSS_PWSZ *pwszExposed) PURE;
    STDMETHOD_(HRESULT,RevertToSnapshot)(THIS_ VSS_ID SnapshotId,BOOLEAN bForceDismount) PURE;
    STDMETHOD_(HRESULT,QueryRevertStatus)(THIS_ VSS_PWSZ pwszVolume,IVssAsync **ppAsync) PURE;

    /* IVssBackupComponentsEx methods */
    STDMETHOD_(HRESULT,GetWriterMetadataEx)(THIS_ UINT iWriter,VSS_ID *pidInstance,IVssExamineWriterMetadataEx **ppMetadata) PURE;
    STDMETHOD_(HRESULT,SetSelectedForRestoreEx)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bSelectedForRestore,VSS_ID instanceId) PURE;

    /* IVssBackupComponentsEx2 methods */
    STDMETHOD_(HRESULT,UnexposeSnapshot)(THIS_ VSS_ID snapshotId) PURE;
    STDMETHOD_(HRESULT,SetAuthoritativeRestore)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bAuth) PURE;
    STDMETHOD_(HRESULT,SetRollForward)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,VSS_ROLLFORWARD_TYPE rollType,LPCWSTR wszRollForwardPoint) PURE;
    STDMETHOD_(HRESULT,SetRestoreName)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszRestoreName) PURE;
    STDMETHOD_(HRESULT,BreakSnapshotSetEx)(THIS_ VSS_ID SnapshotSetID,DWORD dwBreakFlags,IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,PreFastRecovery)(THIS) PURE; /*Unsupported*/
    STDMETHOD_(HRESULT,FastRecovery)(THIS) PURE;    /*Unsupported*/

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssBackupComponentsEx2_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssBackupComponentsEx2_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssBackupComponentsEx2_Release(This) (This)->lpVtbl->Release(This)
#define IVssBackupComponentsEx2_GetWriterComponentsCount(This,pcComponents) (This)->lpVtbl->GetWriterComponentsCount(This,pcComponents)
#define IVssBackupComponentsEx2_GetWriterComponents(This,iWriter,pWriterComponents) (This)->lpVtbl->GetWriterComponents(This,iWriter,pWriterComponents)
#define IVssBackupComponentsEx2_InitializeForBackup(This,bstrXML) (This)->lpVtbl->InitializeForBackup(This,bstrXML)
#define IVssBackupComponentsEx2_SetBackupState(This,bSelectComponents,bBackupBootableSystemState,backupType,bPartialFileSupport) (This)->lpVtbl->SetBackupState(This,bSelectComponents,bBackupBootableSystemState,backupType,bPartialFileSupport)
#define IVssBackupComponentsEx2_InitializeForRestore(This,bstrXML) (This)->lpVtbl->InitializeForRestore(This,bstrXML)
#define IVssBackupComponentsEx2_SetRestoreState(This,restoreType) (This)->lpVtbl->SetRestoreState(This,restoreType)
#define IVssBackupComponentsEx2_GatherWriterMetadata(This,ppAsync) (This)->lpVtbl->GatherWriterMetadata(This,ppAsync)
#define IVssBackupComponentsEx2_GetWriterMetadataCount(This,pcWriters) (This)->lpVtbl->GetWriterMetadataCount(This,pcWriters)
#define IVssBackupComponentsEx2_GetWriterMetadata(This,iWriter,pidWriterInstance,ppMetadata) (This)->lpVtbl->GetWriterMetadata(This,iWriter,pidWriterInstance,ppMetadata)
#define IVssBackupComponentsEx2_FreeWriterMetadata() (This)->lpVtbl->FreeWriterMetadata(This)
#define IVssBackupComponentsEx2_AddComponent(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName) (This)->lpVtbl->AddComponent(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName)
#define IVssBackupComponentsEx2_PrepareForBackup(This,ppAsync) (This)->lpVtbl->PrepareForBackup(This,ppAsync)
#define IVssBackupComponentsEx2_AbortBackup() (This)->lpVtbl->AbortBackup(This)
#define IVssBackupComponentsEx2_GatherWriterStatus(This,ppAsync) (This)->lpVtbl->GatherWriterStatus(This,ppAsync)
#define IVssBackupComponentsEx2_GetWriterStatusCount(This,pcWriters) (This)->lpVtbl->GetWriterStatusCount(This,pcWriters)
#define IVssBackupComponentsEx2_FreeWriterStatus() (This)->lpVtbl->FreeWriterStatus(This)
#define IVssBackupComponentsEx2_GetWriterStatus(This,iWriter,pidInstance,pidWriter,pbstrWriter,pState,pHrResultFailure) (This)->lpVtbl->GetWriterStatus(This,iWriter,pidInstance,pidWriter,pbstrWriter,pState,pHrResultFailure)
#define IVssBackupComponentsEx2_SetBackupSucceeded(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName,bSucceeded) (This)->lpVtbl->SetBackupSucceeded(This,instanceId,writerId,componentType,wszLogicalPath,wszComponentName,bSucceeded)
#define IVssBackupComponentsEx2_SetBackupOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszBackupOptions) (This)->lpVtbl->SetBackupOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszBackupOptions)
#define IVssBackupComponentsEx2_SetSelectedForRestore(This,writerId,componentType,wszLogicalPath,wszComponentName,bSelectedForRestore) (This)->lpVtbl->SetSelectedForRestore(This,writerId,componentType,wszLogicalPath,wszComponentName,bSelectedForRestore)
#define IVssBackupComponentsEx2_SetRestoreOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszRestoreOptions) (This)->lpVtbl->SetRestoreOptions(This,writerId,componentType,wszLogicalPath,wszComponentName,wszRestoreOptions)
#define IVssBackupComponentsEx2_SetAdditionalRestores(This,writerId,componentType,wszLogicalPath,wszComponentName,bAdditionalResources) (This)->lpVtbl->SetAdditionalRestores(This,writerId,componentType,wszLogicalPath,wszComponentName,bAdditionalResources)
#define IVssBackupComponentsEx2_SetPreviousBackupStamp(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPreviousBackupStamp) (This)->lpVtbl->SetPreviousBackupStamp(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPreviousBackupStamp)
#define IVssBackupComponentsEx2_SaveAsXML(This,pbstrXML) (This)->lpVtbl->SaveAsXML(This,pbstrXML)
#define IVssBackupComponentsEx2_BackupComplete(This,ppAsync) (This)->lpVtbl->BackupComplete(This,ppAsync)
#define IVssBackupComponentsEx2_AddAlternativeLocationMapping(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPath,wszFilespec,bRecursive,wszDestination) (This)->lpVtbl->AddAlternativeLocationMapping(This,writerId,componentType,wszLogicalPath,wszComponentName,wszPath,wszFilespec,bRecursive,wszDestination)
#define IVssBackupComponentsEx2_AddRestoreSubcomponent(This,writerId,componentType,wszLogicalPath,wszComponentName,wszSubComponentLogicalPath,wszSubComponentName,bRepair) (This)->lpVtbl->AddRestoreSubcomponent(This,writerId,componentType,wszLogicalPath,wszComponentName,wszSubComponentLogicalPath,wszSubComponentName,bRepair)
#define IVssBackupComponentsEx2_SetFileRestoreStatus(This,writerId,componentType,wszLogicalPath,wszComponentName,status) (This)->lpVtbl->SetFileRestoreStatus(This,writerId,componentType,wszLogicalPath,wszComponentName,status)
#define IVssBackupComponentsEx2_AddNewTarget(This,writerId,ct,wszLogicalPath,wszComponentName,wszPath,wszFileName,bRecursive,wszAlternatePath) (This)->lpVtbl->AddNewTarget(This,writerId,ct,wszLogicalPath,wszComponentName,wszPath,wszFileName,bRecursive,wszAlternatePath)
#define IVssBackupComponentsEx2_SetRangesFilePath(This,writerId,ct,wszLogicalPath,wszComponentName,iPartialFile,wszRangesFile) (This)->lpVtbl->SetRangesFilePath(This,writerId,ct,wszLogicalPath,wszComponentName,iPartialFile,wszRangesFile)
#define IVssBackupComponentsEx2_PreRestore(This,ppAsync) (This)->lpVtbl->PreRestore(This,ppAsync)
#define IVssBackupComponentsEx2_PostRestore(This,ppAsync) (This)->lpVtbl->PostRestore(This,ppAsync)
#define IVssBackupComponentsEx2_SetContext(This,lContext) (This)->lpVtbl->SetContext(This,lContext)
#define IVssBackupComponentsEx2_StartSnapshotSet(This,pSnapshotSetId) (This)->lpVtbl->StartSnapshotSet(This,pSnapshotSetId)
#define IVssBackupComponentsEx2_AddToSnapshotSet(This,pwszVolumeName,ProviderId,pidSnapshot) (This)->lpVtbl->AddToSnapshotSet(This,pwszVolumeName,ProviderId,pidSnapshot)
#define IVssBackupComponentsEx2_DoSnapshotSet(This,ppAsync) (This)->lpVtbl->DoSnapshotSet(This,ppAsync)
#define IVssBackupComponentsEx2_DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID) (This)->lpVtbl->DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID)
#define IVssBackupComponentsEx2_ImportSnapshots(This,ppAsync) (This)->lpVtbl->ImportSnapshots(This,ppAsync)
#define IVssBackupComponentsEx2_BreakSnapshotSet(This,SnapshotSetId) (This)->lpVtbl->BreakSnapshotSet(This,SnapshotSetId)
#define IVssBackupComponentsEx2_GetSnapshotProperties(This,SnapshotId,pProp) (This)->lpVtbl->GetSnapshotProperties(This,SnapshotId,pProp)
#define IVssBackupComponentsEx2_Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum) (This)->lpVtbl->Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum)
#define IVssBackupComponentsEx2_IsVolumeSupported(This,ProviderId,pwszVolumeName,pbSupportedByThisProvider) (This)->lpVtbl->IsVolumeSupported(This,ProviderId,pwszVolumeName,pbSupportedByThisProvider)
#define IVssBackupComponentsEx2_DisableWriterClasses(This,rgWriterClassId,cClassId) (This)->lpVtbl->DisableWriterClasses(This,rgWriterClassId,cClassId)
#define IVssBackupComponentsEx2_EnableWriterClasses(This,rgWriterClassId,cClassId) (This)->lpVtbl->EnableWriterClasses(This,rgWriterClassId,cClassId)
#define IVssBackupComponentsEx2_DisableWriterInstances(This,rgWriterInstanceId,cInstanceId) (This)->lpVtbl->DisableWriterInstances(This,rgWriterInstanceId,cInstanceId)
#define IVssBackupComponentsEx2_ExposeSnapshot(This,SnapshotId,wszPathFromRoot,lAttributes,wszExpose,pwszExposed) (This)->lpVtbl->ExposeSnapshot(This,SnapshotId,wszPathFromRoot,lAttributes,wszExpose,pwszExposed)
#define IVssBackupComponentsEx2_RevertToSnapshot(This,SnapshotId,bForceDismount) (This)->lpVtbl->RevertToSnapshot(This,SnapshotId,bForceDismount)
#define IVssBackupComponentsEx2_QueryRevertStatus(This,pwszVolume,ppAsync) (This)->lpVtbl->QueryRevertStatus(This,pwszVolume,ppAsync)
#define IVssBackupComponentsEx2_GetWriterMetadataEx(This,iWriter,pidInstance,ppMetadata) (This)->lpVtbl->GetWriterMetadataEx(This,iWriter,pidInstance,ppMetadata)
#define IVssBackupComponentsEx2_SetSelectedForRestoreEx(This,writerId,ct,wszLogicalPath,wszComponentName,bSelectedForRestore,instanceId) (This)->lpVtbl->SetSelectedForRestoreEx(This,writerId,ct,wszLogicalPath,wszComponentName,bSelectedForRestore,instanceId)
#define IVssBackupComponentsEx2_UnexposeSnapshot(This,snapshotId) (This)->lpVtbl->UnexposeSnapshot(This,snapshotId)
#define IVssBackupComponentsEx2_SetAuthoritativeRestore(This,writerId,ct,wszLogicalPath,wszComponentName,bAuth) (This)->lpVtbl->SetAuthoritativeRestore(This,writerId,ct,wszLogicalPath,wszComponentName,bAuth)
#define IVssBackupComponentsEx2_SetRollForward(This,writerId,ct,wszLogicalPath,wszComponentName,rollType,wszRollForwardPoint) (This)->lpVtbl->SetRollForward(This,writerId,ct,wszLogicalPath,wszComponentName,rollType,wszRollForwardPoint)
#define IVssBackupComponentsEx2_SetRestoreName(This,writerId,ct,wszLogicalPath,wszComponentName,wszRestoreName) (This)->lpVtbl->SetRestoreName(This,writerId,ct,wszLogicalPath,wszComponentName,wszRestoreName)
#define IVssBackupComponentsEx2_BreakSnapshotSetEx(This,SnapshotSetID,dwBreakFlags,ppAsync) (This)->lpVtbl->BreakSnapshotSetEx(This,SnapshotSetID,dwBreakFlags,ppAsync)
#define IVssBackupComponentsEx2_PreFastRecovery() (This)->lpVtbl->PreFastRecovery(This)
#define IVssBackupComponentsEx2_FastRecovery() (This)->lpVtbl->FastRecovery(This)
#endif /*COBJMACROS*/
#endif /*(_WIN32_WINNT >= 0x0600)*/

#if (_WIN32_WINNT >= 0x0601)
#undef  INTERFACE
#define INTERFACE IVssBackupComponentsEx3
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssBackupComponentsEx3,IVssBackupComponentsEx2)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssBackupComponents methods */
    STDMETHOD_(HRESULT,GetWriterComponentsCount)(THIS_ UINT *pcComponents) PURE;
    STDMETHOD_(HRESULT,GetWriterComponents)(THIS_ UINT iWriter,IVssWriterComponentsExt **pWriterComponents) PURE;
    STDMETHOD_(HRESULT,InitializeForBackup)(THIS_ BSTR bstrXML) PURE;
    STDMETHOD_(HRESULT,SetBackupState)(THIS_ BOOLEAN bSelectComponents,BOOLEAN bBackupBootableSystemState,VSS_BACKUP_TYPE backupType,BOOLEAN bPartialFileSupport) PURE;
    STDMETHOD_(HRESULT,InitializeForRestore)(THIS_ BSTR bstrXML) PURE;
    STDMETHOD_(HRESULT,SetRestoreState)(THIS_ VSS_RESTORE_TYPE restoreType) PURE;
    STDMETHOD_(HRESULT,GatherWriterMetadata)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,GetWriterMetadataCount)(THIS_ UINT *pcWriters) PURE;
    STDMETHOD_(HRESULT,GetWriterMetadata)(THIS_ UINT iWriter,VSS_ID *pidWriterInstance,IVssExamineWriterMetadata **ppMetadata) PURE;
    STDMETHOD_(HRESULT,FreeWriterMetadata)(THIS) PURE;
    STDMETHOD_(HRESULT,AddComponent)(THIS_ VSS_ID instanceId,VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName) PURE;
    STDMETHOD_(HRESULT,PrepareForBackup)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,AbortBackup)(THIS) PURE;
    STDMETHOD_(HRESULT,GatherWriterStatus)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,GetWriterStatusCount)(THIS_ UINT *pcWriters) PURE;
    STDMETHOD_(HRESULT,FreeWriterStatus)(THIS) PURE;
    STDMETHOD_(HRESULT,GetWriterStatus)(THIS_ UINT iWriter,VSS_ID *pidInstance,VSS_ID *pidWriter,BSTR *pbstrWriter,VSS_WRITER_STATE *pState,HRESULT *pHrResultFailure) PURE;
    STDMETHOD_(HRESULT,SetBackupSucceeded)(THIS_ VSS_ID instanceId,VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bSucceeded) PURE;
    STDMETHOD_(HRESULT,SetBackupOptions)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszBackupOptions) PURE;
    STDMETHOD_(HRESULT,SetSelectedForRestore)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bSelectedForRestore) PURE;
    STDMETHOD_(HRESULT,SetRestoreOptions)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszRestoreOptions) PURE;
    STDMETHOD_(HRESULT,SetAdditionalRestores)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bAdditionalResources) PURE;
    STDMETHOD_(HRESULT,SetPreviousBackupStamp)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPreviousBackupStamp) PURE;
    STDMETHOD_(HRESULT,SaveAsXML)(THIS_ BSTR *pbstrXML) PURE;
    STDMETHOD_(HRESULT,BackupComplete)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,AddAlternativeLocationMapping)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive,LPCWSTR wszDestination) PURE;
    STDMETHOD_(HRESULT,AddRestoreSubcomponent)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszSubComponentLogicalPath,LPCWSTR wszSubComponentName,BOOLEAN bRepair) PURE;
    STDMETHOD_(HRESULT,SetFileRestoreStatus)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,VSS_FILE_RESTORE_STATUS status) PURE;
    STDMETHOD_(HRESULT,AddNewTarget)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszPath,LPCWSTR wszFileName,BOOLEAN bRecursive,LPCWSTR wszAlternatePath) PURE;
    STDMETHOD_(HRESULT,SetRangesFilePath)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,UINT iPartialFile,LPCWSTR wszRangesFile) PURE;
    STDMETHOD_(HRESULT,PreRestore)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,PostRestore)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,SetContext)(THIS_ LONG lContext) PURE;
    STDMETHOD_(HRESULT,StartSnapshotSet)(THIS_ VSS_ID *pSnapshotSetId) PURE;
    STDMETHOD_(HRESULT,AddToSnapshotSet)(THIS_ VSS_PWSZ pwszVolumeName,VSS_ID ProviderId,VSS_ID *pidSnapshot) PURE;
    STDMETHOD_(HRESULT,DoSnapshotSet)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,DeleteSnapshots)(THIS_ VSS_ID SourceObjectId,VSS_OBJECT_TYPE eSourceObjectType,BOOLEAN bForceDelete,LONG *plDeletedSnapshots,VSS_ID *pNondeletedSnapshotID) PURE;
    STDMETHOD_(HRESULT,ImportSnapshots)(THIS_ IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,BreakSnapshotSet)(THIS_ VSS_ID SnapshotSetId) PURE;
    STDMETHOD_(HRESULT,GetSnapshotProperties)(THIS_ VSS_ID SnapshotId,VSS_SNAPSHOT_PROP *pProp) PURE;
    STDMETHOD_(HRESULT,Query)(THIS_ VSS_ID QueriedObjectId,VSS_OBJECT_TYPE eQueriedObjectType,VSS_OBJECT_TYPE eReturnedObjectsType,IVssEnumObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,IsVolumeSupported)(THIS_ VSS_ID ProviderId,VSS_PWSZ pwszVolumeName,BOOLEAN *pbSupportedByThisProvider) PURE;
    STDMETHOD_(HRESULT,DisableWriterClasses)(THIS_ const VSS_ID *rgWriterClassId,UINT cClassId) PURE;
    STDMETHOD_(HRESULT,EnableWriterClasses)(THIS_ const VSS_ID *rgWriterClassId,UINT cClassId) PURE;
    STDMETHOD_(HRESULT,DisableWriterInstances)(THIS_ const VSS_ID *rgWriterInstanceId,UINT cInstanceId) PURE;
    STDMETHOD_(HRESULT,ExposeSnapshot)(THIS_ VSS_ID SnapshotId,VSS_PWSZ wszPathFromRoot,LONG lAttributes,VSS_PWSZ wszExpose,VSS_PWSZ *pwszExposed) PURE;
    STDMETHOD_(HRESULT,RevertToSnapshot)(THIS_ VSS_ID SnapshotId,BOOLEAN bForceDismount) PURE;
    STDMETHOD_(HRESULT,QueryRevertStatus)(THIS_ VSS_PWSZ pwszVolume,IVssAsync **ppAsync) PURE;

    /* IVssBackupComponentsEx methods */
    STDMETHOD_(HRESULT,GetWriterMetadataEx)(THIS_ UINT iWriter,VSS_ID *pidInstance,IVssExamineWriterMetadataEx **ppMetadata) PURE;
    STDMETHOD_(HRESULT,SetSelectedForRestoreEx)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bSelectedForRestore,VSS_ID instanceId) PURE;

    /* IVssBackupComponentsEx2 methods */
    STDMETHOD_(HRESULT,UnexposeSnapshot)(THIS_ VSS_ID snapshotId) PURE;
    STDMETHOD_(HRESULT,SetAuthoritativeRestore)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,BOOLEAN bAuth) PURE;
    STDMETHOD_(HRESULT,SetRollForward)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,VSS_ROLLFORWARD_TYPE rollType,LPCWSTR wszRollForwardPoint) PURE;
    STDMETHOD_(HRESULT,SetRestoreName)(THIS_ VSS_ID writerId,VSS_COMPONENT_TYPE ct,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszRestoreName) PURE;
    STDMETHOD_(HRESULT,BreakSnapshotSetEx)(THIS_ VSS_ID SnapshotSetID,DWORD dwBreakFlags,IVssAsync **ppAsync) PURE;
    STDMETHOD_(HRESULT,PreFastRecovery)(THIS) PURE; /*Unsupported*/
    STDMETHOD_(HRESULT,FastRecovery)(THIS) PURE;    /*Unsupported*/

    /* IVssBackupComponentsEx3 methods */
    STDMETHOD_(HRESULT,AddSnapshotToRecoverySet)(THIS_ VSS_ID snapshotId,DWORD dwFlags,VSS_PWSZ pwszDestinationVolume) PURE;
    STDMETHOD_(HRESULT,GetSessionId)(THIS_ VSS_ID *idSession) PURE;
    STDMETHOD_(HRESULT,GetWriterStatusEx)(THIS_ UINT iWriter,VSS_ID *pidInstance,VSS_ID *pidWriter,BSTR *pbstrWriter,VSS_WRITER_STATE *pnStatus,HRESULT *phrFailureWriter,BSTR *pbstrApplicationMessage) PURE;
    STDMETHOD_(HRESULT,RecoverSet)(THIS_ DWORD dwFlags,IVssAsync **ppAsync) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssBackupComponentsEx3_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssBackupComponentsEx3_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssBackupComponentsEx3_Release(This) (This)->lpVtbl->Release(This)
#define IVssBackupComponentsEx3_AddSnapshotToRecoverySet(This,snapshotId,dwFlags,pwszDestinationVolume) (This)->lpVtbl->AddSnapshotToRecoverySet(This,snapshotId,dwFlags,pwszDestinationVolume)
#define IVssBackupComponentsEx3_GetSessionId(This,idSession) (This)->lpVtbl->GetSessionId(This,idSession)
#define IVssBackupComponentsEx3_GetWriterStatusEx(This,iWriter,pidInstance,pidWriter,pbstrWriter,pnStatus,phrFailureWriter,pbstrApplicationMessage) (This)->lpVtbl->GetWriterStatusEx(This,iWriter,pidInstance,pidWriter,pbstrWriter,pnStatus,phrFailureWriter,pbstrApplicationMessage)
#define IVssBackupComponentsEx3_RecoverSet(This,dwFlags,ppAsync) (This)->lpVtbl->RecoverSet(This,dwFlags,ppAsync)
#endif /*COBJMACROS*/
#endif /*(_WIN32_WINNT >= 0x0601)*/

#ifdef __cplusplus
/* Is a C++ interface instead of a COM */
#undef  INTERFACE
#define INTERFACE IVssExamineWriterMetadata
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssExamineWriterMetadata,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssExamineWriterMetadata methods */
    STDMETHOD_(HRESULT,GetIdentity)(THIS_ VSS_ID *pidInstance,VSS_ID *pidWriter,BSTR *pbstrWriterName,VSS_USAGE_TYPE *pUsage,VSS_SOURCE_TYPE *pSource) PURE;
    STDMETHOD_(HRESULT,GetFileCounts)(THIS_ UINT *pcIncludeFiles,UINT *pcExcludeFiles,UINT *pcComponents) PURE;
    STDMETHOD_(HRESULT,GetIncludeFile)(THIS) PURE;
    STDMETHOD_(HRESULT,GetExcludeFile)(THIS_ UINT iFile,IVssWMFiledesc **ppFiledesc) PURE;
    STDMETHOD_(HRESULT,GetComponent)(THIS_ UINT iComponent,IVssWMComponent **ppComponent) PURE;
    STDMETHOD_(HRESULT,GetRestoreMethod)(THIS_ VSS_RESTOREMETHOD_ENUM *pMethod,BSTR *pbstrService,BSTR *pbstrUserProcedure,VSS_WRITERRESTORE_ENUM *pwreWriterRestore,BOOLEAN *pbRebootRequired,UINT *piMappings) PURE;
    STDMETHOD_(HRESULT,GetAlternateLocationMapping)(THIS_ UINT iMapping,IVssWMFiledesc **ppMapping) PURE;
    STDMETHOD_(HRESULT,GetBackupSchema)(THIS_ DWORD *pdsSchemaMask) PURE;
    STDMETHOD_(HRESULT,GetDocument)(THIS) PURE;
    STDMETHOD_(HRESULT,SaveAsXML)(THIS_ BSTR *pbstrXML) PURE;
    STDMETHOD_(HRESULT,LoadFromXML)(THIS_ BSTR bstrXML) PURE;

    END_INTERFACE
};

#if (_WIN32_WINNT >= 0x0600)
#undef  INTERFACE
#define INTERFACE IVssExamineWriterMetadataEx
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssExamineWriterMetadataEx,IVssExamineWriterMetadata)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssExamineWriterMetadata methods */
    STDMETHOD_(HRESULT,GetIdentity)(THIS_ VSS_ID *pidInstance,VSS_ID *pidWriter,BSTR *pbstrWriterName,VSS_USAGE_TYPE *pUsage,VSS_SOURCE_TYPE *pSource) PURE;
    STDMETHOD_(HRESULT,GetFileCounts)(THIS_ UINT *pcIncludeFiles,UINT *pcExcludeFiles,UINT *pcComponents) PURE;
    STDMETHOD_(HRESULT,GetIncludeFile)(THIS) PURE;
    STDMETHOD_(HRESULT,GetExcludeFile)(THIS_ UINT iFile,IVssWMFiledesc **ppFiledesc) PURE;
    STDMETHOD_(HRESULT,GetComponent)(THIS_ UINT iComponent,IVssWMComponent **ppComponent) PURE;
    STDMETHOD_(HRESULT,GetRestoreMethod)(THIS_ VSS_RESTOREMETHOD_ENUM *pMethod,BSTR *pbstrService,BSTR *pbstrUserProcedure,VSS_WRITERRESTORE_ENUM *pwreWriterRestore,BOOLEAN *pbRebootRequired,UINT *piMappings) PURE;
    STDMETHOD_(HRESULT,GetAlternateLocationMapping)(THIS_ UINT iMapping,IVssWMFiledesc **ppMapping) PURE;
    STDMETHOD_(HRESULT,GetBackupSchema)(THIS_ DWORD *pdsSchemaMask) PURE;
    STDMETHOD_(HRESULT,GetDocument)(THIS) PURE;
    STDMETHOD_(HRESULT,SaveAsXML)(THIS_ BSTR *pbstrXML) PURE;
    STDMETHOD_(HRESULT,LoadFromXML)(THIS_ BSTR bstrXML) PURE;

    /* IVssExamineWriterMetadataEx methods */
    STDMETHOD_(HRESULT,GetIdentityEx)(THIS_ VSS_ID *pidInstance,VSS_ID *pidWriter,BSTR *pbstrWriterName,BSTR *pbstrInstanceName,VSS_USAGE_TYPE *pUsage,VSS_SOURCE_TYPE *pSource) PURE;

    END_INTERFACE
};

#undef  INTERFACE
#define INTERFACE IVssExamineWriterMetadataEx2
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssExamineWriterMetadataEx2,IVssExamineWriterMetadataEx)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

/* IVssExamineWriterMetadata methods */
    STDMETHOD_(HRESULT,GetIdentity)(THIS_ VSS_ID *pidInstance,VSS_ID *pidWriter,BSTR *pbstrWriterName,VSS_USAGE_TYPE *pUsage,VSS_SOURCE_TYPE *pSource) PURE;
    STDMETHOD_(HRESULT,GetFileCounts)(THIS_ UINT *pcIncludeFiles,UINT *pcExcludeFiles,UINT *pcComponents) PURE;
    STDMETHOD_(HRESULT,GetIncludeFile)(THIS) PURE;
    STDMETHOD_(HRESULT,GetExcludeFile)(THIS_ UINT iFile,IVssWMFiledesc **ppFiledesc) PURE;
    STDMETHOD_(HRESULT,GetComponent)(THIS_ UINT iComponent,IVssWMComponent **ppComponent) PURE;
    STDMETHOD_(HRESULT,GetRestoreMethod)(THIS_ VSS_RESTOREMETHOD_ENUM *pMethod,BSTR *pbstrService,BSTR *pbstrUserProcedure,VSS_WRITERRESTORE_ENUM *pwreWriterRestore,BOOLEAN *pbRebootRequired,UINT *piMappings) PURE;
    STDMETHOD_(HRESULT,GetAlternateLocationMapping)(THIS_ UINT iMapping,IVssWMFiledesc **ppMapping) PURE;
    STDMETHOD_(HRESULT,GetBackupSchema)(THIS_ DWORD *pdsSchemaMask) PURE;
    STDMETHOD_(HRESULT,GetDocument)(THIS) PURE;
    STDMETHOD_(HRESULT,SaveAsXML)(THIS_ BSTR *pbstrXML) PURE;
    STDMETHOD_(HRESULT,LoadFromXML)(THIS_ BSTR bstrXML) PURE;

    /* IVssExamineWriterMetadataEx methods */
    STDMETHOD_(HRESULT,GetIdentityEx)(THIS_ VSS_ID *pidInstance,VSS_ID *pidWriter,BSTR *pbstrWriterName,BSTR *pbstrInstanceName,VSS_USAGE_TYPE *pUsage,VSS_SOURCE_TYPE *pSource) PURE;

    /* IVssExamineWriterMetadataEx2 methods */
    STDMETHOD_(HRESULT,GetVersion)(THIS_ DWORD *pdwMajorVersion,DWORD *pdwMinorVersion) PURE;
    STDMETHOD_(HRESULT,GetExcludeFromSnapshotCount)(THIS_ UINT *pcExcludedFromSnapshot) PURE;
    STDMETHOD_(HRESULT,GetExcludeFromSnapshotFile)(THIS_ UINT iFile,IVssWMFiledesc **ppFiledesc) PURE;

    END_INTERFACE
};

#endif /*(_WIN32_WINNT >= 0x0600)*/

#undef  INTERFACE
#define INTERFACE IVssWMComponent
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssWMComponent,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssWMComponent methods */
    STDMETHOD_(HRESULT,GetComponentInfo)(THIS_ PVSSCOMPONENTINFO *ppInfo) PURE;
    STDMETHOD_(HRESULT,FreeComponentInfo)(THIS_ VSS_COMPONENTINFO *pInfo) PURE;
    STDMETHOD_(HRESULT,GetFile)(THIS_ UINT iFile,IVssWMFiledesc **ppFiledesc) PURE;
    STDMETHOD_(HRESULT,GetDatabaseFile)(THIS_ UINT iFile,IVssWMFiledesc **ppFiledesc) PURE;
    STDMETHOD_(HRESULT,GetDatabaseLogFile)(THIS_ UINT iFile,IVssWMFiledesc **ppFiledesc) PURE;
    STDMETHOD_(HRESULT,GetDependency)(THIS_ UINT iDependency,IVssWMDependency **ppDependency) PURE;

    END_INTERFACE
};

#undef  INTERFACE
#define INTERFACE IVssWriterComponentsExt
DECLARE_INTERFACE_(IVssWriterComponentsExt,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssWriterComponentsExt methods */
    /* No additional members */

    END_INTERFACE
};

#endif /*__cplusplus*/
#endif /*_INC_VSBACKUP*/
                                                                            usr/share/mingw-w64/include/vsmgmt.h                                                                0100644 0000000 0000000 00000047337 12404413016 016041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_VSMGT
#define _INC_VSMGT

#include <vss.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _VSS_PROTECTION_FAULT {
  VSS_PROTECTION_FAULT_NONE                           = 0,
  VSS_PROTECTION_FAULT_DIFF_AREA_MISSING              = ( VSS_PROTECTION_FAULT_NONE + 1 ),
  VSS_PROTECTION_FAULT_IO_FAILURE_DURING_ONLINE       = ( VSS_PROTECTION_FAULT_DIFF_AREA_MISSING + 1 ),
  VSS_PROTECTION_FAULT_META_DATA_CORRUPTION           = ( VSS_PROTECTION_FAULT_IO_FAILURE_DURING_ONLINE + 1 ),
  VSS_PROTECTION_FAULT_MEMORY_ALLOCATION_FAILURE      = ( VSS_PROTECTION_FAULT_META_DATA_CORRUPTION + 1 ),
  VSS_PROTECTION_FAULT_MAPPED_MEMORY_FAILURE          = ( VSS_PROTECTION_FAULT_MEMORY_ALLOCATION_FAILURE + 1 ),
  VSS_PROTECTION_FAULT_COW_READ_FAILURE               = ( VSS_PROTECTION_FAULT_MAPPED_MEMORY_FAILURE + 1 ),
  VSS_PROTECTION_FAULT_COW_WRITE_FAILURE              = ( VSS_PROTECTION_FAULT_COW_READ_FAILURE + 1 ),
  VSS_PROTECTION_FAULT_DIFF_AREA_FULL                 = ( VSS_PROTECTION_FAULT_COW_WRITE_FAILURE + 1 ),
  VSS_PROTECTION_FAULT_GROW_TOO_SLOW                  = ( VSS_PROTECTION_FAULT_DIFF_AREA_FULL + 1 ),
  VSS_PROTECTION_FAULT_GROW_FAILED                    = ( VSS_PROTECTION_FAULT_GROW_TOO_SLOW + 1 ),
  VSS_PROTECTION_FAULT_DESTROY_ALL_SNAPSHOTS          = ( VSS_PROTECTION_FAULT_GROW_FAILED + 1 ),
  VSS_PROTECTION_FAULT_FILE_SYSTEM_FAILURE            = ( VSS_PROTECTION_FAULT_DESTROY_ALL_SNAPSHOTS + 1 ),
  VSS_PROTECTION_FAULT_IO_FAILURE                     = ( VSS_PROTECTION_FAULT_FILE_SYSTEM_FAILURE + 1 ),
  VSS_PROTECTION_FAULT_DIFF_AREA_REMOVED              = ( VSS_PROTECTION_FAULT_IO_FAILURE + 1 ),
  VSS_PROTECTION_FAULT_EXTERNAL_WRITER_TO_DIFF_AREA   = ( VSS_PROTECTION_FAULT_DIFF_AREA_REMOVED + 1 ) 
} VSS_PROTECTION_FAULT;

typedef enum _VSS_PROTECTION_LEVEL {
  VSS_PROTECTION_LEVEL_ORIGINAL_VOLUME   = 0,
  VSS_PROTECTION_LEVEL_SNAPSHOT          = ( VSS_PROTECTION_LEVEL_ORIGINAL_VOLUME + 1 ) 
} VSS_PROTECTION_LEVEL;

typedef enum _VSS_MGMT_OBJECT_TYPE {
  VSS_MGMT_OBJECT_UNKNOWN       = 0,
  VSS_MGMT_OBJECT_VOLUME        = 1,
  VSS_MGMT_OBJECT_DIFF_VOLUME   = 2,
  VSS_MGMT_OBJECT_DIFF_AREA     = 3 
} VSS_MGMT_OBJECT_TYPE, *PVSS_MGMT_OBJECT_TYPE;

typedef struct _VSS_VOLUME_PROP {
  VSS_PWSZ m_pwszVolumeName;
  VSS_PWSZ m_pwszVolumeDisplayName;
} VSS_VOLUME_PROP, *PVSS_VOLUME_PROP;

typedef struct _VSS_VOLUME_PROTECTION_INFO {
  VSS_PROTECTION_LEVEL m_protectionLevel;
  WINBOOL              m_volumeIsOfflineForProtection;
  VSS_PROTECTION_FAULT m_protectionFault;
  LONG                 m_failureStatus;
  WINBOOL              m_volumeHasUnusedDiffArea;
  DWORD                m_reserved;
} VSS_VOLUME_PROTECTION_INFO;

#if (_WIN32_WINNT >= 0x0600)

typedef struct _VSS_DIFF_AREA_PROP {
  VSS_PWSZ m_pwszVolumeName;
  VSS_PWSZ m_pwszDiffAreaVolumeName;
  LONGLONG m_llMaximumDiffSpace;
  LONGLONG m_llAllocatedDiffSpace;
  LONGLONG m_llUsedDiffSpace;
} VSS_DIFF_AREA_PROP, *PVSS_DIFF_AREA_PROP;

typedef struct _VSS_DIFF_VOLUME_PROP {
  VSS_PWSZ m_pwszVolumeName;
  VSS_PWSZ m_pwszVolumeDisplayName;
  LONGLONG m_llVolumeFreeSpace;
  LONGLONG m_llVolumeTotalSpace;
} VSS_DIFF_VOLUME_PROP, *PVSS_DIFF_VOLUME_PROP;

typedef union _VSS_MGMT_OBJECT_UNION {
  VSS_VOLUME_PROP      Vol;
  VSS_DIFF_VOLUME_PROP DiffVol;
  VSS_DIFF_AREA_PROP   DiffArea;
} VSS_MGMT_OBJECT_UNION, *PVSS_MGMT_OBJECT_UNION;

typedef struct _VSS_MGMT_OBJECT_PROP {
  VSS_MGMT_OBJECT_TYPE  Type;
  VSS_MGMT_OBJECT_UNION Obj;
} VSS_MGMT_OBJECT_PROP, *PVSS_MGMT_OBJECT_PROP;

#endif /* (_WIN32_WINNT >= 0x0600) */

#ifdef __cplusplus
}
#endif

#undef  INTERFACE
#define INTERFACE IVssDifferentialSoftwareSnapshotMgmt
/*IID_IVssDifferentialSoftwareSnapshotMgmt is defined as 214A0F28-B737-4026-B847-4F9E37D79529*/
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssDifferentialSoftwareSnapshotMgmt,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssDifferentialSoftwareSnapshotMgmt methods */
    STDMETHOD_(HRESULT,AddDiffArea)(THIS_ VSS_PWSZ pwszVolumeName,VSS_PWSZ pwszDiffAreaVolumeName,LONGLONG llMaximumDiffSpace) PURE;
    STDMETHOD_(HRESULT,ChangeDiffAreaMaximumSize)(THIS_ VSS_PWSZ pwszVolumeName,VSS_PWSZ pwszDiffAreaVolumeName,LONGLONG llMaximumDiffSpace) PURE;
    STDMETHOD_(HRESULT,QueryVolumesSupportedForDiffAreas)(THIS_ VSS_PWSZ pwszOriginalVolumeName,IVssEnumMgmtObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,QueryDiffAreasForVolume)(THIS_ VSS_PWSZ pwszVolumeName,IVssEnumMgmtObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,QueryDiffAreasOnVolume)(THIS_ VSS_PWSZ pwszVolumeName,IVssEnumMgmtObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,QueryDiffAreasForSnapshot)(THIS_ VSS_ID SnapshotId,IVssEnumMgmtObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,Opmun08NotUsedOnWire)(THIS) PURE; /* Reserved */

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssDifferentialSoftwareSnapshotMgmt_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssDifferentialSoftwareSnapshotMgmt_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssDifferentialSoftwareSnapshotMgmt_Release(This) (This)->lpVtbl->Release(This)
#define IVssDifferentialSoftwareSnapshotMgmt_AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) (This)->lpVtbl->AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)
#define IVssDifferentialSoftwareSnapshotMgmt_ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) (This)->lpVtbl->ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)
#define IVssDifferentialSoftwareSnapshotMgmt_QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum) (This)->lpVtbl->QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum) (This)->lpVtbl->QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum) (This)->lpVtbl->QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum) (This)->lpVtbl->QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt_Opmun08NotUsedOnWire(This)
#endif /*COBJMACROS*/

#if (_WIN32_WINNT >= 0x0600)
#undef  INTERFACE
#define INTERFACE IVssDifferentialSoftwareSnapshotMgmt2
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssDifferentialSoftwareSnapshotMgmt2,IVssDifferentialSoftwareSnapshotMgmt)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssDifferentialSoftwareSnapshotMgmt methods */
    STDMETHOD_(HRESULT,AddDiffArea)(THIS_ VSS_PWSZ pwszVolumeName,VSS_PWSZ pwszDiffAreaVolumeName,LONGLONG llMaximumDiffSpace) PURE;
    STDMETHOD_(HRESULT,ChangeDiffAreaMaximumSize)(THIS_ VSS_PWSZ pwszVolumeName,VSS_PWSZ pwszDiffAreaVolumeName,LONGLONG llMaximumDiffSpace) PURE;
    STDMETHOD_(HRESULT,QueryVolumesSupportedForDiffAreas)(THIS_ VSS_PWSZ pwszOriginalVolumeName,IVssEnumMgmtObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,QueryDiffAreasForVolume)(THIS_ VSS_PWSZ pwszVolumeName,IVssEnumMgmtObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,QueryDiffAreasOnVolume)(THIS_ VSS_PWSZ pwszVolumeName,IVssEnumMgmtObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,QueryDiffAreasForSnapshot)(THIS_ VSS_ID SnapshotId,IVssEnumMgmtObject **ppEnum) PURE;

    /* IVssDifferentialSoftwareSnapshotMgmt2 methods */
    STDMETHOD_(HRESULT,ChangeDiffAreaMaximumSizeEx)(THIS_ VSS_PWSZ pwszVolumeName,VSS_PWSZ pwszDiffAreaVolumeName,LONGLONG llMaximumDiffSpace,WINBOOL bVolatile) PURE;
    STDMETHOD_(HRESULT,MigrateDiffAreas)(THIS) PURE;      /*Unsupported*/
    STDMETHOD_(HRESULT,QueryMigrationStatus)(THIS) PURE;  /*Unsupported*/
    STDMETHOD_(HRESULT,SetSnapshotPriority)(THIS) PURE;   /*Unsupported*/

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssDifferentialSoftwareSnapshotMgmt2_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssDifferentialSoftwareSnapshotMgmt2_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssDifferentialSoftwareSnapshotMgmt2_Release(This) (This)->lpVtbl->Release(This)
#define IVssDifferentialSoftwareSnapshotMgmt2_AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) (This)->lpVtbl->AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)
#define IVssDifferentialSoftwareSnapshotMgmt2_ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) (This)->lpVtbl->ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)
#define IVssDifferentialSoftwareSnapshotMgmt2_QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum) (This)->lpVtbl->QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt2_QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum) (This)->lpVtbl->QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt2_QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum) (This)->lpVtbl->QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt2_QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum) (This)->lpVtbl->QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt2_ChangeDiffAreaMaximumSizeEx(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace,bVolatile) (This)->lpVtbl->ChangeDiffAreaMaximumSizeEx(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace,bVolatile)
#define IVssDifferentialSoftwareSnapshotMgmt2_MigrateDiffAreas() (This)->lpVtbl->MigrateDiffAreas(This)
#define IVssDifferentialSoftwareSnapshotMgmt2_QueryMigrationStatus() (This)->lpVtbl->QueryMigrationStatus(This)
#define IVssDifferentialSoftwareSnapshotMgmt2_SetSnapshotPriority() (This)->lpVtbl->SetSnapshotPriority(This)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IVssDifferentialSoftwareSnapshotMgmt3
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssDifferentialSoftwareSnapshotMgmt3,IVssDifferentialSoftwareSnapshotMgmt2)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssDifferentialSoftwareSnapshotMgmt methods */
    STDMETHOD_(HRESULT,AddDiffArea)(THIS_ VSS_PWSZ pwszVolumeName,VSS_PWSZ pwszDiffAreaVolumeName,LONGLONG llMaximumDiffSpace) PURE;
    STDMETHOD_(HRESULT,ChangeDiffAreaMaximumSize)(THIS_ VSS_PWSZ pwszVolumeName,VSS_PWSZ pwszDiffAreaVolumeName,LONGLONG llMaximumDiffSpace) PURE;
    STDMETHOD_(HRESULT,QueryVolumesSupportedForDiffAreas)(THIS_ VSS_PWSZ pwszOriginalVolumeName,IVssEnumMgmtObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,QueryDiffAreasForVolume)(THIS_ VSS_PWSZ pwszVolumeName,IVssEnumMgmtObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,QueryDiffAreasOnVolume)(THIS_ VSS_PWSZ pwszVolumeName,IVssEnumMgmtObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,QueryDiffAreasForSnapshot)(THIS_ VSS_ID SnapshotId,IVssEnumMgmtObject **ppEnum) PURE;

    /* IVssDifferentialSoftwareSnapshotMgmt2 methods */
    STDMETHOD_(HRESULT,ChangeDiffAreaMaximumSizeEx)(THIS_ VSS_PWSZ pwszVolumeName,VSS_PWSZ pwszDiffAreaVolumeName,LONGLONG llMaximumDiffSpace,WINBOOL bVolatile) PURE;
    STDMETHOD_(HRESULT,MigrateDiffAreas)(THIS) PURE;      /*Unsupported*/
    STDMETHOD_(HRESULT,QueryMigrationStatus)(THIS) PURE;  /*Unsupported*/
    STDMETHOD_(HRESULT,SetSnapshotPriority)(THIS) PURE;   /*Unsupported*/

    /* IVssDifferentialSoftwareSnapshotMgmt3 methods */
    STDMETHOD_(HRESULT,SetVolumeProtectLevel)(THIS_ VSS_PWSZ pwszVolumeName,VSS_PROTECTION_LEVEL protectionLevel) PURE;
    STDMETHOD_(HRESULT,GetVolumeProtectLevel)(THIS_ VSS_PWSZ pwszVolumeName,VSS_VOLUME_PROTECTION_INFO *protectionLevel) PURE;
    STDMETHOD_(HRESULT,ClearVolumeProtectFault)(THIS_ VSS_PWSZ pwszVolumeName) PURE;
    STDMETHOD_(HRESULT,DeleteUnusedDiffAreas)(THIS_ VSS_PWSZ pwszDiffAreaVolumeName) PURE;
    STDMETHOD_(HRESULT,QuerySnapshotDeltaBitmap)(THIS) PURE;  /*Unsupported*/

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssDifferentialSoftwareSnapshotMgmt3_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssDifferentialSoftwareSnapshotMgmt3_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssDifferentialSoftwareSnapshotMgmt3_Release(This) (This)->lpVtbl->Release(This)
#define IVssDifferentialSoftwareSnapshotMgmt3_AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) (This)->lpVtbl->AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)
#define IVssDifferentialSoftwareSnapshotMgmt3_ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace) (This)->lpVtbl->ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)
#define IVssDifferentialSoftwareSnapshotMgmt3_QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum) (This)->lpVtbl->QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt3_QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum) (This)->lpVtbl->QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt3_QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum) (This)->lpVtbl->QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt3_QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum) (This)->lpVtbl->QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum)
#define IVssDifferentialSoftwareSnapshotMgmt3_ChangeDiffAreaMaximumSizeEx(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace,bVolatile) (This)->lpVtbl->ChangeDiffAreaMaximumSizeEx(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace,bVolatile)
#define IVssDifferentialSoftwareSnapshotMgmt3_MigrateDiffAreas() (This)->lpVtbl->MigrateDiffAreas(This)
#define IVssDifferentialSoftwareSnapshotMgmt3_QueryMigrationStatus() (This)->lpVtbl->QueryMigrationStatus(This)
#define IVssDifferentialSoftwareSnapshotMgmt3_SetSnapshotPriority() (This)->lpVtbl->SetSnapshotPriority(This)
#define IVssDifferentialSoftwareSnapshotMgmt3_SetVolumeProtectLevel(This,pwszVolumeName,protectionLevel) (This)->lpVtbl->SetVolumeProtectLevel(This,pwszVolumeName,protectionLevel)
#define IVssDifferentialSoftwareSnapshotMgmt3_GetVolumeProtectLevel(This,pwszVolumeName,protectionLevel) (This)->lpVtbl->GetVolumeProtectLevel(This,pwszVolumeName,protectionLevel)
#define IVssDifferentialSoftwareSnapshotMgmt3_ClearVolumeProtectFault(This,pwszVolumeName) (This)->lpVtbl->ClearVolumeProtectFault(This,pwszVolumeName)
#define IVssDifferentialSoftwareSnapshotMgmt3_DeleteUnusedDiffAreas(This,pwszDiffAreaVolumeName) (This)->lpVtbl->DeleteUnusedDiffAreas(This,pwszDiffAreaVolumeName)
#define IVssDifferentialSoftwareSnapshotMgmt3_QuerySnapshotDeltaBitmap() (This)->lpVtbl->QuerySnapshotDeltaBitmap(This)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IVssEnumMgmtObject
/*IID_IVssEnumMgmtObject is defined as 01954E6B-9254-4e6e-808C-C9E05D007696*/
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssEnumMgmtObject,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssEnumMgmtObject methods */
    STDMETHOD_(HRESULT,Next)(THIS_ ULONG celt,VSS_MGMT_OBJECT_PROP *rgelt,ULONG *pceltFetched) PURE;
    STDMETHOD_(HRESULT,Skip)(THIS_ ULONG celt) PURE;
    STDMETHOD_(HRESULT,Reset)(THIS) PURE;
    STDMETHOD_(HRESULT,Clone)(THIS_ IVssEnumMgmtObject **ppenum) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssEnumMgmtObject_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssEnumMgmtObject_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssEnumMgmtObject_Release(This) (This)->lpVtbl->Release(This)
#define IVssEnumMgmtObject_Next(This,celt,rgelt,pceltFetched) (This)->lpVtbl->Next(This,celt,rgelt,pceltFetched)
#define IVssEnumMgmtObject_Skip(This,celt) (This)->lpVtbl->Skip(This,celt)
#define IVssEnumMgmtObject_Reset() (This)->lpVtbl->Reset(This)
#define IVssEnumMgmtObject_Clone(This,ppenum) (This)->lpVtbl->Clone(This,ppenum)
#endif /*COBJMACROS*/

#endif /* (_WIN32_WINNT >= 0x0600) */

#undef  INTERFACE
#define INTERFACE IVssSnapshotMgmt
/*IID_IVssSnapshotMgmt is defined as FA7DF749-66E7-4986-A27F-E2F04AE53772*/
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssSnapshotMgmt,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssSnapshotMgmt methods */
    STDMETHOD_(HRESULT,GetProviderMgmtInterface)(THIS_ VSS_ID ProviderId,REFIID InterfaceId,IUnknown **ppItf) PURE;
    STDMETHOD_(HRESULT,QueryVolumesSupportedForSnapshots)(THIS) PURE; /*Unsupported*/
    STDMETHOD_(HRESULT,QuerySnapshotsByVolume)(THIS) PURE;            /*Unsupported*/

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssSnapshotMgmt_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssSnapshotMgmt_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssSnapshotMgmt_Release(This) (This)->lpVtbl->Release(This)
#define IVssSnapshotMgmt_GetProviderMgmtInterface(This,ProviderId,InterfaceId,ppItf) (This)->lpVtbl->GetProviderMgmtInterface(This,ProviderId,InterfaceId,ppItf)
#define IVssSnapshotMgmt_QueryVolumesSupportedForSnapshots() (This)->lpVtbl->QueryVolumesSupportedForSnapshots(This)
#define IVssSnapshotMgmt_QuerySnapshotsByVolume() (This)->lpVtbl->QuerySnapshotsByVolume(This)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IVssSnapshotMgmt2
DECLARE_INTERFACE_(IVssSnapshotMgmt2,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssSnapshotMgmt2 methods */
    STDMETHOD_(HRESULT,GetMinDiffAreaSize)(THIS_ LONGLONG *pllMinDiffAreaSize) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssSnapshotMgmt2_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssSnapshotMgmt2_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssSnapshotMgmt2_Release(This) (This)->lpVtbl->Release(This)
#define IVssSnapshotMgmt2_GetMinDiffAreaSize(This,pllMinDiffAreaSize) (This)->lpVtbl->GetMinDiffAreaSize(This,pllMinDiffAreaSize)
#endif /*COBJMACROS*/

#endif /*_INC_VSMGT*/
                                                                                                                                                                                                                                                                                                 usr/share/mingw-w64/include/vsprov.h                                                                0100644 0000000 0000000 00000034353 12404413016 016055  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_VSPROV
#define _INC_VSPROV

#include <vss.h>
#include <vds.h>
#undef  INTERFACE
#define INTERFACE IVssHardwareSnapshotProvider
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssHardwareSnapshotProvider,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssHardwareSnapshotProvider methods */
    STDMETHOD_(HRESULT,AreLunsSupported)(THIS_ LONG lLunCount,LONG lContext,VSS_PWSZ *rgwszDevices,VDS_LUN_INFORMATION *pLunInformation,WINBOOL *pbIsSupported) PURE;
    STDMETHOD_(HRESULT,FillInLunInfo)(THIS_ VSS_PWSZ wszDeviceName,VDS_LUN_INFORMATION *pLunInfo,WINBOOL *pbIsSupported) PURE;
    STDMETHOD_(HRESULT,BeginPrepareSnapshot)(THIS_ VSS_ID SnapshotSetId,VSS_ID SnapshotId,LONG lContext,LONG lLunCount,VSS_PWSZ *rgDeviceNames,VDS_LUN_INFORMATION *rgLunInformation) PURE;
    STDMETHOD_(HRESULT,GetTargetLuns)(THIS_ LONG lLunCount,VSS_PWSZ *rgDeviceNames,VDS_LUN_INFORMATION *rgSourceLuns,VDS_LUN_INFORMATION *rgDestinationLuns) PURE;
    STDMETHOD_(HRESULT,LocateLuns)(THIS_ LONG lLunCount,VDS_LUN_INFORMATION *rgSourceLuns) PURE;
    STDMETHOD_(HRESULT,OnLunEmpty)(THIS_ VSS_PWSZ wszDeviceName,VDS_LUN_INFORMATION *pInformation) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssHardwareSnapshotProvider_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssHardwareSnapshotProvider_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssHardwareSnapshotProvider_Release(This) (This)->lpVtbl->Release(This)
#define IVssHardwareSnapshotProvider_AreLunsSupported(This,lLunCount,lContext,rgwszDevices,pLunInformation,pbIsSupported) (This)->lpVtbl->AreLunsSupported(This,lLunCount,lContext,rgwszDevices,pLunInformation,pbIsSupported)
#define IVssHardwareSnapshotProvider_FillInLunInfo(This,wszDeviceName,pLunInfo,pbIsSupported) (This)->lpVtbl->FillInLunInfo(This,wszDeviceName,pLunInfo,pbIsSupported)
#define IVssHardwareSnapshotProvider_BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,lContext,lLunCount,rgDeviceNames,rgLunInformation) (This)->lpVtbl->BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,lContext,lLunCount,rgDeviceNames,rgLunInformation)
#define IVssHardwareSnapshotProvider_GetTargetLuns(This,lLunCount,rgDeviceNames,rgSourceLuns,rgDestinationLuns) (This)->lpVtbl->GetTargetLuns(This,lLunCount,rgDeviceNames,rgSourceLuns,rgDestinationLuns)
#define IVssHardwareSnapshotProvider_LocateLuns(This,lLunCount,rgSourceLuns) (This)->lpVtbl->LocateLuns(This,lLunCount,rgSourceLuns)
#define IVssHardwareSnapshotProvider_OnLunEmpty(This,wszDeviceName,pInformation) (This)->lpVtbl->OnLunEmpty(This,wszDeviceName,pInformation)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IVssHardwareSnapshotProviderEx
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssHardwareSnapshotProviderEx,IVssHardwareSnapshotProvider)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssHardwareSnapshotProvider methods */
    STDMETHOD_(HRESULT,AreLunsSupported)(THIS_ LONG lLunCount,LONG lContext,VSS_PWSZ *rgwszDevices,VDS_LUN_INFORMATION *pLunInformation,WINBOOL *pbIsSupported) PURE;
    STDMETHOD_(HRESULT,FillInLunInfo)(THIS_ VSS_PWSZ wszDeviceName,VDS_LUN_INFORMATION *pLunInfo,WINBOOL *pbIsSupported) PURE;
    STDMETHOD_(HRESULT,BeginPrepareSnapshot)(THIS_ VSS_ID SnapshotSetId,VSS_ID SnapshotId,LONG lContext,LONG lLunCount,VSS_PWSZ *rgDeviceNames,VDS_LUN_INFORMATION *rgLunInformation) PURE;
    STDMETHOD_(HRESULT,GetTargetLuns)(THIS_ LONG lLunCount,VSS_PWSZ *rgDeviceNames,VDS_LUN_INFORMATION *rgSourceLuns,VDS_LUN_INFORMATION *rgDestinationLuns) PURE;
    STDMETHOD_(HRESULT,LocateLuns)(THIS_ LONG lLunCount,VDS_LUN_INFORMATION *rgSourceLuns) PURE;
    STDMETHOD_(HRESULT,OnLunEmpty)(THIS_ VSS_PWSZ wszDeviceName,VDS_LUN_INFORMATION *pInformation) PURE;

    /* IVssHardwareSnapshotProviderEx methods */
    STDMETHOD_(HRESULT,GetProviderCapabilities)(THIS) PURE;
    STDMETHOD_(HRESULT,OnLunStateChange)(THIS_ VDS_LUN_INFORMATION *pSnapshotLuns,VDS_LUN_INFORMATION *pOriginalLuns,DWORD dwCount,DWORD dwFlags) PURE;
    STDMETHOD_(HRESULT,OnReuseLuns)(THIS) PURE;
    STDMETHOD_(HRESULT,ResyncLuns)(THIS_ VDS_LUN_INFORMATION *pSourceLuns,VDS_LUN_INFORMATION *pTargetLuns,DWORD dwCount,IVssAsync **ppAsync) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssHardwareSnapshotProviderEx_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssHardwareSnapshotProviderEx_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssHardwareSnapshotProviderEx_Release(This) (This)->lpVtbl->Release(This)
#define IVssHardwareSnapshotProviderEx_AreLunsSupported(This,lLunCount,lContext,rgwszDevices,pLunInformation,pbIsSupported) (This)->lpVtbl->AreLunsSupported(This,lLunCount,lContext,rgwszDevices,pLunInformation,pbIsSupported)
#define IVssHardwareSnapshotProviderEx_FillInLunInfo(This,wszDeviceName,pLunInfo,pbIsSupported) (This)->lpVtbl->FillInLunInfo(This,wszDeviceName,pLunInfo,pbIsSupported)
#define IVssHardwareSnapshotProviderEx_BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,lContext,lLunCount,rgDeviceNames,rgLunInformation) (This)->lpVtbl->BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,lContext,lLunCount,rgDeviceNames,rgLunInformation)
#define IVssHardwareSnapshotProviderEx_GetTargetLuns(This,lLunCount,rgDeviceNames,rgSourceLuns,rgDestinationLuns) (This)->lpVtbl->GetTargetLuns(This,lLunCount,rgDeviceNames,rgSourceLuns,rgDestinationLuns)
#define IVssHardwareSnapshotProviderEx_LocateLuns(This,lLunCount,rgSourceLuns) (This)->lpVtbl->LocateLuns(This,lLunCount,rgSourceLuns)
#define IVssHardwareSnapshotProviderEx_OnLunEmpty(This,wszDeviceName,pInformation) (This)->lpVtbl->OnLunEmpty(This,wszDeviceName,pInformation)
#define IVssHardwareSnapshotProviderEx_GetProviderCapabilities() (This)->lpVtbl->GetProviderCapabilities(This)
#define IVssHardwareSnapshotProviderEx_OnLunStateChange(This,pSnapshotLuns,pOriginalLuns,dwCount,dwFlags) (This)->lpVtbl->OnLunStateChange(This,pSnapshotLuns,pOriginalLuns,dwCount,dwFlags)
#define IVssHardwareSnapshotProviderEx_OnReuseLuns() (This)->lpVtbl->OnReuseLuns(This)
#define IVssHardwareSnapshotProviderEx_ResyncLuns(This,pSourceLuns,pTargetLuns,dwCount,ppAsync) (This)->lpVtbl->ResyncLuns(This,pSourceLuns,pTargetLuns,dwCount,ppAsync)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IVssProviderCreateSnapshotSet
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssProviderCreateSnapshotSet,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssProviderCreateSnapshotSet methods */
    STDMETHOD_(HRESULT,EndPrepareSnapshots)(THIS_ VSS_ID SnapshotSetId) PURE;
    STDMETHOD_(HRESULT,PreCommitSnapshots)(THIS_ VSS_ID SnapshotSetId) PURE;
    STDMETHOD_(HRESULT,CommitSnapshots)(THIS_ VSS_ID SnapshotSetId) PURE;
    STDMETHOD_(HRESULT,PostCommitSnapshots)(THIS_ VSS_ID SnapshotSetId,LONG lSnapshotsCount) PURE;
    STDMETHOD_(HRESULT,PreFinalCommitSnapshots)(THIS_ VSS_ID SnapshotSetId) PURE;
    STDMETHOD_(HRESULT,PostFinalCommitSnapshots)(THIS_ VSS_ID SnapshotSetId) PURE;
    STDMETHOD_(HRESULT,AbortSnapshots)(THIS_ VSS_ID SnapshotSetId) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssProviderCreateSnapshotSet_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssProviderCreateSnapshotSet_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssProviderCreateSnapshotSet_Release(This) (This)->lpVtbl->Release(This)
#define IVssProviderCreateSnapshotSet_EndPrepareSnapshots(This,SnapshotSetId) (This)->lpVtbl->EndPrepareSnapshots(This,SnapshotSetId)
#define IVssProviderCreateSnapshotSet_PreCommitSnapshots(This,SnapshotSetId) (This)->lpVtbl->PreCommitSnapshots(This,SnapshotSetId)
#define IVssProviderCreateSnapshotSet_CommitSnapshots(This,SnapshotSetId) (This)->lpVtbl->CommitSnapshots(This,SnapshotSetId)
#define IVssProviderCreateSnapshotSet_PostCommitSnapshots(This,SnapshotSetId,lSnapshotsCount) (This)->lpVtbl->PostCommitSnapshots(This,SnapshotSetId,lSnapshotsCount)
#define IVssProviderCreateSnapshotSet_PreFinalCommitSnapshots(This,SnapshotSetId) (This)->lpVtbl->PreFinalCommitSnapshots(This,SnapshotSetId)
#define IVssProviderCreateSnapshotSet_PostFinalCommitSnapshots(This,SnapshotSetId) (This)->lpVtbl->PostFinalCommitSnapshots(This,SnapshotSetId)
#define IVssProviderCreateSnapshotSet_AbortSnapshots(This,SnapshotSetId) (This)->lpVtbl->AbortSnapshots(This,SnapshotSetId)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IVssProviderNotifications
DECLARE_INTERFACE_(IVssProviderNotifications,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssProviderNotifications methods */
    STDMETHOD_(HRESULT,OnLoad)(THIS_ IUnknown *pCallback) PURE;
    STDMETHOD_(HRESULT,OnUnload)(THIS_ WINBOOL bForceUnload) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssProviderNotifications_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssProviderNotifications_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssProviderNotifications_Release(This) (This)->lpVtbl->Release(This)
#define IVssProviderNotifications_OnLoad(This,pCallback) (This)->lpVtbl->OnLoad(This,pCallback)
#define IVssProviderNotifications_OnUnload(This,bForceUnload) (This)->lpVtbl->OnUnload(This,bForceUnload)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IVssSoftwareSnapshotProvider
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssSoftwareSnapshotProvider,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssSoftwareSnapshotProvider methods */
    STDMETHOD_(HRESULT,SetContext)(THIS_ LONG lContext) PURE;
    STDMETHOD_(HRESULT,GetSnapshotProperties)(THIS_ VSS_ID SnapshotId,VSS_SNAPSHOT_PROP *pProp) PURE;
    STDMETHOD_(HRESULT,Query)(THIS_ VSS_ID QueriedObjectId,VSS_OBJECT_TYPE eQueriedObjectType,VSS_OBJECT_TYPE eReturnedObjectsType,IVssEnumObject **ppEnum) PURE;
    STDMETHOD_(HRESULT,DeleteSnapshots)(THIS_ VSS_ID SourceObjectId,VSS_OBJECT_TYPE eSourceObjectType,WINBOOL bForceDelete,LONG *plDeletedSnapshots,VSS_ID *pNondeletedSnapshotID) PURE;
    STDMETHOD_(HRESULT,BeginPrepareSnapshot)(THIS_ VSS_ID SnapshotSetId,VSS_ID SnapshotId,VSS_PWSZ pwszVolumeName,LONG lNewContext) PURE;
    STDMETHOD_(HRESULT,IsVolumeSupported)(THIS_ VSS_PWSZ pwszVolumeName,WINBOOL *pbSupportedByThisProvider) PURE;
    STDMETHOD_(HRESULT,IsVolumeSnapshotted)(THIS_ VSS_PWSZ pwszVolumeName,WINBOOL *pbSnapshotsPresent,LONG *plSnapshotCompatibility) PURE;
    STDMETHOD_(HRESULT,SetSnapshotProperty)(THIS_ VSS_ID SnapshotId,VSS_SNAPSHOT_PROPERTY_ID eSnapshotPropertyId,VARIANT vProperty) PURE;
    STDMETHOD_(HRESULT,RevertToSnapshot)(THIS_ VSS_ID SnapshotId) PURE;
    STDMETHOD_(HRESULT,QueryRevertStatus)(THIS_ VSS_PWSZ pwszVolume,IVssAsync **ppAsync) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssSoftwareSnapshotProvider_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssSoftwareSnapshotProvider_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssSoftwareSnapshotProvider_Release(This) (This)->lpVtbl->Release(This)
#define IVssSoftwareSnapshotProvider_SetContext(This,lContext) (This)->lpVtbl->SetContext(This,lContext)
#define IVssSoftwareSnapshotProvider_GetSnapshotProperties(This,SnapshotId,pProp) (This)->lpVtbl->GetSnapshotProperties(This,SnapshotId,pProp)
#define IVssSoftwareSnapshotProvider_Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum) (This)->lpVtbl->Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum)
#define IVssSoftwareSnapshotProvider_DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID) (This)->lpVtbl->DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID)
#define IVssSoftwareSnapshotProvider_BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,pwszVolumeName,lNewContext) (This)->lpVtbl->BeginPrepareSnapshot(This,SnapshotSetId,SnapshotId,pwszVolumeName,lNewContext)
#define IVssSoftwareSnapshotProvider_IsVolumeSupported(This,pwszVolumeName,pbSupportedByThisProvider) (This)->lpVtbl->IsVolumeSupported(This,pwszVolumeName,pbSupportedByThisProvider)
#define IVssSoftwareSnapshotProvider_IsVolumeSnapshotted(This,pwszVolumeName,pbSnapshotsPresent,plSnapshotCompatibility) (This)->lpVtbl->IsVolumeSnapshotted(This,pwszVolumeName,pbSnapshotsPresent,plSnapshotCompatibility)
#define IVssSoftwareSnapshotProvider_SetSnapshotProperty(This,SnapshotId,eSnapshotPropertyId,vProperty) (This)->lpVtbl->SetSnapshotProperty(This,SnapshotId,eSnapshotPropertyId,vProperty)
#define IVssSoftwareSnapshotProvider_RevertToSnapshot(This,SnapshotId) (This)->lpVtbl->RevertToSnapshot(This,SnapshotId)
#define IVssSoftwareSnapshotProvider_QueryRevertStatus(This,pwszVolume,ppAsync) (This)->lpVtbl->QueryRevertStatus(This,pwszVolume,ppAsync)
#endif /*COBJMACROS*/

#endif /*_INC_VSPROV*/
                                                                                                                                                                                                                                                                                     usr/share/mingw-w64/include/vss.h                                                                   0100644 0000000 0000000 00000047155 12404413016 015335  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_VSS
#define _INC_VSS

#ifndef __IVssAdmin_FWD_DEFINED__
#define __IVssAdmin_FWD_DEFINED__
typedef struct IVssAdmin IVssAdmin;
#endif /* __IVssAdmin_FWD_DEFINED__ */

#ifndef __IVssBackupComponents_FWD_DEFINED__
#define __IVssBackupComponents_FWD_DEFINED__
typedef struct IVssBackupComponents IVssBackupComponents;
#endif /* __IVssBackupComponents_FWD_DEFINED__ */

#ifndef __IVssBackupComponentsEx_FWD_DEFINED__
#define __IVssBackupComponentsEx_FWD_DEFINED__
typedef struct IVssBackupComponentsEx IVssBackupComponentsEx;
#endif /* __IVssBackupComponentsEx_FWD_DEFINED__ */

#ifndef __IVssBackupComponentsEx2_FWD_DEFINED__
#define __IVssBackupComponentsEx2_FWD_DEFINED__
typedef struct IVssBackupComponentsEx2 IVssBackupComponentsEx2;
#endif /* __IVssBackupComponentsEx2_FWD_DEFINED__ */

#ifndef __IVssBackupComponentsEx3_FWD_DEFINED__
#define __IVssBackupComponentsEx3_FWD_DEFINED__
typedef struct IVssBackupComponentsEx3 IVssBackupComponentsEx3;
#endif /* __IVssBackupComponentsEx3_FWD_DEFINED__ */

#ifndef __IVssExamineWriterMetadata_FWD_DEFINED__
#define __IVssExamineWriterMetadata_FWD_DEFINED__
typedef struct IVssExamineWriterMetadata IVssExamineWriterMetadata;
#endif /* __IVssExamineWriterMetadata_FWD_DEFINED__ */

#ifndef __IVssExamineWriterMetadataEx_FWD_DEFINED__
#define __IVssExamineWriterMetadataEx_FWD_DEFINED__
typedef struct IVssExamineWriterMetadataEx IVssExamineWriterMetadataEx;
#endif /* __IVssExamineWriterMetadataEx_FWD_DEFINED__ */

#ifndef __IVssExamineWriterMetadataEx2_FWD_DEFINED__
#define __IVssExamineWriterMetadataEx2_FWD_DEFINED__
typedef struct IVssExamineWriterMetadataEx2 IVssExamineWriterMetadataEx2;
#endif /* __IVssExamineWriterMetadataEx2_FWD_DEFINED__ */

#ifndef __IVssWMComponent_FWD_DEFINED__
#define __IVssWMComponent_FWD_DEFINED__
typedef struct IVssWMComponent IVssWMComponent;
#endif /* __IVssWMComponent_FWD_DEFINED__ */

#ifndef __IVssWriterComponentsExt_FWD_DEFINED__
#define __IVssWriterComponentsExt_FWD_DEFINED__
typedef struct IVssWriterComponentsExt IVssWriterComponentsExt;
#endif /* __IVssWriterComponentsExt_FWD_DEFINED__ */

#ifndef __IVssDifferentialSoftwareSnapshotMgmt_FWD_DEFINED__
#define __IVssDifferentialSoftwareSnapshotMgmt_FWD_DEFINED__
typedef struct IVssDifferentialSoftwareSnapshotMgmt IVssDifferentialSoftwareSnapshotMgmt;
#endif /* __IVssDifferentialSoftwareSnapshotMgmt_FWD_DEFINED__ */

#ifndef __IVssDifferentialSoftwareSnapshotMgmt2_FWD_DEFINED__
#define __IVssDifferentialSoftwareSnapshotMgmt2_FWD_DEFINED__
typedef struct IVssDifferentialSoftwareSnapshotMgmt2 IVssDifferentialSoftwareSnapshotMgmt2;
#endif /* __IVssDifferentialSoftwareSnapshotMgmt2_FWD_DEFINED__ */

#ifndef __IVssDifferentialSoftwareSnapshotMgmt3_FWD_DEFINED__
#define __IVssDifferentialSoftwareSnapshotMgmt3_FWD_DEFINED__
typedef struct IVssDifferentialSoftwareSnapshotMgmt3 IVssDifferentialSoftwareSnapshotMgmt3;
#endif /* __IVssDifferentialSoftwareSnapshotMgmt3_FWD_DEFINED__ */

#ifndef __IVssEnumMgmtObject_FWD_DEFINED__
#define __IVssEnumMgmtObject_FWD_DEFINED__
typedef struct IVssEnumMgmtObject IVssEnumMgmtObject;
#endif /* __IVssEnumMgmtObject_FWD_DEFINED__ */

#ifndef __IVssSnapshotMgmt_FWD_DEFINED__
#define __IVssSnapshotMgmt_FWD_DEFINED__
typedef struct IVssSnapshotMgmt IVssSnapshotMgmt;
#endif /* __IVssSnapshotMgmt_FWD_DEFINED__ */

#ifndef __IVssSnapshotMgmt2_FWD_DEFINED__
#define __IVssSnapshotMgmt2_FWD_DEFINED__
typedef struct IVssSnapshotMgmt2 IVssSnapshotMgmt2;
#endif /* __IVssSnapshotMgmt2_FWD_DEFINED__ */

#ifndef __IVssHardwareSnapshotProvider_FWD_DEFINED__
#define __IVssHardwareSnapshotProvider_FWD_DEFINED__
typedef struct IVssHardwareSnapshotProvider IVssHardwareSnapshotProvider;
#endif /* __IVssHardwareSnapshotProvider_FWD_DEFINED__ */

#ifndef __IVssHardwareSnapshotProviderEx_FWD_DEFINED__
#define __IVssHardwareSnapshotProviderEx_FWD_DEFINED__
typedef struct IVssHardwareSnapshotProviderEx IVssHardwareSnapshotProviderEx;
#endif /* __IVssHardwareSnapshotProviderEx_FWD_DEFINED__ */

#ifndef __IVssProviderCreateSnapshotSet_FWD_DEFINED__
#define __IVssProviderCreateSnapshotSet_FWD_DEFINED__
typedef struct IVssProviderCreateSnapshotSet IVssProviderCreateSnapshotSet;
#endif /* __IVssProviderCreateSnapshotSet_FWD_DEFINED__ */

#ifndef __IVssProviderNotifications_FWD_DEFINED__
#define __IVssProviderNotifications_FWD_DEFINED__
typedef struct IVssProviderNotifications IVssProviderNotifications;
#endif /* __IVssProviderNotifications_FWD_DEFINED__ */

#ifndef __IVssSoftwareSnapshotProvider_FWD_DEFINED__
#define __IVssSoftwareSnapshotProvider_FWD_DEFINED__
typedef struct IVssSoftwareSnapshotProvider IVssSoftwareSnapshotProvider;
#endif /* __IVssSoftwareSnapshotProvider_FWD_DEFINED__ */

#ifndef __IVssAsync_FWD_DEFINED__
#define __IVssAsync_FWD_DEFINED__
typedef struct IVssAsync IVssAsync;
#endif /* __IVssAsync_FWD_DEFINED__ */

#ifndef __IVssEnumObject_FWD_DEFINED__
#define __IVssEnumObject_FWD_DEFINED__
typedef struct IVssEnumObject IVssEnumObject;
#endif /* __IVssEnumObject_FWD_DEFINED__ */

#ifndef __IVssCreateExpressWriterMetadata_FWD_DEFINED__
#define __IVssCreateExpressWriterMetadata_FWD_DEFINED__
typedef struct IVssCreateExpressWriterMetadata IVssCreateExpressWriterMetadata;
#endif /* __IVssCreateExpressWriterMetadata_FWD_DEFINED__ */

#ifndef __IVssCreateWriterMetadata_FWD_DEFINED__
#define __IVssCreateWriterMetadata_FWD_DEFINED__
typedef struct IVssCreateWriterMetadata IVssCreateWriterMetadata;
#endif /* __IVssCreateWriterMetadata_FWD_DEFINED__ */

#ifndef __IVssCreateWriterMetadataEx_FWD_DEFINED__
#define __IVssCreateWriterMetadataEx_FWD_DEFINED__
typedef struct IVssCreateWriterMetadataEx IVssCreateWriterMetadataEx;
#endif /* __IVssCreateWriterMetadataEx_FWD_DEFINED__ */

#ifndef __IVssExpressWriter_FWD_DEFINED__
#define __IVssExpressWriter_FWD_DEFINED__
typedef struct IVssExpressWriter IVssExpressWriter;
#endif /* __IVssExpressWriter_FWD_DEFINED__ */

#ifndef __IVssWriterComponents_FWD_DEFINED__
#define __IVssWriterComponents_FWD_DEFINED__
typedef struct IVssWriterComponents IVssWriterComponents;
#endif /* __IVssWriterComponents_FWD_DEFINED__ */

#ifndef __IVssComponent_FWD_DEFINED__
#define __IVssComponent_FWD_DEFINED__
typedef struct IVssComponent IVssComponent;
#endif /* __IVssComponent_FWD_DEFINED__ */

#ifndef __IVssComponentEx_FWD_DEFINED__
#define __IVssComponentEx_FWD_DEFINED__
typedef struct IVssComponentEx IVssComponentEx;
#endif /* __IVssComponentEx_FWD_DEFINED__ */

#ifndef __IVssComponentEx2_FWD_DEFINED__
#define __IVssComponentEx2_FWD_DEFINED__
typedef struct IVssComponentEx2 IVssComponentEx2;
#endif /* __IVssComponentEx2_FWD_DEFINED__ */

#ifndef __IVssWMDependency_FWD_DEFINED__
#define __IVssWMDependency_FWD_DEFINED__
typedef struct IVssWMDependency IVssWMDependency;
#endif /* __IVssWMDependency_FWD_DEFINED__ */

#ifndef __IVssWMFiledesc_FWD_DEFINED__
#define __IVssWMFiledesc_FWD_DEFINED__
typedef struct IVssWMFiledesc IVssWMFiledesc;
#endif /* __IVssWMFiledesc_FWD_DEFINED__ */

/* http://msdn.microsoft.com/en-us/library/aa384641%28VS.85%29.aspx */
typedef WCHAR *VSS_PWSZ;
typedef LONGLONG VSS_TIMESTAMP;
typedef GUID VSS_ID;

#ifndef __cplusplus
typedef char bool;
#endif

typedef enum _VSS_APPLICATION_LEVEL {
  VSS_APP_UNKNOWN     = 0,
  VSS_APP_SYSTEM      = 1,
  VSS_APP_BACK_END    = 2,
  VSS_APP_FRONT_END   = 3,
  VSS_APP_AUTO        = -1 
} VSS_APPLICATION_LEVEL, *PVSS_APPLICATION_LEVEL;

typedef enum _VSS_BACKUP_TYPE {
  VSS_BT_UNDEFINED      = 0,
  VSS_BT_FULL           = 1,
  VSS_BT_INCREMENTAL    = 2,
  VSS_BT_DIFFERENTIAL   = 3,
  VSS_BT_LOG            = 4,
  VSS_BT_COPY           = 5,
  VSS_BT_OTHER          = 6 
} VSS_BACKUP_TYPE, *PVSS_BACKUP_TYPE;

/* Reserved for future use */
/*typedef enum _VSS_FASTRECOVERY_OPTIONS;*/

typedef enum _VSS_PROVIDER_TYPE {
  VSS_PROV_UNKNOWN    = 0,
  VSS_PROV_SYSTEM     = 1,
  VSS_PROV_SOFTWARE   = 2,
  VSS_PROV_HARDWARE   = 3 
} VSS_PROVIDER_TYPE, *PVSS_PROVIDER_TYPE;

typedef enum _VSS_SNAPSHOT_COMPATIBILITY {
  VSS_SC_DISABLE_DEFRAG         = 0x1,
  VSS_SC_DISABLE_CONTENTINDEX   = 0x2 
} VSS_SNAPSHOT_COMPATIBILITY;

typedef enum _VSS_SNAPSHOT_STATE {
  VSS_SS_UNKNOWN                      = 0x00,
  VSS_SS_PREPARING                    = 0x01,
  VSS_SS_PROCESSING_PREPARE           = 0x02,
  VSS_SS_PREPARED                     = 0x03,
  VSS_SS_PROCESSING_PRECOMMIT         = 0x04,
  VSS_SS_PRECOMMITTED                 = 0x05,
  VSS_SS_PROCESSING_COMMIT            = 0x06,
  VSS_SS_COMMITTED                    = 0x07,
  VSS_SS_PROCESSING_POSTCOMMIT        = 0x08,
  VSS_SS_PROCESSING_PREFINALCOMMIT    = 0x09,
  VSS_SS_PREFINALCOMMITTED            = 0x0a,
  VSS_SS_PROCESSING_POSTFINALCOMMIT   = 0x0b,
  VSS_SS_CREATED                      = 0x0c,
  VSS_SS_ABORTED                      = 0x0d,
  VSS_SS_DELETED                      = 0x0e,
  VSS_SS_POSTCOMMITTED                = 0x0f,
  VSS_SS_COUNT                        = 0x10 
} VSS_SNAPSHOT_STATE, *PVSS_SNAPSHOT_STATE;

typedef enum _VSS_VOLUME_SNAPSHOT_ATTRIBUTES {
  VSS_VOLSNAP_ATTR_PERSISTENT             = 0x00000001,
  VSS_VOLSNAP_ATTR_NO_AUTORECOVERY        = 0x00000002,
  VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE      = 0x00000004,
  VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE        = 0x00000008,
  VSS_VOLSNAP_ATTR_NO_WRITERS             = 0x00000010,
  VSS_VOLSNAP_ATTR_TRANSPORTABLE          = 0x00000020,
  VSS_VOLSNAP_ATTR_NOT_SURFACED           = 0x00000040,
  VSS_VOLSNAP_ATTR_NOT_TRANSACTED         = 0x00000080,
  VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED      = 0x00010000,
  VSS_VOLSNAP_ATTR_DIFFERENTIAL           = 0x00020000,
  VSS_VOLSNAP_ATTR_PLEX                   = 0x00040000,
  VSS_VOLSNAP_ATTR_IMPORTED               = 0x00080000,
  VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY        = 0x00100000,
  VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY       = 0x00200000,
  VSS_VOLSNAP_ATTR_AUTORECOVER            = 0x00400000,
  VSS_VOLSNAP_ATTR_ROLLBACK_RECOVERY      = 0x00800000,
  VSS_VOLSNAP_ATTR_DELAYED_POSTSNAPSHOT   = 0x01000000,
  VSS_VOLSNAP_ATTR_TXF_RECOVERY           = 0x02000000 
} VSS_VOLUME_SNAPSHOT_ATTRIBUTES, *PVSS_VOLUME_SNAPSHOT_ATTRIBUTES;

typedef enum _VSS_SNAPSHOT_CONTEXT {
  VSS_CTX_BACKUP                      = 0,
  VSS_CTX_FILE_SHARE_BACKUP           = VSS_VOLSNAP_ATTR_NO_WRITERS,
  VSS_CTX_NAS_ROLLBACK                = ( ( VSS_VOLSNAP_ATTR_PERSISTENT | VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE ) | VSS_VOLSNAP_ATTR_NO_WRITERS ),
  VSS_CTX_APP_ROLLBACK                = ( VSS_VOLSNAP_ATTR_PERSISTENT | VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE ),
  VSS_CTX_CLIENT_ACCESSIBLE           = ( ( ( VSS_VOLSNAP_ATTR_PERSISTENT | VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE ) | VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE ) | VSS_VOLSNAP_ATTR_NO_WRITERS ),
  VSS_CTX_CLIENT_ACCESSIBLE_WRITERS   = ( ( VSS_VOLSNAP_ATTR_PERSISTENT | VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE ) | VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE ),
  VSS_CTX_ALL                         = 0xffffffff
} VSS_SNAPSHOT_CONTEXT, *PVSS_SNAPSHOT_CONTEXT;

typedef enum _VSS_WRITER_STATE {
  VSS_WS_UNKNOWN                       = 0,
  VSS_WS_STABLE                        = 1,
  VSS_WS_WAITING_FOR_FREEZE            = 2,
  VSS_WS_WAITING_FOR_THAW              = 3,
  VSS_WS_WAITING_FOR_POST_SNAPSHOT     = 4,
  VSS_WS_WAITING_FOR_BACKUP_COMPLETE   = 5,
  VSS_WS_FAILED_AT_IDENTIFY            = 6,
  VSS_WS_FAILED_AT_PREPARE_BACKUP      = 7,
  VSS_WS_FAILED_AT_PREPARE_SNAPSHOT    = 8,
  VSS_WS_FAILED_AT_FREEZE              = 9,
  VSS_WS_FAILED_AT_THAW                = 10,
  VSS_WS_FAILED_AT_POST_SNAPSHOT       = 11,
  VSS_WS_FAILED_AT_BACKUP_COMPLETE     = 12,
  VSS_WS_FAILED_AT_PRE_RESTORE         = 13,
  VSS_WS_FAILED_AT_POST_RESTORE        = 14,
  VSS_WS_FAILED_AT_BACKUPSHUTDOWN      = 15,
  VSS_WS_COUNT                         = 16 
} VSS_WRITER_STATE, *PVSS_WRITER_STATE;

typedef enum _VSS_SNAPSHOT_PROPERTY_ID {
  VSS_SPROPID_UNKNOWN               = 0x00000000,
  VSS_SPROPID_SNAPSHOT_ID           = 0x00000001,
  VSS_SPROPID_SNAPSHOT_SET_ID       = 0x00000002,
  VSS_SPROPID_SNAPSHOTS_COUNT       = 0x00000003,
  VSS_SPROPID_SNAPSHOT_DEVICE       = 0x00000004,
  VSS_SPROPID_ORIGINAL_VOLUME       = 0x00000005,
  VSS_SPROPID_ORIGINATING_MACHINE   = 0x00000006,
  VSS_SPROPID_SERVICE_MACHINE       = 0x00000007,
  VSS_SPROPID_EXPOSED_NAME          = 0x00000008,
  VSS_SPROPID_EXPOSED_PATH          = 0x00000009,
  VSS_SPROPID_PROVIDER_ID           = 0x0000000A,
  VSS_SPROPID_SNAPSHOT_ATTRIBUTES   = 0x0000000B,
  VSS_SPROPID_CREATION_TIMESTAMP    = 0x0000000C,
  VSS_SPROPID_STATUS                = 0x0000000D 
} VSS_SNAPSHOT_PROPERTY_ID, *PVSS_SNAPSHOT_PROPERTY_ID;

typedef enum _VSS_OBJECT_TYPE {
  VSS_OBJECT_UNKNOWN        = 0,
  VSS_OBJECT_NONE           = 1,
  VSS_OBJECT_SNAPSHOT_SET   = 2,
  VSS_OBJECT_SNAPSHOT       = 3,
  VSS_OBJECT_PROVIDER       = 4,
  VSS_OBJECT_TYPE_COUNT     = 5 
} VSS_OBJECT_TYPE, *PVSS_OBJECT_TYPE;

#if (_WIN32_WINNT >= 0x0600)

typedef enum VSS_BACKUP_SCHEMA {
  VSS_BS_UNDEFINED                            = 0x00000000,
  VSS_BS_DIFFERENTIAL                         = 0x00000001,
  VSS_BS_INCREMENTAL                          = 0x00000002,
  VSS_BS_EXCLUSIVE_INCREMENTAL_DIFFERENTIAL   = 0x00000004,
  VSS_BS_LOG                                  = 0x00000008,
  VSS_BS_COPY                                 = 0x00000010,
  VSS_BS_TIMESTAMPED                          = 0x00000020,
  VSS_BS_LAST_MODIFY                          = 0x00000040,
  VSS_BS_LSN                                  = 0x00000080,
  VSS_BS_WRITER_SUPPORTS_NEW_TARGET           = 0x00000100,
  VSS_BS_WRITER_SUPPORTS_RESTORE_WITH_MOVE    = 0x00000200,
  VSS_BS_INDEPENDENT_SYSTEM_STATE             = 0x00000400,
  VSS_BS_ROLLFORWARD_RESTORE                  = 0x00001000,
  VSS_BS_RESTORE_RENAME                       = 0x00002000,
  VSS_BS_AUTHORITATIVE_RESTORE                = 0x00004000,
  VSS_BS_WRITER_SUPPORTS_PARALLEL_RESTORES    = 0x00008000 
} VSS_BACKUP_SCHEMA, *PVSS_BACKUP_SCHEMA;

typedef enum _VSS_FILE_SPEC_BACKUP_TYPE {
  VSS_FSBT_FULL_BACKUP_REQUIRED             = 0x00000001,
  VSS_FSBT_DIFFERENTIAL_BACKUP_REQUIRED     = 0x00000002,
  VSS_FSBT_INCREMENTAL_BACKUP_REQUIRED      = 0x00000004,
  VSS_FSBT_LOG_BACKUP_REQUIRED              = 0x00000008,
  VSS_FSBT_FULL_SNAPSHOT_REQUIRED           = 0x00000100,
  VSS_FSBT_DIFFERENTIAL_SNAPSHOT_REQUIRED   = 0x00000200,
  VSS_FSBT_INCREMENTAL_SNAPSHOT_REQUIRED    = 0x00000400,
  VSS_FSBT_LOG_SNAPSHOT_REQUIRED            = 0x00000800,
  VSS_FSBT_ALL_BACKUP_REQUIRED              = 0x0000000F,
  VSS_FSBT_ALL_SNAPSHOT_REQUIRED            = 0x00000F00 
} VSS_FILE_SPEC_BACKUP_TYPE, *PVSS_FILE_SPEC_BACKUP_TYPE;

typedef enum _VSS_HARDWARE_OPTIONS {
  VSS_BREAKEX_FLAG_MASK_LUNS                      = 0x00000001,
  VSS_BREAKEX_FLAG_MAKE_READ_WRITE                = 0x00000002,
  VSS_BREAKEX_FLAG_REVERT_IDENTITY_ALL            = 0x00000004,
  VSS_BREAKEX_FLAG_REVERT_IDENTITY_NONE           = 0x00000008,
  VSS_ONLUNSTATECHANGE_NOTIFY_READ_WRITE          = 0x00000100,
  VSS_ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY    = 0x00000200,
  VSS_ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY   = 0x00000400,
  VSS_ONLUNSTATECHANGE_DO_MASK_LUNS               = 0x00000800 
} VSS_HARDWARE_OPTIONS, *PVSS_HARDWARE_OPTIONS;

typedef enum _VSS_RESTORE_TYPE {
  VSS_RTYPE_UNDEFINED   = 0,
  VSS_RTYPE_BY_COPY     = 1,
  VSS_RTYPE_IMPORT      = 2,
  VSS_RTYPE_OTHER       = 3 
} VSS_RESTORE_TYPE, *PVSS_RESTORE_TYPE;

typedef enum _VSS_ROLLFORWARD_TYPE {
  VSS_RF_UNDEFINED   = 0,
  VSS_RF_NONE        = 1,
  VSS_RF_ALL         = 2,
  VSS_RF_PARTIAL     = 3 
} VSS_ROLLFORWARD_TYPE, *PVSS_ROLLFORWARD_TYPE;

#endif /*(_WIN32_WINNT >= 0x0600)*/

#if (_WIN32_WINNT >= 0x0601)
typedef enum _VSS_RECOVERY_OPTIONS {
  VSS_RECOVERY_REVERT_IDENTITY_ALL   = 0x00000100,
  VSS_RECOVERY_NO_VOLUME_CHECK       = 0x00000200 
} VSS_RECOVERY_OPTIONS;
#endif /*(_WIN32_WINNT >= 0x0601)*/

typedef struct _VSS_SNAPSHOT_PROP {
  VSS_ID             m_SnapshotId;
  VSS_ID             m_SnapshotSetId;
  LONG               m_lSnapshotsCount;
  VSS_PWSZ           m_pwszSnapshotDeviceObject;
  VSS_PWSZ           m_pwszOriginalVolumeName;
  VSS_PWSZ           m_pwszOriginatingMachine;
  VSS_PWSZ           m_pwszServiceMachine;
  VSS_PWSZ           m_pwszExposedName;
  VSS_PWSZ           m_pwszExposedPath;
  VSS_ID             m_ProviderId;
  LONG               m_lSnapshotAttributes;
  VSS_TIMESTAMP      m_tsCreationTimestamp;
  VSS_SNAPSHOT_STATE m_eStatus;
} VSS_SNAPSHOT_PROP, *PVSS_SNAPSHOT_PROP;

typedef struct _VSS_PROVIDER_PROP {
  VSS_ID            m_ProviderId;
  VSS_PWSZ          m_pwszProviderName;
  VSS_PROVIDER_TYPE m_eProviderType;
  VSS_PWSZ          m_pwszProviderVersion;
  VSS_ID            m_ProviderVersionId;
  CLSID             m_ClassId;
} VSS_PROVIDER_PROP, *PVSS_PROVIDER_PROP;

typedef union _VSS_OBJECT_UNION {
  /*[case(VSS_OBJECT_SNAPSHOT)]*/
    VSS_SNAPSHOT_PROP Snap;
  /*[case(VSS_OBJECT_PROVIDER)]*/
    VSS_PROVIDER_PROP Prov;
} VSS_OBJECT_UNION;

typedef struct _VSS_OBJECT_PROP {
  VSS_OBJECT_TYPE  Type;
  VSS_OBJECT_UNION Obj;
} VSS_OBJECT_PROP, *PVSS_OBJECT_PROP;

#undef  INTERFACE
#define INTERFACE IVssAsync
/* IID_IVssAsync is defined as 507C37B4-CF5B-4e95-B0AF-14EB9767467E */
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssAsync,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssAsync methods */
    STDMETHOD_(HRESULT,Cancel)(THIS) PURE;
    STDMETHOD_(HRESULT,Wait)(THIS_ DWORD dwMilliseconds) PURE;
    STDMETHOD_(HRESULT,QueryStatus)(THIS_ HRESULT *pHrResult,INT *pReserved) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssAsync_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssAsync_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssAsync_Release(This) (This)->lpVtbl->Release(This)
#define IVssAsync_Cancel() (This)->lpVtbl->Cancel(This)
#define IVssAsync_Wait(This,dwMilliseconds) (This)->lpVtbl->Wait(This,dwMilliseconds)
#define IVssAsync_QueryStatus(This,pHrResult,pReserved) (This)->lpVtbl->QueryStatus(This,pHrResult,pReserved)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IVssEnumObject
/* IID_IVssEnumObject is defined as AE1C7110-2F60-11d3-8A39-00C04F72D8E3 */
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssEnumObject,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssEnumObject methods */
    STDMETHOD_(HRESULT,Next)(THIS_ ULONG celt,VSS_OBJECT_PROP *rgelt,ULONG *pceltFetched) PURE;
    STDMETHOD_(HRESULT,Skip)(THIS_ ULONG celt) PURE;
    STDMETHOD_(HRESULT,Reset)(THIS) PURE;
    STDMETHOD_(HRESULT,Clone)(THIS_ IVssEnumObject **ppEnum) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssEnumObject_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssEnumObject_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssEnumObject_Release(This) (This)->lpVtbl->Release(This)
#define IVssEnumObject_Next(This,celt,rgelt,pceltFetched) (This)->lpVtbl->Next(This,celt,rgelt,pceltFetched)
#define IVssEnumObject_Skip(This,celt) (This)->lpVtbl->Skip(This,celt)
#define IVssEnumObject_Reset() (This)->lpVtbl->Reset(This)
#define IVssEnumObject_Clone(This,ppEnum) (This)->lpVtbl->Clone(This,ppEnum)
#endif /*COBJMACROS*/

#include <vswriter.h>
#include <vsbackup.h>

#endif /*_INC_VSS*/
                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/mingw-w64/include/vsstyle.h                                                               0100644 0000000 0000000 00000123300 12404413016 016216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 This Software is provided under the Zope Public License (ZPL) Version 2.1.

 Copyright (C) 2011 Piotr Caban for CodeWeavers

 See the AUTHORS file for the list of contributors to the mingw-w64 project.

 This license has been certified as open source. It has also been designated
 as GPL compatible by the Free Software Foundation (FSF).

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

   1. Redistributions in source code must retain the accompanying copyright
      notice, this list of conditions, and the following disclaimer.
   2. Redistributions in binary form must reproduce the accompanying
      copyright notice, this list of conditions, and the following disclaimer
      in the documentation and/or other materials provided with the
      distribution.
   3. Names of the copyright holders must not be used to endorse or promote
      products derived from this software without prior written permission
      from the copyright holders.
   4. The right to distribute this software or to use it for any purpose does
      not give you the right to use Servicemarks (sm) or Trademarks (tm) of
      the copyright holders.  Use of them is covered by separate agreement
      with the copyright holders.
   5. If any files are modified, you must cause the modified files to carry
      prominent notices stating that you changed the files and the date of
      any change.

 Disclaimer

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY EXPRESSED
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef __VSSTYLE_H__
#define __VSSTYLE_H__


#define TMTVS_RESERVEDLOW 100000
#define TMTVS_RESERVEDHIGH 19999

/* AEROWIZARDSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_AEROWIZARDSTYLE (const WCHAR []){'A','E','R','O','W','I','Z','A','R','D','S','T','Y','L','E',0}
#define VSCLASS_AEROWIZARD (const WCHAR []){'A','E','R','O','W','I','Z','A','R','D',0}
#elif defined(_MSC_VER)
#define VSCLASS_AEROWIZARDSTYLE L"AEROWIZARDSTYLE"
#define VSCLASS_AEROWIZARD L"AEROWIZARD"
#else
static const WCHAR VSCLASS_AEROWIZARDSTYLE[] = {'A','E','R','O','W','I','Z','A','R','D','S','T','Y','L','E',0};
static const WCHAR VSCLASS_AEROWIZARD [] = {'A','E','R','O','W','I','Z','A','R','D',0};
#endif

enum AEROWIZARDPARTS {
    AW_TITLEBAR = 1,
    AW_HEADERAREA = 2,
    AW_CONTENTAREA = 3,
    AW_COMMANDAREA = 4,
    AW_BUTTON = 5,
};

#define AEROWIZARDSTYLEPARTS AEROWIZARDPARTS;

enum TITLEBARSTATES {
    AW_S_TITLEBAR_ACTIVE = 1,
    AW_S_TITLEBAR_INACTIVE = 2,
};

enum HEADERAREASTATES {
    AW_S_HEADERAREA_NOMARGIN = 1,
};

enum CONTENTAREASTATES {
    AW_S_CONTENTAREA_NOMARGIN = 1,
};

/* BUTTONSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_BUTTONSTYLE (const WCHAR []){'B','U','T','T','O','N','S','T','Y','L','E',0}
#define VSCLASS_BUTTON (const WCHAR []){'B','U','T','T','O','N',0}
#elif defined(_MSC_VER)
#define VSCLASS_BUTTONSTYLE L"BUTTONSTYLE"
#define VSCLASS_BUTTON L"BUTTON"
#else
static const WCHAR VSCLASS_BUTTONSTYLE [] = {'B','U','T','T','O','N','S','T','Y','L','E',0};
static const WCHAR VSCLASS_BUTTON [] = {'B','U','T','T','O','N',0};
#endif

enum BUTTONPARTS {
    BP_PUSHBUTTON = 1,
    BP_RADIOBUTTON = 2,
    BP_CHECKBOX = 3,
    BP_GROUPBOX = 4,
    BP_USERBUTTON = 5,
    BP_COMMANDLINK = 6,
    BP_COMMANDLINKGLYPH = 7,
};

#define BUTTONSTYLEPARTS BUTTONPARTS;

enum PUSHBUTTONSTATES {
    PBS_NORMAL = 1,
    PBS_HOT = 2,
    PBS_PRESSED = 3,
    PBS_DISABLED = 4,
    PBS_DEFAULTED = 5,
    PBS_DEFAULTED_ANIMATING = 6,
};

enum RADIOBUTTONSTATES {
    RBS_UNCHECKEDNORMAL = 1,
    RBS_UNCHECKEDHOT = 2,
    RBS_UNCHECKEDPRESSED = 3,
    RBS_UNCHECKEDDISABLED = 4,
    RBS_CHECKEDNORMAL = 5,
    RBS_CHECKEDHOT = 6,
    RBS_CHECKEDPRESSED = 7,
    RBS_CHECKEDDISABLED = 8,
};

enum CHECKBOXSTATES {
    CBS_UNCHECKEDNORMAL = 1,
    CBS_UNCHECKEDHOT = 2,
    CBS_UNCHECKEDPRESSED = 3,
    CBS_UNCHECKEDDISABLED = 4,
    CBS_CHECKEDNORMAL = 5,
    CBS_CHECKEDHOT = 6,
    CBS_CHECKEDPRESSED = 7,
    CBS_CHECKEDDISABLED = 8,
    CBS_MIXEDNORMAL = 9,
    CBS_MIXEDHOT = 10,
    CBS_MIXEDPRESSED = 11,
    CBS_MIXEDDISABLED = 12,
    CBS_IMPLICITNORMAL = 13,
    CBS_IMPLICITHOT = 14,
    CBS_IMPLICITPRESSED = 15,
    CBS_IMPLICITDISABLED = 16,
    CBS_EXCLUDEDNORMAL = 17,
    CBS_EXCLUDEDHOT = 18,
    CBS_EXCLUDEDPRESSED = 19,
    CBS_EXCLUDEDDISABLED = 20,
};

enum GROUPBOXSTATES {
    GBS_NORMAL = 1,
    GBS_DISABLED = 2,
};

enum COMMANDLINKSTATES {
    CMDLS_NORMAL = 1,
    CMDLS_HOT = 2,
    CMDLS_PRESSED = 3,
    CMDLS_DISABLED = 4,
    CMDLS_DEFAULTED = 5,
    CMDLS_DEFAULTED_ANIMATING = 6,
};

enum COMMANDLINKGLYPHSTATES {
    CMDLGS_NORMAL = 1,
    CMDLGS_HOT = 2,
    CMDLGS_PRESSED = 3,
    CMDLGS_DISABLED = 4,
    CMDLGS_DEFAULTED = 5,
};

/* COMBOBOXSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_COMBOBOXSTYLE (const WCHAR []){'C','O','M','B','O','B','O','X','S','T','Y','L','E',0}
#define VSCLASS_COMBOBOX (const WCHAR []){'C','O','M','B','O','B','O','X',0}
#elif defined(_MSC_VER)
#define VSCLASS_COMBOBOXSTYLE L"COMBOBOXSTYLE"
#define VSCLASS_COMBOBOX L"COMBOBOX"
#else
static const WCHAR VSCLASS_COMBOBOXSTYLE [] = {'C','O','M','B','O','B','O','X','S','T','Y','L','E',0};
static const WCHAR VSCLASS_COMBOBOX [] = {'C','O','M','B','O','B','O','X',0};
#endif

enum COMBOBOXPARTS {
    CP_DROPDOWNBUTTON = 1,
    CP_BACKGROUND = 2,
    CP_TRANSPARENTBACKGROUND = 3,
    CP_BORDER = 4,
    CP_READONLY = 5,
    CP_DROPDOWNBUTTONRIGHT = 6,
    CP_DROPDOWNBUTTONLEFT = 7,
    CP_CUEBANNER = 8,
};

#define COMBOBOXSTYLEPARTS COMBOBOXPARTS;

enum COMBOBOXSTYLESTATES {
    CBXS_NORMAL = 1,
    CBXS_HOT = 2,
    CBXS_PRESSED = 3,
    CBXS_DISABLED = 4,
};

enum DROPDOWNBUTTONRIGHTSTATES {
    CBXSR_NORMAL = 1,
    CBXSR_HOT = 2,
    CBXSR_PRESSED = 3,
    CBXSR_DISABLED = 4,
};

enum DROPDOWNBUTTONLEFTSTATES {
    CBXSL_NORMAL = 1,
    CBXSL_HOT = 2,
    CBXSL_PRESSED = 3,
    CBXSL_DISABLED = 4,
};

enum TRANSPARENTBACKGROUNDSTATES {
    CBTBS_NORMAL = 1,
    CBTBS_HOT = 2,
    CBTBS_DISABLED = 3,
    CBTBS_FOCUSED = 4,
};

enum BORDERSTATES {
    CBB_NORMAL = 1,
    CBB_HOT = 2,
    CBB_FOCUSED = 3,
    CBB_DISABLED = 4,
};

enum READONLYSTATES {
    CBRO_NORMAL = 1,
    CBRO_HOT = 2,
    CBRO_PRESSED = 3,
    CBRO_DISABLED = 4,
};

enum CUEBANNERSTATES {
    CBCB_NORMAL = 1,
    CBCB_HOT = 2,
    CBCB_PRESSED = 3,
    CBCB_DISABLED = 4,
};

/* COMMUNICATIONSSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_COMMUNICATIONSSTYLE (const WCHAR []){'C','O','M','M','U','N','I','C','A','T','I','O','N','S','S','T','Y','L','E',0}
#define VSCLASS_COMMUNICATIONS (const WCHAR []){'C','O','M','M','U','N','I','C','A','T','I','O','N','S',0}
#elif defined(_MSC_VER)
#define VSCLASS_COMMUNICATIONSSTYLE L"COMMUNICATIONSSTYLE"
#define VSCLASS_COMMUNICATIONS L"COMMUNICATIONS"
#else
static const WCHAR VSCLASS_COMMUNICATIONSSTYLE [] = {'C','O','M','M','U','N','I','C','A','T','I','O','N','S','S','T','Y','L','E',0};
static const WCHAR VSCLASS_COMMUNICATIONS [] = {'C','O','M','M','U','N','I','C','A','T','I','O','N','S',0};
#endif

enum COMMUNICATIONSPARTS {
    CSST_TAB = 1,
};

#define COMMUNICATIONSSTYLEPARTS COMMUNICATIONSPARTS;

enum TABSTATES {
    CSTB_NORMAL = 1,
    CSTB_HOT = 2,
    CSTB_SELECTED = 3,
};

/* CONTROLPANELSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_CONTROLPANELSTYLE (const WCHAR []){'C','O','N','T','R','O','L','P','A','N','E','L','S','T','Y','L','E',0}
#define VSCLASS_CONTROLPANEL (const WCHAR []){'C','O','N','T','R','O','L','P','A','N','E','L',0}
#elif defined(_MSC_VER)
#define VSCLASS_CONTROLPANELSTYLE L"CONTROLPANELSTYLE"
#define VSCLASS_CONTROLPANEL L"CONTROLPANEL"
#else
static const WCHAR VSCLASS_CONTROLPANELSTYLE [] = {'C','O','N','T','R','O','L','P','A','N','E','L','S','T','Y','L','E',0};
static const WCHAR VSCLASS_CONTROLPANEL [] = {'C','O','N','T','R','O','L','P','A','N','E','L',0};
#endif

enum CONTROLPANELPARTS {
    CPANEL_NAVIGATIONPANE = 1,
    CPANEL_CONTENTPANE = 2,
    CPANEL_NAVIGATIONPANELABEL = 3,
    CPANEL_CONTENTPANELABEL = 4,
    CPANEL_TITLE = 5,
    CPANEL_BODYTEXT = 6,
    CPANEL_HELPLINK = 7,
    CPANEL_TASKLINK = 8,
    CPANEL_GROUPTEXT = 9,
    CPANEL_CONTENTLINK = 10,
    CPANEL_SECTIONTITLELINK = 11,
    CPANEL_LARGECOMMANDAREA = 12,
    CPANEL_SMALLCOMMANDAREA = 13,
    CPANEL_BUTTON = 14,
    CPANEL_MESSAGETEXT = 15,
    CPANEL_NAVIGATIONPANELINE = 16,
    CPANEL_CONTENTPANELINE = 17,
    CPANEL_BANNERAREA = 18,
    CPANEL_BODYTITLE = 19,
};

#define CONTROLPANELSTYLEPARTS CONTROLPANELPARTS;

enum HELPLINKSTATES {
    CPHL_NORMAL = 1,
    CPHL_HOT = 2,
    CPHL_PRESSED = 3,
    CPHL_DISABLED = 4,
};

enum TASKLINKSTATES {
    CPTL_NORMAL = 1,
    CPTL_HOT = 2,
    CPTL_PRESSED = 3,
    CPTL_DISABLED = 4,
    CPTL_PAGE = 5,
};

enum CONTENTLINKSTATES {
    CPCL_NORMAL = 1,
    CPCL_HOT = 2,
    CPCL_PRESSED = 3,
    CPCL_DISABLED = 4,
};

enum SECTIONTITLELINKSTATES {
    CPSTL_NORMAL = 1,
    CPSTL_HOT = 2,
};

/* DATEPICKERSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_DATEPICKERSTYLE (const WCHAR []){'D','A','T','E','P','I','C','K','E','R','S','T','Y','L','E',0}
#define VSCLASS_DATEPICKER (const WCHAR []){'D','A','T','E','P','I','C','K','E','R',0}
#elif defined(_MSC_VER)
#define VSCLASS_DATEPICKERSTYLE L"DATEPICKERSTYLE"
#define VSCLASS_DATEPICKER L"DATEPICKER"
#else
static const WCHAR VSCLASS_DATEPICKERSTYLE[] = {'D','A','T','E','P','I','C','K','E','R','S','T','Y','L','E',0};
static const WCHAR VSCLASS_DATEPICKER [] = {'D','A','T','E','P','I','C','K','E','R',0};
#endif

enum DATEPICKERPARTS {
    DP_DATETEXT = 1,
    DP_DATEBORDER = 2,
    DP_SHOWCALENDARBUTTONRIGHT = 3,
};

#define DATEPICKERSTYLEPARTS DATEPICKERPARTS;

enum DATETEXTSTATES {
    DPDT_NORMAL = 1,
    DPDT_DISABLED = 2,
    DPDT_SELECTED = 3,
};

enum DATEBORDERSTATES {
    DPDB_NORMAL = 1,
    DPDB_HOT = 2,
    DPDB_FOCUSED = 3,
    DPDB_DISABLED = 4,
};

enum SHOWCALENDARBUTTONRIGHTSTATES {
    DPSCBR_NORMAL = 1,
    DPSCBR_HOT = 2,
    DPSCBR_PRESSED = 3,
    DPSCBR_DISABLED = 4,
};

/* DRAGDROPSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_DRAGDROPSTYLE (const WCHAR []){'D','R','A','G','D','R','O','P','S','T','Y','L','E',0}
#define VSCLASS_DRAGDROP (const WCHAR []){'D','R','A','G','D','R','O','P',0}
#elif defined(_MSC_VER)
#define VSCLASS_DRAGDROPSTYLE L"DRAGDROPSTYLE"
#define VSCLASS_DRAGDROP L"DRAGDROP"
#else
static const WCHAR VSCLASS_DRAGDROPSTYLE [] = {'D','R','A','G','D','R','O','P','S','T','Y','L','E',0};
static const WCHAR VSCLASS_DRAGDROP [] = {'D','R','A','G','D','R','O','P',0};
#endif

enum DRAGDROPPARTS {
    DD_COPY = 1,
    DD_MOVE = 2,
    DD_UPDATEMETADATA = 3,
    DD_CREATELINK = 4,
    DD_WARNING = 5,
    DD_NONE = 6,
    DD_IMAGEBG = 7,
    DD_TEXTBG = 8,
};

#define DRAGDROPSTYLEPARTS DRAGDROPPARTS;

enum COPYSTATES {
    DDCOPY_HIGHLIGHT = 1,
    DDCOPY_NOHIGHLIGHT = 2,
};

enum MOVESTATES {
    DDMOVE_HIGHLIGHT = 1,
    DDMOVE_NOHIGHLIGHT = 2,
};

enum UPDATEMETADATASTATES {
    DDUPDATEMETADATA_HIGHLIGHT = 1,
    DDUPDATEMETADATA_NOHIGHLIGHT = 2,
};

enum CREATELINKSTATES {
    DDCREATELINK_HIGHLIGHT = 1,
    DDCREATELINK_NOHIGHLIGHT = 2,
};

enum WARNINGSTATES {
    DDWARNING_HIGHLIGHT = 1,
    DDWARNING_NOHIGHLIGHT = 2,
};

enum NONESTATES {
    DDNONE_HIGHLIGHT = 1,
    DDNONE_NOHIGHLIGHT = 2,
};

/* EDITSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_EDITSTYLE (const WCHAR []){'E','D','I','T','S','T','Y','L','E',0}
#define VSCLASS_EDIT (const WCHAR []){'E','D','I','T',0}
#elif defined(_MSC_VER)
#define VSCLASS_EDITSTYLE L"EDITSTYLE"
#define VSCLASS_EDIT L"EDIT"
#else
static const WCHAR VSCLASS_EDITSTYLE [] = {'E','D','I','T','S','T','Y','L','E',0};
static const WCHAR VSCLASS_EDIT [] = {'E','D','I','T',0};
#endif

enum EDITPARTS {
    EP_EDITTEXT = 1,
    EP_CARET = 2,
    EP_BACKGROUND = 3,
    EP_PASSWORD = 4,
    EP_BACKGROUNDWITHBORDER = 5,
    EP_EDITBORDER_NOSCROLL = 6,
    EP_EDITBORDER_HSCROLL = 7,
    EP_EDITBORDER_VSCROLL = 8,
    EP_EDITBORDER_HVSCROLL = 9,
};

#define EDITSTYLEPARTS EDITPARTS;

enum EDITTEXTSTATES {
    ETS_NORMAL = 1,
    ETS_HOT = 2,
    ETS_SELECTED = 3,
    ETS_DISABLED = 4,
    ETS_FOCUSED = 5,
    ETS_READONLY = 6,
    ETS_ASSIST = 7,
    ETS_CUEBANNER = 8,
};

enum BACKGROUNDSTATES {
    EBS_NORMAL = 1,
    EBS_HOT = 2,
    EBS_DISABLED = 3,
    EBS_FOCUSED = 4,
    EBS_READONLY = 5,
    EBS_ASSIST = 6,
};

enum BACKGROUNDWITHBORDERSTATES {
    EBWBS_NORMAL = 1,
    EBWBS_HOT = 2,
    EBWBS_DISABLED = 3,
    EBWBS_FOCUSED = 4,
};

enum EDITBORDER_NOSCROLLSTATES {
    EPSN_NORMAL = 1,
    EPSN_HOT = 2,
    EPSN_FOCUSED = 3,
    EPSN_DISABLED = 4,
};

enum EDITBORDER_HSCROLLSTATES {
    EPSH_NORMAL = 1,
    EPSH_HOT = 2,
    EPSH_FOCUSED = 3,
    EPSH_DISABLED = 4,
};

enum EDITBORDER_VSCROLLSTATES {
    EPSV_NORMAL = 1,
    EPSV_HOT = 2,
    EPSV_FOCUSED = 3,
    EPSV_DISABLED = 4,
};

enum EDITBORDER_HVSCROLLSTATES {
    EPSHV_NORMAL = 1,
    EPSHV_HOT = 2,
    EPSHV_FOCUSED = 3,
    EPSHV_DISABLED = 4,
};

/* EXPLORERBARSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_EXPLORERBARSTYLE (const WCHAR []){'E','X','P','L','O','R','E','R','B','A','R','S','T','Y','L','E',0}
#define VSCLASS_EXPLORERBAR (const WCHAR []){'E','X','P','L','O','R','E','R','B','A','R',0}
#elif defined(_MSC_VER)
#define VSCLASS_EXPLORERBARSTYLE L"EXPLORERBARSTYLE"
#define VSCLASS_EXPLORERBAR L"EXPLORERBAR"
#else
static const WCHAR VSCLASS_EXPLORERBARSTYLE [] = {'E','X','P','L','O','R','E','R','B','A','R','S','T','Y','L','E',0};
static const WCHAR VSCLASS_EXPLORERBAR [] = {'E','X','P','L','O','R','E','R','B','A','R',0};
#endif

enum EXPLORERBARPARTS {
    EBP_HEADERBACKGROUND = 1,
    EBP_HEADERCLOSE = 2,
    EBP_HEADERPIN = 3,
    EBP_IEBARMENU = 4,
    EBP_NORMALGROUPBACKGROUND = 5,
    EBP_NORMALGROUPCOLLAPSE = 6,
    EBP_NORMALGROUPEXPAND = 7,
    EBP_NORMALGROUPHEAD = 8,
    EBP_SPECIALGROUPBACKGROUND = 9,
    EBP_SPECIALGROUPCOLLAPSE = 10,
    EBP_SPECIALGROUPEXPAND = 11,
    EBP_SPECIALGROUPHEAD = 12,
};

#define EXPLORERBARSTYLEPARTS EXPLORERBARPARTS;

enum HEADERCLOSESTATES {
    EBHC_NORMAL = 1,
    EBHC_HOT = 2,
    EBHC_PRESSED = 3,
};

enum HEADERPINSTATES {
    EBHP_NORMAL = 1,
    EBHP_HOT = 2,
    EBHP_PRESSED = 3,
    EBHP_SELECTEDNORMAL = 4,
    EBHP_SELECTEDHOT = 5,
    EBHP_SELECTEDPRESSED = 6,
};

enum IEBARMENUSTATES {
    EBM_NORMAL = 1,
    EBM_HOT = 2,
    EBM_PRESSED = 3,
};

enum NORMALGROUPCOLLAPSESTATES {
    EBNGC_NORMAL = 1,
    EBNGC_HOT = 2,
    EBNGC_PRESSED = 3,
};

enum NORMALGROUPEXPANDSTATES {
    EBNGE_NORMAL = 1,
    EBNGE_HOT = 2,
    EBNGE_PRESSED = 3,
};

enum SPECIALGROUPCOLLAPSESTATES {
    EBSGC_NORMAL = 1,
    EBSGC_HOT = 2,
    EBSGC_PRESSED = 3,
};

enum SPECIALGROUPEXPANDSTATES {
    EBSGE_NORMAL = 1,
    EBSGE_HOT = 2,
    EBSGE_PRESSED = 3,
};

/* FLYOUTSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_FLYOUTSTYLE (const WCHAR []){'F','L','Y','O','U','T','S','T','Y','L','E',0}
#define VSCLASS_FLYOUT (const WCHAR []){'F','L','Y','O','U','T',0}
#elif defined(_MSC_VER)
#define VSCLASS_FLYOUTSTYLE L"FLYOUTSTYLE"
#define VSCLASS_FLYOUT L"FLYOUT"
#else
static const WCHAR VSCLASS_FLYOUTSTYLE [] = {'F','L','Y','O','U','T','S','T','Y','L','E',0};
static const WCHAR VSCLASS_FLYOUT [] = {'F','L','Y','O','U','T',0};
#endif

enum FLYOUTPARTS {
    FLYOUT_HEADER = 1,
    FLYOUT_BODY = 2,
    FLYOUT_LABEL = 3,
    FLYOUT_LINK = 4,
    FLYOUT_DIVIDER = 5,
    FLYOUT_WINDOW = 6,
    FLYOUT_LINKAREA = 7,
    FLYOUT_LINKHEADER = 8,
};

#define FLYOUTSTYLEPARTS FLYOUTPARTS;

enum LABELSTATES {
    FLS_NORMAL = 1,
    FLS_SELECTED = 2,
    FLS_EMPHASIZED = 3,
    FLS_DISABLED = 4,
};

enum LINKSTATES {
    FLYOUTLINK_NORMAL = 1,
    FLYOUTLINK_HOVER = 2,
};

enum BODYSTATES {
    FBS_NORMAL = 1,
    FBS_EMPHASIZED = 2,
};

enum LINKHEADERSTATES {
    FLH_NORMAL = 1,
    FLH_HOVER = 2,
};

/* HEADERSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_HEADERSTYLE (const WCHAR []){'H','E','A','D','E','R','S','T','Y','L','E',0}
#define VSCLASS_HEADER (const WCHAR []){'H','E','A','D','E','R',0}
#elif defined(_MSC_VER)
#define VSCLASS_HEADERSTYLE L"HEADERSTYLE"
#define VSCLASS_HEADER L"HEADER"
#else
static const WCHAR VSCLASS_HEADERSTYLE [] = {'H','E','A','D','E','R','S','T','Y','L','E',0};
static const WCHAR VSCLASS_HEADER [] = {'H','E','A','D','E','R',0};
#endif

enum HEADERPARTS {
    HP_HEADERITEM = 1,
    HP_HEADERITEMLEFT = 2,
    HP_HEADERITEMRIGHT = 3,
    HP_HEADERSORTARROW = 4,
    HP_HEADERDROPDOWN = 5,
    HP_HEADERDROPDOWNFILTER = 6,
    HP_HEADEROVERFLOW = 7,
};

#define HEADERSTYLEPARTS HEADERPARTS;

enum HEADERSTYLESTATES {
    HBG_DETAILS = 1,
    HBG_ICON = 2,
};

enum HEADERITEMSTATES {
    HIS_NORMAL = 1,
    HIS_HOT = 2,
    HIS_PRESSED = 3,
    HIS_SORTEDNORMAL = 4,
    HIS_SORTEDHOT = 5,
    HIS_SORTEDPRESSED = 6,
    HIS_ICONNORMAL = 7,
    HIS_ICONHOT = 8,
    HIS_ICONPRESSED = 9,
    HIS_ICONSORTEDNORMAL = 10,
    HIS_ICONSORTEDHOT = 11,
    HIS_ICONSORTEDPRESSED = 12,
};

enum HEADERITEMLEFTSTATES {
    HILS_NORMAL = 1,
    HILS_HOT = 2,
    HILS_PRESSED = 3,
};

enum HEADERITEMRIGHTSTATES {
    HIRS_NORMAL = 1,
    HIRS_HOT = 2,
    HIRS_PRESSED = 3,
};

enum HEADERSORTARROWSTATES {
    HSAS_SORTEDUP = 1,
    HSAS_SORTEDDOWN = 2,
};

enum HEADERDROPDOWNSTATES {
    HDDS_NORMAL = 1,
    HDDS_SOFTHOT = 2,
    HDDS_HOT = 3,
};

enum HEADERDROPDOWNFILTERSTATES {
    HDDFS_NORMAL = 1,
    HDDFS_SOFTHOT = 2,
    HDDFS_HOT = 3,
};

enum HEADEROVERFLOWSTATES {
    HOFS_NORMAL = 1,
    HOFS_HOT = 2,
};

/* LISTBOXSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_LISTBOXSTYLE (const WCHAR []){'L','I','S','T','B','O','X','S','T','Y','L','E',0}
#define VSCLASS_LISTBOX (const WCHAR []){'L','I','S','T','B','O','X',0}
#elif defined(_MSC_VER)
#define VSCLASS_LISTBOXSTYLE L"LISTBOXSTYLE"
#define VSCLASS_LISTBOX L"LISTBOX"
#else
static const WCHAR VSCLASS_LISTBOXSTYLE [] = {'L','I','S','T','B','O','X','S','T','Y','L','E',0};
static const WCHAR VSCLASS_LISTBOX[] = {'L','I','S','T','B','O','X',0};
#endif

enum LISTBOXPARTS {
    LBCP_BORDER_HSCROLL = 1,
    LBCP_BORDER_HVSCROLL = 2,
    LBCP_BORDER_NOSCROLL = 3,
    LBCP_BORDER_VSCROLL = 4,
    LBCP_ITEM = 5,
};

#define LISTBOXSTYLEPARTS LISTBOXPARTS;

enum BORDER_HSCROLLSTATES {
    LBPSH_NORMAL = 1,
    LBPSH_FOCUSED = 2,
    LBPSH_HOT = 3,
    LBPSH_DISABLED = 4,
};

enum BORDER_HVSCROLLSTATES {
    LBPSHV_NORMAL = 1,
    LBPSHV_FOCUSED = 2,
    LBPSHV_HOT = 3,
    LBPSHV_DISABLED = 4,
};

enum BORDER_NOSCROLLSTATES {
    LBPSN_NORMAL = 1,
    LBPSN_FOCUSED = 2,
    LBPSN_HOT = 3,
    LBPSN_DISABLED = 4,
};

enum BORDER_VSCROLLSTATES {
    LBPSV_NORMAL = 1,
    LBPSV_FOCUSED = 2,
    LBPSV_HOT = 3,
    LBPSV_DISABLED = 4,
};

enum ITEMSTATES {
    LBPSI_HOT = 1,
    LBPSI_HOTSELECTED = 2,
    LBPSI_SELECTED = 3,
    LBPSI_SELECTEDNOTFOCUS = 4,
};

/* LISTVIEWSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_LISTVIEWSTYLE (const WCHAR []){'L','I','S','T','V','I','E','W','S','T','Y','L','E',0}
#define VSCLASS_LISTVIEW (const WCHAR []){'L','I','S','T','V','I','E','W',0}
#elif defined(_MSC_VER)
#define VSCLASS_LISTVIEWSTYLE L"LISTVIEWSTYLE"
#define VSCLASS_LISTVIEW L"LISTVIEW"
#else
static const WCHAR VSCLASS_LISTVIEWSTYLE [] = {'L','I','S','T','V','I','E','W','S','T','Y','L','E',0};
static const WCHAR VSCLASS_LISTVIEW [] = {'L','I','S','T','V','I','E','W',0};
#endif

enum LISTVIEWPARTS {
    LVP_LISTITEM = 1,
    LVP_LISTGROUP = 2,
    LVP_LISTDETAIL = 3,
    LVP_LISTSORTEDDETAIL = 4,
    LVP_EMPTYTEXT = 5,
    LVP_GROUPHEADER = 6,
    LVP_GROUPHEADERLINE = 7,
    LVP_EXPANDBUTTON = 8,
    LVP_COLLAPSEBUTTON = 9,
    LVP_COLUMNDETAIL = 10,
};

#define LISTVIEWSTYLEPARTS LISTVIEWPARTS;

enum LISTITEMSTATES {
    LISS_NORMAL = 1,
    LISS_HOT = 2,
    LISS_SELECTED = 3,
    LISS_DISABLED = 4,
    LISS_SELECTEDNOTFOCUS = 5,
    LISS_HOTSELECTED = 6,
};

enum GROUPHEADERSTATES {
    LVGH_OPEN = 1,
    LVGH_OPENHOT = 2,
    LVGH_OPENSELECTED = 3,
    LVGH_OPENSELECTEDHOT = 4,
    LVGH_OPENSELECTEDNOTFOCUSED = 5,
    LVGH_OPENSELECTEDNOTFOCUSEDHOT = 6,
    LVGH_OPENMIXEDSELECTION = 7,
    LVGH_OPENMIXEDSELECTIONHOT = 8,
    LVGH_CLOSE = 9,
    LVGH_CLOSEHOT = 10,
    LVGH_CLOSESELECTED = 11,
    LVGH_CLOSESELECTEDHOT = 12,
    LVGH_CLOSESELECTEDNOTFOCUSED = 13,
    LVGH_CLOSESELECTEDNOTFOCUSEDHOT = 14,
    LVGH_CLOSEMIXEDSELECTION = 15,
    LVGH_CLOSEMIXEDSELECTIONHOT = 16,
};

enum GROUPHEADERLINESTATES {
    LVGHL_OPEN = 1,
    LVGHL_OPENHOT = 2,
    LVGHL_OPENSELECTED = 3,
    LVGHL_OPENSELECTEDHOT = 4,
    LVGHL_OPENSELECTEDNOTFOCUSED = 5,
    LVGHL_OPENSELECTEDNOTFOCUSEDHOT = 6,
    LVGHL_OPENMIXEDSELECTION = 7,
    LVGHL_OPENMIXEDSELECTIONHOT = 8,
    LVGHL_CLOSE = 9,
    LVGHL_CLOSEHOT = 10,
    LVGHL_CLOSESELECTED = 11,
    LVGHL_CLOSESELECTEDHOT = 12,
    LVGHL_CLOSESELECTEDNOTFOCUSED = 13,
    LVGHL_CLOSESELECTEDNOTFOCUSEDHOT = 14,
    LVGHL_CLOSEMIXEDSELECTION = 15,
    LVGHL_CLOSEMIXEDSELECTIONHOT = 16,
};

enum EXPANDBUTTONSTATES {
    LVEB_NORMAL = 1,
    LVEB_HOVER = 2,
    LVEB_PUSHED = 3,
};

enum COLLAPSEBUTTONSTATES {
    LVCB_NORMAL = 1,
    LVCB_HOVER = 2,
    LVCB_PUSHED = 3,
};

/* MENUSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_MENUSTYLE (const WCHAR []){'M','E','N','U','S','T','Y','L','E',0}
#define VSCLASS_MENU (const WCHAR []){'M','E','N','U',0}
#elif defined(_MSC_VER)
#define VSCLASS_MENUSTYLE L"MENUSTYLE"
#define VSCLASS_MENU L"MENU"
#else
static const WCHAR VSCLASS_MENUSTYLE [] = {'M','E','N','U','S','T','Y','L','E',0};
static const WCHAR VSCLASS_MENU [] = {'M','E','N','U',0};
#endif

enum MENUPARTS {
    MENU_MENUITEM_TMSCHEMA = 1,
    MENU_MENUDROPDOWN_TMSCHEMA = 2,
    MENU_MENUBARITEM_TMSCHEMA = 3,
    MENU_MENUBARDROPDOWN_TMSCHEMA = 4,
    MENU_CHEVRON_TMSCHEMA = 5,
    MENU_SEPARATOR_TMSCHEMA = 6,
    MENU_BARBACKGROUND = 7,
    MENU_BARITEM = 8,
    MENU_POPUPBACKGROUND = 9,
    MENU_POPUPBORDERS = 10,
    MENU_POPUPCHECK = 11,
    MENU_POPUPCHECKBACKGROUND = 12,
    MENU_POPUPGUTTER = 13,
    MENU_POPUPITEM = 14,
    MENU_POPUPSEPARATOR = 15,
    MENU_POPUPSUBMENU = 16,
    MENU_SYSTEMCLOSE = 17,
    MENU_SYSTEMMAXIMIZE = 18,
    MENU_SYSTEMMINIMIZE = 19,
    MENU_SYSTEMRESTORE = 20,
};

#define MENUSTYLEPARTS MENUPARTS;

enum BARBACKGROUNDSTATES {
    MB_ACTIVE = 1,
    MB_INACTIVE = 2,
};

enum BARITEMSTATES {
    MBI_NORMAL = 1,
    MBI_HOT = 2,
    MBI_PUSHED = 3,
    MBI_DISABLED = 4,
    MBI_DISABLEDHOT = 5,
    MBI_DISABLEDPUSHED = 6,
};

enum POPUPCHECKSTATES {
    MC_CHECKMARKNORMAL = 1,
    MC_CHECKMARKDISABLED = 2,
    MC_BULLETNORMAL = 3,
    MC_BULLETDISABLED = 4,
};

enum POPUPCHECKBACKGROUNDSTATES {
    MCB_DISABLED = 1,
    MCB_NORMAL = 2,
    MCB_BITMAP = 3,
};

enum POPUPITEMSTATES {
    MPI_NORMAL = 1,
    MPI_HOT = 2,
    MPI_DISABLED = 3,
    MPI_DISABLEDHOT = 4,
};

enum POPUPSUBMENUSTATES {
    MSM_NORMAL = 1,
    MSM_DISABLED = 2,
};

enum SYSTEMCLOSESTATES {
    MSYSC_NORMAL = 1,
    MSYSC_DISABLED = 2,
};

enum SYSTEMMAXIMIZESTATES {
    MSYSMX_NORMAL = 1,
    MSYSMX_DISABLED = 2,
};

enum SYSTEMMINIMIZESTATES {
    MSYSMN_NORMAL = 1,
    MSYSMN_DISABLED = 2,
};

enum SYSTEMRESTORESTATES {
    MSYSR_NORMAL = 1,
    MSYSR_DISABLED = 2,
};

/* NAVIGATION class */
#if defined(__GNUC__)
#define VSCLASS_NAVIGATION (const WCHAR []){'N','A','V','I','G','A','T','I','O','N',0}
#elif defined(_MSC_VER)
#define VSCLASS_NAVIGATION L"NAVIGATION"
#else
static const WCHAR VSCLASS_NAVIGATION [] = {'N','A','V','I','G','A','T','I','O','N',0};
#endif

enum NAVIGATIONPARTS {
    NAV_BACKBUTTON = 1,
    NAV_FORWARDBUTTON = 2,
    NAV_MENUBUTTON = 3,
};

enum NAV_BACKBUTTONSTATES {
    NAV_BB_NORMAL = 1,
    NAV_BB_HOT = 2,
    NAV_BB_PRESSED = 3,
    NAV_BB_DISABLED = 4,
};

enum NAV_FORWARDBUTTONSTATES {
    NAV_FB_NORMAL = 1,
    NAV_FB_HOT = 2,
    NAV_FB_PRESSED = 3,
    NAV_FB_DISABLED = 4,
};

enum NAV_MENUBUTTONSTATES {
    NAV_MB_NORMAL = 1,
    NAV_MB_HOT = 2,
    NAV_MB_PRESSED = 3,
    NAV_MB_DISABLED = 4,
};

/* PROGRESSSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_PROGRESSSTYLE (const WCHAR []){'P','R','O','G','R','E','S','S','S','T','Y','L','E',0}
#define VSCLASS_PROGRESS (const WCHAR []){'P','R','O','G','R','E','S','S',0}
#elif defined(_MSC_VER)
#define VSCLASS_PROGRESSSTYLE L"PROGRESSSTYLE"
#define VSCLASS_PROGRESS L"PROGRESS"
#else
static const WCHAR VSCLASS_PROGRESSSTYLE [] = {'P','R','O','G','R','E','S','S','S','T','Y','L','E',0};
static const WCHAR VSCLASS_PROGRESS [] = {'P','R','O','G','R','E','S','S',0};
#endif

enum PROGRESSPARTS {
    PP_BAR = 1,
    PP_BARVERT = 2,
    PP_CHUNK = 3,
    PP_CHUNKVERT = 4,
    PP_FILL = 5,
    PP_FILLVERT = 6,
    PP_PULSEOVERLAY = 7,
    PP_MOVEOVERLAY = 8,
    PP_PULSEOVERLAYVERT = 9,
    PP_MOVEOVERLAYVERT = 10,
    PP_TRANSPARENTBAR = 11,
    PP_TRANSPARENTBARVERT = 12,
};

#define PROGRESSSTYLEPARTS PROGRESSPARTS;

enum TRANSPARENTBARSTATES {
    PBBS_NORMAL = 1,
    PBBS_PARTIAL = 2,
};

enum TRANSPARENTBARVERTSTATES {
    PBBVS_NORMAL = 1,
    PBBVS_PARTIAL = 2,
};

enum FILLSTATES {
    PBFS_NORMAL = 1,
    PBFS_ERROR = 2,
    PBFS_PAUSED = 3,
    PBFS_PARTIAL = 4,
};

enum FILLVERTSTATES {
    PBFVS_NORMAL = 1,
    PBFVS_ERROR = 2,
    PBFVS_PAUSED = 3,
    PBFVS_PARTIAL = 4,
};

/* REBARSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_REBARSTYLE (const WCHAR []){'R','E','B','A','R','S','T','Y','L','E',0}
#define VSCLASS_REBAR (const WCHAR []){'R','E','B','A','R',0}
#elif defined(_MSC_VER)
#define VSCLASS_REBARSTYLE L"REBARSTYLE"
#define VSCLASS_REBAR L"REBAR"
#else
static const WCHAR VSCLASS_REBARSTYLE [] = {'R','E','B','A','R','S','T','Y','L','E',0};
static const WCHAR VSCLASS_REBAR [] = {'R','E','B','A','R',0};
#endif

enum REBARPARTS {
    RP_GRIPPER = 1,
    RP_GRIPPERVERT = 2,
    RP_BAND = 3,
    RP_CHEVRON = 4,
    RP_CHEVRONVERT = 5,
    RP_BACKGROUND = 6,
    RP_SPLITTER = 7,
    RP_SPLITTERVERT = 8,
};

#define REBARSTYLEPARTS REBARPARTS;

enum CHEVRONSTATES {
    CHEVS_NORMAL = 1,
    CHEVS_HOT = 2,
    CHEVS_PRESSED = 3,
};

enum CHEVRONVERTSTATES {
    CHEVSV_NORMAL = 1,
    CHEVSV_HOT = 2,
    CHEVSV_PRESSED = 3,
};

enum SPLITTERSTATES {
    SPLITS_NORMAL = 1,
    SPLITS_HOT = 2,
    SPLITS_PRESSED = 3,
};

enum SPLITTERVERTSTATES {
    SPLITSV_NORMAL = 1,
    SPLITSV_HOT = 2,
    SPLITSV_PRESSED = 3,
};

/* SCROLLBARSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_SCROLLBARSTYLE (const WCHAR []){'S','C','R','O','L','L','B','A','R','S','T','Y','L','E',0}
#define VSCLASS_SCROLLBAR (const WCHAR []){'S','C','R','O','L','L','B','A','R',0}
#elif defined(_MSC_VER)
#define VSCLASS_SCROLLBARSTYLE L"SCROLLBARSTYLE"
#define VSCLASS_SCROLLBAR L"SCROLLBAR"
#else
static const WCHAR VSCLASS_SCROLLBARSTYLE [] = {'S','C','R','O','L','L','B','A','R','S','T','Y','L','E',0};
static const WCHAR VSCLASS_SCROLLBAR [] = {'S','C','R','O','L','L','B','A','R',0};
#endif

enum SCROLLBARPARTS {
    SBP_ARROWBTN = 1,
    SBP_THUMBBTNHORZ = 2,
    SBP_THUMBBTNVERT = 3,
    SBP_LOWERTRACKHORZ = 4,
    SBP_UPPERTRACKHORZ = 5,
    SBP_LOWERTRACKVERT = 6,
    SBP_UPPERTRACKVERT = 7,
    SBP_GRIPPERHORZ = 8,
    SBP_GRIPPERVERT = 9,
    SBP_SIZEBOX = 10,
};

#define SCROLLBARSTYLEPARTS SCROLLBARPARTS;

enum ARROWBTNSTATES {
    ABS_UPNORMAL = 1,
    ABS_UPHOT = 2,
    ABS_UPPRESSED = 3,
    ABS_UPDISABLED = 4,
    ABS_DOWNNORMAL = 5,
    ABS_DOWNHOT = 6,
    ABS_DOWNPRESSED = 7,
    ABS_DOWNDISABLED = 8,
    ABS_LEFTNORMAL = 9,
    ABS_LEFTHOT = 10,
    ABS_LEFTPRESSED = 11,
    ABS_LEFTDISABLED = 12,
    ABS_RIGHTNORMAL = 13,
    ABS_RIGHTHOT = 14,
    ABS_RIGHTPRESSED = 15,
    ABS_RIGHTDISABLED = 16,
    ABS_UPHOVER = 17,
    ABS_DOWNHOVER = 18,
    ABS_LEFTHOVER = 19,
    ABS_RIGHTHOVER = 20,
};

enum SCROLLBARSTYLESTATES {
    SCRBS_NORMAL = 1,
    SCRBS_HOT = 2,
    SCRBS_PRESSED = 3,
    SCRBS_DISABLED = 4,
    SCRBS_HOVER = 5,
};

enum SIZEBOXSTATES {
    SZB_RIGHTALIGN = 1,
    SZB_LEFTALIGN = 2,
    SZB_TOPRIGHTALIGN = 3,
    SZB_TOPLEFTALIGN = 4,
    SZB_HALFBOTTOMRIGHTALIGN = 5,
    SZB_HALFBOTTOMLEFTALIGN = 6,
    SZB_HALFTOPRIGHTALIGN = 7,
    SZB_HALFTOPLEFTALIGN = 8,
};

/* SPINSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_SPINSTYLE (const WCHAR []){'S','P','I','N','S','T','Y','L','E',0}
#elif defined(_MSC_VER)
#define VSCLASS_SPINSTYLE L"SPINSTYLE"
#else
static const WCHAR VSCLASS_SPINSTYLE [] = {'S','P','I','N','S','T','Y','L','E',0};
#endif
#if defined(__GNUC__)
#define VSCLASS_SPIN (const WCHAR []){'S','P','I','N',0}
#elif defined(_MSC_VER)
#define VSCLASS_SPIN L"SPIN"
#else
static const WCHAR VSCLASS_SPIN [] = {'S','P','I','N',0};
#endif

enum SPINPARTS {
    SPNP_UP = 1,
    SPNP_DOWN = 2,
    SPNP_UPHORZ = 3,
    SPNP_DOWNHORZ = 4,
};

#define SPINSTYLEPARTS SPINPARTS;

enum UPSTATES {
    UPS_NORMAL = 1,
    UPS_HOT = 2,
    UPS_PRESSED = 3,
    UPS_DISABLED = 4,
};

enum DOWNSTATES {
    DNS_NORMAL = 1,
    DNS_HOT = 2,
    DNS_PRESSED = 3,
    DNS_DISABLED = 4,
};

enum UPHORZSTATES {
    UPHZS_NORMAL = 1,
    UPHZS_HOT = 2,
    UPHZS_PRESSED = 3,
    UPHZS_DISABLED = 4,
};

enum DOWNHORZSTATES {
    DNHZS_NORMAL = 1,
    DNHZS_HOT = 2,
    DNHZS_PRESSED = 3,
    DNHZS_DISABLED = 4,
};

/* STATUSSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_STATUSSTYLE (const WCHAR []){'S','T','A','T','U','S','S','T','Y','L','E',0}
#define VSCLASS_STATUS (const WCHAR []){'S','T','A','T','U','S',0}
#elif defined(_MSC_VER)
#define VSCLASS_STATUSSTYLE L"STATUSSTYLE"
#define VSCLASS_STATUS L"STATUS"
#else
static const WCHAR VSCLASS_STATUSSTYLE [] = {'S','T','A','T','U','S','S','T','Y','L','E',0};
static const WCHAR VSCLASS_STATUS [] = {'S','T','A','T','U','S',0};
#endif

enum STATUSPARTS {
    SP_PANE = 1,
    SP_GRIPPERPANE = 2,
    SP_GRIPPER = 3,
};

#define STATUSSTYLEPARTS STATUSPARTS;

/* TABSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_TABSTYLE (const WCHAR []){'T','A','B','S','T','Y','L','E',0}
#define VSCLASS_TAB (const WCHAR []){'T','A','B',0}
#elif defined(_MSC_VER)
#define VSCLASS_TABSTYLE L"TABSTYLE"
#define VSCLASS_TAB L"TAB"
#else
static const WCHAR VSCLASS_TABSTYLE [] = {'T','A','B','S','T','Y','L','E',0};
static const WCHAR VSCLASS_TAB [] = {'T','A','B',0};
#endif

enum TABPARTS {
    TABP_TABITEM = 1,
    TABP_TABITEMLEFTEDGE = 2,
    TABP_TABITEMRIGHTEDGE = 3,
    TABP_TABITEMBOTHEDGE = 4,
    TABP_TOPTABITEM = 5,
    TABP_TOPTABITEMLEFTEDGE = 6,
    TABP_TOPTABITEMRIGHTEDGE = 7,
    TABP_TOPTABITEMBOTHEDGE = 8,
    TABP_PANE = 9,
    TABP_BODY = 10,
    TABP_AEROWIZARDBODY = 11,
};

#define TABSTYLEPARTS TABPARTS;

enum TABITEMSTATES {
    TIS_NORMAL = 1,
    TIS_HOT = 2,
    TIS_SELECTED = 3,
    TIS_DISABLED = 4,
    TIS_FOCUSED = 5,
};

enum TABITEMLEFTEDGESTATES {
    TILES_NORMAL = 1,
    TILES_HOT = 2,
    TILES_SELECTED = 3,
    TILES_DISABLED = 4,
    TILES_FOCUSED = 5,
};

enum TABITEMRIGHTEDGESTATES {
    TIRES_NORMAL = 1,
    TIRES_HOT = 2,
    TIRES_SELECTED = 3,
    TIRES_DISABLED = 4,
    TIRES_FOCUSED = 5,
};

enum TABITEMBOTHEDGESTATES {
    TIBES_NORMAL = 1,
    TIBES_HOT = 2,
    TIBES_SELECTED = 3,
    TIBES_DISABLED = 4,
    TIBES_FOCUSED = 5,
};

enum TOPTABITEMSTATES {
    TTIS_NORMAL = 1,
    TTIS_HOT = 2,
    TTIS_SELECTED = 3,
    TTIS_DISABLED = 4,
    TTIS_FOCUSED = 5,
};

enum TOPTABITEMLEFTEDGESTATES {
    TTILES_NORMAL = 1,
    TTILES_HOT = 2,
    TTILES_SELECTED = 3,
    TTILES_DISABLED = 4,
    TTILES_FOCUSED = 5,
};

enum TOPTABITEMRIGHTEDGESTATES {
    TTIRES_NORMAL = 1,
    TTIRES_HOT = 2,
    TTIRES_SELECTED = 3,
    TTIRES_DISABLED = 4,
    TTIRES_FOCUSED = 5,
};

enum TOPTABITEMBOTHEDGESTATES {
    TTIBES_NORMAL = 1,
    TTIBES_HOT = 2,
    TTIBES_SELECTED = 3,
    TTIBES_DISABLED = 4,
    TTIBES_FOCUSED = 5,
};

/* TASKDIALOGSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_TASKDIALOGSTYLE (const WCHAR []){'T','A','S','K','D','I','A','L','O','G','S','T','Y','L','E',0}
#define VSCLASS_TASKDIALOG (const WCHAR []){'T','A','S','K','D','I','A','L','O','G',0}
#elif defined(_MSC_VER)
#define VSCLASS_TASKDIALOGSTYLE L"TASKDIALOGSTYLE"
#define VSCLASS_TASKDIALOG L"TASKDIALOG"
#else
static const WCHAR VSCLASS_TASKDIALOGSTYLE[] = {'T','A','S','K','D','I','A','L','O','G','S','T','Y','L','E',0};
static const WCHAR VSCLASS_TASKDIALOG [] = {'T','A','S','K','D','I','A','L','O','G',0};
#endif

enum TASKDIALOGPARTS {
    TDLG_PRIMARYPANEL = 1,
    TDLG_MAININSTRUCTIONPANE = 2,
    TDLG_MAINICON = 3,
    TDLG_CONTENTPANE = 4,
    TDLG_CONTENTICON = 5,
    TDLG_EXPANDEDCONTENT = 6,
    TDLG_COMMANDLINKPANE = 7,
    TDLG_SECONDARYPANEL = 8,
    TDLG_CONTROLPANE = 9,
    TDLG_BUTTONSECTION = 10,
    TDLG_BUTTONWRAPPER = 11,
    TDLG_EXPANDOTEXT = 12,
    TDLG_EXPANDOBUTTON = 13,
    TDLG_VERIFICATIONTEXT = 14,
    TDLG_FOOTNOTEPANE = 15,
    TDLG_FOOTNOTEAREA = 16,
    TDLG_FOOTNOTESEPARATOR = 17,
    TDLG_EXPANDEDFOOTERAREA = 18,
    TDLG_PROGRESSBAR = 19,
    TDLG_IMAGEALIGNMENT = 20,
    TDLG_RADIOBUTTONPANE = 21,
};

#define TASKDIALOGSTYLEPARTS TASKDIALOGPARTS;

enum CONTENTPANESTATES {
    TDLGCPS_STANDALONE = 1,
};

enum EXPANDOBUTTONSTATES {
    TDLGEBS_NORMAL = 1,
    TDLGEBS_HOVER = 2,
    TDLGEBS_PRESSED = 3,
    TDLGEBS_EXPANDEDNORMAL = 4,
    TDLGEBS_EXPANDEDHOVER = 5,
    TDLGEBS_EXPANDEDPRESSED = 6,
};

/* TEXTSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_TEXTSTYLE (const WCHAR []){'T','E','X','T','S','T','Y','L','E',0}
#elif defined(_MSC_VER)
#define VSCLASS_TEXTSTYLE L"TEXTSTYLE"
#else
static const WCHAR VSCLASS_TEXTSTYLE [] = {'T','E','X','T','S','T','Y','L','E',0};
#endif

enum TEXTSTYLEPARTS {
    TEXT_MAININSTRUCTION = 1,
    TEXT_INSTRUCTION = 2,
    TEXT_BODYTITLE = 3,
    TEXT_BODYTEXT = 4,
    TEXT_SECONDARYTEXT = 5,
    TEXT_HYPERLINKTEXT = 6,
    TEXT_EXPANDED = 7,
    TEXT_LABEL = 8,
    TEXT_CONTROLLABEL = 9,
};

enum HYPERLINKTEXTSTATES {
    TS_HYPERLINK_NORMAL = 1,
    TS_HYPERLINK_HOT = 2,
    TS_HYPERLINK_PRESSED = 3,
    TS_HYPERLINK_DISABLED = 4,
};

enum CONTROLLABELSTATES {
    TS_CONTROLLABEL_NORMAL = 1,
    TS_CONTROLLABEL_DISABLED = 2,
};

/* TOOLBARSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_TOOLBARSTYLE (const WCHAR []){'T','O','O','L','B','A','R','S','T','Y','L','E',0}
#define VSCLASS_TOOLBAR (const WCHAR []){'T','O','O','L','B','A','R',0}
#elif defined(_MSC_VER)
#define VSCLASS_TOOLBARSTYLE L"TOOLBARSTYLE"
#define VSCLASS_TOOLBAR L"TOOLBAR"
#else
static const WCHAR VSCLASS_TOOLBARSTYLE [] = {'T','O','O','L','B','A','R','S','T','Y','L','E',0};
static const WCHAR VSCLASS_TOOLBAR[] = {'T','O','O','L','B','A','R',0};
#endif

enum TOOLBARPARTS {
    TP_BUTTON = 1,
    TP_DROPDOWNBUTTON = 2,
    TP_SPLITBUTTON = 3,
    TP_SPLITBUTTONDROPDOWN = 4,
    TP_SEPARATOR = 5,
    TP_SEPARATORVERT = 6,
    TP_DROPDOWNBUTTONGLYPH = 7,
};

#define TOOLBARSTYLEPARTS TOOLBARPARTS;

enum TOOLBARSTYLESTATES {
    TS_NORMAL = 1,
    TS_HOT = 2,
    TS_PRESSED = 3,
    TS_DISABLED = 4,
    TS_CHECKED = 5,
    TS_HOTCHECKED = 6,
    TS_NEARHOT = 7,
    TS_OTHERSIDEHOT = 8,
};

/* TOOLTIPSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_TOOLTIPSTYLE (const WCHAR []){'T','O','O','L','T','I','P','S','T','Y','L','E',0}
#define VSCLASS_TOOLTIP (const WCHAR []){'T','O','O','L','T','I','P',0}
#elif defined(_MSC_VER)
#define VSCLASS_TOOLTIPSTYLE L"TOOLTIPSTYLE"
#define VSCLASS_TOOLTIP L"TOOLTIP"
#else
static const WCHAR VSCLASS_TOOLTIPSTYLE [] = {'T','O','O','L','T','I','P','S','T','Y','L','E',0};
static const WCHAR VSCLASS_TOOLTIP[] = {'T','O','O','L','T','I','P',0};
#endif

enum TOOLTIPPARTS {
    TTP_STANDARD = 1,
    TTP_STANDARDTITLE = 2,
    TTP_BALLOON = 3,
    TTP_BALLOONTITLE = 4,
    TTP_CLOSE = 5,
    TTP_BALLOONSTEM = 6,
    TTP_WRENCH = 7,
};

#define TOOLTIPSTYLEPARTS TOOLTIPPARTS;

enum CLOSESTATES {
    TTCS_NORMAL = 1,
    TTCS_HOT = 2,
    TTCS_PRESSED = 3,
};

enum STANDARDSTATES {
    TTSS_NORMAL = 1,
    TTSS_LINK = 2,
};

enum BALLOONSTATES {
    TTBS_NORMAL = 1,
    TTBS_LINK = 2,
};

enum BALLOONSTEMSTATES {
    TTBSS_POINTINGUPLEFTWALL = 1,
    TTBSS_POINTINGUPCENTERED = 2,
    TTBSS_POINTINGUPRIGHTWALL = 3,
    TTBSS_POINTINGDOWNRIGHTWALL = 4,
    TTBSS_POINTINGDOWNCENTERED = 5,
    TTBSS_POINTINGDOWNLEFTWALL = 6,
};

enum WRENCHSTATES {
    TTWS_NORMAL = 1,
    TTWS_HOT = 2,
    TTWS_PRESSED = 3,
};

/* TRACKBARSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_TRACKBARSTYLE (const WCHAR []){'T','R','A','C','K','B','A','R','S','T','Y','L','E',0}
#define VSCLASS_TRACKBAR (const WCHAR []){'T','R','A','C','K','B','A','R',0}
#elif defined(_MSC_VER)
#define VSCLASS_TRACKBARSTYLE L"TRACKBARSTYLE"
#define VSCLASS_TRACKBAR L"TRACKBAR"
#else
static const WCHAR VSCLASS_TRACKBARSTYLE [] = {'T','R','A','C','K','B','A','R','S','T','Y','L','E',0};
static const WCHAR VSCLASS_TRACKBAR [] = {'T','R','A','C','K','B','A','R',0};
#endif

enum TRACKBARPARTS {
    TKP_TRACK = 1,
    TKP_TRACKVERT = 2,
    TKP_THUMB = 3,
    TKP_THUMBBOTTOM = 4,
    TKP_THUMBTOP = 5,
    TKP_THUMBVERT = 6,
    TKP_THUMBLEFT = 7,
    TKP_THUMBRIGHT = 8,
    TKP_TICS = 9,
    TKP_TICSVERT = 10,
};

#define TRACKBARSTYLEPARTS TRACKBARPARTS;

enum TRACKBARSTYLESTATES {
    TKS_NORMAL = 1,
};

enum TRACKSTATES {
    TRS_NORMAL = 1,
};

enum TRACKVERTSTATES {
    TRVS_NORMAL = 1,
};

enum THUMBSTATES {
    TUS_NORMAL = 1,
    TUS_HOT = 2,
    TUS_PRESSED = 3,
    TUS_FOCUSED = 4,
    TUS_DISABLED = 5,
};

enum THUMBBOTTOMSTATES {
    TUBS_NORMAL = 1,
    TUBS_HOT = 2,
    TUBS_PRESSED = 3,
    TUBS_FOCUSED = 4,
    TUBS_DISABLED = 5,
};

enum THUMBTOPSTATES {
    TUTS_NORMAL = 1,
    TUTS_HOT = 2,
    TUTS_PRESSED = 3,
    TUTS_FOCUSED = 4,
    TUTS_DISABLED = 5,
};

enum THUMBVERTSTATES {
    TUVS_NORMAL = 1,
    TUVS_HOT = 2,
    TUVS_PRESSED = 3,
    TUVS_FOCUSED = 4,
    TUVS_DISABLED = 5,
};

enum THUMBLEFTSTATES {
    TUVLS_NORMAL = 1,
    TUVLS_HOT = 2,
    TUVLS_PRESSED = 3,
    TUVLS_FOCUSED = 4,
    TUVLS_DISABLED = 5,
};

enum THUMBRIGHTSTATES {
    TUVRS_NORMAL = 1,
    TUVRS_HOT = 2,
    TUVRS_PRESSED = 3,
    TUVRS_FOCUSED = 4,
    TUVRS_DISABLED = 5,
};

enum TICSSTATES {
    TSS_NORMAL = 1,
};

enum TICSVERTSTATES {
    TSVS_NORMAL = 1,
};

/* TREEVIEWSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_TREEVIEWSTYLE (const WCHAR []){'T','R','E','E','V','I','E','W','S','T','Y','L','E',0}
#define VSCLASS_TREEVIEW (const WCHAR []){'T','R','E','E','V','I','E','W',0}
#elif defined(_MSC_VER)
#define VSCLASS_TREEVIEWSTYLE L"TREEVIEWSTYLE"
#define VSCLASS_TREEVIEW L"TREEVIEW"
#else
static const WCHAR VSCLASS_TREEVIEWSTYLE [] = {'T','R','E','E','V','I','E','W','S','T','Y','L','E',0};
static const WCHAR VSCLASS_TREEVIEW [] = {'T','R','E','E','V','I','E','W',0};
#endif

enum TREEVIEWPARTS {
    TVP_TREEITEM = 1,
    TVP_GLYPH = 2,
    TVP_BRANCH = 3,
    TVP_HOTGLYPH = 4,
};

#define TREEVIEWSTYLEPARTS TREEVIEWPARTS;

enum TREEITEMSTATES {
    TREIS_NORMAL = 1,
    TREIS_HOT = 2,
    TREIS_SELECTED = 3,
    TREIS_DISABLED = 4,
    TREIS_SELECTEDNOTFOCUS = 5,
    TREIS_HOTSELECTED = 6,
};

enum GLYPHSTATES {
    GLPS_CLOSED = 1,
    GLPS_OPENED = 2,
};

enum HOTGLYPHSTATES {
    HGLPS_CLOSED = 1,
    HGLPS_OPENED = 2,
};

/* WINDOWSTYLE class */
#if defined(__GNUC__)
#define VSCLASS_WINDOWSTYLE (const WCHAR []){'W','I','N','D','O','W','S','T','Y','L','E',0}
#define VSCLASS_WINDOW (const WCHAR []){'W','I','N','D','O','W',0}
#elif defined(_MSC_VER)
#define VSCLASS_WINDOWSTYLE L"WINDOWSTYLE"
#define VSCLASS_WINDOW L"WINDOW"
#else
static const WCHAR VSCLASS_WINDOWSTYLE [] = {'W','I','N','D','O','W','S','T','Y','L','E',0};
static const WCHAR VSCLASS_WINDOW [] = {'W','I','N','D','O','W',0};
#endif

enum WINDOWPARTS {
    WP_CAPTION = 1,
    WP_SMALLCAPTION = 2,
    WP_MINCAPTION = 3,
    WP_SMALLMINCAPTION = 4,
    WP_MAXCAPTION = 5,
    WP_SMALLMAXCAPTION = 6,
    WP_FRAMELEFT = 7,
    WP_FRAMERIGHT = 8,
    WP_FRAMEBOTTOM = 9,
    WP_SMALLFRAMELEFT = 10,
    WP_SMALLFRAMERIGHT = 11,
    WP_SMALLFRAMEBOTTOM = 12,
    WP_SYSBUTTON = 13,
    WP_MDISYSBUTTON = 14,
    WP_MINBUTTON = 15,
    WP_MDIMINBUTTON = 16,
    WP_MAXBUTTON = 17,
    WP_CLOSEBUTTON = 18,
    WP_SMALLCLOSEBUTTON = 19,
    WP_MDICLOSEBUTTON = 20,
    WP_RESTOREBUTTON = 21,
    WP_MDIRESTOREBUTTON = 22,
    WP_HELPBUTTON = 23,
    WP_MDIHELPBUTTON = 24,
    WP_HORZSCROLL = 25,
    WP_HORZTHUMB = 26,
    WP_VERTSCROLL = 27,
    WP_VERTTHUMB = 28,
    WP_DIALOG = 29,
    WP_CAPTIONSIZINGTEMPLATE = 30,
    WP_SMALLCAPTIONSIZINGTEMPLATE = 31,
    WP_FRAMELEFTSIZINGTEMPLATE = 32,
    WP_SMALLFRAMELEFTSIZINGTEMPLATE = 33,
    WP_FRAMERIGHTSIZINGTEMPLATE = 34,
    WP_SMALLFRAMERIGHTSIZINGTEMPLATE = 35,
    WP_FRAMEBOTTOMSIZINGTEMPLATE = 36,
    WP_SMALLFRAMEBOTTOMSIZINGTEMPLATE = 37,
    WP_FRAME = 38,
};

#define WINDOWSTYLEPARTS WINDOWPARTS;

enum FRAMESTATES {
    FS_ACTIVE = 1,
    FS_INACTIVE = 2,
};

enum CAPTIONSTATES {
    CS_ACTIVE = 1,
    CS_INACTIVE = 2,
    CS_DISABLED = 3,
};

enum MAXCAPTIONSTATES {
    MXCS_ACTIVE = 1,
    MXCS_INACTIVE = 2,
    MXCS_DISABLED = 3,
};

enum MINCAPTIONSTATES {
    MNCS_ACTIVE = 1,
    MNCS_INACTIVE = 2,
    MNCS_DISABLED = 3,
};

enum HORZSCROLLSTATES {
    HSS_NORMAL = 1,
    HSS_HOT = 2,
    HSS_PUSHED = 3,
    HSS_DISABLED = 4,
};

enum HORZTHUMBSTATES {
    HTS_NORMAL = 1,
    HTS_HOT = 2,
    HTS_PUSHED = 3,
    HTS_DISABLED = 4,
};

enum VERTSCROLLSTATES {
    VSS_NORMAL = 1,
    VSS_HOT = 2,
    VSS_PUSHED = 3,
    VSS_DISABLED = 4,
};

enum VERTTHUMBSTATES {
    VTS_NORMAL = 1,
    VTS_HOT = 2,
    VTS_PUSHED = 3,
    VTS_DISABLED = 4,
};

enum SYSBUTTONSTATES {
    SBS_NORMAL = 1,
    SBS_HOT = 2,
    SBS_PUSHED = 3,
    SBS_DISABLED = 4,
};

enum MINBUTTONSTATES {
    MINBS_NORMAL = 1,
    MINBS_HOT = 2,
    MINBS_PUSHED = 3,
    MINBS_DISABLED = 4,
};

enum MAXBUTTONSTATES {
    MAXBS_NORMAL = 1,
    MAXBS_HOT = 2,
    MAXBS_PUSHED = 3,
    MAXBS_DISABLED = 4,
};

enum RESTOREBUTTONSTATES {
    RBS_NORMAL = 1,
    RBS_HOT = 2,
    RBS_PUSHED = 3,
    RBS_DISABLED = 4,
};

enum HELPBUTTONSTATES {
    HBS_NORMAL = 1,
    HBS_HOT = 2,
    HBS_PUSHED = 3,
    HBS_DISABLED = 4,
};

enum CLOSEBUTTONSTATES {
    CBS_NORMAL = 1,
    CBS_HOT = 2,
    CBS_PUSHED = 3,
    CBS_DISABLED = 4,
};

#endif /* __VSSTYLE_H__ */
                                                                                                                                                                                                                                                                                                                                usr/share/mingw-w64/include/vssym32.h                                                               0100644 0000000 0000000 00000042437 12404413016 016046  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 This Software is provided under the Zope Public License (ZPL) Version 2.1.

 Copyright (C) 2011 Piotr Caban for CodeWeavers

 See the AUTHORS file for the list of contributors to the mingw-w64 project.

 This license has been certified as open source. It has also been designated
 as GPL compatible by the Free Software Foundation (FSF).

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

   1. Redistributions in source code must retain the accompanying copyright
      notice, this list of conditions, and the following disclaimer.
   2. Redistributions in binary form must reproduce the accompanying
      copyright notice, this list of conditions, and the following disclaimer
      in the documentation and/or other materials provided with the
      distribution.
   3. Names of the copyright holders must not be used to endorse or promote
      products derived from this software without prior written permission
      from the copyright holders.
   4. The right to distribute this software or to use it for any purpose does
      not give you the right to use Servicemarks (sm) or Trademarks (tm) of
      the copyright holders.  Use of them is covered by separate agreement
      with the copyright holders.
   5. If any files are modified, you must cause the modified files to carry
      prominent notices stating that you changed the files and the date of
      any change.

 Disclaimer

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY EXPRESSED
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef __VSSYM32_H__
#define __VSSYM32_H__

#include "vsstyle.h"


enum BGTYPE {
    BT_IMAGEFILE = 0,
    BT_BORDERFILL = 1,
    BT_NONE = 2,
};

enum IMAGELAYOUT {
    IL_VERTICAL = 0,
    IL_HORIZONTAL = 1,
};

enum BORDERTYPE {
    BT_RECT = 0,
    BT_ROUNDRECT = 1,
    BT_ELLIPSE = 2,
};

enum FILLTYPE {
    FT_SOLID = 0,
    FT_VERTGRADIENT = 1,
    FT_HORZGRADIENT = 2,
    FT_RADIALGRADIENT = 3,
    FT_TILEIMAGE = 4,
};

enum SIZINGTYPE {
    ST_TRUESIZE = 0,
    ST_STRETCH = 1,
    ST_TILE = 2,
};

enum HALIGN {
    HA_LEFT = 0,
    HA_CENTER = 1,
    HA_RIGHT = 2,
};

enum CONTENTALIGNMENT {
    CA_LEFT = 0,
    CA_CENTER = 1,
    CA_RIGHT = 2,
};

enum VALIGN {
    VA_TOP = 0,
    VA_CENTER = 1,
    VA_BOTTOM = 2,
};

enum OFFSETTYPE {
    OT_TOPLEFT = 0,
    OT_TOPRIGHT = 1,
    OT_TOPMIDDLE = 2,
    OT_BOTTOMLEFT = 3,
    OT_BOTTOMRIGHT = 4,
    OT_BOTTOMMIDDLE = 5,
    OT_MIDDLELEFT = 6,
    OT_MIDDLERIGHT = 7,
    OT_LEFTOFCAPTION = 8,
    OT_RIGHTOFCAPTION = 9,
    OT_LEFTOFLASTBUTTON = 10,
    OT_RIGHTOFLASTBUTTON = 11,
    OT_ABOVELASTBUTTON = 12,
    OT_BELOWLASTBUTTON = 13,
};

enum ICONEFFECT {
    ICE_NONE = 0,
    ICE_GLOW = 1,
    ICE_SHADOW = 2,
    ICE_PULSE = 3,
    ICE_ALPHA = 4,
};

enum TEXTSHADOWTYPE {
    TST_NONE = 0,
    TST_SINGLE = 1,
    TST_CONTINUOUS = 2,
};

enum GLYPHTYPE {
    GT_NONE = 0,
    GT_IMAGEGLYPH = 1,
    GT_FONTGLYPH = 2,
};

enum IMAGESELECTTYPE {
    IST_NONE = 0,
    IST_SIZE = 1,
    IST_DPI = 2,
};

enum TRUESIZESCALINGTYPE {
    TSST_NONE = 0,
    TSST_SIZE = 1,
    TSST_DPI = 2,
};

enum GLYPHFONTSIZINGTYPE {
    GFST_NONE = 0,
    GFST_SIZE = 1,
    GFST_DPI = 2,
};

#define TMT_RESERVEDLOW 0
#define TMT_RESERVEDHIGH 7999

#define TMT_DIBDATA 2
#define TMT_GLYPHDIBDATA 8
#define TMT_ENUM 200
#define TMT_STRING 201
#define TMT_INT 202
#define TMT_BOOL 203
#define TMT_COLOR 204
#define TMT_MARGINS 205
#define TMT_FILENAME 206
#define TMT_SIZE 207
#define TMT_POSITION 208
#define TMT_RECT 209
#define TMT_FONT 210
#define TMT_INTLIST 211
#define TMT_HBITMAP 212
#define TMT_DISKSTREAM 213
#define TMT_STREAM 214
#define TMT_BITMAPREF 215
#define TMT_COLORSCHEMES 401
#define TMT_SIZES 402
#define TMT_CHARSET 403
#define TMT_NAME 600
#define TMT_DISPLAYNAME 601
#define TMT_TOOLTIP 602
#define TMT_COMPANY 603
#define TMT_AUTHOR 604
#define TMT_COPYRIGHT 605
#define TMT_URL 606
#define TMT_VERSION 607
#define TMT_DESCRIPTION 608
#define TMT_FIRST_RCSTRING_NAME TMT_DISPLAYNAME
#define TMT_LAST_RCSTRING_NAME TMT_DESCRIPTION
#define TMT_CAPTIONFONT 801
#define TMT_SMALLCAPTIONFONT 802
#define TMT_MENUFONT 803
#define TMT_STATUSFONT 804
#define TMT_MSGBOXFONT 805
#define TMT_ICONTITLEFONT 806
#define TMT_HEADING1FONT 807
#define TMT_HEADING2FONT 808
#define TMT_BODYFONT 809
#define TMT_FIRSTFONT TMT_CAPTIONFONT
#define TMT_LASTFONT TMT_BODYFONT
#define TMT_FLATMENUS 1001
#define TMT_FIRSTBOOL TMT_FLATMENUS
#define TMT_LASTBOOL TMT_FLATMENUS
#define TMT_SIZINGBORDERWIDTH 1201
#define TMT_SCROLLBARWIDTH 1202
#define TMT_SCROLLBARHEIGHT 1203
#define TMT_CAPTIONBARWIDTH 1204
#define TMT_CAPTIONBARHEIGHT 1205
#define TMT_SMCAPTIONBARWIDTH 1206
#define TMT_SMCAPTIONBARHEIGHT 1207
#define TMT_MENUBARWIDTH 1208
#define TMT_MENUBARHEIGHT 1209
#define TMT_PADDEDBORDERWIDTH 1210
#define TMT_FIRSTSIZE TMT_SIZINGBORDERWIDTH
#define TMT_LASTSIZE TMT_PADDEDBORDERWIDTH
#define TMT_MINCOLORDEPTH 1301
#define TMT_FIRSTINT TMT_MINCOLORDEPTH
#define TMT_LASTINT TMT_MINCOLORDEPTH
#define TMT_CSSNAME 1401
#define TMT_XMLNAME 1402
#define TMT_LASTUPDATED 1403
#define TMT_ALIAS 1404
#define TMT_FIRSTSTRING TMT_CSSNAME
#define TMT_LASTSTRING TMT_ALIAS
#define TMT_SCROLLBAR 1601
#define TMT_BACKGROUND 1602
#define TMT_ACTIVECAPTION 1603
#define TMT_INACTIVECAPTION 1604
#define TMT_MENU 1605
#define TMT_WINDOW 1606
#define TMT_WINDOWFRAME 1607
#define TMT_MENUTEXT 1608
#define TMT_WINDOWTEXT 1609
#define TMT_CAPTIONTEXT 1610
#define TMT_ACTIVEBORDER 1611
#define TMT_INACTIVEBORDER 1612
#define TMT_APPWORKSPACE 1613
#define TMT_HIGHLIGHT 1614
#define TMT_HIGHLIGHTTEXT 1615
#define TMT_BTNFACE 1616
#define TMT_BTNSHADOW 1617
#define TMT_GRAYTEXT 1618
#define TMT_BTNTEXT 1619
#define TMT_INACTIVECAPTIONTEXT 1620
#define TMT_BTNHIGHLIGHT 1621
#define TMT_DKSHADOW3D 1622
#define TMT_LIGHT3D 1623
#define TMT_INFOTEXT 1624
#define TMT_INFOBK 1625
#define TMT_BUTTONALTERNATEFACE 1626
#define TMT_HOTTRACKING 1627
#define TMT_GRADIENTACTIVECAPTION 1628
#define TMT_GRADIENTINACTIVECAPTION 1629
#define TMT_MENUHILIGHT 1630
#define TMT_MENUBAR 1631
#define TMT_FIRSTCOLOR TMT_SCROLLBAR
#define TMT_LASTCOLOR TMT_MENUBAR
#define TMT_FROMHUE1 1801
#define TMT_FROMHUE2 1802
#define TMT_FROMHUE3 1803
#define TMT_FROMHUE4 1804
#define TMT_FROMHUE5 1805
#define TMT_TOHUE1 1806
#define TMT_TOHUE2 1807
#define TMT_TOHUE3 1808
#define TMT_TOHUE4 1809
#define TMT_TOHUE5 1810
#define TMT_FROMCOLOR1 2001
#define TMT_FROMCOLOR2 2002
#define TMT_FROMCOLOR3 2003
#define TMT_FROMCOLOR4 2004
#define TMT_FROMCOLOR5 2005
#define TMT_TOCOLOR1 2006
#define TMT_TOCOLOR2 2007
#define TMT_TOCOLOR3 2008
#define TMT_TOCOLOR4 2009
#define TMT_TOCOLOR5 2010
#define TMT_TRANSPARENT 2201
#define TMT_AUTOSIZE 2202
#define TMT_BORDERONLY 2203
#define TMT_COMPOSITED 2204
#define TMT_BGFILL 2205
#define TMT_GLYPHTRANSPARENT 2206
#define TMT_GLYPHONLY 2207
#define TMT_ALWAYSSHOWSIZINGBAR 2208
#define TMT_MIRRORIMAGE 2209
#define TMT_UNIFORMSIZING 2210
#define TMT_INTEGRALSIZING 2211
#define TMT_SOURCEGROW 2212
#define TMT_SOURCESHRINK 2213
#define TMT_DRAWBORDERS 2214
#define TMT_NOETCHEDEFFECT 2215
#define TMT_TEXTAPPLYOVERLAY 2216
#define TMT_TEXTGLOW 2217
#define TMT_TEXTITALIC 2218
#define TMT_COMPOSITEDOPAQUE 2219
#define TMT_LOCALIZEDMIRRORIMAGE 2220
#define TMT_IMAGECOUNT 2401
#define TMT_ALPHALEVEL 2402
#define TMT_BORDERSIZE 2403
#define TMT_ROUNDCORNERWIDTH 2404
#define TMT_ROUNDCORNERHEIGHT 2405
#define TMT_GRADIENTRATIO1 2406
#define TMT_GRADIENTRATIO2 2407
#define TMT_GRADIENTRATIO3 2408
#define TMT_GRADIENTRATIO4 2409
#define TMT_GRADIENTRATIO5 2410
#define TMT_PROGRESSCHUNKSIZE 2411
#define TMT_PROGRESSSPACESIZE 2412
#define TMT_SATURATION 2413
#define TMT_TEXTBORDERSIZE 2414
#define TMT_ALPHATHRESHOLD 2415
#define TMT_WIDTH 2416
#define TMT_HEIGHT 2417
#define TMT_GLYPHINDEX 2418
#define TMT_TRUESIZESTRETCHMARK 2419
#define TMT_MINDPI1 2420
#define TMT_MINDPI2 2421
#define TMT_MINDPI3 2422
#define TMT_MINDPI4 2423
#define TMT_MINDPI5 2424
#define TMT_TEXTGLOWSIZE 2425
#define TMT_FRAMESPERSECOND 2426
#define TMT_PIXELSPERFRAME 2427
#define TMT_ANIMATIONDELAY 2428
#define TMT_GLOWINTENSITY 2429
#define TMT_OPACITY 2430
#define TMT_COLORIZATIONCOLOR 2431
#define TMT_COLORIZATIONOPACITY 2432
#define TMT_GLYPHFONT 2601
#define TMT_IMAGEFILE 3001
#define TMT_IMAGEFILE1 3002
#define TMT_IMAGEFILE2 3003
#define TMT_IMAGEFILE3 3004
#define TMT_IMAGEFILE4 3005
#define TMT_IMAGEFILE5 3006
#define TMT_GLYPHIMAGEFILE 3008
#define TMT_TEXT 3201
#define TMT_CLASSICVALUE 3202
#define TMT_OFFSET 3401
#define TMT_TEXTSHADOWOFFSET 3402
#define TMT_MINSIZE 3403
#define TMT_MINSIZE1 3404
#define TMT_MINSIZE2 3405
#define TMT_MINSIZE3 3406
#define TMT_MINSIZE4 3407
#define TMT_MINSIZE5 3408
#define TMT_NORMALSIZE 3409
#define TMT_SIZINGMARGINS 3601
#define TMT_CONTENTMARGINS 3602
#define TMT_CAPTIONMARGINS 3603
#define TMT_BORDERCOLOR 3801
#define TMT_FILLCOLOR 3802
#define TMT_TEXTCOLOR 3803
#define TMT_EDGELIGHTCOLOR 3804
#define TMT_EDGEHIGHLIGHTCOLOR 3805
#define TMT_EDGESHADOWCOLOR 3806
#define TMT_EDGEDKSHADOWCOLOR 3807
#define TMT_EDGEFILLCOLOR 3808
#define TMT_TRANSPARENTCOLOR 3809
#define TMT_GRADIENTCOLOR1 3810
#define TMT_GRADIENTCOLOR2 3811
#define TMT_GRADIENTCOLOR3 3812
#define TMT_GRADIENTCOLOR4 3813
#define TMT_GRADIENTCOLOR5 3814
#define TMT_SHADOWCOLOR 3815
#define TMT_GLOWCOLOR 3816
#define TMT_TEXTBORDERCOLOR 3817
#define TMT_TEXTSHADOWCOLOR 3818
#define TMT_GLYPHTEXTCOLOR 3819
#define TMT_GLYPHTRANSPARENTCOLOR 3820
#define TMT_FILLCOLORHINT 3821
#define TMT_BORDERCOLORHINT 3822
#define TMT_ACCENTCOLORHINT 3823
#define TMT_TEXTCOLORHINT 3824
#define TMT_HEADING1TEXTCOLOR 3825
#define TMT_HEADING2TEXTCOLOR 3826
#define TMT_BODYTEXTCOLOR 3827
#define TMT_BGTYPE 4001
#define TMT_BORDERTYPE 4002
#define TMT_FILLTYPE 4003
#define TMT_SIZINGTYPE 4004
#define TMT_HALIGN 4005
#define TMT_CONTENTALIGNMENT 4006
#define TMT_VALIGN 4007
#define TMT_OFFSETTYPE 4008
#define TMT_ICONEFFECT 4009
#define TMT_TEXTSHADOWTYPE 4010
#define TMT_IMAGELAYOUT 4011
#define TMT_GLYPHTYPE 4012
#define TMT_IMAGESELECTTYPE 4013
#define TMT_GLYPHFONTSIZINGTYPE 4014
#define TMT_TRUESIZESCALINGTYPE 4015
#define TMT_USERPICTURE 5001
#define TMT_DEFAULTPANESIZE 5002
#define TMT_BLENDCOLOR 5003
#define TMT_CUSTOMSPLITRECT 5004
#define TMT_ANIMATIONBUTTONRECT 5005
#define TMT_ANIMATIONDURATION 5006
#define TMT_TRANSITIONDURATIONS 6000
#define TMT_SCALEDBACKGROUND 7001
#define TMT_ATLASIMAGE 8000
#define TMT_ATLASINPUTIMAGE 8001
#define TMT_ATLASRECT 8002

/* LINK class */
#if defined(__GNUC__)
#define VSCLASS_LINK (const WCHAR []){'L','I','N','K',0}
#elif defined(_MSC_VER)
#define VSCLASS_LINK L"LINK"
#else
static const WCHAR VSCLASS_LINK[] = {'L','I','N','K',0};
#endif

enum LINKPARTS {
    LP_HYPERLINK = 1,
};

enum HYPERLINKSTATES {
    HLS_NORMALTEXT = 1,
    HLS_LINKTEXT = 2,
};

/* EMPTYMARKUP class */
#if defined(__GNUC__)
#define VSCLASS_EMPTYMARKUP (const WCHAR []){'E','M','P','T','Y','M','A','R','K','U','P',0}
#elif defined(_MSC_VER)
#define VSCLASS_EMPTYMARKUP L"EMPTYMARKUP"
#else
static const WCHAR VSCLASS_EMPTYMARKUP[] = {'E','M','P','T','Y','M','A','R','K','U','P',0};
#endif

enum EMPTYMARKUPPARTS {
    EMP_MARKUPTEXT = 1,
};

enum MARKUPTEXTSTATES {
    EMT_NORMALTEXT = 1,
    EMT_LINKTEXT = 2,
};

/* STATIC class */
#if defined(__GNUC__)
#define VSCLASS_STATIC (const WCHAR []){'S','T','A','T','I','C',0}
#elif defined(_MSC_VER)
#define VSCLASS_STATIC L"STATIC"
#else
static const WCHAR VSCLASS_STATIC[] = {'S','T','A','T','I','C',0};
#endif

enum STATICPARTS {
    STAT_TEXT = 1,
};

/* PAGE class */
#if defined(__GNUC__)
#define VSCLASS_PAGE (const WCHAR []){'P','A','G','E',0}
#elif defined(_MSC_VER)
#define VSCLASS_PAGE L"PAGE"
#else
static const WCHAR VSCLASS_PAGE[] = {'P','A','G','E',0};
#endif

enum PAGEPARTS {
    PGRP_UP = 1,
    PGRP_DOWN = 2,
    PGRP_UPHORZ = 3,
    PGRP_DOWNHORZ = 4,
};

/* MONTHCAL class */
#if defined(__GNUC__)
#define VSCLASS_MONTHCAL (const WCHAR []){'M','O','N','T','H','C','A','L',0}
#elif defined(_MSC_VER)
#define VSCLASS_MONTHCAL L"MONTHCAL"
#else
static const WCHAR VSCLASS_MONTHCAL[] = {'M','O','N','T','H','C','A','L',0};
#endif

enum MONTHCALPARTS {
    MC_BACKGROUND = 1,
    MC_BORDERS = 2,
    MC_GRIDBACKGROUND = 3,
    MC_COLHEADERSPLITTER = 4,
    MC_GRIDCELLBACKGROUND = 5,
    MC_GRIDCELL = 6,
    MC_GRIDCELLUPPER = 7,
    MC_TRAILINGGRIDCELL = 8,
    MC_TRAILINGGRIDCELLUPPER = 9,
    MC_NAVNEXT = 10,
    MC_NAVPREV = 11,
};

enum GRIDCELLBACKGROUNDSTATES {
    MCGCB_SELECTED = 1,
    MCGCB_HOT = 2,
    MCGCB_SELECTEDHOT = 3,
    MCGCB_SELECTEDNOTFOCUSED = 4,
    MCGCB_TODAY = 5,
};

enum GRIDCELLSTATES {
    MCGC_HOT = 1,
    MCGC_HASSTATE = 2,
    MCGC_HASSTATEHOT = 3,
    MCGC_TODAY = 4,
};

enum GRIDCELLUPPERSTATES {
    MCGCU_HOT = 1,
    MCGCU_HASSTATE = 2,
    MCGCU_HASSTATEHOT = 3,
};

enum TRAILINGGRIDCELLSTATES {
    MCTGC_HOT = 1,
    MCTGC_HASSTATE = 2,
    MCTGC_HASSTATEHOT = 3,
    MCTGC_TODAY = 4,
};

enum TRAILINGGRIDCELLUPPERSTATES {
    MCTGCU_HOT = 1,
    MCTGCU_HASSTATE = 2,
    MCTGCU_HASSTATEHOT = 3,
};

enum NAVNEXTSTATES {
    MCNN_NORMAL = 1,
    MCNN_HOT = 2,
    MCNN_PRESSED = 3,
    MCNN_DISABLED = 4,
};

enum NAVPREVSTATES {
    MCNP_NORMAL = 1,
    MCNP_HOT = 2,
    MCNP_PRESSED = 3,
    MCNP_DISABLED = 4,
};

/* CLOCK class */
#if defined(__GNUC__)
#define VSCLASS_CLOCK (const WCHAR []){'C','L','O','C','K',0}
#elif defined(_MSC_VER)
#define VSCLASS_CLOCK L"CLOCK"
#else
static const WCHAR VSCLASS_CLOCK[] = {'C','L','O','C','K',0};
#endif

enum CLOCKPARTS {
    CLP_TIME = 1,
};

enum CLOCKSTATES {
    CLS_NORMAL = 1,
    CLS_HOT = 2,
    CLS_PRESSED = 3,
};

/* TRAYNOTIFY class */
#if defined(__GNUC__)
#define VSCLASS_TRAYNOTIFY (const WCHAR []){'T','R','A','Y','N','O','T','I','F','Y',0}
#elif defined(_MSC_VER)
#define VSCLASS_TRAYNOTIFY L"TRAYNOTIFY"
#else
static const WCHAR VSCLASS_TRAYNOTIFY[] = {'T','R','A','Y','N','O','T','I','F','Y',0};
#endif

enum TRAYNOTIFYPARTS {
    TNP_BACKGROUND = 1,
    TNP_ANIMBACKGROUND = 2,
};

/* TASKBAR class */
#if defined(__GNUC__)
#define VSCLASS_TASKBAR (const WCHAR []){'T','A','S','K','B','A','R',0}
#elif defined(_MSC_VER)
#define VSCLASS_TASKBAR L"TASKBAR"
#else
static const WCHAR VSCLASS_TASKBAR[] = {'T','A','S','K','B','A','R',0};
#endif

enum TASKBARPARTS {
    TBP_BACKGROUNDBOTTOM = 1,
    TBP_BACKGROUNDRIGHT = 2,
    TBP_BACKGROUNDTOP = 3,
    TBP_BACKGROUNDLEFT = 4,
    TBP_SIZINGBARBOTTOM = 5,
    TBP_SIZINGBARRIGHT = 6,
    TBP_SIZINGBARTOP = 7,
    TBP_SIZINGBARLEFT = 8,
};

/* TASKBAND class */
#if defined(__GNUC__)
#define VSCLASS_TASKBAND (const WCHAR []){'T','A','S','K','B','A','N','D',0}
#elif defined(_MSC_VER)
#define VSCLASS_TASKBAND L"TASKBAND"
#else
static const WCHAR VSCLASS_TASKBAND[] = {'T','A','S','K','B','A','N','D',0};
#endif

enum TASKBANDPARTS {
    TDP_GROUPCOUNT = 1,
    TDP_FLASHBUTTON = 2,
    TDP_FLASHBUTTONGROUPMENU = 3,
};

/* STARTPANEL class */
#if defined(__GNUC__)
#define VSCLASS_STARTPANEL (const WCHAR []){'S','T','A','R','T','P','A','N','E','L',0}
#elif defined(_MSC_VER)
#define VSCLASS_STARTPANEL L"STARTPANEL"
#else
static const WCHAR VSCLASS_STARTPANEL[] = {'S','T','A','R','T','P','A','N','E','L',0};
#endif

enum STARTPANELPARTS {
    SPP_USERPANE = 1,
    SPP_MOREPROGRAMS = 2,
    SPP_MOREPROGRAMSARROW = 3,
    SPP_PROGLIST = 4,
    SPP_PROGLISTSEPARATOR = 5,
    SPP_PLACESLIST = 6,
    SPP_PLACESLISTSEPARATOR = 7,
    SPP_LOGOFF = 8,
    SPP_LOGOFFBUTTONS = 9,
    SPP_USERPICTURE = 10,
    SPP_PREVIEW = 11,
    SPP_MOREPROGRAMSTAB = 12,
    SPP_NSCHOST = 13,
    SPP_SOFTWAREEXPLORER = 14,
    SPP_OPENBOX = 15,
    SPP_SEARCHVIEW = 16,
    SPP_MOREPROGRAMSARROWBACK = 17,
    SPP_TOPMATCH = 18,
    SPP_LOGOFFSPLITBUTTONDROPDOWN = 19,
};

enum MOREPROGRAMSTABSTATES {
    SPMPT_NORMAL = 1,
    SPMPT_HOT = 2,
    SPMPT_SELECTED = 3,
    SPMPT_DISABLED = 4,
    SPMPT_FOCUSED = 5,
};

enum SOFTWAREEXPLORERSTATES {
    SPSE_NORMAL = 1,
    SPSE_HOT = 2,
    SPSE_SELECTED = 3,
    SPSE_DISABLED = 4,
    SPSE_FOCUSED = 5,
};

enum OPENBOXSTATES {
    SPOB_NORMAL = 1,
    SPOB_HOT = 2,
    SPOB_SELECTED = 3,
    SPOB_DISABLED = 4,
    SPOB_FOCUSED = 5,
};

enum MOREPROGRAMSARROWSTATES {
    SPS_NORMAL = 1,
    SPS_HOT = 2,
    SPS_PRESSED = 3,
};

enum MOREPROGRAMSARROWBACKSTATES {
    SPSB_NORMAL = 1,
    SPSB_HOT = 2,
    SPSB_PRESSED = 3,
};

enum LOGOFFBUTTONSSTATES {
    SPLS_NORMAL = 1,
    SPLS_HOT = 2,
    SPLS_PRESSED = 3,
};

/* MENUBAND class */
#if defined(__GNUC__)
#define VSCLASS_MENUBAND (const WCHAR []){'M','E','N','U','B','A','N','D',0}
#elif defined(_MSC_VER)
#define VSCLASS_MENUBAND L"MENUBAND"
#else
static const WCHAR VSCLASS_MENUBAND[] = {'M','E','N','U','B','A','N','D',0};
#endif

enum MENUBANDPARTS {
    MDP_NEWAPPBUTTON = 1,
    MDP_SEPERATOR = 2,
};

enum MENUBANDSTATES {
    MDS_NORMAL = 1,
    MDS_HOT = 2,
    MDS_PRESSED = 3,
    MDS_DISABLED = 4,
    MDS_CHECKED = 5,
    MDS_HOTCHECKED = 6,
};

#endif /* __VSSYM32_H__ */
                                                                                                                                                                                                                                 usr/share/mingw-w64/include/vswriter.h                                                              0100644 0000000 0000000 00000152134 12404413016 016401  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_VSWRITER
#define _INC_VSWRITER

  typedef enum VSS_COMPONENT_FLAGS {
    VSS_CF_BACKUP_RECOVERY         = 0x00000001,
    VSS_CF_APP_ROLLBACK_RECOVERY   = 0x00000002,
    VSS_CF_NOT_SYSTEM_STATE        = 0x00000004 
  } VSS_COMPONENT_FLAGS;

  /* http://msdn.microsoft.com/en-us/library/aa384976%28v=VS.85%29.aspx */
  typedef enum VSS_USAGE_TYPE {
    VSS_UT_UNDEFINED             = 0,
    VSS_UT_BOOTABLESYSTEMSTATE   = 1,
    VSS_UT_SYSTEMSERVICE         = 2,
    VSS_UT_USERDATA              = 3,
    VSS_UT_OTHER                 = 4 
  } VSS_USAGE_TYPE;

typedef enum VSS_ALTERNATE_WRITER_STATE {
  VSS_AWS_UNDEFINED                  = 0,
  VSS_AWS_NO_ALTERNATE_WRITER        = 1,
  VSS_AWS_ALTERNATE_WRITER_EXISTS    = 2,
  VSS_AWS_THIS_IS_ALTERNATE_WRITER   = 3 
} VSS_ALTERNATE_WRITER_STATE;

typedef enum VSS_COMPONENT_TYPE {
  VSS_CT_UNDEFINED   = 0,
  VSS_CT_DATABASE    = 1,
  VSS_CT_FILEGROUP   = 2 
} VSS_COMPONENT_TYPE;

typedef enum VSS_FILE_RESTORE_STATUS {
  VSS_RS_UNDEFINED   = 0,
  VSS_RS_NONE        = 1,
  VSS_RS_ALL         = 2,
  VSS_RS_FAILED      = 3 
} VSS_FILE_RESTORE_STATUS;

typedef enum VSS_RESTORE_TARGET {
  VSS_RT_UNDEFINED           = 0,
  VSS_RT_ORIGINAL            = 1,
  VSS_RT_ALTERNATE           = 2,
  VSS_RT_DIRECTED            = 3,
  VSS_RT_ORIGINAL_LOCATION   = 4 
} VSS_RESTORE_TARGET;

typedef enum VSS_RESTOREMETHOD_ENUM {
  VSS_RME_UNDEFINED                             = 0,
  VSS_RME_RESTORE_IF_NOT_THERE                  = 1,
  VSS_RME_RESTORE_IF_CAN_REPLACE                = 2,
  VSS_RME_STOP_RESTORE_START                    = 3,
  VSS_RME_RESTORE_TO_ALTERNATE_LOCATION         = 4,
  VSS_RME_RESTORE_AT_REBOOT                     = 5,
  VSS_RME_RESTORE_AT_REBOOT_IF_CANNOT_REPLACE   = 6,
  VSS_RME_CUSTOM                                = 7,
  VSS_RME_RESTORE_STOP_START                    = 8 
} VSS_RESTOREMETHOD_ENUM;

typedef enum VSS_SOURCE_TYPE {
  VSS_ST_UNDEFINED         = 0,
  VSS_ST_TRANSACTEDDB      = 1,
  VSS_ST_NONTRANSACTEDDB   = 2,
  VSS_ST_OTHER             = 3 
} VSS_SOURCE_TYPE;

typedef enum VSS_SUBSCRIBE_MASK {
  VSS_SM_POST_SNAPSHOT_FLAG    = 0x00000001,
  VSS_SM_BACKUP_EVENTS_FLAG    = 0x00000002,
  VSS_SM_RESTORE_EVENTS_FLAG   = 0x00000004,
  VSS_SM_IO_THROTTLING_FLAG    = 0x00000008,
  VSS_SM_ALL_FLAGS             = 0xffffffff 
} VSS_SUBSCRIBE_MASK;

typedef enum VSS_WRITERRESTORE_ENUM {
  VSS_WRE_UNDEFINED          = 0,
  VSS_WRE_NEVER              = 1,
  VSS_WRE_IF_REPLACE_FAILS   = 2,
  VSS_WRE_ALWAYS             = 3 
} VSS_WRITERRESTORE_ENUM;

#include <vss.h>

#if (_WIN32_WINNT >= 0x601)
HRESULT WINAPI CreateVssExpressWriterInternal(
  IVssExpressWriter **ppWriter
);

FORCEINLINE
HRESULT WINAPI CreateVssExpressWriter(
  IVssExpressWriter **ppWriter
){return CreateVssExpressWriterInternal(ppWriter);}

#undef  INTERFACE
#define INTERFACE IVssCreateExpressWriterMetadata
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssCreateExpressWriterMetadata,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssCreateExpressWriterMetadata methods */
    STDMETHOD_(HRESULT,AddComponent)(THIS_ VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszCaption,const BYTE *pbIcon,UINT cbIcon,BOOLEAN bRestoreMetadata,BOOLEAN bNotifyOnBackupComplete,BOOLEAN bSelectable,BOOLEAN bSelectableForRestore,DWORD dwComponentFlags) PURE;
    STDMETHOD_(HRESULT,AddComponentDependency)(THIS_ LPCWSTR wszForLogicalPath,LPCWSTR wszForComponentName,VSS_ID onWriterId,LPCWSTR wszOnLogicalPath,LPCWSTR wszOnComponentName) PURE;
    STDMETHOD_(HRESULT,AddExcludeFiles)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive) PURE;
    STDMETHOD_(HRESULT,SaveAsXML)(THIS_ BSTR *pbstrXML) PURE;
    STDMETHOD_(HRESULT,SetBackupSchema)(THIS_ DWORD dsSchemaMask) PURE;
    STDMETHOD_(HRESULT,SetRestoreMethod)(THIS_ VSS_RESTOREMETHOD_ENUM method,LPCWSTR wszService,LPCWSTR wszUserProcedure,VSS_WRITERRESTORE_ENUM wreWriterRestore,BOOLEAN bRebootRequired) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssCreateExpressWriterMetadata_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssCreateExpressWriterMetadata_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssCreateExpressWriterMetadata_Release(This) (This)->lpVtbl->Release(This)
#define IVssCreateExpressWriterMetadata_AddComponent(This,componentType,wszLogicalPath,wszComponentName,wszCaption,pbIcon,cbIcon,bRestoreMetadata,bNotifyOnBackupComplete,bSelectable,bSelectableForRestore,dwComponentFlags) (This)->lpVtbl->AddComponent(This,componentType,wszLogicalPath,wszComponentName,wszCaption,pbIcon,cbIcon,bRestoreMetadata,bNotifyOnBackupComplete,bSelectable,bSelectableForRestore,dwComponentFlags)
#define IVssCreateExpressWriterMetadata_AddFilesToFileGroup(This,wszLogicalPath,wszGroupName,wszPath,wszFilespec,bRecursive,wszAlternateLocation,dwBackupTypeMask) (This)->lpVtbl->AddFilesToFileGroup(This,wszLogicalPath,wszGroupName,wszPath,wszFilespec,bRecursive,wszAlternateLocation,dwBackupTypeMask)
#define IVssCreateExpressWriterMetadata_SaveAsXML(This,pbstrXML) (This)->lpVtbl->SaveAsXML(This,pbstrXML)
#define IVssCreateExpressWriterMetadata_SetBackupSchema(This,dsSchemaMask) (This)->lpVtbl->SetBackupSchema(This,dsSchemaMask)
#define IVssCreateExpressWriterMetadata_SetRestoreMethod(This,method,wszService,wszUserProcedure,wreWriterRestore,bRebootRequired) (This)->lpVtbl->SetRestoreMethod(This,method,wszService,wszUserProcedure,wreWriterRestore,bRebootRequired)
#endif /*COBJMACROS*/

#endif /*(_WIN32_WINNT >= 0x601)*/

#ifdef __cplusplus
/* Is a C++ interface instead of a COM */
#undef  INTERFACE
#define INTERFACE IVssCreateWriterMetadata
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssCreateWriterMetadata,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssCreateWriterMetadata methods */
    STDMETHOD_(HRESULT,AddAlternateLocationMapping)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive,LPCWSTR wszDestination) PURE;
    STDMETHOD_(HRESULT,AddComponent)(THIS_ VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszCaption,const BYTE *pbIcon,UINT cbIcon,BOOLEAN bRestoreMetadata,BOOLEAN bNotifyOnBackupComplete,BOOLEAN bSelectable,BOOLEAN bSelectableForRestore,DWORD dwComponentFlags) PURE;
    STDMETHOD_(HRESULT,AddComponentDependency)(THIS_ LPCWSTR wszForLogicalPath,LPCWSTR wszForComponentName,VSS_ID onWriterId,LPCWSTR wszOnLogicalPath,LPCWSTR wszOnComponentName) PURE;
    STDMETHOD_(HRESULT,AddDatabaseFiles)(THIS_ LPCWSTR wszLogicalPath,LPCWSTR wszDatabaseName,LPCWSTR wszPath,LPCWSTR wszFilespec,DWORD dwBackupTypeMask) PURE;
    STDMETHOD_(HRESULT,AddDatabaseLogFiles)(THIS_ LPCWSTR wszLogicalPath,LPCWSTR wszDatabaseName,LPCWSTR wszPath,LPCWSTR wszFilespec,DWORD dwBackupTypeMask) PURE;
    STDMETHOD_(HRESULT,AddExcludeFiles)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive) PURE;
    STDMETHOD_(HRESULT,AddFilesToFileGroup)(THIS_ LPCWSTR wszLogicalPath,LPCWSTR wszGroupName,LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive,LPCWSTR wszAlternatePath,DWORD dwBackupTypeMask) PURE;
    STDMETHOD_(HRESULT,AddIncludeFiles)(THIS) PURE;
    STDMETHOD_(HRESULT,GetDocument)(THIS) PURE;
    STDMETHOD_(HRESULT,SaveAsXML)(THIS_ BSTR *pbstrXML) PURE;
    STDMETHOD_(HRESULT,SetBackupSchema)(THIS_ DWORD dsSchemaMask) PURE;
    STDMETHOD_(HRESULT,SetRestoreMethod)(THIS_ VSS_RESTOREMETHOD_ENUM method,LPCWSTR wszService,LPCWSTR wszUserProcedure,VSS_WRITERRESTORE_ENUM wreWriterRestore,BOOLEAN bRebootRequired) PURE;

    END_INTERFACE
};

#if (_WIN32_WINNT >= 0x600)
#undef  INTERFACE
#define INTERFACE IVssCreateWriterMetadataEx
DECLARE_INTERFACE_(IVssCreateWriterMetadataEx,IVssCreateWriterMetadata)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssCreateWriterMetadata methods */
    STDMETHOD_(HRESULT,AddAlternateLocationMapping)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive,LPCWSTR wszDestination) PURE;
    STDMETHOD_(HRESULT,AddComponent)(THIS_ VSS_COMPONENT_TYPE componentType,LPCWSTR wszLogicalPath,LPCWSTR wszComponentName,LPCWSTR wszCaption,const BYTE *pbIcon,UINT cbIcon,BOOLEAN bRestoreMetadata,BOOLEAN bNotifyOnBackupComplete,BOOLEAN bSelectable,BOOLEAN bSelectableForRestore,DWORD dwComponentFlags) PURE;
    STDMETHOD_(HRESULT,AddComponentDependency)(THIS_ LPCWSTR wszForLogicalPath,LPCWSTR wszForComponentName,VSS_ID onWriterId,LPCWSTR wszOnLogicalPath,LPCWSTR wszOnComponentName) PURE;
    STDMETHOD_(HRESULT,AddDatabaseFiles)(THIS_ LPCWSTR wszLogicalPath,LPCWSTR wszDatabaseName,LPCWSTR wszPath,LPCWSTR wszFilespec,DWORD dwBackupTypeMask) PURE;
    STDMETHOD_(HRESULT,AddDatabaseLogFiles)(THIS_ LPCWSTR wszLogicalPath,LPCWSTR wszDatabaseName,LPCWSTR wszPath,LPCWSTR wszFilespec,DWORD dwBackupTypeMask) PURE;
    STDMETHOD_(HRESULT,AddExcludeFiles)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive) PURE;
    STDMETHOD_(HRESULT,AddFilesToFileGroup)(THIS_ LPCWSTR wszLogicalPath,LPCWSTR wszGroupName,LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive,LPCWSTR wszAlternatePath,DWORD dwBackupTypeMask) PURE;
    STDMETHOD_(HRESULT,AddIncludeFiles)(THIS) PURE; /*Not supported*/
    STDMETHOD_(HRESULT,GetDocument)(THIS) PURE;     /*Not supported*/
    STDMETHOD_(HRESULT,SaveAsXML)(THIS_ BSTR *pbstrXML) PURE;
    STDMETHOD_(HRESULT,SetBackupSchema)(THIS_ DWORD dsSchemaMask) PURE;
    STDMETHOD_(HRESULT,SetRestoreMethod)(THIS_ VSS_RESTOREMETHOD_ENUM method,LPCWSTR wszService,LPCWSTR wszUserProcedure,VSS_WRITERRESTORE_ENUM wreWriterRestore,BOOLEAN bRebootRequired) PURE;

    /* IVssCreateWriterMetadataEx methods */
    STDMETHOD_(HRESULT,AddExcludeFilesFromSnapshot)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilespec,BOOLEAN bRecursive) PURE;

    END_INTERFACE
};
#endif /*(_WIN32_WINNT >= 0x600)*/
#endif /*__cplusplus*/

#if (_WIN32_WINNT >= 0x601)
#undef  INTERFACE
#define INTERFACE IVssExpressWriter
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssExpressWriter,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssExpressWriter methods */
    STDMETHOD_(HRESULT,CreateMetadata)(THIS_ VSS_ID writerId,LPCWSTR writerName,VSS_USAGE_TYPE usageType,DWORD versionMajor,DWORD versionMinor,DWORD reserved,IVssCreateWriterMetadataEx **ppMetadata) PURE;
    STDMETHOD_(HRESULT,Load)(THIS_ LPCWSTR metadata,DWORD reserved) PURE;
    STDMETHOD_(HRESULT,Register)(THIS) PURE;
    STDMETHOD_(HRESULT,Unregister)(THIS_ VSS_ID writerId) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssExpressWriter_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssExpressWriter_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssExpressWriter_Release(This) (This)->lpVtbl->Release(This)
#define IVssExpressWriter_CreateMetadata(This,writerId,writerName,usageType,versionMajor,versionMinor,reserved,ppMetadata) (This)->lpVtbl->CreateMetadata(This,writerId,writerName,usageType,versionMajor,versionMinor,reserved,ppMetadata)
#define IVssExpressWriter_Load(This,metadata,reserved) (This)->lpVtbl->Load(This,metadata,reserved)
#define IVssExpressWriter_Register() (This)->lpVtbl->Register(This)
#define IVssExpressWriter_Unregister(This,writerId) (This)->lpVtbl->Unregister(This,writerId)
#endif /*COBJMACROS*/
#endif /*(_WIN32_WINNT >= 0x601)*/

#ifdef __cplusplus
/* Is a C++ interface instead of a COM */
#undef  INTERFACE
#define INTERFACE IVssWriterComponents
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssWriterComponents,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssWriterComponents methods */
    STDMETHOD_(HRESULT,GetComponent)(THIS_ UINT iComponent,IVssComponent **ppComponent) PURE;
    STDMETHOD_(HRESULT,GetComponentCount)(THIS_ UINT *pcComponents) PURE;
    STDMETHOD_(HRESULT,GetWriterInfo)(THIS_ VSS_ID *pidInstance,VSS_ID *pidWriter) PURE;

    END_INTERFACE
};
#endif /*__cplusplus*/

#undef  INTERFACE
#define INTERFACE IVssComponent
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssComponent,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssComponent methods */
    STDMETHOD_(HRESULT,GetLogicalPath)(THIS_ BSTR *pbstrPath) PURE;
    STDMETHOD_(HRESULT,GetComponentType)(THIS_ VSS_COMPONENT_TYPE *pType) PURE;
    STDMETHOD_(HRESULT,GetComponentName)(THIS_ BSTR *pwszName) PURE;
    STDMETHOD_(HRESULT,GetBackupSucceeded)(THIS_ BOOLEAN *pbSucceeded) PURE;
    STDMETHOD_(HRESULT,GetAlternateLocationMappingCount)(THIS_ UINT *pcMappings) PURE;
    STDMETHOD_(HRESULT,GetAlternateLocationMapping)(THIS_ UINT iMapping,const IVssWMFiledesc **ppMapping) PURE;
    STDMETHOD_(HRESULT,SetBackupMetadata)(THIS_ BSTR bstrMetadata) PURE;
    STDMETHOD_(HRESULT,GetBackupMetadata)(THIS_ BSTR *pbstrMetadata) PURE;
    STDMETHOD_(HRESULT,AddPartialFile)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilename,LPCWSTR wszRanges,LPCWSTR wszMetadata) PURE;
    STDMETHOD_(HRESULT,GetPartialFileCount)(THIS_ UINT *pcPartialFiles) PURE;
    STDMETHOD_(HRESULT,GetPartialFile)(THIS_ UINT iPartialFile,BSTR *pbstrPath,BSTR *pbstrFilename,BSTR *pbstrRange,BSTR *pbstrMetadata) PURE;
    STDMETHOD_(HRESULT,IsSelectedForRestore)(THIS_ BOOLEAN *pbSelectedForRestore) PURE;
    STDMETHOD_(HRESULT,GetAdditionalRestores)(THIS_ BOOLEAN *pbAdditionalRestores) PURE;
    STDMETHOD_(HRESULT,GetNewTargetCount)(THIS_ UINT *pcNewTarget) PURE;
    STDMETHOD_(HRESULT,GetNewTarget)(THIS_ UINT iMapping,IVssWMFiledesc **ppFiledesc) PURE;
    STDMETHOD_(HRESULT,AddDirectedTarget)(THIS_ LPCWSTR wszSourcePath,LPCWSTR wszSourceFilename,LPCWSTR wszSourceRangeList,LPCWSTR wszDestinationPath,LPCWSTR wszDestinationFilename,LPCWSTR wszDestinationRangeList) PURE;
    STDMETHOD_(HRESULT,GetDirectedTargetCount)(THIS_ UINT *pcDirectedTarget) PURE;
    STDMETHOD_(HRESULT,GetDirectedTarget)(THIS_ UINT iDirectedTarget,BSTR *pbstrSourcePath,BSTR *pbstrSourceFileName,BSTR *pbstrSourceRangeList,BSTR *pbstrDestinationPath,BSTR *pbstrDestinationFilename,BSTR *pbstrDestinationRangeList) PURE;
    STDMETHOD_(HRESULT,SetRestoreMetadata)(THIS_ LPCWSTR wszRestoreMetadata) PURE;
    STDMETHOD_(HRESULT,GetRestoreMetadata)(THIS_ BSTR *pbstrRestoreMetadata) PURE;
    STDMETHOD_(HRESULT,SetRestoreTarget)(THIS_ VSS_RESTORE_TARGET target) PURE;
    STDMETHOD_(HRESULT,GetRestoreTarget)(THIS_ VSS_RESTORE_TARGET *pTarget) PURE;
    STDMETHOD_(HRESULT,SetPreRestoreFailureMsg)(THIS_ LPCWSTR wszPreRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetPreRestoreFailureMsg)(THIS_ BSTR *pbstrPreRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,SetPostRestoreFailureMsg)(THIS_ LPCWSTR wszPostRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetPostRestoreFailureMsg)(THIS_ BSTR *pbstrPostRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,SetBackupStamp)(THIS_ LPCWSTR wszBackupStamp) PURE;
    STDMETHOD_(HRESULT,GetBackupStamp)(THIS_ BSTR *pbstrBackupStamp) PURE;
    STDMETHOD_(HRESULT,GetPreviousBackupStamp)(THIS_ BSTR *pbstrBackupStamp) PURE;
    STDMETHOD_(HRESULT,GetBackupOptions)(THIS_ BSTR *pbstrBackupOptions) PURE;
    STDMETHOD_(HRESULT,GetRestoreOptions)(THIS_ BSTR *pbstrRestoreOptions) PURE;
    STDMETHOD_(HRESULT,GetRestoreSubcomponentCount)(THIS_ UINT *pcRestoreSubcomponent) PURE;
    STDMETHOD_(HRESULT,GetRestoreSubcomponent)(THIS_ UINT iComponent,BSTR *pbstrLogicalPath,BSTR *pbstrComponentName,BOOLEAN *pbRepair) PURE;
    STDMETHOD_(HRESULT,GetFileRestoreStatus)(THIS_ VSS_FILE_RESTORE_STATUS *pStatus) PURE;
    STDMETHOD_(HRESULT,AddDifferencedFilesByLastModifyTime)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilespec,WINBOOL bRecursive,FILETIME ftLastModifyTime) PURE;
    STDMETHOD_(HRESULT,AddDifferencedFilesByLastModifyLSN)(THIS) PURE;
    STDMETHOD_(HRESULT,GetDifferencedFilesCount)(THIS_ UINT *pcDifferencedFiles) PURE;
    STDMETHOD_(HRESULT,GetDifferencedFile)(THIS_ UINT iDifferencedFile,BSTR *pbstrPath,BSTR *pbstrFilespec,WINBOOL *pbRecursive,BSTR *pbstrLsnString,FILETIME *pftLastModifyTime) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssComponent_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssComponent_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssComponent_Release(This) (This)->lpVtbl->Release(This)
#define IVssComponent_GetLogicalPath(This,pbstrPath) (This)->lpVtbl->GetLogicalPath(This,pbstrPath)
#define IVssComponent_GetComponentType(This,pType) (This)->lpVtbl->GetComponentType(This,pType)
#define IVssComponent_GetComponentName(This,pwszName) (This)->lpVtbl->GetComponentName(This,pwszName)
#define IVssComponent_GetBackupSucceeded(This,pbSucceeded) (This)->lpVtbl->GetBackupSucceeded(This,pbSucceeded)
#define IVssComponent_GetAlternateLocationMappingCount(This,pcMappings) (This)->lpVtbl->GetAlternateLocationMappingCount(This,pcMappings)
#define IVssComponent_GetAlternateLocationMapping(This,iMapping,ppMapping) (This)->lpVtbl->GetAlternateLocationMapping(This,iMapping,ppMapping)
#define IVssComponent_SetBackupMetadata(This,bstrMetadata) (This)->lpVtbl->SetBackupMetadata(This,bstrMetadata)
#define IVssComponent_GetBackupMetadata(This,pbstrMetadata) (This)->lpVtbl->GetBackupMetadata(This,pbstrMetadata)
#define IVssComponent_AddPartialFile(This,wszPath,wszFilename,wszRanges,wszMetadata) (This)->lpVtbl->AddPartialFile(This,wszPath,wszFilename,wszRanges,wszMetadata)
#define IVssComponent_GetPartialFileCount(This,pcPartialFiles) (This)->lpVtbl->GetPartialFileCount(This,pcPartialFiles)
#define IVssComponent_GetPartialFile(This,iPartialFile,pbstrPath,pbstrFilename,pbstrRange,pbstrMetadata) (This)->lpVtbl->GetPartialFile(This,iPartialFile,pbstrPath,pbstrFilename,pbstrRange,pbstrMetadata)
#define IVssComponent_IsSelectedForRestore(This,pbSelectedForRestore) (This)->lpVtbl->IsSelectedForRestore(This,pbSelectedForRestore)
#define IVssComponent_GetAdditionalRestores(This,pbAdditionalRestores) (This)->lpVtbl->GetAdditionalRestores(This,pbAdditionalRestores)
#define IVssComponent_GetNewTargetCount(This,pcNewTarget) (This)->lpVtbl->GetNewTargetCount(This,pcNewTarget)
#define IVssComponent_GetNewTarget(This,iMapping,ppFiledesc) (This)->lpVtbl->GetNewTarget(This,iMapping,ppFiledesc)
#define IVssComponent_AddDirectedTarget(This,wszSourcePath,wszSourceFilename,wszSourceRangeList,wszDestinationPath,wszDestinationFilename,wszDestinationRangeList) (This)->lpVtbl->AddDirectedTarget(This,wszSourcePath,wszSourceFilename,wszSourceRangeList,wszDestinationPath,wszDestinationFilename,wszDestinationRangeList)
#define IVssComponent_GetDirectedTargetCount(This,pcDirectedTarget) (This)->lpVtbl->GetDirectedTargetCount(This,pcDirectedTarget)
#define IVssComponent_GetDirectedTarget(This,iDirectedTarget,pbstrSourcePath,pbstrSourceFileName,pbstrSourceRangeList,pbstrDestinationPath,pbstrDestinationFilename,pbstrDestinationRangeList) (This)->lpVtbl->GetDirectedTarget(This,iDirectedTarget,pbstrSourcePath,pbstrSourceFileName,pbstrSourceRangeList,pbstrDestinationPath,pbstrDestinationFilename,pbstrDestinationRangeList)
#define IVssComponent_SetRestoreMetadata(This,wszRestoreMetadata) (This)->lpVtbl->SetRestoreMetadata(This,wszRestoreMetadata)
#define IVssComponent_GetRestoreMetadata(This,pbstrRestoreMetadata) (This)->lpVtbl->GetRestoreMetadata(This,pbstrRestoreMetadata)
#define IVssComponent_SetRestoreTarget(This,target) (This)->lpVtbl->SetRestoreTarget(This,target)
#define IVssComponent_GetRestoreTarget(This,pTarget) (This)->lpVtbl->GetRestoreTarget(This,pTarget)
#define IVssComponent_SetPreRestoreFailureMsg(This,wszPreRestoreFailureMsg) (This)->lpVtbl->SetPreRestoreFailureMsg(This,wszPreRestoreFailureMsg)
#define IVssComponent_GetPreRestoreFailureMsg(This,pbstrPreRestoreFailureMsg) (This)->lpVtbl->GetPreRestoreFailureMsg(This,pbstrPreRestoreFailureMsg)
#define IVssComponent_SetPostRestoreFailureMsg(This,wszPostRestoreFailureMsg) (This)->lpVtbl->SetPostRestoreFailureMsg(This,wszPostRestoreFailureMsg)
#define IVssComponent_GetPostRestoreFailureMsg(This,pbstrPostRestoreFailureMsg) (This)->lpVtbl->GetPostRestoreFailureMsg(This,pbstrPostRestoreFailureMsg)
#define IVssComponent_SetBackupStamp(This,wszBackupStamp) (This)->lpVtbl->SetBackupStamp(This,wszBackupStamp)
#define IVssComponent_GetBackupStamp(This,pbstrBackupStamp) (This)->lpVtbl->GetBackupStamp(This,pbstrBackupStamp)
#define IVssComponent_GetPreviousBackupStamp(This,pbstrBackupStamp) (This)->lpVtbl->GetPreviousBackupStamp(This,pbstrBackupStamp)
#define IVssComponent_GetBackupOptions(This,pbstrBackupOptions) (This)->lpVtbl->GetBackupOptions(This,pbstrBackupOptions)
#define IVssComponent_GetRestoreOptions(This,pbstrRestoreOptions) (This)->lpVtbl->GetRestoreOptions(This,pbstrRestoreOptions)
#define IVssComponent_GetRestoreSubcomponentCount(This,pcRestoreSubcomponent) (This)->lpVtbl->GetRestoreSubcomponentCount(This,pcRestoreSubcomponent)
#define IVssComponent_GetRestoreSubcomponent(This,iComponent,pbstrLogicalPath,pbstrComponentName,pbRepair) (This)->lpVtbl->GetRestoreSubcomponent(This,iComponent,pbstrLogicalPath,pbstrComponentName,pbRepair)
#define IVssComponent_GetFileRestoreStatus(This,pStatus) (This)->lpVtbl->GetFileRestoreStatus(This,pStatus)
#define IVssComponent_AddDifferencedFilesByLastModifyTime(This,wszPath,wszFilespec,bRecursive,ftLastModifyTime) (This)->lpVtbl->AddDifferencedFilesByLastModifyTime(This,wszPath,wszFilespec,bRecursive,ftLastModifyTime)
#define IVssComponent_AddDifferencedFilesByLastModifyLSN() (This)->lpVtbl->AddDifferencedFilesByLastModifyLSN(This)
#define IVssComponent_GetDifferencedFilesCount(This,pcDifferencedFiles) (This)->lpVtbl->GetDifferencedFilesCount(This,pcDifferencedFiles)
#define IVssComponent_GetDifferencedFile(This,iDifferencedFile,pbstrPath,pbstrFilespec,pbRecursive,pbstrLsnString,pftLastModifyTime) (This)->lpVtbl->GetDifferencedFile(This,iDifferencedFile,pbstrPath,pbstrFilespec,pbRecursive,pbstrLsnString,pftLastModifyTime)
#endif /*COBJMACROS*/

#if (_WIN32_WINNT >= 0x600)
#undef  INTERFACE
#define INTERFACE IVssComponentEx
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssComponentEx,IVssComponent)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssComponent methods */
    STDMETHOD_(HRESULT,GetLogicalPath)(THIS_ BSTR *pbstrPath) PURE;
    STDMETHOD_(HRESULT,GetComponentType)(THIS_ VSS_COMPONENT_TYPE *pType) PURE;
    STDMETHOD_(HRESULT,GetComponentName)(THIS_ BSTR *pwszName) PURE;
    STDMETHOD_(HRESULT,GetBackupSucceeded)(THIS_ BOOLEAN *pbSucceeded) PURE;
    STDMETHOD_(HRESULT,GetAlternateLocationMappingCount)(THIS_ UINT *pcMappings) PURE;
    STDMETHOD_(HRESULT,GetAlternateLocationMapping)(THIS_ UINT iMapping,const IVssWMFiledesc **ppMapping) PURE;
    STDMETHOD_(HRESULT,SetBackupMetadata)(THIS_ BSTR bstrMetadata) PURE;
    STDMETHOD_(HRESULT,GetBackupMetadata)(THIS_ BSTR *pbstrMetadata) PURE;
    STDMETHOD_(HRESULT,AddPartialFile)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilename,LPCWSTR wszRanges,LPCWSTR wszMetadata) PURE;
    STDMETHOD_(HRESULT,GetPartialFileCount)(THIS_ UINT *pcPartialFiles) PURE;
    STDMETHOD_(HRESULT,GetPartialFile)(THIS_ UINT iPartialFile,BSTR *pbstrPath,BSTR *pbstrFilename,BSTR *pbstrRange,BSTR *pbstrMetadata) PURE;
    STDMETHOD_(HRESULT,IsSelectedForRestore)(THIS_ BOOLEAN *pbSelectedForRestore) PURE;
    STDMETHOD_(HRESULT,GetAdditionalRestores)(THIS_ BOOLEAN *pbAdditionalRestores) PURE;
    STDMETHOD_(HRESULT,GetNewTargetCount)(THIS_ UINT *pcNewTarget) PURE;
    STDMETHOD_(HRESULT,GetNewTarget)(THIS_ UINT iMapping,IVssWMFiledesc **ppFiledesc) PURE;
    STDMETHOD_(HRESULT,AddDirectedTarget)(THIS_ LPCWSTR wszSourcePath,LPCWSTR wszSourceFilename,LPCWSTR wszSourceRangeList,LPCWSTR wszDestinationPath,LPCWSTR wszDestinationFilename,LPCWSTR wszDestinationRangeList) PURE;
    STDMETHOD_(HRESULT,GetDirectedTargetCount)(THIS_ UINT *pcDirectedTarget) PURE;
    STDMETHOD_(HRESULT,GetDirectedTarget)(THIS_ UINT iDirectedTarget,BSTR *pbstrSourcePath,BSTR *pbstrSourceFileName,BSTR *pbstrSourceRangeList,BSTR *pbstrDestinationPath,BSTR *pbstrDestinationFilename,BSTR *pbstrDestinationRangeList) PURE;
    STDMETHOD_(HRESULT,SetRestoreMetadata)(THIS_ LPCWSTR wszRestoreMetadata) PURE;
    STDMETHOD_(HRESULT,GetRestoreMetadata)(THIS_ BSTR *pbstrRestoreMetadata) PURE;
    STDMETHOD_(HRESULT,SetRestoreTarget)(THIS_ VSS_RESTORE_TARGET target) PURE;
    STDMETHOD_(HRESULT,GetRestoreTarget)(THIS_ VSS_RESTORE_TARGET *pTarget) PURE;
    STDMETHOD_(HRESULT,SetPreRestoreFailureMsg)(THIS_ LPCWSTR wszPreRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetPreRestoreFailureMsg)(THIS_ BSTR *pbstrPreRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,SetPostRestoreFailureMsg)(THIS_ LPCWSTR wszPostRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetPostRestoreFailureMsg)(THIS_ BSTR *pbstrPostRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,SetBackupStamp)(THIS_ LPCWSTR wszBackupStamp) PURE;
    STDMETHOD_(HRESULT,GetBackupStamp)(THIS_ BSTR *pbstrBackupStamp) PURE;
    STDMETHOD_(HRESULT,GetPreviousBackupStamp)(THIS_ BSTR *pbstrBackupStamp) PURE;
    STDMETHOD_(HRESULT,GetBackupOptions)(THIS_ BSTR *pbstrBackupOptions) PURE;
    STDMETHOD_(HRESULT,GetRestoreOptions)(THIS_ BSTR *pbstrRestoreOptions) PURE;
    STDMETHOD_(HRESULT,GetRestoreSubcomponentCount)(THIS_ UINT *pcRestoreSubcomponent) PURE;
    STDMETHOD_(HRESULT,GetRestoreSubcomponent)(THIS_ UINT iComponent,BSTR *pbstrLogicalPath,BSTR *pbstrComponentName,BOOLEAN *pbRepair) PURE;
    STDMETHOD_(HRESULT,GetFileRestoreStatus)(THIS_ VSS_FILE_RESTORE_STATUS *pStatus) PURE;
    STDMETHOD_(HRESULT,AddDifferencedFilesByLastModifyTime)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilespec,WINBOOL bRecursive,FILETIME ftLastModifyTime) PURE;
    STDMETHOD_(HRESULT,AddDifferencedFilesByLastModifyLSN)(THIS) PURE;
    STDMETHOD_(HRESULT,GetDifferencedFilesCount)(THIS_ UINT *pcDifferencedFiles) PURE;
    STDMETHOD_(HRESULT,GetDifferencedFile)(THIS_ UINT iDifferencedFile,BSTR *pbstrPath,BSTR *pbstrFilespec,WINBOOL *pbRecursive,BSTR *pbstrLsnString,FILETIME *pftLastModifyTime) PURE;

    /* IVssComponentEx methods */
    STDMETHOD_(HRESULT,SetPrepareForBackupFailureMsg)(THIS_ LPCWSTR wszFailureMsg) PURE;
    STDMETHOD_(HRESULT,SetPostSnapshotFailureMsg)(THIS_ LPCWSTR wszFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetPrepareForBackupFailureMsg)(THIS_ BSTR *pbstrFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetPostSnapshotFailureMsg)(THIS_ BSTR *pbstrFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetAuthoritativeRestore)(THIS_ BOOLEAN *pbAuth) PURE;
    STDMETHOD_(HRESULT,GetRollForward)(THIS_ VSS_ROLLFORWARD_TYPE *pRollType,BSTR *pbstrPoint) PURE;
    STDMETHOD_(HRESULT,GetRestoreName)(THIS_ BSTR *pbstrName) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssComponentEx_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssComponentEx_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssComponentEx_Release(This) (This)->lpVtbl->Release(This)
#define IVssComponentEx_GetLogicalPath(This,pbstrPath) (This)->lpVtbl->GetLogicalPath(This,pbstrPath)
#define IVssComponentEx_GetComponentType(This,pType) (This)->lpVtbl->GetComponentType(This,pType)
#define IVssComponentEx_GetComponentName(This,pwszName) (This)->lpVtbl->GetComponentName(This,pwszName)
#define IVssComponentEx_GetBackupSucceeded(This,pbSucceeded) (This)->lpVtbl->GetBackupSucceeded(This,pbSucceeded)
#define IVssComponentEx_GetAlternateLocationMappingCount(This,pcMappings) (This)->lpVtbl->GetAlternateLocationMappingCount(This,pcMappings)
#define IVssComponentEx_GetAlternateLocationMapping(This,iMapping,ppMapping) (This)->lpVtbl->GetAlternateLocationMapping(This,iMapping,ppMapping)
#define IVssComponentEx_SetBackupMetadata(This,bstrMetadata) (This)->lpVtbl->SetBackupMetadata(This,bstrMetadata)
#define IVssComponentEx_GetBackupMetadata(This,pbstrMetadata) (This)->lpVtbl->GetBackupMetadata(This,pbstrMetadata)
#define IVssComponentEx_AddPartialFile(This,wszPath,wszFilename,wszRanges,wszMetadata) (This)->lpVtbl->AddPartialFile(This,wszPath,wszFilename,wszRanges,wszMetadata)
#define IVssComponentEx_GetPartialFileCount(This,pcPartialFiles) (This)->lpVtbl->GetPartialFileCount(This,pcPartialFiles)
#define IVssComponentEx_GetPartialFile(This,iPartialFile,pbstrPath,pbstrFilename,pbstrRange,pbstrMetadata) (This)->lpVtbl->GetPartialFile(This,iPartialFile,pbstrPath,pbstrFilename,pbstrRange,pbstrMetadata)
#define IVssComponentEx_IsSelectedForRestore(This,pbSelectedForRestore) (This)->lpVtbl->IsSelectedForRestore(This,pbSelectedForRestore)
#define IVssComponentEx_GetAdditionalRestores(This,pbAdditionalRestores) (This)->lpVtbl->GetAdditionalRestores(This,pbAdditionalRestores)
#define IVssComponentEx_GetNewTargetCount(This,pcNewTarget) (This)->lpVtbl->GetNewTargetCount(This,pcNewTarget)
#define IVssComponentEx_GetNewTarget(This,iMapping,ppFiledesc) (This)->lpVtbl->GetNewTarget(This,iMapping,ppFiledesc)
#define IVssComponentEx_AddDirectedTarget(This,wszSourcePath,wszSourceFilename,wszSourceRangeList,wszDestinationPath,wszDestinationFilename,wszDestinationRangeList) (This)->lpVtbl->AddDirectedTarget(This,wszSourcePath,wszSourceFilename,wszSourceRangeList,wszDestinationPath,wszDestinationFilename,wszDestinationRangeList)
#define IVssComponentEx_GetDirectedTargetCount(This,pcDirectedTarget) (This)->lpVtbl->GetDirectedTargetCount(This,pcDirectedTarget)
#define IVssComponentEx_GetDirectedTarget(This,iDirectedTarget,pbstrSourcePath,pbstrSourceFileName,pbstrSourceRangeList,pbstrDestinationPath,pbstrDestinationFilename,pbstrDestinationRangeList) (This)->lpVtbl->GetDirectedTarget(This,iDirectedTarget,pbstrSourcePath,pbstrSourceFileName,pbstrSourceRangeList,pbstrDestinationPath,pbstrDestinationFilename,pbstrDestinationRangeList)
#define IVssComponentEx_SetRestoreMetadata(This,wszRestoreMetadata) (This)->lpVtbl->SetRestoreMetadata(This,wszRestoreMetadata)
#define IVssComponentEx_GetRestoreMetadata(This,pbstrRestoreMetadata) (This)->lpVtbl->GetRestoreMetadata(This,pbstrRestoreMetadata)
#define IVssComponentEx_SetRestoreTarget(This,target) (This)->lpVtbl->SetRestoreTarget(This,target)
#define IVssComponentEx_GetRestoreTarget(This,pTarget) (This)->lpVtbl->GetRestoreTarget(This,pTarget)
#define IVssComponentEx_SetPreRestoreFailureMsg(This,wszPreRestoreFailureMsg) (This)->lpVtbl->SetPreRestoreFailureMsg(This,wszPreRestoreFailureMsg)
#define IVssComponentEx_GetPreRestoreFailureMsg(This,pbstrPreRestoreFailureMsg) (This)->lpVtbl->GetPreRestoreFailureMsg(This,pbstrPreRestoreFailureMsg)
#define IVssComponentEx_SetPostRestoreFailureMsg(This,wszPostRestoreFailureMsg) (This)->lpVtbl->SetPostRestoreFailureMsg(This,wszPostRestoreFailureMsg)
#define IVssComponentEx_GetPostRestoreFailureMsg(This,pbstrPostRestoreFailureMsg) (This)->lpVtbl->GetPostRestoreFailureMsg(This,pbstrPostRestoreFailureMsg)
#define IVssComponentEx_SetBackupStamp(This,wszBackupStamp) (This)->lpVtbl->SetBackupStamp(This,wszBackupStamp)
#define IVssComponentEx_GetBackupStamp(This,pbstrBackupStamp) (This)->lpVtbl->GetBackupStamp(This,pbstrBackupStamp)
#define IVssComponentEx_GetPreviousBackupStamp(This,pbstrBackupStamp) (This)->lpVtbl->GetPreviousBackupStamp(This,pbstrBackupStamp)
#define IVssComponentEx_GetBackupOptions(This,pbstrBackupOptions) (This)->lpVtbl->GetBackupOptions(This,pbstrBackupOptions)
#define IVssComponentEx_GetRestoreOptions(This,pbstrRestoreOptions) (This)->lpVtbl->GetRestoreOptions(This,pbstrRestoreOptions)
#define IVssComponentEx_GetRestoreSubcomponentCount(This,pcRestoreSubcomponent) (This)->lpVtbl->GetRestoreSubcomponentCount(This,pcRestoreSubcomponent)
#define IVssComponentEx_GetRestoreSubcomponent(This,iComponent,pbstrLogicalPath,pbstrComponentName,pbRepair) (This)->lpVtbl->GetRestoreSubcomponent(This,iComponent,pbstrLogicalPath,pbstrComponentName,pbRepair)
#define IVssComponentEx_GetFileRestoreStatus(This,pStatus) (This)->lpVtbl->GetFileRestoreStatus(This,pStatus)
#define IVssComponentEx_AddDifferencedFilesByLastModifyTime(This,wszPath,wszFilespec,bRecursive,ftLastModifyTime) (This)->lpVtbl->AddDifferencedFilesByLastModifyTime(This,wszPath,wszFilespec,bRecursive,ftLastModifyTime)
#define IVssComponentEx_AddDifferencedFilesByLastModifyLSN() (This)->lpVtbl->AddDifferencedFilesByLastModifyLSN(This)
#define IVssComponentEx_GetDifferencedFilesCount(This,pcDifferencedFiles) (This)->lpVtbl->GetDifferencedFilesCount(This,pcDifferencedFiles)
#define IVssComponentEx_GetDifferencedFile(This,iDifferencedFile,pbstrPath,pbstrFilespec,pbRecursive,pbstrLsnString,pftLastModifyTime) (This)->lpVtbl->GetDifferencedFile(This,iDifferencedFile,pbstrPath,pbstrFilespec,pbRecursive,pbstrLsnString,pftLastModifyTime)
#define IVssComponentEx_SetPrepareForBackupFailureMsg(This,wszFailureMsg) (This)->lpVtbl->SetPrepareForBackupFailureMsg(This,wszFailureMsg)
#define IVssComponentEx_SetPostSnapshotFailureMsg(This,wszFailureMsg) (This)->lpVtbl->SetPostSnapshotFailureMsg(This,wszFailureMsg)
#define IVssComponentEx_GetPrepareForBackupFailureMsg(This,pbstrFailureMsg) (This)->lpVtbl->GetPrepareForBackupFailureMsg(This,pbstrFailureMsg)
#define IVssComponentEx_GetPostSnapshotFailureMsg(This,pbstrFailureMsg) (This)->lpVtbl->GetPostSnapshotFailureMsg(This,pbstrFailureMsg)
#define IVssComponentEx_GetAuthoritativeRestore(This,pbAuth) (This)->lpVtbl->GetAuthoritativeRestore(This,pbAuth)
#define IVssComponentEx_GetRollForward(This,pRollType,pbstrPoint) (This)->lpVtbl->GetRollForward(This,pRollType,pbstrPoint)
#define IVssComponentEx_GetRestoreName(This,pbstrName) (This)->lpVtbl->GetRestoreName(This,pbstrName)
#endif /*COBJMACROS*/
#endif /*(_WIN32_WINNT >= 0x600)*/

#if (_WIN32_WINNT >= 0x601)
#undef  INTERFACE
#define INTERFACE IVssComponentEx2
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssComponentEx2,IVssComponentEx)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssComponent methods */
    STDMETHOD_(HRESULT,GetLogicalPath)(THIS_ BSTR *pbstrPath) PURE;
    STDMETHOD_(HRESULT,GetComponentType)(THIS_ VSS_COMPONENT_TYPE *pType) PURE;
    STDMETHOD_(HRESULT,GetComponentName)(THIS_ BSTR *pwszName) PURE;
    STDMETHOD_(HRESULT,GetBackupSucceeded)(THIS_ BOOLEAN *pbSucceeded) PURE;
    STDMETHOD_(HRESULT,GetAlternateLocationMappingCount)(THIS_ UINT *pcMappings) PURE;
    STDMETHOD_(HRESULT,GetAlternateLocationMapping)(THIS_ UINT iMapping,const IVssWMFiledesc **ppMapping) PURE;
    STDMETHOD_(HRESULT,SetBackupMetadata)(THIS_ BSTR bstrMetadata) PURE;
    STDMETHOD_(HRESULT,GetBackupMetadata)(THIS_ BSTR *pbstrMetadata) PURE;
    STDMETHOD_(HRESULT,AddPartialFile)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilename,LPCWSTR wszRanges,LPCWSTR wszMetadata) PURE;
    STDMETHOD_(HRESULT,GetPartialFileCount)(THIS_ UINT *pcPartialFiles) PURE;
    STDMETHOD_(HRESULT,GetPartialFile)(THIS_ UINT iPartialFile,BSTR *pbstrPath,BSTR *pbstrFilename,BSTR *pbstrRange,BSTR *pbstrMetadata) PURE;
    STDMETHOD_(HRESULT,IsSelectedForRestore)(THIS_ BOOLEAN *pbSelectedForRestore) PURE;
    STDMETHOD_(HRESULT,GetAdditionalRestores)(THIS_ BOOLEAN *pbAdditionalRestores) PURE;
    STDMETHOD_(HRESULT,GetNewTargetCount)(THIS_ UINT *pcNewTarget) PURE;
    STDMETHOD_(HRESULT,GetNewTarget)(THIS_ UINT iMapping,IVssWMFiledesc **ppFiledesc) PURE;
    STDMETHOD_(HRESULT,AddDirectedTarget)(THIS_ LPCWSTR wszSourcePath,LPCWSTR wszSourceFilename,LPCWSTR wszSourceRangeList,LPCWSTR wszDestinationPath,LPCWSTR wszDestinationFilename,LPCWSTR wszDestinationRangeList) PURE;
    STDMETHOD_(HRESULT,GetDirectedTargetCount)(THIS_ UINT *pcDirectedTarget) PURE;
    STDMETHOD_(HRESULT,GetDirectedTarget)(THIS_ UINT iDirectedTarget,BSTR *pbstrSourcePath,BSTR *pbstrSourceFileName,BSTR *pbstrSourceRangeList,BSTR *pbstrDestinationPath,BSTR *pbstrDestinationFilename,BSTR *pbstrDestinationRangeList) PURE;
    STDMETHOD_(HRESULT,SetRestoreMetadata)(THIS_ LPCWSTR wszRestoreMetadata) PURE;
    STDMETHOD_(HRESULT,GetRestoreMetadata)(THIS_ BSTR *pbstrRestoreMetadata) PURE;
    STDMETHOD_(HRESULT,SetRestoreTarget)(THIS_ VSS_RESTORE_TARGET target) PURE;
    STDMETHOD_(HRESULT,GetRestoreTarget)(THIS_ VSS_RESTORE_TARGET *pTarget) PURE;
    STDMETHOD_(HRESULT,SetPreRestoreFailureMsg)(THIS_ LPCWSTR wszPreRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetPreRestoreFailureMsg)(THIS_ BSTR *pbstrPreRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,SetPostRestoreFailureMsg)(THIS_ LPCWSTR wszPostRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetPostRestoreFailureMsg)(THIS_ BSTR *pbstrPostRestoreFailureMsg) PURE;
    STDMETHOD_(HRESULT,SetBackupStamp)(THIS_ LPCWSTR wszBackupStamp) PURE;
    STDMETHOD_(HRESULT,GetBackupStamp)(THIS_ BSTR *pbstrBackupStamp) PURE;
    STDMETHOD_(HRESULT,GetPreviousBackupStamp)(THIS_ BSTR *pbstrBackupStamp) PURE;
    STDMETHOD_(HRESULT,GetBackupOptions)(THIS_ BSTR *pbstrBackupOptions) PURE;
    STDMETHOD_(HRESULT,GetRestoreOptions)(THIS_ BSTR *pbstrRestoreOptions) PURE;
    STDMETHOD_(HRESULT,GetRestoreSubcomponentCount)(THIS_ UINT *pcRestoreSubcomponent) PURE;
    STDMETHOD_(HRESULT,GetRestoreSubcomponent)(THIS_ UINT iComponent,BSTR *pbstrLogicalPath,BSTR *pbstrComponentName,BOOLEAN *pbRepair) PURE;
    STDMETHOD_(HRESULT,GetFileRestoreStatus)(THIS_ VSS_FILE_RESTORE_STATUS *pStatus) PURE;
    STDMETHOD_(HRESULT,AddDifferencedFilesByLastModifyTime)(THIS_ LPCWSTR wszPath,LPCWSTR wszFilespec,WINBOOL bRecursive,FILETIME ftLastModifyTime) PURE;
    STDMETHOD_(HRESULT,AddDifferencedFilesByLastModifyLSN)(THIS) PURE;
    STDMETHOD_(HRESULT,GetDifferencedFilesCount)(THIS_ UINT *pcDifferencedFiles) PURE;
    STDMETHOD_(HRESULT,GetDifferencedFile)(THIS_ UINT iDifferencedFile,BSTR *pbstrPath,BSTR *pbstrFilespec,WINBOOL *pbRecursive,BSTR *pbstrLsnString,FILETIME *pftLastModifyTime) PURE;

    /* IVssComponentEx methods */
    STDMETHOD_(HRESULT,SetPrepareForBackupFailureMsg)(THIS_ LPCWSTR wszFailureMsg) PURE;
    STDMETHOD_(HRESULT,SetPostSnapshotFailureMsg)(THIS_ LPCWSTR wszFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetPrepareForBackupFailureMsg)(THIS_ BSTR *pbstrFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetPostSnapshotFailureMsg)(THIS_ BSTR *pbstrFailureMsg) PURE;
    STDMETHOD_(HRESULT,GetAuthoritativeRestore)(THIS_ BOOLEAN *pbAuth) PURE;
    STDMETHOD_(HRESULT,GetRollForward)(THIS_ VSS_ROLLFORWARD_TYPE *pRollType,BSTR *pbstrPoint) PURE;
    STDMETHOD_(HRESULT,GetRestoreName)(THIS_ BSTR *pbstrName) PURE;

    /* IVssComponentEx2 methods */
    STDMETHOD_(HRESULT,GetFailure)(THIS_ HRESULT *phr,HRESULT *phrApplication,BSTR *pbstrApplicationMessage,DWORD *pdwReserved) PURE;
    STDMETHOD_(HRESULT,SetFailure)(THIS_ HRESULT hr,HRESULT hrApplication,LPCWSTR wszApplicationMessage,DWORD dwReserved) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IVssComponentEx2_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IVssComponentEx2_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IVssComponentEx2_Release(This) (This)->lpVtbl->Release(This)
#define IVssComponentEx2_GetLogicalPath(This,pbstrPath) (This)->lpVtbl->GetLogicalPath(This,pbstrPath)
#define IVssComponentEx2_GetComponentType(This,pType) (This)->lpVtbl->GetComponentType(This,pType)
#define IVssComponentEx2_GetComponentName(This,pwszName) (This)->lpVtbl->GetComponentName(This,pwszName)
#define IVssComponentEx2_GetBackupSucceeded(This,pbSucceeded) (This)->lpVtbl->GetBackupSucceeded(This,pbSucceeded)
#define IVssComponentEx2_GetAlternateLocationMappingCount(This,pcMappings) (This)->lpVtbl->GetAlternateLocationMappingCount(This,pcMappings)
#define IVssComponentEx2_GetAlternateLocationMapping(This,iMapping,ppMapping) (This)->lpVtbl->GetAlternateLocationMapping(This,iMapping,ppMapping)
#define IVssComponentEx2_SetBackupMetadata(This,bstrMetadata) (This)->lpVtbl->SetBackupMetadata(This,bstrMetadata)
#define IVssComponentEx2_GetBackupMetadata(This,pbstrMetadata) (This)->lpVtbl->GetBackupMetadata(This,pbstrMetadata)
#define IVssComponentEx2_AddPartialFile(This,wszPath,wszFilename,wszRanges,wszMetadata) (This)->lpVtbl->AddPartialFile(This,wszPath,wszFilename,wszRanges,wszMetadata)
#define IVssComponentEx2_GetPartialFileCount(This,pcPartialFiles) (This)->lpVtbl->GetPartialFileCount(This,pcPartialFiles)
#define IVssComponentEx2_GetPartialFile(This,iPartialFile,pbstrPath,pbstrFilename,pbstrRange,pbstrMetadata) (This)->lpVtbl->GetPartialFile(This,iPartialFile,pbstrPath,pbstrFilename,pbstrRange,pbstrMetadata)
#define IVssComponentEx2_IsSelectedForRestore(This,pbSelectedForRestore) (This)->lpVtbl->IsSelectedForRestore(This,pbSelectedForRestore)
#define IVssComponentEx2_GetAdditionalRestores(This,pbAdditionalRestores) (This)->lpVtbl->GetAdditionalRestores(This,pbAdditionalRestores)
#define IVssComponentEx2_GetNewTargetCount(This,pcNewTarget) (This)->lpVtbl->GetNewTargetCount(This,pcNewTarget)
#define IVssComponentEx2_GetNewTarget(This,iMapping,ppFiledesc) (This)->lpVtbl->GetNewTarget(This,iMapping,ppFiledesc)
#define IVssComponentEx2_AddDirectedTarget(This,wszSourcePath,wszSourceFilename,wszSourceRangeList,wszDestinationPath,wszDestinationFilename,wszDestinationRangeList) (This)->lpVtbl->AddDirectedTarget(This,wszSourcePath,wszSourceFilename,wszSourceRangeList,wszDestinationPath,wszDestinationFilename,wszDestinationRangeList)
#define IVssComponentEx2_GetDirectedTargetCount(This,pcDirectedTarget) (This)->lpVtbl->GetDirectedTargetCount(This,pcDirectedTarget)
#define IVssComponentEx2_GetDirectedTarget(This,iDirectedTarget,pbstrSourcePath,pbstrSourceFileName,pbstrSourceRangeList,pbstrDestinationPath,pbstrDestinationFilename,pbstrDestinationRangeList) (This)->lpVtbl->GetDirectedTarget(This,iDirectedTarget,pbstrSourcePath,pbstrSourceFileName,pbstrSourceRangeList,pbstrDestinationPath,pbstrDestinationFilename,pbstrDestinationRangeList)
#define IVssComponentEx2_SetRestoreMetadata(This,wszRestoreMetadata) (This)->lpVtbl->SetRestoreMetadata(This,wszRestoreMetadata)
#define IVssComponentEx2_GetRestoreMetadata(This,pbstrRestoreMetadata) (This)->lpVtbl->GetRestoreMetadata(This,pbstrRestoreMetadata)
#define IVssComponentEx2_SetRestoreTarget(This,target) (This)->lpVtbl->SetRestoreTarget(This,target)
#define IVssComponentEx2_GetRestoreTarget(This,pTarget) (This)->lpVtbl->GetRestoreTarget(This,pTarget)
#define IVssComponentEx2_SetPreRestoreFailureMsg(This,wszPreRestoreFailureMsg) (This)->lpVtbl->SetPreRestoreFailureMsg(This,wszPreRestoreFailureMsg)
#define IVssComponentEx2_GetPreRestoreFailureMsg(This,pbstrPreRestoreFailureMsg) (This)->lpVtbl->GetPreRestoreFailureMsg(This,pbstrPreRestoreFailureMsg)
#define IVssComponentEx2_SetPostRestoreFailureMsg(This,wszPostRestoreFailureMsg) (This)->lpVtbl->SetPostRestoreFailureMsg(This,wszPostRestoreFailureMsg)
#define IVssComponentEx2_GetPostRestoreFailureMsg(This,pbstrPostRestoreFailureMsg) (This)->lpVtbl->GetPostRestoreFailureMsg(This,pbstrPostRestoreFailureMsg)
#define IVssComponentEx2_SetBackupStamp(This,wszBackupStamp) (This)->lpVtbl->SetBackupStamp(This,wszBackupStamp)
#define IVssComponentEx2_GetBackupStamp(This,pbstrBackupStamp) (This)->lpVtbl->GetBackupStamp(This,pbstrBackupStamp)
#define IVssComponentEx2_GetPreviousBackupStamp(This,pbstrBackupStamp) (This)->lpVtbl->GetPreviousBackupStamp(This,pbstrBackupStamp)
#define IVssComponentEx2_GetBackupOptions(This,pbstrBackupOptions) (This)->lpVtbl->GetBackupOptions(This,pbstrBackupOptions)
#define IVssComponentEx2_GetRestoreOptions(This,pbstrRestoreOptions) (This)->lpVtbl->GetRestoreOptions(This,pbstrRestoreOptions)
#define IVssComponentEx2_GetRestoreSubcomponentCount(This,pcRestoreSubcomponent) (This)->lpVtbl->GetRestoreSubcomponentCount(This,pcRestoreSubcomponent)
#define IVssComponentEx2_GetRestoreSubcomponent(This,iComponent,pbstrLogicalPath,pbstrComponentName,pbRepair) (This)->lpVtbl->GetRestoreSubcomponent(This,iComponent,pbstrLogicalPath,pbstrComponentName,pbRepair)
#define IVssComponentEx2_GetFileRestoreStatus(This,pStatus) (This)->lpVtbl->GetFileRestoreStatus(This,pStatus)
#define IVssComponentEx2_AddDifferencedFilesByLastModifyTime(This,wszPath,wszFilespec,bRecursive,ftLastModifyTime) (This)->lpVtbl->AddDifferencedFilesByLastModifyTime(This,wszPath,wszFilespec,bRecursive,ftLastModifyTime)
#define IVssComponentEx2_AddDifferencedFilesByLastModifyLSN() (This)->lpVtbl->AddDifferencedFilesByLastModifyLSN(This)
#define IVssComponentEx2_GetDifferencedFilesCount(This,pcDifferencedFiles) (This)->lpVtbl->GetDifferencedFilesCount(This,pcDifferencedFiles)
#define IVssComponentEx2_GetDifferencedFile(This,iDifferencedFile,pbstrPath,pbstrFilespec,pbRecursive,pbstrLsnString,pftLastModifyTime) (This)->lpVtbl->GetDifferencedFile(This,iDifferencedFile,pbstrPath,pbstrFilespec,pbRecursive,pbstrLsnString,pftLastModifyTime)
#define IVssComponentEx2_SetPrepareForBackupFailureMsg(This,wszFailureMsg) (This)->lpVtbl->SetPrepareForBackupFailureMsg(This,wszFailureMsg)
#define IVssComponentEx2_SetPostSnapshotFailureMsg(This,wszFailureMsg) (This)->lpVtbl->SetPostSnapshotFailureMsg(This,wszFailureMsg)
#define IVssComponentEx2_GetPrepareForBackupFailureMsg(This,pbstrFailureMsg) (This)->lpVtbl->GetPrepareForBackupFailureMsg(This,pbstrFailureMsg)
#define IVssComponentEx2_GetPostSnapshotFailureMsg(This,pbstrFailureMsg) (This)->lpVtbl->GetPostSnapshotFailureMsg(This,pbstrFailureMsg)
#define IVssComponentEx2_GetAuthoritativeRestore(This,pbAuth) (This)->lpVtbl->GetAuthoritativeRestore(This,pbAuth)
#define IVssComponentEx2_GetRollForward(This,pRollType,pbstrPoint) (This)->lpVtbl->GetRollForward(This,pRollType,pbstrPoint)
#define IVssComponentEx2_GetRestoreName(This,pbstrName) (This)->lpVtbl->GetRestoreName(This,pbstrName)
#define IVssComponentEx2_GetFailure(This,phr,phrApplication,pbstrApplicationMessage,pdwReserved) (This)->lpVtbl->GetFailure(This,phr,phrApplication,pbstrApplicationMessage,pdwReserved)
#define IVssComponentEx2_SetFailure(This,hr,hrApplication,wszApplicationMessage,dwReserved) (This)->lpVtbl->SetFailure(This,hr,hrApplication,wszApplicationMessage,dwReserved)
#endif /*COBJMACROS*/
#endif /*(_WIN32_WINNT >= 0x601)*/

#ifdef __cplusplus
/* Is a C++ interface instead of a COM */
#undef  INTERFACE
#define INTERFACE IVssWMDependency
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssWMDependency,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssWMDependency methods */
    STDMETHOD_(HRESULT,GetWriterId)(THIS_ VSS_ID *pWriterId) PURE;
    STDMETHOD_(HRESULT,GetLogicalPath)(THIS_ BSTR *pbstrLogicalPath) PURE;
    STDMETHOD_(HRESULT,GetComponentName)(THIS_ BSTR *pbstrComponentName) PURE;

    END_INTERFACE
};

#undef  INTERFACE
#define INTERFACE IVssWMFiledesc
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IVssWMFiledesc,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IVssWMFiledesc methods */
    STDMETHOD_(HRESULT,GetPath)(THIS_ BSTR *pbstrPath) PURE;
    STDMETHOD_(HRESULT,GetFilespec)(THIS_ BSTR *pbstrFilespec) PURE;
    STDMETHOD_(HRESULT,GetRecursive)(THIS_ BOOLEAN *pbRecursive) PURE;
    STDMETHOD_(HRESULT,GetAlternateLocation)(THIS_ BSTR *pbstrAlternateLocation) PURE;
    STDMETHOD_(HRESULT,GetBackupTypeMask)(THIS_ DWORD *pdwTypeMask) PURE;

    END_INTERFACE
};
#endif /*__cplusplus*/

#ifdef __cplusplus
#if __MINGW_GNUC_PREREQ(4,6)
/* We need __thiscall support */
class CVssWriter {
protected:
    bool WINAPI AreComponentsSelected() const;
    VSS_BACKUP_TYPE WINAPI GetBackupType() const;
    LONG WINAPI GetContext() const;
    VSS_APPLICATION_LEVEL WINAPI GetCurrentLevel() const;
    VSS_ID WINAPI GetCurrentSnapshotSetId() const;
    LPCWSTR* WINAPI GetCurrentVolumeArray() const;
    UINT WINAPI GetCurrentVolumeCount() const;
    VSS_RESTORE_TYPE WINAPI GetRestoreType() const;
    HRESULT WINAPI GetSnapshotDeviceName(
        LPCWSTR wszOriginalVolume,
        LPCWSTR *ppwszSnapshotDevice) const;
    bool WINAPI IsBootableSystemStateBackedUp() const;
    bool WINAPI IsPartialFileSupportEnabled() const;
    bool WINAPI IsPathAffected(
        LPCWSTR wszPath) const;
    HRESULT WINAPI SetWriterFailure(
        HRESULT hr);
public:
    //Pure virtuals
    virtual bool WINAPI OnAbort() = 0;
    virtual bool WINAPI OnFreeze() = 0;
    virtual bool WINAPI OnPrepareSnapshot() = 0;
    virtual bool WINAPI OnThaw() = 0;
    //Virtuals
    virtual __thiscall ~CVssWriter();
    virtual bool WINAPI OnBackupComplete(
        IVssWriterComponents *pComponent);
    virtual bool WINAPI OnBackupShutdown(
        VSS_ID SnapshotSetId);
    virtual bool WINAPI OnIdentify(
        IVssCreateWriterMetadata *pMetadata);
    virtual bool WINAPI OnPostRestore(
        IVssWriterComponents *pComponent);
    virtual bool WINAPI OnPostSnapshot(
        IVssWriterComponents *pComponent);
    virtual bool WINAPI OnPrepareBackup(
        IVssWriterComponents *pComponent);
    virtual bool WINAPI OnPreRestore(
        IVssWriterComponents *pComponent);
    //gendef says public: virtual bool __stdcall CVssWriter::OnBackOffIOOnVolume(unsigned short *,struct _GUID,struct _GUID)
    //Method unsupported
    virtual bool WINAPI OnBackOffIOOnVolume(
        VSS_PWSZ _vss_pwsz,
        VSS_ID _id1,
        VSS_ID _id2);
    //gendef says public: virtual bool __stdcall CVssWriter::OnContinueIOOnVolume(unsigned short *,struct _GUID,struct _GUID)
    //Method unsupported
    virtual bool WINAPI OnContinueIOOnVolume(
        VSS_PWSZ _vss_pwsz,
        VSS_ID _id1,
        VSS_ID _id2);
    //gendef says public: virtual bool __stdcall CVssWriter::OnVSSShutdown(void)
    //Method unsupported
    virtual bool WINAPI OnVssShutdown();
    //Non-virtuals
    __thiscall CVssWriter();
    HRESULT WINAPI Initialize(
        VSS_ID WriterId,
        LPCWSTR WriterName,
        VSS_USAGE_TYPE UsageType,
        VSS_SOURCE_TYPE SourceType,
        VSS_APPLICATION_LEVEL AppLevel,
        DWORD dwTimeoutFreeze = 60000,
        VSS_ALTERNATE_WRITER_STATE aws = VSS_AWS_NO_ALTERNATE_WRITER,
        bool bIOThrottlingOnly = false,
        LPCWSTR wszWriterInstanceName = NULL);
    HRESULT WINAPI Subscribe(
        DWORD dwEventFlags);
    HRESULT WINAPI Unsubscribe();
    //gendef says public: long __stdcall CVssWriter::InstallAlternateWriter(struct _GUID,struct _GUID)
    //Method unsupported
    HRESULT WINAPI InstallAlternateWriter(
        VSS_ID _id1,
        VSS_ID _id2);
};

class CVssWriterEx : public CVssWriter {
  protected:
    HRESULT WINAPI GetIdentifyInformation(
        IVssExamineWriterMetadata **ppMetadata) const;
    HRESULT WINAPI SubscribeEx(
        DWORD dwUnsubscribeTimeout,
        DWORD dwEventFlags);
  public:
    virtual bool WINAPI OnIdentifyEx(
        IVssCreateWriterMetadataEx *pMetadata) const;
    HRESULT WINAPI InitializeEx(
        VSS_ID WriterId,
        LPCWSTR wszWriterName,
        DWORD dwMajorVersion,
        DWORD dwMinorVersion,
        VSS_USAGE_TYPE ut,
        VSS_SOURCE_TYPE st,
        VSS_APPLICATION_LEVEL nLevel,
        DWORD dwTimeoutFreeze = 60000,
        VSS_ALTERNATE_WRITER_STATE aws = VSS_AWS_NO_ALTERNATE_WRITER,
        bool bIOThrottlingOnly = false,
        LPCWSTR wszWriterInstanceName = NULL);
};

class CVssWriterEx2: public CVssWriterEx {
  public:
    HRESULT WINAPI GetSessionId(
        VSS_ID *idSession) const;
    bool WINAPI IsWriterShuttingDown() const;
    HRESULT WINAPI SetWriterFailureEx(
        HRESULT hrWriter,
        HRESULT hrApplication,
        LPCWSTR wszApplicationMessage);
};
#endif /*__MINGW_GNUC_PREREQ(4,6)*/
#endif /*__cplusplus*/

#include <vsbackup.h>

#endif /*_INC_VSWRITER*/
                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/share/mingw-w64/include/w32api.h                                                                0100644 0000000 0000000 00000003374 12404413016 015622  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _W32API_H
#define _W32API_H
#define _W32API_H_
#if __GNUC__ >=3
#pragma GCC system_header
#endif

#define __W32API_VERSION 3.14
#define __W32API_MAJOR_VERSION 3
#define __W32API_MINOR_VERSION 14

/* The following defines are for documentation purposes.  The following defines
 * identify the versions of Windows and Internet Explorer.  They are not to be
 * used in the w32api library but may be used by a user to set the _WIN32_WINNT
 * or _WIN32_WINDOWS and the WINVER values to their minimum level of support.
 *
 * Similarly the user can use the Internet Explorer values to set the _WIN32_IE
 * value to their minimum level of support.
 */

/* Use these values to set _WIN32_WINDOWS and WINVER to your minimum support 
 * level */
#define Windows95    0x0400
#define Windows98    0x0410
#define WindowsME    0x0500

/* Use these values to set _WIN32_WINNT and WINVER to your mimimum support 
 * level. */
#define WindowsNT4   0x0400
#define Windows2000  0x0500
#define WindowsXP    0x0501
#define Windows2003  0x0502
#define WindowsVista 0x0600
#define Windows7     0x0601
#define Windows8     0x0602

/* Use these values to set _WIN32_IE to your minimum support level */
#define IE3	0x0300
#define IE301	0x0300
#define IE302	0x0300
#define IE4	0x0400
#define IE401	0x0401
#define IE5	0x0500
#define IE5a	0x0500
#define IE5b	0x0500
#define IE501	0x0501
#define IE55	0x0501
#define IE56	0x0560
#define IE6	0x0600
#define IE601	0x0601
#define IE602	0x0603
#define IE7	0x0700
#define IE8	0x0800
#define IE9	0x0900
#define IE10	0x0A00

#endif /* ndef _W32API_H */
                                                                                                                                                                                                                                                                    usr/share/mingw-w64/include/wab.h                                                                   0100644 0000000 0000000 00000000574 12404413016 015265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#include <wabdefs.h>
#include <wabcode.h>
#include <wabtags.h>
#include <wabutil.h>
#include <wabiab.h>
#include <wabapi.h>
#include <wabmem.h>
#include <wabnot.h>
                                                                                                                                    usr/share/mingw-w64/include/wabapi.h                                                                0100644 0000000 0000000 00000011206 12404413016 015751  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WABAPI_H_
#define _WABAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

  typedef struct _WABACTIONITEM *LPWABACTIONITEM;

#define CBIWABOBJECT sizeof(IWABOBJECT)
#define WAB_IWABOBJECT_METHODS(IPURE) MAPIMETHOD(GetLastError) (THIS_ HRESULT hResult,ULONG ulFlags,LPMAPIERROR *lppMAPIError) IPURE; MAPIMETHOD(AllocateBuffer) (THIS_ ULONG cbSize,LPVOID *lppBuffer) IPURE; MAPIMETHOD(AllocateMore) (THIS_ ULONG cbSize,LPVOID lpObject,LPVOID *lppBuffer) IPURE; MAPIMETHOD(FreeBuffer) (THIS_ LPVOID lpBuffer) IPURE; MAPIMETHOD(Backup) (THIS_ LPSTR lpFileName) IPURE; MAPIMETHOD(Import) (THIS_ LPSTR lpImportParam) IPURE; MAPIMETHOD(Find) (THIS_ LPADRBOOK lpIAB,HWND hWnd) IPURE; MAPIMETHOD(VCardDisplay) (THIS_ LPADRBOOK lpIAB,HWND hWnd,LPSTR lpszFileName) IPURE; MAPIMETHOD(LDAPUrl) (THIS_ LPADRBOOK lpIAB,HWND hWnd,ULONG ulFlags,LPSTR lpszURL,LPMAILUSER *lppMailUser) IPURE; MAPIMETHOD(VCardCreate) (THIS_ LPADRBOOK lpIAB,ULONG ulFlags,LPSTR lpszVCard,LPMAILUSER lpMailUser) IPURE; MAPIMETHOD(VCardRetrieve) (THIS_ LPADRBOOK lpIAB,ULONG ulFlags,LPSTR lpszVCard,LPMAILUSER *lppMailUser) IPURE; MAPIMETHOD(GetMe) (THIS_ LPADRBOOK lpIAB,ULONG ulFlags,DWORD *lpdwAction,SBinary *lpsbEID,ULONG ulParam) IPURE; MAPIMETHOD(SetMe) (THIS_ LPADRBOOK lpIAB,ULONG ulFlags,SBinary sbEID,ULONG ulParam) IPURE;

#undef INTERFACE
#define INTERFACE IWABObject
  DECLARE_MAPI_INTERFACE_(IWABObject,IUnknown) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      WAB_IWABOBJECT_METHODS(PURE)
  };

  DECLARE_MAPI_INTERFACE_PTR(IWABObject,LPWABOBJECT);

#undef INTERFACE
#define INTERFACE struct _IWABOBJECT

#undef METHOD_PREFIX
#define METHOD_PREFIX IWABOBJECT_
#undef LPVTBL_ELEM
#define LPVTBL_ELEM lpvtbl
#undef MAPIMETHOD_
#define MAPIMETHOD_(type,method) MAPIMETHOD_DECLARE(type,method,IWABOBJECT_)
  MAPI_IUNKNOWN_METHODS(IMPL)
    WAB_IWABOBJECT_METHODS(IMPL)
#undef MAPIMETHOD_
#define MAPIMETHOD_(type,method) MAPIMETHOD_TYPEDEF(type,method,IWABOBJECT_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    WAB_IWABOBJECT_METHODS(IMPL)
#undef MAPIMETHOD_
#define MAPIMETHOD_(type,method) STDMETHOD_(type,method)

    DECLARE_MAPI_INTERFACE(IWABOBJECT_)
  {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(IMPL)
      WAB_IWABOBJECT_METHODS(IMPL)
  };

#define WABOBJECT_LDAPURL_RETURN_MAILUSER 0x00000001
#define WABOBJECT_ME_NEW 0x00000001
#define WABOBJECT_ME_NOCREATE 0x00000002

#define WAB_VCARD_FILE 0x00000000
#define WAB_VCARD_STREAM 0x00000001

  typedef struct _tagWAB_PARAM {
    ULONG cbSize;
    HWND hwnd;
    LPSTR szFileName;
    ULONG ulFlags;
    GUID guidPSExt;
  } WAB_PARAM,*LPWAB_PARAM;

#define WAB_USE_OE_SENDMAIL 0x00000001
#define WAB_ENABLE_PROFILES 0x00400000

  STDMETHODIMP WABOpen(LPADRBOOK *lppAdrBook,LPWABOBJECT *lppWABObject,LPWAB_PARAM lpWP,DWORD Reserved2);

  typedef HRESULT (WINAPI WABOPEN)(LPADRBOOK *lppAdrBook,LPWABOBJECT *lppWABObject,LPWAB_PARAM lpWP,DWORD Reserved2);
  typedef WABOPEN *LPWABOPEN;

  STDMETHODIMP WABOpenEx(LPADRBOOK *lppAdrBook,LPWABOBJECT *lppWABObject,LPWAB_PARAM lpWP,DWORD Reserved,ALLOCATEBUFFER *fnAllocateBuffer,ALLOCATEMORE *fnAllocateMore,FREEBUFFER *fnFreeBuffer);

  typedef HRESULT (WINAPI WABOPENEX)(LPADRBOOK *lppAdrBook,LPWABOBJECT *lppWABObject,LPWAB_PARAM lpWP,DWORD Reserved,ALLOCATEBUFFER *fnAllocateBuffer,ALLOCATEMORE *fnAllocateMore,FREEBUFFER *fnFreeBuffer);
  typedef WABOPENEX *LPWABOPENEX;

  typedef struct _WABIMPORTPARAM {
    ULONG cbSize;
    LPADRBOOK lpAdrBook;
    HWND hWnd;
    ULONG ulFlags;
    LPSTR lpszFileName;
  } WABIMPORTPARAM,*LPWABIMPORTPARAM;

#define WAB_DISPLAY_LDAPURL 0x00000001
#define WAB_CONTEXT_ADRLIST 0x00000002
#define WAB_DISPLAY_ISNTDS 0x00000004

  typedef struct _WABEXTDISPLAY {
    ULONG cbSize;
    LPWABOBJECT lpWABObject;
    LPADRBOOK lpAdrBook;
    LPMAPIPROP lpPropObj;
    WINBOOL fReadOnly;
    WINBOOL fDataChanged;
    ULONG ulFlags;
    LPVOID lpv;
    LPTSTR lpsz;
  } WABEXTDISPLAY,*LPWABEXTDISPLAY;

#define WAB_IWABEXTINIT_METHODS(IPURE) MAPIMETHOD(Initialize) (THIS_ LPWABEXTDISPLAY lpWABExtDisplay) IPURE;
#undef INTERFACE
#define INTERFACE IWABExtInit
  DECLARE_MAPI_INTERFACE_(IWABExtInit,IUnknown) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      WAB_IWABEXTINIT_METHODS(PURE)
  };

  DECLARE_MAPI_INTERFACE_PTR(IWABExtInit,LPWABEXTINIT);
  DEFINE_GUID(IID_IWABExtInit,0xea22ebf0,0x87a4,0x11d1,0x9a,0xcf,0x0,0xa0,0xc9,0x1f,0x9c,0x8b);

#define WAB_DLL_NAME TEXT("WAB32.DLL")
#define WAB_DLL_PATH_KEY TEXT("Software\\Microsoft\\WAB\\DLLPath")

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                          usr/share/mingw-w64/include/wabcode.h                                                               0100644 0000000 0000000 00000006636 12404413016 016125  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#if !defined(MAPICODE_H) && !defined(WABCODE_H)
#define WABCODE_H

#include <objerror.h>

#define MAKE_MAPI_SCODE(sev,fac,code) ((SCODE) (((unsigned __LONG32)(sev)<<31) | ((unsigned __LONG32)(fac)<<16) | ((unsigned __LONG32)(code))))

#define MAKE_MAPI_E(err) (MAKE_MAPI_SCODE(1,FACILITY_ITF,err))
#define MAKE_MAPI_S(warn) (MAKE_MAPI_SCODE(0,FACILITY_ITF,warn))

#ifdef SUCCESS_SUCCESS
#undef SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS __MSABI_LONG(0)

#define MAPI_E_CALL_FAILED E_FAIL
#define MAPI_E_NOT_ENOUGH_MEMORY E_OUTOFMEMORY
#define MAPI_E_INVALID_PARAMETER E_INVALIDARG
#define MAPI_E_INTERFACE_NOT_SUPPORTED E_NOINTERFACE
#define MAPI_E_NO_ACCESS E_ACCESSDENIED

#define MAPI_E_NO_SUPPORT MAKE_MAPI_E(0x102)
#define MAPI_E_BAD_CHARWIDTH MAKE_MAPI_E(0x103)
#define MAPI_E_STRING_TOO_LONG MAKE_MAPI_E(0x105)
#define MAPI_E_UNKNOWN_FLAGS MAKE_MAPI_E(0x106)
#define MAPI_E_INVALID_ENTRYID MAKE_MAPI_E(0x107)
#define MAPI_E_INVALID_OBJECT MAKE_MAPI_E(0x108)
#define MAPI_E_OBJECT_CHANGED MAKE_MAPI_E(0x109)
#define MAPI_E_OBJECT_DELETED MAKE_MAPI_E(0x10A)
#define MAPI_E_BUSY MAKE_MAPI_E(0x10B)
#define MAPI_E_NOT_ENOUGH_DISK MAKE_MAPI_E(0x10D)
#define MAPI_E_NOT_ENOUGH_RESOURCES MAKE_MAPI_E(0x10E)
#define MAPI_E_NOT_FOUND MAKE_MAPI_E(0x10F)
#define MAPI_E_VERSION MAKE_MAPI_E(0x110)
#define MAPI_E_LOGON_FAILED MAKE_MAPI_E(0x111)
#define MAPI_E_SESSION_LIMIT MAKE_MAPI_E(0x112)
#define MAPI_E_USER_CANCEL MAKE_MAPI_E(0x113)
#define MAPI_E_UNABLE_TO_ABORT MAKE_MAPI_E(0x114)
#define MAPI_E_NETWORK_ERROR MAKE_MAPI_E(0x115)
#define MAPI_E_DISK_ERROR MAKE_MAPI_E(0x116)
#define MAPI_E_TOO_COMPLEX MAKE_MAPI_E(0x117)
#define MAPI_E_BAD_COLUMN MAKE_MAPI_E(0x118)
#define MAPI_E_EXTENDED_ERROR MAKE_MAPI_E(0x119)
#define MAPI_E_COMPUTED MAKE_MAPI_E(0x11A)
#define MAPI_E_CORRUPT_DATA MAKE_MAPI_E(0x11B)
#define MAPI_E_UNCONFIGURED MAKE_MAPI_E(0x11C)
#define MAPI_E_FAILONEPROVIDER MAKE_MAPI_E(0x11D)
#define MAPI_E_END_OF_SESSION MAKE_MAPI_E(0x200)
#define MAPI_E_UNKNOWN_ENTRYID MAKE_MAPI_E(0x201)
#define MAPI_E_MISSING_REQUIRED_COLUMN MAKE_MAPI_E(0x202)
#define MAPI_W_NO_SERVICE MAKE_MAPI_S(0x203)
#define MAPI_E_BAD_VALUE MAKE_MAPI_E(0x301)
#define MAPI_E_INVALID_TYPE MAKE_MAPI_E(0x302)
#define MAPI_E_TYPE_NO_SUPPORT MAKE_MAPI_E(0x303)
#define MAPI_E_UNEXPECTED_TYPE MAKE_MAPI_E(0x304)
#define MAPI_E_TOO_BIG MAKE_MAPI_E(0x305)
#define MAPI_E_DECLINE_COPY MAKE_MAPI_E(0x306)
#define MAPI_E_UNEXPECTED_ID MAKE_MAPI_E(0x307)
#define MAPI_W_ERRORS_RETURNED MAKE_MAPI_S(0x380)
#define MAPI_E_UNABLE_TO_COMPLETE MAKE_MAPI_E(0x400)
#define MAPI_E_TIMEOUT MAKE_MAPI_E(0x401)
#define MAPI_E_TABLE_EMPTY MAKE_MAPI_E(0x402)
#define MAPI_E_TABLE_TOO_BIG MAKE_MAPI_E(0x403)
#define MAPI_E_INVALID_BOOKMARK MAKE_MAPI_E(0x405)
#define MAPI_W_POSITION_CHANGED MAKE_MAPI_S(0x481)
#define MAPI_W_APPROX_COUNT MAKE_MAPI_S(0x482)
#define MAPI_W_PARTIAL_COMPLETION MAKE_MAPI_S(0x680)
#define MAPI_E_AMBIGUOUS_RECIP MAKE_MAPI_E(0x700)
#define MAPI_E_COLLISION MAKE_MAPI_E(0x604)
#define MAPI_E_NOT_INITIALIZED MAKE_MAPI_E(0x605)
#define MAPI_E_FOLDER_CYCLE MAKE_MAPI_E(0x60B)

#ifndef MakeResult
#define MakeResult(_s) ResultFromScode(_s)
#endif

#ifndef HR_SUCCEEDED
#define HR_SUCCEEDED(_hr) SUCCEEDED((SCODE)(_hr))
#define HR_FAILED(_hr) FAILED((SCODE)(_hr))
#endif
#endif
                                                                                                  usr/share/mingw-w64/include/wabdefs.h                                                               0100644 0000000 0000000 00000147423 12404413016 016134  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#if !defined(MAPIDEFS_H) && !defined(WABDEFS_H)
#define WABDEFS_H
#if defined (NT) && !defined (_WINNT)
#warning NT defined but not _WINNT. You must define _WINNT to ensure " "successful compile of Windows NT code.
#define _WINNT
#endif

#ifndef _WINDOWS_
#define INC_OLE2
#define INC_RPC
#define _OLE_H_
#include <windows.h>
#endif

#ifndef _OLEERROR_H_
#include <objerror.h>
#endif
#include <objbase.h>
#include <stddef.h>

#ifndef MAPI_DIM
#define MAPI_DIM 1
#endif

#ifndef STDMAPIINITCALLTYPE
#define STDMAPIINITCALLTYPE __cdecl
#define STDINITMETHODIMP HRESULT __cdecl
#define STDINITMETHODIMP_(type) type __cdecl
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __WCHAR_DEFINED
#define __WCHAR_DEFINED
  typedef WORD WCHAR;
#endif

#if defined(UNICODE)
  typedef WCHAR TCHAR;
#else
  typedef char TCHAR;
#endif

  typedef WCHAR *LPWSTR;
  typedef const WCHAR *LPCWSTR;
  typedef TCHAR *LPTSTR;
  typedef const TCHAR *LPCTSTR;
  typedef BYTE *LPBYTE;
  typedef ULONG *LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
  typedef unsigned __LONG32 LHANDLE,*LPLHANDLE;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
  typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
  } FILETIME,*LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#define MAPI_MODIFY ((ULONG) 0x00000001)

#define MAPI_ACCESS_MODIFY ((ULONG) 0x00000001)
#define MAPI_ACCESS_READ ((ULONG) 0x00000002)
#define MAPI_ACCESS_DELETE ((ULONG) 0x00000004)
#define MAPI_ACCESS_CREATE_HIERARCHY ((ULONG) 0x00000008)
#define MAPI_ACCESS_CREATE_CONTENTS ((ULONG) 0x00000010)
#define MAPI_ACCESS_CREATE_ASSOCIATED ((ULONG) 0x00000020)
#define MAPI_UNICODE ((ULONG) 0x80000000)

#if defined(UNICODE)
#define fMapiUnicode MAPI_UNICODE
#else
#define fMapiUnicode 0
#endif

#define hrSuccess 0

#ifndef MAPI_ORIG
#define MAPI_ORIG 0
#define MAPI_TO 1
#define MAPI_CC 2
#define MAPI_BCC 3
#define MAPI_P1 0x10000000
#define MAPI_SUBMITTED 0x80000000
#endif

#define MAPI_SHORTTERM 0x80
#define MAPI_NOTRECIP 0x40
#define MAPI_THISSESSION 0x20
#define MAPI_NOW 0x10
#define MAPI_NOTRESERVED 0x08

#define MAPI_COMPOUND 0x80

  typedef struct {
    BYTE abFlags[4];
    BYTE ab[MAPI_DIM];
  } ENTRYID,*LPENTRYID;

#define CbNewENTRYID(_cb) (offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb) (offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb,_name) struct _ENTRYID_ ## _name { BYTE abFlags[4]; BYTE ab[_cb]; } _name

  typedef struct _MAPIUID {
    BYTE ab[16];
  } MAPIUID,*LPMAPIUID;

#define IsEqualMAPIUID(lpuid1,lpuid2) (!memcmp(lpuid1,lpuid2,sizeof(MAPIUID)))

#define MAPI_STORE ((ULONG) 0x00000001)
#define MAPI_ADDRBOOK ((ULONG) 0x00000002)
#define MAPI_FOLDER ((ULONG) 0x00000003)
#define MAPI_ABCONT ((ULONG) 0x00000004)
#define MAPI_MESSAGE ((ULONG) 0x00000005)
#define MAPI_MAILUSER ((ULONG) 0x00000006)
#define MAPI_ATTACH ((ULONG) 0x00000007)
#define MAPI_DISTLIST ((ULONG) 0x00000008)
#define MAPI_PROFSECT ((ULONG) 0x00000009)
#define MAPI_STATUS ((ULONG) 0x0000000A)
#define MAPI_SESSION ((ULONG) 0x0000000B)
#define MAPI_FORMINFO ((ULONG) 0x0000000C)

#ifndef cchProfileNameMax
#define cchProfileNameMax 64
#define cchProfilePassMax 64
#endif

#define MV_FLAG 0x1000

#define PT_UNSPECIFIED ((ULONG) 0)
#define PT_NULL ((ULONG) 1)
#define PT_I2 ((ULONG) 2)
#define PT_LONG ((ULONG) 3)
#define PT_R4 ((ULONG) 4)
#define PT_DOUBLE ((ULONG) 5)
#define PT_CURRENCY ((ULONG) 6)
#define PT_APPTIME ((ULONG) 7)
#define PT_ERROR ((ULONG) 10)
#define PT_BOOLEAN ((ULONG) 11)
#define PT_OBJECT ((ULONG) 13)
#define PT_I8 ((ULONG) 20)
#define PT_STRING8 ((ULONG) 30)
#define PT_UNICODE ((ULONG) 31)
#define PT_SYSTIME ((ULONG) 64)
#define PT_CLSID ((ULONG) 72)
#define PT_BINARY ((ULONG) 258)

#define PT_SHORT PT_I2
#define PT_I4 PT_LONG
#define PT_FLOAT PT_R4
#define PT_R8 PT_DOUBLE
#define PT_LONGLONG PT_I8

#if defined(UNICODE)
#define PT_TSTRING PT_UNICODE
#define PT_MV_TSTRING (MV_FLAG|PT_UNICODE)
#define LPSZ lpszW
#define LPPSZ lppszW
#define MVSZ MVszW
#else
#define PT_TSTRING PT_STRING8
#define PT_MV_TSTRING (MV_FLAG|PT_STRING8)
#define LPSZ lpszA
#define LPPSZ lppszA
#define MVSZ MVszA
#endif

#define PROP_TYPE_MASK ((ULONG)0x0000FFFF)
#define PROP_TYPE(ulPropTag) (((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag) (((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID) ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL 0
#define PROP_ID_INVALID 0xFFFF
#define PR_NULL PROP_TAG(PT_NULL,PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag,ulPropType) (((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)

#define PT_MV_I2 (MV_FLAG|PT_I2)
#define PT_MV_LONG (MV_FLAG|PT_LONG)
#define PT_MV_R4 (MV_FLAG|PT_R4)
#define PT_MV_DOUBLE (MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY (MV_FLAG|PT_CURRENCY)
#define PT_MV_APPTIME (MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME (MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8 (MV_FLAG|PT_STRING8)
#define PT_MV_BINARY (MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE (MV_FLAG|PT_UNICODE)
#define PT_MV_CLSID (MV_FLAG|PT_CLSID)
#define PT_MV_I8 (MV_FLAG|PT_I8)

#define PT_MV_SHORT PT_MV_I2
#define PT_MV_I4 PT_MV_LONG
#define PT_MV_FLOAT PT_MV_R4
#define PT_MV_R8 PT_MV_DOUBLE
#define PT_MV_LONGLONG PT_MV_I8

#define MV_INSTANCE 0x2000
#define MVI_FLAG (MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag) ((tag) | MVI_FLAG)

  typedef struct _SPropTagArray {
    ULONG cValues;
    ULONG aulPropTag[MAPI_DIM];
  } SPropTagArray,*LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) (offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) (offsetof(SPropTagArray,aulPropTag) + (UINT)((_lparray)->cValues)*sizeof(ULONG))
#define SizedSPropTagArray(_ctag,_name) struct _SPropTagArray_ ## _name { ULONG cValues; ULONG aulPropTag[_ctag]; } _name

  typedef struct _SPropValue SPropValue;

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
  typedef union tagCY {
    struct {
      unsigned __LONG32 Lo;
      __LONG32 Hi;
    };
    LONGLONG int64;
  } CY;
#endif

  typedef CY CURRENCY;

  typedef struct _SBinary {
    ULONG cb;
    LPBYTE lpb;
  } SBinary,*LPSBinary;

  typedef struct _SShortArray {
    ULONG cValues;
    short int *lpi;
  } SShortArray;

  typedef struct _SGuidArray {
    ULONG cValues;
    GUID *lpguid;
  } SGuidArray;

  typedef struct _SRealArray {
    ULONG cValues;
    float *lpflt;
  } SRealArray;

  typedef struct _SLongArray {
    ULONG cValues;
    LONG *lpl;
  } SLongArray;

  typedef struct _SLargeIntegerArray {
    ULONG cValues;
    LARGE_INTEGER *lpli;
  } SLargeIntegerArray;

  typedef struct _SDateTimeArray {
    ULONG cValues;
    FILETIME *lpft;
  } SDateTimeArray;

  typedef struct _SAppTimeArray {
    ULONG cValues;
    double *lpat;
  } SAppTimeArray;

  typedef struct _SCurrencyArray {
    ULONG cValues;
    CURRENCY *lpcur;
  } SCurrencyArray;

  typedef struct _SBinaryArray {
    ULONG cValues;
    SBinary *lpbin;
  } SBinaryArray;

  typedef struct _SDoubleArray {
    ULONG cValues;
    double *lpdbl;
  } SDoubleArray;

  typedef struct _SWStringArray {
    ULONG cValues;
    LPWSTR *lppszW;
  } SWStringArray;

  typedef struct _SLPSTRArray {
    ULONG cValues;
    LPSTR *lppszA;
  } SLPSTRArray;

  typedef union _PV {
    short int i;
    LONG l;
    ULONG ul;
    float flt;
    double dbl;
    unsigned short int b;
    CURRENCY cur;
    double at;
    FILETIME ft;
    LPSTR lpszA;
    SBinary bin;
    LPWSTR lpszW;
    LPGUID lpguid;
    LARGE_INTEGER li;
    SShortArray MVi;
    SLongArray MVl;
    SRealArray MVflt;
    SDoubleArray MVdbl;
    SCurrencyArray MVcur;
    SAppTimeArray MVat;
    SDateTimeArray MVft;
    SBinaryArray MVbin;
    SLPSTRArray MVszA;
    SWStringArray MVszW;
    SGuidArray MVguid;
    SLargeIntegerArray MVli;
    SCODE err;
    LONG x;
  } __UPV;

  typedef struct _SPropValue {
    ULONG ulPropTag;
    ULONG dwAlignPad;
    union _PV Value;
  } SPropValue,*LPSPropValue;

  typedef struct _SPropProblem {
    ULONG ulIndex;
    ULONG ulPropTag;
    SCODE scode;
  } SPropProblem,*LPSPropProblem;

  typedef struct _SPropProblemArray {
    ULONG cProblem;
    SPropProblem aProblem[MAPI_DIM];
  } SPropProblemArray,*LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) (offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) (offsetof(SPropProblemArray,aProblem) + (UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob,_name) struct _SPropProblemArray_ ## _name { ULONG cProblem; SPropProblem aProblem[_cprob]; } _name

  typedef SBinaryArray ENTRYLIST,*LPENTRYLIST;

  typedef struct {
    ULONG cb;
    BYTE abEntry[MAPI_DIM];
  } FLATENTRY,*LPFLATENTRY;

  typedef struct {
    ULONG cEntries;
    ULONG cbEntries;
    BYTE abEntries[MAPI_DIM];
  } FLATENTRYLIST,*LPFLATENTRYLIST;

  typedef struct {
    ULONG cb;
    BYTE ab[MAPI_DIM];
  } MTSID,*LPMTSID;

  typedef struct {
    ULONG cMTSIDs;
    ULONG cbMTSIDs;
    BYTE abMTSIDs[MAPI_DIM];
  } FLATMTSIDLIST,*LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb) (offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry) (offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb) (offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb) (offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry) (offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)

  typedef struct _ADRENTRY {
    ULONG ulReserved1;
    ULONG cValues;
    LPSPropValue rgPropVals;
  } ADRENTRY,*LPADRENTRY;

  typedef struct _ADRLIST {
    ULONG cEntries;
    ADRENTRY aEntries[MAPI_DIM];
  } ADRLIST,*LPADRLIST;

#define CbNewADRLIST(_centries) (offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) (offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries,_name) struct _ADRLIST_ ## _name { ULONG cEntries; ADRENTRY aEntries[_centries]; } _name

  typedef struct _SRow {
    ULONG ulAdrEntryPad;
    ULONG cValues;
    LPSPropValue lpProps;
  } SRow,*LPSRow;

  typedef struct _SRowSet {
    ULONG cRows;
    SRow aRow[MAPI_DIM];
  } SRowSet,*LPSRowSet;

#define CbNewSRowSet(_crow) (offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset) (offsetof(SRowSet,aRow) + (UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow,_name) struct _SRowSet_ ## _name { ULONG cRows; SRow aRow[_crow]; } _name

  typedef SCODE (WINAPI ALLOCATEBUFFER)(ULONG cbSize,LPVOID *lppBuffer);
  typedef SCODE (WINAPI ALLOCATEMORE)(ULONG cbSize,LPVOID lpObject,LPVOID *lppBuffer);
  typedef ULONG (WINAPI FREEBUFFER)(LPVOID lpBuffer);
  typedef ALLOCATEBUFFER *LPALLOCATEBUFFER;
  typedef ALLOCATEMORE *LPALLOCATEMORE;
  typedef FREEBUFFER *LPFREEBUFFER;

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface) typedef struct iface##Vtbl iface##Vtbl,*iface; struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface,baseiface) DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface,piface) typedef struct iface##Vtbl iface##Vtbl,*iface,**piface;
#else
#define DECLARE_MAPI_INTERFACE(iface) DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface,baseiface) DECLARE_INTERFACE_(iface,baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface,piface) struct iface; typedef iface *piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface,piface) typedef struct iface iface,*piface
#endif
#endif

#define MAPIMETHOD(method) MAPIMETHOD_(HRESULT,method)
#define MAPIMETHOD_(type,method) STDMETHOD_(type,method)
#define MAPIMETHOD_DECLARE(type,method,prefix) STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type,method,prefix) typedef type (WINAPI prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE) MAPIMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppvObj) IPURE; MAPIMETHOD_(ULONG,AddRef) (THIS) IPURE; MAPIMETHOD_(ULONG,Release) (THIS) IPURE;
#undef IMPL
#define IMPL

  typedef const IID *LPCIID;

  DECLARE_MAPI_INTERFACE_PTR(IMsgStore,LPMDB);
  DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,LPMAPIFOLDER);
  DECLARE_MAPI_INTERFACE_PTR(IMessage,LPMESSAGE);
  DECLARE_MAPI_INTERFACE_PTR(IAttach,LPATTACH);
  DECLARE_MAPI_INTERFACE_PTR(IAddrBook,LPADRBOOK);
  DECLARE_MAPI_INTERFACE_PTR(IABContainer,LPABCONT);
  DECLARE_MAPI_INTERFACE_PTR(IMailUser,LPMAILUSER);
  DECLARE_MAPI_INTERFACE_PTR(IDistList,LPDISTLIST);
  DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,LPMAPISTATUS);
  DECLARE_MAPI_INTERFACE_PTR(IMAPITable,LPMAPITABLE);
  DECLARE_MAPI_INTERFACE_PTR(IProfSect,LPPROFSECT);
  DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,LPMAPIPROP);
  DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,LPMAPICONTAINER);
  DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink,LPMAPIADVISESINK);
  DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,LPMAPIPROGRESS);
  DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,LPPROVIDERADMIN);

  typedef struct _MAPIERROR {
    ULONG ulVersion;
    LPTSTR lpszError;
    LPTSTR lpszComponent;
    ULONG ulLowLevelError;
    ULONG ulContext;

  } MAPIERROR,*LPMAPIERROR;

#define fnevCriticalError ((ULONG) 0x00000001)
#define fnevNewMail ((ULONG) 0x00000002)
#define fnevObjectCreated ((ULONG) 0x00000004)
#define fnevObjectDeleted ((ULONG) 0x00000008)
#define fnevObjectModified ((ULONG) 0x00000010)
#define fnevObjectMoved ((ULONG) 0x00000020)
#define fnevObjectCopied ((ULONG) 0x00000040)
#define fnevSearchComplete ((ULONG) 0x00000080)
#define fnevTableModified ((ULONG) 0x00000100)
#define fnevStatusObjectModified ((ULONG) 0x00000200)
#define fnevReservedForMapi ((ULONG) 0x40000000)
#define fnevExtended ((ULONG) 0x80000000)

#define TABLE_CHANGED 1
#define TABLE_ERROR 2
#define TABLE_ROW_ADDED 3
#define TABLE_ROW_DELETED 4
#define TABLE_ROW_MODIFIED 5
#define TABLE_SORT_DONE 6
#define TABLE_RESTRICT_DONE 7
#define TABLE_SETCOL_DONE 8
#define TABLE_RELOAD 9

  typedef struct _ERROR_NOTIFICATION {
    ULONG cbEntryID;
    LPENTRYID lpEntryID;
    SCODE scode;
    ULONG ulFlags;
    LPMAPIERROR lpMAPIError;
  } ERROR_NOTIFICATION;

  typedef struct _NEWMAIL_NOTIFICATION {
    ULONG cbEntryID;
    LPENTRYID lpEntryID;
    ULONG cbParentID;
    LPENTRYID lpParentID;
    ULONG ulFlags;
    LPTSTR lpszMessageClass;
    ULONG ulMessageFlags;
  } NEWMAIL_NOTIFICATION;

  typedef struct _OBJECT_NOTIFICATION {
    ULONG cbEntryID;
    LPENTRYID lpEntryID;
    ULONG ulObjType;
    ULONG cbParentID;
    LPENTRYID lpParentID;
    ULONG cbOldID;
    LPENTRYID lpOldID;
    ULONG cbOldParentID;
    LPENTRYID lpOldParentID;
    LPSPropTagArray lpPropTagArray;
  } OBJECT_NOTIFICATION;

  typedef struct _TABLE_NOTIFICATION {
    ULONG ulTableEvent;
    HRESULT hResult;
    SPropValue propIndex;
    SPropValue propPrior;
    SRow row;
    ULONG ulPad;
  } TABLE_NOTIFICATION;

  typedef struct _EXTENDED_NOTIFICATION {
    ULONG ulEvent;
    ULONG cb;
    LPBYTE pbEventParameters;
  } EXTENDED_NOTIFICATION;

  typedef struct {
    ULONG cbEntryID;
    LPENTRYID lpEntryID;
    ULONG cValues;
    LPSPropValue lpPropVals;
  } STATUS_OBJECT_NOTIFICATION;

  typedef struct _NOTIFICATION {
    ULONG ulEventType;
    ULONG ulAlignPad;
    union {
      ERROR_NOTIFICATION err;
      NEWMAIL_NOTIFICATION newmail;
      OBJECT_NOTIFICATION obj;
      TABLE_NOTIFICATION tab;
      EXTENDED_NOTIFICATION ext;
      STATUS_OBJECT_NOTIFICATION statobj;
    } info;
  } NOTIFICATION,*LPNOTIFICATION;

#define MAPI_IMAPIADVISESINK_METHODS(IPURE) MAPIMETHOD_(ULONG,OnNotify) (THIS_ ULONG cNotif,LPNOTIFICATION lpNotifications) IPURE;
#undef INTERFACE
#define INTERFACE IMAPIAdviseSink
  DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink,IUnknown) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIADVISESINK_METHODS(PURE)
  };

  typedef __LONG32 (WINAPI NOTIFCALLBACK) (LPVOID lpvContext,ULONG cNotification,LPNOTIFICATION lpNotifications);
  typedef NOTIFCALLBACK *LPNOTIFCALLBACK;

#define szMAPINotificationMsg "MAPI Notify window message"

#define MAPI_TOP_LEVEL ((ULONG) 0x00000001)
#define MAPI_IMAPIPROGRESS_METHODS(IPURE) MAPIMETHOD(Progress) (THIS_ ULONG ulValue,ULONG ulCount,ULONG ulTotal) IPURE; MAPIMETHOD(GetFlags) (THIS_ ULONG *lpulFlags) IPURE; MAPIMETHOD(GetMax) (THIS_ ULONG *lpulMax) IPURE; MAPIMETHOD(GetMin) (THIS_ ULONG *lpulMin) IPURE; MAPIMETHOD(SetLimits) (THIS_ LPULONG lpulMin,LPULONG lpulMax,LPULONG lpulFlags) IPURE;

#undef INTERFACE
#define INTERFACE IMAPIProgress
  DECLARE_MAPI_INTERFACE_(IMAPIProgress,IUnknown) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROGRESS_METHODS(PURE)
  };

#define MAPI_ERROR_VERSION __MSABI_LONG(0x00000000)

#define KEEP_OPEN_READONLY ((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE ((ULONG) 0x00000002)
#define FORCE_SAVE ((ULONG) 0x00000004)

#define MAPI_CREATE ((ULONG) 0x00000002)
#define STREAM_APPEND ((ULONG) 0x00000004)

#define MAPI_MOVE ((ULONG) 0x00000001)
#define MAPI_NOREPLACE ((ULONG) 0x00000002)
#define MAPI_DECLINE_OK ((ULONG) 0x00000004)

#ifndef MAPI_DIALOG
#define MAPI_DIALOG ((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT
#define MAPI_USE_DEFAULT 0x00000040
#endif

#define MAPI_NO_STRINGS ((ULONG) 0x00000001)
#define MAPI_NO_IDS ((ULONG) 0x00000002)

#define MNID_ID 0
#define MNID_STRING 1

  typedef struct _MAPINAMEID {
    LPGUID lpguid;
    ULONG ulKind;
    union {
      LONG lID;
      LPWSTR lpwstrName;
    } Kind;
  } MAPINAMEID,*LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE) MAPIMETHOD(GetLastError) (THIS_ HRESULT hResult,ULONG ulFlags,LPMAPIERROR *lppMAPIError) IPURE; MAPIMETHOD(SaveChanges) (THIS_ ULONG ulFlags) IPURE; MAPIMETHOD(GetProps) (THIS_ LPSPropTagArray lpPropTagArray,ULONG ulFlags,ULONG *lpcValues,LPSPropValue *lppPropArray) IPURE; MAPIMETHOD(GetPropList) (THIS_ ULONG ulFlags,LPSPropTagArray *lppPropTagArray) IPURE; MAPIMETHOD(OpenProperty) (THIS_ ULONG ulPropTag,LPCIID lpiid,ULONG ulInterfaceOptions,ULONG ulFlags,LPUNKNOWN *lppUnk) IPURE; MAPIMETHOD(SetProps) (THIS_ ULONG cValues,LPSPropValue lpPropArray,LPSPropProblemArray *lppProblems) IPURE; MAPIMETHOD(DeleteProps) (THIS_ LPSPropTagArray lpPropTagArray,LPSPropProblemArray *lppProblems) IPURE; MAPIMETHOD(CopyTo) (THIS_ ULONG ciidExclude,LPCIID rgiidExclude,LPSPropTagArray lpExcludeProps,ULONG ulUIParam,LPMAPIPROGRESS lpProgress,LPCIID lpInterface,LPVOID lpDestObj,ULONG ulFlags,LPSPropProblemArray *lppProblems) IPURE; MAPIMETHOD(CopyProps) (THIS_ LPSPropTagArray lpIncludeProps,ULONG ulUIParam,LPMAPIPROGRESS lpProgress,LPCIID lpInterface,LPVOID lpDestObj,ULONG ulFlags,LPSPropProblemArray *lppProblems) IPURE; MAPIMETHOD(GetNamesFromIDs) (THIS_ LPSPropTagArray *lppPropTags,LPGUID lpPropSetGuid,ULONG ulFlags,ULONG *lpcPropNames,LPMAPINAMEID **lpppPropNames) IPURE; MAPIMETHOD(GetIDsFromNames) (THIS_ ULONG cPropNames,LPMAPINAMEID *lppPropNames,ULONG ulFlags,LPSPropTagArray *lppPropTags) IPURE;

#undef INTERFACE
#define INTERFACE IMAPIProp
  DECLARE_MAPI_INTERFACE_(IMAPIProp,IUnknown) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
  };

#define TBLSTAT_COMPLETE ((ULONG) 0)
#define TBLSTAT_QCHANGED ((ULONG) 7)
#define TBLSTAT_SORTING ((ULONG) 9)
#define TBLSTAT_SORT_ERROR ((ULONG) 10)
#define TBLSTAT_SETTING_COLS ((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR ((ULONG) 13)
#define TBLSTAT_RESTRICTING ((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR ((ULONG) 15)

#define TBLTYPE_SNAPSHOT ((ULONG) 0)
#define TBLTYPE_KEYSET ((ULONG) 1)
#define TBLTYPE_DYNAMIC ((ULONG) 2)

#define TABLE_SORT_ASCEND ((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND ((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE ((ULONG) 0x00000002)

  typedef struct _SSortOrder {
    ULONG ulPropTag;
    ULONG ulOrder;
  } SSortOrder,*LPSSortOrder;

  typedef struct _SSortOrderSet {
    ULONG cSorts;
    ULONG cCategories;
    ULONG cExpanded;
    SSortOrder aSort[MAPI_DIM];
  } SSortOrderSet,*LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) (offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) (offsetof(SSortOrderSet,aSort) + (UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort,_name) struct _SSortOrderSet_ ## _name { ULONG cSorts; ULONG cCategories; ULONG cExpanded; SSortOrder aSort[_csort]; } _name

  typedef ULONG BOOKMARK;

#define BOOKMARK_BEGINNING ((BOOKMARK) 0)
#define BOOKMARK_CURRENT ((BOOKMARK) 1)
#define BOOKMARK_END ((BOOKMARK) 2)

#define FL_FULLSTRING ((ULONG) 0x00000000)
#define FL_SUBSTRING ((ULONG) 0x00000001)
#define FL_PREFIX ((ULONG) 0x00000002)

#define FL_IGNORECASE ((ULONG) 0x00010000)
#define FL_IGNORENONSPACE ((ULONG) 0x00020000)
#define FL_LOOSE ((ULONG) 0x00040000)

  typedef struct _SRestriction *LPSRestriction;

#define RES_AND ((ULONG) 0x00000000)
#define RES_OR ((ULONG) 0x00000001)
#define RES_NOT ((ULONG) 0x00000002)
#define RES_CONTENT ((ULONG) 0x00000003)
#define RES_PROPERTY ((ULONG) 0x00000004)
#define RES_COMPAREPROPS ((ULONG) 0x00000005)
#define RES_BITMASK ((ULONG) 0x00000006)
#define RES_SIZE ((ULONG) 0x00000007)
#define RES_EXIST ((ULONG) 0x00000008)
#define RES_SUBRESTRICTION ((ULONG) 0x00000009)
#define RES_COMMENT ((ULONG) 0x0000000A)

#define RELOP_LT ((ULONG) 0)
#define RELOP_LE ((ULONG) 1)
#define RELOP_GT ((ULONG) 2)
#define RELOP_GE ((ULONG) 3)
#define RELOP_EQ ((ULONG) 4)
#define RELOP_NE ((ULONG) 5)
#define RELOP_RE ((ULONG) 6)

#define BMR_EQZ ((ULONG) 0)
#define BMR_NEZ ((ULONG) 1)

  typedef struct _SAndRestriction {
    ULONG cRes;
    LPSRestriction lpRes;
  } SAndRestriction;

  typedef struct _SOrRestriction {
    ULONG cRes;
    LPSRestriction lpRes;
  } SOrRestriction;

  typedef struct _SNotRestriction {
    ULONG ulReserved;
    LPSRestriction lpRes;
  } SNotRestriction;

  typedef struct _SContentRestriction {
    ULONG ulFuzzyLevel;
    ULONG ulPropTag;
    LPSPropValue lpProp;
  } SContentRestriction;

  typedef struct _SBitMaskRestriction {
    ULONG relBMR;
    ULONG ulPropTag;
    ULONG ulMask;
  } SBitMaskRestriction;

  typedef struct _SPropertyRestriction {
    ULONG relop;
    ULONG ulPropTag;
    LPSPropValue lpProp;
  } SPropertyRestriction;

  typedef struct _SComparePropsRestriction {
    ULONG relop;
    ULONG ulPropTag1;
    ULONG ulPropTag2;
  } SComparePropsRestriction;

  typedef struct _SSizeRestriction {
    ULONG relop;
    ULONG ulPropTag;
    ULONG cb;
  } SSizeRestriction;

  typedef struct _SExistRestriction {
    ULONG ulReserved1;
    ULONG ulPropTag;
    ULONG ulReserved2;
  } SExistRestriction;

  typedef struct _SSubRestriction {
    ULONG ulSubObject;
    LPSRestriction lpRes;
  } SSubRestriction;

  typedef struct _SCommentRestriction {
    ULONG cValues;
    LPSRestriction lpRes;
    LPSPropValue lpProp;
  } SCommentRestriction;

  typedef struct _SRestriction {
    ULONG rt;
    union {
      SComparePropsRestriction resCompareProps;
      SAndRestriction resAnd;
      SOrRestriction resOr;
      SNotRestriction resNot;
      SContentRestriction resContent;
      SPropertyRestriction resProperty;
      SBitMaskRestriction resBitMask;
      SSizeRestriction resSize;
      SExistRestriction resExist;
      SSubRestriction resSub;
      SCommentRestriction resComment;
    } res;
  } SRestriction;

#define TBL_ALL_COLUMNS ((ULONG) 0x00000001)

#define TBL_LEAF_ROW ((ULONG) 1)
#define TBL_EMPTY_CATEGORY ((ULONG) 2)
#define TBL_EXPANDED_CATEGORY ((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY ((ULONG) 4)

#define TBL_NOWAIT ((ULONG) 0x00000001)

#define TBL_ASYNC ((ULONG) 0x00000001)
#define TBL_BATCH ((ULONG) 0x00000002)

#define DIR_BACKWARD ((ULONG) 0x00000001)

#define TBL_NOADVANCE ((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE) MAPIMETHOD(GetLastError) (THIS_ HRESULT hResult,ULONG ulFlags,LPMAPIERROR *lppMAPIError) IPURE; MAPIMETHOD(Advise) (THIS_ ULONG ulEventMask,LPMAPIADVISESINK lpAdviseSink,ULONG *lpulConnection) IPURE; MAPIMETHOD(Unadvise) (THIS_ ULONG ulConnection) IPURE; MAPIMETHOD(GetStatus) (THIS_ ULONG *lpulTableStatus,ULONG *lpulTableType) IPURE; MAPIMETHOD(SetColumns) (THIS_ LPSPropTagArray lpPropTagArray,ULONG ulFlags) IPURE; MAPIMETHOD(QueryColumns) (THIS_ ULONG ulFlags,LPSPropTagArray *lpPropTagArray) IPURE; MAPIMETHOD(GetRowCount) (THIS_ ULONG ulFlags,ULONG *lpulCount) IPURE; MAPIMETHOD(SeekRow) (THIS_ BOOKMARK bkOrigin,LONG lRowCount,LONG *lplRowsSought) IPURE; MAPIMETHOD(SeekRowApprox) (THIS_ ULONG ulNumerator,ULONG ulDenominator) IPURE; MAPIMETHOD(QueryPosition) (THIS_ ULONG *lpulRow,ULONG *lpulNumerator,ULONG *lpulDenominator) IPURE; MAPIMETHOD(FindRow) (THIS_ LPSRestriction lpRestriction,BOOKMARK bkOrigin,ULONG ulFlags) IPURE; MAPIMETHOD(Restrict) (THIS_ LPSRestriction lpRestriction,ULONG ulFlags) IPURE; MAPIMETHOD(CreateBookmark) (THIS_ BOOKMARK *lpbkPosition) IPURE; MAPIMETHOD(FreeBookmark) (THIS_ BOOKMARK bkPosition) IPURE; MAPIMETHOD(SortTable) (THIS_ LPSSortOrderSet lpSortCriteria,ULONG ulFlags) IPURE; MAPIMETHOD(QuerySortOrder) (THIS_ LPSSortOrderSet *lppSortCriteria) IPURE; MAPIMETHOD(QueryRows) (THIS_ LONG lRowCount,ULONG ulFlags,LPSRowSet *lppRows) IPURE; MAPIMETHOD(Abort) (THIS) IPURE; MAPIMETHOD(ExpandRow) (THIS_ ULONG cbInstanceKey,LPBYTE pbInstanceKey,ULONG ulRowCount,ULONG ulFlags,LPSRowSet *lppRows,ULONG *lpulMoreRows) IPURE; MAPIMETHOD(CollapseRow) (THIS_ ULONG cbInstanceKey,LPBYTE pbInstanceKey,ULONG ulFlags,ULONG *lpulRowCount) IPURE; MAPIMETHOD(WaitForCompletion) (THIS_ ULONG ulFlags,ULONG ulTimeout,ULONG *lpulTableStatus) IPURE; MAPIMETHOD(GetCollapseState) (THIS_ ULONG ulFlags,ULONG cbInstanceKey,LPBYTE lpbInstanceKey,ULONG *lpcbCollapseState,LPBYTE *lppbCollapseState) IPURE; MAPIMETHOD(SetCollapseState) (THIS_ ULONG ulFlags,ULONG cbCollapseState,LPBYTE pbCollapseState,BOOKMARK *lpbkLocation) IPURE;

#undef INTERFACE
#define INTERFACE IMAPITable
  DECLARE_MAPI_INTERFACE_(IMAPITable,IUnknown) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPITABLE_METHODS(PURE)
  };

#define PS_PROFILE_PROPERTIES_INIT { 0x98,0x15,0xAC,0x08,0xAA,0xB0,0x10,0x1A,0x8C,0x93,0x08,0x00,0x2B,0x2A,0x56,0xC2 }

#define MAPI_IPROFSECT_METHODS(IPURE)

#undef INTERFACE
#define INTERFACE IProfSect
  DECLARE_MAPI_INTERFACE_(IProfSect,IMAPIProp) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
      MAPI_IPROFSECT_METHODS(PURE)
  };

#define MAPI_STORE_PROVIDER ((ULONG) 33)
#define MAPI_AB ((ULONG) 34)
#define MAPI_AB_PROVIDER ((ULONG) 35)
#define MAPI_TRANSPORT_PROVIDER ((ULONG) 36)
#define MAPI_SPOOLER ((ULONG) 37)
#define MAPI_PROFILE_PROVIDER ((ULONG) 38)
#define MAPI_SUBSYSTEM ((ULONG) 39)
#define MAPI_HOOK_PROVIDER ((ULONG) 40)

#define STATUS_VALIDATE_STATE ((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG ((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD ((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES ((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND ((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE ((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY ((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE ((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST ((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE ((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION ((ULONG) 0x00000080)
#define STATUS_OWN_STORE ((ULONG) 0x00000100)

#define STATUS_NEED_IPM_TREE ((ULONG) 0x00000800)
#define STATUS_PRIMARY_STORE ((ULONG) 0x00001000)
#define STATUS_SECONDARY_STORE ((ULONG) 0x00002000)

#define STATUS_AVAILABLE ((ULONG) 0x00000001)
#define STATUS_OFFLINE ((ULONG) 0x00000002)
#define STATUS_FAILURE ((ULONG) 0x00000004)

#define STATUS_INBOUND_ENABLED ((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE ((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH ((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED ((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE ((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH ((ULONG) 0x00400000)
#define STATUS_REMOTE_ACCESS ((ULONG) 0x00800000)

#define SUPPRESS_UI ((ULONG) 0x00000001)
#define REFRESH_XP_HEADER_CACHE ((ULONG) 0x00010000)
#define PROCESS_XP_HEADER_CACHE ((ULONG) 0x00020000)
#define FORCE_XP_CONNECT ((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT ((ULONG) 0x00080000)
#define CONFIG_CHANGED ((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION ((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI ((ULONG) 0x00400000)

#define UI_READONLY ((ULONG) 0x00000001)

#define FLUSH_UPLOAD ((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD ((ULONG) 0x00000004)
#define FLUSH_FORCE ((ULONG) 0x00000008)
#define FLUSH_NO_UI ((ULONG) 0x00000010)
#define FLUSH_ASYNC_OK ((ULONG) 0x00000020)

#define MAPI_IMAPISTATUS_METHODS(IPURE) MAPIMETHOD(ValidateState) (THIS_ ULONG ulUIParam,ULONG ulFlags) IPURE; MAPIMETHOD(SettingsDialog) (THIS_ ULONG ulUIParam,ULONG ulFlags) IPURE; MAPIMETHOD(ChangePassword) (THIS_ LPTSTR lpOldPass,LPTSTR lpNewPass,ULONG ulFlags) IPURE; MAPIMETHOD(FlushQueues) (THIS_ ULONG ulUIParam,ULONG cbTargetTransport,LPENTRYID lpTargetTransport,ULONG ulFlags) IPURE;

#undef INTERFACE
#define INTERFACE IMAPIStatus
  DECLARE_MAPI_INTERFACE_(IMAPIStatus,IMAPIProp) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
      MAPI_IMAPISTATUS_METHODS(PURE)
  };

#define MAPI_BEST_ACCESS ((ULONG) 0x00000010)

#define WAB_LOCAL_CONTAINERS 0x00100000
#define WAB_PROFILE_CONTENTS 0x00200000

#define CONVENIENT_DEPTH ((ULONG) 0x00000001)

#define SEARCH_RUNNING ((ULONG) 0x00000001)
#define SEARCH_REBUILD ((ULONG) 0x00000002)
#define SEARCH_RECURSIVE ((ULONG) 0x00000004)
#define SEARCH_FOREGROUND ((ULONG) 0x00000008)

#define STOP_SEARCH ((ULONG) 0x00000001)
#define RESTART_SEARCH ((ULONG) 0x00000002)
#define RECURSIVE_SEARCH ((ULONG) 0x00000004)
#define SHALLOW_SEARCH ((ULONG) 0x00000008)
#define FOREGROUND_SEARCH ((ULONG) 0x00000010)
#define BACKGROUND_SEARCH ((ULONG) 0x00000020)

#define MAPI_IMAPICONTAINER_METHODS(IPURE) MAPIMETHOD(GetContentsTable) (THIS_ ULONG ulFlags,LPMAPITABLE *lppTable) IPURE; MAPIMETHOD(GetHierarchyTable) (THIS_ ULONG ulFlags,LPMAPITABLE *lppTable) IPURE; MAPIMETHOD(OpenEntry) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,LPCIID lpInterface,ULONG ulFlags,ULONG *lpulObjType,LPUNKNOWN *lppUnk) IPURE; MAPIMETHOD(SetSearchCriteria) (THIS_ LPSRestriction lpRestriction,LPENTRYLIST lpContainerList,ULONG ulSearchFlags) IPURE; MAPIMETHOD(GetSearchCriteria) (THIS_ ULONG ulFlags,LPSRestriction *lppRestriction,LPENTRYLIST *lppContainerList,ULONG *lpulSearchState)IPURE;

#undef INTERFACE
#define INTERFACE IMAPIContainer
  DECLARE_MAPI_INTERFACE_(IMAPIContainer,IMAPIProp) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
      MAPI_IMAPICONTAINER_METHODS(PURE)
  };

  typedef struct _flaglist {
    ULONG cFlags;
    ULONG ulFlag[MAPI_DIM];
  } FlagList,*LPFlagList;

#define AB_RECIPIENTS ((ULONG) 0x00000001)
#define AB_SUBCONTAINERS ((ULONG) 0x00000002)
#define AB_MODIFIABLE ((ULONG) 0x00000004)
#define AB_UNMODIFIABLE ((ULONG) 0x00000008)
#define AB_FIND_ON_OPEN ((ULONG) 0x00000010)
#define AB_NOT_DEFAULT ((ULONG) 0x00000020)

#define CREATE_CHECK_DUP_STRICT ((ULONG) 0x00000001)
#define CREATE_CHECK_DUP_LOOSE ((ULONG) 0x00000002)
#define CREATE_REPLACE ((ULONG) 0x00000004)
#define CREATE_MERGE ((ULONG) 0x00000008)

#define WAB_IGNORE_PROFILES 0x00800000

#define MAPI_UNRESOLVED ((ULONG) 0x00000000)
#define MAPI_AMBIGUOUS ((ULONG) 0x00000001)
#define MAPI_RESOLVED ((ULONG) 0x00000002)

#define MAPI_IABCONTAINER_METHODS(IPURE) MAPIMETHOD(CreateEntry) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,ULONG ulCreateFlags,LPMAPIPROP *lppMAPIPropEntry) IPURE; MAPIMETHOD(CopyEntries) (THIS_ LPENTRYLIST lpEntries,ULONG ulUIParam,LPMAPIPROGRESS lpProgress,ULONG ulFlags) IPURE; MAPIMETHOD(DeleteEntries) (THIS_ LPENTRYLIST lpEntries,ULONG ulFlags) IPURE; MAPIMETHOD(ResolveNames) (THIS_ LPSPropTagArray lpPropTagArray,ULONG ulFlags,LPADRLIST lpAdrList,LPFlagList lpFlagList) IPURE;

#undef INTERFACE
#define INTERFACE IABContainer
  DECLARE_MAPI_INTERFACE_(IABContainer,IMAPIContainer) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
      MAPI_IMAPICONTAINER_METHODS(PURE)
      MAPI_IABCONTAINER_METHODS(PURE)
  };

#define MAPI_SEND_NO_RICH_INFO ((ULONG) 0x00010000)

#define MAPI_DIAG(_code) ((LONG) _code)
#define MAPI_DIAG_NO_DIAGNOSTIC MAPI_DIAG(-1)
#define MAPI_DIAG_OR_NAME_UNRECOGNIZED MAPI_DIAG(0)
#define MAPI_DIAG_OR_NAME_AMBIGUOUS MAPI_DIAG(1)
#define MAPI_DIAG_MTS_CONGESTED MAPI_DIAG(2)
#define MAPI_DIAG_LOOP_DETECTED MAPI_DIAG(3)
#define MAPI_DIAG_RECIPIENT_UNAVAILABLE MAPI_DIAG(4)
#define MAPI_DIAG_MAXIMUM_TIME_EXPIRED MAPI_DIAG(5)
#define MAPI_DIAG_EITS_UNSUPPORTED MAPI_DIAG(6)
#define MAPI_DIAG_CONTENT_TOO_LONG MAPI_DIAG(7)
#define MAPI_DIAG_IMPRACTICAL_TO_CONVERT MAPI_DIAG(8)
#define MAPI_DIAG_PROHIBITED_TO_CONVERT MAPI_DIAG(9)
#define MAPI_DIAG_CONVERSION_UNSUBSCRIBED MAPI_DIAG(10)
#define MAPI_DIAG_PARAMETERS_INVALID MAPI_DIAG(11)
#define MAPI_DIAG_CONTENT_SYNTAX_IN_ERROR MAPI_DIAG(12)
#define MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD MAPI_DIAG(13)
#define MAPI_DIAG_NUMBER_CONSTRAINT_VIOLATD MAPI_DIAG(14)
#define MAPI_DIAG_CONTENT_TYPE_UNSUPPORTED MAPI_DIAG(15)
#define MAPI_DIAG_TOO_MANY_RECIPIENTS MAPI_DIAG(16)
#define MAPI_DIAG_NO_BILATERAL_AGREEMENT MAPI_DIAG(17)
#define MAPI_DIAG_CRITICAL_FUNC_UNSUPPORTED MAPI_DIAG(18)
#define MAPI_DIAG_CONVERSION_LOSS_PROHIB MAPI_DIAG(19)
#define MAPI_DIAG_LINE_TOO_LONG MAPI_DIAG(20)
#define MAPI_DIAG_PAGE_TOO_LONG MAPI_DIAG(21)
#define MAPI_DIAG_PICTORIAL_SYMBOL_LOST MAPI_DIAG(22)
#define MAPI_DIAG_PUNCTUATION_SYMBOL_LOST MAPI_DIAG(23)
#define MAPI_DIAG_ALPHABETIC_CHARACTER_LOST MAPI_DIAG(24)
#define MAPI_DIAG_MULTIPLE_INFO_LOSSES MAPI_DIAG(25)
#define MAPI_DIAG_REASSIGNMENT_PROHIBITED MAPI_DIAG(26)
#define MAPI_DIAG_REDIRECTION_LOOP_DETECTED MAPI_DIAG(27)
#define MAPI_DIAG_EXPANSION_PROHIBITED MAPI_DIAG(28)
#define MAPI_DIAG_SUBMISSION_PROHIBITED MAPI_DIAG(29)
#define MAPI_DIAG_EXPANSION_FAILED MAPI_DIAG(30)
#define MAPI_DIAG_RENDITION_UNSUPPORTED MAPI_DIAG(31)
#define MAPI_DIAG_MAIL_ADDRESS_INCORRECT MAPI_DIAG(32)
#define MAPI_DIAG_MAIL_OFFICE_INCOR_OR_INVD MAPI_DIAG(33)
#define MAPI_DIAG_MAIL_ADDRESS_INCOMPLETE MAPI_DIAG(34)
#define MAPI_DIAG_MAIL_RECIPIENT_UNKNOWN MAPI_DIAG(35)
#define MAPI_DIAG_MAIL_RECIPIENT_DECEASED MAPI_DIAG(36)
#define MAPI_DIAG_MAIL_ORGANIZATION_EXPIRED MAPI_DIAG(37)
#define MAPI_DIAG_MAIL_REFUSED MAPI_DIAG(38)
#define MAPI_DIAG_MAIL_UNCLAIMED MAPI_DIAG(39)
#define MAPI_DIAG_MAIL_RECIPIENT_MOVED MAPI_DIAG(40)
#define MAPI_DIAG_MAIL_RECIPIENT_TRAVELLING MAPI_DIAG(41)
#define MAPI_DIAG_MAIL_RECIPIENT_DEPARTED MAPI_DIAG(42)
#define MAPI_DIAG_MAIL_NEW_ADDRESS_UNKNOWN MAPI_DIAG(43)
#define MAPI_DIAG_MAIL_FORWARDING_UNWANTED MAPI_DIAG(44)
#define MAPI_DIAG_MAIL_FORWARDING_PROHIB MAPI_DIAG(45)
#define MAPI_DIAG_SECURE_MESSAGING_ERROR MAPI_DIAG(46)
#define MAPI_DIAG_DOWNGRADING_IMPOSSIBLE MAPI_DIAG(47)

#define MAPI_IMAILUSER_METHODS(IPURE)

#undef INTERFACE
#define INTERFACE IMailUser
  DECLARE_MAPI_INTERFACE_(IMailUser,IMAPIProp) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
      MAPI_IMAILUSER_METHODS(PURE)
  };

#define MAPI_IDISTLIST_METHODS(IPURE) MAPIMETHOD(CreateEntry) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,ULONG ulCreateFlags,LPMAPIPROP *lppMAPIPropEntry) IPURE; MAPIMETHOD(CopyEntries) (THIS_ LPENTRYLIST lpEntries,ULONG ulUIParam,LPMAPIPROGRESS lpProgress,ULONG ulFlags) IPURE; MAPIMETHOD(DeleteEntries) (THIS_ LPENTRYLIST lpEntries,ULONG ulFlags) IPURE; MAPIMETHOD(ResolveNames) (THIS_ LPSPropTagArray lpPropTagArray,ULONG ulFlags,LPADRLIST lpAdrList,LPFlagList lpFlagList) IPURE;

#undef INTERFACE
#define INTERFACE IDistList
  DECLARE_MAPI_INTERFACE_(IDistList,IMAPIContainer) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
      MAPI_IMAPICONTAINER_METHODS(PURE)
      MAPI_IDISTLIST_METHODS(PURE)
  };

#define FOLDER_ROOT ((ULONG) 0x00000000)
#define FOLDER_GENERIC ((ULONG) 0x00000001)
#define FOLDER_SEARCH ((ULONG) 0x00000002)

#define MESSAGE_MOVE ((ULONG) 0x00000001)
#define MESSAGE_DIALOG ((ULONG) 0x00000002)

#define OPEN_IF_EXISTS ((ULONG) 0x00000001)

#define DEL_MESSAGES ((ULONG) 0x00000001)
#define FOLDER_DIALOG ((ULONG) 0x00000002)
#define DEL_FOLDERS ((ULONG) 0x00000004)

#define DEL_ASSOCIATED ((ULONG) 0x00000008)

#define FOLDER_MOVE ((ULONG) 0x00000001)

#define COPY_SUBFOLDERS ((ULONG) 0x00000010)

#define GENERATE_RECEIPT_ONLY ((ULONG) 0x00000010)

#define MSGSTATUS_HIGHLIGHTED ((ULONG) 0x00000001)
#define MSGSTATUS_TAGGED ((ULONG) 0x00000002)
#define MSGSTATUS_HIDDEN ((ULONG) 0x00000004)
#define MSGSTATUS_DELMARKED ((ULONG) 0x00000008)

#define MSGSTATUS_REMOTE_DOWNLOAD ((ULONG) 0x00001000)
#define MSGSTATUS_REMOTE_DELETE ((ULONG) 0x00002000)

#define RECURSIVE_SORT ((ULONG) 0x00000002)

#define FLDSTATUS_HIGHLIGHTED ((ULONG) 0x00000001)
#define FLDSTATUS_TAGGED ((ULONG) 0x00000002)
#define FLDSTATUS_HIDDEN ((ULONG) 0x00000004)
#define FLDSTATUS_DELMARKED ((ULONG) 0x00000008)

#define MAPI_IMAPIFOLDER_METHODS(IPURE) MAPIMETHOD(CreateMessage) (THIS_ LPCIID lpInterface,ULONG ulFlags,LPMESSAGE *lppMessage) IPURE; MAPIMETHOD(CopyMessages) (THIS_ LPENTRYLIST lpMsgList,LPCIID lpInterface,LPVOID lpDestFolder,ULONG ulUIParam,LPMAPIPROGRESS lpProgress,ULONG ulFlags) IPURE; MAPIMETHOD(DeleteMessages) (THIS_ LPENTRYLIST lpMsgList,ULONG ulUIParam,LPMAPIPROGRESS lpProgress,ULONG ulFlags) IPURE; MAPIMETHOD(CreateFolder) (THIS_ ULONG ulFolderType,LPTSTR lpszFolderName,LPTSTR lpszFolderComment,LPCIID lpInterface,ULONG ulFlags,LPMAPIFOLDER *lppFolder) IPURE; MAPIMETHOD(CopyFolder) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,LPCIID lpInterface,LPVOID lpDestFolder,LPTSTR lpszNewFolderName,ULONG ulUIParam,LPMAPIPROGRESS lpProgress,ULONG ulFlags) IPURE; MAPIMETHOD(DeleteFolder) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,ULONG ulUIParam,LPMAPIPROGRESS lpProgress,ULONG ulFlags) IPURE; MAPIMETHOD(SetReadFlags) (THIS_ LPENTRYLIST lpMsgList,ULONG ulUIParam,LPMAPIPROGRESS lpProgress,ULONG ulFlags) IPURE; MAPIMETHOD(GetMessageStatus) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,ULONG ulFlags,ULONG *lpulMessageStatus) IPURE; MAPIMETHOD(SetMessageStatus) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,ULONG ulNewStatus,ULONG ulNewStatusMask,ULONG *lpulOldStatus) IPURE; MAPIMETHOD(SaveContentsSort) (THIS_ LPSSortOrderSet lpSortCriteria,ULONG ulFlags) IPURE; MAPIMETHOD(EmptyFolder) (THIS_ ULONG ulUIParam,LPMAPIPROGRESS lpProgress,ULONG ulFlags) IPURE;

#undef INTERFACE
#define INTERFACE IMAPIFolder
  DECLARE_MAPI_INTERFACE_(IMAPIFolder,IMAPIContainer) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
      MAPI_IMAPICONTAINER_METHODS(PURE)
      MAPI_IMAPIFOLDER_METHODS(PURE)
  };

#define STORE_ENTRYID_UNIQUE ((ULONG) 0x00000001)
#define STORE_READONLY ((ULONG) 0x00000002)
#define STORE_SEARCH_OK ((ULONG) 0x00000004)
#define STORE_MODIFY_OK ((ULONG) 0x00000008)
#define STORE_CREATE_OK ((ULONG) 0x00000010)
#define STORE_ATTACH_OK ((ULONG) 0x00000020)
#define STORE_OLE_OK ((ULONG) 0x00000040)
#define STORE_SUBMIT_OK ((ULONG) 0x00000080)
#define STORE_NOTIFY_OK ((ULONG) 0x00000100)
#define STORE_MV_PROPS_OK ((ULONG) 0x00000200)
#define STORE_CATEGORIZE_OK ((ULONG) 0x00000400)
#define STORE_RTF_OK ((ULONG) 0x00000800)
#define STORE_RESTRICTION_OK ((ULONG) 0x00001000)
#define STORE_SORT_OK ((ULONG) 0x00002000)

#define STORE_HAS_SEARCHES ((ULONG) 0x01000000)

#define LOGOFF_NO_WAIT ((ULONG) 0x00000001)
#define LOGOFF_ORDERLY ((ULONG) 0x00000002)
#define LOGOFF_PURGE ((ULONG) 0x00000004)
#define LOGOFF_ABORT ((ULONG) 0x00000008)
#define LOGOFF_QUIET ((ULONG) 0x00000010)

#define LOGOFF_COMPLETE ((ULONG) 0x00010000)
#define LOGOFF_INBOUND ((ULONG) 0x00020000)
#define LOGOFF_OUTBOUND ((ULONG) 0x00040000)
#define LOGOFF_OUTBOUND_QUEUE ((ULONG) 0x00080000)

#define MSG_LOCKED ((ULONG) 0x00000001)
#define MSG_UNLOCKED ((ULONG) 0x00000000)

#define FOLDER_IPM_SUBTREE_VALID ((ULONG) 0x00000001)
#define FOLDER_IPM_INBOX_VALID ((ULONG) 0x00000002)
#define FOLDER_IPM_OUTBOX_VALID ((ULONG) 0x00000004)
#define FOLDER_IPM_WASTEBASKET_VALID ((ULONG) 0x00000008)
#define FOLDER_IPM_SENTMAIL_VALID ((ULONG) 0x00000010)
#define FOLDER_VIEWS_VALID ((ULONG) 0x00000020)
#define FOLDER_COMMON_VIEWS_VALID ((ULONG) 0x00000040)
#define FOLDER_FINDER_VALID ((ULONG) 0x00000080)

#define MAPI_IMSGSTORE_METHODS(IPURE) MAPIMETHOD(Advise) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,ULONG ulEventMask,LPMAPIADVISESINK lpAdviseSink,ULONG *lpulConnection) IPURE; MAPIMETHOD(Unadvise) (THIS_ ULONG ulConnection) IPURE; MAPIMETHOD(CompareEntryIDs) (THIS_ ULONG cbEntryID1,LPENTRYID lpEntryID1,ULONG cbEntryID2,LPENTRYID lpEntryID2,ULONG ulFlags,ULONG *lpulResult) IPURE; MAPIMETHOD(OpenEntry) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,LPCIID lpInterface,ULONG ulFlags,ULONG *lpulObjType,LPUNKNOWN *lppUnk) IPURE; MAPIMETHOD(SetReceiveFolder) (THIS_ LPTSTR lpszMessageClass,ULONG ulFlags,ULONG cbEntryID,LPENTRYID lpEntryID) IPURE; MAPIMETHOD(GetReceiveFolder) (THIS_ LPTSTR lpszMessageClass,ULONG ulFlags,ULONG *lpcbEntryID,LPENTRYID *lppEntryID,LPTSTR *lppszExplicitClass) IPURE; MAPIMETHOD(GetReceiveFolderTable) (THIS_ ULONG ulFlags,LPMAPITABLE *lppTable) IPURE; MAPIMETHOD(StoreLogoff) (THIS_ ULONG *lpulFlags) IPURE; MAPIMETHOD(AbortSubmit) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,ULONG ulFlags) IPURE; MAPIMETHOD(GetOutgoingQueue) (THIS_ ULONG ulFlags,LPMAPITABLE *lppTable) IPURE; MAPIMETHOD(SetLockState) (THIS_ LPMESSAGE lpMessage,ULONG ulLockState) IPURE; MAPIMETHOD(FinishedMsg) (THIS_ ULONG ulFlags,ULONG cbEntryID,LPENTRYID lpEntryID) IPURE; MAPIMETHOD(NotifyNewMail) (THIS_ LPNOTIFICATION lpNotification) IPURE;

#undef INTERFACE
#define INTERFACE IMsgStore
  DECLARE_MAPI_INTERFACE_(IMsgStore,IMAPIProp) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
      MAPI_IMSGSTORE_METHODS(PURE)
  };

#define FORCE_SUBMIT ((ULONG) 0x00000001)

#define MSGFLAG_READ ((ULONG) 0x00000001)
#define MSGFLAG_UNMODIFIED ((ULONG) 0x00000002)
#define MSGFLAG_SUBMIT ((ULONG) 0x00000004)
#define MSGFLAG_UNSENT ((ULONG) 0x00000008)
#define MSGFLAG_HASATTACH ((ULONG) 0x00000010)
#define MSGFLAG_FROMME ((ULONG) 0x00000020)
#define MSGFLAG_ASSOCIATED ((ULONG) 0x00000040)
#define MSGFLAG_RESEND ((ULONG) 0x00000080)
#define MSGFLAG_RN_PENDING ((ULONG) 0x00000100)
#define MSGFLAG_NRN_PENDING ((ULONG) 0x00000200)

#define SUBMITFLAG_LOCKED ((ULONG) 0x00000001)
#define SUBMITFLAG_PREPROCESS ((ULONG) 0x00000002)

#define MODRECIP_ADD ((ULONG) 0x00000002)
#define MODRECIP_MODIFY ((ULONG) 0x00000004)
#define MODRECIP_REMOVE ((ULONG) 0x00000008)

#define SUPPRESS_RECEIPT ((ULONG) 0x00000001)
#define CLEAR_READ_FLAG ((ULONG) 0x00000004)

#define GENERATE_RECEIPT_ONLY ((ULONG) 0x00000010)
#define CLEAR_RN_PENDING ((ULONG) 0x00000020)
#define CLEAR_NRN_PENDING ((ULONG) 0x00000040)

#define ATTACH_DIALOG ((ULONG) 0x00000001)

#define SECURITY_SIGNED ((ULONG) 0x00000001)
#define SECURITY_ENCRYPTED ((ULONG) 0x00000002)

#define PRIO_URGENT ((__LONG32) 1)
#define PRIO_NORMAL ((__LONG32) 0)
#define PRIO_NONURGENT ((__LONG32) -1)

#define SENSITIVITY_NONE ((ULONG) 0x00000000)
#define SENSITIVITY_PERSONAL ((ULONG) 0x00000001)
#define SENSITIVITY_PRIVATE ((ULONG) 0x00000002)
#define SENSITIVITY_COMPANY_CONFIDENTIAL ((ULONG) 0x00000003)

#define IMPORTANCE_LOW ((__LONG32) 0)
#define IMPORTANCE_NORMAL ((__LONG32) 1)
#define IMPORTANCE_HIGH ((__LONG32) 2)

#define MAPI_IMESSAGE_METHODS(IPURE) MAPIMETHOD(GetAttachmentTable) (THIS_ ULONG ulFlags,LPMAPITABLE *lppTable) IPURE; MAPIMETHOD(OpenAttach) (THIS_ ULONG ulAttachmentNum,LPCIID lpInterface,ULONG ulFlags,LPATTACH *lppAttach) IPURE; MAPIMETHOD(CreateAttach) (THIS_ LPCIID lpInterface,ULONG ulFlags,ULONG *lpulAttachmentNum,LPATTACH *lppAttach) IPURE; MAPIMETHOD(DeleteAttach) (THIS_ ULONG ulAttachmentNum,ULONG ulUIParam,LPMAPIPROGRESS lpProgress,ULONG ulFlags) IPURE; MAPIMETHOD(GetRecipientTable) (THIS_ ULONG ulFlags,LPMAPITABLE *lppTable) IPURE; MAPIMETHOD(ModifyRecipients) (THIS_ ULONG ulFlags,LPADRLIST lpMods) IPURE; MAPIMETHOD(SubmitMessage) (THIS_ ULONG ulFlags) IPURE; MAPIMETHOD(SetReadFlag) (THIS_ ULONG ulFlags) IPURE;
#undef INTERFACE
#define INTERFACE IMessage
  DECLARE_MAPI_INTERFACE_(IMessage,IMAPIProp) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
      MAPI_IMESSAGE_METHODS(PURE)
  };

#define NO_ATTACHMENT ((ULONG) 0x00000000)
#define ATTACH_BY_VALUE ((ULONG) 0x00000001)
#define ATTACH_BY_REFERENCE ((ULONG) 0x00000002)
#define ATTACH_BY_REF_RESOLVE ((ULONG) 0x00000003)
#define ATTACH_BY_REF_ONLY ((ULONG) 0x00000004)
#define ATTACH_EMBEDDED_MSG ((ULONG) 0x00000005)
#define ATTACH_OLE ((ULONG) 0x00000006)

#define MAPI_IATTACH_METHODS(IPURE)

#undef INTERFACE
#define INTERFACE IAttach
  DECLARE_MAPI_INTERFACE_(IAttach,IMAPIProp) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
      MAPI_IATTACH_METHODS(PURE)
  };

#define GET_ADRPARM_VERSION(ulFlags) (((ULONG)ulFlags) & 0xF0000000)
#define SET_ADRPARM_VERSION(ulFlags,ulVersion) (((ULONG)ulVersion) | (((ULONG)ulFlags) & 0x0FFFFFFF))

#define ADRPARM_HELP_CTX ((ULONG) 0x00000000)

#define DIALOG_MODAL ((ULONG) 0x00000001)
#define DIALOG_SDI ((ULONG) 0x00000002)
#define DIALOG_OPTIONS ((ULONG) 0x00000004)
#define ADDRESS_ONE ((ULONG) 0x00000008)
#define AB_SELECTONLY ((ULONG) 0x00000010)
#define AB_RESOLVE ((ULONG) 0x00000020)

#define DT_MAILUSER ((ULONG) 0x00000000)
#define DT_DISTLIST ((ULONG) 0x00000001)
#define DT_FORUM ((ULONG) 0x00000002)
#define DT_AGENT ((ULONG) 0x00000003)
#define DT_ORGANIZATION ((ULONG) 0x00000004)
#define DT_PRIVATE_DISTLIST ((ULONG) 0x00000005)
#define DT_REMOTE_MAILUSER ((ULONG) 0x00000006)

#define DT_MODIFIABLE ((ULONG) 0x00010000)
#define DT_GLOBAL ((ULONG) 0x00020000)
#define DT_LOCAL ((ULONG) 0x00030000)
#define DT_WAN ((ULONG) 0x00040000)
#define DT_NOT_SPECIFIC ((ULONG) 0x00050000)

#define DT_FOLDER ((ULONG) 0x01000000)
#define DT_FOLDER_LINK ((ULONG) 0x02000000)

  typedef WINBOOL (WINAPI ACCELERATEABSDI)(ULONG ulUIParam,LPVOID lpvmsg);
  typedef ACCELERATEABSDI *LPFNABSDI;
  typedef void (WINAPI DISMISSMODELESS)(ULONG ulUIParam,LPVOID lpvContext);
  typedef DISMISSMODELESS *LPFNDISMISS;
  typedef SCODE (WINAPI *LPFNBUTTON)(ULONG ulUIParam,LPVOID lpvContext,ULONG cbEntryID,LPENTRYID lpSelection,ULONG ulFlags);

  typedef struct _ADRPARM {
    ULONG cbABContEntryID;
    LPENTRYID lpABContEntryID;
    ULONG ulFlags;
    LPVOID lpReserved;
    ULONG ulHelpContext;
    LPTSTR lpszHelpFileName;
    LPFNABSDI lpfnABSDI;
    LPFNDISMISS lpfnDismiss;
    LPVOID lpvDismissContext;
    LPTSTR lpszCaption;
    LPTSTR lpszNewEntryTitle;
    LPTSTR lpszDestWellsTitle;
    ULONG cDestFields;
    ULONG nDestFieldFocus;
    LPTSTR *lppszDestTitles;
    ULONG *lpulDestComps;
    LPSRestriction lpContRestriction;
    LPSRestriction lpHierRestriction;
  } ADRPARM,*LPADRPARM;

#define MAPI_ONE_OFF_NO_RICH_INFO 0x0001
#define MAPI_DEFERRED_ERRORS ((ULONG) 0x00000008)
#define MAPI_ASSOCIATED ((ULONG) 0x00000040)

#define MDB_NO_DIALOG ((ULONG) 0x00000001)
#define MDB_WRITE ((ULONG) 0x00000004)

#define MDB_TEMPORARY ((ULONG) 0x00000020)
#define MDB_NO_MAIL ((ULONG) 0x00000080)

#define AB_NO_DIALOG ((ULONG) 0x00000001)

#define MAPI_ENABLED ((ULONG) 0x00000000)
#define MAPI_DISABLED ((ULONG) 0x00000001)

#define MAPI_IMAPICONTROL_METHODS(IPURE) MAPIMETHOD(GetLastError) (THIS_ HRESULT hResult,ULONG ulFlags,LPMAPIERROR *lppMAPIError) IPURE; MAPIMETHOD(Activate) (THIS_ ULONG ulFlags,ULONG ulUIParam) IPURE; MAPIMETHOD(GetState) (THIS_ ULONG ulFlags,ULONG *lpulState) IPURE;
#undef INTERFACE
#define INTERFACE IMAPIControl
  DECLARE_MAPI_INTERFACE_(IMAPIControl,IUnknown) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPICONTROL_METHODS(PURE)
  };

  DECLARE_MAPI_INTERFACE_PTR(IMAPIControl,LPMAPICONTROL);

#define DT_MULTILINE ((ULONG) 0x00000001)
#define DT_EDITABLE ((ULONG) 0x00000002)
#define DT_REQUIRED ((ULONG) 0x00000004)
#define DT_SET_IMMEDIATE ((ULONG) 0x00000008)
#define DT_PASSWORD_EDIT ((ULONG) 0x00000010)
#define DT_ACCEPT_DBCS ((ULONG) 0x00000020)
#define DT_SET_SELECTION ((ULONG) 0x00000040)

#define DTCT_LABEL ((ULONG) 0x00000000)
#define DTCT_EDIT ((ULONG) 0x00000001)
#define DTCT_LBX ((ULONG) 0x00000002)
#define DTCT_COMBOBOX ((ULONG) 0x00000003)
#define DTCT_DDLBX ((ULONG) 0x00000004)
#define DTCT_CHECKBOX ((ULONG) 0x00000005)
#define DTCT_GROUPBOX ((ULONG) 0x00000006)
#define DTCT_BUTTON ((ULONG) 0x00000007)
#define DTCT_PAGE ((ULONG) 0x00000008)
#define DTCT_RADIOBUTTON ((ULONG) 0x00000009)
#define DTCT_MVLISTBOX ((ULONG) 0x0000000B)
#define DTCT_MVDDLBX ((ULONG) 0x0000000C)

  typedef struct _DTBLLABEL {
    ULONG ulbLpszLabelName;
    ULONG ulFlags;
  } DTBLLABEL,*LPDTBLLABEL;
#define SizedDtblLabel(n,u) struct _DTBLLABEL_ ## u { DTBLLABEL dtbllabel; TCHAR lpszLabelName[n]; } u

  typedef struct _DTBLEDIT {
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPropTag;
  } DTBLEDIT,*LPDTBLEDIT;
#define SizedDtblEdit(n,u) struct _DTBLEDIT_ ## u { DTBLEDIT dtbledit; TCHAR lpszCharsAllowed[n]; } u

#define MAPI_NO_HBAR ((ULONG) 0x00000001)
#define MAPI_NO_VBAR ((ULONG) 0x00000002)

  typedef struct _DTBLLBX {
    ULONG ulFlags;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
  } DTBLLBX,*LPDTBLLBX;

  typedef struct _DTBLCOMBOBOX {
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPRPropertyName;
    ULONG ulPRTableName;
  } DTBLCOMBOBOX,*LPDTBLCOMBOBOX;
#define SizedDtblComboBox(n,u) struct _DTBLCOMBOBOX_ ## u { DTBLCOMBOBOX dtblcombobox; TCHAR lpszCharsAllowed[n]; } u

  typedef struct _DTBLDDLBX {
    ULONG ulFlags;
    ULONG ulPRDisplayProperty;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
  } DTBLDDLBX,*LPDTBLDDLBX;

  typedef struct _DTBLCHECKBOX {
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRPropertyName;
  } DTBLCHECKBOX,*LPDTBLCHECKBOX;
#define SizedDtblCheckBox(n,u) struct _DTBLCHECKBOX_ ## u { DTBLCHECKBOX dtblcheckbox; TCHAR lpszLabel[n]; } u

  typedef struct _DTBLGROUPBOX {
    ULONG ulbLpszLabel;
    ULONG ulFlags;
  } DTBLGROUPBOX,*LPDTBLGROUPBOX;
#define SizedDtblGroupBox(n,u) struct _DTBLGROUPBOX_ ## u { DTBLGROUPBOX dtblgroupbox; TCHAR lpszLabel[n]; } u

  typedef struct _DTBLBUTTON {
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRControl;
  } DTBLBUTTON,*LPDTBLBUTTON;
#define SizedDtblButton(n,u) struct _DTBLBUTTON_ ## u { DTBLBUTTON dtblbutton; TCHAR lpszLabel[n]; } u

  typedef struct _DTBLPAGE {
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulbLpszComponent;
    ULONG ulContext;
  } DTBLPAGE,*LPDTBLPAGE;
#define SizedDtblPage(n,n1,u) struct _DTBLPAGE_ ## u { DTBLPAGE dtblpage; TCHAR lpszLabel[n]; TCHAR lpszComponent[n1]; } u

  typedef struct _DTBLRADIOBUTTON {
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulcButtons;
    ULONG ulPropTag;
    __LONG32 lReturnValue;
  } DTBLRADIOBUTTON,*LPDTBLRADIOBUTTON;
#define SizedDtblRadioButton(n,u) struct _DTBLRADIOBUTTON_ ## u { DTBLRADIOBUTTON dtblradiobutton; TCHAR lpszLabel[n]; } u

  typedef struct _DTBLMVLISTBOX {
    ULONG ulFlags;
    ULONG ulMVPropTag;
  } DTBLMVLISTBOX,*LPDTBLMVLISTBOX;

  typedef struct _DTBLMVDDLBX {
    ULONG ulFlags;
    ULONG ulMVPropTag;
  } DTBLMVDDLBX,*LPDTBLMVDDLBX;

#define UI_SERVICE 0x00000002
#define SERVICE_UI_ALWAYS 0x00000002
#define SERVICE_UI_ALLOWED 0x00000010
#define UI_CURRENT_PROVIDER_FIRST 0x00000004

#define MAPI_IPROVIDERADMIN_METHODS(IPURE) MAPIMETHOD(GetLastError) (THIS_ HRESULT hResult,ULONG ulFlags,LPMAPIERROR *lppMAPIError) IPURE; MAPIMETHOD(GetProviderTable) (THIS_ ULONG ulFlags,LPMAPITABLE *lppTable) IPURE; MAPIMETHOD(CreateProvider) (THIS_ LPTSTR lpszProvider,ULONG cValues,LPSPropValue lpProps,ULONG ulUIParam,ULONG ulFlags,MAPIUID *lpUID) IPURE; MAPIMETHOD(DeleteProvider) (THIS_ LPMAPIUID lpUID) IPURE; MAPIMETHOD(OpenProfileSection) (THIS_ LPMAPIUID lpUID,LPCIID lpInterface,ULONG ulFlags,LPPROFSECT *lppProfSect) IPURE;

#undef INTERFACE
#define INTERFACE IProviderAdmin
  DECLARE_MAPI_INTERFACE_(IProviderAdmin,IUnknown) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IPROVIDERADMIN_METHODS(PURE)
  };

  typedef HANDLE HANDLE_16;
  typedef WPARAM WPARAM_16;

#define EXTERN_C_16
#define WINAPI_16
#define CALLBACK_16
#define EXPORT_16
#define LOADDS_16
#define HUGEP_16
#define APIENTRY_16 WINAPI
#define IF_WIN16(x)
#define IF_NOT_WIN16(x) x
#define IF_WIN32(x) x

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                             usr/share/mingw-w64/include/wabiab.h                                                                0100644 0000000 0000000 00000006013 12404413016 015733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef WABIAB_H
#define WABIAB_H

#define WAB_RESOLVE_LOCAL_ONLY ((ULONG) 0x80000000)
#define WAB_RESOLVE_ALL_EMAILS ((ULONG) 0x40000000)
#define WAB_RESOLVE_NO_ONE_OFFS ((ULONG) 0x20000000)
#define WAB_RESOLVE_NEED_CERT ((ULONG) 0x10000000)
#define WAB_RESOLVE_NO_NOT_FOUND_UI ((ULONG) 0x08000000)
#define WAB_RESOLVE_USE_CURRENT_PROFILE ((ULONG) 0x04000000)
#define WAB_RESOLVE_FIRST_MATCH ((ULONG) 0x02000000)
#define WAB_RESOLVE_UNICODE ((ULONG) 0x01000000)

#ifndef MAPIX_H
#define MAPI_IADDRBOOK_METHODS(IPURE) MAPIMETHOD(OpenEntry) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,LPCIID lpInterface,ULONG ulFlags,ULONG *lpulObjType,LPUNKNOWN *lppUnk) IPURE; MAPIMETHOD(CompareEntryIDs) (THIS_ ULONG cbEntryID1,LPENTRYID lpEntryID1,ULONG cbEntryID2,LPENTRYID lpEntryID2,ULONG ulFlags,ULONG *lpulResult) IPURE; MAPIMETHOD(Advise) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID,ULONG ulEventMask,LPMAPIADVISESINK lpAdviseSink,ULONG *lpulConnection) IPURE; MAPIMETHOD(Unadvise) (THIS_ ULONG ulConnection) IPURE; MAPIMETHOD(CreateOneOff) (THIS_ LPTSTR lpszName,LPTSTR lpszAdrType,LPTSTR lpszAddress,ULONG ulFlags,ULONG *lpcbEntryID,LPENTRYID *lppEntryID) IPURE; MAPIMETHOD(NewEntry) (THIS_ ULONG ulUIParam,ULONG ulFlags,ULONG cbEIDContainer,LPENTRYID lpEIDContainer,ULONG cbEIDNewEntryTpl,LPENTRYID lpEIDNewEntryTpl,ULONG *lpcbEIDNewEntry,LPENTRYID *lppEIDNewEntry) IPURE; MAPIMETHOD(ResolveName) (THIS_ ULONG_PTR ulUIParam,ULONG ulFlags,LPTSTR lpszNewEntryTitle,LPADRLIST lpAdrList) IPURE; MAPIMETHOD(Address) (THIS_ ULONG *lpulUIParam,LPADRPARM lpAdrParms,LPADRLIST *lppAdrList) IPURE; MAPIMETHOD(Details) (THIS_ ULONG *lpulUIParam,LPFNDISMISS lpfnDismiss,LPVOID lpvDismissContext,ULONG cbEntryID,LPENTRYID lpEntryID,LPFNBUTTON lpfButtonCallback,LPVOID lpvButtonContext,LPTSTR lpszButtonText,ULONG ulFlags) IPURE; MAPIMETHOD(RecipOptions) (THIS_ ULONG ulUIParam,ULONG ulFlags,LPADRENTRY lpRecip) IPURE; MAPIMETHOD(QueryDefaultRecipOpt) (THIS_ LPTSTR lpszAdrType,ULONG ulFlags,ULONG *lpcValues,LPSPropValue *lppOptions) IPURE; MAPIMETHOD(GetPAB) (THIS_ ULONG *lpcbEntryID,LPENTRYID *lppEntryID) IPURE; MAPIMETHOD(SetPAB) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID) IPURE; MAPIMETHOD(GetDefaultDir) (THIS_ ULONG *lpcbEntryID,LPENTRYID *lppEntryID) IPURE; MAPIMETHOD(SetDefaultDir) (THIS_ ULONG cbEntryID,LPENTRYID lpEntryID) IPURE; MAPIMETHOD(GetSearchPath) (THIS_ ULONG ulFlags,LPSRowSet *lppSearchPath) IPURE; MAPIMETHOD(SetSearchPath) (THIS_ ULONG ulFlags,LPSRowSet lpSearchPath) IPURE; MAPIMETHOD(PrepareRecips) (THIS_ ULONG ulFlags,LPSPropTagArray lpPropTagArray,LPADRLIST lpRecipList) IPURE;
#undef INTERFACE
#define INTERFACE IAddrBook
DECLARE_MAPI_INTERFACE_(IAddrBook,IMAPIProp) {
  BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IADDRBOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IAddrBook,LPADRBOOK);
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/share/mingw-w64/include/wabmem.h                                                                0100644 0000000 0000000 00000002053 12404413016 015756  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#if !defined(WABMEM_H)
#define WABMEM_H

#ifndef MAPIX_H
typedef SCODE (WINAPI MAPIALLOCATEBUFFER)(ULONG cbSize,LPVOID *lppBuffer);
typedef SCODE (WINAPI MAPIALLOCATEMORE)(ULONG cbSize,LPVOID lpObject,LPVOID *lppBuffer);
typedef ULONG (WINAPI MAPIFREEBUFFER)(LPVOID lpBuffer);
typedef MAPIALLOCATEBUFFER *LPMAPIALLOCATEBUFFER;
typedef MAPIALLOCATEMORE *LPMAPIALLOCATEMORE;
typedef MAPIFREEBUFFER *LPMAPIFREEBUFFER;
#endif
typedef SCODE (WINAPI WABALLOCATEBUFFER)(LPWABOBJECT lpWABObject,ULONG cbSize,LPVOID *lppBuffer);
typedef SCODE (WINAPI WABALLOCATEMORE)(LPWABOBJECT lpWABObject,ULONG cbSize,LPVOID lpObject,LPVOID *lppBuffer);
typedef ULONG (WINAPI WABFREEBUFFER)(LPWABOBJECT lpWABObject,LPVOID lpBuffer);
typedef WABALLOCATEBUFFER *LPWABALLOCATEBUFFER;
typedef WABALLOCATEMORE *LPWABALLOCATEMORE;
typedef WABFREEBUFFER *LPWABFREEBUFFER;

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/share/mingw-w64/include/wabnot.h                                                                0100644 0000000 0000000 00000003015 12404413016 015777  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#if !defined(MAPISPI_H) && !defined(WABSPI_H)
#define WABSPI_H

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifndef MAPI_DIM
#define MAPI_DIM 1
#endif

#ifdef __cplusplus
extern "C" {
#endif

  typedef struct {
    ULONG cb;
    BYTE ab[MAPI_DIM];
  } NOTIFKEY,*LPNOTIFKEY;

#define CbNewNOTIFKEY(_cb) (offsetof(NOTIFKEY,ab) + (_cb))
#define CbNOTIFKEY(_lpkey) (offsetof(NOTIFKEY,ab) + (_lpkey)->cb)
#define SizedNOTIFKEY(_cb,_name) struct _NOTIFKEY_ ## _name { ULONG cb; BYTE ab[_cb]; } _name

#define NOTIFY_SYNC ((ULONG) 0x40000000)

#define NOTIFY_CANCELED ((ULONG) 0x80000000)

#define CALLBACK_DISCONTINUE ((ULONG) 0x80000000)

#define NOTIFY_NEWMAIL ((ULONG) 0x00000001)
#define NOTIFY_READYTOSEND ((ULONG) 0x00000002)
#define NOTIFY_SENTDEFERRED ((ULONG) 0x00000004)
#define NOTIFY_CRITSEC ((ULONG) 0x00001000)
#define NOTIFY_NONCRIT ((ULONG) 0x00002000)
#define NOTIFY_CONFIG_CHANGE ((ULONG) 0x00004000)
#define NOTIFY_CRITICAL_ERROR ((ULONG) 0x10000000)
#define NOTIFY_NEWMAIL_RECEIVED ((ULONG) 0x20000000)

#define STATUSROW_UPDATE ((ULONG) 0x10000000)

#define STGSTRM_RESET ((ULONG) 0x00000000)
#define STGSTRM_CURRENT ((ULONG) 0x10000000)
#define STGSTRM_MODIFY ((ULONG) 0x00000002)
#define STGSTRM_CREATE ((ULONG) 0x00001000)

#define MAPI_NON_READ ((ULONG) 0x00000001)

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/mingw-w64/include/wabtags.h                                                               0100644 0000000 0000000 00000046376 12404413016 016156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#if !defined(MAPITAGS_H) && !defined(WABTAGS_H)
#define WABTAGS_H

#define FIsTransmittable(ulPropTag) ((PROP_ID (ulPropTag) < (ULONG)0x0E00) || (PROP_ID (ulPropTag) >= (ULONG)0x8000) || ((PROP_ID (ulPropTag) >= (ULONG)0x1000) && (PROP_ID (ulPropTag) < (ULONG)0x6000)) || ((PROP_ID (ulPropTag) >= (ULONG)0x6800) && (PROP_ID (ulPropTag) < (ULONG)0x7C00)))

#define PR_ENTRYID PROP_TAG(PT_BINARY,0x0FFF)
#define PR_OBJECT_TYPE PROP_TAG(PT_LONG,0x0FFE)
#define PR_ICON PROP_TAG(PT_BINARY,0x0FFD)
#define PR_MINI_ICON PROP_TAG(PT_BINARY,0x0FFC)
#define PR_STORE_ENTRYID PROP_TAG(PT_BINARY,0x0FFB)
#define PR_STORE_RECORD_KEY PROP_TAG(PT_BINARY,0x0FFA)
#define PR_RECORD_KEY PROP_TAG(PT_BINARY,0x0FF9)
#define PR_MAPPING_SIGNATURE PROP_TAG(PT_BINARY,0x0FF8)
#define PR_ACCESS_LEVEL PROP_TAG(PT_LONG,0x0FF7)
#define PR_INSTANCE_KEY PROP_TAG(PT_BINARY,0x0FF6)
#define PR_ROW_TYPE PROP_TAG(PT_LONG,0x0FF5)
#define PR_ACCESS PROP_TAG(PT_LONG,0x0FF4)

#define PR_ROWID PROP_TAG(PT_LONG,0x3000)
#define PR_DISPLAY_NAME PROP_TAG(PT_TSTRING,0x3001)
#define PR_DISPLAY_NAME_W PROP_TAG(PT_UNICODE,0x3001)
#define PR_DISPLAY_NAME_A PROP_TAG(PT_STRING8,0x3001)
#define PR_ADDRTYPE PROP_TAG(PT_TSTRING,0x3002)
#define PR_ADDRTYPE_W PROP_TAG(PT_UNICODE,0x3002)
#define PR_ADDRTYPE_A PROP_TAG(PT_STRING8,0x3002)
#define PR_EMAIL_ADDRESS PROP_TAG(PT_TSTRING,0x3003)
#define PR_EMAIL_ADDRESS_W PROP_TAG(PT_UNICODE,0x3003)
#define PR_EMAIL_ADDRESS_A PROP_TAG(PT_STRING8,0x3003)
#define PR_COMMENT PROP_TAG(PT_TSTRING,0x3004)
#define PR_COMMENT_W PROP_TAG(PT_UNICODE,0x3004)
#define PR_COMMENT_A PROP_TAG(PT_STRING8,0x3004)
#define PR_DEPTH PROP_TAG(PT_LONG,0x3005)
#define PR_PROVIDER_DISPLAY PROP_TAG(PT_TSTRING,0x3006)
#define PR_PROVIDER_DISPLAY_W PROP_TAG(PT_UNICODE,0x3006)
#define PR_PROVIDER_DISPLAY_A PROP_TAG(PT_STRING8,0x3006)
#define PR_CREATION_TIME PROP_TAG(PT_SYSTIME,0x3007)
#define PR_LAST_MODIFICATION_TIME PROP_TAG(PT_SYSTIME,0x3008)
#define PR_RESOURCE_FLAGS PROP_TAG(PT_LONG,0x3009)
#define PR_PROVIDER_DLL_NAME PROP_TAG(PT_TSTRING,0x300A)
#define PR_PROVIDER_DLL_NAME_W PROP_TAG(PT_UNICODE,0x300A)
#define PR_PROVIDER_DLL_NAME_A PROP_TAG(PT_STRING8,0x300A)
#define PR_SEARCH_KEY PROP_TAG(PT_BINARY,0x300B)
#define PR_PROVIDER_UID PROP_TAG(PT_BINARY,0x300C)
#define PR_PROVIDER_ORDINAL PROP_TAG(PT_LONG,0x300D)

#define PR_CONTAINER_FLAGS PROP_TAG(PT_LONG,0x3600)
#define PR_FOLDER_TYPE PROP_TAG(PT_LONG,0x3601)
#define PR_CONTENT_COUNT PROP_TAG(PT_LONG,0x3602)
#define PR_CONTENT_UNREAD PROP_TAG(PT_LONG,0x3603)
#define PR_CREATE_TEMPLATES PROP_TAG(PT_OBJECT,0x3604)
#define PR_DETAILS_TABLE PROP_TAG(PT_OBJECT,0x3605)
#define PR_SEARCH PROP_TAG(PT_OBJECT,0x3607)
#define PR_SELECTABLE PROP_TAG(PT_BOOLEAN,0x3609)
#define PR_SUBFOLDERS PROP_TAG(PT_BOOLEAN,0x360a)
#define PR_STATUS PROP_TAG(PT_LONG,0x360b)
#define PR_ANR PROP_TAG(PT_TSTRING,0x360c)
#define PR_ANR_W PROP_TAG(PT_UNICODE,0x360c)
#define PR_ANR_A PROP_TAG(PT_STRING8,0x360c)
#define PR_CONTENTS_SORT_ORDER PROP_TAG(PT_MV_LONG,0x360d)
#define PR_CONTAINER_HIERARCHY PROP_TAG(PT_OBJECT,0x360e)
#define PR_CONTAINER_CONTENTS PROP_TAG(PT_OBJECT,0x360f)
#define PR_FOLDER_ASSOCIATED_CONTENTS PROP_TAG(PT_OBJECT,0x3610)
#define PR_DEF_CREATE_DL PROP_TAG(PT_BINARY,0x3611)
#define PR_DEF_CREATE_MAILUSER PROP_TAG(PT_BINARY,0x3612)
#define PR_CONTAINER_CLASS PROP_TAG(PT_TSTRING,0x3613)
#define PR_CONTAINER_CLASS_W PROP_TAG(PT_UNICODE,0x3613)
#define PR_CONTAINER_CLASS_A PROP_TAG(PT_STRING8,0x3613)
#define PR_CONTAINER_MODIFY_VERSION PROP_TAG(PT_I8,0x3614)
#define PR_AB_PROVIDER_ID PROP_TAG(PT_BINARY,0x3615)
#define PR_DEFAULT_VIEW_ENTRYID PROP_TAG(PT_BINARY,0x3616)
#define PR_ASSOC_CONTENT_COUNT PROP_TAG(PT_LONG,0x3617)

#define PR_DISPLAY_TYPE PROP_TAG(PT_LONG,0x3900)
#define PR_TEMPLATEID PROP_TAG(PT_BINARY,0x3902)
#define PR_PRIMARY_CAPABILITY PROP_TAG(PT_BINARY,0x3904)
#define PR_7BIT_DISPLAY_NAME PROP_TAG(PT_STRING8,0x39FF)

#define PR_ACCOUNT PROP_TAG(PT_TSTRING,0x3A00)
#define PR_ACCOUNT_W PROP_TAG(PT_UNICODE,0x3A00)
#define PR_ACCOUNT_A PROP_TAG(PT_STRING8,0x3A00)
#define PR_ALTERNATE_RECIPIENT PROP_TAG(PT_BINARY,0x3A01)
#define PR_CALLBACK_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A02)
#define PR_CONVERSION_PROHIBITED PROP_TAG(PT_BOOLEAN,0x3A03)
#define PR_DISCLOSE_RECIPIENTS PROP_TAG(PT_BOOLEAN,0x3A04)
#define PR_GENERATION PROP_TAG(PT_TSTRING,0x3A05)
#define PR_GENERATION_W PROP_TAG(PT_UNICODE,0x3A05)
#define PR_GENERATION_A PROP_TAG(PT_STRING8,0x3A05)
#define PR_GIVEN_NAME PROP_TAG(PT_TSTRING,0x3A06)
#define PR_GIVEN_NAME_W PROP_TAG(PT_UNICODE,0x3A06)
#define PR_GIVEN_NAME_A PROP_TAG(PT_STRING8,0x3A06)
#define PR_GOVERNMENT_ID_NUMBER PROP_TAG(PT_TSTRING,0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_W PROP_TAG(PT_UNICODE,0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_A PROP_TAG(PT_STRING8,0x3A07)
#define PR_BUSINESS_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A08)
#define PR_OFFICE_TELEPHONE_NUMBER PR_BUSINESS_TELEPHONE_NUMBER
#define PR_OFFICE_TELEPHONE_NUMBER_W PR_BUSINESS_TELEPHONE_NUMBER_W
#define PR_OFFICE_TELEPHONE_NUMBER_A PR_BUSINESS_TELEPHONE_NUMBER_A
#define PR_HOME_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A09)
#define PR_INITIALS PROP_TAG(PT_TSTRING,0x3A0A)
#define PR_INITIALS_W PROP_TAG(PT_UNICODE,0x3A0A)
#define PR_INITIALS_A PROP_TAG(PT_STRING8,0x3A0A)
#define PR_KEYWORD PROP_TAG(PT_TSTRING,0x3A0B)
#define PR_KEYWORD_W PROP_TAG(PT_UNICODE,0x3A0B)
#define PR_KEYWORD_A PROP_TAG(PT_STRING8,0x3A0B)
#define PR_LANGUAGE PROP_TAG(PT_TSTRING,0x3A0C)
#define PR_LANGUAGE_W PROP_TAG(PT_UNICODE,0x3A0C)
#define PR_LANGUAGE_A PROP_TAG(PT_STRING8,0x3A0C)
#define PR_LOCATION PROP_TAG(PT_TSTRING,0x3A0D)
#define PR_LOCATION_W PROP_TAG(PT_UNICODE,0x3A0D)
#define PR_LOCATION_A PROP_TAG(PT_STRING8,0x3A0D)
#define PR_MAIL_PERMISSION PROP_TAG(PT_BOOLEAN,0x3A0E)
#define PR_MHS_COMMON_NAME PROP_TAG(PT_TSTRING,0x3A0F)
#define PR_MHS_COMMON_NAME_W PROP_TAG(PT_UNICODE,0x3A0F)
#define PR_MHS_COMMON_NAME_A PROP_TAG(PT_STRING8,0x3A0F)
#define PR_ORGANIZATIONAL_ID_NUMBER PROP_TAG(PT_TSTRING,0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_W PROP_TAG(PT_UNICODE,0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_A PROP_TAG(PT_STRING8,0x3A10)
#define PR_SURNAME PROP_TAG(PT_TSTRING,0x3A11)
#define PR_SURNAME_W PROP_TAG(PT_UNICODE,0x3A11)
#define PR_SURNAME_A PROP_TAG(PT_STRING8,0x3A11)
#define PR_ORIGINAL_ENTRYID PROP_TAG(PT_BINARY,0x3A12)
#define PR_ORIGINAL_DISPLAY_NAME PROP_TAG(PT_TSTRING,0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_W PROP_TAG(PT_UNICODE,0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_A PROP_TAG(PT_STRING8,0x3A13)
#define PR_ORIGINAL_SEARCH_KEY PROP_TAG(PT_BINARY,0x3A14)
#define PR_POSTAL_ADDRESS PROP_TAG(PT_TSTRING,0x3A15)
#define PR_POSTAL_ADDRESS_W PROP_TAG(PT_UNICODE,0x3A15)
#define PR_POSTAL_ADDRESS_A PROP_TAG(PT_STRING8,0x3A15)
#define PR_COMPANY_NAME PROP_TAG(PT_TSTRING,0x3A16)
#define PR_COMPANY_NAME_W PROP_TAG(PT_UNICODE,0x3A16)
#define PR_COMPANY_NAME_A PROP_TAG(PT_STRING8,0x3A16)
#define PR_TITLE PROP_TAG(PT_TSTRING,0x3A17)
#define PR_TITLE_W PROP_TAG(PT_UNICODE,0x3A17)
#define PR_TITLE_A PROP_TAG(PT_STRING8,0x3A17)
#define PR_DEPARTMENT_NAME PROP_TAG(PT_TSTRING,0x3A18)
#define PR_DEPARTMENT_NAME_W PROP_TAG(PT_UNICODE,0x3A18)
#define PR_DEPARTMENT_NAME_A PROP_TAG(PT_STRING8,0x3A18)
#define PR_OFFICE_LOCATION PROP_TAG(PT_TSTRING,0x3A19)
#define PR_OFFICE_LOCATION_W PROP_TAG(PT_UNICODE,0x3A19)
#define PR_OFFICE_LOCATION_A PROP_TAG(PT_STRING8,0x3A19)
#define PR_PRIMARY_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A1A)
#define PR_BUSINESS2_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A1B)
#define PR_OFFICE2_TELEPHONE_NUMBER PR_BUSINESS2_TELEPHONE_NUMBER
#define PR_OFFICE2_TELEPHONE_NUMBER_W PR_BUSINESS2_TELEPHONE_NUMBER_W
#define PR_OFFICE2_TELEPHONE_NUMBER_A PR_BUSINESS2_TELEPHONE_NUMBER_A
#define PR_MOBILE_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A1C)
#define PR_CELLULAR_TELEPHONE_NUMBER PR_MOBILE_TELEPHONE_NUMBER
#define PR_CELLULAR_TELEPHONE_NUMBER_W PR_MOBILE_TELEPHONE_NUMBER_W
#define PR_CELLULAR_TELEPHONE_NUMBER_A PR_MOBILE_TELEPHONE_NUMBER_A
#define PR_RADIO_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A1D)
#define PR_CAR_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A1E)
#define PR_OTHER_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A1F)
#define PR_TRANSMITABLE_DISPLAY_NAME PROP_TAG(PT_TSTRING,0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_W PROP_TAG(PT_UNICODE,0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_A PROP_TAG(PT_STRING8,0x3A20)
#define PR_PAGER_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A21)
#define PR_BEEPER_TELEPHONE_NUMBER PR_PAGER_TELEPHONE_NUMBER
#define PR_BEEPER_TELEPHONE_NUMBER_W PR_PAGER_TELEPHONE_NUMBER_W
#define PR_BEEPER_TELEPHONE_NUMBER_A PR_PAGER_TELEPHONE_NUMBER_A
#define PR_USER_CERTIFICATE PROP_TAG(PT_BINARY,0x3A22)
#define PR_PRIMARY_FAX_NUMBER PROP_TAG(PT_TSTRING,0x3A23)
#define PR_PRIMARY_FAX_NUMBER_W PROP_TAG(PT_UNICODE,0x3A23)
#define PR_PRIMARY_FAX_NUMBER_A PROP_TAG(PT_STRING8,0x3A23)
#define PR_BUSINESS_FAX_NUMBER PROP_TAG(PT_TSTRING,0x3A24)
#define PR_BUSINESS_FAX_NUMBER_W PROP_TAG(PT_UNICODE,0x3A24)
#define PR_BUSINESS_FAX_NUMBER_A PROP_TAG(PT_STRING8,0x3A24)
#define PR_HOME_FAX_NUMBER PROP_TAG(PT_TSTRING,0x3A25)
#define PR_HOME_FAX_NUMBER_W PROP_TAG(PT_UNICODE,0x3A25)
#define PR_HOME_FAX_NUMBER_A PROP_TAG(PT_STRING8,0x3A25)
#define PR_COUNTRY PROP_TAG(PT_TSTRING,0x3A26)
#define PR_COUNTRY_W PROP_TAG(PT_UNICODE,0x3A26)
#define PR_COUNTRY_A PROP_TAG(PT_STRING8,0x3A26)
#define PR_LOCALITY PROP_TAG(PT_TSTRING,0x3A27)
#define PR_LOCALITY_W PROP_TAG(PT_UNICODE,0x3A27)
#define PR_LOCALITY_A PROP_TAG(PT_STRING8,0x3A27)
#define PR_STATE_OR_PROVINCE PROP_TAG(PT_TSTRING,0x3A28)
#define PR_STATE_OR_PROVINCE_W PROP_TAG(PT_UNICODE,0x3A28)
#define PR_STATE_OR_PROVINCE_A PROP_TAG(PT_STRING8,0x3A28)
#define PR_STREET_ADDRESS PROP_TAG(PT_TSTRING,0x3A29)
#define PR_STREET_ADDRESS_W PROP_TAG(PT_UNICODE,0x3A29)
#define PR_STREET_ADDRESS_A PROP_TAG(PT_STRING8,0x3A29)
#define PR_POSTAL_CODE PROP_TAG(PT_TSTRING,0x3A2A)
#define PR_POSTAL_CODE_W PROP_TAG(PT_UNICODE,0x3A2A)
#define PR_POSTAL_CODE_A PROP_TAG(PT_STRING8,0x3A2A)
#define PR_POST_OFFICE_BOX PROP_TAG(PT_TSTRING,0x3A2B)
#define PR_POST_OFFICE_BOX_W PROP_TAG(PT_UNICODE,0x3A2B)
#define PR_POST_OFFICE_BOX_A PROP_TAG(PT_STRING8,0x3A2B)
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX PR_POST_OFFICE_BOX
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_W PR_POST_OFFICE_BOX_W
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_A PR_POST_OFFICE_BOX_A
#define PR_TELEX_NUMBER PROP_TAG(PT_TSTRING,0x3A2C)
#define PR_TELEX_NUMBER_W PROP_TAG(PT_UNICODE,0x3A2C)
#define PR_TELEX_NUMBER_A PROP_TAG(PT_STRING8,0x3A2C)
#define PR_ISDN_NUMBER PROP_TAG(PT_TSTRING,0x3A2D)
#define PR_ISDN_NUMBER_W PROP_TAG(PT_UNICODE,0x3A2D)
#define PR_ISDN_NUMBER_A PROP_TAG(PT_STRING8,0x3A2D)
#define PR_ASSISTANT_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A2E)
#define PR_HOME2_TELEPHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A2F)
#define PR_ASSISTANT PROP_TAG(PT_TSTRING,0x3A30)
#define PR_ASSISTANT_W PROP_TAG(PT_UNICODE,0x3A30)
#define PR_ASSISTANT_A PROP_TAG(PT_STRING8,0x3A30)
#define PR_SEND_RICH_INFO PROP_TAG(PT_BOOLEAN,0x3A40)
#define PR_WEDDING_ANNIVERSARY PROP_TAG(PT_SYSTIME,0x3A41)
#define PR_BIRTHDAY PROP_TAG(PT_SYSTIME,0x3A42)
#define PR_HOBBIES PROP_TAG(PT_TSTRING,0x3A43)
#define PR_HOBBIES_W PROP_TAG(PT_UNICODE,0x3A43)
#define PR_HOBBIES_A PROP_TAG(PT_STRING8,0x3A43)
#define PR_MIDDLE_NAME PROP_TAG(PT_TSTRING,0x3A44)
#define PR_MIDDLE_NAME_W PROP_TAG(PT_UNICODE,0x3A44)
#define PR_MIDDLE_NAME_A PROP_TAG(PT_STRING8,0x3A44)
#define PR_DISPLAY_NAME_PREFIX PROP_TAG(PT_TSTRING,0x3A45)
#define PR_DISPLAY_NAME_PREFIX_W PROP_TAG(PT_UNICODE,0x3A45)
#define PR_DISPLAY_NAME_PREFIX_A PROP_TAG(PT_STRING8,0x3A45)
#define PR_PROFESSION PROP_TAG(PT_TSTRING,0x3A46)
#define PR_PROFESSION_W PROP_TAG(PT_UNICODE,0x3A46)
#define PR_PROFESSION_A PROP_TAG(PT_STRING8,0x3A46)
#define PR_PREFERRED_BY_NAME PROP_TAG(PT_TSTRING,0x3A47)
#define PR_PREFERRED_BY_NAME_W PROP_TAG(PT_UNICODE,0x3A47)
#define PR_PREFERRED_BY_NAME_A PROP_TAG(PT_STRING8,0x3A47)
#define PR_SPOUSE_NAME PROP_TAG(PT_TSTRING,0x3A48)
#define PR_SPOUSE_NAME_W PROP_TAG(PT_UNICODE,0x3A48)
#define PR_SPOUSE_NAME_A PROP_TAG(PT_STRING8,0x3A48)
#define PR_COMPUTER_NETWORK_NAME PROP_TAG(PT_TSTRING,0x3A49)
#define PR_COMPUTER_NETWORK_NAME_W PROP_TAG(PT_UNICODE,0x3A49)
#define PR_COMPUTER_NETWORK_NAME_A PROP_TAG(PT_STRING8,0x3A49)
#define PR_CUSTOMER_ID PROP_TAG(PT_TSTRING,0x3A4A)
#define PR_CUSTOMER_ID_W PROP_TAG(PT_UNICODE,0x3A4A)
#define PR_CUSTOMER_ID_A PROP_TAG(PT_STRING8,0x3A4A)
#define PR_TTYTDD_PHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A4B)
#define PR_FTP_SITE PROP_TAG(PT_TSTRING,0x3A4C)
#define PR_FTP_SITE_W PROP_TAG(PT_UNICODE,0x3A4C)
#define PR_FTP_SITE_A PROP_TAG(PT_STRING8,0x3A4C)
#define PR_GENDER PROP_TAG(PT_SHORT,0x3A4D)
#define PR_MANAGER_NAME PROP_TAG(PT_TSTRING,0x3A4E)
#define PR_MANAGER_NAME_W PROP_TAG(PT_UNICODE,0x3A4E)
#define PR_MANAGER_NAME_A PROP_TAG(PT_STRING8,0x3A4E)
#define PR_NICKNAME PROP_TAG(PT_TSTRING,0x3A4F)
#define PR_NICKNAME_W PROP_TAG(PT_UNICODE,0x3A4F)
#define PR_NICKNAME_A PROP_TAG(PT_STRING8,0x3A4F)
#define PR_PERSONAL_HOME_PAGE PROP_TAG(PT_TSTRING,0x3A50)
#define PR_PERSONAL_HOME_PAGE_W PROP_TAG(PT_UNICODE,0x3A50)
#define PR_PERSONAL_HOME_PAGE_A PROP_TAG(PT_STRING8,0x3A50)
#define PR_BUSINESS_HOME_PAGE PROP_TAG(PT_TSTRING,0x3A51)
#define PR_BUSINESS_HOME_PAGE_W PROP_TAG(PT_UNICODE,0x3A51)
#define PR_BUSINESS_HOME_PAGE_A PROP_TAG(PT_STRING8,0x3A51)
#define PR_CONTACT_VERSION PROP_TAG(PT_CLSID,0x3A52)
#define PR_CONTACT_ENTRYIDS PROP_TAG(PT_MV_BINARY,0x3A53)
#define PR_CONTACT_ADDRTYPES PROP_TAG(PT_MV_TSTRING,0x3A54)
#define PR_CONTACT_ADDRTYPES_W PROP_TAG(PT_MV_UNICODE,0x3A54)
#define PR_CONTACT_ADDRTYPES_A PROP_TAG(PT_MV_STRING8,0x3A54)
#define PR_CONTACT_DEFAULT_ADDRESS_INDEX PROP_TAG(PT_LONG,0x3A55)
#define PR_CONTACT_EMAIL_ADDRESSES PROP_TAG(PT_MV_TSTRING,0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_W PROP_TAG(PT_MV_UNICODE,0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_A PROP_TAG(PT_MV_STRING8,0x3A56)
#define PR_COMPANY_MAIN_PHONE_NUMBER PROP_TAG(PT_TSTRING,0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_W PROP_TAG(PT_UNICODE,0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_A PROP_TAG(PT_STRING8,0x3A57)
#define PR_CHILDRENS_NAMES PROP_TAG(PT_MV_TSTRING,0x3A58)
#define PR_CHILDRENS_NAMES_W PROP_TAG(PT_MV_UNICODE,0x3A58)
#define PR_CHILDRENS_NAMES_A PROP_TAG(PT_MV_STRING8,0x3A58)
#define PR_HOME_ADDRESS_CITY PROP_TAG(PT_TSTRING,0x3A59)
#define PR_HOME_ADDRESS_CITY_W PROP_TAG(PT_UNICODE,0x3A59)
#define PR_HOME_ADDRESS_CITY_A PROP_TAG(PT_STRING8,0x3A59)
#define PR_HOME_ADDRESS_COUNTRY PROP_TAG(PT_TSTRING,0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_W PROP_TAG(PT_UNICODE,0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_A PROP_TAG(PT_STRING8,0x3A5A)
#define PR_HOME_ADDRESS_POSTAL_CODE PROP_TAG(PT_TSTRING,0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_W PROP_TAG(PT_UNICODE,0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_A PROP_TAG(PT_STRING8,0x3A5B)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE PROP_TAG(PT_TSTRING,0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_W PROP_TAG(PT_UNICODE,0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_A PROP_TAG(PT_STRING8,0x3A5C)
#define PR_HOME_ADDRESS_STREET PROP_TAG(PT_TSTRING,0x3A5D)
#define PR_HOME_ADDRESS_STREET_W PROP_TAG(PT_UNICODE,0x3A5D)
#define PR_HOME_ADDRESS_STREET_A PROP_TAG(PT_STRING8,0x3A5D)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX PROP_TAG(PT_TSTRING,0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_W PROP_TAG(PT_UNICODE,0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_A PROP_TAG(PT_STRING8,0x3A5E)
#define PR_OTHER_ADDRESS_CITY PROP_TAG(PT_TSTRING,0x3A5F)
#define PR_OTHER_ADDRESS_CITY_W PROP_TAG(PT_UNICODE,0x3A5F)
#define PR_OTHER_ADDRESS_CITY_A PROP_TAG(PT_STRING8,0x3A5F)
#define PR_OTHER_ADDRESS_COUNTRY PROP_TAG(PT_TSTRING,0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_W PROP_TAG(PT_UNICODE,0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_A PROP_TAG(PT_STRING8,0x3A60)
#define PR_OTHER_ADDRESS_POSTAL_CODE PROP_TAG(PT_TSTRING,0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_W PROP_TAG(PT_UNICODE,0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_A PROP_TAG(PT_STRING8,0x3A61)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE PROP_TAG(PT_TSTRING,0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_W PROP_TAG(PT_UNICODE,0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_A PROP_TAG(PT_STRING8,0x3A62)
#define PR_OTHER_ADDRESS_STREET PROP_TAG(PT_TSTRING,0x3A63)
#define PR_OTHER_ADDRESS_STREET_W PROP_TAG(PT_UNICODE,0x3A63)
#define PR_OTHER_ADDRESS_STREET_A PROP_TAG(PT_STRING8,0x3A63)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX PROP_TAG(PT_TSTRING,0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_W PROP_TAG(PT_UNICODE,0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_A PROP_TAG(PT_STRING8,0x3A64)
#define PR_USER_X509_CERTIFICATE PROP_TAG(PT_MV_BINARY,0x3A70)
#define PR_SEND_INTERNET_ENCODING PROP_TAG(PT_LONG,0x3A71)

#define PR_BUSINESS_ADDRESS_CITY PR_LOCALITY
#define PR_BUSINESS_ADDRESS_COUNTRY PR_COUNTRY
#define PR_BUSINESS_ADDRESS_POSTAL_CODE PR_POSTAL_CODE
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE PR_STATE_OR_PROVINCE
#define PR_BUSINESS_ADDRESS_STREET PR_STREET_ADDRESS

#define PR_RECIPIENT_TYPE PROP_TAG(PT_LONG,0x0C15)

#define PROP_ID_SECURE_MIN 0x67F0
#define PROP_ID_SECURE_MAX 0x67FF

#define ENCODING_PREFERENCE ((ULONG) 0x00020000)

#define ENCODING_TEXT ((ULONG) 0x00000000)
#define ENCODING_MIME ((ULONG) 0x00040000)

#define BODY_ENCODING_MASK ((ULONG) 0x00180000)
#define BODY_ENCODING_TEXT ((ULONG) 0x00000000)
#define BODY_ENCODING_HTML ((ULONG) 0x00080000)
#define BODY_ENCODING_TEXT_AND_HTML ((ULONG) 0x00100000)

#define MAC_ATTACH_ENCODING_MASK ((ULONG) 0x00600000)
#define MAC_ATTACH_ENCODING_BINHEX ((ULONG) 0x00000000)
#define MAC_ATTACH_ENCODING_UUENCODE ((ULONG) 0x00200000)
#define MAC_ATTACH_ENCODING_APPLESINGLE ((ULONG) 0x00400000)
#define MAC_ATTACH_ENCODING_APPLEDOUBLE ((ULONG) 0x00600000)

enum Gender {
  genderUnspecified = 0,genderFemale,genderMale
};
#endif
                                                                                                                                                                                                                                                                  usr/share/mingw-w64/include/wabutil.h                                                               0100644 0000000 0000000 00000024677 12404413016 016175  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#if !defined(_MAPIUTIL_H) && !defined(_WABUTIL_H)
#define _WABUTIL_H

#include "mapidefs.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

  DECLARE_MAPI_INTERFACE_PTR(ITableData,LPTABLEDATA);

  typedef void (WINAPI CALLERRELEASE)(ULONG ulCallerData,LPTABLEDATA lpTblData,LPMAPITABLE lpVue);

#define MAPI_ITABLEDATA_METHODS(IPURE) MAPIMETHOD(HrGetView) (THIS_ LPSSortOrderSet lpSSortOrderSet,CALLERRELEASE *lpfCallerRelease,ULONG ulCallerData,LPMAPITABLE *lppMAPITable) IPURE; MAPIMETHOD(HrModifyRow) (THIS_ LPSRow) IPURE; MAPIMETHOD(HrDeleteRow) (THIS_ LPSPropValue lpSPropValue) IPURE; MAPIMETHOD(HrQueryRow) (THIS_ LPSPropValue lpsPropValue,LPSRow *lppSRow,ULONG *lpuliRow) IPURE; MAPIMETHOD(HrEnumRow) (THIS_ ULONG ulRowNumber,LPSRow *lppSRow) IPURE; MAPIMETHOD(HrNotify) (THIS_ ULONG ulFlags,ULONG cValues,LPSPropValue lpSPropValue) IPURE; MAPIMETHOD(HrInsertRow) (THIS_ ULONG uliRow,LPSRow lpSRow) IPURE; MAPIMETHOD(HrModifyRows) (THIS_ ULONG ulFlags,LPSRowSet lpSRowSet) IPURE; MAPIMETHOD(HrDeleteRows) (THIS_ ULONG ulFlags,LPSRowSet lprowsetToDelete,ULONG *cRowsDeleted) IPURE;
#undef INTERFACE
#define INTERFACE ITableData
  DECLARE_MAPI_INTERFACE_(ITableData,IUnknown) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_ITABLEDATA_METHODS(PURE)
  };

  STDAPI_(SCODE) CreateTable(LPCIID lpInterface,ALLOCATEBUFFER *lpAllocateBuffer,ALLOCATEMORE *lpAllocateMore,FREEBUFFER *lpFreeBuffer,LPVOID lpvReserved,ULONG ulTableType,ULONG ulPropTagIndexColumn,LPSPropTagArray lpSPropTagArrayColumns,LPTABLEDATA *lppTableData);

#define TAD_ALL_ROWS 1

#define MAPI_IPROPDATA_METHODS(IPURE) MAPIMETHOD(HrSetObjAccess) (THIS_ ULONG ulAccess) IPURE; MAPIMETHOD(HrSetPropAccess) (THIS_ LPSPropTagArray lpPropTagArray,ULONG *rgulAccess) IPURE; MAPIMETHOD(HrGetPropAccess) (THIS_ LPSPropTagArray *lppPropTagArray,ULONG **lprgulAccess) IPURE; MAPIMETHOD(HrAddObjProps) (THIS_ LPSPropTagArray lppPropTagArray,LPSPropProblemArray *lprgulAccess) IPURE;

#undef INTERFACE
#define INTERFACE IPropData
  DECLARE_MAPI_INTERFACE_(IPropData,IMAPIProp) {
    BEGIN_INTERFACE
      MAPI_IUNKNOWN_METHODS(PURE)
      MAPI_IMAPIPROP_METHODS(PURE)
      MAPI_IPROPDATA_METHODS(PURE)
  };

  DECLARE_MAPI_INTERFACE_PTR(IPropData,LPPROPDATA);

#ifndef CreateIProp
  STDAPI_(SCODE) CreateIProp(LPCIID lpInterface,ALLOCATEBUFFER *lpAllocateBuffer,ALLOCATEMORE *lpAllocateMore,FREEBUFFER *lpFreeBuffer,LPVOID lpvReserved,LPPROPDATA *lppPropData);
#endif

  STDAPI_(SCODE) WABCreateIProp(LPCIID lpInterface,ALLOCATEBUFFER *lpAllocateBuffer,ALLOCATEMORE *lpAllocateMore,FREEBUFFER *lpFreeBuffer,LPVOID lpvReserved,LPPROPDATA *lppPropData);

#define IPROP_READONLY ((ULONG) 0x00000001)
#define IPROP_READWRITE ((ULONG) 0x00000002)
#define IPROP_CLEAN ((ULONG) 0x00010000)
#define IPROP_DIRTY ((ULONG) 0x00020000)

#ifndef NOIDLEENGINE

#define PRILOWEST -32768
#define PRIHIGHEST 32767
#define PRIUSER 0

#define IRONULL ((USHORT) 0x0000)
#define FIROWAIT ((USHORT) 0x0001)
#define FIROINTERVAL ((USHORT) 0x0002)
#define FIROPERBLOCK ((USHORT) 0x0004)
#define FIRODISABLED ((USHORT) 0x0020)
#define FIROONCEONLY ((USHORT) 0x0040)

#define IRCNULL ((USHORT) 0x0000)
#define FIRCPFN ((USHORT) 0x0001)
#define FIRCPV ((USHORT) 0x0002)
#define FIRCPRI ((USHORT) 0x0004)
#define FIRCCSEC ((USHORT) 0x0008)
#define FIRCIRO ((USHORT) 0x0010)

  typedef WINBOOL (WINAPI FNIDLE)(LPVOID);
  typedef FNIDLE *PFNIDLE;

  typedef void *FTG;
  typedef FTG *PFTG;
#define FTGNULL ((FTG) NULL)

  STDAPI_(LONG) MAPIInitIdle(LPVOID lpvReserved);
  STDAPI_(VOID) MAPIDeinitIdle(VOID);
  STDAPI_(FTG) FtgRegisterIdleRoutine(PFNIDLE lpfnIdle,LPVOID lpvIdleParam,short priIdle,ULONG csecIdle,USHORT iroIdle);
  STDAPI_(void) DeregisterIdleRoutine(FTG ftg);
  STDAPI_(void) EnableIdleRoutine(FTG ftg,WINBOOL fEnable);
  STDAPI_(void) ChangeIdleRoutine(FTG ftg,PFNIDLE lpfnIdle,LPVOID lpvIdleParam,short priIdle,ULONG csecIdle,USHORT iroIdle,USHORT ircIdle);
#endif

  STDAPI_(LPMALLOC) MAPIGetDefaultMalloc(VOID);

#define SOF_UNIQUEFILENAME ((ULONG) 0x80000000)

  STDMETHODIMP OpenStreamOnFile(LPALLOCATEBUFFER lpAllocateBuffer,LPFREEBUFFER lpFreeBuffer,ULONG ulFlags,LPTSTR lpszFileName,LPTSTR lpszPrefix,LPSTREAM *lppStream);

  typedef HRESULT (WINAPI *LPOPENSTREAMONFILE) (LPALLOCATEBUFFER lpAllocateBuffer,LPFREEBUFFER lpFreeBuffer,ULONG ulFlags,LPTSTR lpszFileName,LPTSTR lpszPrefix,LPSTREAM *lppStream);

#define OPENSTREAMONFILE "OpenStreamOnFile"

  STDAPI_(SCODE) PropCopyMore(LPSPropValue lpSPropValueDest,LPSPropValue lpSPropValueSrc,ALLOCATEMORE *lpfAllocMore,LPVOID lpvObject);
  STDAPI_(ULONG) UlPropSize(LPSPropValue lpSPropValue);
  STDAPI_(WINBOOL) FEqualNames(LPMAPINAMEID lpName1,LPMAPINAMEID lpName2);

#ifndef _WINNT
#define _WINNT
#endif

  STDAPI_(void) GetInstance(LPSPropValue lpPropMv,LPSPropValue lpPropSv,ULONG uliInst);

  extern unsigned char rgchCsds[];
  extern unsigned char rgchCids[];
  extern unsigned char rgchCsdi[];
  extern unsigned char rgchCidi[];

  STDAPI_(WINBOOL) FPropContainsProp(LPSPropValue lpSPropValueDst,LPSPropValue lpSPropValueSrc,ULONG ulFuzzyLevel);
  STDAPI_(WINBOOL) FPropCompareProp(LPSPropValue lpSPropValue1,ULONG ulRelOp,LPSPropValue lpSPropValue2);
  STDAPI_(LONG) LPropCompareProp(LPSPropValue lpSPropValueA,LPSPropValue lpSPropValueB);
  STDAPI_(HRESULT) HrAddColumns(LPMAPITABLE lptbl,LPSPropTagArray lpproptagColumnsNew,LPALLOCATEBUFFER lpAllocateBuffer,LPFREEBUFFER lpFreeBuffer);
  STDAPI_(HRESULT) HrAddColumnsEx(LPMAPITABLE lptbl,LPSPropTagArray lpproptagColumnsNew,LPALLOCATEBUFFER lpAllocateBuffer,LPFREEBUFFER lpFreeBuffer,void (*lpfnFilterColumns)(LPSPropTagArray ptaga));
  STDAPI HrAllocAdviseSink(LPNOTIFCALLBACK lpfnCallback,LPVOID lpvContext,LPMAPIADVISESINK *lppAdviseSink);
  STDAPI HrThisThreadAdviseSink(LPMAPIADVISESINK lpAdviseSink,LPMAPIADVISESINK *lppAdviseSink);
  STDAPI HrDispatchNotifications(ULONG ulFlags);

  typedef struct {
    ULONG ulCtlType;
    ULONG ulCtlFlags;
    LPBYTE lpbNotif;
    ULONG cbNotif;
    LPTSTR lpszFilter;
    ULONG ulItemID;
    union {
      LPVOID lpv;
      LPDTBLLABEL lplabel;
      LPDTBLEDIT lpedit;
      LPDTBLLBX lplbx;
      LPDTBLCOMBOBOX lpcombobox;
      LPDTBLDDLBX lpddlbx;
      LPDTBLCHECKBOX lpcheckbox;
      LPDTBLGROUPBOX lpgroupbox;
      LPDTBLBUTTON lpbutton;
      LPDTBLRADIOBUTTON lpradiobutton;
      LPDTBLMVLISTBOX lpmvlbx;
      LPDTBLMVDDLBX lpmvddlbx;
      LPDTBLPAGE lppage;
    } ctl;
  } DTCTL,*LPDTCTL;

  typedef struct {
    ULONG cctl;
    LPTSTR lpszResourceName;
    __C89_NAMELESS union {
      LPTSTR lpszComponent;
      ULONG ulItemID;
    };
    LPDTCTL lpctl;
  } DTPAGE,*LPDTPAGE;

  STDAPI BuildDisplayTable(LPALLOCATEBUFFER lpAllocateBuffer,LPALLOCATEMORE lpAllocateMore,LPFREEBUFFER lpFreeBuffer,LPMALLOC lpMalloc,HINSTANCE hInstance,UINT cPages,LPDTPAGE lpPage,ULONG ulFlags,LPMAPITABLE *lppTable,LPTABLEDATA *lppTblData);
  STDAPI_(SCODE) ScCountNotifications(int cNotifications,LPNOTIFICATION lpNotifications,ULONG *lpcb);
  STDAPI_(SCODE) ScCopyNotifications(int cNotification,LPNOTIFICATION lpNotifications,LPVOID lpvDst,ULONG *lpcb);
  STDAPI_(SCODE) ScRelocNotifications(int cNotification,LPNOTIFICATION lpNotifications,LPVOID lpvBaseOld,LPVOID lpvBaseNew,ULONG *lpcb);
  STDAPI_(SCODE) ScCountProps(int cValues,LPSPropValue lpPropArray,ULONG *lpcb);
  STDAPI_(LPSPropValue) LpValFindProp(ULONG ulPropTag,ULONG cValues,LPSPropValue lpPropArray);
  STDAPI_(SCODE) ScCopyProps(int cValues,LPSPropValue lpPropArray,LPVOID lpvDst,ULONG *lpcb);
  STDAPI_(SCODE) ScRelocProps(int cValues,LPSPropValue lpPropArray,LPVOID lpvBaseOld,LPVOID lpvBaseNew,ULONG *lpcb);
  STDAPI_(SCODE) ScDupPropset(int cValues,LPSPropValue lpPropArray,LPALLOCATEBUFFER lpAllocateBuffer,LPSPropValue *lppPropArray);
  STDAPI_(ULONG) UlAddRef(LPVOID lpunk);
  STDAPI_(ULONG) UlRelease(LPVOID lpunk);
  STDAPI HrGetOneProp(LPMAPIPROP lpMapiProp,ULONG ulPropTag,LPSPropValue *lppProp);
  STDAPI HrSetOneProp(LPMAPIPROP lpMapiProp,LPSPropValue lpProp);
  STDAPI_(WINBOOL) FPropExists(LPMAPIPROP lpMapiProp,ULONG ulPropTag);
  STDAPI_(LPSPropValue) PpropFindProp(LPSPropValue lpPropArray,ULONG cValues,ULONG ulPropTag);
  STDAPI_(void) FreePadrlist(LPADRLIST lpAdrlist);
  STDAPI_(void) FreeProws(LPSRowSet lpRows);
  STDAPI HrQueryAllRows(LPMAPITABLE lpTable,LPSPropTagArray lpPropTags,LPSRestriction lpRestriction,LPSSortOrderSet lpSortOrderSet,LONG crowsMax,LPSRowSet *lppRows);
  STDAPI_(LPTSTR) SzFindCh(LPCTSTR lpsz,USHORT ch);
  STDAPI_(LPTSTR) SzFindLastCh(LPCTSTR lpsz,USHORT ch);
  STDAPI_(LPTSTR) SzFindSz(LPCTSTR lpsz,LPCTSTR lpszKey);
  STDAPI_(unsigned int) UFromSz(LPCTSTR lpsz);
  STDAPI_(SCODE) ScUNCFromLocalPath(LPSTR lpszLocal,LPSTR lpszUNC,UINT cchUNC);
  STDAPI_(SCODE) ScLocalPathFromUNC(LPSTR lpszUNC,LPSTR lpszLocal,UINT cchLocal);
  STDAPI_(FILETIME) FtAddFt(FILETIME ftAddend1,FILETIME ftAddend2);
  STDAPI_(FILETIME) FtMulDwDw(DWORD ftMultiplicand,DWORD ftMultiplier);
  STDAPI_(FILETIME) FtMulDw(DWORD ftMultiplier,FILETIME ftMultiplicand);
  STDAPI_(FILETIME) FtSubFt(FILETIME ftMinuend,FILETIME ftSubtrahend);
  STDAPI_(FILETIME) FtNegFt(FILETIME ft);
  STDAPI_(SCODE) ScCreateConversationIndex(ULONG cbParent,LPBYTE lpbParent,ULONG *lpcbConvIndex,LPBYTE *lppbConvIndex);
  STDAPI WrapStoreEntryID(ULONG ulFlags,LPTSTR lpszDLLName,ULONG cbOrigEntry,LPENTRYID lpOrigEntry,ULONG *lpcbWrappedEntry,LPENTRYID *lppWrappedEntry);

#define RTF_SYNC_RTF_CHANGED ((ULONG) 0x00000001)
#define RTF_SYNC_BODY_CHANGED ((ULONG) 0x00000002)

  STDAPI_(HRESULT) RTFSync (LPMESSAGE lpMessage,ULONG ulFlags,WINBOOL *lpfMessageUpdated);
  STDAPI_(HRESULT) WrapCompressedRTFStream (LPSTREAM lpCompressedRTFStream,ULONG ulFlags,LPSTREAM *lpUncompressedRTFStream);
  STDAPI_(HRESULT) HrIStorageFromStream (LPUNKNOWN lpUnkIn,LPCIID lpInterface,ULONG ulFlags,LPSTORAGE *lppStorageOut);
  STDAPI_(SCODE) ScInitMapiUtil(ULONG ulFlags);
  STDAPI_(VOID) DeinitMapiUtil(VOID);

#ifdef _X86_
#define szHrDispatchNotifications "_HrDispatchNotifications@4"
#endif

  typedef HRESULT (WINAPI DISPATCHNOTIFICATIONS)(ULONG ulFlags);
  typedef DISPATCHNOTIFICATIONS *LPDISPATCHNOTIFICATIONS;

#ifdef _X86_
#define szScCreateConversationIndex "_ScCreateConversationIndex@16"
#endif

  typedef SCODE (WINAPI CREATECONVERSATIONINDEX)(ULONG cbParent,LPBYTE lpbParent,ULONG *lpcbConvIndex,LPBYTE *lppbConvIndex);
  typedef CREATECONVERSATIONINDEX *LPCREATECONVERSATIONINDEX;

#ifdef __cplusplus
}
#endif
#endif
                                                                 usr/share/mingw-w64/include/wbemads.h                                                               0100644 0000000 0000000 00000012617 12404413016 016137  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error This stub requires an updated version of <rpcndr.h>
#endif

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif

#ifndef __wbemads_h__
#define __wbemads_h__

#ifndef __IWMIExtension_FWD_DEFINED__
#define __IWMIExtension_FWD_DEFINED__
typedef struct IWMIExtension IWMIExtension;
#endif

#ifndef __WMIExtension_FWD_DEFINED__
#define __WMIExtension_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMIExtension WMIExtension;
#else
typedef struct WMIExtension WMIExtension;
#endif
#endif

#ifndef __IWMIExtension_FWD_DEFINED__
#define __IWMIExtension_FWD_DEFINED__
typedef struct IWMIExtension IWMIExtension;
#endif

#include "oaidl.h"
#include "ocidl.h"
#include "wbemdisp.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __MIDL_user_allocate_free_DEFINED__
#define __MIDL_user_allocate_free_DEFINED__
  void *__RPC_API MIDL_user_allocate(size_t);
  void __RPC_API MIDL_user_free(void *);
#endif

  extern RPC_IF_HANDLE __MIDL_itf_wbemads_0000_v0_0_c_ifspec;
  extern RPC_IF_HANDLE __MIDL_itf_wbemads_0000_v0_0_s_ifspec;
#ifndef __WMIEXTENSIONLib_LIBRARY_DEFINED__
#define __WMIEXTENSIONLib_LIBRARY_DEFINED__
  EXTERN_C const IID LIBID_WMIEXTENSIONLib;
#ifndef __IWMIExtension_INTERFACE_DEFINED__
#define __IWMIExtension_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWMIExtension;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWMIExtension : public IDispatch {
  public:
    virtual HRESULT WINAPI get_WMIObjectPath(BSTR *strWMIObjectPath) = 0;
    virtual HRESULT WINAPI GetWMIObject(ISWbemObject **objWMIObject) = 0;
    virtual HRESULT WINAPI GetWMIServices(ISWbemServices **objWMIServices) = 0;
  };
#else
  typedef struct IWMIExtensionVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWMIExtension *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWMIExtension *This);
      ULONG (WINAPI *Release)(IWMIExtension *This);
      HRESULT (WINAPI *GetTypeInfoCount)(IWMIExtension *This,UINT *pctinfo);
      HRESULT (WINAPI *GetTypeInfo)(IWMIExtension *This,UINT iTInfo,LCID lcid,ITypeInfo **ppTInfo);
      HRESULT (WINAPI *GetIDsOfNames)(IWMIExtension *This,REFIID riid,LPOLESTR *rgszNames,UINT cNames,LCID lcid,DISPID *rgDispId);
      HRESULT (WINAPI *Invoke)(IWMIExtension *This,DISPID dispIdMember,REFIID riid,LCID lcid,WORD wFlags,DISPPARAMS *pDispParams,VARIANT *pVarResult,EXCEPINFO *pExcepInfo,UINT *puArgErr);
      HRESULT (WINAPI *get_WMIObjectPath)(IWMIExtension *This,BSTR *strWMIObjectPath);
      HRESULT (WINAPI *GetWMIObject)(IWMIExtension *This,ISWbemObject **objWMIObject);
      HRESULT (WINAPI *GetWMIServices)(IWMIExtension *This,ISWbemServices **objWMIServices);
    END_INTERFACE
  } IWMIExtensionVtbl;
  struct IWMIExtension {
    CONST_VTBL struct IWMIExtensionVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWMIExtension_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWMIExtension_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWMIExtension_Release(This) (This)->lpVtbl->Release(This)
#define IWMIExtension_GetTypeInfoCount(This,pctinfo) (This)->lpVtbl->GetTypeInfoCount(This,pctinfo)
#define IWMIExtension_GetTypeInfo(This,iTInfo,lcid,ppTInfo) (This)->lpVtbl->GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define IWMIExtension_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) (This)->lpVtbl->GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define IWMIExtension_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) (This)->lpVtbl->Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define IWMIExtension_get_WMIObjectPath(This,strWMIObjectPath) (This)->lpVtbl->get_WMIObjectPath(This,strWMIObjectPath)
#define IWMIExtension_GetWMIObject(This,objWMIObject) (This)->lpVtbl->GetWMIObject(This,objWMIObject)
#define IWMIExtension_GetWMIServices(This,objWMIServices) (This)->lpVtbl->GetWMIServices(This,objWMIServices)
#endif
#endif
  HRESULT WINAPI IWMIExtension_get_WMIObjectPath_Proxy(IWMIExtension *This,BSTR *strWMIObjectPath);
  void __RPC_STUB IWMIExtension_get_WMIObjectPath_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWMIExtension_GetWMIObject_Proxy(IWMIExtension *This,ISWbemObject **objWMIObject);
  void __RPC_STUB IWMIExtension_GetWMIObject_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWMIExtension_GetWMIServices_Proxy(IWMIExtension *This,ISWbemServices **objWMIServices);
  void __RPC_STUB IWMIExtension_GetWMIServices_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

  EXTERN_C const CLSID CLSID_WMIExtension;
#ifdef __cplusplus
  class WMIExtension;
#endif
#endif

  ULONG __RPC_API BSTR_UserSize(ULONG *,ULONG,BSTR *);
  unsigned char *__RPC_API BSTR_UserMarshal(ULONG *,unsigned char *,BSTR *);
  unsigned char *__RPC_API BSTR_UserUnmarshal(ULONG *,unsigned char *,BSTR *);
  void __RPC_API BSTR_UserFree(ULONG *,BSTR *);

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                 usr/share/mingw-w64/include/wbemcli.h                                                               0100644 0000000 0000000 00000356016 12404413016 016143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error This stub requires an updated version of <rpcndr.h>
#endif

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif

#ifndef __wbemcli_h__
#define __wbemcli_h__

#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef struct IWbemClassObject IWbemClassObject;
#endif

#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef struct IWbemObjectAccess IWbemObjectAccess;
#endif

#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef struct IWbemQualifierSet IWbemQualifierSet;
#endif

#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef struct IWbemServices IWbemServices;
#endif

#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef struct IWbemLocator IWbemLocator;
#endif

#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef struct IWbemObjectSink IWbemObjectSink;
#endif

#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef struct IEnumWbemClassObject IEnumWbemClassObject;
#endif

#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef struct IWbemCallResult IWbemCallResult;
#endif

#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef struct IWbemContext IWbemContext;
#endif

#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef struct IUnsecuredApartment IUnsecuredApartment;
#endif

#ifndef __IWbemUnsecuredApartment_FWD_DEFINED__
#define __IWbemUnsecuredApartment_FWD_DEFINED__
typedef struct IWbemUnsecuredApartment IWbemUnsecuredApartment;
#endif

#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef struct IWbemStatusCodeText IWbemStatusCodeText;
#endif

#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef struct IWbemBackupRestore IWbemBackupRestore;
#endif

#ifndef __IWbemBackupRestoreEx_FWD_DEFINED__
#define __IWbemBackupRestoreEx_FWD_DEFINED__
typedef struct IWbemBackupRestoreEx IWbemBackupRestoreEx;
#endif

#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef struct IWbemRefresher IWbemRefresher;
#endif

#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef struct IWbemHiPerfEnum IWbemHiPerfEnum;
#endif

#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef struct IWbemConfigureRefresher IWbemConfigureRefresher;
#endif

#ifndef __WbemLocator_FWD_DEFINED__
#define __WbemLocator_FWD_DEFINED__
#ifdef __cplusplus
typedef class WbemLocator WbemLocator;
#else
typedef struct WbemLocator WbemLocator;
#endif
#endif

#ifndef __WbemContext_FWD_DEFINED__
#define __WbemContext_FWD_DEFINED__
#ifdef __cplusplus
typedef class WbemContext WbemContext;
#else
typedef struct WbemContext WbemContext;
#endif
#endif

#ifndef __UnsecuredApartment_FWD_DEFINED__
#define __UnsecuredApartment_FWD_DEFINED__
#ifdef __cplusplus
typedef class UnsecuredApartment UnsecuredApartment;
#else
typedef struct UnsecuredApartment UnsecuredApartment;
#endif
#endif

#ifndef __WbemClassObject_FWD_DEFINED__
#define __WbemClassObject_FWD_DEFINED__
#ifdef __cplusplus
typedef class WbemClassObject WbemClassObject;
#else
typedef struct WbemClassObject WbemClassObject;
#endif
#endif

#ifndef __MofCompiler_FWD_DEFINED__
#define __MofCompiler_FWD_DEFINED__
#ifdef __cplusplus
typedef class MofCompiler MofCompiler;
#else
typedef struct MofCompiler MofCompiler;
#endif
#endif

#ifndef __WbemStatusCodeText_FWD_DEFINED__
#define __WbemStatusCodeText_FWD_DEFINED__
#ifdef __cplusplus
typedef class WbemStatusCodeText WbemStatusCodeText;
#else
typedef struct WbemStatusCodeText WbemStatusCodeText;
#endif
#endif

#ifndef __WbemBackupRestore_FWD_DEFINED__
#define __WbemBackupRestore_FWD_DEFINED__
#ifdef __cplusplus
typedef class WbemBackupRestore WbemBackupRestore;
#else
typedef struct WbemBackupRestore WbemBackupRestore;
#endif
#endif

#ifndef __WbemRefresher_FWD_DEFINED__
#define __WbemRefresher_FWD_DEFINED__
#ifdef __cplusplus
typedef class WbemRefresher WbemRefresher;
#else
typedef struct WbemRefresher WbemRefresher;
#endif
#endif

#ifndef __WbemObjectTextSrc_FWD_DEFINED__
#define __WbemObjectTextSrc_FWD_DEFINED__
#ifdef __cplusplus
typedef class WbemObjectTextSrc WbemObjectTextSrc;
#else
typedef struct WbemObjectTextSrc WbemObjectTextSrc;
#endif
#endif

#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef struct IWbemClassObject IWbemClassObject;
#endif

#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef struct IWbemQualifierSet IWbemQualifierSet;
#endif

#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef struct IWbemLocator IWbemLocator;
#endif

#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef struct IWbemObjectSink IWbemObjectSink;
#endif

#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef struct IEnumWbemClassObject IEnumWbemClassObject;
#endif

#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef struct IWbemContext IWbemContext;
#endif

#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef struct IWbemCallResult IWbemCallResult;
#endif

#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef struct IWbemServices IWbemServices;
#endif

#ifndef __IWbemShutdown_FWD_DEFINED__
#define __IWbemShutdown_FWD_DEFINED__
typedef struct IWbemShutdown IWbemShutdown;
#endif

#ifndef __IWbemObjectTextSrc_FWD_DEFINED__
#define __IWbemObjectTextSrc_FWD_DEFINED__
typedef struct IWbemObjectTextSrc IWbemObjectTextSrc;
#endif

#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef struct IWbemObjectAccess IWbemObjectAccess;
#endif

#ifndef __IMofCompiler_FWD_DEFINED__
#define __IMofCompiler_FWD_DEFINED__
typedef struct IMofCompiler IMofCompiler;
#endif

#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef struct IUnsecuredApartment IUnsecuredApartment;
#endif

#ifndef __IWbemUnsecuredApartment_FWD_DEFINED__
#define __IWbemUnsecuredApartment_FWD_DEFINED__
typedef struct IWbemUnsecuredApartment IWbemUnsecuredApartment;
#endif

#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef struct IWbemStatusCodeText IWbemStatusCodeText;
#endif

#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef struct IWbemBackupRestore IWbemBackupRestore;
#endif

#ifndef __IWbemBackupRestoreEx_FWD_DEFINED__
#define __IWbemBackupRestoreEx_FWD_DEFINED__
typedef struct IWbemBackupRestoreEx IWbemBackupRestoreEx;
#endif

#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef struct IWbemRefresher IWbemRefresher;
#endif

#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef struct IWbemHiPerfEnum IWbemHiPerfEnum;
#endif

#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef struct IWbemConfigureRefresher IWbemConfigureRefresher;
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __MIDL_user_allocate_free_DEFINED__
#define __MIDL_user_allocate_free_DEFINED__
  void *__RPC_API MIDL_user_allocate(size_t);
  void __RPC_API MIDL_user_free(void *);
#endif

#ifndef __WbemClient_v1_LIBRARY_DEFINED__
#define __WbemClient_v1_LIBRARY_DEFINED__

  typedef enum tag_WBEM_GENUS_TYPE {
    WBEM_GENUS_CLASS = 1,WBEM_GENUS_INSTANCE = 2
  } WBEM_GENUS_TYPE;

  typedef enum tag_WBEM_CHANGE_FLAG_TYPE {
    WBEM_FLAG_CREATE_OR_UPDATE = 0,WBEM_FLAG_UPDATE_ONLY = 0x1,WBEM_FLAG_CREATE_ONLY = 0x2,WBEM_FLAG_UPDATE_COMPATIBLE = 0,
    WBEM_FLAG_UPDATE_SAFE_MODE = 0x20,WBEM_FLAG_UPDATE_FORCE_MODE = 0x40,WBEM_MASK_UPDATE_MODE = 0x60,WBEM_FLAG_ADVISORY = 0x10000
  } WBEM_CHANGE_FLAG_TYPE;

  typedef enum tag_WBEM_GENERIC_FLAG_TYPE {
    WBEM_FLAG_RETURN_IMMEDIATELY = 0x10,WBEM_FLAG_RETURN_WBEM_COMPLETE = 0,WBEM_FLAG_BIDIRECTIONAL = 0,WBEM_FLAG_FORWARD_ONLY = 0x20,
    WBEM_FLAG_NO_ERROR_OBJECT = 0x40,WBEM_FLAG_RETURN_ERROR_OBJECT = 0,WBEM_FLAG_SEND_STATUS = 0x80,WBEM_FLAG_DONT_SEND_STATUS = 0,
    WBEM_FLAG_ENSURE_LOCATABLE = 0x100,WBEM_FLAG_DIRECT_READ = 0x200,WBEM_FLAG_SEND_ONLY_SELECTED = 0,WBEM_RETURN_WHEN_COMPLETE = 0,
    WBEM_RETURN_IMMEDIATELY = 0x10,WBEM_MASK_RESERVED_FLAGS = 0x1f000,WBEM_FLAG_USE_AMENDED_QUALIFIERS = 0x20000,
    WBEM_FLAG_STRONG_VALIDATION = 0x100000
  } WBEM_GENERIC_FLAG_TYPE;

  typedef enum tag_WBEM_STATUS_TYPE {
    WBEM_STATUS_COMPLETE = 0,WBEM_STATUS_REQUIREMENTS = 1,WBEM_STATUS_PROGRESS = 2
  } WBEM_STATUS_TYPE;

  typedef enum tag_WBEM_TIMEOUT_TYPE {
    WBEM_NO_WAIT = 0,WBEM_INFINITE = 0xffffffff
  } WBEM_TIMEOUT_TYPE;

  typedef enum tag_WBEM_CONDITION_FLAG_TYPE {
    WBEM_FLAG_ALWAYS = 0,WBEM_FLAG_ONLY_IF_TRUE = 0x1,WBEM_FLAG_ONLY_IF_FALSE = 0x2,WBEM_FLAG_ONLY_IF_IDENTICAL = 0x3,WBEM_MASK_PRIMARY_CONDITION = 0x3,
    WBEM_FLAG_KEYS_ONLY = 0x4,WBEM_FLAG_REFS_ONLY = 0x8,WBEM_FLAG_LOCAL_ONLY = 0x10,WBEM_FLAG_PROPAGATED_ONLY = 0x20,WBEM_FLAG_SYSTEM_ONLY = 0x30,
    WBEM_FLAG_NONSYSTEM_ONLY = 0x40,WBEM_MASK_CONDITION_ORIGIN = 0x70,WBEM_FLAG_CLASS_OVERRIDES_ONLY = 0x100,WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES = 0x200,
    WBEM_MASK_CLASS_CONDITION = 0x300
  } WBEM_CONDITION_FLAG_TYPE;

  typedef enum tag_WBEM_FLAVOR_TYPE {
    WBEM_FLAVOR_DONT_PROPAGATE = 0,WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE = 0x1,WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS = 0x2,
    WBEM_FLAVOR_MASK_PROPAGATION = 0xf,WBEM_FLAVOR_OVERRIDABLE = 0,WBEM_FLAVOR_NOT_OVERRIDABLE = 0x10,WBEM_FLAVOR_MASK_PERMISSIONS = 0x10,
    WBEM_FLAVOR_ORIGIN_LOCAL = 0,WBEM_FLAVOR_ORIGIN_PROPAGATED = 0x20,WBEM_FLAVOR_ORIGIN_SYSTEM = 0x40,WBEM_FLAVOR_MASK_ORIGIN = 0x60,
    WBEM_FLAVOR_NOT_AMENDED = 0,WBEM_FLAVOR_AMENDED = 0x80,WBEM_FLAVOR_MASK_AMENDED = 0x80
  } WBEM_FLAVOR_TYPE;

  typedef enum tag_WBEM_QUERY_FLAG_TYPE {
    WBEM_FLAG_DEEP = 0,WBEM_FLAG_SHALLOW = 1,WBEM_FLAG_PROTOTYPE = 2
  } WBEM_QUERY_FLAG_TYPE;

  typedef enum tag_WBEM_SECURITY_FLAGS {
    WBEM_ENABLE = 1,WBEM_METHOD_EXECUTE = 2,WBEM_FULL_WRITE_REP = 4,WBEM_PARTIAL_WRITE_REP = 8,WBEM_WRITE_PROVIDER = 0x10,WBEM_REMOTE_ACCESS = 0x20,
    WBEM_RIGHT_SUBSCRIBE = 0x40,WBEM_RIGHT_PUBLISH = 0x80
  } WBEM_SECURITY_FLAGS;

  typedef enum tag_WBEM_LIMITATION_FLAG_TYPE {
    WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS = 0x10,WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS = 0x20
  } WBEM_LIMITATION_FLAG_TYPE;

  typedef enum tag_WBEM_TEXT_FLAG_TYPE {
    WBEM_FLAG_NO_FLAVORS = 0x1
  } WBEM_TEXT_FLAG_TYPE;

  typedef enum tag_WBEM_COMPARISON_FLAG {
    WBEM_COMPARISON_INCLUDE_ALL = 0,WBEM_FLAG_IGNORE_QUALIFIERS = 0x1,WBEM_FLAG_IGNORE_OBJECT_SOURCE = 0x2,WBEM_FLAG_IGNORE_DEFAULT_VALUES = 0x4,
    WBEM_FLAG_IGNORE_CLASS = 0x8,WBEM_FLAG_IGNORE_CASE = 0x10,WBEM_FLAG_IGNORE_FLAVOR = 0x20
  } WBEM_COMPARISON_FLAG;

  typedef enum tag_WBEM_LOCKING {
    WBEM_FLAG_ALLOW_READ = 0x1
  } WBEM_LOCKING_FLAG_TYPE;

  typedef enum tag_CIMTYPE_ENUMERATION {
    CIM_ILLEGAL = 0xfff,CIM_EMPTY = 0,CIM_SINT8 = 16,CIM_UINT8 = 17,CIM_SINT16 = 2,CIM_UINT16 = 18,CIM_SINT32 = 3,CIM_UINT32 = 19,CIM_SINT64 = 20,
    CIM_UINT64 = 21,CIM_REAL32 = 4,CIM_REAL64 = 5,CIM_BOOLEAN = 11,CIM_STRING = 8,CIM_DATETIME = 101,CIM_REFERENCE = 102,CIM_CHAR16 = 103,
    CIM_OBJECT = 13,CIM_FLAG_ARRAY = 0x2000
  } CIMTYPE_ENUMERATION;

  typedef enum tag_WBEM_BACKUP_RESTORE_FLAGS {
    WBEM_FLAG_BACKUP_RESTORE_DEFAULT = 0,WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN = 1
  } WBEM_BACKUP_RESTORE_FLAGS;

  typedef enum tag_WBEM_REFRESHER_FLAGS {
    WBEM_FLAG_REFRESH_AUTO_RECONNECT = 0,WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT = 1
  } WBEM_REFRESHER_FLAGS;

  typedef enum tag_WBEM_SHUTDOWN_FLAGS {
    WBEM_SHUTDOWN_UNLOAD_COMPONENT = 1,WBEM_SHUTDOWN_WMI = 2,WBEM_SHUTDOWN_OS = 3
  } WBEM_SHUTDOWN_FLAGS;

  typedef __LONG32 CIMTYPE;

  typedef enum tag_WBEMSTATUS_FORMAT {
    WBEMSTATUS_FORMAT_NEWLINE = 0,WBEMSTATUS_FORMAT_NO_NEWLINE = 1
  } WBEMSTATUS_FORMAT;

  typedef enum tag_WBEM_LIMITS {
    WBEM_MAX_IDENTIFIER = 0x1000,WBEM_MAX_QUERY = 0x4000,WBEM_MAX_PATH = 0x2000,WBEM_MAX_OBJECT_NESTING = 64,WBEM_MAX_USER_PROPERTIES = 1024
  } WBEM_LIMITS;

  typedef enum tag_WBEMSTATUS {
    WBEM_NO_ERROR = 0,WBEM_S_NO_ERROR = 0,WBEM_S_SAME = 0,WBEM_S_FALSE = 1,WBEM_S_ALREADY_EXISTS = 0x40001,WBEM_S_RESET_TO_DEFAULT = 0x40002,
    WBEM_S_DIFFERENT = 0x40003,WBEM_S_TIMEDOUT = 0x40004,WBEM_S_NO_MORE_DATA = 0x40005,WBEM_S_OPERATION_CANCELLED = 0x40006,WBEM_S_PENDING = 0x40007,
    WBEM_S_DUPLICATE_OBJECTS = 0x40008,WBEM_S_ACCESS_DENIED = 0x40009,WBEM_S_PARTIAL_RESULTS = 0x40010,WBEM_S_SOURCE_NOT_AVAILABLE = 0x40017,
    WBEM_E_FAILED = 0x80041001,WBEM_E_NOT_FOUND = 0x80041002,WBEM_E_ACCESS_DENIED = 0x80041003,WBEM_E_PROVIDER_FAILURE = 0x80041004,
    WBEM_E_TYPE_MISMATCH = 0x80041005,WBEM_E_OUT_OF_MEMORY = 0x80041006,WBEM_E_INVALID_CONTEXT = 0x80041007,WBEM_E_INVALID_PARAMETER = 0x80041008,
    WBEM_E_NOT_AVAILABLE = 0x80041009,WBEM_E_CRITICAL_ERROR = 0x8004100a,WBEM_E_INVALID_STREAM = 0x8004100b,WBEM_E_NOT_SUPPORTED = 0x8004100c,
    WBEM_E_INVALID_SUPERCLASS = 0x8004100d,WBEM_E_INVALID_NAMESPACE = 0x8004100e,WBEM_E_INVALID_OBJECT = 0x8004100f,WBEM_E_INVALID_CLASS = 0x80041010,
    WBEM_E_PROVIDER_NOT_FOUND = 0x80041011,WBEM_E_INVALID_PROVIDER_REGISTRATION = 0x80041012,WBEM_E_PROVIDER_LOAD_FAILURE = 0x80041013,
    WBEM_E_INITIALIZATION_FAILURE = 0x80041014,WBEM_E_TRANSPORT_FAILURE = 0x80041015,WBEM_E_INVALID_OPERATION = 0x80041016,
    WBEM_E_INVALID_QUERY = 0x80041017,WBEM_E_INVALID_QUERY_TYPE = 0x80041018,WBEM_E_ALREADY_EXISTS = 0x80041019,WBEM_E_OVERRIDE_NOT_ALLOWED = 0x8004101a,
    WBEM_E_PROPAGATED_QUALIFIER = 0x8004101b,WBEM_E_PROPAGATED_PROPERTY = 0x8004101c,WBEM_E_UNEXPECTED = 0x8004101d,WBEM_E_ILLEGAL_OPERATION = 0x8004101e,
    WBEM_E_CANNOT_BE_KEY = 0x8004101f,WBEM_E_INCOMPLETE_CLASS = 0x80041020,WBEM_E_INVALID_SYNTAX = 0x80041021,WBEM_E_NONDECORATED_OBJECT = 0x80041022,
    WBEM_E_READ_ONLY = 0x80041023,WBEM_E_PROVIDER_NOT_CAPABLE = 0x80041024,WBEM_E_CLASS_HAS_CHILDREN = 0x80041025,
    WBEM_E_CLASS_HAS_INSTANCES = 0x80041026,WBEM_E_QUERY_NOT_IMPLEMENTED = 0x80041027,WBEM_E_ILLEGAL_NULL = 0x80041028,
    WBEM_E_INVALID_QUALIFIER_TYPE = 0x80041029,WBEM_E_INVALID_PROPERTY_TYPE = 0x8004102a,WBEM_E_VALUE_OUT_OF_RANGE = 0x8004102b,
    WBEM_E_CANNOT_BE_SINGLETON = 0x8004102c,WBEM_E_INVALID_CIM_TYPE = 0x8004102d,WBEM_E_INVALID_METHOD = 0x8004102e,
    WBEM_E_INVALID_METHOD_PARAMETERS = 0x8004102f,WBEM_E_SYSTEM_PROPERTY = 0x80041030,WBEM_E_INVALID_PROPERTY = 0x80041031,
    WBEM_E_CALL_CANCELLED = 0x80041032,WBEM_E_SHUTTING_DOWN = 0x80041033,WBEM_E_PROPAGATED_METHOD = 0x80041034,
    WBEM_E_UNSUPPORTED_PARAMETER = 0x80041035,WBEM_E_MISSING_PARAMETER_ID = 0x80041036,WBEM_E_INVALID_PARAMETER_ID = 0x80041037,
    WBEM_E_NONCONSECUTIVE_PARAMETER_IDS = 0x80041038,WBEM_E_PARAMETER_ID_ON_RETVAL = 0x80041039,WBEM_E_INVALID_OBJECT_PATH = 0x8004103a,
    WBEM_E_OUT_OF_DISK_SPACE = 0x8004103b,WBEM_E_BUFFER_TOO_SMALL = 0x8004103c,WBEM_E_UNSUPPORTED_PUT_EXTENSION = 0x8004103d,
    WBEM_E_UNKNOWN_OBJECT_TYPE = 0x8004103e,WBEM_E_UNKNOWN_PACKET_TYPE = 0x8004103f,WBEM_E_MARSHAL_VERSION_MISMATCH = 0x80041040,
    WBEM_E_MARSHAL_INVALID_SIGNATURE = 0x80041041,WBEM_E_INVALID_QUALIFIER = 0x80041042,WBEM_E_INVALID_DUPLICATE_PARAMETER = 0x80041043,
    WBEM_E_TOO_MUCH_DATA = 0x80041044,WBEM_E_SERVER_TOO_BUSY = 0x80041045,WBEM_E_INVALID_FLAVOR = 0x80041046,WBEM_E_CIRCULAR_REFERENCE = 0x80041047,
    WBEM_E_UNSUPPORTED_CLASS_UPDATE = 0x80041048,WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE = 0x80041049,WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE = 0x80041050,
    WBEM_E_TOO_MANY_PROPERTIES = 0x80041051,WBEM_E_UPDATE_TYPE_MISMATCH = 0x80041052,WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED = 0x80041053,
    WBEM_E_UPDATE_PROPAGATED_METHOD = 0x80041054,WBEM_E_METHOD_NOT_IMPLEMENTED = 0x80041055,WBEM_E_METHOD_DISABLED = 0x80041056,
    WBEM_E_REFRESHER_BUSY = 0x80041057,WBEM_E_UNPARSABLE_QUERY = 0x80041058,WBEM_E_NOT_EVENT_CLASS = 0x80041059,WBEM_E_MISSING_GROUP_WITHIN = 0x8004105a,
    WBEM_E_MISSING_AGGREGATION_LIST = 0x8004105b,WBEM_E_PROPERTY_NOT_AN_OBJECT = 0x8004105c,WBEM_E_AGGREGATING_BY_OBJECT = 0x8004105d,
    WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY = 0x8004105f,WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING = 0x80041060,WBEM_E_QUEUE_OVERFLOW = 0x80041061,
    WBEM_E_PRIVILEGE_NOT_HELD = 0x80041062,WBEM_E_INVALID_OPERATOR = 0x80041063,WBEM_E_LOCAL_CREDENTIALS = 0x80041064,
    WBEM_E_CANNOT_BE_ABSTRACT = 0x80041065,WBEM_E_AMENDED_OBJECT = 0x80041066,WBEM_E_CLIENT_TOO_SLOW = 0x80041067,
    WBEM_E_NULL_SECURITY_DESCRIPTOR = 0x80041068,WBEM_E_TIMED_OUT = 0x80041069,WBEM_E_INVALID_ASSOCIATION = 0x8004106a,
    WBEM_E_AMBIGUOUS_OPERATION = 0x8004106b,WBEM_E_QUOTA_VIOLATION = 0x8004106c,WBEM_E_RESERVED_001 = 0x8004106d,WBEM_E_RESERVED_002 = 0x8004106e,
    WBEM_E_UNSUPPORTED_LOCALE = 0x8004106f,WBEM_E_HANDLE_OUT_OF_DATE = 0x80041070,WBEM_E_CONNECTION_FAILED = 0x80041071,
    WBEM_E_INVALID_HANDLE_REQUEST = 0x80041072,WBEM_E_PROPERTY_NAME_TOO_WIDE = 0x80041073,WBEM_E_CLASS_NAME_TOO_WIDE = 0x80041074,
    WBEM_E_METHOD_NAME_TOO_WIDE = 0x80041075,WBEM_E_QUALIFIER_NAME_TOO_WIDE = 0x80041076,WBEM_E_RERUN_COMMAND = 0x80041077,
    WBEM_E_DATABASE_VER_MISMATCH = 0x80041078,WBEM_E_VETO_DELETE = 0x80041079,WBEM_E_VETO_PUT = 0x8004107a,WBEM_E_INVALID_LOCALE = 0x80041080,
    WBEM_E_PROVIDER_SUSPENDED = 0x80041081,WBEM_E_SYNCHRONIZATION_REQUIRED = 0x80041082,WBEM_E_NO_SCHEMA = 0x80041083,
    WBEM_E_PROVIDER_ALREADY_REGISTERED = 0x80041084,WBEM_E_PROVIDER_NOT_REGISTERED = 0x80041085,WBEM_E_FATAL_TRANSPORT_ERROR = 0x80041086,
    WBEM_E_ENCRYPTED_CONNECTION_REQUIRED = 0x80041087,WBEM_E_PROVIDER_TIMED_OUT = 0x80041088,WBEM_E_NO_KEY = 0x80041089,
    WBEM_E_PROVIDER_DISABLED = 0x8004108a,WBEMESS_E_REGISTRATION_TOO_BROAD = 0x80042001,WBEMESS_E_REGISTRATION_TOO_PRECISE = 0x80042002,
    WBEMESS_E_AUTHZ_NOT_PRIVILEGED = 0x80042003,WBEMMOF_E_EXPECTED_QUALIFIER_NAME = 0x80044001,WBEMMOF_E_EXPECTED_SEMI = 0x80044002,
    WBEMMOF_E_EXPECTED_OPEN_BRACE = 0x80044003,WBEMMOF_E_EXPECTED_CLOSE_BRACE = 0x80044004,WBEMMOF_E_EXPECTED_CLOSE_BRACKET = 0x80044005,
    WBEMMOF_E_EXPECTED_CLOSE_PAREN = 0x80044006,WBEMMOF_E_ILLEGAL_CONSTANT_VALUE = 0x80044007,WBEMMOF_E_EXPECTED_TYPE_IDENTIFIER = 0x80044008,
    WBEMMOF_E_EXPECTED_OPEN_PAREN = 0x80044009,WBEMMOF_E_UNRECOGNIZED_TOKEN = 0x8004400a,WBEMMOF_E_UNRECOGNIZED_TYPE = 0x8004400b,
    WBEMMOF_E_EXPECTED_PROPERTY_NAME = 0x8004400c,WBEMMOF_E_TYPEDEF_NOT_SUPPORTED = 0x8004400d,WBEMMOF_E_UNEXPECTED_ALIAS = 0x8004400e,
    WBEMMOF_E_UNEXPECTED_ARRAY_INIT = 0x8004400f,WBEMMOF_E_INVALID_AMENDMENT_SYNTAX = 0x80044010,WBEMMOF_E_INVALID_DUPLICATE_AMENDMENT = 0x80044011,
    WBEMMOF_E_INVALID_PRAGMA = 0x80044012,WBEMMOF_E_INVALID_NAMESPACE_SYNTAX = 0x80044013,WBEMMOF_E_EXPECTED_CLASS_NAME = 0x80044014,
    WBEMMOF_E_TYPE_MISMATCH = 0x80044015,WBEMMOF_E_EXPECTED_ALIAS_NAME = 0x80044016,WBEMMOF_E_INVALID_CLASS_DECLARATION = 0x80044017,
    WBEMMOF_E_INVALID_INSTANCE_DECLARATION = 0x80044018,WBEMMOF_E_EXPECTED_DOLLAR = 0x80044019,WBEMMOF_E_CIMTYPE_QUALIFIER = 0x8004401a,
    WBEMMOF_E_DUPLICATE_PROPERTY = 0x8004401b,WBEMMOF_E_INVALID_NAMESPACE_SPECIFICATION = 0x8004401c,WBEMMOF_E_OUT_OF_RANGE = 0x8004401d,
    WBEMMOF_E_INVALID_FILE = 0x8004401e,WBEMMOF_E_ALIASES_IN_EMBEDDED = 0x8004401f,WBEMMOF_E_NULL_ARRAY_ELEM = 0x80044020,
    WBEMMOF_E_DUPLICATE_QUALIFIER = 0x80044021,WBEMMOF_E_EXPECTED_FLAVOR_TYPE = 0x80044022,WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES = 0x80044023,
    WBEMMOF_E_MULTIPLE_ALIASES = 0x80044024,WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2 = 0x80044025,WBEMMOF_E_NO_ARRAYS_RETURNED = 0x80044026,
    WBEMMOF_E_MUST_BE_IN_OR_OUT = 0x80044027,WBEMMOF_E_INVALID_FLAGS_SYNTAX = 0x80044028,WBEMMOF_E_EXPECTED_BRACE_OR_BAD_TYPE = 0x80044029,
    WBEMMOF_E_UNSUPPORTED_CIMV22_QUAL_VALUE = 0x8004402a,WBEMMOF_E_UNSUPPORTED_CIMV22_DATA_TYPE = 0x8004402b,
    WBEMMOF_E_INVALID_DELETEINSTANCE_SYNTAX = 0x8004402c,WBEMMOF_E_INVALID_QUALIFIER_SYNTAX = 0x8004402d,
    WBEMMOF_E_QUALIFIER_USED_OUTSIDE_SCOPE = 0x8004402e,WBEMMOF_E_ERROR_CREATING_TEMP_FILE = 0x8004402f,
    WBEMMOF_E_ERROR_INVALID_INCLUDE_FILE = 0x80044030,WBEMMOF_E_INVALID_DELETECLASS_SYNTAX = 0x80044031
  } WBEMSTATUS;

  EXTERN_C const IID LIBID_WbemClient_v1;
#ifndef __IWbemClassObject_INTERFACE_DEFINED__
#define __IWbemClassObject_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemClassObject;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemClassObject : public IUnknown {
  public:
    virtual HRESULT WINAPI GetQualifierSet(IWbemQualifierSet **ppQualSet) = 0;
    virtual HRESULT WINAPI Get(LPCWSTR wszName,__LONG32 lFlags,VARIANT *pVal,CIMTYPE *pType,__LONG32 *plFlavor) = 0;
    virtual HRESULT WINAPI Put(LPCWSTR wszName,__LONG32 lFlags,VARIANT *pVal,CIMTYPE Type) = 0;
    virtual HRESULT WINAPI Delete(LPCWSTR wszName) = 0;
    virtual HRESULT WINAPI GetNames(LPCWSTR wszQualifierName,__LONG32 lFlags,VARIANT *pQualifierVal,SAFEARRAY **pNames) = 0;
    virtual HRESULT WINAPI BeginEnumeration(__LONG32 lEnumFlags) = 0;
    virtual HRESULT WINAPI Next(__LONG32 lFlags,BSTR *strName,VARIANT *pVal,CIMTYPE *pType,__LONG32 *plFlavor) = 0;
    virtual HRESULT WINAPI EndEnumeration(void) = 0;
    virtual HRESULT WINAPI GetPropertyQualifierSet(LPCWSTR wszProperty,IWbemQualifierSet **ppQualSet) = 0;
    virtual HRESULT WINAPI Clone(IWbemClassObject **ppCopy) = 0;
    virtual HRESULT WINAPI GetObjectText(__LONG32 lFlags,BSTR *pstrObjectText) = 0;
    virtual HRESULT WINAPI SpawnDerivedClass(__LONG32 lFlags,IWbemClassObject **ppNewClass) = 0;
    virtual HRESULT WINAPI SpawnInstance(__LONG32 lFlags,IWbemClassObject **ppNewInstance) = 0;
    virtual HRESULT WINAPI CompareTo(__LONG32 lFlags,IWbemClassObject *pCompareTo) = 0;
    virtual HRESULT WINAPI GetPropertyOrigin(LPCWSTR wszName,BSTR *pstrClassName) = 0;
    virtual HRESULT WINAPI InheritsFrom(LPCWSTR strAncestor) = 0;
    virtual HRESULT WINAPI GetMethod(LPCWSTR wszName,__LONG32 lFlags,IWbemClassObject **ppInSignature,IWbemClassObject **ppOutSignature) = 0;
    virtual HRESULT WINAPI PutMethod(LPCWSTR wszName,__LONG32 lFlags,IWbemClassObject *pInSignature,IWbemClassObject *pOutSignature) = 0;
    virtual HRESULT WINAPI DeleteMethod(LPCWSTR wszName) = 0;
    virtual HRESULT WINAPI BeginMethodEnumeration(__LONG32 lEnumFlags) = 0;
    virtual HRESULT WINAPI NextMethod(__LONG32 lFlags,BSTR *pstrName,IWbemClassObject **ppInSignature,IWbemClassObject **ppOutSignature) = 0;
    virtual HRESULT WINAPI EndMethodEnumeration(void) = 0;
    virtual HRESULT WINAPI GetMethodQualifierSet(LPCWSTR wszMethod,IWbemQualifierSet **ppQualSet) = 0;
    virtual HRESULT WINAPI GetMethodOrigin(LPCWSTR wszMethodName,BSTR *pstrClassName) = 0;
  };
#else
  typedef struct IWbemClassObjectVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemClassObject *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemClassObject *This);
      ULONG (WINAPI *Release)(IWbemClassObject *This);
      HRESULT (WINAPI *GetQualifierSet)(IWbemClassObject *This,IWbemQualifierSet **ppQualSet);
      HRESULT (WINAPI *Get)(IWbemClassObject *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pVal,CIMTYPE *pType,__LONG32 *plFlavor);
      HRESULT (WINAPI *Put)(IWbemClassObject *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pVal,CIMTYPE Type);
      HRESULT (WINAPI *Delete)(IWbemClassObject *This,LPCWSTR wszName);
      HRESULT (WINAPI *GetNames)(IWbemClassObject *This,LPCWSTR wszQualifierName,__LONG32 lFlags,VARIANT *pQualifierVal,SAFEARRAY **pNames);
      HRESULT (WINAPI *BeginEnumeration)(IWbemClassObject *This,__LONG32 lEnumFlags);
      HRESULT (WINAPI *Next)(IWbemClassObject *This,__LONG32 lFlags,BSTR *strName,VARIANT *pVal,CIMTYPE *pType,__LONG32 *plFlavor);
      HRESULT (WINAPI *EndEnumeration)(IWbemClassObject *This);
      HRESULT (WINAPI *GetPropertyQualifierSet)(IWbemClassObject *This,LPCWSTR wszProperty,IWbemQualifierSet **ppQualSet);
      HRESULT (WINAPI *Clone)(IWbemClassObject *This,IWbemClassObject **ppCopy);
      HRESULT (WINAPI *GetObjectText)(IWbemClassObject *This,__LONG32 lFlags,BSTR *pstrObjectText);
      HRESULT (WINAPI *SpawnDerivedClass)(IWbemClassObject *This,__LONG32 lFlags,IWbemClassObject **ppNewClass);
      HRESULT (WINAPI *SpawnInstance)(IWbemClassObject *This,__LONG32 lFlags,IWbemClassObject **ppNewInstance);
      HRESULT (WINAPI *CompareTo)(IWbemClassObject *This,__LONG32 lFlags,IWbemClassObject *pCompareTo);
      HRESULT (WINAPI *GetPropertyOrigin)(IWbemClassObject *This,LPCWSTR wszName,BSTR *pstrClassName);
      HRESULT (WINAPI *InheritsFrom)(IWbemClassObject *This,LPCWSTR strAncestor);
      HRESULT (WINAPI *GetMethod)(IWbemClassObject *This,LPCWSTR wszName,__LONG32 lFlags,IWbemClassObject **ppInSignature,IWbemClassObject **ppOutSignature);
      HRESULT (WINAPI *PutMethod)(IWbemClassObject *This,LPCWSTR wszName,__LONG32 lFlags,IWbemClassObject *pInSignature,IWbemClassObject *pOutSignature);
      HRESULT (WINAPI *DeleteMethod)(IWbemClassObject *This,LPCWSTR wszName);
      HRESULT (WINAPI *BeginMethodEnumeration)(IWbemClassObject *This,__LONG32 lEnumFlags);
      HRESULT (WINAPI *NextMethod)(IWbemClassObject *This,__LONG32 lFlags,BSTR *pstrName,IWbemClassObject **ppInSignature,IWbemClassObject **ppOutSignature);
      HRESULT (WINAPI *EndMethodEnumeration)(IWbemClassObject *This);
      HRESULT (WINAPI *GetMethodQualifierSet)(IWbemClassObject *This,LPCWSTR wszMethod,IWbemQualifierSet **ppQualSet);
      HRESULT (WINAPI *GetMethodOrigin)(IWbemClassObject *This,LPCWSTR wszMethodName,BSTR *pstrClassName);
    END_INTERFACE
  } IWbemClassObjectVtbl;
  struct IWbemClassObject {
    CONST_VTBL struct IWbemClassObjectVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemClassObject_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemClassObject_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemClassObject_Release(This) (This)->lpVtbl->Release(This)
#define IWbemClassObject_GetQualifierSet(This,ppQualSet) (This)->lpVtbl->GetQualifierSet(This,ppQualSet)
#define IWbemClassObject_Get(This,wszName,lFlags,pVal,pType,plFlavor) (This)->lpVtbl->Get(This,wszName,lFlags,pVal,pType,plFlavor)
#define IWbemClassObject_Put(This,wszName,lFlags,pVal,Type) (This)->lpVtbl->Put(This,wszName,lFlags,pVal,Type)
#define IWbemClassObject_Delete(This,wszName) (This)->lpVtbl->Delete(This,wszName)
#define IWbemClassObject_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames) (This)->lpVtbl->GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)
#define IWbemClassObject_BeginEnumeration(This,lEnumFlags) (This)->lpVtbl->BeginEnumeration(This,lEnumFlags)
#define IWbemClassObject_Next(This,lFlags,strName,pVal,pType,plFlavor) (This)->lpVtbl->Next(This,lFlags,strName,pVal,pType,plFlavor)
#define IWbemClassObject_EndEnumeration(This) (This)->lpVtbl->EndEnumeration(This)
#define IWbemClassObject_GetPropertyQualifierSet(This,wszProperty,ppQualSet) (This)->lpVtbl->GetPropertyQualifierSet(This,wszProperty,ppQualSet)
#define IWbemClassObject_Clone(This,ppCopy) (This)->lpVtbl->Clone(This,ppCopy)
#define IWbemClassObject_GetObjectText(This,lFlags,pstrObjectText) (This)->lpVtbl->GetObjectText(This,lFlags,pstrObjectText)
#define IWbemClassObject_SpawnDerivedClass(This,lFlags,ppNewClass) (This)->lpVtbl->SpawnDerivedClass(This,lFlags,ppNewClass)
#define IWbemClassObject_SpawnInstance(This,lFlags,ppNewInstance) (This)->lpVtbl->SpawnInstance(This,lFlags,ppNewInstance)
#define IWbemClassObject_CompareTo(This,lFlags,pCompareTo) (This)->lpVtbl->CompareTo(This,lFlags,pCompareTo)
#define IWbemClassObject_GetPropertyOrigin(This,wszName,pstrClassName) (This)->lpVtbl->GetPropertyOrigin(This,wszName,pstrClassName)
#define IWbemClassObject_InheritsFrom(This,strAncestor) (This)->lpVtbl->InheritsFrom(This,strAncestor)
#define IWbemClassObject_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature) (This)->lpVtbl->GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)
#define IWbemClassObject_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature) (This)->lpVtbl->PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)
#define IWbemClassObject_DeleteMethod(This,wszName) (This)->lpVtbl->DeleteMethod(This,wszName)
#define IWbemClassObject_BeginMethodEnumeration(This,lEnumFlags) (This)->lpVtbl->BeginMethodEnumeration(This,lEnumFlags)
#define IWbemClassObject_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature) (This)->lpVtbl->NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)
#define IWbemClassObject_EndMethodEnumeration(This) (This)->lpVtbl->EndMethodEnumeration(This)
#define IWbemClassObject_GetMethodQualifierSet(This,wszMethod,ppQualSet) (This)->lpVtbl->GetMethodQualifierSet(This,wszMethod,ppQualSet)
#define IWbemClassObject_GetMethodOrigin(This,wszMethodName,pstrClassName) (This)->lpVtbl->GetMethodOrigin(This,wszMethodName,pstrClassName)
#endif
#endif
  HRESULT WINAPI IWbemClassObject_GetQualifierSet_Proxy(IWbemClassObject *This,IWbemQualifierSet **ppQualSet);
  void __RPC_STUB IWbemClassObject_GetQualifierSet_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_Get_Proxy(IWbemClassObject *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pVal,CIMTYPE *pType,__LONG32 *plFlavor);
  void __RPC_STUB IWbemClassObject_Get_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_Put_Proxy(IWbemClassObject *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pVal,CIMTYPE Type);
  void __RPC_STUB IWbemClassObject_Put_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_Delete_Proxy(IWbemClassObject *This,LPCWSTR wszName);
  void __RPC_STUB IWbemClassObject_Delete_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_GetNames_Proxy(IWbemClassObject *This,LPCWSTR wszQualifierName,__LONG32 lFlags,VARIANT *pQualifierVal,SAFEARRAY **pNames);
  void __RPC_STUB IWbemClassObject_GetNames_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_BeginEnumeration_Proxy(IWbemClassObject *This,__LONG32 lEnumFlags);
  void __RPC_STUB IWbemClassObject_BeginEnumeration_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_Next_Proxy(IWbemClassObject *This,__LONG32 lFlags,BSTR *strName,VARIANT *pVal,CIMTYPE *pType,__LONG32 *plFlavor);
  void __RPC_STUB IWbemClassObject_Next_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_EndEnumeration_Proxy(IWbemClassObject *This);
  void __RPC_STUB IWbemClassObject_EndEnumeration_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_GetPropertyQualifierSet_Proxy(IWbemClassObject *This,LPCWSTR wszProperty,IWbemQualifierSet **ppQualSet);
  void __RPC_STUB IWbemClassObject_GetPropertyQualifierSet_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_Clone_Proxy(IWbemClassObject *This,IWbemClassObject **ppCopy);
  void __RPC_STUB IWbemClassObject_Clone_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_GetObjectText_Proxy(IWbemClassObject *This,__LONG32 lFlags,BSTR *pstrObjectText);
  void __RPC_STUB IWbemClassObject_GetObjectText_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_SpawnDerivedClass_Proxy(IWbemClassObject *This,__LONG32 lFlags,IWbemClassObject **ppNewClass);
  void __RPC_STUB IWbemClassObject_SpawnDerivedClass_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_SpawnInstance_Proxy(IWbemClassObject *This,__LONG32 lFlags,IWbemClassObject **ppNewInstance);
  void __RPC_STUB IWbemClassObject_SpawnInstance_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_CompareTo_Proxy(IWbemClassObject *This,__LONG32 lFlags,IWbemClassObject *pCompareTo);
  void __RPC_STUB IWbemClassObject_CompareTo_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_GetPropertyOrigin_Proxy(IWbemClassObject *This,LPCWSTR wszName,BSTR *pstrClassName);
  void __RPC_STUB IWbemClassObject_GetPropertyOrigin_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_InheritsFrom_Proxy(IWbemClassObject *This,LPCWSTR strAncestor);
  void __RPC_STUB IWbemClassObject_InheritsFrom_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_GetMethod_Proxy(IWbemClassObject *This,LPCWSTR wszName,__LONG32 lFlags,IWbemClassObject **ppInSignature,IWbemClassObject **ppOutSignature);
  void __RPC_STUB IWbemClassObject_GetMethod_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_PutMethod_Proxy(IWbemClassObject *This,LPCWSTR wszName,__LONG32 lFlags,IWbemClassObject *pInSignature,IWbemClassObject *pOutSignature);
  void __RPC_STUB IWbemClassObject_PutMethod_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_DeleteMethod_Proxy(IWbemClassObject *This,LPCWSTR wszName);
  void __RPC_STUB IWbemClassObject_DeleteMethod_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_BeginMethodEnumeration_Proxy(IWbemClassObject *This,__LONG32 lEnumFlags);
  void __RPC_STUB IWbemClassObject_BeginMethodEnumeration_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_NextMethod_Proxy(IWbemClassObject *This,__LONG32 lFlags,BSTR *pstrName,IWbemClassObject **ppInSignature,IWbemClassObject **ppOutSignature);
  void __RPC_STUB IWbemClassObject_NextMethod_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_EndMethodEnumeration_Proxy(IWbemClassObject *This);
  void __RPC_STUB IWbemClassObject_EndMethodEnumeration_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_GetMethodQualifierSet_Proxy(IWbemClassObject *This,LPCWSTR wszMethod,IWbemQualifierSet **ppQualSet);
  void __RPC_STUB IWbemClassObject_GetMethodQualifierSet_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemClassObject_GetMethodOrigin_Proxy(IWbemClassObject *This,LPCWSTR wszMethodName,BSTR *pstrClassName);
  void __RPC_STUB IWbemClassObject_GetMethodOrigin_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IWbemObjectAccess_INTERFACE_DEFINED__
#define __IWbemObjectAccess_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemObjectAccess;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemObjectAccess : public IWbemClassObject {
  public:
    virtual HRESULT WINAPI GetPropertyHandle(LPCWSTR wszPropertyName,CIMTYPE *pType,__LONG32 *plHandle) = 0;
    virtual HRESULT WINAPI WritePropertyValue(__LONG32 lHandle,__LONG32 lNumBytes,const byte *aData) = 0;
    virtual HRESULT WINAPI ReadPropertyValue(__LONG32 lHandle,__LONG32 lBufferSize,__LONG32 *plNumBytes,byte *aData) = 0;
    virtual HRESULT WINAPI ReadDWORD(__LONG32 lHandle,DWORD *pdw) = 0;
    virtual HRESULT WINAPI WriteDWORD(__LONG32 lHandle,DWORD dw) = 0;
    __MINGW_EXTENSION virtual HRESULT WINAPI ReadQWORD(__LONG32 lHandle,unsigned __int64 *pqw) = 0;
    __MINGW_EXTENSION virtual HRESULT WINAPI WriteQWORD(__LONG32 lHandle,unsigned __int64 pw) = 0;
    virtual HRESULT WINAPI GetPropertyInfoByHandle(__LONG32 lHandle,BSTR *pstrName,CIMTYPE *pType) = 0;
    virtual HRESULT WINAPI Lock(__LONG32 lFlags) = 0;
    virtual HRESULT WINAPI Unlock(__LONG32 lFlags) = 0;
  };
#else
  typedef struct IWbemObjectAccessVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemObjectAccess *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemObjectAccess *This);
      ULONG (WINAPI *Release)(IWbemObjectAccess *This);
      HRESULT (WINAPI *GetQualifierSet)(IWbemObjectAccess *This,IWbemQualifierSet **ppQualSet);
      HRESULT (WINAPI *Get)(IWbemObjectAccess *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pVal,CIMTYPE *pType,__LONG32 *plFlavor);
      HRESULT (WINAPI *Put)(IWbemObjectAccess *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pVal,CIMTYPE Type);
      HRESULT (WINAPI *Delete)(IWbemObjectAccess *This,LPCWSTR wszName);
      HRESULT (WINAPI *GetNames)(IWbemObjectAccess *This,LPCWSTR wszQualifierName,__LONG32 lFlags,VARIANT *pQualifierVal,SAFEARRAY **pNames);
      HRESULT (WINAPI *BeginEnumeration)(IWbemObjectAccess *This,__LONG32 lEnumFlags);
      HRESULT (WINAPI *Next)(IWbemObjectAccess *This,__LONG32 lFlags,BSTR *strName,VARIANT *pVal,CIMTYPE *pType,__LONG32 *plFlavor);
      HRESULT (WINAPI *EndEnumeration)(IWbemObjectAccess *This);
      HRESULT (WINAPI *GetPropertyQualifierSet)(IWbemObjectAccess *This,LPCWSTR wszProperty,IWbemQualifierSet **ppQualSet);
      HRESULT (WINAPI *Clone)(IWbemObjectAccess *This,IWbemClassObject **ppCopy);
      HRESULT (WINAPI *GetObjectText)(IWbemObjectAccess *This,__LONG32 lFlags,BSTR *pstrObjectText);
      HRESULT (WINAPI *SpawnDerivedClass)(IWbemObjectAccess *This,__LONG32 lFlags,IWbemClassObject **ppNewClass);
      HRESULT (WINAPI *SpawnInstance)(IWbemObjectAccess *This,__LONG32 lFlags,IWbemClassObject **ppNewInstance);
      HRESULT (WINAPI *CompareTo)(IWbemObjectAccess *This,__LONG32 lFlags,IWbemClassObject *pCompareTo);
      HRESULT (WINAPI *GetPropertyOrigin)(IWbemObjectAccess *This,LPCWSTR wszName,BSTR *pstrClassName);
      HRESULT (WINAPI *InheritsFrom)(IWbemObjectAccess *This,LPCWSTR strAncestor);
      HRESULT (WINAPI *GetMethod)(IWbemObjectAccess *This,LPCWSTR wszName,__LONG32 lFlags,IWbemClassObject **ppInSignature,IWbemClassObject **ppOutSignature);
      HRESULT (WINAPI *PutMethod)(IWbemObjectAccess *This,LPCWSTR wszName,__LONG32 lFlags,IWbemClassObject *pInSignature,IWbemClassObject *pOutSignature);
      HRESULT (WINAPI *DeleteMethod)(IWbemObjectAccess *This,LPCWSTR wszName);
      HRESULT (WINAPI *BeginMethodEnumeration)(IWbemObjectAccess *This,__LONG32 lEnumFlags);
      HRESULT (WINAPI *NextMethod)(IWbemObjectAccess *This,__LONG32 lFlags,BSTR *pstrName,IWbemClassObject **ppInSignature,IWbemClassObject **ppOutSignature);
      HRESULT (WINAPI *EndMethodEnumeration)(IWbemObjectAccess *This);
      HRESULT (WINAPI *GetMethodQualifierSet)(IWbemObjectAccess *This,LPCWSTR wszMethod,IWbemQualifierSet **ppQualSet);
      HRESULT (WINAPI *GetMethodOrigin)(IWbemObjectAccess *This,LPCWSTR wszMethodName,BSTR *pstrClassName);
      HRESULT (WINAPI *GetPropertyHandle)(IWbemObjectAccess *This,LPCWSTR wszPropertyName,CIMTYPE *pType,__LONG32 *plHandle);
      HRESULT (WINAPI *WritePropertyValue)(IWbemObjectAccess *This,__LONG32 lHandle,__LONG32 lNumBytes,const byte *aData);
      HRESULT (WINAPI *ReadPropertyValue)(IWbemObjectAccess *This,__LONG32 lHandle,__LONG32 lBufferSize,__LONG32 *plNumBytes,byte *aData);
      HRESULT (WINAPI *ReadDWORD)(IWbemObjectAccess *This,__LONG32 lHandle,DWORD *pdw);
      HRESULT (WINAPI *WriteDWORD)(IWbemObjectAccess *This,__LONG32 lHandle,DWORD dw);
      __MINGW_EXTENSION HRESULT (WINAPI *ReadQWORD)(IWbemObjectAccess *This,__LONG32 lHandle,unsigned __int64 *pqw);
      __MINGW_EXTENSION HRESULT (WINAPI *WriteQWORD)(IWbemObjectAccess *This,__LONG32 lHandle,unsigned __int64 pw);
      HRESULT (WINAPI *GetPropertyInfoByHandle)(IWbemObjectAccess *This,__LONG32 lHandle,BSTR *pstrName,CIMTYPE *pType);
      HRESULT (WINAPI *Lock)(IWbemObjectAccess *This,__LONG32 lFlags);
      HRESULT (WINAPI *Unlock)(IWbemObjectAccess *This,__LONG32 lFlags);
    END_INTERFACE
  } IWbemObjectAccessVtbl;
  struct IWbemObjectAccess {
    CONST_VTBL struct IWbemObjectAccessVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemObjectAccess_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemObjectAccess_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemObjectAccess_Release(This) (This)->lpVtbl->Release(This)
#define IWbemObjectAccess_GetQualifierSet(This,ppQualSet) (This)->lpVtbl->GetQualifierSet(This,ppQualSet)
#define IWbemObjectAccess_Get(This,wszName,lFlags,pVal,pType,plFlavor) (This)->lpVtbl->Get(This,wszName,lFlags,pVal,pType,plFlavor)
#define IWbemObjectAccess_Put(This,wszName,lFlags,pVal,Type) (This)->lpVtbl->Put(This,wszName,lFlags,pVal,Type)
#define IWbemObjectAccess_Delete(This,wszName) (This)->lpVtbl->Delete(This,wszName)
#define IWbemObjectAccess_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames) (This)->lpVtbl->GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)
#define IWbemObjectAccess_BeginEnumeration(This,lEnumFlags) (This)->lpVtbl->BeginEnumeration(This,lEnumFlags)
#define IWbemObjectAccess_Next(This,lFlags,strName,pVal,pType,plFlavor) (This)->lpVtbl->Next(This,lFlags,strName,pVal,pType,plFlavor)
#define IWbemObjectAccess_EndEnumeration(This) (This)->lpVtbl->EndEnumeration(This)
#define IWbemObjectAccess_GetPropertyQualifierSet(This,wszProperty,ppQualSet) (This)->lpVtbl->GetPropertyQualifierSet(This,wszProperty,ppQualSet)
#define IWbemObjectAccess_Clone(This,ppCopy) (This)->lpVtbl->Clone(This,ppCopy)
#define IWbemObjectAccess_GetObjectText(This,lFlags,pstrObjectText) (This)->lpVtbl->GetObjectText(This,lFlags,pstrObjectText)
#define IWbemObjectAccess_SpawnDerivedClass(This,lFlags,ppNewClass) (This)->lpVtbl->SpawnDerivedClass(This,lFlags,ppNewClass)
#define IWbemObjectAccess_SpawnInstance(This,lFlags,ppNewInstance) (This)->lpVtbl->SpawnInstance(This,lFlags,ppNewInstance)
#define IWbemObjectAccess_CompareTo(This,lFlags,pCompareTo) (This)->lpVtbl->CompareTo(This,lFlags,pCompareTo)
#define IWbemObjectAccess_GetPropertyOrigin(This,wszName,pstrClassName) (This)->lpVtbl->GetPropertyOrigin(This,wszName,pstrClassName)
#define IWbemObjectAccess_InheritsFrom(This,strAncestor) (This)->lpVtbl->InheritsFrom(This,strAncestor)
#define IWbemObjectAccess_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature) (This)->lpVtbl->GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)
#define IWbemObjectAccess_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature) (This)->lpVtbl->PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)
#define IWbemObjectAccess_DeleteMethod(This,wszName) (This)->lpVtbl->DeleteMethod(This,wszName)
#define IWbemObjectAccess_BeginMethodEnumeration(This,lEnumFlags) (This)->lpVtbl->BeginMethodEnumeration(This,lEnumFlags)
#define IWbemObjectAccess_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature) (This)->lpVtbl->NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)
#define IWbemObjectAccess_EndMethodEnumeration(This) (This)->lpVtbl->EndMethodEnumeration(This)
#define IWbemObjectAccess_GetMethodQualifierSet(This,wszMethod,ppQualSet) (This)->lpVtbl->GetMethodQualifierSet(This,wszMethod,ppQualSet)
#define IWbemObjectAccess_GetMethodOrigin(This,wszMethodName,pstrClassName) (This)->lpVtbl->GetMethodOrigin(This,wszMethodName,pstrClassName)
#define IWbemObjectAccess_GetPropertyHandle(This,wszPropertyName,pType,plHandle) (This)->lpVtbl->GetPropertyHandle(This,wszPropertyName,pType,plHandle)
#define IWbemObjectAccess_WritePropertyValue(This,lHandle,lNumBytes,aData) (This)->lpVtbl->WritePropertyValue(This,lHandle,lNumBytes,aData)
#define IWbemObjectAccess_ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData) (This)->lpVtbl->ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)
#define IWbemObjectAccess_ReadDWORD(This,lHandle,pdw) (This)->lpVtbl->ReadDWORD(This,lHandle,pdw)
#define IWbemObjectAccess_WriteDWORD(This,lHandle,dw) (This)->lpVtbl->WriteDWORD(This,lHandle,dw)
#define IWbemObjectAccess_ReadQWORD(This,lHandle,pqw) (This)->lpVtbl->ReadQWORD(This,lHandle,pqw)
#define IWbemObjectAccess_WriteQWORD(This,lHandle,pw) (This)->lpVtbl->WriteQWORD(This,lHandle,pw)
#define IWbemObjectAccess_GetPropertyInfoByHandle(This,lHandle,pstrName,pType) (This)->lpVtbl->GetPropertyInfoByHandle(This,lHandle,pstrName,pType)
#define IWbemObjectAccess_Lock(This,lFlags) (This)->lpVtbl->Lock(This,lFlags)
#define IWbemObjectAccess_Unlock(This,lFlags) (This)->lpVtbl->Unlock(This,lFlags)
#endif
#endif
  HRESULT WINAPI IWbemObjectAccess_GetPropertyHandle_Proxy(IWbemObjectAccess *This,LPCWSTR wszPropertyName,CIMTYPE *pType,__LONG32 *plHandle);
  void __RPC_STUB IWbemObjectAccess_GetPropertyHandle_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemObjectAccess_WritePropertyValue_Proxy(IWbemObjectAccess *This,__LONG32 lHandle,__LONG32 lNumBytes,const byte *aData);
  void __RPC_STUB IWbemObjectAccess_WritePropertyValue_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemObjectAccess_ReadPropertyValue_Proxy(IWbemObjectAccess *This,__LONG32 lHandle,__LONG32 lBufferSize,__LONG32 *plNumBytes,byte *aData);
  void __RPC_STUB IWbemObjectAccess_ReadPropertyValue_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemObjectAccess_ReadDWORD_Proxy(IWbemObjectAccess *This,__LONG32 lHandle,DWORD *pdw);
  void __RPC_STUB IWbemObjectAccess_ReadDWORD_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemObjectAccess_WriteDWORD_Proxy(IWbemObjectAccess *This,__LONG32 lHandle,DWORD dw);
  void __RPC_STUB IWbemObjectAccess_WriteDWORD_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  __MINGW_EXTENSION HRESULT WINAPI IWbemObjectAccess_ReadQWORD_Proxy(IWbemObjectAccess *This,__LONG32 lHandle,unsigned __int64 *pqw);
  void __RPC_STUB IWbemObjectAccess_ReadQWORD_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  __MINGW_EXTENSION HRESULT WINAPI IWbemObjectAccess_WriteQWORD_Proxy(IWbemObjectAccess *This,__LONG32 lHandle,unsigned __int64 pw);
  void __RPC_STUB IWbemObjectAccess_WriteQWORD_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemObjectAccess_GetPropertyInfoByHandle_Proxy(IWbemObjectAccess *This,__LONG32 lHandle,BSTR *pstrName,CIMTYPE *pType);
  void __RPC_STUB IWbemObjectAccess_GetPropertyInfoByHandle_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemObjectAccess_Lock_Proxy(IWbemObjectAccess *This,__LONG32 lFlags);
  void __RPC_STUB IWbemObjectAccess_Lock_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemObjectAccess_Unlock_Proxy(IWbemObjectAccess *This,__LONG32 lFlags);
  void __RPC_STUB IWbemObjectAccess_Unlock_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IWbemQualifierSet_INTERFACE_DEFINED__
#define __IWbemQualifierSet_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemQualifierSet;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemQualifierSet : public IUnknown {
  public:
    virtual HRESULT WINAPI Get(LPCWSTR wszName,__LONG32 lFlags,VARIANT *pVal,__LONG32 *plFlavor) = 0;
    virtual HRESULT WINAPI Put(LPCWSTR wszName,VARIANT *pVal,__LONG32 lFlavor) = 0;
    virtual HRESULT WINAPI Delete(LPCWSTR wszName) = 0;
    virtual HRESULT WINAPI GetNames(__LONG32 lFlags,SAFEARRAY **pNames) = 0;
    virtual HRESULT WINAPI BeginEnumeration(__LONG32 lFlags) = 0;
    virtual HRESULT WINAPI Next(__LONG32 lFlags,BSTR *pstrName,VARIANT *pVal,__LONG32 *plFlavor) = 0;
    virtual HRESULT WINAPI EndEnumeration(void) = 0;
  };
#else
  typedef struct IWbemQualifierSetVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemQualifierSet *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemQualifierSet *This);
      ULONG (WINAPI *Release)(IWbemQualifierSet *This);
      HRESULT (WINAPI *Get)(IWbemQualifierSet *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pVal,__LONG32 *plFlavor);
      HRESULT (WINAPI *Put)(IWbemQualifierSet *This,LPCWSTR wszName,VARIANT *pVal,__LONG32 lFlavor);
      HRESULT (WINAPI *Delete)(IWbemQualifierSet *This,LPCWSTR wszName);
      HRESULT (WINAPI *GetNames)(IWbemQualifierSet *This,__LONG32 lFlags,SAFEARRAY **pNames);
      HRESULT (WINAPI *BeginEnumeration)(IWbemQualifierSet *This,__LONG32 lFlags);
      HRESULT (WINAPI *Next)(IWbemQualifierSet *This,__LONG32 lFlags,BSTR *pstrName,VARIANT *pVal,__LONG32 *plFlavor);
      HRESULT (WINAPI *EndEnumeration)(IWbemQualifierSet *This);
    END_INTERFACE
  } IWbemQualifierSetVtbl;
  struct IWbemQualifierSet {
    CONST_VTBL struct IWbemQualifierSetVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemQualifierSet_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemQualifierSet_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemQualifierSet_Release(This) (This)->lpVtbl->Release(This)
#define IWbemQualifierSet_Get(This,wszName,lFlags,pVal,plFlavor) (This)->lpVtbl->Get(This,wszName,lFlags,pVal,plFlavor)
#define IWbemQualifierSet_Put(This,wszName,pVal,lFlavor) (This)->lpVtbl->Put(This,wszName,pVal,lFlavor)
#define IWbemQualifierSet_Delete(This,wszName) (This)->lpVtbl->Delete(This,wszName)
#define IWbemQualifierSet_GetNames(This,lFlags,pNames) (This)->lpVtbl->GetNames(This,lFlags,pNames)
#define IWbemQualifierSet_BeginEnumeration(This,lFlags) (This)->lpVtbl->BeginEnumeration(This,lFlags)
#define IWbemQualifierSet_Next(This,lFlags,pstrName,pVal,plFlavor) (This)->lpVtbl->Next(This,lFlags,pstrName,pVal,plFlavor)
#define IWbemQualifierSet_EndEnumeration(This) (This)->lpVtbl->EndEnumeration(This)
#endif
#endif
  HRESULT WINAPI IWbemQualifierSet_Get_Proxy(IWbemQualifierSet *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pVal,__LONG32 *plFlavor);
  void __RPC_STUB IWbemQualifierSet_Get_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQualifierSet_Put_Proxy(IWbemQualifierSet *This,LPCWSTR wszName,VARIANT *pVal,__LONG32 lFlavor);
  void __RPC_STUB IWbemQualifierSet_Put_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQualifierSet_Delete_Proxy(IWbemQualifierSet *This,LPCWSTR wszName);
  void __RPC_STUB IWbemQualifierSet_Delete_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQualifierSet_GetNames_Proxy(IWbemQualifierSet *This,__LONG32 lFlags,SAFEARRAY **pNames);
  void __RPC_STUB IWbemQualifierSet_GetNames_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQualifierSet_BeginEnumeration_Proxy(IWbemQualifierSet *This,__LONG32 lFlags);
  void __RPC_STUB IWbemQualifierSet_BeginEnumeration_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQualifierSet_Next_Proxy(IWbemQualifierSet *This,__LONG32 lFlags,BSTR *pstrName,VARIANT *pVal,__LONG32 *plFlavor);
  void __RPC_STUB IWbemQualifierSet_Next_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQualifierSet_EndEnumeration_Proxy(IWbemQualifierSet *This);
  void __RPC_STUB IWbemQualifierSet_EndEnumeration_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IWbemServices_INTERFACE_DEFINED__
#define __IWbemServices_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemServices;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemServices : public IUnknown {
  public:
    virtual HRESULT WINAPI OpenNamespace(const BSTR strNamespace,__LONG32 lFlags,IWbemContext *pCtx,IWbemServices **ppWorkingNamespace,IWbemCallResult **ppResult) = 0;
    virtual HRESULT WINAPI CancelAsyncCall(IWbemObjectSink *pSink) = 0;
    virtual HRESULT WINAPI QueryObjectSink(__LONG32 lFlags,IWbemObjectSink **ppResponseHandler) = 0;
    virtual HRESULT WINAPI GetObject(const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject **ppObject,IWbemCallResult **ppCallResult) = 0;
    virtual HRESULT WINAPI GetObjectAsync(const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) = 0;
    virtual HRESULT WINAPI PutClass(IWbemClassObject *pObject,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult) = 0;
    virtual HRESULT WINAPI PutClassAsync(IWbemClassObject *pObject,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) = 0;
    virtual HRESULT WINAPI DeleteClass(const BSTR strClass,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult) = 0;
    virtual HRESULT WINAPI DeleteClassAsync(const BSTR strClass,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) = 0;
    virtual HRESULT WINAPI CreateClassEnum(const BSTR strSuperclass,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) = 0;
    virtual HRESULT WINAPI CreateClassEnumAsync(const BSTR strSuperclass,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) = 0;
    virtual HRESULT WINAPI PutInstance(IWbemClassObject *pInst,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult) = 0;
    virtual HRESULT WINAPI PutInstanceAsync(IWbemClassObject *pInst,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) = 0;
    virtual HRESULT WINAPI DeleteInstance(const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult) = 0;
    virtual HRESULT WINAPI DeleteInstanceAsync(const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) = 0;
    virtual HRESULT WINAPI CreateInstanceEnum(const BSTR strFilter,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) = 0;
    virtual HRESULT WINAPI CreateInstanceEnumAsync(const BSTR strFilter,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) = 0;
    virtual HRESULT WINAPI ExecQuery(const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) = 0;
    virtual HRESULT WINAPI ExecQueryAsync(const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) = 0;
    virtual HRESULT WINAPI ExecNotificationQuery(const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) = 0;
    virtual HRESULT WINAPI ExecNotificationQueryAsync(const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) = 0;
    virtual HRESULT WINAPI ExecMethod(const BSTR strObjectPath,const BSTR strMethodName,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject *pInParams,IWbemClassObject **ppOutParams,IWbemCallResult **ppCallResult) = 0;
    virtual HRESULT WINAPI ExecMethodAsync(const BSTR strObjectPath,const BSTR strMethodName,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject *pInParams,IWbemObjectSink *pResponseHandler) = 0;
  };
#else
  typedef struct IWbemServicesVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemServices *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemServices *This);
      ULONG (WINAPI *Release)(IWbemServices *This);
      HRESULT (WINAPI *OpenNamespace)(IWbemServices *This,const BSTR strNamespace,__LONG32 lFlags,IWbemContext *pCtx,IWbemServices **ppWorkingNamespace,IWbemCallResult **ppResult);
      HRESULT (WINAPI *CancelAsyncCall)(IWbemServices *This,IWbemObjectSink *pSink);
      HRESULT (WINAPI *QueryObjectSink)(IWbemServices *This,__LONG32 lFlags,IWbemObjectSink **ppResponseHandler);
      HRESULT (WINAPI *GetObject)(IWbemServices *This,const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject **ppObject,IWbemCallResult **ppCallResult);
      HRESULT (WINAPI *GetObjectAsync)(IWbemServices *This,const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
      HRESULT (WINAPI *PutClass)(IWbemServices *This,IWbemClassObject *pObject,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult);
      HRESULT (WINAPI *PutClassAsync)(IWbemServices *This,IWbemClassObject *pObject,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
      HRESULT (WINAPI *DeleteClass)(IWbemServices *This,const BSTR strClass,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult);
      HRESULT (WINAPI *DeleteClassAsync)(IWbemServices *This,const BSTR strClass,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
      HRESULT (WINAPI *CreateClassEnum)(IWbemServices *This,const BSTR strSuperclass,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum);
      HRESULT (WINAPI *CreateClassEnumAsync)(IWbemServices *This,const BSTR strSuperclass,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
      HRESULT (WINAPI *PutInstance)(IWbemServices *This,IWbemClassObject *pInst,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult);
      HRESULT (WINAPI *PutInstanceAsync)(IWbemServices *This,IWbemClassObject *pInst,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
      HRESULT (WINAPI *DeleteInstance)(IWbemServices *This,const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult);
      HRESULT (WINAPI *DeleteInstanceAsync)(IWbemServices *This,const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
      HRESULT (WINAPI *CreateInstanceEnum)(IWbemServices *This,const BSTR strFilter,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum);
      HRESULT (WINAPI *CreateInstanceEnumAsync)(IWbemServices *This,const BSTR strFilter,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
      HRESULT (WINAPI *ExecQuery)(IWbemServices *This,const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum);
      HRESULT (WINAPI *ExecQueryAsync)(IWbemServices *This,const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
      HRESULT (WINAPI *ExecNotificationQuery)(IWbemServices *This,const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum);
      HRESULT (WINAPI *ExecNotificationQueryAsync)(IWbemServices *This,const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
      HRESULT (WINAPI *ExecMethod)(IWbemServices *This,const BSTR strObjectPath,const BSTR strMethodName,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject *pInParams,IWbemClassObject **ppOutParams,IWbemCallResult **ppCallResult);
      HRESULT (WINAPI *ExecMethodAsync)(IWbemServices *This,const BSTR strObjectPath,const BSTR strMethodName,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject *pInParams,IWbemObjectSink *pResponseHandler);
    END_INTERFACE
  } IWbemServicesVtbl;
  struct IWbemServices {
    CONST_VTBL struct IWbemServicesVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemServices_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemServices_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemServices_Release(This) (This)->lpVtbl->Release(This)
#define IWbemServices_OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult) (This)->lpVtbl->OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)
#define IWbemServices_CancelAsyncCall(This,pSink) (This)->lpVtbl->CancelAsyncCall(This,pSink)
#define IWbemServices_QueryObjectSink(This,lFlags,ppResponseHandler) (This)->lpVtbl->QueryObjectSink(This,lFlags,ppResponseHandler)
#define IWbemServices_GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult) (This)->lpVtbl->GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)
#define IWbemServices_GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler) (This)->lpVtbl->GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)
#define IWbemServices_PutClass(This,pObject,lFlags,pCtx,ppCallResult) (This)->lpVtbl->PutClass(This,pObject,lFlags,pCtx,ppCallResult)
#define IWbemServices_PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler) (This)->lpVtbl->PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)
#define IWbemServices_DeleteClass(This,strClass,lFlags,pCtx,ppCallResult) (This)->lpVtbl->DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)
#define IWbemServices_DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler) (This)->lpVtbl->DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)
#define IWbemServices_CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum) (This)->lpVtbl->CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)
#define IWbemServices_CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler) (This)->lpVtbl->CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)
#define IWbemServices_PutInstance(This,pInst,lFlags,pCtx,ppCallResult) (This)->lpVtbl->PutInstance(This,pInst,lFlags,pCtx,ppCallResult)
#define IWbemServices_PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler) (This)->lpVtbl->PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)
#define IWbemServices_DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult) (This)->lpVtbl->DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)
#define IWbemServices_DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler) (This)->lpVtbl->DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)
#define IWbemServices_CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum) (This)->lpVtbl->CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)
#define IWbemServices_CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler) (This)->lpVtbl->CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)
#define IWbemServices_ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum) (This)->lpVtbl->ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)
#define IWbemServices_ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler) (This)->lpVtbl->ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)
#define IWbemServices_ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum) (This)->lpVtbl->ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)
#define IWbemServices_ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler) (This)->lpVtbl->ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)
#define IWbemServices_ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult) (This)->lpVtbl->ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)
#define IWbemServices_ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler) (This)->lpVtbl->ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)
#endif
#endif
  HRESULT WINAPI IWbemServices_OpenNamespace_Proxy(IWbemServices *This,const BSTR strNamespace,__LONG32 lFlags,IWbemContext *pCtx,IWbemServices **ppWorkingNamespace,IWbemCallResult **ppResult);
  void __RPC_STUB IWbemServices_OpenNamespace_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_CancelAsyncCall_Proxy(IWbemServices *This,IWbemObjectSink *pSink);
  void __RPC_STUB IWbemServices_CancelAsyncCall_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_QueryObjectSink_Proxy(IWbemServices *This,__LONG32 lFlags,IWbemObjectSink **ppResponseHandler);
  void __RPC_STUB IWbemServices_QueryObjectSink_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_GetObject_Proxy(IWbemServices *This,const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject **ppObject,IWbemCallResult **ppCallResult);
  void __RPC_STUB IWbemServices_GetObject_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_GetObjectAsync_Proxy(IWbemServices *This,const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
  void __RPC_STUB IWbemServices_GetObjectAsync_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_PutClass_Proxy(IWbemServices *This,IWbemClassObject *pObject,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult);
  void __RPC_STUB IWbemServices_PutClass_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_PutClassAsync_Proxy(IWbemServices *This,IWbemClassObject *pObject,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
  void __RPC_STUB IWbemServices_PutClassAsync_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_DeleteClass_Proxy(IWbemServices *This,const BSTR strClass,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult);
  void __RPC_STUB IWbemServices_DeleteClass_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_DeleteClassAsync_Proxy(IWbemServices *This,const BSTR strClass,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
  void __RPC_STUB IWbemServices_DeleteClassAsync_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_CreateClassEnum_Proxy(IWbemServices *This,const BSTR strSuperclass,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum);
  void __RPC_STUB IWbemServices_CreateClassEnum_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_CreateClassEnumAsync_Proxy(IWbemServices *This,const BSTR strSuperclass,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
  void __RPC_STUB IWbemServices_CreateClassEnumAsync_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_PutInstance_Proxy(IWbemServices *This,IWbemClassObject *pInst,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult);
  void __RPC_STUB IWbemServices_PutInstance_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_PutInstanceAsync_Proxy(IWbemServices *This,IWbemClassObject *pInst,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
  void __RPC_STUB IWbemServices_PutInstanceAsync_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_DeleteInstance_Proxy(IWbemServices *This,const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult);
  void __RPC_STUB IWbemServices_DeleteInstance_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_DeleteInstanceAsync_Proxy(IWbemServices *This,const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
  void __RPC_STUB IWbemServices_DeleteInstanceAsync_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_CreateInstanceEnum_Proxy(IWbemServices *This,const BSTR strFilter,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum);
  void __RPC_STUB IWbemServices_CreateInstanceEnum_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_CreateInstanceEnumAsync_Proxy(IWbemServices *This,const BSTR strFilter,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
  void __RPC_STUB IWbemServices_CreateInstanceEnumAsync_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_ExecQuery_Proxy(IWbemServices *This,const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum);
  void __RPC_STUB IWbemServices_ExecQuery_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_ExecQueryAsync_Proxy(IWbemServices *This,const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
  void __RPC_STUB IWbemServices_ExecQueryAsync_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_ExecNotificationQuery_Proxy(IWbemServices *This,const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum);
  void __RPC_STUB IWbemServices_ExecNotificationQuery_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_ExecNotificationQueryAsync_Proxy(IWbemServices *This,const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler);
  void __RPC_STUB IWbemServices_ExecNotificationQueryAsync_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_ExecMethod_Proxy(IWbemServices *This,const BSTR strObjectPath,const BSTR strMethodName,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject *pInParams,IWbemClassObject **ppOutParams,IWbemCallResult **ppCallResult);
  void __RPC_STUB IWbemServices_ExecMethod_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemServices_ExecMethodAsync_Proxy(IWbemServices *This,const BSTR strObjectPath,const BSTR strMethodName,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject *pInParams,IWbemObjectSink *pResponseHandler);
  void __RPC_STUB IWbemServices_ExecMethodAsync_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IWbemLocator_INTERFACE_DEFINED__
#define __IWbemLocator_INTERFACE_DEFINED__
DEFINE_GUID(IID_IWbemLocator, 0xdc12a687, 0x737f, 0x11cf, 0x88,0x4d, 0x00,0xaa,0x00,0x4b,0x2e,0x24);
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemLocator : public IUnknown {
  public:
    virtual HRESULT WINAPI ConnectServer(const BSTR strNetworkResource,const BSTR strUser,const BSTR strPassword,const BSTR strLocale,__LONG32 lSecurityFlags,const BSTR strAuthority,IWbemContext *pCtx,IWbemServices **ppNamespace) = 0;
  };
#else
  typedef struct IWbemLocatorVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemLocator *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemLocator *This);
      ULONG (WINAPI *Release)(IWbemLocator *This);
      HRESULT (WINAPI *ConnectServer)(IWbemLocator *This,const BSTR strNetworkResource,const BSTR strUser,const BSTR strPassword,const BSTR strLocale,__LONG32 lSecurityFlags,const BSTR strAuthority,IWbemContext *pCtx,IWbemServices **ppNamespace);
    END_INTERFACE
  } IWbemLocatorVtbl;
  struct IWbemLocator {
    CONST_VTBL struct IWbemLocatorVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemLocator_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemLocator_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemLocator_Release(This) (This)->lpVtbl->Release(This)
#define IWbemLocator_ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace) (This)->lpVtbl->ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)
#endif
#endif
  HRESULT WINAPI IWbemLocator_ConnectServer_Proxy(IWbemLocator *This,const BSTR strNetworkResource,const BSTR strUser,const BSTR strPassword,const BSTR strLocale,__LONG32 lSecurityFlags,const BSTR strAuthority,IWbemContext *pCtx,IWbemServices **ppNamespace);
  void __RPC_STUB IWbemLocator_ConnectServer_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IWbemObjectSink_INTERFACE_DEFINED__
#define __IWbemObjectSink_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemObjectSink;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemObjectSink : public IUnknown {
  public:
    virtual HRESULT WINAPI Indicate(__LONG32 lObjectCount,IWbemClassObject **apObjArray) = 0;
    virtual HRESULT WINAPI SetStatus(__LONG32 lFlags,HRESULT hResult,BSTR strParam,IWbemClassObject *pObjParam) = 0;
  };
#else
  typedef struct IWbemObjectSinkVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemObjectSink *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemObjectSink *This);
      ULONG (WINAPI *Release)(IWbemObjectSink *This);
      HRESULT (WINAPI *Indicate)(IWbemObjectSink *This,__LONG32 lObjectCount,IWbemClassObject **apObjArray);
      HRESULT (WINAPI *SetStatus)(IWbemObjectSink *This,__LONG32 lFlags,HRESULT hResult,BSTR strParam,IWbemClassObject *pObjParam);
    END_INTERFACE
  } IWbemObjectSinkVtbl;
  struct IWbemObjectSink {
    CONST_VTBL struct IWbemObjectSinkVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemObjectSink_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemObjectSink_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemObjectSink_Release(This) (This)->lpVtbl->Release(This)
#define IWbemObjectSink_Indicate(This,lObjectCount,apObjArray) (This)->lpVtbl->Indicate(This,lObjectCount,apObjArray)
#define IWbemObjectSink_SetStatus(This,lFlags,hResult,strParam,pObjParam) (This)->lpVtbl->SetStatus(This,lFlags,hResult,strParam,pObjParam)
#endif
#endif
  HRESULT WINAPI IWbemObjectSink_Indicate_Proxy(IWbemObjectSink *This,__LONG32 lObjectCount,IWbemClassObject **apObjArray);
  void __RPC_STUB IWbemObjectSink_Indicate_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemObjectSink_SetStatus_Proxy(IWbemObjectSink *This,__LONG32 lFlags,HRESULT hResult,BSTR strParam,IWbemClassObject *pObjParam);
  void __RPC_STUB IWbemObjectSink_SetStatus_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IEnumWbemClassObject_INTERFACE_DEFINED__
#define __IEnumWbemClassObject_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IEnumWbemClassObject;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IEnumWbemClassObject : public IUnknown {
  public:
    virtual HRESULT WINAPI Reset(void) = 0;
    virtual HRESULT WINAPI Next(__LONG32 lTimeout,ULONG uCount,IWbemClassObject **apObjects,ULONG *puReturned) = 0;
    virtual HRESULT WINAPI NextAsync(ULONG uCount,IWbemObjectSink *pSink) = 0;
    virtual HRESULT WINAPI Clone(IEnumWbemClassObject **ppEnum) = 0;
    virtual HRESULT WINAPI Skip(__LONG32 lTimeout,ULONG nCount) = 0;
  };
#else
  typedef struct IEnumWbemClassObjectVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IEnumWbemClassObject *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IEnumWbemClassObject *This);
      ULONG (WINAPI *Release)(IEnumWbemClassObject *This);
      HRESULT (WINAPI *Reset)(IEnumWbemClassObject *This);
      HRESULT (WINAPI *Next)(IEnumWbemClassObject *This,__LONG32 lTimeout,ULONG uCount,IWbemClassObject **apObjects,ULONG *puReturned);
      HRESULT (WINAPI *NextAsync)(IEnumWbemClassObject *This,ULONG uCount,IWbemObjectSink *pSink);
      HRESULT (WINAPI *Clone)(IEnumWbemClassObject *This,IEnumWbemClassObject **ppEnum);
      HRESULT (WINAPI *Skip)(IEnumWbemClassObject *This,__LONG32 lTimeout,ULONG nCount);
    END_INTERFACE
  } IEnumWbemClassObjectVtbl;
  struct IEnumWbemClassObject {
    CONST_VTBL struct IEnumWbemClassObjectVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IEnumWbemClassObject_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IEnumWbemClassObject_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IEnumWbemClassObject_Release(This) (This)->lpVtbl->Release(This)
#define IEnumWbemClassObject_Reset(This) (This)->lpVtbl->Reset(This)
#define IEnumWbemClassObject_Next(This,lTimeout,uCount,apObjects,puReturned) (This)->lpVtbl->Next(This,lTimeout,uCount,apObjects,puReturned)
#define IEnumWbemClassObject_NextAsync(This,uCount,pSink) (This)->lpVtbl->NextAsync(This,uCount,pSink)
#define IEnumWbemClassObject_Clone(This,ppEnum) (This)->lpVtbl->Clone(This,ppEnum)
#define IEnumWbemClassObject_Skip(This,lTimeout,nCount) (This)->lpVtbl->Skip(This,lTimeout,nCount)
#endif
#endif
  HRESULT WINAPI IEnumWbemClassObject_Reset_Proxy(IEnumWbemClassObject *This);
  void __RPC_STUB IEnumWbemClassObject_Reset_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnumWbemClassObject_Next_Proxy(IEnumWbemClassObject *This,__LONG32 lTimeout,ULONG uCount,IWbemClassObject **apObjects,ULONG *puReturned);
  void __RPC_STUB IEnumWbemClassObject_Next_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnumWbemClassObject_NextAsync_Proxy(IEnumWbemClassObject *This,ULONG uCount,IWbemObjectSink *pSink);
  void __RPC_STUB IEnumWbemClassObject_NextAsync_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnumWbemClassObject_Clone_Proxy(IEnumWbemClassObject *This,IEnumWbemClassObject **ppEnum);
  void __RPC_STUB IEnumWbemClassObject_Clone_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnumWbemClassObject_Skip_Proxy(IEnumWbemClassObject *This,__LONG32 lTimeout,ULONG nCount);
  void __RPC_STUB IEnumWbemClassObject_Skip_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IWbemCallResult_INTERFACE_DEFINED__
#define __IWbemCallResult_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemCallResult;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemCallResult : public IUnknown {
  public:
    virtual HRESULT WINAPI GetResultObject(__LONG32 lTimeout,IWbemClassObject **ppResultObject) = 0;
    virtual HRESULT WINAPI GetResultString(__LONG32 lTimeout,BSTR *pstrResultString) = 0;
    virtual HRESULT WINAPI GetResultServices(__LONG32 lTimeout,IWbemServices **ppServices) = 0;
    virtual HRESULT WINAPI GetCallStatus(__LONG32 lTimeout,__LONG32 *plStatus) = 0;
  };
#else
  typedef struct IWbemCallResultVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemCallResult *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemCallResult *This);
      ULONG (WINAPI *Release)(IWbemCallResult *This);
      HRESULT (WINAPI *GetResultObject)(IWbemCallResult *This,__LONG32 lTimeout,IWbemClassObject **ppResultObject);
      HRESULT (WINAPI *GetResultString)(IWbemCallResult *This,__LONG32 lTimeout,BSTR *pstrResultString);
      HRESULT (WINAPI *GetResultServices)(IWbemCallResult *This,__LONG32 lTimeout,IWbemServices **ppServices);
      HRESULT (WINAPI *GetCallStatus)(IWbemCallResult *This,__LONG32 lTimeout,__LONG32 *plStatus);
    END_INTERFACE
  } IWbemCallResultVtbl;
  struct IWbemCallResult {
    CONST_VTBL struct IWbemCallResultVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemCallResult_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemCallResult_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemCallResult_Release(This) (This)->lpVtbl->Release(This)
#define IWbemCallResult_GetResultObject(This,lTimeout,ppResultObject) (This)->lpVtbl->GetResultObject(This,lTimeout,ppResultObject)
#define IWbemCallResult_GetResultString(This,lTimeout,pstrResultString) (This)->lpVtbl->GetResultString(This,lTimeout,pstrResultString)
#define IWbemCallResult_GetResultServices(This,lTimeout,ppServices) (This)->lpVtbl->GetResultServices(This,lTimeout,ppServices)
#define IWbemCallResult_GetCallStatus(This,lTimeout,plStatus) (This)->lpVtbl->GetCallStatus(This,lTimeout,plStatus)
#endif
#endif
  HRESULT WINAPI IWbemCallResult_GetResultObject_Proxy(IWbemCallResult *This,__LONG32 lTimeout,IWbemClassObject **ppResultObject);
  void __RPC_STUB IWbemCallResult_GetResultObject_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemCallResult_GetResultString_Proxy(IWbemCallResult *This,__LONG32 lTimeout,BSTR *pstrResultString);
  void __RPC_STUB IWbemCallResult_GetResultString_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemCallResult_GetResultServices_Proxy(IWbemCallResult *This,__LONG32 lTimeout,IWbemServices **ppServices);
  void __RPC_STUB IWbemCallResult_GetResultServices_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemCallResult_GetCallStatus_Proxy(IWbemCallResult *This,__LONG32 lTimeout,__LONG32 *plStatus);
  void __RPC_STUB IWbemCallResult_GetCallStatus_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IWbemContext_INTERFACE_DEFINED__
#define __IWbemContext_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemContext;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemContext : public IUnknown {
  public:
    virtual HRESULT WINAPI Clone(IWbemContext **ppNewCopy) = 0;
    virtual HRESULT WINAPI GetNames(__LONG32 lFlags,SAFEARRAY **pNames) = 0;
    virtual HRESULT WINAPI BeginEnumeration(__LONG32 lFlags) = 0;
    virtual HRESULT WINAPI Next(__LONG32 lFlags,BSTR *pstrName,VARIANT *pValue) = 0;
    virtual HRESULT WINAPI EndEnumeration(void) = 0;
    virtual HRESULT WINAPI SetValue(LPCWSTR wszName,__LONG32 lFlags,VARIANT *pValue) = 0;
    virtual HRESULT WINAPI GetValue(LPCWSTR wszName,__LONG32 lFlags,VARIANT *pValue) = 0;
    virtual HRESULT WINAPI DeleteValue(LPCWSTR wszName,__LONG32 lFlags) = 0;
    virtual HRESULT WINAPI DeleteAll(void) = 0;
  };
#else
  typedef struct IWbemContextVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemContext *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemContext *This);
      ULONG (WINAPI *Release)(IWbemContext *This);
      HRESULT (WINAPI *Clone)(IWbemContext *This,IWbemContext **ppNewCopy);
      HRESULT (WINAPI *GetNames)(IWbemContext *This,__LONG32 lFlags,SAFEARRAY **pNames);
      HRESULT (WINAPI *BeginEnumeration)(IWbemContext *This,__LONG32 lFlags);
      HRESULT (WINAPI *Next)(IWbemContext *This,__LONG32 lFlags,BSTR *pstrName,VARIANT *pValue);
      HRESULT (WINAPI *EndEnumeration)(IWbemContext *This);
      HRESULT (WINAPI *SetValue)(IWbemContext *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pValue);
      HRESULT (WINAPI *GetValue)(IWbemContext *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pValue);
      HRESULT (WINAPI *DeleteValue)(IWbemContext *This,LPCWSTR wszName,__LONG32 lFlags);
      HRESULT (WINAPI *DeleteAll)(IWbemContext *This);
    END_INTERFACE
  } IWbemContextVtbl;
  struct IWbemContext {
    CONST_VTBL struct IWbemContextVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemContext_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemContext_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemContext_Release(This) (This)->lpVtbl->Release(This)
#define IWbemContext_Clone(This,ppNewCopy) (This)->lpVtbl->Clone(This,ppNewCopy)
#define IWbemContext_GetNames(This,lFlags,pNames) (This)->lpVtbl->GetNames(This,lFlags,pNames)
#define IWbemContext_BeginEnumeration(This,lFlags) (This)->lpVtbl->BeginEnumeration(This,lFlags)
#define IWbemContext_Next(This,lFlags,pstrName,pValue) (This)->lpVtbl->Next(This,lFlags,pstrName,pValue)
#define IWbemContext_EndEnumeration(This) (This)->lpVtbl->EndEnumeration(This)
#define IWbemContext_SetValue(This,wszName,lFlags,pValue) (This)->lpVtbl->SetValue(This,wszName,lFlags,pValue)
#define IWbemContext_GetValue(This,wszName,lFlags,pValue) (This)->lpVtbl->GetValue(This,wszName,lFlags,pValue)
#define IWbemContext_DeleteValue(This,wszName,lFlags) (This)->lpVtbl->DeleteValue(This,wszName,lFlags)
#define IWbemContext_DeleteAll(This) (This)->lpVtbl->DeleteAll(This)
#endif
#endif
  HRESULT WINAPI IWbemContext_Clone_Proxy(IWbemContext *This,IWbemContext **ppNewCopy);
  void __RPC_STUB IWbemContext_Clone_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemContext_GetNames_Proxy(IWbemContext *This,__LONG32 lFlags,SAFEARRAY **pNames);
  void __RPC_STUB IWbemContext_GetNames_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemContext_BeginEnumeration_Proxy(IWbemContext *This,__LONG32 lFlags);
  void __RPC_STUB IWbemContext_BeginEnumeration_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemContext_Next_Proxy(IWbemContext *This,__LONG32 lFlags,BSTR *pstrName,VARIANT *pValue);
  void __RPC_STUB IWbemContext_Next_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemContext_EndEnumeration_Proxy(IWbemContext *This);
  void __RPC_STUB IWbemContext_EndEnumeration_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemContext_SetValue_Proxy(IWbemContext *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pValue);
  void __RPC_STUB IWbemContext_SetValue_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemContext_GetValue_Proxy(IWbemContext *This,LPCWSTR wszName,__LONG32 lFlags,VARIANT *pValue);
  void __RPC_STUB IWbemContext_GetValue_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemContext_DeleteValue_Proxy(IWbemContext *This,LPCWSTR wszName,__LONG32 lFlags);
  void __RPC_STUB IWbemContext_DeleteValue_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemContext_DeleteAll_Proxy(IWbemContext *This);
  void __RPC_STUB IWbemContext_DeleteAll_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IUnsecuredApartment_INTERFACE_DEFINED__
#define __IUnsecuredApartment_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IUnsecuredApartment;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IUnsecuredApartment : public IUnknown {
  public:
    virtual HRESULT WINAPI CreateObjectStub(IUnknown *pObject,IUnknown **ppStub) = 0;
  };
#else
  typedef struct IUnsecuredApartmentVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IUnsecuredApartment *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IUnsecuredApartment *This);
      ULONG (WINAPI *Release)(IUnsecuredApartment *This);
      HRESULT (WINAPI *CreateObjectStub)(IUnsecuredApartment *This,IUnknown *pObject,IUnknown **ppStub);
    END_INTERFACE
  } IUnsecuredApartmentVtbl;
  struct IUnsecuredApartment {
    CONST_VTBL struct IUnsecuredApartmentVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IUnsecuredApartment_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IUnsecuredApartment_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IUnsecuredApartment_Release(This) (This)->lpVtbl->Release(This)
#define IUnsecuredApartment_CreateObjectStub(This,pObject,ppStub) (This)->lpVtbl->CreateObjectStub(This,pObject,ppStub)
#endif
#endif
  HRESULT WINAPI IUnsecuredApartment_CreateObjectStub_Proxy(IUnsecuredApartment *This,IUnknown *pObject,IUnknown **ppStub);
  void __RPC_STUB IUnsecuredApartment_CreateObjectStub_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IWbemUnsecuredApartment_INTERFACE_DEFINED__
#define __IWbemUnsecuredApartment_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemUnsecuredApartment;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemUnsecuredApartment : public IUnsecuredApartment {
  public:
    virtual HRESULT WINAPI CreateSinkStub(IWbemObjectSink *pSink,DWORD dwFlags,LPCWSTR wszReserved,IWbemObjectSink **ppStub) = 0;
  };
#else
  typedef struct IWbemUnsecuredApartmentVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemUnsecuredApartment *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemUnsecuredApartment *This);
      ULONG (WINAPI *Release)(IWbemUnsecuredApartment *This);
      HRESULT (WINAPI *CreateObjectStub)(IWbemUnsecuredApartment *This,IUnknown *pObject,IUnknown **ppStub);
      HRESULT (WINAPI *CreateSinkStub)(IWbemUnsecuredApartment *This,IWbemObjectSink *pSink,DWORD dwFlags,LPCWSTR wszReserved,IWbemObjectSink **ppStub);
    END_INTERFACE
  } IWbemUnsecuredApartmentVtbl;
  struct IWbemUnsecuredApartment {
    CONST_VTBL struct IWbemUnsecuredApartmentVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemUnsecuredApartment_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemUnsecuredApartment_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemUnsecuredApartment_Release(This) (This)->lpVtbl->Release(This)
#define IWbemUnsecuredApartment_CreateObjectStub(This,pObject,ppStub) (This)->lpVtbl->CreateObjectStub(This,pObject,ppStub)
#define IWbemUnsecuredApartment_CreateSinkStub(This,pSink,dwFlags,wszReserved,ppStub) (This)->lpVtbl->CreateSinkStub(This,pSink,dwFlags,wszReserved,ppStub)
#endif
#endif
  HRESULT WINAPI IWbemUnsecuredApartment_CreateSinkStub_Proxy(IWbemUnsecuredApartment *This,IWbemObjectSink *pSink,DWORD dwFlags,LPCWSTR wszReserved,IWbemObjectSink **ppStub);
  void __RPC_STUB IWbemUnsecuredApartment_CreateSinkStub_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IWbemStatusCodeText_INTERFACE_DEFINED__
#define __IWbemStatusCodeText_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemStatusCodeText;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemStatusCodeText : public IUnknown {
  public:
    virtual HRESULT WINAPI GetErrorCodeText(HRESULT hRes,LCID LocaleId,__LONG32 lFlags,BSTR *MessageText) = 0;
    virtual HRESULT WINAPI GetFacilityCodeText(HRESULT hRes,LCID LocaleId,__LONG32 lFlags,BSTR *MessageText) = 0;
  };
#else
  typedef struct IWbemStatusCodeTextVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemStatusCodeText *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemStatusCodeText *This);
      ULONG (WINAPI *Release)(IWbemStatusCodeText *This);
      HRESULT (WINAPI *GetErrorCodeText)(IWbemStatusCodeText *This,HRESULT hRes,LCID LocaleId,__LONG32 lFlags,BSTR *MessageText);
      HRESULT (WINAPI *GetFacilityCodeText)(IWbemStatusCodeText *This,HRESULT hRes,LCID LocaleId,__LONG32 lFlags,BSTR *MessageText);
    END_INTERFACE
  } IWbemStatusCodeTextVtbl;
  struct IWbemStatusCodeText {
    CONST_VTBL struct IWbemStatusCodeTextVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemStatusCodeText_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemStatusCodeText_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemStatusCodeText_Release(This) (This)->lpVtbl->Release(This)
#define IWbemStatusCodeText_GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText) (This)->lpVtbl->GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText)
#define IWbemStatusCodeText_GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText) (This)->lpVtbl->GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText)
#endif
#endif
  HRESULT WINAPI IWbemStatusCodeText_GetErrorCodeText_Proxy(IWbemStatusCodeText *This,HRESULT hRes,LCID LocaleId,__LONG32 lFlags,BSTR *MessageText);
  void __RPC_STUB IWbemStatusCodeText_GetErrorCodeText_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemStatusCodeText_GetFacilityCodeText_Proxy(IWbemStatusCodeText *This,HRESULT hRes,LCID LocaleId,__LONG32 lFlags,BSTR *MessageText);
  void __RPC_STUB IWbemStatusCodeText_GetFacilityCodeText_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IWbemBackupRestore_INTERFACE_DEFINED__
#define __IWbemBackupRestore_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemBackupRestore;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemBackupRestore : public IUnknown {
  public:
    virtual HRESULT WINAPI Backup(LPCWSTR strBackupToFile,__LONG32 lFlags) = 0;
    virtual HRESULT WINAPI Restore(LPCWSTR strRestoreFromFile,__LONG32 lFlags) = 0;
  };
#else
  typedef struct IWbemBackupRestoreVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemBackupRestore *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemBackupRestore *This);
      ULONG (WINAPI *Release)(IWbemBackupRestore *This);
      HRESULT (WINAPI *Backup)(IWbemBackupRestore *This,LPCWSTR strBackupToFile,__LONG32 lFlags);
      HRESULT (WINAPI *Restore)(IWbemBackupRestore *This,LPCWSTR strRestoreFromFile,__LONG32 lFlags);
    END_INTERFACE
  } IWbemBackupRestoreVtbl;
  struct IWbemBackupRestore {
    CONST_VTBL struct IWbemBackupRestoreVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemBackupRestore_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemBackupRestore_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemBackupRestore_Release(This) (This)->lpVtbl->Release(This)
#define IWbemBackupRestore_Backup(This,strBackupToFile,lFlags) (This)->lpVtbl->Backup(This,strBackupToFile,lFlags)
#define IWbemBackupRestore_Restore(This,strRestoreFromFile,lFlags) (This)->lpVtbl->Restore(This,strRestoreFromFile,lFlags)
#endif
#endif
  HRESULT WINAPI IWbemBackupRestore_Backup_Proxy(IWbemBackupRestore *This,LPCWSTR strBackupToFile,__LONG32 lFlags);
  void __RPC_STUB IWbemBackupRestore_Backup_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemBackupRestore_Restore_Pr