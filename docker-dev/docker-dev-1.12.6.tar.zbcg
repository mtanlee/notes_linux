hat depend on the
 *	value of this symbol.
 */
/* I_SGTTY:
 *	This symbol, if defined, indicates that the program should include
 *	<sgtty.h> rather than <termio.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/*#define I_TERMIO		/ **/
#define I_TERMIOS		/**/
/*#define I_SGTTY		/ **/

/* USE_CROSS_COMPILE:
 *	This symbol, if defined, indicates that Perl is being cross-compiled.
 */
/* PERL_TARGETARCH:
 *	This symbol, if defined, indicates the target architecture
 *	Perl has been cross-compiled to.  Undefined if not a cross-compile.
 */
#ifndef USE_CROSS_COMPILE
/*#define	USE_CROSS_COMPILE	/ **/
#define	PERL_TARGETARCH	""	/**/
#endif

/* PERL_USE_DEVEL:
 *	This symbol, if defined, indicates that Perl was configured with
 *	-Dusedevel, to enable development features.  This should not be
 *	done for production builds.
 */
/*#define	PERL_USE_DEVEL		/ **/

/* HAS_ATOLF:
 *	This symbol, if defined, indicates that the atolf routine is
 *	available to convert strings into long doubles.
 */
/*#define HAS_ATOLF		/ **/

/* HAS_ATOLL:
 *	This symbol, if defined, indicates that the atoll routine is
 *	available to convert strings into long longs.
 */
#define HAS_ATOLL		/**/

/* HAS__FWALK:
 *	This symbol, if defined, indicates that the _fwalk system call is
 *	available to apply a function to all the file handles.
 */
/*#define HAS__FWALK		/ **/

/* HAS_AINTL:
 *	This symbol, if defined, indicates that the aintl routine is
 *	available.  If copysignl is also present we can emulate modfl.
 */
/*#define HAS_AINTL		/ **/

/* HAS_BUILTIN_CHOOSE_EXPR:
 *	Can we handle GCC builtin for compile-time ternary-like expressions
 */
/* HAS_BUILTIN_EXPECT:
 *	Can we handle GCC builtin for telling that certain values are more
 *	likely
 */
#define HAS_BUILTIN_EXPECT	/**/
#define HAS_BUILTIN_CHOOSE_EXPR	/**/

/* HAS_C99_VARIADIC_MACROS:
 *	If defined, the compiler supports C99 variadic macros.
 */
#define	HAS_C99_VARIADIC_MACROS	/**/

/* HAS_CLASS:
 *	This symbol, if defined, indicates that the class routine is
 *	available to classify doubles.  Available for example in AIX.
 *	The returned values are defined in <float.h> and are:
 *
 *	FP_PLUS_NORM	Positive normalized, nonzero
 *	FP_MINUS_NORM	Negative normalized, nonzero
 *	FP_PLUS_DENORM	Positive denormalized, nonzero
 *	FP_MINUS_DENORM	Negative denormalized, nonzero
 *	FP_PLUS_ZERO	+0.0
 *	FP_MINUS_ZERO	-0.0
 *	FP_PLUS_INF	+INF
 *	FP_MINUS_INF	-INF
 *	FP_NANS		Signaling Not a Number (NaNS)
 *	FP_NANQ		Quiet Not a Number (NaNQ)
 */
/*#define HAS_CLASS		/ **/

/* HAS_CLEARENV:
 *	This symbol, if defined, indicates that the clearenv () routine is
 *	available for use.
 */
#define HAS_CLEARENV		/**/

/* HAS_STRUCT_CMSGHDR:
 *	This symbol, if defined, indicates that the struct cmsghdr
 *	is supported.
 */
#define HAS_STRUCT_CMSGHDR	/**/

/* HAS_COPYSIGNL:
 *	This symbol, if defined, indicates that the copysignl routine is
 *	available.  If aintl is also present we can emulate modfl.
 */
#define HAS_COPYSIGNL		/**/

/* USE_CPLUSPLUS:
 *	This symbol, if defined, indicates that a C++ compiler was
 *	used to compiled Perl and will be used to compile extensions.
 */
/*#define USE_CPLUSPLUS		/ **/

/* HAS_DBMINIT_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the dbminit() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int dbminit(char *);
 */
#define	HAS_DBMINIT_PROTO	/**/

/* HAS_DIR_DD_FD:
 *	This symbol, if defined, indicates that the the DIR* dirstream
 *	structure contains a member variable named dd_fd.
 */
/*#define HAS_DIR_DD_FD		/ **/

/* HAS_DIRFD:
 *	This manifest constant lets the C program know that dirfd
 *	is available.
 */
#define HAS_DIRFD		/**/

/* DLSYM_NEEDS_UNDERSCORE:
 *	This symbol, if defined, indicates that we need to prepend an
 *	underscore to the symbol name before calling dlsym().  This only
 *	makes sense if you *have* dlsym, which we will presume is the
 *	case if you're using dl_dlopen.xs.
 */
/*#define 	DLSYM_NEEDS_UNDERSCORE 	/ **/

/* HAS_FAST_STDIO:
 *	This symbol, if defined, indicates that the "fast stdio"
 *	is available to manipulate the stdio buffers directly.
 */
#define HAS_FAST_STDIO		/**/

/* HAS_FCHDIR:
 *	This symbol, if defined, indicates that the fchdir routine is
 *	available to change directory using a file descriptor.
 */
#define HAS_FCHDIR		/**/

/* FCNTL_CAN_LOCK:
 *	This symbol, if defined, indicates that fcntl() can be used
 *	for file locking.  Normally on Unix systems this is defined.
 *	It may be undefined on VMS.
 */
#define FCNTL_CAN_LOCK		/**/

/* HAS_FINITE:
 *	This symbol, if defined, indicates that the finite routine is
 *	available to check whether a double is finite (non-infinity non-NaN).
 */
#define HAS_FINITE		/**/

/* HAS_FINITEL:
 *	This symbol, if defined, indicates that the finitel routine is
 *	available to check whether a long double is finite
 *	(non-infinity non-NaN).
 */
#define HAS_FINITEL		/**/

/* HAS_FLOCK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the flock() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int flock(int, int);
 */
#define	HAS_FLOCK_PROTO	/**/

/* HAS_FP_CLASS:
 *	This symbol, if defined, indicates that the fp_class routine is
 *	available to classify doubles.  Available for example in Digital UNIX.
 *	The returned values are defined in <math.h> and are:
 *
 *	FP_SNAN           Signaling NaN (Not-a-Number)
 *	FP_QNAN           Quiet NaN (Not-a-Number)
 *	FP_POS_INF        +infinity
 *	FP_NEG_INF        -infinity
 *	FP_POS_NORM       Positive normalized
 *	FP_NEG_NORM       Negative normalized
 *	FP_POS_DENORM     Positive denormalized
 *	FP_NEG_DENORM     Negative denormalized
 *	FP_POS_ZERO       +0.0 (positive zero)
 *	FP_NEG_ZERO       -0.0 (negative zero)
 */
/*#define HAS_FP_CLASS		/ **/

/* HAS_FPCLASS:
 *	This symbol, if defined, indicates that the fpclass routine is
 *	available to classify doubles.  Available for example in Solaris/SVR4.
 *	The returned values are defined in <ieeefp.h> and are:
 *
 *	FP_SNAN		signaling NaN
 *	FP_QNAN		quiet NaN
 *	FP_NINF		negative infinity
 *	FP_PINF		positive infinity
 *	FP_NDENORM	negative denormalized non-zero
 *	FP_PDENORM	positive denormalized non-zero
 *	FP_NZERO	negative zero
 *	FP_PZERO	positive zero
 *	FP_NNORM	negative normalized non-zero
 *	FP_PNORM	positive normalized non-zero
 */
/*#define HAS_FPCLASS		/ **/

/* HAS_FPCLASSIFY:
 *	This symbol, if defined, indicates that the fpclassify routine is
 *	available to classify doubles.  Available for example in HP-UX.
 *	The returned values are defined in <math.h> and are
 *
 *           FP_NORMAL     Normalized
 *           FP_ZERO       Zero
 *           FP_INFINITE   Infinity
 *           FP_SUBNORMAL  Denormalized
 *           FP_NAN        NaN
 *
 */
/*#define HAS_FPCLASSIFY		/ **/

/* HAS_FPCLASSL:
 *	This symbol, if defined, indicates that the fpclassl routine is
 *	available to classify long doubles.  Available for example in IRIX.
 *	The returned values are defined in <ieeefp.h> and are:
 *
 *	FP_SNAN		signaling NaN
 *	FP_QNAN		quiet NaN
 *	FP_NINF		negative infinity
 *	FP_PINF		positive infinity
 *	FP_NDENORM	negative denormalized non-zero
 *	FP_PDENORM	positive denormalized non-zero
 *	FP_NZERO	negative zero
 *	FP_PZERO	positive zero
 *	FP_NNORM	negative normalized non-zero
 *	FP_PNORM	positive normalized non-zero
 */
/*#define HAS_FPCLASSL		/ **/

/* HAS_FPOS64_T:
 *	This symbol will be defined if the C compiler supports fpos64_t.
 */
/*#define	HAS_FPOS64_T    	/ **/

/* HAS_FREXPL:
 *	This symbol, if defined, indicates that the frexpl routine is
 *	available to break a long double floating-point number into
 *	a normalized fraction and an integral power of 2.
 */
#define HAS_FREXPL		/**/

/* HAS_STRUCT_FS_DATA:
 *	This symbol, if defined, indicates that the struct fs_data
 *	to do statfs() is supported.
 */
/*#define HAS_STRUCT_FS_DATA	/ **/

/* HAS_FSEEKO:
 *	This symbol, if defined, indicates that the fseeko routine is
 *	available to fseek beyond 32 bits (useful for ILP32 hosts).
 */
#define HAS_FSEEKO		/**/

/* HAS_FSTATFS:
 *	This symbol, if defined, indicates that the fstatfs routine is
 *	available to stat filesystems by file descriptors.
 */
#define HAS_FSTATFS		/**/

/* HAS_FSYNC:
 *	This symbol, if defined, indicates that the fsync routine is
 *	available to write a file's modified data and attributes to
 *	permanent storage.
 */
#define HAS_FSYNC		/**/

/* HAS_FTELLO:
 *	This symbol, if defined, indicates that the ftello routine is
 *	available to ftell beyond 32 bits (useful for ILP32 hosts).
 */
#define HAS_FTELLO		/**/

/* HAS_FUTIMES:
 *	This symbol, if defined, indicates that the futimes routine is
 *	available to change file descriptor time stamps with struct timevals.
 */
#define HAS_FUTIMES		/**/

/* HAS_GETADDRINFO:
 *	This symbol, if defined, indicates that the getaddrinfo() function
 *	is available for use.
 */
#define HAS_GETADDRINFO		/**/

/* HAS_GETCWD:
 *	This symbol, if defined, indicates that the getcwd routine is
 *	available to get the current working directory.
 */
#define HAS_GETCWD		/**/

/* HAS_GETESPWNAM:
 *	This symbol, if defined, indicates that the getespwnam system call is
 *	available to retrieve enhanced (shadow) password entries by name.
 */
/*#define HAS_GETESPWNAM		/ **/

/* HAS_GETFSSTAT:
 *	This symbol, if defined, indicates that the getfsstat routine is
 *	available to stat filesystems in bulk.
 */
/*#define HAS_GETFSSTAT		/ **/

/* HAS_GETITIMER:
 *	This symbol, if defined, indicates that the getitimer routine is
 *	available to return interval timers.
 */
#define HAS_GETITIMER		/**/

/* HAS_GETMNT:
 *	This symbol, if defined, indicates that the getmnt routine is
 *	available to get filesystem mount info by filename.
 */
/*#define HAS_GETMNT		/ **/

/* HAS_GETMNTENT:
 *	This symbol, if defined, indicates that the getmntent routine is
 *	available to iterate through mounted file systems to get their info.
 */
#define HAS_GETMNTENT		/**/

/* HAS_GETNAMEINFO:
 *	This symbol, if defined, indicates that the getnameinfo() function
 *	is available for use.
 */
#define HAS_GETNAMEINFO		/**/

/* HAS_GETPRPWNAM:
 *	This symbol, if defined, indicates that the getprpwnam system call is
 *	available to retrieve protected (shadow) password entries by name.
 */
/*#define HAS_GETPRPWNAM		/ **/

/* HAS_GETSPNAM:
 *	This symbol, if defined, indicates that the getspnam system call is
 *	available to retrieve SysV shadow password entries by name.
 */
#define HAS_GETSPNAM		/**/

/* HAS_HASMNTOPT:
 *	This symbol, if defined, indicates that the hasmntopt routine is
 *	available to query the mount options of file systems.
 */
#define HAS_HASMNTOPT		/**/

/* HAS_ILOGBL:
 *	This symbol, if defined, indicates that the ilogbl routine is
 *	available.  If scalbnl is also present we can emulate frexpl.
 */
#define HAS_ILOGBL		/**/

/* HAS_INETNTOP:
 *	This symbol, if defined, indicates that the inet_ntop() function
 *	is available to parse IPv4 and IPv6 strings.
 */
#define HAS_INETNTOP		/**/

/* HAS_INETPTON:
 *	This symbol, if defined, indicates that the inet_pton() function
 *	is available to parse IPv4 and IPv6 strings.
 */
#define HAS_INETPTON		/**/

/* HAS_INT64_T:
 *     This symbol will defined if the C compiler supports int64_t.
 *     Usually the <inttypes.h> needs to be included, but sometimes
 *	<sys/types.h> is enough.
 */
#define     HAS_INT64_T               /**/

/* HAS_ISBLANK:
 *	This manifest constant lets the C program know that isblank
 *	is available.
 */
#define HAS_ISBLANK		/**/

/* HAS_ISFINITE:
 *	This symbol, if defined, indicates that the isfinite routine is
 *	available to check whether a double is finite (non-infinity non-NaN).
 */
/*#define HAS_ISFINITE		/ **/

/* HAS_ISINF:
 *	This symbol, if defined, indicates that the isinf routine is
 *	available to check whether a double is an infinity.
 */
#define HAS_ISINF		/**/

/* HAS_ISNAN:
 *	This symbol, if defined, indicates that the isnan routine is
 *	available to check whether a double is a NaN.
 */
#define HAS_ISNAN		/**/

/* HAS_ISNANL:
 *	This symbol, if defined, indicates that the isnanl routine is
 *	available to check whether a long double is a NaN.
 */
#define HAS_ISNANL		/**/

/* HAS_LDBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol LDBL_DIG, which is the number
 *	of significant digits in a long double precision number. Unlike
 *	for DBL_DIG, there's no good guess for LDBL_DIG if it is undefined.
 */
#define HAS_LDBL_DIG 	/* */

/* LIBM_LIB_VERSION:
 *	This symbol, if defined, indicates that libm exports _LIB_VERSION
 *	and that math.h defines the enum to manipulate it.
 */
#define LIBM_LIB_VERSION		/**/

/* HAS_MADVISE:
 *	This symbol, if defined, indicates that the madvise system call is
 *	available to map a file into memory.
 */
#define HAS_MADVISE		/**/

/* HAS_MALLOC_SIZE:
 *	This symbol, if defined, indicates that the malloc_size
 *	routine is available for use.
 */
/*#define HAS_MALLOC_SIZE		/ **/

/* HAS_MALLOC_GOOD_SIZE:
 *	This symbol, if defined, indicates that the malloc_good_size
 *	routine is available for use.
 */
/*#define HAS_MALLOC_GOOD_SIZE	/ **/

/* HAS_MKDTEMP:
 *	This symbol, if defined, indicates that the mkdtemp routine is
 *	available to exclusively create a uniquely named temporary directory.
 */
#define HAS_MKDTEMP		/**/

/* HAS_MKSTEMPS:
 *	This symbol, if defined, indicates that the mkstemps routine is
 *	available to exclusively create and open a uniquely named
 *	(with a suffix) temporary file.
 */
#define HAS_MKSTEMPS		/**/

/* HAS_MODFL:
 *	This symbol, if defined, indicates that the modfl routine is
 *	available to split a long double x into a fractional part f and
 *	an integer part i such that |f| < 1.0 and (f + i) = x.
 */
/* HAS_MODFL_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the modfl() function.  Otherwise, it is up
 *	to the program to supply one.
 */
/* HAS_MODFL_POW32_BUG:
 *	This symbol, if defined, indicates that the modfl routine is
 *	broken for long doubles >= pow(2, 32).
 *	For example from 4294967303.150000 one would get 4294967302.000000
 *	and 1.150000.  The bug has been seen in certain versions of glibc,
 *	release 2.2.2 is known to be okay.
 */
#define HAS_MODFL		/**/
#define HAS_MODFL_PROTO		/**/
/*#define HAS_MODFL_POW32_BUG		/ **/

/* HAS_MPROTECT:
 *	This symbol, if defined, indicates that the mprotect system call is
 *	available to modify the access protection of a memory mapped file.
 */
#define HAS_MPROTECT		/**/

/* HAS_STRUCT_MSGHDR:
 *	This symbol, if defined, indicates that the struct msghdr
 *	is supported.
 */
#define HAS_STRUCT_MSGHDR	/**/

/* HAS_NL_LANGINFO:
 *	This symbol, if defined, indicates that the nl_langinfo routine is
 *	available to return local data.  You will also need <langinfo.h>
 *	and therefore I_LANGINFO.
 */
#define HAS_NL_LANGINFO		/**/

/* HAS_OFF64_T:
 *	This symbol will be defined if the C compiler supports off64_t.
 */
#define	HAS_OFF64_T    		/**/

/* HAS_PRCTL:
 *	This symbol, if defined, indicates that the prctl routine is
 *	available to set process title.
 */
/* HAS_PRCTL_SET_NAME:
 *	This symbol, if defined, indicates that the prctl routine is
 *	available to set process title and supports PR_SET_NAME.
 */
#define HAS_PRCTL		/**/
#define HAS_PRCTL_SET_NAME		/**/

/* HAS_PROCSELFEXE:
 *	This symbol is defined if PROCSELFEXE_PATH is a symlink
 *	to the absolute pathname of the executing program.
 */
/* PROCSELFEXE_PATH:
 *	If HAS_PROCSELFEXE is defined this symbol is the filename
 *	of the symbolic link pointing to the absolute pathname of
 *	the executing program.
 */
#define HAS_PROCSELFEXE	/**/
#if defined(HAS_PROCSELFEXE) && !defined(PROCSELFEXE_PATH)
#define PROCSELFEXE_PATH	"/proc/self/exe"	/**/
#endif

/* HAS_PTHREAD_ATTR_SETSCOPE:
 *	This symbol, if defined, indicates that the pthread_attr_setscope
 *	system call is available to set the contention scope attribute of
 *	a thread attribute object.
 */
#define HAS_PTHREAD_ATTR_SETSCOPE		/**/

/* HAS_READV:
 *	This symbol, if defined, indicates that the readv routine is
 *	available to do gather reads.  You will also need <sys/uio.h>
 *	and there I_SYSUIO.
 */
#define HAS_READV		/**/

/* HAS_RECVMSG:
 *	This symbol, if defined, indicates that the recvmsg routine is
 *	available to send structured socket messages.
 */
#define HAS_RECVMSG		/**/

/* HAS_SBRK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the sbrk() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern void* sbrk(int);
 *		extern void* sbrk(size_t);
 */
#define	HAS_SBRK_PROTO	/**/

/* HAS_SCALBNL:
 *	This symbol, if defined, indicates that the scalbnl routine is
 *	available.  If ilogbl is also present we can emulate frexpl.
 */
#define HAS_SCALBNL		/**/

/* HAS_SENDMSG:
 *	This symbol, if defined, indicates that the sendmsg routine is
 *	available to send structured socket messages.
 */
#define HAS_SENDMSG		/**/

/* HAS_SETITIMER:
 *	This symbol, if defined, indicates that the setitimer routine is
 *	available to set interval timers.
 */
#define HAS_SETITIMER		/**/

/* HAS_SETPROCTITLE:
 *	This symbol, if defined, indicates that the setproctitle routine is
 *	available to set process title.
 */
/*#define HAS_SETPROCTITLE		/ **/

/* HAS_SIGNBIT:
 *	This symbol, if defined, indicates that the signbit routine is
 *	available to check if the given number has the sign bit set.
 *	This should include correct testing of -0.0.  This will only be set
 *	if the signbit() routine is safe to use with the NV type used internally
 *	in perl.  Users should call Perl_signbit(), which will be #defined to
 *	the system's signbit() function or macro if this symbol is defined.
 */
#define HAS_SIGNBIT		/**/

/* HAS_SIGPROCMASK:
 *	This symbol, if defined, indicates that the sigprocmask
 *	system call is available to examine or change the signal mask
 *	of the calling process.
 */
#define HAS_SIGPROCMASK		/**/

/* USE_SITECUSTOMIZE:
 *	This symbol, if defined, indicates that sitecustomize should
 *	be used.
 */
#ifndef USE_SITECUSTOMIZE
#define	USE_SITECUSTOMIZE		/**/
#endif

/* HAS_SNPRINTF:
 *	This symbol, if defined, indicates that the snprintf () library
 *	function is available for use.
 */
/* HAS_VSNPRINTF:
 *	This symbol, if defined, indicates that the vsnprintf () library
 *	function is available for use.
 */
#define HAS_SNPRINTF	/**/
#define HAS_VSNPRINTF	/**/

/* HAS_SOCKATMARK:
 *	This symbol, if defined, indicates that the sockatmark routine is
 *	available to test whether a socket is at the out-of-band mark.
 */
#define HAS_SOCKATMARK		/**/

/* HAS_SOCKATMARK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the sockatmark() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int sockatmark(int);
 */
#define	HAS_SOCKATMARK_PROTO	/**/

/* HAS_SOCKS5_INIT:
 *	This symbol, if defined, indicates that the socks5_init routine is
 *	available to initialize SOCKS 5.
 */
/*#define HAS_SOCKS5_INIT		/ **/

/* SPRINTF_RETURNS_STRLEN:
 *	This variable defines whether sprintf returns the length of the string
 *	(as per the ANSI spec). Some C libraries retain compatibility with
 *	pre-ANSI C and return a pointer to the passed in buffer; for these
 *	this variable will be undef.
 */
#define SPRINTF_RETURNS_STRLEN	/**/

/* HAS_SQRTL:
 *	This symbol, if defined, indicates that the sqrtl routine is
 *	available to do long double square roots.
 */
#define HAS_SQRTL		/**/

/* HAS_SETRESGID_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the setresgid() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int setresgid(uid_t ruid, uid_t euid, uid_t suid);
 */
#define	HAS_SETRESGID_PROTO	/**/

/* HAS_SETRESUID_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the setresuid() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int setresuid(uid_t ruid, uid_t euid, uid_t suid);
 */
#define	HAS_SETRESUID_PROTO	/**/

/* HAS_STRUCT_STATFS_F_FLAGS:
 *	This symbol, if defined, indicates that the struct statfs
 *	does have the f_flags member containing the mount flags of
 *	the filesystem containing the file.
 *	This kind of struct statfs is coming from <sys/mount.h> (BSD 4.3),
 *	not from <sys/statfs.h> (SYSV).  Older BSDs (like Ultrix) do not
 *	have statfs() and struct statfs, they have ustat() and getmnt()
 *	with struct ustat and struct fs_data.
 */
#define HAS_STRUCT_STATFS_F_FLAGS		/**/

/* HAS_STRUCT_STATFS:
 *	This symbol, if defined, indicates that the struct statfs
 *	to do statfs() is supported.
 */
#define HAS_STRUCT_STATFS	/**/

/* HAS_FSTATVFS:
 *	This symbol, if defined, indicates that the fstatvfs routine is
 *	available to stat filesystems by file descriptors.
 */
#define HAS_FSTATVFS		/**/

/* HAS_STRFTIME:
 *	This symbol, if defined, indicates that the strftime routine is
 *	available to do time formatting.
 */
#define HAS_STRFTIME		/**/

/* HAS_STRLCAT:
 *	This symbol, if defined, indicates that the strlcat () routine is
 *	available to do string concatenation.
 */
/*#define HAS_STRLCAT		/ **/

/* HAS_STRLCPY:
 *	This symbol, if defined, indicates that the strlcpy () routine is
 *	available to do string copying.
 */
/*#define HAS_STRLCPY		/ **/

/* HAS_STRTOLD:
 *	This symbol, if defined, indicates that the strtold routine is
 *	available to convert strings to long doubles.
 */
#define HAS_STRTOLD		/**/

/* HAS_STRTOLL:
 *	This symbol, if defined, indicates that the strtoll routine is
 *	available to convert strings to long longs.
 */
#define HAS_STRTOLL		/**/

/* HAS_STRTOQ:
 *	This symbol, if defined, indicates that the strtoq routine is
 *	available to convert strings to long longs (quads).
 */
#define HAS_STRTOQ		/**/

/* HAS_STRTOULL:
 *	This symbol, if defined, indicates that the strtoull routine is
 *	available to convert strings to unsigned long longs.
 */
#define HAS_STRTOULL		/**/

/* HAS_STRTOUQ:
 *	This symbol, if defined, indicates that the strtouq routine is
 *	available to convert strings to unsigned long longs (quads).
 */
#define HAS_STRTOUQ		/**/

/* HAS_SYSCALL_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the syscall() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int syscall(int,  ...);
 *		extern int syscall(long, ...);
 */
#define	HAS_SYSCALL_PROTO	/**/

/* HAS_TELLDIR_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the telldir() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern long telldir(DIR*);
 */
#define	HAS_TELLDIR_PROTO	/**/

/* HAS_CTIME64:
 *	This symbol, if defined, indicates that the ctime64 () routine is
 *	available to do the 64bit variant of ctime ()
 */
/* HAS_LOCALTIME64:
 *	This symbol, if defined, indicates that the localtime64 () routine is
 *	available to do the 64bit variant of localtime ()
 */
/* HAS_GMTIME64:
 *	This symbol, if defined, indicates that the gmtime64 () routine is
 *	available to do the 64bit variant of gmtime ()
 */
/* HAS_MKTIME64:
 *	This symbol, if defined, indicates that the mktime64 () routine is
 *	available to do the 64bit variant of mktime ()
 */
/* HAS_DIFFTIME64:
 *	This symbol, if defined, indicates that the difftime64 () routine is
 *	available to do the 64bit variant of difftime ()
 */
/* HAS_ASCTIME64:
 *	This symbol, if defined, indicates that the asctime64 () routine is
 *	available to do the 64bit variant of asctime ()
 */
/*#define	HAS_CTIME64		/ **/
/*#define	HAS_LOCALTIME64		/ **/
/*#define	HAS_GMTIME64		/ **/
/*#define	HAS_MKTIME64		/ **/
/*#define	HAS_DIFFTIME64		/ **/
/*#define	HAS_ASCTIME64		/ **/

/* HAS_TIMEGM:
 *	This symbol, if defined, indicates that the timegm routine is
 *	available to do the opposite of gmtime ()
 */
#define HAS_TIMEGM		/**/

/* U32_ALIGNMENT_REQUIRED:
 *	This symbol, if defined, indicates that you must access
 *	character data through U32-aligned pointers.
 */
#ifndef U32_ALIGNMENT_REQUIRED
#define U32_ALIGNMENT_REQUIRED	/**/
#endif

/* HAS_UALARM:
 *	This symbol, if defined, indicates that the ualarm routine is
 *	available to do alarms with microsecond granularity.
 */
/*#define HAS_UALARM		/ **/

/* HAS_UNORDERED:
 *	This symbol, if defined, indicates that the unordered routine is
 *	available to check whether two doubles are unordered
 *	(effectively: whether either of them is NaN)
 */
/*#define HAS_UNORDERED		/ **/

/* HAS_UNSETENV:
 *	This symbol, if defined, indicates that the unsetenv () routine is
 *	available for use.
 */
#define HAS_UNSETENV		/**/

/* HAS_USLEEP_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the usleep() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int usleep(useconds_t);
 */
#define	HAS_USLEEP_PROTO	/**/

/* HAS_USTAT:
 *	This symbol, if defined, indicates that the ustat system call is
 *	available to query file system statistics by dev_t.
 */
#define HAS_USTAT		/**/

/* HAS_WRITEV:
 *	This symbol, if defined, indicates that the writev routine is
 *	available to do scatter writes.
 */
#define HAS_WRITEV		/**/

/* USE_DYNAMIC_LOADING:
 *	This symbol, if defined, indicates that dynamic loading of
 *	some sort is available.
 */
#define USE_DYNAMIC_LOADING		/**/

/* FFLUSH_NULL:
 *	This symbol, if defined, tells that fflush(NULL) correctly
 *	flushes all pending stdio output without side effects. In
 *	particular, on some platforms calling fflush(NULL) *still*
 *	corrupts STDIN if it is a pipe.
 */
/* FFLUSH_ALL:
 *	This symbol, if defined, tells that to flush
 *	all pending stdio output one must loop through all
 *	the stdio file handles stored in an array and fflush them.
 *	Note that if fflushNULL is defined, fflushall will not
 *	even be probed for and will be left undefined.
 */
#define	FFLUSH_NULL 		/**/
/*#define	FFLUSH_ALL 		/ **/

/* I_ASSERT:
 *	This symbol, if defined, indicates that <assert.h> exists and
 *	could be included by the C program to get the assert() macro.
 */
#define	I_ASSERT		/**/

/* I_CRYPT:
 *	This symbol, if defined, indicates that <crypt.h> exists and
 *	should be included.
 */
#define	I_CRYPT		/**/

/* DB_Prefix_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is u_int32_t.
 */
/* DB_Hash_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is size_t.
 */
/* DB_VERSION_MAJOR_CFG:
 *	This symbol, if defined, defines the major version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 */
/* DB_VERSION_MINOR_CFG:
 *	This symbol, if defined, defines the minor version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 *	For DB version 1 this is always 0.
 */
/* DB_VERSION_PATCH_CFG:
 *	This symbol, if defined, defines the patch version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 *	For DB version 1 this is always 0.
 */
#define DB_Hash_t	u_int32_t		/**/
#define DB_Prefix_t	size_t  	/**/
#define DB_VERSION_MAJOR_CFG	5  	/**/
#define DB_VERSION_MINOR_CFG	3  	/**/
#define DB_VERSION_PATCH_CFG	28  	/**/

/* I_FP:
 *	This symbol, if defined, indicates that <fp.h> exists and
 *	should be included.
 */
/*#define	I_FP		/ **/

/* I_FP_CLASS:
 *	This symbol, if defined, indicates that <fp_class.h> exists and
 *	should be included.
 */
/*#define	I_FP_CLASS		/ **/

/* I_IEEEFP:
 *	This symbol, if defined, indicates that <ieeefp.h> exists and
 *	should be included.
 */
/*#define	I_IEEEFP		/ **/

/* I_INTTYPES:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <inttypes.h>.
 */
#define   I_INTTYPES                /**/

/* I_LANGINFO:
 *	This symbol, if defined, indicates that <langinfo.h> exists and
 *	should be included.
 */
#define	I_LANGINFO		/**/

/* I_LIBUTIL:
 *	This symbol, if defined, indicates that <libutil.h> exists and
 *	should be included.
 */
/*#define	I_LIBUTIL		/ **/

/* I_MALLOCMALLOC:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <malloc/malloc.h>.
 */
/*#define I_MALLOCMALLOC		/ **/

/* I_MNTENT:
 *	This symbol, if defined, indicates that <mntent.h> exists and
 *	should be included.
 */
#define	I_MNTENT		/**/

/* I_NETINET_TCP:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <netinet/tcp.h>.
 */
#define   I_NETINET_TCP                /**/

/* I_POLL:
 *	This symbol, if defined, indicates that <poll.h> exists and
 *	should be included. (see also HAS_POLL)
 */
#define	I_POLL		/**/

/* I_PROT:
 *	This symbol, if defined, indicates that <prot.h> exists and
 *	should be included.
 */
/*#define	I_PROT		/ **/

/* I_SHADOW:
 *	This symbol, if defined, indicates that <shadow.h> exists and
 *	should be included.
 */
#define	I_SHADOW		/**/

/* I_SOCKS:
 *	This symbol, if defined, indicates that <socks.h> exists and
 *	should be included.
 */
/*#define	I_SOCKS		/ **/

/* I_STDBOOL:
 *	This symbol, if defined, indicates that <stdbool.h> exists and
 *	can be included.
 */
#define	I_STDBOOL		/**/

/* I_SUNMATH:
 *	This symbol, if defined, indicates that <sunmath.h> exists and
 *	should be included.
 */
/*#define	I_SUNMATH		/ **/

/* I_SYSLOG:
 *	This symbol, if defined, indicates that <syslog.h> exists and
 *	should be included.
 */
#define	I_SYSLOG		/**/

/* I_SYSMODE:
 *	This symbol, if defined, indicates that <sys/mode.h> exists and
 *	should be included.
 */
/*#define	I_SYSMODE		/ **/

/* I_SYS_MOUNT:
 *	This symbol, if defined, indicates that <sys/mount.h> exists and
 *	should be included.
 */
#define	I_SYS_MOUNT		/**/

/* I_SYS_STATFS:
 *	This symbol, if defined, indicates that <sys/statfs.h> exists.
 */
#define	I_SYS_STATFS		/**/

/* I_SYS_STATVFS:
 *	This symbol, if defined, indicates that <sys/statvfs.h> exists and
 *	should be included.
 */
#define	I_SYS_STATVFS		/**/

/* I_SYSUTSNAME:
 *	This symbol, if defined, indicates that <sys/utsname.h> exists and
 *	should be included.
 */
#define	I_SYSUTSNAME		/**/

/* I_SYS_VFS:
 *	This symbol, if defined, indicates that <sys/vfs.h> exists and
 *	should be included.
 */
#define	I_SYS_VFS		/**/

/* I_USTAT:
 *	This symbol, if defined, indicates that <ustat.h> exists and
 *	should be included.
 */
#define	I_USTAT		/**/

/* PERL_PRIfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for output.
 */
/* PERL_PRIgldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'g') for output.
 */
/* PERL_PRIeldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'e') for output.
 */
/* PERL_SCNfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for input.
 */
#define PERL_PRIfldbl	"Lf"	/**/
#define PERL_PRIgldbl	"Lg"	/**/
#define PERL_PRIeldbl	"Le"	/**/
#define PERL_SCNfldbl	"Lf"	/**/

/* PERL_MAD:
 *	This symbol, if defined, indicates that the Misc Attribution
 *	Declaration code should be conditionally compiled.
 */
/*#define	PERL_MAD		/ **/

/* NEED_VA_COPY:
 *	This symbol, if defined, indicates that the system stores
 *	the variable argument list datatype, va_list, in a format
 *	that cannot be copied by simple assignment, so that some
 *	other means must be used when copying is required.
 *	As such systems vary in their provision (or non-provision)
 *	of copying mechanisms, handy.h defines a platform-
 *	independent macro, Perl_va_copy(src, dst), to do the job.
 */
#define	NEED_VA_COPY		/**/

/* IVTYPE:
 *	This symbol defines the C type used for Perl's IV.
 */
/* UVTYPE:
 *	This symbol defines the C type used for Perl's UV.
 */
/* I8TYPE:
 *	This symbol defines the C type used for Perl's I8.
 */
/* U8TYPE:
 *	This symbol defines the C type used for Perl's U8.
 */
/* I16TYPE:
 *	This symbol defines the C type used for Perl's I16.
 */
/* U16TYPE:
 *	This symbol defines the C type used for Perl's U16.
 */
/* I32TYPE:
 *	This symbol defines the C type used for Perl's I32.
 */
/* U32TYPE:
 *	This symbol defines the C type used for Perl's U32.
 */
/* I64TYPE:
 *	This symbol defines the C type used for Perl's I64.
 */
/* U64TYPE:
 *	This symbol defines the C type used for Perl's U64.
 */
/* NVTYPE:
 *	This symbol defines the C type used for Perl's NV.
 */
/* IVSIZE:
 *	This symbol contains the sizeof(IV).
 */
/* UVSIZE:
 *	This symbol contains the sizeof(UV).
 */
/* I8SIZE:
 *	This symbol contains the sizeof(I8).
 */
/* U8SIZE:
 *	This symbol contains the sizeof(U8).
 */
/* I16SIZE:
 *	This symbol contains the sizeof(I16).
 */
/* U16SIZE:
 *	This symbol contains the sizeof(U16).
 */
/* I32SIZE:
 *	This symbol contains the sizeof(I32).
 */
/* U32SIZE:
 *	This symbol contains the sizeof(U32).
 */
/* I64SIZE:
 *	This symbol contains the sizeof(I64).
 */
/* U64SIZE:
 *	This symbol contains the sizeof(U64).
 */
/* NVSIZE:
 *	This symbol contains the sizeof(NV).
 */
/* NV_PRESERVES_UV:
 *	This symbol, if defined, indicates that a variable of type NVTYPE
 *	can preserve all the bits of a variable of type UVTYPE.
 */
/* NV_PRESERVES_UV_BITS:
 *	This symbol contains the number of bits a variable of type NVTYPE
 *	can preserve of a variable of type UVTYPE.
 */
/* NV_OVERFLOWS_INTEGERS_AT:
 *	This symbol gives the largest integer value that NVs can hold. This
 *	value + 1.0 cannot be stored accurately. It is expressed as constant
 *	floating point expression to reduce the chance of decimal/binary
 *	conversion issues. If it can not be determined, the value 0 is given.
 */
/* NV_ZERO_IS_ALLBITS_ZERO:
 *	This symbol, if defined, indicates that a variable of type NVTYPE
 *	stores 0.0 in memory as all bits zero.
 */
#define	IVTYPE		long		/**/
#define	UVTYPE		unsigned long		/**/
#define	I8TYPE		signed char		/**/
#define	U8TYPE		unsigned char		/**/
#define	I16TYPE		short	/**/
#define	U16TYPE		unsigned short	/**/
#define	I32TYPE		int	/**/
#define	U32TYPE		unsigned int	/**/
#ifdef HAS_QUAD
#define	I64TYPE		long	/**/
#define	U64TYPE		unsigned long	/**/
#endif
#define	NVTYPE		double		/**/
#define	IVSIZE		8		/**/
#define	UVSIZE		8		/**/
#define	I8SIZE		1		/**/
#define	U8SIZE		1		/**/
#define	I16SIZE		2	/**/
#define	U16SIZE		2	/**/
#define	I32SIZE		4	/**/
#define	U32SIZE		4	/**/
#ifdef HAS_QUAD
#define	I64SIZE		8	/**/
#define	U64SIZE		8	/**/
#endif
#define	NVSIZE		8		/**/
#undef	NV_PRESERVES_UV
#define	NV_PRESERVES_UV_BITS	53
#define	NV_OVERFLOWS_INTEGERS_AT	256.0*256.0*256.0*256.0*256.0*256.0*2.0*2.0*2.0*2.0*2.0
#define	NV_ZERO_IS_ALLBITS_ZERO
#if UVSIZE == 8
#   ifdef BYTEORDER
#       if BYTEORDER == 0x1234
#           undef BYTEORDER
#           define BYTEORDER 0x12345678
#       else
#           if BYTEORDER == 0x4321
#               undef BYTEORDER
#               define BYTEORDER 0x87654321
#           endif
#       endif
#   endif
#endif

/* IVdf:
 *	This symbol defines the format string used for printing a Perl IV
 *	as a signed decimal integer.
 */
/* UVuf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned decimal integer.
 */
/* UVof:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned octal integer.
 */
/* UVxf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned hexadecimal integer in lowercase abcdef.
 */
/* UVXf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned hexadecimal integer in uppercase ABCDEF.
 */
/* NVef:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %e-ish floating point format.
 */
/* NVff:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %f-ish floating point format.
 */
/* NVgf:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %g-ish floating point format.
 */
#define	IVdf		"ld"		/**/
#define	UVuf		"lu"		/**/
#define	UVof		"lo"		/**/
#define	UVxf		"lx"		/**/
#define	UVXf		"lX"		/**/
#define	NVef		"e"		/**/
#define	NVff		"f"		/**/
#define	NVgf		"g"		/**/

/* SELECT_MIN_BITS:
 *	This symbol holds the minimum number of bits operated by select.
 *	That is, if you do select(n, ...), how many bits at least will be
 *	cleared in the masks if some activity is detected.  Usually this
 *	is either n or 32*ceil(n/32), especially many little-endians do
 *	the latter.  This is only useful if you have select(), naturally.
 */
#define SELECT_MIN_BITS 	64	/**/

/* ST_INO_SIZE:
 *	This variable contains the size of struct stat's st_ino in bytes.
 */
/* ST_INO_SIGN:
 *	This symbol holds the signedness of struct stat's st_ino.
 *	1 for unsigned, -1 for signed.
 */
#define ST_INO_SIGN 1	/* st_ino sign */
#define ST_INO_SIZE 8	/* st_ino size */

/* STARTPERL:
 *	This variable contains the string to put in front of a perl
 *	script to make sure (one hopes) that it runs with perl and not
 *	some shell.
 */
#define STARTPERL "#!/usr/bin/perl"		/**/

/* HAS_STDIO_STREAM_ARRAY:
 *	This symbol, if defined, tells that there is an array
 *	holding the stdio streams.
 */
/* STDIO_STREAM_ARRAY:
 *	This symbol tells the name of the array holding the stdio streams.
 *	Usual values include _iob, __iob, and __sF.
 */
/*#define	HAS_STDIO_STREAM_ARRAY	/ **/
#ifdef HAS_STDIO_STREAM_ARRAY
#define STDIO_STREAM_ARRAY	
#endif

/* GMTIME_MAX:
 *	This symbol contains the maximum value for the time_t offset that
 *	the system function gmtime () accepts, and defaults to 0
 */
/* GMTIME_MIN:
 *	This symbol contains the minimum value for the time_t offset that
 *	the system function gmtime () accepts, and defaults to 0
 */
/* LOCALTIME_MAX:
 *	This symbol contains the maximum value for the time_t offset that
 *	the system function localtime () accepts, and defaults to 0
 */
/* LOCALTIME_MIN:
 *	This symbol contains the minimum value for the time_t offset that
 *	the system function localtime () accepts, and defaults to 0
 */
#define GMTIME_MAX		67768036191676799	/**/
#define GMTIME_MIN		-62167219200	/**/
#define LOCALTIME_MAX	67768036191676799	/**/
#define LOCALTIME_MIN	-62167219200	/**/

/* USE_64_BIT_INT:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be employed (be they 32 or 64 bits).  The minimal possible
 *	64-bitness is used, just enough to get 64-bit integers into Perl.
 *	This may mean using for example "long longs", while your memory
 *	may still be limited to 2 gigabytes.
 */
/* USE_64_BIT_ALL:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be used (be they 32 or 64 bits).  The maximal possible
 *	64-bitness is employed: LP64 or ILP64, meaning that you will
 *	be able to use more than 2 gigabytes of memory.  This mode is
 *	even more binary incompatible than USE_64_BIT_INT. You may not
 *	be able to run the resulting executable in a 32-bit CPU at all or
 *	you may need at least to reboot your OS to 64-bit mode.
 */
#ifndef USE_64_BIT_INT
#define	USE_64_BIT_INT		/**/
#endif
#ifndef USE_64_BIT_ALL
#define	USE_64_BIT_ALL		/**/
#endif

/* USE_DTRACE:
 *	This symbol, if defined, indicates that Perl should
 *	be built with support for DTrace.
 */
/*#define USE_DTRACE		/ **/

/* USE_FAST_STDIO:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use 'fast stdio'.
 *	Defaults to define in Perls 5.8 and earlier, to undef later.
 */
#ifndef USE_FAST_STDIO
/*#define	USE_FAST_STDIO		/ **/
#endif

/* USE_KERN_PROC_PATHNAME:
 *	This symbol, if defined, indicates that we can use sysctl with
 *	KERN_PROC_PATHNAME to get a full path for the executable, and hence
 * 	convert $^X to an absolute path.
 */
/*#define USE_KERN_PROC_PATHNAME	/ **/

/* USE_LARGE_FILES:
 *	This symbol, if defined, indicates that large file support
 *	should be used when available.
 */
#ifndef USE_LARGE_FILES
#define	USE_LARGE_FILES		/**/
#endif

/* USE_LONG_DOUBLE:
 *	This symbol, if defined, indicates that long doubles should
 *	be used when available.
 */
#ifndef USE_LONG_DOUBLE
/*#define	USE_LONG_DOUBLE		/ **/
#endif

/* USE_MORE_BITS:
 *	This symbol, if defined, indicates that 64-bit interfaces and
 *	long doubles should be used when available.
 */
#ifndef USE_MORE_BITS
/*#define	USE_MORE_BITS		/ **/
#endif

/* MULTIPLICITY:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use multiplicity.
 */
#ifndef MULTIPLICITY
#define	MULTIPLICITY		/**/
#endif

/* USE_NSGETEXECUTABLEPATH:
 *	This symbol, if defined, indicates that we can use _NSGetExecutablePath
 *	and realpath to get a full path for the executable, and hence convert
 *	$^X to an absolute path.
 */
/*#define USE_NSGETEXECUTABLEPATH	/ **/

/* USE_PERLIO:
 *	This symbol, if defined, indicates that the PerlIO abstraction should
 *	be used throughout.  If not defined, stdio should be
 *	used in a fully backward compatible manner.
 */
#ifndef USE_PERLIO
#define	USE_PERLIO		/**/
#endif

/* USE_SOCKS:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use socks.
 */
#ifndef USE_SOCKS
/*#define	USE_SOCKS		/ **/
#endif

#endif
                                                                                                                                                                                                                                                                     usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/cop.h                                                     0100644 0000000 0000000 00000122233 12744441327 016671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    cop.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * Control ops (cops) are one of the two ops OP_NEXTSTATE and OP_DBSTATE,
 * that (loosely speaking) are separate statements.
 * They hold information important for lexical state and error reporting.
 * At run time, PL_curcop is set to point to the most recently executed cop,
 * and thus can be used to determine our current state.
 */

/* A jmpenv packages the state required to perform a proper non-local jump.
 * Note that there is a PL_start_env initialized when perl starts, and
 * PL_top_env points to this initially, so PL_top_env should always be
 * non-null.
 *
 * Existence of a non-null PL_top_env->je_prev implies it is valid to call
 * longjmp() at that runlevel (we make sure PL_start_env.je_prev is always
 * null to ensure this).
 *
 * je_mustcatch, when set at any runlevel to TRUE, means eval ops must
 * establish a local jmpenv to handle exception traps.  Care must be taken
 * to restore the previous value of je_mustcatch before exiting the
 * stack frame iff JMPENV_PUSH was not called in that stack frame.
 * GSAR 97-03-27
 */

struct jmpenv {
    struct jmpenv *	je_prev;
    Sigjmp_buf		je_buf;		/* uninit if je_prev is NULL */
    int			je_ret;		/* last exception thrown */
    bool		je_mustcatch;	/* need to call longjmp()? */
};

typedef struct jmpenv JMPENV;

/*
 * How to build the first jmpenv.
 *
 * top_env needs to be non-zero. It points to an area
 * in which longjmp() stuff is stored, as C callstack
 * info there at least is thread specific this has to
 * be per-thread. Otherwise a 'die' in a thread gives
 * that thread the C stack of last thread to do an eval {}!
 */

#define JMPENV_BOOTSTRAP \
    STMT_START {				\
	PERL_POISON_EXPR(PoisonNew(&PL_start_env, 1, JMPENV));\
	PL_top_env = &PL_start_env;		\
	PL_start_env.je_prev = NULL;		\
	PL_start_env.je_ret = -1;		\
	PL_start_env.je_mustcatch = TRUE;	\
    } STMT_END

/*
 *   PERL_FLEXIBLE_EXCEPTIONS
 * 
 * All the flexible exceptions code has been removed.
 * See the following threads for details:
 *
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2004-07/msg00378.html
 * 
 * Joshua's original patches (which weren't applied) and discussion:
 * 
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01396.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01489.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01491.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01608.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg02144.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg02998.html
 * 
 * Chip's reworked patch and discussion:
 * 
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1999-03/msg00520.html
 * 
 * The flaw in these patches (which went unnoticed at the time) was
 * that they moved some code that could potentially die() out of the
 * region protected by the setjmp()s.  This caused exceptions within
 * END blocks and such to not be handled by the correct setjmp().
 * 
 * The original patches that introduces flexible exceptions were:
 *
 * http://perl5.git.perl.org/perl.git/commit/312caa8e97f1c7ee342a9895c2f0e749625b4929
 * http://perl5.git.perl.org/perl.git/commit/14dd3ad8c9bf82cf09798a22cc89a9862dfd6d1a                                        
 *  
 */

#define dJMPENV		JMPENV cur_env

#define JMPENV_PUSH(v) \
    STMT_START {							\
	DEBUG_l({							\
	    int i = 0; JMPENV *p = PL_top_env;				\
	    while (p) { i++; p = p->je_prev; }				\
	    Perl_deb(aTHX_ "JUMPENV_PUSH level=%d at %s:%d\n",		\
		         i,  __FILE__, __LINE__);})			\
	cur_env.je_prev = PL_top_env;					\
	cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, SCOPE_SAVES_SIGNAL_MASK);		\
	PL_top_env = &cur_env;						\
	cur_env.je_mustcatch = FALSE;					\
	(v) = cur_env.je_ret;						\
    } STMT_END

#define JMPENV_POP \
    STMT_START {							\
	DEBUG_l({							\
	    int i = -1; JMPENV *p = PL_top_env;				\
	    while (p) { i++; p = p->je_prev; }				\
	    Perl_deb(aTHX_ "JUMPENV_POP level=%d at %s:%d\n",		\
		         i, __FILE__, __LINE__);})			\
	assert(PL_top_env == &cur_env);					\
	PL_top_env = cur_env.je_prev;					\
    } STMT_END

#define JMPENV_JUMP(v) \
    STMT_START {						\
	DEBUG_l({						\
	    int i = -1; JMPENV *p = PL_top_env;			\
	    while (p) { i++; p = p->je_prev; }			\
	    Perl_deb(aTHX_ "JUMPENV_JUMP(%d) level=%d at %s:%d\n", \
		         (int)v, i, __FILE__, __LINE__);})	\
	if (PL_top_env->je_prev)				\
	    PerlProc_longjmp(PL_top_env->je_buf, (v));		\
	if ((v) == 2)						\
	    PerlProc_exit(STATUS_EXIT);		                \
	PerlIO_printf(PerlIO_stderr(), "panic: top_env, v=%d\n", (int)v); \
	PerlProc_exit(1);					\
    } STMT_END

#define CATCH_GET		(PL_top_env->je_mustcatch)
#define CATCH_SET(v) \
    STMT_START {							\
	DEBUG_l(							\
	    Perl_deb(aTHX_						\
		"JUMPLEVEL set catch %d => %d (for %p) at %s:%d\n",	\
		 PL_top_env->je_mustcatch, v, (void*)PL_top_env,	\
		 __FILE__, __LINE__);)					\
	PL_top_env->je_mustcatch = (v);					\
    } STMT_END

/*
=head1 COP Hint Hashes
*/

typedef struct refcounted_he COPHH;

#define COPHH_KEY_UTF8 REFCOUNTED_HE_KEY_UTF8

/*
=for apidoc Amx|SV *|cophh_fetch_pvn|const COPHH *cophh|const char *keypv|STRLEN keylen|U32 hash|U32 flags

Look up the entry in the cop hints hash I<cophh> with the key specified by
I<keypv> and I<keylen>.  If I<flags> has the C<COPHH_KEY_UTF8> bit set,
the key octets are interpreted as UTF-8, otherwise they are interpreted
as Latin-1.  I<hash> is a precomputed hash of the key string, or zero if
it has not been precomputed.  Returns a mortal scalar copy of the value
associated with the key, or C<&PL_sv_placeholder> if there is no value
associated with the key.

=cut
*/

#define cophh_fetch_pvn(cophh, keypv, keylen, hash, flags) \
    Perl_refcounted_he_fetch_pvn(aTHX_ cophh, keypv, keylen, hash, flags)

/*
=for apidoc Amx|SV *|cophh_fetch_pvs|const COPHH *cophh|const char *key|U32 flags

Like L</cophh_fetch_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.

=cut
*/

#define cophh_fetch_pvs(cophh, key, flags) \
    Perl_refcounted_he_fetch_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, flags)

/*
=for apidoc Amx|SV *|cophh_fetch_pv|const COPHH *cophh|const char *key|U32 hash|U32 flags

Like L</cophh_fetch_pvn>, but takes a nul-terminated string instead of
a string/length pair.

=cut
*/

#define cophh_fetch_pv(cophh, key, hash, flags) \
    Perl_refcounted_he_fetch_pv(aTHX_ cophh, key, hash, flags)

/*
=for apidoc Amx|SV *|cophh_fetch_sv|const COPHH *cophh|SV *key|U32 hash|U32 flags

Like L</cophh_fetch_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

#define cophh_fetch_sv(cophh, key, hash, flags) \
    Perl_refcounted_he_fetch_sv(aTHX_ cophh, key, hash, flags)

/*
=for apidoc Amx|HV *|cophh_2hv|const COPHH *cophh|U32 flags

Generates and returns a standard Perl hash representing the full set of
key/value pairs in the cop hints hash I<cophh>.  I<flags> is currently
unused and must be zero.

=cut
*/

#define cophh_2hv(cophh, flags) \
    Perl_refcounted_he_chain_2hv(aTHX_ cophh, flags)

/*
=for apidoc Amx|COPHH *|cophh_copy|COPHH *cophh

Make and return a complete copy of the cop hints hash I<cophh>.

=cut
*/

#define cophh_copy(cophh) Perl_refcounted_he_inc(aTHX_ cophh)

/*
=for apidoc Amx|void|cophh_free|COPHH *cophh

Discard the cop hints hash I<cophh>, freeing all resources associated
with it.

=cut
*/

#define cophh_free(cophh) Perl_refcounted_he_free(aTHX_ cophh)

/*
=for apidoc Amx|COPHH *|cophh_new_empty

Generate and return a fresh cop hints hash containing no entries.

=cut
*/

#define cophh_new_empty() ((COPHH *)NULL)

/*
=for apidoc Amx|COPHH *|cophh_store_pvn|COPHH *cophh|const char *keypv|STRLEN keylen|U32 hash|SV *value|U32 flags

Stores a value, associated with a key, in the cop hints hash I<cophh>,
and returns the modified hash.  The returned hash pointer is in general
not the same as the hash pointer that was passed in.  The input hash is
consumed by the function, and the pointer to it must not be subsequently
used.  Use L</cophh_copy> if you need both hashes.

The key is specified by I<keypv> and I<keylen>.  If I<flags> has the
C<COPHH_KEY_UTF8> bit set, the key octets are interpreted as UTF-8,
otherwise they are interpreted as Latin-1.  I<hash> is a precomputed
hash of the key string, or zero if it has not been precomputed.

I<value> is the scalar value to store for this key.  I<value> is copied
by this function, which thus does not take ownership of any reference
to it, and later changes to the scalar will not be reflected in the
value visible in the cop hints hash.  Complex types of scalar will not
be stored with referential integrity, but will be coerced to strings.

=cut
*/

#define cophh_store_pvn(cophh, keypv, keylen, hash, value, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, keypv, keylen, hash, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_store_pvs|const COPHH *cophh|const char *key|SV *value|U32 flags

Like L</cophh_store_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.

=cut
*/

#define cophh_store_pvs(cophh, key, value, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_store_pv|const COPHH *cophh|const char *key|U32 hash|SV *value|U32 flags

Like L</cophh_store_pvn>, but takes a nul-terminated string instead of
a string/length pair.

=cut
*/

#define cophh_store_pv(cophh, key, hash, value, flags) \
    Perl_refcounted_he_new_pv(aTHX_ cophh, key, hash, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_store_sv|const COPHH *cophh|SV *key|U32 hash|SV *value|U32 flags

Like L</cophh_store_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

#define cophh_store_sv(cophh, key, hash, value, flags) \
    Perl_refcounted_he_new_sv(aTHX_ cophh, key, hash, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_pvn|COPHH *cophh|const char *keypv|STRLEN keylen|U32 hash|U32 flags

Delete a key and its associated value from the cop hints hash I<cophh>,
and returns the modified hash.  The returned hash pointer is in general
not the same as the hash pointer that was passed in.  The input hash is
consumed by the function, and the pointer to it must not be subsequently
used.  Use L</cophh_copy> if you need both hashes.

The key is specified by I<keypv> and I<keylen>.  If I<flags> has the
C<COPHH_KEY_UTF8> bit set, the key octets are interpreted as UTF-8,
otherwise they are interpreted as Latin-1.  I<hash> is a precomputed
hash of the key string, or zero if it has not been precomputed.

=cut
*/

#define cophh_delete_pvn(cophh, keypv, keylen, hash, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, keypv, keylen, hash, \
	(SV *)NULL, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_pvs|const COPHH *cophh|const char *key|U32 flags

Like L</cophh_delete_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.

=cut
*/

#define cophh_delete_pvs(cophh, key, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, \
	(SV *)NULL, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_pv|const COPHH *cophh|const char *key|U32 hash|U32 flags

Like L</cophh_delete_pvn>, but takes a nul-terminated string instead of
a string/length pair.

=cut
*/

#define cophh_delete_pv(cophh, key, hash, flags) \
    Perl_refcounted_he_new_pv(aTHX_ cophh, key, hash, (SV *)NULL, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_sv|const COPHH *cophh|SV *key|U32 hash|U32 flags

Like L</cophh_delete_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

#define cophh_delete_sv(cophh, key, hash, flags) \
    Perl_refcounted_he_new_sv(aTHX_ cophh, key, hash, (SV *)NULL, flags)

#include "mydtrace.h"

struct cop {
    BASEOP
    /* On LP64 putting this here takes advantage of the fact that BASEOP isn't
       an exact multiple of 8 bytes to save structure padding.  */
    line_t      cop_line;       /* line # of this command */
    /* label for this construct is now stored in cop_hints_hash */
#ifdef USE_ITHREADS
    PADOFFSET	cop_stashoff;	/* offset into PL_stashpad, for the
				   package the line was compiled in */
    char *	cop_file;	/* file name the following line # is from */
#else
    HV *	cop_stash;	/* package line was compiled in */
    GV *	cop_filegv;	/* file the following line # is from */
#endif
    U32		cop_hints;	/* hints bits from pragmata */
    U32		cop_seq;	/* parse sequence number */
    /* Beware. mg.c and warnings.pl assume the type of this is STRLEN *:  */
    STRLEN *	cop_warnings;	/* lexical warnings bitmask */
    /* compile time state of %^H.  See the comment in op.c for how this is
       used to recreate a hash to return from caller.  */
    COPHH *	cop_hints_hash;
};

#ifdef USE_ITHREADS
#  define CopFILE(c)		((c)->cop_file)
#  define CopFILEGV(c)		(CopFILE(c) \
				 ? gv_fetchfile(CopFILE(c)) : NULL)
				 
#  ifdef NETWARE
#    define CopFILE_set(c,pv)	((c)->cop_file = savepv(pv))
#    define CopFILE_setn(c,pv,l)  ((c)->cop_file = savepvn((pv),(l)))
#  else
#    define CopFILE_set(c,pv)	((c)->cop_file = savesharedpv(pv))
#    define CopFILE_setn(c,pv,l)  ((c)->cop_file = savesharedpvn((pv),(l)))
#  endif

#  define CopFILESV(c)		(CopFILE(c) \
				 ? GvSV(gv_fetchfile(CopFILE(c))) : NULL)
#  define CopFILEAV(c)		(CopFILE(c) \
				 ? GvAV(gv_fetchfile(CopFILE(c))) : NULL)
#  define CopFILEAVx(c)		(assert_(CopFILE(c)) \
				   GvAV(gv_fetchfile(CopFILE(c))))

#  define CopSTASH(c)           PL_stashpad[(c)->cop_stashoff]
#  define CopSTASH_set(c,hv)	((c)->cop_stashoff = (hv)		\
				    ? alloccopstash(hv)			\
				    : 0)
#  ifdef NETWARE
#    define CopFILE_free(c) SAVECOPFILE_FREE(c)
#  else
#    define CopFILE_free(c)	(PerlMemShared_free(CopFILE(c)),(CopFILE(c) = NULL))
#  endif
#else
#  define CopFILEGV(c)		((c)->cop_filegv)
#  define CopFILEGV_set(c,gv)	((c)->cop_filegv = (GV*)SvREFCNT_inc(gv))
#  define CopFILE_set(c,pv)	CopFILEGV_set((c), gv_fetchfile(pv))
#  define CopFILE_setn(c,pv,l)	CopFILEGV_set((c), gv_fetchfile_flags((pv),(l),0))
#  define CopFILESV(c)		(CopFILEGV(c) ? GvSV(CopFILEGV(c)) : NULL)
#  define CopFILEAV(c)		(CopFILEGV(c) ? GvAV(CopFILEGV(c)) : NULL)
#  ifdef DEBUGGING
#    define CopFILEAVx(c)	(assert(CopFILEGV(c)), GvAV(CopFILEGV(c)))
#  else
#    define CopFILEAVx(c)	(GvAV(CopFILEGV(c)))
# endif
#  define CopFILE(c)		(CopFILEGV(c) \
				    ? GvNAME(CopFILEGV(c))+2 : NULL)
#  define CopSTASH(c)		((c)->cop_stash)
#  define CopSTASH_set(c,hv)	((c)->cop_stash = (hv))
#  define CopFILE_free(c)	(SvREFCNT_dec(CopFILEGV(c)),(CopFILEGV(c) = NULL))

#endif /* USE_ITHREADS */

#define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME_get(CopSTASH(c)) : NULL)
   /* cop_stash is not refcounted */
#define CopSTASHPV_set(c,pv)	CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
#define CopSTASH_eq(c,hv)	(CopSTASH(c) == (hv))

#define CopHINTHASH_get(c)	((COPHH*)((c)->cop_hints_hash))
#define CopHINTHASH_set(c,h)	((c)->cop_hints_hash = (h))

/*
=head1 COP Hint Reading
*/

/*
=for apidoc Am|SV *|cop_hints_fetch_pvn|const COP *cop|const char *keypv|STRLEN keylen|U32 hash|U32 flags

Look up the hint entry in the cop I<cop> with the key specified by
I<keypv> and I<keylen>.  If I<flags> has the C<COPHH_KEY_UTF8> bit set,
the key octets are interpreted as UTF-8, otherwise they are interpreted
as Latin-1.  I<hash> is a precomputed hash of the key string, or zero if
it has not been precomputed.  Returns a mortal scalar copy of the value
associated with the key, or C<&PL_sv_placeholder> if there is no value
associated with the key.

=cut
*/

#define cop_hints_fetch_pvn(cop, keypv, keylen, hash, flags) \
    cophh_fetch_pvn(CopHINTHASH_get(cop), keypv, keylen, hash, flags)

/*
=for apidoc Am|SV *|cop_hints_fetch_pvs|const COP *cop|const char *key|U32 flags

Like L</cop_hints_fetch_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.

=cut
*/

#define cop_hints_fetch_pvs(cop, key, flags) \
    cophh_fetch_pvs(CopHINTHASH_get(cop), key, flags)

/*
=for apidoc Am|SV *|cop_hints_fetch_pv|const COP *cop|const char *key|U32 hash|U32 flags

Like L</cop_hints_fetch_pvn>, but takes a nul-terminated string instead
of a string/length pair.

=cut
*/

#define cop_hints_fetch_pv(cop, key, hash, flags) \
    cophh_fetch_pv(CopHINTHASH_get(cop), key, hash, flags)

/*
=for apidoc Am|SV *|cop_hints_fetch_sv|const COP *cop|SV *key|U32 hash|U32 flags

Like L</cop_hints_fetch_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

#define cop_hints_fetch_sv(cop, key, hash, flags) \
    cophh_fetch_sv(CopHINTHASH_get(cop), key, hash, flags)

/*
=for apidoc Am|HV *|cop_hints_2hv|const COP *cop|U32 flags

Generates and returns a standard Perl hash representing the full set of
hint entries in the cop I<cop>.  I<flags> is currently unused and must
be zero.

=cut
*/

#define cop_hints_2hv(cop, flags) \
    cophh_2hv(CopHINTHASH_get(cop), flags)

#define CopLABEL(c)  Perl_cop_fetch_label(aTHX_ (c), NULL, NULL)
#define CopLABEL_len(c,len)  Perl_cop_fetch_label(aTHX_ (c), len, NULL)
#define CopLABEL_len_flags(c,len,flags)  Perl_cop_fetch_label(aTHX_ (c), len, flags)
#define CopLABEL_alloc(pv)	((pv)?savepv(pv):NULL)

#define CopSTASH_ne(c,hv)	(!CopSTASH_eq(c,hv))
#define CopLINE(c)		((c)->cop_line)
#define CopLINE_inc(c)		(++CopLINE(c))
#define CopLINE_dec(c)		(--CopLINE(c))
#define CopLINE_set(c,l)	(CopLINE(c) = (l))

/* OutCopFILE() is CopFILE for output (caller, die, warn, etc.) */
#define OutCopFILE(c) CopFILE(c)

#define CopHINTS_get(c)		((c)->cop_hints + 0)
#define CopHINTS_set(c, h)	STMT_START {				\
				    (c)->cop_hints = (h);		\
				} STMT_END

/*
 * Here we have some enormously heavy (or at least ponderous) wizardry.
 */

/* subroutine context */
struct block_sub {
    OP *	retop;	/* op to execute on exit from sub */
    /* Above here is the same for sub, format and eval.  */
    CV *	cv;
    /* Above here is the same for sub and format.  */
    AV *	savearray;
    AV *	argarray;
    I32		olddepth;
    PAD		*oldcomppad;
};


/* format context */
struct block_format {
    OP *	retop;	/* op to execute on exit from sub */
    /* Above here is the same for sub, format and eval.  */
    CV *	cv;
    /* Above here is the same for sub and format.  */
    GV *	gv;
    GV *	dfoutgv;
};

/* base for the next two macros. Don't use directly.
 * Note that the refcnt of the cv is incremented twice;  The CX one is
 * decremented by LEAVESUB, the other by LEAVE. */

#define PUSHSUB_BASE(cx)						\
	ENTRY_PROBE(CvNAMED(cv)						\
			? HEK_KEY(CvNAME_HEK(cv))			\
			: GvENAME(CvGV(cv)),	       			\
		CopFILE((const COP *)CvSTART(cv)),			\
		CopLINE((const COP *)CvSTART(cv)),			\
		CopSTASHPV((const COP *)CvSTART(cv)));			\
									\
	cx->blk_sub.cv = cv;						\
	cx->blk_sub.olddepth = CvDEPTH(cv);				\
	cx->cx_type |= (hasargs) ? CXp_HASARGS : 0;			\
	cx->blk_sub.retop = NULL;					\
	if (!CvDEPTH(cv)) {						\
	    SvREFCNT_inc_simple_void_NN(cv);				\
	    SvREFCNT_inc_simple_void_NN(cv);				\
	    SAVEFREESV(cv);						\
	}

#define PUSHSUB_GET_LVALUE_MASK(func) \
	/* If the context is indeterminate, then only the lvalue */	\
	/* flags that the caller also has are applicable.        */	\
	(								\
	   (PL_op->op_flags & OPf_WANT)					\
	       ? OPpENTERSUB_LVAL_MASK					\
	       : !(PL_op->op_private & OPpENTERSUB_LVAL_MASK)		\
	           ? 0 : (U8)func(aTHX)					\
	)

#define PUSHSUB(cx)							\
    {									\
	U8 phlags = PUSHSUB_GET_LVALUE_MASK(Perl_was_lvalue_sub);	\
	PUSHSUB_BASE(cx)						\
	cx->blk_u16 = PL_op->op_private &				\
	                  (phlags|OPpDEREF);				\
    }

/* variant for use by OP_DBSTATE, where op_private holds hint bits */
#define PUSHSUB_DB(cx)							\
	PUSHSUB_BASE(cx)						\
	cx->blk_u16 = 0;


#define PUSHFORMAT(cx, retop)						\
	cx->blk_format.cv = cv;						\
	cx->blk_format.gv = gv;						\
	cx->blk_format.retop = (retop);					\
	cx->blk_format.dfoutgv = PL_defoutgv;				\
	cx->blk_u16 = 0;                                                \
	if (!CvDEPTH(cv)) SvREFCNT_inc_simple_void_NN(cv);		\
	CvDEPTH(cv)++;							\
	SvREFCNT_inc_void(cx->blk_format.dfoutgv)

#define POP_SAVEARRAY()						\
    STMT_START {							\
	SvREFCNT_dec(GvAV(PL_defgv));					\
	GvAV(PL_defgv) = cx->blk_sub.savearray;				\
    } STMT_END

/* junk in @_ spells trouble when cloning CVs and in pp_caller(), so don't
 * leave any (a fast av_clear(ary), basically) */
#define CLEAR_ARGARRAY(ary) \
    STMT_START {							\
	AvMAX(ary) += AvARRAY(ary) - AvALLOC(ary);			\
	AvARRAY(ary) = AvALLOC(ary);					\
	AvFILLp(ary) = -1;						\
    } STMT_END

#define POPSUB(cx,sv)							\
    STMT_START {							\
	const I32 olddepth = cx->blk_sub.olddepth;			\
        if (!(cx->blk_u16 & CxPOPSUB_DONE)) {                           \
        cx->blk_u16 |= CxPOPSUB_DONE;                                   \
	RETURN_PROBE(CvNAMED(cx->blk_sub.cv)				\
			? HEK_KEY(CvNAME_HEK(cx->blk_sub.cv))		\
			: GvENAME(CvGV(cx->blk_sub.cv)),		\
		CopFILE((COP*)CvSTART((const CV*)cx->blk_sub.cv)),	\
		CopLINE((COP*)CvSTART((const CV*)cx->blk_sub.cv)),	\
		CopSTASHPV((COP*)CvSTART((const CV*)cx->blk_sub.cv)));	\
									\
	if (CxHASARGS(cx)) {						\
	    POP_SAVEARRAY();						\
	    /* abandon @_ if it got reified */				\
	    if (AvREAL(cx->blk_sub.argarray)) {				\
		const SSize_t fill = AvFILLp(cx->blk_sub.argarray);	\
		SvREFCNT_dec_NN(cx->blk_sub.argarray);			\
		cx->blk_sub.argarray = newAV();				\
		av_extend(cx->blk_sub.argarray, fill);			\
		AvREIFY_only(cx->blk_sub.argarray);			\
		CX_CURPAD_SV(cx->blk_sub, 0) = MUTABLE_SV(cx->blk_sub.argarray); \
	    }								\
	    else {							\
		CLEAR_ARGARRAY(cx->blk_sub.argarray);			\
	    }								\
	}								\
        }                                                               \
	sv = MUTABLE_SV(cx->blk_sub.cv);				\
	LEAVE_SCOPE(PL_scopestack[cx->blk_oldscopesp-1]);		\
	if (sv && (CvDEPTH((const CV*)sv) = olddepth))			\
	    sv = NULL;						\
    } STMT_END

#define LEAVESUB(sv)							\
    STMT_START {							\
	SvREFCNT_dec(sv);						\
    } STMT_END

#define POPFORMAT(cx)							\
    STMT_START {							\
        if (!(cx->blk_u16 & CxPOPSUB_DONE)) {                           \
	CV * const cv = cx->blk_format.cv;				\
	GV * const dfuot = cx->blk_format.dfoutgv;			\
        cx->blk_u16 |= CxPOPSUB_DONE;                                   \
	setdefout(dfuot);						\
	LEAVE_SCOPE(PL_scopestack[cx->blk_oldscopesp-1]);		\
	if (!--CvDEPTH(cv))						\
	    SvREFCNT_dec_NN(cx->blk_format.cv);				\
	SvREFCNT_dec_NN(dfuot);						\
        }                                                               \
    } STMT_END

/* eval context */
struct block_eval {
    OP *	retop;	/* op to execute on exit from eval */
    /* Above here is the same for sub, format and eval.  */
    SV *	old_namesv;
    OP *	old_eval_root;
    SV *	cur_text;
    CV *	cv;
    JMPENV *	cur_top_env; /* value of PL_top_env when eval CX created */
};

/* If we ever need more than 512 op types, change the shift from 7.
   blku_gimme is actually also only 2 bits, so could be merged with something.
*/

#define CxOLD_IN_EVAL(cx)	(((cx)->blk_u16) & 0x7F)
#define CxOLD_OP_TYPE(cx)	(((cx)->blk_u16) >> 7)

#define PUSHEVAL(cx,n)							\
    STMT_START {							\
	assert(!(PL_in_eval & ~0x7F));					\
	assert(!(PL_op->op_type & ~0x1FF));				\
	cx->blk_u16 = (PL_in_eval & 0x7F) | ((U16)PL_op->op_type << 7);	\
	cx->blk_eval.old_namesv = (n ? newSVpv(n,0) : NULL);		\
	cx->blk_eval.old_eval_root = PL_eval_root;			\
	cx->blk_eval.cur_text = PL_parser ? PL_parser->linestr : NULL;	\
	cx->blk_eval.cv = NULL; /* set by doeval(), as applicable */	\
	cx->blk_eval.retop = NULL;					\
	cx->blk_eval.cur_top_env = PL_top_env; 				\
    } STMT_END

#define POPEVAL(cx)							\
    STMT_START {							\
	PL_in_eval = CxOLD_IN_EVAL(cx);					\
	optype = CxOLD_OP_TYPE(cx);					\
	PL_eval_root = cx->blk_eval.old_eval_root;			\
	if (cx->blk_eval.cur_text && SvSCREAM(cx->blk_eval.cur_text))	\
	    SvREFCNT_dec_NN(cx->blk_eval.cur_text);			\
	if (cx->blk_eval.old_namesv)					\
	    sv_2mortal(cx->blk_eval.old_namesv);			\
    } STMT_END

/* loop context */
struct block_loop {
    I32		resetsp;
    LOOP *	my_op;	/* My op, that contains redo, next and last ops.  */
    union {	/* different ways of locating the iteration variable */
	SV      **svp;
	GV      *gv;
	PAD     *oldcomppad; /* only used in ITHREADS */
    } itervar_u;
    union {
	struct { /* valid if type is LOOP_FOR or LOOP_PLAIN (but {NULL,0})*/
	    AV * ary; /* use the stack if this is NULL */
	    IV ix;
	} ary;
	struct { /* valid if type is LOOP_LAZYIV */
	    IV cur;
	    IV end;
	} lazyiv;
	struct { /* valid if type if LOOP_LAZYSV */
	    SV * cur;
	    SV * end; /* maxiumum value (or minimum in reverse) */
	} lazysv;
    } state_u;
};

#ifdef USE_ITHREADS
#  define CxITERVAR_PADSV(c) \
	&CX_CURPAD_SV( (c)->blk_loop.itervar_u, (c)->blk_loop.my_op->op_targ)
#else
#  define CxITERVAR_PADSV(c) ((c)->blk_loop.itervar_u.svp)
#endif

#define CxITERVAR(c)							\
	((c)->blk_loop.itervar_u.oldcomppad				\
	 ? (CxPADLOOP(c) 						\
	    ? CxITERVAR_PADSV(c)					\
	    : &GvSV((c)->blk_loop.itervar_u.gv))			\
	 : (SV**)NULL)

#define CxLABEL(c)	(0 + CopLABEL((c)->blk_oldcop))
#define CxLABEL_len(c,len)	(0 + CopLABEL_len((c)->blk_oldcop, len))
#define CxLABEL_len_flags(c,len,flags)	(0 + CopLABEL_len_flags((c)->blk_oldcop, len, flags))
#define CxHASARGS(c)	(((c)->cx_type & CXp_HASARGS) == CXp_HASARGS)
#define CxLVAL(c)	(0 + ((c)->blk_u16 & 0xff))
/* POPSUB has already been performed on this context frame */
#define CxPOPSUB_DONE 0x100


#define PUSHLOOP_PLAIN(cx, s)						\
	cx->blk_loop.resetsp = s - PL_stack_base;			\
	cx->blk_loop.my_op = cLOOP;					\
	cx->blk_loop.state_u.ary.ary = NULL;				\
	cx->blk_loop.state_u.ary.ix = 0;				\
	cx->blk_loop.itervar_u.svp = NULL;

#define PUSHLOOP_FOR(cx, ivar, s)					\
	cx->blk_loop.resetsp = s - PL_stack_base;			\
	cx->blk_loop.my_op = cLOOP;					\
	cx->blk_loop.state_u.ary.ary = NULL;				\
	cx->blk_loop.state_u.ary.ix = 0;				\
	cx->blk_loop.itervar_u.svp = (SV**)(ivar);

#define POPLOOP(cx)							\
	if (CxTYPE(cx) == CXt_LOOP_LAZYSV) {				\
	    SvREFCNT_dec_NN(cx->blk_loop.state_u.lazysv.cur);		\
	    SvREFCNT_dec_NN(cx->blk_loop.state_u.lazysv.end);		\
	}								\
	if (CxTYPE(cx) == CXt_LOOP_FOR)					\
	    SvREFCNT_dec(cx->blk_loop.state_u.ary.ary);

/* given/when context */
struct block_givwhen {
	OP *leave_op;
};

#define PUSHGIVEN(cx)							\
	cx->blk_givwhen.leave_op = cLOGOP->op_other;

#define PUSHWHEN PUSHGIVEN

/* context common to subroutines, evals and loops */
struct block {
    U8		blku_type;	/* what kind of context this is */
    U8		blku_gimme;	/* is this block running in list context? */
    U16		blku_u16;	/* used by block_sub and block_eval (so far) */
    I32		blku_oldsp;	/* stack pointer to copy stuff down to */
    COP *	blku_oldcop;	/* old curcop pointer */
    I32		blku_oldmarksp;	/* mark stack index */
    I32		blku_oldscopesp;	/* scope stack index */
    PMOP *	blku_oldpm;	/* values of pattern match vars */

    union {
	struct block_sub	blku_sub;
	struct block_format	blku_format;
	struct block_eval	blku_eval;
	struct block_loop	blku_loop;
	struct block_givwhen	blku_givwhen;
    } blk_u;
};
#define blk_oldsp	cx_u.cx_blk.blku_oldsp
#define blk_oldcop	cx_u.cx_blk.blku_oldcop
#define blk_oldmarksp	cx_u.cx_blk.blku_oldmarksp
#define blk_oldscopesp	cx_u.cx_blk.blku_oldscopesp
#define blk_oldpm	cx_u.cx_blk.blku_oldpm
#define blk_gimme	cx_u.cx_blk.blku_gimme
#define blk_u16		cx_u.cx_blk.blku_u16
#define blk_sub		cx_u.cx_blk.blk_u.blku_sub
#define blk_format	cx_u.cx_blk.blk_u.blku_format
#define blk_eval	cx_u.cx_blk.blk_u.blku_eval
#define blk_loop	cx_u.cx_blk.blk_u.blku_loop
#define blk_givwhen	cx_u.cx_blk.blk_u.blku_givwhen

#define DEBUG_CX(action)						\
    DEBUG_l(								\
	Perl_deb(aTHX_ "CX %ld %s %s (scope %ld,%ld) at %s:%d\n",	\
		    (long)cxstack_ix,					\
		    action,						\
		    PL_block_type[CxTYPE(&cxstack[cxstack_ix])],	\
		    (long)PL_scopestack_ix,				\
		    (long)(cxstack[cxstack_ix].blk_oldscopesp),		\
		    __FILE__, __LINE__));

/* Enter a block. */
#define PUSHBLOCK(cx,t,sp) CXINC, cx = &cxstack[cxstack_ix],		\
	cx->cx_type		= t,					\
	cx->blk_oldsp		= sp - PL_stack_base,			\
	cx->blk_oldcop		= PL_curcop,				\
	cx->blk_oldmarksp	= PL_markstack_ptr - PL_markstack,	\
	cx->blk_oldscopesp	= PL_scopestack_ix,			\
	cx->blk_oldpm		= PL_curpm,				\
	cx->blk_gimme		= (U8)gimme;				\
	DEBUG_CX("PUSH");

/* Exit a block (RETURN and LAST). */
#define POPBLOCK(cx,pm)							\
	DEBUG_CX("POP");						\
	cx = &cxstack[cxstack_ix--],					\
	newsp		 = PL_stack_base + cx->blk_oldsp,		\
	PL_curcop	 = cx->blk_oldcop,				\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	pm		 = cx->blk_oldpm,				\
	gimme		 = cx->blk_gimme;

/* Continue a block elsewhere (NEXT and REDO). */
#define TOPBLOCK(cx)							\
	DEBUG_CX("TOP");						\
	cx  = &cxstack[cxstack_ix],					\
	PL_stack_sp	 = PL_stack_base + cx->blk_oldsp,		\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	PL_curpm         = cx->blk_oldpm;

/* substitution context */
struct subst {
    U8		sbu_type;	/* what kind of context this is */
    U8		sbu_rflags;
    U16		sbu_rxtainted;	/* matches struct block */
    I32		sbu_iters;
    I32		sbu_maxiters;
    I32		sbu_oldsave;
    char *	sbu_orig;
    SV *	sbu_dstr;
    SV *	sbu_targ;
    char *	sbu_s;
    char *	sbu_m;
    char *	sbu_strend;
    void *	sbu_rxres;
    REGEXP *	sbu_rx;
};
#define sb_iters	cx_u.cx_subst.sbu_iters
#define sb_maxiters	cx_u.cx_subst.sbu_maxiters
#define sb_rflags	cx_u.cx_subst.sbu_rflags
#define sb_oldsave	cx_u.cx_subst.sbu_oldsave
#define sb_rxtainted	cx_u.cx_subst.sbu_rxtainted
#define sb_orig		cx_u.cx_subst.sbu_orig
#define sb_dstr		cx_u.cx_subst.sbu_dstr
#define sb_targ		cx_u.cx_subst.sbu_targ
#define sb_s		cx_u.cx_subst.sbu_s
#define sb_m		cx_u.cx_subst.sbu_m
#define sb_strend	cx_u.cx_subst.sbu_strend
#define sb_rxres	cx_u.cx_subst.sbu_rxres
#define sb_rx		cx_u.cx_subst.sbu_rx

#ifdef PERL_CORE
#  define PUSHSUBST(cx) CXINC, cx = &cxstack[cxstack_ix],		\
	cx->sb_iters		= iters,				\
	cx->sb_maxiters		= maxiters,				\
	cx->sb_rflags		= r_flags,				\
	cx->sb_oldsave		= oldsave,				\
	cx->sb_rxtainted	= rxtainted,				\
	cx->sb_orig		= orig,					\
	cx->sb_dstr		= dstr,					\
	cx->sb_targ		= targ,					\
	cx->sb_s		= s,					\
	cx->sb_m		= m,					\
	cx->sb_strend		= strend,				\
	cx->sb_rxres		= NULL,					\
	cx->sb_rx		= rx,					\
	cx->cx_type		= CXt_SUBST | (once ? CXp_ONCE : 0);	\
	rxres_save(&cx->sb_rxres, rx);					\
	(void)ReREFCNT_inc(rx)

#  define POPSUBST(cx) cx = &cxstack[cxstack_ix--];			\
	rxres_free(&cx->sb_rxres);					\
	ReREFCNT_dec(cx->sb_rx)
#endif

#define CxONCE(cx)		((cx)->cx_type & CXp_ONCE)

struct context {
    union {
	struct block	cx_blk;
	struct subst	cx_subst;
    } cx_u;
};
#define cx_type cx_u.cx_subst.sbu_type

/* If you re-order these, there is also an array of uppercase names in perl.h
   and a static array of context names in pp_ctl.c  */
#define CXTYPEMASK	0xf
#define CXt_NULL	0
#define CXt_WHEN	1
#define CXt_BLOCK	2
/* When micro-optimising :-) keep GIVEN next to the LOOPs, as these 5 share a
   jump table in pp_ctl.c
   The first 4 don't have a 'case' in at least one switch statement in pp_ctl.c
*/
#define CXt_GIVEN	3
/* This is first so that CXt_LOOP_FOR|CXt_LOOP_LAZYIV is CXt_LOOP_LAZYIV */
#define CXt_LOOP_FOR	4
#define CXt_LOOP_PLAIN	5
#define CXt_LOOP_LAZYSV	6
#define CXt_LOOP_LAZYIV	7
#define CXt_SUB		8
#define CXt_FORMAT      9
#define CXt_EVAL       10
#define CXt_SUBST      11
/* SUBST doesn't feature in all switch statements.  */

/* private flags for CXt_SUB and CXt_NULL
   However, this is checked in many places which do not check the type, so
   this bit needs to be kept clear for most everything else. For reasons I
   haven't investigated, it can coexist with CXp_FOR_DEF */
#define CXp_MULTICALL	0x10	/* part of a multicall (so don't
				   tear down context on exit). */ 

/* private flags for CXt_SUB and CXt_FORMAT */
#define CXp_HASARGS	0x20
#define CXp_SUB_RE	0x40    /* code called within regex, i.e. (?{}) */
#define CXp_SUB_RE_FAKE	0x80    /* fake sub CX for (?{}) in current scope */

/* private flags for CXt_EVAL */
#define CXp_REAL	0x20	/* truly eval'', not a lookalike */
#define CXp_TRYBLOCK	0x40	/* eval{}, not eval'' or similar */

/* private flags for CXt_LOOP */
#define CXp_FOR_DEF	0x10	/* foreach using $_ */
#define CxPADLOOP(c)	((c)->blk_loop.my_op->op_targ)

/* private flags for CXt_SUBST */
#define CXp_ONCE	0x10	/* What was sbu_once in struct subst */

#define CxTYPE(c)	((c)->cx_type & CXTYPEMASK)
#define CxTYPE_is_LOOP(c)	(((c)->cx_type & 0xC) == 0x4)
#define CxMULTICALL(c)	(((c)->cx_type & CXp_MULTICALL)			\
			 == CXp_MULTICALL)
#define CxREALEVAL(c)	(((c)->cx_type & (CXTYPEMASK|CXp_REAL))		\
			 == (CXt_EVAL|CXp_REAL))
#define CxTRYBLOCK(c)	(((c)->cx_type & (CXTYPEMASK|CXp_TRYBLOCK))	\
			 == (CXt_EVAL|CXp_TRYBLOCK))
#define CxFOREACH(c)	(CxTYPE_is_LOOP(c) && CxTYPE(c) != CXt_LOOP_PLAIN)
#define CxFOREACHDEF(c)	((CxTYPE_is_LOOP(c) && CxTYPE(c) != CXt_LOOP_PLAIN) \
			 && ((c)->cx_type & CXp_FOR_DEF))

#define CXINC (cxstack_ix < cxstack_max ? ++cxstack_ix : (cxstack_ix = cxinc()))

/* 
=head1 "Gimme" Values
*/

/*
=for apidoc AmU||G_SCALAR
Used to indicate scalar context.  See C<GIMME_V>, C<GIMME>, and
L<perlcall>.

=for apidoc AmU||G_ARRAY
Used to indicate list context.  See C<GIMME_V>, C<GIMME> and
L<perlcall>.

=for apidoc AmU||G_VOID
Used to indicate void context.  See C<GIMME_V> and L<perlcall>.

=for apidoc AmU||G_DISCARD
Indicates that arguments returned from a callback should be discarded.  See
L<perlcall>.

=for apidoc AmU||G_EVAL

Used to force a Perl C<eval> wrapper around a callback.  See
L<perlcall>.

=for apidoc AmU||G_NOARGS

Indicates that no arguments are being sent to a callback.  See
L<perlcall>.

=cut
*/

#define G_SCALAR	2
#define G_ARRAY		3
#define G_VOID		1
#define G_WANT		3

/* extra flags for Perl_call_* routines */
#define G_DISCARD	4	/* Call FREETMPS.
				   Don't change this without consulting the
				   hash actions codes defined in hv.h */
#define G_EVAL		8	/* Assume eval {} around subroutine call. */
#define G_NOARGS       16	/* Don't construct a @_ array. */
#define G_KEEPERR      32	/* Warn for errors, don't overwrite $@ */
#define G_NODEBUG      64	/* Disable debugging at toplevel.  */
#define G_METHOD      128       /* Calling method. */
#define G_FAKINGEVAL  256	/* Faking an eval context for call_sv or
				   fold_constants. */
#define G_UNDEF_FILL  512	/* Fill the stack with &PL_sv_undef
				   A special case for UNSHIFT in
				   Perl_magic_methcall().  */
#define G_WRITING_TO_STDERR 1024 /* Perl_write_to_stderr() is calling
				    Perl_magic_methcall().  */
#define G_RE_REPARSING 0x800     /* compiling a run-time /(?{..})/ */
#define G_METHOD_NAMED 4096	/* calling named method, eg without :: or ' */

/* flag bits for PL_in_eval */
#define EVAL_NULL	0	/* not in an eval */
#define EVAL_INEVAL	1	/* some enclosing scope is an eval */
#define EVAL_WARNONLY	2	/* used by yywarn() when calling yyerror() */
#define EVAL_KEEPERR	4	/* set by Perl_call_sv if G_KEEPERR */
#define EVAL_INREQUIRE	8	/* The code is being required. */
#define EVAL_RE_REPARSING 0x10	/* eval_sv() called with G_RE_REPARSING */

/* Support for switching (stack and block) contexts.
 * This ensures magic doesn't invalidate local stack and cx pointers.
 */

#define PERLSI_UNKNOWN		-1
#define PERLSI_UNDEF		0
#define PERLSI_MAIN		1
#define PERLSI_MAGIC		2
#define PERLSI_SORT		3
#define PERLSI_SIGNAL		4
#define PERLSI_OVERLOAD		5
#define PERLSI_DESTROY		6
#define PERLSI_WARNHOOK		7
#define PERLSI_DIEHOOK		8
#define PERLSI_REQUIRE		9

struct stackinfo {
    AV *		si_stack;	/* stack for current runlevel */
    PERL_CONTEXT *	si_cxstack;	/* context stack for runlevel */
    struct stackinfo *	si_prev;
    struct stackinfo *	si_next;
    I32			si_cxix;	/* current context index */
    I32			si_cxmax;	/* maximum allocated index */
    I32			si_type;	/* type of runlevel */
    I32			si_markoff;	/* offset where markstack begins for us.
					 * currently used only with DEBUGGING,
					 * but not #ifdef-ed for bincompat */
};

typedef struct stackinfo PERL_SI;

#define cxstack		(PL_curstackinfo->si_cxstack)
#define cxstack_ix	(PL_curstackinfo->si_cxix)
#define cxstack_max	(PL_curstackinfo->si_cxmax)

#ifdef DEBUGGING
#  define	SET_MARK_OFFSET \
    PL_curstackinfo->si_markoff = PL_markstack_ptr - PL_markstack
#else
#  define	SET_MARK_OFFSET NOOP
#endif

#define PUSHSTACKi(type) \
    STMT_START {							\
	PERL_SI *next = PL_curstackinfo->si_next;			\
	DEBUG_l({							\
	    int i = 0; PERL_SI *p = PL_curstackinfo;			\
	    while (p) { i++; p = p->si_prev; }				\
	    Perl_deb(aTHX_ "push STACKINFO %d at %s:%d\n",		\
		         i, __FILE__, __LINE__);})			\
	if (!next) {							\
	    next = new_stackinfo(32, 2048/sizeof(PERL_CONTEXT) - 1);	\
	    next->si_prev = PL_curstackinfo;				\
	    PL_curstackinfo->si_next = next;				\
	}								\
	next->si_type = type;						\
	next->si_cxix = -1;						\
	AvFILLp(next->si_stack) = 0;					\
	SWITCHSTACK(PL_curstack,next->si_stack);			\
	PL_curstackinfo = next;						\
	SET_MARK_OFFSET;						\
    } STMT_END

#define PUSHSTACK PUSHSTACKi(PERLSI_UNKNOWN)

/* POPSTACK works with PL_stack_sp, so it may need to be bracketed by
 * PUTBACK/SPAGAIN to flush/refresh any local SP that may be active */
#define POPSTACK \
    STMT_START {							\
	dSP;								\
	PERL_SI * const prev = PL_curstackinfo->si_prev;		\
	DEBUG_l({							\
	    int i = -1; PERL_SI *p = PL_curstackinfo;			\
	    while (p) { i++; p = p->si_prev; }				\
	    Perl_deb(aTHX_ "pop  STACKINFO %d at %s:%d\n",		\
		         i, __FILE__, __LINE__);})			\
	if (!prev) {							\
	    Perl_croak_popstack();					\
	}								\
	SWITCHSTACK(PL_curstack,prev->si_stack);			\
	/* don't free prev here, free them all at the END{} */		\
	PL_curstackinfo = prev;						\
    } STMT_END

#define POPSTACK_TO(s) \
    STMT_START {							\
	while (PL_curstack != s) {					\
	    dounwind(-1);						\
	    POPSTACK;							\
	}								\
    } STMT_END

#define IN_PERL_COMPILETIME	(PL_curcop == &PL_compiling)
#define IN_PERL_RUNTIME		(PL_curcop != &PL_compiling)

/*
=head1 Multicall Functions

=for apidoc Ams||dMULTICALL
Declare local variables for a multicall.  See L<perlcall/LIGHTWEIGHT CALLBACKS>.

=for apidoc Ams||PUSH_MULTICALL
Opening bracket for a lightweight callback.
See L<perlcall/LIGHTWEIGHT CALLBACKS>.

=for apidoc Ams||MULTICALL
Make a lightweight callback.  See L<perlcall/LIGHTWEIGHT CALLBACKS>.

=for apidoc Ams||POP_MULTICALL
Closing bracket for a lightweight callback.
See L<perlcall/LIGHTWEIGHT CALLBACKS>.

=cut
*/

#define dMULTICALL \
    SV **newsp;			/* set by POPBLOCK */			\
    PERL_CONTEXT *cx;							\
    CV *multicall_cv;							\
    OP *multicall_cop;							\
    bool multicall_oldcatch; 						\
    U8 hasargs = 0		/* used by PUSHSUB */

#define PUSH_MULTICALL(the_cv) \
    PUSH_MULTICALL_FLAGS(the_cv, 0)

/* Like PUSH_MULTICALL, but allows you to specify extra flags
 * for the CX stack entry (this isn't part of the public API) */

#define PUSH_MULTICALL_FLAGS(the_cv, flags) \
    STMT_START {							\
	CV * const _nOnclAshIngNamE_ = the_cv;				\
	CV * const cv = _nOnclAshIngNamE_;				\
	PADLIST * const padlist = CvPADLIST(cv);			\
	ENTER;								\
 	multicall_oldcatch = CATCH_GET;					\
	SAVETMPS; SAVEVPTR(PL_op);					\
	CATCH_SET(TRUE);						\
	PUSHSTACKi(PERLSI_SORT);					\
	PUSHBLOCK(cx, (CXt_SUB|CXp_MULTICALL|flags), PL_stack_sp);	\
	PUSHSUB(cx);							\
        if (!(flags & CXp_SUB_RE_FAKE))                                 \
            CvDEPTH(cv)++;						\
	if (CvDEPTH(cv) >= 2) {						\
	    PERL_STACK_OVERFLOW_CHECK();				\
	    Perl_pad_push(aTHX_ padlist, CvDEPTH(cv));			\
	}								\
	SAVECOMPPAD();							\
	PAD_SET_CUR_NOSAVE(padlist, CvDEPTH(cv));			\
	multicall_cv = cv;						\
	multicall_cop = CvSTART(cv);					\
    } STMT_END

#define MULTICALL \
    STMT_START {							\
	PL_op = multicall_cop;						\
	CALLRUNOPS(aTHX);						\
    } STMT_END

#define POP_MULTICALL \
    STMT_START {							\
	cx = &cxstack[cxstack_ix];					\
        if (! ((CvDEPTH(multicall_cv) = cx->blk_sub.olddepth)) ) {	\
		LEAVESUB(multicall_cv);					\
	}								\
	POPBLOCK(cx,PL_curpm);						\
	POPSTACK;							\
	CATCH_SET(multicall_oldcatch);					\
	LEAVE;								\
	SPAGAIN;							\
    } STMT_END

/* Change the CV of an already-pushed MULTICALL CxSUB block.
 * (this isn't part of the public API) */

#define CHANGE_MULTICALL_FLAGS(the_cv, flags) \
    STMT_START {							\
	CV * const _nOnclAshIngNamE_ = the_cv;				\
	CV * const cv = _nOnclAshIngNamE_;				\
	PADLIST * const padlist = CvPADLIST(cv);			\
	cx = &cxstack[cxstack_ix];					\
	assert(cx->cx_type & CXp_MULTICALL);				\
	if (! ((CvDEPTH(multicall_cv) = cx->blk_sub.olddepth)) ) {	\
		LEAVESUB(multicall_cv);					\
	}								\
	cx->cx_type = (CXt_SUB|CXp_MULTICALL|flags);                    \
	PUSHSUB(cx);							\
        if (!(flags & CXp_SUB_RE_FAKE))                                 \
            CvDEPTH(cv)++;						\
	if (CvDEPTH(cv) >= 2) {						\
	    PERL_STACK_OVERFLOW_CHECK();				\
	    Perl_pad_push(aTHX_ padlist, CvDEPTH(cv));			\
	}								\
	SAVECOMPPAD();							\
	PAD_SET_CUR_NOSAVE(padlist, CvDEPTH(cv));			\
	multicall_cv = cv;						\
	multicall_cop = CvSTART(cv);					\
    } STMT_END
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                     usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/cv.h                                                      0100644 0000000 0000000 00000024377 12744441327 016532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    cv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* This structure must match the beginning of XPVFM in sv.h  */

struct xpvcv {
    _XPV_HEAD;
    _XPVCV_COMMON;
};

/*
=head1 Handy Values

=for apidoc AmU||Nullcv
Null CV pointer.

(deprecated - use C<(CV *)NULL> instead)

=head1 CV Manipulation Functions

This section documents functions to manipulate CVs which are code-values,
or subroutines.  For more information, see L<perlguts>.

=for apidoc Am|HV*|CvSTASH|CV* cv
Returns the stash of the CV.  A stash is the symbol table hash, containing
the package-scoped variables in the package where the subroutine was defined.
For more information, see L<perlguts>.

This also has a special use with XS AUTOLOAD subs.
See L<perlguts/Autoloading with XSUBs>.

=cut
*/

#ifndef PERL_CORE
#  define Nullcv Null(CV*)
#endif

#define CvSTASH(sv)	(0+((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_stash)
#define CvSTASH_set(cv,st) Perl_cvstash_set(aTHX_ cv, st)
#define CvSTART(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_start_u.xcv_start
#define CvROOT(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_root_u.xcv_root
#define CvXSUB(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_root_u.xcv_xsub
#define CvXSUBANY(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_start_u.xcv_xsubany
#define CvGV(sv)	S_CvGV((const CV *)(sv))
#define CvGV_set(cv,gv)	Perl_cvgv_set(aTHX_ cv, gv)
#define CvFILE(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_file
#ifdef USE_ITHREADS
#  define CvFILE_set_from_cop(sv, cop)	\
    (CvFILE(sv) = savepv(CopFILE(cop)), CvDYNFILE_on(sv))
#else
#  define CvFILE_set_from_cop(sv, cop)	\
    (CvFILE(sv) = CopFILE(cop), CvDYNFILE_off(sv))
#endif
#define CvFILEGV(sv)	(gv_fetchfile(CvFILE(sv)))
#define CvDEPTH(sv)	(*S_CvDEPTHp((const CV *)sv))
#define CvPADLIST(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_padlist
#define CvOUTSIDE(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_outside
#define CvFLAGS(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_flags
#define CvOUTSIDE_SEQ(sv) ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_outside_seq

/* These two are sometimes called on non-CVs */
#define CvPROTO(sv)                               \
	(                                          \
	 SvPOK(sv)                                  \
	  ? SvTYPE(sv) == SVt_PVCV && CvAUTOLOAD(sv) \
	     ? SvEND(sv)+1 : SvPVX_const(sv)          \
	  : NULL                                       \
	)
#define CvPROTOLEN(sv)	                          \
	(                                          \
	 SvPOK(sv)                                  \
	  ? SvTYPE(sv) == SVt_PVCV && CvAUTOLOAD(sv) \
	     ? SvLEN(sv)-SvCUR(sv)-2                  \
	     : SvCUR(sv)                               \
	  : 0                                           \
	)

#define CVf_METHOD	0x0001	/* CV is explicitly marked as a method */
#define CVf_LVALUE	0x0002  /* CV return value can be used as lvalue */
#define CVf_CONST	0x0004  /* inlinable sub */
#define CVf_ISXSUB	0x0008	/* CV is an XSUB, not pure perl.  */

#define CVf_WEAKOUTSIDE	0x0010  /* CvOUTSIDE isn't ref counted */
#define CVf_CLONE	0x0020	/* anon CV uses external lexicals */
#define CVf_CLONED	0x0040	/* a clone of one of those */
#define CVf_ANON	0x0080	/* CV is not pointed to by a GV */
#define CVf_UNIQUE	0x0100	/* sub is only called once (eg PL_main_cv,
				 * require, eval). */
#define CVf_NODEBUG	0x0200	/* no DB::sub indirection for this CV
				   (esp. useful for special XSUBs) */
#define CVf_CVGV_RC	0x0400	/* CvGV is reference counted */
#ifdef PERL_CORE
# define CVf_SLABBED	0x0800	/* Holds refcount on op slab  */
#endif
#define CVf_DYNFILE	0x1000	/* The filename isn't static  */
#define CVf_AUTOLOAD	0x2000	/* SvPVX contains AUTOLOADed sub name  */
#define CVf_HASEVAL	0x4000	/* contains string eval  */
#define CVf_NAMED	0x8000  /* Has a name HEK */

/* This symbol for optimised communication between toke.c and op.c: */
#define CVf_BUILTIN_ATTRS	(CVf_METHOD|CVf_LVALUE)

#define CvCLONE(cv)		(CvFLAGS(cv) & CVf_CLONE)
#define CvCLONE_on(cv)		(CvFLAGS(cv) |= CVf_CLONE)
#define CvCLONE_off(cv)		(CvFLAGS(cv) &= ~CVf_CLONE)

#define CvCLONED(cv)		(CvFLAGS(cv) & CVf_CLONED)
#define CvCLONED_on(cv)		(CvFLAGS(cv) |= CVf_CLONED)
#define CvCLONED_off(cv)	(CvFLAGS(cv) &= ~CVf_CLONED)

#define CvANON(cv)		(CvFLAGS(cv) & CVf_ANON)
#define CvANON_on(cv)		(CvFLAGS(cv) |= CVf_ANON)
#define CvANON_off(cv)		(CvFLAGS(cv) &= ~CVf_ANON)

/* CvEVAL or CvSPECIAL */
#define CvUNIQUE(cv)		(CvFLAGS(cv) & CVf_UNIQUE)
#define CvUNIQUE_on(cv)		(CvFLAGS(cv) |= CVf_UNIQUE)
#define CvUNIQUE_off(cv)	(CvFLAGS(cv) &= ~CVf_UNIQUE)

#define CvNODEBUG(cv)		(CvFLAGS(cv) & CVf_NODEBUG)
#define CvNODEBUG_on(cv)	(CvFLAGS(cv) |= CVf_NODEBUG)
#define CvNODEBUG_off(cv)	(CvFLAGS(cv) &= ~CVf_NODEBUG)

#define CvMETHOD(cv)		(CvFLAGS(cv) & CVf_METHOD)
#define CvMETHOD_on(cv)		(CvFLAGS(cv) |= CVf_METHOD)
#define CvMETHOD_off(cv)	(CvFLAGS(cv) &= ~CVf_METHOD)

#define CvLVALUE(cv)		(CvFLAGS(cv) & CVf_LVALUE)
#define CvLVALUE_on(cv)		(CvFLAGS(cv) |= CVf_LVALUE)
#define CvLVALUE_off(cv)	(CvFLAGS(cv) &= ~CVf_LVALUE)

/* eval or PL_main_cv */
#define CvEVAL(cv)		(CvUNIQUE(cv) && !SvFAKE(cv))
#define CvEVAL_on(cv)		(CvUNIQUE_on(cv),SvFAKE_off(cv))
#define CvEVAL_off(cv)		CvUNIQUE_off(cv)

/* BEGIN|CHECK|INIT|UNITCHECK|END */
#define CvSPECIAL(cv)		(CvUNIQUE(cv) && SvFAKE(cv))
#define CvSPECIAL_on(cv)	(CvUNIQUE_on(cv),SvFAKE_on(cv))
#define CvSPECIAL_off(cv)	(CvUNIQUE_off(cv),SvFAKE_off(cv))

#define CvCONST(cv)		(CvFLAGS(cv) & CVf_CONST)
#define CvCONST_on(cv)		(CvFLAGS(cv) |= CVf_CONST)
#define CvCONST_off(cv)		(CvFLAGS(cv) &= ~CVf_CONST)

#define CvWEAKOUTSIDE(cv)	(CvFLAGS(cv) & CVf_WEAKOUTSIDE)
#define CvWEAKOUTSIDE_on(cv)	(CvFLAGS(cv) |= CVf_WEAKOUTSIDE)
#define CvWEAKOUTSIDE_off(cv)	(CvFLAGS(cv) &= ~CVf_WEAKOUTSIDE)

#define CvISXSUB(cv)		(CvFLAGS(cv) & CVf_ISXSUB)
#define CvISXSUB_on(cv)		(CvFLAGS(cv) |= CVf_ISXSUB)
#define CvISXSUB_off(cv)	(CvFLAGS(cv) &= ~CVf_ISXSUB)

#define CvCVGV_RC(cv)		(CvFLAGS(cv) & CVf_CVGV_RC)
#define CvCVGV_RC_on(cv)	(CvFLAGS(cv) |= CVf_CVGV_RC)
#define CvCVGV_RC_off(cv)	(CvFLAGS(cv) &= ~CVf_CVGV_RC)

#ifdef PERL_CORE
# define CvSLABBED(cv)		(CvFLAGS(cv) & CVf_SLABBED)
# define CvSLABBED_on(cv)	(CvFLAGS(cv) |= CVf_SLABBED)
# define CvSLABBED_off(cv)	(CvFLAGS(cv) &= ~CVf_SLABBED)
#endif

#define CvDYNFILE(cv)		(CvFLAGS(cv) & CVf_DYNFILE)
#define CvDYNFILE_on(cv)	(CvFLAGS(cv) |= CVf_DYNFILE)
#define CvDYNFILE_off(cv)	(CvFLAGS(cv) &= ~CVf_DYNFILE)

#define CvAUTOLOAD(cv)		(CvFLAGS(cv) & CVf_AUTOLOAD)
#define CvAUTOLOAD_on(cv)	(CvFLAGS(cv) |= CVf_AUTOLOAD)
#define CvAUTOLOAD_off(cv)	(CvFLAGS(cv) &= ~CVf_AUTOLOAD)

#define CvHASEVAL(cv)		(CvFLAGS(cv) & CVf_HASEVAL)
#define CvHASEVAL_on(cv)	(CvFLAGS(cv) |= CVf_HASEVAL)
#define CvHASEVAL_off(cv)	(CvFLAGS(cv) &= ~CVf_HASEVAL)

#define CvNAMED(cv)		(CvFLAGS(cv) & CVf_NAMED)
#define CvNAMED_on(cv)		(CvFLAGS(cv) |= CVf_NAMED)
#define CvNAMED_off(cv)		(CvFLAGS(cv) &= ~CVf_NAMED)

/* Flags for newXS_flags  */
#define XS_DYNAMIC_FILENAME	0x01	/* The filename isn't static  */

PERL_STATIC_INLINE GV *
S_CvGV(const CV *sv)
{
    return CvNAMED(sv)
	? 0
	: ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_gv_u.xcv_gv;
}
PERL_STATIC_INLINE HEK *
CvNAME_HEK(CV *sv)
{
    return CvNAMED(sv)
	? ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_gv_u.xcv_hek
	: 0;
}
/* This lowers the refernce count of the previous value, but does *not*
   increment the reference count of the new value. */
#define CvNAME_HEK_set(cv, hek) ( \
	CvNAME_HEK((CV *)(cv))						 \
	    ? unshare_hek(SvANY((CV *)(cv))->xcv_gv_u.xcv_hek)	  \
	    : (void)0,						   \
	((XPVCV*)MUTABLE_PTR(SvANY(cv)))->xcv_gv_u.xcv_hek = (hek), \
	CvNAMED_on(cv)						     \
    )

/*
=head1 CV reference counts and CvOUTSIDE

=for apidoc m|bool|CvWEAKOUTSIDE|CV *cv

Each CV has a pointer, C<CvOUTSIDE()>, to its lexically enclosing
CV (if any).  Because pointers to anonymous sub prototypes are
stored in C<&> pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa.  To avoid the
ensuing memory leak, we do not increment the reference count of the CV
pointed to by C<CvOUTSIDE> in the I<one specific instance> that the parent
has a C<&> pad slot pointing back to us.  In this case, we set the
C<CvWEAKOUTSIDE> flag in the child.  This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.

There is a further complication with non-closure anonymous subs (i.e. those
that do not refer to any lexicals outside that sub).  In this case, the
anonymous prototype is shared rather than being cloned.  This has the
consequence that the parent may be freed while there are still active
children, eg

    BEGIN { $a = sub { eval '$x' } }

In this case, the BEGIN is freed immediately after execution since there
are no active references to it: the anon sub prototype has
C<CvWEAKOUTSIDE> set since it's not a closure, and $a points to the same
CV, so it doesn't contribute to BEGIN's refcount either.  When $a is
executed, the C<eval '$x'> causes the chain of C<CvOUTSIDE>s to be followed,
and the freed BEGIN is accessed.

To avoid this, whenever a CV and its associated pad is freed, any
C<&> entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's C<CvOUTSIDE> is set to point to its grandparent.  This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as C<$a> above).

One other thing to consider is that a CV may be merely undefined
rather than freed, eg C<undef &foo>.  In this case, its refcount may
not have reached zero, but we still delete its pad and its C<CvROOT> etc.
Since various children may still have their C<CvOUTSIDE> pointing at this
undefined CV, we keep its own C<CvOUTSIDE> for the time being, so that
the chain of lexical scopes is unbroken.  For example, the following
should print 123:

    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &tmp;
    print  $a->();

=cut
*/

typedef OP *(*Perl_call_checker)(pTHX_ OP *, GV *, SV *);

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                 usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/dosish.h                                                  0100644 0000000 0000000 00000012645 12744441327 017406  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    dosish.h
 *
 *    Copyright (C) 1993, 1994, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */
#define ABORT() abort();

#ifndef SH_PATH
#define SH_PATH "/bin/sh"
#endif

#ifdef DJGPP
#  define BIT_BUCKET "nul"
#  define OP_BINARY O_BINARY
#  define PERL_SYS_INIT_BODY(c,v)					\
	 MALLOC_CHECK_TAINT2(*c,*v) Perl_DJGPP_init(c,v); PERLIO_INIT
#  define init_os_extras Perl_init_os_extras
#  define HAS_UTIME
#  define HAS_KILL
   char *djgpp_pathexp (const char*);
   void Perl_DJGPP_init (int *argcp,char ***argvp);
#  if (DJGPP==2 && DJGPP_MINOR < 2)
#    define NO_LOCALECONV_MON_THOUSANDS_SEP
#  endif
#  ifndef PERL_CORE
#    define PERL_FS_VER_FMT	"%d_%d_%d"
#  endif
#  define PERL_FS_VERSION	STRINGIFY(PERL_REVISION) "_" \
				STRINGIFY(PERL_VERSION) "_" \
				STRINGIFY(PERL_SUBVERSION)
#else	/* DJGPP */
#  ifdef WIN32
#    define PERL_SYS_INIT_BODY(c,v)					\
	MALLOC_CHECK_TAINT2(*c,*v) Perl_win32_init(c,v); PERLIO_INIT
#    define PERL_SYS_TERM_BODY()   Perl_win32_term()
#    define BIT_BUCKET "nul"
#  else
#	 ifdef NETWARE
#      define PERL_SYS_INIT_BODY(c,v)					\
	MALLOC_CHECK_TAINT2(*c,*v) Perl_nw5_init(c,v); PERLIO_INIT
#      define BIT_BUCKET "nwnul"
#    else
#      define PERL_SYS_INIT_BODY(c,v)		\
	MALLOC_CHECK_TAINT2(*c,*v); PERLIO_INIT
#      define BIT_BUCKET "\\dev\\nul" /* "wanna be like, umm, Newlined, or somethin?" */
#    endif /* NETWARE */
#  endif
#endif	/* DJGPP */

#ifndef PERL_SYS_TERM_BODY
#  define PERL_SYS_TERM_BODY() \
    HINTS_REFCNT_TERM; OP_CHECK_MUTEX_TERM; \
    OP_REFCNT_TERM; PERLIO_TERM; MALLOC_TERM
#endif
#define dXSUB_SYS

/* USEMYBINMODE
 *	This symbol, if defined, indicates that the program should
 *	use the routine my_binmode(FILE *fp, char iotype, int mode) to insure
 *	that a file is in "binary" mode -- that is, that no translation
 *	of bytes occurs on read or write operations.
 */
#undef USEMYBINMODE

/* Stat_t:
 *	This symbol holds the type used to declare buffers for information
 *	returned by stat().  It's usually just struct stat.  It may be necessary
 *	to include <sys/stat.h> and <sys/types.h> to get any typedef'ed
 *	information.
 */
#if defined(WIN64) || defined(USE_LARGE_FILES)
#define Stat_t struct _stati64
#else
#if defined(UNDER_CE)
#define Stat_t struct xcestat
#else
#define Stat_t struct stat
#endif
#endif

/* USE_STAT_RDEV:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_rdev
 */
#define USE_STAT_RDEV 	/**/

/* ACME_MESS:
 *	This symbol, if defined, indicates that error messages should be 
 *	should be generated in a format that allows the use of the Acme
 *	GUI/editor's autofind feature.
 */
#undef ACME_MESS	/**/

/* ALTERNATE_SHEBANG:
 *	This symbol, if defined, contains a "magic" string which may be used
 *	as the first line of a Perl program designed to be executed directly
 *	by name, instead of the standard Unix #!.  If ALTERNATE_SHEBANG
 *	begins with a character other then #, then Perl will only treat
 *	it as a command line if it finds the string "perl" in the first
 *	word; otherwise it's treated as the first line of code in the script.
 *	(IOW, Perl won't hand off to another interpreter via an alternate
 *	shebang sequence that might be legal Perl code.)
 */
/* #define ALTERNATE_SHEBANG "#!" / **/

#include <signal.h>

/*
 * fwrite1() should be a routine with the same calling sequence as fwrite(),
 * but which outputs all of the bytes requested as a single stream (unlike
 * fwrite() itself, which on some systems outputs several distinct records
 * if the number_of_items parameter is >1).
 */
#define fwrite1 fwrite

#define Fstat(fd,bufptr)   fstat((fd),(bufptr))
#ifdef DJGPP
#   define Fflush(fp)      djgpp_fflush(fp)
#else
#   define Fflush(fp)      fflush(fp)
#endif
#define Mkdir(path,mode)   mkdir((path),(mode))

#ifndef WIN32
#  define Stat(fname,bufptr) stat((fname),(bufptr))
#else
#  define HAS_IOCTL
#  define HAS_UTIME
#  define HAS_KILL
#  define HAS_WAIT
#  define HAS_CHOWN
#endif	/* WIN32 */

/*
 * <rich@phekda.freeserve.co.uk>: The DJGPP port has code that converts
 * the return code of system() into the form that Unixy wait usually
 * returns:
 *
 * - signal number in bits 0-6;
 * - core dump flag in bit 7;
 * - exit code in bits 8-15.
 *
 * Bits 0-7 are always zero for DJGPP, because it uses system().
 * See djgpp.c.
 *
 * POSIX::W* use the W* macros from <sys/wait.h> to decode
 * the return code. Unfortunately the W* macros for DJGPP use
 * a different format than Unixy wait does. So there's a mismatch
 * and, say, WEXITSTATUS($?) will return bogus values.
 *
 * So here we add hack to redefine the W* macros from DJGPP's <sys/wait.h>
 * to work with our return-code conversion.
 */

#ifdef DJGPP

#include <sys/wait.h>

#undef WEXITSTATUS
#undef WIFEXITED
#undef WIFSIGNALED
#undef WIFSTOPPED
#undef WNOHANG
#undef WSTOPSIG
#undef WTERMSIG
#undef WUNTRACED

#define WEXITSTATUS(stat_val) ((stat_val) >> 8)
#define WIFEXITED(stat_val)   0
#define WIFSIGNALED(stat_val) 0
#define WIFSTOPPED(stat_val)  0
#define WNOHANG               0
#define WSTOPSIG(stat_val)    0
#define WTERMSIG(stat_val)    0
#define WUNTRACED             0

#endif

/* Don't go reading from /dev/urandom */
#define PERL_NO_DEV_RANDOM

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                           usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/embed.h                                                   0100644 0000000 0000000 00000260455 12744441327 017175  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    embed.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/embed.pl from data in embed.fnc,
 * regen/embed.pl, regen/opcodes, intrpvar.h and perlvars.h.
 * Any changes made here will be lost!
 *
 * Edit those files and run 'make regen_headers' to effect changes.
 */

/* (Doing namespace management portably in C is really gross.) */

/* By defining PERL_NO_SHORT_NAMES (not done by default) the short forms
 * (like warn instead of Perl_warn) for the API are not defined.
 * Not defining the short forms is a good thing for cleaner embedding. */

#ifndef PERL_NO_SHORT_NAMES

/* Hide global symbols */

#define Gv_AMupdate(a,b)	Perl_Gv_AMupdate(aTHX_ a,b)
#define _is_uni_FOO(a,b)	Perl__is_uni_FOO(aTHX_ a,b)
#define _is_uni_perl_idcont(a)	Perl__is_uni_perl_idcont(aTHX_ a)
#define _is_uni_perl_idstart(a)	Perl__is_uni_perl_idstart(aTHX_ a)
#define _is_utf8_FOO(a,b)	Perl__is_utf8_FOO(aTHX_ a,b)
#define _is_utf8_mark(a)	Perl__is_utf8_mark(aTHX_ a)
#define _is_utf8_perl_idcont(a)	Perl__is_utf8_perl_idcont(aTHX_ a)
#define _is_utf8_perl_idstart(a)	Perl__is_utf8_perl_idstart(aTHX_ a)
#define _to_uni_fold_flags(a,b,c,d)	Perl__to_uni_fold_flags(aTHX_ a,b,c,d)
#define _to_utf8_fold_flags(a,b,c,d)	Perl__to_utf8_fold_flags(aTHX_ a,b,c,d)
#define _to_utf8_lower_flags(a,b,c,d)	Perl__to_utf8_lower_flags(aTHX_ a,b,c,d)
#define _to_utf8_title_flags(a,b,c,d)	Perl__to_utf8_title_flags(aTHX_ a,b,c,d)
#define _to_utf8_upper_flags(a,b,c,d)	Perl__to_utf8_upper_flags(aTHX_ a,b,c,d)
#define amagic_call(a,b,c,d)	Perl_amagic_call(aTHX_ a,b,c,d)
#define amagic_deref_call(a,b)	Perl_amagic_deref_call(aTHX_ a,b)
#define append_utf8_from_native_byte	S_append_utf8_from_native_byte
#define apply_attrs_string(a,b,c,d)	Perl_apply_attrs_string(aTHX_ a,b,c,d)
#define atfork_lock		Perl_atfork_lock
#define atfork_unlock		Perl_atfork_unlock
#define av_clear(a)		Perl_av_clear(aTHX_ a)
#define av_delete(a,b,c)	Perl_av_delete(aTHX_ a,b,c)
#define av_exists(a,b)		Perl_av_exists(aTHX_ a,b)
#define av_extend(a,b)		Perl_av_extend(aTHX_ a,b)
#define av_fetch(a,b,c)		Perl_av_fetch(aTHX_ a,b,c)
#define av_fill(a,b)		Perl_av_fill(aTHX_ a,b)
#define av_len(a)		Perl_av_len(aTHX_ a)
#define av_make(a,b)		Perl_av_make(aTHX_ a,b)
#define av_pop(a)		Perl_av_pop(aTHX_ a)
#define av_push(a,b)		Perl_av_push(aTHX_ a,b)
#define av_shift(a)		Perl_av_shift(aTHX_ a)
#define av_store(a,b,c)		Perl_av_store(aTHX_ a,b,c)
#define av_top_index(a)		S_av_top_index(aTHX_ a)
#define av_undef(a)		Perl_av_undef(aTHX_ a)
#define av_unshift(a,b)		Perl_av_unshift(aTHX_ a,b)
#define block_gimme()		Perl_block_gimme(aTHX)
#define bytes_cmp_utf8(a,b,c,d)	Perl_bytes_cmp_utf8(aTHX_ a,b,c,d)
#define bytes_from_utf8(a,b,c)	Perl_bytes_from_utf8(aTHX_ a,b,c)
#define bytes_to_utf8(a,b)	Perl_bytes_to_utf8(aTHX_ a,b)
#define call_argv(a,b,c)	Perl_call_argv(aTHX_ a,b,c)
#define call_atexit(a,b)	Perl_call_atexit(aTHX_ a,b)
#define call_list(a,b)		Perl_call_list(aTHX_ a,b)
#define call_method(a,b)	Perl_call_method(aTHX_ a,b)
#define call_pv(a,b)		Perl_call_pv(aTHX_ a,b)
#define call_sv(a,b)		Perl_call_sv(aTHX_ a,b)
#define caller_cx(a,b)		Perl_caller_cx(aTHX_ a,b)
#define cast_i32(a)		Perl_cast_i32(aTHX_ a)
#define cast_iv(a)		Perl_cast_iv(aTHX_ a)
#define cast_ulong(a)		Perl_cast_ulong(aTHX_ a)
#define cast_uv(a)		Perl_cast_uv(aTHX_ a)
#define ck_entersub_args_list(a)	Perl_ck_entersub_args_list(aTHX_ a)
#define ck_entersub_args_proto(a,b,c)	Perl_ck_entersub_args_proto(aTHX_ a,b,c)
#define ck_entersub_args_proto_or_list(a,b,c)	Perl_ck_entersub_args_proto_or_list(aTHX_ a,b,c)
#ifndef PERL_IMPLICIT_CONTEXT
#define ck_warner		Perl_ck_warner
#define ck_warner_d		Perl_ck_warner_d
#endif
#ifndef PERL_IMPLICIT_CONTEXT
#define croak			Perl_croak
#endif
#define croak_memory_wrap	S_croak_memory_wrap
#define croak_no_modify		Perl_croak_no_modify
#define croak_sv(a)		Perl_croak_sv(aTHX_ a)
#define croak_xs_usage		Perl_croak_xs_usage
#define custom_op_desc(a)	Perl_custom_op_desc(aTHX_ a)
#define custom_op_name(a)	Perl_custom_op_name(aTHX_ a)
#define cv_clone(a)		Perl_cv_clone(aTHX_ a)
#define cv_const_sv(a)		Perl_cv_const_sv(aTHX_ a)
#define cv_get_call_checker(a,b,c)	Perl_cv_get_call_checker(aTHX_ a,b,c)
#define cv_set_call_checker(a,b,c)	Perl_cv_set_call_checker(aTHX_ a,b,c)
#define cv_undef(a)		Perl_cv_undef(aTHX_ a)
#define cx_dump(a)		Perl_cx_dump(aTHX_ a)
#define cxinc()			Perl_cxinc(aTHX)
#ifndef PERL_IMPLICIT_CONTEXT
#define deb			Perl_deb
#endif
#define debop(a)		Perl_debop(aTHX_ a)
#define debprofdump()		Perl_debprofdump(aTHX)
#define debstack()		Perl_debstack(aTHX)
#define debstackptrs()		Perl_debstackptrs(aTHX)
#define delimcpy		Perl_delimcpy
#define despatch_signals()	Perl_despatch_signals(aTHX)
#ifndef PERL_IMPLICIT_CONTEXT
#define die			Perl_die
#endif
#define die_sv(a)		Perl_die_sv(aTHX_ a)
#define do_binmode(a,b,c)	Perl_do_binmode(aTHX_ a,b,c)
#define do_close(a,b)		Perl_do_close(aTHX_ a,b)
#define do_gv_dump(a,b,c,d)	Perl_do_gv_dump(aTHX_ a,b,c,d)
#define do_gvgv_dump(a,b,c,d)	Perl_do_gvgv_dump(aTHX_ a,b,c,d)
#define do_hv_dump(a,b,c,d)	Perl_do_hv_dump(aTHX_ a,b,c,d)
#define do_join(a,b,c,d)	Perl_do_join(aTHX_ a,b,c,d)
#define do_magic_dump(a,b,c,d,e,f,g)	Perl_do_magic_dump(aTHX_ a,b,c,d,e,f,g)
#define do_op_dump(a,b,c)	Perl_do_op_dump(aTHX_ a,b,c)
#define do_open9(a,b,c,d,e,f,g,h,i)	Perl_do_open9(aTHX_ a,b,c,d,e,f,g,h,i)
#define do_openn(a,b,c,d,e,f,g,h,i)	Perl_do_openn(aTHX_ a,b,c,d,e,f,g,h,i)
#define do_pmop_dump(a,b,c)	Perl_do_pmop_dump(aTHX_ a,b,c)
#define do_sprintf(a,b,c)	Perl_do_sprintf(aTHX_ a,b,c)
#define do_sv_dump(a,b,c,d,e,f,g)	Perl_do_sv_dump(aTHX_ a,b,c,d,e,f,g)
#define doing_taint		Perl_doing_taint
#define doref(a,b,c)		Perl_doref(aTHX_ a,b,c)
#define dounwind(a)		Perl_dounwind(aTHX_ a)
#define dowantarray()		Perl_dowantarray(aTHX)
#define dump_all()		Perl_dump_all(aTHX)
#define dump_eval()		Perl_dump_eval(aTHX)
#define dump_form(a)		Perl_dump_form(aTHX_ a)
#ifndef PERL_IMPLICIT_CONTEXT
#define dump_indent		Perl_dump_indent
#endif
#define dump_packsubs(a)	Perl_dump_packsubs(aTHX_ a)
#define dump_sub(a)		Perl_dump_sub(aTHX_ a)
#define dump_vindent(a,b,c,d)	Perl_dump_vindent(aTHX_ a,b,c,d)
#define eval_pv(a,b)		Perl_eval_pv(aTHX_ a,b)
#define eval_sv(a,b)		Perl_eval_sv(aTHX_ a,b)
#define fbm_compile(a,b)	Perl_fbm_compile(aTHX_ a,b)
#define fbm_instr(a,b,c,d)	Perl_fbm_instr(aTHX_ a,b,c,d)
#define filter_add(a,b)		Perl_filter_add(aTHX_ a,b)
#define filter_del(a)		Perl_filter_del(aTHX_ a)
#define filter_read(a,b,c)	Perl_filter_read(aTHX_ a,b,c)
#define find_runcv(a)		Perl_find_runcv(aTHX_ a)
#define find_rundefsv()		Perl_find_rundefsv(aTHX)
#define find_rundefsvoffset()	Perl_find_rundefsvoffset(aTHX)
#define foldEQ			Perl_foldEQ
#define foldEQ_latin1		Perl_foldEQ_latin1
#define foldEQ_locale		Perl_foldEQ_locale
#define foldEQ_utf8_flags(a,b,c,d,e,f,g,h,i)	Perl_foldEQ_utf8_flags(aTHX_ a,b,c,d,e,f,g,h,i)
#ifndef PERL_IMPLICIT_CONTEXT
#define form			Perl_form
#endif
#define free_tmps()		Perl_free_tmps(aTHX)
#define get_av(a,b)		Perl_get_av(aTHX_ a,b)
#define get_context		Perl_get_context
#define get_cv(a,b)		Perl_get_cv(aTHX_ a,b)
#define get_cvn_flags(a,b,c)	Perl_get_cvn_flags(aTHX_ a,b,c)
#define get_hv(a,b)		Perl_get_hv(aTHX_ a,b)
#define get_op_descs()		Perl_get_op_descs(aTHX)
#define get_op_names()		Perl_get_op_names(aTHX)
#define get_ppaddr()		Perl_get_ppaddr(aTHX)
#define get_sv(a,b)		Perl_get_sv(aTHX_ a,b)
#define get_vtbl(a)		Perl_get_vtbl(aTHX_ a)
#define getcwd_sv(a)		Perl_getcwd_sv(aTHX_ a)
#define gp_free(a)		Perl_gp_free(aTHX_ a)
#define gp_ref(a)		Perl_gp_ref(aTHX_ a)
#define grok_bin(a,b,c,d)	Perl_grok_bin(aTHX_ a,b,c,d)
#define grok_hex(a,b,c,d)	Perl_grok_hex(aTHX_ a,b,c,d)
#define grok_number(a,b,c)	Perl_grok_number(aTHX_ a,b,c)
#define grok_numeric_radix(a,b)	Perl_grok_numeric_radix(aTHX_ a,b)
#define grok_oct(a,b,c,d)	Perl_grok_oct(aTHX_ a,b,c,d)
#define gv_add_by_type(a,b)	Perl_gv_add_by_type(aTHX_ a,b)
#define gv_autoload_pv(a,b,c)	Perl_gv_autoload_pv(aTHX_ a,b,c)
#define gv_autoload_pvn(a,b,c,d)	Perl_gv_autoload_pvn(aTHX_ a,b,c,d)
#define gv_autoload_sv(a,b,c)	Perl_gv_autoload_sv(aTHX_ a,b,c)
#define gv_check(a)		Perl_gv_check(aTHX_ a)
#define gv_const_sv(a)		Perl_gv_const_sv(aTHX_ a)
#define gv_dump(a)		Perl_gv_dump(aTHX_ a)
#define gv_efullname(a,b)	Perl_gv_efullname(aTHX_ a,b)
#define gv_efullname4(a,b,c,d)	Perl_gv_efullname4(aTHX_ a,b,c,d)
#define gv_fetchfile(a)		Perl_gv_fetchfile(aTHX_ a)
#define gv_fetchfile_flags(a,b,c)	Perl_gv_fetchfile_flags(aTHX_ a,b,c)
#define gv_fetchmeth_pv(a,b,c,d)	Perl_gv_fetchmeth_pv(aTHX_ a,b,c,d)
#define gv_fetchmeth_pv_autoload(a,b,c,d)	Perl_gv_fetchmeth_pv_autoload(aTHX_ a,b,c,d)
#define gv_fetchmeth_pvn(a,b,c,d,e)	Perl_gv_fetchmeth_pvn(aTHX_ a,b,c,d,e)
#define gv_fetchmeth_pvn_autoload(a,b,c,d,e)	Perl_gv_fetchmeth_pvn_autoload(aTHX_ a,b,c,d,e)
#define gv_fetchmeth_sv(a,b,c,d)	Perl_gv_fetchmeth_sv(aTHX_ a,b,c,d)
#define gv_fetchmeth_sv_autoload(a,b,c,d)	Perl_gv_fetchmeth_sv_autoload(aTHX_ a,b,c,d)
#define gv_fetchmethod_autoload(a,b,c)	Perl_gv_fetchmethod_autoload(aTHX_ a,b,c)
#define gv_fetchmethod_pv_flags(a,b,c)	Perl_gv_fetchmethod_pv_flags(aTHX_ a,b,c)
#define gv_fetchmethod_pvn_flags(a,b,c,d)	Perl_gv_fetchmethod_pvn_flags(aTHX_ a,b,c,d)
#define gv_fetchmethod_sv_flags(a,b,c)	Perl_gv_fetchmethod_sv_flags(aTHX_ a,b,c)
#define gv_fetchpv(a,b,c)	Perl_gv_fetchpv(aTHX_ a,b,c)
#define gv_fetchpvn_flags(a,b,c,d)	Perl_gv_fetchpvn_flags(aTHX_ a,b,c,d)
#define gv_fetchsv(a,b,c)	Perl_gv_fetchsv(aTHX_ a,b,c)
#define gv_fullname(a,b)	Perl_gv_fullname(aTHX_ a,b)
#define gv_fullname4(a,b,c,d)	Perl_gv_fullname4(aTHX_ a,b,c,d)
#define gv_handler(a,b)		Perl_gv_handler(aTHX_ a,b)
#define gv_init_pv(a,b,c,d)	Perl_gv_init_pv(aTHX_ a,b,c,d)
#define gv_init_pvn(a,b,c,d,e)	Perl_gv_init_pvn(aTHX_ a,b,c,d,e)
#define gv_init_sv(a,b,c,d)	Perl_gv_init_sv(aTHX_ a,b,c,d)
#define gv_name_set(a,b,c,d)	Perl_gv_name_set(aTHX_ a,b,c,d)
#define gv_stashpv(a,b)		Perl_gv_stashpv(aTHX_ a,b)
#define gv_stashpvn(a,b,c)	Perl_gv_stashpvn(aTHX_ a,b,c)
#define gv_stashsv(a,b)		Perl_gv_stashsv(aTHX_ a,b)
#define hv_clear(a)		Perl_hv_clear(aTHX_ a)
#define hv_clear_placeholders(a)	Perl_hv_clear_placeholders(aTHX_ a)
#define hv_common(a,b,c,d,e,f,g,h)	Perl_hv_common(aTHX_ a,b,c,d,e,f,g,h)
#define hv_common_key_len(a,b,c,d,e,f)	Perl_hv_common_key_len(aTHX_ a,b,c,d,e,f)
#define hv_copy_hints_hv(a)	Perl_hv_copy_hints_hv(aTHX_ a)
#define hv_delayfree_ent(a,b)	Perl_hv_delayfree_ent(aTHX_ a,b)
#define hv_free_ent(a,b)	Perl_hv_free_ent(aTHX_ a,b)
#define hv_iterinit(a)		Perl_hv_iterinit(aTHX_ a)
#define hv_iterkey(a,b)		Perl_hv_iterkey(aTHX_ a,b)
#define hv_iterkeysv(a)		Perl_hv_iterkeysv(aTHX_ a)
#define hv_iternext_flags(a,b)	Perl_hv_iternext_flags(aTHX_ a,b)
#define hv_iternextsv(a,b,c)	Perl_hv_iternextsv(aTHX_ a,b,c)
#define hv_iterval(a,b)		Perl_hv_iterval(aTHX_ a,b)
#define hv_ksplit(a,b)		Perl_hv_ksplit(aTHX_ a,b)
#define hv_name_set(a,b,c,d)	Perl_hv_name_set(aTHX_ a,b,c,d)
#define hv_rand_set(a,b)	Perl_hv_rand_set(aTHX_ a,b)
#define hv_scalar(a)		Perl_hv_scalar(aTHX_ a)
#define init_i18nl10n(a)	Perl_init_i18nl10n(aTHX_ a)
#define init_i18nl14n(a)	Perl_init_i18nl14n(aTHX_ a)
#define init_stacks()		Perl_init_stacks(aTHX)
#define init_tm(a)		Perl_init_tm(aTHX_ a)
#define instr			Perl_instr
#define is_ascii_string		Perl_is_ascii_string
#define is_lvalue_sub()		Perl_is_lvalue_sub(aTHX)
#define is_safe_syscall(a,b,c,d)	S_is_safe_syscall(aTHX_ a,b,c,d)
#define is_uni_alnum(a)		Perl_is_uni_alnum(aTHX_ a)
#define is_uni_alnum_lc(a)	Perl_is_uni_alnum_lc(aTHX_ a)
#define is_uni_alnumc(a)	Perl_is_uni_alnumc(aTHX_ a)
#define is_uni_alnumc_lc(a)	Perl_is_uni_alnumc_lc(aTHX_ a)
#define is_uni_alpha(a)		Perl_is_uni_alpha(aTHX_ a)
#define is_uni_alpha_lc(a)	Perl_is_uni_alpha_lc(aTHX_ a)
#define is_uni_ascii(a)		Perl_is_uni_ascii(aTHX_ a)
#define is_uni_ascii_lc(a)	Perl_is_uni_ascii_lc(aTHX_ a)
#define is_uni_blank(a)		Perl_is_uni_blank(aTHX_ a)
#define is_uni_blank_lc(a)	Perl_is_uni_blank_lc(aTHX_ a)
#define is_uni_cntrl(a)		Perl_is_uni_cntrl(aTHX_ a)
#define is_uni_cntrl_lc(a)	Perl_is_uni_cntrl_lc(aTHX_ a)
#define is_uni_digit(a)		Perl_is_uni_digit(aTHX_ a)
#define is_uni_digit_lc(a)	Perl_is_uni_digit_lc(aTHX_ a)
#define is_uni_graph(a)		Perl_is_uni_graph(aTHX_ a)
#define is_uni_graph_lc(a)	Perl_is_uni_graph_lc(aTHX_ a)
#define is_uni_idfirst(a)	Perl_is_uni_idfirst(aTHX_ a)
#define is_uni_idfirst_lc(a)	Perl_is_uni_idfirst_lc(aTHX_ a)
#define is_uni_lower(a)		Perl_is_uni_lower(aTHX_ a)
#define is_uni_lower_lc(a)	Perl_is_uni_lower_lc(aTHX_ a)
#define is_uni_print(a)		Perl_is_uni_print(aTHX_ a)
#define is_uni_print_lc(a)	Perl_is_uni_print_lc(aTHX_ a)
#define is_uni_punct(a)		Perl_is_uni_punct(aTHX_ a)
#define is_uni_punct_lc(a)	Perl_is_uni_punct_lc(aTHX_ a)
#define is_uni_space(a)		Perl_is_uni_space(aTHX_ a)
#define is_uni_space_lc(a)	Perl_is_uni_space_lc(aTHX_ a)
#define is_uni_upper(a)		Perl_is_uni_upper(aTHX_ a)
#define is_uni_upper_lc(a)	Perl_is_uni_upper_lc(aTHX_ a)
#define is_uni_xdigit(a)	Perl_is_uni_xdigit(aTHX_ a)
#define is_uni_xdigit_lc(a)	Perl_is_uni_xdigit_lc(aTHX_ a)
#define is_utf8_alnum(a)	Perl_is_utf8_alnum(aTHX_ a)
#define is_utf8_alnumc(a)	Perl_is_utf8_alnumc(aTHX_ a)
#define is_utf8_alpha(a)	Perl_is_utf8_alpha(aTHX_ a)
#define is_utf8_ascii(a)	Perl_is_utf8_ascii(aTHX_ a)
#define is_utf8_blank(a)	Perl_is_utf8_blank(aTHX_ a)
#define is_utf8_char		Perl_is_utf8_char
#define is_utf8_char_buf	Perl_is_utf8_char_buf
#define is_utf8_cntrl(a)	Perl_is_utf8_cntrl(aTHX_ a)
#define is_utf8_digit(a)	Perl_is_utf8_digit(aTHX_ a)
#define is_utf8_graph(a)	Perl_is_utf8_graph(aTHX_ a)
#define is_utf8_idcont(a)	Perl_is_utf8_idcont(aTHX_ a)
#define is_utf8_idfirst(a)	Perl_is_utf8_idfirst(aTHX_ a)
#define is_utf8_lower(a)	Perl_is_utf8_lower(aTHX_ a)
#define is_utf8_mark(a)		Perl_is_utf8_mark(aTHX_ a)
#define is_utf8_perl_space(a)	Perl_is_utf8_perl_space(aTHX_ a)
#define is_utf8_perl_word(a)	Perl_is_utf8_perl_word(aTHX_ a)
#define is_utf8_posix_digit(a)	Perl_is_utf8_posix_digit(aTHX_ a)
#define is_utf8_print(a)	Perl_is_utf8_print(aTHX_ a)
#define is_utf8_punct(a)	Perl_is_utf8_punct(aTHX_ a)
#define is_utf8_space(a)	Perl_is_utf8_space(aTHX_ a)
#define is_utf8_string		Perl_is_utf8_string
#define is_utf8_string_loclen	Perl_is_utf8_string_loclen
#define is_utf8_upper(a)	Perl_is_utf8_upper(aTHX_ a)
#define is_utf8_xdigit(a)	Perl_is_utf8_xdigit(aTHX_ a)
#define is_utf8_xidcont(a)	Perl_is_utf8_xidcont(aTHX_ a)
#define is_utf8_xidfirst(a)	Perl_is_utf8_xidfirst(aTHX_ a)
#define leave_scope(a)		Perl_leave_scope(aTHX_ a)
#define lex_bufutf8()		Perl_lex_bufutf8(aTHX)
#define lex_discard_to(a)	Perl_lex_discard_to(aTHX_ a)
#define lex_grow_linestr(a)	Perl_lex_grow_linestr(aTHX_ a)
#define lex_next_chunk(a)	Perl_lex_next_chunk(aTHX_ a)
#define lex_peek_unichar(a)	Perl_lex_peek_unichar(aTHX_ a)
#define lex_read_space(a)	Perl_lex_read_space(aTHX_ a)
#define lex_read_to(a)		Perl_lex_read_to(aTHX_ a)
#define lex_read_unichar(a)	Perl_lex_read_unichar(aTHX_ a)
#define lex_start(a,b,c)	Perl_lex_start(aTHX_ a,b,c)
#define lex_stuff_pv(a,b)	Perl_lex_stuff_pv(aTHX_ a,b)
#define lex_stuff_pvn(a,b,c)	Perl_lex_stuff_pvn(aTHX_ a,b,c)
#define lex_stuff_sv(a,b)	Perl_lex_stuff_sv(aTHX_ a,b)
#define lex_unstuff(a)		Perl_lex_unstuff(aTHX_ a)
#ifndef PERL_IMPLICIT_CONTEXT
#define load_module		Perl_load_module
#endif
#define looks_like_number(a)	Perl_looks_like_number(aTHX_ a)
#define magic_dump(a)		Perl_magic_dump(aTHX_ a)
#define markstack_grow()	Perl_markstack_grow(aTHX)
#ifndef PERL_IMPLICIT_CONTEXT
#define mess			Perl_mess
#endif
#define mess_sv(a,b)		Perl_mess_sv(aTHX_ a,b)
#define mg_clear(a)		Perl_mg_clear(aTHX_ a)
#define mg_copy(a,b,c,d)	Perl_mg_copy(aTHX_ a,b,c,d)
#define mg_find(a,b)		Perl_mg_find(aTHX_ a,b)
#define mg_findext(a,b,c)	Perl_mg_findext(aTHX_ a,b,c)
#define mg_free(a)		Perl_mg_free(aTHX_ a)
#define mg_free_type(a,b)	Perl_mg_free_type(aTHX_ a,b)
#define mg_get(a)		Perl_mg_get(aTHX_ a)
#define mg_length(a)		Perl_mg_length(aTHX_ a)
#define mg_magical(a)		Perl_mg_magical(aTHX_ a)
#define mg_set(a)		Perl_mg_set(aTHX_ a)
#define mg_size(a)		Perl_mg_size(aTHX_ a)
#define mini_mktime(a)		Perl_mini_mktime(aTHX_ a)
#define moreswitches(a)		Perl_moreswitches(aTHX_ a)
#define mro_get_linear_isa(a)	Perl_mro_get_linear_isa(aTHX_ a)
#define mro_method_changed_in(a)	Perl_mro_method_changed_in(aTHX_ a)
#define my_atof(a)		Perl_my_atof(aTHX_ a)
#define my_atof2(a,b)		Perl_my_atof2(aTHX_ a,b)
#define my_dirfd(a)		Perl_my_dirfd(aTHX_ a)
#define my_exit(a)		Perl_my_exit(aTHX_ a)
#define my_failure_exit()	Perl_my_failure_exit(aTHX)
#define my_fflush_all()		Perl_my_fflush_all(aTHX)
#define my_fork			Perl_my_fork
#define my_popen_list(a,b,c)	Perl_my_popen_list(aTHX_ a,b,c)
#define my_setenv(a,b)		Perl_my_setenv(aTHX_ a,b)
#define my_socketpair		Perl_my_socketpair
#define my_strftime(a,b,c,d,e,f,g,h,i,j)	Perl_my_strftime(aTHX_ a,b,c,d,e,f,g,h,i,j)
#define newANONATTRSUB(a,b,c,d)	Perl_newANONATTRSUB(aTHX_ a,b,c,d)
#define newANONHASH(a)		Perl_newANONHASH(aTHX_ a)
#define newANONLIST(a)		Perl_newANONLIST(aTHX_ a)
#define newANONSUB(a,b,c)	Perl_newANONSUB(aTHX_ a,b,c)
#define newASSIGNOP(a,b,c,d)	Perl_newASSIGNOP(aTHX_ a,b,c,d)
#define newAVREF(a)		Perl_newAVREF(aTHX_ a)
#define newBINOP(a,b,c,d)	Perl_newBINOP(aTHX_ a,b,c,d)
#define newCONDOP(a,b,c,d)	Perl_newCONDOP(aTHX_ a,b,c,d)
#define newCONSTSUB(a,b,c)	Perl_newCONSTSUB(aTHX_ a,b,c)
#define newCONSTSUB_flags(a,b,c,d,e)	Perl_newCONSTSUB_flags(aTHX_ a,b,c,d,e)
#define newCVREF(a,b)		Perl_newCVREF(aTHX_ a,b)
#define newFOROP(a,b,c,d,e)	Perl_newFOROP(aTHX_ a,b,c,d,e)
#define newGIVENOP(a,b,c)	Perl_newGIVENOP(aTHX_ a,b,c)
#define newGVOP(a,b,c)		Perl_newGVOP(aTHX_ a,b,c)
#define newGVREF(a,b)		Perl_newGVREF(aTHX_ a,b)
#define newGVgen_flags(a,b)	Perl_newGVgen_flags(aTHX_ a,b)
#define newHVREF(a)		Perl_newHVREF(aTHX_ a)
#define newHVhv(a)		Perl_newHVhv(aTHX_ a)
#define newLISTOP(a,b,c,d)	Perl_newLISTOP(aTHX_ a,b,c,d)
#define newLOGOP(a,b,c,d)	Perl_newLOGOP(aTHX_ a,b,c,d)
#define newLOOPEX(a,b)		Perl_newLOOPEX(aTHX_ a,b)
#define newLOOPOP(a,b,c,d)	Perl_newLOOPOP(aTHX_ a,b,c,d)
#define newMYSUB(a,b,c,d,e)	Perl_newMYSUB(aTHX_ a,b,c,d,e)
#define newNULLLIST()		Perl_newNULLLIST(aTHX)
#define newOP(a,b)		Perl_newOP(aTHX_ a,b)
#define newPMOP(a,b)		Perl_newPMOP(aTHX_ a,b)
#define newPROG(a)		Perl_newPROG(aTHX_ a)
#define newPVOP(a,b,c)		Perl_newPVOP(aTHX_ a,b,c)
#define newRANGE(a,b,c)		Perl_newRANGE(aTHX_ a,b,c)
#define newRV(a)		Perl_newRV(aTHX_ a)
#define newRV_noinc(a)		Perl_newRV_noinc(aTHX_ a)
#define newSLICEOP(a,b,c)	Perl_newSLICEOP(aTHX_ a,b,c)
#define newSTATEOP(a,b,c)	Perl_newSTATEOP(aTHX_ a,b,c)
#define newSV(a)		Perl_newSV(aTHX_ a)
#define newSVOP(a,b,c)		Perl_newSVOP(aTHX_ a,b,c)
#define newSVREF(a)		Perl_newSVREF(aTHX_ a)
#define newSV_type(a)		Perl_newSV_type(aTHX_ a)
#define newSVhek(a)		Perl_newSVhek(aTHX_ a)
#define newSViv(a)		Perl_newSViv(aTHX_ a)
#define newSVnv(a)		Perl_newSVnv(aTHX_ a)
#define newSVpv(a,b)		Perl_newSVpv(aTHX_ a,b)
#define newSVpv_share(a,b)	Perl_newSVpv_share(aTHX_ a,b)
#ifndef PERL_IMPLICIT_CONTEXT
#define newSVpvf		Perl_newSVpvf
#endif
#define newSVpvn(a,b)		Perl_newSVpvn(aTHX_ a,b)
#define newSVpvn_flags(a,b,c)	Perl_newSVpvn_flags(aTHX_ a,b,c)
#define newSVpvn_share(a,b,c)	Perl_newSVpvn_share(aTHX_ a,b,c)
#define newSVrv(a,b)		Perl_newSVrv(aTHX_ a,b)
#define newSVsv(a)		Perl_newSVsv(aTHX_ a)
#define newSVuv(a)		Perl_newSVuv(aTHX_ a)
#define newUNOP(a,b,c)		Perl_newUNOP(aTHX_ a,b,c)
#define newWHENOP(a,b)		Perl_newWHENOP(aTHX_ a,b)
#define newWHILEOP(a,b,c,d,e,f,g)	Perl_newWHILEOP(aTHX_ a,b,c,d,e,f,g)
#define newXS(a,b,c)		Perl_newXS(aTHX_ a,b,c)
#define newXS_flags(a,b,c,d,e)	Perl_newXS_flags(aTHX_ a,b,c,d,e)
#define new_collate(a)		Perl_new_collate(aTHX_ a)
#define new_ctype(a)		Perl_new_ctype(aTHX_ a)
#define new_numeric(a)		Perl_new_numeric(aTHX_ a)
#define new_stackinfo(a,b)	Perl_new_stackinfo(aTHX_ a,b)
#define new_version(a)		Perl_new_version(aTHX_ a)
#define ninstr			Perl_ninstr
#define nothreadhook()		Perl_nothreadhook(aTHX)
#define op_append_elem(a,b,c)	Perl_op_append_elem(aTHX_ a,b,c)
#define op_append_list(a,b,c)	Perl_op_append_list(aTHX_ a,b,c)
#define op_contextualize(a,b)	Perl_op_contextualize(aTHX_ a,b)
#define op_dump(a)		Perl_op_dump(aTHX_ a)
#define op_free(a)		Perl_op_free(aTHX_ a)
#define op_linklist(a)		Perl_op_linklist(aTHX_ a)
#define op_null(a)		Perl_op_null(aTHX_ a)
#define op_prepend_elem(a,b,c)	Perl_op_prepend_elem(aTHX_ a,b,c)
#define op_refcnt_lock()	Perl_op_refcnt_lock(aTHX)
#define op_refcnt_unlock()	Perl_op_refcnt_unlock(aTHX)
#define op_scope(a)		Perl_op_scope(aTHX_ a)
#define pack_cat(a,b,c,d,e,f,g)	Perl_pack_cat(aTHX_ a,b,c,d,e,f,g)
#define packlist(a,b,c,d,e)	Perl_packlist(aTHX_ a,b,c,d,e)
#define pad_add_anon(a,b)	Perl_pad_add_anon(aTHX_ a,b)
#define pad_add_name_pv(a,b,c,d)	Perl_pad_add_name_pv(aTHX_ a,b,c,d)
#define pad_add_name_pvn(a,b,c,d,e)	Perl_pad_add_name_pvn(aTHX_ a,b,c,d,e)
#define pad_add_name_sv(a,b,c,d)	Perl_pad_add_name_sv(aTHX_ a,b,c,d)
#define pad_alloc(a,b)		Perl_pad_alloc(aTHX_ a,b)
#define pad_compname_type(a)	Perl_pad_compname_type(aTHX_ a)
#define pad_findmy_pv(a,b)	Perl_pad_findmy_pv(aTHX_ a,b)
#define pad_findmy_pvn(a,b,c)	Perl_pad_findmy_pvn(aTHX_ a,b,c)
#define pad_findmy_sv(a,b)	Perl_pad_findmy_sv(aTHX_ a,b)
#define pad_new(a)		Perl_pad_new(aTHX_ a)
#define pad_tidy(a)		Perl_pad_tidy(aTHX_ a)
#define parse_arithexpr(a)	Perl_parse_arithexpr(aTHX_ a)
#define parse_barestmt(a)	Perl_parse_barestmt(aTHX_ a)
#define parse_block(a)		Perl_parse_block(aTHX_ a)
#define parse_fullexpr(a)	Perl_parse_fullexpr(aTHX_ a)
#define parse_fullstmt(a)	Perl_parse_fullstmt(aTHX_ a)
#define parse_label(a)		Perl_parse_label(aTHX_ a)
#define parse_listexpr(a)	Perl_parse_listexpr(aTHX_ a)
#define parse_stmtseq(a)	Perl_parse_stmtseq(aTHX_ a)
#define parse_termexpr(a)	Perl_parse_termexpr(aTHX_ a)
#define pmop_dump(a)		Perl_pmop_dump(aTHX_ a)
#define pop_scope()		Perl_pop_scope(aTHX)
#define pregcomp(a,b)		Perl_pregcomp(aTHX_ a,b)
#define pregexec(a,b,c,d,e,f,g)	Perl_pregexec(aTHX_ a,b,c,d,e,f,g)
#define pregfree(a)		Perl_pregfree(aTHX_ a)
#define pregfree2(a)		Perl_pregfree2(aTHX_ a)
#define prescan_version(a,b,c,d,e,f,g)	Perl_prescan_version(aTHX_ a,b,c,d,e,f,g)
#define ptr_table_clear(a)	Perl_ptr_table_clear(aTHX_ a)
#define ptr_table_fetch(a,b)	Perl_ptr_table_fetch(aTHX_ a,b)
#define ptr_table_free(a)	Perl_ptr_table_free(aTHX_ a)
#define ptr_table_new()		Perl_ptr_table_new(aTHX)
#define ptr_table_split(a)	Perl_ptr_table_split(aTHX_ a)
#define ptr_table_store(a,b,c)	Perl_ptr_table_store(aTHX_ a,b,c)
#define push_scope()		Perl_push_scope(aTHX)
#define pv_display(a,b,c,d,e)	Perl_pv_display(aTHX_ a,b,c,d,e)
#define pv_escape(a,b,c,d,e,f)	Perl_pv_escape(aTHX_ a,b,c,d,e,f)
#define pv_pretty(a,b,c,d,e,f,g)	Perl_pv_pretty(aTHX_ a,b,c,d,e,f,g)
#define pv_uni_display(a,b,c,d,e)	Perl_pv_uni_display(aTHX_ a,b,c,d,e)
#define re_compile(a,b)		Perl_re_compile(aTHX_ a,b)
#define re_intuit_start(a,b,c,d,e,f,g)	Perl_re_intuit_start(aTHX_ a,b,c,d,e,f,g)
#define re_intuit_string(a)	Perl_re_intuit_string(aTHX_ a)
#define reentrant_free()	Perl_reentrant_free(aTHX)
#define reentrant_init()	Perl_reentrant_init(aTHX)
#define reentrant_retry		Perl_reentrant_retry
#define reentrant_size()	Perl_reentrant_size(aTHX)
#define reg_named_buff_all(a,b)	Perl_reg_named_buff_all(aTHX_ a,b)
#define reg_named_buff_exists(a,b,c)	Perl_reg_named_buff_exists(aTHX_ a,b,c)
#define reg_named_buff_fetch(a,b,c)	Perl_reg_named_buff_fetch(aTHX_ a,b,c)
#define reg_named_buff_firstkey(a,b)	Perl_reg_named_buff_firstkey(aTHX_ a,b)
#define reg_named_buff_nextkey(a,b)	Perl_reg_named_buff_nextkey(aTHX_ a,b)
#define reg_named_buff_scalar(a,b)	Perl_reg_named_buff_scalar(aTHX_ a,b)
#define regclass_swash(a,b,c,d,e)	Perl_regclass_swash(aTHX_ a,b,c,d,e)
#define regdump(a)		Perl_regdump(aTHX_ a)
#define regexec_flags(a,b,c,d,e,f,g,h)	Perl_regexec_flags(aTHX_ a,b,c,d,e,f,g,h)
#define regfree_internal(a)	Perl_regfree_internal(aTHX_ a)
#define reginitcolors()		Perl_reginitcolors(aTHX)
#define regnext(a)		Perl_regnext(aTHX_ a)
#define repeatcpy		Perl_repeatcpy
#define require_pv(a)		Perl_require_pv(aTHX_ a)
#define rninstr			Perl_rninstr
#define rsignal(a,b)		Perl_rsignal(aTHX_ a,b)
#define rsignal_state(a)	Perl_rsignal_state(aTHX_ a)
#define runops_debug()		Perl_runops_debug(aTHX)
#define runops_standard()	Perl_runops_standard(aTHX)
#define rv2cv_op_cv(a,b)	Perl_rv2cv_op_cv(aTHX_ a,b)
#define safesyscalloc		Perl_safesyscalloc
#define safesysfree		Perl_safesysfree
#define safesysmalloc		Perl_safesysmalloc
#define safesysrealloc		Perl_safesysrealloc
#define save_I16(a)		Perl_save_I16(aTHX_ a)
#define save_I32(a)		Perl_save_I32(aTHX_ a)
#define save_I8(a)		Perl_save_I8(aTHX_ a)
#define save_adelete(a,b)	Perl_save_adelete(aTHX_ a,b)
#define save_aelem_flags(a,b,c,d)	Perl_save_aelem_flags(aTHX_ a,b,c,d)
#define save_alloc(a,b)		Perl_save_alloc(aTHX_ a,b)
#define save_aptr(a)		Perl_save_aptr(aTHX_ a)
#define save_ary(a)		Perl_save_ary(aTHX_ a)
#define save_bool(a)		Perl_save_bool(aTHX_ a)
#define save_clearsv(a)		Perl_save_clearsv(aTHX_ a)
#define save_delete(a,b,c)	Perl_save_delete(aTHX_ a,b,c)
#define save_destructor(a,b)	Perl_save_destructor(aTHX_ a,b)
#define save_destructor_x(a,b)	Perl_save_destructor_x(aTHX_ a,b)
#define save_generic_pvref(a)	Perl_save_generic_pvref(aTHX_ a)
#define save_generic_svref(a)	Perl_save_generic_svref(aTHX_ a)
#define save_gp(a,b)		Perl_save_gp(aTHX_ a,b)
#define save_hash(a)		Perl_save_hash(aTHX_ a)
#define save_hdelete(a,b)	Perl_save_hdelete(aTHX_ a,b)
#define save_helem_flags(a,b,c,d)	Perl_save_helem_flags(aTHX_ a,b,c,d)
#define save_hints()		Perl_save_hints(aTHX)
#define save_hptr(a)		Perl_save_hptr(aTHX_ a)
#define save_int(a)		Perl_save_int(aTHX_ a)
#define save_item(a)		Perl_save_item(aTHX_ a)
#define save_iv(a)		Perl_save_iv(aTHX_ a)
#define save_list(a,b)		Perl_save_list(aTHX_ a,b)
#define save_long(a)		Perl_save_long(aTHX_ a)
#define save_nogv(a)		Perl_save_nogv(aTHX_ a)
#define save_padsv_and_mortalize(a)	Perl_save_padsv_and_mortalize(aTHX_ a)
#define save_pptr(a)		Perl_save_pptr(aTHX_ a)
#define save_pushi32ptr(a,b,c)	Perl_save_pushi32ptr(aTHX_ a,b,c)
#define save_pushptr(a,b)	Perl_save_pushptr(aTHX_ a,b)
#define save_pushptrptr(a,b,c)	Perl_save_pushptrptr(aTHX_ a,b,c)
#define save_re_context()	Perl_save_re_context(aTHX)
#define save_scalar(a)		Perl_save_scalar(aTHX_ a)
#define save_set_svflags(a,b,c)	Perl_save_set_svflags(aTHX_ a,b,c)
#define save_shared_pvref(a)	Perl_save_shared_pvref(aTHX_ a)
#define save_sptr(a)		Perl_save_sptr(aTHX_ a)
#define save_svref(a)		Perl_save_svref(aTHX_ a)
#define save_vptr(a)		Perl_save_vptr(aTHX_ a)
#define savepv(a)		Perl_savepv(aTHX_ a)
#define savepvn(a,b)		Perl_savepvn(aTHX_ a,b)
#define savesharedpv(a)		Perl_savesharedpv(aTHX_ a)
#define savesharedpvn(a,b)	Perl_savesharedpvn(aTHX_ a,b)
#define savesharedsvpv(a)	Perl_savesharedsvpv(aTHX_ a)
#define savestack_grow()	Perl_savestack_grow(aTHX)
#define savestack_grow_cnt(a)	Perl_savestack_grow_cnt(aTHX_ a)
#define savesvpv(a)		Perl_savesvpv(aTHX_ a)
#define scan_bin(a,b,c)		Perl_scan_bin(aTHX_ a,b,c)
#define scan_hex(a,b,c)		Perl_scan_hex(aTHX_ a,b,c)
#define scan_num(a,b)		Perl_scan_num(aTHX_ a,b)
#define scan_oct(a,b,c)		Perl_scan_oct(aTHX_ a,b,c)
#define scan_version(a,b,c)	Perl_scan_version(aTHX_ a,b,c)
#define scan_vstring(a,b,c)	Perl_scan_vstring(aTHX_ a,b,c)
#define screaminstr(a,b,c,d,e,f)	Perl_screaminstr(aTHX_ a,b,c,d,e,f)
#define seed()			Perl_seed(aTHX)
#define set_context		Perl_set_context
#define set_numeric_local()	Perl_set_numeric_local(aTHX)
#define set_numeric_radix()	Perl_set_numeric_radix(aTHX)
#define set_numeric_standard()	Perl_set_numeric_standard(aTHX)
#define setdefout(a)		Perl_setdefout(aTHX_ a)
#define share_hek(a,b,c)	Perl_share_hek(aTHX_ a,b,c)
#define sortsv(a,b,c)		Perl_sortsv(aTHX_ a,b,c)
#define sortsv_flags(a,b,c,d)	Perl_sortsv_flags(aTHX_ a,b,c,d)
#define stack_grow(a,b,c)	Perl_stack_grow(aTHX_ a,b,c)
#define start_subparse(a,b)	Perl_start_subparse(aTHX_ a,b)
#define str_to_version(a)	Perl_str_to_version(aTHX_ a)
#define sv_2bool_flags(a,b)	Perl_sv_2bool_flags(aTHX_ a,b)
#define sv_2cv(a,b,c,d)		Perl_sv_2cv(aTHX_ a,b,c,d)
#define sv_2io(a)		Perl_sv_2io(aTHX_ a)
#define sv_2iv_flags(a,b)	Perl_sv_2iv_flags(aTHX_ a,b)
#define sv_2mortal(a)		Perl_sv_2mortal(aTHX_ a)
#define sv_2nv_flags(a,b)	Perl_sv_2nv_flags(aTHX_ a,b)
#define sv_2pv_flags(a,b,c)	Perl_sv_2pv_flags(aTHX_ a,b,c)
#define sv_2pvbyte(a,b)		Perl_sv_2pvbyte(aTHX_ a,b)
#define sv_2pvutf8(a,b)		Perl_sv_2pvutf8(aTHX_ a,b)
#define sv_2uv_flags(a,b)	Perl_sv_2uv_flags(aTHX_ a,b)
#define sv_backoff(a)		Perl_sv_backoff(aTHX_ a)
#define sv_bless(a,b)		Perl_sv_bless(aTHX_ a,b)
#define sv_cat_decode(a,b,c,d,e,f)	Perl_sv_cat_decode(aTHX_ a,b,c,d,e,f)
#define sv_catpv(a,b)		Perl_sv_catpv(aTHX_ a,b)
#define sv_catpv_flags(a,b,c)	Perl_sv_catpv_flags(aTHX_ a,b,c)
#define sv_catpv_mg(a,b)	Perl_sv_catpv_mg(aTHX_ a,b)
#ifndef PERL_IMPLICIT_CONTEXT
#define sv_catpvf		Perl_sv_catpvf
#define sv_catpvf_mg		Perl_sv_catpvf_mg
#endif
#define sv_catpvn_flags(a,b,c,d)	Perl_sv_catpvn_flags(aTHX_ a,b,c,d)
#define sv_catsv_flags(a,b,c)	Perl_sv_catsv_flags(aTHX_ a,b,c)
#define sv_chop(a,b)		Perl_sv_chop(aTHX_ a,b)
#define sv_clear(a)		Perl_sv_clear(aTHX_ a)
#define sv_cmp_flags(a,b,c)	Perl_sv_cmp_flags(aTHX_ a,b,c)
#define sv_cmp_locale_flags(a,b,c)	Perl_sv_cmp_locale_flags(aTHX_ a,b,c)
#define sv_copypv_flags(a,b,c)	Perl_sv_copypv_flags(aTHX_ a,b,c)
#define sv_dec(a)		Perl_sv_dec(aTHX_ a)
#define sv_dec_nomg(a)		Perl_sv_dec_nomg(aTHX_ a)
#define sv_derived_from(a,b)	Perl_sv_derived_from(aTHX_ a,b)
#define sv_derived_from_pv(a,b,c)	Perl_sv_derived_from_pv(aTHX_ a,b,c)
#define sv_derived_from_pvn(a,b,c,d)	Perl_sv_derived_from_pvn(aTHX_ a,b,c,d)
#define sv_derived_from_sv(a,b,c)	Perl_sv_derived_from_sv(aTHX_ a,b,c)
#define sv_destroyable(a)	Perl_sv_destroyable(aTHX_ a)
#define sv_does(a,b)		Perl_sv_does(aTHX_ a,b)
#define sv_does_pv(a,b,c)	Perl_sv_does_pv(aTHX_ a,b,c)
#define sv_does_pvn(a,b,c,d)	Perl_sv_does_pvn(aTHX_ a,b,c,d)
#define sv_does_sv(a,b,c)	Perl_sv_does_sv(aTHX_ a,b,c)
#define sv_dump(a)		Perl_sv_dump(aTHX_ a)
#define sv_eq_flags(a,b,c)	Perl_sv_eq_flags(aTHX_ a,b,c)
#define sv_force_normal_flags(a,b)	Perl_sv_force_normal_flags(aTHX_ a,b)
#define sv_free(a)		Perl_sv_free(aTHX_ a)
#define sv_gets(a,b,c)		Perl_sv_gets(aTHX_ a,b,c)
#define sv_grow(a,b)		Perl_sv_grow(aTHX_ a,b)
#define sv_inc(a)		Perl_sv_inc(aTHX_ a)
#define sv_inc_nomg(a)		Perl_sv_inc_nomg(aTHX_ a)
#define sv_insert_flags(a,b,c,d,e,f)	Perl_sv_insert_flags(aTHX_ a,b,c,d,e,f)
#define sv_isa(a,b)		Perl_sv_isa(aTHX_ a,b)
#define sv_isobject(a)		Perl_sv_isobject(aTHX_ a)
#define sv_iv(a)		Perl_sv_iv(aTHX_ a)
#define sv_len(a)		Perl_sv_len(aTHX_ a)
#define sv_len_utf8(a)		Perl_sv_len_utf8(aTHX_ a)
#define sv_magic(a,b,c,d,e)	Perl_sv_magic(aTHX_ a,b,c,d,e)
#define sv_magicext(a,b,c,d,e,f)	Perl_sv_magicext(aTHX_ a,b,c,d,e,f)
#define sv_newmortal()		Perl_sv_newmortal(aTHX)
#define sv_newref(a)		Perl_sv_newref(aTHX_ a)
#define sv_nosharing(a)		Perl_sv_nosharing(aTHX_ a)
#define sv_nv(a)		Perl_sv_nv(aTHX_ a)
#define sv_peek(a)		Perl_sv_peek(aTHX_ a)
#define sv_pos_b2u(a,b)		Perl_sv_pos_b2u(aTHX_ a,b)
#define sv_pos_b2u_flags(a,b,c)	Perl_sv_pos_b2u_flags(aTHX_ a,b,c)
#define sv_pos_u2b(a,b,c)	Perl_sv_pos_u2b(aTHX_ a,b,c)
#define sv_pos_u2b_flags(a,b,c,d)	Perl_sv_pos_u2b_flags(aTHX_ a,b,c,d)
#define sv_pvbyten(a,b)		Perl_sv_pvbyten(aTHX_ a,b)
#define sv_pvbyten_force(a,b)	Perl_sv_pvbyten_force(aTHX_ a,b)
#define sv_pvn(a,b)		Perl_sv_pvn(aTHX_ a,b)
#define sv_pvn_force_flags(a,b,c)	Perl_sv_pvn_force_flags(aTHX_ a,b,c)
#define sv_pvn_nomg(a,b)	Perl_sv_pvn_nomg(aTHX_ a,b)
#define sv_pvutf8n(a,b)		Perl_sv_pvutf8n(aTHX_ a,b)
#define sv_pvutf8n_force(a,b)	Perl_sv_pvutf8n_force(aTHX_ a,b)
#define sv_recode_to_utf8(a,b)	Perl_sv_recode_to_utf8(aTHX_ a,b)
#define sv_reftype(a,b)		Perl_sv_reftype(aTHX_ a,b)
#define sv_replace(a,b)		Perl_sv_replace(aTHX_ a,b)
#define sv_report_used()	Perl_sv_report_used(aTHX)
#define sv_reset(a,b)		Perl_sv_reset(aTHX_ a,b)
#define sv_rvweaken(a)		Perl_sv_rvweaken(aTHX_ a)
#define sv_setiv(a,b)		Perl_sv_setiv(aTHX_ a,b)
#define sv_setiv_mg(a,b)	Perl_sv_setiv_mg(aTHX_ a,b)
#define sv_setnv(a,b)		Perl_sv_setnv(aTHX_ a,b)
#define sv_setnv_mg(a,b)	Perl_sv_setnv_mg(aTHX_ a,b)
#define sv_setpv(a,b)		Perl_sv_setpv(aTHX_ a,b)
#define sv_setpv_mg(a,b)	Perl_sv_setpv_mg(aTHX_ a,b)
#ifndef PERL_IMPLICIT_CONTEXT
#define sv_setpvf		Perl_sv_setpvf
#define sv_setpvf_mg		Perl_sv_setpvf_mg
#endif
#define sv_setpviv(a,b)		Perl_sv_setpviv(aTHX_ a,b)
#define sv_setpviv_mg(a,b)	Perl_sv_setpviv_mg(aTHX_ a,b)
#define sv_setpvn(a,b,c)	Perl_sv_setpvn(aTHX_ a,b,c)
#define sv_setpvn_mg(a,b,c)	Perl_sv_setpvn_mg(aTHX_ a,b,c)
#define sv_setref_iv(a,b,c)	Perl_sv_setref_iv(aTHX_ a,b,c)
#define sv_setref_nv(a,b,c)	Perl_sv_setref_nv(aTHX_ a,b,c)
#define sv_setref_pv(a,b,c)	Perl_sv_setref_pv(aTHX_ a,b,c)
#define sv_setref_pvn(a,b,c,d)	Perl_sv_setref_pvn(aTHX_ a,b,c,d)
#define sv_setref_uv(a,b,c)	Perl_sv_setref_uv(aTHX_ a,b,c)
#define sv_setsv_flags(a,b,c)	Perl_sv_setsv_flags(aTHX_ a,b,c)
#define sv_setsv_mg(a,b)	Perl_sv_setsv_mg(aTHX_ a,b)
#define sv_setuv(a,b)		Perl_sv_setuv(aTHX_ a,b)
#define sv_setuv_mg(a,b)	Perl_sv_setuv_mg(aTHX_ a,b)
#define sv_tainted(a)		Perl_sv_tainted(aTHX_ a)
#define sv_true(a)		Perl_sv_true(aTHX_ a)
#define sv_uni_display(a,b,c,d)	Perl_sv_uni_display(aTHX_ a,b,c,d)
#define sv_unmagic(a,b)		Perl_sv_unmagic(aTHX_ a,b)
#define sv_unmagicext(a,b,c)	Perl_sv_unmagicext(aTHX_ a,b,c)
#define sv_unref_flags(a,b)	Perl_sv_unref_flags(aTHX_ a,b)
#define sv_untaint(a)		Perl_sv_untaint(aTHX_ a)
#define sv_upgrade(a,b)		Perl_sv_upgrade(aTHX_ a,b)
#define sv_usepvn_flags(a,b,c,d)	Perl_sv_usepvn_flags(aTHX_ a,b,c,d)
#define sv_utf8_decode(a)	Perl_sv_utf8_decode(aTHX_ a)
#define sv_utf8_downgrade(a,b)	Perl_sv_utf8_downgrade(aTHX_ a,b)
#define sv_utf8_encode(a)	Perl_sv_utf8_encode(aTHX_ a)
#define sv_utf8_upgrade_flags_grow(a,b,c)	Perl_sv_utf8_upgrade_flags_grow(aTHX_ a,b,c)
#define sv_uv(a)		Perl_sv_uv(aTHX_ a)
#define sv_vcatpvf(a,b,c)	Perl_sv_vcatpvf(aTHX_ a,b,c)
#define sv_vcatpvf_mg(a,b,c)	Perl_sv_vcatpvf_mg(aTHX_ a,b,c)
#define sv_vcatpvfn(a,b,c,d,e,f,g)	Perl_sv_vcatpvfn(aTHX_ a,b,c,d,e,f,g)
#define sv_vcatpvfn_flags(a,b,c,d,e,f,g,h)	Perl_sv_vcatpvfn_flags(aTHX_ a,b,c,d,e,f,g,h)
#define sv_vsetpvf(a,b,c)	Perl_sv_vsetpvf(aTHX_ a,b,c)
#define sv_vsetpvf_mg(a,b,c)	Perl_sv_vsetpvf_mg(aTHX_ a,b,c)
#define sv_vsetpvfn(a,b,c,d,e,f,g)	Perl_sv_vsetpvfn(aTHX_ a,b,c,d,e,f,g)
#define swash_fetch(a,b,c)	Perl_swash_fetch(aTHX_ a,b,c)
#define swash_init(a,b,c,d,e)	Perl_swash_init(aTHX_ a,b,c,d,e)
#define taint_env()		Perl_taint_env(aTHX)
#define taint_proper(a,b)	Perl_taint_proper(aTHX_ a,b)
#define tmps_grow(a)		Perl_tmps_grow(aTHX_ a)
#define to_uni_lower(a,b,c)	Perl_to_uni_lower(aTHX_ a,b,c)
#define to_uni_lower_lc(a)	Perl_to_uni_lower_lc(aTHX_ a)
#define to_uni_title(a,b,c)	Perl_to_uni_title(aTHX_ a,b,c)
#define to_uni_title_lc(a)	Perl_to_uni_title_lc(aTHX_ a)
#define to_uni_upper(a,b,c)	Perl_to_uni_upper(aTHX_ a,b,c)
#define to_uni_upper_lc(a)	Perl_to_uni_upper_lc(aTHX_ a)
#define to_utf8_case(a,b,c,d,e,f)	Perl_to_utf8_case(aTHX_ a,b,c,d,e,f)
#define unpack_str(a,b,c,d,e,f,g,h)	Perl_unpack_str(aTHX_ a,b,c,d,e,f,g,h)
#define unpackstring(a,b,c,d,e)	Perl_unpackstring(aTHX_ a,b,c,d,e)
#define unsharepvn(a,b,c)	Perl_unsharepvn(aTHX_ a,b,c)
#define upg_version(a,b)	Perl_upg_version(aTHX_ a,b)
#define utf16_to_utf8(a,b,c,d)	Perl_utf16_to_utf8(aTHX_ a,b,c,d)
#define utf16_to_utf8_reversed(a,b,c,d)	Perl_utf16_to_utf8_reversed(aTHX_ a,b,c,d)
#define utf8_distance(a,b)	Perl_utf8_distance(aTHX_ a,b)
#define utf8_hop(a,b)		Perl_utf8_hop(aTHX_ a,b)
#define utf8_length(a,b)	Perl_utf8_length(aTHX_ a,b)
#define utf8_to_bytes(a,b)	Perl_utf8_to_bytes(aTHX_ a,b)
#define utf8_to_uvchr(a,b)	Perl_utf8_to_uvchr(aTHX_ a,b)
#define utf8_to_uvuni(a,b)	Perl_utf8_to_uvuni(aTHX_ a,b)
#define utf8_to_uvuni_buf(a,b,c)	Perl_utf8_to_uvuni_buf(aTHX_ a,b,c)
#define utf8n_to_uvchr(a,b,c,d)	Perl_utf8n_to_uvchr(aTHX_ a,b,c,d)
#define utf8n_to_uvuni(a,b,c,d)	Perl_utf8n_to_uvuni(aTHX_ a,b,c,d)
#define uvoffuni_to_utf8_flags(a,b,c)	Perl_uvoffuni_to_utf8_flags(aTHX_ a,b,c)
#define uvuni_to_utf8(a,b)	Perl_uvuni_to_utf8(aTHX_ a,b)
#define uvuni_to_utf8_flags(a,b,c)	Perl_uvuni_to_utf8_flags(aTHX_ a,b,c)
#define valid_utf8_to_uvchr(a,b)	Perl_valid_utf8_to_uvchr(aTHX_ a,b)
#define valid_utf8_to_uvuni(a,b)	Perl_valid_utf8_to_uvuni(aTHX_ a,b)
#define vcmp(a,b)		Perl_vcmp(aTHX_ a,b)
#define vcroak(a,b)		Perl_vcroak(aTHX_ a,b)
#define vdeb(a,b)		Perl_vdeb(aTHX_ a,b)
#define vform(a,b)		Perl_vform(aTHX_ a,b)
#define vload_module(a,b,c,d)	Perl_vload_module(aTHX_ a,b,c,d)
#define vmess(a,b)		Perl_vmess(aTHX_ a,b)
#define vnewSVpvf(a,b)		Perl_vnewSVpvf(aTHX_ a,b)
#define vnormal(a)		Perl_vnormal(aTHX_ a)
#define vnumify(a)		Perl_vnumify(aTHX_ a)
#define vstringify(a)		Perl_vstringify(aTHX_ a)
#define vverify(a)		Perl_vverify(aTHX_ a)
#define vwarn(a,b)		Perl_vwarn(aTHX_ a,b)
#define vwarner(a,b,c)		Perl_vwarner(aTHX_ a,b,c)
#ifndef PERL_IMPLICIT_CONTEXT
#define warn			Perl_warn
#endif
#define warn_sv(a)		Perl_warn_sv(aTHX_ a)
#ifndef PERL_IMPLICIT_CONTEXT
#define warner			Perl_warner
#endif
#define whichsig_pv(a)		Perl_whichsig_pv(aTHX_ a)
#define whichsig_pvn(a,b)	Perl_whichsig_pvn(aTHX_ a,b)
#define whichsig_sv(a)		Perl_whichsig_sv(aTHX_ a)
#define wrap_op_checker(a,b,c)	Perl_wrap_op_checker(aTHX_ a,b,c)
#if !(defined(HAS_SIGACTION) && defined(SA_SIGINFO))
#define csighandler		Perl_csighandler
#endif
#if !(defined(NO_MATHOMS))
#define sv_nounlocking(a)	Perl_sv_nounlocking(aTHX_ a)
#endif
#if !(defined(PERL_MAD))
#define newFORM(a,b,c)		Perl_newFORM(aTHX_ a,b,c)
#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
#define my_bzero		Perl_my_bzero
#endif
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
#define my_memcmp		Perl_my_memcmp
#endif
#if !defined(HAS_MEMSET)
#define my_memset		Perl_my_memset
#endif
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
#define my_chsize(a,b)		Perl_my_chsize(aTHX_ a,b)
#endif
#if !defined(PERL_IMPLICIT_SYS)
#define my_pclose(a)		Perl_my_pclose(aTHX_ a)
#define my_popen(a,b)		Perl_my_popen(aTHX_ a,b)
#endif
#if (!defined(HAS_MEMCPY) && !defined(HAS_BCOPY)) || (!defined(HAS_MEMMOVE) && !defined(HAS_SAFE_MEMCPY) && !defined(HAS_SAFE_BCOPY))
#define my_bcopy		Perl_my_bcopy
#endif
#if defined(DEBUGGING)
#define pad_setsv(a,b)		Perl_pad_setsv(aTHX_ a,b)
#define pad_sv(a)		Perl_pad_sv(aTHX_ a)
#endif
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
#define csighandler		Perl_csighandler
#endif
#if defined(HAVE_INTERP_INTERN)
#define sys_intern_clear()	Perl_sys_intern_clear(aTHX)
#define sys_intern_init()	Perl_sys_intern_init(aTHX)
#  if defined(USE_ITHREADS)
#define sys_intern_dup(a,b)	Perl_sys_intern_dup(aTHX_ a,b)
#  endif
#endif
#if defined(MYMALLOC)
#define dump_mstats(a)		Perl_dump_mstats(aTHX_ a)
#define get_mstats(a,b,c)	Perl_get_mstats(aTHX_ a,b,c)
#endif
#if defined(PERL_GLOBAL_STRUCT)
#define GetVars()		Perl_GetVars(aTHX)
#define free_global_struct(a)	Perl_free_global_struct(aTHX_ a)
#define init_global_struct()	Perl_init_global_struct(aTHX)
#endif
#if defined(PERL_IMPLICIT_CONTEXT)
#define croak_nocontext		Perl_croak_nocontext
#define deb_nocontext		Perl_deb_nocontext
#define die_nocontext		Perl_die_nocontext
#define form_nocontext		Perl_form_nocontext
#define fprintf_nocontext	Perl_fprintf_nocontext
#define load_module_nocontext	Perl_load_module_nocontext
#define mess_nocontext		Perl_mess_nocontext
#define newSVpvf_nocontext	Perl_newSVpvf_nocontext
#define printf_nocontext	Perl_printf_nocontext
#define sv_catpvf_mg_nocontext	Perl_sv_catpvf_mg_nocontext
#define sv_catpvf_nocontext	Perl_sv_catpvf_nocontext
#define sv_setpvf_mg_nocontext	Perl_sv_setpvf_mg_nocontext
#define sv_setpvf_nocontext	Perl_sv_setpvf_nocontext
#define warn_nocontext		Perl_warn_nocontext
#define warner_nocontext	Perl_warner_nocontext
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_PERL_C) || defined(PERL_IN_UTF8_C)
#define _new_invlist_C_array(a)	Perl__new_invlist_C_array(aTHX_ a)
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)
#define _get_regclass_nonbitmap_data(a,b,c,d,e)	Perl__get_regclass_nonbitmap_data(aTHX_ a,b,c,d,e)
#endif
#if defined(PERL_MAD)
#define newFORM(a,b,c)		Perl_newFORM(aTHX_ a,b,c)
#endif
#if defined(UNLINK_ALL_VERSIONS)
#define unlnk(a)		Perl_unlnk(aTHX_ a)
#endif
#if defined(USE_ITHREADS)
#define alloccopstash(a)	Perl_alloccopstash(aTHX_ a)
#define any_dup(a,b)		Perl_any_dup(aTHX_ a,b)
#define cx_dup(a,b,c,d)		Perl_cx_dup(aTHX_ a,b,c,d)
#define dirp_dup(a,b)		Perl_dirp_dup(aTHX_ a,b)
#define fp_dup(a,b,c)		Perl_fp_dup(aTHX_ a,b,c)
#define gp_dup(a,b)		Perl_gp_dup(aTHX_ a,b)
#define he_dup(a,b,c)		Perl_he_dup(aTHX_ a,b,c)
#define hek_dup(a,b)		Perl_hek_dup(aTHX_ a,b)
#define mg_dup(a,b)		Perl_mg_dup(aTHX_ a,b)
#define newPADOP(a,b,c)		Perl_newPADOP(aTHX_ a,b,c)
#define parser_dup(a,b)		Perl_parser_dup(aTHX_ a,b)
#define re_dup_guts(a,b,c)	Perl_re_dup_guts(aTHX_ a,b,c)
#define regdupe_internal(a,b)	Perl_regdupe_internal(aTHX_ a,b)
#define rvpv_dup(a,b,c)		Perl_rvpv_dup(aTHX_ a,b,c)
#define si_dup(a,b)		Perl_si_dup(aTHX_ a,b)
#define ss_dup(a,b)		Perl_ss_dup(aTHX_ a,b)
#define sv_dup(a,b)		Perl_sv_dup(aTHX_ a,b)
#define sv_dup_inc(a,b)		Perl_sv_dup_inc(aTHX_ a,b)
#endif
#if defined(USE_LOCALE_COLLATE)
#define sv_collxfrm_flags(a,b,c)	Perl_sv_collxfrm_flags(aTHX_ a,b,c)
#endif
#if defined(USE_PERLIO)
#define PerlIO_clearerr(a)	Perl_PerlIO_clearerr(aTHX_ a)
#define PerlIO_close(a)		Perl_PerlIO_close(aTHX_ a)
#define PerlIO_eof(a)		Perl_PerlIO_eof(aTHX_ a)
#define PerlIO_error(a)		Perl_PerlIO_error(aTHX_ a)
#define PerlIO_fileno(a)	Perl_PerlIO_fileno(aTHX_ a)
#define PerlIO_fill(a)		Perl_PerlIO_fill(aTHX_ a)
#define PerlIO_flush(a)		Perl_PerlIO_flush(aTHX_ a)
#define PerlIO_get_base(a)	Perl_PerlIO_get_base(aTHX_ a)
#define PerlIO_get_bufsiz(a)	Perl_PerlIO_get_bufsiz(aTHX_ a)
#define PerlIO_get_cnt(a)	Perl_PerlIO_get_cnt(aTHX_ a)
#define PerlIO_get_ptr(a)	Perl_PerlIO_get_ptr(aTHX_ a)
#define PerlIO_read(a,b,c)	Perl_PerlIO_read(aTHX_ a,b,c)
#define PerlIO_seek(a,b,c)	Perl_PerlIO_seek(aTHX_ a,b,c)
#define PerlIO_set_cnt(a,b)	Perl_PerlIO_set_cnt(aTHX_ a,b)
#define PerlIO_set_ptrcnt(a,b,c)	Perl_PerlIO_set_ptrcnt(aTHX_ a,b,c)
#define PerlIO_setlinebuf(a)	Perl_PerlIO_setlinebuf(aTHX_ a)
#define PerlIO_stderr()		Perl_PerlIO_stderr(aTHX)
#define PerlIO_stdin()		Perl_PerlIO_stdin(aTHX)
#define PerlIO_stdout()		Perl_PerlIO_stdout(aTHX)
#define PerlIO_tell(a)		Perl_PerlIO_tell(aTHX_ a)
#define PerlIO_unread(a,b,c)	Perl_PerlIO_unread(aTHX_ a,b,c)
#define PerlIO_write(a,b,c)	Perl_PerlIO_write(aTHX_ a,b,c)
#endif
#if defined(WIN32)
#define my_setlocale(a,b)	Perl_my_setlocale(aTHX_ a,b)
#endif
#if defined(WIN32) || defined(__SYMBIAN32__) || defined(VMS)
#define do_aspawn(a,b,c)	Perl_do_aspawn(aTHX_ a,b,c)
#define do_spawn(a)		Perl_do_spawn(aTHX_ a)
#define do_spawn_nowait(a)	Perl_do_spawn_nowait(aTHX_ a)
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define av_reify(a)		Perl_av_reify(aTHX_ a)
#define current_re_engine()	Perl_current_re_engine(aTHX)
#define cv_ckproto_len_flags(a,b,c,d,e)	Perl_cv_ckproto_len_flags(aTHX_ a,b,c,d,e)
#define mg_find_mglob(a)	Perl_mg_find_mglob(aTHX_ a)
#define op_clear(a)		Perl_op_clear(aTHX_ a)
#define qerror(a)		Perl_qerror(aTHX_ a)
#define reg_named_buff(a,b,c,d)	Perl_reg_named_buff(aTHX_ a,b,c,d)
#define reg_named_buff_iter(a,b,c)	Perl_reg_named_buff_iter(aTHX_ a,b,c)
#define reg_numbered_buff_fetch(a,b,c)	Perl_reg_numbered_buff_fetch(aTHX_ a,b,c)
#define reg_numbered_buff_length(a,b,c)	Perl_reg_numbered_buff_length(aTHX_ a,b,c)
#define reg_numbered_buff_store(a,b,c)	Perl_reg_numbered_buff_store(aTHX_ a,b,c)
#define reg_qr_package(a)	Perl_reg_qr_package(aTHX_ a)
#define reg_temp_copy(a,b)	Perl_reg_temp_copy(aTHX_ a,b)
#define regprop(a,b,c,d)	Perl_regprop(aTHX_ a,b,c,d)
#define report_uninit(a)	Perl_report_uninit(aTHX_ a)
#define sv_magicext_mglob(a)	Perl_sv_magicext_mglob(aTHX_ a)
#define sv_only_taint_gmagic	S_sv_only_taint_gmagic
#define validate_proto(a,b,c)	Perl_validate_proto(aTHX_ a,b,c)
#define vivify_defelem(a)	Perl_vivify_defelem(aTHX_ a)
#define yylex()			Perl_yylex(aTHX)
#  if defined(DEBUGGING)
#    if defined(PERL_IN_REGCOMP_C)
#define dump_trie(a,b,c,d)	S_dump_trie(aTHX_ a,b,c,d)
#define dump_trie_interim_list(a,b,c,d,e)	S_dump_trie_interim_list(aTHX_ a,b,c,d,e)
#define dump_trie_interim_table(a,b,c,d,e)	S_dump_trie_interim_table(aTHX_ a,b,c,d,e)
#define dumpuntil(a,b,c,d,e,f,g,h)	S_dumpuntil(aTHX_ a,b,c,d,e,f,g,h)
#define put_byte(a,b)		S_put_byte(aTHX_ a,b)
#define put_latin1_charclass_innards(a,b)	S_put_latin1_charclass_innards(aTHX_ a,b)
#define put_range(a,b,c)	S_put_range(aTHX_ a,b,c)
#define regdump_extflags(a,b)	S_regdump_extflags(aTHX_ a,b)
#define regdump_intflags(a,b)	S_regdump_intflags(aTHX_ a,b)
#define regtail_study(a,b,c,d)	S_regtail_study(aTHX_ a,b,c,d)
#    endif
#    if defined(PERL_IN_REGEXEC_C)
#define debug_start_match(a,b,c,d,e)	S_debug_start_match(aTHX_ a,b,c,d,e)
#define dump_exec_pos(a,b,c,d,e,f)	S_dump_exec_pos(aTHX_ a,b,c,d,e,f)
#    endif
#  endif
#  if defined(PERL_ANY_COW)
#define sv_setsv_cow(a,b)	Perl_sv_setsv_cow(aTHX_ a,b)
#  endif
#  if defined(PERL_CORE) || defined (PERL_EXT)
#define sv_or_pv_pos_u2b(a,b,c,d)	S_sv_or_pv_pos_u2b(aTHX_ a,b,c,d)
#  endif
#  if defined(PERL_IN_REGCOMP_C)
#define _append_range_to_invlist(a,b,c)	S__append_range_to_invlist(aTHX_ a,b,c)
#define _invlist_array_init(a,b)	S__invlist_array_init(aTHX_ a,b)
#define add_cp_to_invlist(a,b)	S_add_cp_to_invlist(aTHX_ a,b)
#define add_data		S_add_data
#define alloc_maybe_populate_EXACT(a,b,c,d,e,f)	S_alloc_maybe_populate_EXACT(aTHX_ a,b,c,d,e,f)
#define compute_EXACTish(a)	S_compute_EXACTish(aTHX_ a)
#define could_it_be_a_POSIX_class(a)	S_could_it_be_a_POSIX_class(aTHX_ a)
#define get_ANYOF_cp_list_for_ssc(a,b)	S_get_ANYOF_cp_list_for_ssc(aTHX_ a,b)
#define get_invlist_iter_addr(a)	S_get_invlist_iter_addr(aTHX_ a)
#define get_invlist_previous_index_addr(a)	S_get_invlist_previous_index_addr(aTHX_ a)
#define grok_bslash_N(a,b,c,d,e,f,g)	S_grok_bslash_N(aTHX_ a,b,c,d,e,f,g)
#define handle_regex_sets(a,b,c,d,e)	S_handle_regex_sets(aTHX_ a,b,c,d,e)
#define invlist_array(a)	S_invlist_array(aTHX_ a)
#define invlist_clone(a)	S_invlist_clone(aTHX_ a)
#define invlist_extend(a,b)	S_invlist_extend(aTHX_ a,b)
#define invlist_highest(a)	S_invlist_highest(aTHX_ a)
#define invlist_is_iterating(a)	S_invlist_is_iterating(aTHX_ a)
#define invlist_iterfinish(a)	S_invlist_iterfinish(aTHX_ a)
#define invlist_iterinit(a)	S_invlist_iterinit(aTHX_ a)
#define invlist_iternext(a,b,c)	S_invlist_iternext(aTHX_ a,b,c)
#define invlist_max(a)		S_invlist_max(aTHX_ a)
#define invlist_previous_index(a)	S_invlist_previous_index(aTHX_ a)
#define invlist_set_len(a,b,c)	S_invlist_set_len(aTHX_ a,b,c)
#define invlist_set_previous_index(a,b)	S_invlist_set_previous_index(aTHX_ a,b)
#define invlist_trim(a)		S_invlist_trim(aTHX_ a)
#define join_exact(a,b,c,d,e,f,g)	S_join_exact(aTHX_ a,b,c,d,e,f,g)
#define make_trie(a,b,c,d,e,f,g,h)	S_make_trie(aTHX_ a,b,c,d,e,f,g,h)
#define make_trie_failtable(a,b,c,d)	S_make_trie_failtable(aTHX_ a,b,c,d)
#define nextchar(a)		S_nextchar(aTHX_ a)
#define parse_lparen_question_flags(a)	S_parse_lparen_question_flags(aTHX_ a)
#define populate_ANYOF_from_invlist(a,b)	S_populate_ANYOF_from_invlist(aTHX_ a,b)
#define reg(a,b,c,d)		S_reg(aTHX_ a,b,c,d)
#define reg_node(a,b)		S_reg_node(aTHX_ a,b)
#define reg_recode(a,b)		S_reg_recode(aTHX_ a,b)
#define reg_scan_name(a,b)	S_reg_scan_name(aTHX_ a,b)
#define reg_skipcomment(a)	S_reg_skipcomment(aTHX_ a)
#define reganode(a,b,c)		S_reganode(aTHX_ a,b,c)
#define regatom(a,b,c)		S_regatom(aTHX_ a,b,c)
#define regbranch(a,b,c,d)	S_regbranch(aTHX_ a,b,c,d)
#define regclass(a,b,c,d,e,f,g)	S_regclass(aTHX_ a,b,c,d,e,f,g)
#define reginsert(a,b,c,d)	S_reginsert(aTHX_ a,b,c,d)
#define regpatws		S_regpatws
#define regpiece(a,b,c)		S_regpiece(aTHX_ a,b,c)
#define regpposixcc(a,b,c)	S_regpposixcc(aTHX_ a,b,c)
#define regtail(a,b,c,d)	S_regtail(aTHX_ a,b,c,d)
#define reguni(a,b,c)		S_reguni(aTHX_ a,b,c)
#define regwhite		S_regwhite
#define scan_commit(a,b,c,d)	S_scan_commit(aTHX_ a,b,c,d)
#define set_ANYOF_arg(a,b,c,d,e,f,g)	S_set_ANYOF_arg(aTHX_ a,b,c,d,e,f,g)
#define ssc_add_range(a,b,c)	S_ssc_add_range(aTHX_ a,b,c)
#define ssc_and(a,b,c)		S_ssc_and(aTHX_ a,b,c)
#define ssc_anything(a)		S_ssc_anything(aTHX_ a)
#define ssc_clear_locale(a)	S_ssc_clear_locale(aTHX_ a)
#define ssc_cp_and(a,b)		S_ssc_cp_and(aTHX_ a,b)
#define ssc_finalize(a,b)	S_ssc_finalize(aTHX_ a,b)
#define ssc_init(a,b)		S_ssc_init(aTHX_ a,b)
#define ssc_intersection(a,b,c)	S_ssc_intersection(aTHX_ a,b,c)
#define ssc_is_anything(a)	S_ssc_is_anything(aTHX_ a)
#define ssc_is_cp_posixl_init(a,b)	S_ssc_is_cp_posixl_init(aTHX_ a,b)
#define ssc_or(a,b,c)		S_ssc_or(aTHX_ a,b,c)
#define ssc_union(a,b,c)	S_ssc_union(aTHX_ a,b,c)
#define study_chunk(a,b,c,d,e,f,g,h,i,j,k)	S_study_chunk(aTHX_ a,b,c,d,e,f,g,h,i,j,k)
#  endif
#  if defined(PERL_IN_REGCOMP_C) || defined (PERL_IN_DUMP_C)
#define _invlist_dump(a,b,c,d)	Perl__invlist_dump(aTHX_ a,b,c,d)
#  endif
#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)
#define _get_swash_invlist(a)	Perl__get_swash_invlist(aTHX_ a)
#define _invlist_contains_cp(a,b)	S__invlist_contains_cp(aTHX_ a,b)
#define _invlist_contents(a)	Perl__invlist_contents(aTHX_ a)
#define _invlist_len(a)		S__invlist_len(aTHX_ a)
#define _invlist_search(a,b)	Perl__invlist_search(aTHX_ a,b)
#define _swash_inversion_hash(a)	Perl__swash_inversion_hash(aTHX_ a)
#define get_invlist_offset_addr(a)	S_get_invlist_offset_addr(aTHX_ a)
#  endif
#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C) || defined(PERL_IN_TOKE_C)
#define _core_swash_init(a,b,c,d,e,f,g)	Perl__core_swash_init(aTHX_ a,b,c,d,e,f,g)
#  endif
#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_TOKE_C)
#define form_short_octal_warning(a,b)	S_form_short_octal_warning(aTHX_ a,b)
#define grok_bslash_c(a,b)	S_grok_bslash_c(aTHX_ a,b)
#define grok_bslash_o(a,b,c,d,e,f,g)	S_grok_bslash_o(aTHX_ a,b,c,d,e,f,g)
#define grok_bslash_x(a,b,c,d,e,f,g)	S_grok_bslash_x(aTHX_ a,b,c,d,e,f,g)
#define regcurly(a,b)		S_regcurly(aTHX_ a,b)
#  endif
#  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)
#define _add_range_to_invlist(a,b,c)	Perl__add_range_to_invlist(aTHX_ a,b,c)
#define _invlist_intersection_maybe_complement_2nd(a,b,c,d)	Perl__invlist_intersection_maybe_complement_2nd(aTHX_ a,b,c,d)
#define _invlist_invert(a)	Perl__invlist_invert(aTHX_ a)
#define _invlist_populate_swatch(a,b,c,d)	Perl__invlist_populate_swatch(aTHX_ a,b,c,d)
#define _invlist_union_maybe_complement_2nd(a,b,c,d)	Perl__invlist_union_maybe_complement_2nd(aTHX_ a,b,c,d)
#define _new_invlist(a)		Perl__new_invlist(aTHX_ a)
#define _setup_canned_invlist(a,b,c)	Perl__setup_canned_invlist(aTHX_ a,b,c)
#define _swash_to_invlist(a)	Perl__swash_to_invlist(aTHX_ a)
#  endif
#  if defined(PERL_IN_REGEXEC_C)
#define find_byclass(a,b,c,d,e)	S_find_byclass(aTHX_ a,b,c,d,e)
#define isFOO_lc(a,b)		S_isFOO_lc(aTHX_ a,b)
#define isFOO_utf8_lc(a,b)	S_isFOO_utf8_lc(aTHX_ a,b)
#define reg_check_named_buff_matched(a,b)	S_reg_check_named_buff_matched(aTHX_ a,b)
#define regcppop(a,b)		S_regcppop(aTHX_ a,b)
#define regcppush(a,b,c)	S_regcppush(aTHX_ a,b,c)
#define reghop3			S_reghop3
#define reghop4			S_reghop4
#define reghopmaybe3		S_reghopmaybe3
#define reginclass(a,b,c,d,e)	S_reginclass(aTHX_ a,b,c,d,e)
#define regmatch(a,b,c)		S_regmatch(aTHX_ a,b,c)
#define regrepeat(a,b,c,d,e,f)	S_regrepeat(aTHX_ a,b,c,d,e,f)
#define regtry(a,b)		S_regtry(aTHX_ a,b)
#define to_byte_substr(a)	S_to_byte_substr(aTHX_ a)
#define to_utf8_substr(a)	S_to_utf8_substr(aTHX_ a)
#  endif
#  if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)
#define _to_fold_latin1(a,b,c,d)	Perl__to_fold_latin1(aTHX_ a,b,c,d)
#  endif
#endif
#ifdef PERL_CORE
#define Slab_Alloc(a)		Perl_Slab_Alloc(aTHX_ a)
#define Slab_Free(a)		Perl_Slab_Free(aTHX_ a)
#define allocmy(a,b,c)		Perl_allocmy(aTHX_ a,b,c)
#define amagic_is_enabled(a)	Perl_amagic_is_enabled(aTHX_ a)
#define apply(a,b,c)		Perl_apply(aTHX_ a,b,c)
#define av_extend_guts(a,b,c,d,e)	Perl_av_extend_guts(aTHX_ a,b,c,d,e)
#define bind_match(a,b,c)	Perl_bind_match(aTHX_ a,b,c)
#define block_end(a,b)		Perl_block_end(aTHX_ a,b)
#define block_start(a)		Perl_block_start(aTHX_ a)
#define boot_core_PerlIO()	Perl_boot_core_PerlIO(aTHX)
#define boot_core_UNIVERSAL()	Perl_boot_core_UNIVERSAL(aTHX)
#define boot_core_mro()		Perl_boot_core_mro(aTHX)
#define cando(a,b,c)		Perl_cando(aTHX_ a,b,c)
#define check_utf8_print(a,b)	Perl_check_utf8_print(aTHX_ a,b)
#define ck_anoncode(a)		Perl_ck_anoncode(aTHX_ a)
#define ck_backtick(a)		Perl_ck_backtick(aTHX_ a)
#define ck_bitop(a)		Perl_ck_bitop(aTHX_ a)
#define ck_cmp(a)		Perl_ck_cmp(aTHX_ a)
#define ck_concat(a)		Perl_ck_concat(aTHX_ a)
#define ck_defined(a)		Perl_ck_defined(aTHX_ a)
#define ck_delete(a)		Perl_ck_delete(aTHX_ a)
#define ck_each(a)		Perl_ck_each(aTHX_ a)
#define ck_eof(a)		Perl_ck_eof(aTHX_ a)
#define ck_eval(a)		Perl_ck_eval(aTHX_ a)
#define ck_exec(a)		Perl_ck_exec(aTHX_ a)
#define ck_exists(a)		Perl_ck_exists(aTHX_ a)
#define ck_ftst(a)		Perl_ck_ftst(aTHX_ a)
#define ck_fun(a)		Perl_ck_fun(aTHX_ a)
#define ck_glob(a)		Perl_ck_glob(aTHX_ a)
#define ck_grep(a)		Perl_ck_grep(aTHX_ a)
#define ck_index(a)		Perl_ck_index(aTHX_ a)
#define ck_join(a)		Perl_ck_join(aTHX_ a)
#define ck_length(a)		Perl_ck_length(aTHX_ a)
#define ck_lfun(a)		Perl_ck_lfun(aTHX_ a)
#define ck_listiob(a)		Perl_ck_listiob(aTHX_ a)
#define ck_match(a)		Perl_ck_match(aTHX_ a)
#define ck_method(a)		Perl_ck_method(aTHX_ a)
#define ck_null(a)		Perl_ck_null(aTHX_ a)
#define ck_open(a)		Perl_ck_open(aTHX_ a)
#define ck_readline(a)		Perl_ck_readline(aTHX_ a)
#define ck_repeat(a)		Perl_ck_repeat(aTHX_ a)
#define ck_require(a)		Perl_ck_require(aTHX_ a)
#define ck_return(a)		Perl_ck_return(aTHX_ a)
#define ck_rfun(a)		Perl_ck_rfun(aTHX_ a)
#define ck_rvconst(a)		Perl_ck_rvconst(aTHX_ a)
#define ck_sassign(a)		Perl_ck_sassign(aTHX_ a)
#define ck_select(a)		Perl_ck_select(aTHX_ a)
#define ck_shift(a)		Perl_ck_shift(aTHX_ a)
#define ck_smartmatch(a)	Perl_ck_smartmatch(aTHX_ a)
#define ck_sort(a)		Perl_ck_sort(aTHX_ a)
#define ck_spair(a)		Perl_ck_spair(aTHX_ a)
#define ck_split(a)		Perl_ck_split(aTHX_ a)
#define ck_subr(a)		Perl_ck_subr(aTHX_ a)
#define ck_substr(a)		Perl_ck_substr(aTHX_ a)
#define ck_svconst(a)		Perl_ck_svconst(aTHX_ a)
#define ck_tell(a)		Perl_ck_tell(aTHX_ a)
#define ck_trunc(a)		Perl_ck_trunc(aTHX_ a)
#define closest_cop(a,b,c,d)	Perl_closest_cop(aTHX_ a,b,c,d)
#define convert(a,b,c)		Perl_convert(aTHX_ a,b,c)
#define core_prototype(a,b,c,d)	Perl_core_prototype(aTHX_ a,b,c,d)
#define coresub_op(a,b,c)	Perl_coresub_op(aTHX_ a,b,c)
#define create_eval_scope(a)	Perl_create_eval_scope(aTHX_ a)
#define croak_no_mem		Perl_croak_no_mem
#define croak_popstack		Perl_croak_popstack
#define custom_op_get_field(a,b)	Perl_custom_op_get_field(aTHX_ a,b)
#define cv_clone_into(a,b)	Perl_cv_clone_into(aTHX_ a,b)
#define cv_const_sv_or_av(a)	Perl_cv_const_sv_or_av(aTHX_ a)
#define cv_forget_slab(a)	Perl_cv_forget_slab(aTHX_ a)
#define cvgv_set(a,b)		Perl_cvgv_set(aTHX_ a,b)
#define cvstash_set(a,b)	Perl_cvstash_set(aTHX_ a,b)
#define deb_stack_all()		Perl_deb_stack_all(aTHX)
#define defelem_target(a,b)	Perl_defelem_target(aTHX_ a,b)
#define delete_eval_scope()	Perl_delete_eval_scope(aTHX)
#define die_unwind(a)		Perl_die_unwind(aTHX_ a)
#define do_aexec5(a,b,c,d,e)	Perl_do_aexec5(aTHX_ a,b,c,d,e)
#define do_dump_pad(a,b,c,d)	Perl_do_dump_pad(aTHX_ a,b,c,d)
#define do_eof(a)		Perl_do_eof(aTHX_ a)
#define do_execfree()		Perl_do_execfree(aTHX)
#define do_ncmp(a,b)		Perl_do_ncmp(aTHX_ a,b)
#define do_open6(a,b,c,d,e,f)	Perl_do_open6(aTHX_ a,b,c,d,e,f)
#define do_open_raw(a,b,c,d,e)	Perl_do_open_raw(aTHX_ a,b,c,d,e)
#define do_print(a,b)		Perl_do_print(aTHX_ a,b)
#define do_readline()		Perl_do_readline(aTHX)
#define do_seek(a,b,c)		Perl_do_seek(aTHX_ a,b,c)
#define do_sysseek(a,b,c)	Perl_do_sysseek(aTHX_ a,b,c)
#define do_tell(a)		Perl_do_tell(aTHX_ a)
#define do_trans(a)		Perl_do_trans(aTHX_ a)
#define do_vecget(a,b,c)	Perl_do_vecget(aTHX_ a,b,c)
#define do_vecset(a)		Perl_do_vecset(aTHX_ a)
#define do_vop(a,b,c,d)		Perl_do_vop(aTHX_ a,b,c,d)
#define dofile(a,b)		Perl_dofile(aTHX_ a,b)
#define dump_all_perl(a)	Perl_dump_all_perl(aTHX_ a)
#define dump_packsubs_perl(a,b)	Perl_dump_packsubs_perl(aTHX_ a,b)
#define dump_sub_perl(a,b)	Perl_dump_sub_perl(aTHX_ a,b)
#define finalize_optree(a)	Perl_finalize_optree(aTHX_ a)
#define find_lexical_cv(a)	Perl_find_lexical_cv(aTHX_ a)
#define find_runcv_where(a,b,c)	Perl_find_runcv_where(aTHX_ a,b,c)
#define find_rundefsv2(a,b)	Perl_find_rundefsv2(aTHX_ a,b)
#define find_script(a,b,c,d)	Perl_find_script(aTHX_ a,b,c,d)
#define free_tied_hv_pool()	Perl_free_tied_hv_pool(aTHX)
#define get_hash_seed(a)	Perl_get_hash_seed(aTHX_ a)
#define get_no_modify()		Perl_get_no_modify(aTHX)
#define get_opargs()		Perl_get_opargs(aTHX)
#define gv_override(a,b)	Perl_gv_override(aTHX_ a,b)
#define gv_try_downgrade(a)	Perl_gv_try_downgrade(aTHX_ a)
#define hv_ename_add(a,b,c,d)	Perl_hv_ename_add(aTHX_ a,b,c,d)
#define hv_ename_delete(a,b,c,d)	Perl_hv_ename_delete(aTHX_ a,b,c,d)
#define init_argv_symbols(a,b)	Perl_init_argv_symbols(aTHX_ a,b)
#define init_constants()	Perl_init_constants(aTHX)
#define init_debugger()		Perl_init_debugger(aTHX)
#define intro_my()		Perl_intro_my(aTHX)
#define invert(a)		Perl_invert(aTHX_ a)
#define io_close(a,b)		Perl_io_close(aTHX_ a,b)
#define isALNUM_lazy(a)		S_isALNUM_lazy(aTHX_ a)
#define isIDFIRST_lazy(a)	S_isIDFIRST_lazy(aTHX_ a)
#define jmaybe(a)		Perl_jmaybe(aTHX_ a)
#define keyword(a,b,c)		Perl_keyword(aTHX_ a,b,c)
#define list(a)			Perl_list(aTHX_ a)
#define localize(a,b)		Perl_localize(aTHX_ a,b)
#define magic_clear_all_env(a,b)	Perl_magic_clear_all_env(aTHX_ a,b)
#define magic_cleararylen_p(a,b)	Perl_magic_cleararylen_p(aTHX_ a,b)
#define magic_clearenv(a,b)	Perl_magic_clearenv(aTHX_ a,b)
#define magic_clearhint(a,b)	Perl_magic_clearhint(aTHX_ a,b)
#define magic_clearhints(a,b)	Perl_magic_clearhints(aTHX_ a,b)
#define magic_clearisa(a,b)	Perl_magic_clearisa(aTHX_ a,b)
#define magic_clearpack(a,b)	Perl_magic_clearpack(aTHX_ a,b)
#define magic_clearsig(a,b)	Perl_magic_clearsig(aTHX_ a,b)
#define magic_copycallchecker(a,b,c,d,e)	Perl_magic_copycallchecker(aTHX_ a,b,c,d,e)
#define magic_existspack(a,b)	Perl_magic_existspack(aTHX_ a,b)
#define magic_freearylen_p(a,b)	Perl_magic_freearylen_p(aTHX_ a,b)
#define magic_freeovrld(a,b)	Perl_magic_freeovrld(aTHX_ a,b)
#define magic_get(a,b)		Perl_magic_get(aTHX_ a,b)
#define magic_getarylen(a,b)	Perl_magic_getarylen(aTHX_ a,b)
#define magic_getdefelem(a,b)	Perl_magic_getdefelem(aTHX_ a,b)
#define magic_getnkeys(a,b)	Perl_magic_getnkeys(aTHX_ a,b)
#define magic_getpack(a,b)	Perl_magic_getpack(aTHX_ a,b)
#define magic_getpos(a,b)	Perl_magic_getpos(aTHX_ a,b)
#define magic_getsig(a,b)	Perl_magic_getsig(aTHX_ a,b)
#define magic_getsubstr(a,b)	Perl_magic_getsubstr(aTHX_ a,b)
#define magic_gettaint(a,b)	Perl_magic_gettaint(aTHX_ a,b)
#define magic_getuvar(a,b)	Perl_magic_getuvar(aTHX_ a,b)
#define magic_getvec(a,b)	Perl_magic_getvec(aTHX_ a,b)
#define magic_killbackrefs(a,b)	Perl_magic_killbackrefs(aTHX_ a,b)
#define magic_nextpack(a,b,c)	Perl_magic_nextpack(aTHX_ a,b,c)
#define magic_regdata_cnt(a,b)	Perl_magic_regdata_cnt(aTHX_ a,b)
#define magic_regdatum_get(a,b)	Perl_magic_regdatum_get(aTHX_ a,b)
#define magic_scalarpack(a,b)	Perl_magic_scalarpack(aTHX_ a,b)
#define magic_set(a,b)		Perl_magic_set(aTHX_ a,b)
#define magic_set_all_env(a,b)	Perl_magic_set_all_env(aTHX_ a,b)
#define magic_setarylen(a,b)	Perl_magic_setarylen(aTHX_ a,b)
#define magic_setdbline(a,b)	Perl_magic_setdbline(aTHX_ a,b)
#define magic_setdefelem(a,b)	Perl_magic_setdefelem(aTHX_ a,b)
#define magic_setenv(a,b)	Perl_magic_setenv(aTHX_ a,b)
#define magic_sethint(a,b)	Perl_magic_sethint(aTHX_ a,b)
#define magic_setisa(a,b)	Perl_magic_setisa(aTHX_ a,b)
#define magic_setmglob(a,b)	Perl_magic_setmglob(aTHX_ a,b)
#define magic_setnkeys(a,b)	Perl_magic_setnkeys(aTHX_ a,b)
#define magic_setpack(a,b)	Perl_magic_setpack(aTHX_ a,b)
#define magic_setpos(a,b)	Perl_magic_setpos(aTHX_ a,b)
#define magic_setregexp(a,b)	Perl_magic_setregexp(aTHX_ a,b)
#define magic_setsig(a,b)	Perl_magic_setsig(aTHX_ a,b)
#define magic_setsubstr(a,b)	Perl_magic_setsubstr(aTHX_ a,b)
#define magic_settaint(a,b)	Perl_magic_settaint(aTHX_ a,b)
#define magic_setutf8(a,b)	Perl_magic_setutf8(aTHX_ a,b)
#define magic_setuvar(a,b)	Perl_magic_setuvar(aTHX_ a,b)
#define magic_setvec(a,b)	Perl_magic_setvec(aTHX_ a,b)
#define magic_sizepack(a,b)	Perl_magic_sizepack(aTHX_ a,b)
#define magic_wipepack(a,b)	Perl_magic_wipepack(aTHX_ a,b)
#define mg_localize(a,b,c)	Perl_mg_localize(aTHX_ a,b,c)
#define mode_from_discipline(a,b)	Perl_mode_from_discipline(aTHX_ a,b)
#define mro_isa_changed_in(a)	Perl_mro_isa_changed_in(aTHX_ a)
#define mro_package_moved(a,b,c,d)	Perl_mro_package_moved(aTHX_ a,b,c,d)
#define my_attrs(a,b)		Perl_my_attrs(aTHX_ a,b)
#define my_clearenv()		Perl_my_clearenv(aTHX)
#define my_lstat_flags(a)	Perl_my_lstat_flags(aTHX_ a)
#define my_stat_flags(a)	Perl_my_stat_flags(aTHX_ a)
#define my_unexec()		Perl_my_unexec(aTHX)
#define newATTRSUB_x(a,b,c,d,e,f)	Perl_newATTRSUB_x(aTHX_ a,b,c,d,e,f)
#define newSTUB(a,b)		Perl_newSTUB(aTHX_ a,b)
#define newSVavdefelem(a,b,c)	Perl_newSVavdefelem(aTHX_ a,b,c)
#define newXS_len_flags(a,b,c,d,e,f,g)	Perl_newXS_len_flags(aTHX_ a,b,c,d,e,f,g)
#define nextargv(a)		Perl_nextargv(aTHX_ a)
#define oopsAV(a)		Perl_oopsAV(aTHX_ a)
#define oopsHV(a)		Perl_oopsHV(aTHX_ a)
#define op_const_sv(a,b)	Perl_op_const_sv(aTHX_ a,b)
#define op_unscope(a)		Perl_op_unscope(aTHX_ a)
#define package_version(a)	Perl_package_version(aTHX_ a)
#define pad_block_start(a)	Perl_pad_block_start(aTHX_ a)
#define pad_fixup_inner_anons(a,b,c)	Perl_pad_fixup_inner_anons(aTHX_ a,b,c)
#define pad_free(a)		Perl_pad_free(aTHX_ a)
#define pad_leavemy()		Perl_pad_leavemy(aTHX)
#define pad_push(a,b)		Perl_pad_push(aTHX_ a,b)
#define pad_swipe(a,b)		Perl_pad_swipe(aTHX_ a,b)
#define padlist_store(a,b,c)	Perl_padlist_store(aTHX_ a,b,c)
#define parse_subsignature()	Perl_parse_subsignature(aTHX)
#define parse_unicode_opts(a)	Perl_parse_unicode_opts(aTHX_ a)
#define parser_free(a)		Perl_parser_free(aTHX_ a)
#define peep(a)			Perl_peep(aTHX_ a)
#define pmruntime(a,b,c,d)	Perl_pmruntime(aTHX_ a,b,c,d)
#define re_op_compile(a,b,c,d,e,f,g,h)	Perl_re_op_compile(aTHX_ a,b,c,d,e,f,g,h)
#define refcounted_he_chain_2hv(a,b)	Perl_refcounted_he_chain_2hv(aTHX_ a,b)
#define refcounted_he_fetch_pv(a,b,c,d)	Perl_refcounted_he_fetch_pv(aTHX_ a,b,c,d)
#define refcounted_he_fetch_pvn(a,b,c,d,e)	Perl_refcounted_he_fetch_pvn(aTHX_ a,b,c,d,e)
#define refcounted_he_fetch_sv(a,b,c,d)	Perl_refcounted_he_fetch_sv(aTHX_ a,b,c,d)
#define refcounted_he_free(a)	Perl_refcounted_he_free(aTHX_ a)
#define refcounted_he_inc(a)	Perl_refcounted_he_inc(aTHX_ a)
#define refcounted_he_new_pv(a,b,c,d,e)	Perl_refcounted_he_new_pv(aTHX_ a,b,c,d,e)
#define refcounted_he_new_pvn(a,b,c,d,e,f)	Perl_refcounted_he_new_pvn(aTHX_ a,b,c,d,e,f)
#define refcounted_he_new_sv(a,b,c,d,e)	Perl_refcounted_he_new_sv(aTHX_ a,b,c,d,e)
#define report_evil_fh(a)	Perl_report_evil_fh(aTHX_ a)
#define report_wrongway_fh(a,b)	Perl_report_wrongway_fh(aTHX_ a,b)
#define rpeep(a)		Perl_rpeep(aTHX_ a)
#define rsignal_restore(a,b)	Perl_rsignal_restore(aTHX_ a,b)
#define rsignal_save(a,b,c)	Perl_rsignal_save(aTHX_ a,b,c)
#define rxres_save(a,b)		Perl_rxres_save(aTHX_ a,b)
#define save_strlen(a)		Perl_save_strlen(aTHX_ a)
#define sawparens(a)		Perl_sawparens(aTHX_ a)
#define scalar(a)		Perl_scalar(aTHX_ a)
#define scalarvoid(a)		Perl_scalarvoid(aTHX_ a)
#define set_caret_X()		Perl_set_caret_X(aTHX)
#define sub_crush_depth(a)	Perl_sub_crush_depth(aTHX_ a)
#define sv_2num(a)		Perl_sv_2num(aTHX_ a)
#define sv_clean_all()		Perl_sv_clean_all(aTHX)
#define sv_clean_objs()		Perl_sv_clean_objs(aTHX)
#define sv_del_backref(a,b)	Perl_sv_del_backref(aTHX_ a,b)
#define sv_free_arenas()	Perl_sv_free_arenas(aTHX)
#define sv_len_utf8_nomg(a)	Perl_sv_len_utf8_nomg(aTHX_ a)
#define sv_mortalcopy_flags(a,b)	Perl_sv_mortalcopy_flags(aTHX_ a,b)
#define sv_ref(a,b,c)		Perl_sv_ref(aTHX_ a,b,c)
#define sv_resetpvn(a,b,c)	Perl_sv_resetpvn(aTHX_ a,b,c)
#define sv_sethek(a,b)		Perl_sv_sethek(aTHX_ a,b)
#ifndef PERL_IMPLICIT_CONTEXT
#define tied_method		Perl_tied_method
#endif
#define unshare_hek(a)		Perl_unshare_hek(aTHX_ a)
#define vivify_ref(a,b)		Perl_vivify_ref(aTHX_ a,b)
#define wait4pid(a,b,c)		Perl_wait4pid(aTHX_ a,b,c)
#define watch(a)		Perl_watch(aTHX_ a)
#define write_to_stderr(a)	Perl_write_to_stderr(aTHX_ a)
#define yyerror(a)		Perl_yyerror(aTHX_ a)
#define yyerror_pv(a,b)		Perl_yyerror_pv(aTHX_ a,b)
#define yyerror_pvn(a,b,c)	Perl_yyerror_pvn(aTHX_ a,b,c)
#define yyparse(a)		Perl_yyparse(aTHX_ a)
#define yyunlex()		Perl_yyunlex(aTHX)
#  if !(defined(DEBUGGING))
#    if !defined(NV_PRESERVES_UV)
#      if defined(PERL_IN_SV_C)
#define sv_2iuv_non_preserve(a)	S_sv_2iuv_non_preserve(aTHX_ a)
#      endif
#    endif
#  endif
#  if !(defined(HAS_SIGACTION) && defined(SA_SIGINFO))
#define sighandler		Perl_sighandler
#  endif
#  if !(defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION))
#define do_exec(a)		Perl_do_exec(aTHX_ a)
#  endif
#  if !(defined(PERL_MAD))
#define package(a)		Perl_package(aTHX_ a)
#define utilize(a,b,c,d,e)	Perl_utilize(aTHX_ a,b,c,d,e)
#  endif
#  if !(defined(_MSC_VER))
#define magic_regdatum_set(a,b)	Perl_magic_regdatum_set(aTHX_ a,b)
#  endif
#  if !defined(HAS_GETENV_LEN)
#define getenv_len(a,b)		Perl_getenv_len(aTHX_ a,b)
#  endif
#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
#    if defined(PERL_IN_PP_SYS_C)
#define dooneliner(a,b)		S_dooneliner(aTHX_ a,b)
#    endif
#  endif
#  if !defined(HAS_RENAME)
#define same_dirent(a,b)	Perl_same_dirent(aTHX_ a,b)
#  endif
#  if !defined(NV_PRESERVES_UV)
#    if defined(DEBUGGING)
#      if defined(PERL_IN_SV_C)
#define sv_2iuv_non_preserve(a,b)	S_sv_2iuv_non_preserve(aTHX_ a,b)
#      endif
#    endif
#  endif
#  if !defined(PERL_DISABLE_PMC)
#    if defined(PERL_IN_PP_CTL_C)
#define doopen_pm(a)		S_doopen_pm(aTHX_ a)
#    endif
#  endif
#  if !defined(PERL_IS_MINIPERL)
#    if defined(PERL_IN_PERL_C)
#define incpush_if_exists(a,b,c)	S_incpush_if_exists(aTHX_ a,b,c)
#    endif
#  endif
#  if !defined(PERL_NO_UTF16_FILTER)
#    if defined(PERL_IN_TOKE_C)
#define add_utf16_textfilter(a,b)	S_add_utf16_textfilter(aTHX_ a,b)
#define utf16_textfilter(a,b,c)	S_utf16_textfilter(aTHX_ a,b,c)
#    endif
#  endif
#  if !defined(WIN32)
#define do_exec3(a,b,c)		Perl_do_exec3(aTHX_ a,b,c)
#  endif
#  if defined(DEBUGGING)
#define get_debug_opts(a,b)	Perl_get_debug_opts(aTHX_ a,b)
#    if defined(PERL_IN_PAD_C)
#define cv_dump(a,b)		S_cv_dump(aTHX_ a,b)
#    endif
#    if defined(PERL_IN_SV_C)
#define del_sv(a)		S_del_sv(aTHX_ a)
#    endif
#    if defined(PERL_IN_TOKE_C)
#define printbuf(a,b)		S_printbuf(aTHX_ a,b)
#define tokereport(a,b)		S_tokereport(aTHX_ a,b)
#    endif
#  endif
#  if defined(DEBUG_LEAKING_SCALARS_FORK_DUMP)
#define dump_sv_child(a)	Perl_dump_sv_child(aTHX_ a)
#  endif
#  if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
#define do_ipcctl(a,b,c)	Perl_do_ipcctl(aTHX_ a,b,c)
#define do_ipcget(a,b,c)	Perl_do_ipcget(aTHX_ a,b,c)
#define do_msgrcv(a,b)		Perl_do_msgrcv(aTHX_ a,b)
#define do_msgsnd(a,b)		Perl_do_msgsnd(aTHX_ a,b)
#define do_semop(a,b)		Perl_do_semop(aTHX_ a,b)
#define do_shmio(a,b,c)		Perl_do_shmio(aTHX_ a,b,c)
#  endif
#  if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
#define sighandler		Perl_sighandler
#  endif
#  if defined(MYMALLOC)
#define malloc_good_size	Perl_malloc_good_size
#define malloced_size		Perl_malloced_size
#  endif
#  if defined(PERL_CORE)
#define opslab_force_free(a)	Perl_opslab_force_free(aTHX_ a)
#define opslab_free(a)		Perl_opslab_free(aTHX_ a)
#define opslab_free_nopad(a)	Perl_opslab_free_nopad(aTHX_ a)
#define parser_free_nexttoke_ops(a,b)	Perl_parser_free_nexttoke_ops(aTHX_ a,b)
#    if defined(PERL_DEBUG_READONLY_OPS)
#define Slab_to_ro(a)		Perl_Slab_to_ro(aTHX_ a)
#define Slab_to_rw(a)		Perl_Slab_to_rw(aTHX_ a)
#    endif
#  endif
#  if defined(PERL_CR_FILTER)
#    if defined(PERL_IN_TOKE_C)
#define cr_textfilter(a,b,c)	S_cr_textfilter(aTHX_ a,b,c)
#define strip_return(a)		S_strip_return(aTHX_ a)
#    endif
#  endif
#  if defined(PERL_DEBUG_READONLY_COW)
#define sv_buf_to_ro(a)		Perl_sv_buf_to_ro(aTHX_ a)
#    if defined(PERL_IN_SV_C)
#define sv_buf_to_rw(a)		S_sv_buf_to_rw(aTHX_ a)
#    endif
#  endif
#  if defined(PERL_IN_AV_C)
#define get_aux_mg(a)		S_get_aux_mg(aTHX_ a)
#  endif
#  if defined(PERL_IN_DEB_C)
#define deb_stack_n(a,b,c,d,e)	S_deb_stack_n(aTHX_ a,b,c,d,e)
#  endif
#  if defined(PERL_IN_DOIO_C)
#define exec_failed(a,b,c)	S_exec_failed(aTHX_ a,b,c)
#define ingroup(a,b)		S_ingroup(aTHX_ a,b)
#define openn_cleanup(a,b,c,d,e,f,g,h,i,j,k,l)	S_openn_cleanup(aTHX_ a,b,c,d,e,f,g,h,i,j,k,l)
#define openn_setup(a,b,c,d,e,f)	S_openn_setup(aTHX_ a,b,c,d,e,f)
#  endif
#  if defined(PERL_IN_DOOP_C)
#define do_trans_complex(a)	S_do_trans_complex(aTHX_ a)
#define do_trans_complex_utf8(a)	S_do_trans_complex_utf8(aTHX_ a)
#define do_trans_count(a)	S_do_trans_count(aTHX_ a)
#define do_trans_count_utf8(a)	S_do_trans_count_utf8(aTHX_ a)
#define do_trans_simple(a)	S_do_trans_simple(aTHX_ a)
#define do_trans_simple_utf8(a)	S_do_trans_simple_utf8(aTHX_ a)
#  endif
#  if defined(PERL_IN_DUMP_C)
#define deb_curcv(a)		S_deb_curcv(aTHX_ a)
#define debprof(a)		S_debprof(aTHX_ a)
#define pm_description(a)	S_pm_description(aTHX_ a)
#define sequence_num(a)		S_sequence_num(aTHX_ a)
#  endif
#  if defined(PERL_IN_GV_C)
#define find_default_stash(a,b,c,d,e,f)	S_find_default_stash(aTHX_ a,b,c,d,e,f)
#define gv_init_svtype(a,b)	S_gv_init_svtype(aTHX_ a,b)
#define gv_is_in_main(a,b,c)	S_gv_is_in_main(aTHX_ a,b,c)
#define gv_magicalize(a,b,c,d,e,f)	S_gv_magicalize(aTHX_ a,b,c,d,e,f)
#define gv_magicalize_isa(a)	S_gv_magicalize_isa(aTHX_ a)
#define maybe_multimagic_gv(a,b,c)	S_maybe_multimagic_gv(aTHX_ a,b,c)
#define parse_gv_stash_name(a,b,c,d,e,f,g,h)	S_parse_gv_stash_name(aTHX_ a,b,c,d,e,f,g,h)
#define require_tie_mod(a,b,c,d,e)	S_require_tie_mod(aTHX_ a,b,c,d,e)
#  endif
#  if defined(PERL_IN_HV_C)
#define clear_placeholders(a,b)	S_clear_placeholders(aTHX_ a,b)
#define hfreeentries(a)		S_hfreeentries(aTHX_ a)
#define hsplit(a,b,c)		S_hsplit(aTHX_ a,b,c)
#define hv_auxinit(a)		S_hv_auxinit(aTHX_ a)
#define hv_auxinit_internal	S_hv_auxinit_internal
#define hv_delete_common(a,b,c,d,e,f,g)	S_hv_delete_common(aTHX_ a,b,c,d,e,f,g)
#define hv_free_ent_ret(a,b)	S_hv_free_ent_ret(aTHX_ a,b)
#define hv_magic_check		S_hv_magic_check
#define hv_notallowed(a,b,c,d)	S_hv_notallowed(aTHX_ a,b,c,d)
#define new_he()		S_new_he(aTHX)
#define ptr_hash		S_ptr_hash
#define refcounted_he_value(a)	S_refcounted_he_value(aTHX_ a)
#define save_hek_flags		S_save_hek_flags
#define share_hek_flags(a,b,c,d)	S_share_hek_flags(aTHX_ a,b,c,d)
#define unshare_hek_or_pvn(a,b,c,d)	S_unshare_hek_or_pvn(aTHX_ a,b,c,d)
#  endif
#  if defined(PERL_IN_LOCALE_C) && defined(USE_LOCALE)
#define is_cur_LC_category_utf8(a)	S_is_cur_LC_category_utf8(aTHX_ a)
#define stdize_locale(a)	S_stdize_locale(aTHX_ a)
#  endif
#  if defined(PERL_IN_MALLOC_C)
#define adjust_size_and_find_bucket	S_adjust_size_and_find_bucket
#  endif
#  if defined(PERL_IN_MG_C)
#define fixup_errno_string(a)	S_fixup_errno_string(aTHX_ a)
#define magic_methcall1(a,b,c,d,e,f)	S_magic_methcall1(aTHX_ a,b,c,d,e,f)
#define magic_methpack(a,b,c)	S_magic_methpack(aTHX_ a,b,c)
#define restore_magic(a)	S_restore_magic(aTHX_ a)
#define save_magic_flags(a,b,c)	S_save_magic_flags(aTHX_ a,b,c)
#define unwind_handler_stack(a)	S_unwind_handler_stack(aTHX_ a)
#  endif
#  if defined(PERL_IN_MG_C) || defined(PERL_IN_PP_C)
#define translate_substr_offsets(a,b,c,d,e,f,g)	Perl_translate_substr_offsets(aTHX_ a,b,c,d,e,f,g)
#  endif
#  if defined(PERL_IN_MRO_C)
#define mro_clean_isarev(a,b,c,d,e,f)	S_mro_clean_isarev(aTHX_ a,b,c,d,e,f)
#define mro_gather_and_rename(a,b,c,d,e)	S_mro_gather_and_rename(aTHX_ a,b,c,d,e)
#define mro_get_linear_isa_dfs(a,b)	S_mro_get_linear_isa_dfs(aTHX_ a,b)
#  endif
#  if defined(PERL_IN_NUMERIC_C)
#define mulexp10		S_mulexp10
#  endif
#  if defined(PERL_IN_OP_C)
#define aassign_common_vars(a)	S_aassign_common_vars(aTHX_ a)
#define apply_attrs(a,b,c)	S_apply_attrs(aTHX_ a,b,c)
#define apply_attrs_my(a,b,c,d)	S_apply_attrs_my(aTHX_ a,b,c,d)
#define bad_type_gv(a,b,c,d,e)	S_bad_type_gv(aTHX_ a,b,c,d,e)
#define bad_type_pv(a,b,c,d,e)	S_bad_type_pv(aTHX_ a,b,c,d,e)
#define cop_free(a)		S_cop_free(aTHX_ a)
#define dup_attrlist(a)		S_dup_attrlist(aTHX_ a)
#define finalize_op(a)		S_finalize_op(aTHX_ a)
#define find_and_forget_pmops(a)	S_find_and_forget_pmops(aTHX_ a)
#define fold_constants(a)	S_fold_constants(aTHX_ a)
#define force_list(a)		S_force_list(aTHX_ a)
#define forget_pmop(a)		S_forget_pmop(aTHX_ a)
#define gen_constant_list(a)	S_gen_constant_list(aTHX_ a)
#define gv_ename(a)		S_gv_ename(aTHX_ a)
#define inplace_aassign(a)	S_inplace_aassign(aTHX_ a)
#define is_handle_constructor	S_is_handle_constructor
#define is_list_assignment(a)	S_is_list_assignment(aTHX_ a)
#define listkids(a)		S_listkids(aTHX_ a)
#define looks_like_bool(a)	S_looks_like_bool(aTHX_ a)
#define modkids(a,b)		S_modkids(aTHX_ a,b)
#define move_proto_attr(a,b,c)	S_move_proto_attr(aTHX_ a,b,c)
#define my_kid(a,b,c)		S_my_kid(aTHX_ a,b,c)
#define newDEFSVOP()		S_newDEFSVOP(aTHX)
#define newGIVWHENOP(a,b,c,d,e)	S_newGIVWHENOP(aTHX_ a,b,c,d,e)
#define new_logop(a,b,c,d)	S_new_logop(aTHX_ a,b,c,d)
#define no_bareword_allowed(a)	S_no_bareword_allowed(aTHX_ a)
#define no_fh_allowed(a)	S_no_fh_allowed(aTHX_ a)
#define null_listop_in_list_context(a)	S_null_listop_in_list_context(aTHX_ a)
#define op_integerize(a)	S_op_integerize(aTHX_ a)
#define op_std_init(a)		S_op_std_init(aTHX_ a)
#define pmtrans(a,b,c)		S_pmtrans(aTHX_ a,b,c)
#define process_special_blocks(a,b,c,d)	S_process_special_blocks(aTHX_ a,b,c,d)
#define ref_array_or_hash(a)	S_ref_array_or_hash(aTHX_ a)
#define refkids(a,b)		S_refkids(aTHX_ a,b)
#define scalar_mod_type		S_scalar_mod_type
#define scalarboolean(a)	S_scalarboolean(aTHX_ a)
#define scalarkids(a)		S_scalarkids(aTHX_ a)
#define scalarseq(a)		S_scalarseq(aTHX_ a)
#define search_const(a)		S_search_const(aTHX_ a)
#define simplify_sort(a)	S_simplify_sort(aTHX_ a)
#define too_few_arguments_pv(a,b,c)	S_too_few_arguments_pv(aTHX_ a,b,c)
#define too_few_arguments_sv(a,b,c)	S_too_few_arguments_sv(aTHX_ a,b,c)
#define too_many_arguments_pv(a,b,c)	S_too_many_arguments_pv(aTHX_ a,b,c)
#define too_many_arguments_sv(a,b,c)	S_too_many_arguments_sv(aTHX_ a,b,c)
#  endif
#  if defined(PERL_IN_OP_C) || defined(PERL_IN_SV_C)
#define report_redefined_cv(a,b,c)	Perl_report_redefined_cv(aTHX_ a,b,c)
#  endif
#  if defined(PERL_IN_PAD_C)
#define pad_alloc_name(a,b,c,d)	S_pad_alloc_name(aTHX_ a,b,c,d)
#define pad_check_dup(a,b,c)	S_pad_check_dup(aTHX_ a,b,c)
#define pad_findlex(a,b,c,d,e,f,g,h,i)	S_pad_findlex(aTHX_ a,b,c,d,e,f,g,h,i)
#define pad_reset()		S_pad_reset(aTHX)
#  endif
#  if defined(PERL_IN_PERL_C)
#define find_beginning(a,b)	S_find_beginning(aTHX_ a,b)
#define forbid_setid(a,b)	S_forbid_setid(aTHX_ a,b)
#define incpush(a,b,c)		S_incpush(aTHX_ a,b,c)
#define incpush_use_sep(a,b,c)	S_incpush_use_sep(aTHX_ a,b,c)
#define init_ids()		S_init_ids(aTHX)
#define init_interp()		S_init_interp(aTHX)
#define init_main_stash()	S_init_main_stash(aTHX)
#define init_perllib()		S_init_perllib(aTHX)
#define init_postdump_symbols(a,b,c)	S_init_postdump_symbols(aTHX_ a,b,c)
#define init_predump_symbols()	S_init_predump_symbols(aTHX)
#define mayberelocate(a,b,c)	S_mayberelocate(aTHX_ a,b,c)
#define minus_v()		S_minus_v(aTHX)
#define my_exit_jump()		S_my_exit_jump(aTHX)
#define nuke_stacks()		S_nuke_stacks(aTHX)
#define open_script(a,b,c)	S_open_script(aTHX_ a,b,c)
#define parse_body(a,b)		S_parse_body(aTHX_ a,b)
#define run_body(a)		S_run_body(aTHX_ a)
#define usage()			S_usage(aTHX)
#  endif
#  if defined(PERL_IN_PP_C)
#define do_chomp(a,b,c)		S_do_chomp(aTHX_ a,b,c)
#define do_delete_local()	S_do_delete_local(aTHX)
#define refto(a)		S_refto(aTHX_ a)
#  endif
#  if defined(PERL_IN_PP_CTL_C)
#define adjust_stack_on_leave(a,b,c,d,e,f)	S_adjust_stack_on_leave(aTHX_ a,b,c,d,e,f)
#define check_type_and_open(a)	S_check_type_and_open(aTHX_ a)
#define destroy_matcher(a)	S_destroy_matcher(aTHX_ a)
#define do_smartmatch(a,b,c)	S_do_smartmatch(aTHX_ a,b,c)
#define docatch(a)		S_docatch(aTHX_ a)
#define doeval(a,b,c,d)		S_doeval(aTHX_ a,b,c,d)
#define dofindlabel(a,b,c,d,e,f)	S_dofindlabel(aTHX_ a,b,c,d,e,f)
#define doparseform(a)		S_doparseform(aTHX_ a)
#define dopoptoeval(a)		S_dopoptoeval(aTHX_ a)
#define dopoptogiven(a)		S_dopoptogiven(aTHX_ a)
#define dopoptolabel(a,b,c)	S_dopoptolabel(aTHX_ a,b,c)
#define dopoptoloop(a)		S_dopoptoloop(aTHX_ a)
#define dopoptosub_at(a,b)	S_dopoptosub_at(aTHX_ a,b)
#define dopoptowhen(a)		S_dopoptowhen(aTHX_ a)
#define make_matcher(a)		S_make_matcher(aTHX_ a)
#define matcher_matches_sv(a,b)	S_matcher_matches_sv(aTHX_ a,b)
#define num_overflow		S_num_overflow
#define path_is_searchable	S_path_is_searchable
#define run_user_filter(a,b,c)	S_run_user_filter(aTHX_ a,b,c)
#define rxres_free(a)		S_rxres_free(aTHX_ a)
#define rxres_restore(a,b)	S_rxres_restore(aTHX_ a,b)
#define save_lines(a,b)		S_save_lines(aTHX_ a,b)
#  endif
#  if defined(PERL_IN_PP_HOT_C)
#define do_oddball(a,b)		S_do_oddball(aTHX_ a,b)
#define method_common(a,b)	S_method_common(aTHX_ a,b)
#  endif
#  if defined(PERL_IN_PP_PACK_C)
#define bytes_to_uni		S_bytes_to_uni
#define div128(a,b)		S_div128(aTHX_ a,b)
#define first_symbol		S_first_symbol
#define get_num(a,b)		S_get_num(aTHX_ a,b)
#define group_end(a,b,c)	S_group_end(aTHX_ a,b,c)
#define is_an_int(a,b)		S_is_an_int(aTHX_ a,b)
#define measure_struct(a)	S_measure_struct(aTHX_ a)
#define mul128(a,b)		S_mul128(aTHX_ a,b)
#define need_utf8		S_need_utf8
#define next_symbol(a)		S_next_symbol(aTHX_ a)
#define pack_rec(a,b,c,d)	S_pack_rec(aTHX_ a,b,c,d)
#define sv_exp_grow(a,b)	S_sv_exp_grow(aTHX_ a,b)
#define unpack_rec(a,b,c,d,e)	S_unpack_rec(aTHX_ a,b,c,d,e)
#  endif
#  if defined(PERL_IN_PP_SORT_C)
#define amagic_cmp(a,b)		S_amagic_cmp(aTHX_ a,b)
#define amagic_cmp_locale(a,b)	S_amagic_cmp_locale(aTHX_ a,b)
#define amagic_i_ncmp(a,b)	S_amagic_i_ncmp(aTHX_ a,b)
#define amagic_ncmp(a,b)	S_amagic_ncmp(aTHX_ a,b)
#define qsortsvu(a,b,c)		S_qsortsvu(aTHX_ a,b,c)
#define sortcv(a,b)		S_sortcv(aTHX_ a,b)
#define sortcv_stacked(a,b)	S_sortcv_stacked(aTHX_ a,b)
#define sortcv_xsub(a,b)	S_sortcv_xsub(aTHX_ a,b)
#define sv_i_ncmp(a,b)		S_sv_i_ncmp(aTHX_ a,b)
#define sv_ncmp(a,b)		S_sv_ncmp(aTHX_ a,b)
#  endif
#  if defined(PERL_IN_PP_SYS_C)
#define doform(a,b,c)		S_doform(aTHX_ a,b,c)
#define space_join_names_mortal(a)	S_space_join_names_mortal(aTHX_ a)
#  endif
#  if defined(PERL_IN_SCOPE_C)
#define save_pushptri32ptr(a,b,c,d)	S_save_pushptri32ptr(aTHX_ a,b,c,d)
#define save_scalar_at(a,b)	S_save_scalar_at(aTHX_ a,b)
#  endif
#  if defined(PERL_IN_SV_C)
#define F0convert		S_F0convert
#define anonymise_cv_maybe(a,b)	S_anonymise_cv_maybe(aTHX_ a,b)
#define assert_uft8_cache_coherent(a,b,c,d)	S_assert_uft8_cache_coherent(aTHX_ a,b,c,d)
#define curse(a,b)		S_curse(aTHX_ a,b)
#define expect_number(a)	S_expect_number(aTHX_ a)
#define find_array_subscript(a,b)	S_find_array_subscript(aTHX_ a,b)
#define find_hash_subscript(a,b)	S_find_hash_subscript(aTHX_ a,b)
#define find_uninit_var(a,b,c)	S_find_uninit_var(aTHX_ a,b,c)
#define glob_2number(a)		S_glob_2number(aTHX_ a)
#define glob_assign_glob(a,b,c)	S_glob_assign_glob(aTHX_ a,b,c)
#define glob_assign_ref(a,b)	S_glob_assign_ref(aTHX_ a,b)
#define more_sv()		S_more_sv(aTHX)
#define not_a_number(a)		S_not_a_number(aTHX_ a)
#define ptr_table_find		S_ptr_table_find
#define sv_2iuv_common(a)	S_sv_2iuv_common(aTHX_ a)
#define sv_add_arena(a,b,c)	S_sv_add_arena(aTHX_ a,b,c)
#define sv_pos_b2u_midway(a,b,c,d)	S_sv_pos_b2u_midway(aTHX_ a,b,c,d)
#define sv_pos_u2b_cached(a,b,c,d,e,f,g)	S_sv_pos_u2b_cached(aTHX_ a,b,c,d,e,f,g)
#define sv_pos_u2b_forwards	S_sv_pos_u2b_forwards
#define sv_pos_u2b_midway	S_sv_pos_u2b_midway
#define sv_unglob(a,b)		S_sv_unglob(aTHX_ a,b)
#define uiv_2buf		S_uiv_2buf
#define utf8_mg_len_cache_update(a,b,c)	S_utf8_mg_len_cache_update(aTHX_ a,b,c)
#define utf8_mg_pos_cache_update(a,b,c,d,e)	S_utf8_mg_pos_cache_update(aTHX_ a,b,c,d,e)
#define visit(a,b,c)		S_visit(aTHX_ a,b,c)
#    if defined(PERL_OLD_COPY_ON_WRITE)
#define sv_release_COW(a,b,c)	S_sv_release_COW(aTHX_ a,b,c)
#    endif
#    if defined(USE_ITHREADS)
#define sv_dup_common(a,b)	S_sv_dup_common(aTHX_ a,b)
#define sv_dup_inc_multiple(a,b,c,d)	S_sv_dup_inc_multiple(aTHX_ a,b,c,d)
#define unreferenced_to_tmp_stack(a)	S_unreferenced_to_tmp_stack(aTHX_ a)
#    endif
#  endif
#  if defined(PERL_IN_SV_C) || defined (PERL_IN_OP_C)
#define varname(a,b,c,d,e,f)	Perl_varname(aTHX_ a,b,c,d,e,f)
#  endif
#  if defined(PERL_IN_TOKE_C)
#define ao(a)			S_ao(aTHX_ a)
#define check_uni()		S_check_uni(aTHX)
#define checkcomma(a,b,c)	S_checkcomma(aTHX_ a,b,c)
#define deprecate_commaless_var_list()	S_deprecate_commaless_var_list(aTHX)
#define filter_gets(a,b)	S_filter_gets(aTHX_ a,b)
#define find_in_my_stash(a,b)	S_find_in_my_stash(aTHX_ a,b)
#define force_ident(a,b)	S_force_ident(aTHX_ a,b)
#define force_ident_maybe_lex(a)	S_force_ident_maybe_lex(aTHX_ a)
#define force_next(a)		S_force_next(aTHX_ a)
#define force_strict_version(a)	S_force_strict_version(aTHX_ a)
#define force_version(a,b)	S_force_version(aTHX_ a,b)
#define force_word(a,b,c,d)	S_force_word(aTHX_ a,b,c,d)
#define get_and_check_backslash_N_name(a,b)	S_get_and_check_backslash_N_name(aTHX_ a,b)
#define incline(a)		S_incline(aTHX_ a)
#define intuit_method(a,b,c)	S_intuit_method(aTHX_ a,b,c)
#define intuit_more(a)		S_intuit_more(aTHX_ a)
#define lop(a,b,c)		S_lop(aTHX_ a,b,c)
#define missingterm(a)		S_missingterm(aTHX_ a)
#define no_op(a,b)		S_no_op(aTHX_ a,b)
#define parse_ident(a,b,c,d,e)	S_parse_ident(aTHX_ a,b,c,d,e)
#define pending_ident()		S_pending_ident(aTHX)
#define scan_const(a)		S_scan_const(aTHX_ a)
#define scan_formline(a)	S_scan_formline(aTHX_ a)
#define scan_heredoc(a)		S_scan_heredoc(aTHX_ a)
#define scan_ident(a,b,c,d)	S_scan_ident(aTHX_ a,b,c,d)
#define scan_inputsymbol(a)	S_scan_inputsymbol(aTHX_ a)
#define scan_pat(a,b)		S_scan_pat(aTHX_ a,b)
#define scan_str(a,b,c,d,e,f)	S_scan_str(aTHX_ a,b,c,d,e,f)
#define scan_subst(a)		S_scan_subst(aTHX_ a)
#define scan_trans(a)		S_scan_trans(aTHX_ a)
#define scan_word(a,b,c,d,e)	S_scan_word(aTHX_ a,b,c,d,e)
#define skipspace_flags(a,b)	S_skipspace_flags(aTHX_ a,b)
#define sublex_done()		S_sublex_done(aTHX)
#define sublex_push()		S_sublex_push(aTHX)
#define sublex_start()		S_sublex_start(aTHX)
#define swallow_bom(a)		S_swallow_bom(aTHX_ a)
#define tokenize_use(a,b)	S_tokenize_use(aTHX_ a,b)
#define tokeq(a)		S_tokeq(aTHX_ a)
#define update_debugger_info(a,b,c)	S_update_debugger_info(aTHX_ a,b,c)
#define yywarn(a,b)		S_yywarn(aTHX_ a,b)
#    if defined(PERL_MAD)
#define curmad(a,b)		S_curmad(aTHX_ a,b)
#define skipspace0(a)		S_skipspace0(aTHX_ a)
#define skipspace1(a)		S_skipspace1(aTHX_ a)
#define skipspace2(a,b)		S_skipspace2(aTHX_ a,b)
#define start_force(a)		S_start_force(aTHX_ a)
#    endif
#  endif
#  if defined(PERL_IN_UNIVERSAL_C)
#define isa_lookup(a,b,c,d)	S_isa_lookup(aTHX_ a,b,c,d)
#  endif
#  if defined(PERL_IN_UTF8_C)
#define check_locale_boundary_crossing(a,b,c,d)	S_check_locale_boundary_crossing(aTHX_ a,b,c,d)
#define is_utf8_char_slow	S_is_utf8_char_slow
#define is_utf8_common(a,b,c,d)	S_is_utf8_common(aTHX_ a,b,c,d)
#define swatch_get(a,b,c)	S_swatch_get(aTHX_ a,b,c)
#define to_lower_latin1(a,b,c)	S_to_lower_latin1(aTHX_ a,b,c)
#  endif
#  if defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)
#define _to_upper_title_latin1(a,b,c,d)	Perl__to_upper_title_latin1(aTHX_ a,b,c,d)
#  endif
#  if defined(PERL_IN_UTIL_C)
#define ckwarn_common(a)	S_ckwarn_common(aTHX_ a)
#define invoke_exception_hook(a,b)	S_invoke_exception_hook(aTHX_ a,b)
#define mess_alloc()		S_mess_alloc(aTHX)
#define with_queued_errors(a)	S_with_queued_errors(aTHX_ a)
#    if defined(PERL_MEM_LOG) && !defined(PERL_MEM_LOG_NOIMPL)
#define mem_log_common		S_mem_log_common
#    endif
#  endif
#  if defined(PERL_MAD)
#define addmad(a,b,c)		Perl_addmad(aTHX_ a,b,c)
#define append_madprops(a,b,c)	Perl_append_madprops(aTHX_ a,b,c)
#define do_op_xmldump(a,b,c)	Perl_do_op_xmldump(aTHX_ a,b,c)
#define do_pmop_xmldump(a,b,c)	Perl_do_pmop_xmldump(aTHX_ a,b,c)
#define mad_free(a)		Perl_mad_free(aTHX_ a)
#define madlex()		Perl_madlex(aTHX)
#define madparse(a)		Perl_madparse(aTHX_ a)
#define newMADPROP(a,b,c,d)	Perl_newMADPROP(aTHX_ a,b,c,d)
#define newMADsv(a,b)		Perl_newMADsv(aTHX_ a,b)
#define newTOKEN(a,b,c)		Perl_newTOKEN(aTHX_ a,b,c)
#define op_getmad(a,b,c)	Perl_op_getmad(aTHX_ a,b,c)
#define op_getmad_weak(a,b,c)	Perl_op_getmad_weak(aTHX_ a,b,c)
#define op_xmldump(a)		Perl_op_xmldump(aTHX_ a)
#define package(a)		Perl_package(aTHX_ a)
#define pad_peg			Perl_pad_peg
#define pmop_xmldump(a)		Perl_pmop_xmldump(aTHX_ a)
#define prepend_madprops(a,b,c)	Perl_prepend_madprops(aTHX_ a,b,c)
#define sv_catxmlpv(a,b,c)	Perl_sv_catxmlpv(aTHX_ a,b,c)
#define sv_catxmlpvn(a,b,c,d)	Perl_sv_catxmlpvn(aTHX_ a,b,c,d)
#define sv_catxmlsv(a,b)	Perl_sv_catxmlsv(aTHX_ a,b)
#define sv_xmlpeek(a)		Perl_sv_xmlpeek(aTHX_ a)
#define token_free(a)		Perl_token_free(aTHX_ a)
#define token_getmad(a,b,c)	Perl_token_getmad(aTHX_ a,b,c)
#define utilize(a,b,c,d,e)	Perl_utilize(aTHX_ a,b,c,d,e)
#define xmldump_all()		Perl_xmldump_all(aTHX)
#define xmldump_all_perl(a)	Perl_xmldump_all_perl(aTHX_ a)
#define xmldump_eval()		Perl_xmldump_eval(aTHX)
#define xmldump_form(a)		Perl_xmldump_form(aTHX_ a)
#ifndef PERL_IMPLICIT_CONTEXT
#define xmldump_indent		Perl_xmldump_indent
#endif
#define xmldump_packsubs(a)	Perl_xmldump_packsubs(aTHX_ a)
#define xmldump_packsubs_perl(a,b)	Perl_xmldump_packsubs_perl(aTHX_ a,b)
#define xmldump_sub(a)		Perl_xmldump_sub(aTHX_ a)
#define xmldump_sub_perl(a,b)	Perl_xmldump_sub_perl(aTHX_ a,b)
#define xmldump_vindent(a,b,c,d)	Perl_xmldump_vindent(aTHX_ a,b,c,d)
#  endif
#  if defined(PERL_USES_PL_PIDSTATUS) && defined(PERL_IN_UTIL_C)
#define pidgone(a,b)		S_pidgone(aTHX_ a,b)
#  endif
#  if defined(USE_ITHREADS)
#define mro_meta_dup(a,b)	Perl_mro_meta_dup(aTHX_ a,b)
#define padlist_dup(a,b)	Perl_padlist_dup(aTHX_ a,b)
#  endif
#  if defined(USE_LOCALE_COLLATE)
#define magic_setcollxfrm(a,b)	Perl_magic_setcollxfrm(aTHX_ a,b)
#define mem_collxfrm(a,b,c)	Perl_mem_collxfrm(aTHX_ a,b,c)
#  endif
#  if defined(_MSC_VER)
#define magic_regdatum_set(a,b)	Perl_magic_regdatum_set(aTHX_ a,b)
#  endif
#endif

#endif	/* #ifndef PERL_NO_SHORT_NAMES */

/* Compatibility stubs.  Compile extensions with -DPERL_NOCOMPAT to
   disable them.
 */

#if !defined(PERL_CORE)
#  define sv_setptrobj(rv,ptr,name)	sv_setref_iv(rv,name,PTR2IV(ptr))
#  define sv_setptrref(rv,ptr)		sv_setref_iv(rv,NULL,PTR2IV(ptr))
#endif

#if !defined(PERL_CORE) && !defined(PERL_NOCOMPAT)

/* Compatibility for various misnamed functions.  All functions
   in the API that begin with "perl_" (not "Perl_") take an explicit
   interpreter context pointer.
   The following are not like that, but since they had a "perl_"
   prefix in previous versions, we provide compatibility macros.
 */
#  define perl_atexit(a,b)		call_atexit(a,b)
#  define perl_call_argv(a,b,c)		call_argv(a,b,c)
#  define perl_call_method(a,b)		call_method(a,b)
#  define perl_call_pv(a,b)		call_pv(a,b)
#  define perl_call_sv(a,b)		call_sv(a,b)
#  define perl_eval_pv(a,b)		eval_pv(a,b)
#  define perl_eval_sv(a,b)		eval_sv(a,b)
#  define perl_get_av(a,b)		get_av(a,b)
#  define perl_get_cv(a,b)		get_cv(a,b)
#  define perl_get_hv(a,b)		get_hv(a,b)
#  define perl_get_sv(a,b)		get_sv(a,b)
#  define perl_init_i18nl10n(a)		init_i18nl10n(a)
#  define perl_init_i18nl14n(a)		init_i18nl14n(a)
#  define perl_new_collate(a)		new_collate(a)
#  define perl_new_ctype(a)		new_ctype(a)
#  define perl_new_numeric(a)		new_numeric(a)
#  define perl_require_pv(a)		require_pv(a)

/* varargs functions can't be handled with CPP macros. :-(
   This provides a set of compatibility functions that don't take
   an extra argument but grab the context pointer using the macro
   dTHX.
 */
#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_NO_SHORT_NAMES)
#  define croak			Perl_croak_nocontext
#  define deb			Perl_deb_nocontext
#  define die			Perl_die_nocontext
#  define form			Perl_form_nocontext
#  define load_module		Perl_load_module_nocontext
#  define mess			Perl_mess_nocontext
#  define newSVpvf		Perl_newSVpvf_nocontext
#  define sv_catpvf		Perl_sv_catpvf_nocontext
#  define sv_catpvf_mg		Perl_sv_catpvf_mg_nocontext
#  define sv_setpvf		Perl_sv_setpvf_nocontext
#  define sv_setpvf_mg		Perl_sv_setpvf_mg_nocontext
#  define warn			Perl_warn_nocontext
#  define warner		Perl_warner_nocontext
#endif

#endif /* !defined(PERL_CORE) && !defined(PERL_NOCOMPAT) */

#if !defined(PERL_IMPLICIT_CONTEXT)
/* undefined symbols, point them back at the usual ones */
#  define Perl_croak_nocontext	Perl_croak
#  define Perl_deb_nocontext	Perl_deb
#  define Perl_die_nocontext	Perl_die
#  define Perl_form_nocontext	Perl_form
#  define Perl_load_module_nocontext	Perl_load_module
#  define Perl_mess_nocontext	Perl_mess
#  define Perl_newSVpvf_nocontext	Perl_newSVpvf
#  define Perl_sv_catpvf_nocontext	Perl_sv_catpvf
#  define Perl_sv_catpvf_mg_nocontext	Perl_sv_catpvf_mg
#  define Perl_sv_setpvf_nocontext	Perl_sv_setpvf
#  define Perl_sv_setpvf_mg_nocontext	Perl_sv_setpvf_mg
#  define Perl_warn_nocontext	Perl_warn
#  define Perl_warner_nocontext	Perl_warner
#endif

/* ex: set ro: */
                                                                                                                                                                                                                   usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/embedvar.h                                                0100644 0000000 0000000 00000043007 12744441327 017676  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    embedvar.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/embed.pl from data in embed.fnc,
 * regen/embed.pl, regen/opcodes, intrpvar.h and perlvars.h.
 * Any changes made here will be lost!
 *
 * Edit those files and run 'make regen_headers' to effect changes.
 */

/* (Doing namespace management portably in C is really gross.) */

/*
   The following combinations of MULTIPLICITY and PERL_IMPLICIT_CONTEXT
   are supported:
     1) none
     2) MULTIPLICITY	# supported for compatibility
     3) MULTIPLICITY && PERL_IMPLICIT_CONTEXT

   All other combinations of these flags are errors.

   only #3 is supported directly, while #2 is a special
   case of #3 (supported by redefining vTHX appropriately).
*/

#if defined(MULTIPLICITY)
/* cases 2 and 3 above */

#  if defined(PERL_IMPLICIT_CONTEXT)
#    define vTHX	aTHX
#  else
#    define vTHX	PERL_GET_INTERP
#  endif

#define PL_AboveLatin1		(vTHX->IAboveLatin1)
#define PL_Argv			(vTHX->IArgv)
#define PL_Cmd			(vTHX->ICmd)
#define PL_DBcv			(vTHX->IDBcv)
#define PL_DBgv			(vTHX->IDBgv)
#define PL_DBline		(vTHX->IDBline)
#define PL_DBsignal		(vTHX->IDBsignal)
#define PL_DBsingle		(vTHX->IDBsingle)
#define PL_DBsub		(vTHX->IDBsub)
#define PL_DBtrace		(vTHX->IDBtrace)
#define PL_Dir			(vTHX->IDir)
#define PL_Env			(vTHX->IEnv)
#define PL_HasMultiCharFold	(vTHX->IHasMultiCharFold)
#define PL_LIO			(vTHX->ILIO)
#define PL_Latin1		(vTHX->ILatin1)
#define PL_Mem			(vTHX->IMem)
#define PL_MemParse		(vTHX->IMemParse)
#define PL_MemShared		(vTHX->IMemShared)
#define PL_NonL1NonFinalFold	(vTHX->INonL1NonFinalFold)
#define PL_Posix_ptrs		(vTHX->IPosix_ptrs)
#define PL_Proc			(vTHX->IProc)
#define PL_Sock			(vTHX->ISock)
#define PL_StdIO		(vTHX->IStdIO)
#define PL_Sv			(vTHX->ISv)
#define PL_UpperLatin1		(vTHX->IUpperLatin1)
#define PL_XPosix_ptrs		(vTHX->IXPosix_ptrs)
#define PL_Xpv			(vTHX->IXpv)
#define PL_an			(vTHX->Ian)
#define PL_apiversion		(vTHX->Iapiversion)
#define PL_argvgv		(vTHX->Iargvgv)
#define PL_argvout_stack	(vTHX->Iargvout_stack)
#define PL_argvoutgv		(vTHX->Iargvoutgv)
#define PL_basetime		(vTHX->Ibasetime)
#define PL_beginav		(vTHX->Ibeginav)
#define PL_beginav_save		(vTHX->Ibeginav_save)
#define PL_blockhooks		(vTHX->Iblockhooks)
#define PL_body_arenas		(vTHX->Ibody_arenas)
#define PL_body_roots		(vTHX->Ibody_roots)
#define PL_bodytarget		(vTHX->Ibodytarget)
#define PL_breakable_sub_gen	(vTHX->Ibreakable_sub_gen)
#define PL_checkav		(vTHX->Icheckav)
#define PL_checkav_save		(vTHX->Icheckav_save)
#define PL_chopset		(vTHX->Ichopset)
#define PL_clocktick		(vTHX->Iclocktick)
#define PL_collation_ix		(vTHX->Icollation_ix)
#define PL_collation_name	(vTHX->Icollation_name)
#define PL_collation_standard	(vTHX->Icollation_standard)
#define PL_collxfrm_base	(vTHX->Icollxfrm_base)
#define PL_collxfrm_mult	(vTHX->Icollxfrm_mult)
#define PL_colors		(vTHX->Icolors)
#define PL_colorset		(vTHX->Icolorset)
#define PL_compcv		(vTHX->Icompcv)
#define PL_compiling		(vTHX->Icompiling)
#define PL_comppad		(vTHX->Icomppad)
#define PL_comppad_name		(vTHX->Icomppad_name)
#define PL_comppad_name_fill	(vTHX->Icomppad_name_fill)
#define PL_comppad_name_floor	(vTHX->Icomppad_name_floor)
#define PL_cop_seqmax		(vTHX->Icop_seqmax)
#define PL_cryptseen		(vTHX->Icryptseen)
#define PL_curcop		(vTHX->Icurcop)
#define PL_curcopdb		(vTHX->Icurcopdb)
#define PL_curpad		(vTHX->Icurpad)
#define PL_curpm		(vTHX->Icurpm)
#define PL_curstack		(vTHX->Icurstack)
#define PL_curstackinfo		(vTHX->Icurstackinfo)
#define PL_curstash		(vTHX->Icurstash)
#define PL_curstname		(vTHX->Icurstname)
#define PL_custom_op_descs	(vTHX->Icustom_op_descs)
#define PL_custom_op_names	(vTHX->Icustom_op_names)
#define PL_custom_ops		(vTHX->Icustom_ops)
#define PL_cv_has_eval		(vTHX->Icv_has_eval)
#define PL_dbargs		(vTHX->Idbargs)
#define PL_debstash		(vTHX->Idebstash)
#define PL_debug		(vTHX->Idebug)
#define PL_debug_pad		(vTHX->Idebug_pad)
#define PL_def_layerlist	(vTHX->Idef_layerlist)
#define PL_defgv		(vTHX->Idefgv)
#define PL_defoutgv		(vTHX->Idefoutgv)
#define PL_defstash		(vTHX->Idefstash)
#define PL_delaymagic		(vTHX->Idelaymagic)
#define PL_delaymagic_egid	(vTHX->Idelaymagic_egid)
#define PL_delaymagic_euid	(vTHX->Idelaymagic_euid)
#define PL_delaymagic_gid	(vTHX->Idelaymagic_gid)
#define PL_delaymagic_uid	(vTHX->Idelaymagic_uid)
#define PL_destroyhook		(vTHX->Idestroyhook)
#define PL_diehook		(vTHX->Idiehook)
#define PL_doswitches		(vTHX->Idoswitches)
#define PL_dowarn		(vTHX->Idowarn)
#define PL_dumper_fd		(vTHX->Idumper_fd)
#define PL_dumpindent		(vTHX->Idumpindent)
#define PL_e_script		(vTHX->Ie_script)
#define PL_efloatbuf		(vTHX->Iefloatbuf)
#define PL_efloatsize		(vTHX->Iefloatsize)
#define PL_encoding		(vTHX->Iencoding)
#define PL_endav		(vTHX->Iendav)
#define PL_envgv		(vTHX->Ienvgv)
#define PL_errgv		(vTHX->Ierrgv)
#define PL_errors		(vTHX->Ierrors)
#define PL_eval_root		(vTHX->Ieval_root)
#define PL_eval_start		(vTHX->Ieval_start)
#define PL_evalseq		(vTHX->Ievalseq)
#define PL_exit_flags		(vTHX->Iexit_flags)
#define PL_exitlist		(vTHX->Iexitlist)
#define PL_exitlistlen		(vTHX->Iexitlistlen)
#define PL_fdpid		(vTHX->Ifdpid)
#define PL_filemode		(vTHX->Ifilemode)
#define PL_firstgv		(vTHX->Ifirstgv)
#define PL_forkprocess		(vTHX->Iforkprocess)
#define PL_formtarget		(vTHX->Iformtarget)
#define PL_generation		(vTHX->Igeneration)
#define PL_gensym		(vTHX->Igensym)
#define PL_globalstash		(vTHX->Iglobalstash)
#define PL_globhook		(vTHX->Iglobhook)
#define PL_hash_rand_bits	(vTHX->Ihash_rand_bits)
#define PL_hash_rand_bits_enabled	(vTHX->Ihash_rand_bits_enabled)
#define PL_hintgv		(vTHX->Ihintgv)
#define PL_hv_fetch_ent_mh	(vTHX->Ihv_fetch_ent_mh)
#define PL_in_clean_all		(vTHX->Iin_clean_all)
#define PL_in_clean_objs	(vTHX->Iin_clean_objs)
#define PL_in_eval		(vTHX->Iin_eval)
#define PL_in_load_module	(vTHX->Iin_load_module)
#define PL_in_utf8_CTYPE_locale	(vTHX->Iin_utf8_CTYPE_locale)
#define PL_incgv		(vTHX->Iincgv)
#define PL_initav		(vTHX->Iinitav)
#define PL_inplace		(vTHX->Iinplace)
#define PL_isarev		(vTHX->Iisarev)
#define PL_known_layers		(vTHX->Iknown_layers)
#define PL_last_in_gv		(vTHX->Ilast_in_gv)
#define PL_last_swash_hv	(vTHX->Ilast_swash_hv)
#define PL_last_swash_key	(vTHX->Ilast_swash_key)
#define PL_last_swash_klen	(vTHX->Ilast_swash_klen)
#define PL_last_swash_slen	(vTHX->Ilast_swash_slen)
#define PL_last_swash_tmps	(vTHX->Ilast_swash_tmps)
#define PL_lastfd		(vTHX->Ilastfd)
#define PL_lastgotoprobe	(vTHX->Ilastgotoprobe)
#define PL_laststatval		(vTHX->Ilaststatval)
#define PL_laststype		(vTHX->Ilaststype)
#define PL_localizing		(vTHX->Ilocalizing)
#define PL_localpatches		(vTHX->Ilocalpatches)
#define PL_lockhook		(vTHX->Ilockhook)
#define PL_madskills		(vTHX->Imadskills)
#define PL_main_cv		(vTHX->Imain_cv)
#define PL_main_root		(vTHX->Imain_root)
#define PL_main_start		(vTHX->Imain_start)
#define PL_mainstack		(vTHX->Imainstack)
#define PL_markstack		(vTHX->Imarkstack)
#define PL_markstack_max	(vTHX->Imarkstack_max)
#define PL_markstack_ptr	(vTHX->Imarkstack_ptr)
#define PL_max_intro_pending	(vTHX->Imax_intro_pending)
#define PL_maxo			(vTHX->Imaxo)
#define PL_maxsysfd		(vTHX->Imaxsysfd)
#define PL_memory_debug_header	(vTHX->Imemory_debug_header)
#define PL_mess_sv		(vTHX->Imess_sv)
#define PL_min_intro_pending	(vTHX->Imin_intro_pending)
#define PL_minus_E		(vTHX->Iminus_E)
#define PL_minus_F		(vTHX->Iminus_F)
#define PL_minus_a		(vTHX->Iminus_a)
#define PL_minus_c		(vTHX->Iminus_c)
#define PL_minus_l		(vTHX->Iminus_l)
#define PL_minus_n		(vTHX->Iminus_n)
#define PL_minus_p		(vTHX->Iminus_p)
#define PL_modcount		(vTHX->Imodcount)
#define PL_modglobal		(vTHX->Imodglobal)
#define PL_my_cxt_keys		(vTHX->Imy_cxt_keys)
#define PL_my_cxt_list		(vTHX->Imy_cxt_list)
#define PL_my_cxt_size		(vTHX->Imy_cxt_size)
#define PL_na			(vTHX->Ina)
#define PL_nomemok		(vTHX->Inomemok)
#define PL_numeric_local	(vTHX->Inumeric_local)
#define PL_numeric_name		(vTHX->Inumeric_name)
#define PL_numeric_radix_sv	(vTHX->Inumeric_radix_sv)
#define PL_numeric_standard	(vTHX->Inumeric_standard)
#define PL_ofsgv		(vTHX->Iofsgv)
#define PL_oldname		(vTHX->Ioldname)
#define PL_op			(vTHX->Iop)
#define PL_op_exec_cnt		(vTHX->Iop_exec_cnt)
#define PL_op_mask		(vTHX->Iop_mask)
#define PL_opfreehook		(vTHX->Iopfreehook)
#define PL_origalen		(vTHX->Iorigalen)
#define PL_origargc		(vTHX->Iorigargc)
#define PL_origargv		(vTHX->Iorigargv)
#define PL_origenviron		(vTHX->Iorigenviron)
#define PL_origfilename		(vTHX->Iorigfilename)
#define PL_ors_sv		(vTHX->Iors_sv)
#define PL_osname		(vTHX->Iosname)
#define PL_pad_reset_pending	(vTHX->Ipad_reset_pending)
#define PL_padix		(vTHX->Ipadix)
#define PL_padix_floor		(vTHX->Ipadix_floor)
#define PL_parser		(vTHX->Iparser)
#define PL_patchlevel		(vTHX->Ipatchlevel)
#define PL_peepp		(vTHX->Ipeepp)
#define PL_perl_destruct_level	(vTHX->Iperl_destruct_level)
#define PL_perldb		(vTHX->Iperldb)
#define PL_perlio		(vTHX->Iperlio)
#define PL_phase		(vTHX->Iphase)
#define PL_pidstatus		(vTHX->Ipidstatus)
#define PL_preambleav		(vTHX->Ipreambleav)
#define PL_profiledata		(vTHX->Iprofiledata)
#define PL_psig_name		(vTHX->Ipsig_name)
#define PL_psig_pend		(vTHX->Ipsig_pend)
#define PL_psig_ptr		(vTHX->Ipsig_ptr)
#define PL_ptr_table		(vTHX->Iptr_table)
#define PL_random_state		(vTHX->Irandom_state)
#define PL_reentrant_buffer	(vTHX->Ireentrant_buffer)
#define PL_reentrant_retint	(vTHX->Ireentrant_retint)
#define PL_reg_curpm		(vTHX->Ireg_curpm)
#define PL_regex_pad		(vTHX->Iregex_pad)
#define PL_regex_padav		(vTHX->Iregex_padav)
#define PL_registered_mros	(vTHX->Iregistered_mros)
#define PL_regmatch_slab	(vTHX->Iregmatch_slab)
#define PL_regmatch_state	(vTHX->Iregmatch_state)
#define PL_replgv		(vTHX->Ireplgv)
#define PL_restartjmpenv	(vTHX->Irestartjmpenv)
#define PL_restartop		(vTHX->Irestartop)
#define PL_rpeepp		(vTHX->Irpeepp)
#define PL_rs			(vTHX->Irs)
#define PL_runops		(vTHX->Irunops)
#define PL_savebegin		(vTHX->Isavebegin)
#define PL_savestack		(vTHX->Isavestack)
#define PL_savestack_ix		(vTHX->Isavestack_ix)
#define PL_savestack_max	(vTHX->Isavestack_max)
#ifndef PL_sawampersand
#define PL_sawampersand		(vTHX->Isawampersand)
#endif
#define PL_scopestack		(vTHX->Iscopestack)
#define PL_scopestack_ix	(vTHX->Iscopestack_ix)
#define PL_scopestack_max	(vTHX->Iscopestack_max)
#define PL_scopestack_name	(vTHX->Iscopestack_name)
#define PL_secondgv		(vTHX->Isecondgv)
#define PL_sharehook		(vTHX->Isharehook)
#define PL_sig_pending		(vTHX->Isig_pending)
#define PL_sighandlerp		(vTHX->Isighandlerp)
#define PL_signalhook		(vTHX->Isignalhook)
#define PL_signals		(vTHX->Isignals)
#define PL_sort_RealCmp		(vTHX->Isort_RealCmp)
#define PL_sortcop		(vTHX->Isortcop)
#define PL_sortstash		(vTHX->Isortstash)
#define PL_splitstr		(vTHX->Isplitstr)
#define PL_srand_called		(vTHX->Isrand_called)
#define PL_stack_base		(vTHX->Istack_base)
#define PL_stack_max		(vTHX->Istack_max)
#define PL_stack_sp		(vTHX->Istack_sp)
#define PL_start_env		(vTHX->Istart_env)
#define PL_stashcache		(vTHX->Istashcache)
#define PL_stashpad		(vTHX->Istashpad)
#define PL_stashpadix		(vTHX->Istashpadix)
#define PL_stashpadmax		(vTHX->Istashpadmax)
#define PL_statbuf		(vTHX->Istatbuf)
#define PL_statcache		(vTHX->Istatcache)
#define PL_statgv		(vTHX->Istatgv)
#define PL_statname		(vTHX->Istatname)
#define PL_statusvalue		(vTHX->Istatusvalue)
#define PL_statusvalue_posix	(vTHX->Istatusvalue_posix)
#define PL_statusvalue_vms	(vTHX->Istatusvalue_vms)
#define PL_stderrgv		(vTHX->Istderrgv)
#define PL_stdingv		(vTHX->Istdingv)
#define PL_strtab		(vTHX->Istrtab)
#define PL_sub_generation	(vTHX->Isub_generation)
#define PL_subline		(vTHX->Isubline)
#define PL_subname		(vTHX->Isubname)
#define PL_sv_arenaroot		(vTHX->Isv_arenaroot)
#define PL_sv_consts		(vTHX->Isv_consts)
#define PL_sv_count		(vTHX->Isv_count)
#define PL_sv_no		(vTHX->Isv_no)
#define PL_sv_objcount		(vTHX->Isv_objcount)
#define PL_sv_root		(vTHX->Isv_root)
#define PL_sv_serial		(vTHX->Isv_serial)
#define PL_sv_undef		(vTHX->Isv_undef)
#define PL_sv_yes		(vTHX->Isv_yes)
#define PL_sys_intern		(vTHX->Isys_intern)
#define PL_taint_warn		(vTHX->Itaint_warn)
#define PL_tainted		(vTHX->Itainted)
#define PL_tainting		(vTHX->Itainting)
#define PL_threadhook		(vTHX->Ithreadhook)
#define PL_timesbuf		(vTHX->Itimesbuf)
#define PL_tmps_floor		(vTHX->Itmps_floor)
#define PL_tmps_ix		(vTHX->Itmps_ix)
#define PL_tmps_max		(vTHX->Itmps_max)
#define PL_tmps_stack		(vTHX->Itmps_stack)
#define PL_top_env		(vTHX->Itop_env)
#define PL_toptarget		(vTHX->Itoptarget)
#define PL_unicode		(vTHX->Iunicode)
#define PL_unitcheckav		(vTHX->Iunitcheckav)
#define PL_unitcheckav_save	(vTHX->Iunitcheckav_save)
#define PL_unlockhook		(vTHX->Iunlockhook)
#define PL_unsafe		(vTHX->Iunsafe)
#define PL_utf8_X_extend	(vTHX->Iutf8_X_extend)
#define PL_utf8_X_regular_begin	(vTHX->Iutf8_X_regular_begin)
#define PL_utf8_charname_begin	(vTHX->Iutf8_charname_begin)
#define PL_utf8_charname_continue	(vTHX->Iutf8_charname_continue)
#define PL_utf8_foldable	(vTHX->Iutf8_foldable)
#define PL_utf8_foldclosures	(vTHX->Iutf8_foldclosures)
#define PL_utf8_idcont		(vTHX->Iutf8_idcont)
#define PL_utf8_idstart		(vTHX->Iutf8_idstart)
#define PL_utf8_mark		(vTHX->Iutf8_mark)
#define PL_utf8_perl_idcont	(vTHX->Iutf8_perl_idcont)
#define PL_utf8_perl_idstart	(vTHX->Iutf8_perl_idstart)
#define PL_utf8_swash_ptrs	(vTHX->Iutf8_swash_ptrs)
#define PL_utf8_tofold		(vTHX->Iutf8_tofold)
#define PL_utf8_tolower		(vTHX->Iutf8_tolower)
#define PL_utf8_totitle		(vTHX->Iutf8_totitle)
#define PL_utf8_toupper		(vTHX->Iutf8_toupper)
#define PL_utf8_xidcont		(vTHX->Iutf8_xidcont)
#define PL_utf8_xidstart	(vTHX->Iutf8_xidstart)
#define PL_utf8cache		(vTHX->Iutf8cache)
#define PL_utf8locale		(vTHX->Iutf8locale)
#define PL_warnhook		(vTHX->Iwarnhook)
#define PL_watchaddr		(vTHX->Iwatchaddr)
#define PL_watchok		(vTHX->Iwatchok)
#define PL_xmlfp		(vTHX->Ixmlfp)

#endif	/* MULTIPLICITY */

#if defined(PERL_GLOBAL_STRUCT)

#define PL_appctx		(my_vars->Gappctx)
#define PL_Gappctx		(my_vars->Gappctx)
#define PL_check		(my_vars->Gcheck)
#define PL_Gcheck		(my_vars->Gcheck)
#define PL_check_mutex		(my_vars->Gcheck_mutex)
#define PL_Gcheck_mutex		(my_vars->Gcheck_mutex)
#define PL_csighandlerp		(my_vars->Gcsighandlerp)
#define PL_Gcsighandlerp	(my_vars->Gcsighandlerp)
#define PL_curinterp		(my_vars->Gcurinterp)
#define PL_Gcurinterp		(my_vars->Gcurinterp)
#define PL_do_undump		(my_vars->Gdo_undump)
#define PL_Gdo_undump		(my_vars->Gdo_undump)
#define PL_dollarzero_mutex	(my_vars->Gdollarzero_mutex)
#define PL_Gdollarzero_mutex	(my_vars->Gdollarzero_mutex)
#define PL_fold_locale		(my_vars->Gfold_locale)
#define PL_Gfold_locale		(my_vars->Gfold_locale)
#define PL_hash_seed		(my_vars->Ghash_seed)
#define PL_Ghash_seed		(my_vars->Ghash_seed)
#define PL_hash_seed_set	(my_vars->Ghash_seed_set)
#define PL_Ghash_seed_set	(my_vars->Ghash_seed_set)
#define PL_hints_mutex		(my_vars->Ghints_mutex)
#define PL_Ghints_mutex		(my_vars->Ghints_mutex)
#define PL_keyword_plugin	(my_vars->Gkeyword_plugin)
#define PL_Gkeyword_plugin	(my_vars->Gkeyword_plugin)
#define PL_malloc_mutex		(my_vars->Gmalloc_mutex)
#define PL_Gmalloc_mutex	(my_vars->Gmalloc_mutex)
#define PL_mmap_page_size	(my_vars->Gmmap_page_size)
#define PL_Gmmap_page_size	(my_vars->Gmmap_page_size)
#define PL_my_ctx_mutex		(my_vars->Gmy_ctx_mutex)
#define PL_Gmy_ctx_mutex	(my_vars->Gmy_ctx_mutex)
#define PL_my_cxt_index		(my_vars->Gmy_cxt_index)
#define PL_Gmy_cxt_index	(my_vars->Gmy_cxt_index)
#define PL_op_mutex		(my_vars->Gop_mutex)
#define PL_Gop_mutex		(my_vars->Gop_mutex)
#define PL_op_seq		(my_vars->Gop_seq)
#define PL_Gop_seq		(my_vars->Gop_seq)
#define PL_op_sequence		(my_vars->Gop_sequence)
#define PL_Gop_sequence		(my_vars->Gop_sequence)
#define PL_perlio_debug_fd	(my_vars->Gperlio_debug_fd)
#define PL_Gperlio_debug_fd	(my_vars->Gperlio_debug_fd)
#define PL_perlio_fd_refcnt	(my_vars->Gperlio_fd_refcnt)
#define PL_Gperlio_fd_refcnt	(my_vars->Gperlio_fd_refcnt)
#define PL_perlio_fd_refcnt_size	(my_vars->Gperlio_fd_refcnt_size)
#define PL_Gperlio_fd_refcnt_size	(my_vars->Gperlio_fd_refcnt_size)
#define PL_perlio_mutex		(my_vars->Gperlio_mutex)
#define PL_Gperlio_mutex	(my_vars->Gperlio_mutex)
#define PL_ppaddr		(my_vars->Gppaddr)
#define PL_Gppaddr		(my_vars->Gppaddr)
#ifdef OS2
#define PL_sh_path		(my_vars->Gsh_path)
#define PL_Gsh_path		(my_vars->Gsh_path)
#endif
#define PL_sig_defaulting	(my_vars->Gsig_defaulting)
#define PL_Gsig_defaulting	(my_vars->Gsig_defaulting)
#define PL_sig_handlers_initted	(my_vars->Gsig_handlers_initted)
#define PL_Gsig_handlers_initted	(my_vars->Gsig_handlers_initted)
#define PL_sig_ignoring		(my_vars->Gsig_ignoring)
#define PL_Gsig_ignoring	(my_vars->Gsig_ignoring)
#define PL_sig_trapped		(my_vars->Gsig_trapped)
#define PL_Gsig_trapped		(my_vars->Gsig_trapped)
#define PL_sigfpe_saved		(my_vars->Gsigfpe_saved)
#define PL_Gsigfpe_saved	(my_vars->Gsigfpe_saved)
#define PL_sv_placeholder	(my_vars->Gsv_placeholder)
#define PL_Gsv_placeholder	(my_vars->Gsv_placeholder)
#define PL_thr_key		(my_vars->Gthr_key)
#define PL_Gthr_key		(my_vars->Gthr_key)
#define PL_timesbase		(my_vars->Gtimesbase)
#define PL_Gtimesbase		(my_vars->Gtimesbase)
#define PL_use_safe_putenv	(my_vars->Guse_safe_putenv)
#define PL_Guse_safe_putenv	(my_vars->Guse_safe_putenv)
#define PL_veto_cleanup		(my_vars->Gveto_cleanup)
#define PL_Gveto_cleanup	(my_vars->Gveto_cleanup)
#define PL_watch_pvx		(my_vars->Gwatch_pvx)
#define PL_Gwatch_pvx		(my_vars->Gwatch_pvx)

#endif /* PERL_GLOBAL_STRUCT */

/* ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/fakesdio.h                                                0100644 0000000 0000000 00000006364 12744441327 017703  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    fakestdio.h
 *
 *    Copyright (C) 2000, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * This is "source level" stdio compatibility mode.
 * We try and #define stdio functions in terms of PerlIO.
 */
#define _CANNOT "CANNOT"
#undef FILE
#define FILE			PerlIO
#undef clearerr
#undef fclose
#undef fdopen
#undef feof
#undef ferror
#undef fflush
#undef fgetc
#undef fgetpos
#undef fgets
#undef fileno
#undef flockfile
#undef fopen
#undef fprintf
#undef fputc
#undef fputs
#undef fread
#undef freopen
#undef fscanf
#undef fseek
#undef fsetpos
#undef ftell
#undef ftrylockfile
#undef funlockfile
#undef fwrite
#undef getc
#undef getc_unlocked
#undef getw
#undef pclose
#undef popen
#undef putc
#undef putc_unlocked
#undef putw
#undef rewind
#undef setbuf
#undef setvbuf
#undef stderr
#undef stdin
#undef stdout
#undef tmpfile
#undef ungetc
#undef vfprintf
#undef printf

/* printf used to live in perl.h like this - more sophisticated 
   than the rest 
 */
#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(PERL_GCC_PEDANTIC)
#define printf(fmt,args...) PerlIO_stdoutf(fmt,##args)
#else
#define printf PerlIO_stdoutf
#endif

#define fprintf			PerlIO_printf
#define stdin			PerlIO_stdin()
#define stdout			PerlIO_stdout()
#define stderr			PerlIO_stderr()
#define tmpfile()		PerlIO_tmpfile()
#define fclose(f)		PerlIO_close(f)
#define fflush(f)		PerlIO_flush(f)
#define fopen(p,m)		PerlIO_open(p,m)
#define vfprintf(f,fmt,a)	PerlIO_vprintf(f,fmt,a)
#define fgetc(f)		PerlIO_getc(f)
#define fputc(c,f)		PerlIO_putc(f,c)
#define fputs(s,f)		PerlIO_puts(f,s)
#define getc(f)			PerlIO_getc(f)
#define getc_unlocked(f)	PerlIO_getc(f)
#define putc(c,f)		PerlIO_putc(f,c)
#define putc_unlocked(c,f)	PerlIO_putc(c,f)
#define ungetc(c,f)		PerlIO_ungetc(f,c)
#if 0
/* return values of read/write need work */
#define fread(b,s,c,f)		PerlIO_read(f,b,(s*c))
#define fwrite(b,s,c,f)		PerlIO_write(f,b,(s*c))
#else
#define fread(b,s,c,f)		_CANNOT fread
#define fwrite(b,s,c,f)		_CANNOT fwrite
#endif
#define fseek(f,o,w)		PerlIO_seek(f,o,w)
#define ftell(f)		PerlIO_tell(f)
#define rewind(f)		PerlIO_rewind(f)
#define clearerr(f)		PerlIO_clearerr(f)
#define feof(f)			PerlIO_eof(f)
#define ferror(f)		PerlIO_error(f)
#define fdopen(fd,p)		PerlIO_fdopen(fd,p)
#define fileno(f)		PerlIO_fileno(f)
#define popen(c,m)		my_popen(c,m)
#define pclose(f)		my_pclose(f)

#define fsetpos(f,p)		_CANNOT _fsetpos_
#define fgetpos(f,p)		_CANNOT _fgetpos_

#define __filbuf(f)		_CANNOT __filbuf_
#define _filbuf(f)		_CANNOT _filbuf_
#define __flsbuf(c,f)		_CANNOT __flsbuf_
#define _flsbuf(c,f)		_CANNOT _flsbuf_
#define getw(f)			_CANNOT _getw_
#define putw(v,f)		_CANNOT _putw_
#if SFIO_VERSION < 20000101L
#define flockfile(f)		_CANNOT _flockfile_
#define ftrylockfile(f)		_CANNOT _ftrylockfile_
#define funlockfile(f)		_CANNOT _funlockfile_
#endif
#define freopen(p,m,f)		_CANNOT _freopen_
#define setbuf(f,b)		_CANNOT _setbuf_
#define setvbuf(f,b,x,s)	_CANNOT _setvbuf_
#define fscanf			_CANNOT _fscanf_
#define fgets(s,n,f)		_CANNOT _fgets_

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                            usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/feature.h                                                 0100644 0000000 0000000 00000010414 12744441327 017540  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regen/feature.pl.
   Any changes made here will be lost!
 */


#if defined(PERL_CORE) || defined (PERL_EXT)

#define HINT_FEATURE_SHIFT	26

#define FEATURE_BUNDLE_DEFAULT	0
#define FEATURE_BUNDLE_510	1
#define FEATURE_BUNDLE_511	2
#define FEATURE_BUNDLE_515	3
#define FEATURE_BUNDLE_CUSTOM	(HINT_FEATURE_MASK >> HINT_FEATURE_SHIFT)

#define CURRENT_HINTS \
    (PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints)
#define CURRENT_FEATURE_BUNDLE \
    ((CURRENT_HINTS & HINT_FEATURE_MASK) >> HINT_FEATURE_SHIFT)

/* Avoid using ... && Perl_feature_is_enabled(...) as that triggers a bug in
   the HP-UX cc on PA-RISC */
#define FEATURE_IS_ENABLED(name)				        \
	((CURRENT_HINTS							 \
	   & HINT_LOCALIZE_HH)						  \
	    ? Perl_feature_is_enabled(aTHX_ STR_WITH_LEN(name)) : FALSE)
/* The longest string we pass in.  */
#define MAX_FEATURE_LEN (sizeof("postderef_qq")-1)

#define FEATURE_FC_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_515 \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("fc")) \
    )

#define FEATURE_SAY_IS_ENABLED \
    ( \
	(CURRENT_FEATURE_BUNDLE >= FEATURE_BUNDLE_510 && \
	 CURRENT_FEATURE_BUNDLE <= FEATURE_BUNDLE_515) \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("say")) \
    )

#define FEATURE_STATE_IS_ENABLED \
    ( \
	(CURRENT_FEATURE_BUNDLE >= FEATURE_BUNDLE_510 && \
	 CURRENT_FEATURE_BUNDLE <= FEATURE_BUNDLE_515) \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("state")) \
    )

#define FEATURE_SWITCH_IS_ENABLED \
    ( \
	(CURRENT_FEATURE_BUNDLE >= FEATURE_BUNDLE_510 && \
	 CURRENT_FEATURE_BUNDLE <= FEATURE_BUNDLE_515) \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("switch")) \
    )

#define FEATURE_EVALBYTES_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_515 \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("evalbytes")) \
    )

#define FEATURE_POSTDEREF_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("postderef") \
    )

#define FEATURE_ARYBASE_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE <= FEATURE_BUNDLE_511 \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("arybase")) \
    )

#define FEATURE_SIGNATURES_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("signatures") \
    )

#define FEATURE___SUB___IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_515 \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("__SUB__")) \
    )

#define FEATURE_LEXSUBS_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("lexsubs") \
    )

#define FEATURE_POSTDEREF_QQ_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("postderef_qq") \
    )

#define FEATURE_UNIEVAL_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_515 \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("unieval")) \
    )

#define FEATURE_UNICODE_IS_ENABLED \
    ( \
	(CURRENT_FEATURE_BUNDLE >= FEATURE_BUNDLE_511 && \
	 CURRENT_FEATURE_BUNDLE <= FEATURE_BUNDLE_515) \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("unicode")) \
    )


#endif /* PERL_CORE or PERL_EXT */

#ifdef PERL_IN_OP_C
PERL_STATIC_INLINE void
S_enable_feature_bundle(pTHX_ SV *ver)
{
    SV *comp_ver = sv_newmortal();
    PL_hints = (PL_hints &~ HINT_FEATURE_MASK)
	     | (
		  (sv_setnv(comp_ver, 5.015),
		   vcmp(ver, upg_version(comp_ver, FALSE)) >= 0)
			? FEATURE_BUNDLE_515 :
		  (sv_setnv(comp_ver, 5.011),
		   vcmp(ver, upg_version(comp_ver, FALSE)) >= 0)
			? FEATURE_BUNDLE_511 :
		  (sv_setnv(comp_ver, 5.009005),
		   vcmp(ver, upg_version(comp_ver, FALSE)) >= 0)
			? FEATURE_BUNDLE_510 :
			  FEATURE_BUNDLE_DEFAULT
	       ) << HINT_FEATURE_SHIFT;
    /* special case */
    assert(PL_curcop == &PL_compiling);
    if (FEATURE_UNICODE_IS_ENABLED) PL_hints |=  HINT_UNI_8_BIT;
    else			    PL_hints &= ~HINT_UNI_8_BIT;
}
#endif /* PERL_IN_OP_C */

/* ex: set ro: */
                                                                                                                                                                                                                                                    usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/form.h                                                    0100644 0000000 0000000 00000002667 12744441327 017063  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    form.h
 *
 *    Copyright (C) 1991, 1992, 1993, 2000, 2004, 2011 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#define FF_END          0  /* tidy up, then return */
#define FF_LINEMARK     1  /* start (or end) of a line */
#define FF_LITERAL      2  /* append <arg> literal chars */
#define FF_SKIP         3  /* skip <arg> chars in format */
#define FF_FETCH        4  /* get next item and set field size to <arg> */
#define FF_CHECKNL      5  /* find max len of item (up to \n) that fits field */
#define FF_CHECKCHOP    6  /* like CHECKNL, but up to highest split point */
#define FF_SPACE        7  /* append padding space (diff of field, item size) */
#define FF_HALFSPACE    8  /* like FF_SPACE, but only append half as many */
#define FF_ITEM         9  /* append a text item, while blanking ctrl chars */
#define FF_CHOP         10 /* (for ^*) chop the current item */
#define FF_LINEGLOB     11 /* process @*  */
#define FF_DECIMAL      12 /* do @##, ^##, where <arg>=(precision|flags) */
#define FF_NEWLINE      13 /* delete trailing spaces, then append \n */
#define FF_BLANK        14 /* for arg==0: do '~'; for arg>0 : do '~~' */
#define FF_MORE         15 /* replace long end of string with '...' */
#define FF_0DECIMAL     16 /* like FF_DECIMAL but for 0### */
#define FF_LINESNGL     17 /* process ^*  */
                                                                         usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/git_version.h                                             0100644 0000000 0000000 00000000545 12744441327 020441  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**************************************************************************
* WARNING: 'git_version.h' is automatically generated by make_patchnum.pl
*          DO NOT EDIT DIRECTLY - edit make_patchnum.pl instead
***************************************************************************/

#define PERL_GIT_UNPUSHED_COMMITS		\
    /*leave-this-comment*/

                                                                                                                                                           usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/gv.h                                                      0100644 0000000 0000000 00000025056 12744441327 016531  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    gv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

struct gp {
    SV *	gp_sv;		/* scalar value */
    struct io *	gp_io;		/* filehandle value */
    CV *	gp_cv;		/* subroutine value */
    U32		gp_cvgen;	/* generational validity of cached gv_cv */
    U32		gp_refcnt;	/* how many globs point to this? */
    HV *	gp_hv;		/* hash value */
    AV *	gp_av;		/* array value */
    CV *	gp_form;	/* format value */
    GV *	gp_egv;		/* effective gv, if *glob */
    line_t	gp_line;	/* line first declared at (for -w) */
    HEK *	gp_file_hek;	/* file first declared in (for -w) */
};

#define GvXPVGV(gv)	((XPVGV*)SvANY(gv))


#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN) && !defined(__INTEL_COMPILER)
#  define GvGP(gv)							\
	(0+(*({GV *const _gvgp = (GV *) (gv);				\
	    assert(SvTYPE(_gvgp) == SVt_PVGV || SvTYPE(_gvgp) == SVt_PVLV); \
	    assert(isGV_with_GP(_gvgp));				\
	    &((_gvgp)->sv_u.svu_gp);})))
#  define GvGP_set(gv,gp)						\
	{GV *const _gvgp = (GV *) (gv);				\
	    assert(SvTYPE(_gvgp) == SVt_PVGV || SvTYPE(_gvgp) == SVt_PVLV); \
	    assert(isGV_with_GP(_gvgp));				\
	    (_gvgp)->sv_u.svu_gp = (gp); }
#  define GvFLAGS(gv)							\
	(*({GV *const _gvflags = (GV *) (gv);				\
	    assert(SvTYPE(_gvflags) == SVt_PVGV || SvTYPE(_gvflags) == SVt_PVLV); \
	    assert(isGV_with_GP(_gvflags));				\
	    &(GvXPVGV(_gvflags)->xpv_cur);}))
#  define GvSTASH(gv)							\
	(*({ GV * const _gvstash = (GV *) (gv);				\
	    assert(isGV_with_GP(_gvstash));				\
	    assert(SvTYPE(_gvstash) == SVt_PVGV || SvTYPE(_gvstash) >= SVt_PVLV); \
	    &(GvXPVGV(_gvstash)->xnv_u.xgv_stash);			\
	 }))
#  define GvNAME_HEK(gv)						\
    (*({ GV * const _gvname_hek = (GV *) (gv);				\
	   assert(isGV_with_GP(_gvname_hek));				\
	   assert(SvTYPE(_gvname_hek) == SVt_PVGV || SvTYPE(_gvname_hek) >= SVt_PVLV); \
	   assert(!SvVALID(_gvname_hek));				\
	   &(GvXPVGV(_gvname_hek)->xiv_u.xivu_namehek);			\
	 }))
#  define GvNAME_get(gv)	({ assert(GvNAME_HEK(gv)); (char *)HEK_KEY(GvNAME_HEK(gv)); })
#  define GvNAMELEN_get(gv)	({ assert(GvNAME_HEK(gv)); HEK_LEN(GvNAME_HEK(gv)); })
#  define GvNAMEUTF8(gv)	({ assert(GvNAME_HEK(gv)); HEK_UTF8(GvNAME_HEK(gv)); })
#else
#  define GvGP(gv)	(0+(gv)->sv_u.svu_gp)
#  define GvGP_set(gv,gp)	((gv)->sv_u.svu_gp = (gp))
#  define GvFLAGS(gv)	(GvXPVGV(gv)->xpv_cur)
#  define GvSTASH(gv)	(GvXPVGV(gv)->xnv_u.xgv_stash)
#  define GvNAME_HEK(gv)	(GvXPVGV(gv)->xiv_u.xivu_namehek)
#  define GvNAME_get(gv)	HEK_KEY(GvNAME_HEK(gv))
#  define GvNAMELEN_get(gv)	HEK_LEN(GvNAME_HEK(gv))
#  define GvNAMEUTF8(gv)	HEK_UTF8(GvNAME_HEK(gv))
#endif

#define GvNAME(gv)	GvNAME_get(gv)
#define GvNAMELEN(gv)	GvNAMELEN_get(gv)

#define	GvASSIGN_GENERATION(gv)		(0 + ((XPV*) SvANY(gv))->xpv_len)
#define	GvASSIGN_GENERATION_set(gv,val)			\
	STMT_START { assert(SvTYPE(gv) == SVt_PVGV);	\
		(((XPV*) SvANY(gv))->xpv_len = (val)); } STMT_END

/*
=head1 GV Functions

=for apidoc Am|SV*|GvSV|GV* gv

Return the SV from the GV.

=for apidoc Am|AV*|GvAV|GV* gv

Return the AV from the GV.

=for apidoc Am|HV*|GvHV|GV* gv

Return the HV from the GV.

=for apidoc Am|CV*|GvCV|GV* gv

Return the CV from the GV.

=cut
*/

#define GvSV(gv)	(GvGP(gv)->gp_sv)
#ifdef PERL_DONT_CREATE_GVSV
#define GvSVn(gv)	(*(GvGP(gv)->gp_sv ? \
			 &(GvGP(gv)->gp_sv) : \
			 &(GvGP(gv_SVadd(gv))->gp_sv)))
#else
#define GvSVn(gv)	GvSV(gv)
#endif

#define GvREFCNT(gv)	(GvGP(gv)->gp_refcnt)
#define GvIO(gv)                         \
 (                                        \
     (gv)                                  \
  && (                                      \
         SvTYPE((const SV*)(gv)) == SVt_PVGV \
      || SvTYPE((const SV*)(gv)) == SVt_PVLV  \
     )                                         \
  && GvGP(gv)                                   \
   ? GvIOp(gv)                                   \
   : NULL                                         \
 )
#define GvIOp(gv)	(GvGP(gv)->gp_io)
#define GvIOn(gv)	(GvIO(gv) ? GvIOp(gv) : GvIOp(gv_IOadd(gv)))

#define GvFORM(gv)	(GvGP(gv)->gp_form)
#define GvAV(gv)	(GvGP(gv)->gp_av)

#define GvAVn(gv)	(GvGP(gv)->gp_av ? \
			 GvGP(gv)->gp_av : \
			 GvGP(gv_AVadd(gv))->gp_av)
#define GvHV(gv)	((GvGP(gv))->gp_hv)

#define GvHVn(gv)	(GvGP(gv)->gp_hv ? \
			 GvGP(gv)->gp_hv : \
			 GvGP(gv_HVadd(gv))->gp_hv)

#define GvCV(gv)	(0+GvGP(gv)->gp_cv)
#define GvCV_set(gv,cv)	(GvGP(gv)->gp_cv = (cv))
#define GvCVGEN(gv)	(GvGP(gv)->gp_cvgen)
#define GvCVu(gv)	(GvGP(gv)->gp_cvgen ? NULL : GvGP(gv)->gp_cv)

#define GvLINE(gv)	(GvGP(gv)->gp_line)
#define GvFILE_HEK(gv)	(GvGP(gv)->gp_file_hek)
#define GvFILEx(gv)	HEK_KEY(GvFILE_HEK(gv))
#define GvFILE(gv)	(GvFILE_HEK(gv) ? GvFILEx(gv) : NULL)
#define GvFILEGV(gv)	(GvFILE_HEK(gv) ? gv_fetchfile(GvFILEx(gv)) : NULL)

#define GvEGV(gv)	(GvGP(gv)->gp_egv)
#define GvEGVx(gv)	(isGV_with_GP(gv) ? GvEGV(gv) : NULL)
#define GvENAME(gv)	GvNAME(GvEGV(gv) ? GvEGV(gv) : gv)
#define GvENAMELEN(gv)  GvNAMELEN(GvEGV(gv) ? GvEGV(gv) : gv)
#define GvENAMEUTF8(gv) GvNAMEUTF8(GvEGV(gv) ? GvEGV(gv) : gv)
#define GvENAME_HEK(gv) GvNAME_HEK(GvEGV(gv) ? GvEGV(gv) : gv)
#define GvESTASH(gv)	GvSTASH(GvEGV(gv) ? GvEGV(gv) : gv)

#define GVf_INTRO	0x01
#define GVf_MULTI	0x02
#define GVf_ASSUMECV	0x04
#define GVf_IN_PAD	0x08
#define GVf_IMPORTED	0xF0
#define GVf_IMPORTED_SV	  0x10
#define GVf_IMPORTED_AV	  0x20
#define GVf_IMPORTED_HV	  0x40
#define GVf_IMPORTED_CV	  0x80

#define GvINTRO(gv)		(GvFLAGS(gv) & GVf_INTRO)
#define GvINTRO_on(gv)		(GvFLAGS(gv) |= GVf_INTRO)
#define GvINTRO_off(gv)		(GvFLAGS(gv) &= ~GVf_INTRO)

#define GvMULTI(gv)		(GvFLAGS(gv) & GVf_MULTI)
#define GvMULTI_on(gv)		(GvFLAGS(gv) |= GVf_MULTI)
#define GvMULTI_off(gv)		(GvFLAGS(gv) &= ~GVf_MULTI)

#define GvASSUMECV(gv)		(GvFLAGS(gv) & GVf_ASSUMECV)
#define GvASSUMECV_on(gv)	(GvFLAGS(gv) |= GVf_ASSUMECV)
#define GvASSUMECV_off(gv)	(GvFLAGS(gv) &= ~GVf_ASSUMECV)

#define GvIMPORTED(gv)		(GvFLAGS(gv) & GVf_IMPORTED)
#define GvIMPORTED_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED)
#define GvIMPORTED_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED)

#define GvIMPORTED_SV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_SV)
#define GvIMPORTED_SV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_SV)
#define GvIMPORTED_SV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_SV)

#define GvIMPORTED_AV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_AV)
#define GvIMPORTED_AV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_AV)
#define GvIMPORTED_AV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_AV)

#define GvIMPORTED_HV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_HV)
#define GvIMPORTED_HV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_HV)
#define GvIMPORTED_HV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_HV)

#define GvIMPORTED_CV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_CV)
#define GvIMPORTED_CV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_CV)
#define GvIMPORTED_CV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_CV)

#define GvIN_PAD(gv)		(GvFLAGS(gv) & GVf_IN_PAD)
#define GvIN_PAD_on(gv)		(GvFLAGS(gv) |= GVf_IN_PAD)
#define GvIN_PAD_off(gv)	(GvFLAGS(gv) &= ~GVf_IN_PAD)

#ifndef PERL_CORE
#  define Nullgv Null(GV*)
#endif

#define DM_RUID      0x001
#define DM_EUID      0x002
#define DM_UID       (DM_RUID|DM_EUID)
#define DM_ARRAY_ISA 0x004
#define DM_RGID      0x010
#define DM_EGID      0x020
#define DM_GID       (DM_RGID|DM_EGID)
#define DM_DELAY     0x100

/*
 * symbol creation flags, for use in gv_fetchpv() and get_*v()
 */
#define GV_ADD		0x01	/* add, if symbol not already there
				   For gv_name_set, adding a HEK for the first
				   time, so don't try to free what's there.  */
#define GV_ADDMULTI	0x02	/* add, pretending it has been added
				   already; used also by gv_init_* */
#define GV_ADDWARN	0x04	/* add, but warn if symbol wasn't already there */
#define GV_ADDINEVAL	0x08	/* add, as though we're doing so within an eval */
#define GV_NOINIT	0x10	/* add, but don't init symbol, if type != PVGV */
/* This is used by toke.c to avoid turing placeholder constants in the symbol
   table into full PVGVs with attached constant subroutines.  */
#define GV_NOADD_NOINIT	0x20	/* Don't add the symbol if it's not there.
				   Don't init it if it is there but ! PVGV */
#define GV_NOEXPAND	0x40	/* Don't expand SvOK() entries to PVGV */
#define GV_NOTQUAL	0x80	/* A plain symbol name, not qualified with a
				   package (so skip checks for :: and ')  */
#define GV_AUTOLOAD	0x100	/* gv_fetchmethod_flags() should AUTOLOAD  */
#define GV_CROAK	0x200	/* gv_fetchmethod_flags() should croak  */
#define GV_ADDMG	0x400	/* add if magical */
#define GV_NO_SVGMAGIC	0x800	/* Skip get-magic on an SV argument;
				   used only by gv_fetchsv(_nomg) */

/* Flags for gv_fetchmeth_pvn and gv_autoload_pvn*/
#define GV_SUPER	0x1000	/* SUPER::method */

/* Flags for gv_autoload_*/
#define GV_AUTOLOAD_ISMETHOD 1	/* autoloading a method? */

/*      SVf_UTF8 (more accurately the return value from SvUTF8) is also valid
	as a flag to various gv_* functions, so ensure it lies
	outside this range.
*/

#define GV_NOADD_MASK \
  (SVf_UTF8|GV_NOADD_NOINIT|GV_NOEXPAND|GV_NOTQUAL|GV_ADDMG|GV_NO_SVGMAGIC)
/* The bit flags that don't cause gv_fetchpv() to add a symbol if not
   found (with the exception GV_ADDMG, which *might* cause the symbol
   to be added) */

#define gv_fullname3(sv,gv,prefix) gv_fullname4(sv,gv,prefix,TRUE)
#define gv_efullname3(sv,gv,prefix) gv_efullname4(sv,gv,prefix,TRUE)
#define gv_fetchmethod(stash, name) gv_fetchmethod_autoload(stash, name, TRUE)
#define gv_fetchsv_nomg(n,f,t) gv_fetchsv(n,(f)|GV_NO_SVGMAGIC,t)
#define gv_init(gv,stash,name,len,multi) \
	gv_init_pvn(gv,stash,name,len,GV_ADDMULTI*!!(multi))
#define gv_fetchmeth(stash,name,len,level) gv_fetchmeth_pvn(stash, name, len, level, 0)
#define gv_fetchmeth_autoload(stash,name,len,level) gv_fetchmeth_pvn_autoload(stash, name, len, level, 0)
#define gv_fetchmethod_flags(stash,name,flags) gv_fetchmethod_pv_flags(stash, name, flags)
#define gv_autoload4(stash, name, len, method) \
	gv_autoload_pvn(stash, name, len, !!(method))
#define newGVgen(pack)  newGVgen_flags(pack, 0)
#define gv_method_changed(gv)		    \
    (					     \
    	assert_(isGV_with_GP(gv))	      \
	GvREFCNT(gv) > 1		       \
	    ? (void)++PL_sub_generation		\
	    : mro_method_changed_in(GvSTASH(gv)) \
    )

#define gv_AVadd(gv) gv_add_by_type((gv), SVt_PVAV)
#define gv_HVadd(gv) gv_add_by_type((gv), SVt_PVHV)
#define gv_IOadd(gv) gv_add_by_type((gv), SVt_PVIO)
#define gv_SVadd(gv) gv_add_by_type((gv), SVt_NULL)

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/handy.h                                                   0100644 0000000 0000000 00000265733 12744441327 017230  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    handy.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000,
 *    2001, 2002, 2004, 2005, 2006, 2007, 2008, 2012 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* IMPORTANT NOTE: Everything whose name begins with an underscore is for
 * internal core Perl use only. */

#ifndef HANDY_H /* Guard against nested #inclusion */
#define HANDY_H

#if !defined(__STDC__)
#ifdef NULL
#undef NULL
#endif
#  define NULL 0
#endif

#ifndef PERL_CORE
#  define Null(type) ((type)NULL)

/*
=head1 Handy Values

=for apidoc AmU||Nullch
Null character pointer.  (No longer available when C<PERL_CORE> is
defined.)

=for apidoc AmU||Nullsv
Null SV pointer.  (No longer available when C<PERL_CORE> is defined.)

=cut
*/

#  define Nullch Null(char*)
#  define Nullfp Null(PerlIO*)
#  define Nullsv Null(SV*)
#endif

#ifdef TRUE
#undef TRUE
#endif
#ifdef FALSE
#undef FALSE
#endif
#define TRUE (1)
#define FALSE (0)

/* The MUTABLE_*() macros cast pointers to the types shown, in such a way
 * (compiler permitting) that casting away const-ness will give a warning;
 * e.g.:
 *
 * const SV *sv = ...;
 * AV *av1 = (AV*)sv;        <== BAD:  the const has been silently cast away
 * AV *av2 = MUTABLE_AV(sv); <== GOOD: it may warn
 */

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define MUTABLE_PTR(p) ({ void *_p = (p); _p; })
#else
#  define MUTABLE_PTR(p) ((void *) (p))
#endif

#define MUTABLE_AV(p)	((AV *)MUTABLE_PTR(p))
#define MUTABLE_CV(p)	((CV *)MUTABLE_PTR(p))
#define MUTABLE_GV(p)	((GV *)MUTABLE_PTR(p))
#define MUTABLE_HV(p)	((HV *)MUTABLE_PTR(p))
#define MUTABLE_IO(p)	((IO *)MUTABLE_PTR(p))
#define MUTABLE_SV(p)	((SV *)MUTABLE_PTR(p))

#if defined(I_STDBOOL) && !defined(PERL_BOOL_AS_CHAR)
#  include <stdbool.h>
#  ifndef HAS_BOOL
#    define HAS_BOOL 1
#  endif
#endif

/* bool is built-in for g++-2.6.3 and later, which might be used
   for extensions.  <_G_config.h> defines _G_HAVE_BOOL, but we can't
   be sure _G_config.h will be included before this file.  _G_config.h
   also defines _G_HAVE_BOOL for both gcc and g++, but only g++
   actually has bool.  Hence, _G_HAVE_BOOL is pretty useless for us.
   g++ can be identified by __GNUG__.
   Andy Dougherty	February 2000
*/
#ifdef __GNUG__		/* GNU g++ has bool built-in */
# ifndef PERL_BOOL_AS_CHAR
#  ifndef HAS_BOOL
#    define HAS_BOOL 1
#  endif
# endif
#endif

/* The NeXT dynamic loader headers will not build with the bool macro
   So declare them now to clear confusion.
*/
#if defined(NeXT) || defined(__NeXT__)
# undef FALSE
# undef TRUE
  typedef enum bool { FALSE = 0, TRUE = 1 } bool;
# define ENUM_BOOL 1
# ifndef HAS_BOOL
#  define HAS_BOOL 1
# endif /* !HAS_BOOL */
#endif /* NeXT || __NeXT__ */

#ifndef HAS_BOOL
# ifdef bool
#  undef bool
# endif
# define bool char
# define HAS_BOOL 1
#endif

/* cast-to-bool.  A simple (bool) cast may not do the right thing: if bool is
 * defined as char for example, then the cast from int is
 * implementation-defined (bool)!!(cbool) in a ternary triggers a bug in xlc on
 * AIX */
#define cBOOL(cbool) ((cbool) ? (bool)1 : (bool)0)

/* Try to figure out __func__ or __FUNCTION__ equivalent, if any.
 * XXX Should really be a Configure probe, with HAS__FUNCTION__
 *     and FUNCTION__ as results.
 * XXX Similarly, a Configure probe for __FILE__ and __LINE__ is needed. */
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || (defined(__SUNPRO_C)) /* C99 or close enough. */
#  define FUNCTION__ __func__
#else
#  if (defined(USING_MSVC6)) || /* MSVC6 has neither __func__ nor __FUNCTION and no good workarounds, either. */ \
      (defined(__DECC_VER)) /* Tru64 or VMS, and strict C89 being used, but not modern enough cc (in Tur64, -c99 not known, only -std1). */
#    define FUNCTION__ ""
#  else
#    define FUNCTION__ __FUNCTION__ /* Common extension. */
#  endif
#endif

/* XXX A note on the perl source internal type system.  The
   original intent was that I32 be *exactly* 32 bits.

   Currently, we only guarantee that I32 is *at least* 32 bits.
   Specifically, if int is 64 bits, then so is I32.  (This is the case
   for the Cray.)  This has the advantage of meshing nicely with
   standard library calls (where we pass an I32 and the library is
   expecting an int), but the disadvantage that an I32 is not 32 bits.
   Andy Dougherty	August 1996

   There is no guarantee that there is *any* integral type with
   exactly 32 bits.  It is perfectly legal for a system to have
   sizeof(short) == sizeof(int) == sizeof(long) == 8.

   Similarly, there is no guarantee that I16 and U16 have exactly 16
   bits.

   For dealing with issues that may arise from various 32/64-bit
   systems, we will ask Configure to check out

	SHORTSIZE == sizeof(short)
	INTSIZE == sizeof(int)
	LONGSIZE == sizeof(long)
	LONGLONGSIZE == sizeof(long long) (if HAS_LONG_LONG)
	PTRSIZE == sizeof(void *)
	DOUBLESIZE == sizeof(double)
	LONG_DOUBLESIZE == sizeof(long double) (if HAS_LONG_DOUBLE).

*/

#ifdef I_INTTYPES /* e.g. Linux has int64_t without <inttypes.h> */
#   include <inttypes.h>
#   ifdef INT32_MIN_BROKEN
#       undef  INT32_MIN
#       define INT32_MIN (-2147483647-1)
#   endif
#   ifdef INT64_MIN_BROKEN
#       undef  INT64_MIN
#       define INT64_MIN (-9223372036854775807LL-1)
#   endif
#endif

typedef I8TYPE I8;
typedef U8TYPE U8;
typedef I16TYPE I16;
typedef U16TYPE U16;
typedef I32TYPE I32;
typedef U32TYPE U32;
#ifdef PERL_CORE
#   ifdef HAS_QUAD
typedef I64TYPE I64;
typedef U64TYPE U64;
#   endif
#endif /* PERL_CORE */

#if defined(HAS_QUAD) && defined(USE_64_BIT_INT)
#   if defined(HAS_LONG_LONG) && QUADKIND == QUAD_IS_LONG_LONG
#       define PeRl_INT64_C(c)	CAT2(c,LL)
#       define PeRl_UINT64_C(c)	CAT2(c,ULL)
#   else
#       if QUADKIND == QUAD_IS___INT64
#           define PeRl_INT64_C(c)	CAT2(c,I64)
#           define PeRl_UINT64_C(c)	CAT2(c,UI64)
#       else
#           if LONGSIZE == 8 && QUADKIND == QUAD_IS_LONG
#               define PeRl_INT64_C(c)	CAT2(c,L)
#               define PeRl_UINT64_C(c)	CAT2(c,UL)
#           else
#               define PeRl_INT64_C(c)	((I64TYPE)(c))
#               define PeRl_UINT64_C(c)	((U64TYPE)(c))
#           endif
#       endif
#   endif
#   ifndef UINT64_C
#   define UINT64_C(c) PeRl_UINT64_C(c)
#   endif
#   ifndef INT64_C
#   define INT64_C(c) PeRl_INT64_C(c)
#   endif
#endif

#if defined(UINT8_MAX) && defined(INT16_MAX) && defined(INT32_MAX)

/* I8_MAX and I8_MIN constants are not defined, as I8 is an ambiguous type.
   Please search CHAR_MAX in perl.h for further details. */
#define U8_MAX UINT8_MAX
#define U8_MIN UINT8_MIN

#define I16_MAX INT16_MAX
#define I16_MIN INT16_MIN
#define U16_MAX UINT16_MAX
#define U16_MIN UINT16_MIN

#define I32_MAX INT32_MAX
#define I32_MIN INT32_MIN
#ifndef UINT32_MAX_BROKEN /* e.g. HP-UX with gcc messes this up */
#  define U32_MAX UINT32_MAX
#else
#  define U32_MAX 4294967295U
#endif
#define U32_MIN UINT32_MIN

#else

/* I8_MAX and I8_MIN constants are not defined, as I8 is an ambiguous type.
   Please search CHAR_MAX in perl.h for further details. */
#define U8_MAX PERL_UCHAR_MAX
#define U8_MIN PERL_UCHAR_MIN

#define I16_MAX PERL_SHORT_MAX
#define I16_MIN PERL_SHORT_MIN
#define U16_MAX PERL_USHORT_MAX
#define U16_MIN PERL_USHORT_MIN

#if LONGSIZE > 4
# define I32_MAX PERL_INT_MAX
# define I32_MIN PERL_INT_MIN
# define U32_MAX PERL_UINT_MAX
# define U32_MIN PERL_UINT_MIN
#else
# define I32_MAX PERL_LONG_MAX
# define I32_MIN PERL_LONG_MIN
# define U32_MAX PERL_ULONG_MAX
# define U32_MIN PERL_ULONG_MIN
#endif

#endif

/* log(2) is pretty close to  0.30103, just in case anyone is grepping for it */
#define BIT_DIGITS(N)   (((N)*146)/485 + 1)  /* log2(10) =~ 146/485 */
#define TYPE_DIGITS(T)  BIT_DIGITS(sizeof(T) * 8)
#define TYPE_CHARS(T)   (TYPE_DIGITS(T) + 2) /* sign, NUL */

#define Ctl(ch) ((ch) & 037)

/* This is a helper macro to avoid preprocessor issues, replaced by nothing
 * unless under DEBUGGING, where it expands to an assert of its argument,
 * followed by a comma (hence the comma operator).  If we just used a straight
 * assert(), we would get a comma with nothing before it when not DEBUGGING */
#ifdef DEBUGGING
#   define __ASSERT_(statement)  assert(statement),
#else
#   define __ASSERT_(statement)
#endif

/*
=head1 SV-Body Allocation

=for apidoc Ama|SV*|newSVpvs|const char* s
Like C<newSVpvn>, but takes a literal C<NUL>-terminated string instead of a
string/length pair.

=for apidoc Ama|SV*|newSVpvs_flags|const char* s|U32 flags
Like C<newSVpvn_flags>, but takes a literal C<NUL>-terminated string instead of
a string/length pair.

=for apidoc Ama|SV*|newSVpvs_share|const char* s
Like C<newSVpvn_share>, but takes a literal C<NUL>-terminated string instead of
a string/length pair and omits the hash parameter.

=for apidoc Am|void|sv_catpvs_flags|SV* sv|const char* s|I32 flags
Like C<sv_catpvn_flags>, but takes a literal C<NUL>-terminated string instead
of a string/length pair.

=for apidoc Am|void|sv_catpvs_nomg|SV* sv|const char* s
Like C<sv_catpvn_nomg>, but takes a literal string instead of a
string/length pair.

=for apidoc Am|void|sv_catpvs|SV* sv|const char* s
Like C<sv_catpvn>, but takes a literal string instead of a string/length pair.

=for apidoc Am|void|sv_catpvs_mg|SV* sv|const char* s
Like C<sv_catpvn_mg>, but takes a literal string instead of a
string/length pair.

=for apidoc Am|void|sv_setpvs|SV* sv|const char* s
Like C<sv_setpvn>, but takes a literal string instead of a string/length pair.

=for apidoc Am|void|sv_setpvs_mg|SV* sv|const char* s
Like C<sv_setpvn_mg>, but takes a literal string instead of a
string/length pair.

=for apidoc Am|SV *|sv_setref_pvs|const char* s
Like C<sv_setref_pvn>, but takes a literal string instead of a
string/length pair.

=head1 Memory Management

=for apidoc Ama|char*|savepvs|const char* s
Like C<savepvn>, but takes a literal C<NUL>-terminated string instead of a
string/length pair.

=for apidoc Ama|char*|savesharedpvs|const char* s
A version of C<savepvs()> which allocates the duplicate string in memory
which is shared between threads.

=head1 GV Functions

=for apidoc Am|HV*|gv_stashpvs|const char* name|I32 create
Like C<gv_stashpvn>, but takes a literal string instead of a string/length pair.

=head1 Hash Manipulation Functions

=for apidoc Am|SV**|hv_fetchs|HV* tb|const char* key|I32 lval
Like C<hv_fetch>, but takes a literal string instead of a string/length pair.

=for apidoc Am|SV**|hv_stores|HV* tb|const char* key|NULLOK SV* val
Like C<hv_store>, but takes a literal string instead of a string/length pair
and omits the hash parameter.

=head1 Lexer interface

=for apidoc Amx|void|lex_stuff_pvs|const char *pv|U32 flags

Like L</lex_stuff_pvn>, but takes a literal string instead of a
string/length pair.

=cut
*/

/* concatenating with "" ensures that only literal strings are accepted as
 * argument */
#define STR_WITH_LEN(s)  ("" s ""), (sizeof(s)-1)

/* note that STR_WITH_LEN() can't be used as argument to macros or functions
 * that under some configurations might be macros, which means that it requires
 * the full Perl_xxx(aTHX_ ...) form for any API calls where it's used.
 */

/* STR_WITH_LEN() shortcuts */
#define newSVpvs(str) Perl_newSVpvn(aTHX_ STR_WITH_LEN(str))
#define newSVpvs_flags(str,flags)	\
    Perl_newSVpvn_flags(aTHX_ STR_WITH_LEN(str), flags)
#define newSVpvs_share(str) Perl_newSVpvn_share(aTHX_ STR_WITH_LEN(str), 0)
#define sv_catpvs_flags(sv, str, flags) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), flags)
#define sv_catpvs_nomg(sv, str) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), 0)
#define sv_catpvs(sv, str) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), SV_GMAGIC)
#define sv_catpvs_mg(sv, str) \
    Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), SV_GMAGIC|SV_SMAGIC)
#define sv_setpvs(sv, str) Perl_sv_setpvn(aTHX_ sv, STR_WITH_LEN(str))
#define sv_setpvs_mg(sv, str) Perl_sv_setpvn_mg(aTHX_ sv, STR_WITH_LEN(str))
#define sv_setref_pvs(rv, classname, str) \
    Perl_sv_setref_pvn(aTHX_ rv, classname, STR_WITH_LEN(str))
#define savepvs(str) Perl_savepvn(aTHX_ STR_WITH_LEN(str))
#define savesharedpvs(str) Perl_savesharedpvn(aTHX_ STR_WITH_LEN(str))
#define gv_stashpvs(str, create) \
    Perl_gv_stashpvn(aTHX_ STR_WITH_LEN(str), create)
#define gv_fetchpvs(namebeg, add, sv_type) \
    Perl_gv_fetchpvn_flags(aTHX_ STR_WITH_LEN(namebeg), add, sv_type)
#define gv_fetchpvn(namebeg, len, add, sv_type) \
    Perl_gv_fetchpvn_flags(aTHX_ namebeg, len, add, sv_type)
#define sv_catxmlpvs(dsv, str, utf8) \
    Perl_sv_catxmlpvn(aTHX_ dsv, STR_WITH_LEN(str), utf8)
#define hv_fetchs(hv,key,lval)						\
  ((SV **)Perl_hv_common(aTHX_ (hv), NULL, STR_WITH_LEN(key), 0,	\
			 (lval) ? (HV_FETCH_JUST_SV | HV_FETCH_LVALUE)	\
			 : HV_FETCH_JUST_SV, NULL, 0))

#define hv_stores(hv,key,val)						\
  ((SV **)Perl_hv_common(aTHX_ (hv), NULL, STR_WITH_LEN(key), 0,	\
			 (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), (val), 0))

#define lex_stuff_pvs(pv,flags) Perl_lex_stuff_pvn(aTHX_ STR_WITH_LEN(pv), flags)

#define get_cvs(str, flags)					\
	Perl_get_cvn_flags(aTHX_ STR_WITH_LEN(str), (flags))

/*
=head1 Miscellaneous Functions

=for apidoc Am|bool|strNE|char* s1|char* s2
Test two strings to see if they are different.  Returns true or
false.

=for apidoc Am|bool|strEQ|char* s1|char* s2
Test two strings to see if they are equal.  Returns true or false.

=for apidoc Am|bool|strLT|char* s1|char* s2
Test two strings to see if the first, C<s1>, is less than the second,
C<s2>.  Returns true or false.

=for apidoc Am|bool|strLE|char* s1|char* s2
Test two strings to see if the first, C<s1>, is less than or equal to the
second, C<s2>.  Returns true or false.

=for apidoc Am|bool|strGT|char* s1|char* s2
Test two strings to see if the first, C<s1>, is greater than the second,
C<s2>.  Returns true or false.

=for apidoc Am|bool|strGE|char* s1|char* s2
Test two strings to see if the first, C<s1>, is greater than or equal to
the second, C<s2>.  Returns true or false.

=for apidoc Am|bool|strnNE|char* s1|char* s2|STRLEN len
Test two strings to see if they are different.  The C<len> parameter
indicates the number of bytes to compare.  Returns true or false.  (A
wrapper for C<strncmp>).

=for apidoc Am|bool|strnEQ|char* s1|char* s2|STRLEN len
Test two strings to see if they are equal.  The C<len> parameter indicates
the number of bytes to compare.  Returns true or false.  (A wrapper for
C<strncmp>).

=cut
*/

#define strNE(s1,s2) (strcmp(s1,s2))
#define strEQ(s1,s2) (!strcmp(s1,s2))
#define strLT(s1,s2) (strcmp(s1,s2) < 0)
#define strLE(s1,s2) (strcmp(s1,s2) <= 0)
#define strGT(s1,s2) (strcmp(s1,s2) > 0)
#define strGE(s1,s2) (strcmp(s1,s2) >= 0)
#define strnNE(s1,s2,l) (strncmp(s1,s2,l))
#define strnEQ(s1,s2,l) (!strncmp(s1,s2,l))

#ifdef HAS_MEMCMP
#  define memNE(s1,s2,l) (memcmp(s1,s2,l))
#  define memEQ(s1,s2,l) (!memcmp(s1,s2,l))
#else
#  define memNE(s1,s2,l) (bcmp(s1,s2,l))
#  define memEQ(s1,s2,l) (!bcmp(s1,s2,l))
#endif

#define memEQs(s1, l, s2) \
	(sizeof(s2)-1 == l && memEQ(s1, ("" s2 ""), (sizeof(s2)-1)))
#define memNEs(s1, l, s2) !memEQs(s1, l, s2)

/*
 * Character classes.
 *
 * Unfortunately, the introduction of locales means that we
 * can't trust isupper(), etc. to tell the truth.  And when
 * it comes to /\w+/ with tainting enabled, we *must* be able
 * to trust our character classes.
 *
 * Therefore, the default tests in the text of Perl will be
 * independent of locale.  Any code that wants to depend on
 * the current locale will use the tests that begin with "lc".
 */

#ifdef HAS_SETLOCALE  /* XXX Is there a better test for this? */
#  ifndef CTYPE256
#    define CTYPE256
#  endif
#endif

/*

=head1 Character classes
This section is about functions (really macros) that classify characters
into types, such as punctuation versus alphabetic, etc.  Most of these are
analogous to regular expression character classes.  (See
L<perlrecharclass/POSIX Character Classes>.)  There are several variants for
each class.  (Not all macros have all variants; each item below lists the
ones valid for it.)  None are affected by C<use bytes>, and only the ones
with C<LC> in the name are affected by the current locale.

The base function, e.g., C<isALPHA()>, takes an octet (either a C<char> or a
C<U8>) as input and returns a boolean as to whether or not the character
represented by that octet is (or on non-ASCII platforms, corresponds to) an
ASCII character in the named class based on platform, Unicode, and Perl rules.
If the input is a number that doesn't fit in an octet, FALSE is returned.

Variant C<isFOO_A> (e.g., C<isALPHA_A()>) is identical to the base function
with no suffix C<"_A">.

Variant C<isFOO_L1> imposes the Latin-1 (or EBCDIC equivlalent) character set
onto the platform.  That is, the code points that are ASCII are unaffected,
since ASCII is a subset of Latin-1.  But the non-ASCII code points are treated
as if they are Latin-1 characters.  For example, C<isWORDCHAR_L1()> will return
true when called with the code point 0xDF, which is a word character in both
ASCII and EBCDIC (though it represents different characters in each).

Variant C<isFOO_uni> is like the C<isFOO_L1> variant, but accepts any UV code
point as input.  If the code point is larger than 255, Unicode rules are used
to determine if it is in the character class.  For example,
C<isWORDCHAR_uni(0x100)> returns TRUE, since 0x100 is LATIN CAPITAL LETTER A
WITH MACRON in Unicode, and is a word character.

Variant C<isFOO_utf8> is like C<isFOO_uni>, but the input is a pointer to a
(known to be well-formed) UTF-8 encoded string (C<U8*> or C<char*>).  The
classification of just the first (possibly multi-byte) character in the string
is tested.

Variant C<isFOO_LC> is like the C<isFOO_A> and C<isFOO_L1> variants, but the
result is based on the current locale, which is what C<LC> in the name stands
for.  If Perl can determine that the current locale is a UTF-8 locale, it uses
the published Unicode rules; otherwise, it uses the C library function that
gives the named classification.  For example, C<isDIGIT_LC()> when not in a
UTF-8 locale returns the result of calling C<isdigit()>.  FALSE is always
returned if the input won't fit into an octet.

Variant C<isFOO_LC_uvchr> is like C<isFOO_LC>, but is defined on any UV.  It
returns the same as C<isFOO_LC> for input code points less than 256, and
returns the hard-coded, not-affected-by-locale, Unicode results for larger ones.

Variant C<isFOO_LC_utf8> is like C<isFOO_LC_uvchr>, but the input is a pointer to a
(known to be well-formed) UTF-8 encoded string (C<U8*> or C<char*>).  The
classification of just the first (possibly multi-byte) character in the string
is tested.

=for apidoc Am|bool|isALPHA|char ch
Returns a boolean indicating whether the specified character is an
alphabetic character, analogous to C<m/[[:alpha:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isALPHA_A>, C<isALPHA_L1>, C<isALPHA_uni>, C<isALPHA_utf8>, C<isALPHA_LC>,
C<isALPHA_LC_uvchr>, and C<isALPHA_LC_utf8>.

=for apidoc Am|bool|isALPHANUMERIC|char ch
Returns a boolean indicating whether the specified character is a either an
alphabetic character or decimal digit, analogous to C<m/[[:alnum:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isALPHANUMERIC_A>, C<isALPHANUMERIC_L1>, C<isALPHANUMERIC_uni>,
C<isALPHANUMERIC_utf8>, C<isALPHANUMERIC_LC>, C<isALPHANUMERIC_LC_uvchr>, and
C<isALPHANUMERIC_LC_utf8>.

=for apidoc Am|bool|isASCII|char ch
Returns a boolean indicating whether the specified character is one of the 128
characters in the ASCII character set, analogous to C<m/[[:ascii:]]/>.
On non-ASCII platforms, it returns TRUE iff this
character corresponds to an ASCII character.  Variants C<isASCII_A()> and
C<isASCII_L1()> are identical to C<isASCII()>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isASCII_uni>, C<isASCII_utf8>, C<isASCII_LC>, C<isASCII_LC_uvchr>, and
C<isASCII_LC_utf8>.  Note, however, that some platforms do not have the C
library routine C<isascii()>.  In these cases, the variants whose names contain
C<LC> are the same as the corresponding ones without.

Also note, that because all ASCII characters are UTF-8 invariant (meaning they
have the exact same representation (always a single byte) whether encoded in
UTF-8 or not), C<isASCII> will give the correct results when called with any
byte in any string encoded or not in UTF-8.  And similarly C<isASCII_utf8> will
work properly on any string encoded or not in UTF-8.

=for apidoc Am|bool|isBLANK|char ch
Returns a boolean indicating whether the specified character is a
character considered to be a blank, analogous to C<m/[[:blank:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isBLANK_A>, C<isBLANK_L1>, C<isBLANK_uni>, C<isBLANK_utf8>, C<isBLANK_LC>,
C<isBLANK_LC_uvchr>, and C<isBLANK_LC_utf8>.  Note, however, that some
platforms do not have the C library routine C<isblank()>.  In these cases, the
variants whose names contain C<LC> are the same as the corresponding ones
without.

=for apidoc Am|bool|isCNTRL|char ch
Returns a boolean indicating whether the specified character is a
control character, analogous to C<m/[[:cntrl:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isCNTRL_A>, C<isCNTRL_L1>, C<isCNTRL_uni>, C<isCNTRL_utf8>, C<isCNTRL_LC>,
C<isCNTRL_LC_uvchr>, and C<isCNTRL_LC_utf8>
On EBCDIC platforms, you almost always want to use the C<isCNTRL_L1> variant.

=for apidoc Am|bool|isDIGIT|char ch
Returns a boolean indicating whether the specified character is a
digit, analogous to C<m/[[:digit:]]/>.
Variants C<isDIGIT_A> and C<isDIGIT_L1> are identical to C<isDIGIT>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isDIGIT_uni>, C<isDIGIT_utf8>, C<isDIGIT_LC>, C<isDIGIT_LC_uvchr>, and
C<isDIGIT_LC_utf8>.

=for apidoc Am|bool|isGRAPH|char ch
Returns a boolean indicating whether the specified character is a
graphic character, analogous to C<m/[[:graph:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isGRAPH_A>, C<isGRAPH_L1>, C<isGRAPH_uni>, C<isGRAPH_utf8>, C<isGRAPH_LC>,
C<isGRAPH_LC_uvchr>, and C<isGRAPH_LC_utf8>.

=for apidoc Am|bool|isLOWER|char ch
Returns a boolean indicating whether the specified character is a
lowercase character, analogous to C<m/[[:lower:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isLOWER_A>, C<isLOWER_L1>, C<isLOWER_uni>, C<isLOWER_utf8>, C<isLOWER_LC>,
C<isLOWER_LC_uvchr>, and C<isLOWER_LC_utf8>.

=for apidoc Am|bool|isOCTAL|char ch
Returns a boolean indicating whether the specified character is an
octal digit, [0-7].
The only two variants are C<isOCTAL_A> and C<isOCTAL_L1>; each is identical to
C<isOCTAL>.

=for apidoc Am|bool|isPUNCT|char ch
Returns a boolean indicating whether the specified character is a
punctuation character, analogous to C<m/[[:punct:]]/>.
Note that the definition of what is punctuation isn't as
straightforward as one might desire.  See L<perlrecharclass/POSIX Character
Classes> for details.
See the L<top of this section|/Character classes> for an explanation of variants
C<isPUNCT_A>, C<isPUNCT_L1>, C<isPUNCT_uni>, C<isPUNCT_utf8>, C<isPUNCT_LC>,
C<isPUNCT_LC_uvchr>, and C<isPUNCT_LC_utf8>.

=for apidoc Am|bool|isSPACE|char ch
Returns a boolean indicating whether the specified character is a
whitespace character.  This is analogous
to what C<m/\s/> matches in a regular expression.  Starting in Perl 5.18
(experimentally), this also matches what C<m/[[:space:]]/> does.
("Experimentally" means that this change may be backed out in 5.22 if
field experience indicates that it was unwise.)  Prior to 5.18, only the
locale forms of this macro (the ones with C<LC> in their names) matched
precisely what C<m/[[:space:]]/> does.  In those releases, the only difference,
in the non-locale variants, was that C<isSPACE()> did not match a vertical tab.
(See L</isPSXSPC> for a macro that matches a vertical tab in all releases.)
See the L<top of this section|/Character classes> for an explanation of variants
C<isSPACE_A>, C<isSPACE_L1>, C<isSPACE_uni>, C<isSPACE_utf8>, C<isSPACE_LC>,
C<isSPACE_LC_uvchr>, and C<isSPACE_LC_utf8>.

=for apidoc Am|bool|isPSXSPC|char ch
(short for Posix Space)
Starting in 5.18, this is identical (experimentally) in all its forms to the
corresponding C<isSPACE()> macros.  ("Experimentally" means that this change
may be backed out in 5.22 if field experience indicates that it
was unwise.)
The locale forms of this macro are identical to their corresponding
C<isSPACE()> forms in all Perl releases.  In releases prior to 5.18, the
non-locale forms differ from their C<isSPACE()> forms only in that the
C<isSPACE()> forms don't match a Vertical Tab, and the C<isPSXSPC()> forms do.
Otherwise they are identical.  Thus this macro is analogous to what
C<m/[[:space:]]/> matches in a regular expression.
See the L<top of this section|/Character classes> for an explanation of variants
C<isPSXSPC_A>, C<isPSXSPC_L1>, C<isPSXSPC_uni>, C<isPSXSPC_utf8>, C<isPSXSPC_LC>,
C<isPSXSPC_LC_uvchr>, and C<isPSXSPC_LC_utf8>.

=for apidoc Am|bool|isUPPER|char ch
Returns a boolean indicating whether the specified character is an
uppercase character, analogous to C<m/[[:upper:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isUPPER_A>, C<isUPPER_L1>, C<isUPPER_uni>, C<isUPPER_utf8>, C<isUPPER_LC>,
C<isUPPER_LC_uvchr>, and C<isUPPER_LC_utf8>.

=for apidoc Am|bool|isPRINT|char ch
Returns a boolean indicating whether the specified character is a
printable character, analogous to C<m/[[:print:]]/>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isPRINT_A>, C<isPRINT_L1>, C<isPRINT_uni>, C<isPRINT_utf8>, C<isPRINT_LC>,
C<isPRINT_LC_uvchr>, and C<isPRINT_LC_utf8>.

=for apidoc Am|bool|isWORDCHAR|char ch
Returns a boolean indicating whether the specified character is a character
that is a word character, analogous to what C<m/\w/> and C<m/[[:word:]]/> match
in a regular expression.  A word character is an alphabetic character, a
decimal digit, a connecting punctuation character (such as an underscore), or
a "mark" character that attaches to one of those (like some sort of accent).
C<isALNUM()> is a synonym provided for backward compatibility, even though a
word character includes more than the standard C language meaning of
alphanumeric.
See the L<top of this section|/Character classes> for an explanation of variants
C<isWORDCHAR_A>, C<isWORDCHAR_L1>, C<isWORDCHAR_uni>, C<isWORDCHAR_utf8>,
C<isWORDCHAR_LC>, C<isWORDCHAR_LC_uvchr>, and C<isWORDCHAR_LC_utf8>.

=for apidoc Am|bool|isXDIGIT|char ch
Returns a boolean indicating whether the specified character is a hexadecimal
digit.  In the ASCII range these are C<[0-9A-Fa-f]>.  Variants C<isXDIGIT_A()>
and C<isXDIGIT_L1()> are identical to C<isXDIGIT()>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isXDIGIT_uni>, C<isXDIGIT_utf8>, C<isXDIGIT_LC>, C<isXDIGIT_LC_uvchr>, and
C<isXDIGIT_LC_utf8>.

=for apidoc Am|bool|isIDFIRST|char ch
Returns a boolean indicating whether the specified character can be the first
character of an identifier.  This is very close to, but not quite the same as
the official Unicode property C<XID_Start>.  The difference is that this
returns true only if the input character also matches L</isWORDCHAR>.
See the L<top of this section|/Character classes> for an explanation of variants
C<isIDFIRST_A>, C<isIDFIRST_L1>, C<isIDFIRST_uni>, C<isIDFIRST_utf8>,
C<isIDFIRST_LC>, C<isIDFIRST_LC_uvchr>, and C<isIDFIRST_LC_utf8>.

=for apidoc Am|bool|isIDCONT|char ch
Returns a boolean indicating whether the specified character can be the
second or succeeding character of an identifier.  This is very close to, but
not quite the same as the official Unicode property C<XID_Continue>.  The
difference is that this returns true only if the input character also matches
L</isWORDCHAR>.  See the L<top of this section|/Character classes> for an
explanation of variants C<isIDCONT_A>, C<isIDCONT_L1>, C<isIDCONT_uni>,
C<isIDCONT_utf8>, C<isIDCONT_LC>, C<isIDCONT_LC_uvchr>, and
C<isIDCONT_LC_utf8>.

=head1 Miscellaneous Functions

=for apidoc Am|U8|READ_XDIGIT|char str*
Returns the value of an ASCII-range hex digit and advances the string pointer.
Behaviour is only well defined when isXDIGIT(*str) is true.

=head1 Character case changing

=for apidoc Am|U8|toUPPER|U8 ch
Converts the specified character to uppercase.  If the input is anything but an
ASCII lowercase character, that input character itself is returned.  Variant
C<toUPPER_A> is equivalent.

=for apidoc Am|UV|toUPPER_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its uppercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the uppercase version may be longer than the original character.

The first code point of the uppercased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toUPPER_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its uppercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the uppercase version may be longer than the original character.

The first code point of the uppercased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.

=for apidoc Am|U8|toFOLD|U8 ch
Converts the specified character to foldcase.  If the input is anything but an
ASCII uppercase character, that input character itself is returned.  Variant
C<toFOLD_A> is equivalent.  (There is no equivalent C<to_FOLD_L1> for the full
Latin1 range, as the full generality of L</toFOLD_uni> is needed there.)

=for apidoc Am|UV|toFOLD_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its foldcase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the foldcase version may be longer than the original character.

The first code point of the foldcased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toFOLD_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its foldcase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the foldcase version may be longer than the original character.

The first code point of the foldcased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.

=for apidoc Am|U8|toLOWER|U8 ch
Converts the specified character to lowercase.  If the input is anything but an
ASCII uppercase character, that input character itself is returned.  Variant
C<toLOWER_A> is equivalent.

=for apidoc Am|U8|toLOWER_L1|U8 ch
Converts the specified Latin1 character to lowercase.  The results are undefined if
the input doesn't fit in a byte.

=for apidoc Am|U8|toLOWER_LC|U8 ch
Converts the specified character to lowercase using the current locale's rules,
if possible; otherwise returns the input character itself.

=for apidoc Am|UV|toLOWER_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its lowercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the lowercase version may be longer than the original character.

The first code point of the lowercased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toLOWER_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its lowercase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the lowercase version may be longer than the original character.

The first code point of the lowercased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.

=for apidoc Am|U8|toLOWER_LC|U8 ch
Converts the specified character to lowercase using the current locale's rules,
if possible; otherwise returns the input character itself.

=for apidoc Am|U8|toTITLE|U8 ch
Converts the specified character to titlecase.  If the input is anything but an
ASCII lowercase character, that input character itself is returned.  Variant
C<toTITLE_A> is equivalent.  (There is no C<toTITLE_L1> for the full Latin1 range,
as the full generality of L</toTITLE_uni> is needed there.  Titlecase is not a
concept used in locale handling, so there is no functionality for that.)

=for apidoc Am|UV|toTITLE_uni|UV cp|U8* s|STRLEN* lenp
Converts the Unicode code point C<cp> to its titlecase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the titlecase version may be longer than the original character.

The first code point of the titlecased version is returned
(but note, as explained just above, that there may be more.)

=for apidoc Am|UV|toTITLE_utf8|U8* p|U8* s|STRLEN* lenp
Converts the UTF-8 encoded character at C<p> to its titlecase version, and
stores that in UTF-8 in C<s>, and its length in bytes in C<lenp>.  Note
that the buffer pointed to by C<s> needs to be at least C<UTF8_MAXBYTES_CASE+1>
bytes since the titlecase version may be longer than the original character.

The first code point of the titlecased version is returned
(but note, as explained just above, that there may be more.)

The input character at C<p> is assumed to be well-formed.

=cut

XXX Still undocumented isVERTWS_uni and _utf8; it's unclear what their names
really should be.  Also toUPPER_LC and toFOLD_LC, which are subject to change.

Note that these macros are repeated in Devel::PPPort, so should also be
patched there.  The file as of this writing is cpan/Devel-PPPort/parts/inc/misc

*/

/* Specify the widest unsigned type on the platform.  Use U64TYPE because U64
 * is known only in the perl core, and this macro can be called from outside
 * that */
#ifdef HAS_QUAD
#   define WIDEST_UTYPE U64TYPE
#else
#   define WIDEST_UTYPE U32
#endif

/* FITS_IN_8_BITS(c) returns true if c doesn't have  a bit set other than in
 * the lower 8.  It is designed to be hopefully bomb-proof, making sure that no
 * bits of information are lost even on a 64-bit machine, but to get the
 * compiler to optimize it out if possible.  This is because Configure makes
 * sure that the machine has an 8-bit byte, so if c is stored in a byte, the
 * sizeof() guarantees that this evaluates to a constant true at compile time.
 */
#define FITS_IN_8_BITS(c) ((sizeof(c) == 1) || !(((WIDEST_UTYPE)(c)) & ~0xFF))

#ifdef EBCDIC
#   ifndef _ALL_SOURCE
        /* This returns the wrong results on at least z/OS unless this is
         * defined. */
#       error   _ALL_SOURCE should probably be defined
#   endif

    /* We could be called without perl.h, in which case NATIVE_TO_ASCII() is
     * likely not defined, and so we use the native function */
#   define isASCII(c)    cBOOL(isascii(c))
#else
#   define isASCII(c)    ((WIDEST_UTYPE)(c) < 128)
#endif

#define isASCII_A(c)  isASCII(c)
#define isASCII_L1(c)  isASCII(c)

/* The lower 3 bits in both the ASCII and EBCDIC representations of '0' are 0,
 * and the 8 possible permutations of those bits exactly comprise the 8 octal
 * digits */
#define isOCTAL_A(c)  cBOOL(FITS_IN_8_BITS(c) && (0xF8 & (c)) == '0')

/* ASCII range only */
#ifdef H_PERL       /* If have access to perl.h, lookup in its table */

/* Character class numbers.  For internal core Perl use only.  The ones less
 * than 32 are used in PL_charclass[] and the ones up through the one that
 * corresponds to <_HIGHEST_REGCOMP_DOT_H_SYNC> are used by regcomp.h and
 * related files.  PL_charclass ones use names used in l1_char_class_tab.h but
 * their actual definitions are here.  If that file has a name not used here,
 * it won't compile.
 *
 * The first group of these is ordered in what I (khw) estimate to be the
 * frequency of their use.  This gives a slight edge to exiting a loop earlier
 * (in reginclass() in regexec.c) */
#  define _CC_WORDCHAR           0      /* \w and [:word:] */
#  define _CC_DIGIT              1      /* \d and [:digit:] */
#  define _CC_ALPHA              2      /* [:alpha:] */
#  define _CC_LOWER              3      /* [:lower:] */
#  define _CC_UPPER              4      /* [:upper:] */
#  define _CC_PUNCT              5      /* [:punct:] */
#  define _CC_PRINT              6      /* [:print:] */
#  define _CC_ALPHANUMERIC       7      /* [:alnum:] */
#  define _CC_GRAPH              8      /* [:graph:] */
#  define _CC_CASED              9      /* [:lower:] and [:upper:] under /i */

#define _FIRST_NON_SWASH_CC     10
/* The character classes above are implemented with swashes.  The second group
 * (just below) contains the ones implemented without.  These are also sorted
 * in rough order of the frequency of their use, except that \v should be last,
 * as it isn't a real Posix character class, and some (small) inefficiencies in
 * regular expression handling would be introduced by putting it in the middle
 * of those that are.  Also, cntrl and ascii come after the others as it may be
 * useful to group these which have no members that match above Latin1, (or
 * above ASCII in the latter case) */

#  define _CC_SPACE             10      /* \s */
#  define _CC_BLANK             11      /* [:blank:] */
#  define _CC_XDIGIT            12      /* [:xdigit:] */
#  define _CC_PSXSPC            13      /* [:space:] */
#  define _CC_CNTRL             14      /* [:cntrl:] */
#  define _CC_ASCII             15      /* [:ascii:] */
#  define _CC_VERTSPACE         16      /* \v */

#  define _HIGHEST_REGCOMP_DOT_H_SYNC _CC_VERTSPACE

/* The members of the third group below do not need to be coordinated with data
 * structures in regcomp.[ch] and regexec.c.  But they should be added to
 * bootstrap_ctype() */
#  define _CC_IDFIRST           17
#  define _CC_CHARNAME_CONT     18
#  define _CC_NONLATIN1_FOLD    19
#  define _CC_QUOTEMETA         20
#  define _CC_NON_FINAL_FOLD    21
#  define _CC_IS_IN_SOME_FOLD   22
#  define _CC_BACKSLASH_FOO_LBRACE_IS_META 31 /* temp, see mk_PL_charclass.pl */
/* Unused: 23-30
 * If more bits are needed, one could add a second word for non-64bit
 * QUAD_IS_INT systems, using some #ifdefs to distinguish between having a 2nd
 * word or not.  The IS_IN_SOME_FOLD bit is the most easily expendable, as it
 * is used only for optimization (as of this writing), and differs in the
 * Latin1 range from the ALPHA bit only in two relatively unimportant
 * characters: the masculine and feminine ordinal indicators, so removing it
 * would just cause /i regexes which match them to run less efficiently */

#if defined(PERL_CORE) || defined(PERL_EXT)
/* An enum version of the character class numbers, to help compilers
 * optimize */
typedef enum {
    _CC_ENUM_ALPHA          = _CC_ALPHA,
    _CC_ENUM_ALPHANUMERIC   = _CC_ALPHANUMERIC,
    _CC_ENUM_ASCII          = _CC_ASCII,
    _CC_ENUM_BLANK          = _CC_BLANK,
    _CC_ENUM_CASED          = _CC_CASED,
    _CC_ENUM_CNTRL          = _CC_CNTRL,
    _CC_ENUM_DIGIT          = _CC_DIGIT,
    _CC_ENUM_GRAPH          = _CC_GRAPH,
    _CC_ENUM_LOWER          = _CC_LOWER,
    _CC_ENUM_PRINT          = _CC_PRINT,
    _CC_ENUM_PSXSPC         = _CC_PSXSPC,
    _CC_ENUM_PUNCT          = _CC_PUNCT,
    _CC_ENUM_SPACE          = _CC_SPACE,
    _CC_ENUM_UPPER          = _CC_UPPER,
    _CC_ENUM_VERTSPACE      = _CC_VERTSPACE,
    _CC_ENUM_WORDCHAR       = _CC_WORDCHAR,
    _CC_ENUM_XDIGIT         = _CC_XDIGIT
} _char_class_number;
#endif

#define POSIX_SWASH_COUNT _FIRST_NON_SWASH_CC
#define POSIX_CC_COUNT    (_HIGHEST_REGCOMP_DOT_H_SYNC + 1)

#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)
#   if _CC_WORDCHAR != 0 || _CC_DIGIT != 1 || _CC_ALPHA != 2 || _CC_LOWER != 3 \
       || _CC_UPPER != 4 || _CC_PUNCT != 5 || _CC_PRINT != 6                   \
       || _CC_ALPHANUMERIC != 7 || _CC_GRAPH != 8 || _CC_CASED != 9
      #error Need to adjust order of swash_property_names[]
#   endif

/* This is declared static in each of the few files that this is #defined for
 * to keep them from being publicly accessible.  Hence there is a small amount
 * of wasted space */

static const char* const swash_property_names[] = {
    "XPosixWord",
    "XPosixDigit",
    "XPosixAlpha",
    "XPosixLower",
    "XPosixUpper",
    "XPosixPunct",
    "XPosixPrint",
    "XPosixAlnum",
    "XPosixGraph",
    "Cased"
};
#endif

#  ifdef DOINIT
EXTCONST  U32 PL_charclass[] = {
#    include "l1_char_class_tab.h"
};

#  else /* ! DOINIT */
EXTCONST U32 PL_charclass[];
#  endif
#endif  /* Has perl.h */

#if defined(H_PERL) && ! defined(BOOTSTRAP_CHARSET)

    /* The 1U keeps Solaris from griping when shifting sets the uppermost bit */
#   define _CC_mask(classnum) (1U << (classnum))

    /* For internal core Perl use only: the base macro for defining macros like
     * isALPHA */
#   define _generic_isCC(c, classnum) cBOOL(FITS_IN_8_BITS(c) \
                && (PL_charclass[(U8) (c)] & _CC_mask(classnum)))

    /* The mask for the _A versions of the macros; it just adds in the bit for
     * ASCII. */
#   define _CC_mask_A(classnum) (_CC_mask(classnum) | _CC_mask(_CC_ASCII))

    /* For internal core Perl use only: the base macro for defining macros like
     * isALPHA_A.  The foo_A version makes sure that both the desired bit and
     * the ASCII bit are present */
#   define _generic_isCC_A(c, classnum) (FITS_IN_8_BITS(c)  \
        && ((PL_charclass[(U8) (c)] & _CC_mask_A(classnum)) \
                                == _CC_mask_A(classnum)))

#   define isALPHA_A(c)  _generic_isCC_A(c, _CC_ALPHA)
#   define isALPHANUMERIC_A(c) _generic_isCC_A(c, _CC_ALPHANUMERIC)
#   define isBLANK_A(c)  _generic_isCC_A(c, _CC_BLANK)
#   define isCNTRL_A(c)  _generic_isCC_A(c, _CC_CNTRL)
#   define isDIGIT_A(c)  _generic_isCC(c, _CC_DIGIT)
#   define isGRAPH_A(c)  _generic_isCC_A(c, _CC_GRAPH)
#   define isLOWER_A(c)  _generic_isCC_A(c, _CC_LOWER)
#   define isPRINT_A(c)  _generic_isCC_A(c, _CC_PRINT)
#   define isPSXSPC_A(c) _generic_isCC_A(c, _CC_PSXSPC)
#   define isPUNCT_A(c)  _generic_isCC_A(c, _CC_PUNCT)
#   define isSPACE_A(c)  _generic_isCC_A(c, _CC_SPACE)
#   define isUPPER_A(c)  _generic_isCC_A(c, _CC_UPPER)
#   define isWORDCHAR_A(c) _generic_isCC_A(c, _CC_WORDCHAR)
#   define isXDIGIT_A(c)  _generic_isCC(c, _CC_XDIGIT)
#   define isIDFIRST_A(c) _generic_isCC_A(c, _CC_IDFIRST)
#   define isALPHA_L1(c)  _generic_isCC(c, _CC_ALPHA)
#   define isALPHANUMERIC_L1(c) _generic_isCC(c, _CC_ALPHANUMERIC)
#   define isBLANK_L1(c)  _generic_isCC(c, _CC_BLANK)

    /* continuation character for legal NAME in \N{NAME} */
#   define isCHARNAME_CONT(c) _generic_isCC(c, _CC_CHARNAME_CONT)

#   define isCNTRL_L1(c)  _generic_isCC(c, _CC_CNTRL)
#   define isGRAPH_L1(c)  _generic_isCC(c, _CC_GRAPH)
#   define isLOWER_L1(c)  _generic_isCC(c, _CC_LOWER)
#   define isPRINT_L1(c)  _generic_isCC(c, _CC_PRINT)
#   define isPSXSPC_L1(c) _generic_isCC(c, _CC_PSXSPC)
#   define isPUNCT_L1(c)  _generic_isCC(c, _CC_PUNCT)
#   define isSPACE_L1(c)  _generic_isCC(c, _CC_SPACE)
#   define isUPPER_L1(c)  _generic_isCC(c, _CC_UPPER)
#   define isWORDCHAR_L1(c) _generic_isCC(c, _CC_WORDCHAR)
#   define isIDFIRST_L1(c) _generic_isCC(c, _CC_IDFIRST)

    /* Either participates in a fold with a character above 255, or is a
     * multi-char fold */
#   define _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) ((! cBOOL(FITS_IN_8_BITS(c))) || (PL_charclass[(U8) (c)] & _CC_mask(_CC_NONLATIN1_FOLD)))

#   define _isQUOTEMETA(c) _generic_isCC(c, _CC_QUOTEMETA)
#   define _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) \
                                            _generic_isCC(c, _CC_NON_FINAL_FOLD)
#   define _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) \
                                            _generic_isCC(c, _CC_IS_IN_SOME_FOLD)
#else   /* Either don't have perl.h or don't want to use char_class_tab.h */

    /* If we don't have perl.h, we are compiling a utility program.  Below we
     * hard-code various macro definitions that wouldn't otherwise be available
     * to it.  We can also get here if we are configured to bootstrap up Perl
     * on a non-ASCII platform that doesn't have a working Perl (currently only
     * EBCDIC).  For these we currently use the native definitions to get
     * things going.  (It should also be possible to use the translation
     * function NATIVE_TO_LATIN1(), but that is an extra layer of dependence on
     * Perl, so it is currently avoided for the macros where it's possible to
     * do so.) */
#   ifdef EBCDIC
        /* Use the native functions.  They likely will return false for all
         * non-ASCII values, but this makes sure */
#       define isALPHA_A(c)    (isASCII(c) && isalpha(c))
#       define isALPHANUMERIC_A(c) (isASCII(c) && isalnum(c))
#       define isCNTRL_A(c)    (isASCII(c) && iscntrl(c))
#       define isDIGIT_A(c)    (isASCII(c) && isdigit(c))
#       define isGRAPH_A(c)    (isASCII(c) && isgraph(c))
#       define isLOWER_A(c)    (isASCII(c) && islower(c))
#       define isPRINT_A(c)    (isASCII(c) && isprint(c))
#       define isPUNCT_A(c)    (isASCII(c) && ispunct(c))
#       define isSPACE_A(c)    (isASCII(c) && isspace(c))
#       define isUPPER_A(c)    (isASCII(c) && isupper(c))
#       define isXDIGIT_A(c)   (isASCII(c) && isxdigit(c))
#   else   /* ASCII platform.  These are coded based on first principals */
#       define isALPHA_A(c)  (isUPPER_A(c) || isLOWER_A(c))
#       define isALPHANUMERIC_A(c) (isALPHA_A(c) || isDIGIT_A(c))
#       define isCNTRL_A(c)  (isASCII(c) && (! isPRINT_A(c)))
#       define isDIGIT_A(c)  ((c) <= '9' && (c) >= '0')
#       define isGRAPH_A(c)  (isPRINT_A(c) && (c) != ' ')
#       define isLOWER_A(c)  ((c) >= 'a' && (c) <= 'z')
#       define isPRINT_A(c)  (((c) >= 32 && (c) < 127))
#       define isPUNCT_A(c)  (isGRAPH_A(c) && (! isALPHANUMERIC_A(c)))
#       define isSPACE_A(c)  ((c) == ' '                                     \
                              || (c) == '\t'                                 \
                              || (c) == '\n'                                 \
                              || (c) == '\r'                                 \
                              || (c) =='\v'                                  \
                              || (c) == '\f')
#       define isUPPER_A(c)  ((c) <= 'Z' && (c) >= 'A')
#       define isXDIGIT_A(c) (isDIGIT_A(c)                                   \
                              || ((c) >= 'a' && (c) <= 'f')                  \
                              || ((c) <= 'F' && (c) >= 'A'))
#   endif   /* Below are common definitions for ASCII and non-ASCII */
#   define isBLANK_A(c)      ((c) == ' ' || (c) == '\t')
#   define isIDFIRST_A(c)    (isALPHA_A(c) || (c) == '_')
#   define isWORDCHAR_A(c)   (isALPHANUMERIC_A(c) || (c) == '_')

    /* The _L1 macros may be unnecessary for both the utilities and for
     * bootstrapping; I (khw) added them during debugging of bootstrapping, and
     * it seems best to keep them. */
#   define isPSXSPC_A(c)     isSPACE_A(c) /* XXX Assumes SPACE matches '\v' */
#   define isALPHA_L1(c)     (isUPPER_L1(c) || isLOWER_L1(c))
#   define isALPHANUMERIC_L1(c) (isALPHA_L1(c) || isDIGIT_A(c))
#   define isBLANK_L1(c)     (isBLANK_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && NATIVE_TO_LATIN1((U8) c) == 0xA0))
#   define isCNTRL_L1(c)     (FITS_IN_8_BITS(c) && (! isPRINT_L1(c)))
#   define isGRAPH_L1(c)     (isPRINT_L1(c) && (! isBLANK_L1(c)))
#   define isLOWER_L1(c)     (isLOWER_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && ((NATIVE_TO_LATIN1((U8) c) >= 0xDF      \
                                       && NATIVE_TO_LATIN1((U8) c) != 0xF7)  \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xAA   \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xBA   \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xB5)))
#   define isPRINT_L1(c)     (isPRINT_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && NATIVE_TO_LATIN1((U8) c) >= 0xA0))
#   define isPSXSPC_L1(c)    isSPACE_L1(c)
#   define isPUNCT_L1(c)     (isPUNCT_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (NATIVE_TO_LATIN1((U8) c) == 0xA1       \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xA7    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xAB    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xB6    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xB7    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xBB    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xBF)))
#   define isSPACE_L1(c)     (isSPACE_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (NATIVE_TO_LATIN1((U8) c) == 0x85       \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xA0)))
#   define isUPPER_L1(c)     (isUPPER_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (NATIVE_TO_LATIN1((U8) c) >= 0xC0       \
                                      && NATIVE_TO_LATIN1((U8) c) <= 0xDE    \
                                      && NATIVE_TO_LATIN1((U8) c) != 0xD7)))
#   define isWORDCHAR_L1(c)  (isIDFIRST_L1(c) || isDIGIT_A(c))
#   define isIDFIRST_L1(c)   (isALPHA_L1(c) || NATIVE_TO_LATIN1(c) == '_')
#   define isCHARNAME_CONT(c) (isWORDCHAR_L1(c)                              \
                               || isBLANK_L1(c)                              \
                               || (c) == '-'                                 \
                               || (c) == '('                                 \
                               || (c) == ')')
    /* The following are not fully accurate in the above-ASCII range.  I (khw)
     * don't think it's necessary to be so for the purposes where this gets
     * compiled */
#   define _isQUOTEMETA(c)      (FITS_IN_8_BITS(c) && ! isWORDCHAR_L1(c))
#   define _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) isALPHA_L1(c)

    /*  And these aren't accurate at all.  They are useful only for above
     *  Latin1, which utilities and bootstrapping don't deal with */
#   define _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) 0
#   define _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) 0

    /* Many of the macros later in this file are defined in terms of these.  By
     * implementing them with a function, which converts the class number into
     * a call to the desired macro, all of the later ones work.  However, that
     * function won't be actually defined when building a utility program (no
     * perl.h), and so a compiler error will be generated if one is attempted
     * to be used.  And the above-Latin1 code points require Unicode tables to
     * be present, something unlikely to be the case when bootstrapping */
#   define _generic_isCC(c, classnum)                                        \
         (FITS_IN_8_BITS(c) && S_bootstrap_ctype((U8) (c), (classnum), TRUE))
#   define _generic_isCC_A(c, classnum)                                      \
         (FITS_IN_8_BITS(c) && S_bootstrap_ctype((U8) (c), (classnum), FALSE))
#endif  /* End of no perl.h or have BOOTSTRAP_CHARSET */

#define isALPHANUMERIC(c)  isALPHANUMERIC_A(c)
#define isALPHA(c)   isALPHA_A(c)
#define isBLANK(c)   isBLANK_A(c)
#define isCNTRL(c)   isCNTRL_A(c)
#define isDIGIT(c)   isDIGIT_A(c)
#define isGRAPH(c)   isGRAPH_A(c)
#define isIDFIRST(c) isIDFIRST_A(c)
#define isLOWER(c)   isLOWER_A(c)
#define isPRINT(c)   isPRINT_A(c)
#define isPSXSPC(c)  isPSXSPC_A(c)
#define isPUNCT(c)   isPUNCT_A(c)
#define isSPACE(c)   isSPACE_A(c)
#define isUPPER(c)   isUPPER_A(c)
#define isWORDCHAR(c) isWORDCHAR_A(c)
#define isXDIGIT(c)  isXDIGIT_A(c)

/* ASCII casing.  These could also be written as
    #define toLOWER(c) (isASCII(c) ? toLOWER_LATIN1(c) : (c))
    #define toUPPER(c) (isASCII(c) ? toUPPER_LATIN1_MOD(c) : (c))
   which uses table lookup and mask instead of subtraction.  (This would
   work because the _MOD does not apply in the ASCII range) */
#define toLOWER(c)  (isUPPER(c) ? (U8)((c) + ('a' - 'A')) : (c))
#define toUPPER(c)  (isLOWER(c) ? (U8)((c) - ('a' - 'A')) : (c))

/* In the ASCII range, these are equivalent to what they're here defined to be.
 * But by creating these definitions, other code doesn't have to be aware of
 * this detail */
#define toFOLD(c)    toLOWER(c)
#define toTITLE(c)   toUPPER(c)

#define toLOWER_A(c) toLOWER(c)
#define toUPPER_A(c) toUPPER(c)
#define toFOLD_A(c)  toFOLD(c)
#define toTITLE_A(c) toTITLE(c)

/* Use table lookup for speed; returns the input itself if is out-of-range */
#define toLOWER_LATIN1(c)    ((! FITS_IN_8_BITS(c))                        \
                             ? (c)                                         \
                             : PL_latin1_lc[ (U8) (c) ])
#define toLOWER_L1(c)    toLOWER_LATIN1(c)  /* Synonym for consistency */

/* Modified uc.  Is correct uc except for three non-ascii chars which are
 * all mapped to one of them, and these need special handling; returns the
 * input itself if is out-of-range */
#define toUPPER_LATIN1_MOD(c) ((! FITS_IN_8_BITS(c))                       \
                               ? (c)                                       \
                               : PL_mod_latin1_uc[ (U8) (c) ])
#define IN_UTF8_CTYPE_LOCALE PL_in_utf8_CTYPE_locale

/* Use foo_LC_uvchr() instead  of these for beyond the Latin1 range */

/* For internal core Perl use only: the base macro for defining macros like
 * isALPHA_LC, which uses the current LC_CTYPE locale.  'c' is the code point
 * (0-255) to check.  In a UTF-8 locale, the result is the same as calling
 * isFOO_L1(); the 'utf8_locale_classnum' parameter is something like
 * _CC_UPPER, which gives the class number for doing this.  For non-UTF-8
 * locales, the code to actually do the test this is passed in 'non_utf8'.  If
 * 'c' is above 255, 0 is returned.  For accessing the full range of possible
 * code points under locale rules, use the macros based on _generic_LC_uvchr
 * instead of this. */
#define _generic_LC_base(c, utf8_locale_classnum, non_utf8)                    \
           (! FITS_IN_8_BITS(c)                                                \
           ? 0                                                                 \
           : IN_UTF8_CTYPE_LOCALE                                              \
             ? cBOOL(PL_charclass[(U8) (c)] & _CC_mask(utf8_locale_classnum))  \
             : cBOOL(non_utf8))

/* For internal core Perl use only: a helper macro for defining macros like
 * isALPHA_LC.  'c' is the code point (0-255) to check.  The function name to
 * actually do this test is passed in 'non_utf8_func', which is called on 'c',
 * casting 'c' to the macro _LC_CAST, which should not be parenthesized.  See
 * _generic_LC_base for more info */
#define _generic_LC(c, utf8_locale_classnum, non_utf8_func)                    \
                        _generic_LC_base(c,utf8_locale_classnum,               \
                                         non_utf8_func( (_LC_CAST) (c)))

/* For internal core Perl use only: like _generic_LC, but also returns TRUE if
 * 'c' is the platform's native underscore character */
#define _generic_LC_underscore(c,utf8_locale_classnum,non_utf8_func)           \
                        _generic_LC_base(c, utf8_locale_classnum,              \
                                         (non_utf8_func( (_LC_CAST) (c))       \
                                          || (char)(c) == '_'))

/* These next three are also for internal core Perl use only: case-change
 * helper macros */
#define _generic_toLOWER_LC(c, function, cast)  (! FITS_IN_8_BITS(c)           \
                                                ? (c)                          \
                                                : (IN_UTF8_CTYPE_LOCALE)       \
                                                  ? PL_latin1_lc[ (U8) (c) ]   \
                                                : function((cast)(c)))

/* Note that the result can be larger than a byte in a UTF-8 locale.  It
 * returns a single value, so can't adequately return the upper case of LATIN
 * SMALL LETTER SHARP S in a UTF-8 locale (which should be a string of two
 * values "SS");  instead it asserts against that under DEBUGGING, and
 * otherwise returns its input */
#define _generic_toUPPER_LC(c, function, cast)                                 \
                    (! FITS_IN_8_BITS(c)                                       \
                    ? (c)                                                      \
                    : ((! IN_UTF8_CTYPE_LOCALE)                                \
                      ? function((cast)(c))                                    \
                      : ((((U8)(c)) == MICRO_SIGN)                             \
                        ? GREEK_CAPITAL_LETTER_MU                              \
                        : ((((U8)(c)) == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)  \
                          ? LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS              \
                          : ((((U8)(c)) == LATIN_SMALL_LETTER_SHARP_S)         \
                            ? (__ASSERT_(0) (c))                               \
                            : PL_mod_latin1_uc[ (U8) (c) ])))))

/* Note that the result can be larger than a byte in a UTF-8 locale.  It
 * returns a single value, so can't adequately return the fold case of LATIN
 * SMALL LETTER SHARP S in a UTF-8 locale (which should be a string of two
 * values "ss"); instead it asserts against that under DEBUGGING, and
 * otherwise returns its input */
#define _generic_toFOLD_LC(c, function, cast)                                  \
                    ((UNLIKELY((c) == MICRO_SIGN) && IN_UTF8_CTYPE_LOCALE)     \
                      ? GREEK_SMALL_LETTER_MU                                  \
                      : (__ASSERT_(! IN_UTF8_CTYPE_LOCALE                      \
                                   || (c) != LATIN_SMALL_LETTER_SHARP_S)       \
                         _generic_toLOWER_LC(c, function, cast)))

/* Use the libc versions for these if available. */
#if defined(HAS_ISASCII) && ! defined(USE_NEXT_CTYPE)
#   define isASCII_LC(c) (FITS_IN_8_BITS(c) && isascii( (U8) (c)))
#else
#   define isASCII_LC(c) isASCII(c)
#endif

#if defined(HAS_ISBLANK) && ! defined(USE_NEXT_CTYPE)
#   define isBLANK_LC(c) _generic_LC(c, _CC_BLANK, isblank)
#else /* Unlike isASCII, varies if in a UTF-8 locale */
#   define isBLANK_LC(c) (IN_UTF8_CTYPE_LOCALE) ? isBLANK_L1(c) : isBLANK(c)
#endif

#ifdef USE_NEXT_CTYPE   /* NeXT computers */

#    define _LC_CAST unsigned int   /* Needed by _generic_LC.  NeXT functions
                                       use this as their input type */

#    define isALPHA_LC(c)   _generic_LC(c, _CC_ALPHA, NXIsAlpha)
#    define isALPHANUMERIC_LC(c)  _generic_LC(c, _CC_ALPHANUMERIC, NXIsAlNum)
#    define isCNTRL_LC(c)    _generic_LC(c, _CC_CNTRL, NXIsCntrl)
#    define isDIGIT_LC(c)    _generic_LC(c, _CC_DIGIT, NXIsDigit)
#    define isGRAPH_LC(c)    _generic_LC(c, _CC_GRAPH, NXIsGraph)
#    define isIDFIRST_LC(c)  _generic_LC_underscore(c, _CC_IDFIRST, NXIsAlpha)
#    define isLOWER_LC(c)    _generic_LC(c, _CC_LOWER, NXIsLower)
#    define isPRINT_LC(c)    _generic_LC(c, _CC_PRINT, NXIsPrint)
#    define isPUNCT_LC(c)    _generic_LC(c, _CC_PUNCT, NXIsPunct)
#    define isSPACE_LC(c)    _generic_LC(c, _CC_SPACE, NXIsSpace)
#    define isUPPER_LC(c)    _generic_LC(c, _CC_UPPER, NXIsUpper)
#    define isWORDCHAR_LC(c) _generic_LC_underscore(c, _CC_WORDCHAR, NXIsAlNum)
#    define isXDIGIT_LC(c)   _generic_LC(c, _CC_XDIGIT, NXIsXdigit)

#    define toLOWER_LC(c) _generic_toLOWER_LC((c), NXToLower, unsigned int)
#    define toUPPER_LC(c) _generic_toUPPER_LC((c), NXToUpper, unsigned int)
#    define toFOLD_LC(c)  _generic_toFOLD_LC((c), NXToLower, unsigned int)

#else /* !USE_NEXT_CTYPE */

#  define _LC_CAST U8

#  if defined(CTYPE256) || (!defined(isascii) && !defined(HAS_ISASCII))
    /* For most other platforms */

#    define isALPHA_LC(c)   _generic_LC(c, _CC_ALPHA, isalpha)
#    define isALPHANUMERIC_LC(c)  _generic_LC(c, _CC_ALPHANUMERIC, isalnum)
#    define isCNTRL_LC(c)    _generic_LC(c, _CC_CNTRL, iscntrl)
#    define isDIGIT_LC(c)    _generic_LC(c, _CC_DIGIT, isdigit)
#    define isGRAPH_LC(c)    _generic_LC(c, _CC_GRAPH, isgraph)
#    define isIDFIRST_LC(c)  _generic_LC_underscore(c, _CC_IDFIRST, isalpha)
#    define isLOWER_LC(c)    _generic_LC(c, _CC_LOWER, islower)
#    define isPRINT_LC(c)    _generic_LC(c, _CC_PRINT, isprint)
#    define isPUNCT_LC(c)    _generic_LC(c, _CC_PUNCT, ispunct)
#    define isSPACE_LC(c)    _generic_LC(c, _CC_SPACE, isspace)
#    define isUPPER_LC(c)    _generic_LC(c, _CC_UPPER, isupper)
#    define isWORDCHAR_LC(c) _generic_LC_underscore(c, _CC_WORDCHAR, isalnum)
#    define isXDIGIT_LC(c)   _generic_LC(c, _CC_XDIGIT, isxdigit)


#    define toLOWER_LC(c) _generic_toLOWER_LC((c), tolower, U8)
#    define toUPPER_LC(c) _generic_toUPPER_LC((c), toupper, U8)
#    define toFOLD_LC(c)  _generic_toFOLD_LC((c), tolower, U8)

#  else  /* The final fallback position */

#    define isALPHA_LC(c)	(isascii(c) && isalpha(c))
#    define isALPHANUMERIC_LC(c) (isascii(c) && isalnum(c))
#    define isCNTRL_LC(c)	(isascii(c) && iscntrl(c))
#    define isDIGIT_LC(c)	(isascii(c) && isdigit(c))
#    define isGRAPH_LC(c)	(isascii(c) && isgraph(c))
#    define isIDFIRST_LC(c)	(isascii(c) && (isalpha(c) || (c) == '_'))
#    define isLOWER_LC(c)	(isascii(c) && islower(c))
#    define isPRINT_LC(c)	(isascii(c) && isprint(c))
#    define isPUNCT_LC(c)	(isascii(c) && ispunct(c))
#    define isSPACE_LC(c)	(isascii(c) && isspace(c))
#    define isUPPER_LC(c)	(isascii(c) && isupper(c))
#    define isWORDCHAR_LC(c)	(isascii(c) && (isalnum(c) || (c) == '_'))
#    define isXDIGIT_LC(c)      (isascii(c) && isxdigit(c))

#    define toLOWER_LC(c)	(isascii(c) ? tolower(c) : (c))
#    define toUPPER_LC(c)	(isascii(c) ? toupper(c) : (c))
#    define toFOLD_LC(c)	(isascii(c) ? tolower(c) : (c))

#  endif
#endif /* USE_NEXT_CTYPE */

#define isIDCONT(c)             isWORDCHAR(c)
#define isIDCONT_A(c)           isWORDCHAR_A(c)
#define isIDCONT_L1(c)	        isWORDCHAR_L1(c)
#define isIDCONT_LC(c)	        isWORDCHAR_LC(c)
#define isPSXSPC_LC(c)		isSPACE_LC(c)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_uni.  'c' is the code point to check.  'classnum' is the POSIX class
 * number defined earlier in this file.  _generic_uni() is used for POSIX
 * classes where there is a macro or function 'above_latin1' that takes the
 * single argument 'c' and returns the desired value.  These exist for those
 * classes which have simple definitions, avoiding the overhead of a hash
 * lookup or inversion list binary search.  _generic_swash_uni() can be used
 * for classes where that overhead is faster than a direct lookup.
 * _generic_uni() won't compile if 'c' isn't unsigned, as it won't match the
 * 'above_latin1' prototype. _generic_isCC() macro does bounds checking, so
 * have duplicate checks here, so could create versions of the macros that
 * don't, but experiments show that gcc optimizes them out anyway. */

/* Note that all ignore 'use bytes' */
#define _generic_uni(classnum, above_latin1, c) ((c) < 256                    \
                                             ? _generic_isCC(c, classnum)     \
                                             : above_latin1(c))
#define _generic_swash_uni(classnum, c) ((c) < 256                            \
                                             ? _generic_isCC(c, classnum)     \
                                             : _is_uni_FOO(classnum, c))
#define isALPHA_uni(c)      _generic_swash_uni(_CC_ALPHA, c)
#define isALPHANUMERIC_uni(c) _generic_swash_uni(_CC_ALPHANUMERIC, c)
#define isASCII_uni(c)      isASCII(c)
#define isBLANK_uni(c)      _generic_uni(_CC_BLANK, is_HORIZWS_cp_high, c)
#define isCNTRL_uni(c)      isCNTRL_L1(c) /* All controls are in Latin1 */
#define isDIGIT_uni(c)      _generic_swash_uni(_CC_DIGIT, c)
#define isGRAPH_uni(c)      _generic_swash_uni(_CC_GRAPH, c)
#define isIDCONT_uni(c)     _generic_uni(_CC_WORDCHAR, _is_uni_perl_idcont, c)
#define isIDFIRST_uni(c)    _generic_uni(_CC_IDFIRST, _is_uni_perl_idstart, c)
#define isLOWER_uni(c)      _generic_swash_uni(_CC_LOWER, c)
#define isPRINT_uni(c)      _generic_swash_uni(_CC_PRINT, c)

/* Posix and regular space are identical above Latin1 */
#define isPSXSPC_uni(c)     _generic_uni(_CC_PSXSPC, is_XPERLSPACE_cp_high, c)

#define isPUNCT_uni(c)      _generic_swash_uni(_CC_PUNCT, c)
#define isSPACE_uni(c)      _generic_uni(_CC_SPACE, is_XPERLSPACE_cp_high, c)
#define isUPPER_uni(c)      _generic_swash_uni(_CC_UPPER, c)
#define isVERTWS_uni(c)     _generic_uni(_CC_VERTSPACE, is_VERTWS_cp_high, c)
#define isWORDCHAR_uni(c)   _generic_swash_uni(_CC_WORDCHAR, c)
#define isXDIGIT_uni(c)     _generic_uni(_CC_XDIGIT, is_XDIGIT_cp_high, c)

#define toFOLD_uni(c,s,l)	to_uni_fold(c,s,l)
#define toLOWER_uni(c,s,l)	to_uni_lower(c,s,l)
#define toTITLE_uni(c,s,l)	to_uni_title(c,s,l)
#define toUPPER_uni(c,s,l)	to_uni_upper(c,s,l)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_LC_uvchr.  These are like isALPHA_LC, but the input can be any code
 * point, not just 0-255.  Like _generic_uni, there are two versions, one for
 * simple class definitions; the other for more complex.  These are like
 * _generic_uni, so see it for more info. */
#define _generic_LC_uvchr(latin1, above_latin1, c)                            \
                                    (c < 256 ? latin1(c) : above_latin1(c))
#define _generic_LC_swash_uvchr(latin1, classnum, c)                          \
                            (c < 256 ? latin1(c) : _is_uni_FOO(classnum, c))

#define isALPHA_LC_uvchr(c)  _generic_LC_swash_uvchr(isALPHA_LC, _CC_ALPHA, c)
#define isALPHANUMERIC_LC_uvchr(c)  _generic_LC_swash_uvchr(isALPHANUMERIC_LC, \
                                                         _CC_ALPHANUMERIC, c)
#define isASCII_LC_uvchr(c)  isASCII_LC(c)
#define isBLANK_LC_uvchr(c)  _generic_LC_uvchr(isBLANK_LC, is_HORIZWS_cp_high, c)
#define isCNTRL_LC_uvchr(c)  (c < 256 ? isCNTRL_LC(c) : 0)
#define isDIGIT_LC_uvchr(c)  _generic_LC_swash_uvchr(isDIGIT_LC, _CC_DIGIT, c)
#define isGRAPH_LC_uvchr(c)  _generic_LC_swash_uvchr(isGRAPH_LC, _CC_GRAPH, c)
#define isIDCONT_LC_uvchr(c)  _generic_LC_uvchr(isIDCONT_LC,                  \
                                                  _is_uni_perl_idcont, c)
#define isIDFIRST_LC_uvchr(c)  _generic_LC_uvchr(isIDFIRST_LC,                 \
                                                  _is_uni_perl_idstart, c)
#define isLOWER_LC_uvchr(c)  _generic_LC_swash_uvchr(isLOWER_LC, _CC_LOWER, c)
#define isPRINT_LC_uvchr(c)  _generic_LC_swash_uvchr(isPRINT_LC, _CC_PRINT, c)
#define isPSXSPC_LC_uvchr(c) isSPACE_LC_uvchr(c) /* space is identical to posix
                                                    space under locale */
#define isPUNCT_LC_uvchr(c)  _generic_LC_swash_uvchr(isPUNCT_LC, _CC_PUNCT, c)
#define isSPACE_LC_uvchr(c)  _generic_LC_uvchr(isSPACE_LC,                     \
                                                    is_XPERLSPACE_cp_high, c)
#define isUPPER_LC_uvchr(c)  _generic_LC_swash_uvchr(isUPPER_LC, _CC_UPPER, c)
#define isWORDCHAR_LC_uvchr(c)  _generic_LC_swash_uvchr(isWORDCHAR_LC,              \
                                                           _CC_WORDCHAR, c)
#define isXDIGIT_LC_uvchr(c) _generic_LC_uvchr(isXDIGIT_LC, is_XDIGIT_cp_high, c)

#define isBLANK_LC_uni(c)	isBLANK_LC_uvchr(UNI_TO_NATIVE(c))

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_utf8.  These are like the earlier defined macros, but take an input
 * UTF-8 encoded string 'p'. If the input is in the Latin1 range, use
 * the Latin1 macro 'classnum' on 'p'.  Otherwise use the value given by the
 * 'utf8' parameter.  This relies on the fact that ASCII characters have the
 * same representation whether utf8 or not.  Note that it assumes that the utf8
 * has been validated, and ignores 'use bytes' */
#define _generic_utf8(classnum, p, utf8) (UTF8_IS_INVARIANT(*(p))              \
                                         ? _generic_isCC(*(p), classnum)       \
                                         : (UTF8_IS_DOWNGRADEABLE_START(*(p))) \
                                           ? _generic_isCC(                    \
                                                TWO_BYTE_UTF8_TO_NATIVE(*(p),  \
                                                                   *((p)+1 )), \
                                                classnum)                      \
                                           : utf8)
/* Like the above, but calls 'above_latin1(p)' to get the utf8 value.  'above_latin1'
 * can be a macro */
#define _generic_func_utf8(classnum, above_latin1, p)  \
                                    _generic_utf8(classnum, p, above_latin1(p))
/* Like the above, but passes classnum to _isFOO_utf8(), instead of having an
 * 'above_latin1' parameter */
#define _generic_swash_utf8(classnum, p)  \
                      _generic_utf8(classnum, p, _is_utf8_FOO(classnum, p))

/* Like the above, but should be used only when it is known that there are no
 * characters in the range 128-255 which the class is TRUE for.  Hence it can
 * skip the tests for this range.  'above_latin1' should include its arguments */
#define _generic_utf8_no_upper_latin1(classnum, p, above_latin1)               \
                                         (UTF8_IS_INVARIANT(*(p))              \
                                         ? _generic_isCC(*(p), classnum)       \
                                         : (UTF8_IS_ABOVE_LATIN1(*(p)))        \
                                           ? above_latin1                      \
                                           : 0)

/* NOTE that some of these macros have very similar ones in regcharclass.h.
 * For example, there is (at the time of this writing) an 'is_SPACE_utf8()'
 * there, differing in name only by an underscore from the one here
 * 'isSPACE_utf8().  The difference is that the ones here are probably more
 * efficient and smaller, using an O(1) array lookup for Latin1-range code
 * points; the regcharclass.h ones are implemented as a series of
 * "if-else-if-else ..." */

#define isALPHA_utf8(p)         _generic_swash_utf8(_CC_ALPHA, p)
#define isALPHANUMERIC_utf8(p)  _generic_swash_utf8(_CC_ALPHANUMERIC, p)
#define isASCII_utf8(p)         isASCII(*p) /* Because ASCII is invariant under
                                               utf8, the non-utf8 macro works
                                             */
#define isBLANK_utf8(p)         _generic_func_utf8(_CC_BLANK, is_HORIZWS_high, p)
#define isCNTRL_utf8(p)         _generic_utf8(_CC_CNTRL, p, 0)
#define isDIGIT_utf8(p)         _generic_utf8_no_upper_latin1(_CC_DIGIT, p,   \
                                                  _is_utf8_FOO(_CC_DIGIT, p))
#define isGRAPH_utf8(p)         _generic_swash_utf8(_CC_GRAPH, p)
#define isIDCONT_utf8(p)        _generic_func_utf8(_CC_WORDCHAR,              \
                                                  _is_utf8_perl_idcont, p)

/* To prevent S_scan_word in toke.c from hanging, we have to make sure that
 * IDFIRST is an alnum.  See
 * http://rt.perl.org/rt3/Ticket/Display.html?id=74022 for more detail than you
 * ever wanted to know about.  (In the ASCII range, there isn't a difference.)
 * This used to be not the XID version, but we decided to go with the more
 * modern Unicode definition */
#define isIDFIRST_utf8(p)       _generic_func_utf8(_CC_IDFIRST,               \
                                                _is_utf8_perl_idstart, p)

#define isLOWER_utf8(p)         _generic_swash_utf8(_CC_LOWER, p)
#define isPRINT_utf8(p)         _generic_swash_utf8(_CC_PRINT, p)

/* Posix and regular space are identical above Latin1 */
#define isPSXSPC_utf8(p)        _generic_func_utf8(_CC_PSXSPC, is_XPERLSPACE_high, p)

#define isPUNCT_utf8(p)         _generic_swash_utf8(_CC_PUNCT, p)
#define isSPACE_utf8(p)         _generic_func_utf8(_CC_SPACE, is_XPERLSPACE_high, p)
#define isUPPER_utf8(p)         _generic_swash_utf8(_CC_UPPER, p)
#define isVERTWS_utf8(p)        _generic_func_utf8(_CC_VERTSPACE, is_VERTWS_high, p)
#define isWORDCHAR_utf8(p)      _generic_swash_utf8(_CC_WORDCHAR, p)
#define isXDIGIT_utf8(p)        _generic_utf8_no_upper_latin1(_CC_XDIGIT, p,   \
                                                          is_XDIGIT_high(p))

#define toFOLD_utf8(p,s,l)	to_utf8_fold(p,s,l)
#define toLOWER_utf8(p,s,l)	to_utf8_lower(p,s,l)
#define toTITLE_utf8(p,s,l)	to_utf8_title(p,s,l)
#define toUPPER_utf8(p,s,l)	to_utf8_upper(p,s,l)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_LC_utf8.  These are like _generic_utf8, but if the first code point
 * in 'p' is within the 0-255 range, it uses locale rules from the passed-in
 * 'macro' parameter */
#define _generic_LC_utf8(macro, p, utf8)                                    \
                         (UTF8_IS_INVARIANT(*(p))                           \
                         ? macro(*(p))                                      \
                         : (UTF8_IS_DOWNGRADEABLE_START(*(p)))              \
                           ? macro(TWO_BYTE_UTF8_TO_NATIVE(*(p), *((p)+1))) \
                           : utf8)

#define _generic_LC_swash_utf8(macro, classnum, p)                         \
                    _generic_LC_utf8(macro, p, _is_utf8_FOO(classnum, p))
#define _generic_LC_func_utf8(macro, above_latin1, p)                         \
                              _generic_LC_utf8(macro, p, above_latin1(p))

#define isALPHANUMERIC_LC_utf8(p)  _generic_LC_swash_utf8(isALPHANUMERIC_LC,  \
                                                      _CC_ALPHANUMERIC, p)
#define isALPHA_LC_utf8(p)   _generic_LC_swash_utf8(isALPHA_LC, _CC_ALPHA, p)
#define isASCII_LC_utf8(p)   isASCII_LC(*p)
#define isBLANK_LC_utf8(p)   _generic_LC_func_utf8(isBLANK_LC, is_HORIZWS_high, p)
#define isCNTRL_LC_utf8(p)   _generic_LC_utf8(isCNTRL_LC, p, 0)
#define isDIGIT_LC_utf8(p)   _generic_LC_swash_utf8(isDIGIT_LC, _CC_DIGIT, p)
#define isGRAPH_LC_utf8(p)   _generic_LC_swash_utf8(isGRAPH_LC, _CC_GRAPH, p)
#define isIDCONT_LC_utf8(p) _generic_LC_func_utf8(isIDCONT_LC, _is_utf8_perl_idcont, p)
#define isIDFIRST_LC_utf8(p) _generic_LC_func_utf8(isIDFIRST_LC, _is_utf8_perl_idstart, p)
#define isLOWER_LC_utf8(p)   _generic_LC_swash_utf8(isLOWER_LC, _CC_LOWER, p)
#define isPRINT_LC_utf8(p)   _generic_LC_swash_utf8(isPRINT_LC, _CC_PRINT, p)
#define isPSXSPC_LC_utf8(p)  isSPACE_LC_utf8(p) /* space is identical to posix
                                                   space under locale */
#define isPUNCT_LC_utf8(p)   _generic_LC_swash_utf8(isPUNCT_LC, _CC_PUNCT, p)
#define isSPACE_LC_utf8(p)   _generic_LC_func_utf8(isSPACE_LC, is_XPERLSPACE_high, p)
#define isUPPER_LC_utf8(p)   _generic_LC_swash_utf8(isUPPER_LC, _CC_UPPER, p)
#define isWORDCHAR_LC_utf8(p) _generic_LC_swash_utf8(isWORDCHAR_LC,           \
                                                            _CC_WORDCHAR, p)
#define isXDIGIT_LC_utf8(p)  _generic_LC_func_utf8(isXDIGIT_LC, is_XDIGIT_high, p)

/* Macros for backwards compatibility and for completeness when the ASCII and
 * Latin1 values are identical */
#define isALPHAU(c)     isALPHA_L1(c)
#define isDIGIT_L1(c)   isDIGIT_A(c)
#define isOCTAL(c)      isOCTAL_A(c)
#define isOCTAL_L1(c)   isOCTAL_A(c)
#define isXDIGIT_L1(c)  isXDIGIT_A(c)
#define isALNUM(c)      isWORDCHAR(c)
#define isALNUMU(c)     isWORDCHAR_L1(c)
#define isALNUM_LC(c)   isWORDCHAR_LC(c)
#define isALNUM_uni(c)  isWORDCHAR_uni(c)
#define isALNUM_LC_uvchr(c) isWORDCHAR_LC_uvchr(c)
#define isALNUM_utf8(p) isWORDCHAR_utf8(p)
#define isALNUM_LC_utf8(p) isWORDCHAR_LC_utf8(p)
#define isALNUMC_A(c)   isALPHANUMERIC_A(c)      /* Mnemonic: "C's alnum" */
#define isALNUMC_L1(c)  isALPHANUMERIC_L1(c)
#define isALNUMC(c)	isALPHANUMERIC(c)
#define isALNUMC_LC(c)	isALPHANUMERIC_LC(c)
#define isALNUMC_uni(c) isALPHANUMERIC_uni(c)
#define isALNUMC_LC_uvchr(c) isALPHANUMERIC_LC_uvchr(c)
#define isALNUMC_utf8(p) isALPHANUMERIC_utf8(p)
#define isALNUMC_LC_utf8(p) isALPHANUMERIC_LC_utf8(p)

/* On EBCDIC platforms, CTRL-@ is 0, CTRL-A is 1, etc, just like on ASCII,
 * except that they don't necessarily mean the same characters, e.g. CTRL-D is
 * 4 on both systems, but that is EOT on ASCII;  ST on EBCDIC.
 * '?' is special-cased on EBCDIC to APC, which is the control there that is
 * the outlier from the block that contains the other controls, just like
 * toCTRL('?') on ASCII yields DEL, the control that is the outlier from the C0
 * block.  If it weren't special cased, it would yield a non-control.
 * The conversion works both ways, so CTRL('D') is 4, and CTRL(4) is D, etc. */
#ifndef EBCDIC
#  define toCTRL(c)    (toUPPER(c) ^ 64)
#else
#  define toCTRL(c)    ((c) == '?'                               \
                        ? LATIN1_TO_NATIVE(0x9F)                 \
                        : (c) == LATIN1_TO_NATIVE(0x9F)          \
                          ? '?'                                  \
                          : (NATIVE_TO_LATIN1(toUPPER(c)) ^ 64))
#endif

/* Line numbers are unsigned, 32 bits. */
typedef U32 line_t;
#define NOLINE ((line_t) 4294967295UL)  /* = FFFFFFFF */

/* Helpful alias for version prescan */
#define is_LAX_VERSION(a,b) \
	(a != Perl_prescan_version(aTHX_ a, FALSE, b, NULL, NULL, NULL, NULL))

#define is_STRICT_VERSION(a,b) \
	(a != Perl_prescan_version(aTHX_ a, TRUE, b, NULL, NULL, NULL, NULL))

#define BADVERSION(a,b,c) \
	if (b) { \
	    *b = c; \
	} \
	return a;

/* Converts a character known to represent a hexadecimal digit (0-9, A-F, or
 * a-f) to its numeric value.  READ_XDIGIT's argument is a string pointer,
 * which is advanced.  The input is validated only by an assert() in DEBUGGING
 * builds.  In both ASCII and EBCDIC the last 4 bits of the digits are 0-9; and
 * the last 4 bits of A-F and a-f are 1-6, so adding 9 yields 10-15 */
#define XDIGIT_VALUE(c) (__ASSERT_(isXDIGIT(c)) (0xf & (isDIGIT(c)        \
                                                        ? (c)             \
                                                        : ((c) + 9))))
#define READ_XDIGIT(s)  (__ASSERT_(isXDIGIT(*s)) (0xf & (isDIGIT(*(s))     \
                                                        ? (*(s)++)         \
                                                        : (*(s)++ + 9))))

/* Converts a character known to represent an octal digit (0-7) to its numeric
 * value.  The input is validated only by an assert() in DEBUGGING builds.  In
 * both ASCII and EBCDIC the last 3 bits of the octal digits range from 0-7. */
#define OCTAL_VALUE(c) (__ASSERT_(isOCTAL(c)) (7 & (c)))

/*
=head1 Memory Management

=for apidoc Am|void|Newx|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<malloc> function.

Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

In 5.9.3, Newx() and friends replace the older New() API, and drops
the first parameter, I<x>, a debug aid which allowed callers to identify
themselves.  This aid has been superseded by a new build option,
PERL_MEM_LOG (see L<perlhacktips/PERL_MEM_LOG>).  The older API is still
there for use in XS modules supporting older perls.

=for apidoc Am|void|Newxc|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<malloc> function, with
cast.  See also C<Newx>.

Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

=for apidoc Am|void|Newxz|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<malloc> function.  The allocated
memory is zeroed with C<memzero>.  See also C<Newx>.

Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

=for apidoc Am|void|Renew|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<realloc> function.

Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

=for apidoc Am|void|Renewc|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<realloc> function, with
cast.

Memory obtained by this should B<ONLY> be freed with L<"Safefree">.

=for apidoc Am|void|Safefree|void* ptr
The XSUB-writer's interface to the C C<free> function.

This should B<ONLY> be used on memory obtained using L<"Newx"> and friends.

=for apidoc Am|void|Move|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memmove> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and
C<type> is the type.  Can do overlapping moves.  See also C<Copy>.

=for apidoc Am|void *|MoveD|void* src|void* dest|int nitems|type
Like C<Move> but returns dest.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc Am|void|Copy|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memcpy> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and
C<type> is the type.  May fail on overlapping copies.  See also C<Move>.

=for apidoc Am|void *|CopyD|void* src|void* dest|int nitems|type

Like C<Copy> but returns dest.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc Am|void|Zero|void* dest|int nitems|type

The XSUB-writer's interface to the C C<memzero> function.  The C<dest> is the
destination, C<nitems> is the number of items, and C<type> is the type.

=for apidoc Am|void *|ZeroD|void* dest|int nitems|type

Like C<Zero> but returns dest.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc Am|void|StructCopy|type *src|type *dest|type
This is an architecture-independent macro to copy one structure to another.

=for apidoc Am|void|PoisonWith|void* dest|int nitems|type|U8 byte

Fill up memory with a byte pattern (a byte repeated over and over
again) that hopefully catches attempts to access uninitialized memory.

=for apidoc Am|void|PoisonNew|void* dest|int nitems|type

PoisonWith(0xAB) for catching access to allocated but uninitialized memory.

=for apidoc Am|void|PoisonFree|void* dest|int nitems|type

PoisonWith(0xEF) for catching access to freed memory.

=for apidoc Am|void|Poison|void* dest|int nitems|type

PoisonWith(0xEF) for catching access to freed memory.

=cut */

/* Maintained for backwards-compatibility only. Use newSV() instead. */
#ifndef PERL_CORE
#define NEWSV(x,len)	newSV(len)
#endif

#define MEM_SIZE_MAX ((MEM_SIZE)~0)

/* The +0.0 in MEM_WRAP_CHECK_ is an attempt to foil
 * overly eager compilers that will bleat about e.g.
 * (U16)n > (size_t)~0/sizeof(U16) always being false. */
#ifdef PERL_MALLOC_WRAP
#define MEM_WRAP_CHECK(n,t) \
	(void)(UNLIKELY(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t)) && (croak_memory_wrap(),0))
#define MEM_WRAP_CHECK_1(n,t,a) \
	(void)(UNLIKELY(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t)) && (Perl_croak_nocontext("%s",(a)),0))
#define MEM_WRAP_CHECK_(n,t) MEM_WRAP_CHECK(n,t),

#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > MEM_SIZE_MAX - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ? (croak_memory_wrap(),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))
#else

#define MEM_WRAP_CHECK(n,t)
#define MEM_WRAP_CHECK_1(n,t,a)
#define MEM_WRAP_CHECK_2(n,t,a,b)
#define MEM_WRAP_CHECK_(n,t)

#define PERL_STRLEN_ROUNDUP(n) (((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))

#endif

#ifdef PERL_MEM_LOG
/*
 * If PERL_MEM_LOG is defined, all Newx()s, Renew()s, and Safefree()s
 * go through functions, which are handy for debugging breakpoints, but
 * which more importantly get the immediate calling environment (file and
 * line number, and C function name if available) passed in.  This info can
 * then be used for logging the calls, for which one gets a sample
 * implementation unless -DPERL_MEM_LOG_NOIMPL is also defined.
 *
 * Known problems:
 * - not all memory allocs get logged, only those
 *   that go through Newx() and derivatives (while all
 *   Safefrees do get logged)
 * - __FILE__ and __LINE__ do not work everywhere
 * - __func__ or __FUNCTION__ even less so
 * - I think more goes on after the perlio frees but
 *   the thing is that STDERR gets closed (as do all
 *   the file descriptors)
 * - no deeper calling stack than the caller of the Newx()
 *   or the kind, but do I look like a C reflection/introspection
 *   utility to you?
 * - the function prototypes for the logging functions
 *   probably should maybe be somewhere else than handy.h
 * - one could consider inlining (macrofying) the logging
 *   for speed, but I am too lazy
 * - one could imagine recording the allocations in a hash,
 *   (keyed by the allocation address?), and maintain that
 *   through reallocs and frees, but how to do that without
 *   any News() happening...?
 * - lots of -Ddefines to get useful/controllable output
 * - lots of ENV reads
 */

PERL_EXPORT_C Malloc_t Perl_mem_log_alloc(const UV n, const UV typesize, const char *type_name, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);

PERL_EXPORT_C Malloc_t Perl_mem_log_realloc(const UV n, const UV typesize, const char *type_name, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);

PERL_EXPORT_C Malloc_t Perl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname);

# ifdef PERL_CORE
#  ifndef PERL_MEM_LOG_NOIMPL
enum mem_log_type {
  MLT_ALLOC,
  MLT_REALLOC,
  MLT_FREE,
  MLT_NEW_SV,
  MLT_DEL_SV
};
#  endif
#  if defined(PERL_IN_SV_C)  /* those are only used in sv.c */
void Perl_mem_log_new_sv(const SV *sv, const char *filename, const int linenumber, const char *funcname);
void Perl_mem_log_del_sv(const SV *sv, const char *filename, const int linenumber, const char *funcname);
#  endif
# endif

#endif

#ifdef PERL_MEM_LOG
#define MEM_LOG_ALLOC(n,t,a)     Perl_mem_log_alloc(n,sizeof(t),STRINGIFY(t),a,__FILE__,__LINE__,FUNCTION__)
#define MEM_LOG_REALLOC(n,t,v,a) Perl_mem_log_realloc(n,sizeof(t),STRINGIFY(t),v,a,__FILE__,__LINE__,FUNCTION__)
#define MEM_LOG_FREE(a)          Perl_mem_log_free(a,__FILE__,__LINE__,FUNCTION__)
#endif

#ifndef MEM_LOG_ALLOC
#define MEM_LOG_ALLOC(n,t,a)     (a)
#endif
#ifndef MEM_LOG_REALLOC
#define MEM_LOG_REALLOC(n,t,v,a) (a)
#endif
#ifndef MEM_LOG_FREE
#define MEM_LOG_FREE(a)          (a)
#endif

#define Newx(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_ALLOC(n,t,safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxc(v,n,t,c)	(v = (MEM_WRAP_CHECK_(n,t) (c*)MEM_LOG_ALLOC(n,t,safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxz(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_ALLOC(n,t,safecalloc((n),sizeof(t)))))

#ifndef PERL_CORE
/* pre 5.9.x compatibility */
#define New(x,v,n,t)	Newx(v,n,t)
#define Newc(x,v,n,t,c)	Newxc(v,n,t,c)
#define Newz(x,v,n,t)	Newxz(v,n,t)
#endif

#define Renew(v,n,t) \
	  (v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_REALLOC(n,t,v,saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))
#define Renewc(v,n,t,c) \
	  (v = (MEM_WRAP_CHECK_(n,t) (c*)MEM_LOG_REALLOC(n,t,v,saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))

#ifdef PERL_POISON
#define Safefree(d) \
  ((d) ? (void)(safefree(MEM_LOG_FREE((Malloc_t)(d))), Poison(&(d), 1, Malloc_t)) : (void) 0)
#else
#define Safefree(d)	safefree(MEM_LOG_FREE((Malloc_t)(d)))
#endif

#define Move(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memmove((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define Copy(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memcpy((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define Zero(d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memzero((char*)(d), (n) * sizeof(t)))

#define MoveD(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) memmove((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define CopyD(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) memcpy((char*)(d),(const char*)(s), (n) * sizeof(t)))
#ifdef HAS_MEMSET
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK_(n,t) memzero((char*)(d), (n) * sizeof(t)))
#else
/* Using bzero(), which returns void.  */
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK_(n,t) memzero((char*)(d), (n) * sizeof(t)),d)
#endif

#define PoisonWith(d,n,t,b)	(MEM_WRAP_CHECK_(n,t) (void)memset((char*)(d), (U8)(b), (n) * sizeof(t)))
#define PoisonNew(d,n,t)	PoisonWith(d,n,t,0xAB)
#define PoisonFree(d,n,t)	PoisonWith(d,n,t,0xEF)
#define Poison(d,n,t)		PoisonFree(d,n,t)

#ifdef PERL_POISON
#  define PERL_POISON_EXPR(x) x
#else
#  define PERL_POISON_EXPR(x)
#endif

#ifdef USE_STRUCT_COPY
#define StructCopy(s,d,t) (*((t*)(d)) = *((t*)(s)))
#else
#define StructCopy(s,d,t) Copy(s,d,1,t)
#endif

/* C_ARRAY_LENGTH is the number of elements in the C array (so you
 * want your zero-based indices to be less than but not equal to).
 *
 * C_ARRAY_END is one past the last: half-open/half-closed range,
 * not last-inclusive range. */
#define C_ARRAY_LENGTH(a)	(sizeof(a)/sizeof((a)[0]))
#define C_ARRAY_END(a)		((a) + C_ARRAY_LENGTH(a))

#ifdef NEED_VA_COPY
# ifdef va_copy
#  define Perl_va_copy(s, d) va_copy(d, s)
# else
#  if defined(__va_copy)
#   define Perl_va_copy(s, d) __va_copy(d, s)
#  else
#   define Perl_va_copy(s, d) Copy(s, d, 1, va_list)
#  endif
# endif
#endif

/* convenience debug macros */
#ifdef USE_ITHREADS
#define pTHX_FORMAT  "Perl interpreter: 0x%p"
#define pTHX__FORMAT ", Perl interpreter: 0x%p"
#define pTHX_VALUE_   (void *)my_perl,
#define pTHX_VALUE    (void *)my_perl
#define pTHX__VALUE_ ,(void *)my_perl,
#define pTHX__VALUE  ,(void *)my_perl
#else
#define pTHX_FORMAT
#define pTHX__FORMAT
#define pTHX_VALUE_
#define pTHX_VALUE
#define pTHX__VALUE_
#define pTHX__VALUE
#endif /* USE_ITHREADS */

/* Perl_deprecate was not part of the public API, and did not have a deprecate()
   shortcut macro defined without -DPERL_CORE. Neither codesearch.google.com nor
   CPAN::Unpack show any users outside the core.  */
#ifdef PERL_CORE
#  define deprecate(s) Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED), "Use of " s " is deprecated")
#endif

/* Internal macros to deal with gids and uids */
#ifdef PERL_CORE

#  if Uid_t_size > IVSIZE
#    define sv_setuid(sv, uid)       sv_setnv((sv), (NV)(uid))
#    define SvUID(sv)                SvNV(sv)
#  else
#    if Uid_t_sign <= 0
#      define sv_setuid(sv, uid)       sv_setiv((sv), (IV)(uid))
#      define SvUID(sv)                SvIV(sv)
#    else
#      define sv_setuid(sv, uid)       sv_setuv((sv), (UV)(uid))
#      define SvUID(sv)                SvUV(sv)
#    endif
#  endif /* Uid_t_size */

#  if Gid_t_size > IVSIZE
#    define sv_setgid(sv, gid)       sv_setnv((sv), (NV)(gid))
#    define SvGID(sv)                SvNV(sv)
#  else
#    if Gid_t_sign <= 0
#      define sv_setgid(sv, gid)       sv_setiv((sv), (IV)(gid))
#      define SvGID(sv)                SvIV(sv)
#    else
#      define sv_setgid(sv, gid)       sv_setuv((sv), (UV)(gid))
#      define SvGID(sv)                SvUV(sv)
#    endif
#  endif /* Gid_t_size */

#endif

#endif  /* HANDY_H */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                     usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/hv.h                                                      0100644 0000000 0000000 00000057632 12744441327 016537  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    hv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* These control hash traversal randomization and the environment variable PERL_PERTURB_KEYS.
 * Currently disabling this functionality will break a few tests, but should otherwise work fine.
 * See perlrun for more details. */

#if defined(PERL_PERTURB_KEYS_DISABLED)
#   define PL_HASH_RAND_BITS_ENABLED        0
#   define PERL_HASH_ITER_BUCKET(iter)      ((iter)->xhv_riter)
#else
#   define PERL_HASH_RANDOMIZE_KEYS         1
#   if defined(PERL_PERTURB_KEYS_RANDOM)
#       define PL_HASH_RAND_BITS_ENABLED    1
#   elif defined(PERL_PERTURB_KEYS_DETERMINISTIC)
#       define PL_HASH_RAND_BITS_ENABLED    2
#   else
#       define USE_PERL_PERTURB_KEYS        1
#       define PL_HASH_RAND_BITS_ENABLED    PL_hash_rand_bits_enabled
#   endif
#   define PERL_HASH_ITER_BUCKET(iter)      (((iter)->xhv_riter) ^ ((iter)->xhv_rand))
#endif

/* entry in hash value chain */
struct he {
    /* Keep hent_next first in this structure, because sv_free_arenas take
       advantage of this to share code between the he arenas and the SV
       body arenas  */
    HE		*hent_next;	/* next entry in chain */
    HEK		*hent_hek;	/* hash key */
    union {
	SV	*hent_val;	/* scalar value that was hashed */
	Size_t	hent_refcount;	/* references for this shared hash key */
    } he_valu;
};

/* hash key -- defined separately for use as shared pointer */
struct hek {
    U32		hek_hash;	/* hash of key */
    I32		hek_len;	/* length of hash key */
    char	hek_key[1];	/* variable-length hash key */
    /* the hash-key is \0-terminated */
    /* after the \0 there is a byte for flags, such as whether the key
       is UTF-8 */
};

struct shared_he {
    struct he shared_he_he;
    struct hek shared_he_hek;
};

/* Subject to change.
   Don't access this directly.
   Use the funcs in mro.c
*/

struct mro_alg {
    AV *(*resolve)(pTHX_ HV* stash, U32 level);
    const char *name;
    U16 length;
    U16	kflags;	/* For the hash API - set HVhek_UTF8 if name is UTF-8 */
    U32 hash; /* or 0 */
};

struct mro_meta {
    /* a hash holding the different MROs private data.  */
    HV      *mro_linear_all;
    /* a pointer directly to the current MROs private data.  If mro_linear_all
       is NULL, this owns the SV reference, else it is just a pointer to a
       value stored in and owned by mro_linear_all.  */
    SV      *mro_linear_current;
    HV      *mro_nextmethod; /* next::method caching */
    U32     cache_gen;       /* Bumping this invalidates our method cache */
    U32     pkg_gen;         /* Bumps when local methods/@ISA change */
    const struct mro_alg *mro_which; /* which mro alg is in use? */
    HV      *isa;            /* Everything this class @ISA */
    HV      *super;          /* SUPER method cache */
    U32     destroy_gen;     /* Generation number of DESTROY cache */
};

#define MRO_GET_PRIVATE_DATA(smeta, which)		   \
    (((smeta)->mro_which && (which) == (smeta)->mro_which) \
     ? (smeta)->mro_linear_current			   \
     : Perl_mro_get_private_data(aTHX_ (smeta), (which)))

/* Subject to change.
   Don't access this directly.
*/

union _xhvnameu {
    HEK *xhvnameu_name;		/* When xhv_name_count is 0 */
    HEK **xhvnameu_names;	/* When xhv_name_count is non-0 */
};

struct xpvhv_aux {
    union _xhvnameu xhv_name_u;	/* name, if a symbol table */
    AV		*xhv_backreferences; /* back references for weak references */
    HE		*xhv_eiter;	/* current entry of iterator */
    I32		xhv_riter;	/* current root of iterator */

/* Concerning xhv_name_count: When non-zero, xhv_name_u contains a pointer 
 * to an array of HEK pointers, this being the length. The first element is
 * the name of the stash, which may be NULL. If xhv_name_count is positive,
 * then *xhv_name is one of the effective names. If xhv_name_count is nega-
 * tive, then xhv_name_u.xhvnameu_names[1] is the first effective name.
 */
    I32		xhv_name_count;
    struct mro_meta *xhv_mro_meta;
#ifdef PERL_HASH_RANDOMIZE_KEYS
    U32         xhv_rand;       /* random value for hash traversal */
    U32         xhv_last_rand;  /* last random value for hash traversal,
                                   used to detect each() after insert for warnings */
#endif
    U32         xhv_fill_lazy;
    U32         xhv_aux_flags;      /* assorted extra flags */
};

#define HvAUXf_SCAN_STASH   0x1   /* stash is being scanned by gv_check */
#define HvAUXf_NO_DEREF     0x2   /* @{}, %{} etc (and nomethod) not present */

/* hash structure: */
/* This structure must match the beginning of struct xpvmg in sv.h. */
struct xpvhv {
    HV*		xmg_stash;	/* class package */
    union _xmgu	xmg_u;
    STRLEN      xhv_keys;       /* total keys, including placeholders */
    STRLEN      xhv_max;        /* subscript of last element of xhv_array */
};

/*
=head1 Hash Manipulation Functions

=for apidoc AmU||HEf_SVKEY
This flag, used in the length slot of hash entries and magic structures,
specifies the structure contains an C<SV*> pointer where a C<char*> pointer
is to be expected.  (For information only--not to be used).

=head1 Handy Values

=for apidoc AmU||Nullhv
Null HV pointer.

(deprecated - use C<(HV *)NULL> instead)

=head1 Hash Manipulation Functions

=for apidoc Am|char*|HvNAME|HV* stash
Returns the package name of a stash, or NULL if C<stash> isn't a stash.
See C<SvSTASH>, C<CvSTASH>.

=for apidoc Am|STRLEN|HvNAMELEN|HV *stash
Returns the length of the stash's name.

=for apidoc Am|unsigned char|HvNAMEUTF8|HV *stash
Returns true if the name is in UTF8 encoding.

=for apidoc Am|char*|HvENAME|HV* stash
Returns the effective name of a stash, or NULL if there is none.  The
effective name represents a location in the symbol table where this stash
resides.  It is updated automatically when packages are aliased or deleted.
A stash that is no longer in the symbol table has no effective name.  This
name is preferable to C<HvNAME> for use in MRO linearisations and isa
caches.

=for apidoc Am|STRLEN|HvENAMELEN|HV *stash
Returns the length of the stash's effective name.

=for apidoc Am|unsigned char|HvENAMEUTF8|HV *stash
Returns true if the effective name is in UTF8 encoding.

=for apidoc Am|void*|HeKEY|HE* he
Returns the actual pointer stored in the key slot of the hash entry.  The
pointer may be either C<char*> or C<SV*>, depending on the value of
C<HeKLEN()>.  Can be assigned to.  The C<HePV()> or C<HeSVKEY()> macros are
usually preferable for finding the value of a key.

=for apidoc Am|STRLEN|HeKLEN|HE* he
If this is negative, and amounts to C<HEf_SVKEY>, it indicates the entry
holds an C<SV*> key.  Otherwise, holds the actual length of the key.  Can
be assigned to.  The C<HePV()> macro is usually preferable for finding key
lengths.

=for apidoc Am|SV*|HeVAL|HE* he
Returns the value slot (type C<SV*>)
stored in the hash entry.  Can be assigned
to.

  SV *foo= HeVAL(hv);
  HeVAL(hv)= sv;


=for apidoc Am|U32|HeHASH|HE* he
Returns the computed hash stored in the hash entry.

=for apidoc Am|char*|HePV|HE* he|STRLEN len
Returns the key slot of the hash entry as a C<char*> value, doing any
necessary dereferencing of possibly C<SV*> keys.  The length of the string
is placed in C<len> (this is a macro, so do I<not> use C<&len>).  If you do
not care about what the length of the key is, you may use the global
variable C<PL_na>, though this is rather less efficient than using a local
variable.  Remember though, that hash keys in perl are free to contain
embedded nulls, so using C<strlen()> or similar is not a good way to find
the length of hash keys.  This is very similar to the C<SvPV()> macro
described elsewhere in this document.  See also C<HeUTF8>.

If you are using C<HePV> to get values to pass to C<newSVpvn()> to create a
new SV, you should consider using C<newSVhek(HeKEY_hek(he))> as it is more
efficient.

=for apidoc Am|U32|HeUTF8|HE* he
Returns whether the C<char *> value returned by C<HePV> is encoded in UTF-8,
doing any necessary dereferencing of possibly C<SV*> keys.  The value returned
will be 0 or non-0, not necessarily 1 (or even a value with any low bits set),
so B<do not> blindly assign this to a C<bool> variable, as C<bool> may be a
typedef for C<char>.

=for apidoc Am|SV*|HeSVKEY|HE* he
Returns the key as an C<SV*>, or C<NULL> if the hash entry does not
contain an C<SV*> key.

=for apidoc Am|SV*|HeSVKEY_force|HE* he
Returns the key as an C<SV*>.  Will create and return a temporary mortal
C<SV*> if the hash entry contains only a C<char*> key.

=for apidoc Am|SV*|HeSVKEY_set|HE* he|SV* sv
Sets the key to a given C<SV*>, taking care to set the appropriate flags to
indicate the presence of an C<SV*> key, and returns the same
C<SV*>.

=cut
*/

#define PERL_HASH_DEFAULT_HvMAX 7

/* During hsplit(), if HvMAX(hv)+1 (the new bucket count) is >= this value,
 * we preallocate the HvAUX() struct.
 * The assumption being that we are using so much space anyway we might
 * as well allocate the extra bytes and speed up later keys()
 * or each() operations. We don't do this to small hashes as we assume
 * that a) it will be easy/fast to resize them to add the iterator, and b) that
 * many of them will be objects which won't be traversed. Larger hashes however
 * will take longer to extend, and the size of the aux struct is swamped by the
 * overall length of the bucket array.
 * */
#define PERL_HV_ALLOC_AUX_SIZE (1 << 9)

/* these hash entry flags ride on hent_klen (for use only in magic/tied HVs) */
#define HEf_SVKEY	-2	/* hent_key is an SV* */

#ifndef PERL_CORE
#  define Nullhv Null(HV*)
#endif
#define HvARRAY(hv)	((hv)->sv_u.svu_hash)
#define HvFILL(hv)	Perl_hv_fill(aTHX_ MUTABLE_HV(hv))
#define HvMAX(hv)	((XPVHV*)  SvANY(hv))->xhv_max
/* This quite intentionally does no flag checking first. That's your
   responsibility.  */
#define HvAUX(hv)	((struct xpvhv_aux*)&(HvARRAY(hv)[HvMAX(hv)+1]))
#define HvRITER(hv)	(*Perl_hv_riter_p(aTHX_ MUTABLE_HV(hv)))
#define HvEITER(hv)	(*Perl_hv_eiter_p(aTHX_ MUTABLE_HV(hv)))
#define HvRITER_set(hv,r)	Perl_hv_riter_set(aTHX_ MUTABLE_HV(hv), r)
#define HvEITER_set(hv,e)	Perl_hv_eiter_set(aTHX_ MUTABLE_HV(hv), e)
#define HvRITER_get(hv)	(SvOOK(hv) ? HvAUX(hv)->xhv_riter : -1)
#define HvEITER_get(hv)	(SvOOK(hv) ? HvAUX(hv)->xhv_eiter : NULL)
#define HvRAND_get(hv)	(SvOOK(hv) ? HvAUX(hv)->xhv_rand : 0)
#define HvLASTRAND_get(hv)	(SvOOK(hv) ? HvAUX(hv)->xhv_last_rand : 0)

#define HvNAME(hv)	HvNAME_get(hv)
#define HvNAMELEN(hv)   HvNAMELEN_get(hv)
#define HvENAME(hv)	HvENAME_get(hv)
#define HvENAMELEN(hv)  HvENAMELEN_get(hv)

/* Checking that hv is a valid package stash is the
   caller's responsibility */
#define HvMROMETA(hv) (HvAUX(hv)->xhv_mro_meta \
                       ? HvAUX(hv)->xhv_mro_meta \
                       : Perl_mro_meta_init(aTHX_ hv))

#define HvNAME_HEK_NN(hv)			  \
 (						  \
  HvAUX(hv)->xhv_name_count			  \
  ? *HvAUX(hv)->xhv_name_u.xhvnameu_names	  \
  : HvAUX(hv)->xhv_name_u.xhvnameu_name		  \
 )
/* This macro may go away without notice.  */
#define HvNAME_HEK(hv) \
	(SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name ? HvNAME_HEK_NN(hv) : NULL)
#define HvNAME_get(hv) \
	((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvNAME_HEK_NN(hv)) \
			 ? HEK_KEY(HvNAME_HEK_NN(hv)) : NULL)
#define HvNAMELEN_get(hv) \
	((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvNAME_HEK_NN(hv)) \
				 ? HEK_LEN(HvNAME_HEK_NN(hv)) : 0)
#define HvNAMEUTF8(hv) \
	((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvNAME_HEK_NN(hv)) \
				 ? HEK_UTF8(HvNAME_HEK_NN(hv)) : 0)
#define HvENAME_HEK_NN(hv)                                             \
 (                                                                      \
  HvAUX(hv)->xhv_name_count > 0   ? HvAUX(hv)->xhv_name_u.xhvnameu_names[0] : \
  HvAUX(hv)->xhv_name_count < -1  ? HvAUX(hv)->xhv_name_u.xhvnameu_names[1] : \
  HvAUX(hv)->xhv_name_count == -1 ? NULL                              : \
                                    HvAUX(hv)->xhv_name_u.xhvnameu_name \
 )
#define HvENAME_HEK(hv) \
	(SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name ? HvENAME_HEK_NN(hv) : NULL)
#define HvENAME_get(hv) \
   ((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvAUX(hv)->xhv_name_count != -1) \
			 ? HEK_KEY(HvENAME_HEK_NN(hv)) : NULL)
#define HvENAMELEN_get(hv) \
   ((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvAUX(hv)->xhv_name_count != -1) \
				 ? HEK_LEN(HvENAME_HEK_NN(hv)) : 0)
#define HvENAMEUTF8(hv) \
   ((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvAUX(hv)->xhv_name_count != -1) \
				 ? HEK_UTF8(HvENAME_HEK_NN(hv)) : 0)

/* the number of keys (including any placeholders) */
#define XHvTOTALKEYS(xhv)	((xhv)->xhv_keys)

/*
 * HvKEYS gets the number of keys that actually exist(), and is provided
 * for backwards compatibility with old XS code. The core uses HvUSEDKEYS
 * (keys, excluding placeholders) and HvTOTALKEYS (including placeholders)
 */
#define HvKEYS(hv)		HvUSEDKEYS(hv)
#define HvUSEDKEYS(hv)		(HvTOTALKEYS(hv) - HvPLACEHOLDERS_get(hv))
#define HvTOTALKEYS(hv)		XHvTOTALKEYS((XPVHV*)  SvANY(hv))
#define HvPLACEHOLDERS(hv)	(*Perl_hv_placeholders_p(aTHX_ MUTABLE_HV(hv)))
#define HvPLACEHOLDERS_get(hv)	(SvMAGIC(hv) ? Perl_hv_placeholders_get(aTHX_ (const HV *)hv) : 0)
#define HvPLACEHOLDERS_set(hv,p)	Perl_hv_placeholders_set(aTHX_ MUTABLE_HV(hv), p)

#define HvSHAREKEYS(hv)		(SvFLAGS(hv) & SVphv_SHAREKEYS)
#define HvSHAREKEYS_on(hv)	(SvFLAGS(hv) |= SVphv_SHAREKEYS)
#define HvSHAREKEYS_off(hv)	(SvFLAGS(hv) &= ~SVphv_SHAREKEYS)

/* This is an optimisation flag. It won't be set if all hash keys have a 0
 * flag. Currently the only flags relate to utf8.
 * Hence it won't be set if all keys are 8 bit only. It will be set if any key
 * is utf8 (including 8 bit keys that were entered as utf8, and need upgrading
 * when retrieved during iteration. It may still be set when there are no longer
 * any utf8 keys.
 * See HVhek_ENABLEHVKFLAGS for the trigger.
 */
#define HvHASKFLAGS(hv)		(SvFLAGS(hv) & SVphv_HASKFLAGS)
#define HvHASKFLAGS_on(hv)	(SvFLAGS(hv) |= SVphv_HASKFLAGS)
#define HvHASKFLAGS_off(hv)	(SvFLAGS(hv) &= ~SVphv_HASKFLAGS)

#define HvLAZYDEL(hv)		(SvFLAGS(hv) & SVphv_LAZYDEL)
#define HvLAZYDEL_on(hv)	(SvFLAGS(hv) |= SVphv_LAZYDEL)
#define HvLAZYDEL_off(hv)	(SvFLAGS(hv) &= ~SVphv_LAZYDEL)

#ifndef PERL_CORE
#  define Nullhe Null(HE*)
#endif
#define HeNEXT(he)		(he)->hent_next
#define HeKEY_hek(he)		(he)->hent_hek
#define HeKEY(he)		HEK_KEY(HeKEY_hek(he))
#define HeKEY_sv(he)		(*(SV**)HeKEY(he))
#define HeKLEN(he)		HEK_LEN(HeKEY_hek(he))
#define HeKUTF8(he)  HEK_UTF8(HeKEY_hek(he))
#define HeKWASUTF8(he)  HEK_WASUTF8(HeKEY_hek(he))
#define HeKLEN_UTF8(he)  (HeKUTF8(he) ? -HeKLEN(he) : HeKLEN(he))
#define HeKFLAGS(he)  HEK_FLAGS(HeKEY_hek(he))
#define HeVAL(he)		(he)->he_valu.hent_val
#define HeHASH(he)		HEK_HASH(HeKEY_hek(he))
#define HePV(he,lp)		((HeKLEN(he) == HEf_SVKEY) ?		\
				 SvPV(HeKEY_sv(he),lp) :		\
				 ((lp = HeKLEN(he)), HeKEY(he)))
#define HeUTF8(he)		((HeKLEN(he) == HEf_SVKEY) ?		\
				 SvUTF8(HeKEY_sv(he)) :			\
				 (U32)HeKUTF8(he))

#define HeSVKEY(he)		((HeKEY(he) && 				\
				  HeKLEN(he) == HEf_SVKEY) ?		\
				 HeKEY_sv(he) : NULL)

#define HeSVKEY_force(he)	(HeKEY(he) ?				\
				 ((HeKLEN(he) == HEf_SVKEY) ?		\
				  HeKEY_sv(he) :			\
				  newSVpvn_flags(HeKEY(he),		\
                                                 HeKLEN(he),            \
                                                 SVs_TEMP |             \
                                      ( HeKUTF8(he) ? SVf_UTF8 : 0 ))) : \
				 &PL_sv_undef)
#define HeSVKEY_set(he,sv)	((HeKLEN(he) = HEf_SVKEY), (HeKEY_sv(he) = sv))

#ifndef PERL_CORE
#  define Nullhek Null(HEK*)
#endif
#define HEK_BASESIZE		STRUCT_OFFSET(HEK, hek_key[0])
#define HEK_HASH(hek)		(hek)->hek_hash
#define HEK_LEN(hek)		(hek)->hek_len
#define HEK_KEY(hek)		(hek)->hek_key
#define HEK_FLAGS(hek)	(*((unsigned char *)(HEK_KEY(hek))+HEK_LEN(hek)+1))

#define HVhek_UTF8	0x01 /* Key is utf8 encoded. */
#define HVhek_WASUTF8	0x02 /* Key is bytes here, but was supplied as utf8. */
#define HVhek_UNSHARED	0x08 /* This key isn't a shared hash key. */
#define HVhek_FREEKEY	0x100 /* Internal flag to say key is malloc()ed.  */
#define HVhek_PLACEHOLD	0x200 /* Internal flag to create placeholder.
                               * (may change, but Storable is a core module) */
#define HVhek_KEYCANONICAL 0x400 /* Internal flag - key is in canonical form.
				    If the string is UTF-8, it cannot be
				    converted to bytes. */
#define HVhek_MASK	0xFF

#define HVhek_ENABLEHVKFLAGS        (HVhek_MASK & ~(HVhek_UNSHARED))

#define HEK_UTF8(hek)		(HEK_FLAGS(hek) & HVhek_UTF8)
#define HEK_UTF8_on(hek)	(HEK_FLAGS(hek) |= HVhek_UTF8)
#define HEK_UTF8_off(hek)	(HEK_FLAGS(hek) &= ~HVhek_UTF8)
#define HEK_WASUTF8(hek)	(HEK_FLAGS(hek) & HVhek_WASUTF8)
#define HEK_WASUTF8_on(hek)	(HEK_FLAGS(hek) |= HVhek_WASUTF8)
#define HEK_WASUTF8_off(hek)	(HEK_FLAGS(hek) &= ~HVhek_WASUTF8)

/* calculate HV array allocation */
#ifndef PERL_USE_LARGE_HV_ALLOC
/* Default to allocating the correct size - default to assuming that malloc()
   is not broken and is efficient at allocating blocks sized at powers-of-two.
*/   
#  define PERL_HV_ARRAY_ALLOC_BYTES(size) ((size) * sizeof(HE*))
#else
#  define MALLOC_OVERHEAD 16
#  define PERL_HV_ARRAY_ALLOC_BYTES(size) \
			(((size) < 64)					\
			 ? (size) * sizeof(HE*)				\
			 : (size) * sizeof(HE*) * 2 - MALLOC_OVERHEAD)
#endif

/* Flags for hv_iternext_flags.  */
#define HV_ITERNEXT_WANTPLACEHOLDERS	0x01	/* Don't skip placeholders.  */

#define hv_iternext(hv)	hv_iternext_flags(hv, 0)
#define hv_magic(hv, gv, how) sv_magic(MUTABLE_SV(hv), MUTABLE_SV(gv), how, NULL, 0)
#define hv_undef(hv) Perl_hv_undef_flags(aTHX_ hv, 0)

#define Perl_sharepvn(pv, len, hash) HEK_KEY(share_hek(pv, len, hash))
#define sharepvn(pv, len, hash)	     Perl_sharepvn(pv, len, hash)

#define share_hek_hek(hek)						\
    (++(((struct shared_he *)(((char *)hek)				\
			      - STRUCT_OFFSET(struct shared_he,		\
					      shared_he_hek)))		\
	->shared_he_he.he_valu.hent_refcount),				\
     hek)

#define hv_store_ent(hv, keysv, val, hash)				\
    ((HE *) hv_common((hv), (keysv), NULL, 0, 0, HV_FETCH_ISSTORE,	\
		      (val), (hash)))

#define hv_exists_ent(hv, keysv, hash)					\
    (hv_common((hv), (keysv), NULL, 0, 0, HV_FETCH_ISEXISTS, 0, (hash))	\
     ? TRUE : FALSE)
#define hv_fetch_ent(hv, keysv, lval, hash)				\
    ((HE *) hv_common((hv), (keysv), NULL, 0, 0,			\
		      ((lval) ? HV_FETCH_LVALUE : 0), NULL, (hash)))
#define hv_delete_ent(hv, key, flags, hash)				\
    (MUTABLE_SV(hv_common((hv), (key), NULL, 0, 0, (flags) | HV_DELETE,	\
			  NULL, (hash))))

#define hv_store_flags(hv, key, klen, val, hash, flags)			\
    ((SV**) hv_common((hv), NULL, (key), (klen), (flags),		\
		      (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), (val),	\
		      (hash)))

#define hv_store(hv, key, klen, val, hash)				\
    ((SV**) hv_common_key_len((hv), (key), (klen),			\
			      (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV),	\
			      (val), (hash)))

#define hv_exists(hv, key, klen)					\
    (hv_common_key_len((hv), (key), (klen), HV_FETCH_ISEXISTS, NULL, 0) \
     ? TRUE : FALSE)

#define hv_fetch(hv, key, klen, lval)					\
    ((SV**) hv_common_key_len((hv), (key), (klen), (lval)		\
			      ? (HV_FETCH_JUST_SV | HV_FETCH_LVALUE)	\
			      : HV_FETCH_JUST_SV, NULL, 0))

#define hv_delete(hv, key, klen, flags)					\
    (MUTABLE_SV(hv_common_key_len((hv), (key), (klen),			\
				  (flags) | HV_DELETE, NULL, 0)))

#ifdef PERL_CORE
# define hv_storehek(hv, hek, val) \
    hv_common((hv), NULL, HEK_KEY(hek), HEK_LEN(hek), HEK_UTF8(hek),	\
	      HV_FETCH_ISSTORE|HV_FETCH_JUST_SV, (val), HEK_HASH(hek))
# define hv_fetchhek(hv, hek, lval) \
    ((SV **)								\
     hv_common((hv), NULL, HEK_KEY(hek), HEK_LEN(hek), HEK_UTF8(hek),	\
	       (lval)							\
		? (HV_FETCH_JUST_SV | HV_FETCH_LVALUE)			\
		: HV_FETCH_JUST_SV,					\
	       NULL, HEK_HASH(hek)))
# define hv_deletehek(hv, hek, flags) \
    hv_common((hv), NULL, HEK_KEY(hek), HEK_LEN(hek), HEK_UTF8(hek), \
	      (flags)|HV_DELETE, NULL, HEK_HASH(hek))
#endif

/* This refcounted he structure is used for storing the hints used for lexical
   pragmas. Without threads, it's basically struct he + refcount.
   With threads, life gets more complex as the structure needs to be shared
   between threads (because it hangs from OPs, which are shared), hence the
   alternate definition and mutex.  */

struct refcounted_he;

/* flags for the refcounted_he API */
#define REFCOUNTED_HE_KEY_UTF8		0x00000001
#ifdef PERL_CORE
# define REFCOUNTED_HE_EXISTS		0x00000002
#endif

#ifdef PERL_CORE

/* Gosh. This really isn't a good name any longer.  */
struct refcounted_he {
    struct refcounted_he *refcounted_he_next;	/* next entry in chain */
#ifdef USE_ITHREADS
    U32                   refcounted_he_hash;
    U32                   refcounted_he_keylen;
#else
    HEK                  *refcounted_he_hek;	/* hint key */
#endif
    union {
	IV                refcounted_he_u_iv;
	UV                refcounted_he_u_uv;
	STRLEN            refcounted_he_u_len;
	void		 *refcounted_he_u_ptr;	/* Might be useful in future */
    } refcounted_he_val;
    U32	                  refcounted_he_refcnt;	/* reference count */
    /* First byte is flags. Then NUL-terminated value. Then for ithreads,
       non-NUL terminated key.  */
    char                  refcounted_he_data[1];
};

/*
=for apidoc m|SV *|refcounted_he_fetch_pvs|const struct refcounted_he *chain|const char *key|U32 flags

Like L</refcounted_he_fetch_pvn>, but takes a literal string instead of
a string/length pair, and no precomputed hash.

=cut
*/

#define refcounted_he_fetch_pvs(chain, key, flags) \
    Perl_refcounted_he_fetch_pvn(aTHX_ chain, STR_WITH_LEN(key), 0, flags)

/*
=for apidoc m|struct refcounted_he *|refcounted_he_new_pvs|struct refcounted_he *parent|const char *key|SV *value|U32 flags

Like L</refcounted_he_new_pvn>, but takes a literal string instead of
a string/length pair, and no precomputed hash.

=cut
*/

#define refcounted_he_new_pvs(parent, key, value, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ parent, STR_WITH_LEN(key), 0, value, flags)

/* Flag bits are HVhek_UTF8, HVhek_WASUTF8, then */
#define HVrhek_undef	0x00 /* Value is undef. */
#define HVrhek_delete	0x10 /* Value is placeholder - signifies delete. */
#define HVrhek_IV	0x20 /* Value is IV. */
#define HVrhek_UV	0x30 /* Value is UV. */
#define HVrhek_PV	0x40 /* Value is a (byte) string. */
#define HVrhek_PV_UTF8	0x50 /* Value is a (utf8) string. */
/* Two spare. As these have to live in the optree, you can't store anything
   interpreter specific, such as SVs. :-( */
#define HVrhek_typemask 0x70

#ifdef USE_ITHREADS
/* A big expression to find the key offset */
#define REF_HE_KEY(chain)						\
	((((chain->refcounted_he_data[0] & 0x60) == 0x40)		\
	    ? chain->refcounted_he_val.refcounted_he_u_len + 1 : 0)	\
	 + 1 + chain->refcounted_he_data)
#endif

#  ifdef USE_ITHREADS
#    define HINTS_REFCNT_LOCK		MUTEX_LOCK(&PL_hints_mutex)
#    define HINTS_REFCNT_UNLOCK		MUTEX_UNLOCK(&PL_hints_mutex)
#  else
#    define HINTS_REFCNT_LOCK		NOOP
#    define HINTS_REFCNT_UNLOCK		NOOP
#  endif
#endif

#ifdef USE_ITHREADS
#  define HINTS_REFCNT_INIT		MUTEX_INIT(&PL_hints_mutex)
#  define HINTS_REFCNT_TERM		MUTEX_DESTROY(&PL_hints_mutex)
#else
#  define HINTS_REFCNT_INIT		NOOP
#  define HINTS_REFCNT_TERM		NOOP
#endif

/* Hash actions
 * Passed in PERL_MAGIC_uvar calls
 */
#define HV_DISABLE_UVAR_XKEY	0x01
/* We need to ensure that these don't clash with G_DISCARD, which is 2, as it
   is documented as being passed to hv_delete().  */
#define HV_FETCH_ISSTORE	0x04
#define HV_FETCH_ISEXISTS	0x08
#define HV_FETCH_LVALUE		0x10
#define HV_FETCH_JUST_SV	0x20
#define HV_DELETE		0x40
#define HV_FETCH_EMPTY_HE	0x80 /* Leave HeVAL null. */

/* Must not conflict with HVhek_UTF8 */
#define HV_NAME_SETALL		0x02

/*
=for apidoc newHV

Creates a new HV.  The reference count is set to 1.

=cut
*/

#define newHV()	MUTABLE_HV(newSV_type(SVt_PVHV))

#include "hv_func.h"

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                      usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/hv_func.h                                                 0100644 0000000 0000000 00000042710 12744441327 017541  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* hash a key
 *--------------------------------------------------------------------------------------
 * The "hash seed" feature was added in Perl 5.8.1 to perturb the results
 * to avoid "algorithmic complexity attacks".
 *
 * If USE_HASH_SEED is defined, hash randomisation is done by default
 * If USE_HASH_SEED_EXPLICIT is defined, hash randomisation is done
 * only if the environment variable PERL_HASH_SEED is set.
 * (see also perl.c:perl_parse() and S_init_tls_and_interp() and util.c:get_hash_seed())
 */

#ifndef PERL_SEEN_HV_FUNC_H /* compile once */
#define PERL_SEEN_HV_FUNC_H

#if !( 0 \
        || defined(PERL_HASH_FUNC_SIPHASH) \
        || defined(PERL_HASH_FUNC_SDBM) \
        || defined(PERL_HASH_FUNC_DJB2) \
        || defined(PERL_HASH_FUNC_SUPERFAST) \
        || defined(PERL_HASH_FUNC_MURMUR3) \
        || defined(PERL_HASH_FUNC_ONE_AT_A_TIME) \
        || defined(PERL_HASH_FUNC_ONE_AT_A_TIME_HARD) \
        || defined(PERL_HASH_FUNC_ONE_AT_A_TIME_OLD) \
    )
#define PERL_HASH_FUNC_ONE_AT_A_TIME_HARD
#endif

#if defined(PERL_HASH_FUNC_SIPHASH)
#   define PERL_HASH_FUNC "SIPHASH_2_4"
#   define PERL_HASH_SEED_BYTES 16
#   define PERL_HASH(hash,str,len) (hash)= S_perl_hash_siphash_2_4(PERL_HASH_SEED,(U8*)(str),(len))
#elif defined(PERL_HASH_FUNC_SUPERFAST)
#   define PERL_HASH_FUNC "SUPERFAST"
#   define PERL_HASH_SEED_BYTES 4
#   define PERL_HASH(hash,str,len) (hash)= S_perl_hash_superfast(PERL_HASH_SEED,(U8*)(str),(len))
#elif defined(PERL_HASH_FUNC_MURMUR3)
#   define PERL_HASH_FUNC "MURMUR3"
#   define PERL_HASH_SEED_BYTES 4
#   define PERL_HASH(hash,str,len) (hash)= S_perl_hash_murmur3(PERL_HASH_SEED,(U8*)(str),(len))
#elif defined(PERL_HASH_FUNC_DJB2)
#   define PERL_HASH_FUNC "DJB2"
#   define PERL_HASH_SEED_BYTES 4
#   define PERL_HASH(hash,str,len) (hash)= S_perl_hash_djb2(PERL_HASH_SEED,(U8*)(str),(len))
#elif defined(PERL_HASH_FUNC_SDBM)
#   define PERL_HASH_FUNC "SDBM"
#   define PERL_HASH_SEED_BYTES 4
#   define PERL_HASH(hash,str,len) (hash)= S_perl_hash_sdbm(PERL_HASH_SEED,(U8*)(str),(len))
#elif defined(PERL_HASH_FUNC_ONE_AT_A_TIME_HARD)
#   define PERL_HASH_FUNC "ONE_AT_A_TIME_HARD"
#   define PERL_HASH_SEED_BYTES 8
#   define PERL_HASH(hash,str,len) (hash)= S_perl_hash_one_at_a_time_hard(PERL_HASH_SEED,(U8*)(str),(len))
#elif defined(PERL_HASH_FUNC_ONE_AT_A_TIME)
#   define PERL_HASH_FUNC "ONE_AT_A_TIME"
#   define PERL_HASH_SEED_BYTES 4
#   define PERL_HASH(hash,str,len) (hash)= S_perl_hash_one_at_a_time(PERL_HASH_SEED,(U8*)(str),(len))
#elif defined(PERL_HASH_FUNC_ONE_AT_A_TIME_OLD)
#   define PERL_HASH_FUNC "ONE_AT_A_TIME_OLD"
#   define PERL_HASH_SEED_BYTES 4
#   define PERL_HASH(hash,str,len) (hash)= S_perl_hash_old_one_at_a_time(PERL_HASH_SEED,(U8*)(str),(len))
#endif

#ifndef PERL_HASH
#error "No hash function defined!"
#endif
#ifndef PERL_HASH_SEED_BYTES
#error "PERL_HASH_SEED_BYTES not defined"
#endif
#ifndef PERL_HASH_FUNC
#error "PERL_HASH_FUNC not defined"
#endif

#ifndef PERL_HASH_SEED
#   if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT)
#       define PERL_HASH_SEED PL_hash_seed
#   elif PERL_HASH_SEED_BYTES == 4
#       define PERL_HASH_SEED "PeRl"
#   elif PERL_HASH_SEED_BYTES == 16
#       define PERL_HASH_SEED "PeRlHaShhAcKpErl"
#   else
#       error "No PERL_HASH_SEED definition for " PERL_HASH_FUNC
#   endif
#endif

/*-----------------------------------------------------------------------------
 * Endianess, misalignment capabilities and util macros
 *
 * The following 3 macros are defined in this section. The other macros defined
 * are only needed to help derive these 3.
 *
 * U8TO32_LE(x)   Read a little endian unsigned 32-bit int
 * UNALIGNED_SAFE   Defined if READ_UINT32 works on non-word boundaries
 * ROTL32(x,r)      Rotate x left by r bits
 */

#if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__) \
  || defined(_MSC_VER) || defined (__TURBOC__)
#define U8TO16_LE(d) (*((const U16 *) (d)))
#endif

#if !defined (U8TO16_LE)
#define U8TO16_LE(d) ((((const U8 *)(d))[1] << 8)\
                      +((const U8 *)(d))[0])
#endif


/* Now find best way we can to READ_UINT32 */
#if (BYTEORDER == 0x1234 || BYTEORDER == 0x12345678) && U32SIZE == 4
  /* CPU endian matches murmurhash algorithm, so read 32-bit word directly */
  #define U8TO32_LE(ptr)   (*((U32*)(ptr)))
#elif BYTEORDER == 0x4321 || BYTEORDER == 0x87654321
  /* TODO: Add additional cases below where a compiler provided bswap32 is available */
  #if defined(__GNUC__) && (__GNUC__>4 || (__GNUC__==4 && __GNUC_MINOR__>=3))
    #define U8TO32_LE(ptr)   (__builtin_bswap32(*((U32*)(ptr))))
  #else
    /* Without a known fast bswap32 we're just as well off doing this */
    #define U8TO32_LE(ptr)   (ptr[0]|ptr[1]<<8|ptr[2]<<16|ptr[3]<<24)
    #define UNALIGNED_SAFE
  #endif
#else
  /* Unknown endianess so last resort is to read individual bytes */
  #define U8TO32_LE(ptr)   (ptr[0]|ptr[1]<<8|ptr[2]<<16|ptr[3]<<24)
  /* Since we're not doing word-reads we can skip the messing about with realignment */
  #define UNALIGNED_SAFE
#endif

#ifdef HAS_QUAD
#ifndef U64TYPE
/* This probably isn't going to work, but failing with a compiler error due to
   lack of uint64_t is no worse than failing right now with an #error.  */
#define U64TYPE uint64_t
#endif
#endif

/* Find best way to ROTL32/ROTL64 */
#if defined(_MSC_VER)
  #include <stdlib.h>  /* Microsoft put _rotl declaration in here */
  #define ROTL32(x,r)  _rotl(x,r)
  #ifdef HAS_QUAD
    #define ROTL64(x,r)  _rotl64(x,r)
  #endif
#else
  /* gcc recognises this code and generates a rotate instruction for CPUs with one */
  #define ROTL32(x,r)  (((U32)x << r) | ((U32)x >> (32 - r)))
  #ifdef HAS_QUAD
    #define ROTL64(x,r)  (((U64TYPE)x << r) | ((U64TYPE)x >> (64 - r)))
  #endif
#endif


#ifdef UV_IS_QUAD
#define ROTL_UV(x,r) ROTL64(x,r)
#else
#define ROTL_UV(x,r) ROTL32(x,r)
#endif

/* This is SipHash by Jean-Philippe Aumasson and Daniel J. Bernstein.
 * The authors claim it is relatively secure compared to the alternatives
 * and that performance wise it is a suitable hash for languages like Perl.
 * See:
 *
 * https://www.131002.net/siphash/
 *
 * This implementation seems to perform slightly slower than one-at-a-time for
 * short keys, but degrades slower for longer keys. Murmur Hash outperforms it
 * regardless of keys size.
 *
 * It is 64 bit only.
 */

#ifdef HAS_QUAD

#define U8TO64_LE(p) \
  (((U64TYPE)((p)[0])      ) | \
   ((U64TYPE)((p)[1]) <<  8) | \
   ((U64TYPE)((p)[2]) << 16) | \
   ((U64TYPE)((p)[3]) << 24) | \
   ((U64TYPE)((p)[4]) << 32) | \
   ((U64TYPE)((p)[5]) << 40) | \
   ((U64TYPE)((p)[6]) << 48) | \
   ((U64TYPE)((p)[7]) << 56))

#define SIPROUND            \
  do {              \
    v0 += v1; v1=ROTL64(v1,13); v1 ^= v0; v0=ROTL64(v0,32); \
    v2 += v3; v3=ROTL64(v3,16); v3 ^= v2;     \
    v0 += v3; v3=ROTL64(v3,21); v3 ^= v0;     \
    v2 += v1; v1=ROTL64(v1,17); v1 ^= v2; v2=ROTL64(v2,32); \
  } while(0)

/* SipHash-2-4 */

PERL_STATIC_INLINE U32
S_perl_hash_siphash_2_4(const unsigned char * const seed, const unsigned char *in, const STRLEN inlen) {
  /* "somepseudorandomlygeneratedbytes" */
  U64TYPE v0 = 0x736f6d6570736575ULL;
  U64TYPE v1 = 0x646f72616e646f6dULL;
  U64TYPE v2 = 0x6c7967656e657261ULL;
  U64TYPE v3 = 0x7465646279746573ULL;

  U64TYPE b;
  U64TYPE k0 = ((U64TYPE*)seed)[0];
  U64TYPE k1 = ((U64TYPE*)seed)[1];
  U64TYPE m;
  const int left = inlen & 7;
  const U8 *end = in + inlen - left;

  b = ( ( U64TYPE )(inlen) ) << 56;
  v3 ^= k1;
  v2 ^= k0;
  v1 ^= k1;
  v0 ^= k0;

  for ( ; in != end; in += 8 )
  {
    m = U8TO64_LE( in );
    v3 ^= m;
    SIPROUND;
    SIPROUND;
    v0 ^= m;
  }

  switch( left )
  {
  case 7: b |= ( ( U64TYPE )in[ 6] )  << 48;
  case 6: b |= ( ( U64TYPE )in[ 5] )  << 40;
  case 5: b |= ( ( U64TYPE )in[ 4] )  << 32;
  case 4: b |= ( ( U64TYPE )in[ 3] )  << 24;
  case 3: b |= ( ( U64TYPE )in[ 2] )  << 16;
  case 2: b |= ( ( U64TYPE )in[ 1] )  <<  8;
  case 1: b |= ( ( U64TYPE )in[ 0] ); break;
  case 0: break;
  }

  v3 ^= b;
  SIPROUND;
  SIPROUND;
  v0 ^= b;

  v2 ^= 0xff;
  SIPROUND;
  SIPROUND;
  SIPROUND;
  SIPROUND;
  b = v0 ^ v1 ^ v2  ^ v3;
  return (U32)(b & U32_MAX);
}
#endif /* defined(HAS_QUAD) */

/* FYI: This is the "Super-Fast" algorithm mentioned by Bob Jenkins in
 * (http://burtleburtle.net/bob/hash/doobs.html)
 * It is by Paul Hsieh (c) 2004 and is analysed here
 * http://www.azillionmonkeys.com/qed/hash.html
 * license terms are here:
 * http://www.azillionmonkeys.com/qed/weblicense.html
 */


PERL_STATIC_INLINE U32
S_perl_hash_superfast(const unsigned char * const seed, const unsigned char *str, STRLEN len) {
    U32 hash = *((U32*)seed) + len;
    U32 tmp;
    int rem= len & 3;
    len >>= 2;

    for (;len > 0; len--) {
        hash  += U8TO16_LE (str);
        tmp    = (U8TO16_LE (str+2) << 11) ^ hash;
        hash   = (hash << 16) ^ tmp;
        str   += 2 * sizeof (U16);
        hash  += hash >> 11;
    }

    /* Handle end cases */
    switch (rem) { \
        case 3: hash += U8TO16_LE (str);
                hash ^= hash << 16;
                hash ^= str[sizeof (U16)] << 18;
                hash += hash >> 11;
                break;
        case 2: hash += U8TO16_LE (str);
                hash ^= hash << 11;
                hash += hash >> 17;
                break;
        case 1: hash += *str;
                hash ^= hash << 10;
                hash += hash >> 1;
    }
    /* Force "avalanching" of final 127 bits */
    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    return (hash + (hash >> 6));
}


/*-----------------------------------------------------------------------------
 * MurmurHash3 was written by Austin Appleby, and is placed in the public
 * domain.
 *
 * This implementation was originally written by Shane Day, and is also public domain,
 * and was modified to function as a macro similar to other perl hash functions by
 * Yves Orton.
 *
 * This is a portable ANSI C implementation of MurmurHash3_x86_32 (Murmur3A)
 * with support for progressive processing.
 *
 * If you want to understand the MurmurHash algorithm you would be much better
 * off reading the original source. Just point your browser at:
 * http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 *
 * How does it work?
 *
 * We can only process entire 32 bit chunks of input, except for the very end
 * that may be shorter.
 *
 * To handle endianess I simply use a macro that reads a U32 and define
 * that macro to be a direct read on little endian machines, a read and swap
 * on big endian machines, or a byte-by-byte read if the endianess is unknown.
 */


/*-----------------------------------------------------------------------------
 * Core murmurhash algorithm macros */

#define MURMUR_C1  (0xcc9e2d51)
#define MURMUR_C2  (0x1b873593)
#define MURMUR_C3  (0xe6546b64)
#define MURMUR_C4  (0x85ebca6b)
#define MURMUR_C5  (0xc2b2ae35)

/* This is the main processing body of the algorithm. It operates
 * on each full 32-bits of input. */
#define MURMUR_DOBLOCK(h1, k1) STMT_START { \
    k1 *= MURMUR_C1; \
    k1 = ROTL32(k1,15); \
    k1 *= MURMUR_C2; \
    \
    h1 ^= k1; \
    h1 = ROTL32(h1,13); \
    h1 = h1 * 5 + MURMUR_C3; \
} STMT_END


/* Append unaligned bytes to carry, forcing hash churn if we have 4 bytes */
/* cnt=bytes to process, h1=name of h1 var, c=carry, n=bytes in c, ptr/len=payload */
#define MURMUR_DOBYTES(cnt, h1, c, n, ptr, len) STMT_START { \
    int MURMUR_DOBYTES_i = cnt; \
    while(MURMUR_DOBYTES_i--) { \
        c = c>>8 | *ptr++<<24; \
        n++; len--; \
        if(n==4) { \
            MURMUR_DOBLOCK(h1, c); \
            n = 0; \
        } \
    } \
} STMT_END


/* now we create the hash function */
PERL_STATIC_INLINE U32
S_perl_hash_murmur3(const unsigned char * const seed, const unsigned char *ptr, STRLEN len) {
    U32 h1 = *((U32*)seed);
    U32 k1;
    U32 carry = 0;

    const unsigned char *end;
    int bytes_in_carry = 0; /* bytes in carry */
    I32 total_length= len;

#if defined(UNALIGNED_SAFE)
    /* Handle carry: commented out as its only used in incremental mode - it never fires for us
    int i = (4-n) & 3;
    if(i && i <= len) {
      MURMUR_DOBYTES(i, h1, carry, bytes_in_carry, ptr, len);
    }
    */

    /* This CPU handles unaligned word access */
    /* Process 32-bit chunks */
    end = ptr + len/4*4;
    for( ; ptr < end ; ptr+=4) {
        k1 = U8TO32_LE(ptr);
        MURMUR_DOBLOCK(h1, k1);
    }
#else
    /* This CPU does not handle unaligned word access */

    /* Consume enough so that the next data byte is word aligned */
    STRLEN i = -PTR2IV(ptr) & 3;
    if(i && i <= len) {
      MURMUR_DOBYTES(i, h1, carry, bytes_in_carry, ptr, len);
    }

    /* We're now aligned. Process in aligned blocks. Specialise for each possible carry count */
    end = ptr + len/4*4;
    switch(bytes_in_carry) { /* how many bytes in carry */
        case 0: /* c=[----]  w=[3210]  b=[3210]=w            c'=[----] */
        for( ; ptr < end ; ptr+=4) {
            k1 = U8TO32_LE(ptr);
            MURMUR_DOBLOCK(h1, k1);
        }
        break;
        case 1: /* c=[0---]  w=[4321]  b=[3210]=c>>24|w<<8   c'=[4---] */
        for( ; ptr < end ; ptr+=4) {
            k1 = carry>>24;
            carry = U8TO32_LE(ptr);
            k1 |= carry<<8;
            MURMUR_DOBLOCK(h1, k1);
        }
        break;
        case 2: /* c=[10--]  w=[5432]  b=[3210]=c>>16|w<<16  c'=[54--] */
        for( ; ptr < end ; ptr+=4) {
            k1 = carry>>16;
            carry = U8TO32_LE(ptr);
            k1 |= carry<<16;
            MURMUR_DOBLOCK(h1, k1);
        }
        break;
        case 3: /* c=[210-]  w=[6543]  b=[3210]=c>>8|w<<24   c'=[654-] */
        for( ; ptr < end ; ptr+=4) {
            k1 = carry>>8;
            carry = U8TO32_LE(ptr);
            k1 |= carry<<24;
            MURMUR_DOBLOCK(h1, k1);
        }
    }
#endif
    /* Advance over whole 32-bit chunks, possibly leaving 1..3 bytes */
    len -= len/4*4;

    /* Append any remaining bytes into carry */
    MURMUR_DOBYTES(len, h1, carry, bytes_in_carry, ptr, len);

    if (bytes_in_carry) {
        k1 = carry >> ( 4 - bytes_in_carry ) * 8;
        k1 *= MURMUR_C1;
        k1 = ROTL32(k1,15);
        k1 *= MURMUR_C2;
        h1 ^= k1;
    }
    h1 ^= total_length;

    /* fmix */
    h1 ^= h1 >> 16;
    h1 *= MURMUR_C4;
    h1 ^= h1 >> 13;
    h1 *= MURMUR_C5;
    h1 ^= h1 >> 16;
    return h1;
}


PERL_STATIC_INLINE U32
S_perl_hash_djb2(const unsigned char * const seed, const unsigned char *str, const STRLEN len) {
    const unsigned char * const end = (const unsigned char *)str + len;
    U32 hash = *((U32*)seed + len);
    while (str < end) {
        hash = ((hash << 5) + hash) + *str++;
    }
    return hash;
}

PERL_STATIC_INLINE U32
S_perl_hash_sdbm(const unsigned char * const seed, const unsigned char *str, const STRLEN len) {
    const unsigned char * const end = (const unsigned char *)str + len;
    U32 hash = *((U32*)seed + len);
    while (str < end) {
        hash = (hash << 6) + (hash << 16) - hash + *str++;
    }
    return hash;
}

/* - ONE_AT_A_TIME_HARD is the 5.17+ recommend ONE_AT_A_TIME algorithm
 * - ONE_AT_A_TIME_OLD is the unmodified 5.16 and older algorithm
 * - ONE_AT_A_TIME is a 5.17+ tweak of ONE_AT_A_TIME_OLD to
 *   prevent strings of only \0 but different lengths from colliding
 *
 * Security-wise, from best to worst,
 * ONE_AT_A_TIME_HARD > ONE_AT_A_TIME > ONE_AT_A_TIME_OLD
 * There is a big drop-off in security between ONE_AT_A_TIME_HARD and
 * ONE_AT_A_TIME
 * */

/* This is the "One-at-a-Time" algorithm by Bob Jenkins
 * from requirements by Colin Plumb.
 * (http://burtleburtle.net/bob/hash/doobs.html)
 * With seed/len tweak.
 * */
PERL_STATIC_INLINE U32
S_perl_hash_one_at_a_time(const unsigned char * const seed, const unsigned char *str, const STRLEN len) {
    const unsigned char * const end = (const unsigned char *)str + len;
    U32 hash = *((U32*)seed) + len;
    while (str < end) {
        hash += *str++;
        hash += (hash << 10);
        hash ^= (hash >> 6);
    }
    hash += (hash << 3);
    hash ^= (hash >> 11);
    return (hash + (hash << 15));
}

/* Derived from "One-at-a-Time" algorithm by Bob Jenkins */
PERL_STATIC_INLINE U32
S_perl_hash_one_at_a_time_hard(const unsigned char * const seed, const unsigned char *str, const STRLEN len) {
    const unsigned char * const end = (const unsigned char *)str + len;
    U32 hash = *((U32*)seed) + len;
    
    while (str < end) {
        hash += (hash << 10);
        hash ^= (hash >> 6);
        hash += *str++;
    }
    
    hash += (hash << 10);
    hash ^= (hash >> 6);
    hash += seed[4];
    
    hash += (hash << 10);
    hash ^= (hash >> 6);
    hash += seed[5];
    
    hash += (hash << 10);
    hash ^= (hash >> 6);
    hash += seed[6];
    
    hash += (hash << 10);
    hash ^= (hash >> 6);
    hash += seed[7];
    
    hash += (hash << 10);
    hash ^= (hash >> 6);

    hash += (hash << 3);
    hash ^= (hash >> 11);
    return (hash + (hash << 15));
}

PERL_STATIC_INLINE U32
S_perl_hash_old_one_at_a_time(const unsigned char * const seed, const unsigned char *str, const STRLEN len) {
    const unsigned char * const end = (const unsigned char *)str + len;
    U32 hash = *((U32*)seed);
    while (str < end) {
        hash += *str++;
        hash += (hash << 10);
        hash ^= (hash >> 6);
    }
    hash += (hash << 3);
    hash ^= (hash >> 11);
    return (hash + (hash << 15));
}

/* legacy - only mod_perl should be doing this.  */
#ifdef PERL_HASH_INTERNAL_ACCESS
#define PERL_HASH_INTERNAL(hash,str,len) PERL_HASH(hash,str,len)
#endif

#endif /*compile once*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                        usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/inline.h                                                  0100644 0000000 0000000 00000023355 12744441327 017373  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    inline.h
 *
 *    Copyright (C) 2012 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * This file is a home for static inline functions that cannot go in other
 * headers files, because they depend on proto.h (included after most other
 * headers) or struct definitions.
 *
 * Each section names the header file that the functions "belong" to.
 */

/* ------------------------------- av.h ------------------------------- */

PERL_STATIC_INLINE SSize_t
S_av_top_index(pTHX_ AV *av)
{
    PERL_ARGS_ASSERT_AV_TOP_INDEX;
    assert(SvTYPE(av) == SVt_PVAV);

    return AvFILL(av);
}

/* ------------------------------- cv.h ------------------------------- */

PERL_STATIC_INLINE I32 *
S_CvDEPTHp(const CV * const sv)
{
    assert(SvTYPE(sv) == SVt_PVCV || SvTYPE(sv) == SVt_PVFM);
    return &((XPVCV*)SvANY(sv))->xcv_depth;
}

/*
 CvPROTO returns the prototype as stored, which is not necessarily what
 the interpreter should be using. Specifically, the interpreter assumes
 that spaces have been stripped, which has been the case if the prototype
 was added by toke.c, but is generally not the case if it was added elsewhere.
 Since we can't enforce the spacelessness at assignment time, this routine
 provides a temporary copy at parse time with spaces removed.
 I<orig> is the start of the original buffer, I<len> is the length of the
 prototype and will be updated when this returns.
 */

#ifdef PERL_CORE
PERL_STATIC_INLINE char *
S_strip_spaces(pTHX_ const char * orig, STRLEN * const len)
{
    SV * tmpsv;
    char * tmps;
    tmpsv = newSVpvn_flags(orig, *len, SVs_TEMP);
    tmps = SvPVX(tmpsv);
    while ((*len)--) {
	if (!isSPACE(*orig))
	    *tmps++ = *orig;
	orig++;
    }
    *tmps = '\0';
    *len = tmps - SvPVX(tmpsv);
		return SvPVX(tmpsv);
}
#endif

/* ------------------------------- mg.h ------------------------------- */

#if defined(PERL_CORE) || defined(PERL_EXT)
/* assumes get-magic and stringification have already occurred */
PERL_STATIC_INLINE STRLEN
S_MgBYTEPOS(pTHX_ MAGIC *mg, SV *sv, const char *s, STRLEN len)
{
    assert(mg->mg_type == PERL_MAGIC_regex_global);
    assert(mg->mg_len != -1);
    if (mg->mg_flags & MGf_BYTES || !DO_UTF8(sv))
	return (STRLEN)mg->mg_len;
    else {
	const STRLEN pos = (STRLEN)mg->mg_len;
	/* Without this check, we may read past the end of the buffer: */
	if (pos > sv_or_pv_len_utf8(sv, s, len)) return len+1;
	return sv_or_pv_pos_u2b(sv, s, pos, NULL);
    }
}
#endif

/* ----------------------------- regexp.h ----------------------------- */

PERL_STATIC_INLINE struct regexp *
S_ReANY(const REGEXP * const re)
{
    assert(isREGEXP(re));
    return re->sv_u.svu_rx;
}

/* ------------------------------- sv.h ------------------------------- */

PERL_STATIC_INLINE SV *
S_SvREFCNT_inc(SV *sv)
{
    if (LIKELY(sv != NULL))
	SvREFCNT(sv)++;
    return sv;
}
PERL_STATIC_INLINE SV *
S_SvREFCNT_inc_NN(SV *sv)
{
    SvREFCNT(sv)++;
    return sv;
}
PERL_STATIC_INLINE void
S_SvREFCNT_inc_void(SV *sv)
{
    if (LIKELY(sv != NULL))
	SvREFCNT(sv)++;
}
PERL_STATIC_INLINE void
S_SvREFCNT_dec(pTHX_ SV *sv)
{
    if (LIKELY(sv != NULL)) {
	U32 rc = SvREFCNT(sv);
	if (LIKELY(rc > 1))
	    SvREFCNT(sv) = rc - 1;
	else
	    Perl_sv_free2(aTHX_ sv, rc);
    }
}

PERL_STATIC_INLINE void
S_SvREFCNT_dec_NN(pTHX_ SV *sv)
{
    U32 rc = SvREFCNT(sv);
    if (LIKELY(rc > 1))
	SvREFCNT(sv) = rc - 1;
    else
	Perl_sv_free2(aTHX_ sv, rc);
}

PERL_STATIC_INLINE void
SvAMAGIC_on(SV *sv)
{
    assert(SvROK(sv));
    if (SvOBJECT(SvRV(sv))) HvAMAGIC_on(SvSTASH(SvRV(sv)));
}
PERL_STATIC_INLINE void
SvAMAGIC_off(SV *sv)
{
    if (SvROK(sv) && SvOBJECT(SvRV(sv)))
	HvAMAGIC_off(SvSTASH(SvRV(sv)));
}

PERL_STATIC_INLINE U32
S_SvPADTMP_on(SV *sv)
{
    assert(!(SvFLAGS(sv) & SVs_PADMY));
    return SvFLAGS(sv) |= SVs_PADTMP;
}
PERL_STATIC_INLINE U32
S_SvPADTMP_off(SV *sv)
{
    assert(!(SvFLAGS(sv) & SVs_PADMY));
    return SvFLAGS(sv) &= ~SVs_PADTMP;
}
PERL_STATIC_INLINE U32
S_SvPADSTALE_on(SV *sv)
{
    assert(SvFLAGS(sv) & SVs_PADMY);
    return SvFLAGS(sv) |= SVs_PADSTALE;
}
PERL_STATIC_INLINE U32
S_SvPADSTALE_off(SV *sv)
{
    assert(SvFLAGS(sv) & SVs_PADMY);
    return SvFLAGS(sv) &= ~SVs_PADSTALE;
}
#if defined(PERL_CORE) || defined (PERL_EXT)
PERL_STATIC_INLINE STRLEN
S_sv_or_pv_pos_u2b(pTHX_ SV *sv, const char *pv, STRLEN pos, STRLEN *lenp)
{
    PERL_ARGS_ASSERT_SV_OR_PV_POS_U2B;
    if (SvGAMAGIC(sv)) {
	U8 *hopped = utf8_hop((U8 *)pv, pos);
	if (lenp) *lenp = (STRLEN)(utf8_hop(hopped, *lenp) - hopped);
	return (STRLEN)(hopped - (U8 *)pv);
    }
    return sv_pos_u2b_flags(sv,pos,lenp,SV_CONST_RETURN);
}
#endif

/* ------------------------------- handy.h ------------------------------- */

/* saves machine code for a common noreturn idiom typically used in Newx*() */
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"
#endif
static void
S_croak_memory_wrap(void)
{
    Perl_croak_nocontext("%s",PL_memory_wrap);
}
#ifdef __clang__
#pragma clang diagnostic pop
#endif

#ifdef BOOTSTRAP_CHARSET
static bool
S_bootstrap_ctype(U8 character, UV classnum, bool full_Latin1)
{
    /* See comments in handy.h.  This is placed in this file primarily to avoid
     * having to have an entry for it in embed.fnc */

    dTHX;

    if (! full_Latin1 && ! isASCII(character)) {
        return FALSE;
    }

    switch (classnum) {
        case _CC_ALPHANUMERIC: return isALPHANUMERIC_L1(character);
        case _CC_ALPHA:     return isALPHA_L1(character);
        case _CC_ASCII:     return isASCII_L1(character);
        case _CC_BLANK:     return isBLANK_L1(character);
        case _CC_CASED:     return isLOWER_L1(character)
                                   || isUPPER_L1(character);
        case _CC_CNTRL:     return isCNTRL_L1(character);
        case _CC_DIGIT:     return isDIGIT_L1(character);
        case _CC_GRAPH:     return isGRAPH_L1(character);
        case _CC_LOWER:     return isLOWER_L1(character);
        case _CC_PRINT:     return isPRINT_L1(character);
        case _CC_PSXSPC:    return isPSXSPC_L1(character);
        case _CC_PUNCT:     return isPUNCT_L1(character);
        case _CC_SPACE:     return isSPACE_L1(character);
        case _CC_UPPER:     return isUPPER_L1(character);
        case _CC_WORDCHAR:  return isWORDCHAR_L1(character);
        case _CC_XDIGIT:    return isXDIGIT_L1(character);
        case _CC_VERTSPACE: return isSPACE_L1(character) && ! isBLANK_L1(character);
        case _CC_IDFIRST:   return isIDFIRST_L1(character);
        case _CC_QUOTEMETA: return _isQUOTEMETA(character);
        case _CC_CHARNAME_CONT: return isCHARNAME_CONT(character);
        case _CC_NONLATIN1_FOLD: return _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(character);
        case _CC_NON_FINAL_FOLD: return _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(character);
        case _CC_IS_IN_SOME_FOLD: return _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(character);
        case _CC_BACKSLASH_FOO_LBRACE_IS_META: return 0;


        default: break;
    }
    Perl_croak(aTHX_ "panic: bootstrap_ctype() has an unexpected character class '%" UVxf "'", classnum);
}
#endif

/* ------------------------------- utf8.h ------------------------------- */

PERL_STATIC_INLINE void
S_append_utf8_from_native_byte(const U8 byte, U8** dest)
{
    /* Takes an input 'byte' (Latin1 or EBCDIC) and appends it to the UTF-8
     * encoded string at '*dest', updating '*dest' to include it */

    PERL_ARGS_ASSERT_APPEND_UTF8_FROM_NATIVE_BYTE;

    if (NATIVE_BYTE_IS_INVARIANT(byte))
        *(*dest)++ = byte;
    else {
        *(*dest)++ = UTF8_EIGHT_BIT_HI(byte);
        *(*dest)++ = UTF8_EIGHT_BIT_LO(byte);
    }
}

/* These two exist only to replace the macros they formerly were so that their
 * use can be deprecated */

PERL_STATIC_INLINE bool
S_isIDFIRST_lazy(pTHX_ const char* p)
{
    PERL_ARGS_ASSERT_ISIDFIRST_LAZY;

    return isIDFIRST_lazy_if(p,1);
}

PERL_STATIC_INLINE bool
S_isALNUM_lazy(pTHX_ const char* p)
{
    PERL_ARGS_ASSERT_ISALNUM_LAZY;

    return isALNUM_lazy_if(p,1);
}

/* ------------------------------- perl.h ----------------------------- */

/*
=for apidoc AiR|bool|is_safe_syscall|const char *pv|STRLEN len|const char *what|const char *op_name

Test that the given C<pv> doesn't contain any internal C<NUL> characters.
If it does, set C<errno> to ENOENT, optionally warn, and return FALSE.

Return TRUE if the name is safe.

Used by the IS_SAFE_SYSCALL() macro.

=cut
*/

PERL_STATIC_INLINE bool
S_is_safe_syscall(pTHX_ const char *pv, STRLEN len, const char *what, const char *op_name) {
    /* While the Windows CE API provides only UCS-16 (or UTF-16) APIs
     * perl itself uses xce*() functions which accept 8-bit strings.
     */

    PERL_ARGS_ASSERT_IS_SAFE_SYSCALL;

    if (pv && len > 1) {
        char *null_at;
        if (UNLIKELY((null_at = (char *)memchr(pv, 0, len-1)) != NULL)) {
                SETERRNO(ENOENT, LIB_INVARG);
                Perl_ck_warner(aTHX_ packWARN(WARN_SYSCALLS),
                                   "Invalid \\0 character in %s for %s: %s\\0%s",
                                   what, op_name, pv, null_at+1);
                return FALSE;
        }
    }

    return TRUE;
}

/*

Return false if any get magic is on the SV other than taint magic.

*/

PERL_STATIC_INLINE bool
S_sv_only_taint_gmagic(SV *sv) {
    MAGIC *mg = SvMAGIC(sv);

    PERL_ARGS_ASSERT_SV_ONLY_TAINT_GMAGIC;

    while (mg) {
        if (mg->mg_type != PERL_MAGIC_taint
            && !(mg->mg_flags & MGf_GSKIP)
            && mg->mg_virtual->svt_get) {
            return FALSE;
        }
        mg = mg->mg_moremagic;
    }

    return TRUE;
}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                   usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/intrpvar.h                                                0100644 0000000 0000000 00000065764 12744441327 017774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*   intrpvar.h 
 *
 *    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
 *    2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#include "handy.h"

/*
=head1 Per-Interpreter Variables
*/

/* These variables are per-interpreter in threaded/multiplicity builds,
 * global otherwise.

 * Don't forget to re-run regen/embed.pl to propagate changes! */

/* New variables must be added to the very end for binary compatibility. */

/* Don't forget to add your variable also to perl_clone()! (in sv.c) */

/* The 'I' prefix is only needed for vars that need appropriate #defines
 * generated when built with or without MULTIPLICITY.  It is also used
 * to generate the appropriate export list for win32.  If the variable
 * needs to be initialized, use PERLVARI.
 *
 * When building without MULTIPLICITY, these variables will be truly global.
 *
 * Important ones in the first cache line (if alignment is done right) */

PERLVAR(I, stack_sp,	SV **)		/* top of the stack */
PERLVAR(I, op,		OP *)		/* currently executing op */
PERLVAR(I, curpad,	SV **)		/* active pad (lexicals+tmps) */

PERLVAR(I, stack_base,	SV **)
PERLVAR(I, stack_max,	SV **)

PERLVAR(I, savestack,	ANY *)		/* items that need to be restored when
					   LEAVEing scopes we've ENTERed */
PERLVAR(I, savestack_ix, I32)
PERLVAR(I, savestack_max, I32)

PERLVAR(I, scopestack,	I32 *)		/* scopes we've ENTERed */
PERLVAR(I, scopestack_ix, I32)
PERLVAR(I, scopestack_max, I32)

PERLVAR(I, tmps_stack,	SV **)		/* mortals we've made */
PERLVARI(I, tmps_ix,	SSize_t,	-1)
PERLVARI(I, tmps_floor,	SSize_t,	-1)
PERLVAR(I, tmps_max,	SSize_t)

PERLVARI(I, sub_generation, U32, 1)	/* incr to invalidate method cache */

PERLVAR(I, markstack,	I32 *)		/* stack_sp locations we're
					   remembering */
PERLVAR(I, markstack_ptr, I32 *)
PERLVAR(I, markstack_max, I32 *)

#ifdef PERL_HASH_RANDOMIZE_KEYS
#ifdef USE_PERL_PERTURB_KEYS
PERLVARI(I, hash_rand_bits_enabled, U8, 1) /* used to randomize hash stuff 0 == no-random, 1 == random, 2 == determinsitic */
#endif
PERLVARI(I, hash_rand_bits, UV, 0)      /* used to randomize hash stuff */
#endif
PERLVAR(I, strtab,	HV *)		/* shared string table */

/* Fields used by magic variables such as $@, $/ and so on */
PERLVAR(I, curpm,	PMOP *)		/* what to do \ interps in REs from */

PERLVAR(I, tainting,	bool)		/* doing taint checks */
PERLVAR(I, tainted,	bool)		/* using variables controlled by $< */
PERLVAR(I, delaymagic,	U16)		/* ($<,$>) = ... */
PERLVAR(I, localizing,	U8)		/* are we processing a local() list? */
PERLVAR(I, in_eval,	U8)		/* trap "fatal" errors? */
PERLVAR(I, defgv,	GV *)           /* the *_ glob */
/*

=for apidoc mn|bool|PL_dowarn

The C variable which corresponds to Perl's $^W warning variable.

=cut
*/

PERLVAR(I, dowarn,	U8)

#if defined (PERL_UTF8_CACHE_ASSERT) || defined (DEBUGGING)
#  define PERL___I -1
#else
#  define PERL___I 1
#endif
PERLVARI(I, utf8cache, I8, PERL___I)	/* Is the utf8 caching code enabled? */
#undef PERL___I


/* Stashes */
PERLVAR(I, defstash,	HV *)		/* main symbol table */
PERLVAR(I, curstash,	HV *)		/* symbol table for current package */

PERLVAR(I, curcop,	COP *)
PERLVAR(I, curstack,	AV *)		/* THE STACK */
PERLVAR(I, curstackinfo, PERL_SI *)	/* current stack + context */
PERLVAR(I, mainstack,	AV *)		/* the stack when nothing funny is
					   happening */

/* memory management */
PERLVAR(I, sv_count,	IV)		/* how many SV* are currently allocated */
PERLVAR(I, sv_objcount,	IV)		/* DEPRECATED AND UNMAINTAINED.
                                         * Will be removed in Perl 5.22.
                                         * Used to be: how many objects are currently allocated. */

PERLVAR(I, sv_root,	SV *)		/* storage for SVs belonging to interp */
PERLVAR(I, sv_arenaroot, SV *)		/* list of areas for garbage collection */

/* fake PMOP that PL_curpm points to while in (?{}) so $1 et al are visible */
PERLVARI(I, reg_curpm, PMOP*, NULL)

/* the currently active slab in a chain of slabs of regmatch states,
 * and the currently active state within that slab. This stack of states
 * is shared amongst re-entrant calls to the regex engine */

PERLVARI(I, regmatch_slab, regmatch_slab *,	NULL)
PERLVAR(I, regmatch_state, regmatch_state *)

PERLVAR(I, comppad,	PAD *)		/* storage for lexically scoped temporaries */

/*
=for apidoc Amn|SV|PL_sv_undef
This is the C<undef> SV.  Always refer to this as C<&PL_sv_undef>.

=for apidoc Amn|SV|PL_sv_no
This is the C<false> SV.  See C<PL_sv_yes>.  Always refer to this as
C<&PL_sv_no>.

=for apidoc Amn|SV|PL_sv_yes
This is the C<true> SV.  See C<PL_sv_no>.  Always refer to this as
C<&PL_sv_yes>.

=cut
*/

PERLVAR(I, sv_undef,	SV)
PERLVAR(I, sv_no,	SV)
PERLVAR(I, sv_yes,	SV)
PERLVAR(I, Sv,		SV *)		/* used to hold temporary values */

PERLVAR(I, parser,	yy_parser *)	/* current parser state */

PERLVAR(I, stashcache,	HV *)		/* Cache to speed up S_method_common */


/*
=for apidoc Amn|STRLEN|PL_na

A convenience variable which is typically used with C<SvPV> when one
doesn't care about the length of the string.  It is usually more efficient
to either declare a local variable and use that instead or to use the
C<SvPV_nolen> macro.

=cut
*/

PERLVAR(I, na,		STRLEN)		/* for use in SvPV when length is
					   Not Applicable */

/* stat stuff */
PERLVAR(I, statbuf,	Stat_t)
PERLVAR(I, statcache,	Stat_t)		/* _ */
PERLVAR(I, statgv,	GV *)
PERLVARI(I, statname,	SV *,	NULL)

#ifdef HAS_TIMES
/* Will be removed soon after v5.21.0. See RT #121351 */
PERLVAR(I, timesbuf,	struct tms)
#endif

/*
=for apidoc mn|SV*|PL_rs

The input record separator - C<$/> in Perl space.

=for apidoc mn|GV*|PL_last_in_gv

The GV which was last used for a filehandle input operation.  (C<< <FH> >>)

=for apidoc mn|GV*|PL_ofsgv

The glob containing the output field separator - C<*,> in Perl space.

=cut
*/

PERLVAR(I, rs,		SV *)		/* input record separator $/ */
PERLVAR(I, last_in_gv,	GV *)		/* GV used in last <FH> */
PERLVAR(I, ofsgv,	GV *)		/* GV of output field separator *, */
PERLVAR(I, defoutgv,	GV *)		/* default FH for output */
PERLVARI(I, chopset,	const char *, " \n-")	/* $: */
PERLVAR(I, formtarget,	SV *)
PERLVAR(I, bodytarget,	SV *)
PERLVAR(I, toptarget,	SV *)


PERLVAR(I, restartop,	OP *)		/* propagating an error from croak? */
PERLVAR(I, restartjmpenv, JMPENV *)	/* target frame for longjmp in die */

PERLVAR(I, top_env,	JMPENV *)	/* ptr to current sigjmp environment */
PERLVAR(I, start_env,	JMPENV)		/* empty startup sigjmp environment */
PERLVARI(I, errors,	SV *,	NULL)	/* outstanding queued errors */

/* statics "owned" by various functions */
PERLVAR(I, hv_fetch_ent_mh, HE*)	/* owned by hv_fetch_ent() */

PERLVAR(I, lastgotoprobe, OP*)		/* from pp_ctl.c */

/* sort stuff */
PERLVAR(I, sortcop,	OP *)		/* user defined sort routine */
PERLVAR(I, sortstash,	HV *)		/* which is in some package or other */
PERLVAR(I, firstgv,	GV *)		/* $a */
PERLVAR(I, secondgv,	GV *)		/* $b */

/* float buffer */
PERLVAR(I, efloatbuf,	char *)
PERLVAR(I, efloatsize,	STRLEN)

PERLVARI(I, dumpindent,	U16,	4)	/* number of blanks per dump
					   indentation level */

PERLVAR(I, exit_flags,	U8)		/* was exit() unexpected, etc. */

PERLVAR(I, utf8locale,	bool)		/* utf8 locale detected */
PERLVAR(I, in_utf8_CTYPE_locale, bool)

PERLVARA(I, colors,6,	char *)		/* values from PERL_RE_COLORS env var */

/*
=for apidoc Amn|peep_t|PL_peepp

Pointer to the per-subroutine peephole optimiser.  This is a function
that gets called at the end of compilation of a Perl subroutine (or
equivalently independent piece of Perl code) to perform fixups of
some ops and to perform small-scale optimisations.  The function is
called once for each subroutine that is compiled, and is passed, as sole
parameter, a pointer to the op that is the entry point to the subroutine.
It modifies the op tree in place.

The peephole optimiser should never be completely replaced.  Rather,
add code to it by wrapping the existing optimiser.  The basic way to do
this can be seen in L<perlguts/Compile pass 3: peephole optimization>.
If the new code wishes to operate on ops throughout the subroutine's
structure, rather than just at the top level, it is likely to be more
convenient to wrap the L</PL_rpeepp> hook.

=cut
*/

PERLVARI(I, peepp,	peep_t, Perl_peep)

/*
=for apidoc Amn|peep_t|PL_rpeepp

Pointer to the recursive peephole optimiser.  This is a function
that gets called at the end of compilation of a Perl subroutine (or
equivalently independent piece of Perl code) to perform fixups of some
ops and to perform small-scale optimisations.  The function is called
once for each chain of ops linked through their C<op_next> fields;
it is recursively called to handle each side chain.  It is passed, as
sole parameter, a pointer to the op that is at the head of the chain.
It modifies the op tree in place.

The peephole optimiser should never be completely replaced.  Rather,
add code to it by wrapping the existing optimiser.  The basic way to do
this can be seen in L<perlguts/Compile pass 3: peephole optimization>.
If the new code wishes to operate only on ops at a subroutine's top level,
rather than throughout the structure, it is likely to be more convenient
to wrap the L</PL_peepp> hook.

=cut
*/

PERLVARI(I, rpeepp,	peep_t, Perl_rpeep)

/*
=for apidoc Amn|Perl_ophook_t|PL_opfreehook

When non-C<NULL>, the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument.
This allows extensions to free any extra attribute they have locally attached to an OP.
It is also assured to first fire for the parent OP and then for its kids.

When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.

=cut
*/

PERLVARI(I, opfreehook,	Perl_ophook_t, 0) /* op_free() hook */

PERLVARI(I, watchaddr,	char **, 0)
PERLVAR(I, watchok,	char *)

PERLVAR(I, perldb,	U32)

PERLVAR(I, signals,	U32)	/* Using which pre-5.8 signals */

PERLVAR(I, reentrant_retint, int)	/* Integer return value from reentrant functions */

/* pseudo environmental stuff */
PERLVAR(I, origargc,	int)
PERLVAR(I, origargv,	char **)
PERLVAR(I, envgv,	GV *)
PERLVAR(I, incgv,	GV *)
PERLVAR(I, hintgv,	GV *)
PERLVAR(I, origfilename, char *)
PERLVAR(I, diehook,	SV *)
PERLVAR(I, warnhook,	SV *)

/* switches */
PERLVAR(I, patchlevel,	SV *)
PERLVAR(I, apiversion,	SV *)
PERLVAR(I, localpatches, const char * const *)
PERLVARI(I, splitstr,	const char *, " ")

PERLVAR(I, minus_c,	bool)
PERLVAR(I, minus_n,	bool)
PERLVAR(I, minus_p,	bool)
PERLVAR(I, minus_l,	bool)
PERLVAR(I, minus_a,	bool)
PERLVAR(I, minus_F,	bool)
PERLVAR(I, doswitches,	bool)
PERLVAR(I, minus_E,	bool)

PERLVAR(I, inplace,	char *)
PERLVAR(I, e_script,	SV *)

PERLVAR(I, basetime,	Time_t)		/* $^T */

PERLVARI(I, maxsysfd,	I32,	MAXSYSFD)
					/* top fd to pass to subprocesses */
PERLVAR(I, statusvalue,	I32)		/* $? */
#ifdef VMS
PERLVAR(I, statusvalue_vms, U32)
#else
PERLVAR(I, statusvalue_posix, I32)
#endif

PERLVARI(I, sig_pending, int, 0)	/* Number if highest signal pending */
PERLVAR(I, psig_pend, int *)		/* per-signal "count" of pending */

/* shortcuts to various I/O objects */
PERLVAR(I, stdingv,	GV *)		/*  *STDIN      */
PERLVAR(I, stderrgv,	GV *)		/*  *STDERR     */
PERLVAR(I, argvgv,	GV *)		/*  *ARGV       */
PERLVAR(I, argvoutgv,	GV *)		/*  *ARGVOUT    */
PERLVAR(I, argvout_stack, AV *)

/* shortcuts to regexp stuff */
PERLVAR(I, replgv,	GV *)		/*  *^R         */

/* shortcuts to misc objects */
PERLVAR(I, errgv,	GV *)		/*  *@          */

/* shortcuts to debugging objects */
PERLVAR(I, DBgv,	GV *)		/*  *DB::DB     */
PERLVAR(I, DBline,	GV *)		/*  *DB::line   */

/*
=for apidoc mn|GV *|PL_DBsub
When Perl is run in debugging mode, with the B<-d> switch, this GV contains
the SV which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's $DB::sub variable.  See
C<PL_DBsingle>.

=for apidoc mn|SV *|PL_DBsingle
When Perl is run in debugging mode, with the B<-d> switch, this SV is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's $DB::single variable.  See
C<PL_DBsub>.

=for apidoc mn|SV *|PL_DBtrace
Trace variable used when Perl is run in debugging mode, with the B<-d>
switch.  This is the C variable which corresponds to Perl's $DB::trace
variable.  See C<PL_DBsingle>.

=cut
*/

PERLVAR(I, DBsub,	GV *)		/*  *DB::sub    */
PERLVAR(I, DBsingle,	SV *)		/*  $DB::single */
PERLVAR(I, DBtrace,	SV *)		/*  $DB::trace  */
PERLVAR(I, DBsignal,	SV *)		/*  $DB::signal */
PERLVAR(I, dbargs,	AV *)		/* args to call listed by caller function */

/* symbol tables */
PERLVAR(I, debstash,	HV *)		/* symbol table for perldb package */
PERLVAR(I, globalstash,	HV *)		/* global keyword overrides imported here */
PERLVAR(I, curstname,	SV *)		/* name of current package */
PERLVAR(I, beginav,	AV *)		/* names of BEGIN subroutines */
PERLVAR(I, endav,	AV *)		/* names of END subroutines */
PERLVAR(I, unitcheckav,	AV *)		/* names of UNITCHECK subroutines */
PERLVAR(I, checkav,	AV *)		/* names of CHECK subroutines */
PERLVAR(I, initav,	AV *)		/* names of INIT subroutines */

/* subprocess state */
PERLVAR(I, fdpid,	AV *)		/* keep fd-to-pid mappings for my_popen */

/* internal state */
PERLVARI(I, op_mask,	char *,	NULL)	/* masked operations for safe evals */

/* current interpreter roots */
PERLVAR(I, main_cv,	CV *)
PERLVAR(I, main_root,	OP *)
PERLVAR(I, main_start,	OP *)
PERLVAR(I, eval_root,	OP *)
PERLVAR(I, eval_start,	OP *)

/* runtime control stuff */
PERLVARI(I, curcopdb,	COP *,	NULL)

PERLVAR(I, filemode,	int)		/* so nextargv() can preserve mode */
PERLVAR(I, lastfd,	int)		/* what to preserve mode on */
PERLVAR(I, oldname,	char *)		/* what to preserve mode on */
PERLVAR(I, Argv,	const char **)	/* stuff to free from do_aexec, vfork safe */
PERLVAR(I, Cmd,		char *)		/* stuff to free from do_aexec, vfork safe */
/* Elements in this array have ';' appended and are injected as a single line
   into the tokeniser. You can't put any (literal) newlines into any program
   you stuff in into this array, as the point where it's injected is expecting
   a single physical line. */
PERLVAR(I, preambleav,	AV *)
PERLVAR(I, mess_sv,	SV *)
PERLVAR(I, ors_sv,	SV *)		/* output record separator $\ */

/* funky return mechanisms */
PERLVAR(I, forkprocess,	int)		/* so do_open |- can return proc# */

/* statics moved here for shared library purposes */
PERLVARI(I, gensym,	I32,	0)	/* next symbol for getsym() to define */
PERLVARI(I, cv_has_eval, bool, FALSE)	/* PL_compcv includes an entereval or similar */
PERLVAR(I, taint_warn,	bool)		/* taint warns instead of dying */
PERLVARI(I, laststype,	U16,	OP_STAT)

PERLVARI(I, laststatval, int,	-1)

PERLVAR(I, modcount,	I32)		/* how much op_lvalue()ification in
					   assignment? */

/* interpreter atexit processing */
PERLVARI(I, exitlistlen, I32, 0)	/* length of same */
PERLVARI(I, exitlist,	PerlExitListEntry *, NULL)
					/* list of exit functions */

/*
=for apidoc Amn|HV*|PL_modglobal

C<PL_modglobal> is a general purpose, interpreter global HV for use by
extensions that need to keep information on a per-interpreter basis.
In a pinch, it can also be used as a symbol table for extensions
to share data among each other.  It is a good idea to use keys
prefixed by the package name of the extension that owns the data.

=cut
*/

PERLVAR(I, modglobal,	HV *)		/* per-interp module data */

/* these used to be in global before 5.004_68 */
PERLVARI(I, profiledata, U32 *,	NULL)	/* table of ops, counts */

PERLVAR(I, compiling,	COP)		/* compiling/done executing marker */

PERLVAR(I, compcv,	CV *)		/* currently compiling subroutine */
PERLVAR(I, comppad_name, PADNAMELIST *)	/* variable names for "my" variables */
PERLVAR(I, comppad_name_fill,	I32)	/* last "introduced" variable offset */
PERLVAR(I, comppad_name_floor,	I32)	/* start of vars in innermost block */

#ifdef HAVE_INTERP_INTERN
PERLVAR(I, sys_intern,	struct interp_intern)
					/* platform internals */
#endif

/* more statics moved here */
PERLVAR(I, DBcv,	CV *)		/* from perl.c */
PERLVARI(I, generation,	int,	100)	/* from op.c */

PERLVAR(I, unicode, U32)	/* Unicode features: $ENV{PERL_UNICODE} or -C */

PERLVARI(I, in_clean_objs,bool,    FALSE)	/* from sv.c */
PERLVARI(I, in_clean_all, bool,    FALSE)	/* ptrs to freed SVs now legal */
PERLVAR(I, nomemok,	bool)		/* let malloc context handle nomem */
PERLVARI(I, savebegin,	bool,	FALSE)	/* save BEGINs for compiler	*/


PERLVAR(I, delaymagic_uid,	Uid_t)	/* current real user id, only for delaymagic */
PERLVAR(I, delaymagic_euid,	Uid_t)	/* current effective user id, only for delaymagic */
PERLVAR(I, delaymagic_gid,	Gid_t)	/* current real group id, only for delaymagic */
PERLVAR(I, delaymagic_egid,	Gid_t)	/* current effective group id, only for delaymagic */
PERLVARI(I, an,		U32,	0)	/* malloc sequence number */

/* Perl_Ibreakable_sub_generation_ptr was too long for VMS, hence "gen"  */
PERLVARI(I, breakable_sub_gen, U32, 0)

#ifdef DEBUGGING
    /* exercise wrap-around */
    #define PERL_COP_SEQMAX (U32_MAX-50)
#else
    #define PERL_COP_SEQMAX 0
#endif
PERLVARI(I, cop_seqmax,	U32,	PERL_COP_SEQMAX) /* statement sequence number */
#undef PERL_COP_SEQMAX

PERLVARI(I, evalseq,	U32,	0)	/* eval sequence number */
PERLVAR(I, origalen,	U32)
PERLVAR(I, origenviron,	char **)
#ifdef PERL_USES_PL_PIDSTATUS
PERLVAR(I, pidstatus,	HV *)		/* pid-to-status mappings for waitpid */
#endif
PERLVAR(I, osname,	char *)		/* operating system */

PERLVAR(I, sighandlerp,	Sighandler_t)

PERLVARA(I, body_roots,	PERL_ARENA_ROOTS_SIZE, void*) /* array of body roots */

PERLVAR(I, debug,	VOL U32)	/* flags given to -D switch */

PERLVARI(I, maxo,	int,	MAXO)	/* maximum number of ops */

PERLVARI(I, runops,	runops_proc_t, RUNOPS_DEFAULT)

PERLVAR(I, subname,	SV *)		/* name of current subroutine */

PERLVAR(I, subline,	I32)		/* line this subroutine began on */
PERLVAR(I, min_intro_pending, I32)	/* start of vars to introduce */

PERLVAR(I, max_intro_pending, I32)	/* end of vars to introduce */
PERLVAR(I, padix,	I32)		/* max used index in current "register" pad */

PERLVAR(I, padix_floor,	I32)		/* how low may inner block reset padix */

#ifdef USE_LOCALE_COLLATE
PERLVAR(I, collation_name, char *)	/* Name of current collation */
PERLVAR(I, collxfrm_base, Size_t)	/* Basic overhead in *xfrm() */
PERLVARI(I, collxfrm_mult,Size_t, 2)	/* Expansion factor in *xfrm() */
PERLVARI(I, collation_ix, U32,	0)	/* Collation generation index */
PERLVARI(I, collation_standard, bool, TRUE)
					/* Assume simple collation */
#endif /* USE_LOCALE_COLLATE */

#ifdef PERL_SAWAMPERSAND
PERLVAR(I, sawampersand, U8)		/* must save all match strings */
#endif

PERLVAR(I, unsafe,	bool)
PERLVAR(I, colorset,	bool)		/* PERL_RE_COLORS env var is in use */

/* current phase the interpreter is in
   for ordering this structure to remove holes, we're assuming that this is 4
   bytes.  */
PERLVARI(I, phase,	enum perl_phase, PERL_PHASE_CONSTRUCT)

PERLVARI(I, in_load_module, bool, FALSE)	/* to prevent recursions in PerlIO_find_layer */

/* This value may be set when embedding for full cleanup  */
/* 0=none, 1=full, 2=full with checks */
/* mod_perl is special, and also assigns a meaning -1 */
PERLVARI(I, perl_destruct_level, signed char,	0)

#ifdef USE_LOCALE_NUMERIC

PERLVARI(I, numeric_standard, bool, TRUE)
					/* Assume simple numerics */
PERLVARI(I, numeric_local, bool, TRUE)
					/* Assume local numerics */
PERLVAR(I, numeric_name, char *)	/* Name of current numeric locale */
PERLVAR(I, numeric_radix_sv, SV *)	/* The radix separator if not '.' */

#endif /* !USE_LOCALE_NUMERIC */

/* Unicode inversion lists */
PERLVAR(I, Latin1,	SV *)
PERLVAR(I, UpperLatin1,	SV *)   /* Code points 128 - 255 */
PERLVAR(I, AboveLatin1,	SV *)

PERLVAR(I, NonL1NonFinalFold,   SV *)
PERLVAR(I, HasMultiCharFold,   SV *)

/* utf8 character class swashes */
PERLVAR(I, utf8_mark,	SV *)
PERLVAR(I, utf8_X_regular_begin, SV *)
PERLVAR(I, utf8_X_extend, SV *)
PERLVAR(I, utf8_toupper, SV *)
PERLVAR(I, utf8_totitle, SV *)
PERLVAR(I, utf8_tolower, SV *)
PERLVAR(I, utf8_tofold,	SV *)
PERLVAR(I, utf8_charname_begin, SV *)
PERLVAR(I, utf8_charname_continue, SV *)

PERLVARA(I, utf8_swash_ptrs, POSIX_SWASH_COUNT, SV *)
PERLVARA(I, Posix_ptrs, POSIX_CC_COUNT, SV *)
PERLVARA(I, XPosix_ptrs, POSIX_CC_COUNT, SV *)

PERLVAR(I, last_swash_hv, HV *)
PERLVAR(I, last_swash_tmps, U8 *)
PERLVAR(I, last_swash_slen, STRLEN)
PERLVARA(I, last_swash_key,UTF8_MAXBYTES-1, U8)
PERLVAR(I, last_swash_klen, U8)		/* Only needs to store 0-12  */

#ifdef FCRYPT
PERLVARI(I, cryptseen,	bool,	FALSE)	/* has fast crypt() been initialized? */
#else
/* One byte hole in the interpreter structure.  */
#endif

PERLVAR(I, pad_reset_pending, bool)	/* reset pad on next attempted alloc */
PERLVAR(I, srand_called, bool)

/* Array of signal handlers, indexed by signal number, through which the C
   signal handler dispatches.  */
PERLVAR(I, psig_ptr,	SV **)
/* Array of names of signals, indexed by signal number, for (re)use as the first
   argument to a signal handler.   Only one block of memory is allocated for
   both psig_name and psig_ptr.  */
PERLVAR(I, psig_name,	SV **)

#if defined(PERL_IMPLICIT_SYS)
PERLVAR(I, Mem,		struct IPerlMem *)
PERLVAR(I, MemShared,	struct IPerlMem *)
PERLVAR(I, MemParse,	struct IPerlMem *)
PERLVAR(I, Env,		struct IPerlEnv *)
PERLVAR(I, StdIO,	struct IPerlStdIO *)
PERLVAR(I, LIO,		struct IPerlLIO *)
PERLVAR(I, Dir,		struct IPerlDir *)
PERLVAR(I, Sock,	struct IPerlSock *)
PERLVAR(I, Proc,	struct IPerlProc *)
#endif

PERLVAR(I, ptr_table,	PTR_TBL_t *)
PERLVARI(I, beginav_save, AV *, NULL)	/* save BEGIN{}s when compiling */

PERLVAR(I, body_arenas, void *)		/* pointer to list of body-arenas */


#if defined(USE_ITHREADS)
PERLVAR(I, regex_pad,     SV **)	/* Shortcut into the array of
					   regex_padav */
PERLVAR(I, regex_padav,   AV *)		/* All regex objects, indexed via the
					   values in op_pmoffset of pmop.
					   Entry 0 is an SV whose PV is a
					   "packed" list of IVs listing
					   the now-free slots in the array */
PERLVAR(I, stashpad,    HV **)		/* for CopSTASH */
PERLVARI(I, stashpadmax, PADOFFSET, 64)
PERLVARI(I, stashpadix, PADOFFSET, 0)
#endif

#ifdef USE_REENTRANT_API
PERLVAR(I, reentrant_buffer, REENTR *)	/* here we store the _r buffers */
#endif

PERLVAR(I, custom_op_names, HV *)	/* Names of user defined ops */
PERLVAR(I, custom_op_descs, HV *)	/* Descriptions of user defined ops */

#ifdef PERLIO_LAYERS
PERLVARI(I, perlio,	PerlIOl *, NULL)
PERLVARI(I, known_layers, PerlIO_list_t *, NULL)
PERLVARI(I, def_layerlist, PerlIO_list_t *, NULL)
#endif

PERLVARI(I, encoding,	SV *,	NULL)	/* character encoding */

PERLVAR(I, utf8_idstart, SV *)
PERLVAR(I, utf8_idcont,	SV *)
PERLVAR(I, utf8_xidstart, SV *)
PERLVAR(I, utf8_perl_idstart, SV *)
PERLVAR(I, utf8_perl_idcont, SV *)
PERLVAR(I, utf8_xidcont, SV *)

PERLVAR(I, sort_RealCmp, SVCOMPARE_t)

PERLVARI(I, checkav_save, AV *, NULL)	/* save CHECK{}s when compiling */
PERLVARI(I, unitcheckav_save, AV *, NULL)
					/* save UNITCHECK{}s when compiling */

PERLVARI(I, clocktick,	long,	0)	/* this many times() ticks in a second */

/* Hooks to shared SVs and locks. */
PERLVARI(I, sharehook,	share_proc_t, Perl_sv_nosharing)
PERLVARI(I, lockhook,	share_proc_t, Perl_sv_nosharing)
#ifdef NO_MATHOMS
#  define PERL_UNLOCK_HOOK Perl_sv_nosharing
#else
/* This reference ensures that the mathoms are linked with perl */
#  define PERL_UNLOCK_HOOK Perl_sv_nounlocking
#endif
PERLVARI(I, unlockhook,	share_proc_t, PERL_UNLOCK_HOOK)

PERLVARI(I, threadhook,	thrhook_proc_t,	Perl_nothreadhook)

/* Can shared object be destroyed */
PERLVARI(I, destroyhook, destroyable_proc_t, Perl_sv_destroyable)

#ifndef PERL_MICRO
PERLVARI(I, signalhook,	despatch_signals_proc_t, Perl_despatch_signals)
#endif

PERLVARI(I, isarev, HV *, NULL)		/* Reverse map of @ISA dependencies */

/* Register of known Method Resolution Orders.
   What this actually points to is an implementation detail (it may change to
   a structure incorporating a reference count - use mro_get_from_name to
   retrieve a C<struct mro_alg *>  */
PERLVAR(I, registered_mros, HV *)

/* Compile-time block start/end hooks */
PERLVAR(I, blockhooks,	AV *)

/* Everything that folds to a given character, for case insensitivity regex
 * matching */
PERLVARI(I, utf8_foldclosures, HV *, NULL)

/* List of characters that participate in folds (except marks, etc in
 * multi-char folds) */
PERLVARI(I, utf8_foldable, SV *, NULL)

PERLVAR(I, custom_ops,	HV *)		/* custom op registrations */

PERLVAR(I, Xpv,		XPV *)		/* (unused) held temporary value */

/* name of the scopes we've ENTERed. Only used with -DDEBUGGING, but needs to be
   present always, as -DDEBUGGING must be binary compatible with non.  */
PERLVARI(I, scopestack_name, const char * *, NULL)

PERLVAR(I, debug_pad,	struct perl_debug_pad)	/* always needed because of the re extension */

/* Hook for File::Glob */
PERLVARI(I, globhook,	globhook_t, NULL)

/* The last unconditional member of the interpreter structure when 5.20.2 was
   released. The offset of the end of this is baked into a global variable in 
   any shared perl library which will allow a sanity test in future perl
   releases.  */
#define PERL_LAST_5_18_0_INTERP_MEMBER	Iglobhook

#ifdef PERL_IMPLICIT_CONTEXT
PERLVARI(I, my_cxt_list, void **, NULL) /* per-module array of MY_CXT pointers */
PERLVARI(I, my_cxt_size, int,	0)	/* size of PL_my_cxt_list */
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
PERLVARI(I, my_cxt_keys, const char **, NULL) /* per-module array of pointers to MY_CXT_KEY constants */
#  endif
#endif

#ifdef PERL_TRACK_MEMPOOL
/* For use with the memory debugging code in util.c  */
PERLVAR(I, memory_debug_header, struct perl_memory_debug_header)
#endif

#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
/* File descriptor to talk to the child which dumps scalars.  */
PERLVARI(I, dumper_fd,	int,	-1)
#endif

#ifdef PERL_MAD
PERLVARI(I, madskills,	bool,	FALSE)	/* preserve all syntactic info */
					/* (MAD = Misc Attribute Decoration) */
PERLVARI(I, xmlfp,	PerlIO *, NULL)
#endif

#ifdef DEBUG_LEAKING_SCALARS
PERLVARI(I, sv_serial,	U32,	0)	/* SV serial number, used in sv.c */
#endif

PERLVARA(I, sv_consts, SV_CONSTS_COUNT, SV*)	/* constant SVs with precomputed hash value */

#ifdef PERL_TRACE_OPS
PERLVARA(I, op_exec_cnt, OP_max+2, UV)	/* Counts of executed OPs of the given type.
                                           If PERL_TRACE_OPS is enabled, we'll dump
                                           a summary count of all ops executed in the
                                           program at perl_destruct time. For
                                           profiling/debugging only. Works only if
                                           DEBUGGING is enabled, too. */
#endif

PERLVAR(I, random_state, PL_RANDOM_STATE_TYPE)

/* If you are adding a U8 or U16, check to see if there are 'Space' comments
 * above on where there are gaps which currently will be structure padding.  */

/* Within a stable branch, new variables must be added to the very end, before
 * this comment, for binary compatibility (the offsets of the old members must
 *  not change).
 * (Don't forget to add your variable also to perl_clone()!)
 * XSUB.h provides wrapper functions via perlapi.h that make this
 * irrelevant, but not all code may be expected to #include XSUB.h.
 */
            usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/iperlsys.h                                                0100644 0000000 0000000 00000137210 12744441327 017763  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * iperlsys.h - Perl's interface to the system
 *
 * This file defines the system level functionality that perl needs.
 *
 * When using C, this definition is in the form of a set of macros
 * that can be #defined to the system-level function (or a wrapper
 * provided elsewhere).
 *
 * GSAR 21-JUN-98
 */

#ifndef __Inc__IPerl___
#define __Inc__IPerl___

/*
 *	PerlXXX_YYY explained - DickH and DougL @ ActiveState.com
 *
 * XXX := functional group
 * YYY := stdlib/OS function name
 *
 * Continuing with the theme of PerlIO, all OS functionality was
 * encapsulated into one of several interfaces.
 *
 * PerlIO - stdio
 * PerlLIO - low level I/O
 * PerlMem - malloc, realloc, free
 * PerlDir - directory related
 * PerlEnv - process environment handling
 * PerlProc - process control
 * PerlSock - socket functions
 *
 *
 * The features of this are:
 * 1. All OS dependant code is in the Perl Host and not the Perl Core.
 *    (At least this is the holy grail goal of this work)
 * 2. The Perl Host (see perl.h for description) can provide a new and
 *    improved interface to OS functionality if required.
 * 3. Developers can easily hook into the OS calls for instrumentation
 *    or diagnostic purposes.
 *
 * What was changed to do this:
 * 1. All calls to OS functions were replaced with PerlXXX_YYY
 *
 */

/*
    Interface for perl stdio functions, or whatever we are Configure-d
    to use.
*/
#include "perlio.h"

#ifndef Sighandler_t
#  if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
typedef Signal_t (*Sighandler_t) (int, siginfo_t*, void*);
#  else
typedef Signal_t (*Sighandler_t) (int);
#  endif
#endif

#if defined(PERL_IMPLICIT_SYS)

/* IPerlStdIO		*/
struct IPerlStdIO;
struct IPerlStdIOInfo;
typedef FILE*		(*LPStdin)(struct IPerlStdIO*);
typedef FILE*		(*LPStdout)(struct IPerlStdIO*);
typedef FILE*		(*LPStderr)(struct IPerlStdIO*);
typedef FILE*		(*LPOpen)(struct IPerlStdIO*, const char*,
			    const char*);
typedef int		(*LPClose)(struct IPerlStdIO*, FILE*);
typedef int		(*LPEof)(struct IPerlStdIO*, FILE*);
typedef int		(*LPError)(struct IPerlStdIO*, FILE*);
typedef void		(*LPClearerr)(struct IPerlStdIO*, FILE*);
typedef int		(*LPGetc)(struct IPerlStdIO*, FILE*);
typedef STDCHAR*	(*LPGetBase)(struct IPerlStdIO*, FILE*);
typedef int		(*LPGetBufsiz)(struct IPerlStdIO*, FILE*);
typedef int		(*LPGetCnt)(struct IPerlStdIO*, FILE*);
typedef STDCHAR*	(*LPGetPtr)(struct IPerlStdIO*, FILE*);
typedef char*		(*LPGets)(struct IPerlStdIO*, char*, int, FILE*);
typedef int		(*LPPutc)(struct IPerlStdIO*, int, FILE*);
typedef int		(*LPPuts)(struct IPerlStdIO*, const char *, FILE*);
typedef int		(*LPFlush)(struct IPerlStdIO*, FILE*);
typedef int		(*LPUngetc)(struct IPerlStdIO*, int,FILE*);
typedef int		(*LPFileno)(struct IPerlStdIO*, FILE*);
typedef FILE*		(*LPFdopen)(struct IPerlStdIO*, int, const char*);
typedef FILE*		(*LPReopen)(struct IPerlStdIO*, const char*,
			    const char*, FILE*);
typedef SSize_t		(*LPRead)(struct IPerlStdIO*, void*, Size_t, Size_t, FILE *);
typedef SSize_t		(*LPWrite)(struct IPerlStdIO*, const void*, Size_t, Size_t, FILE *);
typedef void		(*LPSetBuf)(struct IPerlStdIO*, FILE*, char*);
typedef int		(*LPSetVBuf)(struct IPerlStdIO*, FILE*, char*, int,
			    Size_t);
typedef void		(*LPSetCnt)(struct IPerlStdIO*, FILE*, int);

#ifndef NETWARE
typedef void		(*LPSetPtr)(struct IPerlStdIO*, FILE*, STDCHAR*);
#elif defined(NETWARE)
typedef void		(*LPSetPtr)(struct IPerlStdIO*, FILE*, STDCHAR*, int);
#endif

typedef void		(*LPSetlinebuf)(struct IPerlStdIO*, FILE*);
typedef int		(*LPPrintf)(struct IPerlStdIO*, FILE*, const char*,
			    ...);
typedef int		(*LPVprintf)(struct IPerlStdIO*, FILE*, const char*,
			    va_list);
typedef Off_t		(*LPTell)(struct IPerlStdIO*, FILE*);
typedef int		(*LPSeek)(struct IPerlStdIO*, FILE*, Off_t, int);
typedef void		(*LPRewind)(struct IPerlStdIO*, FILE*);
typedef FILE*		(*LPTmpfile)(struct IPerlStdIO*);
typedef int		(*LPGetpos)(struct IPerlStdIO*, FILE*, Fpos_t*);
typedef int		(*LPSetpos)(struct IPerlStdIO*, FILE*,
			    const Fpos_t*);
typedef void		(*LPInit)(struct IPerlStdIO*);
typedef void		(*LPInitOSExtras)(struct IPerlStdIO*);
typedef FILE*		(*LPFdupopen)(struct IPerlStdIO*, FILE*);

struct IPerlStdIO
{
    LPStdin		pStdin;
    LPStdout		pStdout;
    LPStderr		pStderr;
    LPOpen		pOpen;
    LPClose		pClose;
    LPEof		pEof;
    LPError		pError;
    LPClearerr		pClearerr;
    LPGetc		pGetc;
    LPGetBase		pGetBase;
    LPGetBufsiz		pGetBufsiz;
    LPGetCnt		pGetCnt;
    LPGetPtr		pGetPtr;
    LPGets		pGets;
    LPPutc		pPutc;
    LPPuts		pPuts;
    LPFlush		pFlush;
    LPUngetc		pUngetc;
    LPFileno		pFileno;
    LPFdopen		pFdopen;
    LPReopen		pReopen;
    LPRead		pRead;
    LPWrite		pWrite;
    LPSetBuf		pSetBuf;
    LPSetVBuf		pSetVBuf;
    LPSetCnt		pSetCnt;
    LPSetPtr		pSetPtr;
    LPSetlinebuf	pSetlinebuf;
    LPPrintf		pPrintf;
    LPVprintf		pVprintf;
    LPTell		pTell;
    LPSeek		pSeek;
    LPRewind		pRewind;
    LPTmpfile		pTmpfile;
    LPGetpos		pGetpos;
    LPSetpos		pSetpos;
    LPInit		pInit;
    LPInitOSExtras	pInitOSExtras;
    LPFdupopen		pFdupopen;
};

struct IPerlStdIOInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlStdIO	perlStdIOList;
};

/* These do not belong here ... NI-S, 14 Nov 2000 */

#ifdef USE_STDIO_PTR
#  define PerlSIO_has_cntptr(f)		1
#  ifdef STDIO_PTR_LVALUE
#    ifdef  STDIO_CNT_LVALUE
#      define PerlSIO_canset_cnt(f)	1
#      ifdef STDIO_PTR_LVAL_NOCHANGE_CNT
#        define PerlSIO_fast_gets(f)	1
#      endif
#    else /* STDIO_CNT_LVALUE */
#      define PerlSIO_canset_cnt(f)	0
#    endif
#  else /* STDIO_PTR_LVALUE */
#    ifdef STDIO_PTR_LVAL_SETS_CNT
#      define PerlSIO_fast_gets(f)	1
#    endif
#  endif
#else  /* USE_STDIO_PTR */
#  define PerlSIO_has_cntptr(f)		0
#  define PerlSIO_canset_cnt(f)		0
#endif /* USE_STDIO_PTR */

#ifndef PerlSIO_fast_gets
#define PerlSIO_fast_gets(f)		0
#endif

#ifdef FILE_base
#define PerlSIO_has_base(f)		1
#else
#define PerlSIO_has_base(f)		0
#endif

/* Now take FILE * via function table */

#define PerlSIO_stdin							\
	(*PL_StdIO->pStdin)(PL_StdIO)
#define PerlSIO_stdout							\
	(*PL_StdIO->pStdout)(PL_StdIO)
#define PerlSIO_stderr							\
	(*PL_StdIO->pStderr)(PL_StdIO)
#define PerlSIO_fopen(x,y)						\
	(*PL_StdIO->pOpen)(PL_StdIO, (x),(y))
#define PerlSIO_fclose(f)						\
	(*PL_StdIO->pClose)(PL_StdIO, (f))
#define PerlSIO_feof(f)							\
	(*PL_StdIO->pEof)(PL_StdIO, (f))
#define PerlSIO_ferror(f)						\
	(*PL_StdIO->pError)(PL_StdIO, (f))
#define PerlSIO_clearerr(f)						\
	(*PL_StdIO->pClearerr)(PL_StdIO, (f))
#define PerlSIO_fgetc(f)						\
	(*PL_StdIO->pGetc)(PL_StdIO, (f))
#define PerlSIO_get_base(f)						\
	(*PL_StdIO->pGetBase)(PL_StdIO, (f))
#define PerlSIO_get_bufsiz(f)						\
	(*PL_StdIO->pGetBufsiz)(PL_StdIO, (f))
#define PerlSIO_get_cnt(f)						\
	(*PL_StdIO->pGetCnt)(PL_StdIO, (f))
#define PerlSIO_get_ptr(f)						\
	(*PL_StdIO->pGetPtr)(PL_StdIO, (f))
#define PerlSIO_fputc(c,f)			\
	(*PL_StdIO->pPutc)(PL_StdIO, (c),(f))
#define PerlSIO_fputs(s,f)			\
	(*PL_StdIO->pPuts)(PL_StdIO, (s),(f))
#define PerlSIO_fflush(f)						\
	(*PL_StdIO->pFlush)(PL_StdIO, (f))
#define PerlSIO_fgets(s, n, f)						\
	(*PL_StdIO->pGets)(PL_StdIO, s, n, (f))
#define PerlSIO_ungetc(c,f)						\
	(*PL_StdIO->pUngetc)(PL_StdIO, (c),(f))
#define PerlSIO_fileno(f)						\
	(*PL_StdIO->pFileno)(PL_StdIO, (f))
#define PerlSIO_fdopen(f, s)						\
	(*PL_StdIO->pFdopen)(PL_StdIO, (f),(s))
#define PerlSIO_freopen(p, m, f)					\
	(*PL_StdIO->pReopen)(PL_StdIO, (p), (m), (f))
#define PerlSIO_fread(buf,sz,count,f)					\
	(*PL_StdIO->pRead)(PL_StdIO, (buf), (sz), (count), (f))
#define PerlSIO_fwrite(buf,sz,count,f)					\
	(*PL_StdIO->pWrite)(PL_StdIO, (buf), (sz), (count), (f))
#define PerlSIO_setbuf(f,b)						\
	(*PL_StdIO->pSetBuf)(PL_StdIO, (f), (b))
#define PerlSIO_setvbuf(f,b,t,s)					\
	(*PL_StdIO->pSetVBuf)(PL_StdIO, (f),(b),(t),(s))
#define PerlSIO_set_cnt(f,c)						\
	(*PL_StdIO->pSetCnt)(PL_StdIO, (f), (c))
#define PerlSIO_set_ptr(f,p)						\
	(*PL_StdIO->pSetPtr)(PL_StdIO, (f), (p))
#define PerlSIO_setlinebuf(f)						\
	(*PL_StdIO->pSetlinebuf)(PL_StdIO, (f))
#define PerlSIO_printf		Perl_fprintf_nocontext
#define PerlSIO_stdoutf		Perl_printf_nocontext
#define PerlSIO_vprintf(f,fmt,a)						\
	(*PL_StdIO->pVprintf)(PL_StdIO, (f),(fmt),a)
#define PerlSIO_ftell(f)							\
	(*PL_StdIO->pTell)(PL_StdIO, (f))
#define PerlSIO_fseek(f,o,w)						\
	(*PL_StdIO->pSeek)(PL_StdIO, (f),(o),(w))
#define PerlSIO_fgetpos(f,p)						\
	(*PL_StdIO->pGetpos)(PL_StdIO, (f),(p))
#define PerlSIO_fsetpos(f,p)						\
	(*PL_StdIO->pSetpos)(PL_StdIO, (f),(p))
#define PerlSIO_rewind(f)						\
	(*PL_StdIO->pRewind)(PL_StdIO, (f))
#define PerlSIO_tmpfile()						\
	(*PL_StdIO->pTmpfile)(PL_StdIO)
#define PerlSIO_init()							\
	(*PL_StdIO->pInit)(PL_StdIO)
#undef 	init_os_extras
#define init_os_extras()						\
	(*PL_StdIO->pInitOSExtras)(PL_StdIO)
#define PerlSIO_fdupopen(f)						\
	(*PL_StdIO->pFdupopen)(PL_StdIO, (f))

#else	/* PERL_IMPLICIT_SYS */

#define PerlSIO_stdin			stdin
#define PerlSIO_stdout			stdout
#define PerlSIO_stderr			stderr
#define PerlSIO_fopen(x,y)		fopen(x,y)
#ifdef __VOS__
/* Work around VOS bug posix-979, wrongly setting errno when at end of file. */
#define PerlSIO_fclose(f)		(((errno==1025)?errno=0:0),fclose(f))
#define PerlSIO_feof(f)			(((errno==1025)?errno=0:0),feof(f))
#define PerlSIO_ferror(f)		(((errno==1025)?errno=0:0),ferror(f))
#else
#define PerlSIO_fclose(f)		fclose(f)
#define PerlSIO_feof(f)			feof(f)
#define PerlSIO_ferror(f)		ferror(f)
#endif
#define PerlSIO_clearerr(f)		clearerr(f)
#define PerlSIO_fgetc(f)			fgetc(f)
#ifdef FILE_base
#define PerlSIO_get_base(f)		FILE_base(f)
#define PerlSIO_get_bufsiz(f)		FILE_bufsiz(f)
#else
#define PerlSIO_get_base(f)		NULL
#define PerlSIO_get_bufsiz(f)		0
#endif
#ifdef USE_STDIO_PTR
#define PerlSIO_get_cnt(f)		FILE_cnt(f)
#define PerlSIO_get_ptr(f)		FILE_ptr(f)
#else
#define PerlSIO_get_cnt(f)		0
#define PerlSIO_get_ptr(f)		NULL
#endif
#define PerlSIO_fputc(c,f)		fputc(c,f)
#define PerlSIO_fputs(s,f)		fputs(s,f)
#define PerlSIO_fflush(f)		Fflush(f)
#define PerlSIO_fgets(s, n, f)		fgets(s,n,f)
#if defined(VMS) && defined(__DECC)
     /* Unusual definition of ungetc() here to accommodate fast_sv_gets()'
      * belief that it can mix getc/ungetc with reads from stdio buffer */
     int decc$ungetc(int __c, FILE *__stream);
#    define PerlSIO_ungetc(c,f) ((c) == EOF ? EOF : \
            ((*(f) && !((*(f))->_flag & _IONBF) && \
            ((*(f))->_ptr > (*(f))->_base)) ? \
            ((*(f))->_cnt++, *(--(*(f))->_ptr) = (c)) : decc$ungetc(c,f)))
#else
#  define PerlSIO_ungetc(c,f)          ungetc(c,f)
#endif
#define PerlSIO_fileno(f)		fileno(f)
#define PerlSIO_fdopen(f, s)		fdopen(f,s)
#define PerlSIO_freopen(p, m, f)	freopen(p,m,f)
#define PerlSIO_fread(buf,sz,count,f)	fread(buf,sz,count,f)
#define PerlSIO_fwrite(buf,sz,count,f)	fwrite(buf,sz,count,f)
#define PerlSIO_setbuf(f,b)		setbuf(f,b)
#define PerlSIO_setvbuf(f,b,t,s)	setvbuf(f,b,t,s)
#if defined(USE_STDIO_PTR) && defined(STDIO_CNT_LVALUE)
#define PerlSIO_set_cnt(f,c)		FILE_cnt(f) = (c)
#else
#define PerlSIO_set_cnt(f,c)		PerlIOProc_abort()
#endif
#if defined(USE_STDIO_PTR) && defined(STDIO_PTR_LVALUE)
#define PerlSIO_set_ptr(f,p)		(FILE_ptr(f) = (p))
#else
#define PerlSIO_set_ptr(f,p)		PerlIOProc_abort()
#endif
#define PerlSIO_setlinebuf(f)		setlinebuf(f)
#define PerlSIO_printf			fprintf
#define PerlSIO_stdoutf			printf
#define PerlSIO_vprintf(f,fmt,a)	vfprintf(f,fmt,a)
#define PerlSIO_ftell(f)		ftell(f)
#define PerlSIO_fseek(f,o,w)		fseek(f,o,w)
#define PerlSIO_fgetpos(f,p)		fgetpos(f,p)
#define PerlSIO_fsetpos(f,p)		fsetpos(f,p)
#define PerlSIO_rewind(f)		rewind(f)
#define PerlSIO_tmpfile()		tmpfile()
#define PerlSIO_fdupopen(f)		(f)

#endif	/* PERL_IMPLICIT_SYS */

/*
 *   Interface for directory functions
 */

#if defined(PERL_IMPLICIT_SYS)

/* IPerlDir		*/
struct IPerlDir;
struct IPerlDirInfo;
typedef int		(*LPMakedir)(struct IPerlDir*, const char*, int);
typedef int		(*LPChdir)(struct IPerlDir*, const char*);
typedef int		(*LPRmdir)(struct IPerlDir*, const char*);
typedef int		(*LPDirClose)(struct IPerlDir*, DIR*);
typedef DIR*		(*LPDirOpen)(struct IPerlDir*, const char*);
typedef struct direct*	(*LPDirRead)(struct IPerlDir*, DIR*);
typedef void		(*LPDirRewind)(struct IPerlDir*, DIR*);
typedef void		(*LPDirSeek)(struct IPerlDir*, DIR*, long);
typedef long		(*LPDirTell)(struct IPerlDir*, DIR*);
#ifdef WIN32
typedef char*		(*LPDirMapPathA)(struct IPerlDir*, const char*);
typedef WCHAR*		(*LPDirMapPathW)(struct IPerlDir*, const WCHAR*);
#endif

struct IPerlDir
{
    LPMakedir		pMakedir;
    LPChdir		pChdir;
    LPRmdir		pRmdir;
    LPDirClose		pClose;
    LPDirOpen		pOpen;
    LPDirRead		pRead;
    LPDirRewind		pRewind;
    LPDirSeek		pSeek;
    LPDirTell		pTell;
#ifdef WIN32
    LPDirMapPathA	pMapPathA;
    LPDirMapPathW	pMapPathW;
#endif
};

struct IPerlDirInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlDir	perlDirList;
};

#define PerlDir_mkdir(name, mode)				\
	(*PL_Dir->pMakedir)(PL_Dir, (name), (mode))
#define PerlDir_chdir(name)					\
	(*PL_Dir->pChdir)(PL_Dir, (name))
#define PerlDir_rmdir(name)					\
	(*PL_Dir->pRmdir)(PL_Dir, (name))
#define PerlDir_close(dir)					\
	(*PL_Dir->pClose)(PL_Dir, (dir))
#define PerlDir_open(name)					\
	(*PL_Dir->pOpen)(PL_Dir, (name))
#define PerlDir_read(dir)					\
	(*PL_Dir->pRead)(PL_Dir, (dir))
#define PerlDir_rewind(dir)					\
	(*PL_Dir->pRewind)(PL_Dir, (dir))
#define PerlDir_seek(dir, loc)					\
	(*PL_Dir->pSeek)(PL_Dir, (dir), (loc))
#define PerlDir_tell(dir)					\
	(*PL_Dir->pTell)(PL_Dir, (dir))
#ifdef WIN32
#define PerlDir_mapA(dir)					\
	(*PL_Dir->pMapPathA)(PL_Dir, (dir))
#define PerlDir_mapW(dir)					\
	(*PL_Dir->pMapPathW)(PL_Dir, (dir))
#endif

#else	/* PERL_IMPLICIT_SYS */

#define PerlDir_mkdir(name, mode)	Mkdir((name), (mode))
#ifdef VMS
#  define PerlDir_chdir(n)		Chdir((n))
#else
#  define PerlDir_chdir(name)		chdir((name))
#endif
#define PerlDir_rmdir(name)		rmdir((name))
#define PerlDir_close(dir)		closedir((dir))
#define PerlDir_open(name)		opendir((name))
#define PerlDir_read(dir)		readdir((dir))
#define PerlDir_rewind(dir)		rewinddir((dir))
#define PerlDir_seek(dir, loc)		seekdir((dir), (loc))
#define PerlDir_tell(dir)		telldir((dir))
#ifdef WIN32
#define PerlDir_mapA(dir)		dir
#define PerlDir_mapW(dir)		dir
#endif

#endif	/* PERL_IMPLICIT_SYS */

/*
    Interface for perl environment functions
*/

#if defined(PERL_IMPLICIT_SYS)

/* IPerlEnv		*/
struct IPerlEnv;
struct IPerlEnvInfo;
typedef char*		(*LPEnvGetenv)(struct IPerlEnv*, const char*);
typedef int		(*LPEnvPutenv)(struct IPerlEnv*, const char*);
typedef char*		(*LPEnvGetenv_len)(struct IPerlEnv*,
				    const char *varname, unsigned long *len);
typedef int		(*LPEnvUname)(struct IPerlEnv*, struct utsname *name);
typedef void		(*LPEnvClearenv)(struct IPerlEnv*);
typedef void*		(*LPEnvGetChildenv)(struct IPerlEnv*);
typedef void		(*LPEnvFreeChildenv)(struct IPerlEnv*, void* env);
typedef char*		(*LPEnvGetChilddir)(struct IPerlEnv*);
typedef void		(*LPEnvFreeChilddir)(struct IPerlEnv*, char* dir);
#ifdef HAS_ENVGETENV
typedef char*		(*LPENVGetenv)(struct IPerlEnv*, const char *varname);
typedef char*		(*LPENVGetenv_len)(struct IPerlEnv*,
				    const char *varname, unsigned long *len);
#endif
#ifdef WIN32
typedef unsigned long	(*LPEnvOsID)(struct IPerlEnv*);
typedef char*		(*LPEnvLibPath)(struct IPerlEnv*, const char*,
					STRLEN *const len);
typedef char*		(*LPEnvSiteLibPath)(struct IPerlEnv*, const char*,
					    STRLEN *const len);
typedef char*		(*LPEnvVendorLibPath)(struct IPerlEnv*, const char*,
					      STRLEN *const len);
typedef void		(*LPEnvGetChildIO)(struct IPerlEnv*, child_IO_table*);
#endif

struct IPerlEnv
{
    LPEnvGetenv		pGetenv;
    LPEnvPutenv		pPutenv;
    LPEnvGetenv_len	pGetenv_len;
    LPEnvUname		pEnvUname;
    LPEnvClearenv	pClearenv;
    LPEnvGetChildenv	pGetChildenv;
    LPEnvFreeChildenv	pFreeChildenv;
    LPEnvGetChilddir	pGetChilddir;
    LPEnvFreeChilddir	pFreeChilddir;
#ifdef HAS_ENVGETENV
    LPENVGetenv		pENVGetenv;
    LPENVGetenv_len	pENVGetenv_len;
#endif
#ifdef WIN32
    LPEnvOsID		pEnvOsID;
    LPEnvLibPath	pLibPath;
    LPEnvSiteLibPath	pSiteLibPath;
    LPEnvVendorLibPath	pVendorLibPath;
    LPEnvGetChildIO	pGetChildIO;
#endif
};

struct IPerlEnvInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlEnv	perlEnvList;
};

#define PerlEnv_putenv(str)					\
	(*PL_Env->pPutenv)(PL_Env,(str))
#define PerlEnv_getenv(str)					\
	(*PL_Env->pGetenv)(PL_Env,(str))
#define PerlEnv_getenv_len(str,l)				\
	(*PL_Env->pGetenv_len)(PL_Env,(str), (l))
#define PerlEnv_clearenv()					\
	(*PL_Env->pClearenv)(PL_Env)
#define PerlEnv_get_childenv()					\
	(*PL_Env->pGetChildenv)(PL_Env)
#define PerlEnv_free_childenv(e)				\
	(*PL_Env->pFreeChildenv)(PL_Env, (e))
#define PerlEnv_get_childdir()					\
	(*PL_Env->pGetChilddir)(PL_Env)
#define PerlEnv_free_childdir(d)				\
	(*PL_Env->pFreeChilddir)(PL_Env, (d))
#ifdef HAS_ENVGETENV
#  define PerlEnv_ENVgetenv(str)				\
	(*PL_Env->pENVGetenv)(PL_Env,(str))
#  define PerlEnv_ENVgetenv_len(str,l)				\
	(*PL_Env->pENVGetenv_len)(PL_Env,(str), (l))
#else
#  define PerlEnv_ENVgetenv(str)				\
	PerlEnv_getenv((str))
#  define PerlEnv_ENVgetenv_len(str,l)				\
	PerlEnv_getenv_len((str),(l))
#endif
#define PerlEnv_uname(name)					\
	(*PL_Env->pEnvUname)(PL_Env,(name))
#ifdef WIN32
#define PerlEnv_os_id()						\
	(*PL_Env->pEnvOsID)(PL_Env)
#define PerlEnv_lib_path(str, lenp)				\
	(*PL_Env->pLibPath)(PL_Env,(str),(lenp))
#define PerlEnv_sitelib_path(str, lenp)				\
	(*PL_Env->pSiteLibPath)(PL_Env,(str),(lenp))
#define PerlEnv_vendorlib_path(str, lenp)			\
	(*PL_Env->pVendorLibPath)(PL_Env,(str),(lenp))
#define PerlEnv_get_child_IO(ptr)				\
	(*PL_Env->pGetChildIO)(PL_Env, ptr)
#endif

#else	/* PERL_IMPLICIT_SYS */

#define PerlEnv_putenv(str)		putenv((str))
#define PerlEnv_getenv(str)		getenv((str))
#define PerlEnv_getenv_len(str,l)	getenv_len((str), (l))
#ifdef HAS_ENVGETENV
#  define PerlEnv_ENVgetenv(str)	ENVgetenv((str))
#  define PerlEnv_ENVgetenv_len(str,l)	ENVgetenv_len((str), (l))
#else
#  define PerlEnv_ENVgetenv(str)	PerlEnv_getenv((str))
#  define PerlEnv_ENVgetenv_len(str,l)	PerlEnv_getenv_len((str), (l))
#endif
#define PerlEnv_uname(name)		uname((name))

#ifdef WIN32
#define PerlEnv_os_id()			win32_os_id()
#define PerlEnv_lib_path(str, lenp)	win32_get_privlib(str, lenp)
#define PerlEnv_sitelib_path(str, lenp)	win32_get_sitelib(str, lenp)
#define PerlEnv_vendorlib_path(str, lenp)	win32_get_vendorlib(str, lenp)
#define PerlEnv_get_child_IO(ptr)	win32_get_child_IO(ptr)
#define PerlEnv_clearenv()		win32_clearenv()
#define PerlEnv_get_childenv()		win32_get_childenv()
#define PerlEnv_free_childenv(e)	win32_free_childenv((e))
#define PerlEnv_get_childdir()		win32_get_childdir()
#define PerlEnv_free_childdir(d)	win32_free_childdir((d))
#else
#define PerlEnv_clearenv()		clearenv()
#define PerlEnv_get_childenv()		get_childenv()
#define PerlEnv_free_childenv(e)	free_childenv((e))
#define PerlEnv_get_childdir()		get_childdir()
#define PerlEnv_free_childdir(d)	free_childdir((d))
#endif

#endif	/* PERL_IMPLICIT_SYS */

/*
    Interface for perl low-level IO functions
*/

#if defined(PERL_IMPLICIT_SYS)

/* IPerlLIO		*/
struct IPerlLIO;
struct IPerlLIOInfo;
typedef int		(*LPLIOAccess)(struct IPerlLIO*, const char*, int);
typedef int		(*LPLIOChmod)(struct IPerlLIO*, const char*, int);
typedef int		(*LPLIOChown)(struct IPerlLIO*, const char*, uid_t,
			    gid_t);
typedef int		(*LPLIOChsize)(struct IPerlLIO*, int, Off_t);
typedef int		(*LPLIOClose)(struct IPerlLIO*, int);
typedef int		(*LPLIODup)(struct IPerlLIO*, int);
typedef int		(*LPLIODup2)(struct IPerlLIO*, int, int);
typedef int		(*LPLIOFlock)(struct IPerlLIO*, int, int);
typedef int		(*LPLIOFileStat)(struct IPerlLIO*, int, Stat_t*);
typedef int		(*LPLIOIOCtl)(struct IPerlLIO*, int, unsigned int,
			    char*);
typedef int		(*LPLIOIsatty)(struct IPerlLIO*, int);
typedef int		(*LPLIOLink)(struct IPerlLIO*, const char*,
				     const char *);
typedef Off_t		(*LPLIOLseek)(struct IPerlLIO*, int, Off_t, int);
typedef int		(*LPLIOLstat)(struct IPerlLIO*, const char*,
			    Stat_t*);
typedef char*		(*LPLIOMktemp)(struct IPerlLIO*, char*);
typedef int		(*LPLIOOpen)(struct IPerlLIO*, const char*, int);	
typedef int		(*LPLIOOpen3)(struct IPerlLIO*, const char*, int, int);	
typedef int		(*LPLIORead)(struct IPerlLIO*, int, void*, unsigned int);
typedef int		(*LPLIORename)(struct IPerlLIO*, const char*,
			    const char*);
#ifdef NETWARE
typedef int		(*LPLIOSetmode)(struct IPerlLIO*, FILE*, int);
#else
typedef int		(*LPLIOSetmode)(struct IPerlLIO*, int, int);
#endif	/* NETWARE */
typedef int		(*LPLIONameStat)(struct IPerlLIO*, const char*,
			    Stat_t*);
typedef char*		(*LPLIOTmpnam)(struct IPerlLIO*, char*);
typedef int		(*LPLIOUmask)(struct IPerlLIO*, int);
typedef int		(*LPLIOUnlink)(struct IPerlLIO*, const char*);
typedef int		(*LPLIOUtime)(struct IPerlLIO*, const char*, struct utimbuf*);
typedef int		(*LPLIOWrite)(struct IPerlLIO*, int, const void*,
			    unsigned int);

struct IPerlLIO
{
    LPLIOAccess		pAccess;
    LPLIOChmod		pChmod;
    LPLIOChown		pChown;
    LPLIOChsize		pChsize;
    LPLIOClose		pClose;
    LPLIODup		pDup;
    LPLIODup2		pDup2;
    LPLIOFlock		pFlock;
    LPLIOFileStat	pFileStat;
    LPLIOIOCtl		pIOCtl;
    LPLIOIsatty		pIsatty;
    LPLIOLink		pLink;
    LPLIOLseek		pLseek;
    LPLIOLstat		pLstat;
    LPLIOMktemp		pMktemp;
    LPLIOOpen		pOpen;
    LPLIOOpen3		pOpen3;
    LPLIORead		pRead;
    LPLIORename		pRename;
    LPLIOSetmode	pSetmode;
    LPLIONameStat	pNameStat;
    LPLIOTmpnam		pTmpnam;
    LPLIOUmask		pUmask;
    LPLIOUnlink		pUnlink;
    LPLIOUtime		pUtime;
    LPLIOWrite		pWrite;
};

struct IPerlLIOInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlLIO	perlLIOList;
};

#define PerlLIO_access(file, mode)					\
	(*PL_LIO->pAccess)(PL_LIO, (file), (mode))
#define PerlLIO_chmod(file, mode)					\
	(*PL_LIO->pChmod)(PL_LIO, (file), (mode))
#define PerlLIO_chown(file, owner, group)				\
	(*PL_LIO->pChown)(PL_LIO, (file), (owner), (group))
#define PerlLIO_chsize(fd, size)					\
	(*PL_LIO->pChsize)(PL_LIO, (fd), (size))
#define PerlLIO_close(fd)						\
	(*PL_LIO->pClose)(PL_LIO, (fd))
#define PerlLIO_dup(fd)							\
	(*PL_LIO->pDup)(PL_LIO, (fd))
#define PerlLIO_dup2(fd1, fd2)						\
	(*PL_LIO->pDup2)(PL_LIO, (fd1), (fd2))
#define PerlLIO_flock(fd, op)						\
	(*PL_LIO->pFlock)(PL_LIO, (fd), (op))
#define PerlLIO_fstat(fd, buf)						\
	(*PL_LIO->pFileStat)(PL_LIO, (fd), (buf))
#define PerlLIO_ioctl(fd, u, buf)					\
	(*PL_LIO->pIOCtl)(PL_LIO, (fd), (u), (buf))
#define PerlLIO_isatty(fd)						\
	(*PL_LIO->pIsatty)(PL_LIO, (fd))
#define PerlLIO_link(oldname, newname)					\
	(*PL_LIO->pLink)(PL_LIO, (oldname), (newname))
#define PerlLIO_lseek(fd, offset, mode)					\
	(*PL_LIO->pLseek)(PL_LIO, (fd), (offset), (mode))
#define PerlLIO_lstat(name, buf)					\
	(*PL_LIO->pLstat)(PL_LIO, (name), (buf))
#define PerlLIO_mktemp(file)						\
	(*PL_LIO->pMktemp)(PL_LIO, (file))
#define PerlLIO_open(file, flag)					\
	(*PL_LIO->pOpen)(PL_LIO, (file), (flag))
#define PerlLIO_open3(file, flag, perm)					\
	(*PL_LIO->pOpen3)(PL_LIO, (file), (flag), (perm))
#define PerlLIO_read(fd, buf, count)					\
	(*PL_LIO->pRead)(PL_LIO, (fd), (buf), (count))
#define PerlLIO_rename(oname, newname)					\
	(*PL_LIO->pRename)(PL_LIO, (oname), (newname))
#define PerlLIO_setmode(fd, mode)					\
	(*PL_LIO->pSetmode)(PL_LIO, (fd), (mode))
#define PerlLIO_stat(name, buf)						\
	(*PL_LIO->pNameStat)(PL_LIO, (name), (buf))
#define PerlLIO_tmpnam(str)						\
	(*PL_LIO->pTmpnam)(PL_LIO, (str))
#define PerlLIO_umask(mode)						\
	(*PL_LIO->pUmask)(PL_LIO, (mode))
#define PerlLIO_unlink(file)						\
	(*PL_LIO->pUnlink)(PL_LIO, (file))
#define PerlLIO_utime(file, time)					\
	(*PL_LIO->pUtime)(PL_LIO, (file), (time))
#define PerlLIO_write(fd, buf, count)					\
	(*PL_LIO->pWrite)(PL_LIO, (fd), (buf), (count))

#else	/* PERL_IMPLICIT_SYS */

#define PerlLIO_access(file, mode)	access((file), (mode))
#define PerlLIO_chmod(file, mode)	chmod((file), (mode))
#define PerlLIO_chown(file, owner, grp)	chown((file), (owner), (grp))
#if defined(HAS_TRUNCATE)
#  define PerlLIO_chsize(fd, size)	ftruncate((fd), (size))
#elif defined(HAS_CHSIZE)
#  define PerlLIO_chsize(fd, size)	chsize((fd), (size))
#else
#  define PerlLIO_chsize(fd, size)	my_chsize((fd), (size))
#endif
#define PerlLIO_close(fd)		close((fd))
#define PerlLIO_dup(fd)			dup((fd))
#define PerlLIO_dup2(fd1, fd2)		dup2((fd1), (fd2))
#define PerlLIO_flock(fd, op)		FLOCK((fd), (op))
#define PerlLIO_fstat(fd, buf)		Fstat((fd), (buf))
#define PerlLIO_ioctl(fd, u, buf)	ioctl((fd), (u), (buf))
#define PerlLIO_isatty(fd)		isatty((fd))
#define PerlLIO_link(oldname, newname)	link((oldname), (newname))
#define PerlLIO_lseek(fd, offset, mode)	lseek((fd), (offset), (mode))
#define PerlLIO_stat(name, buf)		Stat((name), (buf))
#ifdef HAS_LSTAT
#  define PerlLIO_lstat(name, buf)	lstat((name), (buf))
#else
#  define PerlLIO_lstat(name, buf)	PerlLIO_stat((name), (buf))
#endif
#define PerlLIO_mktemp(file)		mktemp((file))
#define PerlLIO_mkstemp(file)		mkstemp((file))
#define PerlLIO_open(file, flag)	open((file), (flag))
#define PerlLIO_open3(file, flag, perm)	open((file), (flag), (perm))
#define PerlLIO_read(fd, buf, count)	read((fd), (buf), (count))
#define PerlLIO_rename(old, new)	rename((old), (new))
#define PerlLIO_setmode(fd, mode)	setmode((fd), (mode))
#define PerlLIO_tmpnam(str)		tmpnam((str))
#define PerlLIO_umask(mode)		umask((mode))
#define PerlLIO_unlink(file)		unlink((file))
#define PerlLIO_utime(file, time)	utime((file), (time))
#define PerlLIO_write(fd, buf, count)	write((fd), (buf), (count))

#endif	/* PERL_IMPLICIT_SYS */

/*
    Interface for perl memory allocation
*/

#if defined(PERL_IMPLICIT_SYS)

/* IPerlMem		*/
struct IPerlMem;
struct IPerlMemInfo;
typedef void*		(*LPMemMalloc)(struct IPerlMem*, size_t);
typedef void*		(*LPMemRealloc)(struct IPerlMem*, void*, size_t);
typedef void		(*LPMemFree)(struct IPerlMem*, void*);
typedef void*		(*LPMemCalloc)(struct IPerlMem*, size_t, size_t);
typedef void		(*LPMemGetLock)(struct IPerlMem*);
typedef void		(*LPMemFreeLock)(struct IPerlMem*);
typedef int		(*LPMemIsLocked)(struct IPerlMem*);

struct IPerlMem
{
    LPMemMalloc		pMalloc;
    LPMemRealloc	pRealloc;
    LPMemFree		pFree;
    LPMemCalloc		pCalloc;
    LPMemGetLock	pGetLock;
    LPMemFreeLock	pFreeLock;
    LPMemIsLocked	pIsLocked;
};

struct IPerlMemInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlMem	perlMemList;
};

/* Interpreter specific memory macros */
#define PerlMem_malloc(size)				    \
	(*PL_Mem->pMalloc)(PL_Mem, (size))
#define PerlMem_realloc(buf, size)			    \
	(*PL_Mem->pRealloc)(PL_Mem, (buf), (size))
#define PerlMem_free(buf)				    \
	(*PL_Mem->pFree)(PL_Mem, (buf))
#define PerlMem_calloc(num, size)			    \
	(*PL_Mem->pCalloc)(PL_Mem, (num), (size))
#define PerlMem_get_lock()				    \
	(*PL_Mem->pGetLock)(PL_Mem)
#define PerlMem_free_lock()				    \
	(*PL_Mem->pFreeLock)(PL_Mem)
#define PerlMem_is_locked()				    \
	(*PL_Mem->pIsLocked)(PL_Mem)

/* Shared memory macros */
#ifdef NETWARE

#define PerlMemShared_malloc(size)			    \
	(*PL_Mem->pMalloc)(PL_Mem, (size))
#define PerlMemShared_realloc(buf, size)		    \
	(*PL_Mem->pRealloc)(PL_Mem, (buf), (size))
#define PerlMemShared_free(buf)				    \
	(*PL_Mem->pFree)(PL_Mem, (buf))
#define PerlMemShared_calloc(num, size)			    \
	(*PL_Mem->pCalloc)(PL_Mem, (num), (size))
#define PerlMemShared_get_lock()			    \
	(*PL_Mem->pGetLock)(PL_Mem)
#define PerlMemShared_free_lock()			    \
	(*PL_Mem->pFreeLock)(PL_Mem)
#define PerlMemShared_is_locked()			    \
	(*PL_Mem->pIsLocked)(PL_Mem)

#else

#define PerlMemShared_malloc(size)			    \
	(*PL_MemShared->pMalloc)(PL_MemShared, (size))
#define PerlMemShared_realloc(buf, size)		    \
	(*PL_MemShared->pRealloc)(PL_MemShared, (buf), (size))
#define PerlMemShared_free(buf)				    \
	(*PL_MemShared->pFree)(PL_MemShared, (buf))
#define PerlMemShared_calloc(num, size)			    \
	(*PL_MemShared->pCalloc)(PL_MemShared, (num), (size))
#define PerlMemShared_get_lock()			    \
	(*PL_MemShared->pGetLock)(PL_MemShared)
#define PerlMemShared_free_lock()			    \
	(*PL_MemShared->pFreeLock)(PL_MemShared)
#define PerlMemShared_is_locked()			    \
	(*PL_MemShared->pIsLocked)(PL_MemShared)

#endif

/* Parse tree memory macros */
#define PerlMemParse_malloc(size)			    \
	(*PL_MemParse->pMalloc)(PL_MemParse, (size))
#define PerlMemParse_realloc(buf, size)			    \
	(*PL_MemParse->pRealloc)(PL_MemParse, (buf), (size))
#define PerlMemParse_free(buf)				    \
	(*PL_MemParse->pFree)(PL_MemParse, (buf))
#define PerlMemParse_calloc(num, size)			    \
	(*PL_MemParse->pCalloc)(PL_MemParse, (num), (size))
#define PerlMemParse_get_lock()				    \
	(*PL_MemParse->pGetLock)(PL_MemParse)
#define PerlMemParse_free_lock()			    \
	(*PL_MemParse->pFreeLock)(PL_MemParse)
#define PerlMemParse_is_locked()			    \
	(*PL_MemParse->pIsLocked)(PL_MemParse)


#else	/* PERL_IMPLICIT_SYS */

/* Interpreter specific memory macros */
#define PerlMem_malloc(size)		malloc((size))
#define PerlMem_realloc(buf, size)	realloc((buf), (size))
#define PerlMem_free(buf)		free((buf))
#define PerlMem_calloc(num, size)	calloc((num), (size))
#define PerlMem_get_lock()		
#define PerlMem_free_lock()
#define PerlMem_is_locked()		0

/* Shared memory macros */
#define PerlMemShared_malloc(size)		malloc((size))
#define PerlMemShared_realloc(buf, size)	realloc((buf), (size))
#define PerlMemShared_free(buf)			free((buf))
#define PerlMemShared_calloc(num, size)		calloc((num), (size))
#define PerlMemShared_get_lock()		
#define PerlMemShared_free_lock()
#define PerlMemShared_is_locked()		0

/* Parse tree memory macros */
#define PerlMemParse_malloc(size)	malloc((size))
#define PerlMemParse_realloc(buf, size)	realloc((buf), (size))
#define PerlMemParse_free(buf)		free((buf))
#define PerlMemParse_calloc(num, size)	calloc((num), (size))
#define PerlMemParse_get_lock()		
#define PerlMemParse_free_lock()
#define PerlMemParse_is_locked()	0

#endif	/* PERL_IMPLICIT_SYS */

/*
    Interface for perl process functions
*/


#if defined(PERL_IMPLICIT_SYS)

#ifndef jmp_buf
#include <setjmp.h>
#endif

/* IPerlProc		*/
struct IPerlProc;
struct IPerlProcInfo;
typedef void		(*LPProcAbort)(struct IPerlProc*);
typedef char*		(*LPProcCrypt)(struct IPerlProc*, const char*,
			    const char*);
typedef void		(*LPProcExit)(struct IPerlProc*, int)
			    __attribute__noreturn__;
typedef void		(*LPProc_Exit)(struct IPerlProc*, int)
			    __attribute__noreturn__;
typedef int		(*LPProcExecl)(struct IPerlProc*, const char*,
			    const char*, const char*, const char*,
			    const char*);
typedef int		(*LPProcExecv)(struct IPerlProc*, const char*,
			    const char*const*);
typedef int		(*LPProcExecvp)(struct IPerlProc*, const char*,
			    const char*const*);
typedef Uid_t		(*LPProcGetuid)(struct IPerlProc*);
typedef Uid_t		(*LPProcGeteuid)(struct IPerlProc*);
typedef Gid_t		(*LPProcGetgid)(struct IPerlProc*);
typedef Gid_t		(*LPProcGetegid)(struct IPerlProc*);
typedef char*		(*LPProcGetlogin)(struct IPerlProc*);
typedef int		(*LPProcKill)(struct IPerlProc*, int, int);
typedef int		(*LPProcKillpg)(struct IPerlProc*, int, int);
typedef int		(*LPProcPauseProc)(struct IPerlProc*);
typedef PerlIO*		(*LPProcPopen)(struct IPerlProc*, const char*,
			    const char*);
typedef PerlIO*		(*LPProcPopenList)(struct IPerlProc*, const char*,
			    IV narg, SV **args);
typedef int		(*LPProcPclose)(struct IPerlProc*, PerlIO*);
typedef int		(*LPProcPipe)(struct IPerlProc*, int*);
typedef int		(*LPProcSetuid)(struct IPerlProc*, uid_t);
typedef int		(*LPProcSetgid)(struct IPerlProc*, gid_t);
typedef int		(*LPProcSleep)(struct IPerlProc*, unsigned int);
typedef int		(*LPProcTimes)(struct IPerlProc*, struct tms*);
typedef int		(*LPProcWait)(struct IPerlProc*, int*);
typedef int		(*LPProcWaitpid)(struct IPerlProc*, int, int*, int);
typedef Sighandler_t	(*LPProcSignal)(struct IPerlProc*, int, Sighandler_t);
typedef int		(*LPProcFork)(struct IPerlProc*);
typedef int		(*LPProcGetpid)(struct IPerlProc*);
#ifdef WIN32
typedef void*		(*LPProcDynaLoader)(struct IPerlProc*, const char*);
typedef void		(*LPProcGetOSError)(struct IPerlProc*,
			    SV* sv, DWORD dwErr);
typedef int		(*LPProcSpawnvp)(struct IPerlProc*, int, const char*,
			    const char*const*);
#endif
typedef int		(*LPProcLastHost)(struct IPerlProc*);
typedef int		(*LPProcGetTimeOfDay)(struct IPerlProc*,
					      struct timeval*, void*);

struct IPerlProc
{
    LPProcAbort		pAbort;
    LPProcCrypt		pCrypt;
    LPProcExit		pExit;
    LPProc_Exit		p_Exit;
    LPProcExecl		pExecl;
    LPProcExecv		pExecv;
    LPProcExecvp	pExecvp;
    LPProcGetuid	pGetuid;
    LPProcGeteuid	pGeteuid;
    LPProcGetgid	pGetgid;
    LPProcGetegid	pGetegid;
    LPProcGetlogin	pGetlogin;
    LPProcKill		pKill;
    LPProcKillpg	pKillpg;
    LPProcPauseProc	pPauseProc;
    LPProcPopen		pPopen;
    LPProcPclose	pPclose;
    LPProcPipe		pPipe;
    LPProcSetuid	pSetuid;
    LPProcSetgid	pSetgid;
    LPProcSleep		pSleep;
    LPProcTimes		pTimes;
    LPProcWait		pWait;
    LPProcWaitpid	pWaitpid;
    LPProcSignal	pSignal;
    LPProcFork		pFork;
    LPProcGetpid	pGetpid;
#ifdef WIN32
    LPProcDynaLoader	pDynaLoader;
    LPProcGetOSError	pGetOSError;
    LPProcSpawnvp	pSpawnvp;
#endif
    LPProcLastHost      pLastHost;
    LPProcPopenList	pPopenList;
    LPProcGetTimeOfDay	pGetTimeOfDay;
};

struct IPerlProcInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlProc	perlProcList;
};

#define PerlProc_abort()						\
	(*PL_Proc->pAbort)(PL_Proc)
#define PerlProc_crypt(c,s)						\
	(*PL_Proc->pCrypt)(PL_Proc, (c), (s))
#define PerlProc_exit(s)						\
	(*PL_Proc->pExit)(PL_Proc, (s))
#define PerlProc__exit(s)						\
	(*PL_Proc->p_Exit)(PL_Proc, (s))
#define PerlProc_execl(c, w, x, y, z)					\
	(*PL_Proc->pExecl)(PL_Proc, (c), (w), (x), (y), (z))
#define PerlProc_execv(c, a)						\
	(*PL_Proc->pExecv)(PL_Proc, (c), (a))
#define PerlProc_execvp(c, a)						\
	(*PL_Proc->pExecvp)(PL_Proc, (c), (a))
#define PerlProc_getuid()						\
	(*PL_Proc->pGetuid)(PL_Proc)
#define PerlProc_geteuid()						\
	(*PL_Proc->pGeteuid)(PL_Proc)
#define PerlProc_getgid()						\
	(*PL_Proc->pGetgid)(PL_Proc)
#define PerlProc_getegid()						\
	(*PL_Proc->pGetegid)(PL_Proc)
#define PerlProc_getlogin()						\
	(*PL_Proc->pGetlogin)(PL_Proc)
#define PerlProc_kill(i, a)						\
	(*PL_Proc->pKill)(PL_Proc, (i), (a))
#define PerlProc_killpg(i, a)						\
	(*PL_Proc->pKillpg)(PL_Proc, (i), (a))
#define PerlProc_pause()						\
	(*PL_Proc->pPauseProc)(PL_Proc)
#define PerlProc_popen(c, m)						\
	(*PL_Proc->pPopen)(PL_Proc, (c), (m))
#define PerlProc_popen_list(m, n, a)					\
	(*PL_Proc->pPopenList)(PL_Proc, (m), (n), (a))
#define PerlProc_pclose(f)						\
	(*PL_Proc->pPclose)(PL_Proc, (f))
#define PerlProc_pipe(fd)						\
	(*PL_Proc->pPipe)(PL_Proc, (fd))
#define PerlProc_setuid(u)						\
	(*PL_Proc->pSetuid)(PL_Proc, (u))
#define PerlProc_setgid(g)						\
	(*PL_Proc->pSetgid)(PL_Proc, (g))
#define PerlProc_sleep(t)						\
	(*PL_Proc->pSleep)(PL_Proc, (t))
#define PerlProc_times(t)						\
	(*PL_Proc->pTimes)(PL_Proc, (t))
#define PerlProc_wait(t)						\
	(*PL_Proc->pWait)(PL_Proc, (t))
#define PerlProc_waitpid(p,s,f)						\
	(*PL_Proc->pWaitpid)(PL_Proc, (p), (s), (f))
#define PerlProc_signal(n, h)						\
	(*PL_Proc->pSignal)(PL_Proc, (n), (h))
#define PerlProc_fork()							\
	(*PL_Proc->pFork)(PL_Proc)
#define PerlProc_getpid()						\
	(*PL_Proc->pGetpid)(PL_Proc)
#define PerlProc_setjmp(b, n) Sigsetjmp((b), (n))
#define PerlProc_longjmp(b, n) Siglongjmp((b), (n))

#ifdef WIN32
#define PerlProc_DynaLoad(f)						\
	(*PL_Proc->pDynaLoader)(PL_Proc, (f))
#define PerlProc_GetOSError(s,e)					\
	(*PL_Proc->pGetOSError)(PL_Proc, (s), (e))
#define PerlProc_spawnvp(m, c, a)					\
	(*PL_Proc->pSpawnvp)(PL_Proc, (m), (c), (a))
#endif
#define PerlProc_lasthost()						\
	(*PL_Proc->pLastHost)(PL_Proc)
#define PerlProc_gettimeofday(t,z)					\
	(*PL_Proc->pGetTimeOfDay)(PL_Proc,(t),(z))

#else	/* PERL_IMPLICIT_SYS */

#define PerlProc_abort()	abort()
#define PerlProc_crypt(c,s)	crypt((c), (s))
#define PerlProc_exit(s)	exit((s))
#define PerlProc__exit(s)	_exit((s))
#define PerlProc_execl(c,w,x,y,z)					\
	execl((c), (w), (x), (y), (z))
#define PerlProc_execv(c, a)	execv((c), (a))
#define PerlProc_execvp(c, a)	execvp((c), (a))
#define PerlProc_getuid()	getuid()
#define PerlProc_geteuid()	geteuid()
#define PerlProc_getgid()	getgid()
#define PerlProc_getegid()	getegid()
#define PerlProc_getlogin()	getlogin()
#define PerlProc_kill(i, a)	kill((i), (a))
#define PerlProc_killpg(i, a)	killpg((i), (a))
#define PerlProc_pause()	Pause()
#define PerlProc_popen(c, m)	my_popen((c), (m))
#define PerlProc_popen_list(m,n,a)	my_popen_list((m),(n),(a))
#define PerlProc_pclose(f)	my_pclose((f))
#define PerlProc_pipe(fd)	pipe((fd))
#define PerlProc_setuid(u)	setuid((u))
#define PerlProc_setgid(g)	setgid((g))
#define PerlProc_sleep(t)	sleep((t))
#define PerlProc_times(t)	times((t))
#define PerlProc_wait(t)	wait((t))
#define PerlProc_waitpid(p,s,f)	waitpid((p), (s), (f))
#define PerlProc_setjmp(b, n)	Sigsetjmp((b), (n))
#define PerlProc_longjmp(b, n)	Siglongjmp((b), (n))
#define PerlProc_signal(n, h)	signal((n), (h))
#define PerlProc_fork()		my_fork()
#define PerlProc_getpid()	getpid()
#define PerlProc_gettimeofday(t,z)	gettimeofday((t),(z))

#ifdef WIN32
#define PerlProc_DynaLoad(f)						\
	win32_dynaload((f))
#define PerlProc_GetOSError(s,e)					\
	win32_str_os_error((s), (e))
#define PerlProc_spawnvp(m, c, a)					\
	win32_spawnvp((m), (c), (a))
#undef PerlProc_signal
#define PerlProc_signal(n, h) win32_signal((n), (h))
#endif
#endif	/* PERL_IMPLICIT_SYS */

/*
    Interface for perl socket functions
*/

#if defined(PERL_IMPLICIT_SYS)

/* PerlSock		*/
struct IPerlSock;
struct IPerlSockInfo;
typedef u_long		(*LPHtonl)(struct IPerlSock*, u_long);
typedef u_short		(*LPHtons)(struct IPerlSock*, u_short);
typedef u_long		(*LPNtohl)(struct IPerlSock*, u_long);
typedef u_short		(*LPNtohs)(struct IPerlSock*, u_short);
typedef SOCKET		(*LPAccept)(struct IPerlSock*, SOCKET,
			    struct sockaddr*, int*);
typedef int		(*LPBind)(struct IPerlSock*, SOCKET,
			    const struct sockaddr*, int);
typedef int		(*LPConnect)(struct IPerlSock*, SOCKET,
			    const struct sockaddr*, int);
typedef void		(*LPEndhostent)(struct IPerlSock*);
typedef void		(*LPEndnetent)(struct IPerlSock*);
typedef void		(*LPEndprotoent)(struct IPerlSock*);
typedef void		(*LPEndservent)(struct IPerlSock*);
typedef int		(*LPGethostname)(struct IPerlSock*, char*, int);
typedef int		(*LPGetpeername)(struct IPerlSock*, SOCKET,
			    struct sockaddr*, int*);
typedef struct hostent*	(*LPGethostbyaddr)(struct IPerlSock*, const char*,
			    int, int);
typedef struct hostent*	(*LPGethostbyname)(struct IPerlSock*, const char*);
typedef struct hostent*	(*LPGethostent)(struct IPerlSock*);
typedef struct netent*	(*LPGetnetbyaddr)(struct IPerlSock*, long, int);
typedef struct netent*	(*LPGetnetbyname)(struct IPerlSock*, const char*);
typedef struct netent*	(*LPGetnetent)(struct IPerlSock*);
typedef struct protoent*(*LPGetprotobyname)(struct IPerlSock*, const char*);
typedef struct protoent*(*LPGetprotobynumber)(struct IPerlSock*, int);
typedef struct protoent*(*LPGetprotoent)(struct IPerlSock*);
typedef struct servent*	(*LPGetservbyname)(struct IPerlSock*, const char*,
			    const char*);
typedef struct servent*	(*LPGetservbyport)(struct IPerlSock*, int,
			    const char*);
typedef struct servent*	(*LPGetservent)(struct IPerlSock*);
typedef int		(*LPGetsockname)(struct IPerlSock*, SOCKET,
			    struct sockaddr*, int*);
typedef int		(*LPGetsockopt)(struct IPerlSock*, SOCKET, int, int,
			    char*, int*);
typedef unsigned long	(*LPInetAddr)(struct IPerlSock*, const char*);
typedef char*		(*LPInetNtoa)(struct IPerlSock*, struct in_addr);
typedef int		(*LPListen)(struct IPerlSock*, SOCKET, int);
typedef int		(*LPRecv)(struct IPerlSock*, SOCKET, char*, int, int);
typedef int		(*LPRecvfrom)(struct IPerlSock*, SOCKET, char*, int,
			    int, struct sockaddr*, int*);
typedef int		(*LPSelect)(struct IPerlSock*, int, char*, char*,
			    char*, const struct timeval*);
typedef int		(*LPSend)(struct IPerlSock*, SOCKET, const char*, int,
			    int);
typedef int		(*LPSendto)(struct IPerlSock*, SOCKET, const char*,
			    int, int, const struct sockaddr*, int);
typedef void		(*LPSethostent)(struct IPerlSock*, int);
typedef void		(*LPSetnetent)(struct IPerlSock*, int);
typedef void		(*LPSetprotoent)(struct IPerlSock*, int);
typedef void		(*LPSetservent)(struct IPerlSock*, int);
typedef int		(*LPSetsockopt)(struct IPerlSock*, SOCKET, int, int,
			    const char*, int);
typedef int		(*LPShutdown)(struct IPerlSock*, SOCKET, int);
typedef SOCKET		(*LPSocket)(struct IPerlSock*, int, int, int);
typedef int		(*LPSocketpair)(struct IPerlSock*, int, int, int,
			    int*);
#ifdef WIN32
typedef int		(*LPClosesocket)(struct IPerlSock*, SOCKET s);
#endif

struct IPerlSock
{
    LPHtonl		pHtonl;
    LPHtons		pHtons;
    LPNtohl		pNtohl;
    LPNtohs		pNtohs;
    LPAccept		pAccept;
    LPBind		pBind;
    LPConnect		pConnect;
    LPEndhostent	pEndhostent;
    LPEndnetent		pEndnetent;
    LPEndprotoent	pEndprotoent;
    LPEndservent	pEndservent;
    LPGethostname	pGethostname;
    LPGetpeername	pGetpeername;
    LPGethostbyaddr	pGethostbyaddr;
    LPGethostbyname	pGethostbyname;
    LPGethostent	pGethostent;
    LPGetnetbyaddr	pGetnetbyaddr;
    LPGetnetbyname	pGetnetbyname;
    LPGetnetent		pGetnetent;
    LPGetprotobyname	pGetprotobyname;
    LPGetprotobynumber	pGetprotobynumber;
    LPGetprotoent	pGetprotoent;
    LPGetservbyname	pGetservbyname;
    LPGetservbyport	pGetservbyport;
    LPGetservent	pGetservent;
    LPGetsockname	pGetsockname;
    LPGetsockopt	pGetsockopt;
    LPInetAddr		pInetAddr;
    LPInetNtoa		pInetNtoa;
    LPListen		pListen;
    LPRecv		pRecv;
    LPRecvfrom		pRecvfrom;
    LPSelect		pSelect;
    LPSend		pSend;
    LPSendto		pSendto;
    LPSethostent	pSethostent;
    LPSetnetent		pSetnetent;
    LPSetprotoent	pSetprotoent;
    LPSetservent	pSetservent;
    LPSetsockopt	pSetsockopt;
    LPShutdown		pShutdown;
    LPSocket		pSocket;
    LPSocketpair	pSocketpair;
#ifdef WIN32
    LPClosesocket	pClosesocket;
#endif
};

struct IPerlSockInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlSock	perlSockList;
};

#define PerlSock_htonl(x)						\
	(*PL_Sock->pHtonl)(PL_Sock, x)
#define PerlSock_htons(x)						\
	(*PL_Sock->pHtons)(PL_Sock, x)
#define PerlSock_ntohl(x)						\
	(*PL_Sock->pNtohl)(PL_Sock, x)
#define PerlSock_ntohs(x)						\
	(*PL_Sock->pNtohs)(PL_Sock, x)
#define PerlSock_accept(s, a, l)					\
	(*PL_Sock->pAccept)(PL_Sock, s, a, l)
#define PerlSock_bind(s, n, l)						\
	(*PL_Sock->pBind)(PL_Sock, s, n, l)
#define PerlSock_connect(s, n, l)					\
	(*PL_Sock->pConnect)(PL_Sock, s, n, l)
#define PerlSock_endhostent()						\
	(*PL_Sock->pEndhostent)(PL_Sock)
#define PerlSock_endnetent()						\
	(*PL_Sock->pEndnetent)(PL_Sock)
#define PerlSock_endprotoent()						\
	(*PL_Sock->pEndprotoent)(PL_Sock)
#define PerlSock_endservent()						\
	(*PL_Sock->pEndservent)(PL_Sock)
#define PerlSock_gethostbyaddr(a, l, t)					\
	(*PL_Sock->pGethostbyaddr)(PL_Sock, a, l, t)
#define PerlSock_gethostbyname(n)					\
	(*PL_Sock->pGethostbyname)(PL_Sock, n)
#define PerlSock_gethostent()						\
	(*PL_Sock->pGethostent)(PL_Sock)
#define PerlSock_gethostname(n, l)					\
	(*PL_Sock->pGethostname)(PL_Sock, n, l)
#define PerlSock_getnetbyaddr(n, t)					\
	(*PL_Sock->pGetnetbyaddr)(PL_Sock, n, t)
#define PerlSock_getnetbyname(c)					\
	(*PL_Sock->pGetnetbyname)(PL_Sock, c)
#define PerlSock_getnetent()						\
	(*PL_Sock->pGetnetent)(PL_Sock)
#define PerlSock_getpeername(s, n, l)					\
	(*PL_Sock->pGetpeername)(PL_Sock, s, n, l)
#define PerlSock_getprotobyname(n)					\
	(*PL_Sock->pGetprotobyname)(PL_Sock, n)
#define PerlSock_getprotobynumber(n)					\
	(*PL_Sock->pGetprotobynumber)(PL_Sock, n)
#define PerlSock_getprotoent()						\
	(*PL_Sock->pGetprotoent)(PL_Sock)
#define PerlSock_getservbyname(n, p)					\
	(*PL_Sock->pGetservbyname)(PL_Sock, n, p)
#define PerlSock_getservbyport(port, p)					\
	(*PL_Sock->pGetservbyport)(PL_Sock, port, p)
#define PerlSock_getservent()						\
	(*PL_Sock->pGetservent)(PL_Sock)
#define PerlSock_getsockname(s, n, l)					\
	(*PL_Sock->pGetsockname)(PL_Sock, s, n, l)
#define PerlSock_getsockopt(s,l,n,v,i)					\
	(*PL_Sock->pGetsockopt)(PL_Sock, s, l, n, v, i)
#define PerlSock_inet_addr(c)						\
	(*PL_Sock->pInetAddr)(PL_Sock, c)
#define PerlSock_inet_ntoa(i)						\
	(*PL_Sock->pInetNtoa)(PL_Sock, i)
#define PerlSock_listen(s, b)						\
	(*PL_Sock->pListen)(PL_Sock, s, b)
#define PerlSock_recv(s, b, l, f)					\
	(*PL_Sock->pRecv)(PL_Sock, s, b, l, f)
#define PerlSock_recvfrom(s,b,l,f,from,fromlen)				\
	(*PL_Sock->pRecvfrom)(PL_Sock, s, b, l, f, from, fromlen)
#define PerlSock_select(n, r, w, e, t)					\
	(*PL_Sock->pSelect)(PL_Sock, n, (char*)r, (char*)w, (char*)e, t)
#define PerlSock_send(s, b, l, f)					\
	(*PL_Sock->pSend)(PL_Sock, s, b, l, f)
#define PerlSock_sendto(s, b, l, f, t, tlen)				\
	(*PL_Sock->pSendto)(PL_Sock, s, b, l, f, t, tlen)
#define PerlSock_sethostent(f)						\
	(*PL_Sock->pSethostent)(PL_Sock, f)
#define PerlSock_setnetent(f)						\
	(*PL_Sock->pSetnetent)(PL_Sock, f)
#define PerlSock_setprotoent(f)						\
	(*PL_Sock->pSetprotoent)(PL_Sock, f)
#define PerlSock_setservent(f)						\
	(*PL_Sock->pSetservent)(PL_Sock, f)
#define PerlSock_setsockopt(s, l, n, v, len)				\
	(*PL_Sock->pSetsockopt)(PL_Sock, s, l, n, v, len)
#define PerlSock_shutdown(s, h)						\
	(*PL_Sock->pShutdown)(PL_Sock, s, h)
#define PerlSock_socket(a, t, p)					\
	(*PL_Sock->pSocket)(PL_Sock, a, t, p)
#define PerlSock_socketpair(a, t, p, f)					\
	(*PL_Sock->pSocketpair)(PL_Sock, a, t, p, f)

#ifdef WIN32
#define	PerlSock_closesocket(s)						\
	(*PL_Sock->pClosesocket)(PL_Sock, s)
#endif

#else	/* PERL_IMPLICIT_SYS */

#define PerlSock_htonl(x)		htonl(x)
#define PerlSock_htons(x)		htons(x)
#define PerlSock_ntohl(x)		ntohl(x)
#define PerlSock_ntohs(x)		ntohs(x)
#define PerlSock_accept(s, a, l)	accept(s, a, l)
#define PerlSock_bind(s, n, l)		bind(s, n, l)
#define PerlSock_connect(s, n, l)	connect(s, n, l)

#define PerlSock_gethostbyaddr(a, l, t)	gethostbyaddr(a, l, t)
#define PerlSock_gethostbyname(n)	gethostbyname(n)
#define PerlSock_gethostent		gethostent
#define PerlSock_endhostent		endhostent
#define PerlSock_gethostname(n, l)	gethostname(n, l)

#define PerlSock_getnetbyaddr(n, t)	getnetbyaddr(n, t)
#define PerlSock_getnetbyname(n)	getnetbyname(n)
#define PerlSock_getnetent		getnetent
#define PerlSock_endnetent		endnetent
#define PerlSock_getpeername(s, n, l)	getpeername(s, n, l)

#define PerlSock_getprotobyname(n)	getprotobyname(n)
#define PerlSock_getprotobynumber(n)	getprotobynumber(n)
#define PerlSock_getprotoent		getprotoent
#define PerlSock_endprotoent		endprotoent

#define PerlSock_getservbyname(n, p)	getservbyname(n, p)
#define PerlSock_getservbyport(port, p)	getservbyport(port, p)
#define PerlSock_getservent		getservent
#define PerlSock_endservent		endservent

#define PerlSock_getsockname(s, n, l)	getsockname(s, n, l)
#define PerlSock_getsockopt(s,l,n,v,i)	getsockopt(s, l, n, v, i)
#define PerlSock_inet_addr(c)		inet_addr(c)
#define PerlSock_inet_ntoa(i)		inet_ntoa(i)
#define PerlSock_listen(s, b)		listen(s, b)
#define PerlSock_recv(s, b, l, f)	recv(s, b, l, f)
#define PerlSock_recvfrom(s, b, l, f, from, fromlen)			\
	recvfrom(s, b, l, f, from, fromlen)
#define PerlSock_select(n, r, w, e, t)	select(n, r, w, e, t)
#define PerlSock_send(s, b, l, f)	send(s, b, l, f)
#define PerlSock_sendto(s, b, l, f, t, tlen)				\
	sendto(s, b, l, f, t, tlen)
#define PerlSock_sethostent(f)		sethostent(f)
#define PerlSock_setnetent(f)		setnetent(f)
#define PerlSock_setprotoent(f)		setprotoent(f)
#define PerlSock_setservent(f)		setservent(f)
#define PerlSock_setsockopt(s, l, n, v, len)				\
	setsockopt(s, l, n, v, len)
#define PerlSock_shutdown(s, h)		shutdown(s, h)
#define PerlSock_socket(a, t, p)	socket(a, t, p)
#define PerlSock_socketpair(a, t, p, f)	socketpair(a, t, p, f)

#ifdef WIN32
#define PerlSock_closesocket(s)		closesocket(s)
#endif

#endif	/* PERL_IMPLICIT_SYS */

#endif	/* __Inc__IPerl___ */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/keywords.h                                                0100644 0000000 0000000 00000014673 12744441327 017767  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    keywords.h
 *
 *    Copyright (C) 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002, 2005,
 *    2006, 2007 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/keywords.pl from its data.
 * Any changes made here will be lost!
 */

#define KEY_NULL		0
#define KEY___FILE__		1
#define KEY___LINE__		2
#define KEY___PACKAGE__		3
#define KEY___DATA__		4
#define KEY___END__		5
#define KEY___SUB__		6
#define KEY_AUTOLOAD		7
#define KEY_BEGIN		8
#define KEY_UNITCHECK		9
#define KEY_DESTROY		10
#define KEY_END			11
#define KEY_INIT		12
#define KEY_CHECK		13
#define KEY_abs			14
#define KEY_accept		15
#define KEY_alarm		16
#define KEY_and			17
#define KEY_atan2		18
#define KEY_bind		19
#define KEY_binmode		20
#define KEY_bless		21
#define KEY_break		22
#define KEY_caller		23
#define KEY_chdir		24
#define KEY_chmod		25
#define KEY_chomp		26
#define KEY_chop		27
#define KEY_chown		28
#define KEY_chr			29
#define KEY_chroot		30
#define KEY_close		31
#define KEY_closedir		32
#define KEY_cmp			33
#define KEY_connect		34
#define KEY_continue		35
#define KEY_cos			36
#define KEY_crypt		37
#define KEY_dbmclose		38
#define KEY_dbmopen		39
#define KEY_default		40
#define KEY_defined		41
#define KEY_delete		42
#define KEY_die			43
#define KEY_do			44
#define KEY_dump		45
#define KEY_each		46
#define KEY_else		47
#define KEY_elsif		48
#define KEY_endgrent		49
#define KEY_endhostent		50
#define KEY_endnetent		51
#define KEY_endprotoent		52
#define KEY_endpwent		53
#define KEY_endservent		54
#define KEY_eof			55
#define KEY_eq			56
#define KEY_eval		57
#define KEY_evalbytes		58
#define KEY_exec		59
#define KEY_exists		60
#define KEY_exit		61
#define KEY_exp			62
#define KEY_fc			63
#define KEY_fcntl		64
#define KEY_fileno		65
#define KEY_flock		66
#define KEY_for			67
#define KEY_foreach		68
#define KEY_fork		69
#define KEY_format		70
#define KEY_formline		71
#define KEY_ge			72
#define KEY_getc		73
#define KEY_getgrent		74
#define KEY_getgrgid		75
#define KEY_getgrnam		76
#define KEY_gethostbyaddr	77
#define KEY_gethostbyname	78
#define KEY_gethostent		79
#define KEY_getlogin		80
#define KEY_getnetbyaddr	81
#define KEY_getnetbyname	82
#define KEY_getnetent		83
#define KEY_getpeername		84
#define KEY_getpgrp		85
#define KEY_getppid		86
#define KEY_getpriority		87
#define KEY_getprotobyname	88
#define KEY_getprotobynumber	89
#define KEY_getprotoent		90
#define KEY_getpwent		91
#define KEY_getpwnam		92
#define KEY_getpwuid		93
#define KEY_getservbyname	94
#define KEY_getservbyport	95
#define KEY_getservent		96
#define KEY_getsockname		97
#define KEY_getsockopt		98
#define KEY_given		99
#define KEY_glob		100
#define KEY_gmtime		101
#define KEY_goto		102
#define KEY_grep		103
#define KEY_gt			104
#define KEY_hex			105
#define KEY_if			106
#define KEY_index		107
#define KEY_int			108
#define KEY_ioctl		109
#define KEY_join		110
#define KEY_keys		111
#define KEY_kill		112
#define KEY_last		113
#define KEY_lc			114
#define KEY_lcfirst		115
#define KEY_le			116
#define KEY_length		117
#define KEY_link		118
#define KEY_listen		119
#define KEY_local		120
#define KEY_localtime		121
#define KEY_lock		122
#define KEY_log			123
#define KEY_lstat		124
#define KEY_lt			125
#define KEY_m			126
#define KEY_map			127
#define KEY_mkdir		128
#define KEY_msgctl		129
#define KEY_msgget		130
#define KEY_msgrcv		131
#define KEY_msgsnd		132
#define KEY_my			133
#define KEY_ne			134
#define KEY_next		135
#define KEY_no			136
#define KEY_not			137
#define KEY_oct			138
#define KEY_open		139
#define KEY_opendir		140
#define KEY_or			141
#define KEY_ord			142
#define KEY_our			143
#define KEY_pack		144
#define KEY_package		145
#define KEY_pipe		146
#define KEY_pop			147
#define KEY_pos			148
#define KEY_print		149
#define KEY_printf		150
#define KEY_prototype		151
#define KEY_push		152
#define KEY_q			153
#define KEY_qq			154
#define KEY_qr			155
#define KEY_quotemeta		156
#define KEY_qw			157
#define KEY_qx			158
#define KEY_rand		159
#define KEY_read		160
#define KEY_readdir		161
#define KEY_readline		162
#define KEY_readlink		163
#define KEY_readpipe		164
#define KEY_recv		165
#define KEY_redo		166
#define KEY_ref			167
#define KEY_rename		168
#define KEY_require		169
#define KEY_reset		170
#define KEY_return		171
#define KEY_reverse		172
#define KEY_rewinddir		173
#define KEY_rindex		174
#define KEY_rmdir		175
#define KEY_s			176
#define KEY_say			177
#define KEY_scalar		178
#define KEY_seek		179
#define KEY_seekdir		180
#define KEY_select		181
#define KEY_semctl		182
#define KEY_semget		183
#define KEY_semop		184
#define KEY_send		185
#define KEY_setgrent		186
#define KEY_sethostent		187
#define KEY_setnetent		188
#define KEY_setpgrp		189
#define KEY_setpriority		190
#define KEY_setprotoent		191
#define KEY_setpwent		192
#define KEY_setservent		193
#define KEY_setsockopt		194
#define KEY_shift		195
#define KEY_shmctl		196
#define KEY_shmget		197
#define KEY_shmread		198
#define KEY_shmwrite		199
#define KEY_shutdown		200
#define KEY_sin			201
#define KEY_sleep		202
#define KEY_socket		203
#define KEY_socketpair		204
#define KEY_sort		205
#define KEY_splice		206
#define KEY_split		207
#define KEY_sprintf		208
#define KEY_sqrt		209
#define KEY_srand		210
#define KEY_stat		211
#define KEY_state		212
#define KEY_study		213
#define KEY_sub			214
#define KEY_substr		215
#define KEY_symlink		216
#define KEY_syscall		217
#define KEY_sysopen		218
#define KEY_sysread		219
#define KEY_sysseek		220
#define KEY_system		221
#define KEY_syswrite		222
#define KEY_tell		223
#define KEY_telldir		224
#define KEY_tie			225
#define KEY_tied		226
#define KEY_time		227
#define KEY_times		228
#define KEY_tr			229
#define KEY_truncate		230
#define KEY_uc			231
#define KEY_ucfirst		232
#define KEY_umask		233
#define KEY_undef		234
#define KEY_unless		235
#define KEY_unlink		236
#define KEY_unpack		237
#define KEY_unshift		238
#define KEY_untie		239
#define KEY_until		240
#define KEY_use			241
#define KEY_utime		242
#define KEY_values		243
#define KEY_vec			244
#define KEY_wait		245
#define KEY_waitpid		246
#define KEY_wantarray		247
#define KEY_warn		248
#define KEY_when		249
#define KEY_while		250
#define KEY_write		251
#define KEY_x			252
#define KEY_xor			253
#define KEY_y			254

/* Generated from:
 * 7c6d47fd2890b2422a40331ec90eac08f9808209b01f2b9c113141410fea91b5 regen/keywords.pl
 * ex: set ro: */
                                                                     usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/l1_char_class_tab.h                                       0100644 0000000 0000000 00000114377 12744441327 021446  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/mk_PL_charclass.pl from property definitions.
 * Any changes made here will be lost!
 */

/* U+00 NUL */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+01 SOH */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+02 STX */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+03 ETX */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+04 EOT */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+05 ENQ */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+06 ACK */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+07 BEL */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+08 BS */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+09 HT */ (1U<<_CC_ASCII)|(1U<<_CC_BLANK)|(1U<<_CC_CNTRL)|(1U<<_CC_PSXSPC)|(1U<<_CC_QUOTEMETA)|(1U<<_CC_SPACE),
/* U+0A LF */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_PSXSPC)|(1U<<_CC_QUOTEMETA)|(1U<<_CC_SPACE)|(1U<<_CC_VERTSPACE),
/* U+0B VT */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_PSXSPC)|(1U<<_CC_QUOTEMETA)|(1U<<_CC_SPACE)|(1U<<_CC_VERTSPACE),
/* U+0C FF */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_PSXSPC)|(1U<<_CC_QUOTEMETA)|(1U<<_CC_SPACE)|(1U<<_CC_VERTSPACE),
/* U+0D CR */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_PSXSPC)|(1U<<_CC_QUOTEMETA)|(1U<<_CC_SPACE)|(1U<<_CC_VERTSPACE),
/* U+0E SO */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+0F SI */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+10 DLE */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+11 DC1 */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+12 DC2 */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+13 DC3 */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+14 DC4 */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+15 NAK */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+16 SYN */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+17 ETB */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+18 CAN */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+19 EOM */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+1A SUB */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+1B ESC */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+1C FS */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+1D GS */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+1E RS */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+1F US */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+20 SPACE */ (1U<<_CC_ASCII)|(1U<<_CC_BLANK)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_PRINT)|(1U<<_CC_PSXSPC)|(1U<<_CC_QUOTEMETA)|(1U<<_CC_SPACE),
/* U+21 '!' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+22 '"' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+23 '#' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+24 '$' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+25 '%' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+26 '&' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+27 ''' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+28 '(' */ (1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+29 ')' */ (1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+2A '*' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+2B '+' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+2C ',' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+2D '-' */ (1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+2E '.' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+2F '/' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+30 '0' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_DIGIT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT),
/* U+31 '1' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_DIGIT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT),
/* U+32 '2' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_DIGIT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT),
/* U+33 '3' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_DIGIT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT),
/* U+34 '4' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_DIGIT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT),
/* U+35 '5' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_DIGIT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT),
/* U+36 '6' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_DIGIT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT),
/* U+37 '7' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_DIGIT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT),
/* U+38 '8' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_DIGIT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT),
/* U+39 '9' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_DIGIT)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT),
/* U+3A ':' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+3B ';' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+3C '<' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+3D '=' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+3E '>' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+3F '?' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+40 '@' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+41 'A' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+42 'B' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+43 'C' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+44 'D' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+45 'E' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+46 'F' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+47 'G' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+48 'H' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+49 'I' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+4A 'J' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+4B 'K' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+4C 'L' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+4D 'M' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+4E 'N' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD)|(1U<<_CC_BACKSLASH_FOO_LBRACE_IS_META),
/* U+4F 'O' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+50 'P' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD)|(1U<<_CC_BACKSLASH_FOO_LBRACE_IS_META),
/* U+51 'Q' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+52 'R' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+53 'S' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+54 'T' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+55 'U' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+56 'V' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+57 'W' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+58 'X' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+59 'Y' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+5A 'Z' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+5B '[' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+5C '\' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+5D ']' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+5E '^' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+5F '_' */ (1U<<_CC_ASCII)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_WORDCHAR),
/* U+60 '`' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+61 'a' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+62 'b' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+63 'c' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+64 'd' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+65 'e' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+66 'f' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_XDIGIT)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+67 'g' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD)|(1U<<_CC_BACKSLASH_FOO_LBRACE_IS_META),
/* U+68 'h' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+69 'i' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+6A 'j' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+6B 'k' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD)|(1U<<_CC_BACKSLASH_FOO_LBRACE_IS_META),
/* U+6C 'l' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+6D 'm' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+6E 'n' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+6F 'o' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD)|(1U<<_CC_BACKSLASH_FOO_LBRACE_IS_META),
/* U+70 'p' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD)|(1U<<_CC_BACKSLASH_FOO_LBRACE_IS_META),
/* U+71 'q' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+72 'r' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+73 's' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+74 't' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+75 'u' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+76 'v' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+77 'w' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+78 'x' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD)|(1U<<_CC_BACKSLASH_FOO_LBRACE_IS_META),
/* U+79 'y' */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_NON_FINAL_FOLD)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+7A 'z' */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_ASCII)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+7B '{' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+7C '|' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+7D '}' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+7E '~' */ (1U<<_CC_ASCII)|(1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+7F DEL */ (1U<<_CC_ASCII)|(1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+80 PAD */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+81 HOP */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+82 BPH */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+83 NBH */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+84 IND */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+85 NEL */ (1U<<_CC_CNTRL)|(1U<<_CC_PSXSPC)|(1U<<_CC_QUOTEMETA)|(1U<<_CC_SPACE)|(1U<<_CC_VERTSPACE),
/* U+86 SSA */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+87 ESA */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+88 HTS */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+89 HTJ */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+8A VTS */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+8B PLD */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+8C PLU */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+8D RI */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+8E SS2 */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+8F SS3 */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+90 DCS */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+91 PU1 */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+92 PU2 */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+93 STS */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+94 CCH */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+95 MW */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+96 SPA */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+97 EPA */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+98 SOS */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+99 SGC */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+9A SCI */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+9B CSI */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+9C ST */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+9D OSC */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+9E PM */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+9F APC */ (1U<<_CC_CNTRL)|(1U<<_CC_QUOTEMETA),
/* U+A0 NO-BREAK SPACE */ (1U<<_CC_BLANK)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_PRINT)|(1U<<_CC_PSXSPC)|(1U<<_CC_QUOTEMETA)|(1U<<_CC_SPACE),
/* U+A1 INVERTED EXCLAMATION MARK */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+A2 CENT SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+A3 POUND SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+A4 CURRENCY SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+A5 YEN SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+A6 BROKEN BAR */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+A7 SECTION SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+A8 DIAERESIS */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT),
/* U+A9 COPYRIGHT SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+AA FEMININE ORDINAL INDICATOR */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR),
/* U+AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+AC NOT SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+AD SOFT HYPHEN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+AE REGISTERED SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+AF MACRON */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT),
/* U+B0 DEGREE SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+B1 PLUS-MINUS SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+B2 SUPERSCRIPT TWO */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT),
/* U+B3 SUPERSCRIPT THREE */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT),
/* U+B4 ACUTE ACCENT */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT),
/* U+B5 MICRO SIGN */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+B6 PILCROW SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+B7 MIDDLE DOT */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT),
/* U+B8 CEDILLA */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT),
/* U+B9 SUPERSCRIPT ONE */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT),
/* U+BA MASCULINE ORDINAL INDICATOR */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR),
/* U+BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+BC VULGAR FRACTION ONE QUARTER */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT),
/* U+BD VULGAR FRACTION ONE HALF */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT),
/* U+BE VULGAR FRACTION THREE QUARTERS */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT),
/* U+BF INVERTED QUESTION MARK */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_PUNCT)|(1U<<_CC_QUOTEMETA),
/* U+C0 A WITH GRAVE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+C1 A WITH ACUTE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+C2 A WITH CIRCUMFLEX */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+C3 A WITH TILDE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+C4 A WITH DIAERESIS */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+C5 A WITH RING ABOVE */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+C6 AE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+C7 C WITH CEDILLA */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+C8 E WITH GRAVE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+C9 E WITH ACUTE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+CA E WITH CIRCUMFLEX */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+CB E WITH DIAERESIS */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+CC I WITH GRAVE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+CD I WITH ACUTE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+CE I WITH CIRCUMFLEX */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+CF I WITH DIAERESIS */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+D0 ETH */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+D1 N WITH TILDE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+D2 O WITH GRAVE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+D3 O WITH ACUTE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+D4 O WITH CIRCUMFLEX */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+D5 O WITH TILDE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+D6 O WITH DIAERESIS */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+D7 MULTIPLICATION SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+D8 O WITH STROKE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+D9 U WITH GRAVE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+DA U WITH ACUTE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+DB U WITH CIRCUMFLEX */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+DC U WITH DIAERESIS */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+DD Y WITH ACUTE */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+DE THORN */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_PRINT)|(1U<<_CC_UPPER)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+DF sharp s */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+E0 a with grave */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+E1 a with acute */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+E2 a with circumflex */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+E3 a with tilde */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+E4 a with diaeresis */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+E5 a with ring above */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+E6 ae */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+E7 c with cedilla */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+E8 e with grave */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+E9 e with acute */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+EA e with circumflex */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+EB e with diaeresis */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+EC i with grave */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+ED i with acute */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+EE i with circumflex */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+EF i with diaeresis */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+F0 eth */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+F1 n with tilde */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+F2 o with grave */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+F3 o with acute */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+F4 o with circumflex */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+F5 o with tilde */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+F6 o with diaeresis */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+F7 DIVISION SIGN */ (1U<<_CC_GRAPH)|(1U<<_CC_PRINT)|(1U<<_CC_QUOTEMETA),
/* U+F8 o with stroke */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+F9 u with grave */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+FA u with acute */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+FB u with circumflex */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+FC u with diaeresis */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+FD y with acute */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+FE thorn */ (1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),
/* U+FF y with diaeresis */ (1U<<_CC_NONLATIN1_FOLD)|(1U<<_CC_ALPHANUMERIC)|(1U<<_CC_ALPHA)|(1U<<_CC_CASED)|(1U<<_CC_CHARNAME_CONT)|(1U<<_CC_GRAPH)|(1U<<_CC_IDFIRST)|(1U<<_CC_LOWER)|(1U<<_CC_PRINT)|(1U<<_CC_WORDCHAR)|(1U<<_CC_IS_IN_SOME_FOLD),

/* ex: set ro: */
                                                                                                                                                                                                                                                                 usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/malloc_ctl.h                                              0100644 0000000 0000000 00000002750 12744441327 020222  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef MALLOC_CTL_H
#  define MALLOC_CTL_H

struct perl_mstats {
    UV *nfree;
    UV *ntotal;
    IV topbucket, topbucket_ev, topbucket_odd, totfree, total, total_chain;
    IV total_sbrk, sbrks, sbrk_good, sbrk_slack, start_slack, sbrked_remains;
    IV minbucket;
    /* Level 1 info */
    UV *bucket_mem_size;
    UV *bucket_available_size;
    UV nbuckets;
};
typedef struct perl_mstats perl_mstats_t;

PERL_CALLCONV Malloc_t Perl_malloc (MEM_SIZE nbytes);
PERL_CALLCONV Malloc_t Perl_calloc (MEM_SIZE elements, MEM_SIZE size);
PERL_CALLCONV Malloc_t Perl_realloc (Malloc_t where, MEM_SIZE nbytes);
/* 'mfree' rather than 'free', since there is already a 'perl_free'
 * that causes clashes with case-insensitive linkers */
PERL_CALLCONV Free_t   Perl_mfree (Malloc_t where);

#ifndef NO_MALLOC_DYNAMIC_CFG

/* IV configuration data */
enum {
  MallocCfg_FIRST_SBRK,
  MallocCfg_MIN_SBRK,
  MallocCfg_MIN_SBRK_FRAC1000,
  MallocCfg_SBRK_ALLOW_FAILURES,
  MallocCfg_SBRK_FAILURE_PRICE,
  MallocCfg_sbrk_goodness,

  MallocCfg_filldead,
  MallocCfg_fillalive,
  MallocCfg_fillcheck,

  MallocCfg_skip_cfg_env,
  MallocCfg_cfg_env_read,

  MallocCfg_emergency_buffer_size,
  MallocCfg_emergency_buffer_last_req,

  MallocCfg_emergency_buffer_prepared_size,

  MallocCfg_last
};
/* char* configuration data */
enum {
  MallocCfgP_emergency_buffer,
  MallocCfgP_emergency_buffer_prepared,
  MallocCfgP_last
};
START_EXTERN_C
extern IV *MallocCfg_ptr;
extern char **MallocCfgP_ptr;
END_EXTERN_C

#endif

#endif
                        usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/metaconfig.h                                              0100644 0000000 0000000 00000001725 12744441327 020226  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* This is a placeholder file for symbols that should be exported
 * into config_h.SH and Porting/Glossary. See also metaconfig.SH
 *
 * First version was created from the part in handy.h
 * H.Merijn Brand 21 Dec 2010 (Tux)
 *
 * Mentioned variables are forced to be included into config_h.SH
 * as they are only included if meta finds them referenced. That
 * implies that noone can use them unless they are available and
 * they won't be available unless used. When new symbols are probed
 * in Configure, this is the way to force them into availability.
 *
 * BOOTSTRAP_CHARSET
 * CHARBITS
 * HAS_ASCTIME64
 * HAS_CTIME64
 * HAS_DIFFTIME64
 * HAS_GMTIME64
 * HAS_ISBLANK
 * HAS_LOCALTIME64
 * HAS_IP_MREQ
 * HAS_IP_MREQ_SOURCE
 * HAS_IPV6_MREQ
 * HAS_IPV6_MREQ_SOURCE
 * HAS_MKTIME64
 * HAS_PRCTL
 * HAS_PSEUDOFORK
 * HAS_TIMEGM
 * HAS_SOCKADDR_IN6
 * I16SIZE
 * I64SIZE
 * I8SIZE
 * LOCALTIME_R_NEEDS_TZSET
 * U8SIZE
 * USE_KERN_PROC_PATHNAME
 * USE_NSGETEXECUTABLEPATH
 *
 */
                                           usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/mg.h                                                      0100644 0000000 0000000 00000005662 12744441327 016521  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    mg.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
 *    2000, 2002, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

struct mgvtbl {
    int		(*svt_get)	(pTHX_ SV *sv, MAGIC* mg);
    int		(*svt_set)	(pTHX_ SV *sv, MAGIC* mg);
    U32		(*svt_len)	(pTHX_ SV *sv, MAGIC* mg);
    int		(*svt_clear)(pTHX_ SV *sv, MAGIC* mg);
    int		(*svt_free)	(pTHX_ SV *sv, MAGIC* mg);
    int		(*svt_copy)	(pTHX_ SV *sv, MAGIC* mg,
    					SV *nsv, const char *name, I32 namlen);
    int		(*svt_dup)	(pTHX_ MAGIC *mg, CLONE_PARAMS *param);
    int		(*svt_local)(pTHX_ SV *nsv, MAGIC *mg);
};

struct magic {
    MAGIC*	mg_moremagic;
    MGVTBL*	mg_virtual;	/* pointer to magic functions */
    U16		mg_private;
    char	mg_type;
    U8		mg_flags;
    SSize_t	mg_len;
    SV*		mg_obj;
    char*	mg_ptr;
};

#define MGf_TAINTEDDIR 1        /* PERL_MAGIC_envelem only */
#define MGf_MINMATCH   1        /* PERL_MAGIC_regex_global only */
#define MGf_REFCOUNTED 2
#define MGf_GSKIP      4	/* skip further GETs until after next SET */
#define MGf_COPY       8	/* has an svt_copy  MGVTBL entry */
#define MGf_DUP     0x10 	/* has an svt_dup   MGVTBL entry */
#define MGf_LOCAL   0x20	/* has an svt_local MGVTBL entry */
#define MGf_BYTES   0x40        /* PERL_MAGIC_regex_global only */

#define MgTAINTEDDIR(mg)	(mg->mg_flags & MGf_TAINTEDDIR)
#define MgTAINTEDDIR_on(mg)	(mg->mg_flags |= MGf_TAINTEDDIR)
#define MgTAINTEDDIR_off(mg)	(mg->mg_flags &= ~MGf_TAINTEDDIR)

#define MgPV(mg,lp)		((((int)(lp = (mg)->mg_len)) == HEf_SVKEY) ?   \
				 SvPV(MUTABLE_SV((mg)->mg_ptr),lp) :	\
				 (mg)->mg_ptr)
#define MgPV_const(mg,lp)	((((int)(lp = (mg)->mg_len)) == HEf_SVKEY) ? \
				 SvPV_const(MUTABLE_SV((mg)->mg_ptr),lp) :   \
				 (const char*)(mg)->mg_ptr)
#define MgPV_nolen_const(mg)	(((((int)(mg)->mg_len)) == HEf_SVKEY) ?	\
				 SvPV_nolen_const(MUTABLE_SV((mg)->mg_ptr)) : \
				 (const char*)(mg)->mg_ptr)

#define SvTIED_mg(sv,how) (SvRMAGICAL(sv) ? mg_find((sv),(how)) : NULL)
#define SvTIED_obj(sv,mg) \
    ((mg)->mg_obj ? (mg)->mg_obj : sv_2mortal(newRV(sv)))

#if defined(PERL_CORE) || defined(PERL_EXT)
# define MgBYTEPOS(mg,sv,pv,len) S_MgBYTEPOS(aTHX_ mg,sv,pv,len)
/* assumes get-magic and stringification have already occurred */
# define MgBYTEPOS_set(mg,sv,pv,off) (			 \
    assert_((mg)->mg_type == PERL_MAGIC_regex_global)	  \
    SvPOK(sv) && (!SvGMAGICAL(sv) || sv_only_taint_gmagic(sv))  \
	? (mg)->mg_len = (off), (mg)->mg_flags |= MGf_BYTES \
	: ((mg)->mg_len = DO_UTF8(sv)			     \
	    ? (SSize_t)utf8_length((U8 *)(pv), (U8 *)(pv)+(off)) \
	    : (SSize_t)(off),					  \
	   (mg)->mg_flags &= ~MGf_BYTES))
#endif

#define whichsig(pv) whichsig_pv(pv)

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                              usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/mg_data.h                                                 0100644 0000000 0000000 00000011313 12744441327 017500  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
    /* sv '\0' Special scalar variable */
    want_vtbl_sv | PERL_MAGIC_READONLY_ACCEPTABLE,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    /* arylen '#' Array length ($#ary) */
    want_vtbl_arylen | PERL_MAGIC_VALUE_MAGIC,
    0,
    /* rhash '%' extra data for restricted hashes */
    magic_vtable_max | PERL_MAGIC_VALUE_MAGIC,
    /* proto '&' my sub prototype CV */
    magic_vtable_max,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    /* pos '.' pos() lvalue */
    want_vtbl_pos | PERL_MAGIC_VALUE_MAGIC,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    /* symtab ':' extra data for symbol tables */
    magic_vtable_max | PERL_MAGIC_VALUE_MAGIC,
    0,
    /* backref '<' for weak ref data */
    want_vtbl_backref | PERL_MAGIC_READONLY_ACCEPTABLE | PERL_MAGIC_VALUE_MAGIC,
    0,
    0,
    0,
    /* arylen_p '@' to move arylen out of XPVAV */
    magic_vtable_max | PERL_MAGIC_VALUE_MAGIC,
    0,
    /* bm 'B' Boyer-Moore (fast string search) */
    want_vtbl_regexp | PERL_MAGIC_READONLY_ACCEPTABLE | PERL_MAGIC_VALUE_MAGIC,
    0,
    /* regdata 'D' Regex match position data (@+ and @- vars) */
    want_vtbl_regdata,
    /* env 'E' %ENV hash */
    want_vtbl_env,
    0,
    0,
    /* hints 'H' %^H hash */
    want_vtbl_hints,
    /* isa 'I' @ISA array */
    want_vtbl_isa,
    0,
    0,
    /* dbfile 'L' Debugger %_<filename */
    magic_vtable_max,
    0,
    0,
    0,
    /* tied 'P' Tied array or hash */
    want_vtbl_pack | PERL_MAGIC_VALUE_MAGIC,
    0,
    0,
    /* sig 'S' %SIG hash */
    magic_vtable_max,
    0,
    /* uvar 'U' Available for use by extensions */
    want_vtbl_uvar,
    /* vstring 'V' SV was vstring literal */
    magic_vtable_max | PERL_MAGIC_VALUE_MAGIC,
    0,
    0,
    0,
    0,
    0,
    0,
    /* checkcall ']' inlining/mutation of call to this CV */
    want_vtbl_checkcall | PERL_MAGIC_VALUE_MAGIC,
    0,
    0,
    0,
    0,
    0,
    /* overload_table 'c' Holds overload table (AMT) on stash */
    want_vtbl_ovrld,
    /* regdatum 'd' Regex match position data element */
    want_vtbl_regdatum,
    /* envelem 'e' %ENV hash element */
    want_vtbl_envelem,
    /* fm 'f' Formline ('compiled' format) */
    want_vtbl_regexp | PERL_MAGIC_READONLY_ACCEPTABLE | PERL_MAGIC_VALUE_MAGIC,
    /* regex_global 'g' m//g target */
    want_vtbl_mglob | PERL_MAGIC_READONLY_ACCEPTABLE | PERL_MAGIC_VALUE_MAGIC,
    /* hintselem 'h' %^H hash element */
    want_vtbl_hintselem,
    /* isaelem 'i' @ISA array element */
    want_vtbl_isaelem,
    0,
    /* nkeys 'k' scalar(keys()) lvalue */
    want_vtbl_nkeys | PERL_MAGIC_VALUE_MAGIC,
    /* dbline 'l' Debugger %_<filename element */
    want_vtbl_dbline,
    0,
    0,
    /* collxfrm 'o' Locale transformation */
    want_vtbl_collxfrm | PERL_MAGIC_VALUE_MAGIC,
    /* tiedelem 'p' Tied array or hash element */
    want_vtbl_packelem,
    /* tiedscalar 'q' Tied scalar or handle */
    want_vtbl_packelem,
    /* qr 'r' precompiled qr// regex */
    want_vtbl_regexp | PERL_MAGIC_READONLY_ACCEPTABLE | PERL_MAGIC_VALUE_MAGIC,
    /* sigelem 's' %SIG hash element */
    want_vtbl_sigelem,
    /* taint 't' Taintedness */
    want_vtbl_taint | PERL_MAGIC_VALUE_MAGIC,
    0,
    /* vec 'v' vec() lvalue */
    want_vtbl_vec | PERL_MAGIC_VALUE_MAGIC,
    /* utf8 'w' Cached UTF-8 information */
    want_vtbl_utf8 | PERL_MAGIC_VALUE_MAGIC,
    /* substr 'x' substr() lvalue */
    want_vtbl_substr | PERL_MAGIC_VALUE_MAGIC,
    /* defelem 'y' Shadow "foreach" iterator variable / smart parameter vivification */
    want_vtbl_defelem | PERL_MAGIC_VALUE_MAGIC,
    0,
    0,
    0,
    0,
    /* ext '~' Available for use by extensions */
    magic_vtable_max,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
}
                                                                                                                                                                                                                                                                                                                     usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/mg_raw.h                                                  0100644 0000000 0000000 00000010027 12744441327 017361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    mg_raw.h
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/mg_vtable.pl.
 * Any changes made here will be lost!
 */

    { '\0', "want_vtbl_sv | PERL_MAGIC_READONLY_ACCEPTABLE",
      "/* sv '\\0' Special scalar variable */" },
    { '#', "want_vtbl_arylen | PERL_MAGIC_VALUE_MAGIC",
      "/* arylen '#' Array length ($#ary) */" },
    { '%', "magic_vtable_max | PERL_MAGIC_VALUE_MAGIC",
      "/* rhash '%' extra data for restricted hashes */" },
    { '&', "magic_vtable_max",
      "/* proto '&' my sub prototype CV */" },
    { '.', "want_vtbl_pos | PERL_MAGIC_VALUE_MAGIC",
      "/* pos '.' pos() lvalue */" },
    { ':', "magic_vtable_max | PERL_MAGIC_VALUE_MAGIC",
      "/* symtab ':' extra data for symbol tables */" },
    { '<', "want_vtbl_backref | PERL_MAGIC_READONLY_ACCEPTABLE | PERL_MAGIC_VALUE_MAGIC",
      "/* backref '<' for weak ref data */" },
    { '@', "magic_vtable_max | PERL_MAGIC_VALUE_MAGIC",
      "/* arylen_p '@' to move arylen out of XPVAV */" },
    { 'B', "want_vtbl_regexp | PERL_MAGIC_READONLY_ACCEPTABLE | PERL_MAGIC_VALUE_MAGIC",
      "/* bm 'B' Boyer-Moore (fast string search) */" },
    { 'c', "want_vtbl_ovrld",
      "/* overload_table 'c' Holds overload table (AMT) on stash */" },
    { 'D', "want_vtbl_regdata",
      "/* regdata 'D' Regex match position data (@+ and @- vars) */" },
    { 'd', "want_vtbl_regdatum",
      "/* regdatum 'd' Regex match position data element */" },
    { 'E', "want_vtbl_env",
      "/* env 'E' %ENV hash */" },
    { 'e', "want_vtbl_envelem",
      "/* envelem 'e' %ENV hash element */" },
    { 'f', "want_vtbl_regexp | PERL_MAGIC_READONLY_ACCEPTABLE | PERL_MAGIC_VALUE_MAGIC",
      "/* fm 'f' Formline ('compiled' format) */" },
    { 'g', "want_vtbl_mglob | PERL_MAGIC_READONLY_ACCEPTABLE | PERL_MAGIC_VALUE_MAGIC",
      "/* regex_global 'g' m//g target */" },
    { 'H', "want_vtbl_hints",
      "/* hints 'H' %^H hash */" },
    { 'h', "want_vtbl_hintselem",
      "/* hintselem 'h' %^H hash element */" },
    { 'I', "want_vtbl_isa",
      "/* isa 'I' @ISA array */" },
    { 'i', "want_vtbl_isaelem",
      "/* isaelem 'i' @ISA array element */" },
    { 'k', "want_vtbl_nkeys | PERL_MAGIC_VALUE_MAGIC",
      "/* nkeys 'k' scalar(keys()) lvalue */" },
    { 'L', "magic_vtable_max",
      "/* dbfile 'L' Debugger %_<filename */" },
    { 'l', "want_vtbl_dbline",
      "/* dbline 'l' Debugger %_<filename element */" },
    { 'o', "want_vtbl_collxfrm | PERL_MAGIC_VALUE_MAGIC",
      "/* collxfrm 'o' Locale transformation */" },
    { 'P', "want_vtbl_pack | PERL_MAGIC_VALUE_MAGIC",
      "/* tied 'P' Tied array or hash */" },
    { 'p', "want_vtbl_packelem",
      "/* tiedelem 'p' Tied array or hash element */" },
    { 'q', "want_vtbl_packelem",
      "/* tiedscalar 'q' Tied scalar or handle */" },
    { 'r', "want_vtbl_regexp | PERL_MAGIC_READONLY_ACCEPTABLE | PERL_MAGIC_VALUE_MAGIC",
      "/* qr 'r' precompiled qr// regex */" },
    { 'S', "magic_vtable_max",
      "/* sig 'S' %SIG hash */" },
    { 's', "want_vtbl_sigelem",
      "/* sigelem 's' %SIG hash element */" },
    { 't', "want_vtbl_taint | PERL_MAGIC_VALUE_MAGIC",
      "/* taint 't' Taintedness */" },
    { 'U', "want_vtbl_uvar",
      "/* uvar 'U' Available for use by extensions */" },
    { 'V', "magic_vtable_max | PERL_MAGIC_VALUE_MAGIC",
      "/* vstring 'V' SV was vstring literal */" },
    { 'v', "want_vtbl_vec | PERL_MAGIC_VALUE_MAGIC",
      "/* vec 'v' vec() lvalue */" },
    { 'w', "want_vtbl_utf8 | PERL_MAGIC_VALUE_MAGIC",
      "/* utf8 'w' Cached UTF-8 information */" },
    { 'x', "want_vtbl_substr | PERL_MAGIC_VALUE_MAGIC",
      "/* substr 'x' substr() lvalue */" },
    { 'y', "want_vtbl_defelem | PERL_MAGIC_VALUE_MAGIC",
      "/* defelem 'y' Shadow \"foreach\" iterator variable / smart parameter vivification */" },
    { ']', "want_vtbl_checkcall | PERL_MAGIC_VALUE_MAGIC",
      "/* checkcall ']' inlining/mutation of call to this CV */" },
    { '~', "magic_vtable_max",
      "/* ext '~' Available for use by extensions */" },

/* ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/mg_vtable.h                                               0100644 0000000 0000000 00000021352 12744441327 020050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    mg_vtable.h
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/mg_vtable.pl.
 * Any changes made here will be lost!
 */

/* These constants should be used in preference to raw characters
 * when using magic. Note that some perl guts still assume
 * certain character properties of these constants, namely that
 * isUPPER() and toLOWER() may do useful mappings.
 */

#define PERL_MAGIC_sv             '\0' /* Special scalar variable */
#define PERL_MAGIC_arylen         '#' /* Array length ($#ary) */
#define PERL_MAGIC_rhash          '%' /* extra data for restricted hashes */
#define PERL_MAGIC_proto          '&' /* my sub prototype CV */
#define PERL_MAGIC_pos            '.' /* pos() lvalue */
#define PERL_MAGIC_symtab         ':' /* extra data for symbol tables */
#define PERL_MAGIC_backref        '<' /* for weak ref data */
#define PERL_MAGIC_arylen_p       '@' /* to move arylen out of XPVAV */
#define PERL_MAGIC_bm             'B' /* Boyer-Moore (fast string search) */
#define PERL_MAGIC_overload_table 'c' /* Holds overload table (AMT) on stash */
#define PERL_MAGIC_regdata        'D' /* Regex match position data
                                         (@+ and @- vars) */
#define PERL_MAGIC_regdatum       'd' /* Regex match position data element */
#define PERL_MAGIC_env            'E' /* %ENV hash */
#define PERL_MAGIC_envelem        'e' /* %ENV hash element */
#define PERL_MAGIC_fm             'f' /* Formline ('compiled' format) */
#define PERL_MAGIC_regex_global   'g' /* m//g target */
#define PERL_MAGIC_hints          'H' /* %^H hash */
#define PERL_MAGIC_hintselem      'h' /* %^H hash element */
#define PERL_MAGIC_isa            'I' /* @ISA array */
#define PERL_MAGIC_isaelem        'i' /* @ISA array element */
#define PERL_MAGIC_nkeys          'k' /* scalar(keys()) lvalue */
#define PERL_MAGIC_dbfile         'L' /* Debugger %_<filename */
#define PERL_MAGIC_dbline         'l' /* Debugger %_<filename element */
#define PERL_MAGIC_shared         'N' /* Shared between threads */
#define PERL_MAGIC_shared_scalar  'n' /* Shared between threads */
#define PERL_MAGIC_collxfrm       'o' /* Locale transformation */
#define PERL_MAGIC_tied           'P' /* Tied array or hash */
#define PERL_MAGIC_tiedelem       'p' /* Tied array or hash element */
#define PERL_MAGIC_tiedscalar     'q' /* Tied scalar or handle */
#define PERL_MAGIC_qr             'r' /* precompiled qr// regex */
#define PERL_MAGIC_sig            'S' /* %SIG hash */
#define PERL_MAGIC_sigelem        's' /* %SIG hash element */
#define PERL_MAGIC_taint          't' /* Taintedness */
#define PERL_MAGIC_uvar           'U' /* Available for use by extensions */
#define PERL_MAGIC_uvar_elem      'u' /* Reserved for use by extensions */
#define PERL_MAGIC_vstring        'V' /* SV was vstring literal */
#define PERL_MAGIC_vec            'v' /* vec() lvalue */
#define PERL_MAGIC_utf8           'w' /* Cached UTF-8 information */
#define PERL_MAGIC_substr         'x' /* substr() lvalue */
#define PERL_MAGIC_defelem        'y' /* Shadow "foreach" iterator variable /
                                         smart parameter vivification */
#define PERL_MAGIC_checkcall      ']' /* inlining/mutation of call to this CV */
#define PERL_MAGIC_ext            '~' /* Available for use by extensions */

enum {		/* pass one of these to get_vtbl */
    want_vtbl_arylen,
    want_vtbl_arylen_p,
    want_vtbl_backref,
    want_vtbl_checkcall,
    want_vtbl_collxfrm,
    want_vtbl_dbline,
    want_vtbl_defelem,
    want_vtbl_env,
    want_vtbl_envelem,
    want_vtbl_hints,
    want_vtbl_hintselem,
    want_vtbl_isa,
    want_vtbl_isaelem,
    want_vtbl_mglob,
    want_vtbl_nkeys,
    want_vtbl_ovrld,
    want_vtbl_pack,
    want_vtbl_packelem,
    want_vtbl_pos,
    want_vtbl_regdata,
    want_vtbl_regdatum,
    want_vtbl_regexp,
    want_vtbl_sigelem,
    want_vtbl_substr,
    want_vtbl_sv,
    want_vtbl_taint,
    want_vtbl_utf8,
    want_vtbl_uvar,
    want_vtbl_vec,
    magic_vtable_max
};

#ifdef DOINIT
EXTCONST char * const PL_magic_vtable_names[magic_vtable_max] = {
    "arylen",
    "arylen_p",
    "backref",
    "checkcall",
    "collxfrm",
    "dbline",
    "defelem",
    "env",
    "envelem",
    "hints",
    "hintselem",
    "isa",
    "isaelem",
    "mglob",
    "nkeys",
    "ovrld",
    "pack",
    "packelem",
    "pos",
    "regdata",
    "regdatum",
    "regexp",
    "sigelem",
    "substr",
    "sv",
    "taint",
    "utf8",
    "uvar",
    "vec"
};
#else
EXTCONST char * const PL_magic_vtable_names[magic_vtable_max];
#endif

/* These all need to be 0, not NULL, as NULL can be (void*)0, which is a
 * pointer to data, whereas we're assigning pointers to functions, which are
 * not the same beast. ANSI doesn't allow the assignment from one to the other.
 * (although most, but not all, compilers are prepared to do it)
 */

/* order is:
    get
    set
    len
    clear
    free
    copy
    dup
    local
*/

#ifdef DOINIT
EXT_MGVTBL PL_magic_vtables[magic_vtable_max] = {
  { (int (*)(pTHX_ SV *, MAGIC *))Perl_magic_getarylen, Perl_magic_setarylen, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, Perl_magic_cleararylen_p, Perl_magic_freearylen_p, 0, 0, 0 },
  { 0, 0, 0, 0, Perl_magic_killbackrefs, 0, 0, 0 },
  { 0, 0, 0, 0, 0, Perl_magic_copycallchecker, 0, 0 },
#ifdef USE_LOCALE_COLLATE
  { 0, Perl_magic_setcollxfrm, 0, 0, 0, 0, 0, 0 },
#else
  { 0, 0, 0, 0, 0, 0, 0, 0 },
#endif
  { 0, Perl_magic_setdbline, 0, 0, 0, 0, 0, 0 },
  { Perl_magic_getdefelem, Perl_magic_setdefelem, 0, 0, 0, 0, 0, 0 },
  { 0, Perl_magic_set_all_env, 0, Perl_magic_clear_all_env, 0, 0, 0, 0 },
  { 0, Perl_magic_setenv, 0, Perl_magic_clearenv, 0, 0, 0, 0 },
  { 0, 0, 0, Perl_magic_clearhints, 0, 0, 0, 0 },
  { 0, Perl_magic_sethint, 0, Perl_magic_clearhint, 0, 0, 0, 0 },
  { 0, Perl_magic_setisa, 0, Perl_magic_clearisa, 0, 0, 0, 0 },
  { 0, Perl_magic_setisa, 0, 0, 0, 0, 0, 0 },
  { 0, Perl_magic_setmglob, 0, 0, 0, 0, 0, 0 },
  { Perl_magic_getnkeys, Perl_magic_setnkeys, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, Perl_magic_freeovrld, 0, 0, 0 },
  { 0, 0, Perl_magic_sizepack, Perl_magic_wipepack, 0, 0, 0, 0 },
  { Perl_magic_getpack, Perl_magic_setpack, 0, Perl_magic_clearpack, 0, 0, 0, 0 },
  { Perl_magic_getpos, Perl_magic_setpos, 0, 0, 0, 0, 0, 0 },
  { 0, 0, Perl_magic_regdata_cnt, 0, 0, 0, 0, 0 },
  { Perl_magic_regdatum_get, Perl_magic_regdatum_set, 0, 0, 0, 0, 0, 0 },
  { 0, Perl_magic_setregexp, 0, 0, 0, 0, 0, 0 },
#ifndef PERL_MICRO
  { Perl_magic_getsig, Perl_magic_setsig, 0, Perl_magic_clearsig, 0, 0, 0, 0 },
#else
  { 0, 0, 0, 0, 0, 0, 0, 0 },
#endif
  { Perl_magic_getsubstr, Perl_magic_setsubstr, 0, 0, 0, 0, 0, 0 },
  { Perl_magic_get, Perl_magic_set, 0, 0, 0, 0, 0, 0 },
  { Perl_magic_gettaint, Perl_magic_settaint, 0, 0, 0, 0, 0, 0 },
  { 0, Perl_magic_setutf8, 0, 0, 0, 0, 0, 0 },
  { Perl_magic_getuvar, Perl_magic_setuvar, 0, 0, 0, 0, 0, 0 },
  { Perl_magic_getvec, Perl_magic_setvec, 0, 0, 0, 0, 0, 0 }
};
#else
EXT_MGVTBL PL_magic_vtables[magic_vtable_max];
#endif

#define want_vtbl_bm want_vtbl_regexp
#define want_vtbl_fm want_vtbl_regexp

#define PL_vtbl_arylen PL_magic_vtables[want_vtbl_arylen]
#define PL_vtbl_arylen_p PL_magic_vtables[want_vtbl_arylen_p]
#define PL_vtbl_backref PL_magic_vtables[want_vtbl_backref]
#define PL_vtbl_bm PL_magic_vtables[want_vtbl_bm]
#define PL_vtbl_checkcall PL_magic_vtables[want_vtbl_checkcall]
#define PL_vtbl_collxfrm PL_magic_vtables[want_vtbl_collxfrm]
#define PL_vtbl_dbline PL_magic_vtables[want_vtbl_dbline]
#define PL_vtbl_defelem PL_magic_vtables[want_vtbl_defelem]
#define PL_vtbl_env PL_magic_vtables[want_vtbl_env]
#define PL_vtbl_envelem PL_magic_vtables[want_vtbl_envelem]
#define PL_vtbl_fm PL_magic_vtables[want_vtbl_fm]
#define PL_vtbl_hints PL_magic_vtables[want_vtbl_hints]
#define PL_vtbl_hintselem PL_magic_vtables[want_vtbl_hintselem]
#define PL_vtbl_isa PL_magic_vtables[want_vtbl_isa]
#define PL_vtbl_isaelem PL_magic_vtables[want_vtbl_isaelem]
#define PL_vtbl_mglob PL_magic_vtables[want_vtbl_mglob]
#define PL_vtbl_nkeys PL_magic_vtables[want_vtbl_nkeys]
#define PL_vtbl_ovrld PL_magic_vtables[want_vtbl_ovrld]
#define PL_vtbl_pack PL_magic_vtables[want_vtbl_pack]
#define PL_vtbl_packelem PL_magic_vtables[want_vtbl_packelem]
#define PL_vtbl_pos PL_magic_vtables[want_vtbl_pos]
#define PL_vtbl_regdata PL_magic_vtables[want_vtbl_regdata]
#define PL_vtbl_regdatum PL_magic_vtables[want_vtbl_regdatum]
#define PL_vtbl_regexp PL_magic_vtables[want_vtbl_regexp]
#define PL_vtbl_sigelem PL_magic_vtables[want_vtbl_sigelem]
#define PL_vtbl_substr PL_magic_vtables[want_vtbl_substr]
#define PL_vtbl_sv PL_magic_vtables[want_vtbl_sv]
#define PL_vtbl_taint PL_magic_vtables[want_vtbl_taint]
#define PL_vtbl_utf8 PL_magic_vtables[want_vtbl_utf8]
#define PL_vtbl_uvar PL_magic_vtables[want_vtbl_uvar]
#define PL_vtbl_vec PL_magic_vtables[want_vtbl_vec]

/* ex: set ro: */
                                                                                                                                                                                                                                                                                      usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/mydtrace.h                                                0100644 0000000 0000000 00000005525 12744441327 017724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    mydtrace.h
 *
 *    Copyright (C) 2008, 2010, 2011 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *	Provides macros that wrap the various DTrace probes we use. We add
 *	an extra level of wrapping to encapsulate the _ENABLED tests.
 */

#if defined(USE_DTRACE) && defined(PERL_CORE)

#  include "perldtrace.h"

#  if defined(STAP_PROBE_ADDR) && !defined(DEBUGGING)

/* SystemTap 1.2 uses a construct that chokes on passing a char array
 * as a char *, in this case hek_key in struct hek.  Workaround it
 * with a temporary.
 */

#    define ENTRY_PROBE(func, file, line, stash)  	\
    if (PERL_SUB_ENTRY_ENABLED()) {	        	\
	const char *tmp_func = func;			\
	PERL_SUB_ENTRY(tmp_func, file, line, stash); 	\
    }

#    define RETURN_PROBE(func, file, line, stash) 	\
    if (PERL_SUB_RETURN_ENABLED()) {    		\
	const char *tmp_func = func;			\
	PERL_SUB_RETURN(tmp_func, file, line, stash);	\
    }

#    define LOADING_FILE_PROBE(name) 	                        \
    if (PERL_LOADING_FILE_ENABLED()) {    		        \
	const char *tmp_name = name;			\
	PERL_LOADING_FILE(tmp_name);	                        \
    }

#    define LOADED_FILE_PROBE(name) 	                        \
    if (PERL_LOADED_FILE_ENABLED()) {    		        \
	const char *tmp_name = name;			\
	PERL_LOADED_FILE(tmp_name);	                        \
    }

#  else

#    define ENTRY_PROBE(func, file, line, stash) 	\
    if (PERL_SUB_ENTRY_ENABLED()) {	        	\
	PERL_SUB_ENTRY(func, file, line, stash); 	\
    }

#    define RETURN_PROBE(func, file, line, stash)	\
    if (PERL_SUB_RETURN_ENABLED()) {    		\
	PERL_SUB_RETURN(func, file, line, stash); 	\
    }

#    define LOADING_FILE_PROBE(name)	                        \
    if (PERL_LOADING_FILE_ENABLED()) {    		        \
	PERL_LOADING_FILE(name); 	                                \
    }

#    define LOADED_FILE_PROBE(name)	                        \
    if (PERL_LOADED_FILE_ENABLED()) {    		        \
	PERL_LOADED_FILE(name); 	                                \
    }

#  endif

#  define OP_ENTRY_PROBE(name)	                \
    if (PERL_OP_ENTRY_ENABLED()) {    		        \
	PERL_OP_ENTRY(name); 	                        \
    }

#  define PHASE_CHANGE_PROBE(new_phase, old_phase)      \
    if (PERL_PHASE_CHANGE_ENABLED()) {                  \
	PERL_PHASE_CHANGE(new_phase, old_phase);        \
    }

#else

/* NOPs */
#  define ENTRY_PROBE(func, file, line, stash)
#  define RETURN_PROBE(func, file, line, stash)
#  define PHASE_CHANGE_PROBE(new_phase, old_phase)
#  define OP_ENTRY_PROBE(name)
#  define LOADING_FILE_PROBE(name)
#  define LOADED_FILE_PROBE(name)

#endif

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                           usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/nostdio.h                                                 0100644 0000000 0000000 00000006572 12744441327 017576  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    nostdio.h
 *
 *    Copyright (C) 1996, 2000, 2001, 2005, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * Strong denial of stdio - make all stdio calls (we can think of) errors
 */
/* This is a 1st attempt to stop other include files pulling
   in real <stdio.h>.
   A more ambitious set of possible symbols can be found in
   sfio.h (inside an _cplusplus gard).
   It is completely pointless as we have already included it ourselves.
*/

#if !defined(_STDIO_H) && !defined(FILE) && !defined(_STDIO_INCLUDED) && !defined(__STDIO_LOADED)
#define _STDIO_H
#define _STDIO_INCLUDED
#define __STDIO_LOADED
struct _FILE;
#define FILE struct _FILE
#endif

#define _CANNOT "CANNOT"

#undef clearerr
#undef fclose
#undef fdopen
#undef feof
#undef ferror
#undef fflush
#undef fgetc
#undef fgetpos
#undef fgets
#undef fileno
#undef flockfile
#undef fopen
#undef fprintf
#undef fputc
#undef fputs
#undef fread
#undef freopen
#undef fscanf
#undef fseek
#undef fsetpos
#undef ftell
#undef ftrylockfile
#undef funlockfile
#undef fwrite
#undef getc
#undef getc_unlocked
#undef getw
#undef pclose
#undef popen
#undef putc
#undef putc_unlocked
#undef putw
#undef rewind
#undef setbuf
#undef setvbuf
#undef stderr
#undef stdin
#undef stdout
#undef tmpfile
#undef ungetc
#undef vfprintf
#undef printf

#define fprintf    _CANNOT _fprintf_
#define printf     _CANNOT _printf_
#define stdin      _CANNOT _stdin_
#define stdout     _CANNOT _stdout_
#define stderr     _CANNOT _stderr_
#ifndef OS2
#define tmpfile()  _CANNOT _tmpfile_
#endif
#define fclose(f)  _CANNOT _fclose_
#define fflush(f)  _CANNOT _fflush_
#define fopen(p,m)  _CANNOT _fopen_
#define freopen(p,m,f)  _CANNOT _freopen_
#define setbuf(f,b)  _CANNOT _setbuf_
#define setvbuf(f,b,x,s)  _CANNOT _setvbuf_
#define fscanf  _CANNOT _fscanf_
#define vfprintf(f,fmt,a)  _CANNOT _vfprintf_
#define fgetc(f)  _CANNOT _fgetc_
#define fgets(s,n,f)  _CANNOT _fgets_
#define fputc(c,f)  _CANNOT _fputc_
#define fputs(s,f)  _CANNOT _fputs_
#define getc(f)  _CANNOT _getc_
#define putc(c,f)  _CANNOT _putc_
#ifndef OS2
#define ungetc(c,f)  _CANNOT _ungetc_
#endif
#define fread(b,s,c,f)  _CANNOT _fread_
#define fwrite(b,s,c,f)  _CANNOT _fwrite_
#define fgetpos(f,p)  _CANNOT _fgetpos_
#define fseek(f,o,w)  _CANNOT _fseek_
#define fsetpos(f,p)  _CANNOT _fsetpos_
#define ftell(f)  _CANNOT _ftell_
#define rewind(f)  _CANNOT _rewind_
#define clearerr(f)  _CANNOT _clearerr_
#define feof(f)  _CANNOT _feof_
#define ferror(f)  _CANNOT _ferror_
#define __filbuf(f)  _CANNOT __filbuf_
#define __flsbuf(c,f)  _CANNOT __flsbuf_
#define _filbuf(f)  _CANNOT _filbuf_
#define _flsbuf(c,f)  _CANNOT _flsbuf_
#define fdopen(fd,p)  _CANNOT _fdopen_
#define fileno(f)  _CANNOT _fileno_
#if defined(SFIO_VERSION) && SFIO_VERSION < 20000101L
#define flockfile(f)  _CANNOT _flockfile_
#define ftrylockfile(f)  _CANNOT _ftrylockfile_
#define funlockfile(f)  _CANNOT _funlockfile_
#endif
#define getc_unlocked(f)  _CANNOT _getc_unlocked_
#define putc_unlocked(c,f)  _CANNOT _putc_unlocked_
#define popen(c,m)  _CANNOT _popen_
#define getw(f)  _CANNOT _getw_
#define putw(v,f)  _CANNOT _putw_
#ifndef OS2
#define pclose(f)  _CANNOT _pclose_
#endif

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                      usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/op.h                                                      0100644 0000000 0000000 00000112717 12744441327 016534  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    op.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * The fields of BASEOP are:
 *	op_next		Pointer to next ppcode to execute after this one.
 *			(Top level pre-grafted op points to first op,
 *			but this is replaced when op is grafted in, when
 *			this op will point to the real next op, and the new
 *			parent takes over role of remembering starting op.)
 *	op_ppaddr	Pointer to current ppcode's function.
 *	op_type		The type of the operation.
 *	op_opt		Whether or not the op has been optimised by the
 *			peephole optimiser.
 *	op_slabbed	allocated via opslab
 *	op_static	tell op_free() to skip PerlMemShared_free(), when
 *                      !op_slabbed.
 *	op_savefree	on savestack via SAVEFREEOP
 *	op_folded	Result/remainder of a constant fold operation.
 *	op_spare	Two spare bits
 *	op_flags	Flags common to all operations.  See OPf_* below.
 *	op_private	Flags peculiar to a particular operation (BUT,
 *			by default, set to the number of children until
 *			the operation is privatized by a check routine,
 *			which may or may not check number of children).
 */
#include "op_reg_common.h"

#define OPCODE U16

#ifdef PERL_MAD
#  define MADPROP_IN_BASEOP	MADPROP*	op_madprop;
#else
#  define MADPROP_IN_BASEOP
#endif

typedef PERL_BITFIELD16 Optype;

#ifdef BASEOP_DEFINITION
#define BASEOP BASEOP_DEFINITION
#else
#define BASEOP				\
    OP*		op_next;		\
    OP*		op_sibling;		\
    OP*		(*op_ppaddr)(pTHX);	\
    MADPROP_IN_BASEOP			\
    PADOFFSET	op_targ;		\
    PERL_BITFIELD16 op_type:9;		\
    PERL_BITFIELD16 op_opt:1;		\
    PERL_BITFIELD16 op_slabbed:1;	\
    PERL_BITFIELD16 op_savefree:1;	\
    PERL_BITFIELD16 op_static:1;	\
    PERL_BITFIELD16 op_folded:1;	\
    PERL_BITFIELD16 op_spare:2;		\
    U8		op_flags;		\
    U8		op_private;
#endif

/* If op_type:9 is changed to :10, also change PUSHEVAL in cop.h.
   Also, if the type of op_type is ever changed (e.g. to PERL_BITFIELD32)
   then all the other bit-fields before/after it should change their
   types too to let VC pack them into the same 4 byte integer.*/

/* for efficiency, requires OPf_WANT_VOID == G_VOID etc */
#define OP_GIMME(op,dfl) \
	(((op)->op_flags & OPf_WANT) ? ((op)->op_flags & OPf_WANT) : dfl)

#define OP_GIMME_REVERSE(flags)	((flags) & G_WANT)

/*
=head1 "Gimme" Values

=for apidoc Amn|U32|GIMME_V
The XSUB-writer's equivalent to Perl's C<wantarray>.  Returns C<G_VOID>,
C<G_SCALAR> or C<G_ARRAY> for void, scalar or list context,
respectively.  See L<perlcall> for a usage example.

=for apidoc Amn|U32|GIMME
A backward-compatible version of C<GIMME_V> which can only return
C<G_SCALAR> or C<G_ARRAY>; in a void context, it returns C<G_SCALAR>.
Deprecated.  Use C<GIMME_V> instead.

=cut
*/

#define GIMME_V		OP_GIMME(PL_op, block_gimme())

/* Public flags */

#define OPf_WANT	3	/* Mask for "want" bits: */
#define  OPf_WANT_VOID	 1	/*   Want nothing */
#define  OPf_WANT_SCALAR 2	/*   Want single value */
#define  OPf_WANT_LIST	 3	/*   Want list of any length */
#define OPf_KIDS	4	/* There is a firstborn child. */
#define OPf_PARENS	8	/* This operator was parenthesized. */
				/*  (Or block needs explicit scope entry.) */
#define OPf_REF		16	/* Certified reference. */
				/*  (Return container, not containee). */
#define OPf_MOD		32	/* Will modify (lvalue). */
#define OPf_STACKED	64	/* Some arg is arriving on the stack. */
#define OPf_SPECIAL	128	/* Do something weird for this op: */
				/*  On local LVAL, don't init local value. */
				/*  On OP_SORT, subroutine is inlined. */
				/*  On OP_NOT, inversion was implicit. */
				/*  On OP_LEAVE, don't restore curpm. */
				/*  On truncate, we truncate filehandle */
				/*  On control verbs, we saw no label */
				/*  On flipflop, we saw ... instead of .. */
				/*  On UNOPs, saw bare parens, e.g. eof(). */
				/*  On OP_ENTERSUB || OP_NULL, saw a "do". */
				/*  On OP_EXISTS, treat av as av, not avhv.  */
				/*  On OP_(ENTER|LEAVE)EVAL, don't clear $@ */
                                /*  On pushre, rx is used as part of split, e.g. split " " */
				/*  On regcomp, "use re 'eval'" was in scope */
				/*  On OP_READLINE, was <$filehandle> */
				/*  On RV2[ACGHS]V, don't create GV--in
				    defined()*/
				/*  On OP_DBSTATE, indicates breakpoint
				 *    (runtime property) */
				/*  On OP_REQUIRE, was seen as CORE::require */
				/*  On OP_(ENTER|LEAVE)WHEN, there's
				    no condition */
				/*  On OP_SMARTMATCH, an implicit smartmatch */
				/*  On OP_ANONHASH and OP_ANONLIST, create a
				    reference to the new anon hash or array */
				/*  On OP_HELEM and OP_HSLICE, localization will be followed
				    by assignment, so do not wipe the target if it is special
				    (e.g. a glob or a magic SV) */
				/*  On OP_MATCH, OP_SUBST & OP_TRANS, the
				    operand of a logical or conditional
				    that was optimised away, so it should
				    not be bound via =~ */
				/*  On OP_CONST, from a constant CV */
				/*  On OP_GLOB, two meanings:
				    - Before ck_glob, called as CORE::glob
				    - After ck_glob, use Perl glob function
			         */
                                /*  On OP_PADRANGE, push @_ */
                                /*  On OP_DUMP, has no label */

/* old names; don't use in new code, but don't break them, either */
#define OPf_LIST	OPf_WANT_LIST
#define OPf_KNOW	OPf_WANT

#define GIMME \
	  (PL_op->op_flags & OPf_WANT					\
	   ? ((PL_op->op_flags & OPf_WANT) == OPf_WANT_LIST		\
	      ? G_ARRAY							\
	      : G_SCALAR)						\
	   : dowantarray())

/* Lower bits of op_private often carry the number of arguments, as
 * set by newBINOP, newUNOP and ck_fun */

/* NOTE: OP_NEXTSTATE and OP_DBSTATE (i.e. COPs) carry NATIVE_HINTS
 * in op_private */

/* Private for lvalues */
#define OPpLVAL_INTRO	128	/* Lvalue must be localized or lvalue sub */

/* Private for OPs with TARGLEX */
  /* (lower bits may carry MAXARG) */
#define OPpTARGET_MY		16	/* Target is PADMY. */

/* Private for OP_LEAVE, OP_LEAVESUB, OP_LEAVESUBLV and OP_LEAVEWRITE */
#define OPpREFCOUNTED		64	/* op_targ carries a refcount */

/* Private for OP_LEAVE and OP_LEAVELOOP */
#define OPpLVALUE		128	/* Do not copy return value */

/* Private for OP_AASSIGN */
#define OPpASSIGN_COMMON	64	/* Left & right have syms in common. */

/* Private for OP_SASSIGN */
#define OPpASSIGN_BACKWARDS	64	/* Left & right switched. */
#define OPpASSIGN_CV_TO_GV	128	/* Possible optimisation for constants. */

/* Private for OP_MATCH and OP_SUBST{,CONT} */
#define OPpRUNTIME		64	/* Pattern coming in on the stack */

/* Private for OP_TRANS */
#define OPpTRANS_FROM_UTF	1
#define OPpTRANS_TO_UTF		2
#define OPpTRANS_IDENTICAL	4	/* right side is same as left */
#define OPpTRANS_SQUASH		8
    /* 16 is used for OPpTARGET_MY */
#define OPpTRANS_COMPLEMENT	32
#define OPpTRANS_GROWS		64
#define OPpTRANS_DELETE		128
#define OPpTRANS_ALL	(OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF|OPpTRANS_IDENTICAL|OPpTRANS_SQUASH|OPpTRANS_COMPLEMENT|OPpTRANS_GROWS|OPpTRANS_DELETE)

/* Private for OP_REPEAT */
#define OPpREPEAT_DOLIST	64	/* List replication. */

/* Private for OP_RV2GV, OP_RV2SV, OP_AELEM, OP_HELEM, OP_PADSV */
#define OPpDEREF		(32|64)	/* autovivify: Want ref to something: */
#define OPpDEREF_AV		32	/*   Want ref to AV. */
#define OPpDEREF_HV		64	/*   Want ref to HV. */
#define OPpDEREF_SV		(32|64)	/*   Want ref to SV. */

/* OP_ENTERSUB and OP_RV2CV flags

Flags are set on entersub and rv2cv in three phases:
  parser  - the parser passes the flag to the op constructor
  check   - the check routine called by the op constructor sets the flag
  context - application of scalar/ref/lvalue context applies the flag

In the third stage, an entersub op might turn into an rv2cv op (undef &foo,
\&foo, lock &foo, exists &foo, defined &foo).  The two places where that
happens (op_lvalue_flags and doref in op.c) need to make sure the flags do
not conflict.  Flags applied in the context phase are only set when there
is no conversion of op type.

  bit  entersub flag       phase   rv2cv flag             phase
  ---  -------------       -----   ----------             -----
    1  OPpENTERSUB_INARGS  context OPpMAY_RETURN_CONSTANT context
    2  HINT_STRICT_REFS    check   HINT_STRICT_REFS       check
    4  OPpENTERSUB_HASTARG check
    8                              OPpENTERSUB_AMPER      parser
   16  OPpENTERSUB_DB      check
   32  OPpDEREF_AV         context
   64  OPpDEREF_HV         context
  128  OPpLVAL_INTRO       context OPpENTERSUB_NOPAREN    parser

*/

  /* OP_ENTERSUB only */
#define OPpENTERSUB_DB		16	/* Debug subroutine. */
#define OPpENTERSUB_HASTARG	4	/* Called from OP tree. */
#define OPpENTERSUB_INARGS	1	/* Lval used as arg to a sub. */
/* used by OPpDEREF             (32|64) */
/* used by HINT_STRICT_REFS     2          */
  /* Mask for OP_ENTERSUB flags, the absence of which must be propagated
     in dynamic context */
#define OPpENTERSUB_LVAL_MASK (OPpLVAL_INTRO|OPpENTERSUB_INARGS)

  /* OP_RV2CV only */
#define OPpENTERSUB_AMPER	8	/* Used & form to call. */
#define OPpENTERSUB_NOPAREN	128	/* bare sub call (without parens) */
#define OPpMAY_RETURN_CONSTANT	1	/* If a constant sub, return the constant */

  /* OP_GV only */
#define OPpEARLY_CV		32	/* foo() called before sub foo was parsed */
  /* OP_?ELEM only */
#define OPpLVAL_DEFER		16	/* Defer creation of array/hash elem */
  /* OP_RV2[AH]V OP_[AH]SLICE */
#define OPpSLICEWARNING		4	/* warn about @hash{$scalar} */
  /* OP_RV2[SAH]V, OP_GVSV, OP_ENTERITER only */
#define OPpOUR_INTRO		16	/* Variable was in an our() */
  /* OP_RV2[AGH]V, OP_PAD[AH]V, OP_[AH]ELEM, OP_[AH]SLICE OP_AV2ARYLEN,
     OP_R?KEYS, OP_SUBSTR, OP_POS, OP_VEC */
#define OPpMAYBE_LVSUB		8	/* We might be an lvalue to return */
  /* OP_RV2HV and OP_PADHV */
#define OPpTRUEBOOL		32	/* %hash in (%hash || $foo) in
					   void context */
#define OPpMAYBE_TRUEBOOL	64	/* %hash in (%hash || $foo) where
					   cx is not known till run time */

  /* OP_SUBSTR only */
#define OPpSUBSTR_REPL_FIRST	16	/* 1st arg is replacement string */

  /* OP_PADSV only */
#define OPpPAD_STATE		16	/* is a "state" pad */
  /* for OP_RV2?V, lower bits carry hints (currently only HINT_STRICT_REFS) */

  /* OP_PADRANGE only */
  /* bit 7 is OPpLVAL_INTRO */
#define OPpPADRANGE_COUNTMASK	127	/* bits 6..0 hold target range, */
#define OPpPADRANGE_COUNTSHIFT	7	/* 7 bits in total */

  /* OP_RV2GV only */
#define OPpDONT_INIT_GV		4	/* Call gv_fetchpv with GV_NOINIT */
/* (Therefore will return whatever is currently in the symbol table, not
   guaranteed to be a PVGV)  */
#define OPpALLOW_FAKE		16	/* OK to return fake glob */

/* Private for OP_ENTERITER and OP_ITER */
#define OPpITER_REVERSED	4	/* for (reverse ...) */
#define OPpITER_DEF		8	/* for $_ or for my $_ */

/* Private for OP_CONST */
#define	OPpCONST_NOVER		2	/* no 6; */
#define	OPpCONST_SHORTCIRCUIT	4	/* eg the constant 5 in (5 || foo) */
#define	OPpCONST_STRICT		8	/* bareword subject to strict 'subs' */
#define OPpCONST_ENTERED	16	/* Has been entered as symbol. */
#define OPpCONST_BARE		64	/* Was a bare word (filehandle?). */

/* Private for OP_FLIP/FLOP */
#define OPpFLIP_LINENUM		64	/* Range arg potentially a line num. */

/* Private for OP_LIST */
#define OPpLIST_GUESSED		64	/* Guessed that pushmark was needed. */

/* Private for OP_DELETE */
#define OPpSLICE		64	/* Operating on a list of keys */
/* Also OPpLVAL_INTRO (128) */

/* Private for OP_EXISTS */
#define OPpEXISTS_SUB		64	/* Checking for &sub, not {} or [].  */

/* Private for OP_SORT */
#define OPpSORT_NUMERIC		1	/* Optimized away { $a <=> $b } */
#define OPpSORT_INTEGER		2	/* Ditto while under "use integer" */
#define OPpSORT_REVERSE		4	/* Reversed sort */
#define OPpSORT_INPLACE		8	/* sort in-place; eg @a = sort @a */
#define OPpSORT_DESCEND		16	/* Descending sort */
#define OPpSORT_QSORT		32	/* Use quicksort (not mergesort) */
#define OPpSORT_STABLE		64	/* Use a stable algorithm */

/* Private for OP_REVERSE */
#define OPpREVERSE_INPLACE	8	/* reverse in-place (@a = reverse @a) */

/* Private for OP_OPEN and OP_BACKTICK */
#define OPpOPEN_IN_RAW		16	/* binmode(F,":raw") on input fh */
#define OPpOPEN_IN_CRLF		32	/* binmode(F,":crlf") on input fh */
#define OPpOPEN_OUT_RAW		64	/* binmode(F,":raw") on output fh */
#define OPpOPEN_OUT_CRLF	128	/* binmode(F,":crlf") on output fh */

/* Private for COPs */
#define OPpHUSH_VMSISH		32	/* hush DCL exit msg vmsish mode*/
/* Note: Used for NATIVE_HINTS (shifted from the values in PL_hints),
	 currently defined by vms/vmsish.h:
				64
				128
 */

/* Private for OP_FTXXX */
#define OPpFT_ACCESS		2	/* use filetest 'access' */
#define OPpFT_STACKED		4	/* stacked filetest, as "-f" in "-f -x $f" */
#define OPpFT_STACKING		8	/* stacking filetest, as "-x" in "-f -x $f" */
#define OPpFT_AFTER_t		16	/* previous op was -t */

/* Private for OP_(MAP|GREP)(WHILE|START) */
#define OPpGREP_LEX		2	/* iterate over lexical $_ */
    
/* Private for OP_ENTEREVAL */
#define OPpEVAL_HAS_HH		2	/* Does it have a copy of %^H */
#define OPpEVAL_UNICODE		4
#define OPpEVAL_BYTES		8
#define OPpEVAL_COPHH		16	/* Construct %^H from cop hints */
#define OPpEVAL_RE_REPARSING	32	/* eval_sv(..., G_RE_REPARSING) */
    
/* Private for OP_CALLER, OP_WANTARRAY and OP_RUNCV */
#define OPpOFFBYONE		128	/* Treat caller(1) as caller(2) */

/* Private for OP_COREARGS */
/* These must not conflict with OPpDONT_INIT_GV or OPpALLOW_FAKE.
   See pp.c:S_rv2gv. */
#define OPpCOREARGS_DEREF1	1	/* Arg 1 is a handle constructor */
#define OPpCOREARGS_DEREF2	2	/* Arg 2 is a handle constructor */
#define OPpCOREARGS_SCALARMOD	64	/* \$ rather than \[$@%*] */
#define OPpCOREARGS_PUSHMARK	128	/* Call pp_pushmark */

/* Private for OP_(LAST|REDO|NEXT|GOTO|DUMP) */
#define OPpPV_IS_UTF8		128	/* label is in UTF8 */

/* Private for OP_SPLIT */
#define OPpSPLIT_IMPLIM		128	/* implicit limit */

struct op {
    BASEOP
};

struct unop {
    BASEOP
    OP *	op_first;
};

struct binop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
};

struct logop {
    BASEOP
    OP *	op_first;
    OP *	op_other;
};

struct listop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
};

struct pmop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
#ifdef USE_ITHREADS
    PADOFFSET   op_pmoffset;
#else
    REGEXP *    op_pmregexp;            /* compiled expression */
#endif
    U32         op_pmflags;
    union {
	OP *	op_pmreplroot;		/* For OP_SUBST */
#ifdef USE_ITHREADS
	PADOFFSET  op_pmtargetoff;	/* For OP_PUSHRE */
#else
	GV *	op_pmtargetgv;
#endif
    }	op_pmreplrootu;
    union {
	OP *	op_pmreplstart;	/* Only used in OP_SUBST */
#ifdef USE_ITHREADS
	PADOFFSET op_pmstashoff; /* Only used in OP_MATCH, with PMf_ONCE set */
#else
	HV *	op_pmstash;
#endif
    }		op_pmstashstartu;
    OP *	op_code_list;	/* list of (?{}) code blocks */
};

#ifdef USE_ITHREADS
#define PM_GETRE(o)	(SvTYPE(PL_regex_pad[(o)->op_pmoffset]) == SVt_REGEXP \
		 	 ? (REGEXP*)(PL_regex_pad[(o)->op_pmoffset]) : NULL)
/* The assignment is just to enforce type safety (or at least get a warning).
 */
/* With first class regexps not via a reference one needs to assign
   &PL_sv_undef under ithreads. (This would probably work unthreaded, but NULL
   is cheaper. I guess we could allow NULL, but the check above would get
   more complex, and we'd have an AV with (SV*)NULL in it, which feels bad */
/* BEWARE - something that calls this macro passes (r) which has a side
   effect.  */
#define PM_SETRE(o,r)	STMT_START {					\
                            REGEXP *const _pm_setre = (r);		\
                            assert(_pm_setre);				\
			    PL_regex_pad[(o)->op_pmoffset] = MUTABLE_SV(_pm_setre); \
                        } STMT_END
#else
#define PM_GETRE(o)     ((o)->op_pmregexp)
#define PM_SETRE(o,r)   ((o)->op_pmregexp = (r))
#endif

/* Leave some space, so future bit allocations can go either in the shared or
 * unshared area without affecting binary compatibility */
#define PMf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT+6)

/* 'use re "taint"' in scope: taint $1 etc. if target tainted */
#define PMf_RETAINT	(1<<(PMf_BASE_SHIFT+0))

/* match successfully only once per reset, with related flag RXf_USED in
 * re->extflags holding state.  This is used only for ?? matches, and only on
 * OP_MATCH and OP_QR */
#define PMf_ONCE	(1<<(PMf_BASE_SHIFT+1))

/* PMf_ONCE, i.e. ?pat?, has matched successfully.  Not used under threading. */
#define PMf_USED        (1<<(PMf_BASE_SHIFT+3))

/* subst replacement is constant */
#define PMf_CONST	(1<<(PMf_BASE_SHIFT+4))

/* keep 1st runtime pattern forever */
#define PMf_KEEP	(1<<(PMf_BASE_SHIFT+5))

#define PMf_GLOBAL	(1<<(PMf_BASE_SHIFT+6))	/* pattern had a g modifier */

/* don't reset pos() if //g fails */
#define PMf_CONTINUE	(1<<(PMf_BASE_SHIFT+7))

/* evaluating replacement as expr */
#define PMf_EVAL	(1<<(PMf_BASE_SHIFT+8))

/* Return substituted string instead of modifying it. */
#define PMf_NONDESTRUCT	(1<<(PMf_BASE_SHIFT+9))

/* the pattern has a CV attached (currently only under qr/...(?{}).../) */
#define PMf_HAS_CV	(1<<(PMf_BASE_SHIFT+10))

/* op_code_list is private; don't free it etc. It may well point to
 * code within another sub, with different pad etc */
#define PMf_CODELIST_PRIVATE	(1<<(PMf_BASE_SHIFT+11))

/* the PMOP is a QR (we should be able to detect that from the op type,
 * but the regex compilation API passes just the pm flags, not the op
 * itself */
#define PMf_IS_QR	(1<<(PMf_BASE_SHIFT+12))
#define PMf_USE_RE_EVAL	(1<<(PMf_BASE_SHIFT+13)) /* use re'eval' in scope */

#if PMf_BASE_SHIFT+13 > 31
#   error Too many PMf_ bits used.  See above and regnodes.h for any spare in middle
#endif

#ifdef USE_ITHREADS

#  define PmopSTASH(o)         ((o)->op_pmflags & PMf_ONCE                         \
                                ? PL_stashpad[(o)->op_pmstashstartu.op_pmstashoff]   \
                                : NULL)
#  define PmopSTASH_set(o,hv)	\
	(assert_((o)->op_pmflags & PMf_ONCE)				\
	 (o)->op_pmstashstartu.op_pmstashoff =				\
	    (hv) ? alloccopstash(hv) : 0)
#else
#  define PmopSTASH(o)							\
    (((o)->op_pmflags & PMf_ONCE) ? (o)->op_pmstashstartu.op_pmstash : NULL)
#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#    define PmopSTASH_set(o,hv)		({				\
	assert((o)->op_pmflags & PMf_ONCE);				\
	((o)->op_pmstashstartu.op_pmstash = (hv));			\
    })
#  else
#    define PmopSTASH_set(o,hv)	((o)->op_pmstashstartu.op_pmstash = (hv))
#  endif
#endif
#define PmopSTASHPV(o)	(PmopSTASH(o) ? HvNAME_get(PmopSTASH(o)) : NULL)
   /* op_pmstashstartu.op_pmstash is not refcounted */
#define PmopSTASHPV_set(o,pv)	PmopSTASH_set((o), gv_stashpv(pv,GV_ADD))

struct svop {
    BASEOP
    SV *	op_sv;
};

struct padop {
    BASEOP
    PADOFFSET	op_padix;
};

struct pvop {
    BASEOP
    char *	op_pv;
};

struct loop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
    OP *	op_redoop;
    OP *	op_nextop;
    OP *	op_lastop;
};

#define cUNOPx(o)	((UNOP*)o)
#define cBINOPx(o)	((BINOP*)o)
#define cLISTOPx(o)	((LISTOP*)o)
#define cLOGOPx(o)	((LOGOP*)o)
#define cPMOPx(o)	((PMOP*)o)
#define cSVOPx(o)	((SVOP*)o)
#define cPADOPx(o)	((PADOP*)o)
#define cPVOPx(o)	((PVOP*)o)
#define cCOPx(o)	((COP*)o)
#define cLOOPx(o)	((LOOP*)o)

#define cUNOP		cUNOPx(PL_op)
#define cBINOP		cBINOPx(PL_op)
#define cLISTOP		cLISTOPx(PL_op)
#define cLOGOP		cLOGOPx(PL_op)
#define cPMOP		cPMOPx(PL_op)
#define cSVOP		cSVOPx(PL_op)
#define cPADOP		cPADOPx(PL_op)
#define cPVOP		cPVOPx(PL_op)
#define cCOP		cCOPx(PL_op)
#define cLOOP		cLOOPx(PL_op)

#define cUNOPo		cUNOPx(o)
#define cBINOPo		cBINOPx(o)
#define cLISTOPo	cLISTOPx(o)
#define cLOGOPo		cLOGOPx(o)
#define cPMOPo		cPMOPx(o)
#define cSVOPo		cSVOPx(o)
#define cPADOPo		cPADOPx(o)
#define cPVOPo		cPVOPx(o)
#define cCOPo		cCOPx(o)
#define cLOOPo		cLOOPx(o)

#define kUNOP		cUNOPx(kid)
#define kBINOP		cBINOPx(kid)
#define kLISTOP		cLISTOPx(kid)
#define kLOGOP		cLOGOPx(kid)
#define kPMOP		cPMOPx(kid)
#define kSVOP		cSVOPx(kid)
#define kPADOP		cPADOPx(kid)
#define kPVOP		cPVOPx(kid)
#define kCOP		cCOPx(kid)
#define kLOOP		cLOOPx(kid)


#ifdef USE_ITHREADS
#  define	cGVOPx_gv(o)	((GV*)PAD_SVl(cPADOPx(o)->op_padix))
#  define	IS_PADGV(v)	(v && SvTYPE(v) == SVt_PVGV && isGV_with_GP(v) \
				 && GvIN_PAD(v))
#  define	IS_PADCONST(v) \
	(v && (SvREADONLY(v) || (SvIsCOW(v) && !SvLEN(v))))
#  define	cSVOPx_sv(v)	(cSVOPx(v)->op_sv \
				 ? cSVOPx(v)->op_sv : PAD_SVl((v)->op_targ))
#  define	cSVOPx_svp(v)	(cSVOPx(v)->op_sv \
				 ? &cSVOPx(v)->op_sv : &PAD_SVl((v)->op_targ))
#else
#  define	cGVOPx_gv(o)	((GV*)cSVOPx(o)->op_sv)
#  define	IS_PADGV(v)	FALSE
#  define	IS_PADCONST(v)	FALSE
#  define	cSVOPx_sv(v)	(cSVOPx(v)->op_sv)
#  define	cSVOPx_svp(v)	(&cSVOPx(v)->op_sv)
#endif

#define	cGVOP_gv		cGVOPx_gv(PL_op)
#define	cGVOPo_gv		cGVOPx_gv(o)
#define	kGVOP_gv		cGVOPx_gv(kid)
#define cSVOP_sv		cSVOPx_sv(PL_op)
#define cSVOPo_sv		cSVOPx_sv(o)
#define kSVOP_sv		cSVOPx_sv(kid)

#ifndef PERL_CORE
#  define Nullop ((OP*)NULL)
#endif

/* Lowest byte of PL_opargs */
#define OA_MARK 1
#define OA_FOLDCONST 2
#define OA_RETSCALAR 4
#define OA_TARGET 8
#define OA_TARGLEX 16
#define OA_OTHERINT 32
#define OA_DANGEROUS 64
#define OA_DEFGV 128

/* The next 4 bits encode op class information */
#define OCSHIFT 8

#define OA_CLASS_MASK (15 << OCSHIFT)

#define OA_BASEOP (0 << OCSHIFT)
#define OA_UNOP (1 << OCSHIFT)
#define OA_BINOP (2 << OCSHIFT)
#define OA_LOGOP (3 << OCSHIFT)
#define OA_LISTOP (4 << OCSHIFT)
#define OA_PMOP (5 << OCSHIFT)
#define OA_SVOP (6 << OCSHIFT)
#define OA_PADOP (7 << OCSHIFT)
#define OA_PVOP_OR_SVOP (8 << OCSHIFT)
#define OA_LOOP (9 << OCSHIFT)
#define OA_COP (10 << OCSHIFT)
#define OA_BASEOP_OR_UNOP (11 << OCSHIFT)
#define OA_FILESTATOP (12 << OCSHIFT)
#define OA_LOOPEXOP (13 << OCSHIFT)

#define OASHIFT 12

/* Remaining nybbles of PL_opargs */
#define OA_SCALAR 1
#define OA_LIST 2
#define OA_AVREF 3
#define OA_HVREF 4
#define OA_CVREF 5
#define OA_FILEREF 6
#define OA_SCALARREF 7
#define OA_OPTIONAL 8

/* Op_REFCNT is a reference count at the head of each op tree: needed
 * since the tree is shared between threads, and between cloned closure
 * copies in the same thread. OP_REFCNT_LOCK/UNLOCK is used when modifying
 * this count.
 * The same mutex is used to protect the refcounts of the reg_trie_data
 * and reg_ac_data structures, which are shared between duplicated
 * regexes.
 */

#ifdef USE_ITHREADS
#  define OP_REFCNT_INIT		MUTEX_INIT(&PL_op_mutex)
#  ifdef PERL_CORE
#    define OP_REFCNT_LOCK		MUTEX_LOCK(&PL_op_mutex)
#    define OP_REFCNT_UNLOCK		MUTEX_UNLOCK(&PL_op_mutex)
#  else
#    define OP_REFCNT_LOCK		op_refcnt_lock()
#    define OP_REFCNT_UNLOCK		op_refcnt_unlock()
#  endif
#  define OP_REFCNT_TERM		MUTEX_DESTROY(&PL_op_mutex)
#else
#  define OP_REFCNT_INIT		NOOP
#  define OP_REFCNT_LOCK		NOOP
#  define OP_REFCNT_UNLOCK		NOOP
#  define OP_REFCNT_TERM		NOOP
#endif

#define OpREFCNT_set(o,n)		((o)->op_targ = (n))
#ifdef PERL_DEBUG_READONLY_OPS
#  define OpREFCNT_inc(o)		Perl_op_refcnt_inc(aTHX_ o)
#  define OpREFCNT_dec(o)		Perl_op_refcnt_dec(aTHX_ o)
#else
#  define OpREFCNT_inc(o)		((o) ? (++(o)->op_targ, (o)) : NULL)
#  define OpREFCNT_dec(o)		(--(o)->op_targ)
#endif

/* flags used by Perl_load_module() */
#define PERL_LOADMOD_DENY		0x1	/* no Module */
#define PERL_LOADMOD_NOIMPORT		0x2	/* use Module () */
#define PERL_LOADMOD_IMPORT_OPS		0x4	/* use Module (...) */

#if defined(PERL_IN_PERLY_C) || defined(PERL_IN_OP_C) || defined(PERL_IN_TOKE_C)
#define ref(o, type) doref(o, type, TRUE)
#endif

/*
=head1 Optree Manipulation Functions

=for apidoc Am|OP*|LINKLIST|OP *o
Given the root of an optree, link the tree in execution order using the
C<op_next> pointers and return the first op executed.  If this has
already been done, it will not be redone, and C<< o->op_next >> will be
returned.  If C<< o->op_next >> is not already set, I<o> should be at
least an C<UNOP>.

=cut
*/

#define LINKLIST(o) ((o)->op_next ? (o)->op_next : op_linklist((OP*)o))

/* no longer used anywhere in core */
#ifndef PERL_CORE
#define cv_ckproto(cv, gv, p) \
   cv_ckproto_len_flags((cv), (gv), (p), (p) ? strlen(p) : 0, 0)
#endif

#ifdef PERL_CORE
#  define my(o)	my_attrs((o), NULL)
#endif

#ifdef USE_REENTRANT_API
#include "reentr.h"
#endif

#define NewOp(m,var,c,type)	\
	(var = (type *) Perl_Slab_Alloc(aTHX_ c*sizeof(type)))
#define NewOpSz(m,var,size)	\
	(var = (OP *) Perl_Slab_Alloc(aTHX_ size))
#define FreeOp(p) Perl_Slab_Free(aTHX_ p)

/*
 * The per-CV op slabs consist of a header (the opslab struct) and a bunch
 * of space for allocating op slots, each of which consists of two pointers
 * followed by an op.  The first pointer points to the next op slot.  The
 * second points to the slab.  At the end of the slab is a null pointer,
 * so that slot->opslot_next - slot can be used to determine the size
 * of the op.
 *
 * Each CV can have multiple slabs; opslab_next points to the next slab, to
 * form a chain.  All bookkeeping is done on the first slab, which is where
 * all the op slots point.
 *
 * Freed ops are marked as freed and attached to the freed chain
 * via op_next pointers.
 *
 * When there is more than one slab, the second slab in the slab chain is
 * assumed to be the one with free space available.  It is used when allo-
 * cating an op if there are no freed ops available or big enough.
 */

#ifdef PERL_CORE
struct opslot {
    /* keep opslot_next first */
    OPSLOT *	opslot_next;		/* next slot */
    OPSLAB *	opslot_slab;		/* owner */
    OP		opslot_op;		/* the op itself */
};

struct opslab {
    OPSLOT *	opslab_first;		/* first op in this slab */
    OPSLAB *	opslab_next;		/* next slab */
    OP *	opslab_freed;		/* chain of freed ops */
    size_t	opslab_refcnt;		/* number of ops */
# ifdef PERL_DEBUG_READONLY_OPS
    U16		opslab_size;		/* size of slab in pointers */
    bool	opslab_readonly;
# endif
    OPSLOT	opslab_slots;		/* slots begin here */
};

# define OPSLOT_HEADER		STRUCT_OFFSET(OPSLOT, opslot_op)
# define OPSLOT_HEADER_P	(OPSLOT_HEADER/sizeof(I32 *))
# define OpSLOT(o)		(assert_(o->op_slabbed) \
				 (OPSLOT *)(((char *)o)-OPSLOT_HEADER))
# define OpSLAB(o)		OpSLOT(o)->opslot_slab
# define OpslabREFCNT_dec(slab)      \
	(((slab)->opslab_refcnt == 1) \
	 ? opslab_free_nopad(slab)     \
	 : (void)--(slab)->opslab_refcnt)
  /* Variant that does not null out the pads */
# define OpslabREFCNT_dec_padok(slab) \
	(((slab)->opslab_refcnt == 1)  \
	 ? opslab_free(slab)		\
	 : (void)--(slab)->opslab_refcnt)
#endif

struct block_hooks {
    U32	    bhk_flags;
    void    (*bhk_start)	(pTHX_ int full);
    void    (*bhk_pre_end)	(pTHX_ OP **seq);
    void    (*bhk_post_end)	(pTHX_ OP **seq);
    void    (*bhk_eval)		(pTHX_ OP *const saveop);
};

/*
=head1 Compile-time scope hooks

=for apidoc mx|U32|BhkFLAGS|BHK *hk
Return the BHK's flags.

=for apidoc mx|void *|BhkENTRY|BHK *hk|which
Return an entry from the BHK structure.  I<which> is a preprocessor token
indicating which entry to return.  If the appropriate flag is not set
this will return NULL.  The type of the return value depends on which
entry you ask for.

=for apidoc Amx|void|BhkENTRY_set|BHK *hk|which|void *ptr
Set an entry in the BHK structure, and set the flags to indicate it is
valid.  I<which> is a preprocessing token indicating which entry to set.
The type of I<ptr> depends on the entry.

=for apidoc Amx|void|BhkDISABLE|BHK *hk|which
Temporarily disable an entry in this BHK structure, by clearing the
appropriate flag.  I<which> is a preprocessor token indicating which
entry to disable.

=for apidoc Amx|void|BhkENABLE|BHK *hk|which
Re-enable an entry in this BHK structure, by setting the appropriate
flag.  I<which> is a preprocessor token indicating which entry to enable.
This will assert (under -DDEBUGGING) if the entry doesn't contain a valid
pointer.

=for apidoc mx|void|CALL_BLOCK_HOOKS|which|arg
Call all the registered block hooks for type I<which>.  I<which> is a
preprocessing token; the type of I<arg> depends on I<which>.

=cut
*/

#define BhkFLAGS(hk)		((hk)->bhk_flags)

#define BHKf_bhk_start	    0x01
#define BHKf_bhk_pre_end    0x02
#define BHKf_bhk_post_end   0x04
#define BHKf_bhk_eval	    0x08

#define BhkENTRY(hk, which) \
    ((BhkFLAGS(hk) & BHKf_ ## which) ? ((hk)->which) : NULL)

#define BhkENABLE(hk, which) \
    STMT_START { \
	BhkFLAGS(hk) |= BHKf_ ## which; \
	assert(BhkENTRY(hk, which)); \
    } STMT_END

#define BhkDISABLE(hk, which) \
    STMT_START { \
	BhkFLAGS(hk) &= ~(BHKf_ ## which); \
    } STMT_END

#define BhkENTRY_set(hk, which, ptr) \
    STMT_START { \
	(hk)->which = ptr; \
	BhkENABLE(hk, which); \
    } STMT_END

#define CALL_BLOCK_HOOKS(which, arg) \
    STMT_START { \
	if (PL_blockhooks) { \
	    SSize_t i; \
	    for (i = av_tindex(PL_blockhooks); i >= 0; i--) { \
		SV *sv = AvARRAY(PL_blockhooks)[i]; \
		BHK *hk; \
		\
		assert(SvIOK(sv)); \
		if (SvUOK(sv)) \
		    hk = INT2PTR(BHK *, SvUVX(sv)); \
		else \
		    hk = INT2PTR(BHK *, SvIVX(sv)); \
		\
		if (BhkENTRY(hk, which)) \
		    BhkENTRY(hk, which)(aTHX_ arg); \
	    } \
	} \
    } STMT_END

/* flags for rv2cv_op_cv */

#define RV2CVOPCV_MARK_EARLY     0x00000001
#define RV2CVOPCV_RETURN_NAME_GV 0x00000002

#define op_lvalue(op,t) Perl_op_lvalue_flags(aTHX_ op,t,0)

/* flags for op_lvalue_flags */

#define OP_LVALUE_NO_CROAK 1

/*
=head1 Custom Operators

=for apidoc Am|U32|XopFLAGS|XOP *xop
Return the XOP's flags.

=for apidoc Am||XopENTRY|XOP *xop|which
Return a member of the XOP structure.  I<which> is a cpp token
indicating which entry to return.  If the member is not set
this will return a default value.  The return type depends
on I<which>.  This macro evaluates its arguments more than
once.  If you are using C<Perl_custom_op_xop> to retreive a
C<XOP *> from a C<OP *>, use the more efficient L</XopENTRYCUSTOM> instead.

=for apidoc Am||XopENTRYCUSTOM|const OP *o|which
Exactly like C<XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)> but more
efficient.  The I<which> parameter is identical to L</XopENTRY>.

=for apidoc Am|void|XopENTRY_set|XOP *xop|which|value
Set a member of the XOP structure.  I<which> is a cpp token
indicating which entry to set.  See L<perlguts/"Custom Operators">
for details about the available members and how
they are used.  This macro evaluates its argument
more than once.

=for apidoc Am|void|XopDISABLE|XOP *xop|which
Temporarily disable a member of the XOP, by clearing the appropriate flag.

=for apidoc Am|void|XopENABLE|XOP *xop|which
Reenable a member of the XOP which has been disabled.

=cut
*/

struct custom_op {
    U32		    xop_flags;    
    const char	   *xop_name;
    const char	   *xop_desc;
    U32		    xop_class;
    void	  (*xop_peep)(pTHX_ OP *o, OP *oldop);
};

/* return value of Perl_custom_op_get_field, similar to void * then casting but
   the U32 doesn't need truncation on 64 bit platforms in the caller, also
   for easier macro writing */
typedef union {
    const char	   *xop_name;
    const char	   *xop_desc;
    U32		    xop_class;
    void	  (*xop_peep)(pTHX_ OP *o, OP *oldop);
    XOP            *xop_ptr;
} XOPRETANY;

#define XopFLAGS(xop) ((xop)->xop_flags)

#define XOPf_xop_name	0x01
#define XOPf_xop_desc	0x02
#define XOPf_xop_class	0x04
#define XOPf_xop_peep	0x08

/* used by Perl_custom_op_get_field for option checking */
typedef enum {
    XOPe_xop_ptr = 0, /* just get the XOP *, don't look inside it */
    XOPe_xop_name = XOPf_xop_name,
    XOPe_xop_desc = XOPf_xop_desc,
    XOPe_xop_class = XOPf_xop_class,
    XOPe_xop_peep = XOPf_xop_peep
} xop_flags_enum;

#define XOPd_xop_name	PL_op_name[OP_CUSTOM]
#define XOPd_xop_desc	PL_op_desc[OP_CUSTOM]
#define XOPd_xop_class	OA_BASEOP
#define XOPd_xop_peep	((Perl_cpeep_t)0)

#define XopENTRY_set(xop, which, to) \
    STMT_START { \
	(xop)->which = (to); \
	(xop)->xop_flags |= XOPf_ ## which; \
    } STMT_END

#define XopENTRY(xop, which) \
    ((XopFLAGS(xop) & XOPf_ ## which) ? (xop)->which : XOPd_ ## which)

#define XopENTRYCUSTOM(o, which) \
    (Perl_custom_op_get_field(aTHX_ o, XOPe_ ## which).which)

#define XopDISABLE(xop, which) ((xop)->xop_flags &= ~XOPf_ ## which)
#define XopENABLE(xop, which) \
    STMT_START { \
	(xop)->xop_flags |= XOPf_ ## which; \
	assert(XopENTRY(xop, which)); \
    } STMT_END

#define Perl_custom_op_xop(x) \
    (Perl_custom_op_get_field(x, XOPe_xop_ptr).xop_ptr)

/*
=head1 Optree Manipulation Functions

=for apidoc Am|const char *|OP_NAME|OP *o
Return the name of the provided OP.  For core ops this looks up the name
from the op_type; for custom ops from the op_ppaddr.

=for apidoc Am|const char *|OP_DESC|OP *o
Return a short description of the provided OP.

=for apidoc Am|U32|OP_CLASS|OP *o
Return the class of the provided OP: that is, which of the *OP
structures it uses.  For core ops this currently gets the information out
of PL_opargs, which does not always accurately reflect the type used.
For custom ops the type is returned from the registration, and it is up
to the registree to ensure it is accurate.  The value returned will be
one of the OA_* constants from op.h.

=for apidoc Am|bool|OP_TYPE_IS|OP *o|Optype type
Returns true if the given OP is not a NULL pointer
and if it is of the given type.

The negation of this macro, C<OP_TYPE_ISNT> is also available
as well as C<OP_TYPE_IS_NN> and C<OP_TYPE_ISNT_NN> which elide
the NULL pointer check.

=for apidoc Am|bool|OP_TYPE_IS_OR_WAS|OP *o|Optype type
Returns true if the given OP is not a NULL pointer and
if it is of the given type or used to be before being
replaced by an OP of type OP_NULL.

The negation of this macro, C<OP_TYPE_ISNT_AND_WASNT>
is also available as well as C<OP_TYPE_IS_OR_WAS_NN>
and C<OP_TYPE_ISNT_AND_WASNT_NN> which elide
the NULL pointer check.

=cut
*/

#define OP_NAME(o) ((o)->op_type == OP_CUSTOM \
                    ? XopENTRYCUSTOM(o, xop_name) \
		    : PL_op_name[(o)->op_type])
#define OP_DESC(o) ((o)->op_type == OP_CUSTOM \
                    ? XopENTRYCUSTOM(o, xop_desc) \
		    : PL_op_desc[(o)->op_type])
#define OP_CLASS(o) ((o)->op_type == OP_CUSTOM \
		     ? XopENTRYCUSTOM(o, xop_class) \
		     : (PL_opargs[(o)->op_type] & OA_CLASS_MASK))

#define OP_TYPE_IS(o, type) ((o) && (o)->op_type == (type))
#define OP_TYPE_IS_NN(o, type) ((o)->op_type == (type))
#define OP_TYPE_ISNT(o, type) ((o) && (o)->op_type != (type))
#define OP_TYPE_ISNT_NN(o, type) ((o)->op_type != (type))

#define OP_TYPE_IS_OR_WAS_NN(o, type) \
    ( ((o)->op_type == OP_NULL \
       ? (o)->op_targ \
       : (o)->op_type) \
      == (type) )

#define OP_TYPE_IS_OR_WAS(o, type) \
    ( (o) && OP_TYPE_IS_OR_WAS_NN(o, type) )

#define OP_TYPE_ISNT_AND_WASNT_NN(o, type) \
    ( ((o)->op_type == OP_NULL \
       ? (o)->op_targ \
       : (o)->op_type) \
      != (type) )

#define OP_TYPE_ISNT_AND_WASNT(o, type) \
    ( (o) && OP_TYPE_ISNT_AND_WASNT_NN(o, type) )

#define newATTRSUB(f, o, p, a, b) Perl_newATTRSUB_x(aTHX_  f, o, p, a, b, FALSE)
#define newSUB(f, o, p, b)	newATTRSUB((f), (o), (p), NULL, (b))

#ifdef PERL_MAD
#  define MAD_NULL 1
#  define MAD_PV 2
#  define MAD_OP 3
#  define MAD_SV 4

struct madprop {
    MADPROP* mad_next;
    void *mad_val;
    U32 mad_vlen;
/*    short mad_count; */
    char mad_key;
    char mad_type;
};

struct token {
    I32 tk_type;
    YYSTYPE tk_lval;
    MADPROP* tk_mad;
};
#endif

/*
 * Values that can be held by mad_key :
 * ^       unfilled head spot
 * ,       literal ,
 * ;       literal ; (blank if implicit ; at end of block)
 * :       literal : from ?: or attr list
 * +       unary +
 * ?       literal ? from ?:
 * (       literal (
 * )       literal )
 * [       literal [
 * ]       literal ]
 * {       literal {
 * }       literal }
 * @       literal @ sigil
 * $       literal $ sigil
 * *       literal * sigil
 * !       use is source filtered
 * &       & or sub
 * #       whitespace/comment following ; or }
 * #       $# sigil
 * 1       1st ; from for(;;)
 * 1       retired protasis
 * 2       2nd ; from for(;;)
 * 2       retired apodosis
 * 3       C-style for list
 * a       sub or var attributes
 * a       non-method arrow operator
 * A       method arrow operator
 * A       use import args
 * b       format block
 * B       retired stub block
 * C       constant conditional op
 * d       declarator
 * D       do block
 * e       unreached "else" (see C)
 * e       expression producing E
 * E       tr/E/R/, /E/
 * f       folded constant op
 * F       peg op for format
 * g       op was forced to be a word
 * i       if/unless modifier
 * I       if/elsif/unless statement
 * k       local declarator
 * K       retired kid op
 * l       last index of array ($#foo)
 * L       label
 * m       modifier on regex
 * n       sub or format name
 * o       current operator/declarator name
 * o       else/continue
 * O       generic optimized op
 * p       peg to hold extra whitespace at statement level
 * P       peg op for package declaration
 * q       opening quote
 * =       quoted material
 * Q       closing quote
 * Q       optimized qw//
 * r       expression producing R
 * R       tr/E/R/ s/E/R/
 * s       sub signature
 * S       use import stub (no import)
 * S       retired sort block
 * t       unreached "then" (see C)
 * U       use import op
 * v       private sv of for loop
 * V       use version
 * w       while/until modifier
 * W       while/for statement
 * x       optimized qw
 * X       random thing
 * _       whitespace/comments preceding anything else
 * ~       =~ operator
 */

/*
=head1 Hook manipulation
*/

#ifdef USE_ITHREADS
#  define OP_CHECK_MUTEX_INIT		MUTEX_INIT(&PL_check_mutex)
#  define OP_CHECK_MUTEX_LOCK		MUTEX_LOCK(&PL_check_mutex)
#  define OP_CHECK_MUTEX_UNLOCK		MUTEX_UNLOCK(&PL_check_mutex)
#  define OP_CHECK_MUTEX_TERM		MUTEX_DESTROY(&PL_check_mutex)
#else
#  define OP_CHECK_MUTEX_INIT		NOOP
#  define OP_CHECK_MUTEX_LOCK		NOOP
#  define OP_CHECK_MUTEX_UNLOCK		NOOP
#  define OP_CHECK_MUTEX_TERM		NOOP
#endif

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                 usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/op_reg_common.h                                           0100644 0000000 0000000 00000012126 12744441327 020732  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    op_reg_common.h
 *
 *    Definitions common to by op.h and regexp.h
 *
 *    Copyright (C) 2010, 2011 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* These defines are used in both op.h and regexp.h  The definitions use the
 * shift form so that ext/B/defsubs_h.PL will pick them up.
 *
 * Data structures used in the two headers have common fields, and in fact one
 * is copied onto the other.  This makes it easy to keep them in sync */

/* This tells where the first of these bits is.  Setting it to 0 saved cycles
 * and memory.  I (khw) think the code will work if changed back, but haven't
 * tested it */
/* Make sure to update ext/re/re.pm when changing this! */
#ifndef RXf_PMf_STD_PMMOD_SHIFT /* Only expand #include of this file once */

#define RXf_PMf_STD_PMMOD_SHIFT 0

/* The bits need to be ordered so that the msix are contiguous starting at bit
 * RXf_PMf_STD_PMMOD_SHIFT, followed by the p.  See STD_PAT_MODS and
 * INT_PAT_MODS in regexp.h for the reason contiguity is needed */
/* Make sure to update lib/re.pm when changing these! */
/* Make sure you keep the pure PMf_ versions below in sync */
#define RXf_PMf_MULTILINE      (1 << (RXf_PMf_STD_PMMOD_SHIFT+0))    /* /m */
#define RXf_PMf_SINGLELINE     (1 << (RXf_PMf_STD_PMMOD_SHIFT+1))    /* /s */
#define RXf_PMf_FOLD           (1 << (RXf_PMf_STD_PMMOD_SHIFT+2))    /* /i */
#define RXf_PMf_EXTENDED       (1 << (RXf_PMf_STD_PMMOD_SHIFT+3))    /* /x */
#define RXf_PMf_KEEPCOPY       (1 << (RXf_PMf_STD_PMMOD_SHIFT+4))    /* /p */

/* The character set for the regex is stored in a field of more than one bit
 * using an enum, for reasons of compactness and to ensure that the options are
 * mutually exclusive */
/* Make sure to update ext/re/re.pm and regcomp.sym (as these are used as
 * offsets for various node types, like POSIXD vs POSIXL, etc) when changing
 * this! */
typedef enum {
    REGEX_DEPENDS_CHARSET = 0,
    REGEX_LOCALE_CHARSET,
    REGEX_UNICODE_CHARSET,
    REGEX_ASCII_RESTRICTED_CHARSET,
    REGEX_ASCII_MORE_RESTRICTED_CHARSET
} regex_charset;

#define _RXf_PMf_CHARSET_SHIFT ((RXf_PMf_STD_PMMOD_SHIFT)+5)
#define RXf_PMf_CHARSET (7 << (_RXf_PMf_CHARSET_SHIFT)) /* 3 bits */

/* Manually decorate these functions here with gcc-style attributes just to
 * avoid making the regex_charset typedef global, which it would need to be for
 * proto.h to understand it */
PERL_STATIC_INLINE void
set_regex_charset(U32 * const flags, const regex_charset cs)
    __attribute__nonnull__(1);

PERL_STATIC_INLINE void
set_regex_charset(U32 * const flags, const regex_charset cs)
{
    /* Sets the character set portion of 'flags' to 'cs', which is a member of
     * the above enum */

    *flags &= ~RXf_PMf_CHARSET;
    *flags |= (cs << _RXf_PMf_CHARSET_SHIFT);
}

PERL_STATIC_INLINE regex_charset
get_regex_charset(const U32 flags)
    __attribute__warn_unused_result__;

PERL_STATIC_INLINE regex_charset
get_regex_charset(const U32 flags)
{
    /* Returns the enum corresponding to the character set in 'flags' */

    return (regex_charset) ((flags & RXf_PMf_CHARSET) >> _RXf_PMf_CHARSET_SHIFT);
}

#define _RXf_PMf_SHIFT_COMPILETIME (RXf_PMf_STD_PMMOD_SHIFT+8)

/*
  Set in Perl_pmruntime if op_flags & OPf_SPECIAL, i.e. split. Will
  be used by regex engines to check whether they should set
  RXf_SKIPWHITE
*/
#define RXf_PMf_SPLIT (1<<(RXf_PMf_STD_PMMOD_SHIFT+8))

/* Next available bit after the above.  Name begins with '_' so won't be
 * exported by B */
#define _RXf_PMf_SHIFT_NEXT (RXf_PMf_STD_PMMOD_SHIFT+9)

/* Mask of the above bits.  These need to be transferred from op_pmflags to
 * re->extflags during compilation */
#define RXf_PMf_COMPILETIME    (RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_FOLD|RXf_PMf_EXTENDED|RXf_PMf_KEEPCOPY|RXf_PMf_CHARSET)
#define RXf_PMf_FLAGCOPYMASK   (RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_FOLD|RXf_PMf_EXTENDED|RXf_PMf_KEEPCOPY|RXf_PMf_CHARSET|RXf_PMf_SPLIT)

#if RXf_PMf_COMPILETIME > 255
#  error RXf_PMf_COMPILETIME wont fit in U8 flags field of eval node
#endif

/* These copies need to be numerical or defsubs_h.PL won't know about them. */
#define PMf_MULTILINE    1<<0
#define PMf_SINGLELINE   1<<1
#define PMf_FOLD         1<<2
#define PMf_EXTENDED     1<<3
#define PMf_KEEPCOPY     1<<4
#define PMf_CHARSET      7<<5
#define PMf_SPLIT        1<<8

#if PMf_MULTILINE != RXf_PMf_MULTILINE || PMf_SINGLELINE != RXf_PMf_SINGLELINE || PMf_FOLD != RXf_PMf_FOLD || PMf_EXTENDED != RXf_PMf_EXTENDED || PMf_KEEPCOPY != RXf_PMf_KEEPCOPY || PMf_SPLIT != RXf_PMf_SPLIT || PMf_CHARSET != RXf_PMf_CHARSET
#   error RXf_PMf defines are wrong
#endif

/*  Error check that haven't left something out of this.  This isn't done
 *  directly in the #define because doing so confuses regcomp.pl.
 *  (2**n - 1) is n 1 bits, so the below gets the contiguous bits between the
 *  beginning and ending shifts */
#if RXf_PMf_COMPILETIME != (((1 << (_RXf_PMf_SHIFT_COMPILETIME))-1) \
                            & (~((1 << RXf_PMf_STD_PMMOD_SHIFT)-1)))
#   error RXf_PMf_COMPILETIME is invalid
#endif

#endif /* Include only once */
                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/opcode.h                                                  0100644 0000000 0000000 00000135443 12744441327 017370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    opcode.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/opcode.pl from its data.
 * Any changes made here will be lost!
 */

#ifndef PERL_GLOBAL_STRUCT_INIT

#define Perl_pp_scalar Perl_pp_null
#define Perl_pp_padany Perl_unimplemented_op
#define Perl_pp_regcmaybe Perl_pp_null
#define Perl_pp_transr Perl_pp_trans
#define Perl_pp_chomp Perl_pp_chop
#define Perl_pp_schomp Perl_pp_schop
#define Perl_pp_i_preinc Perl_pp_preinc
#define Perl_pp_predec Perl_pp_preinc
#define Perl_pp_i_predec Perl_pp_preinc
#define Perl_pp_i_postinc Perl_pp_postinc
#define Perl_pp_postdec Perl_pp_postinc
#define Perl_pp_i_postdec Perl_pp_postinc
#define Perl_pp_slt Perl_pp_sle
#define Perl_pp_sgt Perl_pp_sle
#define Perl_pp_sge Perl_pp_sle
#define Perl_pp_bit_xor Perl_pp_bit_or
#define Perl_pp_cos Perl_pp_sin
#define Perl_pp_exp Perl_pp_sin
#define Perl_pp_log Perl_pp_sin
#define Perl_pp_sqrt Perl_pp_sin
#define Perl_pp_hex Perl_pp_oct
#define Perl_pp_rindex Perl_pp_index
#define Perl_pp_lcfirst Perl_pp_ucfirst
#define Perl_pp_aelemfast_lex Perl_pp_aelemfast
#define Perl_pp_avalues Perl_pp_akeys
#define Perl_pp_values Perl_do_kv
#define Perl_pp_keys Perl_do_kv
#define Perl_pp_rv2hv Perl_pp_rv2av
#define Perl_pp_pop Perl_pp_shift
#define Perl_pp_mapstart Perl_unimplemented_op
#define Perl_pp_dor Perl_pp_defined
#define Perl_pp_andassign Perl_pp_and
#define Perl_pp_orassign Perl_pp_or
#define Perl_pp_dorassign Perl_pp_defined
#define Perl_pp_lineseq Perl_pp_null
#define Perl_pp_scope Perl_pp_null
#define Perl_pp_dump Perl_pp_goto
#define Perl_pp_dbmclose Perl_pp_untie
#define Perl_pp_read Perl_pp_sysread
#define Perl_pp_say Perl_pp_print
#define Perl_pp_seek Perl_pp_sysseek
#define Perl_pp_fcntl Perl_pp_ioctl
#ifdef HAS_SOCKET
#define Perl_pp_send Perl_pp_syswrite
#define Perl_pp_recv Perl_pp_sysread
#else
#define Perl_pp_send Perl_unimplemented_op
#define Perl_pp_recv Perl_unimplemented_op
#define Perl_pp_socket Perl_unimplemented_op
#endif
#ifdef HAS_SOCKET
#define Perl_pp_connect Perl_pp_bind
#define Perl_pp_gsockopt Perl_pp_ssockopt
#define Perl_pp_getsockname Perl_pp_getpeername
#else
#define Perl_pp_bind Perl_unimplemented_op
#define Perl_pp_connect Perl_unimplemented_op
#define Perl_pp_listen Perl_unimplemented_op
#define Perl_pp_accept Perl_unimplemented_op
#define Perl_pp_shutdown Perl_unimplemented_op
#define Perl_pp_gsockopt Perl_unimplemented_op
#define Perl_pp_ssockopt Perl_unimplemented_op
#define Perl_pp_getsockname Perl_unimplemented_op
#define Perl_pp_getpeername Perl_unimplemented_op
#endif
#define Perl_pp_lstat Perl_pp_stat
#define Perl_pp_ftrwrite Perl_pp_ftrread
#define Perl_pp_ftrexec Perl_pp_ftrread
#define Perl_pp_fteread Perl_pp_ftrread
#define Perl_pp_ftewrite Perl_pp_ftrread
#define Perl_pp_fteexec Perl_pp_ftrread
#define Perl_pp_ftsize Perl_pp_ftis
#define Perl_pp_ftmtime Perl_pp_ftis
#define Perl_pp_ftatime Perl_pp_ftis
#define Perl_pp_ftctime Perl_pp_ftis
#define Perl_pp_fteowned Perl_pp_ftrowned
#define Perl_pp_ftzero Perl_pp_ftrowned
#define Perl_pp_ftsock Perl_pp_ftrowned
#define Perl_pp_ftchr Perl_pp_ftrowned
#define Perl_pp_ftblk Perl_pp_ftrowned
#define Perl_pp_ftfile Perl_pp_ftrowned
#define Perl_pp_ftdir Perl_pp_ftrowned
#define Perl_pp_ftpipe Perl_pp_ftrowned
#define Perl_pp_ftsuid Perl_pp_ftrowned
#define Perl_pp_ftsgid Perl_pp_ftrowned
#define Perl_pp_ftsvtx Perl_pp_ftrowned
#define Perl_pp_ftbinary Perl_pp_fttext
#define Perl_pp_unlink Perl_pp_chown
#define Perl_pp_chmod Perl_pp_chown
#define Perl_pp_utime Perl_pp_chown
#define Perl_pp_symlink Perl_pp_link
#define Perl_pp_kill Perl_pp_chown
#define Perl_pp_localtime Perl_pp_gmtime
#define Perl_pp_shmget Perl_pp_semget
#define Perl_pp_shmctl Perl_pp_semctl
#define Perl_pp_shmread Perl_pp_shmwrite
#define Perl_pp_msgget Perl_pp_semget
#define Perl_pp_msgctl Perl_pp_semctl
#define Perl_pp_msgsnd Perl_pp_shmwrite
#define Perl_pp_msgrcv Perl_pp_shmwrite
#define Perl_pp_semop Perl_pp_shmwrite
#define Perl_pp_dofile Perl_pp_require
#define Perl_pp_ghbyname Perl_pp_ghostent
#define Perl_pp_ghbyaddr Perl_pp_ghostent
#define Perl_pp_gnbyname Perl_pp_gnetent
#define Perl_pp_gnbyaddr Perl_pp_gnetent
#define Perl_pp_gpbyname Perl_pp_gprotoent
#define Perl_pp_gpbynumber Perl_pp_gprotoent
#define Perl_pp_gsbyname Perl_pp_gservent
#define Perl_pp_gsbyport Perl_pp_gservent
#define Perl_pp_snetent Perl_pp_shostent
#define Perl_pp_sprotoent Perl_pp_shostent
#define Perl_pp_sservent Perl_pp_shostent
#define Perl_pp_enetent Perl_pp_ehostent
#define Perl_pp_eprotoent Perl_pp_ehostent
#define Perl_pp_eservent Perl_pp_ehostent
#define Perl_pp_gpwnam Perl_pp_gpwent
#define Perl_pp_gpwuid Perl_pp_gpwent
#define Perl_pp_spwent Perl_pp_ehostent
#define Perl_pp_epwent Perl_pp_ehostent
#define Perl_pp_ggrnam Perl_pp_ggrent
#define Perl_pp_ggrgid Perl_pp_ggrent
#define Perl_pp_sgrent Perl_pp_ehostent
#define Perl_pp_egrent Perl_pp_ehostent
#define Perl_pp_custom Perl_unimplemented_op
#define Perl_pp_reach Perl_pp_rkeys
#define Perl_pp_rvalues Perl_pp_rkeys
START_EXTERN_C

#ifndef DOINIT
EXTCONST char* const PL_op_name[];
#else
EXTCONST char* const PL_op_name[] = {
	"null",
	"stub",
	"scalar",
	"pushmark",
	"wantarray",
	"const",
	"gvsv",
	"gv",
	"gelem",
	"padsv",
	"padav",
	"padhv",
	"padany",
	"pushre",
	"rv2gv",
	"rv2sv",
	"av2arylen",
	"rv2cv",
	"anoncode",
	"prototype",
	"refgen",
	"srefgen",
	"ref",
	"bless",
	"backtick",
	"glob",
	"readline",
	"rcatline",
	"regcmaybe",
	"regcreset",
	"regcomp",
	"match",
	"qr",
	"subst",
	"substcont",
	"trans",
	"transr",
	"sassign",
	"aassign",
	"chop",
	"schop",
	"chomp",
	"schomp",
	"defined",
	"undef",
	"study",
	"pos",
	"preinc",
	"i_preinc",
	"predec",
	"i_predec",
	"postinc",
	"i_postinc",
	"postdec",
	"i_postdec",
	"pow",
	"multiply",
	"i_multiply",
	"divide",
	"i_divide",
	"modulo",
	"i_modulo",
	"repeat",
	"add",
	"i_add",
	"subtract",
	"i_subtract",
	"concat",
	"stringify",
	"left_shift",
	"right_shift",
	"lt",
	"i_lt",
	"gt",
	"i_gt",
	"le",
	"i_le",
	"ge",
	"i_ge",
	"eq",
	"i_eq",
	"ne",
	"i_ne",
	"ncmp",
	"i_ncmp",
	"slt",
	"sgt",
	"sle",
	"sge",
	"seq",
	"sne",
	"scmp",
	"bit_and",
	"bit_xor",
	"bit_or",
	"negate",
	"i_negate",
	"not",
	"complement",
	"smartmatch",
	"atan2",
	"sin",
	"cos",
	"rand",
	"srand",
	"exp",
	"log",
	"sqrt",
	"int",
	"hex",
	"oct",
	"abs",
	"length",
	"substr",
	"vec",
	"index",
	"rindex",
	"sprintf",
	"formline",
	"ord",
	"chr",
	"crypt",
	"ucfirst",
	"lcfirst",
	"uc",
	"lc",
	"quotemeta",
	"rv2av",
	"aelemfast",
	"aelemfast_lex",
	"aelem",
	"aslice",
	"kvaslice",
	"aeach",
	"akeys",
	"avalues",
	"each",
	"values",
	"keys",
	"delete",
	"exists",
	"rv2hv",
	"helem",
	"hslice",
	"kvhslice",
	"unpack",
	"pack",
	"split",
	"join",
	"list",
	"lslice",
	"anonlist",
	"anonhash",
	"splice",
	"push",
	"pop",
	"shift",
	"unshift",
	"sort",
	"reverse",
	"grepstart",
	"grepwhile",
	"mapstart",
	"mapwhile",
	"range",
	"flip",
	"flop",
	"and",
	"or",
	"xor",
	"dor",
	"cond_expr",
	"andassign",
	"orassign",
	"dorassign",
	"method",
	"entersub",
	"leavesub",
	"leavesublv",
	"caller",
	"warn",
	"die",
	"reset",
	"lineseq",
	"nextstate",
	"dbstate",
	"unstack",
	"enter",
	"leave",
	"scope",
	"enteriter",
	"iter",
	"enterloop",
	"leaveloop",
	"return",
	"last",
	"next",
	"redo",
	"dump",
	"goto",
	"exit",
	"method_named",
	"entergiven",
	"leavegiven",
	"enterwhen",
	"leavewhen",
	"break",
	"continue",
	"open",
	"close",
	"pipe_op",
	"fileno",
	"umask",
	"binmode",
	"tie",
	"untie",
	"tied",
	"dbmopen",
	"dbmclose",
	"sselect",
	"select",
	"getc",
	"read",
	"enterwrite",
	"leavewrite",
	"prtf",
	"print",
	"say",
	"sysopen",
	"sysseek",
	"sysread",
	"syswrite",
	"eof",
	"tell",
	"seek",
	"truncate",
	"fcntl",
	"ioctl",
	"flock",
	"send",
	"recv",
	"socket",
	"sockpair",
	"bind",
	"connect",
	"listen",
	"accept",
	"shutdown",
	"gsockopt",
	"ssockopt",
	"getsockname",
	"getpeername",
	"lstat",
	"stat",
	"ftrread",
	"ftrwrite",
	"ftrexec",
	"fteread",
	"ftewrite",
	"fteexec",
	"ftis",
	"ftsize",
	"ftmtime",
	"ftatime",
	"ftctime",
	"ftrowned",
	"fteowned",
	"ftzero",
	"ftsock",
	"ftchr",
	"ftblk",
	"ftfile",
	"ftdir",
	"ftpipe",
	"ftsuid",
	"ftsgid",
	"ftsvtx",
	"ftlink",
	"fttty",
	"fttext",
	"ftbinary",
	"chdir",
	"chown",
	"chroot",
	"unlink",
	"chmod",
	"utime",
	"rename",
	"link",
	"symlink",
	"readlink",
	"mkdir",
	"rmdir",
	"open_dir",
	"readdir",
	"telldir",
	"seekdir",
	"rewinddir",
	"closedir",
	"fork",
	"wait",
	"waitpid",
	"system",
	"exec",
	"kill",
	"getppid",
	"getpgrp",
	"setpgrp",
	"getpriority",
	"setpriority",
	"time",
	"tms",
	"localtime",
	"gmtime",
	"alarm",
	"sleep",
	"shmget",
	"shmctl",
	"shmread",
	"shmwrite",
	"msgget",
	"msgctl",
	"msgsnd",
	"msgrcv",
	"semop",
	"semget",
	"semctl",
	"require",
	"dofile",
	"hintseval",
	"entereval",
	"leaveeval",
	"entertry",
	"leavetry",
	"ghbyname",
	"ghbyaddr",
	"ghostent",
	"gnbyname",
	"gnbyaddr",
	"gnetent",
	"gpbyname",
	"gpbynumber",
	"gprotoent",
	"gsbyname",
	"gsbyport",
	"gservent",
	"shostent",
	"snetent",
	"sprotoent",
	"sservent",
	"ehostent",
	"enetent",
	"eprotoent",
	"eservent",
	"gpwnam",
	"gpwuid",
	"gpwent",
	"spwent",
	"epwent",
	"ggrnam",
	"ggrgid",
	"ggrent",
	"sgrent",
	"egrent",
	"getlogin",
	"syscall",
	"lock",
	"once",
	"custom",
	"reach",
	"rkeys",
	"rvalues",
	"coreargs",
	"runcv",
	"fc",
	"padcv",
	"introcv",
	"clonecv",
	"padrange",
	"freed",
};
#endif

#ifndef DOINIT
EXTCONST char* const PL_op_desc[];
#else
EXTCONST char* const PL_op_desc[] = {
	"null operation",
	"stub",
	"scalar",
	"pushmark",
	"wantarray",
	"constant item",
	"scalar variable",
	"glob value",
	"glob elem",
	"private variable",
	"private array",
	"private hash",
	"private value",
	"push regexp",
	"ref-to-glob cast",
	"scalar dereference",
	"array length",
	"subroutine dereference",
	"anonymous subroutine",
	"subroutine prototype",
	"reference constructor",
	"single ref constructor",
	"reference-type operator",
	"bless",
	"quoted execution (``, qx)",
	"glob",
	"<HANDLE>",
	"append I/O operator",
	"regexp internal guard",
	"regexp internal reset",
	"regexp compilation",
	"pattern match (m//)",
	"pattern quote (qr//)",
	"substitution (s///)",
	"substitution iterator",
	"transliteration (tr///)",
	"transliteration (tr///)",
	"scalar assignment",
	"list assignment",
	"chop",
	"scalar chop",
	"chomp",
	"scalar chomp",
	"defined operator",
	"undef operator",
	"study",
	"match position",
	"preincrement (++)",
	"integer preincrement (++)",
	"predecrement (--)",
	"integer predecrement (--)",
	"postincrement (++)",
	"integer postincrement (++)",
	"postdecrement (--)",
	"integer postdecrement (--)",
	"exponentiation (**)",
	"multiplication (*)",
	"integer multiplication (*)",
	"division (/)",
	"integer division (/)",
	"modulus (%)",
	"integer modulus (%)",
	"repeat (x)",
	"addition (+)",
	"integer addition (+)",
	"subtraction (-)",
	"integer subtraction (-)",
	"concatenation (.) or string",
	"string",
	"left bitshift (<<)",
	"right bitshift (>>)",
	"numeric lt (<)",
	"integer lt (<)",
	"numeric gt (>)",
	"integer gt (>)",
	"numeric le (<=)",
	"integer le (<=)",
	"numeric ge (>=)",
	"integer ge (>=)",
	"numeric eq (==)",
	"integer eq (==)",
	"numeric ne (!=)",
	"integer ne (!=)",
	"numeric comparison (<=>)",
	"integer comparison (<=>)",
	"string lt",
	"string gt",
	"string le",
	"string ge",
	"string eq",
	"string ne",
	"string comparison (cmp)",
	"bitwise and (&)",
	"bitwise xor (^)",
	"bitwise or (|)",
	"negation (-)",
	"integer negation (-)",
	"not",
	"1's complement (~)",
	"smart match",
	"atan2",
	"sin",
	"cos",
	"rand",
	"srand",
	"exp",
	"log",
	"sqrt",
	"int",
	"hex",
	"oct",
	"abs",
	"length",
	"substr",
	"vec",
	"index",
	"rindex",
	"sprintf",
	"formline",
	"ord",
	"chr",
	"crypt",
	"ucfirst",
	"lcfirst",
	"uc",
	"lc",
	"quotemeta",
	"array dereference",
	"constant array element",
	"constant lexical array element",
	"array element",
	"array slice",
	"index/value array slice",
	"each on array",
	"keys on array",
	"values on array",
	"each",
	"values",
	"keys",
	"delete",
	"exists",
	"hash dereference",
	"hash element",
	"hash slice",
	"key/value hash slice",
	"unpack",
	"pack",
	"split",
	"join or string",
	"list",
	"list slice",
	"anonymous list ([])",
	"anonymous hash ({})",
	"splice",
	"push",
	"pop",
	"shift",
	"unshift",
	"sort",
	"reverse",
	"grep",
	"grep iterator",
	"map",
	"map iterator",
	"flipflop",
	"range (or flip)",
	"range (or flop)",
	"logical and (&&)",
	"logical or (||)",
	"logical xor",
	"defined or (//)",
	"conditional expression",
	"logical and assignment (&&=)",
	"logical or assignment (||=)",
	"defined or assignment (//=)",
	"method lookup",
	"subroutine entry",
	"subroutine exit",
	"lvalue subroutine return",
	"caller",
	"warn",
	"die",
	"symbol reset",
	"line sequence",
	"next statement",
	"debug next statement",
	"iteration finalizer",
	"block entry",
	"block exit",
	"block",
	"foreach loop entry",
	"foreach loop iterator",
	"loop entry",
	"loop exit",
	"return",
	"last",
	"next",
	"redo",
	"dump",
	"goto",
	"exit",
	"method with known name",
	"given()",
	"leave given block",
	"when()",
	"leave when block",
	"break",
	"continue",
	"open",
	"close",
	"pipe",
	"fileno",
	"umask",
	"binmode",
	"tie",
	"untie",
	"tied",
	"dbmopen",
	"dbmclose",
	"select system call",
	"select",
	"getc",
	"read",
	"write",
	"write exit",
	"printf",
	"print",
	"say",
	"sysopen",
	"sysseek",
	"sysread",
	"syswrite",
	"eof",
	"tell",
	"seek",
	"truncate",
	"fcntl",
	"ioctl",
	"flock",
	"send",
	"recv",
	"socket",
	"socketpair",
	"bind",
	"connect",
	"listen",
	"accept",
	"shutdown",
	"getsockopt",
	"setsockopt",
	"getsockname",
	"getpeername",
	"lstat",
	"stat",
	"-R",
	"-W",
	"-X",
	"-r",
	"-w",
	"-x",
	"-e",
	"-s",
	"-M",
	"-A",
	"-C",
	"-O",
	"-o",
	"-z",
	"-S",
	"-c",
	"-b",
	"-f",
	"-d",
	"-p",
	"-u",
	"-g",
	"-k",
	"-l",
	"-t",
	"-T",
	"-B",
	"chdir",
	"chown",
	"chroot",
	"unlink",
	"chmod",
	"utime",
	"rename",
	"link",
	"symlink",
	"readlink",
	"mkdir",
	"rmdir",
	"opendir",
	"readdir",
	"telldir",
	"seekdir",
	"rewinddir",
	"closedir",
	"fork",
	"wait",
	"waitpid",
	"system",
	"exec",
	"kill",
	"getppid",
	"getpgrp",
	"setpgrp",
	"getpriority",
	"setpriority",
	"time",
	"times",
	"localtime",
	"gmtime",
	"alarm",
	"sleep",
	"shmget",
	"shmctl",
	"shmread",
	"shmwrite",
	"msgget",
	"msgctl",
	"msgsnd",
	"msgrcv",
	"semop",
	"semget",
	"semctl",
	"require",
	"do \"file\"",
	"eval hints",
	"eval \"string\"",
	"eval \"string\" exit",
	"eval {block}",
	"eval {block} exit",
	"gethostbyname",
	"gethostbyaddr",
	"gethostent",
	"getnetbyname",
	"getnetbyaddr",
	"getnetent",
	"getprotobyname",
	"getprotobynumber",
	"getprotoent",
	"getservbyname",
	"getservbyport",
	"getservent",
	"sethostent",
	"setnetent",
	"setprotoent",
	"setservent",
	"endhostent",
	"endnetent",
	"endprotoent",
	"endservent",
	"getpwnam",
	"getpwuid",
	"getpwent",
	"setpwent",
	"endpwent",
	"getgrnam",
	"getgrgid",
	"getgrent",
	"setgrent",
	"endgrent",
	"getlogin",
	"syscall",
	"lock",
	"once",
	"unknown custom operator",
	"each on reference",
	"keys on reference",
	"values on reference",
	"CORE:: subroutine",
	"__SUB__",
	"fc",
	"private subroutine",
	"private subroutine",
	"private subroutine",
	"list of private variables",
	"freed op",
};
#endif

END_EXTERN_C

#endif /* !PERL_GLOBAL_STRUCT_INIT */

START_EXTERN_C

#ifdef PERL_GLOBAL_STRUCT_INIT
#  define PERL_PPADDR_INITED
static const Perl_ppaddr_t Gppaddr[]
#else
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_PPADDR_INITED
EXT Perl_ppaddr_t PL_ppaddr[] /* or perlvars.h */
#  endif
#endif /* PERL_GLOBAL_STRUCT */
#if (defined(DOINIT) && !defined(PERL_GLOBAL_STRUCT)) || defined(PERL_GLOBAL_STRUCT_INIT)
#  define PERL_PPADDR_INITED
= {
	Perl_pp_null,
	Perl_pp_stub,
	Perl_pp_scalar,	/* implemented by Perl_pp_null */
	Perl_pp_pushmark,
	Perl_pp_wantarray,
	Perl_pp_const,
	Perl_pp_gvsv,
	Perl_pp_gv,
	Perl_pp_gelem,
	Perl_pp_padsv,
	Perl_pp_padav,
	Perl_pp_padhv,
	Perl_pp_padany,	/* implemented by Perl_unimplemented_op */
	Perl_pp_pushre,
	Perl_pp_rv2gv,
	Perl_pp_rv2sv,
	Perl_pp_av2arylen,
	Perl_pp_rv2cv,
	Perl_pp_anoncode,
	Perl_pp_prototype,
	Perl_pp_refgen,
	Perl_pp_srefgen,
	Perl_pp_ref,
	Perl_pp_bless,
	Perl_pp_backtick,
	Perl_pp_glob,
	Perl_pp_readline,
	Perl_pp_rcatline,
	Perl_pp_regcmaybe,	/* implemented by Perl_pp_null */
	Perl_pp_regcreset,
	Perl_pp_regcomp,
	Perl_pp_match,
	Perl_pp_qr,
	Perl_pp_subst,
	Perl_pp_substcont,
	Perl_pp_trans,
	Perl_pp_transr,	/* implemented by Perl_pp_trans */
	Perl_pp_sassign,
	Perl_pp_aassign,
	Perl_pp_chop,
	Perl_pp_schop,
	Perl_pp_chomp,	/* implemented by Perl_pp_chop */
	Perl_pp_schomp,	/* implemented by Perl_pp_schop */
	Perl_pp_defined,
	Perl_pp_undef,
	Perl_pp_study,
	Perl_pp_pos,
	Perl_pp_preinc,
	Perl_pp_i_preinc,	/* implemented by Perl_pp_preinc */
	Perl_pp_predec,	/* implemented by Perl_pp_preinc */
	Perl_pp_i_predec,	/* implemented by Perl_pp_preinc */
	Perl_pp_postinc,
	Perl_pp_i_postinc,	/* implemented by Perl_pp_postinc */
	Perl_pp_postdec,	/* implemented by Perl_pp_postinc */
	Perl_pp_i_postdec,	/* implemented by Perl_pp_postinc */
	Perl_pp_pow,
	Perl_pp_multiply,
	Perl_pp_i_multiply,
	Perl_pp_divide,
	Perl_pp_i_divide,
	Perl_pp_modulo,
	Perl_pp_i_modulo,
	Perl_pp_repeat,
	Perl_pp_add,
	Perl_pp_i_add,
	Perl_pp_subtract,
	Perl_pp_i_subtract,
	Perl_pp_concat,
	Perl_pp_stringify,
	Perl_pp_left_shift,
	Perl_pp_right_shift,
	Perl_pp_lt,
	Perl_pp_i_lt,
	Perl_pp_gt,
	Perl_pp_i_gt,
	Perl_pp_le,
	Perl_pp_i_le,
	Perl_pp_ge,
	Perl_pp_i_ge,
	Perl_pp_eq,
	Perl_pp_i_eq,
	Perl_pp_ne,
	Perl_pp_i_ne,
	Perl_pp_ncmp,
	Perl_pp_i_ncmp,
	Perl_pp_slt,	/* implemented by Perl_pp_sle */
	Perl_pp_sgt,	/* implemented by Perl_pp_sle */
	Perl_pp_sle,
	Perl_pp_sge,	/* implemented by Perl_pp_sle */
	Perl_pp_seq,
	Perl_pp_sne,
	Perl_pp_scmp,
	Perl_pp_bit_and,
	Perl_pp_bit_xor,	/* implemented by Perl_pp_bit_or */
	Perl_pp_bit_or,
	Perl_pp_negate,
	Perl_pp_i_negate,
	Perl_pp_not,
	Perl_pp_complement,
	Perl_pp_smartmatch,
	Perl_pp_atan2,
	Perl_pp_sin,
	Perl_pp_cos,	/* implemented by Perl_pp_sin */
	Perl_pp_rand,
	Perl_pp_srand,
	Perl_pp_exp,	/* implemented by Perl_pp_sin */
	Perl_pp_log,	/* implemented by Perl_pp_sin */
	Perl_pp_sqrt,	/* implemented by Perl_pp_sin */
	Perl_pp_int,
	Perl_pp_hex,	/* implemented by Perl_pp_oct */
	Perl_pp_oct,
	Perl_pp_abs,
	Perl_pp_length,
	Perl_pp_substr,
	Perl_pp_vec,
	Perl_pp_index,
	Perl_pp_rindex,	/* implemented by Perl_pp_index */
	Perl_pp_sprintf,
	Perl_pp_formline,
	Perl_pp_ord,
	Perl_pp_chr,
	Perl_pp_crypt,
	Perl_pp_ucfirst,
	Perl_pp_lcfirst,	/* implemented by Perl_pp_ucfirst */
	Perl_pp_uc,
	Perl_pp_lc,
	Perl_pp_quotemeta,
	Perl_pp_rv2av,
	Perl_pp_aelemfast,
	Perl_pp_aelemfast_lex,	/* implemented by Perl_pp_aelemfast */
	Perl_pp_aelem,
	Perl_pp_aslice,
	Perl_pp_kvaslice,
	Perl_pp_aeach,
	Perl_pp_akeys,
	Perl_pp_avalues,	/* implemented by Perl_pp_akeys */
	Perl_pp_each,
	Perl_pp_values,	/* implemented by Perl_do_kv */
	Perl_pp_keys,	/* implemented by Perl_do_kv */
	Perl_pp_delete,
	Perl_pp_exists,
	Perl_pp_rv2hv,	/* implemented by Perl_pp_rv2av */
	Perl_pp_helem,
	Perl_pp_hslice,
	Perl_pp_kvhslice,
	Perl_pp_unpack,
	Perl_pp_pack,
	Perl_pp_split,
	Perl_pp_join,
	Perl_pp_list,
	Perl_pp_lslice,
	Perl_pp_anonlist,
	Perl_pp_anonhash,
	Perl_pp_splice,
	Perl_pp_push,
	Perl_pp_pop,	/* implemented by Perl_pp_shift */
	Perl_pp_shift,
	Perl_pp_unshift,
	Perl_pp_sort,
	Perl_pp_reverse,
	Perl_pp_grepstart,
	Perl_pp_grepwhile,
	Perl_pp_mapstart,	/* implemented by Perl_unimplemented_op */
	Perl_pp_mapwhile,
	Perl_pp_range,
	Perl_pp_flip,
	Perl_pp_flop,
	Perl_pp_and,
	Perl_pp_or,
	Perl_pp_xor,
	Perl_pp_dor,	/* implemented by Perl_pp_defined */
	Perl_pp_cond_expr,
	Perl_pp_andassign,	/* implemented by Perl_pp_and */
	Perl_pp_orassign,	/* implemented by Perl_pp_or */
	Perl_pp_dorassign,	/* implemented by Perl_pp_defined */
	Perl_pp_method,
	Perl_pp_entersub,
	Perl_pp_leavesub,
	Perl_pp_leavesublv,
	Perl_pp_caller,
	Perl_pp_warn,
	Perl_pp_die,
	Perl_pp_reset,
	Perl_pp_lineseq,	/* implemented by Perl_pp_null */
	Perl_pp_nextstate,
	Perl_pp_dbstate,
	Perl_pp_unstack,
	Perl_pp_enter,
	Perl_pp_leave,
	Perl_pp_scope,	/* implemented by Perl_pp_null */
	Perl_pp_enteriter,
	Perl_pp_iter,
	Perl_pp_enterloop,
	Perl_pp_leaveloop,
	Perl_pp_return,
	Perl_pp_last,
	Perl_pp_next,
	Perl_pp_redo,
	Perl_pp_dump,	/* implemented by Perl_pp_goto */
	Perl_pp_goto,
	Perl_pp_exit,
	Perl_pp_method_named,
	Perl_pp_entergiven,
	Perl_pp_leavegiven,
	Perl_pp_enterwhen,
	Perl_pp_leavewhen,
	Perl_pp_break,
	Perl_pp_continue,
	Perl_pp_open,
	Perl_pp_close,
	Perl_pp_pipe_op,
	Perl_pp_fileno,
	Perl_pp_umask,
	Perl_pp_binmode,
	Perl_pp_tie,
	Perl_pp_untie,
	Perl_pp_tied,
	Perl_pp_dbmopen,
	Perl_pp_dbmclose,	/* implemented by Perl_pp_untie */
	Perl_pp_sselect,
	Perl_pp_select,
	Perl_pp_getc,
	Perl_pp_read,	/* implemented by Perl_pp_sysread */
	Perl_pp_enterwrite,
	Perl_pp_leavewrite,
	Perl_pp_prtf,
	Perl_pp_print,
	Perl_pp_say,	/* implemented by Perl_pp_print */
	Perl_pp_sysopen,
	Perl_pp_sysseek,
	Perl_pp_sysread,
	Perl_pp_syswrite,
	Perl_pp_eof,
	Perl_pp_tell,
	Perl_pp_seek,	/* implemented by Perl_pp_sysseek */
	Perl_pp_truncate,
	Perl_pp_fcntl,	/* implemented by Perl_pp_ioctl */
	Perl_pp_ioctl,
	Perl_pp_flock,
	Perl_pp_send,	/* implemented by Perl_pp_syswrite */
	Perl_pp_recv,	/* implemented by Perl_pp_sysread */
	Perl_pp_socket,
	Perl_pp_sockpair,
	Perl_pp_bind,
	Perl_pp_connect,	/* implemented by Perl_pp_bind */
	Perl_pp_listen,
	Perl_pp_accept,
	Perl_pp_shutdown,
	Perl_pp_gsockopt,	/* implemented by Perl_pp_ssockopt */
	Perl_pp_ssockopt,
	Perl_pp_getsockname,	/* implemented by Perl_pp_getpeername */
	Perl_pp_getpeername,
	Perl_pp_lstat,	/* implemented by Perl_pp_stat */
	Perl_pp_stat,
	Perl_pp_ftrread,
	Perl_pp_ftrwrite,	/* implemented by Perl_pp_ftrread */
	Perl_pp_ftrexec,	/* implemented by Perl_pp_ftrread */
	Perl_pp_fteread,	/* implemented by Perl_pp_ftrread */
	Perl_pp_ftewrite,	/* implemented by Perl_pp_ftrread */
	Perl_pp_fteexec,	/* implemented by Perl_pp_ftrread */
	Perl_pp_ftis,
	Perl_pp_ftsize,	/* implemented by Perl_pp_ftis */
	Perl_pp_ftmtime,	/* implemented by Perl_pp_ftis */
	Perl_pp_ftatime,	/* implemented by Perl_pp_ftis */
	Perl_pp_ftctime,	/* implemented by Perl_pp_ftis */
	Perl_pp_ftrowned,
	Perl_pp_fteowned,	/* implemented by Perl_pp_ftrowned */
	Perl_pp_ftzero,	/* implemented by Perl_pp_ftrowned */
	Perl_pp_ftsock,	/* implemented by Perl_pp_ftrowned */
	Perl_pp_ftchr,	/* implemented by Perl_pp_ftrowned */
	Perl_pp_ftblk,	/* implemented by Perl_pp_ftrowned */
	Perl_pp_ftfile,	/* implemented by Perl_pp_ftrowned */
	Perl_pp_ftdir,	/* implemented by Perl_pp_ftrowned */
	Perl_pp_ftpipe,	/* implemented by Perl_pp_ftrowned */
	Perl_pp_ftsuid,	/* implemented by Perl_pp_ftrowned */
	Perl_pp_ftsgid,	/* implemented by Perl_pp_ftrowned */
	Perl_pp_ftsvtx,	/* implemented by Perl_pp_ftrowned */
	Perl_pp_ftlink,
	Perl_pp_fttty,
	Perl_pp_fttext,
	Perl_pp_ftbinary,	/* implemented by Perl_pp_fttext */
	Perl_pp_chdir,
	Perl_pp_chown,
	Perl_pp_chroot,
	Perl_pp_unlink,	/* implemented by Perl_pp_chown */
	Perl_pp_chmod,	/* implemented by Perl_pp_chown */
	Perl_pp_utime,	/* implemented by Perl_pp_chown */
	Perl_pp_rename,
	Perl_pp_link,
	Perl_pp_symlink,	/* implemented by Perl_pp_link */
	Perl_pp_readlink,
	Perl_pp_mkdir,
	Perl_pp_rmdir,
	Perl_pp_open_dir,
	Perl_pp_readdir,
	Perl_pp_telldir,
	Perl_pp_seekdir,
	Perl_pp_rewinddir,
	Perl_pp_closedir,
	Perl_pp_fork,
	Perl_pp_wait,
	Perl_pp_waitpid,
	Perl_pp_system,
	Perl_pp_exec,
	Perl_pp_kill,	/* implemented by Perl_pp_chown */
	Perl_pp_getppid,
	Perl_pp_getpgrp,
	Perl_pp_setpgrp,
	Perl_pp_getpriority,
	Perl_pp_setpriority,
	Perl_pp_time,
	Perl_pp_tms,
	Perl_pp_localtime,	/* implemented by Perl_pp_gmtime */
	Perl_pp_gmtime,
	Perl_pp_alarm,
	Perl_pp_sleep,
	Perl_pp_shmget,	/* implemented by Perl_pp_semget */
	Perl_pp_shmctl,	/* implemented by Perl_pp_semctl */
	Perl_pp_shmread,	/* implemented by Perl_pp_shmwrite */
	Perl_pp_shmwrite,
	Perl_pp_msgget,	/* implemented by Perl_pp_semget */
	Perl_pp_msgctl,	/* implemented by Perl_pp_semctl */
	Perl_pp_msgsnd,	/* implemented by Perl_pp_shmwrite */
	Perl_pp_msgrcv,	/* implemented by Perl_pp_shmwrite */
	Perl_pp_semop,	/* implemented by Perl_pp_shmwrite */
	Perl_pp_semget,
	Perl_pp_semctl,
	Perl_pp_require,
	Perl_pp_dofile,	/* implemented by Perl_pp_require */
	Perl_pp_hintseval,
	Perl_pp_entereval,
	Perl_pp_leaveeval,
	Perl_pp_entertry,
	Perl_pp_leavetry,
	Perl_pp_ghbyname,	/* implemented by Perl_pp_ghostent */
	Perl_pp_ghbyaddr,	/* implemented by Perl_pp_ghostent */
	Perl_pp_ghostent,
	Perl_pp_gnbyname,	/* implemented by Perl_pp_gnetent */
	Perl_pp_gnbyaddr,	/* implemented by Perl_pp_gnetent */
	Perl_pp_gnetent,
	Perl_pp_gpbyname,	/* implemented by Perl_pp_gprotoent */
	Perl_pp_gpbynumber,	/* implemented by Perl_pp_gprotoent */
	Perl_pp_gprotoent,
	Perl_pp_gsbyname,	/* implemented by Perl_pp_gservent */
	Perl_pp_gsbyport,	/* implemented by Perl_pp_gservent */
	Perl_pp_gservent,
	Perl_pp_shostent,
	Perl_pp_snetent,	/* implemented by Perl_pp_shostent */
	Perl_pp_sprotoent,	/* implemented by Perl_pp_shostent */
	Perl_pp_sservent,	/* implemented by Perl_pp_shostent */
	Perl_pp_ehostent,
	Perl_pp_enetent,	/* implemented by Perl_pp_ehostent */
	Perl_pp_eprotoent,	/* implemented by Perl_pp_ehostent */
	Perl_pp_eservent,	/* implemented by Perl_pp_ehostent */
	Perl_pp_gpwnam,	/* implemented by Perl_pp_gpwent */
	Perl_pp_gpwuid,	/* implemented by Perl_pp_gpwent */
	Perl_pp_gpwent,
	Perl_pp_spwent,	/* implemented by Perl_pp_ehostent */
	Perl_pp_epwent,	/* implemented by Perl_pp_ehostent */
	Perl_pp_ggrnam,	/* implemented by Perl_pp_ggrent */
	Perl_pp_ggrgid,	/* implemented by Perl_pp_ggrent */
	Perl_pp_ggrent,
	Perl_pp_sgrent,	/* implemented by Perl_pp_ehostent */
	Perl_pp_egrent,	/* implemented by Perl_pp_ehostent */
	Perl_pp_getlogin,
	Perl_pp_syscall,
	Perl_pp_lock,
	Perl_pp_once,
	Perl_pp_custom,	/* implemented by Perl_unimplemented_op */
	Perl_pp_reach,	/* implemented by Perl_pp_rkeys */
	Perl_pp_rkeys,
	Perl_pp_rvalues,	/* implemented by Perl_pp_rkeys */
	Perl_pp_coreargs,
	Perl_pp_runcv,
	Perl_pp_fc,
	Perl_pp_padcv,
	Perl_pp_introcv,
	Perl_pp_clonecv,
	Perl_pp_padrange,
}
#endif
#ifdef PERL_PPADDR_INITED
;
#endif

#ifdef PERL_GLOBAL_STRUCT_INIT
#  define PERL_CHECK_INITED
static const Perl_check_t Gcheck[]
#else
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_CHECK_INITED
EXT Perl_check_t PL_check[] /* or perlvars.h */
#  endif
#endif
#if (defined(DOINIT) && !defined(PERL_GLOBAL_STRUCT)) || defined(PERL_GLOBAL_STRUCT_INIT)
#  define PERL_CHECK_INITED
= {
	Perl_ck_null,		/* null */
	Perl_ck_null,		/* stub */
	Perl_ck_fun,		/* scalar */
	Perl_ck_null,		/* pushmark */
	Perl_ck_null,		/* wantarray */
	Perl_ck_svconst,	/* const */
	Perl_ck_null,		/* gvsv */
	Perl_ck_null,		/* gv */
	Perl_ck_null,		/* gelem */
	Perl_ck_null,		/* padsv */
	Perl_ck_null,		/* padav */
	Perl_ck_null,		/* padhv */
	Perl_ck_null,		/* padany */
	Perl_ck_null,		/* pushre */
	Perl_ck_rvconst,	/* rv2gv */
	Perl_ck_rvconst,	/* rv2sv */
	Perl_ck_null,		/* av2arylen */
	Perl_ck_rvconst,	/* rv2cv */
	Perl_ck_anoncode,	/* anoncode */
	Perl_ck_null,		/* prototype */
	Perl_ck_spair,		/* refgen */
	Perl_ck_null,		/* srefgen */
	Perl_ck_fun,		/* ref */
	Perl_ck_fun,		/* bless */
	Perl_ck_backtick,	/* backtick */
	Perl_ck_glob,		/* glob */
	Perl_ck_readline,	/* readline */
	Perl_ck_null,		/* rcatline */
	Perl_ck_fun,		/* regcmaybe */
	Perl_ck_fun,		/* regcreset */
	Perl_ck_null,		/* regcomp */
	Perl_ck_match,		/* match */
	Perl_ck_match,		/* qr */
	Perl_ck_match,		/* subst */
	Perl_ck_null,		/* substcont */
	Perl_ck_match,		/* trans */
	Perl_ck_match,		/* transr */
	Perl_ck_sassign,	/* sassign */
	Perl_ck_null,		/* aassign */
	Perl_ck_spair,		/* chop */
	Perl_ck_null,		/* schop */
	Perl_ck_spair,		/* chomp */
	Perl_ck_null,		/* schomp */
	Perl_ck_defined,	/* defined */
	Perl_ck_fun,		/* undef */
	Perl_ck_fun,		/* study */
	Perl_ck_fun,		/* pos */
	Perl_ck_lfun,		/* preinc */
	Perl_ck_lfun,		/* i_preinc */
	Perl_ck_lfun,		/* predec */
	Perl_ck_lfun,		/* i_predec */
	Perl_ck_lfun,		/* postinc */
	Perl_ck_lfun,		/* i_postinc */
	Perl_ck_lfun,		/* postdec */
	Perl_ck_lfun,		/* i_postdec */
	Perl_ck_null,		/* pow */
	Perl_ck_null,		/* multiply */
	Perl_ck_null,		/* i_multiply */
	Perl_ck_null,		/* divide */
	Perl_ck_null,		/* i_divide */
	Perl_ck_null,		/* modulo */
	Perl_ck_null,		/* i_modulo */
	Perl_ck_repeat,		/* repeat */
	Perl_ck_null,		/* add */
	Perl_ck_null,		/* i_add */
	Perl_ck_null,		/* subtract */
	Perl_ck_null,		/* i_subtract */
	Perl_ck_concat,		/* concat */
	Perl_ck_fun,		/* stringify */
	Perl_ck_bitop,		/* left_shift */
	Perl_ck_bitop,		/* right_shift */
	Perl_ck_cmp,		/* lt */
	Perl_ck_cmp,		/* i_lt */
	Perl_ck_cmp,		/* gt */
	Perl_ck_cmp,		/* i_gt */
	Perl_ck_cmp,		/* le */
	Perl_ck_cmp,		/* i_le */
	Perl_ck_cmp,		/* ge */
	Perl_ck_cmp,		/* i_ge */
	Perl_ck_null,		/* eq */
	Perl_ck_null,		/* i_eq */
	Perl_ck_null,		/* ne */
	Perl_ck_null,		/* i_ne */
	Perl_ck_null,		/* ncmp */
	Perl_ck_null,		/* i_ncmp */
	Perl_ck_null,		/* slt */
	Perl_ck_null,		/* sgt */
	Perl_ck_null,		/* sle */
	Perl_ck_null,		/* sge */
	Perl_ck_null,		/* seq */
	Perl_ck_null,		/* sne */
	Perl_ck_null,		/* scmp */
	Perl_ck_bitop,		/* bit_and */
	Perl_ck_bitop,		/* bit_xor */
	Perl_ck_bitop,		/* bit_or */
	Perl_ck_null,		/* negate */
	Perl_ck_null,		/* i_negate */
	Perl_ck_null,		/* not */
	Perl_ck_bitop,		/* complement */
	Perl_ck_smartmatch,	/* smartmatch */
	Perl_ck_fun,		/* atan2 */
	Perl_ck_fun,		/* sin */
	Perl_ck_fun,		/* cos */
	Perl_ck_fun,		/* rand */
	Perl_ck_fun,		/* srand */
	Perl_ck_fun,		/* exp */
	Perl_ck_fun,		/* log */
	Perl_ck_fun,		/* sqrt */
	Perl_ck_fun,		/* int */
	Perl_ck_fun,		/* hex */
	Perl_ck_fun,		/* oct */
	Perl_ck_fun,		/* abs */
	Perl_ck_length,		/* length */
	Perl_ck_substr,		/* substr */
	Perl_ck_fun,		/* vec */
	Perl_ck_index,		/* index */
	Perl_ck_index,		/* rindex */
	Perl_ck_lfun,		/* sprintf */
	Perl_ck_fun,		/* formline */
	Perl_ck_fun,		/* ord */
	Perl_ck_fun,		/* chr */
	Perl_ck_fun,		/* crypt */
	Perl_ck_fun,		/* ucfirst */
	Perl_ck_fun,		/* lcfirst */
	Perl_ck_fun,		/* uc */
	Perl_ck_fun,		/* lc */
	Perl_ck_fun,		/* quotemeta */
	Perl_ck_rvconst,	/* rv2av */
	Perl_ck_null,		/* aelemfast */
	Perl_ck_null,		/* aelemfast_lex */
	Perl_ck_null,		/* aelem */
	Perl_ck_null,		/* aslice */
	Perl_ck_null,		/* kvaslice */
	Perl_ck_each,		/* aeach */
	Perl_ck_each,		/* akeys */
	Perl_ck_each,		/* avalues */
	Perl_ck_each,		/* each */
	Perl_ck_each,		/* values */
	Perl_ck_each,		/* keys */
	Perl_ck_delete,		/* delete */
	Perl_ck_exists,		/* exists */
	Perl_ck_rvconst,	/* rv2hv */
	Perl_ck_null,		/* helem */
	Perl_ck_null,		/* hslice */
	Perl_ck_null,		/* kvhslice */
	Perl_ck_fun,		/* unpack */
	Perl_ck_fun,		/* pack */
	Perl_ck_split,		/* split */
	Perl_ck_join,		/* join */
	Perl_ck_null,		/* list */
	Perl_ck_null,		/* lslice */
	Perl_ck_fun,		/* anonlist */
	Perl_ck_fun,		/* anonhash */
	Perl_ck_fun,		/* splice */
	Perl_ck_fun,		/* push */
	Perl_ck_shift,		/* pop */
	Perl_ck_shift,		/* shift */
	Perl_ck_fun,		/* unshift */
	Perl_ck_sort,		/* sort */
	Perl_ck_fun,		/* reverse */
	Perl_ck_grep,		/* grepstart */
	Perl_ck_null,		/* grepwhile */
	Perl_ck_grep,		/* mapstart */
	Perl_ck_null,		/* mapwhile */
	Perl_ck_null,		/* range */
	Perl_ck_null,		/* flip */
	Perl_ck_null,		/* flop */
	Perl_ck_null,		/* and */
	Perl_ck_null,		/* or */
	Perl_ck_null,		/* xor */
	Perl_ck_null,		/* dor */
	Perl_ck_null,		/* cond_expr */
	Perl_ck_null,		/* andassign */
	Perl_ck_null,		/* orassign */
	Perl_ck_null,		/* dorassign */
	Perl_ck_method,		/* method */
	Perl_ck_subr,		/* entersub */
	Perl_ck_null,		/* leavesub */
	Perl_ck_null,		/* leavesublv */
	Perl_ck_fun,		/* caller */
	Perl_ck_fun,		/* warn */
	Perl_ck_fun,		/* die */
	Perl_ck_fun,		/* reset */
	Perl_ck_null,		/* lineseq */
	Perl_ck_null,		/* nextstate */
	Perl_ck_null,		/* dbstate */
	Perl_ck_null,		/* unstack */
	Perl_ck_null,		/* enter */
	Perl_ck_null,		/* leave */
	Perl_ck_null,		/* scope */
	Perl_ck_null,		/* enteriter */
	Perl_ck_null,		/* iter */
	Perl_ck_null,		/* enterloop */
	Perl_ck_null,		/* leaveloop */
	Perl_ck_return,		/* return */
	Perl_ck_null,		/* last */
	Perl_ck_null,		/* next */
	Perl_ck_null,		/* redo */
	Perl_ck_null,		/* dump */
	Perl_ck_null,		/* goto */
	Perl_ck_fun,		/* exit */
	Perl_ck_null,		/* method_named */
	Perl_ck_null,		/* entergiven */
	Perl_ck_null,		/* leavegiven */
	Perl_ck_null,		/* enterwhen */
	Perl_ck_null,		/* leavewhen */
	Perl_ck_null,		/* break */
	Perl_ck_null,		/* continue */
	Perl_ck_open,		/* open */
	Perl_ck_fun,		/* close */
	Perl_ck_fun,		/* pipe_op */
	Perl_ck_fun,		/* fileno */
	Perl_ck_fun,		/* umask */
	Perl_ck_fun,		/* binmode */
	Perl_ck_fun,		/* tie */
	Perl_ck_fun,		/* untie */
	Perl_ck_fun,		/* tied */
	Perl_ck_fun,		/* dbmopen */
	Perl_ck_fun,		/* dbmclose */
	Perl_ck_select,		/* sselect */
	Perl_ck_select,		/* select */
	Perl_ck_eof,		/* getc */
	Perl_ck_fun,		/* read */
	Perl_ck_fun,		/* enterwrite */
	Perl_ck_null,		/* leavewrite */
	Perl_ck_listiob,	/* prtf */
	Perl_ck_listiob,	/* print */
	Perl_ck_listiob,	/* say */
	Perl_ck_fun,		/* sysopen */
	Perl_ck_fun,		/* sysseek */
	Perl_ck_fun,		/* sysread */
	Perl_ck_fun,		/* syswrite */
	Perl_ck_eof,		/* eof */
	Perl_ck_tell,		/* tell */
	Perl_ck_tell,		/* seek */
	Perl_ck_trunc,		/* truncate */
	Perl_ck_fun,		/* fcntl */
	Perl_ck_fun,		/* ioctl */
	Perl_ck_fun,		/* flock */
	Perl_ck_fun,		/* send */
	Perl_ck_fun,		/* recv */
	Perl_ck_fun,		/* socket */
	Perl_ck_fun,		/* sockpair */
	Perl_ck_fun,		/* bind */
	Perl_ck_fun,		/* connect */
	Perl_ck_fun,		/* listen */
	Perl_ck_fun,		/* accept */
	Perl_ck_fun,		/* shutdown */
	Perl_ck_fun,		/* gsockopt */
	Perl_ck_fun,		/* ssockopt */
	Perl_ck_fun,		/* getsockname */
	Perl_ck_fun,		/* getpeername */
	Perl_ck_ftst,		/* lstat */
	Perl_ck_ftst,		/* stat */
	Perl_ck_ftst,		/* ftrread */
	Perl_ck_ftst,		/* ftrwrite */
	Perl_ck_ftst,		/* ftrexec */
	Perl_ck_ftst,		/* fteread */
	Perl_ck_ftst,		/* ftewrite */
	Perl_ck_ftst,		/* fteexec */
	Perl_ck_ftst,		/* ftis */
	Perl_ck_ftst,		/* ftsize */
	Perl_ck_ftst,		/* ftmtime */
	Perl_ck_ftst,		/* ftatime */
	Perl_ck_ftst,		/* ftctime */
	Perl_ck_ftst,		/* ftrowned */
	Perl_ck_ftst,		/* fteowned */
	Perl_ck_ftst,		/* ftzero */
	Perl_ck_ftst,		/* ftsock */
	Perl_ck_ftst,		/* ftchr */
	Perl_ck_ftst,		/* ftblk */
	Perl_ck_ftst,		/* ftfile */
	Perl_ck_ftst,		/* ftdir */
	Perl_ck_ftst,		/* ftpipe */
	Perl_ck_ftst,		/* ftsuid */
	Perl_ck_ftst,		/* ftsgid */
	Perl_ck_ftst,		/* ftsvtx */
	Perl_ck_ftst,		/* ftlink */
	Perl_ck_ftst,		/* fttty */
	Perl_ck_ftst,		/* fttext */
	Perl_ck_ftst,		/* ftbinary */
	Perl_ck_trunc,		/* chdir */
	Perl_ck_fun,		/* chown */
	Perl_ck_fun,		/* chroot */
	Perl_ck_fun,		/* unlink */
	Perl_ck_fun,		/* chmod */
	Perl_ck_fun,		/* utime */
	Perl_ck_fun,		/* rename */
	Perl_ck_fun,		/* link */
	Perl_ck_fun,		/* symlink */
	Perl_ck_fun,		/* readlink */
	Perl_ck_fun,		/* mkdir */
	Perl_ck_fun,		/* rmdir */
	Perl_ck_fun,		/* open_dir */
	Perl_ck_fun,		/* readdir */
	Perl_ck_fun,		/* telldir */
	Perl_ck_fun,		/* seekdir */
	Perl_ck_fun,		/* rewinddir */
	Perl_ck_fun,		/* closedir */
	Perl_ck_null,		/* fork */
	Perl_ck_null,		/* wait */
	Perl_ck_fun,		/* waitpid */
	Perl_ck_exec,		/* system */
	Perl_ck_exec,		/* exec */
	Perl_ck_fun,		/* kill */
	Perl_ck_null,		/* getppid */
	Perl_ck_fun,		/* getpgrp */
	Perl_ck_fun,		/* setpgrp */
	Perl_ck_fun,		/* getpriority */
	Perl_ck_fun,		/* setpriority */
	Perl_ck_null,		/* time */
	Perl_ck_null,		/* tms */
	Perl_ck_fun,		/* localtime */
	Perl_ck_fun,		/* gmtime */
	Perl_ck_fun,		/* alarm */
	Perl_ck_fun,		/* sleep */
	Perl_ck_fun,		/* shmget */
	Perl_ck_fun,		/* shmctl */
	Perl_ck_fun,		/* shmread */
	Perl_ck_fun,		/* shmwrite */
	Perl_ck_fun,		/* msgget */
	Perl_ck_fun,		/* msgctl */
	Perl_ck_fun,		/* msgsnd */
	Perl_ck_fun,		/* msgrcv */
	Perl_ck_fun,		/* semop */
	Perl_ck_fun,		/* semget */
	Perl_ck_fun,		/* semctl */
	Perl_ck_require,	/* require */
	Perl_ck_fun,		/* dofile */
	Perl_ck_svconst,	/* hintseval */
	Perl_ck_eval,		/* entereval */
	Perl_ck_null,		/* leaveeval */
	Perl_ck_eval,		/* entertry */
	Perl_ck_null,		/* leavetry */
	Perl_ck_fun,		/* ghbyname */
	Perl_ck_fun,		/* ghbyaddr */
	Perl_ck_null,		/* ghostent */
	Perl_ck_fun,		/* gnbyname */
	Perl_ck_fun,		/* gnbyaddr */
	Perl_ck_null,		/* gnetent */
	Perl_ck_fun,		/* gpbyname */
	Perl_ck_fun,		/* gpbynumber */
	Perl_ck_null,		/* gprotoent */
	Perl_ck_fun,		/* gsbyname */
	Perl_ck_fun,		/* gsbyport */
	Perl_ck_null,		/* gservent */
	Perl_ck_fun,		/* shostent */
	Perl_ck_fun,		/* snetent */
	Perl_ck_fun,		/* sprotoent */
	Perl_ck_fun,		/* sservent */
	Perl_ck_null,		/* ehostent */
	Perl_ck_null,		/* enetent */
	Perl_ck_null,		/* eprotoent */
	Perl_ck_null,		/* eservent */
	Perl_ck_fun,		/* gpwnam */
	Perl_ck_fun,		/* gpwuid */
	Perl_ck_null,		/* gpwent */
	Perl_ck_null,		/* spwent */
	Perl_ck_null,		/* epwent */
	Perl_ck_fun,		/* ggrnam */
	Perl_ck_fun,		/* ggrgid */
	Perl_ck_null,		/* ggrent */
	Perl_ck_null,		/* sgrent */
	Perl_ck_null,		/* egrent */
	Perl_ck_null,		/* getlogin */
	Perl_ck_fun,		/* syscall */
	Perl_ck_rfun,		/* lock */
	Perl_ck_null,		/* once */
	Perl_ck_null,		/* custom */
	Perl_ck_each,		/* reach */
	Perl_ck_each,		/* rkeys */
	Perl_ck_each,		/* rvalues */
	Perl_ck_null,		/* coreargs */
	Perl_ck_null,		/* runcv */
	Perl_ck_fun,		/* fc */
	Perl_ck_null,		/* padcv */
	Perl_ck_null,		/* introcv */
	Perl_ck_null,		/* clonecv */
	Perl_ck_null,		/* padrange */
}
#endif
#ifdef PERL_CHECK_INITED
;
#endif /* #ifdef PERL_CHECK_INITED */

#ifndef PERL_GLOBAL_STRUCT_INIT

#ifndef DOINIT
EXTCONST U32 PL_opargs[];
#else
EXTCONST U32 PL_opargs[] = {
	0x00000000,	/* null */
	0x00000000,	/* stub */
	0x00001b04,	/* scalar */
	0x00000004,	/* pushmark */
	0x00000004,	/* wantarray */
	0x00000604,	/* const */
	0x00000644,	/* gvsv */
	0x00000644,	/* gv */
	0x00011240,	/* gelem */
	0x00000044,	/* padsv */
	0x00000040,	/* padav */
	0x00000040,	/* padhv */
	0x00000040,	/* padany */
	0x00000540,	/* pushre */
	0x00000144,	/* rv2gv */
	0x00000144,	/* rv2sv */
	0x00000104,	/* av2arylen */
	0x00000140,	/* rv2cv */
	0x00000600,	/* anoncode */
	0x00001b04,	/* prototype */
	0x00002101,	/* refgen */
	0x00001106,	/* srefgen */
	0x00009b8c,	/* ref */
	0x00091404,	/* bless */
	0x00009b88,	/* backtick */
	0x00009408,	/* glob */
	0x0000eb08,	/* readline */
	0x00000608,	/* rcatline */
	0x00001104,	/* regcmaybe */
	0x00001104,	/* regcreset */
	0x00001304,	/* regcomp */
	0x00000540,	/* match */
	0x00000504,	/* qr */
	0x00001544,	/* subst */
	0x00000344,	/* substcont */
	0x00001804,	/* trans */
	0x00001804,	/* transr */
	0x00000004,	/* sassign */
	0x00022208,	/* aassign */
	0x00002b0d,	/* chop */
	0x00009b8c,	/* schop */
	0x00002b1d,	/* chomp */
	0x00009b9c,	/* schomp */
	0x00009b84,	/* defined */
	0x0000fb04,	/* undef */
	0x00009b84,	/* study */
	0x0000fb8c,	/* pos */
	0x00001164,	/* preinc */
	0x00001144,	/* i_preinc */
	0x00001164,	/* predec */
	0x00001144,	/* i_predec */
	0x0000116c,	/* postinc */
	0x0000115c,	/* i_postinc */
	0x0000116c,	/* postdec */
	0x0000115c,	/* i_postdec */
	0x0001121e,	/* pow */
	0x0001123e,	/* multiply */
	0x0001121e,	/* i_multiply */
	0x0001123e,	/* divide */
	0x0001121e,	/* i_divide */
	0x0001123e,	/* modulo */
	0x0001121e,	/* i_modulo */
	0x0001220b,	/* repeat */
	0x0001123e,	/* add */
	0x0001121e,	/* i_add */
	0x0001123e,	/* subtract */
	0x0001121e,	/* i_subtract */
	0x0001121e,	/* concat */
	0x0000141e,	/* stringify */
	0x0001121e,	/* left_shift */
	0x0001121e,	/* right_shift */
	0x00011226,	/* lt */
	0x00011206,	/* i_lt */
	0x00011226,	/* gt */
	0x00011206,	/* i_gt */
	0x00011226,	/* le */
	0x00011206,	/* i_le */
	0x00011226,	/* ge */
	0x00011206,	/* i_ge */
	0x00011226,	/* eq */
	0x00011206,	/* i_eq */
	0x00011226,	/* ne */
	0x00011206,	/* i_ne */
	0x0001122e,	/* ncmp */
	0x0001120e,	/* i_ncmp */
	0x00011206,	/* slt */
	0x00011206,	/* sgt */
	0x00011206,	/* sle */
	0x00011206,	/* sge */
	0x00011206,	/* seq */
	0x00011206,	/* sne */
	0x0001120e,	/* scmp */
	0x0001120e,	/* bit_and */
	0x0001120e,	/* bit_xor */
	0x0001120e,	/* bit_or */
	0x0000112e,	/* negate */
	0x0000111e,	/* i_negate */
	0x00001106,	/* not */
	0x0000110e,	/* complement */
	0x00000204,	/* smartmatch */
	0x0001141e,	/* atan2 */
	0x00009b9e,	/* sin */
	0x00009b9e,	/* cos */
	0x00009b1c,	/* rand */
	0x00009b1c,	/* srand */
	0x00009b9e,	/* exp */
	0x00009b9e,	/* log */
	0x00009b9e,	/* sqrt */
	0x00009b9e,	/* int */
	0x00009b9e,	/* hex */
	0x00009b9e,	/* oct */
	0x00009b9e,	/* abs */
	0x00009b9e,	/* length */
	0x0991140c,	/* substr */
	0x0011140c,	/* vec */
	0x0091141c,	/* index */
	0x0091141c,	/* rindex */
	0x0002140f,	/* sprintf */
	0x00021405,	/* formline */
	0x00009b9e,	/* ord */
	0x00009b9e,	/* chr */
	0x0001141e,	/* crypt */
	0x00009b8e,	/* ucfirst */
	0x00009b8e,	/* lcfirst */
	0x00009b8e,	/* uc */
	0x00009b8e,	/* lc */
	0x00009b8e,	/* quotemeta */
	0x00000148,	/* rv2av */
	0x00013604,	/* aelemfast */
	0x00013040,	/* aelemfast_lex */
	0x00013204,	/* aelem */
	0x00023401,	/* aslice */
	0x00023401,	/* kvaslice */
	0x00003b00,	/* aeach */
	0x00003b08,	/* akeys */
	0x00003b08,	/* avalues */
	0x00004b00,	/* each */
	0x00004b08,	/* values */
	0x00004b08,	/* keys */
	0x00001b00,	/* delete */
	0x00001b04,	/* exists */
	0x00000140,	/* rv2hv */
	0x00014204,	/* helem */
	0x00024401,	/* hslice */
	0x00024401,	/* kvhslice */
	0x00091480,	/* unpack */
	0x0002140f,	/* pack */
	0x00111408,	/* split */
	0x0002140d,	/* join */
	0x00002401,	/* list */
	0x00224200,	/* lslice */
	0x00002405,	/* anonlist */
	0x00002405,	/* anonhash */
	0x02993401,	/* splice */
	0x0002341d,	/* push */
	0x0000bb04,	/* pop */
	0x0000bb04,	/* shift */
	0x0002341d,	/* unshift */
	0x0002d441,	/* sort */
	0x00002409,	/* reverse */
	0x00025441,	/* grepstart */
	0x00000348,	/* grepwhile */
	0x00025441,	/* mapstart */
	0x00000348,	/* mapwhile */
	0x00011300,	/* range */
	0x00011100,	/* flip */
	0x00000100,	/* flop */
	0x00000300,	/* and */
	0x00000300,	/* or */
	0x00011206,	/* xor */
	0x00000300,	/* dor */
	0x00000340,	/* cond_expr */
	0x00000304,	/* andassign */
	0x00000304,	/* orassign */
	0x00000304,	/* dorassign */
	0x00000140,	/* method */
	0x00002149,	/* entersub */
	0x00000100,	/* leavesub */
	0x00000100,	/* leavesublv */
	0x00009b08,	/* caller */
	0x0000240d,	/* warn */
	0x0000244d,	/* die */
	0x00009b04,	/* reset */
	0x00000400,	/* lineseq */
	0x00000a04,	/* nextstate */
	0x00000a04,	/* dbstate */
	0x00000004,	/* unstack */
	0x00000000,	/* enter */
	0x00000400,	/* leave */
	0x00000400,	/* scope */
	0x00000940,	/* enteriter */
	0x00000000,	/* iter */
	0x00000940,	/* enterloop */
	0x00000200,	/* leaveloop */
	0x00002441,	/* return */
	0x00000d44,	/* last */
	0x00000d44,	/* next */
	0x00000d44,	/* redo */
	0x00000d44,	/* dump */
	0x00000d44,	/* goto */
	0x00009b44,	/* exit */
	0x00000640,	/* method_named */
	0x00000340,	/* entergiven */
	0x00000100,	/* leavegiven */
	0x00000340,	/* enterwhen */
	0x00000100,	/* leavewhen */
	0x00000000,	/* break */
	0x00000000,	/* continue */
	0x0029640d,	/* open */
	0x0000eb04,	/* close */
	0x00066404,	/* pipe_op */
	0x00006b0c,	/* fileno */
	0x00009b0c,	/* umask */
	0x00096404,	/* binmode */
	0x00217445,	/* tie */
	0x00007b04,	/* untie */
	0x00007b04,	/* tied */
	0x00114404,	/* dbmopen */
	0x00004b04,	/* dbmclose */
	0x01111408,	/* sselect */
	0x0000e40c,	/* select */
	0x0000eb0c,	/* getc */
	0x0917640d,	/* read */
	0x0000eb44,	/* enterwrite */
	0x00000100,	/* leavewrite */
	0x0002e405,	/* prtf */
	0x0002e405,	/* print */
	0x0002e405,	/* say */
	0x09116404,	/* sysopen */
	0x00116404,	/* sysseek */
	0x0917640d,	/* sysread */
	0x0991640d,	/* syswrite */
	0x0000eb04,	/* eof */
	0x0000eb0c,	/* tell */
	0x00116404,	/* seek */
	0x00011404,	/* truncate */
	0x0011640c,	/* fcntl */
	0x0011640c,	/* ioctl */
	0x0001641c,	/* flock */
	0x0911640d,	/* send */
	0x0117640d,	/* recv */
	0x01116404,	/* socket */
	0x11166404,	/* sockpair */
	0x00016404,	/* bind */
	0x00016404,	/* connect */
	0x00016404,	/* listen */
	0x0006640c,	/* accept */
	0x0001640c,	/* shutdown */
	0x00116404,	/* gsockopt */
	0x01116404,	/* ssockopt */
	0x00006b04,	/* getsockname */
	0x00006b04,	/* getpeername */
	0x0000ec80,	/* lstat */
	0x0000ec80,	/* stat */
	0x00006c84,	/* ftrread */
	0x00006c84,	/* ftrwrite */
	0x00006c84,	/* ftrexec */
	0x00006c84,	/* fteread */
	0x00006c84,	/* ftewrite */
	0x00006c84,	/* fteexec */
	0x00006c84,	/* ftis */
	0x00006c8c,	/* ftsize */
	0x00006c8c,	/* ftmtime */
	0x00006c8c,	/* ftatime */
	0x00006c8c,	/* ftctime */
	0x00006c84,	/* ftrowned */
	0x00006c84,	/* fteowned */
	0x00006c84,	/* ftzero */
	0x00006c84,	/* ftsock */
	0x00006c84,	/* ftchr */
	0x00006c84,	/* ftblk */
	0x00006c84,	/* ftfile */
	0x00006c84,	/* ftdir */
	0x00006c84,	/* ftpipe */
	0x00006c84,	/* ftsuid */
	0x00006c84,	/* ftsgid */
	0x00006c84,	/* ftsvtx */
	0x00006c84,	/* ftlink */
	0x00006c04,	/* fttty */
	0x00006c84,	/* fttext */
	0x00006c84,	/* ftbinary */
	0x00009b1c,	/* chdir */
	0x0000241d,	/* chown */
	0x00009b9c,	/* chroot */
	0x0000249d,	/* unlink */
	0x0000241d,	/* chmod */
	0x0000241d,	/* utime */
	0x0001141c,	/* rename */
	0x0001141c,	/* link */
	0x0001141c,	/* symlink */
	0x00009b8c,	/* readlink */
	0x0009949c,	/* mkdir */
	0x00009b9c,	/* rmdir */
	0x00016404,	/* open_dir */
	0x00006b00,	/* readdir */
	0x00006b0c,	/* telldir */
	0x00016404,	/* seekdir */
	0x00006b04,	/* rewinddir */
	0x00006b04,	/* closedir */
	0x0000000c,	/* fork */
	0x0000001c,	/* wait */
	0x0001141c,	/* waitpid */
	0x0002941d,	/* system */
	0x0002945d,	/* exec */
	0x0000245d,	/* kill */
	0x0000001c,	/* getppid */
	0x00009b1c,	/* getpgrp */
	0x0009941c,	/* setpgrp */
	0x0001141c,	/* getpriority */
	0x0011141c,	/* setpriority */
	0x0000001c,	/* time */
	0x00000000,	/* tms */
	0x00009b08,	/* localtime */
	0x00009b08,	/* gmtime */
	0x00009b8c,	/* alarm */
	0x00009b1c,	/* sleep */
	0x0011140d,	/* shmget */
	0x0011140d,	/* shmctl */
	0x0111140d,	/* shmread */
	0x0111140d,	/* shmwrite */
	0x0001140d,	/* msgget */
	0x0011140d,	/* msgctl */
	0x0011140d,	/* msgsnd */
	0x1111140d,	/* msgrcv */
	0x0001140d,	/* semop */
	0x0011140d,	/* semget */
	0x0111140d,	/* semctl */
	0x00009bc0,	/* require */
	0x00001140,	/* dofile */
	0x00000604,	/* hintseval */
	0x00009bc0,	/* entereval */
	0x00001100,	/* leaveeval */
	0x00000340,	/* entertry */
	0x00000400,	/* leavetry */
	0x00001b00,	/* ghbyname */
	0x00011400,	/* ghbyaddr */
	0x00000000,	/* ghostent */
	0x00001b00,	/* gnbyname */
	0x00011400,	/* gnbyaddr */
	0x00000000,	/* gnetent */
	0x00001b00,	/* gpbyname */
	0x00001400,	/* gpbynumber */
	0x00000000,	/* gprotoent */
	0x00011400,	/* gsbyname */
	0x00011400,	/* gsbyport */
	0x00000000,	/* gservent */
	0x00001b04,	/* shostent */
	0x00001b04,	/* snetent */
	0x00001b04,	/* sprotoent */
	0x00001b04,	/* sservent */
	0x00000004,	/* ehostent */
	0x00000004,	/* enetent */
	0x00000004,	/* eprotoent */
	0x00000004,	/* eservent */
	0x00001b00,	/* gpwnam */
	0x00001b00,	/* gpwuid */
	0x00000000,	/* gpwent */
	0x00000004,	/* spwent */
	0x00000004,	/* epwent */
	0x00001b00,	/* ggrnam */
	0x00001b00,	/* ggrgid */
	0x00000000,	/* ggrent */
	0x00000004,	/* sgrent */
	0x00000004,	/* egrent */
	0x0000000c,	/* getlogin */
	0x0002140d,	/* syscall */
	0x00007b04,	/* lock */
	0x00000300,	/* once */
	0x00000000,	/* custom */
	0x00001b00,	/* reach */
	0x00001b08,	/* rkeys */
	0x00001b08,	/* rvalues */
	0x00000600,	/* coreargs */
	0x00000004,	/* runcv */
	0x00009b8e,	/* fc */
	0x00000040,	/* padcv */
	0x00000040,	/* introcv */
	0x00000040,	/* clonecv */
	0x00000040,	/* padrange */
};
#endif

#endif /* !PERL_GLOBAL_STRUCT_INIT */

END_EXTERN_C

/* ex: set ro: */
                                                                                                                                                                                                                             usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/opnames.h                                                 0100644 0000000 0000000 00000020261 12744441327 017550  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    opnames.h
 *
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
 *    2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/opcode.pl from its data.
 * Any changes made here will be lost!
 */

typedef enum opcode {
	OP_NULL		 = 0,
	OP_STUB		 = 1,
	OP_SCALAR	 = 2,
	OP_PUSHMARK	 = 3,
	OP_WANTARRAY	 = 4,
	OP_CONST	 = 5,
	OP_GVSV		 = 6,
	OP_GV		 = 7,
	OP_GELEM	 = 8,
	OP_PADSV	 = 9,
	OP_PADAV	 = 10,
	OP_PADHV	 = 11,
	OP_PADANY	 = 12,
	OP_PUSHRE	 = 13,
	OP_RV2GV	 = 14,
	OP_RV2SV	 = 15,
	OP_AV2ARYLEN	 = 16,
	OP_RV2CV	 = 17,
	OP_ANONCODE	 = 18,
	OP_PROTOTYPE	 = 19,
	OP_REFGEN	 = 20,
	OP_SREFGEN	 = 21,
	OP_REF		 = 22,
	OP_BLESS	 = 23,
	OP_BACKTICK	 = 24,
	OP_GLOB		 = 25,
	OP_READLINE	 = 26,
	OP_RCATLINE	 = 27,
	OP_REGCMAYBE	 = 28,
	OP_REGCRESET	 = 29,
	OP_REGCOMP	 = 30,
	OP_MATCH	 = 31,
	OP_QR		 = 32,
	OP_SUBST	 = 33,
	OP_SUBSTCONT	 = 34,
	OP_TRANS	 = 35,
	OP_TRANSR	 = 36,
	OP_SASSIGN	 = 37,
	OP_AASSIGN	 = 38,
	OP_CHOP		 = 39,
	OP_SCHOP	 = 40,
	OP_CHOMP	 = 41,
	OP_SCHOMP	 = 42,
	OP_DEFINED	 = 43,
	OP_UNDEF	 = 44,
	OP_STUDY	 = 45,
	OP_POS		 = 46,
	OP_PREINC	 = 47,
	OP_I_PREINC	 = 48,
	OP_PREDEC	 = 49,
	OP_I_PREDEC	 = 50,
	OP_POSTINC	 = 51,
	OP_I_POSTINC	 = 52,
	OP_POSTDEC	 = 53,
	OP_I_POSTDEC	 = 54,
	OP_POW		 = 55,
	OP_MULTIPLY	 = 56,
	OP_I_MULTIPLY	 = 57,
	OP_DIVIDE	 = 58,
	OP_I_DIVIDE	 = 59,
	OP_MODULO	 = 60,
	OP_I_MODULO	 = 61,
	OP_REPEAT	 = 62,
	OP_ADD		 = 63,
	OP_I_ADD	 = 64,
	OP_SUBTRACT	 = 65,
	OP_I_SUBTRACT	 = 66,
	OP_CONCAT	 = 67,
	OP_STRINGIFY	 = 68,
	OP_LEFT_SHIFT	 = 69,
	OP_RIGHT_SHIFT	 = 70,
	OP_LT		 = 71,
	OP_I_LT		 = 72,
	OP_GT		 = 73,
	OP_I_GT		 = 74,
	OP_LE		 = 75,
	OP_I_LE		 = 76,
	OP_GE		 = 77,
	OP_I_GE		 = 78,
	OP_EQ		 = 79,
	OP_I_EQ		 = 80,
	OP_NE		 = 81,
	OP_I_NE		 = 82,
	OP_NCMP		 = 83,
	OP_I_NCMP	 = 84,
	OP_SLT		 = 85,
	OP_SGT		 = 86,
	OP_SLE		 = 87,
	OP_SGE		 = 88,
	OP_SEQ		 = 89,
	OP_SNE		 = 90,
	OP_SCMP		 = 91,
	OP_BIT_AND	 = 92,
	OP_BIT_XOR	 = 93,
	OP_BIT_OR	 = 94,
	OP_NEGATE	 = 95,
	OP_I_NEGATE	 = 96,
	OP_NOT		 = 97,
	OP_COMPLEMENT	 = 98,
	OP_SMARTMATCH	 = 99,
	OP_ATAN2	 = 100,
	OP_SIN		 = 101,
	OP_COS		 = 102,
	OP_RAND		 = 103,
	OP_SRAND	 = 104,
	OP_EXP		 = 105,
	OP_LOG		 = 106,
	OP_SQRT		 = 107,
	OP_INT		 = 108,
	OP_HEX		 = 109,
	OP_OCT		 = 110,
	OP_ABS		 = 111,
	OP_LENGTH	 = 112,
	OP_SUBSTR	 = 113,
	OP_VEC		 = 114,
	OP_INDEX	 = 115,
	OP_RINDEX	 = 116,
	OP_SPRINTF	 = 117,
	OP_FORMLINE	 = 118,
	OP_ORD		 = 119,
	OP_CHR		 = 120,
	OP_CRYPT	 = 121,
	OP_UCFIRST	 = 122,
	OP_LCFIRST	 = 123,
	OP_UC		 = 124,
	OP_LC		 = 125,
	OP_QUOTEMETA	 = 126,
	OP_RV2AV	 = 127,
	OP_AELEMFAST	 = 128,
	OP_AELEMFAST_LEX = 129,
	OP_AELEM	 = 130,
	OP_ASLICE	 = 131,
	OP_KVASLICE	 = 132,
	OP_AEACH	 = 133,
	OP_AKEYS	 = 134,
	OP_AVALUES	 = 135,
	OP_EACH		 = 136,
	OP_VALUES	 = 137,
	OP_KEYS		 = 138,
	OP_DELETE	 = 139,
	OP_EXISTS	 = 140,
	OP_RV2HV	 = 141,
	OP_HELEM	 = 142,
	OP_HSLICE	 = 143,
	OP_KVHSLICE	 = 144,
	OP_UNPACK	 = 145,
	OP_PACK		 = 146,
	OP_SPLIT	 = 147,
	OP_JOIN		 = 148,
	OP_LIST		 = 149,
	OP_LSLICE	 = 150,
	OP_ANONLIST	 = 151,
	OP_ANONHASH	 = 152,
	OP_SPLICE	 = 153,
	OP_PUSH		 = 154,
	OP_POP		 = 155,
	OP_SHIFT	 = 156,
	OP_UNSHIFT	 = 157,
	OP_SORT		 = 158,
	OP_REVERSE	 = 159,
	OP_GREPSTART	 = 160,
	OP_GREPWHILE	 = 161,
	OP_MAPSTART	 = 162,
	OP_MAPWHILE	 = 163,
	OP_RANGE	 = 164,
	OP_FLIP		 = 165,
	OP_FLOP		 = 166,
	OP_AND		 = 167,
	OP_OR		 = 168,
	OP_XOR		 = 169,
	OP_DOR		 = 170,
	OP_COND_EXPR	 = 171,
	OP_ANDASSIGN	 = 172,
	OP_ORASSIGN	 = 173,
	OP_DORASSIGN	 = 174,
	OP_METHOD	 = 175,
	OP_ENTERSUB	 = 176,
	OP_LEAVESUB	 = 177,
	OP_LEAVESUBLV	 = 178,
	OP_CALLER	 = 179,
	OP_WARN		 = 180,
	OP_DIE		 = 181,
	OP_RESET	 = 182,
	OP_LINESEQ	 = 183,
	OP_NEXTSTATE	 = 184,
	OP_DBSTATE	 = 185,
	OP_UNSTACK	 = 186,
	OP_ENTER	 = 187,
	OP_LEAVE	 = 188,
	OP_SCOPE	 = 189,
	OP_ENTERITER	 = 190,
	OP_ITER		 = 191,
	OP_ENTERLOOP	 = 192,
	OP_LEAVELOOP	 = 193,
	OP_RETURN	 = 194,
	OP_LAST		 = 195,
	OP_NEXT		 = 196,
	OP_REDO		 = 197,
	OP_DUMP		 = 198,
	OP_GOTO		 = 199,
	OP_EXIT		 = 200,
	OP_METHOD_NAMED	 = 201,
	OP_ENTERGIVEN	 = 202,
	OP_LEAVEGIVEN	 = 203,
	OP_ENTERWHEN	 = 204,
	OP_LEAVEWHEN	 = 205,
	OP_BREAK	 = 206,
	OP_CONTINUE	 = 207,
	OP_OPEN		 = 208,
	OP_CLOSE	 = 209,
	OP_PIPE_OP	 = 210,
	OP_FILENO	 = 211,
	OP_UMASK	 = 212,
	OP_BINMODE	 = 213,
	OP_TIE		 = 214,
	OP_UNTIE	 = 215,
	OP_TIED		 = 216,
	OP_DBMOPEN	 = 217,
	OP_DBMCLOSE	 = 218,
	OP_SSELECT	 = 219,
	OP_SELECT	 = 220,
	OP_GETC		 = 221,
	OP_READ		 = 222,
	OP_ENTERWRITE	 = 223,
	OP_LEAVEWRITE	 = 224,
	OP_PRTF		 = 225,
	OP_PRINT	 = 226,
	OP_SAY		 = 227,
	OP_SYSOPEN	 = 228,
	OP_SYSSEEK	 = 229,
	OP_SYSREAD	 = 230,
	OP_SYSWRITE	 = 231,
	OP_EOF		 = 232,
	OP_TELL		 = 233,
	OP_SEEK		 = 234,
	OP_TRUNCATE	 = 235,
	OP_FCNTL	 = 236,
	OP_IOCTL	 = 237,
	OP_FLOCK	 = 238,
	OP_SEND		 = 239,
	OP_RECV		 = 240,
	OP_SOCKET	 = 241,
	OP_SOCKPAIR	 = 242,
	OP_BIND		 = 243,
	OP_CONNECT	 = 244,
	OP_LISTEN	 = 245,
	OP_ACCEPT	 = 246,
	OP_SHUTDOWN	 = 247,
	OP_GSOCKOPT	 = 248,
	OP_SSOCKOPT	 = 249,
	OP_GETSOCKNAME	 = 250,
	OP_GETPEERNAME	 = 251,
	OP_LSTAT	 = 252,
	OP_STAT		 = 253,
	OP_FTRREAD	 = 254,
	OP_FTRWRITE	 = 255,
	OP_FTREXEC	 = 256,
	OP_FTEREAD	 = 257,
	OP_FTEWRITE	 = 258,
	OP_FTEEXEC	 = 259,
	OP_FTIS		 = 260,
	OP_FTSIZE	 = 261,
	OP_FTMTIME	 = 262,
	OP_FTATIME	 = 263,
	OP_FTCTIME	 = 264,
	OP_FTROWNED	 = 265,
	OP_FTEOWNED	 = 266,
	OP_FTZERO	 = 267,
	OP_FTSOCK	 = 268,
	OP_FTCHR	 = 269,
	OP_FTBLK	 = 270,
	OP_FTFILE	 = 271,
	OP_FTDIR	 = 272,
	OP_FTPIPE	 = 273,
	OP_FTSUID	 = 274,
	OP_FTSGID	 = 275,
	OP_FTSVTX	 = 276,
	OP_FTLINK	 = 277,
	OP_FTTTY	 = 278,
	OP_FTTEXT	 = 279,
	OP_FTBINARY	 = 280,
	OP_CHDIR	 = 281,
	OP_CHOWN	 = 282,
	OP_CHROOT	 = 283,
	OP_UNLINK	 = 284,
	OP_CHMOD	 = 285,
	OP_UTIME	 = 286,
	OP_RENAME	 = 287,
	OP_LINK		 = 288,
	OP_SYMLINK	 = 289,
	OP_READLINK	 = 290,
	OP_MKDIR	 = 291,
	OP_RMDIR	 = 292,
	OP_OPEN_DIR	 = 293,
	OP_READDIR	 = 294,
	OP_TELLDIR	 = 295,
	OP_SEEKDIR	 = 296,
	OP_REWINDDIR	 = 297,
	OP_CLOSEDIR	 = 298,
	OP_FORK		 = 299,
	OP_WAIT		 = 300,
	OP_WAITPID	 = 301,
	OP_SYSTEM	 = 302,
	OP_EXEC		 = 303,
	OP_KILL		 = 304,
	OP_GETPPID	 = 305,
	OP_GETPGRP	 = 306,
	OP_SETPGRP	 = 307,
	OP_GETPRIORITY	 = 308,
	OP_SETPRIORITY	 = 309,
	OP_TIME		 = 310,
	OP_TMS		 = 311,
	OP_LOCALTIME	 = 312,
	OP_GMTIME	 = 313,
	OP_ALARM	 = 314,
	OP_SLEEP	 = 315,
	OP_SHMGET	 = 316,
	OP_SHMCTL	 = 317,
	OP_SHMREAD	 = 318,
	OP_SHMWRITE	 = 319,
	OP_MSGGET	 = 320,
	OP_MSGCTL	 = 321,
	OP_MSGSND	 = 322,
	OP_MSGRCV	 = 323,
	OP_SEMOP	 = 324,
	OP_SEMGET	 = 325,
	OP_SEMCTL	 = 326,
	OP_REQUIRE	 = 327,
	OP_DOFILE	 = 328,
	OP_HINTSEVAL	 = 329,
	OP_ENTEREVAL	 = 330,
	OP_LEAVEEVAL	 = 331,
	OP_ENTERTRY	 = 332,
	OP_LEAVETRY	 = 333,
	OP_GHBYNAME	 = 334,
	OP_GHBYADDR	 = 335,
	OP_GHOSTENT	 = 336,
	OP_GNBYNAME	 = 337,
	OP_GNBYADDR	 = 338,
	OP_GNETENT	 = 339,
	OP_GPBYNAME	 = 340,
	OP_GPBYNUMBER	 = 341,
	OP_GPROTOENT	 = 342,
	OP_GSBYNAME	 = 343,
	OP_GSBYPORT	 = 344,
	OP_GSERVENT	 = 345,
	OP_SHOSTENT	 = 346,
	OP_SNETENT	 = 347,
	OP_SPROTOENT	 = 348,
	OP_SSERVENT	 = 349,
	OP_EHOSTENT	 = 350,
	OP_ENETENT	 = 351,
	OP_EPROTOENT	 = 352,
	OP_ESERVENT	 = 353,
	OP_GPWNAM	 = 354,
	OP_GPWUID	 = 355,
	OP_GPWENT	 = 356,
	OP_SPWENT	 = 357,
	OP_EPWENT	 = 358,
	OP_GGRNAM	 = 359,
	OP_GGRGID	 = 360,
	OP_GGRENT	 = 361,
	OP_SGRENT	 = 362,
	OP_EGRENT	 = 363,
	OP_GETLOGIN	 = 364,
	OP_SYSCALL	 = 365,
	OP_LOCK		 = 366,
	OP_ONCE		 = 367,
	OP_CUSTOM	 = 368,
	OP_REACH	 = 369,
	OP_RKEYS	 = 370,
	OP_RVALUES	 = 371,
	OP_COREARGS	 = 372,
	OP_RUNCV	 = 373,
	OP_FC		 = 374,
	OP_PADCV	 = 375,
	OP_INTROCV	 = 376,
	OP_CLONECV	 = 377,
	OP_PADRANGE	 = 378,
	OP_max		
} opcode;

#define MAXO 379
#define OP_FREED MAXO

/* the OP_IS_* macros are optimized to a simple range check because
    all the member OPs are contiguous in regen/opcodes table.
    opcode.pl verifies the range contiguity, or generates an OR-equals
    expression */

#define OP_IS_SOCKET(op)	\
	((op) >= OP_SEND && (op) <= OP_GETPEERNAME)

#define OP_IS_FILETEST(op)	\
	((op) >= OP_FTRREAD && (op) <= OP_FTBINARY)

#define OP_IS_FILETEST_ACCESS(op)	\
	((op) >= OP_FTRREAD && (op) <= OP_FTEEXEC)

#define OP_IS_NUMCOMPARE(op)	\
	((op) >= OP_LT && (op) <= OP_I_NCMP)

#define OP_IS_DIRHOP(op)	\
	((op) >= OP_READDIR && (op) <= OP_CLOSEDIR)

/* ex: set ro: */
                                                                                                                                                                                                                                                                                                                                               usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/overload.h                                                0100644 0000000 0000000 00000005710 12744441327 017723  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    overload.h
 *
 *    Copyright (C) 1997, 1998, 2000, 2001, 2005, 2006, 2007, 2011
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/overload.pl.
 * Any changes made here will be lost!
 */

enum {
    fallback_amg,	/* 0x00 fallback */
    to_sv_amg,		/* 0x01 ${}      */
    to_av_amg,		/* 0x02 @{}      */
    to_hv_amg,		/* 0x03 %{}      */
    to_gv_amg,		/* 0x04 *{}      */
    to_cv_amg,		/* 0x05 &{}      */
    inc_amg,		/* 0x06 ++       */
    dec_amg,		/* 0x07 --       */
    bool__amg,		/* 0x08 bool     */
    numer_amg,		/* 0x09 0+       */
    string_amg,		/* 0x0a ""       */
    not_amg,		/* 0x0b !        */
    copy_amg,		/* 0x0c =        */
    abs_amg,		/* 0x0d abs      */
    neg_amg,		/* 0x0e neg      */
    iter_amg,		/* 0x0f <>       */
    int_amg,		/* 0x10 int      */
    lt_amg,		/* 0x11 <        */
    le_amg,		/* 0x12 <=       */
    gt_amg,		/* 0x13 >        */
    ge_amg,		/* 0x14 >=       */
    eq_amg,		/* 0x15 ==       */
    ne_amg,		/* 0x16 !=       */
    slt_amg,		/* 0x17 lt       */
    sle_amg,		/* 0x18 le       */
    sgt_amg,		/* 0x19 gt       */
    sge_amg,		/* 0x1a ge       */
    seq_amg,		/* 0x1b eq       */
    sne_amg,		/* 0x1c ne       */
    nomethod_amg,	/* 0x1d nomethod */
    add_amg,		/* 0x1e +        */
    add_ass_amg,	/* 0x1f +=       */
    subtr_amg,		/* 0x20 -        */
    subtr_ass_amg,	/* 0x21 -=       */
    mult_amg,		/* 0x22 *        */
    mult_ass_amg,	/* 0x23 *=       */
    div_amg,		/* 0x24 /        */
    div_ass_amg,	/* 0x25 /=       */
    modulo_amg,		/* 0x26 %        */
    modulo_ass_amg,	/* 0x27 %=       */
    pow_amg,		/* 0x28 **       */
    pow_ass_amg,	/* 0x29 **=      */
    lshift_amg,		/* 0x2a <<       */
    lshift_ass_amg,	/* 0x2b <<=      */
    rshift_amg,		/* 0x2c >>       */
    rshift_ass_amg,	/* 0x2d >>=      */
    band_amg,		/* 0x2e &        */
    band_ass_amg,	/* 0x2f &=       */
    bor_amg,		/* 0x30 |        */
    bor_ass_amg,	/* 0x31 |=       */
    bxor_amg,		/* 0x32 ^        */
    bxor_ass_amg,	/* 0x33 ^=       */
    ncmp_amg,		/* 0x34 <=>      */
    scmp_amg,		/* 0x35 cmp      */
    compl_amg,		/* 0x36 ~        */
    atan2_amg,		/* 0x37 atan2    */
    cos_amg,		/* 0x38 cos      */
    sin_amg,		/* 0x39 sin      */
    exp_amg,		/* 0x3a exp      */
    log_amg,		/* 0x3b log      */
    sqrt_amg,		/* 0x3c sqrt     */
    repeat_amg,		/* 0x3d x        */
    repeat_ass_amg,	/* 0x3e x=       */
    concat_amg,		/* 0x3f .        */
    concat_ass_amg,	/* 0x40 .=       */
    smart_amg,		/* 0x41 ~~       */
    ftest_amg,		/* 0x42 -X       */
    regexp_amg,		/* 0x43 qr       */
    max_amg_code
    /* Do not leave a trailing comma here.  C9X allows it, C89 doesn't. */
};

#define NofAMmeth max_amg_code

/* ex: set ro: */
                                                        usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/pad.h                                                     0100644 0000000 0000000 00000037771 12744441327 016670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    pad.h
 *
 *    Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008,
 *    2009, 2010, 2011 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * This file defines the types and macros associated with the API for
 * manipulating scratchpads, which are used by perl to store lexical
 * variables, op targets and constants.
 */

/*
=head1 Pad Data Structures
*/


/* offsets within a pad */

#if PTRSIZE == 4
typedef U32TYPE PADOFFSET;
#else
#   if PTRSIZE == 8
typedef U64TYPE PADOFFSET;
#   endif
#endif
#define NOT_IN_PAD ((PADOFFSET) -1)


struct padlist {
    SSize_t	xpadl_max;	/* max index for which array has space */
    PAD **	xpadl_alloc;	/* pointer to beginning of array of AVs */
    PADNAMELIST*xpadl_outid;	/* Padnamelist of outer pad; used as ID */
};


/* a value that PL_cop_seqmax is guaranteed never to be,
 * flagging that a lexical is being introduced, or has not yet left scope
 */
#define PERL_PADSEQ_INTRO  U32_MAX


/* B.xs needs these for the benefit of B::Deparse */
/* Low range end is exclusive (valid from the cop seq after this one) */
/* High range end is inclusive (valid up to this cop seq) */

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define COP_SEQ_RANGE_LOW(sv)						\
	(({ const SV *const _sv_cop_seq_range_low = (const SV *) (sv);	\
	  assert(SvTYPE(_sv_cop_seq_range_low) == SVt_NV		\
		 || SvTYPE(_sv_cop_seq_range_low) >= SVt_PVNV);		\
	  assert(SvTYPE(_sv_cop_seq_range_low) != SVt_PVAV);		\
	  assert(SvTYPE(_sv_cop_seq_range_low) != SVt_PVHV);		\
	  assert(SvTYPE(_sv_cop_seq_range_low) != SVt_PVCV);		\
	  assert(SvTYPE(_sv_cop_seq_range_low) != SVt_PVFM);		\
	  assert(!isGV_with_GP(_sv_cop_seq_range_low));			\
	  ((XPVNV*) MUTABLE_PTR(SvANY(_sv_cop_seq_range_low)))->xnv_u.xpad_cop_seq.xlow; \
	 }))
#  define COP_SEQ_RANGE_HIGH(sv)					\
	(({ const SV *const _sv_cop_seq_range_high = (const SV *) (sv);	\
	  assert(SvTYPE(_sv_cop_seq_range_high) == SVt_NV 		\
                 || SvTYPE(_sv_cop_seq_range_high) >= SVt_PVNV);	\
	  assert(SvTYPE(_sv_cop_seq_range_high) != SVt_PVAV);		\
	  assert(SvTYPE(_sv_cop_seq_range_high) != SVt_PVHV);		\
	  assert(SvTYPE(_sv_cop_seq_range_high) != SVt_PVCV);		\
	  assert(SvTYPE(_sv_cop_seq_range_high) != SVt_PVFM);		\
	  assert(!isGV_with_GP(_sv_cop_seq_range_high));		\
	  ((XPVNV*) MUTABLE_PTR(SvANY(_sv_cop_seq_range_high)))->xnv_u.xpad_cop_seq.xhigh; \
	 }))
#  define PARENT_PAD_INDEX(sv)						\
	(({ const SV *const _sv_parent_pad_index = (const SV *) (sv);	\
	  assert(SvTYPE(_sv_parent_pad_index) == SVt_NV			\
		 || SvTYPE(_sv_parent_pad_index) >= SVt_PVNV);		\
	  assert(SvTYPE(_sv_parent_pad_index) != SVt_PVAV);		\
	  assert(SvTYPE(_sv_parent_pad_index) != SVt_PVHV);		\
	  assert(SvTYPE(_sv_parent_pad_index) != SVt_PVCV);		\
	  assert(SvTYPE(_sv_parent_pad_index) != SVt_PVFM);		\
	  assert(!isGV_with_GP(_sv_parent_pad_index));			\
	  ((XPVNV*) MUTABLE_PTR(SvANY(_sv_parent_pad_index)))->xnv_u.xpad_cop_seq.xlow; \
	 }))
#  define PARENT_FAKELEX_FLAGS(sv)					\
	(({ const SV *const _sv_parent_fakelex_flags = (const SV *) (sv); \
	  assert(SvTYPE(_sv_parent_fakelex_flags) == SVt_NV  		\
		 || SvTYPE(_sv_parent_fakelex_flags) >= SVt_PVNV);	\
	  assert(SvTYPE(_sv_parent_fakelex_flags) != SVt_PVAV);		\
	  assert(SvTYPE(_sv_parent_fakelex_flags) != SVt_PVHV);		\
	  assert(SvTYPE(_sv_parent_fakelex_flags) != SVt_PVCV);		\
	  assert(SvTYPE(_sv_parent_fakelex_flags) != SVt_PVFM);		\
	  assert(!isGV_with_GP(_sv_parent_fakelex_flags));		\
	  ((XPVNV*) MUTABLE_PTR(SvANY(_sv_parent_fakelex_flags)))->xnv_u.xpad_cop_seq.xhigh; \
	 }))
#else
#  define COP_SEQ_RANGE_LOW(sv)		\
	(0 + (((XPVNV*) SvANY(sv))->xnv_u.xpad_cop_seq.xlow))
#  define COP_SEQ_RANGE_HIGH(sv)	\
	(0 + (((XPVNV*) SvANY(sv))->xnv_u.xpad_cop_seq.xhigh))


#  define PARENT_PAD_INDEX(sv)		\
	(0 + (((XPVNV*) SvANY(sv))->xnv_u.xpad_cop_seq.xlow))
#  define PARENT_FAKELEX_FLAGS(sv)	\
	(0 + (((XPVNV*) SvANY(sv))->xnv_u.xpad_cop_seq.xhigh))
#endif

/* Flags set in the SvIVX field of FAKE namesvs */

#define PAD_FAKELEX_ANON   1 /* the lex is declared in an ANON, or ... */
#define PAD_FAKELEX_MULTI  2 /* the lex can be instantiated multiple times */

/* flags for the pad_new() function */

#define padnew_CLONE	1	/* this pad is for a cloned CV */
#define padnew_SAVE	2	/* save old globals */
#define padnew_SAVESUB	4	/* also save extra stuff for start of sub */

/* values for the pad_tidy() function */

typedef enum {
	padtidy_SUB,		/* tidy up a pad for a sub, */
	padtidy_SUBCLONE,	/* a cloned sub, */
	padtidy_FORMAT		/* or a format */
} padtidy_type;

/* flags for pad_add_name_pvn. */

#define padadd_OUR		0x01	   /* our declaration. */
#define padadd_STATE		0x02	   /* state declaration. */
#define padadd_NO_DUP_CHECK	0x04	   /* skip warning on dups. */
#define padadd_STALEOK		0x08	   /* allow stale lexical in active
					    * sub, but only one level up */
#define padadd_UTF8_NAME	SVf_UTF8   /* name is UTF-8 encoded. */

/* ASSERT_CURPAD_LEGAL and ASSERT_CURPAD_ACTIVE respectively determine
 * whether PL_comppad and PL_curpad are consistent and whether they have
 * active values */

#ifndef PERL_MAD
#  define pad_peg(label)
#endif

#ifdef DEBUGGING
#  define ASSERT_CURPAD_LEGAL(label) \
    pad_peg(label); \
    if (PL_comppad ? (AvARRAY(PL_comppad) != PL_curpad) : (PL_curpad != 0))  \
	Perl_croak(aTHX_ "panic: illegal pad in %s: 0x%" UVxf "[0x%" UVxf "]",\
	    label, PTR2UV(PL_comppad), PTR2UV(PL_curpad));


#  define ASSERT_CURPAD_ACTIVE(label) \
    pad_peg(label); \
    if (!PL_comppad || (AvARRAY(PL_comppad) != PL_curpad))		  \
	Perl_croak(aTHX_ "panic: invalid pad in %s: 0x%" UVxf "[0x%" UVxf "]",\
	    label, PTR2UV(PL_comppad), PTR2UV(PL_curpad));
#else
#  define ASSERT_CURPAD_LEGAL(label)
#  define ASSERT_CURPAD_ACTIVE(label)
#endif



/* Note: the following three macros are actually defined in scope.h, but
 * they are documented here for completeness, since they directly or
 * indirectly affect pads.

=for apidoc m|void|SAVEPADSV	|PADOFFSET po
Save a pad slot (used to restore after an iteration)

XXX DAPM it would make more sense to make the arg a PADOFFSET
=for apidoc m|void|SAVECLEARSV	|SV **svp
Clear the pointed to pad value on scope exit.  (i.e. the runtime action of
'my')

=for apidoc m|void|SAVECOMPPAD
save PL_comppad and PL_curpad


=for apidoc Amx|PAD **|PadlistARRAY|PADLIST padlist
The C array of a padlist, containing the pads.  Only subscript it with
numbers >= 1, as the 0th entry is not guaranteed to remain usable.

=for apidoc Amx|SSize_t|PadlistMAX|PADLIST padlist
The index of the last allocated space in the padlist.  Note that the last
pad may be in an earlier slot.  Any entries following it will be NULL in
that case.

=for apidoc Amx|PADNAMELIST *|PadlistNAMES|PADLIST padlist
The names associated with pad entries.

=for apidoc Amx|PADNAME **|PadlistNAMESARRAY|PADLIST padlist
The C array of pad names.

=for apidoc Amx|SSize_t|PadlistNAMESMAX|PADLIST padlist
The index of the last pad name.

=for apidoc Amx|U32|PadlistREFCNT|PADLIST padlist
The reference count of the padlist.  Currently this is always 1.

=for apidoc Amx|PADNAME **|PadnamelistARRAY|PADNAMELIST pnl
The C array of pad names.

=for apidoc Amx|SSize_t|PadnamelistMAX|PADNAMELIST pnl
The index of the last pad name.

=for apidoc Amx|SV **|PadARRAY|PAD pad
The C array of pad entries.

=for apidoc Amx|SSize_t|PadMAX|PAD pad
The index of the last pad entry.

=for apidoc Amx|char *|PadnamePV|PADNAME pn	
The name stored in the pad name struct.  This returns NULL for a target or
GV slot.

=for apidoc Amx|STRLEN|PadnameLEN|PADNAME pn	
The length of the name.

=for apidoc Amx|bool|PadnameUTF8|PADNAME pn
Whether PadnamePV is in UTF8.

=for apidoc Amx|SV *|PadnameSV|PADNAME pn
Returns the pad name as an SV.  This is currently just C<pn>.  It will
begin returning a new mortal SV if pad names ever stop being SVs.

=for apidoc m|bool|PadnameIsOUR|PADNAME pn
Whether this is an "our" variable.

=for apidoc m|HV *|PadnameOURSTASH
The stash in which this "our" variable was declared.

=for apidoc m|bool|PadnameOUTER|PADNAME pn
Whether this entry belongs to an outer pad.

=for apidoc m|bool|PadnameIsSTATE|PADNAME pn
Whether this is a "state" variable.

=for apidoc m|HV *|PadnameTYPE|PADNAME pn
The stash associated with a typed lexical.  This returns the %Foo:: hash
for C<my Foo $bar>.


=for apidoc m|SV *|PAD_SETSV	|PADOFFSET po|SV* sv
Set the slot at offset C<po> in the current pad to C<sv>

=for apidoc m|SV *|PAD_SV	|PADOFFSET po
Get the value at offset C<po> in the current pad

=for apidoc m|SV *|PAD_SVl	|PADOFFSET po
Lightweight and lvalue version of C<PAD_SV>.
Get or set the value at offset C<po> in the current pad.
Unlike C<PAD_SV>, does not print diagnostics with -DX.
For internal use only.

=for apidoc m|SV *|PAD_BASE_SV	|PADLIST padlist|PADOFFSET po
Get the value from slot C<po> in the base (DEPTH=1) pad of a padlist

=for apidoc m|void|PAD_SET_CUR	|PADLIST padlist|I32 n
Set the current pad to be pad C<n> in the padlist, saving
the previous current pad.  NB currently this macro expands to a string too
long for some compilers, so it's best to replace it with

    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);


=for apidoc m|void|PAD_SET_CUR_NOSAVE	|PADLIST padlist|I32 n
like PAD_SET_CUR, but without the save

=for apidoc m|void|PAD_SAVE_SETNULLPAD
Save the current pad then set it to null.

=for apidoc m|void|PAD_SAVE_LOCAL|PAD *opad|PAD *npad
Save the current pad to the local variable opad, then make the
current pad equal to npad

=for apidoc m|void|PAD_RESTORE_LOCAL|PAD *opad
Restore the old pad saved into the local variable opad by PAD_SAVE_LOCAL()

=cut
*/

#define PadlistARRAY(pl)	(pl)->xpadl_alloc
#define PadlistMAX(pl)		(pl)->xpadl_max
#define PadlistNAMES(pl)	(*PadlistARRAY(pl))
#define PadlistNAMESARRAY(pl)	PadnamelistARRAY(PadlistNAMES(pl))
#define PadlistNAMESMAX(pl)	PadnamelistMAX(PadlistNAMES(pl))
#define PadlistREFCNT(pl)	1	/* reserved for future use */

#define PadnamelistARRAY(pnl)	AvARRAY(pnl)
#define PadnamelistMAX(pnl)	AvFILLp(pnl)
#define PadnamelistMAXNAMED(pnl) \
	((XPVAV*) SvANY(pnl))->xmg_u.xmg_hash_index

#define PadARRAY(pad)		AvARRAY(pad)
#define PadMAX(pad)		AvFILLp(pad)

#define PadnamePV(pn)		(SvPOKp(pn) ? SvPVX(pn) : NULL)
#define PadnameLEN(pn)		((pn) == &PL_sv_undef ? 0 : SvCUR(pn))
#define PadnameUTF8(pn)		!!SvUTF8(pn)
#define PadnameSV(pn)		pn
#define PadnameIsOUR(pn)	!!SvPAD_OUR(pn)
#define PadnameOURSTASH(pn)	SvOURSTASH(pn)
#define PadnameOUTER(pn)	!!SvFAKE(pn)
#define PadnameIsSTATE(pn)	!!SvPAD_STATE(pn)
#define PadnameTYPE(pn)		(SvPAD_TYPED(pn) ? SvSTASH(pn) : NULL)


#ifdef DEBUGGING
#  define PAD_SV(po)	   pad_sv(po)
#  define PAD_SETSV(po,sv) pad_setsv(po,sv)
#else
#  define PAD_SV(po)       (PL_curpad[po])
#  define PAD_SETSV(po,sv) PL_curpad[po] = (sv)
#endif

#define PAD_SVl(po)       (PL_curpad[po])

#define PAD_BASE_SV(padlist, po) \
	(PadlistARRAY(padlist)[1])					\
	    ? AvARRAY(MUTABLE_AV((PadlistARRAY(padlist)[1])))[po] \
	    : NULL;


#define PAD_SET_CUR_NOSAVE(padlist,nth) \
	PL_comppad = (PAD*) (PadlistARRAY(padlist)[nth]);	\
	PL_curpad = AvARRAY(PL_comppad);			\
	DEBUG_Xv(PerlIO_printf(Perl_debug_log,			\
	      "Pad 0x%" UVxf "[0x%" UVxf "] set_cur    depth=%d\n",	\
	      PTR2UV(PL_comppad), PTR2UV(PL_curpad), (int)(nth)));


#define PAD_SET_CUR(padlist,nth) \
	SAVECOMPPAD();						\
	PAD_SET_CUR_NOSAVE(padlist,nth);


#define PAD_SAVE_SETNULLPAD()	SAVECOMPPAD(); \
	PL_comppad = NULL; PL_curpad = NULL;	\
	DEBUG_Xv(PerlIO_printf(Perl_debug_log, "Pad set_null\n"));

#define PAD_SAVE_LOCAL(opad,npad) \
	opad = PL_comppad;					\
	PL_comppad = (npad);					\
	PL_curpad =  PL_comppad ? AvARRAY(PL_comppad) : NULL;	\
	DEBUG_Xv(PerlIO_printf(Perl_debug_log,			\
	      "Pad 0x%" UVxf "[0x%" UVxf "] save_local\n",		\
	      PTR2UV(PL_comppad), PTR2UV(PL_curpad)));

#define PAD_RESTORE_LOCAL(opad) \
        assert(!opad || !SvIS_FREED(opad));					\
	PL_comppad = opad;						\
	PL_curpad =  PL_comppad ? AvARRAY(PL_comppad) : NULL;	\
	DEBUG_Xv(PerlIO_printf(Perl_debug_log,			\
	      "Pad 0x%" UVxf "[0x%" UVxf "] restore_local\n",	\
	      PTR2UV(PL_comppad), PTR2UV(PL_curpad)));


/*
=for apidoc m|void|CX_CURPAD_SAVE|struct context
Save the current pad in the given context block structure.

=for apidoc m|SV *|CX_CURPAD_SV|struct context|PADOFFSET po
Access the SV at offset po in the saved current pad in the given
context block structure (can be used as an lvalue).

=cut
*/

#define CX_CURPAD_SAVE(block)  (block).oldcomppad = PL_comppad
#define CX_CURPAD_SV(block,po) (AvARRAY(MUTABLE_AV(((block).oldcomppad)))[po])


/*
=for apidoc m|U32|PAD_COMPNAME_FLAGS|PADOFFSET po
Return the flags for the current compiling pad name
at offset C<po>.  Assumes a valid slot entry.

=for apidoc m|char *|PAD_COMPNAME_PV|PADOFFSET po
Return the name of the current compiling pad name
at offset C<po>.  Assumes a valid slot entry.

=for apidoc m|HV *|PAD_COMPNAME_TYPE|PADOFFSET po
Return the type (stash) of the current compiling pad name at offset
C<po>.  Must be a valid name.  Returns null if not typed.

=for apidoc m|HV *|PAD_COMPNAME_OURSTASH|PADOFFSET po
Return the stash associated with an C<our> variable.
Assumes the slot entry is a valid C<our> lexical.

=for apidoc m|STRLEN|PAD_COMPNAME_GEN|PADOFFSET po
The generation number of the name at offset C<po> in the current
compiling pad (lvalue).  Note that C<SvUVX> is hijacked for this purpose.

=for apidoc m|STRLEN|PAD_COMPNAME_GEN_set|PADOFFSET po|int gen
Sets the generation number of the name at offset C<po> in the current
ling pad (lvalue) to C<gen>.  Note that C<SvUV_set> is hijacked for this purpose.

=cut

*/

#define PAD_COMPNAME(po)	PAD_COMPNAME_SV(po)
#define PAD_COMPNAME_SV(po) (*av_fetch(PL_comppad_name, (po), FALSE))
#define PAD_COMPNAME_FLAGS(po) SvFLAGS(PAD_COMPNAME_SV(po))
#define PAD_COMPNAME_FLAGS_isOUR(po) SvPAD_OUR(PAD_COMPNAME_SV(po))
#define PAD_COMPNAME_PV(po) SvPV_nolen(PAD_COMPNAME_SV(po))

#define PAD_COMPNAME_TYPE(po) pad_compname_type(po)

#define PAD_COMPNAME_OURSTASH(po) \
    (SvOURSTASH(PAD_COMPNAME_SV(po)))

#define PAD_COMPNAME_GEN(po) ((STRLEN)SvUVX(AvARRAY(PL_comppad_name)[po]))

#define PAD_COMPNAME_GEN_set(po, gen) SvUV_set(AvARRAY(PL_comppad_name)[po], (UV)(gen))


/*
=for apidoc m|void|PAD_CLONE_VARS|PerlInterpreter *proto_perl|CLONE_PARAMS* param
Clone the state variables associated with running and compiling pads.

=cut
*/

/* NB - we set PL_comppad to null unless it points at a value that
 * has already been dup'ed, ie it points to part of an active padlist.
 * Otherwise PL_comppad ends up being a leaked scalar in code like
 * the following:
 *     threads->create(sub { threads->create(sub {...} ) } );
 * where the second thread dups the outer sub's comppad but not the
 * sub's CV or padlist. */

#define PAD_CLONE_VARS(proto_perl, param)				\
    PL_comppad			= av_dup(proto_perl->Icomppad, param);	\
    PL_curpad = PL_comppad ?  AvARRAY(PL_comppad) : NULL;		\
    PL_comppad_name		= av_dup(proto_perl->Icomppad_name, param); \
    PL_comppad_name_fill	= proto_perl->Icomppad_name_fill;	\
    PL_comppad_name_floor	= proto_perl->Icomppad_name_floor;	\
    PL_min_intro_pending	= proto_perl->Imin_intro_pending;	\
    PL_max_intro_pending	= proto_perl->Imax_intro_pending;	\
    PL_padix			= proto_perl->Ipadix;			\
    PL_padix_floor		= proto_perl->Ipadix_floor;		\
    PL_pad_reset_pending	= proto_perl->Ipad_reset_pending;	\
    PL_cop_seqmax		= proto_perl->Icop_seqmax;

/*
=for apidoc Am|PADOFFSET|pad_add_name_pvs|const char *name|U32 flags|HV *typestash|HV *ourstash

Exactly like L</pad_add_name_pvn>, but takes a literal string instead
of a string/length pair.

=cut
*/

#define pad_add_name_pvs(name,flags,typestash,ourstash) \
    Perl_pad_add_name_pvn(aTHX_ STR_WITH_LEN(name), flags, typestash, ourstash)

/*
=for apidoc Am|PADOFFSET|pad_findmy_pvs|const char *name|U32 flags

Exactly like L</pad_findmy_pvn>, but takes a literal string instead
of a string/length pair.

=cut
*/

#define pad_findmy_pvs(name,flags) \
    Perl_pad_findmy_pvn(aTHX_ STR_WITH_LEN(name), flags)

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
       usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/parser.h                                                  0100644 0000000 0000000 00000015031 12744441327 017401  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    parser.h
 *
 *    Copyright (c) 2006, 2007, 2009, 2010, 2011 Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 * 
 * This file defines the layout of the parser object used by the parser
 * and lexer (perly.c, toke.c).
 */

#define YYEMPTY		(-2)

typedef struct {
    YYSTYPE val;    /* semantic value */
    short   state;
    I32     savestack_ix;	/* size of savestack at this state */
    CV	    *compcv; /* value of PL_compcv when this value was created */
#ifdef DEBUGGING
    const char  *name; /* token/rule name for -Dpv */
#endif
} yy_stack_frame;

/* Fields that need to be shared with (i.e., visible to) inner lex-
   ing scopes. */
typedef struct yy_lexshared {
    struct yy_lexshared	*ls_prev;
    SV			*ls_linestr;	/* mirrors PL_parser->linestr */
    char		*ls_bufptr;	/* mirrors PL_parser->bufptr */
    char		*re_eval_start;	/* start of "(?{..." text */
    SV			*re_eval_str;	/* "(?{...})" text */
} LEXSHARED;

typedef struct yy_parser {

    /* parser state */

    struct yy_parser *old_parser; /* previous value of PL_parser */
    YYSTYPE	    yylval;	/* value of lookahead symbol, set by yylex() */
    int		    yychar;	/* The lookahead symbol.  */

    /* Number of tokens to shift before error messages enabled.  */
    int		    yyerrstatus;

    int		    stack_size;
    int		    yylen;	/* length of active reduction */
    yy_stack_frame  *stack;	/* base of stack */
    yy_stack_frame  *ps;	/* current stack frame */

    /* lexer state */

    I32		lex_brackets;	/* square and curly bracket count */
    I32		lex_casemods;	/* casemod count */
    char	*lex_brackstack;/* what kind of brackets to pop */
    char	*lex_casestack;	/* what kind of case mods in effect */
    U8		lex_defer;	/* state after determined token */
    U8		lex_dojoin;	/* doing an array interpolation
				   1 = @{...}  2 = ->@ */
    U8		lex_expect;	/* expect after determined token */
    U8		expect;		/* how to interpret ambiguous tokens */
    I32		lex_formbrack;	/* bracket count at outer format level */
    OP		*lex_inpat;	/* in pattern $) and $| are special */
    OP		*lex_op;	/* extra info to pass back on op */
    SV		*lex_repl;	/* runtime replacement from s/// */
    U16		lex_inwhat;	/* what kind of quoting are we in */
    OPCODE	last_lop_op;	/* last named list or unary operator */
    I32		lex_starts;	/* how many interps done on level */
    SV		*lex_stuff;	/* runtime pattern from m// or s/// */
    I32		multi_start;	/* 1st line of multi-line string */
    I32		multi_end;	/* last line of multi-line string */
    char	multi_open;	/* delimiter of said string */
    char	multi_close;	/* delimiter of said string */
    bool	preambled;
    bool        lex_re_reparsing; /* we're doing G_RE_REPARSING */
    I32		lex_allbrackets;/* (), [], {}, ?: bracket count */
    SUBLEXINFO	sublex_info;
    LEXSHARED	*lex_shared;
    SV		*linestr;	/* current chunk of src text */
    char	*bufptr;	/* carries the cursor (current parsing
				   position) from one invocation of yylex
				   to the next */
    char	*oldbufptr;	/* in yylex, beginning of current token */
    char	*oldoldbufptr;	/* in yylex, beginning of previous token */
    char	*bufend;	
    char	*linestart;	/* beginning of most recently read line */
    char	*last_uni;	/* position of last named-unary op */
    char	*last_lop;	/* position of last list operator */
    /* copline is used to pass a specific line number to newSTATEOP.  It
       is a one-time line number, as newSTATEOP invalidates it (sets it to
       NOLINE) after using it.  The purpose of this is to report line num-
       bers in multiline constructs using the number of the first line. */
    line_t	copline;
    U16		in_my;		/* we're compiling a "my"/"our" declaration */
    U8		lex_state;	/* next token is determined */
    U8		error_count;	/* how many compile errors so far, max 10 */
    HV		*in_my_stash;	/* declared class of this "my" declaration */
    PerlIO	*rsfp;		/* current source file pointer */
    AV		*rsfp_filters;	/* holds chain of active source filters */
    U8		form_lex_state;	/* remember lex_state when parsing fmt */

#ifdef PERL_MAD
    SV		*endwhite;
    I32		faketokens;
    I32		lasttoke;
    SV		*nextwhite;
    I32		realtokenstart;
    SV		*skipwhite;
    SV		*thisclose;
    MADPROP *	thismad;
    SV		*thisopen;
    SV		*thisstuff;
    SV		*thistoken;
    SV		*thiswhite;

/* What we know when we're in LEX_KNOWNEXT state. */
    NEXTTOKE	nexttoke[5];	/* value of next token, if any */
    I32		curforce;
#else
    YYSTYPE	nextval[5];	/* value of next token, if any */
    I32		nexttype[5];	/* type of next token */
    I32		nexttoke;
#endif

    COP		*saved_curcop;	/* the previous PL_curcop */
    char	tokenbuf[256];
    line_t	herelines;	/* number of lines in here-doc */
    line_t	preambling;	/* line # when processing $ENV{PERL5DB} */
    U8		lex_fakeeof;	/* precedence at which to fake EOF */
    U8		lex_flags;
    PERL_BITFIELD16	in_pod:1;      /* lexer is within a =pod section */
    PERL_BITFIELD16	filtered:1;    /* source filters in evalbytes */
    PERL_BITFIELD16	saw_infix_sigil:1; /* saw & or * or % operator */
} yy_parser;

/* flags for lexer API */
#define LEX_STUFF_UTF8		0x00000001
#define LEX_KEEP_PREVIOUS	0x00000002

#ifdef PERL_CORE
# define LEX_START_SAME_FILTER	0x00000001
# define LEX_IGNORE_UTF8_HINTS	0x00000002
# define LEX_EVALBYTES		0x00000004
# define LEX_START_COPIED	0x00000008
# define LEX_DONT_CLOSE_RSFP	0x00000010
# define LEX_START_FLAGS \
	(LEX_START_SAME_FILTER|LEX_START_COPIED \
	|LEX_IGNORE_UTF8_HINTS|LEX_EVALBYTES|LEX_DONT_CLOSE_RSFP)
#endif

/* flags for parser API */
#define PARSE_OPTIONAL          0x00000001

/* values for lex_fakeeof */
enum {
    LEX_FAKEEOF_NEVER,      /* don't fake EOF */
    LEX_FAKEEOF_CLOSING,    /* fake EOF at unmatched closing punctuation */
    LEX_FAKEEOF_NONEXPR,    /* ... and at token that can't be in expression */
    LEX_FAKEEOF_LOWLOGIC,   /* ... and at low-precedence logic operator */
    LEX_FAKEEOF_COMMA,      /* ... and at comma */
    LEX_FAKEEOF_ASSIGN,     /* ... and at assignment operator */
    LEX_FAKEEOF_IFELSE,     /* ... and at ?: operator */
    LEX_FAKEEOF_RANGE,      /* ... and at range operator */
    LEX_FAKEEOF_LOGIC,      /* ... and at logic operator */
    LEX_FAKEEOF_BITWISE,    /* ... and at bitwise operator */
    LEX_FAKEEOF_COMPARE,    /* ... and at comparison operator */
    LEX_FAKEEOF_MAX
};

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/patchlevel-debian.h                                       0100644 0000000 0000000 00000026234 12744441327 021463  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        	,"DEBPKG:debian/cpan_definstalldirs - Provide a sensible INSTALLDIRS default for modules installed from CPAN."
	,"DEBPKG:debian/db_file_ver - http://bugs.debian.org/340047 Remove overly restrictive DB_File version check."
	,"DEBPKG:debian/doc_info - Replace generic man(1) instructions with Debian-specific information."
	,"DEBPKG:debian/enc2xs_inc - http://bugs.debian.org/290336 Tweak enc2xs to follow symlinks and ignore missing @INC directories."
	,"DEBPKG:debian/errno_ver - http://bugs.debian.org/343351 Remove Errno version check due to upgrade problems with long-running processes."
	,"DEBPKG:debian/libperl_embed_doc - http://bugs.debian.org/186778 Note that libperl-dev package is required for embedded linking"
	,"DEBPKG:fixes/respect_umask - Respect umask during installation"
	,"DEBPKG:debian/writable_site_dirs - Set umask approproately for site install directories"
	,"DEBPKG:debian/extutils_set_libperl_path - EU:MM: set location of libperl.a under /usr/lib"
	,"DEBPKG:debian/no_packlist_perllocal - Don't install .packlist or perllocal.pod for perl or vendor"
	,"DEBPKG:debian/prefix_changes - Fiddle with *PREFIX and variables written to the makefile"
	,"DEBPKG:debian/fakeroot - Postpone LD_LIBRARY_PATH evaluation to the binary targets."
	,"DEBPKG:debian/instmodsh_doc - Debian policy doesn't install .packlist files for core or vendor."
	,"DEBPKG:debian/ld_run_path - Remove standard libs from LD_RUN_PATH as per Debian policy."
	,"DEBPKG:debian/libnet_config_path - Set location of libnet.cfg to /etc/perl/Net as /usr may not be writable."
	,"DEBPKG:debian/mod_paths - Tweak @INC ordering for Debian"
	,"DEBPKG:debian/module_build_man_extensions - http://bugs.debian.org/479460 Adjust Module::Build manual page extensions for the Debian Perl policy"
	,"DEBPKG:debian/prune_libs - http://bugs.debian.org/128355 Prune the list of libraries wanted to what we actually need."
	,"DEBPKG:fixes/net_smtp_docs - [rt.cpan.org #36038] http://bugs.debian.org/100195 Document the Net::SMTP 'Port' option"
	,"DEBPKG:debian/perlivp - http://bugs.debian.org/510895 Make perlivp skip include directories in /usr/local"
	,"DEBPKG:debian/deprecate-with-apt - http://bugs.debian.org/747628 Point users to Debian packages of deprecated core modules"
	,"DEBPKG:debian/squelch-locale-warnings - http://bugs.debian.org/508764 Squelch locale warnings in Debian package maintainer scripts"
	,"DEBPKG:debian/skip-upstream-git-tests - Skip tests specific to the upstream Git repository"
	,"DEBPKG:debian/patchlevel - http://bugs.debian.org/567489 List packaged patches for 5.20.2-3+deb8u6 in patchlevel.h"
	,"DEBPKG:debian/skip-kfreebsd-crash - http://bugs.debian.org/628493 [perl #96272] Skip a crashing test case in t/op/threads.t on GNU/kFreeBSD"
	,"DEBPKG:fixes/document_makemaker_ccflags - http://bugs.debian.org/628522 [rt.cpan.org #68613] Document that CCFLAGS should include $Config{ccflags}"
	,"DEBPKG:debian/find_html2text - http://bugs.debian.org/640479 Configure CPAN::Distribution with correct name of html2text"
	,"DEBPKG:debian/perl5db-x-terminal-emulator.patch - http://bugs.debian.org/668490 Invoke x-terminal-emulator rather than xterm in perl5db.pl"
	,"DEBPKG:debian/cpan-missing-site-dirs - http://bugs.debian.org/688842 Fix CPAN::FirstTime defaults with nonexisting site dirs if a parent is writable"
	,"DEBPKG:fixes/memoize_storable_nstore - [rt.cpan.org #77790] http://bugs.debian.org/587650 Memoize::Storable: respect 'nstore' option not respected"
	,"DEBPKG:debian/regen-skip - Skip a regeneration check in unrelated git repositories"
	,"DEBPKG:fixes/regcomp-mips-optim - [perl #122817] http://bugs.debian.org/754054 Downgrade the optimization of regcomp.c on mips and mipsel due to a gcc-4.9 bug"
	,"DEBPKG:debian/makemaker-pasthru - http://bugs.debian.org/758471 Pass LD settings through to subdirectories"
	,"DEBPKG:fixes/perldoc-less-R - [rt.cpan.org #98636] http://bugs.debian.org/758689 Tell the 'less' pager to allow terminal escape sequences"
	,"DEBPKG:fixes/pod_man_reproducible_date - http://bugs.debian.org/759405 Support POD_MAN_DATE in Pod::Man for the left-hand footer"
	,"DEBPKG:fixes/io_uncompress_gunzip_inmemory - http://bugs.debian.org/747363 [rt.cpan.org #95494] Fix gunzip to in-memory file handle"
	,"DEBPKG:fixes/socket_test_recv_fix - http://bugs.debian.org/758718 [perl #122657] Compare recv return value to peername in socket test"
	,"DEBPKG:fixes/hurd_socket_recv_todo - http://bugs.debian.org/758718 [perl #122657] TODO checking the result of recv() on hurd"
	,"DEBPKG:fixes/regexp-performance - [0fa70a0] http://bugs.debian.org/777556 [perl #123743] simpify and speed up /.*.../ handling"
	,"DEBPKG:fixes/failed_require_diagnostics - http://bugs.debian.org/781120 [perl #123270] Report inaccesible file on failed require"
	,"DEBPKG:fixes/array-cloning - http://bugs.debian.org/779357 [perl #124127] [902d169] fix cloning arrays with unused elements"
	,"DEBPKG:fixes/perldb-threads - http://bugs.debian.org/779357 [perl #124127] [41ef2c6] lib/perl5db.pl: Restore noop lock prototype"
	,"DEBPKG:fixes/CVE-2015-8607_file_spec_taint_fix - ensure File::Spec::canonpath() preserves taint"
	,"DEBPKG:fixes/encode-unicode-bom - http://bugs.debian.org/798727 [rt.cpan.org #107043] Address https://rt.cpan.org/Public/Bug/Display.html?id=107043"
	,"DEBPKG:debian/encode-unicode-bom-doc - http://bugs.debian.org/798727 Document Debian backport of Encode::Unicode fix"
	,"DEBPKG:debian/kfreebsd-softupdates - http://bugs.debian.org/796798 Work around Debian Bug#796798"
	,"DEBPKG:fixes/CVE-2016-2381_duplicate_env - remove duplicate environment variables from environ"
	,"DEBPKG:debian/debugperl-compat-fix - [perl #127212] http://bugs.debian.org/810326 Disable PERL_TRACK_MEMPOOL for debugging builds"
	,"DEBPKG:fixes/CVE-2015-8853_regexp_hang - http://bugs.debian.org/821848 [perl #123562] PATCH [perl #123562] Regexp-matching \"hangs\""
	,"DEBPKG:fixes/utf8_regexp_crash - http://bugs.debian.org/820328 [perl #124109] save_re_context(): do \"local $n\" with no PL_curpm"
	,"DEBPKG:fixes/regcomp_whitespace_fix - http://bugs.debian.org/820328 [perl #124109] Perl_save_re_context(): re-indent after last commit"
	,"DEBPKG:fixes/5.20.3/eval_label_crash - http://bugs.debian.org/822336 [perl #123652] eval {label:} crash"
	,"DEBPKG:fixes/5.20.3/preserve_record_separator - http://bugs.debian.org/822336 [perl #123218] \"preserve\" $/ if set to a bad value"
	,"DEBPKG:fixes/5.20.3/test_count_base_rs - http://bugs.debian.org/822336 Fix test count in t/base/rs.t"
	,"DEBPKG:fixes/5.20.3/remove_get_magic - http://bugs.debian.org/822336 [perl #123739] Remove get-magic from $/"
	,"DEBPKG:fixes/5.20.3/speed_up_scalar_g - http://bugs.debian.org/822336 [perl #123202] speed up scalar //g against tainted strings"
	,"DEBPKG:fixes/5.20.3/accidental_all_features - http://bugs.debian.org/822336 Stop $^H |= 0x1c020000 from enabling all features"
	,"DEBPKG:fixes/5.20.3/multidimensional_arrays_utf8 - http://bugs.debian.org/822336 [perl #124113] Make check for multi-dimensional arrays be UTF8-aware"
	,"DEBPKG:fixes/5.20.3/unquoted_utf8_heredoc_terminators - http://bugs.debian.org/822336 Allow unquoted UTF-8 HERE-document terminators"
	,"DEBPKG:fixes/5.20.3/parentheses_ambiguous_warning_utf8_functions - http://bugs.debian.org/822336 Fix \"...without parentheses is ambuguous\" warning for UTF-8 function names"
	,"DEBPKG:fixes/5.20.3/leak_namepv_copy - http://bugs.debian.org/822336 [perl #123786] don't leak the temp utf8 copy of namepv"
	,"DEBPKG:fixes/5.20.3/h2ph_hex_constants - http://bugs.debian.org/822336 h2ph: correct handling of hex constants for the preamble"
	,"DEBPKG:fixes/5.20.3/leftbracket_XTERMORDORDOR - http://bugs.debian.org/822336 [perl #123711] Fix crash with 0-5x-l{0}"
	,"DEBPKG:fixes/5.20.3/fatalize_warnings_unwinding - http://bugs.debian.org/822336 [perl #123398] don't fatalize warnings during unwinding (#123398)"
	,"DEBPKG:fixes/5.20.3/setpgrp - http://bugs.debian.org/822336 =?UTF-8?q?Don=E2=80=99t=20treat=20setpgrp($nonzero)=20as=20setpgr?= =?UTF-8?q?p(1)?="
	,"DEBPKG:fixes/5.20.3/death_unwinding_crash - http://bugs.debian.org/822336 [perl #124156] RT #124156: death during unwinding causes crash"
	,"DEBPKG:fixes/5.20.3/stashpvn_crash - http://bugs.debian.org/822336 [perl #125541] Fix crash with %::=(); J->${\\\"::\"}"
	,"DEBPKG:fixes/5.20.3/possessive_quantifier - http://bugs.debian.org/822336 [perl #125825] PATCH: [perl 125825] {n}+ possessive quantifier broken"
	,"DEBPKG:fixes/5.20.3/quoted_code_crash - http://bugs.debian.org/822336 [perl #123712] Fix /$a[/ parsing"
	,"DEBPKG:fixes/5.20.3/checking_sub_inwhat - http://bugs.debian.org/822336 [perl #123712] Don't check sub_inwhat"
	,"DEBPKG:fixes/5.20.3/yylex_loop - http://bugs.debian.org/822336 Fix hang with \"@{\""
	,"DEBPKG:fixes/5.20.3/docs/op - http://bugs.debian.org/822336 Fix apidocs for OP_TYPE_IS(_OR_WAS) - arguments separated by |, not ,."
	,"DEBPKG:fixes/5.20.3/docs/encoding - http://bugs.debian.org/822336 perlpodspec: Corrections/adds to detecting =encoding"
	,"DEBPKG:fixes/5.20.3/docs/SvPV_set - http://bugs.debian.org/822336 improve SvPV_set's docs, it really shouldn't be public API"
	,"DEBPKG:fixes/5.20.3/docs/autodie - http://bugs.debian.org/822336 Fix warning message regarding \"use autodie\" and \"use open\"."
	,"DEBPKG:fixes/5.20.3/docs/autodie_2_26 - http://bugs.debian.org/822336 perlunicook: Note that autodie >= 2.26 should be okay with \"use open\"."
	,"DEBPKG:fixes/5.20.3/docs/setenv - http://bugs.debian.org/822336 Fix setenv() replacement documentation in perlclib"
	,"DEBPKG:fixes/5.20.3/docs/clib_caution - http://bugs.debian.org/822336 perlhacktips: Add caution about clib ptr returns to static memory"
	,"DEBPKG:fixes/5.20.3/docs/perlunicook_typos - http://bugs.debian.org/822336 Fix minor code typos in perlunicook"
	,"DEBPKG:fixes/5.20.3/docs/ook_example - http://bugs.debian.org/822336 [perl #122322] Update OOK example in perlguts"
	,"DEBPKG:fixes/5.20.3/docs/study_noop - http://bugs.debian.org/822336 perlfunc: mention that study() is currently a noop"
	,"DEBPKG:fixes/CVE-2016-1238/remove-dot-when-loading - [perl #127834] (perl #127834) remove . from the end of @INC if complex modules are loaded"
	,"DEBPKG:fixes/CVE-2016-1238/remove-dot-in-padwalker - [perl #127834] perl5db.pl: ensure PadWalker is loaded from standard paths"
	,"DEBPKG:fixes/CVE-2016-1238/remove-dot-in-dist - [perl #127834] dist/: remove . from @INC when loading optional modules"
	,"DEBPKG:fixes/CVE-2016-1238/remove-dot-in-cpan - [perl #127834] cpan/: remove . from @INC when loading optional modules"
	,"DEBPKG:fixes/CVE-2016-1238/customized-encode - Update customized.dat for cpan/Encode/Encode.pm"
	,"DEBPKG:debian/CVE-2016-1238/test-suite-without-dot - [perl #127810] Patch unit tests to explicitly insert \".\" into @INC when needed."
	,"DEBPKG:debian/CVE-2016-1238/eumm-without-dot - [perl #127810] Add PERL_USE_UNSAFE_INC support to EU::MM for fortify_inc support."
	,"DEBPKG:debian/CVE-2016-1238/cpan-without-dot - [perl #127810] Set PERL_USE_UNSAFE_INC for cpan usage"
	,"DEBPKG:debian/CVE-2016-1238/mb-without-dot - Make Module::Build set PERL_USE_UNSAFE_INC"
	,"DEBPKG:debian/CVE-2016-1238/sitecustomize-in-etc - Look for sitecustomize.pl in /etc/perl rather than sitelib on Debian systems"
	,"DEBPKG:fixes/xsloader-eval - [rt.cpan.org #115808] http://bugs.debian.org/829578 =?UTF-8?q?Don=E2=80=99t=20let=20XSLoader=20load=20relative=20path?= =?UTF-8?q?s?="
                                                                                                                                                                                                                                                                                                                                                                    usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/patchlevel.h                                              0100644 0000000 0000000 00000012364 12744441327 020242  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    patchlevel.h
 *
 *    Copyright (C) 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
 *    2003, 2004, 2005, 2006, 2007, 2008, 2009, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifndef __PATCHLEVEL_H_INCLUDED__

/* do not adjust the whitespace! Configure expects the numbers to be
 * exactly on the third column */

#define PERL_REVISION	5		/* age */
#define PERL_VERSION	20		/* epoch */
#define PERL_SUBVERSION	2		/* generation */

/* The following numbers describe the earliest compatible version of
   Perl ("compatibility" here being defined as sufficient binary/API
   compatibility to run XS code built with the older version).
   Normally this should not change across maintenance releases.

   Note that this only refers to an out-of-the-box build.  Many non-default
   options such as usemultiplicity tend to break binary compatibility
   more often.

   This is used by Configure et al to figure out
   PERL_INC_VERSION_LIST, which lists version libraries
   to include in @INC.  See INSTALL for how this works.

   Porting/bump-perl-version will automatically set these to the version of perl
   to be released for blead releases, and to 5.X.0 for maint releases. Manually
   changing them should not be necessary.
*/
#define PERL_API_REVISION	5
#define PERL_API_VERSION	20
#define PERL_API_SUBVERSION	0
/*
   XXX Note:  The selection of non-default Configure options, such
   as -Duselonglong may invalidate these settings.  Currently, Configure
   does not adequately test for this.   A.D.  Jan 13, 2000
*/

#define __PATCHLEVEL_H_INCLUDED__
#endif

/*
	local_patches -- list of locally applied less-than-subversion patches.
	If you're distributing such a patch, please give it a name and a
	one-line description, placed just before the last NULL in the array
	below.  If your patch fixes a bug in the perlbug database, please
	mention the bugid.  If your patch *IS* dependent on a prior patch,
	please place your applied patch line after its dependencies. This
	will help tracking of patch dependencies.

	Please either use 'diff --unified=0' if your diff supports
	that or edit the hunk of the diff output which adds your patch
	to this list, to remove context lines which would give patch
	problems. For instance, if the original context diff is

	   *** patchlevel.h.orig	<date here>
	   --- patchlevel.h	<date here>
	   *** 38,43 ***
	   --- 38,44 ---
	     	,"FOO1235 - some patch"
	     	,"BAR3141 - another patch"
	     	,"BAZ2718 - and another patch"
	   + 	,"MINE001 - my new patch"
	     	,NULL
	     };

	please change it to
	   *** patchlevel.h.orig	<date here>
	   --- patchlevel.h	<date here>
	   *** 41,43 ***
	   --- 41,44 ---
	   + 	,"MINE001 - my new patch"
	     	,NULL
	     };

	(Note changes to line numbers as well as removal of context lines.)
	This will prevent patch from choking if someone has previously
	applied different patches than you.

        History has shown that nobody distributes patches that also
        modify patchlevel.h. Do it yourself. The following perl
        program can be used to add a comment to patchlevel.h:

#!perl
die "Usage: perl -x patchlevel.h comment ..." unless @ARGV;
open PLIN, "patchlevel.h" or die "Couldn't open patchlevel.h : $!";
open PLOUT, ">patchlevel.new" or die "Couldn't write on patchlevel.new : $!";
my $seen=0;
while (<PLIN>) {
    if (/\t,NULL/ and $seen) {
       while (my $c = shift @ARGV){
	    $c =~ s|\\|\\\\|g;
	    $c =~ s|"|\\"|g;
            print PLOUT qq{\t,"$c"\n};
       }
    }
    $seen++ if /local_patches\[\]/;
    print PLOUT;
}
close PLOUT or die "Couldn't close filehandle writing to patchlevel.new : $!";
close PLIN or die "Couldn't close filehandle reading from patchlevel.h : $!";
close DATA; # needed to allow unlink to work win32.
unlink "patchlevel.bak" or warn "Couldn't unlink patchlevel.bak : $!"
  if -e "patchlevel.bak";
rename "patchlevel.h", "patchlevel.bak" or
  die "Couldn't rename patchlevel.h to patchlevel.bak : $!";
rename "patchlevel.new", "patchlevel.h" or
  die "Couldn't rename patchlevel.new to patchlevel.h : $!";
__END__

Please keep empty lines below so that context diffs of this file do
not ever collect the lines belonging to local_patches() into the same
hunk.

 */

#if !defined(PERL_PATCHLEVEL_H_IMPLICIT) && !defined(LOCAL_PATCH_COUNT)
#  if defined(PERL_IS_MINIPERL)
#    define PERL_PATCHNUM "UNKNOWN-miniperl"
#    define PERL_GIT_UNPUSHED_COMMITS /*leave-this-comment*/
#  elif defined(PERL_MICRO)
#    define PERL_PATCHNUM "UNKNOWN-microperl"
#    define PERL_GIT_UNPUSHED_COMMITS /*leave-this-comment*/
#  else
#include "git_version.h"
#  endif
static const char * const local_patches[] = {
	NULL
#ifdef PERL_GIT_UNCOMMITTED_CHANGES
	,"uncommitted-changes"
#endif
	PERL_GIT_UNPUSHED_COMMITS    	/* do not remove this line */
#ifdef DEBIAN
#include "patchlevel-debian.h"
#endif
	,NULL
};



/* Initial space prevents this variable from being inserted in config.sh  */
#  define	LOCAL_PATCH_COUNT	\
	((int)(C_ARRAY_LENGTH(local_patches)-2))

/* the old terms of reference, add them only when explicitly included */
#define PATCHLEVEL		PERL_VERSION
#undef  SUBVERSION		/* OS/390 has a SUBVERSION in a system header */
#define SUBVERSION		PERL_SUBVERSION
#endif
                                                                                                                                                                                                                                                                            usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/perl.h                                                    0100644 0000000 0000000 00000542316 12744441327 017062  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    perl.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifndef H_PERL
#define H_PERL 1

#ifdef PERL_FOR_X2P
/*
 * This file is being used for x2p stuff.
 * Above symbol is defined via -D in 'x2p/Makefile.SH'
 * Decouple x2p stuff from some of perls more extreme eccentricities.
 */
#undef MULTIPLICITY
#undef USE_STDIO
#define USE_STDIO
#endif /* PERL_FOR_X2P */

#ifdef PERL_MICRO
#   include "uconfig.h"
#else
#   include "config.h"
#endif

/* See L<perlguts/"The Perl API"> for detailed notes on
 * PERL_IMPLICIT_CONTEXT and PERL_IMPLICIT_SYS */

/* Note that from here --> to <-- the same logic is
 * repeated in makedef.pl, so be certain to update
 * both places when editing. */

#ifdef USE_ITHREADS
#  if !defined(MULTIPLICITY)
#    define MULTIPLICITY
#  endif
#endif

#ifdef PERL_GLOBAL_STRUCT_PRIVATE
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_GLOBAL_STRUCT
#  endif
#endif

#ifdef PERL_GLOBAL_STRUCT
#  ifndef MULTIPLICITY
#    define MULTIPLICITY
#  endif
#endif

#ifdef MULTIPLICITY
#  ifndef PERL_IMPLICIT_CONTEXT
#    define PERL_IMPLICIT_CONTEXT
#  endif
#endif

/* undef WIN32 when building on Cygwin (for libwin32) - gph */
#ifdef __CYGWIN__
#   undef WIN32
#   undef _WIN32
#endif

#if defined(__SYMBIAN32__) || (defined(__VC32__) && defined(WINS))
#   ifndef SYMBIAN
#       define SYMBIAN
#   endif
#endif

#ifdef __SYMBIAN32__
#  include "symbian/symbian_proto.h"
#endif

/* Any stack-challenged places.  The limit varies (and often
 * is configurable), but using more than a kilobyte of stack
 * is usually dubious in these systems. */
#if defined(__SYMBIAN32__)
/* Symbian: need to work around the SDK features. *
 * On WINS: MS VC5 generates calls to _chkstk,         *
 * if a "large" stack frame is allocated.              *
 * gcc on MARM does not generate calls like these.     */
#   define USE_HEAP_INSTEAD_OF_STACK
#endif

/* Use the reentrant APIs like localtime_r and getpwent_r */
/* Win32 has naturally threadsafe libraries, no need to use any _r variants. */
#if defined(USE_ITHREADS) && !defined(USE_REENTRANT_API) && !defined(NETWARE) && !defined(WIN32) && !defined(PERL_DARWIN)
#   define USE_REENTRANT_API
#endif

/* <--- here ends the logic shared by perl.h and makedef.pl */

/* Microsoft Visual C++ 6.0 needs special treatment in numerous places */
#if defined(WIN32) && defined(_MSC_VER) && _MSC_VER >= 1200 && _MSC_VER < 1300
#  define USING_MSVC6
#endif

#undef START_EXTERN_C
#undef END_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C
#  define END_EXTERN_C
#  define EXTERN_C extern
#endif

/* Fallback definitions in case we don't have definitions from config.h.
   This should only matter for systems that don't use Configure and
   haven't been modified to define PERL_STATIC_INLINE yet.
*/
#if !defined(PERL_STATIC_INLINE)
#  ifdef HAS_STATIC_INLINE
#    define PERL_STATIC_INLINE static inline
#  else
#    define PERL_STATIC_INLINE static
#  endif
#endif

#ifdef PERL_GLOBAL_STRUCT
#  ifndef PERL_GET_VARS
#    ifdef PERL_GLOBAL_STRUCT_PRIVATE
       EXTERN_C struct perl_vars* Perl_GetVarsPrivate();
#      define PERL_GET_VARS() Perl_GetVarsPrivate() /* see miniperlmain.c */
#      ifndef PERLIO_FUNCS_CONST
#        define PERLIO_FUNCS_CONST /* Can't have these lying around. */
#      endif
#    else
#      define PERL_GET_VARS() PL_VarsPtr
#    endif
#  endif
#endif

#define pVAR    struct perl_vars* my_vars PERL_UNUSED_DECL

#ifdef PERL_GLOBAL_STRUCT
#  define dVAR		pVAR    = (struct perl_vars*)PERL_GET_VARS()
#else
#  define dVAR		dNOOP
#endif

#ifdef PERL_IMPLICIT_CONTEXT
#  ifndef MULTIPLICITY
#    define MULTIPLICITY
#  endif
#  define tTHX	PerlInterpreter*
#  define pTHX  tTHX my_perl PERL_UNUSED_DECL
#  define aTHX	my_perl
#  define aTHXa(a) aTHX = (tTHX)a
#  ifdef PERL_GLOBAL_STRUCT
#    define dTHXa(a)	dVAR; pTHX = (tTHX)a
#  else
#    define dTHXa(a)	pTHX = (tTHX)a
#  endif
#  ifdef PERL_GLOBAL_STRUCT
#    define dTHX		dVAR; pTHX = PERL_GET_THX
#  else
#    define dTHX		pTHX = PERL_GET_THX
#  endif
#  define pTHX_		pTHX,
#  define aTHX_		aTHX,
#  define pTHX_1	2
#  define pTHX_2	3
#  define pTHX_3	4
#  define pTHX_4	5
#  define pTHX_5	6
#  define pTHX_6	7
#  define pTHX_7	8
#  define pTHX_8	9
#  define pTHX_9	10
#  define pTHX_12	13
/* PERL_TRACK_MEMPOOL temporarily disabled for DEBUGGING */
/* see https://bugs.debian.org/810326 */
#  if 0 && defined(DEBUGGING) && !defined(PERL_TRACK_MEMPOOL)
#    define PERL_TRACK_MEMPOOL
#  endif
#else
#  undef PERL_TRACK_MEMPOOL
#endif

#define STATIC static

#ifndef PERL_CORE
/* Do not use these macros. They were part of PERL_OBJECT, which was an
 * implementation of multiplicity using C++ objects. They have been left
 * here solely for the sake of XS code which has incorrectly
 * cargo-culted them.
 */
#define CPERLscope(x) x
#define CPERLarg void
#define CPERLarg_
#define _CPERLarg
#define PERL_OBJECT_THIS
#define _PERL_OBJECT_THIS
#define PERL_OBJECT_THIS_
#define CALL_FPTR(fptr) (*fptr)
#define MEMBER_TO_FPTR(name) name
#endif /* !PERL_CORE */

#define CALLRUNOPS  PL_runops

#define CALLREGCOMP(sv, flags) Perl_pregcomp(aTHX_ (sv),(flags))

#define CALLREGCOMP_ENG(prog, sv, flags) (prog)->comp(aTHX_ sv, flags)
#define CALLREGEXEC(prog,stringarg,strend,strbeg,minend,sv,data,flags) \
    RX_ENGINE(prog)->exec(aTHX_ (prog),(stringarg),(strend), \
        (strbeg),(minend),(sv),(data),(flags))
#define CALLREG_INTUIT_START(prog,sv,strbeg,strpos,strend,flags,data) \
    RX_ENGINE(prog)->intuit(aTHX_ (prog), (sv), (strbeg), (strpos), \
        (strend),(flags),(data))
#define CALLREG_INTUIT_STRING(prog) \
    RX_ENGINE(prog)->checkstr(aTHX_ (prog))

#define CALLREGFREE(prog) \
    Perl_pregfree(aTHX_ (prog))

#define CALLREGFREE_PVT(prog) \
    if(prog) RX_ENGINE(prog)->free(aTHX_ (prog))

#define CALLREG_NUMBUF_FETCH(rx,paren,usesv)                                \
    RX_ENGINE(rx)->numbered_buff_FETCH(aTHX_ (rx),(paren),(usesv))

#define CALLREG_NUMBUF_STORE(rx,paren,value) \
    RX_ENGINE(rx)->numbered_buff_STORE(aTHX_ (rx),(paren),(value))

#define CALLREG_NUMBUF_LENGTH(rx,sv,paren)                              \
    RX_ENGINE(rx)->numbered_buff_LENGTH(aTHX_ (rx),(sv),(paren))

#define CALLREG_NAMED_BUFF_FETCH(rx, key, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), (key), NULL, ((flags) | RXapif_FETCH))

#define CALLREG_NAMED_BUFF_STORE(rx, key, value, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), (key), (value), ((flags) | RXapif_STORE))

#define CALLREG_NAMED_BUFF_DELETE(rx, key, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx),(key), NULL, ((flags) | RXapif_DELETE))

#define CALLREG_NAMED_BUFF_CLEAR(rx, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_CLEAR))

#define CALLREG_NAMED_BUFF_EXISTS(rx, key, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), (key), NULL, ((flags) | RXapif_EXISTS))

#define CALLREG_NAMED_BUFF_FIRSTKEY(rx, flags) \
    RX_ENGINE(rx)->named_buff_iter(aTHX_ (rx), NULL, ((flags) | RXapif_FIRSTKEY))

#define CALLREG_NAMED_BUFF_NEXTKEY(rx, lastkey, flags) \
    RX_ENGINE(rx)->named_buff_iter(aTHX_ (rx), (lastkey), ((flags) | RXapif_NEXTKEY))

#define CALLREG_NAMED_BUFF_SCALAR(rx, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_SCALAR))

#define CALLREG_NAMED_BUFF_COUNT(rx) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, RXapif_REGNAMES_COUNT)

#define CALLREG_NAMED_BUFF_ALL(rx, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, flags)

#define CALLREG_PACKAGE(rx) \
    RX_ENGINE(rx)->qr_package(aTHX_ (rx))

#if defined(USE_ITHREADS)
#define CALLREGDUPE(prog,param) \
    Perl_re_dup(aTHX_ (prog),(param))

#define CALLREGDUPE_PVT(prog,param) \
    (prog ? RX_ENGINE(prog)->dupe(aTHX_ (prog),(param)) \
          : (REGEXP *)NULL)
#endif





/*
 * Because of backward compatibility reasons the PERL_UNUSED_DECL
 * cannot be changed from postfix to PERL_UNUSED_DECL(x).  Sigh.
 *
 * Note that there are C compilers such as MetroWerks CodeWarrior
 * which do not have an "inlined" way (like the gcc __attribute__) of
 * marking unused variables (they need e.g. a #pragma) and therefore
 * cpp macros like PERL_UNUSED_DECL cannot work for this purpose, even
 * if it were PERL_UNUSED_DECL(x), which it cannot be (see above).
 *
 */

#if defined(__SYMBIAN32__) && defined(__GNUC__)
#  ifdef __cplusplus
#    define PERL_UNUSED_DECL
#  else
#    define PERL_UNUSED_DECL __attribute__((unused))
#  endif
#endif

#ifndef PERL_UNUSED_DECL
#  if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#    define PERL_UNUSED_DECL __attribute__unused__
#  else
#    define PERL_UNUSED_DECL
#  endif
#endif

/* gcc -Wall:
 * for silencing unused variables that are actually used most of the time,
 * but we cannot quite get rid of, such as "ax" in PPCODE+noargs xsubs
 */
#ifndef PERL_UNUSED_ARG
#  if defined(lint) && defined(S_SPLINT_S) /* www.splint.org */
#    include <note.h>
#    define PERL_UNUSED_ARG(x) NOTE(ARGUNUSED(x))
#  else
#    define PERL_UNUSED_ARG(x) ((void)x)
#  endif
#endif
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(x) ((void)x)
#endif

#ifdef USE_ITHREADS
#  define PERL_UNUSED_CONTEXT PERL_UNUSED_ARG(my_perl)
#else
#  define PERL_UNUSED_CONTEXT
#endif

/* gcc (-ansi) -pedantic doesn't allow gcc statement expressions,
 * g++ allows them but seems to have problems with them
 * (insane errors ensue).
 * g++ does not give insane errors now (RMB 2008-01-30, gcc 4.2.2).
 */
#if defined(PERL_GCC_PEDANTIC) || \
    (defined(__GNUC__) && defined(__cplusplus) && \
	((__GNUC__ < 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ < 2))))
#  ifndef PERL_GCC_BRACE_GROUPS_FORBIDDEN
#    define PERL_GCC_BRACE_GROUPS_FORBIDDEN
#  endif
#endif

/* Use PERL_UNUSED_RESULT() to suppress the warnings about unused results
 * of function calls, e.g. PERL_UNUSED_RESULT(foo(a, b)).
 *
 * The main reason for this is that the combination of gcc -Wunused-result
 * (part of -Wall) and the __attribute__((warn_unused_result)) cannot
 * be silenced with casting to void.  This causes trouble when the system
 * header files use the attribute.
 *
 * Use PERL_UNUSED_RESULT sparingly, though, since usually the warning
 * is there for a good reason: you might lose success/failure information,
 * or leak resources, or changes in resources.
 *
 * But sometimes you just want to ignore the return value, e.g. on
 * codepaths soon ending up in abort, or in "best effort" attempts,
 * or in situations where there is no good way to handle failures.
 *
 * Sometimes PERL_UNUSED_RESULT might not be the most natural way:
 * another possibility is that you can capture the return value
 * and use PERL_UNUSED_VAR on that.
 *
 * The __typeof__() is used instead of typeof() since typeof() is not
 * available under strict C89, and because of compilers masquerading
 * as gcc (clang and icc), we want exactly the gcc extension
 * __typeof__ and nothing else.
 */
#ifndef PERL_UNUSED_RESULT
#  if defined(__GNUC__) && defined(HASATTRIBUTE_WARN_UNUSED_RESULT)
#    define PERL_UNUSED_RESULT(v) STMT_START { __typeof__(v) z = (v); (void)sizeof(z); } STMT_END
#  else
#    define PERL_UNUSED_RESULT(v) ((void)(v))
#  endif
#endif

/* on gcc (and clang), specify that a warning should be temporarily
 * ignored; e.g.
 *
 *    GCC_DIAG_IGNORE(-Wmultichar);
 *    char b = 'ab';
 *    GCC_DIAG_RESTORE;
 *
 * based on http://dbp-consulting.com/tutorials/SuppressingGCCWarnings.html
 *
 * Note that "pragma GCC diagnostic push/pop" was added in GCC 4.6, Mar 2011;
 * clang only pretends to be GCC 4.2, but still supports push/pop.
 */

#if defined(__clang) || \
       (defined( __GNUC__) && ((__GNUC__ * 100) + __GNUC_MINOR__) >= 406)
#  define GCC_DIAG_DO_PRAGMA_(x) _Pragma (#x)

#  define GCC_DIAG_IGNORE(x) _Pragma("GCC diagnostic push") \
                             GCC_DIAG_DO_PRAGMA_(GCC diagnostic ignored #x)
#  define GCC_DIAG_RESTORE   _Pragma("GCC diagnostic pop")
#else
#  define GCC_DIAG_IGNORE(w)
#  define GCC_DIAG_RESTORE
#endif


#define NOOP /*EMPTY*/(void)0
/* cea2e8a9dd23747f accidentally lost the comment originally from the first
   check in of thread.h, explaining why we need dNOOP at all:  */
/* Rats: if dTHR is just blank then the subsequent ";" throws an error */
/* Declaring a *function*, instead of a variable, ensures that we don't rely
   on being able to suppress "unused" warnings.  */
#ifdef __cplusplus
#define dNOOP (void)0
#else
#define dNOOP extern int Perl___notused(void)
#endif

#ifndef pTHX
/* Don't bother defining tTHX ; using it outside
 * code guarded by PERL_IMPLICIT_CONTEXT is an error.
 */
#  define pTHX		void
#  define pTHX_
#  define aTHX
#  define aTHX_
#  define aTHXa(a)      NOOP
#  define dTHXa(a)	dNOOP
#  define dTHX		dNOOP
#  define pTHX_1	1	
#  define pTHX_2	2
#  define pTHX_3	3
#  define pTHX_4	4
#  define pTHX_5	5
#  define pTHX_6	6
#  define pTHX_7	7
#  define pTHX_8	8
#  define pTHX_9	9
#  define pTHX_12	12
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif

/* these are only defined for compatibility; should not be used internally */
#if !defined(pTHXo) && !defined(PERL_CORE)
#  define pTHXo		pTHX
#  define pTHXo_	pTHX_
#  define aTHXo		aTHX
#  define aTHXo_	aTHX_
#  define dTHXo		dTHX
#  define dTHXoa(x)	dTHXa(x)
#endif

#ifndef pTHXx
#  define pTHXx		PerlInterpreter *my_perl
#  define pTHXx_	pTHXx,
#  define aTHXx		my_perl
#  define aTHXx_	aTHXx,
#  define dTHXx		dTHX
#endif

/* Under PERL_IMPLICIT_SYS (used in Windows for fork emulation)
 * PerlIO_foo() expands to PL_StdIO->pFOO(PL_StdIO, ...).
 * dTHXs is therefore needed for all functions using PerlIO_foo(). */
#ifdef PERL_IMPLICIT_SYS
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
#    define dTHXs		dVAR; dTHX
#  else
#    define dTHXs		dTHX
#  endif
#else
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
#    define dTHXs		dVAR
#  else
#    define dTHXs		dNOOP
#  endif
#endif

/* Some platforms require marking function declarations
 * for them to be exportable.  Used in perlio.h, proto.h
 * is handled either by the makedef.pl or by defining the
 * PERL_CALLCONV to be something special.  See also the
 * definition of XS() in XSUB.h. */
#ifndef PERL_EXPORT_C
#  ifdef __cplusplus
#    define PERL_EXPORT_C extern "C"
#  else
#    define PERL_EXPORT_C extern
#  endif
#endif
#ifndef PERL_XS_EXPORT_C
#  ifdef __cplusplus
#    define PERL_XS_EXPORT_C extern "C"
#  else
#    define PERL_XS_EXPORT_C
#  endif
#endif

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN) && !defined(__cplusplus)
#  ifndef PERL_USE_GCC_BRACE_GROUPS
#    define PERL_USE_GCC_BRACE_GROUPS
#  endif
#endif

/*
 * STMT_START { statements; } STMT_END;
 * can be used as a single statement, as in
 * if (x) STMT_START { ... } STMT_END; else ...
 *
 * Trying to select a version that gives no warnings...
 */
#if !(defined(STMT_START) && defined(STMT_END))
# ifdef PERL_USE_GCC_BRACE_GROUPS
#   define STMT_START	(void)(	/* gcc supports "({ STATEMENTS; })" */
#   define STMT_END	)
# else
#   define STMT_START	do
#   define STMT_END	while (0)
# endif
#endif

#ifndef BYTEORDER  /* Should never happen -- byteorder is in config.h */
#   define BYTEORDER 0x1234
#endif

/* Overall memory policy? */
#ifndef CONSERVATIVE
#   define LIBERAL 1
#endif

#if 'A' == 65 && 'I' == 73 && 'J' == 74 && 'Z' == 90
#define ASCIIish
#else
#undef  ASCIIish
#endif

/*
 * The following contortions are brought to you on behalf of all the
 * standards, semi-standards, de facto standards, not-so-de-facto standards
 * of the world, as well as all the other botches anyone ever thought of.
 * The basic theory is that if we work hard enough here, the rest of the
 * code can be a lot prettier.  Well, so much for theory.  Sorry, Henry...
 */

/* define this once if either system, instead of cluttering up the src */
#if defined(MSDOS) || defined(WIN32) || defined(NETWARE)
#define DOSISH 1
#endif

#if defined(__STDC__) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus) || defined(NETWARE) || defined(__SYMBIAN32__)
# define STANDARD_C 1
#endif

#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(__EMX__) || defined(__QNX__) || defined(NETWARE) || defined(PERL_MICRO)
# define DONT_DECLARE_STD 1
#endif

#if defined(HASVOLATILE) || defined(STANDARD_C)
#	define VOL volatile
#else
#   define VOL
#endif

/* By compiling a perl with -DNO_TAINT_SUPPORT or -DSILENT_NO_TAINT_SUPPORT,
 * you get a perl without taint support, but doubtlessly with a lesser
 * degree of support. Do not do so unless you know exactly what it means
 * technically, have a good reason to do so, and know exactly how the
 * perl will be used. perls with -DSILENT_NO_TAINT_SUPPORT are considered
 * a potential security risk due to flat out ignoring the security-relevant
 * taint flags. This being said, a perl without taint support compiled in
 * has marginal run-time performance benefits.
 * SILENT_NO_TAINT_SUPPORT implies NO_TAINT_SUPPORT.
 * SILENT_NO_TAINT_SUPPORT is the same as NO_TAINT_SUPPORT except it
 * silently ignores -t/-T instead of throwing an exception.
 *
 * DANGER! Using NO_TAINT_SUPPORT or SILENT_NO_TAINT_SUPPORT
 *         voids your nonexistent warranty!
 */
#if defined(SILENT_NO_TAINT_SUPPORT) && !defined(NO_TAINT_SUPPORT)
#  define NO_TAINT_SUPPORT 1
#endif

/* NO_TAINT_SUPPORT can be set to transform virtually all taint-related
 * operations into no-ops for a very modest speed-up. Enable only if you
 * know what you're doing: tests and CPAN modules' tests are bound to fail.
 */
#ifdef NO_TAINT_SUPPORT
#   define TAINT		NOOP
#   define TAINT_NOT		NOOP
#   define TAINT_IF(c)		NOOP
#   define TAINT_ENV()		NOOP
#   define TAINT_PROPER(s)	NOOP
#   define TAINT_set(s)		NOOP
#   define TAINT_get		0
#   define TAINTING_get		0
#   define TAINTING_set(s)	NOOP
#   define TAINT_WARN_get       0
#   define TAINT_WARN_set(s)    NOOP
#else
#   define TAINT		(PL_tainted = TRUE)
#   define TAINT_NOT	(PL_tainted = FALSE)
#   define TAINT_IF(c)	if (UNLIKELY(c)) { PL_tainted = TRUE; }
#   define TAINT_ENV()	if (UNLIKELY(PL_tainting)) { taint_env(); }
#   define TAINT_PROPER(s)	if (UNLIKELY(PL_tainting)) { taint_proper(NULL, s); }
#   define TAINT_set(s)		(PL_tainted = (s))
#   define TAINT_get		(PL_tainted)
#   define TAINTING_get		(PL_tainting)
#   define TAINTING_set(s)	(PL_tainting = (s))
#   define TAINT_WARN_get       (PL_taint_warn)
#   define TAINT_WARN_set(s)    (PL_taint_warn = (s))
#endif

/* flags used internally only within pp_subst and pp_substcont */
#ifdef PERL_CORE
#  define SUBST_TAINT_STR      1	/* string tainted */
#  define SUBST_TAINT_PAT      2	/* pattern tainted */
#  define SUBST_TAINT_REPL     4	/* replacement tainted */
#  define SUBST_TAINT_RETAINT  8	/* use re'taint' in scope */
#  define SUBST_TAINT_BOOLRET 16	/* return is boolean (don't taint) */
#endif

/* XXX All process group stuff is handled in pp_sys.c.  Should these
   defines move there?  If so, I could simplify this a lot. --AD  9/96.
*/
/* Process group stuff changed from traditional BSD to POSIX.
   perlfunc.pod documents the traditional BSD-style syntax, so we'll
   try to preserve that, if possible.
*/
#ifdef HAS_SETPGID
#  define BSD_SETPGRP(pid, pgrp)	setpgid((pid), (pgrp))
#else
#  if defined(HAS_SETPGRP) && defined(USE_BSD_SETPGRP)
#    define BSD_SETPGRP(pid, pgrp)	setpgrp((pid), (pgrp))
#  else
#    ifdef HAS_SETPGRP2  /* DG/UX */
#      define BSD_SETPGRP(pid, pgrp)	setpgrp2((pid), (pgrp))
#    endif
#  endif
#endif
#if defined(BSD_SETPGRP) && !defined(HAS_SETPGRP)
#  define HAS_SETPGRP  /* Well, effectively it does . . . */
#endif

/* getpgid isn't POSIX, but at least Solaris and Linux have it, and it makes
    our life easier :-) so we'll try it.
*/
#ifdef HAS_GETPGID
#  define BSD_GETPGRP(pid)		getpgid((pid))
#else
#  if defined(HAS_GETPGRP) && defined(USE_BSD_GETPGRP)
#    define BSD_GETPGRP(pid)		getpgrp((pid))
#  else
#    ifdef HAS_GETPGRP2  /* DG/UX */
#      define BSD_GETPGRP(pid)		getpgrp2((pid))
#    endif
#  endif
#endif
#if defined(BSD_GETPGRP) && !defined(HAS_GETPGRP)
#  define HAS_GETPGRP  /* Well, effectively it does . . . */
#endif

/* These are not exact synonyms, since setpgrp() and getpgrp() may
   have different behaviors, but perl.h used to define USE_BSDPGRP
   (prior to 5.003_05) so some extension might depend on it.
*/
#if defined(USE_BSD_SETPGRP) || defined(USE_BSD_GETPGRP)
#  ifndef USE_BSDPGRP
#    define USE_BSDPGRP
#  endif
#endif

/* HP-UX 10.X CMA (Common Multithreaded Architecture) insists that
   pthread.h must be included before all other header files.
*/
#if defined(USE_ITHREADS) && defined(PTHREAD_H_FIRST) && defined(I_PTHREAD)
#  include <pthread.h>
#endif

#include <sys/types.h>

#ifdef __cplusplus
#  ifndef I_STDARG
#    define I_STDARG 1
#  endif
#endif

/* EVC 4 SDK headers includes a bad definition of MB_CUR_MAX in stdlib.h
  which is included from stdarg.h. Bad definition not present in SD 2008
  SDK headers. wince.h is not yet included, so we cant fix this from there
  since by then MB_CUR_MAX will be defined from stdlib.h.
  cewchar.h includes a correct definition of MB_CUR_MAX and it is copied here
  since cewchar.h can't be included this early */
#if defined(UNDER_CE) && (_MSC_VER < 1300)
#  define MB_CUR_MAX 1
#endif
#ifdef I_STDARG
#  include <stdarg.h>
#else
#  ifdef I_VARARGS
#    include <varargs.h>
#  endif
#endif

#ifdef USE_NEXT_CTYPE

#if NX_CURRENT_COMPILER_RELEASE >= 500
#  include <bsd/ctypes.h>
#else
#  if NX_CURRENT_COMPILER_RELEASE >= 400
#    include <objc/NXCType.h>
#  else /*  NX_CURRENT_COMPILER_RELEASE < 400 */
#    include <appkit/NXCType.h>
#  endif /*  NX_CURRENT_COMPILER_RELEASE >= 400 */
#endif /*  NX_CURRENT_COMPILER_RELEASE >= 500 */

#else /* !USE_NEXT_CTYPE */
#include <ctype.h>
#endif /* USE_NEXT_CTYPE */

#ifdef METHOD 	/* Defined by OSF/1 v3.0 by ctype.h */
#undef METHOD
#endif

#ifdef PERL_MICRO
#   define NO_LOCALE
#endif

#ifdef I_LOCALE
#   include <locale.h>
#endif

#if !defined(NO_LOCALE) && defined(HAS_SETLOCALE)
#   define USE_LOCALE
#   define HAS_SKIP_LOCALE_INIT /* Solely for XS code to test for this
                                   capability */
#   if !defined(NO_LOCALE_COLLATE) && defined(LC_COLLATE) \
       && defined(HAS_STRXFRM)
#	define USE_LOCALE_COLLATE
#   endif
#   if !defined(NO_LOCALE_CTYPE) && defined(LC_CTYPE)
#	define USE_LOCALE_CTYPE
#   endif
#   if !defined(NO_LOCALE_NUMERIC) && defined(LC_NUMERIC)
#	define USE_LOCALE_NUMERIC
#   endif
#   if !defined(NO_LOCALE_MESSAGES) && defined(LC_MESSAGES)
#	define USE_LOCALE_MESSAGES
#   endif
#   if !defined(NO_LOCALE_MONETARY) && defined(LC_MONETARY)
#	define USE_LOCALE_MONETARY
#   endif
#   ifndef WIN32    /* No wrapper except on Windows */
#       define my_setlocale(a,b) setlocale(a,b)
#   endif
#endif /* !NO_LOCALE && HAS_SETLOCALE */

#include <setjmp.h>

#ifdef I_SYS_PARAM
#   ifdef PARAM_NEEDS_TYPES
#	include <sys/types.h>
#   endif
#   include <sys/param.h>
#endif

/* On BSD-derived systems, <sys/param.h> defines BSD to a year-month
   value something like 199306.  This may be useful if no more-specific
   feature test is available.
*/
#if defined(BSD)
#   ifndef BSDish
#       define BSDish
#   endif
#endif

/* Use all the "standard" definitions? */
#if defined(STANDARD_C) && defined(I_STDLIB)
#   include <stdlib.h>
#endif

/* If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
#   include <unistd.h>
#endif

/* for WCOREDUMP */
#ifdef I_SYS_WAIT
#   include <sys/wait.h>
#endif

#ifdef __SYMBIAN32__
#   undef _SC_ARG_MAX /* Symbian has _SC_ARG_MAX but no sysconf() */
#endif

#if defined(HAS_SYSCALL) && !defined(HAS_SYSCALL_PROTO)
EXTERN_C int syscall(int, ...);
#endif

#if defined(HAS_USLEEP) && !defined(HAS_USLEEP_PROTO)
EXTERN_C int usleep(unsigned int);
#endif

#ifdef PERL_CORE

/* macros for correct constant construction */
# if INTSIZE >= 2
#  define U16_CONST(x) ((U16)x##U)
# else
#  define U16_CONST(x) ((U16)x##UL)
# endif

# if INTSIZE >= 4
#  define U32_CONST(x) ((U32)x##U)
# else
#  define U32_CONST(x) ((U32)x##UL)
# endif

# ifdef HAS_QUAD
#  if INTSIZE >= 8
#   define U64_CONST(x) ((U64)x##U)
#  elif LONGSIZE >= 8
#   define U64_CONST(x) ((U64)x##UL)
#  elif QUADKIND == QUAD_IS_LONG_LONG
#   define U64_CONST(x) ((U64)x##ULL)
#  elif QUADKIND == QUAD_IS___INT64
#   define U64_CONST(x) ((U64)x##UI64)
#  else /* best guess we can make */
#   define U64_CONST(x) ((U64)x##UL)
#  endif
# endif

/* byte-swapping functions for big-/little-endian conversion */
# define _swab_16_(x) ((U16)( \
         (((U16)(x) & U16_CONST(0x00ff)) << 8) | \
         (((U16)(x) & U16_CONST(0xff00)) >> 8) ))

# define _swab_32_(x) ((U32)( \
         (((U32)(x) & U32_CONST(0x000000ff)) << 24) | \
         (((U32)(x) & U32_CONST(0x0000ff00)) <<  8) | \
         (((U32)(x) & U32_CONST(0x00ff0000)) >>  8) | \
         (((U32)(x) & U32_CONST(0xff000000)) >> 24) ))

# ifdef HAS_QUAD
#  define _swab_64_(x) ((U64)( \
          (((U64)(x) & U64_CONST(0x00000000000000ff)) << 56) | \
          (((U64)(x) & U64_CONST(0x000000000000ff00)) << 40) | \
          (((U64)(x) & U64_CONST(0x0000000000ff0000)) << 24) | \
          (((U64)(x) & U64_CONST(0x00000000ff000000)) <<  8) | \
          (((U64)(x) & U64_CONST(0x000000ff00000000)) >>  8) | \
          (((U64)(x) & U64_CONST(0x0000ff0000000000)) >> 24) | \
          (((U64)(x) & U64_CONST(0x00ff000000000000)) >> 40) | \
          (((U64)(x) & U64_CONST(0xff00000000000000)) >> 56) ))
# endif

/* The old value was hard coded at 1008. (4096-16) seems to be a bit faster,
   at least on FreeBSD.  YMMV, so experiment.  */
#ifndef PERL_ARENA_SIZE
#define PERL_ARENA_SIZE 4080
#endif

/* Maximum level of recursion */
#ifndef PERL_SUB_DEPTH_WARN
#define PERL_SUB_DEPTH_WARN 100
#endif

#endif /* PERL_CORE */

/* We no longer default to creating a new SV for GvSV.
   Do this before embed.  */
#ifndef PERL_CREATE_GVSV
#  ifndef PERL_DONT_CREATE_GVSV
#    define PERL_DONT_CREATE_GVSV
#  endif
#endif

#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
#define PERL_USES_PL_PIDSTATUS
#endif

#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(__SYMBIAN32__)
#define PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
#endif

#define MEM_SIZE Size_t

/* Round all values passed to malloc up, by default to a multiple of
   sizeof(size_t)
*/
#ifndef PERL_STRLEN_ROUNDUP_QUANTUM
#define PERL_STRLEN_ROUNDUP_QUANTUM Size_t_size
#endif

/* sv_grow() will expand strings by at least a certain percentage of
   the previously *used* length to avoid excessive calls to realloc().
   The default is 25% of the current length.
*/
#ifndef PERL_STRLEN_EXPAND_SHIFT
#  define PERL_STRLEN_EXPAND_SHIFT 2
#endif

#if defined(STANDARD_C) && defined(I_STDDEF)
#   include <stddef.h>
#   define STRUCT_OFFSET(s,m)  offsetof(s,m)
#else
#   define STRUCT_OFFSET(s,m)  (Size_t)(&(((s *)0)->m))
#endif

#ifndef __SYMBIAN32__
#  if defined(I_STRING) || defined(__cplusplus)
#     include <string.h>
#  else
#     include <strings.h>
#  endif
#endif

/* This comes after <stdlib.h> so we don't try to change the standard
 * library prototypes; we'll use our own in proto.h instead. */

#ifdef MYMALLOC
#  ifdef PERL_POLLUTE_MALLOC
#   ifndef PERL_EXTMALLOC_DEF
#    define Perl_malloc		malloc
#    define Perl_calloc		calloc
#    define Perl_realloc	realloc
#    define Perl_mfree		free
#   endif
#  else
#    define EMBEDMYMALLOC	/* for compatibility */
#  endif

#  define safemalloc  Perl_malloc
#  define safecalloc  Perl_calloc
#  define saferealloc Perl_realloc
#  define safefree    Perl_mfree
#  define CHECK_MALLOC_TOO_LATE_FOR_(code)	STMT_START {		\
	if (!PL_tainting && MallocCfg_ptr[MallocCfg_cfg_env_read])	\
		code;							\
    } STMT_END
#  define CHECK_MALLOC_TOO_LATE_FOR(ch)				\
	CHECK_MALLOC_TOO_LATE_FOR_(MALLOC_TOO_LATE_FOR(ch))
#  define panic_write2(s)		write(2, s, strlen(s))
#  define CHECK_MALLOC_TAINT(newval)				\
	CHECK_MALLOC_TOO_LATE_FOR_(				\
		if (newval) {					\
		  panic_write2("panic: tainting with $ENV{PERL_MALLOC_OPT}\n");\
		  exit(1); })
#  define MALLOC_CHECK_TAINT(argc,argv,env)	STMT_START {	\
	if (doing_taint(argc,argv,env)) {			\
		MallocCfg_ptr[MallocCfg_skip_cfg_env] = 1;	\
    }} STMT_END;
#else  /* MYMALLOC */
#  define safemalloc  safesysmalloc
#  define safecalloc  safesyscalloc
#  define saferealloc safesysrealloc
#  define safefree    safesysfree
#  define CHECK_MALLOC_TOO_LATE_FOR(ch)		((void)0)
#  define CHECK_MALLOC_TAINT(newval)		((void)0)
#  define MALLOC_CHECK_TAINT(argc,argv,env)
#endif /* MYMALLOC */

/* diag_listed_as: "-T" is on the #! line, it must also be used on the command line */
#define TOO_LATE_FOR_(ch,what)	Perl_croak(aTHX_ "\"-%c\" is on the #! line, it must also be used on the command line%s", (char)(ch), what)
#define TOO_LATE_FOR(ch)	TOO_LATE_FOR_(ch, "")
#define MALLOC_TOO_LATE_FOR(ch)	TOO_LATE_FOR_(ch, " with $ENV{PERL_MALLOC_OPT}")
#define MALLOC_CHECK_TAINT2(argc,argv)	MALLOC_CHECK_TAINT(argc,argv,NULL)

#if !defined(HAS_STRCHR) && defined(HAS_INDEX) && !defined(strchr)
#define strchr index
#define strrchr rindex
#endif

#ifdef I_MEMORY
#  include <memory.h>
#endif

#ifdef HAS_MEMCPY
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memcpy
        extern char * memcpy (char*, char*, int);
#    endif
#  endif
#else
#   ifndef memcpy
#	ifdef HAS_BCOPY
#	    define memcpy(d,s,l) bcopy(s,d,l)
#	else
#	    define memcpy(d,s,l) my_bcopy(s,d,l)
#	endif
#   endif
#endif /* HAS_MEMCPY */

#ifdef HAS_MEMSET
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memset
	extern char *memset (char*, int, int);
#    endif
#  endif
#else
#  undef  memset
#  define memset(d,c,l) my_memset(d,c,l)
#endif /* HAS_MEMSET */

#if !defined(HAS_MEMMOVE) && !defined(memmove)
#   if defined(HAS_BCOPY) && defined(HAS_SAFE_BCOPY)
#	define memmove(d,s,l) bcopy(s,d,l)
#   else
#	if defined(HAS_MEMCPY) && defined(HAS_SAFE_MEMCPY)
#	    define memmove(d,s,l) memcpy(d,s,l)
#	else
#	    define memmove(d,s,l) my_bcopy(s,d,l)
#	endif
#   endif
#endif

#if defined(mips) && defined(ultrix) && !defined(__STDC__)
#   undef HAS_MEMCMP
#endif

#if defined(HAS_MEMCMP) && defined(HAS_SANE_MEMCMP)
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memcmp
	extern int memcmp (char*, char*, int);
#    endif
#  endif
#else
#   ifndef memcmp
#	define memcmp 	my_memcmp
#   endif
#endif /* HAS_MEMCMP && HAS_SANE_MEMCMP */

#ifndef memzero
#   ifdef HAS_MEMSET
#	define memzero(d,l) memset(d,0,l)
#   else
#	ifdef HAS_BZERO
#	    define memzero(d,l) bzero(d,l)
#	else
#	    define memzero(d,l) my_bzero(d,l)
#	endif
#   endif
#endif

#ifndef PERL_MICRO
#ifndef memchr
#   ifndef HAS_MEMCHR
#       define memchr(s,c,n) ninstr((char*)(s), ((char*)(s)) + n, &(c), &(c) + 1)
#   endif
#endif
#endif

#ifndef HAS_BCMP
#   ifndef bcmp
#	define bcmp(s1,s2,l) memcmp(s1,s2,l)
#   endif
#endif /* !HAS_BCMP */

#ifdef I_NETINET_IN
#   include <netinet/in.h>
#endif

#ifdef I_ARPA_INET
#   include <arpa/inet.h>
#endif

#ifdef I_SYS_STAT
#   include <sys/stat.h>
#endif

/* Microsoft VC's sys/stat.h defines all S_Ixxx macros except S_IFIFO.
   This definition should ideally go into win32/win32.h, but S_IFIFO is
   used later here in perl.h before win32/win32.h is being included. */
#if !defined(S_IFIFO) && defined(_S_IFIFO)
#   define S_IFIFO _S_IFIFO
#endif

/* The stat macros for Unisoft System V/88 (and derivatives
   like UTekV) are broken, sometimes giving false positives.  Undefine
   them here and let the code below set them to proper values.

   The ghs macro stands for GreenHills Software C-1.8.5 which
   is the C compiler for sysV88 and the various derivatives.
   This header file bug is corrected in gcc-2.5.8 and later versions.
   --Kaveh Ghazi (ghazi@noc.rutgers.edu) 10/3/94.  */

#if defined(m88k) && defined(ghs)
#   undef S_ISDIR
#   undef S_ISCHR
#   undef S_ISBLK
#   undef S_ISREG
#   undef S_ISFIFO
#   undef S_ISLNK
#endif

#ifdef I_TIME
#   include <time.h>
#endif

#ifdef I_SYS_TIME
#   ifdef I_SYS_TIME_KERNEL
#	define KERNEL
#   endif
#   include <sys/time.h>
#   ifdef I_SYS_TIME_KERNEL
#	undef KERNEL
#   endif
#endif

#if defined(HAS_TIMES) && defined(I_SYS_TIMES)
#    include <sys/times.h>
#endif

#if defined(HAS_STRERROR) && (!defined(HAS_MKDIR) || !defined(HAS_RMDIR))
#   undef HAS_STRERROR
#endif

#include <errno.h>

#if defined(WIN32) && defined(PERL_IMPLICIT_SYS)
#  define WIN32SCK_IS_STDSCK		/* don't pull in custom wsock layer */
#endif

#if defined(HAS_SOCKET) && !defined(WIN32) /* WIN32 handles sockets via win32.h */
# include <sys/socket.h>
# if defined(USE_SOCKS) && defined(I_SOCKS)
#   if !defined(INCLUDE_PROTOTYPES)
#       define INCLUDE_PROTOTYPES /* for <socks.h> */
#       define PERL_SOCKS_NEED_PROTOTYPES
#   endif
#   include <socks.h>
#   ifdef PERL_SOCKS_NEED_PROTOTYPES /* keep cpp space clean */
#       undef INCLUDE_PROTOTYPES
#       undef PERL_SOCKS_NEED_PROTOTYPES
#   endif
# endif
# ifdef I_NETDB
#  ifdef NETWARE
#   include<stdio.h>
#  endif
#  include <netdb.h>
# endif
# ifndef ENOTSOCK
#  ifdef I_NET_ERRNO
#   include <net/errno.h>
#  endif
# endif
#endif

/* sockatmark() is so new (2001) that many places might have it hidden
 * behind some -D_BLAH_BLAH_SOURCE guard.  The __THROW magic is required
 * e.g. in Gentoo, see http://bugs.gentoo.org/show_bug.cgi?id=12605 */
#if defined(HAS_SOCKATMARK) && !defined(HAS_SOCKATMARK_PROTO)
# if defined(__THROW) && defined(__GLIBC__)
int sockatmark(int) __THROW;
# else
int sockatmark(int);
# endif
#endif

#if defined(__osf__) && defined(__cplusplus) && !defined(_XOPEN_SOURCE_EXTENDED) /* Tru64 "cxx" (C++), see hints/dec_osf.sh for why the _XOPEN_SOURCE_EXTENDED cannot be defined. */
EXTERN_C int fchdir(int);
EXTERN_C int flock(int, int);
EXTERN_C int fseeko(FILE *, off_t, int);
EXTERN_C off_t ftello(FILE *);
#endif

#if defined(__SUNPRO_CC) /* SUNWspro CC (C++) */
EXTERN_C char *crypt(const char *, const char *);
EXTERN_C char **environ;
#endif

#if defined(__cplusplus)
#  if defined(BSDish)
EXTERN_C char **environ;
#  elif defined(__CYGWIN__)
EXTERN_C char *crypt(const char *, const char *);
#endif
#endif

#ifdef SETERRNO
# undef SETERRNO  /* SOCKS might have defined this */
#endif

#ifdef VMS
#   define SETERRNO(errcode,vmserrcode) \
	STMT_START {			\
	    set_errno(errcode);		\
	    set_vaxc_errno(vmserrcode);	\
	} STMT_END
#   define dSAVEDERRNO    int saved_errno; unsigned saved_vms_errno
#   define dSAVE_ERRNO    int saved_errno = errno; unsigned saved_vms_errno = vaxc$errno
#   define SAVE_ERRNO     ( saved_errno = errno, saved_vms_errno = vaxc$errno )
#   define RESTORE_ERRNO  SETERRNO(saved_errno, saved_vms_errno)

#   define LIB_INVARG 		LIB$_INVARG
#   define RMS_DIR    		RMS$_DIR
#   define RMS_FAC    		RMS$_FAC
#   define RMS_FEX    		RMS$_FEX
#   define RMS_FNF    		RMS$_FNF
#   define RMS_IFI    		RMS$_IFI
#   define RMS_ISI    		RMS$_ISI
#   define RMS_PRV    		RMS$_PRV
#   define SS_ACCVIO      	SS$_ACCVIO
#   define SS_DEVOFFLINE	SS$_DEVOFFLINE
#   define SS_IVCHAN  		SS$_IVCHAN
#   define SS_NORMAL  		SS$_NORMAL
#else
#   define LIB_INVARG 		0
#   define RMS_DIR    		0
#   define RMS_FAC    		0
#   define RMS_FEX    		0
#   define RMS_FNF    		0
#   define RMS_IFI    		0
#   define RMS_ISI    		0
#   define RMS_PRV    		0
#   define SS_ACCVIO      	0
#   define SS_DEVOFFLINE	0
#   define SS_IVCHAN  		0
#   define SS_NORMAL  		0
#endif

#ifdef WIN32
#   define dSAVEDERRNO  int saved_errno; DWORD saved_win32_errno
#   define dSAVE_ERRNO  int saved_errno = errno; DWORD saved_win32_errno = GetLastError()
#   define SAVE_ERRNO   ( saved_errno = errno, saved_win32_errno = GetLastError() )
#   define RESTORE_ERRNO ( errno = saved_errno, SetLastError(saved_win32_errno) )
#endif

#ifdef OS2
#   define dSAVEDERRNO  int saved_errno; unsigned long saved_os2_errno
#   define dSAVE_ERRNO  int saved_errno = errno; unsigned long saved_os2_errno = Perl_rc
#   define SAVE_ERRNO   ( saved_errno = errno, saved_os2_errno = Perl_rc )
#   define RESTORE_ERRNO ( errno = saved_errno, Perl_rc = saved_os2_errno )
#endif

#ifndef SETERRNO
#   define SETERRNO(errcode,vmserrcode) (errno = (errcode))
#endif

#ifndef dSAVEDERRNO
#   define dSAVEDERRNO    int saved_errno
#   define dSAVE_ERRNO    int saved_errno = errno
#   define SAVE_ERRNO     (saved_errno = errno)
#   define RESTORE_ERRNO  (errno = saved_errno)
#endif

#define ERRSV GvSVn(PL_errgv)

#define CLEAR_ERRSV() STMT_START {					\
    if (!GvSV(PL_errgv)) {						\
	sv_setpvs(GvSV(gv_add_by_type(PL_errgv, SVt_PV)), "");		\
    } else if (SvREADONLY(GvSV(PL_errgv))) {				\
	SvREFCNT_dec(GvSV(PL_errgv));					\
	GvSV(PL_errgv) = newSVpvs("");					\
    } else {								\
	SV *const errsv = GvSV(PL_errgv);				\
	sv_setpvs(errsv, "");						\
	if (SvMAGICAL(errsv)) {						\
	    mg_free(errsv);						\
	}								\
	SvPOK_only(errsv);						\
    }									\
    } STMT_END


#ifdef PERL_CORE
# define DEFSV (0 + GvSVn(PL_defgv))
# define DEFSV_set(sv) \
    (SvREFCNT_dec(GvSV(PL_defgv)), GvSV(PL_defgv) = SvREFCNT_inc(sv))
# define SAVE_DEFSV                \
    (                               \
	save_gp(PL_defgv, 0),        \
	GvINTRO_off(PL_defgv),        \
	SAVEGENERICSV(GvSV(PL_defgv)), \
	GvSV(PL_defgv) = NULL           \
    )
#else
# define DEFSV GvSVn(PL_defgv)
# define DEFSV_set(sv) (GvSV(PL_defgv) = (sv))
# define SAVE_DEFSV SAVESPTR(GvSV(PL_defgv))
#endif

#ifndef errno
	extern int errno;     /* ANSI allows errno to be an lvalue expr.
			       * For example in multithreaded environments
			       * something like this might happen:
			       * extern int *_errno(void);
			       * #define errno (*_errno()) */
#endif

#define UNKNOWN_ERRNO_MSG "(unknown)"

#ifdef HAS_STRERROR
#   ifndef DONT_DECLARE_STD
#       ifdef VMS
	char *strerror (int,...);
#       else
	char *strerror (int);
#       endif
#    endif
#    ifndef Strerror
#       define Strerror strerror
#    endif
#else
#    ifdef HAS_SYS_ERRLIST
	extern int sys_nerr;
	extern char *sys_errlist[];
#       ifndef Strerror
#           define Strerror(e) \
		((e) < 0 || (e) >= sys_nerr ? UNKNOWN_ERRNO_MSG : sys_errlist[e])
#       endif
#   endif
#endif

#ifdef I_SYS_IOCTL
#   ifndef _IOCTL_
#	include <sys/ioctl.h>
#   endif
#endif

#if defined(mc300) || defined(mc500) || defined(mc700) || defined(mc6000)
#   ifdef HAS_SOCKETPAIR
#	undef HAS_SOCKETPAIR
#   endif
#   ifdef I_NDBM
#	undef I_NDBM
#   endif
#endif

#ifndef HAS_SOCKETPAIR
#   ifdef HAS_SOCKET
#	define socketpair Perl_my_socketpair
#   endif
#endif

#if INTSIZE == 2
#   define htoni htons
#   define ntohi ntohs
#else
#   define htoni htonl
#   define ntohi ntohl
#endif

/* Configure already sets Direntry_t */
#if defined(I_DIRENT)
#   include <dirent.h>
    /* NeXT needs dirent + sys/dir.h */
#   if  defined(I_SYS_DIR) && (defined(NeXT) || defined(__NeXT__))
#	include <sys/dir.h>
#   endif
#else
#   ifdef I_SYS_NDIR
#	include <sys/ndir.h>
#   else
#	ifdef I_SYS_DIR
#	    ifdef hp9000s500
#		include <ndir.h>	/* may be wrong in the future */
#	    else
#		include <sys/dir.h>
#	    endif
#	endif
#   endif
#endif

/*
 * The following gobbledygook brought to you on behalf of __STDC__.
 * (I could just use #ifndef __STDC__, but this is more bulletproof
 * in the face of half-implementations.)
 */

#if defined(I_SYSMODE)
#include <sys/mode.h>
#endif

#ifndef S_IFMT
#   ifdef _S_IFMT
#	define S_IFMT _S_IFMT
#   else
#	define S_IFMT 0170000
#   endif
#endif

#ifndef S_ISDIR
#   define S_ISDIR(m) ((m & S_IFMT) == S_IFDIR)
#endif

#ifndef S_ISCHR
#   define S_ISCHR(m) ((m & S_IFMT) == S_IFCHR)
#endif

#ifndef S_ISBLK
#   ifdef S_IFBLK
#	define S_ISBLK(m) ((m & S_IFMT) == S_IFBLK)
#   else
#	define S_ISBLK(m) (0)
#   endif
#endif

#ifndef S_ISREG
#   define S_ISREG(m) ((m & S_IFMT) == S_IFREG)
#endif

#ifndef S_ISFIFO
#   ifdef S_IFIFO
#	define S_ISFIFO(m) ((m & S_IFMT) == S_IFIFO)
#   else
#	define S_ISFIFO(m) (0)
#   endif
#endif

#ifndef S_ISLNK
#   ifdef _S_ISLNK
#	define S_ISLNK(m) _S_ISLNK(m)
#   else
#	ifdef _S_IFLNK
#	    define S_ISLNK(m) ((m & S_IFMT) == _S_IFLNK)
#	else
#	    ifdef S_IFLNK
#		define S_ISLNK(m) ((m & S_IFMT) == S_IFLNK)
#	    else
#		define S_ISLNK(m) (0)
#	    endif
#	endif
#   endif
#endif

#ifndef S_ISSOCK
#   ifdef _S_ISSOCK
#	define S_ISSOCK(m) _S_ISSOCK(m)
#   else
#	ifdef _S_IFSOCK
#	    define S_ISSOCK(m) ((m & S_IFMT) == _S_IFSOCK)
#	else
#	    ifdef S_IFSOCK
#		define S_ISSOCK(m) ((m & S_IFMT) == S_IFSOCK)
#	    else
#		define S_ISSOCK(m) (0)
#	    endif
#	endif
#   endif
#endif

#ifndef S_IRUSR
#   ifdef S_IREAD
#	define S_IRUSR S_IREAD
#	define S_IWUSR S_IWRITE
#	define S_IXUSR S_IEXEC
#   else
#	define S_IRUSR 0400
#	define S_IWUSR 0200
#	define S_IXUSR 0100
#   endif
#endif

#ifndef S_IRGRP
#   ifdef S_IRUSR
#       define S_IRGRP (S_IRUSR>>3)
#       define S_IWGRP (S_IWUSR>>3)
#       define S_IXGRP (S_IXUSR>>3)
#   else
#       define S_IRGRP 0040
#       define S_IWGRP 0020
#       define S_IXGRP 0010
#   endif
#endif

#ifndef S_IROTH
#   ifdef S_IRUSR
#       define S_IROTH (S_IRUSR>>6)
#       define S_IWOTH (S_IWUSR>>6)
#       define S_IXOTH (S_IXUSR>>6)
#   else
#       define S_IROTH 0040
#       define S_IWOTH 0020
#       define S_IXOTH 0010
#   endif
#endif

#ifndef S_ISUID
#   define S_ISUID 04000
#endif

#ifndef S_ISGID
#   define S_ISGID 02000
#endif

#ifndef S_IRWXU
#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
#endif

#ifndef S_IRWXG
#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
#endif

#ifndef S_IRWXO
#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
#endif

/* Haiku R1 seems to define S_IREAD and S_IWRITE in <posix/fcntl.h>
 * which would get included through <sys/file.h >, but that is 3000
 * lines in the future.  --jhi */

#if !defined(S_IREAD) && !defined(__HAIKU__)
#   define S_IREAD S_IRUSR
#endif

#if !defined(S_IWRITE) && !defined(__HAIKU__)
#   define S_IWRITE S_IWUSR
#endif

#ifndef S_IEXEC
#   define S_IEXEC S_IXUSR
#endif

#if defined(cray) || defined(gould) || defined(i860) || defined(pyr)
#   define SLOPPYDIVIDE
#endif

#ifdef UV
#undef UV
#endif

/* For the times when you want the return value of sprintf, and you want it
   to be the length. Can't have a thread variable passed in, because C89 has
   no varargs macros.
*/
#ifdef SPRINTF_RETURNS_STRLEN
#  define my_sprintf sprintf
#else
#  define my_sprintf Perl_my_sprintf
#endif

/*
 * If we have v?snprintf() and the C99 variadic macros, we can just
 * use just the v?snprintf().  It is nice to try to trap the buffer
 * overflow, however, so if we are DEBUGGING, and we cannot use the
 * gcc statement expressions, then use the function wrappers which try
 * to trap the overflow.  If we can use the gcc statement expressions,
 * we can try that even with the version that uses the C99 variadic
 * macros.
 */

/* Note that we do not check against snprintf()/vsnprintf() returning
 * negative values because that is non-standard behaviour and we use
 * snprintf/vsnprintf only iff HAS_VSNPRINTF has been defined, and
 * that should be true only if the snprintf()/vsnprintf() are true
 * to the standard. */

#if defined(HAS_SNPRINTF) && defined(HAS_C99_VARIADIC_MACROS) && !(defined(DEBUGGING) && !defined(PERL_USE_GCC_BRACE_GROUPS)) && !defined(PERL_GCC_PEDANTIC)
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#      define my_snprintf(buffer, len, ...) ({ int __len__ = snprintf(buffer, len, __VA_ARGS__); if ((len) > 0 && (Size_t)__len__ >= (len)) Perl_croak_nocontext("panic: snprintf buffer overflow"); __len__; })
#      define PERL_MY_SNPRINTF_GUARDED
#  else
#    define my_snprintf(buffer, len, ...) snprintf(buffer, len, __VA_ARGS__)
#  endif
#else
#  define my_snprintf  Perl_my_snprintf
#  define PERL_MY_SNPRINTF_GUARDED
#endif

#if defined(HAS_VSNPRINTF) && defined(HAS_C99_VARIADIC_MACROS) && !(defined(DEBUGGING) && !defined(PERL_USE_GCC_BRACE_GROUPS)) && !defined(PERL_GCC_PEDANTIC)
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#      define my_vsnprintf(buffer, len, ...) ({ int __len__ = vsnprintf(buffer, len, __VA_ARGS__); if ((len) > 0 && (Size_t)__len__ >= (Size_t)(len)) Perl_croak_nocontext("panic: vsnprintf buffer overflow"); __len__; })
#      define PERL_MY_VSNPRINTF_GUARDED
#  else
#    define my_vsnprintf(buffer, len, ...) vsnprintf(buffer, len, __VA_ARGS__)
#  endif
#else
#  define my_vsnprintf Perl_my_vsnprintf
#  define PERL_MY_VSNPRINTF_GUARDED
#endif

#ifdef HAS_STRLCAT
#  define my_strlcat    strlcat
#else
#  define my_strlcat    Perl_my_strlcat
#endif

#ifdef HAS_STRLCPY
#  define my_strlcpy	strlcpy
#else
#  define my_strlcpy	Perl_my_strlcpy
#endif

/*
    The IV type is supposed to be long enough to hold any integral
    value or a pointer.
    --Andy Dougherty	August 1996
*/

typedef IVTYPE IV;
typedef UVTYPE UV;

#if defined(USE_64_BIT_INT) && defined(HAS_QUAD)
#  if QUADKIND == QUAD_IS_INT64_T && defined(INT64_MAX)
#    define IV_MAX INT64_MAX
#    define IV_MIN INT64_MIN
#    define UV_MAX UINT64_MAX
#    ifndef UINT64_MIN
#      define UINT64_MIN 0
#    endif
#    define UV_MIN UINT64_MIN
#  else
#    define IV_MAX PERL_QUAD_MAX
#    define IV_MIN PERL_QUAD_MIN
#    define UV_MAX PERL_UQUAD_MAX
#    define UV_MIN PERL_UQUAD_MIN
#  endif
#  define IV_IS_QUAD
#  define UV_IS_QUAD
#else
#  if defined(INT32_MAX) && IVSIZE == 4
#    define IV_MAX INT32_MAX
#    define IV_MIN INT32_MIN
#    ifndef UINT32_MAX_BROKEN /* e.g. HP-UX with gcc messes this up */
#        define UV_MAX UINT32_MAX
#    else
#        define UV_MAX 4294967295U
#    endif
#    ifndef UINT32_MIN
#      define UINT32_MIN 0
#    endif
#    define UV_MIN UINT32_MIN
#  else
#    define IV_MAX PERL_LONG_MAX
#    define IV_MIN PERL_LONG_MIN
#    define UV_MAX PERL_ULONG_MAX
#    define UV_MIN PERL_ULONG_MIN
#  endif
#  if IVSIZE == 8
#    define IV_IS_QUAD
#    define UV_IS_QUAD
#    ifndef HAS_QUAD
#      define HAS_QUAD
#    endif
#  else
#    undef IV_IS_QUAD
#    undef UV_IS_QUAD
#if !defined(PERL_CORE) || defined(USING_MSVC6)
/* We think that removing this decade-old undef this will cause too much
   breakage on CPAN for too little gain. (See RT #119753)
   However, we do need HAS_QUAD in the core for use by the drand48 code,
   but not for Win32 VC6 because it has poor __int64 support. */
#    undef HAS_QUAD
#endif
#  endif
#endif

#define SSize_t_MAX (SSize_t)(~(size_t)0 >> 1)

#define IV_DIG (BIT_DIGITS(IVSIZE * 8))
#define UV_DIG (BIT_DIGITS(UVSIZE * 8))

#ifndef NO_PERL_PRESERVE_IVUV
#define PERL_PRESERVE_IVUV	/* We like our integers to stay integers. */
#endif

/*
 *  The macros INT2PTR and NUM2PTR are (despite their names)
 *  bi-directional: they will convert int/float to or from pointers.
 *  However the conversion to int/float are named explicitly:
 *  PTR2IV, PTR2UV, PTR2NV.
 *
 *  For int conversions we do not need two casts if pointers are
 *  the same size as IV and UV.   Otherwise we need an explicit
 *  cast (PTRV) to avoid compiler warnings.
 */
#if (IVSIZE == PTRSIZE) && (UVSIZE == PTRSIZE)
#  define PTRV			UV
#  define INT2PTR(any,d)	(any)(d)
#else
#  if PTRSIZE == LONGSIZE
#    define PTRV		unsigned long
#    define PTR2ul(p)		(unsigned long)(p)
#  else
#    define PTRV		unsigned
#  endif
#endif

#ifndef INT2PTR
#  define INT2PTR(any,d)	(any)(PTRV)(d)
#endif

#ifndef PTR2ul
#  define PTR2ul(p)	INT2PTR(unsigned long,p)	
#endif

#define NUM2PTR(any,d)	(any)(PTRV)(d)
#define PTR2IV(p)	INT2PTR(IV,p)
#define PTR2UV(p)	INT2PTR(UV,p)
#define PTR2NV(p)	NUM2PTR(NV,p)
#define PTR2nat(p)	(PTRV)(p)	/* pointer to integer of PTRSIZE */

/* According to strict ANSI C89 one cannot freely cast between
 * data pointers and function (code) pointers.  There are at least
 * two ways around this.  One (used below) is to do two casts,
 * first the other pointer to an (unsigned) integer, and then
 * the integer to the other pointer.  The other way would be
 * to use unions to "overlay" the pointers.  For an example of
 * the latter technique, see union dirpu in struct xpvio in sv.h.
 * The only feasible use is probably temporarily storing
 * function pointers in a data pointer (such as a void pointer). */

#define DPTR2FPTR(t,p) ((t)PTR2nat(p))	/* data pointer to function pointer */
#define FPTR2DPTR(t,p) ((t)PTR2nat(p))	/* function pointer to data pointer */

#ifdef USE_LONG_DOUBLE
#  if defined(HAS_LONG_DOUBLE) && LONG_DOUBLESIZE == DOUBLESIZE
#      define LONG_DOUBLE_EQUALS_DOUBLE
#  endif
#  if !(defined(HAS_LONG_DOUBLE) && (LONG_DOUBLESIZE > DOUBLESIZE))
#     undef USE_LONG_DOUBLE /* Ouch! */
#  endif
#endif

#ifdef OVR_DBL_DIG
/* Use an overridden DBL_DIG */
# ifdef DBL_DIG
#  undef DBL_DIG
# endif
# define DBL_DIG OVR_DBL_DIG
#else
/* The following is all to get DBL_DIG, in order to pick a nice
   default value for printing floating point numbers in Gconvert
   (see config.h). (It also has other uses, such as figuring out if
   a given precision of printing can be done with a double instead of
   a long double - Allen).
*/
#ifdef I_LIMITS
#include <limits.h>
#endif
#ifdef I_FLOAT
#include <float.h>
#endif
#ifndef HAS_DBL_DIG
#define DBL_DIG	15   /* A guess that works lots of places */
#endif
#endif

#ifdef OVR_LDBL_DIG
/* Use an overridden LDBL_DIG */
# ifdef LDBL_DIG
#  undef LDBL_DIG
# endif
# define LDBL_DIG OVR_LDBL_DIG
#else
/* The following is all to get LDBL_DIG, in order to pick a nice
   default value for printing floating point numbers in Gconvert.
   (see config.h)
*/
# ifdef I_LIMITS
#   include <limits.h>
# endif
# ifdef I_FLOAT
#  include <float.h>
# endif
# ifndef HAS_LDBL_DIG
#  if LONG_DOUBLESIZE == 10
#   define LDBL_DIG 18 /* assume IEEE */
#  else
#   if LONG_DOUBLESIZE == 12
#    define LDBL_DIG 18 /* gcc? */
#   else
#    if LONG_DOUBLESIZE == 16
#     define LDBL_DIG 33 /* assume IEEE */
#    else
#     if LONG_DOUBLESIZE == DOUBLESIZE
#      define LDBL_DIG DBL_DIG /* bummer */
#     endif
#    endif
#   endif
#  endif
# endif
#endif

/*
 * This is for making sure we have a good DBL_MAX value, if possible,
 * either for usage as NV_MAX or for usage in figuring out if we can
 * fit a given long double into a double, if bug-fixing makes it
 * necessary to do so. - Allen <allens@cpan.org>
 */

#ifdef I_LIMITS
#  include <limits.h>
#endif

#ifdef I_VALUES
#  if !(defined(DBL_MIN) && defined(DBL_MAX) && defined(I_LIMITS))
#    include <values.h>
#    if defined(MAXDOUBLE) && !defined(DBL_MAX)
#      define DBL_MAX MAXDOUBLE
#    endif
#    if defined(MINDOUBLE) && !defined(DBL_MIN)
#      define DBL_MIN MINDOUBLE
#    endif
#  endif
#endif /* defined(I_VALUES) */

typedef NVTYPE NV;

#ifdef I_IEEEFP
#   include <ieeefp.h>
#endif

#ifdef USING_MSVC6
/* VC6 has broken NaN semantics: NaN == NaN returns true instead of false,
 * and for example NaN < IV_MIN. */
#  define NAN_COMPARE_BROKEN
#endif
#if defined(__DECC) && defined(__osf__)
/* Also Tru64 cc has broken NaN comparisons. */
#  define NAN_COMPARE_BROKEN
#endif

#ifdef USE_LONG_DOUBLE
#   ifdef I_SUNMATH
#       include <sunmath.h>
#   endif
#   define NV_DIG LDBL_DIG
#   ifdef LDBL_MANT_DIG
#       define NV_MANT_DIG LDBL_MANT_DIG
#   endif
#   ifdef LDBL_MIN
#       define NV_MIN LDBL_MIN
#   endif
#   ifdef LDBL_MAX
#       define NV_MAX LDBL_MAX
#   endif
#   ifdef LDBL_MIN_10_EXP
#       define NV_MIN_10_EXP LDBL_MIN_10_EXP
#   endif
#   ifdef LDBL_MAX_10_EXP
#       define NV_MAX_10_EXP LDBL_MAX_10_EXP
#   endif
#   ifdef LDBL_EPSILON
#       define NV_EPSILON LDBL_EPSILON
#   endif
#   ifdef LDBL_MAX
#       define NV_MAX LDBL_MAX
/* Having LDBL_MAX doesn't necessarily mean that we have LDBL_MIN... -Allen */
#   else
#       ifdef HUGE_VALL
#           define NV_MAX HUGE_VALL
#       else
#           ifdef HUGE_VAL
#               define NV_MAX ((NV)HUGE_VAL)
#           endif
#       endif
#   endif
#   ifdef HAS_SQRTL
#       define Perl_cos cosl
#       define Perl_sin sinl
#       define Perl_sqrt sqrtl
#       define Perl_exp expl
#       define Perl_log logl
#       define Perl_atan2 atan2l
#       define Perl_pow powl
#       define Perl_floor floorl
#       define Perl_ceil ceill
#       define Perl_fmod fmodl
#   endif
/* e.g. libsunmath doesn't have modfl and frexpl as of mid-March 2000 */
#   ifdef HAS_MODFL
#       define Perl_modf(x,y) modfl(x,y)
/* eg glibc 2.2 series seems to provide modfl on ppc and arm, but has no
   prototype in <math.h> */
#       ifndef HAS_MODFL_PROTO
EXTERN_C long double modfl(long double, long double *);
#	endif
#   else
#       if defined(HAS_AINTL) && defined(HAS_COPYSIGNL)
        extern long double Perl_my_modfl(long double x, long double *ip);
#           define Perl_modf(x,y) Perl_my_modfl(x,y)
#       endif
#   endif
#   ifdef HAS_FREXPL
#       define Perl_frexp(x,y) frexpl(x,y)
#   else
#       if defined(HAS_ILOGBL) && defined(HAS_SCALBNL)
        extern long double Perl_my_frexpl(long double x, int *e);
#           define Perl_frexp(x,y) Perl_my_frexpl(x,y)
#       endif
#   endif
#   ifndef Perl_isnan
#       ifdef HAS_ISNANL
#           define Perl_isnan(x) isnanl(x)
#       endif
#   endif
#   ifndef Perl_isinf
#       ifdef HAS_FINITEL
#           define Perl_isinf(x) !(finitel(x)||Perl_isnan(x))
#       endif
#   endif
#else
#   define NV_DIG DBL_DIG
#   ifdef DBL_MANT_DIG
#       define NV_MANT_DIG DBL_MANT_DIG
#   endif
#   ifdef DBL_MIN
#       define NV_MIN DBL_MIN
#   endif
#   ifdef DBL_MAX
#       define NV_MAX DBL_MAX
#   endif
#   ifdef DBL_MIN_10_EXP
#       define NV_MIN_10_EXP DBL_MIN_10_EXP
#   endif
#   ifdef DBL_MAX_10_EXP
#       define NV_MAX_10_EXP DBL_MAX_10_EXP
#   endif
#   ifdef DBL_EPSILON
#       define NV_EPSILON DBL_EPSILON
#   endif
#   ifdef DBL_MAX               /* XXX Does DBL_MAX imply having DBL_MIN? */
#       define NV_MAX DBL_MAX
#       define NV_MIN DBL_MIN
#   else
#       ifdef HUGE_VAL
#           define NV_MAX HUGE_VAL
#       endif
#   endif
#   define Perl_cos cos
#   define Perl_sin sin
#   define Perl_sqrt sqrt
#   define Perl_exp exp
#   define Perl_log log
#   define Perl_atan2 atan2
#   define Perl_pow pow
#   define Perl_floor floor
#   define Perl_ceil ceil
#   define Perl_fmod fmod
#   define Perl_modf(x,y) modf(x,y)
#   define Perl_frexp(x,y) frexp(x,y)
#endif

/* rumor has it that Win32 has _fpclass() */

/* SGI has fpclassl... but not with the same result values,
 * and it's via a typedef (not via #define), so will need to redo Configure
 * to use. Not worth the trouble, IMO, at least until the below is used
 * more places. Also has fp_class_l, BTW, via fp_class.h. Feel free to check
 * with me for the SGI manpages, SGI testing, etcetera, if you want to
 * try getting this to work with IRIX. - Allen <allens@cpan.org> */

#if !defined(Perl_fp_class) && (defined(HAS_FPCLASS)||defined(HAS_FPCLASSL))
#    ifdef I_IEEFP
#        include <ieeefp.h>
#    endif
#    ifdef I_FP
#        include <fp.h>
#    endif
#    if defined(USE_LONG_DOUBLE) && defined(HAS_FPCLASSL)
#        define Perl_fp_class()		fpclassl(x)
#    else
#        define Perl_fp_class()		fpclass(x)
#    endif
#    define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_CLASS_SNAN)
#    define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_CLASS_QNAN)
#    define Perl_fp_class_nan(x)	(Perl_fp_class(x)==FP_CLASS_SNAN||Perl_fp_class(x)==FP_CLASS_QNAN)
#    define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_CLASS_NINF)
#    define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_CLASS_PINF)
#    define Perl_fp_class_inf(x)	(Perl_fp_class(x)==FP_CLASS_NINF||Perl_fp_class(x)==FP_CLASS_PINF)
#    define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_CLASS_NNORM)
#    define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_CLASS_PNORM)
#    define Perl_fp_class_norm(x)	(Perl_fp_class(x)==FP_CLASS_NNORM||Perl_fp_class(x)==FP_CLASS_PNORM)
#    define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_CLASS_NDENORM)
#    define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_CLASS_PDENORM)
#    define Perl_fp_class_denorm(x)	(Perl_fp_class(x)==FP_CLASS_NDENORM||Perl_fp_class(x)==FP_CLASS_PDENORM)
#    define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_CLASS_NZERO)
#    define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_CLASS_PZERO)
#    define Perl_fp_class_zero(x)	(Perl_fp_class(x)==FP_CLASS_NZERO||Perl_fp_class(x)==FP_CLASS_PZERO)
#endif

#if !defined(Perl_fp_class) && defined(HAS_FP_CLASS)
#    include <math.h>
#    if !defined(FP_SNAN) && defined(I_FP_CLASS)
#        include <fp_class.h>
#    endif
#    define Perl_fp_class(x)		fp_class(x)
#    define Perl_fp_class_snan(x)	(fp_class(x)==FP_SNAN)
#    define Perl_fp_class_qnan(x)	(fp_class(x)==FP_QNAN)
#    define Perl_fp_class_nan(x)	(fp_class(x)==FP_SNAN||fp_class(x)==FP_QNAN)
#    define Perl_fp_class_ninf(x)	(fp_class(x)==FP_NEG_INF)
#    define Perl_fp_class_pinf(x)	(fp_class(x)==FP_POS_INF)
#    define Perl_fp_class_inf(x)	(fp_class(x)==FP_NEG_INF||fp_class(x)==FP_POS_INF)
#    define Perl_fp_class_nnorm(x)	(fp_class(x)==FP_NEG_NORM)
#    define Perl_fp_class_pnorm(x)	(fp_class(x)==FP_POS_NORM)
#    define Perl_fp_class_norm(x)	(fp_class(x)==FP_NEG_NORM||fp_class(x)==FP_POS_NORM)
#    define Perl_fp_class_ndenorm(x)	(fp_class(x)==FP_NEG_DENORM)
#    define Perl_fp_class_pdenorm(x)	(fp_class(x)==FP_POS_DENORM)
#    define Perl_fp_class_denorm(x)	(fp_class(x)==FP_NEG_DENORM||fp_class(x)==FP_POS_DENORM)
#    define Perl_fp_class_nzero(x)	(fp_class(x)==FP_NEG_ZERO)
#    define Perl_fp_class_pzero(x)	(fp_class(x)==FP_POS_ZERO)
#    define Perl_fp_class_zero(x)	(fp_class(x)==FP_NEG_ZERO||fp_class(x)==FP_POS_ZERO)
#endif

#if !defined(Perl_fp_class) && defined(HAS_FPCLASSIFY)
#    include <math.h>
#    define Perl_fp_class(x)		fpclassify(x)
#    define Perl_fp_class_nan(x)	(fp_classify(x)==FP_SNAN||fp_classify(x)==FP_QNAN)
#    define Perl_fp_class_inf(x)	(fp_classify(x)==FP_INFINITE)
#    define Perl_fp_class_norm(x)	(fp_classify(x)==FP_NORMAL)
#    define Perl_fp_class_denorm(x)	(fp_classify(x)==FP_SUBNORMAL)
#    define Perl_fp_class_zero(x)	(fp_classify(x)==FP_ZERO)
#endif

#if !defined(Perl_fp_class) && defined(HAS_CLASS)
#    include <math.h>
#    ifndef _cplusplus
#        define Perl_fp_class(x)	class(x)
#    else
#        define Perl_fp_class(x)	_class(x)
#    endif
#    define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_NANS)
#    define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_NANQ)
#    define Perl_fp_class_nan(x)	(Perl_fp_class(x)==FP_SNAN||Perl_fp_class(x)==FP_QNAN)
#    define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_MINUS_INF)
#    define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_PLUS_INF)
#    define Perl_fp_class_inf(x)	(Perl_fp_class(x)==FP_MINUS_INF||Perl_fp_class(x)==FP_PLUS_INF)
#    define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_MINUS_NORM)
#    define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_PLUS_NORM)
#    define Perl_fp_class_norm(x)	(Perl_fp_class(x)==FP_MINUS_NORM||Perl_fp_class(x)==FP_PLUS_NORM)
#    define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_MINUS_DENORM)
#    define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_PLUS_DENORM)
#    define Perl_fp_class_denorm(x)	(Perl_fp_class(x)==FP_MINUS_DENORM||Perl_fp_class(x)==FP_PLUS_DENORM)
#    define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_MINUS_ZERO)
#    define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_PLUS_ZERO)
#    define Perl_fp_class_zero(x)	(Perl_fp_class(x)==FP_MINUS_ZERO||Perl_fp_class(x)==FP_PLUS_ZERO)
#endif

/* rumor has it that Win32 has _isnan() */

#ifndef Perl_isnan
#   ifdef HAS_ISNAN
#       define Perl_isnan(x) isnan((NV)x)
#   else
#       ifdef Perl_fp_class_nan
#           define Perl_isnan(x) Perl_fp_class_nan(x)
#       else
#           ifdef HAS_UNORDERED
#               define Perl_isnan(x) unordered((x), 0.0)
#           else
#               define Perl_isnan(x) ((x)!=(x))
#           endif
#       endif
#   endif
#endif

#ifdef UNDER_CE
int isnan(double d);
#endif

#ifndef Perl_isinf
#   ifdef HAS_ISINF
#       define Perl_isinf(x) isinf((NV)x)
#   else
#       ifdef Perl_fp_class_inf
#           define Perl_isinf(x) Perl_fp_class_inf(x)
#       else
#           define Perl_isinf(x) ((x)==NV_INF)
#       endif
#   endif
#endif

#ifndef Perl_isfinite
#   ifdef HAS_FINITE
#       define Perl_isfinite(x) finite((NV)x)
#   else
#       ifdef HAS_ISFINITE
#           define Perl_isfinite(x) isfinite(x)
#       else
#           ifdef Perl_fp_class_finite
#               define Perl_isfinite(x) Perl_fp_class_finite(x)
#           else
#               define Perl_isfinite(x) !(Perl_is_inf(x)||Perl_is_nan(x))
#           endif
#       endif
#   endif
#endif

/* The default is to use Perl's own atof() implementation (in numeric.c).
 * Usually that is the one to use but for some platforms (e.g. UNICOS)
 * it is however best to use the native implementation of atof.
 * You can experiment with using your native one by -DUSE_PERL_ATOF=0.
 * Some good tests to try out with either setting are t/base/num.t,
 * t/op/numconvert.t, and t/op/pack.t. Note that if using long doubles
 * you may need to be using a different function than atof! */

#ifndef USE_PERL_ATOF
#   ifndef _UNICOS
#       define USE_PERL_ATOF
#   endif
#else
#   if USE_PERL_ATOF == 0
#       undef USE_PERL_ATOF
#   endif
#endif

#ifdef USE_PERL_ATOF
#   define Perl_atof(s) Perl_my_atof(s)
#   define Perl_atof2(s, n) Perl_my_atof2(aTHX_ (s), &(n))
#else
#   define Perl_atof(s) (NV)atof(s)
#   define Perl_atof2(s, n) ((n) = atof(s))
#endif

/* Previously these definitions used hardcoded figures.
 * It is hoped these formula are more portable, although
 * no data one way or another is presently known to me.
 * The "PERL_" names are used because these calculated constants
 * do not meet the ANSI requirements for LONG_MAX, etc., which
 * need to be constants acceptable to #if - kja
 *    define PERL_LONG_MAX        2147483647L
 *    define PERL_LONG_MIN        (-LONG_MAX - 1)
 *    define PERL ULONG_MAX       4294967295L
 */

#ifdef I_LIMITS  /* Needed for cast_xxx() functions below. */
#  include <limits.h>
#endif
/* Included values.h above if necessary; still including limits.h down here,
 * despite doing above, because math.h might have overridden... XXX - Allen */

/*
 * Try to figure out max and min values for the integral types.  THE CORRECT
 * SOLUTION TO THIS MESS: ADAPT enquire.c FROM GCC INTO CONFIGURE.  The
 * following hacks are used if neither limits.h or values.h provide them:
 * U<TYPE>_MAX: for types >= int: ~(unsigned TYPE)0
 *              for types <  int:  (unsigned TYPE)~(unsigned)0
 *	The argument to ~ must be unsigned so that later signed->unsigned
 *	conversion can't modify the value's bit pattern (e.g. -0 -> +0),
 *	and it must not be smaller than int because ~ does integral promotion.
 * <type>_MAX: (<type>) (U<type>_MAX >> 1)
 * <type>_MIN: -<type>_MAX - <is_twos_complement_architecture: (3 & -1) == 3>.
 *	The latter is a hack which happens to work on some machines but
 *	does *not* catch any random system, or things like integer types
 *	with NaN if that is possible.
 *
 * All of the types are explicitly cast to prevent accidental loss of
 * numeric range, and in the hope that they will be less likely to confuse
 * over-eager optimizers.
 *
 */

#define PERL_UCHAR_MIN ((unsigned char)0)

#ifdef UCHAR_MAX
#  define PERL_UCHAR_MAX ((unsigned char)UCHAR_MAX)
#else
#  ifdef MAXUCHAR
#    define PERL_UCHAR_MAX ((unsigned char)MAXUCHAR)
#  else
#    define PERL_UCHAR_MAX       ((unsigned char)~(unsigned)0)
#  endif
#endif

/*
 * CHAR_MIN and CHAR_MAX are not included here, as the (char) type may be
 * ambiguous. It may be equivalent to (signed char) or (unsigned char)
 * depending on local options. Until Configure detects this (or at least
 * detects whether the "signed" keyword is available) the CHAR ranges
 * will not be included. UCHAR functions normally.
 *                                                           - kja
 */

#define PERL_USHORT_MIN ((unsigned short)0)

#ifdef USHORT_MAX
#  define PERL_USHORT_MAX ((unsigned short)USHORT_MAX)
#else
#  ifdef MAXUSHORT
#    define PERL_USHORT_MAX ((unsigned short)MAXUSHORT)
#  else
#    ifdef USHRT_MAX
#      define PERL_USHORT_MAX ((unsigned short)USHRT_MAX)
#    else
#      define PERL_USHORT_MAX       ((unsigned short)~(unsigned)0)
#    endif
#  endif
#endif

#ifdef SHORT_MAX
#  define PERL_SHORT_MAX ((short)SHORT_MAX)
#else
#  ifdef MAXSHORT    /* Often used in <values.h> */
#    define PERL_SHORT_MAX ((short)MAXSHORT)
#  else
#    ifdef SHRT_MAX
#      define PERL_SHORT_MAX ((short)SHRT_MAX)
#    else
#      define PERL_SHORT_MAX      ((short) (PERL_USHORT_MAX >> 1))
#    endif
#  endif
#endif

#ifdef SHORT_MIN
#  define PERL_SHORT_MIN ((short)SHORT_MIN)
#else
#  ifdef MINSHORT
#    define PERL_SHORT_MIN ((short)MINSHORT)
#  else
#    ifdef SHRT_MIN
#      define PERL_SHORT_MIN ((short)SHRT_MIN)
#    else
#      define PERL_SHORT_MIN        (-PERL_SHORT_MAX - ((3 & -1) == 3))
#    endif
#  endif
#endif

#ifdef UINT_MAX
#  define PERL_UINT_MAX ((unsigned int)UINT_MAX)
#else
#  ifdef MAXUINT
#    define PERL_UINT_MAX ((unsigned int)MAXUINT)
#  else
#    define PERL_UINT_MAX       (~(unsigned int)0)
#  endif
#endif

#define PERL_UINT_MIN ((unsigned int)0)

#ifdef INT_MAX
#  define PERL_INT_MAX ((int)INT_MAX)
#else
#  ifdef MAXINT    /* Often used in <values.h> */
#    define PERL_INT_MAX ((int)MAXINT)
#  else
#    define PERL_INT_MAX        ((int)(PERL_UINT_MAX >> 1))
#  endif
#endif

#ifdef INT_MIN
#  define PERL_INT_MIN ((int)INT_MIN)
#else
#  ifdef MININT
#    define PERL_INT_MIN ((int)MININT)
#  else
#    define PERL_INT_MIN        (-PERL_INT_MAX - ((3 & -1) == 3))
#  endif
#endif

#ifdef ULONG_MAX
#  define PERL_ULONG_MAX ((unsigned long)ULONG_MAX)
#else
#  ifdef MAXULONG
#    define PERL_ULONG_MAX ((unsigned long)MAXULONG)
#  else
#    define PERL_ULONG_MAX       (~(unsigned long)0)
#  endif
#endif

#define PERL_ULONG_MIN ((unsigned long)0L)

#ifdef LONG_MAX
#  define PERL_LONG_MAX ((long)LONG_MAX)
#else
#  ifdef MAXLONG    /* Often used in <values.h> */
#    define PERL_LONG_MAX ((long)MAXLONG)
#  else
#    define PERL_LONG_MAX        ((long) (PERL_ULONG_MAX >> 1))
#  endif
#endif

#ifdef LONG_MIN
#  define PERL_LONG_MIN ((long)LONG_MIN)
#else
#  ifdef MINLONG
#    define PERL_LONG_MIN ((long)MINLONG)
#  else
#    define PERL_LONG_MIN        (-PERL_LONG_MAX - ((3 & -1) == 3))
#  endif
#endif

#ifdef UV_IS_QUAD

#    define PERL_UQUAD_MAX	(~(UV)0)
#    define PERL_UQUAD_MIN	((UV)0)
#    define PERL_QUAD_MAX 	((IV) (PERL_UQUAD_MAX >> 1))
#    define PERL_QUAD_MIN 	(-PERL_QUAD_MAX - ((3 & -1) == 3))

#endif

typedef MEM_SIZE STRLEN;

#ifdef PERL_MAD
typedef struct token TOKEN;
typedef struct madprop MADPROP;
typedef struct nexttoken NEXTTOKE;
#endif
typedef struct op OP;
typedef struct cop COP;
typedef struct unop UNOP;
typedef struct binop BINOP;
typedef struct listop LISTOP;
typedef struct logop LOGOP;
typedef struct pmop PMOP;
typedef struct svop SVOP;
typedef struct padop PADOP;
typedef struct pvop PVOP;
typedef struct loop LOOP;

#ifdef PERL_CORE
typedef struct opslab OPSLAB;
typedef struct opslot OPSLOT;
#endif

typedef struct block_hooks BHK;
typedef struct custom_op XOP;

typedef struct interpreter PerlInterpreter;

/* SGI's <sys/sema.h> has struct sv */
#if defined(__sgi)
#   define STRUCT_SV perl_sv
#else
#   define STRUCT_SV sv
#endif
typedef struct STRUCT_SV SV;
typedef struct av AV;
typedef struct hv HV;
typedef struct cv CV;
typedef struct p5rx REGEXP;
typedef struct gp GP;
typedef struct gv GV;
typedef struct io IO;
typedef struct context PERL_CONTEXT;
typedef struct block BLOCK;

typedef struct magic MAGIC;
typedef struct xpv XPV;
typedef struct xpviv XPVIV;
typedef struct xpvuv XPVUV;
typedef struct xpvnv XPVNV;
typedef struct xpvmg XPVMG;
typedef struct xpvlv XPVLV;
typedef struct xpvinvlist XINVLIST;
typedef struct xpvav XPVAV;
typedef struct xpvhv XPVHV;
typedef struct xpvgv XPVGV;
typedef struct xpvcv XPVCV;
typedef struct xpvbm XPVBM;
typedef struct xpvfm XPVFM;
typedef struct xpvio XPVIO;
typedef struct mgvtbl MGVTBL;
typedef union any ANY;
typedef struct ptr_tbl_ent PTR_TBL_ENT_t;
typedef struct ptr_tbl PTR_TBL_t;
typedef struct clone_params CLONE_PARAMS;

/* a pad or name pad is currently just an AV; but that might change,
 * so hide the type.  */
typedef struct padlist PADLIST;
typedef AV PAD;
typedef AV PADNAMELIST;
typedef SV PADNAME;

/* enable PERL_NEW_COPY_ON_WRITE by default */
#if !defined(PERL_OLD_COPY_ON_WRITE) && !defined(PERL_NEW_COPY_ON_WRITE) && !defined(PERL_NO_COW)
#  define PERL_NEW_COPY_ON_WRITE
#endif

#if defined(PERL_OLD_COPY_ON_WRITE) || defined(PERL_NEW_COPY_ON_WRITE)
# if defined(PERL_OLD_COPY_ON_WRITE) && defined(PERL_NEW_COPY_ON_WRITE)
#  error PERL_OLD_COPY_ON_WRITE and PERL_NEW_COPY_ON_WRITE are exclusive
# else
#  define PERL_ANY_COW
# endif
#else
# define PERL_SAWAMPERSAND
#endif

#include "handy.h"

#if defined(USE_LARGE_FILES) && !defined(NO_64_BIT_RAWIO)
#   if LSEEKSIZE == 8 && !defined(USE_64_BIT_RAWIO)
#       define USE_64_BIT_RAWIO	/* implicit */
#   endif
#endif

/* Notice the use of HAS_FSEEKO: now we are obligated to always use
 * fseeko/ftello if possible.  Don't go #defining ftell to ftello yourself,
 * however, because operating systems like to do that themself. */
#ifndef FSEEKSIZE
#   ifdef HAS_FSEEKO
#       define FSEEKSIZE LSEEKSIZE
#   else
#       define FSEEKSIZE LONGSIZE
#   endif
#endif

#if defined(USE_LARGE_FILES) && !defined(NO_64_BIT_STDIO)
#   if FSEEKSIZE == 8 && !defined(USE_64_BIT_STDIO)
#       define USE_64_BIT_STDIO /* implicit */
#   endif
#endif

#ifdef USE_64_BIT_RAWIO
#   ifdef HAS_OFF64_T
#       undef Off_t
#       define Off_t off64_t
#       undef LSEEKSIZE
#       define LSEEKSIZE 8
#   endif
/* Most 64-bit environments have defines like _LARGEFILE_SOURCE that
 * will trigger defines like the ones below.  Some 64-bit environments,
 * however, do not.  Therefore we have to explicitly mix and match. */
#   if defined(USE_OPEN64)
#       define open open64
#   endif
#   if defined(USE_LSEEK64)
#       define lseek lseek64
#   else
#       if defined(USE_LLSEEK)
#           define lseek llseek
#       endif
#   endif
#   if defined(USE_STAT64)
#       define stat stat64
#   endif
#   if defined(USE_FSTAT64)
#       define fstat fstat64
#   endif
#   if defined(USE_LSTAT64)
#       define lstat lstat64
#   endif
#   if defined(USE_FLOCK64)
#       define flock flock64
#   endif
#   if defined(USE_LOCKF64)
#       define lockf lockf64
#   endif
#   if defined(USE_FCNTL64)
#       define fcntl fcntl64
#   endif
#   if defined(USE_TRUNCATE64)
#       define truncate truncate64
#   endif
#   if defined(USE_FTRUNCATE64)
#       define ftruncate ftruncate64
#   endif
#endif

#ifdef USE_64_BIT_STDIO
#   ifdef HAS_FPOS64_T
#       undef Fpos_t
#       define Fpos_t fpos64_t
#   endif
/* Most 64-bit environments have defines like _LARGEFILE_SOURCE that
 * will trigger defines like the ones below.  Some 64-bit environments,
 * however, do not. */
#   if defined(USE_FOPEN64)
#       define fopen fopen64
#   endif
#   if defined(USE_FSEEK64)
#       define fseek fseek64 /* don't do fseeko here, see perlio.c */
#   endif
#   if defined(USE_FTELL64)
#       define ftell ftell64 /* don't do ftello here, see perlio.c */
#   endif
#   if defined(USE_FSETPOS64)
#       define fsetpos fsetpos64
#   endif
#   if defined(USE_FGETPOS64)
#       define fgetpos fgetpos64
#   endif
#   if defined(USE_TMPFILE64)
#       define tmpfile tmpfile64
#   endif
#   if defined(USE_FREOPEN64)
#       define freopen freopen64
#   endif
#endif

#if defined(OS2)
#  include "iperlsys.h"
#endif

#ifdef DOSISH
#   if defined(OS2)
#       include "os2ish.h"
#   else
#       include "dosish.h"
#   endif
#elif defined(VMS)
#   include "vmsish.h"
#elif defined(PLAN9)
#   include "./plan9/plan9ish.h"
#elif defined(__VOS__)
#   ifdef __GNUC__
#     include "./vos/vosish.h"
#   else
#     include "vos/vosish.h"
#   endif
#elif defined(__SYMBIAN32__)
#   include "symbian/symbianish.h"
#elif defined(__HAIKU__)
#   include "haiku/haikuish.h"
#else
#   include "unixish.h"
#endif

/* NSIG logic from Configure --> */
/* Strange style to avoid deeply-nested #if/#else/#endif */
#ifndef NSIG
#  ifdef _NSIG
#    define NSIG (_NSIG)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGMAX
#    define NSIG (SIGMAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIG_MAX
#    define NSIG (SIG_MAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef _SIG_MAX
#    define NSIG (_SIG_MAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAXSIG
#    define NSIG (MAXSIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAX_SIG
#    define NSIG (MAX_SIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGARRAYSIZE
#    define NSIG SIGARRAYSIZE /* Assume ary[SIGARRAYSIZE] */
#  endif
#endif

#ifndef NSIG
#  ifdef _sys_nsig
#    define NSIG (_sys_nsig) /* Solaris 2.5 */
#  endif
#endif

/* Default to some arbitrary number that's big enough to get most
   of the common signals.
*/
#ifndef NSIG
#    define NSIG 50
#endif
/* <-- NSIG logic from Configure */

#ifndef NO_ENVIRON_ARRAY
#  define USE_ENVIRON_ARRAY
#endif

/*
 * initialise to avoid floating-point exceptions from overflow, etc
 */
#ifndef PERL_FPU_INIT
#  ifdef HAS_FPSETMASK
#    if HAS_FLOATINGPOINT_H
#      include <floatingpoint.h>
#    endif
/* Some operating systems have this as a macro, which in turn expands to a comma
   expression, and the last sub-expression is something that gets calculated,
   and then they have the gall to warn that a value computed is not used. Hence
   cast to void.  */
#    define PERL_FPU_INIT (void)fpsetmask(0)
#  else
#    if defined(SIGFPE) && defined(SIG_IGN) && !defined(PERL_MICRO)
#      define PERL_FPU_INIT       PL_sigfpe_saved = (Sighandler_t) signal(SIGFPE, SIG_IGN)
#      define PERL_FPU_PRE_EXEC   { Sigsave_t xfpe; rsignal_save(SIGFPE, PL_sigfpe_saved, &xfpe);
#      define PERL_FPU_POST_EXEC    rsignal_restore(SIGFPE, &xfpe); }
#    else
#      define PERL_FPU_INIT

#    endif
#  endif
#endif
#ifndef PERL_FPU_PRE_EXEC
#  define PERL_FPU_PRE_EXEC   {
#  define PERL_FPU_POST_EXEC  }
#endif

#ifndef PERL_SYS_INIT3_BODY
#  define PERL_SYS_INIT3_BODY(argvp,argcp,envp) PERL_SYS_INIT_BODY(argvp,argcp)
#endif

/*
=for apidoc Am|void|PERL_SYS_INIT|int *argc|char*** argv
Provides system-specific tune up of the C runtime environment necessary to
run Perl interpreters.  This should be called only once, before creating
any Perl interpreters.

=for apidoc Am|void|PERL_SYS_INIT3|int *argc|char*** argv|char*** env
Provides system-specific tune up of the C runtime environment necessary to
run Perl interpreters.  This should be called only once, before creating
any Perl interpreters.

=for apidoc Am|void|PERL_SYS_TERM|
Provides system-specific clean up of the C runtime environment after
running Perl interpreters.  This should be called only once, after
freeing any remaining Perl interpreters.

=cut
 */

#define PERL_SYS_INIT(argc, argv)	Perl_sys_init(argc, argv)
#define PERL_SYS_INIT3(argc, argv, env)	Perl_sys_init3(argc, argv, env)
#define PERL_SYS_TERM()			Perl_sys_term()

#ifndef PERL_WRITE_MSG_TO_CONSOLE
#  define PERL_WRITE_MSG_TO_CONSOLE(io, msg, len) PerlIO_write(io, msg, len)
#endif

#ifndef MAXPATHLEN
#  ifdef PATH_MAX
#    ifdef _POSIX_PATH_MAX
#       if PATH_MAX > _POSIX_PATH_MAX
/* POSIX 1990 (and pre) was ambiguous about whether PATH_MAX
 * included the null byte or not.  Later amendments of POSIX,
 * XPG4, the Austin Group, and the Single UNIX Specification
 * all explicitly include the null byte in the PATH_MAX.
 * Ditto for _POSIX_PATH_MAX. */
#         define MAXPATHLEN PATH_MAX
#       else
#         define MAXPATHLEN _POSIX_PATH_MAX
#       endif
#    else
#      define MAXPATHLEN (PATH_MAX+1)
#    endif
#  else
#    define MAXPATHLEN 1024	/* Err on the large side. */
#  endif
#endif

/* In case Configure was not used (we are using a "canned config"
 * such as Win32, or a cross-compilation setup, for example) try going
 * by the gcc major and minor versions.  One useful URL is
 * http://www.ohse.de/uwe/articles/gcc-attributes.html,
 * but contrary to this information warn_unused_result seems
 * not to be in gcc 3.3.5, at least. --jhi
 * Also, when building extensions with an installed perl, this allows
 * the user to upgrade gcc and get the right attributes, rather than
 * relying on the list generated at Configure time.  --AD
 * Set these up now otherwise we get confused when some of the <*thread.h>
 * includes below indirectly pull in <perlio.h> (which needs to know if we
 * have HASATTRIBUTE_FORMAT).
 */

#ifndef PERL_MICRO
#if defined __GNUC__ && !defined(__INTEL_COMPILER)
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 1 || __GNUC__ > 3 /* 3.1 -> */
#    define HASATTRIBUTE_DEPRECATED
#  endif
#  if __GNUC__ >= 3 /* 3.0 -> */ /* XXX Verify this version */
#    define HASATTRIBUTE_FORMAT
#    if defined __MINGW32__
#      define PRINTF_FORMAT_NULL_OK
#    endif
#  endif
#  if __GNUC__ >= 3 /* 3.0 -> */
#    define HASATTRIBUTE_MALLOC
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 3 || __GNUC__ > 3 /* 3.3 -> */
#    define HASATTRIBUTE_NONNULL
#  endif
#  if __GNUC__ == 2 && __GNUC_MINOR__ >= 5 || __GNUC__ > 2 /* 2.5 -> */
#    define HASATTRIBUTE_NORETURN
#  endif
#  if __GNUC__ >= 3 /* gcc 3.0 -> */
#    define HASATTRIBUTE_PURE
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 4 || __GNUC__ > 3 /* 3.4 -> */
#    define HASATTRIBUTE_UNUSED
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ == 3 && !defined(__cplusplus)
#    define HASATTRIBUTE_UNUSED /* gcc-3.3, but not g++-3.3. */
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 4 || __GNUC__ > 3 /* 3.4 -> */
#    define HASATTRIBUTE_WARN_UNUSED_RESULT
#  endif
#endif
#endif /* #ifndef PERL_MICRO */

/* USE_5005THREADS needs to be after unixish.h as <pthread.h> includes
 * <sys/signal.h> which defines NSIG - which will stop inclusion of <signal.h>
 * this results in many functions being undeclared which bothers C++
 * May make sense to have threads after "*ish.h" anyway
 */

#if defined(USE_ITHREADS)
#  ifdef NETWARE
#   include <nw5thread.h>
#  else
#    ifdef WIN32
#      include <win32thread.h>
#    else
#      ifdef OS2
#        include "os2thread.h"
#      else
#        ifdef I_MACH_CTHREADS
#          include <mach/cthreads.h>
#          if (defined(NeXT) || defined(__NeXT__)) && defined(PERL_POLLUTE_MALLOC)
#            define MUTEX_INIT_CALLS_MALLOC
#          endif
typedef cthread_t	perl_os_thread;
typedef mutex_t		perl_mutex;
typedef condition_t	perl_cond;
typedef void *		perl_key;
#        else /* Posix threads */
#          ifdef I_PTHREAD
#            include <pthread.h>
#          endif
typedef pthread_t	perl_os_thread;
typedef pthread_mutex_t	perl_mutex;
typedef pthread_cond_t	perl_cond;
typedef pthread_key_t	perl_key;
#        endif /* I_MACH_CTHREADS */
#      endif /* OS2 */
#    endif /* WIN32 */
#  endif /* NETWARE */
#endif /* USE_ITHREADS */

#if defined(WIN32)
#  include "win32.h"
#endif

#ifdef NETWARE
#  include "netware.h"
#endif

#define STATUS_UNIX	PL_statusvalue
#ifdef VMS
#   define STATUS_NATIVE	PL_statusvalue_vms
/*
 * vaxc$errno is only guaranteed to be valid if errno == EVMSERR, otherwise
 * its contents can not be trusted.  Unfortunately, Perl seems to check
 * it on exit, so it when PL_statusvalue_vms is updated, vaxc$errno should
 * be updated also.
 */
#  include <stsdef.h>
#  include <ssdef.h>
/* Presume this because if VMS changes it, it will require a new
 * set of APIs for waiting on children for binary compatibility.
 */
#  define child_offset_bits (8)
#  ifndef C_FAC_POSIX
#  define C_FAC_POSIX 0x35A000
#  endif

/*  STATUS_EXIT - validates and returns a NATIVE exit status code for the
 * platform from the existing UNIX or Native status values.
 */

#   define STATUS_EXIT \
	(((I32)PL_statusvalue_vms == -1 ? SS$_ABORT : PL_statusvalue_vms) | \
	   (VMSISH_HUSHED ? STS$M_INHIB_MSG : 0))


/* STATUS_NATIVE_CHILD_SET - Calculate UNIX status that matches the child
 * exit code and shifts the UNIX value over the correct number of bits to
 * be a child status.  Usually the number of bits is 8, but that could be
 * platform dependent.  The NATIVE status code is presumed to have either
 * from a child process.
 */

/* This is complicated.  The child processes return a true native VMS
   status which must be saved.  But there is an assumption in Perl that
   the UNIX child status has some relationship to errno values, so
   Perl tries to translate it to text in some of the tests.
   In order to get the string translation correct, for the error, errno
   must be EVMSERR, but that generates a different text message
   than what the test programs are expecting.  So an errno value must
   be derived from the native status value when an error occurs.
   That will hide the true native status message.  With this version of
   perl, the true native child status can always be retrieved so that
   is not a problem.  But in this case, Pl_statusvalue and errno may
   have different values in them.
 */

#   define STATUS_NATIVE_CHILD_SET(n) \
	STMT_START {							\
	    I32 evalue = (I32)n;					\
	    if (evalue == EVMSERR) {					\
	      PL_statusvalue_vms = vaxc$errno;				\
	      PL_statusvalue = evalue;					\
	    } else {							\
	      PL_statusvalue_vms = evalue;				\
	      if (evalue == -1) {					\
		PL_statusvalue = -1;					\
		PL_statusvalue_vms = SS$_ABORT; /* Should not happen */ \
	      } else							\
		PL_statusvalue = Perl_vms_status_to_unix(evalue, 1);	\
	      set_vaxc_errno(evalue);					\
	      if ((PL_statusvalue_vms & C_FAC_POSIX) == C_FAC_POSIX)	\
		  set_errno(EVMSERR);					\
	      else set_errno(Perl_vms_status_to_unix(evalue, 0));	\
	      PL_statusvalue = PL_statusvalue << child_offset_bits;	\
	    }								\
	} STMT_END

#   ifdef VMSISH_STATUS
#	define STATUS_CURRENT	(VMSISH_STATUS ? STATUS_NATIVE : STATUS_UNIX)
#   else
#	define STATUS_CURRENT	STATUS_UNIX
#   endif

  /* STATUS_UNIX_SET - takes a UNIX/POSIX errno value and attempts to update
   * the NATIVE status to an equivalent value.  Can not be used to translate
   * exit code values as exit code values are not guaranteed to have any
   * relationship at all to errno values.
   * This is used when Perl is forcing errno to have a specific value.
   */
#   define STATUS_UNIX_SET(n)				\
	STMT_START {					\
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
	    if (PL_statusvalue != -1) {			\
		if (PL_statusvalue != EVMSERR) {	\
		  PL_statusvalue &= 0xFFFF;		\
		  if (MY_POSIX_EXIT)			\
		    PL_statusvalue_vms=PL_statusvalue ? SS$_ABORT : SS$_NORMAL;\
		  else PL_statusvalue_vms = Perl_unix_status_to_vms(evalue); \
		}					\
		else {					\
		  PL_statusvalue_vms = vaxc$errno;	\
		}					\
	    }						\
	    else PL_statusvalue_vms = SS$_ABORT;	\
	    set_vaxc_errno(PL_statusvalue_vms);		\
	} STMT_END

  /* STATUS_UNIX_EXIT_SET - Takes a UNIX/POSIX exit code and sets
   * the NATIVE error status based on it.
   *
   * When in the default mode to comply with the Perl VMS documentation,
   * 0 is a success and any other code sets the NATIVE status to a failure
   * code of SS$_ABORT.
   *
   * In the new POSIX EXIT mode, native status will be set so that the
   * actual exit code will can be retrieved by the calling program or
   * shell.
   *
   * If the exit code is not clearly a UNIX parent or child exit status,
   * it will be passed through as a VMS status.
   */

#   define STATUS_UNIX_EXIT_SET(n)			\
	STMT_START {					\
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
	    if (MY_POSIX_EXIT) { \
	      if (evalue <= 0xFF00) {		\
		  if (evalue > 0xFF)			\
		    evalue = (evalue >> child_offset_bits) & 0xFF; \
		  PL_statusvalue_vms =		\
		    (C_FAC_POSIX | (evalue << 3 ) |	\
		    ((evalue == 1) ? (STS$K_ERROR | STS$M_INHIB_MSG) : 1)); \
	      } else /* forgive them Perl, for they have sinned */ \
		PL_statusvalue_vms = evalue; \
	    } else { \
	      if (evalue == 0)			\
		PL_statusvalue_vms = SS$_NORMAL;	\
	      else if (evalue <= 0xFF00) \
		PL_statusvalue_vms = SS$_ABORT; \
	      else { /* forgive them Perl, for they have sinned */ \
		  if (evalue != EVMSERR) PL_statusvalue_vms = evalue; \
		  else PL_statusvalue_vms = vaxc$errno;	\
		  /* And obviously used a VMS status value instead of UNIX */ \
		  PL_statusvalue = EVMSERR;		\
	      } \
	      set_vaxc_errno(PL_statusvalue_vms);	\
	    }						\
	} STMT_END


  /* STATUS_EXIT_SET - Takes a NATIVE/UNIX/POSIX exit code
   * and sets the NATIVE error status based on it.  This special case
   * is needed to maintain compatibility with past VMS behavior.
   *
   * In the default mode on VMS, this number is passed through as
   * both the NATIVE and UNIX status.  Which makes it different
   * that the STATUS_UNIX_EXIT_SET.
   *
   * In the new POSIX EXIT mode, native status will be set so that the
   * actual exit code will can be retrieved by the calling program or
   * shell.
   *
   * A POSIX exit code is from 0 to 255.  If the exit code is higher
   * than this, it needs to be assumed that it is a VMS exit code and
   * passed through.
   */

#   define STATUS_EXIT_SET(n)				\
	STMT_START {					\
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
	    if (MY_POSIX_EXIT)				\
		if (evalue > 255) PL_statusvalue_vms = evalue; else {	\
		  PL_statusvalue_vms = \
		    (C_FAC_POSIX | (evalue << 3 ) |	\
		     ((evalue == 1) ? (STS$K_ERROR | STS$M_INHIB_MSG) : 1));} \
	    else					\
		PL_statusvalue_vms = evalue ? evalue : SS$_NORMAL; \
	    set_vaxc_errno(PL_statusvalue_vms);		\
	} STMT_END


 /* This macro forces a success status */
#   define STATUS_ALL_SUCCESS	\
	(PL_statusvalue = 0, PL_statusvalue_vms = SS$_NORMAL)

 /* This macro forces a failure status */
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, \
     vaxc$errno = PL_statusvalue_vms = MY_POSIX_EXIT ? \
	(C_FAC_POSIX | (1 << 3) | STS$K_ERROR | STS$M_INHIB_MSG) : SS$_ABORT)

#else
#   define STATUS_NATIVE	PL_statusvalue_posix
#   if defined(WCOREDUMP)
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        (WIFEXITED(PL_statusvalue_posix) ? (WEXITSTATUS(PL_statusvalue_posix) << 8) : 0) |  \
                        (WIFSIGNALED(PL_statusvalue_posix) ? (WTERMSIG(PL_statusvalue_posix) & 0x7F) : 0) | \
                        (WIFSIGNALED(PL_statusvalue_posix) && WCOREDUMP(PL_statusvalue_posix) ? 0x80 : 0);  \
                }                                          \
            } STMT_END
#   elif defined(WIFEXITED)
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        (WIFEXITED(PL_statusvalue_posix) ? (WEXITSTATUS(PL_statusvalue_posix) << 8) : 0) |  \
                        (WIFSIGNALED(PL_statusvalue_posix) ? (WTERMSIG(PL_statusvalue_posix) & 0x7F) : 0);  \
                }                                          \
            } STMT_END
#   else
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        PL_statusvalue_posix & 0xFFFF;     \
                }                                          \
            } STMT_END
#   endif
#   define STATUS_UNIX_SET(n)		\
	STMT_START {			\
	    PL_statusvalue = (n);		\
	    if (PL_statusvalue != -1)	\
		PL_statusvalue &= 0xFFFF;	\
	} STMT_END
#   define STATUS_UNIX_EXIT_SET(n) STATUS_UNIX_SET(n)
#   define STATUS_EXIT_SET(n) STATUS_UNIX_SET(n)
#   define STATUS_CURRENT STATUS_UNIX
#   define STATUS_EXIT STATUS_UNIX
#   define STATUS_ALL_SUCCESS	(PL_statusvalue = 0, PL_statusvalue_posix = 0)
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, PL_statusvalue_posix = 1)
#endif

/* flags in PL_exit_flags for nature of exit() */
#define PERL_EXIT_EXPECTED	0x01
#define PERL_EXIT_DESTRUCT_END  0x02  /* Run END in perl_destruct */
#define PERL_EXIT_WARN		0x04  /* Warn if Perl_my_exit() or Perl_my_failure_exit() called */
#define PERL_EXIT_ABORT		0x08  /* Call abort() if Perl_my_exit() or Perl_my_failure_exit() called */

#ifndef PERL_CORE
/* format to use for version numbers in file/directory names */
/* XXX move to Configure? */
/* This was only ever used for the current version, and that can be done at
   compile time, as PERL_FS_VERSION, so should we just delete it?  */
#  ifndef PERL_FS_VER_FMT
#    define PERL_FS_VER_FMT	"%d.%d.%d"
#  endif
#endif

#ifndef PERL_FS_VERSION
#  define PERL_FS_VERSION	PERL_VERSION_STRING
#endif

/* This defines a way to flush all output buffers.  This may be a
 * performance issue, so we allow people to disable it.  Also, if
 * we are using stdio, there are broken implementations of fflush(NULL)
 * out there, Solaris being the most prominent.
 */
#ifndef PERL_FLUSHALL_FOR_CHILD
# if defined(USE_PERLIO) || defined(FFLUSH_NULL)
#  define PERL_FLUSHALL_FOR_CHILD	PerlIO_flush((PerlIO*)NULL)
# else
#  ifdef FFLUSH_ALL
#   define PERL_FLUSHALL_FOR_CHILD	my_fflush_all()
#  else
#   define PERL_FLUSHALL_FOR_CHILD	NOOP
#  endif
# endif
#endif

#ifndef PERL_WAIT_FOR_CHILDREN
#  define PERL_WAIT_FOR_CHILDREN	NOOP
#endif

/* the traditional thread-unsafe notion of "current interpreter". */
#ifndef PERL_SET_INTERP
#  define PERL_SET_INTERP(i)		(PL_curinterp = (PerlInterpreter*)(i))
#endif

#ifndef PERL_GET_INTERP
#  define PERL_GET_INTERP		(PL_curinterp)
#endif

#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_GET_THX)
#  ifdef MULTIPLICITY
#    define PERL_GET_THX		((PerlInterpreter *)PERL_GET_CONTEXT)
#  endif
#  define PERL_SET_THX(t)		PERL_SET_CONTEXT(t)
#endif

/*
    This replaces the previous %_ "hack" by the "%p" hacks.
    All that is required is that the perl source does not
    use "%-p" or "%-<number>p" or "%<number>p" formats.
    These formats will still work in perl code.
    See comments in sv.c for further details.

    Robin Barker 2005-07-14

    No longer use %1p for VDf = %vd.  RMB 2007-10-19
*/

#ifndef SVf_
#  define SVf_(n) "-" STRINGIFY(n) "p"
#endif

#ifndef SVf
#  define SVf "-p"
#endif

#ifndef SVf32
#  define SVf32 SVf_(32)
#endif

#ifndef SVf256
#  define SVf256 SVf_(256)
#endif

#define SVfARG(p) ((void*)(p))

#ifndef HEKf
#  define HEKf "2p"
#endif

/* Not ideal, but we cannot easily include a number in an already-numeric
 * format sequence. */
#ifndef HEKf256
#  define HEKf256 "3p"
#endif

#define HEKfARG(p) ((void*)(p))

/* Takes three arguments: is_utf8, length, str */
#ifndef UTF8f
#  define UTF8f "d%" UVuf "%4p"
#endif
#define UTF8fARG(u,l,p) (int)cBOOL(u), (UV)(l), (void*)(p)

#ifdef PERL_CORE
/* not used; but needed for backward compatibility with XS code? - RMB */
#  undef UVf
#else
#  ifndef UVf
#    define UVf UVuf
#  endif
#endif

#ifdef HASATTRIBUTE_DEPRECATED
#  define __attribute__deprecated__         __attribute__((deprecated))
#endif
#ifdef HASATTRIBUTE_FORMAT
#  define __attribute__format__(x,y,z)      __attribute__((format(x,y,z)))
#endif
#ifdef HASATTRIBUTE_MALLOC
#  define __attribute__malloc__             __attribute__((__malloc__))
#endif
#ifdef HASATTRIBUTE_NONNULL
#  define __attribute__nonnull__(a)         __attribute__((nonnull(a)))
#endif
#ifdef HASATTRIBUTE_NORETURN
#  define __attribute__noreturn__           __attribute__((noreturn))
#endif
#ifdef HASATTRIBUTE_PURE
#  define __attribute__pure__               __attribute__((pure))
#endif
#ifdef HASATTRIBUTE_UNUSED
#  define __attribute__unused__             __attribute__((unused))
#endif
#ifdef HASATTRIBUTE_WARN_UNUSED_RESULT
#  define __attribute__warn_unused_result__ __attribute__((warn_unused_result))
#endif

/* If we haven't defined the attributes yet, define them to blank. */
#ifndef __attribute__deprecated__
#  define __attribute__deprecated__
#endif
#ifndef __attribute__format__
#  define __attribute__format__(x,y,z)
#endif
#ifndef __attribute__malloc__
#  define __attribute__malloc__
#endif
#ifndef __attribute__nonnull__
#  define __attribute__nonnull__(a)
#endif
#ifndef __attribute__noreturn__
#  define __attribute__noreturn__
#endif
#ifndef __attribute__pure__
#  define __attribute__pure__
#endif
#ifndef __attribute__unused__
#  define __attribute__unused__
#endif
#ifndef __attribute__warn_unused_result__
#  define __attribute__warn_unused_result__
#endif

/* For functions that are marked as __attribute__noreturn__, it's not
   appropriate to call return.  In either case, include the lint directive.
 */
#ifdef HASATTRIBUTE_NORETURN
#  define NORETURN_FUNCTION_END NOT_REACHED; /* NOTREACHED */
#else
#  define NORETURN_FUNCTION_END NOT_REACHED; /* NOTREACHED */ return 0
#endif

/* Some OS warn on NULL format to printf */
#ifdef PRINTF_FORMAT_NULL_OK
#  define __attribute__format__null_ok__(x,y,z)  __attribute__format__(x,y,z)
#else
#  define __attribute__format__null_ok__(x,y,z)
#endif

#ifdef HAS_BUILTIN_EXPECT
#  define EXPECT(expr,val)                  __builtin_expect(expr,val)
#else
#  define EXPECT(expr,val)                  (expr)
#endif
#define LIKELY(cond)                        EXPECT(cBOOL(cond),TRUE)
#define UNLIKELY(cond)                      EXPECT(cBOOL(cond),FALSE)
#ifdef HAS_BUILTIN_CHOOSE_EXPR
/* placeholder */
#endif


#ifndef __has_builtin
#  define __has_builtin(x) 0 /* not a clang style compiler */
#endif

/* ASSUME is like assert(), but it has a benefit in a release build. It is a
   hint to a compiler about a statement of fact in a function call free
   expression, which allows the compiler to generate better machine code.
   In a debug build, ASSUME(x) is a synonym for assert(x). ASSUME(0) means
   the control path is unreachable. In a for loop, ASSUME can be used to hint
   that a loop will run atleast X times. ASSUME is based off MSVC's __assume
   intrinsic function, see its documents for more details.
*/

#ifndef DEBUGGING
#  if __has_builtin(__builtin_unreachable) \
     || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5 || __GNUC__ > 5) /* 4.5 -> */
#    define ASSUME(x) ((x) ? (void) 0 : __builtin_unreachable())
#  elif defined(_MSC_VER)
#    define ASSUME(x) __assume(x)
#  elif defined(__ARMCC_VERSION) /* untested */
#    define ASSUME(x) __promise(x)
#  else
/* a random compiler might define assert to its own special optimization token
   so pass it through to C lib as a last resort */
#    define ASSUME(x) assert(x)
#  endif
#else
#  define ASSUME(x) assert(x)
#endif

#define NOT_REACHED ASSUME(0)

/* Some unistd.h's give a prototype for pause() even though
   HAS_PAUSE ends up undefined.  This causes the #define
   below to be rejected by the compiler.  Sigh.
*/
#ifdef HAS_PAUSE
#define Pause	pause
#else
#define Pause() sleep((32767<<16)+32767)
#endif

#ifndef IOCPARM_LEN
#   ifdef IOCPARM_MASK
	/* on BSDish systems we're safe */
#	define IOCPARM_LEN(x)  (((x) >> 16) & IOCPARM_MASK)
#   else
#	if defined(_IOC_SIZE) && defined(__GLIBC__)
	/* on Linux systems we're safe; except when we're not [perl #38223] */
#	    define IOCPARM_LEN(x) (_IOC_SIZE(x) < 256 ? 256 : _IOC_SIZE(x))
#	else
	/* otherwise guess at what's safe */
#	    define IOCPARM_LEN(x)	256
#	endif
#   endif
#endif

#if defined(__CYGWIN__)
/* USEMYBINMODE
 *   This symbol, if defined, indicates that the program should
 *   use the routine my_binmode(FILE *fp, char iotype, int mode) to insure
 *   that a file is in "binary" mode -- that is, that no translation
 *   of bytes occurs on read or write operations.
 */
#  define USEMYBINMODE /**/
#  include <io.h> /* for setmode() prototype */
#  define my_binmode(fp, iotype, mode) \
            (PerlLIO_setmode(fileno(fp), mode) != -1 ? TRUE : FALSE)
#endif

#ifdef __CYGWIN__
void init_os_extras(void);
#endif

#ifdef UNION_ANY_DEFINITION
UNION_ANY_DEFINITION;
#else
union any {
    void*	any_ptr;
    I32		any_i32;
    U32		any_u32;
    IV		any_iv;
    UV		any_uv;
    long	any_long;
    bool	any_bool;
    void	(*any_dptr) (void*);
    void	(*any_dxptr) (pTHX_ void*);
};
#endif

typedef I32 (*filter_t) (pTHX_ int, SV *, int);

#define FILTER_READ(idx, sv, len)  filter_read(idx, sv, len)
#define FILTER_DATA(idx) \
	    (PL_parser ? AvARRAY(PL_parser->rsfp_filters)[idx] : NULL)
#define FILTER_ISREADER(idx) \
	    (PL_parser && PL_parser->rsfp_filters \
		&& idx >= AvFILLp(PL_parser->rsfp_filters))
#define PERL_FILTER_EXISTS(i) \
	    (PL_parser && PL_parser->rsfp_filters \
		&& (i) <= av_tindex(PL_parser->rsfp_filters))

#if defined(_AIX) && !defined(_AIX43)
#if defined(USE_REENTRANT) || defined(_REENTRANT) || defined(_THREAD_SAFE)
/* We cannot include <crypt.h> to get the struct crypt_data
 * because of setkey prototype problems when threading */
typedef        struct crypt_data {     /* straight from /usr/include/crypt.h */
    /* From OSF, Not needed in AIX
       char C[28], D[28];
    */
    char E[48];
    char KS[16][48];
    char block[66];
    char iobuf[16];
} CRYPTD;
#endif /* threading */
#endif /* AIX */

#if !defined(OS2)
#  include "iperlsys.h"
#endif

#ifdef __LIBCATAMOUNT__
#undef HAS_PASSWD  /* unixish.h but not unixish enough. */
#undef HAS_GROUP
#define FAKE_BIT_BUCKET
#endif

/* [perl #22371] Algorimic Complexity Attack on Perl 5.6.1, 5.8.0.
 * Note that the USE_HASH_SEED and USE_HASH_SEED_EXPLICIT are *NOT*
 * defined by Configure, despite their names being similar to the
 * other defines like USE_ITHREADS.  Configure in fact knows nothing
 * about the randomised hashes.  Therefore to enable/disable the hash
 * randomisation defines use the Configure -Accflags=... instead. */
#if !defined(NO_HASH_SEED) && !defined(USE_HASH_SEED) && !defined(USE_HASH_SEED_EXPLICIT)
#  define USE_HASH_SEED
#endif

/* Win32 defines a type 'WORD' in windef.h. This conflicts with the enumerator
 * 'WORD' defined in perly.h. The yytokentype enum is only a debugging aid, so
 * it's not really needed.
 */
#if defined(WIN32)
#  define YYTOKENTYPE
#endif
#include "perly.h"

#ifdef PERL_MAD
struct nexttoken {
    YYSTYPE next_val;	/* value of next token, if any */
    I32 next_type;	/* type of next token */
    MADPROP *next_mad;	/* everything else about that token */
};
#endif

/* macros to define bit-fields in structs. */
#ifndef PERL_BITFIELD8
#  define PERL_BITFIELD8 unsigned
#endif
#ifndef PERL_BITFIELD16
#  define PERL_BITFIELD16 unsigned
#endif
#ifndef PERL_BITFIELD32
#  define PERL_BITFIELD32 unsigned
#endif

#include "sv.h"
#include "regexp.h"
#include "util.h"
#include "form.h"
#include "gv.h"
#include "pad.h"
#include "cv.h"
#include "opnames.h"
#include "op.h"
#include "hv.h"
#include "cop.h"
#include "av.h"
#include "mg.h"
#include "scope.h"
#include "warnings.h"
#include "utf8.h"

/* these would be in doio.h if there was such a file */
#define my_stat()  my_stat_flags(SV_GMAGIC)
#define my_lstat() my_lstat_flags(SV_GMAGIC)

/* defined in sv.c, but also used in [ach]v.c */
#undef _XPV_HEAD
#undef _XPVMG_HEAD
#undef _XPVCV_COMMON

typedef struct _sublex_info SUBLEXINFO;
struct _sublex_info {
    U8 super_state;	/* lexer state to save */
    U16 sub_inwhat;	/* "lex_inwhat" to use */
    OP *sub_op;		/* "lex_op" to use */
    SV *repl;		/* replacement of s/// or y/// */
};

#include "parser.h"

typedef struct magic_state MGS;	/* struct magic_state defined in mg.c */

#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)

/* These have to be predeclared, as they are used in proto.h which is #included
 * before their definitions in regcomp.h. */

struct scan_data_t;
typedef struct regnode_charclass regnode_charclass;

struct regnode_charclass_class;

/* A hopefully less confusing name.  The sub-classes are all Posix classes only
 * used under /l matching */
typedef struct regnode_charclass_class regnode_charclass_posixl;

typedef struct regnode_ssc regnode_ssc;
typedef struct RExC_state_t RExC_state_t;
struct _reg_trie_data;

#endif

struct ptr_tbl_ent {
    struct ptr_tbl_ent*		next;
    const void*			oldval;
    void*			newval;
};

struct ptr_tbl {
    struct ptr_tbl_ent**	tbl_ary;
    UV				tbl_max;
    UV				tbl_items;
    struct ptr_tbl_arena	*tbl_arena;
    struct ptr_tbl_ent		*tbl_arena_next;
    struct ptr_tbl_ent		*tbl_arena_end;
};

#if defined(htonl) && !defined(HAS_HTONL)
#define HAS_HTONL
#endif
#if defined(htons) && !defined(HAS_HTONS)
#define HAS_HTONS
#endif
#if defined(ntohl) && !defined(HAS_NTOHL)
#define HAS_NTOHL
#endif
#if defined(ntohs) && !defined(HAS_NTOHS)
#define HAS_NTOHS
#endif
#ifndef HAS_HTONL
#define HAS_HTONS
#define HAS_HTONL
#define HAS_NTOHS
#define HAS_NTOHL
#  if (BYTEORDER & 0xffff) == 0x4321
/* Big endian system, so ntohl, ntohs, htonl and htons do not need to
   re-order their values. However, to behave identically to the alternative
   implementations, they should truncate to the correct size.  */
#    define ntohl(x)    ((x)&0xFFFFFFFF)
#    define htonl(x)    ntohl(x)
#    define ntohs(x)    ((x)&0xFFFF)
#    define htons(x)    ntohs(x)
#  elif BYTEORDER == 0x1234 || BYTEORDER == 0x12345678

/* Note that we can't straight out declare our own htonl and htons because
   the Win32 build process forcibly undefines HAS_HTONL etc for its miniperl,
   to avoid the overhead of initialising the socket subsystem, but the headers
   that *declare* the various functions are still seen. If we declare our own
   htonl etc they will clash with the declarations in the Win32 headers.  */

PERL_STATIC_INLINE U32
my_swap32(const U32 x) {
    return ((x & 0xFF) << 24) | ((x >> 24) & 0xFF)	
        | ((x & 0x0000FF00) << 8) | ((x & 0x00FF0000) >> 8);
}

PERL_STATIC_INLINE U16
my_swap16(const U16 x) {
    return ((x & 0xFF) << 8) | ((x >> 8) & 0xFF);
}

#    define htonl(x)    my_swap32(x)
#    define ntohl(x)    my_swap32(x)
#    define ntohs(x)    my_swap16(x)
#    define htons(x)    my_swap16(x)
#  else
#    error "Unsupported byteorder"
/* The C pre-processor doesn't let us return the value of BYTEORDER as part of
   the error message. Please check the value of the macro BYTEORDER, as defined
   in config.h. The values of BYTEORDER we expect are

	    big endian  little endian
   32 bit       0x4321  0x1234
   64 bit   0x87654321  0x12345678

   If you have a system with a different byte order, please see
   pod/perlhack.pod for how to submit a patch to add supporting code.
*/
#  endif
#endif

/*
 * Little-endian byte order functions - 'v' for 'VAX', or 'reVerse'.
 * -DWS
 */
#if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
/* Little endian system, so vtohl, vtohs, htovl and htovs do not need to
   re-order their values. However, to behave identically to the alternative
   implementations, they should truncate to the correct size.  */
#  define vtohl(x)      ((x)&0xFFFFFFFF)
#  define vtohs(x)      ((x)&0xFFFF)
#  define htovl(x)      vtohl(x)
#  define htovs(x)      vtohs(x)
#elif BYTEORDER == 0x4321 || BYTEORDER == 0x87654321
#  define vtohl(x)	((((x)&0xFF)<<24)	\
			+(((x)>>24)&0xFF)	\
			+(((x)&0x0000FF00)<<8)	\
			+(((x)&0x00FF0000)>>8)	)
#  define vtohs(x)	((((x)&0xFF)<<8) + (((x)>>8)&0xFF))
#  define htovl(x)	vtohl(x)
#  define htovs(x)	vtohs(x)
#else
#  error "Unsupported byteorder"
/* If you have need for current perl on PDP-11 or similar, and can help test
   that blead keeps working on a mixed-endian system, then see
   pod/perlhack.pod for how to submit patches to things working again.  */
#endif

/* *MAX Plus 1. A floating point value.
   Hopefully expressed in a way that dodgy floating point can't mess up.
   >> 2 rather than 1, so that value is safely less than I32_MAX after 1
   is added to it
   May find that some broken compiler will want the value cast to I32.
   [after the shift, as signed >> may not be as secure as unsigned >>]
*/
#define I32_MAX_P1 (2.0 * (1 + (((U32)I32_MAX) >> 1)))
#define U32_MAX_P1 (4.0 * (1 + ((U32_MAX) >> 2)))
/* For compilers that can't correctly cast NVs over 0x7FFFFFFF (or
   0x7FFFFFFFFFFFFFFF) to an unsigned integer. In the future, sizeof(UV)
   may be greater than sizeof(IV), so don't assume that half max UV is max IV.
*/
#define U32_MAX_P1_HALF (2.0 * (1 + ((U32_MAX) >> 2)))

#define UV_MAX_P1 (4.0 * (1 + ((UV_MAX) >> 2)))
#define IV_MAX_P1 (2.0 * (1 + (((UV)IV_MAX) >> 1)))
#define UV_MAX_P1_HALF (2.0 * (1 + ((UV_MAX) >> 2)))

/* This may look like unnecessary jumping through hoops, but converting
   out of range floating point values to integers *is* undefined behaviour,
   and it is starting to bite.
*/
#ifndef CAST_INLINE
#define I_32(what) (cast_i32((NV)(what)))
#define U_32(what) (cast_ulong((NV)(what)))
#define I_V(what) (cast_iv((NV)(what)))
#define U_V(what) (cast_uv((NV)(what)))
#else
#define I_32(n) ((n) < I32_MAX_P1 ? ((n) < I32_MIN ? I32_MIN : (I32) (n)) \
                  : ((n) < U32_MAX_P1 ? (I32)(U32) (n) \
                     : ((n) > 0 ? (I32) U32_MAX : 0 /* NaN */)))
#define U_32(n) ((n) < 0.0 ? ((n) < I32_MIN ? (UV) I32_MIN : (U32)(I32) (n)) \
                  : ((n) < U32_MAX_P1 ? (U32) (n) \
                     : ((n) > 0 ? U32_MAX : 0 /* NaN */)))
#define I_V(n) (LIKELY((n) < IV_MAX_P1) ? (UNLIKELY((n) < IV_MIN) ? IV_MIN : (IV) (n)) \
                  : (LIKELY((n) < UV_MAX_P1) ? (IV)(UV) (n) \
                     : ((n) > 0 ? (IV)UV_MAX : 0 /* NaN */)))
#define U_V(n) ((n) < 0.0 ? (UNLIKELY((n) < IV_MIN) ? (UV) IV_MIN : (UV)(IV) (n)) \
                  : (LIKELY((n) < UV_MAX_P1) ? (UV) (n) \
                     : ((n) > 0 ? UV_MAX : 0 /* NaN */)))
#endif

#define U_S(what) ((U16)U_32(what))
#define U_I(what) ((unsigned int)U_32(what))
#define U_L(what) U_32(what)

#ifdef HAS_SIGNBIT
#  define Perl_signbit signbit
#endif

/* These do not care about the fractional part, only about the range. */
#define NV_WITHIN_IV(nv) (I_V(nv) >= IV_MIN && I_V(nv) <= IV_MAX)
#define NV_WITHIN_UV(nv) ((nv)>=0.0 && U_V(nv) >= UV_MIN && U_V(nv) <= UV_MAX)

/* Used with UV/IV arguments: */
					/* XXXX: need to speed it up */
#define CLUMP_2UV(iv)	((iv) < 0 ? 0 : (UV)(iv))
#define CLUMP_2IV(uv)	((uv) > (UV)IV_MAX ? IV_MAX : (IV)(uv))

#ifndef MAXSYSFD
#   define MAXSYSFD 2
#endif

#ifndef __cplusplus
#if !(defined(WIN32) || defined(UNDER_CE) || defined(SYMBIAN))
Uid_t getuid (void);
Uid_t geteuid (void);
Gid_t getgid (void);
Gid_t getegid (void);
#endif
#endif

#ifndef Perl_debug_log
#  define Perl_debug_log	PerlIO_stderr()
#endif

#ifndef Perl_error_log
#  define Perl_error_log	(PL_stderrgv			\
				 && isGV(PL_stderrgv)		\
				 && GvIOp(PL_stderrgv)          \
				 && IoOFP(GvIOp(PL_stderrgv))	\
				 ? IoOFP(GvIOp(PL_stderrgv))	\
				 : PerlIO_stderr())
#endif


#define DEBUG_p_FLAG		0x00000001 /*      1 */
#define DEBUG_s_FLAG		0x00000002 /*      2 */
#define DEBUG_l_FLAG		0x00000004 /*      4 */
#define DEBUG_t_FLAG		0x00000008 /*      8 */
#define DEBUG_o_FLAG		0x00000010 /*     16 */
#define DEBUG_c_FLAG		0x00000020 /*     32 */
#define DEBUG_P_FLAG		0x00000040 /*     64 */
#define DEBUG_m_FLAG		0x00000080 /*    128 */
#define DEBUG_f_FLAG		0x00000100 /*    256 */
#define DEBUG_r_FLAG		0x00000200 /*    512 */
#define DEBUG_x_FLAG		0x00000400 /*   1024 */
#define DEBUG_u_FLAG		0x00000800 /*   2048 */
/* U is reserved for Unofficial, exploratory hacking */
#define DEBUG_U_FLAG		0x00001000 /*   4096 */
#define DEBUG_H_FLAG		0x00002000 /*   8192 */
#define DEBUG_X_FLAG		0x00004000 /*  16384 */
#define DEBUG_D_FLAG		0x00008000 /*  32768 */
#define DEBUG_S_FLAG		0x00010000 /*  65536 */
#define DEBUG_T_FLAG		0x00020000 /* 131072 */
#define DEBUG_R_FLAG		0x00040000 /* 262144 */
#define DEBUG_J_FLAG		0x00080000 /* 524288 */
#define DEBUG_v_FLAG		0x00100000 /*1048576 */
#define DEBUG_C_FLAG		0x00200000 /*2097152 */
#define DEBUG_A_FLAG		0x00400000 /*4194304 */
#define DEBUG_q_FLAG		0x00800000 /*8388608 */
#define DEBUG_M_FLAG		0x01000000 /*16777216*/
#define DEBUG_B_FLAG		0x02000000 /*33554432*/
#define DEBUG_L_FLAG		0x04000000 /*67108864*/
#define DEBUG_MASK		0x07FFEFFF /* mask of all the standard flags */

#define DEBUG_DB_RECURSE_FLAG	0x40000000
#define DEBUG_TOP_FLAG		0x80000000 /* XXX what's this for ??? Signal
					      that something was done? */

#  define DEBUG_p_TEST_ (PL_debug & DEBUG_p_FLAG)
#  define DEBUG_s_TEST_ (PL_debug & DEBUG_s_FLAG)
#  define DEBUG_l_TEST_ (PL_debug & DEBUG_l_FLAG)
#  define DEBUG_t_TEST_ (PL_debug & DEBUG_t_FLAG)
#  define DEBUG_o_TEST_ (PL_debug & DEBUG_o_FLAG)
#  define DEBUG_c_TEST_ (PL_debug & DEBUG_c_FLAG)
#  define DEBUG_P_TEST_ (PL_debug & DEBUG_P_FLAG)
#  define DEBUG_m_TEST_ (PL_debug & DEBUG_m_FLAG)
#  define DEBUG_f_TEST_ (PL_debug & DEBUG_f_FLAG)
#  define DEBUG_r_TEST_ (PL_debug & DEBUG_r_FLAG)
#  define DEBUG_x_TEST_ (PL_debug & DEBUG_x_FLAG)
#  define DEBUG_u_TEST_ (PL_debug & DEBUG_u_FLAG)
#  define DEBUG_U_TEST_ (PL_debug & DEBUG_U_FLAG)
#  define DEBUG_H_TEST_ (PL_debug & DEBUG_H_FLAG)
#  define DEBUG_X_TEST_ (PL_debug & DEBUG_X_FLAG)
#  define DEBUG_D_TEST_ (PL_debug & DEBUG_D_FLAG)
#  define DEBUG_S_TEST_ (PL_debug & DEBUG_S_FLAG)
#  define DEBUG_T_TEST_ (PL_debug & DEBUG_T_FLAG)
#  define DEBUG_R_TEST_ (PL_debug & DEBUG_R_FLAG)
#  define DEBUG_J_TEST_ (PL_debug & DEBUG_J_FLAG)
#  define DEBUG_v_TEST_ (PL_debug & DEBUG_v_FLAG)
#  define DEBUG_C_TEST_ (PL_debug & DEBUG_C_FLAG)
#  define DEBUG_A_TEST_ (PL_debug & DEBUG_A_FLAG)
#  define DEBUG_q_TEST_ (PL_debug & DEBUG_q_FLAG)
#  define DEBUG_M_TEST_ (PL_debug & DEBUG_M_FLAG)
#  define DEBUG_B_TEST_ (PL_debug & DEBUG_B_FLAG)
#  define DEBUG_L_TEST_ (PL_debug & DEBUG_L_FLAG)
#  define DEBUG_Xv_TEST_ (DEBUG_X_TEST_ && DEBUG_v_TEST_)
#  define DEBUG_Uv_TEST_ (DEBUG_U_TEST_ && DEBUG_v_TEST_)
#  define DEBUG_Pv_TEST_ (DEBUG_P_TEST_ && DEBUG_v_TEST_)

#ifdef DEBUGGING

#  define DEBUG_p_TEST DEBUG_p_TEST_
#  define DEBUG_s_TEST DEBUG_s_TEST_
#  define DEBUG_l_TEST DEBUG_l_TEST_
#  define DEBUG_t_TEST DEBUG_t_TEST_
#  define DEBUG_o_TEST DEBUG_o_TEST_
#  define DEBUG_c_TEST DEBUG_c_TEST_
#  define DEBUG_P_TEST DEBUG_P_TEST_
#  define DEBUG_m_TEST DEBUG_m_TEST_
#  define DEBUG_f_TEST DEBUG_f_TEST_
#  define DEBUG_r_TEST DEBUG_r_TEST_
#  define DEBUG_x_TEST DEBUG_x_TEST_
#  define DEBUG_u_TEST DEBUG_u_TEST_
#  define DEBUG_U_TEST DEBUG_U_TEST_
#  define DEBUG_H_TEST DEBUG_H_TEST_
#  define DEBUG_X_TEST DEBUG_X_TEST_
#  define DEBUG_D_TEST DEBUG_D_TEST_
#  define DEBUG_S_TEST DEBUG_S_TEST_
#  define DEBUG_T_TEST DEBUG_T_TEST_
#  define DEBUG_R_TEST DEBUG_R_TEST_
#  define DEBUG_J_TEST DEBUG_J_TEST_
#  define DEBUG_v_TEST DEBUG_v_TEST_
#  define DEBUG_C_TEST DEBUG_C_TEST_
#  define DEBUG_A_TEST DEBUG_A_TEST_
#  define DEBUG_q_TEST DEBUG_q_TEST_
#  define DEBUG_M_TEST DEBUG_M_TEST_
#  define DEBUG_B_TEST DEBUG_B_TEST_
#  define DEBUG_L_TEST DEBUG_L_TEST_
#  define DEBUG_Xv_TEST DEBUG_Xv_TEST_
#  define DEBUG_Uv_TEST DEBUG_Uv_TEST_
#  define DEBUG_Pv_TEST DEBUG_Pv_TEST_

#  define PERL_DEB(a)                  a
#  define PERL_DEBUG(a) if (PL_debug)  a
#  define DEBUG_p(a) if (DEBUG_p_TEST) a
#  define DEBUG_s(a) if (DEBUG_s_TEST) a
#  define DEBUG_l(a) if (DEBUG_l_TEST) a
#  define DEBUG_t(a) if (DEBUG_t_TEST) a
#  define DEBUG_o(a) if (DEBUG_o_TEST) a
#  define DEBUG_c(a) if (DEBUG_c_TEST) a
#  define DEBUG_P(a) if (DEBUG_P_TEST) a

     /* Temporarily turn off memory debugging in case the a
      * does memory allocation, either directly or indirectly. */
#  define DEBUG_m(a)  \
    STMT_START {							\
        if (PERL_GET_INTERP) { dTHX; if (DEBUG_m_TEST) {PL_debug&=~DEBUG_m_FLAG; a; PL_debug|=DEBUG_m_FLAG;} } \
    } STMT_END

#  define DEBUG__(t, a) \
	STMT_START { \
		if (t) STMT_START {a;} STMT_END; \
	} STMT_END

#  define DEBUG_f(a) DEBUG__(DEBUG_f_TEST, a)
#ifndef PERL_EXT_RE_BUILD
#  define DEBUG_r(a) DEBUG__(DEBUG_r_TEST, a)
#else
#  define DEBUG_r(a) STMT_START {a;} STMT_END
#endif /* PERL_EXT_RE_BUILD */
#  define DEBUG_x(a) DEBUG__(DEBUG_x_TEST, a)
#  define DEBUG_u(a) DEBUG__(DEBUG_u_TEST, a)
#  define DEBUG_U(a) DEBUG__(DEBUG_U_TEST, a)
#  define DEBUG_H(a) DEBUG__(DEBUG_H_TEST, a)
#  define DEBUG_X(a) DEBUG__(DEBUG_X_TEST, a)
#  define DEBUG_D(a) DEBUG__(DEBUG_D_TEST, a)
#  define DEBUG_Xv(a) DEBUG__(DEBUG_Xv_TEST, a)
#  define DEBUG_Uv(a) DEBUG__(DEBUG_Uv_TEST, a)
#  define DEBUG_Pv(a) DEBUG__(DEBUG_Pv_TEST, a)

#  define DEBUG_S(a) DEBUG__(DEBUG_S_TEST, a)
#  define DEBUG_T(a) DEBUG__(DEBUG_T_TEST, a)
#  define DEBUG_R(a) DEBUG__(DEBUG_R_TEST, a)
#  define DEBUG_v(a) DEBUG__(DEBUG_v_TEST, a)
#  define DEBUG_C(a) DEBUG__(DEBUG_C_TEST, a)
#  define DEBUG_A(a) DEBUG__(DEBUG_A_TEST, a)
#  define DEBUG_q(a) DEBUG__(DEBUG_q_TEST, a)
#  define DEBUG_M(a) DEBUG__(DEBUG_M_TEST, a)
#  define DEBUG_B(a) DEBUG__(DEBUG_B_TEST, a)
#  define DEBUG_L(a) DEBUG__(DEBUG_L_TEST, a)

#else /* DEBUGGING */

#  define DEBUG_p_TEST (0)
#  define DEBUG_s_TEST (0)
#  define DEBUG_l_TEST (0)
#  define DEBUG_t_TEST (0)
#  define DEBUG_o_TEST (0)
#  define DEBUG_c_TEST (0)
#  define DEBUG_P_TEST (0)
#  define DEBUG_m_TEST (0)
#  define DEBUG_f_TEST (0)
#  define DEBUG_r_TEST (0)
#  define DEBUG_x_TEST (0)
#  define DEBUG_u_TEST (0)
#  define DEBUG_U_TEST (0)
#  define DEBUG_H_TEST (0)
#  define DEBUG_X_TEST (0)
#  define DEBUG_D_TEST (0)
#  define DEBUG_S_TEST (0)
#  define DEBUG_T_TEST (0)
#  define DEBUG_R_TEST (0)
#  define DEBUG_J_TEST (0)
#  define DEBUG_v_TEST (0)
#  define DEBUG_C_TEST (0)
#  define DEBUG_A_TEST (0)
#  define DEBUG_q_TEST (0)
#  define DEBUG_M_TEST (0)
#  define DEBUG_B_TEST (0)
#  define DEBUG_L_TEST (0)
#  define DEBUG_Xv_TEST (0)
#  define DEBUG_Uv_TEST (0)
#  define DEBUG_Pv_TEST (0)

#  define PERL_DEB(a)
#  define PERL_DEBUG(a)
#  define DEBUG_p(a)
#  define DEBUG_s(a)
#  define DEBUG_l(a)
#  define DEBUG_t(a)
#  define DEBUG_o(a)
#  define DEBUG_c(a)
#  define DEBUG_P(a)
#  define DEBUG_m(a)
#  define DEBUG_f(a)
#  define DEBUG_r(a)
#  define DEBUG_x(a)
#  define DEBUG_u(a)
#  define DEBUG_U(a)
#  define DEBUG_H(a)
#  define DEBUG_X(a)
#  define DEBUG_D(a)
#  define DEBUG_S(a)
#  define DEBUG_T(a)
#  define DEBUG_R(a)
#  define DEBUG_v(a)
#  define DEBUG_C(a)
#  define DEBUG_A(a)
#  define DEBUG_q(a)
#  define DEBUG_M(a)
#  define DEBUG_B(a)
#  define DEBUG_L(a)
#  define DEBUG_Xv(a)
#  define DEBUG_Uv(a)
#  define DEBUG_Pv(a)
#endif /* DEBUGGING */


#define DEBUG_SCOPE(where) \
    DEBUG_l( \
    Perl_deb(aTHX_ "%s scope %ld (savestack=%ld) at %s:%d\n",	\
		    where, (long)PL_scopestack_ix, (long)PL_savestack_ix, \
		    __FILE__, __LINE__));

#if defined(DEBUGGING) && defined(I_ASSERT)
#  include <assert.h>
#endif

/* Keep the old croak based assert for those who want it, and as a fallback if
   the platform is so heretically non-ANSI that it can't assert.  */

#define Perl_assert(what)	PERL_DEB( 				\
	((what) ? ((void) 0) :						\
	    (Perl_croak_nocontext("Assertion %s failed: file \"" __FILE__ \
			"\", line %d", STRINGIFY(what), __LINE__),	\
	    (void) 0)))

#ifndef assert
#  define assert(what)	Perl_assert(what)
#endif
#ifdef DEBUGGING
#  define assert_(what)	assert(what),
#else
#  define assert_(what)
#endif

struct ufuncs {
    I32 (*uf_val)(pTHX_ IV, SV*);
    I32 (*uf_set)(pTHX_ IV, SV*);
    IV uf_index;
};

/* In pre-5.7-Perls the PERL_MAGIC_uvar magic didn't get the thread context.
 * XS code wanting to be backward compatible can do something
 * like the following:

#ifndef PERL_MG_UFUNC
#define PERL_MG_UFUNC(name,ix,sv) I32 name(IV ix, SV *sv)
#endif

static PERL_MG_UFUNC(foo_get, index, val)
{
    sv_setsv(val, ...);
    return TRUE;
}

-- Doug MacEachern

*/

#ifndef PERL_MG_UFUNC
#define PERL_MG_UFUNC(name,ix,sv) I32 name(pTHX_ IV ix, SV *sv)
#endif

/* Fix these up for __STDC__ */
#ifndef DONT_DECLARE_STD
char *mktemp (char*);
#ifndef atof
double atof (const char*);
#endif
#endif

#ifndef STANDARD_C
/* All of these are in stdlib.h or time.h for ANSI C */
Time_t time();
struct tm *gmtime(), *localtime();
#if defined(OEMVS)
char *(strchr)(), *(strrchr)();
char *(strcpy)(), *(strcat)();
#else
char *strchr(), *strrchr();
char *strcpy(), *strcat();
#endif
#endif /* ! STANDARD_C */


#ifdef I_MATH
#    include <math.h>
#else
START_EXTERN_C
	    double exp (double);
	    double log (double);
	    double log10 (double);
	    double sqrt (double);
	    double frexp (double,int*);
	    double ldexp (double,int);
	    double modf (double,double*);
	    double sin (double);
	    double cos (double);
	    double atan2 (double,double);
	    double pow (double,double);
END_EXTERN_C
#endif

#if !defined(NV_INF) && defined(USE_LONG_DOUBLE) && defined(LDBL_INFINITY)
#  define NV_INF LDBL_INFINITY
#endif
#if !defined(NV_INF) && defined(DBL_INFINITY)
#  define NV_INF (NV)DBL_INFINITY
#endif
#if !defined(NV_INF) && defined(INFINITY)
#  define NV_INF (NV)INFINITY
#endif
#if !defined(NV_INF) && defined(INF)
#  define NV_INF (NV)INF
#endif
#if !defined(NV_INF) && defined(USE_LONG_DOUBLE) && defined(HUGE_VALL)
#  define NV_INF (NV)HUGE_VALL
#endif
#if !defined(NV_INF) && defined(HUGE_VAL)
#  define NV_INF (NV)HUGE_VAL
#endif

#if !defined(NV_NAN) && defined(USE_LONG_DOUBLE)
#   if !defined(NV_NAN) && defined(LDBL_NAN)
#       define NV_NAN LDBL_NAN
#   endif
#   if !defined(NV_NAN) && defined(LDBL_QNAN)
#       define NV_NAN LDBL_QNAN
#   endif
#   if !defined(NV_NAN) && defined(LDBL_SNAN)
#       define NV_NAN LDBL_SNAN
#   endif
#endif
#if !defined(NV_NAN) && defined(DBL_NAN)
#  define NV_NAN (NV)DBL_NAN
#endif
#if !defined(NV_NAN) && defined(DBL_QNAN)
#  define NV_NAN (NV)DBL_QNAN
#endif
#if !defined(NV_NAN) && defined(DBL_SNAN)
#  define NV_NAN (NV)DBL_SNAN
#endif
#if !defined(NV_NAN) && defined(QNAN)
#  define NV_NAN (NV)QNAN
#endif
#if !defined(NV_NAN) && defined(SNAN)
#  define NV_NAN (NV)SNAN
#endif
#if !defined(NV_NAN) && defined(NAN)
#  define NV_NAN (NV)NAN
#endif

#ifndef __cplusplus
#  if defined(NeXT) || defined(__NeXT__) /* or whatever catches all NeXTs */
char *crypt ();       /* Maybe more hosts will need the unprototyped version */
#  else
#    if !defined(WIN32) && !defined(VMS)
#ifndef crypt
char *crypt (const char*, const char*);
#endif
#    endif /* !WIN32 */
#  endif /* !NeXT && !__NeXT__ */
#  ifndef DONT_DECLARE_STD
#    ifndef getenv
char *getenv (const char*);
#    endif /* !getenv */
#    if !defined(HAS_LSEEK_PROTO) && !defined(__hpux)
#      ifdef _FILE_OFFSET_BITS
#        if _FILE_OFFSET_BITS == 64
Off_t lseek (int,Off_t,int);
#        endif
#      endif
#    endif
#  endif /* !DONT_DECLARE_STD */
#  ifndef WIN32
#    ifndef getlogin
char *getlogin (void);
#    endif
#  endif /* !WIN32 */
#endif /* !__cplusplus */

/* Fixme on VMS.  This needs to be a run-time, not build time options */
/* Also rename() is affected by this */
#ifdef UNLINK_ALL_VERSIONS /* Currently only makes sense for VMS */
#define UNLINK unlnk
I32 unlnk (pTHX_ const char*);
#else
#define UNLINK PerlLIO_unlink
#endif

/* some versions of glibc are missing the setresuid() proto */
#if defined(HAS_SETRESUID) && !defined(HAS_SETRESUID_PROTO)
int setresuid(uid_t ruid, uid_t euid, uid_t suid);
#endif
/* some versions of glibc are missing the setresgid() proto */
#if defined(HAS_SETRESGID) && !defined(HAS_SETRESGID_PROTO)
int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
#endif

#ifndef HAS_SETREUID
#  ifdef HAS_SETRESUID
#    define setreuid(r,e) setresuid(r,e,(Uid_t)-1)
#    define HAS_SETREUID
#  endif
#endif
#ifndef HAS_SETREGID
#  ifdef HAS_SETRESGID
#    define setregid(r,e) setresgid(r,e,(Gid_t)-1)
#    define HAS_SETREGID
#  endif
#endif

/* Sighandler_t defined in iperlsys.h */

#ifdef HAS_SIGACTION
typedef struct sigaction Sigsave_t;
#else
typedef Sighandler_t Sigsave_t;
#endif

#define SCAN_DEF 0
#define SCAN_TR 1
#define SCAN_REPL 2

#ifdef DEBUGGING
# ifndef register
#  define register
# endif
# define RUNOPS_DEFAULT Perl_runops_debug
#else
# define RUNOPS_DEFAULT Perl_runops_standard
#endif

#if defined(USE_PERLIO)
EXTERN_C void PerlIO_teardown(void);
# ifdef USE_ITHREADS
#  define PERLIO_INIT MUTEX_INIT(&PL_perlio_mutex)
#  define PERLIO_TERM 				\
	STMT_START {				\
		PerlIO_teardown();		\
		MUTEX_DESTROY(&PL_perlio_mutex);\
	} STMT_END
# else
#  define PERLIO_INIT
#  define PERLIO_TERM	PerlIO_teardown()
# endif
#else
#  define PERLIO_INIT
#  define PERLIO_TERM
#endif

#ifdef MYMALLOC
#  ifdef MUTEX_INIT_CALLS_MALLOC
#    define MALLOC_INIT					\
	STMT_START {					\
		PL_malloc_mutex = NULL;			\
		MUTEX_INIT(&PL_malloc_mutex);		\
	} STMT_END
#    define MALLOC_TERM					\
	STMT_START {					\
		perl_mutex tmp = PL_malloc_mutex;	\
		PL_malloc_mutex = NULL;			\
		MUTEX_DESTROY(&tmp);			\
	} STMT_END
#  else
#    define MALLOC_INIT MUTEX_INIT(&PL_malloc_mutex)
#    define MALLOC_TERM MUTEX_DESTROY(&PL_malloc_mutex)
#  endif
#else
#  define MALLOC_INIT
#  define MALLOC_TERM
#endif

#if defined(PERL_IMPLICIT_CONTEXT)

struct perl_memory_debug_header;
struct perl_memory_debug_header {
  tTHX	interpreter;
#  if defined(PERL_POISON) || defined(PERL_DEBUG_READONLY_COW)
  MEM_SIZE size;
#  endif
  struct perl_memory_debug_header *prev;
  struct perl_memory_debug_header *next;
#  ifdef PERL_DEBUG_READONLY_COW
  bool readonly;
#  endif
};

#elif defined(PERL_DEBUG_READONLY_COW)

struct perl_memory_debug_header;
struct perl_memory_debug_header {
  MEM_SIZE size;
};

#endif

#if defined (PERL_TRACK_MEMPOOL) || defined (PERL_DEBUG_READONLY_COW)

#  define PERL_MEMORY_DEBUG_HEADER_SIZE \
        (sizeof(struct perl_memory_debug_header) + \
	(MEM_ALIGNBYTES - sizeof(struct perl_memory_debug_header) \
	 %MEM_ALIGNBYTES) % MEM_ALIGNBYTES)

#else
#  define PERL_MEMORY_DEBUG_HEADER_SIZE	0
#endif

#ifdef PERL_TRACK_MEMPOOL
# ifdef PERL_DEBUG_READONLY_COW
#  define INIT_TRACK_MEMPOOL(header, interp)			\
	STMT_START {						\
		(header).interpreter = (interp);		\
		(header).prev = (header).next = &(header);	\
		(header).readonly = 0;				\
	} STMT_END
# else
#  define INIT_TRACK_MEMPOOL(header, interp)			\
	STMT_START {						\
		(header).interpreter = (interp);		\
		(header).prev = (header).next = &(header);	\
	} STMT_END
# endif
# else
#  define INIT_TRACK_MEMPOOL(header, interp)
#endif

#ifdef I_MALLOCMALLOC
/* Needed for malloc_size(), malloc_good_size() on some systems */
#  include <malloc/malloc.h>
#endif

#ifdef MYMALLOC
#  define Perl_safesysmalloc_size(where)	Perl_malloced_size(where)
#else
#  if defined(HAS_MALLOC_SIZE) && !defined(PERL_DEBUG_READONLY_COW)
#    ifdef PERL_TRACK_MEMPOOL
#	define Perl_safesysmalloc_size(where)			\
	    (malloc_size(((char *)(where)) - PERL_MEMORY_DEBUG_HEADER_SIZE) - PERL_MEMORY_DEBUG_HEADER_SIZE)
#    else
#	define Perl_safesysmalloc_size(where) malloc_size(where)
#    endif
#  endif
#  ifdef HAS_MALLOC_GOOD_SIZE
#    ifdef PERL_TRACK_MEMPOOL
#	define Perl_malloc_good_size(how_much)			\
	    (malloc_good_size((how_much) + PERL_MEMORY_DEBUG_HEADER_SIZE) - PERL_MEMORY_DEBUG_HEADER_SIZE)
#    else
#	define Perl_malloc_good_size(how_much) malloc_good_size(how_much)
#    endif
#  else
/* Having this as the identity operation makes some code simpler.  */
#	define Perl_malloc_good_size(how_much)	(how_much)
#  endif
#endif

typedef int (*runops_proc_t)(pTHX);
typedef void (*share_proc_t) (pTHX_ SV *sv);
typedef int  (*thrhook_proc_t) (pTHX);
typedef OP* (*PPADDR_t[]) (pTHX);
typedef bool (*destroyable_proc_t) (pTHX_ SV *sv);
typedef void (*despatch_signals_proc_t) (pTHX);

/* NeXT has problems with crt0.o globals */
#if defined(__DYNAMIC__) && \
    (defined(NeXT) || defined(__NeXT__) || defined(PERL_DARWIN))
#  if defined(NeXT) || defined(__NeXT)
#    include <mach-o/dyld.h>
#    define environ (*environ_pointer)
EXT char *** environ_pointer;
#  else
#    if defined(PERL_DARWIN) && defined(PERL_CORE)
#      include <crt_externs.h>	/* for the env array */
#      define environ (*_NSGetEnviron())
#    endif
#  endif
#else
   /* VMS and some other platforms don't use the environ array */
#  ifdef USE_ENVIRON_ARRAY
#    if !defined(DONT_DECLARE_STD) || \
        (defined(__svr4__) && defined(__GNUC__) && defined(__sun)) || \
        defined(__sgi)
extern char **	environ;	/* environment variables supplied via exec */
#    endif
#  endif
#endif

#define PERL_PATCHLEVEL_H_IMPLICIT
#include "patchlevel.h"
#undef PERL_PATCHLEVEL_H_IMPLICIT

#define PERL_VERSION_STRING	STRINGIFY(PERL_REVISION) "." \
				STRINGIFY(PERL_VERSION) "." \
				STRINGIFY(PERL_SUBVERSION)

#define PERL_API_VERSION_STRING	STRINGIFY(PERL_API_REVISION) "." \
				STRINGIFY(PERL_API_VERSION) "." \
				STRINGIFY(PERL_API_SUBVERSION)

START_EXTERN_C

/* handy constants */
EXTCONST char PL_warn_uninit[]
  INIT("Use of uninitialized value%s%s%s");
EXTCONST char PL_warn_uninit_sv[]
  INIT("Use of uninitialized value%" SVf "%s%s");
EXTCONST char PL_warn_nosemi[]
  INIT("Semicolon seems to be missing");
EXTCONST char PL_warn_reserved[]
  INIT("Unquoted string \"%s\" may clash with future reserved word");
EXTCONST char PL_warn_nl[]
  INIT("Unsuccessful %s on filename containing newline");
EXTCONST char PL_no_wrongref[]
  INIT("Can't use %s ref as %s ref");
/* The core no longer needs these here. If you require the string constant,
   please inline a copy into your own code.  */
EXTCONST char PL_no_symref[] __attribute__deprecated__
  INIT("Can't use string (\"%.32s\") as %s ref while \"strict refs\" in use");
EXTCONST char PL_no_symref_sv[] __attribute__deprecated__
  INIT("Can't use string (\"%" SVf32 "\") as %s ref while \"strict refs\" in use");
EXTCONST char PL_no_usym[]
  INIT("Can't use an undefined value as %s reference");
EXTCONST char PL_no_aelem[]
  INIT("Modification of non-creatable array value attempted, subscript %d");
EXTCONST char PL_no_helem_sv[]
  INIT("Modification of non-creatable hash value attempted, subscript \"%" SVf "\"");
EXTCONST char PL_no_modify[]
  INIT("Modification of a read-only value attempted");
EXTCONST char PL_no_mem[sizeof("Out of memory!\n")]
  INIT("Out of memory!\n");
EXTCONST char PL_no_security[]
  INIT("Insecure dependency in %s%s");
EXTCONST char PL_no_sock_func[]
  INIT("Unsupported socket function \"%s\" called");
EXTCONST char PL_no_dir_func[]
  INIT("Unsupported directory function \"%s\" called");
EXTCONST char PL_no_func[]
  INIT("The %s function is unimplemented");
EXTCONST char PL_no_myglob[]
  INIT("\"%s\" variable %s can't be in a package");
EXTCONST char PL_no_localize_ref[]
  INIT("Can't localize through a reference");
EXTCONST char PL_memory_wrap[]
  INIT("panic: memory wrap");

EXTCONST char PL_Yes[]
  INIT("1");
EXTCONST char PL_No[]
  INIT("");
EXTCONST char PL_hexdigit[]
  INIT("0123456789abcdef0123456789ABCDEF");

/* This is constant on most architectures, a global on OS/2 */
#ifndef OS2
EXTCONST char PL_sh_path[]
  INIT(SH_PATH); /* full path of shell */
#endif

#ifdef CSH
EXTCONST char PL_cshname[]
  INIT(CSH);
#  define PL_cshlen	(sizeof(CSH "") - 1)
#endif

/* These are baked at compile time into any shared perl library.
   In future releases this will allow us in main() to sanity test the
   library we're linking against.  */

EXTCONST U8 PL_revision
  INIT(PERL_REVISION);
EXTCONST U8 PL_version
  INIT(PERL_VERSION);
EXTCONST U8 PL_subversion
  INIT(PERL_SUBVERSION);

EXTCONST char PL_uuemap[65]
  INIT("`!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_");

#ifdef DOINIT
EXTCONST char PL_uudmap[256] =
#  ifdef PERL_MICRO
#    include "uuudmap.h"
#  else
#    include "uudmap.h"
#  endif
;
EXTCONST char PL_bitcount[256] =
#  ifdef PERL_MICRO
#    include "ubitcount.h"
#else
#    include "bitcount.h"
#  endif
;
EXTCONST char* const PL_sig_name[] = { SIG_NAME };
EXTCONST int         PL_sig_num[]  = { SIG_NUM };
#else
EXTCONST char PL_uudmap[256];
EXTCONST char PL_bitcount[256];
EXTCONST char* const PL_sig_name[];
EXTCONST int         PL_sig_num[];
#endif

/* fast conversion and case folding tables.  The folding tables complement the
 * fold, so that 'a' maps to 'A' and 'A' maps to 'a', ignoring more complicated
 * folds such as outside the range or to multiple characters. */

#ifdef DOINIT
#ifndef EBCDIC

/* The EBCDIC fold table depends on the code page, and hence is found in
 * utfebcdic.h */

EXTCONST  unsigned char PL_fold[] = {
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};
EXTCONST  unsigned char PL_fold_latin1[] = {
    /* Full latin1 complement folding, except for three problematic code points:
     *	Micro sign (181 = 0xB5) and y with diearesis (255 = 0xFF) have their
     *	fold complements outside the Latin1 range, so can't match something
     *	that isn't in utf8.
     *	German lower case sharp s (223 = 0xDF) folds to two characters, 'ss',
     *	not one, so can't be represented in this table.
     *
     * All have to be specially handled */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181 /*micro */,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192+32,	193+32,	194+32,	195+32,	196+32,	197+32,	198+32,	199+32,
	200+32,	201+32,	202+32,	203+32,	204+32,	205+32,	206+32,	207+32,
	208+32,	209+32,	210+32,	211+32,	212+32,	213+32,	214+32,	215,
	216+32,	217+32,	218+32,	219+32,	220+32,	221+32,	222+32,	223 /* ss */,
	224-32,	225-32,	226-32,	227-32,	228-32,	229-32,	230-32,	231-32,
	232-32,	233-32,	234-32,	235-32,	236-32,	237-32,	238-32,	239-32,
	240-32,	241-32,	242-32,	243-32,	244-32,	245-32,	246-32,	247,
	248-32,	249-32,	250-32,	251-32,	252-32,	253-32,	254-32,
	255 /* y with diaeresis */
};

/* If these tables are accessed through ebcdic, the access will be converted to
 * latin1 first */
EXTCONST  unsigned char PL_latin1_lc[] = {  /* lowercasing */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	97,	98,	99,	100,	101,	102,	103,
	104,	105,	106,	107,	108,	109,	110,	111,
	112,	113,	114,	115,	116,	117,	118,	119,
	120,	121,	122,	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192+32,	193+32,	194+32,	195+32,	196+32,	197+32,	198+32,	199+32,
	200+32,	201+32,	202+32,	203+32,	204+32,	205+32,	206+32,	207+32,
	208+32,	209+32,	210+32,	211+32,	212+32,	213+32,	214+32,	215,
	216+32,	217+32,	218+32,	219+32,	220+32,	221+32,	222+32,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};

/* upper and title case of latin1 characters, modified so that the three tricky
 * ones are mapped to 255 (which is one of the three) */
EXTCONST  unsigned char PL_mod_latin1_uc[] = {
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	65,	66,	67,	68,	69,	70,	71,
	72,	73,	74,	75,	76,	77,	78,	79,
	80,	81,	82,	83,	84,	85,	86,	87,
	88,	89,	90,	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	255 /*micro*/,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,	255 /*sharp s*/,	
	224-32,	225-32,	226-32,	227-32,	228-32,	229-32,	230-32,	231-32,
	232-32,	233-32,	234-32,	235-32,	236-32,	237-32,	238-32,	239-32,
	240-32,	241-32,	242-32,	243-32,	244-32,	245-32,	246-32,	247,
	248-32,	249-32,	250-32,	251-32,	252-32,	253-32,	254-32,	255
};
#endif  /* !EBCDIC, but still in DOINIT */
#else	/* ! DOINIT */
#   ifndef EBCDIC
EXTCONST unsigned char PL_fold[];
EXTCONST unsigned char PL_fold_latin1[];
EXTCONST unsigned char PL_mod_latin1_uc[];
EXTCONST unsigned char PL_latin1_lc[];
#   endif
#endif

#ifndef PERL_GLOBAL_STRUCT /* or perlvars.h */
#ifdef DOINIT
EXT unsigned char PL_fold_locale[] = { /* Unfortunately not EXTCONST. */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};
#else
EXT unsigned char PL_fold_locale[]; /* Unfortunately not EXTCONST. */
#endif
#endif /* !PERL_GLOBAL_STRUCT */

#ifdef DOINIT
#ifdef EBCDIC
EXTCONST unsigned char PL_freq[] = {/* EBCDIC frequencies for mixed English/C */
    1,      2,      84,     151,    154,    155,    156,    157,
    165,    246,    250,    3,      158,    7,      18,     29,
    40,     51,     62,     73,     85,     96,     107,    118,
    129,    140,    147,    148,    149,    150,    152,    153,
    255,      6,      8,      9,     10,     11,     12,     13,
     14,     15,     24,     25,     26,     27,     28,    226,
     29,     30,     31,     32,     33,     43,     44,     45,
     46,     47,     48,     49,     50,     76,     77,     78,
     79,     80,     81,     82,     83,     84,     85,     86,
     87,     94,     95,    234,    181,    233,    187,    190,
    180,     96,     97,     98,     99,    100,    101,    102,
    104,    112,    182,    174,    236,    232,    229,    103,
    228,    226,    114,    115,    116,    117,    118,    119,
    120,    121,    122,    235,    176,    230,    194,    162,
    130,    131,    132,    133,    134,    135,    136,    137,
    138,    139,    201,    205,    163,    217,    220,    224,
    5,      248,    227,    244,    242,    255,    241,    231,
    240,    253,    16,     197,    19,     20,     21,     187,
    23,     169,    210,    245,    237,    249,    247,    239,
    168,    252,    34,     196,    36,     37,     38,     39,
    41,     42,     251,    254,    238,    223,    221,    213,
    225,    177,    52,     53,     54,     55,     56,     57,
    58,     59,     60,     61,     63,     64,     65,     66,
    67,     68,     69,     70,     71,     72,     74,     75,
    205,    208,    186,    202,    200,    218,    198,    179,
    178,    214,    88,     89,     90,     91,     92,     93,
    217,    166,    170,    207,    199,    209,    206,    204,
    160,    212,    105,    106,    108,    109,    110,    111,
    203,    113,    216,    215,    192,    175,    193,    243,
    172,    161,    123,    124,    125,    126,    127,    128,
    222,    219,    211,    195,    188,    193,    185,    184,
    191,    183,    141,    142,    143,    144,    145,    146
};
#else  /* ascii rather than ebcdic */
EXTCONST unsigned char PL_freq[] = {	/* letter frequencies for mixed English/C */
	1,	2,	84,	151,	154,	155,	156,	157,
	165,	246,	250,	3,	158,	7,	18,	29,
	40,	51,	62,	73,	85,	96,	107,	118,
	129,	140,	147,	148,	149,	150,	152,	153,
	255,	182,	224,	205,	174,	176,	180,	217,
	233,	232,	236,	187,	235,	228,	234,	226,
	222,	219,	211,	195,	188,	193,	185,	184,
	191,	183,	201,	229,	181,	220,	194,	162,
	163,	208,	186,	202,	200,	218,	198,	179,
	178,	214,	166,	170,	207,	199,	209,	206,
	204,	160,	212,	216,	215,	192,	175,	173,
	243,	172,	161,	190,	203,	189,	164,	230,
	167,	248,	227,	244,	242,	255,	241,	231,
	240,	253,	169,	210,	245,	237,	249,	247,
	239,	168,	252,	251,	254,	238,	223,	221,
	213,	225,	177,	197,	171,	196,	159,	4,
	5,	6,	8,	9,	10,	11,	12,	13,
	14,	15,	16,	17,	19,	20,	21,	22,
	23,	24,	25,	26,	27,	28,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	41,	42,	43,	44,	45,	46,	47,	48,
	49,	50,	52,	53,	54,	55,	56,	57,
	58,	59,	60,	61,	63,	64,	65,	66,
	67,	68,	69,	70,	71,	72,	74,	75,
	76,	77,	78,	79,	80,	81,	82,	83,
	86,	87,	88,	89,	90,	91,	92,	93,
	94,	95,	97,	98,	99,	100,	101,	102,
	103,	104,	105,	106,	108,	109,	110,	111,
	112,	113,	114,	115,	116,	117,	119,	120,
	121,	122,	123,	124,	125,	126,	127,	128,
	130,	131,	132,	133,	134,	135,	136,	137,
	138,	139,	141,	142,	143,	144,	145,	146
};
#endif
#else
EXTCONST unsigned char PL_freq[];
#endif

/* Although only used for debugging, these constants must be available in
 * non-debugging builds too, since they're used in ext/re/re_exec.c,
 * which has DEBUGGING enabled always */
#ifdef DOINIT
EXTCONST char* const PL_block_type[] = {
	"NULL",
	"WHEN",
	"BLOCK",
	"GIVEN",
	"LOOP_FOR",
	"LOOP_PLAIN",
	"LOOP_LAZYSV",
	"LOOP_LAZYIV",
	"SUB",
	"FORMAT",
	"EVAL",
	"SUBST"
};
#else
EXTCONST char* PL_block_type[];
#endif

/* These are all the compile time options that affect binary compatibility.
   Other compile time options that are binary compatible are in perl.c
   Both are combined for the output of perl -V
   However, this string will be embedded in any shared perl library, which will
   allow us add a comparison check in perlmain.c in the near future.  */
#ifdef DOINIT
EXTCONST char PL_bincompat_options[] =
#  ifdef DEBUG_LEAKING_SCALARS
			     " DEBUG_LEAKING_SCALARS"
#  endif
#  ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
			     " DEBUG_LEAKING_SCALARS_FORK_DUMP"
#  endif
#  ifdef FCRYPT
			     " FCRYPT"
#  endif
#  ifdef HAS_TIMES
			     " HAS_TIMES"
#  endif
#  ifdef HAVE_INTERP_INTERN
			     " HAVE_INTERP_INTERN"
#  endif
#  ifdef MULTIPLICITY
			     " MULTIPLICITY"
#  endif
#  ifdef MYMALLOC
			     " MYMALLOC"
#  endif
#  ifdef PERLIO_LAYERS
			     " PERLIO_LAYERS"
#  endif
#  ifdef PERL_DEBUG_READONLY_COW
			     " PERL_DEBUG_READONLY_COW"
#  endif
#  ifdef PERL_DEBUG_READONLY_OPS
			     " PERL_DEBUG_READONLY_OPS"
#  endif
#  ifdef PERL_GLOBAL_STRUCT
			     " PERL_GLOBAL_STRUCT"
#  endif
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
			     " PERL_GLOBAL_STRUCT_PRIVATE"
#  endif
#  ifdef PERL_IMPLICIT_CONTEXT
			     " PERL_IMPLICIT_CONTEXT"
#  endif
#  ifdef PERL_IMPLICIT_SYS
			     " PERL_IMPLICIT_SYS"
#  endif
#  ifdef PERL_MAD
			     " PERL_MAD"
#  endif
#  ifdef PERL_MICRO
			     " PERL_MICRO"
#  endif
#  ifdef PERL_NEED_APPCTX
			     " PERL_NEED_APPCTX"
#  endif
#  ifdef PERL_NEED_TIMESBASE
			     " PERL_NEED_TIMESBASE"
#  endif
#  ifdef PERL_OLD_COPY_ON_WRITE
			     " PERL_OLD_COPY_ON_WRITE"
#  endif
#  ifdef PERL_POISON
			     " PERL_POISON"
#  endif
#  ifdef PERL_SAWAMPERSAND
			     " PERL_SAWAMPERSAND"
#  endif
#  ifdef PERL_TRACK_MEMPOOL
			     " PERL_TRACK_MEMPOOL"
#  endif
#  ifdef PERL_USES_PL_PIDSTATUS
			     " PERL_USES_PL_PIDSTATUS"
#  endif
#  ifdef USE_64_BIT_ALL
			     " USE_64_BIT_ALL"
#  endif
#  ifdef USE_64_BIT_INT
			     " USE_64_BIT_INT"
#  endif
#  ifdef USE_IEEE
			     " USE_IEEE"
#  endif
#  ifdef USE_ITHREADS
			     " USE_ITHREADS"
#  endif
#  ifdef USE_LARGE_FILES
			     " USE_LARGE_FILES"
#  endif
#  ifdef USE_LOCALE_COLLATE
			     " USE_LOCALE_COLLATE"
#  endif
#  ifdef USE_LOCALE_NUMERIC
			     " USE_LOCALE_NUMERIC"
#  endif
#  ifdef USE_LONG_DOUBLE
			     " USE_LONG_DOUBLE"
#  endif
#  ifdef USE_PERLIO
			     " USE_PERLIO"
#  endif
#  ifdef USE_REENTRANT_API
			     " USE_REENTRANT_API"
#  endif
#  ifdef USE_SOCKS
			     " USE_SOCKS"
#  endif
#  ifdef VMS_DO_SOCKETS
			     " VMS_DO_SOCKETS"
#  endif
#  ifdef VMS_SHORTEN_LONG_SYMBOLS
			     " VMS_SHORTEN_LONG_SYMBOLS"
#  endif
#  ifdef VMS_WE_ARE_CASE_SENSITIVE
			     " VMS_SYMBOL_CASE_AS_IS"
#  endif
  "";
#else
EXTCONST char PL_bincompat_options[];
#endif

#ifndef PERL_SET_PHASE
#  define PERL_SET_PHASE(new_phase) \
    PHASE_CHANGE_PROBE(PL_phase_names[new_phase], PL_phase_names[PL_phase]); \
    PL_phase = new_phase;
#endif

/* The interpreter phases. If these ever change, PL_phase_names right below will
 * need to be updated accordingly. */
enum perl_phase {
    PERL_PHASE_CONSTRUCT	= 0,
    PERL_PHASE_START		= 1,
    PERL_PHASE_CHECK		= 2,
    PERL_PHASE_INIT		= 3,
    PERL_PHASE_RUN		= 4,
    PERL_PHASE_END		= 5,
    PERL_PHASE_DESTRUCT		= 6
};

#ifdef DOINIT
EXTCONST char *const PL_phase_names[] = {
    "CONSTRUCT",
    "START",
    "CHECK",
    "INIT",
    "RUN",
    "END",
    "DESTRUCT"
};
#else
EXTCONST char *const PL_phase_names[];
#endif

#ifndef PERL_CORE
/* Do not use this macro. It only exists for extensions that rely on PL_dirty
 * instead of using the newer PL_phase, which provides everything PL_dirty
 * provided, and more. */
#  define PL_dirty (PL_phase == PERL_PHASE_DESTRUCT)

#  define PL_amagic_generation PL_na
#endif /* !PERL_CORE */

#define PL_hints PL_compiling.cop_hints

END_EXTERN_C

/*****************************************************************************/
/* This lexer/parser stuff is currently global since yacc is hard to reenter */
/*****************************************************************************/
/* XXX This needs to be revisited, since BEGIN makes yacc re-enter... */

#ifdef __Lynx__
/* LynxOS defines these in scsi.h which is included via ioctl.h */
#ifdef FORMAT
#undef FORMAT
#endif
#ifdef SPACE
#undef SPACE
#endif
#endif

#define LEX_NOTPARSING		11	/* borrowed from toke.c */

typedef enum {
    XOPERATOR,
    XTERM,
    XREF,
    XSTATE,
    XBLOCK,
    XATTRBLOCK,
    XATTRTERM,
    XTERMBLOCK,
    XPOSTDEREF,
    XTERMORDORDOR /* evil hack */
    /* update exp_name[] in toke.c if adding to this enum */
} expectation;

/* Hints are now stored in a dedicated U32, so the bottom 8 bits are no longer
   special and there is no need for HINT_PRIVATE_MASK for COPs
   However, bitops store HINT_INTEGER in their op_private.

    NOTE: The typical module using these has the bit value hard-coded, so don't
    blindly change the values of these */
#define HINT_INTEGER		0x00000001 /* integer pragma */
#define HINT_STRICT_REFS	0x00000002 /* strict pragma */
#define HINT_LOCALE		0x00000004 /* locale pragma */
#define HINT_BYTES		0x00000008 /* bytes pragma */
#define HINT_LOCALE_NOT_CHARS	0x00000010 /* locale ':not_characters' pragma */

#define HINT_EXPLICIT_STRICT_REFS	0x00000020 /* strict.pm */
#define HINT_EXPLICIT_STRICT_SUBS	0x00000040 /* strict.pm */
#define HINT_EXPLICIT_STRICT_VARS	0x00000080 /* strict.pm */

#define HINT_BLOCK_SCOPE	0x00000100
#define HINT_STRICT_SUBS	0x00000200 /* strict pragma */
#define HINT_STRICT_VARS	0x00000400 /* strict pragma */
#define HINT_UNI_8_BIT		0x00000800 /* unicode_strings feature */

/* The HINT_NEW_* constants are used by the overload pragma */
#define HINT_NEW_INTEGER	0x00001000
#define HINT_NEW_FLOAT		0x00002000
#define HINT_NEW_BINARY		0x00004000
#define HINT_NEW_STRING		0x00008000
#define HINT_NEW_RE		0x00010000
#define HINT_LOCALIZE_HH	0x00020000 /* %^H needs to be copied */
#define HINT_LEXICAL_IO_IN	0x00040000 /* ${^OPEN} is set for input */
#define HINT_LEXICAL_IO_OUT	0x00080000 /* ${^OPEN} is set for output */

#define HINT_RE_TAINT		0x00100000 /* re pragma */
#define HINT_RE_EVAL		0x00200000 /* re pragma */

#define HINT_FILETEST_ACCESS	0x00400000 /* filetest pragma */
#define HINT_UTF8		0x00800000 /* utf8 pragma */

#define HINT_NO_AMAGIC		0x01000000 /* overloading pragma */

#define HINT_RE_FLAGS		0x02000000 /* re '/xism' pragma */

#define HINT_FEATURE_MASK	0x1c000000 /* 3 bits for feature bundles */

				/* Note: Used for NATIVE_HINTS, currently
				   defined by vms/vmsish.h:
				0x40000000
				0x80000000
				 */

/* The following are stored in $^H{sort}, not in PL_hints */
#define HINT_SORT_SORT_BITS	0x000000FF /* allow 256 different ones */
#define HINT_SORT_QUICKSORT	0x00000001
#define HINT_SORT_MERGESORT	0x00000002
#define HINT_SORT_STABLE	0x00000100 /* sort styles (currently one) */

/* flags for PL_sawampersand */

#define SAWAMPERSAND_LEFT       1   /* saw $` */
#define SAWAMPERSAND_MIDDLE     2   /* saw $& */
#define SAWAMPERSAND_RIGHT      4   /* saw $' */

#ifndef PERL_SAWAMPERSAND
# define PL_sawampersand \
	(SAWAMPERSAND_LEFT|SAWAMPERSAND_MIDDLE|SAWAMPERSAND_RIGHT)
#endif

/* Various states of the input record separator SV (rs) */
#define RsSNARF(sv)   (! SvOK(sv))
#define RsSIMPLE(sv)  (SvOK(sv) && (! SvPOK(sv) || SvCUR(sv)))
#define RsPARA(sv)    (SvPOK(sv) && ! SvCUR(sv))
#define RsRECORD(sv)  (SvROK(sv) && (SvIV(SvRV(sv)) > 0))

/* A struct for keeping various DEBUGGING related stuff,
 * neatly packed.  Currently only scratch variables for
 * constructing debug output are included.  Needed always,
 * not just when DEBUGGING, though, because of the re extension. c*/
struct perl_debug_pad {
  SV pad[3];
};

#define PERL_DEBUG_PAD(i)	&(PL_debug_pad.pad[i])
#define PERL_DEBUG_PAD_ZERO(i)	(SvPVX(PERL_DEBUG_PAD(i))[0] = 0, \
	(((XPV*) SvANY(PERL_DEBUG_PAD(i)))->xpv_cur = 0), \
	PERL_DEBUG_PAD(i))

/* Enable variables which are pointers to functions */
typedef void (*peep_t)(pTHX_ OP* o);
typedef regexp* (*regcomp_t) (pTHX_ char* exp, char* xend, PMOP* pm);
typedef I32     (*regexec_t) (pTHX_ regexp* prog, char* stringarg,
				      char* strend, char* strbeg, I32 minend,
				      SV* screamer, void* data, U32 flags);
typedef char*   (*re_intuit_start_t) (pTHX_ regexp *prog, SV *sv,
						char *strpos, char *strend,
						U32 flags,
						re_scream_pos_data *d);
typedef SV*	(*re_intuit_string_t) (pTHX_ regexp *prog);
typedef void	(*regfree_t) (pTHX_ struct regexp* r);
typedef regexp* (*regdupe_t) (pTHX_ const regexp* r, CLONE_PARAMS *param);
typedef I32     (*re_fold_t)(const char *, char const *, I32);

typedef void (*DESTRUCTORFUNC_NOCONTEXT_t) (void*);
typedef void (*DESTRUCTORFUNC_t) (pTHX_ void*);
typedef void (*SVFUNC_t) (pTHX_ SV* const);
typedef I32  (*SVCOMPARE_t) (pTHX_ SV* const, SV* const);
typedef void (*XSINIT_t) (pTHX);
typedef void (*ATEXIT_t) (pTHX_ void*);
typedef void (*XSUBADDR_t) (pTHX_ CV *);

typedef OP* (*Perl_ppaddr_t)(pTHX);
typedef OP* (*Perl_check_t) (pTHX_ OP*);
typedef void(*Perl_ophook_t)(pTHX_ OP*);
typedef int (*Perl_keyword_plugin_t)(pTHX_ char*, STRLEN, OP**);
typedef void(*Perl_cpeep_t)(pTHX_ OP *, OP *);

typedef void(*globhook_t)(pTHX);

#define KEYWORD_PLUGIN_DECLINE 0
#define KEYWORD_PLUGIN_STMT    1
#define KEYWORD_PLUGIN_EXPR    2

/* Interpreter exitlist entry */
typedef struct exitlistentry {
    void (*fn) (pTHX_ void*);
    void *ptr;
} PerlExitListEntry;

/* if you only have signal() and it resets on each signal, FAKE_PERSISTENT_SIGNAL_HANDLERS fixes */
/* These have to be before perlvars.h */
#if !defined(HAS_SIGACTION) && defined(VMS)
#  define  FAKE_PERSISTENT_SIGNAL_HANDLERS
#endif
/* if we're doing kill() with sys$sigprc on VMS, FAKE_DEFAULT_SIGNAL_HANDLERS */
#if defined(KILL_BY_SIGPRC)
#  define  FAKE_DEFAULT_SIGNAL_HANDLERS
#endif

#if !defined(MULTIPLICITY)

struct interpreter {
    char broiled;
};

#else

/* If we have multiple interpreters define a struct
   holding variables which must be per-interpreter
   If we don't have threads anything that would have
   be per-thread is per-interpreter.
*/

/* Set up PERLVAR macros for populating structs */
#  define PERLVAR(prefix,var,type) type prefix##var;

/* 'var' is an array of length 'n' */
#  define PERLVARA(prefix,var,n,type) type prefix##var[n];

/* initialize 'var' to init' */
#  define PERLVARI(prefix,var,type,init) type prefix##var;

/* like PERLVARI, but make 'var' a const */
#  define PERLVARIC(prefix,var,type,init) type prefix##var;

struct interpreter {
#  include "intrpvar.h"
};

EXTCONST U16 PL_interp_size
  INIT(sizeof(struct interpreter));

#  define PERL_INTERPRETER_SIZE_UPTO_MEMBER(member)			\
    STRUCT_OFFSET(struct interpreter, member) +				\
    sizeof(((struct interpreter*)0)->member)

/* This will be useful for subsequent releases, because this has to be the
   same in your libperl as in main(), else you have a mismatch and must abort.
*/
EXTCONST U16 PL_interp_size_5_18_0
  INIT(PERL_INTERPRETER_SIZE_UPTO_MEMBER(PERL_LAST_5_18_0_INTERP_MEMBER));


#  ifdef PERL_GLOBAL_STRUCT
/* MULTIPLICITY is automatically defined when PERL_GLOBAL_STRUCT is defined,
   hence it's safe and sane to nest this within #ifdef MULTIPLICITY  */

struct perl_vars {
#    include "perlvars.h"
};

EXTCONST U16 PL_global_struct_size
  INIT(sizeof(struct perl_vars));

#    ifdef PERL_CORE
#      ifndef PERL_GLOBAL_STRUCT_PRIVATE
EXT struct perl_vars PL_Vars;
EXT struct perl_vars *PL_VarsPtr INIT(&PL_Vars);
#        undef PERL_GET_VARS
#        define PERL_GET_VARS() PL_VarsPtr
#      endif /* !PERL_GLOBAL_STRUCT_PRIVATE */
#    else /* PERL_CORE */
#      if !defined(__GNUC__) || !defined(WIN32)
EXT
#      endif /* WIN32 */
struct perl_vars *PL_VarsPtr;
#      define PL_Vars (*((PL_VarsPtr) \
		       ? PL_VarsPtr : (PL_VarsPtr = Perl_GetVars(aTHX))))
#    endif /* PERL_CORE */
#  endif /* PERL_GLOBAL_STRUCT */

/* Done with PERLVAR macros for now ... */
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC

#endif /* MULTIPLICITY */

struct tempsym; /* defined in pp_pack.c */

#include "thread.h"
#include "pp.h"

#ifndef PERL_CALLCONV
#  ifdef __cplusplus
#    define PERL_CALLCONV extern "C"
#  else
#    define PERL_CALLCONV
#  endif
#endif
#ifndef PERL_CALLCONV_NO_RET
#    define PERL_CALLCONV_NO_RET PERL_CALLCONV
#endif

/* PERL_STATIC_NO_RET is supposed to be equivalent to STATIC on builds that
   dont have a noreturn as a declaration specifier
*/
#ifndef PERL_STATIC_NO_RET
#  define PERL_STATIC_NO_RET STATIC
#endif
/* PERL_STATIC_NO_RET is supposed to be equivalent to PERL_STATIC_INLINE on
   builds that dont have a noreturn as a declaration specifier
*/
#ifndef PERL_STATIC_INLINE_NO_RET
#  define PERL_STATIC_INLINE_NO_RET PERL_STATIC_INLINE
#endif


#undef PERL_CKDEF
#undef PERL_PPDEF
#define PERL_CKDEF(s)	PERL_CALLCONV OP *s (pTHX_ OP *o);
#define PERL_PPDEF(s)	PERL_CALLCONV OP *s (pTHX);

#ifdef MYMALLOC
#  include "malloc_ctl.h"
#endif

#include "proto.h"

/* this has structure inits, so it cannot be included before here */
#include "opcode.h"

/* The following must follow proto.h as #defines mess up syntax */

#if !defined(PERL_FOR_X2P)
#  include "embedvar.h"
#endif
#ifndef PERL_MAD
#  undef PL_madskills
#  undef PL_xmlfp
#  define PL_madskills 0
#  define PL_xmlfp 0
#endif

/* Now include all the 'global' variables
 * If we don't have threads or multiple interpreters
 * these include variables that would have been their struct-s
 */

#define PERLVAR(prefix,var,type) EXT type PL_##var;
#define PERLVARA(prefix,var,n,type) EXT type PL_##var[n];
#define PERLVARI(prefix,var,type,init) EXT type  PL_##var INIT(init);
#define PERLVARIC(prefix,var,type,init) EXTCONST type PL_##var INIT(init);

#if !defined(MULTIPLICITY)
START_EXTERN_C
#  include "intrpvar.h"
END_EXTERN_C
#endif

#ifdef PERL_CORE
/* All core uses now exterminated. Ensure no zombies can return:  */
#  undef PL_na
#endif

/* Now all the config stuff is setup we can include embed.h
   In particular, need the relevant *ish file included already, as it may
   define HAVE_INTERP_INTERN  */
#include "embed.h"
#ifndef PERL_MAD
#  undef op_getmad
#  define op_getmad(arg,pegop,slot) NOOP
#endif

#ifndef PERL_GLOBAL_STRUCT
START_EXTERN_C

#  include "perlvars.h"

END_EXTERN_C
#endif

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC

START_EXTERN_C

/* dummy variables that hold pointers to both runops functions, thus forcing
 * them *both* to get linked in (useful for Peek.xs, debugging etc) */

EXTCONST runops_proc_t PL_runops_std
  INIT(Perl_runops_standard);
EXTCONST runops_proc_t PL_runops_dbg
  INIT(Perl_runops_debug);

/* PERL_GLOBAL_STRUCT_PRIVATE wants to keep global data like the
 * magic vtables const, but this is incompatible with SWIG which
 * does want to modify the vtables. */
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
#  define EXT_MGVTBL EXTCONST MGVTBL
#else
#  define EXT_MGVTBL EXT MGVTBL
#endif

#define PERL_MAGIC_READONLY_ACCEPTABLE 0x40
#define PERL_MAGIC_VALUE_MAGIC 0x80
#define PERL_MAGIC_VTABLE_MASK 0x3F
#define PERL_MAGIC_TYPE_READONLY_ACCEPTABLE(t) \
    (PL_magic_data[(U8)(t)] & PERL_MAGIC_READONLY_ACCEPTABLE)
#define PERL_MAGIC_TYPE_IS_VALUE_MAGIC(t) \
    (PL_magic_data[(U8)(t)] & PERL_MAGIC_VALUE_MAGIC)

#include "mg_vtable.h"

#ifdef DOINIT
EXTCONST U8 PL_magic_data[256] =
#  ifdef PERL_MICRO
#    include "umg_data.h"
#  else
#    include "mg_data.h"
#  endif
;
#else
EXTCONST U8 PL_magic_data[256];
#endif

#ifdef DOINIT
		        /* NL IV NV PV INV PI PN MG RX GV LV AV HV CV FM IO */
EXTCONST bool
PL_valid_types_IVX[]    = { 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0 };
EXTCONST bool
PL_valid_types_NVX[]    = { 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0 };
EXTCONST bool
PL_valid_types_PVX[]    = { 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1 };
EXTCONST bool
PL_valid_types_RV[]     = { 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1 };
EXTCONST bool
PL_valid_types_IV_set[] = { 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1 };
EXTCONST bool
PL_valid_types_NV_set[] = { 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };

#else

EXTCONST bool PL_valid_types_IVX[];
EXTCONST bool PL_valid_types_NVX[];
EXTCONST bool PL_valid_types_PVX[];
EXTCONST bool PL_valid_types_RV[];
EXTCONST bool PL_valid_types_IV_set[];
EXTCONST bool PL_valid_types_NV_set[];

#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
/* Static inline funcs that depend on includes and declarations above.
   Some of these reference functions in the perl object files, and some
   compilers aren't smart enough to eliminate unused static inline
   functions, so including this file in source code can cause link errors
   even if the source code uses none of the functions. Hence including these
   can be be suppressed by setting PERL_NO_INLINE_FUNCTIONS. Doing this will
   (obviously) result in unworkable XS code, but allows simple probing code
   to continue to work, because it permits tests to include the perl headers
   for definitions without creating a link dependency on the perl library
   (which may not exist yet).
*/

#  include "inline.h"
#endif

#include "overload.h"

END_EXTERN_C

struct am_table {
  U8 flags;
  U8 fallback;
  U16 spare;
  U32 was_ok_sub;
  CV* table[NofAMmeth];
};
struct am_table_short {
  U8 flags;
  U8 fallback;
  U16 spare;
  U32 was_ok_sub;
};
typedef struct am_table AMT;
typedef struct am_table_short AMTS;

#define AMGfallNEVER	1
#define AMGfallNO	2
#define AMGfallYES	3

#define AMTf_AMAGIC		1
#define AMT_AMAGIC(amt)		((amt)->flags & AMTf_AMAGIC)
#define AMT_AMAGIC_on(amt)	((amt)->flags |= AMTf_AMAGIC)
#define AMT_AMAGIC_off(amt)	((amt)->flags &= ~AMTf_AMAGIC)

#define StashHANDLER(stash,meth)	gv_handler((stash),CAT2(meth,_amg))

/*
 * some compilers like to redefine cos et alia as faster
 * (and less accurate?) versions called F_cos et cetera (Quidquid
 * latine dictum sit, altum viditur.)  This trick collides with
 * the Perl overloading (amg).  The following #defines fool both.
 */

#ifdef _FASTMATH
#   ifdef atan2
#       define F_atan2_amg  atan2_amg
#   endif
#   ifdef cos
#       define F_cos_amg    cos_amg
#   endif
#   ifdef exp
#       define F_exp_amg    exp_amg
#   endif
#   ifdef log
#       define F_log_amg    log_amg
#   endif
#   ifdef pow
#       define F_pow_amg    pow_amg
#   endif
#   ifdef sin
#       define F_sin_amg    sin_amg
#   endif
#   ifdef sqrt
#       define F_sqrt_amg   sqrt_amg
#   endif
#endif /* _FASTMATH */

#define PERLDB_ALL		(PERLDBf_SUB	| PERLDBf_LINE	|	\
				 PERLDBf_NOOPT	| PERLDBf_INTER	|	\
				 PERLDBf_SUBLINE| PERLDBf_SINGLE|	\
				 PERLDBf_NAMEEVAL| PERLDBf_NAMEANON |   \
				 PERLDBf_SAVESRC)
					/* No _NONAME, _GOTO */
#define PERLDBf_SUB		0x01	/* Debug sub enter/exit */
#define PERLDBf_LINE		0x02	/* Keep line # */
#define PERLDBf_NOOPT		0x04	/* Switch off optimizations */
#define PERLDBf_INTER		0x08	/* Preserve more data for
					   later inspections  */
#define PERLDBf_SUBLINE		0x10	/* Keep subr source lines */
#define PERLDBf_SINGLE		0x20	/* Start with single-step on */
#define PERLDBf_NONAME		0x40	/* For _SUB: no name of the subr */
#define PERLDBf_GOTO		0x80	/* Report goto: call DB::goto */
#define PERLDBf_NAMEEVAL	0x100	/* Informative names for evals */
#define PERLDBf_NAMEANON	0x200	/* Informative names for anon subs */
#define PERLDBf_SAVESRC  	0x400	/* Save source lines into @{"_<$filename"} */
#define PERLDBf_SAVESRC_NOSUBS	0x800	/* Including evals that generate no subroutines */
#define PERLDBf_SAVESRC_INVALID	0x1000	/* Save source that did not compile */

#define PERLDB_SUB	(PL_perldb && (PL_perldb & PERLDBf_SUB))
#define PERLDB_LINE	(PL_perldb && (PL_perldb & PERLDBf_LINE))
#define PERLDB_NOOPT	(PL_perldb && (PL_perldb & PERLDBf_NOOPT))
#define PERLDB_INTER	(PL_perldb && (PL_perldb & PERLDBf_INTER))
#define PERLDB_SUBLINE	(PL_perldb && (PL_perldb & PERLDBf_SUBLINE))
#define PERLDB_SINGLE	(PL_perldb && (PL_perldb & PERLDBf_SINGLE))
#define PERLDB_SUB_NN	(PL_perldb && (PL_perldb & (PERLDBf_NONAME)))
#define PERLDB_GOTO	(PL_perldb && (PL_perldb & PERLDBf_GOTO))
#define PERLDB_NAMEEVAL	(PL_perldb && (PL_perldb & PERLDBf_NAMEEVAL))
#define PERLDB_NAMEANON	(PL_perldb && (PL_perldb & PERLDBf_NAMEANON))
#define PERLDB_SAVESRC 	(PL_perldb && (PL_perldb & PERLDBf_SAVESRC))
#define PERLDB_SAVESRC_NOSUBS	(PL_perldb && (PL_perldb & PERLDBf_SAVESRC_NOSUBS))
#define PERLDB_SAVESRC_INVALID	(PL_perldb && (PL_perldb & PERLDBf_SAVESRC_INVALID))

/*

=head1 Locale-related functions and macros

=for apidoc sync_locale

Changing the program's locale should be avoided by XS code.  Nevertheless,
certain non-Perl libraries called from XS, such as C<Gtk> do so.  When this
happens, Perl needs to be told that the locale has changed.  Use this macro
to do so, before returning to Perl code.

=cut
*/

/* Temporary for maint.  Is a function in 5.21 */
#define sync_locale() (new_ctype(setlocale(LC_CTYPE, NULL)),        \
                       new_collate(setlocale(LC_COLLATE, NULL)),    \
                       set_numeric_local(),                         \
                       new_numeric(setlocale(LC_NUMERIC, NULL)))

#ifdef USE_LOCALE_NUMERIC

/* Returns TRUE if the plain locale pragma without a parameter is in effect
 */
#define IN_LOCALE_RUNTIME	cBOOL(CopHINTS_get(PL_curcop) & HINT_LOCALE)

/* Returns TRUE if either form of the locale pragma is in effect */
#define IN_SOME_LOCALE_FORM_RUNTIME   \
           cBOOL(CopHINTS_get(PL_curcop) & (HINT_LOCALE|HINT_LOCALE_NOT_CHARS))

#define IN_LOCALE_COMPILETIME	cBOOL(PL_hints & HINT_LOCALE)
#define IN_SOME_LOCALE_FORM_COMPILETIME \
                          cBOOL(PL_hints & (HINT_LOCALE|HINT_LOCALE_NOT_CHARS))

#define IN_LOCALE \
	(IN_PERL_COMPILETIME ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)
#define IN_SOME_LOCALE_FORM \
	(IN_PERL_COMPILETIME ? IN_SOME_LOCALE_FORM_COMPILETIME \
	                     : IN_SOME_LOCALE_FORM_RUNTIME)

/* These macros are for toggling between the underlying locale (LOCAL) and the
 * C locale. */

/* The first set makes sure that the locale is set to C unless within a 'use
 * locale's scope; otherwise to the default locale.  A function pointer is
 * used, which can be declared separately by
 * DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED, followed by the actual
 * setting (using STORE_LC_NUMERIC_SET_TO_NEEDED()), or the two can be combined
 * into one call DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED().
 * RESTORE_LC_NUMERIC() in all cases restores the locale to what it was before
 * these were called */

#define DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED                       \
    void (*_restore_LC_NUMERIC_function)(pTHX) = NULL;

#define STORE_LC_NUMERIC_SET_TO_NEEDED()                                     \
    if (IN_SOME_LOCALE_FORM) {                                               \
        if (! PL_numeric_local) {                                            \
            SET_NUMERIC_LOCAL();                                             \
            _restore_LC_NUMERIC_function = &Perl_set_numeric_standard;       \
        }                                                                    \
    }                                                                        \
    else {                                                                   \
        if (! PL_numeric_standard) {                                         \
            SET_NUMERIC_STANDARD();                                          \
            _restore_LC_NUMERIC_function = &Perl_set_numeric_local;          \
        }                                                                    \
    }

#define DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED()                             \
    DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED;                          \
    STORE_LC_NUMERIC_SET_TO_NEEDED();

#define RESTORE_LC_NUMERIC()                                                 \
    if (_restore_LC_NUMERIC_function) {                                      \
        _restore_LC_NUMERIC_function(aTHX);                                  \
    }

/* The next two macros set unconditionally.  These should be rarely used, and
 * only after being sure that this is what is needed */
#define SET_NUMERIC_STANDARD() \
	set_numeric_standard();

#define SET_NUMERIC_LOCAL() \
	set_numeric_local();

/* The rest of these LC_NUMERIC macros toggle to one or the other state, with
 * the RESTORE_foo ones called to switch back, but only if need be */
#define STORE_NUMERIC_LOCAL_SET_STANDARD() \
	bool was_local = PL_numeric_local; \
	if (was_local) SET_NUMERIC_STANDARD();

/* Doesn't change to underlying locale unless within the scope of some form of
 * 'use locale'.  This is the usual desired behavior. */
#define STORE_NUMERIC_STANDARD_SET_LOCAL() \
	bool was_standard = PL_numeric_standard && IN_SOME_LOCALE_FORM; \
	if (was_standard) SET_NUMERIC_LOCAL();

/* Rarely, we want to change to the underlying locale even outside of 'use
 * locale'.  This is principally in the POSIX:: functions */
#define STORE_NUMERIC_STANDARD_FORCE_LOCAL() \
	bool was_standard = PL_numeric_standard; \
	if (was_standard) SET_NUMERIC_LOCAL();

#define RESTORE_NUMERIC_LOCAL() \
	if (was_local) SET_NUMERIC_LOCAL();

#define RESTORE_NUMERIC_STANDARD() \
	if (was_standard) SET_NUMERIC_STANDARD();

#define Atof				my_atof

#else /* !USE_LOCALE_NUMERIC */

#define SET_NUMERIC_STANDARD()  	/**/
#define SET_NUMERIC_LOCAL()     	/**/
#define IS_NUMERIC_RADIX(a, b)		(0)
#define STORE_NUMERIC_LOCAL_SET_STANDARD()	/**/
#define STORE_NUMERIC_STANDARD_SET_LOCAL()	/**/
#define STORE_NUMERIC_STANDARD_FORCE_LOCAL()
#define RESTORE_NUMERIC_LOCAL()		/**/
#define RESTORE_NUMERIC_STANDARD()	/**/
#define DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED
#define STORE_LC_NUMERIC_SET_TO_NEEDED()
#define DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED()
#define RESTORE_LC_NUMERIC()

#define Atof				my_atof
#define IN_LOCALE_RUNTIME		0
#define IN_LOCALE_COMPILETIME		0

#endif /* !USE_LOCALE_NUMERIC */

#if !defined(Strtol) && defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && \
	(QUADKIND == QUAD_IS_LONG_LONG || QUADKIND == QUAD_IS___INT64)
#    ifdef __hpux
#        define strtoll __strtoll	/* secret handshake */
#    endif
#    ifdef WIN64
#        define strtoll _strtoi64	/* secret handshake */
#    endif
#   if !defined(Strtol) && defined(HAS_STRTOLL)
#       define Strtol	strtoll
#   endif
#    if !defined(Strtol) && defined(HAS_STRTOQ)
#       define Strtol	strtoq
#    endif
/* is there atoq() anywhere? */
#endif
#if !defined(Strtol) && defined(HAS_STRTOL)
#   define Strtol	strtol
#endif
#ifndef Atol
/* It would be more fashionable to use Strtol() to define atol()
 * (as is done for Atoul(), see below) but for backward compatibility
 * we just assume atol(). */
#   if defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && defined(HAS_ATOLL) && \
	(QUADKIND == QUAD_IS_LONG_LONG || QUADKIND == QUAD_IS___INT64)
#    ifdef WIN64
#       define atoll    _atoi64		/* secret handshake */
#    endif
#       define Atol	atoll
#   else
#       define Atol	atol
#   endif
#endif

#if !defined(Strtoul) && defined(USE_64_BIT_INT) && defined(UV_IS_QUAD) && \
	(QUADKIND == QUAD_IS_LONG_LONG || QUADKIND == QUAD_IS___INT64)
#    ifdef __hpux
#        define strtoull __strtoull	/* secret handshake */
#    endif
#    ifdef WIN64
#        define strtoull _strtoui64	/* secret handshake */
#    endif
#    if !defined(Strtoul) && defined(HAS_STRTOULL)
#       define Strtoul	strtoull
#    endif
#    if !defined(Strtoul) && defined(HAS_STRTOUQ)
#       define Strtoul	strtouq
#    endif
/* is there atouq() anywhere? */
#endif
#if !defined(Strtoul) && defined(HAS_STRTOUL)
#   define Strtoul	strtoul
#endif
#if !defined(Strtoul) && defined(HAS_STRTOL) /* Last resort. */
#   define Strtoul(s, e, b)	strchr((s), '-') ? ULONG_MAX : (unsigned long)strtol((s), (e), (b))
#endif
#ifndef Atoul
#   define Atoul(s)	Strtoul(s, NULL, 10)
#endif


/* if these never got defined, they need defaults */
#ifndef PERL_SET_CONTEXT
#  define PERL_SET_CONTEXT(i)		PERL_SET_INTERP(i)
#endif

#ifndef PERL_GET_CONTEXT
#  define PERL_GET_CONTEXT		PERL_GET_INTERP
#endif

#ifndef PERL_GET_THX
#  define PERL_GET_THX			((void*)NULL)
#endif

#ifndef PERL_SET_THX
#  define PERL_SET_THX(t)		NOOP
#endif

#ifndef PERL_SCRIPT_MODE
#define PERL_SCRIPT_MODE "r"
#endif

/*
 * Some operating systems are stingy with stack allocation,
 * so perl may have to guard against stack overflow.
 */
#ifndef PERL_STACK_OVERFLOW_CHECK
#define PERL_STACK_OVERFLOW_CHECK()  NOOP
#endif

/*
 * Some nonpreemptive operating systems find it convenient to
 * check for asynchronous conditions after each op execution.
 * Keep this check simple, or it may slow down execution
 * massively.
 */

#ifndef PERL_MICRO
#	ifndef PERL_ASYNC_CHECK
#		define PERL_ASYNC_CHECK() if (UNLIKELY(PL_sig_pending)) PL_signalhook(aTHX)
#	endif
#endif

#ifndef PERL_ASYNC_CHECK
#   define PERL_ASYNC_CHECK()  NOOP
#endif

/*
 * On some operating systems, a memory allocation may succeed,
 * but put the process too close to the system's comfort limit.
 * In this case, PERL_ALLOC_CHECK frees the pointer and sets
 * it to NULL.
 */
#ifndef PERL_ALLOC_CHECK
#define PERL_ALLOC_CHECK(p)  NOOP
#endif

#ifdef HAS_SEM
#   include <sys/ipc.h>
#   include <sys/sem.h>
#   ifndef HAS_UNION_SEMUN	/* Provide the union semun. */
    union semun {
	int		val;
	struct semid_ds	*buf;
	unsigned short	*array;
    };
#   endif
#   ifdef USE_SEMCTL_SEMUN
#	ifdef IRIX32_SEMUN_BROKEN_BY_GCC
            union gccbug_semun {
		int             val;
		struct semid_ds *buf;
		unsigned short  *array;
		char            __dummy[5];
	    };
#           define semun gccbug_semun
#	endif
#       define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun)
#   else
#       ifdef USE_SEMCTL_SEMID_DS
#           ifdef EXTRA_F_IN_SEMUN_BUF
#               define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun.buff)
#           else
#               define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun.buf)
#           endif
#       endif
#   endif
#endif

/*
 * Boilerplate macros for initializing and accessing interpreter-local
 * data from C.  All statics in extensions should be reworked to use
 * this, if you want to make the extension thread-safe.  See
 * ext/XS/APItest/APItest.xs for an example of the use of these macros,
 * and perlxs.pod for more.
 *
 * Code that uses these macros is responsible for the following:
 * 1. #define MY_CXT_KEY to a unique string, e.g.
 *    "DynaLoader::_guts" XS_VERSION
 *    XXX in the current implementation, this string is ignored.
 * 2. Declare a typedef named my_cxt_t that is a structure that contains
 *    all the data that needs to be interpreter-local.
 * 3. Use the START_MY_CXT macro after the declaration of my_cxt_t.
 * 4. Use the MY_CXT_INIT macro such that it is called exactly once
 *    (typically put in the BOOT: section).
 * 5. Use the members of the my_cxt_t structure everywhere as
 *    MY_CXT.member.
 * 6. Use the dMY_CXT macro (a declaration) in all the functions that
 *    access MY_CXT.
 */

#if defined(PERL_IMPLICIT_CONTEXT)

/* START_MY_CXT must appear in all extensions that define a my_cxt_t structure,
 * right after the definition (i.e. at file scope).  The non-threads
 * case below uses it to declare the data as static. */
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
#    define START_MY_CXT
#    define MY_CXT_INDEX Perl_my_cxt_index(aTHX_ MY_CXT_KEY)
#    define MY_CXT_INIT_ARG MY_CXT_KEY
#  else
#    define START_MY_CXT static int my_cxt_index = -1;
#    define MY_CXT_INDEX my_cxt_index
#    define MY_CXT_INIT_ARG &my_cxt_index
#  endif /* #ifdef PERL_GLOBAL_STRUCT_PRIVATE */

/* Creates and zeroes the per-interpreter data.
 * (We allocate my_cxtp in a Perl SV so that it will be released when
 * the interpreter goes away.) */
#  define MY_CXT_INIT \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(aTHX_ MY_CXT_INIT_ARG, sizeof(my_cxt_t)); \
	PERL_UNUSED_VAR(my_cxtp)
#  define MY_CXT_INIT_INTERP(my_perl) \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(my_perl, MY_CXT_INIT_ARG, sizeof(my_cxt_t)); \
	PERL_UNUSED_VAR(my_cxtp)

/* This declaration should be used within all functions that use the
 * interpreter-local data. */
#  define dMY_CXT	\
	my_cxt_t *my_cxtp = (my_cxt_t *)PL_my_cxt_list[MY_CXT_INDEX]
#  define dMY_CXT_INTERP(my_perl)	\
	my_cxt_t *my_cxtp = (my_cxt_t *)(my_perl)->Imy_cxt_list[MY_CXT_INDEX]

/* Clones the per-interpreter data. */
#  define MY_CXT_CLONE \
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	Copy(PL_my_cxt_list[MY_CXT_INDEX], my_cxtp, 1, my_cxt_t);\
	PL_my_cxt_list[MY_CXT_INDEX] = my_cxtp				\


/* This macro must be used to access members of the my_cxt_t structure.
 * e.g. MY_CXT.some_data */
#  define MY_CXT		(*my_cxtp)

/* Judicious use of these macros can reduce the number of times dMY_CXT
 * is used.  Use is similar to pTHX, aTHX etc. */
#  define pMY_CXT	my_cxt_t *my_cxtp
#  define pMY_CXT_	pMY_CXT,
#  define _pMY_CXT	,pMY_CXT
#  define aMY_CXT	my_cxtp
#  define aMY_CXT_	aMY_CXT,
#  define _aMY_CXT	,aMY_CXT

#else /* PERL_IMPLICIT_CONTEXT */

#  define START_MY_CXT		static my_cxt_t my_cxt;
#  define dMY_CXT_SV	    	dNOOP
#  define dMY_CXT		dNOOP
#  define dMY_CXT_INTERP(my_perl) dNOOP
#  define MY_CXT_INIT		NOOP
#  define MY_CXT_CLONE		NOOP
#  define MY_CXT		my_cxt

#  define pMY_CXT		void
#  define pMY_CXT_
#  define _pMY_CXT
#  define aMY_CXT
#  define aMY_CXT_
#  define _aMY_CXT

#endif /* !defined(PERL_IMPLICIT_CONTEXT) */

#ifdef I_FCNTL
#  include <fcntl.h>
#endif

#ifdef __Lynx__
#  include <fcntl.h>
#endif

#ifdef I_SYS_FILE
#  include <sys/file.h>
#endif

#if defined(HAS_FLOCK) && !defined(HAS_FLOCK_PROTO)
int flock(int fd, int op);
#endif

#ifndef O_RDONLY
/* Assume UNIX defaults */
#    define O_RDONLY	0000
#    define O_WRONLY	0001
#    define O_RDWR	0002
#    define O_CREAT	0100
#endif

#ifndef O_BINARY
#  define O_BINARY 0
#endif

#ifndef O_TEXT
#  define O_TEXT 0
#endif

#if O_TEXT != O_BINARY
    /* If you have different O_TEXT and O_BINARY and you are a CLRF shop,
     * that is, you are somehow DOSish. */
#   if defined(__HAIKU__) || defined(__VOS__) || defined(__CYGWIN__)
    /* Haiku has O_TEXT != O_BINARY but O_TEXT and O_BINARY have no effect;
     * Haiku is always UNIXoid (LF), not DOSish (CRLF). */
    /* VOS has O_TEXT != O_BINARY, and they have effect,
     * but VOS always uses LF, never CRLF. */
    /* If you have O_TEXT different from your O_BINARY but you still are
     * not a CRLF shop. */
#       undef PERLIO_USING_CRLF
#   else
    /* If you really are DOSish. */
#      define PERLIO_USING_CRLF 1
#   endif
#endif

#ifdef I_LIBUTIL
#   include <libutil.h>		/* setproctitle() in some FreeBSDs */
#endif

#ifndef EXEC_ARGV_CAST
#define EXEC_ARGV_CAST(x) (char **)x
#endif

#define IS_NUMBER_IN_UV		      0x01 /* number within UV range (maybe not
					      int).  value returned in pointed-
					      to UV */
#define IS_NUMBER_GREATER_THAN_UV_MAX 0x02 /* pointed to UV undefined */
#define IS_NUMBER_NOT_INT	      0x04 /* saw . or E notation */
#define IS_NUMBER_NEG		      0x08 /* leading minus sign */
#define IS_NUMBER_INFINITY	      0x10 /* this is big */
#define IS_NUMBER_NAN                 0x20 /* this is not */

#define GROK_NUMERIC_RADIX(sp, send) grok_numeric_radix(sp, send)

/* Input flags: */
#define PERL_SCAN_ALLOW_UNDERSCORES   0x01 /* grok_??? accept _ in numbers */
#define PERL_SCAN_DISALLOW_PREFIX     0x02 /* grok_??? reject 0x in hex etc */
#define PERL_SCAN_SILENT_ILLDIGIT     0x04 /* grok_??? not warn about illegal digits */
#define PERL_SCAN_SILENT_NON_PORTABLE 0x08 /* grok_??? not warn about very large
					      numbers which are <= UV_MAX */
/* Output flags: */
#define PERL_SCAN_GREATER_THAN_UV_MAX 0x02 /* should this merge with above? */

/* to let user control profiling */
#ifdef PERL_GPROF_CONTROL
extern void moncontrol(int);
#define PERL_GPROF_MONCONTROL(x) moncontrol(x)
#else
#define PERL_GPROF_MONCONTROL(x)
#endif

#ifdef UNDER_CE
#include "wince.h"
#endif

/* ISO 6429 NEL - C1 control NExt Line */
/* See http://www.unicode.org/unicode/reports/tr13/ */
#define NEXT_LINE_CHAR	NEXT_LINE_NATIVE

/* The UTF-8 bytes of the Unicode LS and PS, U+2028 and U+2029 */
#define UNICODE_LINE_SEPA_0	0xE2
#define UNICODE_LINE_SEPA_1	0x80
#define UNICODE_LINE_SEPA_2	0xA8
#define UNICODE_PARA_SEPA_0	0xE2
#define UNICODE_PARA_SEPA_1	0x80
#define UNICODE_PARA_SEPA_2	0xA9

#ifndef PIPESOCK_MODE
#  define PIPESOCK_MODE
#endif

#ifndef SOCKET_OPEN_MODE
#  define SOCKET_OPEN_MODE	PIPESOCK_MODE
#endif

#ifndef PIPE_OPEN_MODE
#  define PIPE_OPEN_MODE	PIPESOCK_MODE
#endif

#define PERL_MAGIC_UTF8_CACHESIZE	2

#define PERL_UNICODE_STDIN_FLAG			0x0001
#define PERL_UNICODE_STDOUT_FLAG		0x0002
#define PERL_UNICODE_STDERR_FLAG		0x0004
#define PERL_UNICODE_IN_FLAG			0x0008
#define PERL_UNICODE_OUT_FLAG			0x0010
#define PERL_UNICODE_ARGV_FLAG			0x0020
#define PERL_UNICODE_LOCALE_FLAG		0x0040
#define PERL_UNICODE_WIDESYSCALLS_FLAG		0x0080 /* for Sarathy */
#define PERL_UNICODE_UTF8CACHEASSERT_FLAG	0x0100

#define PERL_UNICODE_STD_FLAG		\
	(PERL_UNICODE_STDIN_FLAG	| \
	 PERL_UNICODE_STDOUT_FLAG	| \
	 PERL_UNICODE_STDERR_FLAG)

#define PERL_UNICODE_INOUT_FLAG		\
	(PERL_UNICODE_IN_FLAG	| \
	 PERL_UNICODE_OUT_FLAG)

#define PERL_UNICODE_DEFAULT_FLAGS	\
	(PERL_UNICODE_STD_FLAG		| \
	 PERL_UNICODE_INOUT_FLAG	| \
	 PERL_UNICODE_LOCALE_FLAG)

#define PERL_UNICODE_ALL_FLAGS			0x01ff

#define PERL_UNICODE_STDIN			'I'
#define PERL_UNICODE_STDOUT			'O'
#define PERL_UNICODE_STDERR			'E'
#define PERL_UNICODE_STD			'S'
#define PERL_UNICODE_IN				'i'
#define PERL_UNICODE_OUT			'o'
#define PERL_UNICODE_INOUT			'D'
#define PERL_UNICODE_ARGV			'A'
#define PERL_UNICODE_LOCALE			'L'
#define PERL_UNICODE_WIDESYSCALLS		'W'
#define PERL_UNICODE_UTF8CACHEASSERT		'a'

#define PERL_SIGNALS_UNSAFE_FLAG	0x0001

/* Use instead of abs() since abs() forces its argument to be an int,
 * but also beware since this evaluates its argument twice, so no x++. */
#define PERL_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(__DECC) && defined(__osf__)
#pragma message disable (mainparm) /* Perl uses the envp in main(). */
#endif

#define do_open(g, n, l, a, rm, rp, sf) \
	do_openn(g, n, l, a, rm, rp, sf, (SV **) NULL, 0)
#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
#  define do_exec(cmd)			do_exec3(cmd,0,0)
#endif
#ifdef OS2
#  define do_aexec			Perl_do_aexec
#else
#  define do_aexec(really, mark,sp)	do_aexec5(really, mark, sp, 0, 0)
#endif

/* check embedded \0 characters in pathnames passed to syscalls,
   but allow one ending \0 */
#define IS_SAFE_SYSCALL(p, len, what, op_name) (S_is_safe_syscall(aTHX_ (p), (len), (what), (op_name)))

#define IS_SAFE_PATHNAME(p, len, op_name) IS_SAFE_SYSCALL((p), (len), "pathname", (op_name))

#if defined(OEMVS)
#define NO_ENV_ARRAY_IN_MAIN
#endif

/* These are used by Perl_pv_escape() and Perl_pv_pretty()
 * are here so that they are available throughout the core
 * NOTE that even though some are for _escape and some for _pretty
 * there must not be any clashes as the flags from _pretty are
 * passed straight through to _escape.
 */

#define PERL_PV_ESCAPE_QUOTE        0x0001
#define PERL_PV_PRETTY_QUOTE        PERL_PV_ESCAPE_QUOTE

#define PERL_PV_PRETTY_ELLIPSES     0x0002
#define PERL_PV_PRETTY_LTGT         0x0004

#define PERL_PV_ESCAPE_FIRSTCHAR    0x0008

#define PERL_PV_ESCAPE_UNI          0x0100
#define PERL_PV_ESCAPE_UNI_DETECT   0x0200
#define PERL_PV_ESCAPE_NONASCII     0x0400

#define PERL_PV_ESCAPE_ALL	    0x1000
#define PERL_PV_ESCAPE_NOBACKSLASH  0x2000
#define PERL_PV_ESCAPE_NOCLEAR      0x4000
#define PERL_PV_ESCAPE_RE           0x8000

#define PERL_PV_ESCAPE_DWIM         0x10000

#define PERL_PV_PRETTY_NOCLEAR      PERL_PV_ESCAPE_NOCLEAR

/* used by pv_display in dump.c*/
#define PERL_PV_PRETTY_DUMP  PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE
#define PERL_PV_PRETTY_REGPROP PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_LTGT|PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII

/*

   (KEEP THIS LAST IN perl.h!)

   Mention

   NV_PRESERVES_UV

   HAS_MKSTEMP
   HAS_MKSTEMPS
   HAS_MKDTEMP

   HAS_GETCWD

   HAS_MMAP
   HAS_MPROTECT
   HAS_MSYNC
   HAS_MADVISE
   HAS_MUNMAP
   I_SYSMMAN
   Mmap_t

   NVef
   NVff
   NVgf

   HAS_UALARM
   HAS_USLEEP

   HAS_SETITIMER
   HAS_GETITIMER

   HAS_SENDMSG
   HAS_RECVMSG
   HAS_READV
   HAS_WRITEV
   I_SYSUIO
   HAS_STRUCT_MSGHDR
   HAS_STRUCT_CMSGHDR

   HAS_NL_LANGINFO

   HAS_DIRFD

   so that Configure picks them up.

   (KEEP THIS LAST IN perl.h!)

*/

#endif /* Include guard */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                  usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/perlapi.h                                                 0100644 0000000 0000000 00000012767 12744441327 017556  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    perlapi.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/embed.pl from data in embed.fnc,
 * regen/embed.pl, regen/opcodes, intrpvar.h and perlvars.h.
 * Any changes made here will be lost!
 *
 * Edit those files and run 'make regen_headers' to effect changes.
 */

/* declare accessor functions for Perl variables */
#ifndef __perlapi_h__
#define __perlapi_h__

#if defined (MULTIPLICITY) && defined (PERL_GLOBAL_STRUCT)

START_EXTERN_C

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#define PERLVAR(p,v,t)	EXTERN_C t* Perl_##p##v##_ptr(pTHX);
#define PERLVARA(p,v,n,t)	typedef t PL_##v##_t[n];		\
			EXTERN_C PL_##v##_t* Perl_##p##v##_ptr(pTHX);
#define PERLVARI(p,v,t,i)	PERLVAR(p,v,t)
#define PERLVARIC(p,v,t,i) PERLVAR(p,v, const t)

#include "perlvars.h"

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC

END_EXTERN_C

#if defined(PERL_CORE)

/* accessor functions for Perl "global" variables */

/* these need to be mentioned here, or most linkers won't put them in
   the perl executable */

#ifndef PERL_NO_FORCE_LINK

START_EXTERN_C

#ifndef DOINIT
EXTCONST void * const PL_force_link_funcs[];
#else
EXTCONST void * const PL_force_link_funcs[] = {
#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#define PERLVAR(p,v,t)		(void*)Perl_##p##v##_ptr,
#define PERLVARA(p,v,n,t)	PERLVAR(p,v,t)
#define PERLVARI(p,v,t,i)	PERLVAR(p,v,t)
#define PERLVARIC(p,v,t,i)	PERLVAR(p,v,t)

/* In Tru64 (__DEC && __osf__) the cc option -std1 causes that one
 * cannot cast between void pointers and function pointers without
 * info level warnings.  The PL_force_link_funcs[] would cause a few
 * hundred of those warnings.  In code one can circumnavigate this by using
 * unions that overlay the different pointers, but in declarations one
 * cannot use this trick.  Therefore we just disable the warning here
 * for the duration of the PL_force_link_funcs[] declaration. */

#if defined(__DECC) && defined(__osf__)
#pragma message save
#pragma message disable (nonstandcast)
#endif

#include "perlvars.h"

#if defined(__DECC) && defined(__osf__)
#pragma message restore
#endif

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
};
#endif	/* DOINIT */

END_EXTERN_C

#endif	/* PERL_NO_FORCE_LINK */

#else	/* !PERL_CORE */

#undef  PL_appctx
#define PL_appctx		(*Perl_Gappctx_ptr(NULL))
#undef  PL_check
#define PL_check		(*Perl_Gcheck_ptr(NULL))
#undef  PL_check_mutex
#define PL_check_mutex		(*Perl_Gcheck_mutex_ptr(NULL))
#undef  PL_csighandlerp
#define PL_csighandlerp		(*Perl_Gcsighandlerp_ptr(NULL))
#undef  PL_curinterp
#define PL_curinterp		(*Perl_Gcurinterp_ptr(NULL))
#undef  PL_do_undump
#define PL_do_undump		(*Perl_Gdo_undump_ptr(NULL))
#undef  PL_dollarzero_mutex
#define PL_dollarzero_mutex	(*Perl_Gdollarzero_mutex_ptr(NULL))
#undef  PL_fold_locale
#define PL_fold_locale		(*Perl_Gfold_locale_ptr(NULL))
#undef  PL_hash_seed
#define PL_hash_seed		(*Perl_Ghash_seed_ptr(NULL))
#undef  PL_hash_seed_set
#define PL_hash_seed_set	(*Perl_Ghash_seed_set_ptr(NULL))
#undef  PL_hints_mutex
#define PL_hints_mutex		(*Perl_Ghints_mutex_ptr(NULL))
#undef  PL_keyword_plugin
#define PL_keyword_plugin	(*Perl_Gkeyword_plugin_ptr(NULL))
#undef  PL_malloc_mutex
#define PL_malloc_mutex		(*Perl_Gmalloc_mutex_ptr(NULL))
#undef  PL_mmap_page_size
#define PL_mmap_page_size	(*Perl_Gmmap_page_size_ptr(NULL))
#undef  PL_my_ctx_mutex
#define PL_my_ctx_mutex		(*Perl_Gmy_ctx_mutex_ptr(NULL))
#undef  PL_my_cxt_index
#define PL_my_cxt_index		(*Perl_Gmy_cxt_index_ptr(NULL))
#undef  PL_op_mutex
#define PL_op_mutex		(*Perl_Gop_mutex_ptr(NULL))
#undef  PL_op_seq
#define PL_op_seq		(*Perl_Gop_seq_ptr(NULL))
#undef  PL_op_sequence
#define PL_op_sequence		(*Perl_Gop_sequence_ptr(NULL))
#undef  PL_perlio_debug_fd
#define PL_perlio_debug_fd	(*Perl_Gperlio_debug_fd_ptr(NULL))
#undef  PL_perlio_fd_refcnt
#define PL_perlio_fd_refcnt	(*Perl_Gperlio_fd_refcnt_ptr(NULL))
#undef  PL_perlio_fd_refcnt_size
#define PL_perlio_fd_refcnt_size	(*Perl_Gperlio_fd_refcnt_size_ptr(NULL))
#undef  PL_perlio_mutex
#define PL_perlio_mutex		(*Perl_Gperlio_mutex_ptr(NULL))
#undef  PL_ppaddr
#define PL_ppaddr		(*Perl_Gppaddr_ptr(NULL))
#undef  PL_sh_path
#define PL_sh_path		(*Perl_Gsh_path_ptr(NULL))
#undef  PL_sig_defaulting
#define PL_sig_defaulting	(*Perl_Gsig_defaulting_ptr(NULL))
#undef  PL_sig_handlers_initted
#define PL_sig_handlers_initted	(*Perl_Gsig_handlers_initted_ptr(NULL))
#undef  PL_sig_ignoring
#define PL_sig_ignoring		(*Perl_Gsig_ignoring_ptr(NULL))
#undef  PL_sig_trapped
#define PL_sig_trapped		(*Perl_Gsig_trapped_ptr(NULL))
#undef  PL_sigfpe_saved
#define PL_sigfpe_saved		(*Perl_Gsigfpe_saved_ptr(NULL))
#undef  PL_sv_placeholder
#define PL_sv_placeholder	(*Perl_Gsv_placeholder_ptr(NULL))
#undef  PL_thr_key
#define PL_thr_key		(*Perl_Gthr_key_ptr(NULL))
#undef  PL_timesbase
#define PL_timesbase		(*Perl_Gtimesbase_ptr(NULL))
#undef  PL_use_safe_putenv
#define PL_use_safe_putenv	(*Perl_Guse_safe_putenv_ptr(NULL))
#undef  PL_veto_cleanup
#define PL_veto_cleanup		(*Perl_Gveto_cleanup_ptr(NULL))
#undef  PL_watch_pvx
#define PL_watch_pvx		(*Perl_Gwatch_pvx_ptr(NULL))

#endif /* !PERL_CORE */
#endif /* MULTIPLICITY && PERL_GLOBAL_STRUCT */

#endif /* __perlapi_h__ */

/* ex: set ro: */
         usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/perlio.h                                                  0100644 0000000 0000000 00000024335 12744441327 017406  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    perlio.h
 *
 *    Copyright (C) 1996, 1997, 1999, 2000, 2001, 2002, 2003,
 *    2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifndef _PERLIO_H
#define _PERLIO_H
/*
  Interface for perl to IO functions.
  There is a hierarchy of Configure determined #define controls:
   USE_STDIO   - forces PerlIO_xxx() to be #define-d onto stdio functions.
                 This is used for x2p subdirectory and for conservative
                 builds - "just like perl5.00X used to be".
                 This dominates over the others.

   USE_PERLIO  - The primary Configure variable that enables PerlIO.
                 If USE_PERLIO is _NOT_ set
                   then USE_STDIO above will be set to be conservative.
                 PerlIO_xxx() are real functions
                 defined in perlio.c which implement extra functionality
                 required for utf8 support.

   One further note - the table-of-functions scheme controlled
   by PERL_IMPLICIT_SYS turns on USE_PERLIO so that iperlsys.h can
   #define PerlIO_xxx() to go via the function table, without having
   to #undef them from (say) stdio forms.

*/

#if defined(PERL_IMPLICIT_SYS)
#ifndef USE_PERLIO
#ifndef NETWARE
/* # define USE_PERLIO */
#endif
#endif
#endif

#ifndef USE_PERLIO
# define USE_STDIO
#endif

#ifdef USE_STDIO
#  ifndef PERLIO_IS_STDIO
#      define PERLIO_IS_STDIO
#  endif
#endif

/* --------------------  End of Configure controls ---------------------------- */

/*
 * Although we may not want stdio to be used including <stdio.h> here
 * avoids issues where stdio.h has strange side effects
 */
#include <stdio.h>

#if defined(USE_64_BIT_STDIO) && defined(HAS_FTELLO) && !defined(USE_FTELL64)
#define ftell ftello
#endif

#if defined(USE_64_BIT_STDIO) && defined(HAS_FSEEKO) && !defined(USE_FSEEK64)
#define fseek fseeko
#endif

/* BS2000 includes are sometimes a bit non standard :-( */
#if defined(POSIX_BC) && defined(O_BINARY) && !defined(O_TEXT)
#undef O_BINARY
#endif

#ifdef PERLIO_IS_STDIO
/* #define PerlIO_xxxx() as equivalent stdio function */
#include "perlsdio.h"
#endif				/* PERLIO_IS_STDIO */

#ifndef PerlIO
/* ----------- PerlIO implementation ---------- */
/* PerlIO not #define-d to something else - define the implementation */

typedef struct _PerlIO PerlIOl;
typedef struct _PerlIO_funcs PerlIO_funcs;
typedef PerlIOl *PerlIO;
#define PerlIO PerlIO
#define PERLIO_LAYERS 1

/* Making the big PerlIO_funcs vtables const is good (enables placing
 * them in the const section which is good for speed, security, and
 * embeddability) but this cannot be done by default because of
 * backward compatibility. */
#ifdef PERLIO_FUNCS_CONST
#define PERLIO_FUNCS_DECL(funcs) const PerlIO_funcs funcs
#define PERLIO_FUNCS_CAST(funcs) (PerlIO_funcs*)(funcs)
#else
#define PERLIO_FUNCS_DECL(funcs) PerlIO_funcs funcs
#define PERLIO_FUNCS_CAST(funcs) (funcs)
#endif

PERL_EXPORT_C void PerlIO_define_layer(pTHX_ PerlIO_funcs *tab);
PERL_EXPORT_C PerlIO_funcs *PerlIO_find_layer(pTHX_ const char *name,
                                              STRLEN len,
				              int load);
PERL_EXPORT_C PerlIO *PerlIO_push(pTHX_ PerlIO *f, PERLIO_FUNCS_DECL(*tab),
			          const char *mode, SV *arg);
PERL_EXPORT_C void PerlIO_pop(pTHX_ PerlIO *f);
PERL_EXPORT_C AV* PerlIO_get_layers(pTHX_ PerlIO *f);
PERL_EXPORT_C void PerlIO_clone(pTHX_ PerlInterpreter *proto,
                                CLONE_PARAMS *param);

#endif				/* PerlIO */

/* ----------- End of implementation choices  ---------- */

#ifndef PERLIO_IS_STDIO
/* Not using stdio _directly_ as PerlIO */

/* We now need to determine  what happens if source trys to use stdio.
 * There are three cases based on PERLIO_NOT_STDIO which XS code
 * can set how it wants.
 */

#   ifdef PERL_CORE
/* Make a choice for perl core code
   - currently this is set to try and catch lingering raw stdio calls.
     This is a known issue with some non UNIX ports which still use
     "native" stdio features.
*/
#       ifndef PERLIO_NOT_STDIO
#           define PERLIO_NOT_STDIO 1
#       endif
    #else
#   ifndef PERLIO_NOT_STDIO
#       define PERLIO_NOT_STDIO 0
#   endif
#endif

#ifdef PERLIO_NOT_STDIO
#if PERLIO_NOT_STDIO
/*
 * PERLIO_NOT_STDIO #define'd as 1
 * Case 1: Strong denial of stdio - make all stdio calls (we can think of) errors
 */
#include "nostdio.h"
#else				/* if PERLIO_NOT_STDIO */
/*
 * PERLIO_NOT_STDIO #define'd as 0
 * Case 2: Declares that both PerlIO and stdio can be used
 */
#endif				/* if PERLIO_NOT_STDIO */
#else				/* ifdef PERLIO_NOT_STDIO */
/*
 * PERLIO_NOT_STDIO not defined
 * Case 3: Try and fake stdio calls as PerlIO calls
 */
#include "fakesdio.h"
#endif				/* ifndef PERLIO_NOT_STDIO */
#endif				/* PERLIO_IS_STDIO */

/* ----------- fill in things that have not got #define'd  ---------- */

#ifndef Fpos_t
#define Fpos_t Off_t
#endif

#ifndef EOF
#define EOF (-1)
#endif

/* This is to catch case with no stdio */
#ifndef BUFSIZ
#define BUFSIZ 1024
#endif

/* The default buffer size for the perlio buffering layer */
#ifndef PERLIOBUF_DEFAULT_BUFSIZ
#define PERLIOBUF_DEFAULT_BUFSIZ (BUFSIZ > 8192 ? BUFSIZ : 8192)
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#endif

#ifndef SEEK_CUR
#define SEEK_CUR 1
#endif

#ifndef SEEK_END
#define SEEK_END 2
#endif

#define PERLIO_DUP_CLONE	1
#define PERLIO_DUP_FD		2

/* --------------------- Now prototypes for functions --------------- */

START_EXTERN_C
#ifndef __attribute__format__
#  ifdef HASATTRIBUTE_FORMAT
#    define __attribute__format__(x,y,z) __attribute__((format(x,y,z)))
#  else
#    define __attribute__format__(x,y,z)
#  endif
#endif
#ifndef PerlIO_init
PERL_EXPORT_C void PerlIO_init(pTHX);
#endif
#ifndef PerlIO_stdoutf
PERL_EXPORT_C int PerlIO_stdoutf(const char *, ...)
    __attribute__format__(__printf__, 1, 2);
#endif
#ifndef PerlIO_puts
PERL_EXPORT_C int PerlIO_puts(PerlIO *, const char *);
#endif
#ifndef PerlIO_open
PERL_EXPORT_C PerlIO *PerlIO_open(const char *, const char *);
#endif
#ifndef PerlIO_openn
PERL_EXPORT_C PerlIO *PerlIO_openn(pTHX_ const char *layers, const char *mode,
				   int fd, int imode, int perm, PerlIO *old,
				   int narg, SV **arg);
#endif
#ifndef PerlIO_eof
PERL_EXPORT_C int PerlIO_eof(PerlIO *);
#endif
#ifndef PerlIO_error
PERL_EXPORT_C int PerlIO_error(PerlIO *);
#endif
#ifndef PerlIO_clearerr
PERL_EXPORT_C void PerlIO_clearerr(PerlIO *);
#endif
#ifndef PerlIO_getc
PERL_EXPORT_C int PerlIO_getc(PerlIO *);
#endif
#ifndef PerlIO_putc
PERL_EXPORT_C int PerlIO_putc(PerlIO *, int);
#endif
#ifndef PerlIO_ungetc
PERL_EXPORT_C int PerlIO_ungetc(PerlIO *, int);
#endif
#ifndef PerlIO_fdopen
PERL_EXPORT_C PerlIO *PerlIO_fdopen(int, const char *);
#endif
#ifndef PerlIO_importFILE
PERL_EXPORT_C PerlIO *PerlIO_importFILE(FILE *, const char *);
#endif
#ifndef PerlIO_exportFILE
PERL_EXPORT_C FILE *PerlIO_exportFILE(PerlIO *, const char *);
#endif
#ifndef PerlIO_findFILE
PERL_EXPORT_C FILE *PerlIO_findFILE(PerlIO *);
#endif
#ifndef PerlIO_releaseFILE
PERL_EXPORT_C void PerlIO_releaseFILE(PerlIO *, FILE *);
#endif
#ifndef PerlIO_read
PERL_EXPORT_C SSize_t PerlIO_read(PerlIO *, void *, Size_t);
#endif
#ifndef PerlIO_unread
PERL_EXPORT_C SSize_t PerlIO_unread(PerlIO *, const void *, Size_t);
#endif
#ifndef PerlIO_write
PERL_EXPORT_C SSize_t PerlIO_write(PerlIO *, const void *, Size_t);
#endif
#ifndef PerlIO_setlinebuf
PERL_EXPORT_C void PerlIO_setlinebuf(PerlIO *);
#endif
#ifndef PerlIO_printf
PERL_EXPORT_C int PerlIO_printf(PerlIO *, const char *, ...)
    __attribute__format__(__printf__, 2, 3);
#endif
#ifndef PerlIO_vprintf
PERL_EXPORT_C int PerlIO_vprintf(PerlIO *, const char *, va_list);
#endif
#ifndef PerlIO_tell
PERL_EXPORT_C Off_t PerlIO_tell(PerlIO *);
#endif
#ifndef PerlIO_seek
PERL_EXPORT_C int PerlIO_seek(PerlIO *, Off_t, int);
#endif
#ifndef PerlIO_rewind
PERL_EXPORT_C void PerlIO_rewind(PerlIO *);
#endif
#ifndef PerlIO_has_base
PERL_EXPORT_C int PerlIO_has_base(PerlIO *);
#endif
#ifndef PerlIO_has_cntptr
PERL_EXPORT_C int PerlIO_has_cntptr(PerlIO *);
#endif
#ifndef PerlIO_fast_gets
PERL_EXPORT_C int PerlIO_fast_gets(PerlIO *);
#endif
#ifndef PerlIO_canset_cnt
PERL_EXPORT_C int PerlIO_canset_cnt(PerlIO *);
#endif
#ifndef PerlIO_get_ptr
PERL_EXPORT_C STDCHAR *PerlIO_get_ptr(PerlIO *);
#endif
#ifndef PerlIO_get_cnt
PERL_EXPORT_C SSize_t PerlIO_get_cnt(PerlIO *);
#endif
#ifndef PerlIO_set_cnt
PERL_EXPORT_C void PerlIO_set_cnt(PerlIO *, SSize_t);
#endif
#ifndef PerlIO_set_ptrcnt
PERL_EXPORT_C void PerlIO_set_ptrcnt(PerlIO *, STDCHAR *, SSize_t);
#endif
#ifndef PerlIO_get_base
PERL_EXPORT_C STDCHAR *PerlIO_get_base(PerlIO *);
#endif
#ifndef PerlIO_get_bufsiz
PERL_EXPORT_C SSize_t PerlIO_get_bufsiz(PerlIO *);
#endif
#ifndef PerlIO_tmpfile
PERL_EXPORT_C PerlIO *PerlIO_tmpfile(void);
#endif
#ifndef PerlIO_stdin
PERL_EXPORT_C PerlIO *PerlIO_stdin(void);
#endif
#ifndef PerlIO_stdout
PERL_EXPORT_C PerlIO *PerlIO_stdout(void);
#endif
#ifndef PerlIO_stderr
PERL_EXPORT_C PerlIO *PerlIO_stderr(void);
#endif
#ifndef PerlIO_getpos
PERL_EXPORT_C int PerlIO_getpos(PerlIO *, SV *);
#endif
#ifndef PerlIO_setpos
PERL_EXPORT_C int PerlIO_setpos(PerlIO *, SV *);
#endif
#ifndef PerlIO_fdupopen
PERL_EXPORT_C PerlIO *PerlIO_fdupopen(pTHX_ PerlIO *, CLONE_PARAMS *, int);
#endif
#if !defined(PerlIO_modestr) && !defined(PERLIO_IS_STDIO)
PERL_EXPORT_C char *PerlIO_modestr(PerlIO *, char *buf);
#endif
#ifndef PerlIO_isutf8
PERL_EXPORT_C int PerlIO_isutf8(PerlIO *);
#endif
#ifndef PerlIO_apply_layers
PERL_EXPORT_C int PerlIO_apply_layers(pTHX_ PerlIO *f, const char *mode,
				      const char *names);
#endif
#ifndef PerlIO_binmode
PERL_EXPORT_C int PerlIO_binmode(pTHX_ PerlIO *f, int iotype, int omode,
			  	 const char *names);
#endif
#ifndef PerlIO_getname
PERL_EXPORT_C char *PerlIO_getname(PerlIO *, char *);
#endif

PERL_EXPORT_C void PerlIO_destruct(pTHX);

PERL_EXPORT_C int PerlIO_intmode2str(int rawmode, char *mode, int *writing);

#ifdef PERLIO_LAYERS
PERL_EXPORT_C void PerlIO_cleanup(pTHX);

PERL_EXPORT_C void PerlIO_debug(const char *fmt, ...)
    __attribute__format__(__printf__, 1, 2);
typedef struct PerlIO_list_s PerlIO_list_t;


#endif

END_EXTERN_C
#endif				/* _PERLIO_H */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                   usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/perliol.h                                                 0100644 0000000 0000000 00000032506 12744441327 017561  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _PERLIOL_H
#define _PERLIOL_H

typedef struct {
    PerlIO_funcs *funcs;
    SV *arg;
} PerlIO_pair_t;

struct PerlIO_list_s {
    IV refcnt;
    IV cur;
    IV len;
    PerlIO_pair_t *array;
};

struct _PerlIO_funcs {
    Size_t fsize;
    const char *name;
    Size_t size;
    U32 kind;
    IV (*Pushed) (pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
    IV (*Popped) (pTHX_ PerlIO *f);
    PerlIO *(*Open) (pTHX_ PerlIO_funcs *tab,
		     PerlIO_list_t *layers, IV n,
		     const char *mode,
		     int fd, int imode, int perm,
		     PerlIO *old, int narg, SV **args);
    IV (*Binmode)(pTHX_ PerlIO *f);
    SV *(*Getarg) (pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags);
    IV (*Fileno) (pTHX_ PerlIO *f);
    PerlIO *(*Dup) (pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
    /* Unix-like functions - cf sfio line disciplines */
     SSize_t(*Read) (pTHX_ PerlIO *f, void *vbuf, Size_t count);
     SSize_t(*Unread) (pTHX_ PerlIO *f, const void *vbuf, Size_t count);
     SSize_t(*Write) (pTHX_ PerlIO *f, const void *vbuf, Size_t count);
    IV (*Seek) (pTHX_ PerlIO *f, Off_t offset, int whence);
     Off_t(*Tell) (pTHX_ PerlIO *f);
    IV (*Close) (pTHX_ PerlIO *f);
    /* Stdio-like buffered IO functions */
    IV (*Flush) (pTHX_ PerlIO *f);
    IV (*Fill) (pTHX_ PerlIO *f);
    IV (*Eof) (pTHX_ PerlIO *f);
    IV (*Error) (pTHX_ PerlIO *f);
    void (*Clearerr) (pTHX_ PerlIO *f);
    void (*Setlinebuf) (pTHX_ PerlIO *f);
    /* Perl's snooping functions */
    STDCHAR *(*Get_base) (pTHX_ PerlIO *f);
     Size_t(*Get_bufsiz) (pTHX_ PerlIO *f);
    STDCHAR *(*Get_ptr) (pTHX_ PerlIO *f);
     SSize_t(*Get_cnt) (pTHX_ PerlIO *f);
    void (*Set_ptrcnt) (pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);
};

/*--------------------------------------------------------------------------------------*/
/* Kind values */
#define PERLIO_K_RAW		0x00000001
#define PERLIO_K_BUFFERED	0x00000002
#define PERLIO_K_CANCRLF	0x00000004
#define PERLIO_K_FASTGETS	0x00000008
#define PERLIO_K_DUMMY		0x00000010
#define PERLIO_K_UTF8		0x00008000
#define PERLIO_K_DESTRUCT	0x00010000
#define PERLIO_K_MULTIARG	0x00020000

/*--------------------------------------------------------------------------------------*/
struct _PerlIO {
    PerlIOl *next;		/* Lower layer */
    PerlIO_funcs *tab;		/* Functions for this layer */
    U32 flags;			/* Various flags for state */
    PerlIOl *head;		/* our ultimate parent pointer */
};

/*--------------------------------------------------------------------------------------*/

/* Flag values */
#define PERLIO_F_EOF		0x00000100
#define PERLIO_F_CANWRITE	0x00000200
#define PERLIO_F_CANREAD	0x00000400
#define PERLIO_F_ERROR		0x00000800
#define PERLIO_F_TRUNCATE	0x00001000
#define PERLIO_F_APPEND		0x00002000
#define PERLIO_F_CRLF		0x00004000
#define PERLIO_F_UTF8		0x00008000
#define PERLIO_F_UNBUF		0x00010000
#define PERLIO_F_WRBUF		0x00020000
#define PERLIO_F_RDBUF		0x00040000
#define PERLIO_F_LINEBUF	0x00080000
#define PERLIO_F_TEMP		0x00100000
#define PERLIO_F_OPEN		0x00200000
#define PERLIO_F_FASTGETS	0x00400000
#define PERLIO_F_TTY		0x00800000
#define PERLIO_F_NOTREG         0x01000000   
#define PERLIO_F_CLEARED        0x02000000 /* layer cleared but not freed */

#define PerlIOBase(f)      (*(f))
#define PerlIOSelf(f,type) ((type *)PerlIOBase(f))
#define PerlIONext(f)      (&(PerlIOBase(f)->next))
#define PerlIOValid(f)     ((f) && *(f))

/*--------------------------------------------------------------------------------------*/
/* Data exports - EXTCONST rather than extern is needed for Cygwin */
#undef EXTPERLIO 
#ifdef PERLIO_FUNCS_CONST
#define EXTPERLIO EXTCONST
#else
#define EXTPERLIO EXT
#endif
EXTPERLIO PerlIO_funcs PerlIO_unix;
EXTPERLIO PerlIO_funcs PerlIO_perlio;
EXTPERLIO PerlIO_funcs PerlIO_stdio;
EXTPERLIO PerlIO_funcs PerlIO_crlf;
EXTPERLIO PerlIO_funcs PerlIO_utf8;
EXTPERLIO PerlIO_funcs PerlIO_byte;
EXTPERLIO PerlIO_funcs PerlIO_raw;
EXTPERLIO PerlIO_funcs PerlIO_pending;
#ifdef WIN32
EXTPERLIO PerlIO_funcs PerlIO_win32;
#endif
PERL_EXPORT_C PerlIO *PerlIO_allocate(pTHX);
PERL_EXPORT_C SV *PerlIO_arg_fetch(PerlIO_list_t *av, IV n);
#define PerlIOArg PerlIO_arg_fetch(layers,n)

#ifdef PERLIO_USING_CRLF
#define PERLIO_STDTEXT "t"
#else
#define PERLIO_STDTEXT ""
#endif

/*--------------------------------------------------------------------------------------*/
/* perlio buffer layer
   As this is reasonably generic its struct and "methods" are declared here
   so they can be used to "inherit" from it.
*/

typedef struct {
    struct _PerlIO base;	/* Base "class" info */
    STDCHAR *buf;		/* Start of buffer */
    STDCHAR *end;		/* End of valid part of buffer */
    STDCHAR *ptr;		/* Current position in buffer */
    Off_t posn;			/* Offset of buf into the file */
    Size_t bufsiz;		/* Real size of buffer */
    IV oneword;			/* Emergency buffer */
} PerlIOBuf;

PERL_EXPORT_C int PerlIO_apply_layera(pTHX_ PerlIO *f, const char *mode,
		    PerlIO_list_t *layers, IV n, IV max);
PERL_EXPORT_C int PerlIO_parse_layers(pTHX_ PerlIO_list_t *av, const char *names);
PERL_EXPORT_C PerlIO_funcs *PerlIO_layer_fetch(pTHX_ PerlIO_list_t *av, IV n, PerlIO_funcs *def);


PERL_EXPORT_C SV *PerlIO_sv_dup(pTHX_ SV *arg, CLONE_PARAMS *param);
PERL_EXPORT_C void PerlIO_cleantable(pTHX_ PerlIOl **tablep);
PERL_EXPORT_C SV * PerlIO_tab_sv(pTHX_ PerlIO_funcs *tab);
PERL_EXPORT_C void PerlIO_default_buffer(pTHX_ PerlIO_list_t *av);
PERL_EXPORT_C void PerlIO_stdstreams(pTHX);
PERL_EXPORT_C int PerlIO__close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO_list_t * PerlIO_resolve_layers(pTHX_ const char *layers, const char *mode, int narg, SV **args);
PERL_EXPORT_C PerlIO_funcs * PerlIO_default_layer(pTHX_ I32 n);
PERL_EXPORT_C PerlIO_list_t * PerlIO_default_layers(pTHX);
PERL_EXPORT_C PerlIO * PerlIO_reopen(const char *path, const char *mode, PerlIO *f);

PERL_EXPORT_C PerlIO_list_t *PerlIO_list_alloc(pTHX);
PERL_EXPORT_C PerlIO_list_t *PerlIO_clone_list(pTHX_ PerlIO_list_t *proto, CLONE_PARAMS *param);
PERL_EXPORT_C void PerlIO_list_free(pTHX_ PerlIO_list_t *list);
PERL_EXPORT_C void PerlIO_list_push(pTHX_ PerlIO_list_t *list, PerlIO_funcs *funcs, SV *arg);
PERL_EXPORT_C void PerlIO_list_free(pTHX_ PerlIO_list_t *list);

/* PerlIO_teardown doesn't need exporting, but the EXTERN_C is needed
 * for compiling as C++.  Must also match with what perl.h says. */
EXTERN_C void PerlIO_teardown(void);

/*--------------------------------------------------------------------------------------*/
/* Generic, or stub layer functions */

PERL_EXPORT_C IV        PerlIOBase_binmode(pTHX_ PerlIO *f);
PERL_EXPORT_C void      PerlIOBase_clearerr(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOBase_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOBase_eof(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_error(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_fileno(pTHX_ PerlIO *f);
PERL_EXPORT_C void      PerlIOBase_flush_linebuf(pTHX);
PERL_EXPORT_C IV        PerlIOBase_noop_fail(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_noop_ok(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_popped(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C PerlIO *  PerlIOBase_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *old, int narg, SV **args);
PERL_EXPORT_C SSize_t   PerlIOBase_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C void      PerlIOBase_setlinebuf(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOBase_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Buf */
PERL_EXPORT_C Size_t    PerlIOBuf_bufsiz(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBuf_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOBuf_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOBuf_fill(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBuf_flush(pTHX_ PerlIO *f);
PERL_EXPORT_C STDCHAR * PerlIOBuf_get_base(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOBuf_get_cnt(pTHX_ PerlIO *f);
PERL_EXPORT_C STDCHAR * PerlIOBuf_get_ptr(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOBuf_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *old, int narg, SV **args);
PERL_EXPORT_C IV        PerlIOBuf_popped(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBuf_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOBuf_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C IV        PerlIOBuf_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C void      PerlIOBuf_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);
PERL_EXPORT_C Off_t     PerlIOBuf_tell(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOBuf_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
PERL_EXPORT_C SSize_t   PerlIOBuf_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Crlf */
PERL_EXPORT_C IV        PerlIOCrlf_binmode(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOCrlf_flush(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOCrlf_get_cnt(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOCrlf_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C void      PerlIOCrlf_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);
PERL_EXPORT_C SSize_t   PerlIOCrlf_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
PERL_EXPORT_C SSize_t   PerlIOCrlf_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Pending */
PERL_EXPORT_C IV        PerlIOPending_close(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOPending_fill(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOPending_flush(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOPending_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOPending_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C IV        PerlIOPending_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C void      PerlIOPending_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);

/* Pop */
PERL_EXPORT_C IV        PerlIOPop_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);

/* Raw */
PERL_EXPORT_C IV        PerlIORaw_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);

/* Stdio */
PERL_EXPORT_C void      PerlIOStdio_clearerr(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOStdio_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOStdio_eof(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_error(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_fileno(pTHX_ PerlIO *f);
#ifdef USE_STDIO_PTR
PERL_EXPORT_C STDCHAR * PerlIOStdio_get_ptr(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOStdio_get_cnt(pTHX_ PerlIO *f);
PERL_EXPORT_C void      PerlIOStdio_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);
#endif
PERL_EXPORT_C IV        PerlIOStdio_fill(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_flush(pTHX_ PerlIO *f);
#ifdef FILE_base
PERL_EXPORT_C STDCHAR * PerlIOStdio_get_base(pTHX_ PerlIO *f);
PERL_EXPORT_C Size_t    PerlIOStdio_get_bufsiz(pTHX_ PerlIO *f);
#endif
PERL_EXPORT_C char *    PerlIOStdio_mode(const char *mode, char *tmode);
PERL_EXPORT_C PerlIO *  PerlIOStdio_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *f, int narg, SV **args);
PERL_EXPORT_C IV        PerlIOStdio_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOStdio_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C IV        PerlIOStdio_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C void      PerlIOStdio_setlinebuf(pTHX_ PerlIO *f);
PERL_EXPORT_C Off_t     PerlIOStdio_tell(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOStdio_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
PERL_EXPORT_C SSize_t   PerlIOStdio_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Unix */
PERL_EXPORT_C IV        PerlIOUnix_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOUnix_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOUnix_fileno(pTHX_ PerlIO *f);
PERL_EXPORT_C int       PerlIOUnix_oflags(const char *mode);
PERL_EXPORT_C PerlIO *  PerlIOUnix_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *f, int narg, SV **args);
PERL_EXPORT_C IV        PerlIOUnix_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOUnix_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C int       PerlIOUnix_refcnt_dec(int fd);
PERL_EXPORT_C void      PerlIOUnix_refcnt_inc(int fd);
PERL_EXPORT_C int       PerlIOUnix_refcnt(int fd);
PERL_EXPORT_C IV        PerlIOUnix_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C Off_t     PerlIOUnix_tell(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOUnix_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Utf8 */
PERL_EXPORT_C IV        PerlIOUtf8_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);

#endif				/* _PERLIOL_H */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                          usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/perlsdio.h                                                0100644 0000000 0000000 00000011651 12744441327 017732  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    perlsdio.h
 *
 *    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef PERLIO_IS_STDIO

#ifdef NETWARE
	#include "nwstdio.h"
#else

/*
 * This file #define-s the PerlIO_xxx abstraction onto stdio functions.
 * Make this as close to original stdio as possible.
 */
#define PerlIO				FILE
#define PerlIO_stderr()			PerlSIO_stderr
#define PerlIO_stdout()			PerlSIO_stdout
#define PerlIO_stdin()			PerlSIO_stdin

#define PerlIO_isutf8(f)		0

#define PerlIO_printf			PerlSIO_printf
#define PerlIO_stdoutf			PerlSIO_stdoutf
#define PerlIO_vprintf(f,fmt,a)		PerlSIO_vprintf(f,fmt,a)
#define PerlIO_write(f,buf,count)	PerlSIO_fwrite(buf,1,count,f)
#define PerlIO_unread(f,buf,count)	(-1)
#define PerlIO_open			PerlSIO_fopen
#define PerlIO_fdopen			PerlSIO_fdopen
#define PerlIO_reopen			PerlSIO_freopen
#define PerlIO_close(f)			PerlSIO_fclose(f)
#define PerlIO_puts(f,s)		PerlSIO_fputs(s,f)
#define PerlIO_putc(f,c)		PerlSIO_fputc(c,f)
#if defined(VMS)
#  if defined(__DECC)
     /* Unusual definition of ungetc() here to accommodate fast_sv_gets()'
      * belief that it can mix getc/ungetc with reads from stdio buffer */
     int decc$ungetc(int __c, FILE *__stream);
#    define PerlIO_ungetc(f,c) ((c) == EOF ? EOF : \
            ((*(f) && !((*(f))->_flag & _IONBF) && \
            ((*(f))->_ptr > (*(f))->_base)) ? \
            ((*(f))->_cnt++, *(--(*(f))->_ptr) = (c)) : decc$ungetc(c,f)))
#  else
#    define PerlIO_ungetc(f,c)		ungetc(c,f)
#  endif
   /* Work around bug in DECCRTL/AXP (DECC v5.x) and some versions of old
    * VAXCRTL which causes read from a pipe after EOF has been returned
    * once to hang.
    */
#  define PerlIO_getc(f) \
		(feof(f) ? EOF : getc(f))
#  define PerlIO_read(f,buf,count) \
		(feof(f) ? 0 : (SSize_t)fread(buf,1,count,f))
#  define PerlIO_tell(f)		ftell(f)
#else
#  define PerlIO_getc(f)		PerlSIO_fgetc(f)
#  define PerlIO_ungetc(f,c)		PerlSIO_ungetc(c,f)
#  define PerlIO_read(f,buf,count)	(SSize_t)PerlSIO_fread(buf,1,count,f)
#  define PerlIO_tell(f)		PerlSIO_ftell(f)
#endif
#define PerlIO_eof(f)			PerlSIO_feof(f)
#define PerlIO_getname(f,b)		fgetname(f,b)
#define PerlIO_error(f)			PerlSIO_ferror(f)
#define PerlIO_fileno(f)		PerlSIO_fileno(f)
#define PerlIO_clearerr(f)		PerlSIO_clearerr(f)
#define PerlIO_flush(f)			PerlSIO_fflush(f)
#if defined(VMS) && !defined(__DECC)
/* Old VAXC RTL doesn't reset EOF on seek; Perl folk seem to expect this */
#define PerlIO_seek(f,o,w)	(((f) && (*f) && ((*f)->_flag &= ~_IOEOF)),fseek(f,o,w))
#else
#  define PerlIO_seek(f,o,w)		PerlSIO_fseek(f,o,w)
#endif

#define PerlIO_rewind(f)		PerlSIO_rewind(f)
#define PerlIO_tmpfile()		PerlSIO_tmpfile()

#define PerlIO_importFILE(f,fl)		(f)
#define PerlIO_exportFILE(f,fl)		(f)
#define PerlIO_findFILE(f)		(f)
#define PerlIO_releaseFILE(p,f)		((void) 0)

#ifdef HAS_SETLINEBUF
#define PerlIO_setlinebuf(f)		PerlSIO_setlinebuf(f);
#else
#define PerlIO_setlinebuf(f)		PerlSIO_setvbuf(f, NULL, _IOLBF, 0);
#endif

/* Now our interface to Configure's FILE_xxx macros */

#ifdef USE_STDIO_PTR
#define PerlIO_has_cntptr(f)		1
#define PerlIO_get_ptr(f)		PerlSIO_get_ptr(f)
#define PerlIO_get_cnt(f)		PerlSIO_get_cnt(f)

#ifdef STDIO_CNT_LVALUE
#define PerlIO_canset_cnt(f)		1
#define PerlIO_set_cnt(f,c)		PerlSIO_set_cnt(f,c)
#ifdef STDIO_PTR_LVALUE
#ifdef STDIO_PTR_LVAL_NOCHANGE_CNT
#define PerlIO_fast_gets(f)		1
#endif
#endif /* STDIO_PTR_LVALUE */
#else /* STDIO_CNT_LVALUE */
#define PerlIO_canset_cnt(f)		0
#define PerlIO_set_cnt(f,c)		abort()
#endif

#ifdef STDIO_PTR_LVALUE
#ifdef STDIO_PTR_LVAL_NOCHANGE_CNT
#define PerlIO_set_ptrcnt(f,p,c)      STMT_START {PerlSIO_set_ptr(f,p), PerlIO_set_cnt(f,c);} STMT_END
#else
#ifdef STDIO_PTR_LVAL_SETS_CNT
/* assert() may pre-process to ""; potential syntax error (FILE_ptr(), ) */
#define PerlIO_set_ptrcnt(f,p,c)      STMT_START {PerlSIO_set_ptr(f,p); assert(PerlSIO_get_cnt(f) == (c));} STMT_END
#define PerlIO_fast_gets(f)		1
#else
#define PerlIO_set_ptrcnt(f,p,c)	abort()
#endif
#endif
#endif

#else  /* USE_STDIO_PTR */

#define PerlIO_has_cntptr(f)		0
#define PerlIO_canset_cnt(f)		0
#define PerlIO_get_cnt(f)		(abort(),0)
#define PerlIO_get_ptr(f)		(abort(),(void *)0)
#define PerlIO_set_cnt(f,c)		abort()
#define PerlIO_set_ptrcnt(f,p,c)	abort()

#endif /* USE_STDIO_PTR */

#ifndef PerlIO_fast_gets
#define PerlIO_fast_gets(f)		0
#endif


#ifdef FILE_base
#define PerlIO_has_base(f)		1
#define PerlIO_get_base(f)		PerlSIO_get_base(f)
#define PerlIO_get_bufsiz(f)		PerlSIO_get_bufsiz(f)
#else
#define PerlIO_has_base(f)		0
#define PerlIO_get_base(f)		(abort(),(void *)0)
#define PerlIO_get_bufsiz(f)		(abort(),0)
#endif

#endif	/* NETWARE */
#endif /* PERLIO_IS_STDIO */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                       usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/perlvars.h                                                0100644 0000000 0000000 00000021407 12744441327 017747  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    perlvars.h
 *
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
=head1 Global Variables

These variables are global to an entire process.  They are shared between
all interpreters and all threads in a process.

=cut
*/

/* Don't forget to re-run regen/embed.pl to propagate changes! */

/* This file describes the "global" variables used by perl
 * This used to be in perl.h directly but we want to abstract out into
 * distinct files which are per-thread, per-interpreter or really global,
 * and how they're initialized.
 *
 * The 'G' prefix is only needed for vars that need appropriate #defines
 * generated in embed*.h.  Such symbols are also used to generate
 * the appropriate export list for win32. */

/* global state */
#if defined(USE_ITHREADS)
PERLVAR(G, op_mutex,	perl_mutex)	/* Mutex for op refcounting */
#endif
PERLVARI(G, curinterp,	PerlInterpreter *, NULL)
					/* currently running interpreter
					 * (initial parent interpreter under
					 * useithreads) */
#if defined(USE_ITHREADS)
PERLVAR(G, thr_key,	perl_key)	/* key to retrieve per-thread struct */
#endif

/* XXX does anyone even use this? */
PERLVARI(G, do_undump,	bool,	FALSE)	/* -u or dump seen? */

#ifndef PERL_USE_SAFE_PUTENV
PERLVARI(G, use_safe_putenv, bool, TRUE)
#endif

#if defined(FAKE_PERSISTENT_SIGNAL_HANDLERS)||defined(FAKE_DEFAULT_SIGNAL_HANDLERS)
PERLVARI(G, sig_handlers_initted, int, 0)
#endif
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
PERLVARA(G, sig_ignoring, SIG_SIZE, int)
					/* which signals we are ignoring */
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
PERLVARA(G, sig_defaulting, SIG_SIZE, int)
#endif

/* XXX signals are process-wide anyway, so we
 * ignore the implications of this for threading */
#ifndef HAS_SIGACTION
PERLVARI(G, sig_trapped, int,	0)
#endif

#ifndef PERL_MICRO
/* If Perl has to ignore SIGPFE, this is its saved state.
 * See perl.h macros PERL_FPU_INIT and PERL_FPU_{PRE,POST}_EXEC. */
PERLVAR(G, sigfpe_saved, Sighandler_t)
PERLVARI(G, csighandlerp, Sighandler_t, Perl_csighandler)
					/* Pointer to C-level sighandler */
#endif

/* This is constant on most architectures, a global on OS/2 */
#ifdef OS2
PERLVARI(G, sh_path,	char *, SH_PATH) /* full path of shell */
#endif

#ifdef USE_PERLIO

#  if defined(USE_ITHREADS)
PERLVAR(G, perlio_mutex, perl_mutex)    /* Mutex for perlio fd refcounts */
#  endif

PERLVARI(G, perlio_fd_refcnt, int *, 0) /* Pointer to array of fd refcounts.  */
PERLVARI(G, perlio_fd_refcnt_size, int, 0) /* Size of the array */
PERLVARI(G, perlio_debug_fd, int, 0)	/* the fd to write perlio debug into, 0 means not set yet */
#endif

#ifdef HAS_MMAP
PERLVARI(G, mmap_page_size, IV, 0)
#endif

#if defined(USE_ITHREADS)
PERLVAR(G, hints_mutex, perl_mutex)    /* Mutex for refcounted he refcounting */
#endif

#ifdef DEBUGGING
PERLVARI(G, watch_pvx,	char *, NULL)
#endif

/*
=for apidoc AmU|Perl_check_t *|PL_check

Array, indexed by opcode, of functions that will be called for the "check"
phase of optree building during compilation of Perl code.  For most (but
not all) types of op, once the op has been initially built and populated
with child ops it will be filtered through the check function referenced
by the appropriate element of this array.  The new op is passed in as the
sole argument to the check function, and the check function returns the
completed op.  The check function may (as the name suggests) check the op
for validity and signal errors.  It may also initialise or modify parts of
the ops, or perform more radical surgery such as adding or removing child
ops, or even throw the op away and return a different op in its place.

This array of function pointers is a convenient place to hook into the
compilation process.  An XS module can put its own custom check function
in place of any of the standard ones, to influence the compilation of a
particular type of op.  However, a custom check function must never fully
replace a standard check function (or even a custom check function from
another module).  A module modifying checking must instead B<wrap> the
preexisting check function.  A custom check function must be selective
about when to apply its custom behaviour.  In the usual case where
it decides not to do anything special with an op, it must chain the
preexisting op function.  Check functions are thus linked in a chain,
with the core's base checker at the end.

For thread safety, modules should not write directly to this array.
Instead, use the function L</wrap_op_checker>.

=cut
*/

#if defined(USE_ITHREADS)
PERLVAR(G, check_mutex,	perl_mutex)	/* Mutex for PL_check */
#endif
#ifdef PERL_GLOBAL_STRUCT 
PERLVAR(G, ppaddr,	Perl_ppaddr_t *) /* or opcode.h */
PERLVAR(G, check,	Perl_check_t *) /* or opcode.h */
PERLVARA(G, fold_locale, 256, unsigned char) /* or perl.h */
#endif

#ifdef PERL_NEED_APPCTX
PERLVAR(G, appctx,	void*)		/* the application context */
#endif

#if defined(HAS_TIMES) && defined(PERL_NEED_TIMESBASE)
PERLVAR(G, timesbase,	struct tms)
#endif

/* allocate a unique index to every module that calls MY_CXT_INIT */

#ifdef PERL_IMPLICIT_CONTEXT
# ifdef USE_ITHREADS
PERLVAR(G, my_ctx_mutex, perl_mutex)
# endif
PERLVARI(G, my_cxt_index, int,	0)
#endif

/* this is currently set without MUTEX protection, so keep it a type which
 * can be set atomically (ie not a bit field) */
PERLVARI(G, veto_cleanup, int, FALSE)	/* exit without cleanup */

/*
=for apidoc AmUx|Perl_keyword_plugin_t|PL_keyword_plugin

Function pointer, pointing at a function used to handle extended keywords.
The function should be declared as

	int keyword_plugin_function(pTHX_
		char *keyword_ptr, STRLEN keyword_len,
		OP **op_ptr)

The function is called from the tokeniser, whenever a possible keyword
is seen.  C<keyword_ptr> points at the word in the parser's input
buffer, and C<keyword_len> gives its length; it is not null-terminated.
The function is expected to examine the word, and possibly other state
such as L<%^H|perlvar/%^H>, to decide whether it wants to handle it
as an extended keyword.  If it does not, the function should return
C<KEYWORD_PLUGIN_DECLINE>, and the normal parser process will continue.

If the function wants to handle the keyword, it first must
parse anything following the keyword that is part of the syntax
introduced by the keyword.  See L</Lexer interface> for details.

When a keyword is being handled, the plugin function must build
a tree of C<OP> structures, representing the code that was parsed.
The root of the tree must be stored in C<*op_ptr>.  The function then
returns a constant indicating the syntactic role of the construct that
it has parsed: C<KEYWORD_PLUGIN_STMT> if it is a complete statement, or
C<KEYWORD_PLUGIN_EXPR> if it is an expression.  Note that a statement
construct cannot be used inside an expression (except via C<do BLOCK>
and similar), and an expression is not a complete statement (it requires
at least a terminating semicolon).

When a keyword is handled, the plugin function may also have
(compile-time) side effects.  It may modify C<%^H>, define functions, and
so on.  Typically, if side effects are the main purpose of a handler,
it does not wish to generate any ops to be included in the normal
compilation.  In this case it is still required to supply an op tree,
but it suffices to generate a single null op.

That's how the C<*PL_keyword_plugin> function needs to behave overall.
Conventionally, however, one does not completely replace the existing
handler function.  Instead, take a copy of C<PL_keyword_plugin> before
assigning your own function pointer to it.  Your handler function should
look for keywords that it is interested in and handle those.  Where it
is not interested, it should call the saved plugin function, passing on
the arguments it received.  Thus C<PL_keyword_plugin> actually points
at a chain of handler functions, all of which have an opportunity to
handle keywords, and only the last function in the chain (built into
the Perl core) will normally return C<KEYWORD_PLUGIN_DECLINE>.

=cut
*/

PERLVARI(G, keyword_plugin, Perl_keyword_plugin_t, Perl_keyword_plugin_standard)

PERLVARI(G, op_sequence, HV *, NULL)	/* dump.c */
PERLVARI(G, op_seq,	UV,	0)	/* dump.c */

#ifdef USE_ITHREADS
PERLVAR(G, dollarzero_mutex, perl_mutex) /* Modifying $0 */
#endif

/* Restricted hashes placeholder value.
   In theory, the contents are never used, only the address.
   In practice, &PL_sv_placeholder is returned by some APIs, and the calling
   code is checking SvOK().  */

PERLVAR(G, sv_placeholder, SV)

#if defined(MYMALLOC) && defined(USE_ITHREADS)
PERLVAR(G, malloc_mutex, perl_mutex)	/* Mutex for malloc */
#endif

PERLVARI(G, hash_seed_set, bool, FALSE)	/* perl.c */
PERLVARA(G, hash_seed, PERL_HASH_SEED_BYTES, unsigned char) /* perl.c and hv.h */
                                                                                                                                                                                                                                                         usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/perly.h                                                   0100644 0000000 0000000 00000014126 12744441327 017244  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regen_perly.pl from perly.y.
   Any changes made here will be lost!
 */

#ifdef PERL_CORE
/* A Bison parser, made by GNU Bison 2.5.  */

/* Bison interface for Yacc-like parsers in C
   
      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
   
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.
   
   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */


/* Tokens.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
   /* Put the tokens into the symbol table, so that GDB and other debuggers
      know about them.  */
   enum yytokentype {
     GRAMPROG = 258,
     GRAMEXPR = 259,
     GRAMBLOCK = 260,
     GRAMBARESTMT = 261,
     GRAMFULLSTMT = 262,
     GRAMSTMTSEQ = 263,
     WORD = 264,
     METHOD = 265,
     FUNCMETH = 266,
     THING = 267,
     PMFUNC = 268,
     PRIVATEREF = 269,
     QWLIST = 270,
     FUNC0OP = 271,
     FUNC0SUB = 272,
     UNIOPSUB = 273,
     LSTOPSUB = 274,
     PLUGEXPR = 275,
     PLUGSTMT = 276,
     LABEL = 277,
     FORMAT = 278,
     SUB = 279,
     ANONSUB = 280,
     PACKAGE = 281,
     USE = 282,
     WHILE = 283,
     UNTIL = 284,
     IF = 285,
     UNLESS = 286,
     ELSE = 287,
     ELSIF = 288,
     CONTINUE = 289,
     FOR = 290,
     GIVEN = 291,
     WHEN = 292,
     DEFAULT = 293,
     LOOPEX = 294,
     DOTDOT = 295,
     YADAYADA = 296,
     FUNC0 = 297,
     FUNC1 = 298,
     FUNC = 299,
     UNIOP = 300,
     LSTOP = 301,
     RELOP = 302,
     EQOP = 303,
     MULOP = 304,
     ADDOP = 305,
     DOLSHARP = 306,
     DO = 307,
     HASHBRACK = 308,
     NOAMP = 309,
     LOCAL = 310,
     MY = 311,
     REQUIRE = 312,
     COLONATTR = 313,
     FORMLBRACK = 314,
     FORMRBRACK = 315,
     PREC_LOW = 316,
     DOROP = 317,
     OROP = 318,
     ANDOP = 319,
     NOTOP = 320,
     ASSIGNOP = 321,
     DORDOR = 322,
     OROR = 323,
     ANDAND = 324,
     BITOROP = 325,
     BITANDOP = 326,
     SHIFTOP = 327,
     MATCHOP = 328,
     REFGEN = 329,
     UMINUS = 330,
     POWOP = 331,
     POSTJOIN = 332,
     POSTDEC = 333,
     POSTINC = 334,
     PREDEC = 335,
     PREINC = 336,
     ARROW = 337,
     PEG = 338
   };
#endif

/* Tokens.  */
#define GRAMPROG 258
#define GRAMEXPR 259
#define GRAMBLOCK 260
#define GRAMBARESTMT 261
#define GRAMFULLSTMT 262
#define GRAMSTMTSEQ 263
#define WORD 264
#define METHOD 265
#define FUNCMETH 266
#define THING 267
#define PMFUNC 268
#define PRIVATEREF 269
#define QWLIST 270
#define FUNC0OP 271
#define FUNC0SUB 272
#define UNIOPSUB 273
#define LSTOPSUB 274
#define PLUGEXPR 275
#define PLUGSTMT 276
#define LABEL 277
#define FORMAT 278
#define SUB 279
#define ANONSUB 280
#define PACKAGE 281
#define USE 282
#define WHILE 283
#define UNTIL 284
#define IF 285
#define UNLESS 286
#define ELSE 287
#define ELSIF 288
#define CONTINUE 289
#define FOR 290
#define GIVEN 291
#define WHEN 292
#define DEFAULT 293
#define LOOPEX 294
#define DOTDOT 295
#define YADAYADA 296
#define FUNC0 297
#define FUNC1 298
#define FUNC 299
#define UNIOP 300
#define LSTOP 301
#define RELOP 302
#define EQOP 303
#define MULOP 304
#define ADDOP 305
#define DOLSHARP 306
#define DO 307
#define HASHBRACK 308
#define NOAMP 309
#define LOCAL 310
#define MY 311
#define REQUIRE 312
#define COLONATTR 313
#define FORMLBRACK 314
#define FORMRBRACK 315
#define PREC_LOW 316
#define DOROP 317
#define OROP 318
#define ANDOP 319
#define NOTOP 320
#define ASSIGNOP 321
#define DORDOR 322
#define OROR 323
#define ANDAND 324
#define BITOROP 325
#define BITANDOP 326
#define SHIFTOP 327
#define MATCHOP 328
#define REFGEN 329
#define UMINUS 330
#define POWOP 331
#define POSTJOIN 332
#define POSTDEC 333
#define POSTINC 334
#define PREDEC 335
#define PREINC 336
#define ARROW 337
#define PEG 338



#ifdef PERL_IN_TOKE_C
static bool
S_is_opval_token(int type) {
    switch (type) {
    case FUNC0OP:
    case FUNC0SUB:
    case FUNCMETH:
    case LSTOPSUB:
    case METHOD:
    case PLUGEXPR:
    case PLUGSTMT:
    case PMFUNC:
    case PRIVATEREF:
    case QWLIST:
    case THING:
    case UNIOPSUB:
    case WORD:
	return 1;
    }
    return 0;
}
#endif /* PERL_IN_TOKE_C */
#endif /* PERL_CORE */
#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef union YYSTYPE
{

/* Line 2068 of yacc.c  */

    I32	ival; /* __DEFAULT__ (marker for regen_perly.pl;
				must always be 1st union member) */
    char *pval;
    OP *opval;
    GV *gvval;
#ifdef PERL_IN_MADLY_C
    TOKEN* p_tkval;
    TOKEN* i_tkval;
#else
    char *p_tkval;
    I32	i_tkval;
#endif
#ifdef PERL_MAD
    TOKEN* tkval;
#endif



/* Line 2068 of yacc.c  */
} YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define yystype YYSTYPE /* obsolescent; will be withdrawn */
# define YYSTYPE_IS_DECLARED 1
#endif





/* Generated from:
 * bb8245a1a537b2afb2445b3973f63b210f9ec346a1955071aef7d05ba97196ae perly.y
 * 5c9d2a0262457fe9b70073fc8ad6c188f812f38ad57712b7e2f53daa01b297cc regen_perly.pl
 * ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/pp.h                                                      0100644 0000000 0000000 00000047522 12744441327 016536  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    pp.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#define PP(s) OP * Perl_##s(pTHX)

/*
=head1 Stack Manipulation Macros

=for apidoc AmU||SP
Stack pointer.  This is usually handled by C<xsubpp>.  See C<dSP> and
C<SPAGAIN>.

=for apidoc AmU||MARK
Stack marker variable for the XSUB.  See C<dMARK>.

=for apidoc Am|void|PUSHMARK|SP
Opening bracket for arguments on a callback.  See C<PUTBACK> and
L<perlcall>.

=for apidoc Ams||dSP
Declares a local copy of perl's stack pointer for the XSUB, available via
the C<SP> macro.  See C<SP>.

=for apidoc ms||djSP

Declare Just C<SP>.  This is actually identical to C<dSP>, and declares
a local copy of perl's stack pointer, available via the C<SP> macro.
See C<SP>.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)

=for apidoc Ams||dMARK
Declare a stack marker variable, C<mark>, for the XSUB.  See C<MARK> and
C<dORIGMARK>.

=for apidoc Ams||dORIGMARK
Saves the original stack mark for the XSUB.  See C<ORIGMARK>.

=for apidoc AmU||ORIGMARK
The original stack mark for the XSUB.  See C<dORIGMARK>.

=for apidoc Ams||SPAGAIN
Refetch the stack pointer.  Used after a callback.  See L<perlcall>.

=cut */

#undef SP /* Solaris 2.7 i386 has this in /usr/include/sys/reg.h */
#define SP sp
#define MARK mark
#define TARG targ

#define PUSHMARK(p)	\
	STMT_START {					\
	    if (UNLIKELY(++PL_markstack_ptr == PL_markstack_max))	\
	    markstack_grow();				\
	    *PL_markstack_ptr = (I32)((p) - PL_stack_base);\
	} STMT_END

#define TOPMARK		(*PL_markstack_ptr)
#define POPMARK		(*PL_markstack_ptr--)

#define dSP		SV **sp = PL_stack_sp
#define djSP		dSP
#define dMARK		SV **mark = PL_stack_base + POPMARK
#define dORIGMARK	const I32 origmark = (I32)(mark - PL_stack_base)
#define ORIGMARK	(PL_stack_base + origmark)

#define SPAGAIN		sp = PL_stack_sp
#define MSPAGAIN	STMT_START { sp = PL_stack_sp; mark = ORIGMARK; } STMT_END

#define GETTARGETSTACKED targ = (PL_op->op_flags & OPf_STACKED ? POPs : PAD_SV(PL_op->op_targ))
#define dTARGETSTACKED SV * GETTARGETSTACKED

#define GETTARGET targ = PAD_SV(PL_op->op_targ)
#define dTARGET SV * GETTARGET

#define GETATARGET targ = (PL_op->op_flags & OPf_STACKED ? sp[-1] : PAD_SV(PL_op->op_targ))
#define dATARGET SV * GETATARGET

#define dTARG SV *targ

#define NORMAL PL_op->op_next
#define DIE return Perl_die

/*
=for apidoc Ams||PUTBACK
Closing bracket for XSUB arguments.  This is usually handled by C<xsubpp>.
See C<PUSHMARK> and L<perlcall> for other uses.

=for apidoc Amn|SV*|POPs
Pops an SV off the stack.

=for apidoc Amn|char*|POPp
Pops a string off the stack.

=for apidoc Amn|char*|POPpx
Pops a string off the stack.  Identical to POPp.  There are two names for
historical reasons.

=for apidoc Amn|char*|POPpbytex
Pops a string off the stack which must consist of bytes i.e. characters < 256.

=for apidoc Amn|NV|POPn
Pops a double off the stack.

=for apidoc Amn|IV|POPi
Pops an integer off the stack.

=for apidoc Amn|long|POPl
Pops a long off the stack.

=cut
*/

#define PUTBACK		PL_stack_sp = sp
#define RETURN		return (PUTBACK, NORMAL)
#define RETURNOP(o)	return (PUTBACK, o)
#define RETURNX(x)	return (x, PUTBACK, NORMAL)

#define POPs		(*sp--)
#define POPp		POPpx
#define POPpx		(SvPVx_nolen(POPs))
#define POPpconstx	(SvPVx_nolen_const(POPs))
#define POPpbytex	(SvPVbytex_nolen(POPs))
#define POPn		(SvNVx(POPs))
#define POPi		((IV)SvIVx(POPs))
#define POPu		((UV)SvUVx(POPs))
#define POPl		((long)SvIVx(POPs))
#define POPul		((unsigned long)SvIVx(POPs))

#define TOPs		(*sp)
#define TOPm1s		(*(sp-1))
#define TOPp1s		(*(sp+1))
#define TOPp		TOPpx
#define TOPpx		(SvPV_nolen(TOPs))
#define TOPn		(SvNV(TOPs))
#define TOPi		((IV)SvIV(TOPs))
#define TOPu		((UV)SvUV(TOPs))
#define TOPl		((long)SvIV(TOPs))
#define TOPul		((unsigned long)SvUV(TOPs))

/* Go to some pains in the rare event that we must extend the stack. */

/*
=for apidoc Am|void|EXTEND|SP|SSize_t nitems
Used to extend the argument stack for an XSUB's return values.  Once
used, guarantees that there is room for at least C<nitems> to be pushed
onto the stack.

=for apidoc Am|void|PUSHs|SV* sv
Push an SV onto the stack.  The stack must have room for this element.
Does not handle 'set' magic.  Does not use C<TARG>.  See also C<PUSHmortal>,
C<XPUSHs> and C<XPUSHmortal>.

=for apidoc Am|void|PUSHp|char* str|STRLEN len
Push a string onto the stack.  The stack must have room for this element.
The C<len> indicates the length of the string.  Handles 'set' magic.  Uses
C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to declare it.  Do not
call multiple C<TARG>-oriented macros to return lists from XSUB's - see
C<mPUSHp> instead.  See also C<XPUSHp> and C<mXPUSHp>.

=for apidoc Am|void|PUSHn|NV nv
Push a double onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to
return lists from XSUB's - see C<mPUSHn> instead.  See also C<XPUSHn> and
C<mXPUSHn>.

=for apidoc Am|void|PUSHi|IV iv
Push an integer onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to 
return lists from XSUB's - see C<mPUSHi> instead.  See also C<XPUSHi> and
C<mXPUSHi>.

=for apidoc Am|void|PUSHu|UV uv
Push an unsigned integer onto the stack.  The stack must have room for this
element.  Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG>
should be called to declare it.  Do not call multiple C<TARG>-oriented
macros to return lists from XSUB's - see C<mPUSHu> instead.  See also
C<XPUSHu> and C<mXPUSHu>.

=for apidoc Am|void|XPUSHs|SV* sv
Push an SV onto the stack, extending the stack if necessary.  Does not
handle 'set' magic.  Does not use C<TARG>.  See also C<XPUSHmortal>,
C<PUSHs> and C<PUSHmortal>.

=for apidoc Am|void|XPUSHp|char* str|STRLEN len
Push a string onto the stack, extending the stack if necessary.  The C<len>
indicates the length of the string.  Handles 'set' magic.  Uses C<TARG>, so
C<dTARGET> or C<dXSTARG> should be called to declare it.  Do not call
multiple C<TARG>-oriented macros to return lists from XSUB's - see
C<mXPUSHp> instead.  See also C<PUSHp> and C<mPUSHp>.

=for apidoc Am|void|XPUSHn|NV nv
Push a double onto the stack, extending the stack if necessary.  Handles
'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to
declare it.  Do not call multiple C<TARG>-oriented macros to return lists
from XSUB's - see C<mXPUSHn> instead.  See also C<PUSHn> and C<mPUSHn>.

=for apidoc Am|void|XPUSHi|IV iv
Push an integer onto the stack, extending the stack if necessary.  Handles
'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to
declare it.  Do not call multiple C<TARG>-oriented macros to return lists
from XSUB's - see C<mXPUSHi> instead.  See also C<PUSHi> and C<mPUSHi>.

=for apidoc Am|void|XPUSHu|UV uv
Push an unsigned integer onto the stack, extending the stack if necessary.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to
return lists from XSUB's - see C<mXPUSHu> instead.  See also C<PUSHu> and
C<mPUSHu>.

=for apidoc Am|void|mPUSHs|SV* sv
Push an SV onto the stack and mortalizes the SV.  The stack must have room
for this element.  Does not use C<TARG>.  See also C<PUSHs> and C<mXPUSHs>.

=for apidoc Am|void|PUSHmortal
Push a new mortal SV onto the stack.  The stack must have room for this
element.  Does not use C<TARG>.  See also C<PUSHs>, C<XPUSHmortal> and C<XPUSHs>.

=for apidoc Am|void|mPUSHp|char* str|STRLEN len
Push a string onto the stack.  The stack must have room for this element.
The C<len> indicates the length of the string.  Does not use C<TARG>.
See also C<PUSHp>, C<mXPUSHp> and C<XPUSHp>.

=for apidoc Am|void|mPUSHn|NV nv
Push a double onto the stack.  The stack must have room for this element.
Does not use C<TARG>.  See also C<PUSHn>, C<mXPUSHn> and C<XPUSHn>.

=for apidoc Am|void|mPUSHi|IV iv
Push an integer onto the stack.  The stack must have room for this element.
Does not use C<TARG>.  See also C<PUSHi>, C<mXPUSHi> and C<XPUSHi>.

=for apidoc Am|void|mPUSHu|UV uv
Push an unsigned integer onto the stack.  The stack must have room for this
element.  Does not use C<TARG>.  See also C<PUSHu>, C<mXPUSHu> and C<XPUSHu>.

=for apidoc Am|void|mXPUSHs|SV* sv
Push an SV onto the stack, extending the stack if necessary and mortalizes
the SV.  Does not use C<TARG>.  See also C<XPUSHs> and C<mPUSHs>.

=for apidoc Am|void|XPUSHmortal
Push a new mortal SV onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<XPUSHs>, C<PUSHmortal> and C<PUSHs>.

=for apidoc Am|void|mXPUSHp|char* str|STRLEN len
Push a string onto the stack, extending the stack if necessary.  The C<len>
indicates the length of the string.  Does not use C<TARG>.  See also C<XPUSHp>,
C<mPUSHp> and C<PUSHp>.

=for apidoc Am|void|mXPUSHn|NV nv
Push a double onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<XPUSHn>, C<mPUSHn> and C<PUSHn>.

=for apidoc Am|void|mXPUSHi|IV iv
Push an integer onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<XPUSHi>, C<mPUSHi> and C<PUSHi>.

=for apidoc Am|void|mXPUSHu|UV uv
Push an unsigned integer onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<XPUSHu>, C<mPUSHu> and C<PUSHu>.

=cut
*/

#ifdef STRESS_REALLOC
# define EXTEND(p,n)	(void)(sp = stack_grow(sp,p, (SSize_t)(n)))
/* Same thing, but update mark register too. */
# define MEXTEND(p,n)	STMT_START {					\
			    const int markoff = mark - PL_stack_base;	\
			    sp = stack_grow(sp,p,(SSize_t) (n));	\
			    mark = PL_stack_base + markoff;		\
			} STMT_END
#else
# define EXTEND(p,n)   (void)(UNLIKELY(PL_stack_max - p < (SSize_t)(n)) &&     \
			    (sp = stack_grow(sp,p, (SSize_t) (n))))

/* Same thing, but update mark register too. */
# define MEXTEND(p,n)  STMT_START {if (UNLIKELY(PL_stack_max - p < (int)(n))) {\
                           const int markoff = mark - PL_stack_base;           \
                           sp = stack_grow(sp,p,(SSize_t) (n));                \
                           mark = PL_stack_base + markoff;                     \
                       } } STMT_END
#endif

#define PUSHs(s)	(*++sp = (s))
#define PUSHTARG	STMT_START { SvSETMAGIC(TARG); PUSHs(TARG); } STMT_END
#define PUSHp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); PUSHTARG; } STMT_END
#define PUSHn(n)	STMT_START { sv_setnv(TARG, (NV)(n)); PUSHTARG; } STMT_END
#define PUSHi(i)	STMT_START { sv_setiv(TARG, (IV)(i)); PUSHTARG; } STMT_END
#define PUSHu(u)	STMT_START { sv_setuv(TARG, (UV)(u)); PUSHTARG; } STMT_END

#define XPUSHs(s)	(EXTEND(sp,1), *++sp = (s))
#define XPUSHTARG	STMT_START { SvSETMAGIC(TARG); XPUSHs(TARG); } STMT_END
#define XPUSHp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); XPUSHTARG; } STMT_END
#define XPUSHn(n)	STMT_START { sv_setnv(TARG, (NV)(n)); XPUSHTARG; } STMT_END
#define XPUSHi(i)	STMT_START { sv_setiv(TARG, (IV)(i)); XPUSHTARG; } STMT_END
#define XPUSHu(u)	STMT_START { sv_setuv(TARG, (UV)(u)); XPUSHTARG; } STMT_END
#define XPUSHundef	STMT_START { SvOK_off(TARG); XPUSHs(TARG); } STMT_END

#define mPUSHs(s)	PUSHs(sv_2mortal(s))
#define PUSHmortal	PUSHs(sv_newmortal())
#define mPUSHp(p,l)	PUSHs(newSVpvn_flags((p), (l), SVs_TEMP))
#define mPUSHn(n)	sv_setnv(PUSHmortal, (NV)(n))
#define mPUSHi(i)	sv_setiv(PUSHmortal, (IV)(i))
#define mPUSHu(u)	sv_setuv(PUSHmortal, (UV)(u))

#define mXPUSHs(s)	XPUSHs(sv_2mortal(s))
#define XPUSHmortal	XPUSHs(sv_newmortal())
#define mXPUSHp(p,l)	STMT_START { EXTEND(sp,1); mPUSHp((p), (l)); } STMT_END
#define mXPUSHn(n)	STMT_START { EXTEND(sp,1); sv_setnv(PUSHmortal, (NV)(n)); } STMT_END
#define mXPUSHi(i)	STMT_START { EXTEND(sp,1); sv_setiv(PUSHmortal, (IV)(i)); } STMT_END
#define mXPUSHu(u)	STMT_START { EXTEND(sp,1); sv_setuv(PUSHmortal, (UV)(u)); } STMT_END

#define SETs(s)		(*sp = s)
#define SETTARG		STMT_START { SvSETMAGIC(TARG); SETs(TARG); } STMT_END
#define SETp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); SETTARG; } STMT_END
#define SETn(n)		STMT_START { sv_setnv(TARG, (NV)(n)); SETTARG; } STMT_END
#define SETi(i)		STMT_START { sv_setiv(TARG, (IV)(i)); SETTARG; } STMT_END
#define SETu(u)		STMT_START { sv_setuv(TARG, (UV)(u)); SETTARG; } STMT_END

#define dTOPss		SV *sv = TOPs
#define dPOPss		SV *sv = POPs
#define dTOPnv		NV value = TOPn
#define dPOPnv		NV value = POPn
#define dPOPnv_nomg	NV value = (sp--, SvNV_nomg(TOPp1s))
#define dTOPiv		IV value = TOPi
#define dPOPiv		IV value = POPi
#define dTOPuv		UV value = TOPu
#define dPOPuv		UV value = POPu

#define dPOPXssrl(X)	SV *right = POPs; SV *left = CAT2(X,s)
#define dPOPXnnrl(X)	NV right = POPn; NV left = CAT2(X,n)
#define dPOPXiirl(X)	IV right = POPi; IV left = CAT2(X,i)

#define USE_LEFT(sv) \
	(SvOK(sv) || !(PL_op->op_flags & OPf_STACKED))
#define dPOPXiirl_ul_nomg(X) \
    IV right = (sp--, SvIV_nomg(TOPp1s));		\
    SV *leftsv = CAT2(X,s);				\
    IV left = USE_LEFT(leftsv) ? SvIV_nomg(leftsv) : 0

#define dPOPPOPssrl	dPOPXssrl(POP)
#define dPOPPOPnnrl	dPOPXnnrl(POP)
#define dPOPPOPiirl	dPOPXiirl(POP)

#define dPOPTOPssrl	dPOPXssrl(TOP)
#define dPOPTOPnnrl	dPOPXnnrl(TOP)
#define dPOPTOPnnrl_nomg \
    NV right = SvNV_nomg(TOPs); NV left = (sp--, SvNV_nomg(TOPs))
#define dPOPTOPiirl	dPOPXiirl(TOP)
#define dPOPTOPiirl_ul_nomg dPOPXiirl_ul_nomg(TOP)
#define dPOPTOPiirl_nomg \
    IV right = SvIV_nomg(TOPs); IV left = (sp--, SvIV_nomg(TOPs))

#define RETPUSHYES	RETURNX(PUSHs(&PL_sv_yes))
#define RETPUSHNO	RETURNX(PUSHs(&PL_sv_no))
#define RETPUSHUNDEF	RETURNX(PUSHs(&PL_sv_undef))

#define RETSETYES	RETURNX(SETs(&PL_sv_yes))
#define RETSETNO	RETURNX(SETs(&PL_sv_no))
#define RETSETUNDEF	RETURNX(SETs(&PL_sv_undef))

#define ARGTARG		PL_op->op_targ

    /* See OPpTARGET_MY: */
#define MAXARG		(PL_op->op_private & 15)

#define SWITCHSTACK(f,t) \
    STMT_START {							\
	AvFILLp(f) = sp - PL_stack_base;				\
	PL_stack_base = AvARRAY(t);					\
	PL_stack_max = PL_stack_base + AvMAX(t);			\
	sp = PL_stack_sp = PL_stack_base + AvFILLp(t);			\
	PL_curstack = t;						\
    } STMT_END

#define EXTEND_MORTAL(n) \
    STMT_START {							\
	if (UNLIKELY(PL_tmps_ix + (n) >= PL_tmps_max))			\
	    tmps_grow(n);						\
    } STMT_END

#define AMGf_noright	1
#define AMGf_noleft	2
#define AMGf_assign	4
#define AMGf_unary	8
#define AMGf_numeric	0x10	/* for Perl_try_amagic_bin */
#define AMGf_set	0x20	/* for Perl_try_amagic_bin */
#define AMGf_want_list	0x40


/* do SvGETMAGIC on the stack args before checking for overload */

#define tryAMAGICun_MG(method, flags) STMT_START { \
	if ( UNLIKELY((SvFLAGS(TOPs) & (SVf_ROK|SVs_GMG))) \
		&& Perl_try_amagic_un(aTHX_ method, flags)) \
	    return NORMAL; \
    } STMT_END
#define tryAMAGICbin_MG(method, flags) STMT_START { \
	if ( UNLIKELY(((SvFLAGS(TOPm1s)|SvFLAGS(TOPs)) & (SVf_ROK|SVs_GMG))) \
		&& Perl_try_amagic_bin(aTHX_ method, flags)) \
	    return NORMAL; \
    } STMT_END

#define AMG_CALLunary(sv,meth) \
    amagic_call(sv,&PL_sv_undef, meth, AMGf_noright | AMGf_unary)

/* No longer used in core. Use AMG_CALLunary instead */
#define AMG_CALLun(sv,meth) AMG_CALLunary(sv, CAT2(meth,_amg))

#define tryAMAGICunTARGETlist(meth, jump)			\
    STMT_START {						\
	dSP;							\
	SV *tmpsv;						\
	SV *arg= *sp;						\
        int gimme = GIMME_V;                                    \
	if (UNLIKELY(SvAMAGIC(arg) &&				\
	    (tmpsv = amagic_call(arg, &PL_sv_undef, meth,	\
				 AMGf_want_list | AMGf_noright	\
				|AMGf_unary))))                 \
        {                                       		\
	    SPAGAIN;						\
            if (gimme == G_VOID) {                              \
                (void)POPs; /* XXX ??? */                       \
            }                                                   \
            else if (gimme == G_ARRAY) {			\
                SSize_t i;                                      \
                SSize_t len;                                    \
                assert(SvTYPE(tmpsv) == SVt_PVAV);              \
                len = av_tindex((AV *)tmpsv) + 1;               \
                (void)POPs; /* get rid of the arg */            \
                EXTEND(sp, len);                                \
                for (i = 0; i < len; ++i)                       \
                    PUSHs(av_shift((AV *)tmpsv));               \
            }                                                   \
            else { /* AMGf_want_scalar */                       \
                dATARGET; /* just use the arg's location */     \
                sv_setsv(TARG, tmpsv);                          \
                if (opASSIGN)                                   \
                    sp--;                                       \
                SETTARG;                                        \
            }                                                   \
	    PUTBACK;						\
	    if (jump) {						\
	        OP *jump_o = NORMAL->op_next;                   \
		while (jump_o->op_type == OP_NULL)		\
		    jump_o = jump_o->op_next;			\
		assert(jump_o->op_type == OP_ENTERSUB);		\
		PL_markstack_ptr--;				\
		return jump_o->op_next;				\
	    }							\
	    return NORMAL;					\
	}							\
    } STMT_END

/* This is no longer used anywhere in the core. You might wish to consider
   calling amagic_deref_call() directly, as it has a cleaner interface.  */
#define tryAMAGICunDEREF(meth)						\
    STMT_START {							\
	sv = amagic_deref_call(*sp, CAT2(meth,_amg));			\
	SPAGAIN;							\
    } STMT_END


#define opASSIGN (PL_op->op_flags & OPf_STACKED)
#define SETsv(sv)	STMT_START {					\
		if (opASSIGN || (SvFLAGS(TARG) & SVs_PADMY))		\
		   { sv_setsv(TARG, (sv)); SETTARG; }			\
		else SETs(sv); } STMT_END

#define SETsvUN(sv)	STMT_START {					\
		if (SvFLAGS(TARG) & SVs_PADMY)		\
		   { sv_setsv(TARG, (sv)); SETTARG; }			\
		else SETs(sv); } STMT_END

/*
=for apidoc mU||LVRET
True if this op will be the return value of an lvalue subroutine

=cut */
#define LVRET ((PL_op->op_private & OPpMAYBE_LVSUB) && is_lvalue_sub())

#define SvCANEXISTDELETE(sv) \
 (!SvRMAGICAL(sv)            \
  || !(mg = mg_find((const SV *) sv, PERL_MAGIC_tied))           \
  || (   (stash = SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(sv), mg)))) \
      && gv_fetchmethod_autoload(stash, "EXISTS", TRUE)          \
      && gv_fetchmethod_autoload(stash, "DELETE", TRUE)          \
     )                       \
  )

#ifdef PERL_CORE

/* These are just for Perl_tied_method(), which is not part of the public API.
   Use 0x04 rather than the next available bit, to help the compiler if the
   architecture can generate more efficient instructions.  */
#  define TIED_METHOD_MORTALIZE_NOT_NEEDED	0x04
#  define TIED_METHOD_ARGUMENTS_ON_STACK	0x08
#  define TIED_METHOD_SAY			0x10

/* Used in various places that need to dereference a glob or globref */
#  define MAYBE_DEREF_GV_flags(sv,phlags)                          \
    (                                                               \
	(void)(phlags & SV_GMAGIC && (SvGETMAGIC(sv),0)),            \
	isGV_with_GP(sv)                                              \
	  ? (GV *)(sv)                                                \
	  : SvROK(sv) && SvTYPE(SvRV(sv)) <= SVt_PVLV &&               \
	    (SvGETMAGIC(SvRV(sv)), isGV_with_GP(SvRV(sv)))              \
	     ? (GV *)SvRV(sv)                                            \
	     : NULL                                                       \
    )
#  define MAYBE_DEREF_GV(sv)      MAYBE_DEREF_GV_flags(sv,SV_GMAGIC)
#  define MAYBE_DEREF_GV_nomg(sv) MAYBE_DEREF_GV_flags(sv,0)

#  define FIND_RUNCV_padid_eq	1
#  define FIND_RUNCV_level_eq	2

#endif

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                              usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/pp_proto.h                                                0100644 0000000 0000000 00000025472 12744441327 017761  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by opcode.pl from its data.
   Any changes made here will be lost!
 */

PERL_CALLCONV OP *Perl_do_kv(pTHX);
PERL_CALLCONV OP *Perl_pp_aassign(pTHX);
PERL_CALLCONV OP *Perl_pp_abs(pTHX);
PERL_CALLCONV OP *Perl_pp_accept(pTHX);
PERL_CALLCONV OP *Perl_pp_add(pTHX);
PERL_CALLCONV OP *Perl_pp_aeach(pTHX);
PERL_CALLCONV OP *Perl_pp_aelem(pTHX);
PERL_CALLCONV OP *Perl_pp_aelemfast(pTHX);
PERL_CALLCONV OP *Perl_pp_akeys(pTHX);
PERL_CALLCONV OP *Perl_pp_alarm(pTHX);
PERL_CALLCONV OP *Perl_pp_and(pTHX);
PERL_CALLCONV OP *Perl_pp_anoncode(pTHX);
PERL_CALLCONV OP *Perl_pp_anonhash(pTHX);
PERL_CALLCONV OP *Perl_pp_anonlist(pTHX);
PERL_CALLCONV OP *Perl_pp_aslice(pTHX);
PERL_CALLCONV OP *Perl_pp_atan2(pTHX);
PERL_CALLCONV OP *Perl_pp_av2arylen(pTHX);
PERL_CALLCONV OP *Perl_pp_backtick(pTHX);
PERL_CALLCONV OP *Perl_pp_bind(pTHX);
PERL_CALLCONV OP *Perl_pp_binmode(pTHX);
PERL_CALLCONV OP *Perl_pp_bit_and(pTHX);
PERL_CALLCONV OP *Perl_pp_bit_or(pTHX);
PERL_CALLCONV OP *Perl_pp_bless(pTHX);
PERL_CALLCONV OP *Perl_pp_break(pTHX);
PERL_CALLCONV OP *Perl_pp_caller(pTHX);
PERL_CALLCONV OP *Perl_pp_chdir(pTHX);
PERL_CALLCONV OP *Perl_pp_chop(pTHX);
PERL_CALLCONV OP *Perl_pp_chown(pTHX);
PERL_CALLCONV OP *Perl_pp_chr(pTHX);
PERL_CALLCONV OP *Perl_pp_chroot(pTHX);
PERL_CALLCONV OP *Perl_pp_clonecv(pTHX);
PERL_CALLCONV OP *Perl_pp_close(pTHX);
PERL_CALLCONV OP *Perl_pp_closedir(pTHX);
PERL_CALLCONV OP *Perl_pp_complement(pTHX);
PERL_CALLCONV OP *Perl_pp_concat(pTHX);
PERL_CALLCONV OP *Perl_pp_cond_expr(pTHX);
PERL_CALLCONV OP *Perl_pp_const(pTHX);
PERL_CALLCONV OP *Perl_pp_continue(pTHX);
PERL_CALLCONV OP *Perl_pp_coreargs(pTHX);
PERL_CALLCONV OP *Perl_pp_crypt(pTHX);
PERL_CALLCONV OP *Perl_pp_dbmopen(pTHX);
PERL_CALLCONV OP *Perl_pp_dbstate(pTHX);
PERL_CALLCONV OP *Perl_pp_defined(pTHX);
PERL_CALLCONV OP *Perl_pp_delete(pTHX);
PERL_CALLCONV OP *Perl_pp_die(pTHX);
PERL_CALLCONV OP *Perl_pp_divide(pTHX);
PERL_CALLCONV OP *Perl_pp_each(pTHX);
PERL_CALLCONV OP *Perl_pp_ehostent(pTHX);
PERL_CALLCONV OP *Perl_pp_enter(pTHX);
PERL_CALLCONV OP *Perl_pp_entereval(pTHX);
PERL_CALLCONV OP *Perl_pp_entergiven(pTHX);
PERL_CALLCONV OP *Perl_pp_enteriter(pTHX);
PERL_CALLCONV OP *Perl_pp_enterloop(pTHX);
PERL_CALLCONV OP *Perl_pp_entersub(pTHX);
PERL_CALLCONV OP *Perl_pp_entertry(pTHX);
PERL_CALLCONV OP *Perl_pp_enterwhen(pTHX);
PERL_CALLCONV OP *Perl_pp_enterwrite(pTHX);
PERL_CALLCONV OP *Perl_pp_eof(pTHX);
PERL_CALLCONV OP *Perl_pp_eq(pTHX);
PERL_CALLCONV OP *Perl_pp_exec(pTHX);
PERL_CALLCONV OP *Perl_pp_exists(pTHX);
PERL_CALLCONV OP *Perl_pp_exit(pTHX);
PERL_CALLCONV OP *Perl_pp_fc(pTHX);
PERL_CALLCONV OP *Perl_pp_fileno(pTHX);
PERL_CALLCONV OP *Perl_pp_flip(pTHX);
PERL_CALLCONV OP *Perl_pp_flock(pTHX);
PERL_CALLCONV OP *Perl_pp_flop(pTHX);
PERL_CALLCONV OP *Perl_pp_fork(pTHX);
PERL_CALLCONV OP *Perl_pp_formline(pTHX);
PERL_CALLCONV OP *Perl_pp_ftis(pTHX);
PERL_CALLCONV OP *Perl_pp_ftlink(pTHX);
PERL_CALLCONV OP *Perl_pp_ftrowned(pTHX);
PERL_CALLCONV OP *Perl_pp_ftrread(pTHX);
PERL_CALLCONV OP *Perl_pp_fttext(pTHX);
PERL_CALLCONV OP *Perl_pp_fttty(pTHX);
PERL_CALLCONV OP *Perl_pp_ge(pTHX);
PERL_CALLCONV OP *Perl_pp_gelem(pTHX);
PERL_CALLCONV OP *Perl_pp_getc(pTHX);
PERL_CALLCONV OP *Perl_pp_getlogin(pTHX);
PERL_CALLCONV OP *Perl_pp_getpeername(pTHX);
PERL_CALLCONV OP *Perl_pp_getpgrp(pTHX);
PERL_CALLCONV OP *Perl_pp_getppid(pTHX);
PERL_CALLCONV OP *Perl_pp_getpriority(pTHX);
PERL_CALLCONV OP *Perl_pp_ggrent(pTHX);
PERL_CALLCONV OP *Perl_pp_ghostent(pTHX);
PERL_CALLCONV OP *Perl_pp_glob(pTHX);
PERL_CALLCONV OP *Perl_pp_gmtime(pTHX);
PERL_CALLCONV OP *Perl_pp_gnetent(pTHX);
PERL_CALLCONV OP *Perl_pp_goto(pTHX);
PERL_CALLCONV OP *Perl_pp_gprotoent(pTHX);
PERL_CALLCONV OP *Perl_pp_gpwent(pTHX);
PERL_CALLCONV OP *Perl_pp_grepstart(pTHX);
PERL_CALLCONV OP *Perl_pp_grepwhile(pTHX);
PERL_CALLCONV OP *Perl_pp_gservent(pTHX);
PERL_CALLCONV OP *Perl_pp_gt(pTHX);
PERL_CALLCONV OP *Perl_pp_gv(pTHX);
PERL_CALLCONV OP *Perl_pp_gvsv(pTHX);
PERL_CALLCONV OP *Perl_pp_helem(pTHX);
PERL_CALLCONV OP *Perl_pp_hintseval(pTHX);
PERL_CALLCONV OP *Perl_pp_hslice(pTHX);
PERL_CALLCONV OP *Perl_pp_i_add(pTHX);
PERL_CALLCONV OP *Perl_pp_i_divide(pTHX);
PERL_CALLCONV OP *Perl_pp_i_eq(pTHX);
PERL_CALLCONV OP *Perl_pp_i_ge(pTHX);
PERL_CALLCONV OP *Perl_pp_i_gt(pTHX);
PERL_CALLCONV OP *Perl_pp_i_le(pTHX);
PERL_CALLCONV OP *Perl_pp_i_lt(pTHX);
PERL_CALLCONV OP *Perl_pp_i_modulo(pTHX);
PERL_CALLCONV OP *Perl_pp_i_multiply(pTHX);
PERL_CALLCONV OP *Perl_pp_i_ncmp(pTHX);
PERL_CALLCONV OP *Perl_pp_i_ne(pTHX);
PERL_CALLCONV OP *Perl_pp_i_negate(pTHX);
PERL_CALLCONV OP *Perl_pp_i_subtract(pTHX);
PERL_CALLCONV OP *Perl_pp_index(pTHX);
PERL_CALLCONV OP *Perl_pp_int(pTHX);
PERL_CALLCONV OP *Perl_pp_introcv(pTHX);
PERL_CALLCONV OP *Perl_pp_ioctl(pTHX);
PERL_CALLCONV OP *Perl_pp_iter(pTHX);
PERL_CALLCONV OP *Perl_pp_join(pTHX);
PERL_CALLCONV OP *Perl_pp_kvaslice(pTHX);
PERL_CALLCONV OP *Perl_pp_kvhslice(pTHX);
PERL_CALLCONV OP *Perl_pp_last(pTHX);
PERL_CALLCONV OP *Perl_pp_lc(pTHX);
PERL_CALLCONV OP *Perl_pp_le(pTHX);
PERL_CALLCONV OP *Perl_pp_leave(pTHX);
PERL_CALLCONV OP *Perl_pp_leaveeval(pTHX);
PERL_CALLCONV OP *Perl_pp_leavegiven(pTHX);
PERL_CALLCONV OP *Perl_pp_leaveloop(pTHX);
PERL_CALLCONV OP *Perl_pp_leavesub(pTHX);
PERL_CALLCONV OP *Perl_pp_leavesublv(pTHX);
PERL_CALLCONV OP *Perl_pp_leavetry(pTHX);
PERL_CALLCONV OP *Perl_pp_leavewhen(pTHX);
PERL_CALLCONV OP *Perl_pp_leavewrite(pTHX);
PERL_CALLCONV OP *Perl_pp_left_shift(pTHX);
PERL_CALLCONV OP *Perl_pp_length(pTHX);
PERL_CALLCONV OP *Perl_pp_link(pTHX);
PERL_CALLCONV OP *Perl_pp_list(pTHX);
PERL_CALLCONV OP *Perl_pp_listen(pTHX);
PERL_CALLCONV OP *Perl_pp_lock(pTHX);
PERL_CALLCONV OP *Perl_pp_lslice(pTHX);
PERL_CALLCONV OP *Perl_pp_lt(pTHX);
PERL_CALLCONV OP *Perl_pp_mapwhile(pTHX);
PERL_CALLCONV OP *Perl_pp_match(pTHX);
PERL_CALLCONV OP *Perl_pp_method(pTHX);
PERL_CALLCONV OP *Perl_pp_method_named(pTHX);
PERL_CALLCONV OP *Perl_pp_mkdir(pTHX);
PERL_CALLCONV OP *Perl_pp_modulo(pTHX);
PERL_CALLCONV OP *Perl_pp_multiply(pTHX);
PERL_CALLCONV OP *Perl_pp_ncmp(pTHX);
PERL_CALLCONV OP *Perl_pp_ne(pTHX);
PERL_CALLCONV OP *Perl_pp_negate(pTHX);
PERL_CALLCONV OP *Perl_pp_next(pTHX);
PERL_CALLCONV OP *Perl_pp_nextstate(pTHX);
PERL_CALLCONV OP *Perl_pp_not(pTHX);
PERL_CALLCONV OP *Perl_pp_null(pTHX);
PERL_CALLCONV OP *Perl_pp_oct(pTHX);
PERL_CALLCONV OP *Perl_pp_once(pTHX);
PERL_CALLCONV OP *Perl_pp_open(pTHX);
PERL_CALLCONV OP *Perl_pp_open_dir(pTHX);
PERL_CALLCONV OP *Perl_pp_or(pTHX);
PERL_CALLCONV OP *Perl_pp_ord(pTHX);
PERL_CALLCONV OP *Perl_pp_pack(pTHX);
PERL_CALLCONV OP *Perl_pp_padav(pTHX);
PERL_CALLCONV OP *Perl_pp_padcv(pTHX);
PERL_CALLCONV OP *Perl_pp_padhv(pTHX);
PERL_CALLCONV OP *Perl_pp_padrange(pTHX);
PERL_CALLCONV OP *Perl_pp_padsv(pTHX);
PERL_CALLCONV OP *Perl_pp_pipe_op(pTHX);
PERL_CALLCONV OP *Perl_pp_pos(pTHX);
PERL_CALLCONV OP *Perl_pp_postinc(pTHX);
PERL_CALLCONV OP *Perl_pp_pow(pTHX);
PERL_CALLCONV OP *Perl_pp_preinc(pTHX);
PERL_CALLCONV OP *Perl_pp_print(pTHX);
PERL_CALLCONV OP *Perl_pp_prototype(pTHX);
PERL_CALLCONV OP *Perl_pp_prtf(pTHX);
PERL_CALLCONV OP *Perl_pp_push(pTHX);
PERL_CALLCONV OP *Perl_pp_pushmark(pTHX);
PERL_CALLCONV OP *Perl_pp_pushre(pTHX);
PERL_CALLCONV OP *Perl_pp_qr(pTHX);
PERL_CALLCONV OP *Perl_pp_quotemeta(pTHX);
PERL_CALLCONV OP *Perl_pp_rand(pTHX);
PERL_CALLCONV OP *Perl_pp_range(pTHX);
PERL_CALLCONV OP *Perl_pp_rcatline(pTHX);
PERL_CALLCONV OP *Perl_pp_readdir(pTHX);
PERL_CALLCONV OP *Perl_pp_readline(pTHX);
PERL_CALLCONV OP *Perl_pp_readlink(pTHX);
PERL_CALLCONV OP *Perl_pp_redo(pTHX);
PERL_CALLCONV OP *Perl_pp_ref(pTHX);
PERL_CALLCONV OP *Perl_pp_refgen(pTHX);
PERL_CALLCONV OP *Perl_pp_regcomp(pTHX);
PERL_CALLCONV OP *Perl_pp_regcreset(pTHX);
PERL_CALLCONV OP *Perl_pp_rename(pTHX);
PERL_CALLCONV OP *Perl_pp_repeat(pTHX);
PERL_CALLCONV OP *Perl_pp_require(pTHX);
PERL_CALLCONV OP *Perl_pp_reset(pTHX);
PERL_CALLCONV OP *Perl_pp_return(pTHX);
PERL_CALLCONV OP *Perl_pp_reverse(pTHX);
PERL_CALLCONV OP *Perl_pp_rewinddir(pTHX);
PERL_CALLCONV OP *Perl_pp_right_shift(pTHX);
PERL_CALLCONV OP *Perl_pp_rkeys(pTHX);
PERL_CALLCONV OP *Perl_pp_rmdir(pTHX);
PERL_CALLCONV OP *Perl_pp_runcv(pTHX);
PERL_CALLCONV OP *Perl_pp_rv2av(pTHX);
PERL_CALLCONV OP *Perl_pp_rv2cv(pTHX);
PERL_CALLCONV OP *Perl_pp_rv2gv(pTHX);
PERL_CALLCONV OP *Perl_pp_rv2sv(pTHX);
PERL_CALLCONV OP *Perl_pp_sassign(pTHX);
PERL_CALLCONV OP *Perl_pp_schop(pTHX);
PERL_CALLCONV OP *Perl_pp_scmp(pTHX);
PERL_CALLCONV OP *Perl_pp_seekdir(pTHX);
PERL_CALLCONV OP *Perl_pp_select(pTHX);
PERL_CALLCONV OP *Perl_pp_semctl(pTHX);
PERL_CALLCONV OP *Perl_pp_semget(pTHX);
PERL_CALLCONV OP *Perl_pp_seq(pTHX);
PERL_CALLCONV OP *Perl_pp_setpgrp(pTHX);
PERL_CALLCONV OP *Perl_pp_setpriority(pTHX);
PERL_CALLCONV OP *Perl_pp_shift(pTHX);
PERL_CALLCONV OP *Perl_pp_shmwrite(pTHX);
PERL_CALLCONV OP *Perl_pp_shostent(pTHX);
PERL_CALLCONV OP *Perl_pp_shutdown(pTHX);
PERL_CALLCONV OP *Perl_pp_sin(pTHX);
PERL_CALLCONV OP *Perl_pp_sle(pTHX);
PERL_CALLCONV OP *Perl_pp_sleep(pTHX);
PERL_CALLCONV OP *Perl_pp_smartmatch(pTHX);
PERL_CALLCONV OP *Perl_pp_sne(pTHX);
PERL_CALLCONV OP *Perl_pp_socket(pTHX);
PERL_CALLCONV OP *Perl_pp_sockpair(pTHX);
PERL_CALLCONV OP *Perl_pp_sort(pTHX);
PERL_CALLCONV OP *Perl_pp_splice(pTHX);
PERL_CALLCONV OP *Perl_pp_split(pTHX);
PERL_CALLCONV OP *Perl_pp_sprintf(pTHX);
PERL_CALLCONV OP *Perl_pp_srand(pTHX);
PERL_CALLCONV OP *Perl_pp_srefgen(pTHX);
PERL_CALLCONV OP *Perl_pp_sselect(pTHX);
PERL_CALLCONV OP *Perl_pp_ssockopt(pTHX);
PERL_CALLCONV OP *Perl_pp_stat(pTHX);
PERL_CALLCONV OP *Perl_pp_stringify(pTHX);
PERL_CALLCONV OP *Perl_pp_stub(pTHX);
PERL_CALLCONV OP *Perl_pp_study(pTHX);
PERL_CALLCONV OP *Perl_pp_subst(pTHX);
PERL_CALLCONV OP *Perl_pp_substcont(pTHX);
PERL_CALLCONV OP *Perl_pp_substr(pTHX);
PERL_CALLCONV OP *Perl_pp_subtract(pTHX);
PERL_CALLCONV OP *Perl_pp_syscall(pTHX);
PERL_CALLCONV OP *Perl_pp_sysopen(pTHX);
PERL_CALLCONV OP *Perl_pp_sysread(pTHX);
PERL_CALLCONV OP *Perl_pp_sysseek(pTHX);
PERL_CALLCONV OP *Perl_pp_system(pTHX);
PERL_CALLCONV OP *Perl_pp_syswrite(pTHX);
PERL_CALLCONV OP *Perl_pp_tell(pTHX);
PERL_CALLCONV OP *Perl_pp_telldir(pTHX);
PERL_CALLCONV OP *Perl_pp_tie(pTHX);
PERL_CALLCONV OP *Perl_pp_tied(pTHX);
PERL_CALLCONV OP *Perl_pp_time(pTHX);
PERL_CALLCONV OP *Perl_pp_tms(pTHX);
PERL_CALLCONV OP *Perl_pp_trans(pTHX);
PERL_CALLCONV OP *Perl_pp_truncate(pTHX);
PERL_CALLCONV OP *Perl_pp_uc(pTHX);
PERL_CALLCONV OP *Perl_pp_ucfirst(pTHX);
PERL_CALLCONV OP *Perl_pp_umask(pTHX);
PERL_CALLCONV OP *Perl_pp_undef(pTHX);
PERL_CALLCONV OP *Perl_pp_unpack(pTHX);
PERL_CALLCONV OP *Perl_pp_unshift(pTHX);
PERL_CALLCONV OP *Perl_pp_unstack(pTHX);
PERL_CALLCONV OP *Perl_pp_untie(pTHX);
PERL_CALLCONV OP *Perl_pp_vec(pTHX);
PERL_CALLCONV OP *Perl_pp_wait(pTHX);
PERL_CALLCONV OP *Perl_pp_waitpid(pTHX);
PERL_CALLCONV OP *Perl_pp_wantarray(pTHX);
PERL_CALLCONV OP *Perl_pp_warn(pTHX);
PERL_CALLCONV OP *Perl_pp_xor(pTHX);
PERL_CALLCONV OP *Perl_unimplemented_op(pTHX);

/* ex: set ro: */
                                                                                                                                                                                                      usr/lib/x86_64-linux-gnu/perl/5.20.2/CORE/proto.h                                                   0100644 0000000 0000000 00001047523 12744441327 017264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- buffer-read-only: t -*-
 *
 *    proto.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/embed.pl from data in embed.fnc,
 * regen/embed.pl, regen/opcodes, intrpvar.h and perlvars.h.
 * Any changes made here will be lost!
 *
 * Edit those files and run 'make regen_headers' to effect changes.
 */

START_EXTERN_C
PERL_CALLCONV UV	ASCII_TO_NEED(const UV enc, const UV ch)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV int	Perl_Gv_AMupdate(pTHX_ HV* stash, bool destructing)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_AMUPDATE	\
	assert(stash)

PERL_CALLCONV UV	NATIVE_TO_NEED(const UV enc, const UV ch)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV const char *	Perl_PerlIO_context_layers(pTHX_ const char *mode);
PERL_CALLCONV void*	Perl_Slab_Alloc(pTHX_ size_t sz)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_Slab_Free(pTHX_ void *op)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_SLAB_FREE	\
	assert(op)

PERL_CALLCONV bool	Perl__is_uni_FOO(pTHX_ const U8 classnum, const UV c)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl__is_uni_perl_idcont(pTHX_ UV c)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl__is_uni_perl_idstart(pTHX_ UV c)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl__is_utf8_FOO(pTHX_ const U8 classnum, const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT__IS_UTF8_FOO	\
	assert(p)

PERL_CALLCONV bool	Perl__is_utf8_mark(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__IS_UTF8_MARK	\
	assert(p)

PERL_CALLCONV bool	Perl__is_utf8_perl_idcont(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__IS_UTF8_PERL_IDCONT	\
	assert(p)

PERL_CALLCONV bool	Perl__is_utf8_perl_idstart(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT__IS_UTF8_PERL_IDSTART	\
	assert(p)

PERL_CALLCONV UV	Perl__to_uni_fold_flags(pTHX_ UV c, U8 *p, STRLEN *lenp, U8 flags)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT__TO_UNI_FOLD_FLAGS	\
	assert(p); assert(lenp)

PERL_CALLCONV UV	Perl__to_utf8_fold_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, U8 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT__TO_UTF8_FOLD_FLAGS	\
	assert(p); assert(ustrp)

PERL_CALLCONV UV	Perl__to_utf8_lower_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT__TO_UTF8_LOWER_FLAGS	\
	assert(p); assert(ustrp)

PERL_CALLCONV UV	Perl__to_utf8_title_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT__TO_UTF8_TITLE_FLAGS	\
	assert(p); assert(ustrp)

PERL_CALLCONV UV	Perl__to_utf8_upper_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT__TO_UTF8_UPPER_FLAGS	\
	assert(p); assert(ustrp)

PERL_CALLCONV PADOFFSET	Perl_allocmy(pTHX_ const char *const name, const STRLEN len, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_ALLOCMY	\
	assert(name)

PERL_CALLCONV SV*	Perl_amagic_call(pTHX_ SV* left, SV* right, int method, int dir)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_AMAGIC_CALL	\
	assert(left); assert(right)

PERL_CALLCONV SV *	Perl_amagic_deref_call(pTHX_ SV *ref, int method)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AMAGIC_DEREF_CALL	\
	assert(ref)

PERL_CALLCONV bool	Perl_amagic_is_enabled(pTHX_ int method);
PERL_STATIC_INLINE void	S_append_utf8_from_native_byte(const U8 byte, U8** dest)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_APPEND_UTF8_FROM_NATIVE_BYTE	\
	assert(dest)

PERL_CALLCONV I32	Perl_apply(pTHX_ I32 type, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_APPLY	\
	assert(mark); assert(sp)

PERL_CALLCONV void	Perl_apply_attrs_string(pTHX_ const char *stashpv, CV *cv, const char *attrstr, STRLEN len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_APPLY_ATTRS_STRING	\
	assert(stashpv); assert(cv); assert(attrstr)

PERL_CALLCONV void	Perl_atfork_lock(void);
PERL_CALLCONV void	Perl_atfork_unlock(void);
PERL_CALLCONV SV**	Perl_av_arylen_p(pTHX_ AV *av)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_ARYLEN_P	\
	assert(av)

PERL_CALLCONV void	Perl_av_clear(pTHX_ AV *av)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_CLEAR	\
	assert(av)

PERL_CALLCONV void	Perl_av_create_and_push(pTHX_ AV **const avp, SV *const val)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_AV_CREATE_AND_PUSH	\
	assert(avp); assert(val)

PERL_CALLCONV SV**	Perl_av_create_and_unshift_one(pTHX_ AV **const avp, SV *const val)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_AV_CREATE_AND_UNSHIFT_ONE	\
	assert(avp); assert(val)

PERL_CALLCONV SV*	Perl_av_delete(pTHX_ AV *av, SSize_t key, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_DELETE	\
	assert(av)

PERL_CALLCONV bool	Perl_av_exists(pTHX_ AV *av, SSize_t key)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_EXISTS	\
	assert(av)

PERL_CALLCONV void	Perl_av_extend(pTHX_ AV *av, SSize_t key)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_EXTEND	\
	assert(av)

PERL_CALLCONV void	Perl_av_extend_guts(pTHX_ AV *av, SSize_t key, SSize_t *maxp, SV ***allocp, SV ***arrayp)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_AV_EXTEND_GUTS	\
	assert(maxp); assert(allocp); assert(arrayp)

PERL_CALLCONV SV**	Perl_av_fetch(pTHX_ AV *av, SSize_t key, I32 lval)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_FETCH	\
	assert(av)

PERL_CALLCONV void	Perl_av_fill(pTHX_ AV *av, SSize_t fill)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_FILL	\
	assert(av)

PERL_CALLCONV IV*	Perl_av_iter_p(pTHX_ AV *av)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_ITER_P	\
	assert(av)

PERL_CALLCONV SSize_t	Perl_av_len(pTHX_ AV *av)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_LEN	\
	assert(av)

PERL_CALLCONV AV*	Perl_av_make(pTHX_ SSize_t size, SV **strp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_AV_MAKE	\
	assert(strp)

PERL_CALLCONV SV*	Perl_av_pop(pTHX_ AV *av)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_POP	\
	assert(av)

PERL_CALLCONV void	Perl_av_push(pTHX_ AV *av, SV *val)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_AV_PUSH	\
	assert(av); assert(val)

PERL_CALLCONV void	Perl_av_reify(pTHX_ AV *av)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_REIFY	\
	assert(av)

PERL_CALLCONV SV*	Perl_av_shift(pTHX_ AV *av)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_SHIFT	\
	assert(av)

PERL_CALLCONV SV**	Perl_av_store(pTHX_ AV *av, SSize_t key, SV *val)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_STORE	\
	assert(av)

/* PERL_CALLCONV SSize_t	Perl_av_tindex(pTHX_ AV *av)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */

PERL_STATIC_INLINE SSize_t	S_av_top_index(pTHX_ AV *av)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_TOP_INDEX	\
	assert(av)

PERL_CALLCONV void	Perl_av_undef(pTHX_ AV *av)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_UNDEF	\
	assert(av)

PERL_CALLCONV void	Perl_av_unshift(pTHX_ AV *av, SSize_t num)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_AV_UNSHIFT	\
	assert(av)

PERL_CALLCONV OP*	Perl_bind_match(pTHX_ I32 type, OP *left, OP *right)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_BIND_MATCH	\
	assert(left); assert(right)

PERL_CALLCONV OP*	Perl_block_end(pTHX_ I32 floor, OP* seq)
			__attribute__warn_unused_result__;

PERL_CALLCONV I32	Perl_block_gimme(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV int	Perl_block_start(pTHX_ int full)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_blockhook_register(pTHX_ BHK *hk)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_BLOCKHOOK_REGISTER	\
	assert(hk)

PERL_CALLCONV void	Perl_boot_core_PerlIO(pTHX);
PERL_CALLCONV void	Perl_boot_core_UNIVERSAL(pTHX);
PERL_CALLCONV void	Perl_boot_core_mro(pTHX);
PERL_CALLCONV int	Perl_bytes_cmp_utf8(pTHX_ const U8 *b, STRLEN blen, const U8 *u, STRLEN ulen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_BYTES_CMP_UTF8	\
	assert(b); assert(u)

PERL_CALLCONV U8*	Perl_bytes_from_utf8(pTHX_ const U8 *s, STRLEN *len, bool *is_utf8)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_BYTES_FROM_UTF8	\
	assert(s); assert(len)

PERL_CALLCONV U8*	Perl_bytes_to_utf8(pTHX_ const U8 *s, STRLEN *len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_BYTES_TO_UTF8	\
	assert(s); assert(len)

PERL_CALLCONV I32	Perl_call_argv(pTHX_ const char* sub_name, I32 flags, char** argv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_CALL_ARGV	\
	assert(sub_name); assert(argv)

PERL_CALLCONV void	Perl_call_atexit(pTHX_ ATEXIT_t fn, void *ptr);
PERL_CALLCONV void	Perl_call_list(pTHX_ I32 oldscope, AV *paramList)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_CALL_LIST	\
	assert(paramList)

PERL_CALLCONV I32	Perl_call_method(pTHX_ const char* methname, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CALL_METHOD	\
	assert(methname)

PERL_CALLCONV I32	Perl_call_pv(pTHX_ const char* sub_name, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CALL_PV	\
	assert(sub_name)

PERL_CALLCONV I32	Perl_call_sv(pTHX_ SV* sv, VOL I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CALL_SV	\
	assert(sv)

PERL_CALLCONV const PERL_CONTEXT *	Perl_caller_cx(pTHX_ I32 level, const PERL_CONTEXT **dbcxp);
PERL_CALLCONV Malloc_t	Perl_calloc(MEM_SIZE elements, MEM_SIZE size)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl_cando(pTHX_ Mode_t mode, bool effective, const Stat_t* statbufp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_CANDO	\
	assert(statbufp)

PERL_CALLCONV I32	Perl_cast_i32(pTHX_ NV f)
			__attribute__warn_unused_result__;

PERL_CALLCONV IV	Perl_cast_iv(pTHX_ NV f)
			__attribute__warn_unused_result__;

PERL_CALLCONV U32	Perl_cast_ulong(pTHX_ NV f)
			__attribute__warn_unused_result__;

PERL_CALLCONV UV	Perl_cast_uv(pTHX_ NV f)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl_check_utf8_print(pTHX_ const U8 *s, const STRLEN len)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CHECK_UTF8_PRINT	\
	assert(s)

PERL_CALLCONV OP *	Perl_ck_anoncode(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_ANONCODE	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_backtick(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_BACKTICK	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_bitop(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_BITOP	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_cmp(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_CMP	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_concat(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_CONCAT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_defined(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_DEFINED	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_delete(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_DELETE	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_each(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_EACH	\
	assert(o)

PERL_CALLCONV OP*	Perl_ck_entersub_args_core(pTHX_ OP *entersubop, GV *namegv, SV *protosv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_CORE	\
	assert(entersubop); assert(namegv); assert(protosv)

PERL_CALLCONV OP*	Perl_ck_entersub_args_list(pTHX_ OP *entersubop)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_LIST	\
	assert(entersubop)

PERL_CALLCONV OP*	Perl_ck_entersub_args_proto(pTHX_ OP *entersubop, GV *namegv, SV *protosv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO	\
	assert(entersubop); assert(namegv); assert(protosv)

PERL_CALLCONV OP*	Perl_ck_entersub_args_proto_or_list(pTHX_ OP *entersubop, GV *namegv, SV *protosv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO_OR_LIST	\
	assert(entersubop); assert(namegv); assert(protosv)

PERL_CALLCONV OP *	Perl_ck_eof(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_EOF	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_eval(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_EVAL	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_exec(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_EXEC	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_exists(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_EXISTS	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_ftst(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_FTST	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_fun(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_FUN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_glob(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_GLOB	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_grep(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_GREP	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_index(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_INDEX	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_join(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_JOIN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_length(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_LENGTH	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_lfun(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_LFUN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_listiob(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_LISTIOB	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_match(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_MATCH	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_method(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_METHOD	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_null(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_NULL	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_open(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_OPEN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_readline(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_READLINE	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_repeat(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_REPEAT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_require(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_REQUIRE	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_return(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_RETURN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_rfun(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_RFUN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_rvconst(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_RVCONST	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_sassign(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_SASSIGN	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_select(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_SELECT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_shift(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_SHIFT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_smartmatch(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_SMARTMATCH	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_sort(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_SORT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_spair(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_SPAIR	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_split(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_SPLIT	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_subr(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_SUBR	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_substr(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_SUBSTR	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_svconst(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_SVCONST	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_tell(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_TELL	\
	assert(o)

PERL_CALLCONV OP *	Perl_ck_trunc(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CK_TRUNC	\
	assert(o)

PERL_CALLCONV void	Perl_ck_warner(pTHX_ U32 err, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_CK_WARNER	\
	assert(pat)

PERL_CALLCONV void	Perl_ck_warner_d(pTHX_ U32 err, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_CK_WARNER_D	\
	assert(pat)

PERL_CALLCONV bool	Perl_ckwarn(pTHX_ U32 w);
PERL_CALLCONV bool	Perl_ckwarn_d(pTHX_ U32 w);
PERL_CALLCONV const COP*	Perl_closest_cop(pTHX_ const COP *cop, const OP *o, const OP *curop, bool opnext)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CLOSEST_COP	\
	assert(cop)

PERL_CALLCONV OP*	Perl_convert(pTHX_ I32 optype, I32 flags, OP* o)
			__attribute__warn_unused_result__;

PERL_CALLCONV const char *	Perl_cop_fetch_label(pTHX_ COP *const cop, STRLEN *len, U32 *flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_COP_FETCH_LABEL	\
	assert(cop)

PERL_CALLCONV void	Perl_cop_store_label(pTHX_ COP *const cop, const char *label, STRLEN len, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_COP_STORE_LABEL	\
	assert(cop); assert(label)

PERL_CALLCONV SV *	Perl_core_prototype(pTHX_ SV *sv, const char *name, const int code, int * const opnum)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_CORE_PROTOTYPE	\
	assert(name)

PERL_CALLCONV OP *	Perl_coresub_op(pTHX_ SV *const coreargssv, const int code, const int opnum)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CORESUB_OP	\
	assert(coreargssv)

PERL_CALLCONV PERL_CONTEXT*	Perl_create_eval_scope(pTHX_ U32 flags);
PERL_CALLCONV_NO_RET void	Perl_croak(pTHX_ const char* pat, ...)
			__attribute__noreturn__
			__attribute__format__null_ok__(__printf__,pTHX_1,pTHX_2);

PERL_STATIC_NO_RET void	S_croak_memory_wrap(void)
			__attribute__noreturn__;

PERL_CALLCONV_NO_RET void	Perl_croak_no_mem(void)
			__attribute__noreturn__;

PERL_CALLCONV_NO_RET void	Perl_croak_no_modify(void)
			__attribute__noreturn__;

PERL_CALLCONV_NO_RET void	Perl_croak_popstack(void)
			__attribute__noreturn__;

PERL_CALLCONV_NO_RET void	Perl_croak_sv(pTHX_ SV *baseex)
			__attribute__noreturn__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CROAK_SV	\
	assert(baseex)

PERL_CALLCONV_NO_RET void	Perl_croak_xs_usage(const CV *const cv, const char *const params)
			__attribute__noreturn__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE	\
	assert(cv); assert(params)

PERL_CALLCONV regexp_engine const *	Perl_current_re_engine(pTHX);
PERL_CALLCONV const char *	Perl_custom_op_desc(pTHX_ const OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CUSTOM_OP_DESC	\
	assert(o)

PERL_CALLCONV XOPRETANY	Perl_custom_op_get_field(pTHX_ const OP *o, const xop_flags_enum field)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CUSTOM_OP_GET_FIELD	\
	assert(o)

PERL_CALLCONV const char *	Perl_custom_op_name(pTHX_ const OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CUSTOM_OP_NAME	\
	assert(o)

PERL_CALLCONV void	Perl_custom_op_register(pTHX_ Perl_ppaddr_t ppaddr, const XOP *xop)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_CUSTOM_OP_REGISTER	\
	assert(ppaddr); assert(xop)

/* PERL_CALLCONV const XOP *	Perl_custom_op_xop(pTHX_ const OP *o)
			__attribute__pure__
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV void	Perl_cv_ckproto_len_flags(pTHX_ const CV* cv, const GV* gv, const char* p, const STRLEN len, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CV_CKPROTO_LEN_FLAGS	\
	assert(cv)

PERL_CALLCONV CV*	Perl_cv_clone(pTHX_ CV* proto)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CV_CLONE	\
	assert(proto)

PERL_CALLCONV CV*	Perl_cv_clone_into(pTHX_ CV* proto, CV *target)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_CV_CLONE_INTO	\
	assert(proto); assert(target)

PERL_CALLCONV SV*	Perl_cv_const_sv(pTHX_ const CV *const cv)
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_cv_const_sv_or_av(pTHX_ const CV *const cv)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_cv_forget_slab(pTHX_ CV *cv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CV_FORGET_SLAB	\
	assert(cv)

PERL_CALLCONV void	Perl_cv_get_call_checker(pTHX_ CV *cv, Perl_call_checker *ckfun_p, SV **ckobj_p)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_CV_GET_CALL_CHECKER	\
	assert(cv); assert(ckfun_p); assert(ckobj_p)

PERL_CALLCONV void	Perl_cv_set_call_checker(pTHX_ CV *cv, Perl_call_checker ckfun, SV *ckobj)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_CV_SET_CALL_CHECKER	\
	assert(cv); assert(ckfun); assert(ckobj)

PERL_CALLCONV void	Perl_cv_undef(pTHX_ CV* cv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CV_UNDEF	\
	assert(cv)

PERL_CALLCONV void	Perl_cvgv_set(pTHX_ CV* cv, GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CVGV_SET	\
	assert(cv)

PERL_CALLCONV void	Perl_cvstash_set(pTHX_ CV* cv, HV* stash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CVSTASH_SET	\
	assert(cv)

PERL_CALLCONV void	Perl_cx_dump(pTHX_ PERL_CONTEXT* cx)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_CX_DUMP	\
	assert(cx)

PERL_CALLCONV I32	Perl_cxinc(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_deb(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DEB	\
	assert(pat)

PERL_CALLCONV void	Perl_deb_stack_all(pTHX);
PERL_CALLCONV I32	Perl_debop(pTHX_ const OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DEBOP	\
	assert(o)

PERL_CALLCONV void	Perl_debprofdump(pTHX);
PERL_CALLCONV I32	Perl_debstack(pTHX);
PERL_CALLCONV I32	Perl_debstackptrs(pTHX);
PERL_CALLCONV SV *	Perl_defelem_target(pTHX_ SV *sv, MAGIC *mg)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DEFELEM_TARGET	\
	assert(sv)

PERL_CALLCONV void	Perl_delete_eval_scope(pTHX);
PERL_CALLCONV char*	Perl_delimcpy(char* to, const char* toend, const char* from, const char* fromend, int delim, I32* retlen)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3)
			__attribute__nonnull__(4)
			__attribute__nonnull__(6);
#define PERL_ARGS_ASSERT_DELIMCPY	\
	assert(to); assert(toend); assert(from); assert(fromend); assert(retlen)

PERL_CALLCONV void	Perl_despatch_signals(pTHX);
PERL_CALLCONV OP*	Perl_die(pTHX_ const char* pat, ...)
			__attribute__format__null_ok__(__printf__,pTHX_1,pTHX_2);

PERL_CALLCONV OP*	Perl_die_sv(pTHX_ SV *baseex)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DIE_SV	\
	assert(baseex)

PERL_CALLCONV_NO_RET void	Perl_die_unwind(pTHX_ SV* msv)
			__attribute__noreturn__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DIE_UNWIND	\
	assert(msv)

/* PERL_CALLCONV bool	Perl_do_aexec(pTHX_ SV* really, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3); */
#define PERL_ARGS_ASSERT_DO_AEXEC	\
	assert(mark); assert(sp)

PERL_CALLCONV bool	Perl_do_aexec5(pTHX_ SV* really, SV** mark, SV** sp, int fd, int do_report)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DO_AEXEC5	\
	assert(mark); assert(sp)

PERL_CALLCONV int	Perl_do_binmode(pTHX_ PerlIO *fp, int iotype, int mode)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_BINMODE	\
	assert(fp)

PERL_CALLCONV bool	Perl_do_close(pTHX_ GV* gv, bool not_implicit);
PERL_CALLCONV void	Perl_do_dump_pad(pTHX_ I32 level, PerlIO *file, PADLIST *padlist, int full)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_DUMP_PAD	\
	assert(file)

PERL_CALLCONV bool	Perl_do_eof(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_EOF	\
	assert(gv)

PERL_CALLCONV void	Perl_do_execfree(pTHX);
PERL_CALLCONV void	Perl_do_gv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DO_GV_DUMP	\
	assert(file); assert(name)

PERL_CALLCONV void	Perl_do_gvgv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DO_GVGV_DUMP	\
	assert(file); assert(name)

PERL_CALLCONV void	Perl_do_hv_dump(pTHX_ I32 level, PerlIO *file, const char *name, HV *sv)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DO_HV_DUMP	\
	assert(file); assert(name)

PERL_CALLCONV void	Perl_do_join(pTHX_ SV *sv, SV *delim, SV **mark, SV **sp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_DO_JOIN	\
	assert(sv); assert(delim); assert(mark); assert(sp)

PERL_CALLCONV void	Perl_do_magic_dump(pTHX_ I32 level, PerlIO *file, const MAGIC *mg, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DO_MAGIC_DUMP	\
	assert(file); assert(mg)

PERL_CALLCONV I32	Perl_do_ncmp(pTHX_ SV *const left, SV *const right)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_NCMP	\
	assert(left); assert(right)

PERL_CALLCONV void	Perl_do_op_dump(pTHX_ I32 level, PerlIO *file, const OP *o)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_OP_DUMP	\
	assert(file)

/* PERL_CALLCONV bool	Perl_do_open(pTHX_ GV* gv, const char* name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO* supplied_fp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_DO_OPEN	\
	assert(gv); assert(name)

PERL_CALLCONV bool	Perl_do_open6(pTHX_ GV *gv, const char *oname, STRLEN len, PerlIO *supplied_fp, SV **svp, U32 num)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_OPEN6	\
	assert(gv); assert(oname)

PERL_CALLCONV bool	Perl_do_open9(pTHX_ GV *gv, const char *name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp, SV *svs, I32 num)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_8);
#define PERL_ARGS_ASSERT_DO_OPEN9	\
	assert(gv); assert(name); assert(svs)

PERL_CALLCONV bool	Perl_do_open_raw(pTHX_ GV *gv, const char *oname, STRLEN len, int rawmode, int rawperm)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_OPEN_RAW	\
	assert(gv); assert(oname)

PERL_CALLCONV bool	Perl_do_openn(pTHX_ GV *gv, const char *oname, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp, SV **svp, I32 num)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_OPENN	\
	assert(gv); assert(oname)

PERL_CALLCONV void	Perl_do_pmop_dump(pTHX_ I32 level, PerlIO *file, const PMOP *pm)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_PMOP_DUMP	\
	assert(file)

PERL_CALLCONV bool	Perl_do_print(pTHX_ SV* sv, PerlIO* fp)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_PRINT	\
	assert(fp)

PERL_CALLCONV OP*	Perl_do_readline(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl_do_seek(pTHX_ GV* gv, Off_t pos, int whence);
PERL_CALLCONV void	Perl_do_sprintf(pTHX_ SV* sv, I32 len, SV** sarg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DO_SPRINTF	\
	assert(sv); assert(sarg)

PERL_CALLCONV void	Perl_do_sv_dump(pTHX_ I32 level, PerlIO *file, SV *sv, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_DO_SV_DUMP	\
	assert(file)

PERL_CALLCONV Off_t	Perl_do_sysseek(pTHX_ GV* gv, Off_t pos, int whence)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_SYSSEEK	\
	assert(gv)

PERL_CALLCONV Off_t	Perl_do_tell(pTHX_ GV* gv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_TELL	\
	assert(gv)

PERL_CALLCONV I32	Perl_do_trans(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_TRANS	\
	assert(sv)

PERL_CALLCONV UV	Perl_do_vecget(pTHX_ SV* sv, SSize_t offset, int size)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_VECGET	\
	assert(sv)

PERL_CALLCONV void	Perl_do_vecset(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DO_VECSET	\
	assert(sv)

PERL_CALLCONV void	Perl_do_vop(pTHX_ I32 optype, SV* sv, SV* left, SV* right)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_DO_VOP	\
	assert(sv); assert(left); assert(right)

PERL_CALLCONV OP*	Perl_dofile(pTHX_ OP* term, I32 force_builtin)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DOFILE	\
	assert(term)

PERL_CALLCONV bool	Perl_doing_taint(int argc, char** argv, char** env)
			__attribute__warn_unused_result__;

PERL_CALLCONV OP *	Perl_doref(pTHX_ OP *o, I32 type, bool set_op_ref)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DOREF	\
	assert(o)

PERL_CALLCONV void	Perl_dounwind(pTHX_ I32 cxix);
PERL_CALLCONV I32	Perl_dowantarray(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_drand48_init_r(perl_drand48_t *random_state, U32 seed)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_DRAND48_INIT_R	\
	assert(random_state)

PERL_CALLCONV double	Perl_drand48_r(perl_drand48_t *random_state)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_DRAND48_R	\
	assert(random_state)

PERL_CALLCONV void	Perl_dump_all(pTHX);
PERL_CALLCONV void	Perl_dump_all_perl(pTHX_ bool justperl);
PERL_CALLCONV void	Perl_dump_eval(pTHX);
PERL_CALLCONV void	Perl_dump_form(pTHX_ const GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DUMP_FORM	\
	assert(gv)

PERL_CALLCONV void	Perl_dump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_3,pTHX_4)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DUMP_INDENT	\
	assert(file); assert(pat)

PERL_CALLCONV void	Perl_dump_packsubs(pTHX_ const HV* stash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DUMP_PACKSUBS	\
	assert(stash)

PERL_CALLCONV void	Perl_dump_packsubs_perl(pTHX_ const HV* stash, bool justperl)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DUMP_PACKSUBS_PERL	\
	assert(stash)

PERL_CALLCONV void	Perl_dump_sub(pTHX_ const GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DUMP_SUB	\
	assert(gv)

PERL_CALLCONV void	Perl_dump_sub_perl(pTHX_ const GV* gv, bool justperl)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_DUMP_SUB_PERL	\
	assert(gv)

PERL_CALLCONV void	Perl_dump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_DUMP_VINDENT	\
	assert(file); assert(pat)

PERL_CALLCONV void	Perl_emulate_cop_io(pTHX_ const COP *const c, SV *const sv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_EMULATE_COP_IO	\
	assert(c); assert(sv)

PERL_CALLCONV SV*	Perl_eval_pv(pTHX_ const char* p, I32 croak_on_error)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_EVAL_PV	\
	assert(p)

PERL_CALLCONV I32	Perl_eval_sv(pTHX_ SV* sv, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_EVAL_SV	\
	assert(sv)

PERL_CALLCONV void	Perl_fbm_compile(pTHX_ SV* sv, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FBM_COMPILE	\
	assert(sv)

PERL_CALLCONV char*	Perl_fbm_instr(pTHX_ unsigned char* big, unsigned char* bigend, SV* littlestr, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_FBM_INSTR	\
	assert(big); assert(bigend); assert(littlestr)

PERL_CALLCONV bool	Perl_feature_is_enabled(pTHX_ const char *const name, STRLEN namelen)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FEATURE_IS_ENABLED	\
	assert(name)

PERL_CALLCONV SV*	Perl_filter_add(pTHX_ filter_t funcp, SV* datasv);
PERL_CALLCONV void	Perl_filter_del(pTHX_ filter_t funcp)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FILTER_DEL	\
	assert(funcp)

PERL_CALLCONV I32	Perl_filter_read(pTHX_ int idx, SV *buf_sv, int maxlen)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_FILTER_READ	\
	assert(buf_sv)

PERL_CALLCONV void	Perl_finalize_optree(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FINALIZE_OPTREE	\
	assert(o)

PERL_CALLCONV CV *	Perl_find_lexical_cv(pTHX_ PADOFFSET off);
PERL_CALLCONV CV*	Perl_find_runcv(pTHX_ U32 *db_seqp)
			__attribute__warn_unused_result__;

PERL_CALLCONV CV*	Perl_find_runcv_where(pTHX_ U8 cond, IV arg, U32 *db_seqp)
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_find_rundefsv(pTHX);
PERL_CALLCONV SV*	Perl_find_rundefsv2(pTHX_ CV *cv, U32 seq)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FIND_RUNDEFSV2	\
	assert(cv)

PERL_CALLCONV PADOFFSET	Perl_find_rundefsvoffset(pTHX)
			__attribute__deprecated__;

PERL_CALLCONV char*	Perl_find_script(pTHX_ const char *scriptname, bool dosearch, const char *const *const search_ext, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FIND_SCRIPT	\
	assert(scriptname)

PERL_CALLCONV I32	Perl_foldEQ(const char* a, const char* b, I32 len)
			__attribute__pure__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_FOLDEQ	\
	assert(a); assert(b)

PERL_CALLCONV I32	Perl_foldEQ_latin1(const char* a, const char* b, I32 len)
			__attribute__pure__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_FOLDEQ_LATIN1	\
	assert(a); assert(b)

PERL_CALLCONV I32	Perl_foldEQ_locale(const char* a, const char* b, I32 len)
			__attribute__pure__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_FOLDEQ_LOCALE	\
	assert(a); assert(b)

/* PERL_CALLCONV I32	foldEQ_utf8(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_5); */

PERL_CALLCONV I32	Perl_foldEQ_utf8_flags(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_5);
#define PERL_ARGS_ASSERT_FOLDEQ_UTF8_FLAGS	\
	assert(s1); assert(s2)

PERL_CALLCONV char*	Perl_form(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_FORM	\
	assert(pat)

PERL_CALLCONV void	Perl_free_tied_hv_pool(pTHX);
PERL_CALLCONV void	Perl_free_tmps(pTHX);
PERL_CALLCONV AV*	Perl_get_av(pTHX_ const char *name, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_AV	\
	assert(name)

PERL_CALLCONV void*	Perl_get_context(void)
			__attribute__warn_unused_result__;

PERL_CALLCONV CV*	Perl_get_cv(pTHX_ const char* name, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_CV	\
	assert(name)

PERL_CALLCONV CV*	Perl_get_cvn_flags(pTHX_ const char* name, STRLEN len, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_CVN_FLAGS	\
	assert(name)

PERL_CALLCONV void	Perl_get_db_sub(pTHX_ SV **svp, CV *cv)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GET_DB_SUB	\
	assert(cv)

PERL_CALLCONV void	Perl_get_hash_seed(pTHX_ unsigned char * const seed_buffer)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_HASH_SEED	\
	assert(seed_buffer)

PERL_CALLCONV HV*	Perl_get_hv(pTHX_ const char *name, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_HV	\
	assert(name)

PERL_CALLCONV const char*	Perl_get_no_modify(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV char**	Perl_get_op_descs(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV char**	Perl_get_op_names(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV U32*	Perl_get_opargs(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV PPADDR_t*	Perl_get_ppaddr(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV REGEXP *	Perl_get_re_arg(pTHX_ SV *sv);
PERL_CALLCONV SV*	Perl_get_sv(pTHX_ const char *name, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GET_SV	\
	assert(name)

PERL_CALLCONV MGVTBL*	Perl_get_vtbl(pTHX_ int vtbl_id)
			__attribute__warn_unused_result__;

PERL_CALLCONV int	Perl_getcwd_sv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GETCWD_SV	\
	assert(sv)

PERL_CALLCONV void	Perl_gp_free(pTHX_ GV* gv);
PERL_CALLCONV GP*	Perl_gp_ref(pTHX_ GP* gp);
PERL_CALLCONV UV	Perl_grok_bin(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_GROK_BIN	\
	assert(start); assert(len_p); assert(flags)

PERL_CALLCONV UV	Perl_grok_hex(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_GROK_HEX	\
	assert(start); assert(len_p); assert(flags)

PERL_CALLCONV int	Perl_grok_number(pTHX_ const char *pv, STRLEN len, UV *valuep)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GROK_NUMBER	\
	assert(pv)

PERL_CALLCONV bool	Perl_grok_numeric_radix(pTHX_ const char **sp, const char *send)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GROK_NUMERIC_RADIX	\
	assert(sp); assert(send)

PERL_CALLCONV UV	Perl_grok_oct(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_GROK_OCT	\
	assert(start); assert(len_p); assert(flags)

/* PERL_CALLCONV GV*	Perl_gv_AVadd(pTHX_ GV *gv); */
/* PERL_CALLCONV GV*	Perl_gv_HVadd(pTHX_ GV *gv); */
/* PERL_CALLCONV GV*	Perl_gv_IOadd(pTHX_ GV* gv); */
PERL_CALLCONV GV*	Perl_gv_add_by_type(pTHX_ GV *gv, svtype type);
/* PERL_CALLCONV GV*	gv_autoload4(pTHX_ HV* stash, const char* name, STRLEN len, I32 method)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2); */

PERL_CALLCONV GV*	Perl_gv_autoload_pv(pTHX_ HV* stash, const char* namepv, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_AUTOLOAD_PV	\
	assert(namepv)

PERL_CALLCONV GV*	Perl_gv_autoload_pvn(pTHX_ HV* stash, const char* name, STRLEN len, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_AUTOLOAD_PVN	\
	assert(name)

PERL_CALLCONV GV*	Perl_gv_autoload_sv(pTHX_ HV* stash, SV* namesv, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_AUTOLOAD_SV	\
	assert(namesv)

PERL_CALLCONV void	Perl_gv_check(pTHX_ HV* stash)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_CHECK	\
	assert(stash)

PERL_CALLCONV SV*	Perl_gv_const_sv(pTHX_ GV* gv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_CONST_SV	\
	assert(gv)

PERL_CALLCONV void	Perl_gv_dump(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_DUMP	\
	assert(gv)

PERL_CALLCONV void	Perl_gv_efullname(pTHX_ SV* sv, const GV* gv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_EFULLNAME	\
	assert(sv); assert(gv)

/* PERL_CALLCONV void	Perl_gv_efullname3(pTHX_ SV* sv, const GV* gv, const char* prefix)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_GV_EFULLNAME3	\
	assert(sv); assert(gv)

PERL_CALLCONV void	Perl_gv_efullname4(pTHX_ SV* sv, const GV* gv, const char* prefix, bool keepmain)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_EFULLNAME4	\
	assert(sv); assert(gv)

PERL_CALLCONV GV*	Perl_gv_fetchfile(pTHX_ const char* name)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_FETCHFILE	\
	assert(name)

PERL_CALLCONV GV*	Perl_gv_fetchfile_flags(pTHX_ const char *const name, const STRLEN len, const U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_FETCHFILE_FLAGS	\
	assert(name)

/* PERL_CALLCONV GV*	gv_fetchmeth(pTHX_ HV* stash, const char* name, STRLEN len, I32 level)
			__attribute__nonnull__(pTHX_2); */

/* PERL_CALLCONV GV*	gv_fetchmeth_autoload(pTHX_ HV* stash, const char* name, STRLEN len, I32 level)
			__attribute__nonnull__(pTHX_2); */

PERL_CALLCONV GV*	Perl_gv_fetchmeth_pv(pTHX_ HV* stash, const char* name, I32 level, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_PV	\
	assert(name)

PERL_CALLCONV GV*	Perl_gv_fetchmeth_pv_autoload(pTHX_ HV* stash, const char* name, I32 level, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_PV_AUTOLOAD	\
	assert(name)

PERL_CALLCONV GV*	Perl_gv_fetchmeth_pvn(pTHX_ HV* stash, const char* name, STRLEN len, I32 level, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_PVN	\
	assert(name)

PERL_CALLCONV GV*	Perl_gv_fetchmeth_pvn_autoload(pTHX_ HV* stash, const char* name, STRLEN len, I32 level, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_PVN_AUTOLOAD	\
	assert(name)

PERL_CALLCONV GV*	Perl_gv_fetchmeth_sv(pTHX_ HV* stash, SV* namesv, I32 level, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_SV	\
	assert(namesv)

PERL_CALLCONV GV*	Perl_gv_fetchmeth_sv_autoload(pTHX_ HV* stash, SV* namesv, I32 level, U32 flags)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_SV_AUTOLOAD	\
	assert(namesv)

/* PERL_CALLCONV GV*	Perl_gv_fetchmethod(pTHX_ HV* stash, const char* name)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_GV_FETCHMETHOD	\
	assert(stash); assert(name)

PERL_CALLCONV GV*	Perl_gv_fetchmethod_autoload(pTHX_ HV* stash, const char* name, I32 autoload)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_AUTOLOAD	\
	assert(stash); assert(name)

PERL_CALLCONV GV*	Perl_gv_fetchmethod_pv_flags(pTHX_ HV* stash, const char* name, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_PV_FLAGS	\
	assert(stash); assert(name)

PERL_CALLCONV GV*	Perl_gv_fetchmethod_pvn_flags(pTHX_ HV* stash, const char* name, const STRLEN len, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_PVN_FLAGS	\
	assert(stash); assert(name)

PERL_CALLCONV GV*	Perl_gv_fetchmethod_sv_flags(pTHX_ HV* stash, SV* namesv, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FETCHMETHOD_SV_FLAGS	\
	assert(stash); assert(namesv)

PERL_CALLCONV GV*	Perl_gv_fetchpv(pTHX_ const char *nambeg, I32 add, const svtype sv_type)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_FETCHPV	\
	assert(nambeg)

PERL_CALLCONV GV*	Perl_gv_fetchpvn_flags(pTHX_ const char* name, STRLEN len, I32 flags, const svtype sv_type)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_FETCHPVN_FLAGS	\
	assert(name)

PERL_CALLCONV GV*	Perl_gv_fetchsv(pTHX_ SV *name, I32 flags, const svtype sv_type)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_FETCHSV	\
	assert(name)

PERL_CALLCONV void	Perl_gv_fullname(pTHX_ SV* sv, const GV* gv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FULLNAME	\
	assert(sv); assert(gv)

/* PERL_CALLCONV void	Perl_gv_fullname3(pTHX_ SV* sv, const GV* gv, const char* prefix)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_GV_FULLNAME3	\
	assert(sv); assert(gv)

PERL_CALLCONV void	Perl_gv_fullname4(pTHX_ SV* sv, const GV* gv, const char* prefix, bool keepmain)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_FULLNAME4	\
	assert(sv); assert(gv)

PERL_CALLCONV CV*	Perl_gv_handler(pTHX_ HV* stash, I32 id)
			__attribute__warn_unused_result__;

/* PERL_CALLCONV void	gv_init(pTHX_ GV* gv, HV* stash, const char* name, STRLEN len, int multi)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3); */

PERL_CALLCONV void	Perl_gv_init_pv(pTHX_ GV* gv, HV* stash, const char* name, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_GV_INIT_PV	\
	assert(gv); assert(name)

PERL_CALLCONV void	Perl_gv_init_pvn(pTHX_ GV* gv, HV* stash, const char* name, STRLEN len, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_GV_INIT_PVN	\
	assert(gv); assert(name)

PERL_CALLCONV void	Perl_gv_init_sv(pTHX_ GV* gv, HV* stash, SV* namesv, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_GV_INIT_SV	\
	assert(gv); assert(namesv)

PERL_CALLCONV void	Perl_gv_name_set(pTHX_ GV* gv, const char *name, U32 len, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_GV_NAME_SET	\
	assert(gv); assert(name)

PERL_CALLCONV GV *	Perl_gv_override(pTHX_ const char * const name, const STRLEN len)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_OVERRIDE	\
	assert(name)

PERL_CALLCONV HV*	Perl_gv_stashpv(pTHX_ const char* name, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_STASHPV	\
	assert(name)

PERL_CALLCONV HV*	Perl_gv_stashpvn(pTHX_ const char* name, U32 namelen, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_STASHPVN	\
	assert(name)

PERL_CALLCONV HV*	Perl_gv_stashsv(pTHX_ SV* sv, I32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_STASHSV	\
	assert(sv)

PERL_CALLCONV void	Perl_gv_try_downgrade(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_GV_TRY_DOWNGRADE	\
	assert(gv)

PERL_CALLCONV AV**	Perl_hv_backreferences_p(pTHX_ HV *hv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_BACKREFERENCES_P	\
	assert(hv)

PERL_CALLCONV void	Perl_hv_clear(pTHX_ HV *hv);
PERL_CALLCONV void	Perl_hv_clear_placeholders(pTHX_ HV *hv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_CLEAR_PLACEHOLDERS	\
	assert(hv)

PERL_CALLCONV void*	Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char* key, STRLEN klen, int flags, int action, SV *val, U32 hash);
PERL_CALLCONV void*	Perl_hv_common_key_len(pTHX_ HV *hv, const char *key, I32 klen_i32, const int action, SV *val, const U32 hash)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_HV_COMMON_KEY_LEN	\
	assert(key)

PERL_CALLCONV HV *	Perl_hv_copy_hints_hv(pTHX_ HV *const ohv)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_hv_delayfree_ent(pTHX_ HV *hv, HE *entry)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_DELAYFREE_ENT	\
	assert(hv)

/* PERL_CALLCONV SV*	Perl_hv_delete(pTHX_ HV *hv, const char *key, I32 klen, I32 flags)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_HV_DELETE	\
	assert(key)

/* PERL_CALLCONV SV*	Perl_hv_delete_ent(pTHX_ HV *hv, SV *keysv, I32 flags, U32 hash)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_HV_DELETE_ENT	\
	assert(keysv)

PERL_CALLCONV HE**	Perl_hv_eiter_p(pTHX_ HV *hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_EITER_P	\
	assert(hv)

PERL_CALLCONV void	Perl_hv_eiter_set(pTHX_ HV *hv, HE *eiter)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_EITER_SET	\
	assert(hv)

PERL_CALLCONV void	Perl_hv_ename_add(pTHX_ HV *hv, const char *name, U32 len, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_HV_ENAME_ADD	\
	assert(hv); assert(name)

PERL_CALLCONV void	Perl_hv_ename_delete(pTHX_ HV *hv, const char *name, U32 len, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_HV_ENAME_DELETE	\
	assert(hv); assert(name)

/* PERL_CALLCONV bool	Perl_hv_exists(pTHX_ HV *hv, const char *key, I32 klen)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_HV_EXISTS	\
	assert(key)

/* PERL_CALLCONV bool	Perl_hv_exists_ent(pTHX_ HV *hv, SV *keysv, U32 hash)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_HV_EXISTS_ENT	\
	assert(keysv)

/* PERL_CALLCONV SV**	Perl_hv_fetch(pTHX_ HV *hv, const char *key, I32 klen, I32 lval)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_HV_FETCH	\
	assert(key)

/* PERL_CALLCONV HE*	Perl_hv_fetch_ent(pTHX_ HV *hv, SV *keysv, I32 lval, U32 hash)
			__attribute__nonnull__(pTHX_2); */
#define PERL_ARGS_ASSERT_HV_FETCH_ENT	\
	assert(keysv)

PERL_CALLCONV STRLEN	Perl_hv_fill(pTHX_ HV *const hv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_FILL	\
	assert(hv)

PERL_CALLCONV void	Perl_hv_free_ent(pTHX_ HV *hv, HE *entry)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_FREE_ENT	\
	assert(hv)

PERL_CALLCONV I32	Perl_hv_iterinit(pTHX_ HV *hv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_ITERINIT	\
	assert(hv)

PERL_CALLCONV char*	Perl_hv_iterkey(pTHX_ HE* entry, I32* retlen)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_HV_ITERKEY	\
	assert(entry); assert(retlen)

PERL_CALLCONV SV*	Perl_hv_iterkeysv(pTHX_ HE* entry)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_ITERKEYSV	\
	assert(entry)

/* PERL_CALLCONV HE*	Perl_hv_iternext(pTHX_ HV *hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_HV_ITERNEXT	\
	assert(hv)

PERL_CALLCONV HE*	Perl_hv_iternext_flags(pTHX_ HV *hv, I32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_ITERNEXT_FLAGS	\
	assert(hv)

PERL_CALLCONV SV*	Perl_hv_iternextsv(pTHX_ HV *hv, char **key, I32 *retlen)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_HV_ITERNEXTSV	\
	assert(hv); assert(key); assert(retlen)

PERL_CALLCONV SV*	Perl_hv_iterval(pTHX_ HV *hv, HE *entry)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_HV_ITERVAL	\
	assert(hv); assert(entry)

PERL_CALLCONV void	Perl_hv_ksplit(pTHX_ HV *hv, IV newmax)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_KSPLIT	\
	assert(hv)

/* PERL_CALLCONV void	Perl_hv_magic(pTHX_ HV *hv, GV *gv, int how)
			__attribute__nonnull__(pTHX_1); */
#define PERL_ARGS_ASSERT_HV_MAGIC	\
	assert(hv)

PERL_CALLCONV void	Perl_hv_name_set(pTHX_ HV *hv, const char *name, U32 len, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_NAME_SET	\
	assert(hv)

PERL_CALLCONV I32	Perl_hv_placeholders_get(pTHX_ const HV *hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_GET	\
	assert(hv)

PERL_CALLCONV SSize_t*	Perl_hv_placeholders_p(pTHX_ HV *hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_P	\
	assert(hv)

PERL_CALLCONV void	Perl_hv_placeholders_set(pTHX_ HV *hv, I32 ph)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_PLACEHOLDERS_SET	\
	assert(hv)

PERL_CALLCONV void	Perl_hv_rand_set(pTHX_ HV *hv, U32 new_xhv_rand)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_RAND_SET	\
	assert(hv)

PERL_CALLCONV I32*	Perl_hv_riter_p(pTHX_ HV *hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_RITER_P	\
	assert(hv)

PERL_CALLCONV void	Perl_hv_riter_set(pTHX_ HV *hv, I32 riter)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_RITER_SET	\
	assert(hv)

PERL_CALLCONV SV*	Perl_hv_scalar(pTHX_ HV *hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_HV_SCALAR	\
	assert(hv)

/* PERL_CALLCONV SV**	Perl_hv_store(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash); */
/* PERL_CALLCONV HE*	Perl_hv_store_ent(pTHX_ HV *hv, SV *key, SV *val, U32 hash); */
/* PERL_CALLCONV SV**	Perl_hv_store_flags(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash, int flags); */
/* PERL_CALLCONV void	hv_undef(pTHX_ HV *hv); */
PERL_CALLCONV void	Perl_hv_undef_flags(pTHX_ HV *hv, U32 flags);
/* PERL_CALLCONV I32	ibcmp(pTHX_ const char* a, const char* b, I32 len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */

/* PERL_CALLCONV I32	ibcmp_locale(pTHX_ const char* a, const char* b, I32 len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */

/* PERL_CALLCONV I32	ibcmp_utf8(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_5); */

PERL_CALLCONV void	Perl_init_argv_symbols(pTHX_ int argc, char **argv)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_INIT_ARGV_SYMBOLS	\
	assert(argv)

PERL_CALLCONV void	Perl_init_constants(pTHX);
PERL_CALLCONV void	Perl_init_dbargs(pTHX);
PERL_CALLCONV void	Perl_init_debugger(pTHX);
PERL_CALLCONV int	Perl_init_i18nl10n(pTHX_ int printwarn);
PERL_CALLCONV int	Perl_init_i18nl14n(pTHX_ int printwarn);
PERL_CALLCONV void	Perl_init_stacks(pTHX);
PERL_CALLCONV void	Perl_init_tm(pTHX_ struct tm *ptm)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_INIT_TM	\
	assert(ptm)

PERL_CALLCONV char*	Perl_instr(const char* big, const char* little)
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_INSTR	\
	assert(big); assert(little)

PERL_CALLCONV U32	Perl_intro_my(pTHX);
PERL_CALLCONV OP*	Perl_invert(pTHX_ OP* cmd)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl_io_close(pTHX_ IO* io, bool not_implicit)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IO_CLOSE	\
	assert(io)

PERL_STATIC_INLINE bool	S_isALNUM_lazy(pTHX_ const char* p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_ISALNUM_LAZY	\
	assert(p)

PERL_STATIC_INLINE bool	S_isIDFIRST_lazy(pTHX_ const char* p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_ISIDFIRST_LAZY	\
	assert(p)

PERL_CALLCONV bool	Perl_is_ascii_string(const U8 *s, STRLEN len)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_IS_ASCII_STRING	\
	assert(s)

PERL_CALLCONV I32	Perl_is_lvalue_sub(pTHX)
			__attribute__warn_unused_result__;

PERL_STATIC_INLINE bool	S_is_safe_syscall(pTHX_ const char *pv, STRLEN len, const char *what, const char *op_name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);
#define PERL_ARGS_ASSERT_IS_SAFE_SYSCALL	\
	assert(pv); assert(what); assert(op_name)

PERL_CALLCONV bool	Perl_is_uni_alnum(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alnum_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alnumc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alnumc_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alpha(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alpha_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_ascii(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_ascii_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_blank(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_blank_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_cntrl(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_cntrl_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_digit(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_digit_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_graph(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_graph_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_idfirst(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_idfirst_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_lower(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_lower_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_print(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_print_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_punct(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_punct_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_space(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_space_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_upper(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_upper_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_xdigit(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_xdigit_lc(pTHX_ UV c)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_utf8_alnum(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_ALNUM	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_alnumc(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_ALNUMC	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_alpha(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_ALPHA	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_ascii(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_ASCII	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_blank(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_BLANK	\
	assert(p)

PERL_CALLCONV STRLEN	Perl_is_utf8_char(const U8 *s)
			__attribute__deprecated__
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_IS_UTF8_CHAR	\
	assert(s)

PERL_CALLCONV STRLEN	Perl_is_utf8_char_buf(const U8 *buf, const U8 *buf_end)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);
#define PERL_ARGS_ASSERT_IS_UTF8_CHAR_BUF	\
	assert(buf); assert(buf_end)

PERL_CALLCONV bool	Perl_is_utf8_cntrl(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_CNTRL	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_digit(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_DIGIT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_graph(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_GRAPH	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_idcont(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_IDCONT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_idfirst(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_IDFIRST	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_lower(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_LOWER	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_mark(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_MARK	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_perl_space(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_PERL_SPACE	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_perl_word(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_PERL_WORD	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_posix_digit(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_POSIX_DIGIT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_print(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_PRINT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_punct(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_PUNCT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_space(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_SPACE	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_string(const U8 *s, STRLEN len)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_IS_UTF8_STRING	\
	assert(s)

/* PERL_CALLCONV bool	Perl_is_utf8_string_loc(const U8 *s, STRLEN len, const U8 **ep)
			__attribute__nonnull__(1); */
#define PERL_ARGS_ASSERT_IS_UTF8_STRING_LOC	\
	assert(s)

PERL_CALLCONV bool	Perl_is_utf8_string_loclen(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el)
			__attribute__nonnull__(1);
#define PERL_ARGS_ASSERT_IS_UTF8_STRING_LOCLEN	\
	assert(s)

PERL_CALLCONV bool	Perl_is_utf8_upper(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_UPPER	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_xdigit(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_XDIGIT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_xidcont(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_XIDCONT	\
	assert(p)

PERL_CALLCONV bool	Perl_is_utf8_xidfirst(pTHX_ const U8 *p)
			__attribute__deprecated__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_IS_UTF8_XIDFIRST	\
	assert(p)

PERL_CALLCONV OP*	Perl_jmaybe(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_JMAYBE	\
	assert(o)

PERL_CALLCONV I32	Perl_keyword(pTHX_ const char *name, I32 len, bool all_keywords)
			__attribute__pure__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_KEYWORD	\
	assert(name)

PERL_CALLCONV int	Perl_keyword_plugin_standard(pTHX_ char* keyword_ptr, STRLEN keyword_len, OP** op_ptr)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_KEYWORD_PLUGIN_STANDARD	\
	assert(keyword_ptr); assert(op_ptr)

PERL_CALLCONV void	Perl_leave_scope(pTHX_ I32 base);
PERL_CALLCONV bool	Perl_lex_bufutf8(pTHX);
PERL_CALLCONV void	Perl_lex_discard_to(pTHX_ char* ptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_LEX_DISCARD_TO	\
	assert(ptr)

PERL_CALLCONV char*	Perl_lex_grow_linestr(pTHX_ STRLEN len);
PERL_CALLCONV bool	Perl_lex_next_chunk(pTHX_ U32 flags);
PERL_CALLCONV I32	Perl_lex_peek_unichar(pTHX_ U32 flags);
PERL_CALLCONV void	Perl_lex_read_space(pTHX_ U32 flags);
PERL_CALLCONV void	Perl_lex_read_to(pTHX_ char* ptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_LEX_READ_TO	\
	assert(ptr)

PERL_CALLCONV I32	Perl_lex_read_unichar(pTHX_ U32 flags);
PERL_CALLCONV void	Perl_lex_start(pTHX_ SV* line, PerlIO *rsfp, U32 flags);
PERL_CALLCONV void	Perl_lex_stuff_pv(pTHX_ const char* pv, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_LEX_STUFF_PV	\
	assert(pv)

PERL_CALLCONV void	Perl_lex_stuff_pvn(pTHX_ const char* pv, STRLEN len, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_LEX_STUFF_PVN	\
	assert(pv)

PERL_CALLCONV void	Perl_lex_stuff_sv(pTHX_ SV* sv, U32 flags)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_LEX_STUFF_SV	\
	assert(sv)

PERL_CALLCONV void	Perl_lex_unstuff(pTHX_ char* ptr)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_LEX_UNSTUFF	\
	assert(ptr)

PERL_CALLCONV OP*	Perl_list(pTHX_ OP* o);
PERL_CALLCONV void	Perl_load_module(pTHX_ U32 flags, SV* name, SV* ver, ...)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_LOAD_MODULE	\
	assert(name)

PERL_CALLCONV OP*	Perl_localize(pTHX_ OP *o, I32 lex)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_LOCALIZE	\
	assert(o)

PERL_CALLCONV I32	Perl_looks_like_number(pTHX_ SV *const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_LOOKS_LIKE_NUMBER	\
	assert(sv)

PERL_CALLCONV int	Perl_magic_clear_all_env(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_CLEAR_ALL_ENV	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_cleararylen_p(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_CLEARARYLEN_P	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_clearenv(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_CLEARENV	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_clearhint(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_CLEARHINT	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_clearhints(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_CLEARHINTS	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_clearisa(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_CLEARISA	\
	assert(mg)

PERL_CALLCONV int	Perl_magic_clearpack(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_CLEARPACK	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_clearsig(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_CLEARSIG	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_copycallchecker(pTHX_ SV* sv, MAGIC *mg, SV *nsv, const char *name, I32 namlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MAGIC_COPYCALLCHECKER	\
	assert(sv); assert(mg); assert(nsv)

PERL_CALLCONV void	Perl_magic_dump(pTHX_ const MAGIC *mg);
PERL_CALLCONV int	Perl_magic_existspack(pTHX_ SV* sv, const MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_EXISTSPACK	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_freearylen_p(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_FREEARYLEN_P	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_freeovrld(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_FREEOVRLD	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_get(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_GET	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_getarylen(pTHX_ SV* sv, const MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_GETARYLEN	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_getdefelem(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_GETDEFELEM	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_getnkeys(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_GETNKEYS	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_getpack(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_GETPACK	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_getpos(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_GETPOS	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_getsig(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_GETSIG	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_getsubstr(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_GETSUBSTR	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_gettaint(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_GETTAINT	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_getuvar(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_GETUVAR	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_getvec(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_GETVEC	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_killbackrefs(pTHX_ SV *sv, MAGIC *mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_KILLBACKREFS	\
	assert(sv); assert(mg)

PERL_CALLCONV SV*	Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags, U32 argc, ...)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MAGIC_METHCALL	\
	assert(sv); assert(mg); assert(meth)

PERL_CALLCONV int	Perl_magic_nextpack(pTHX_ SV *sv, MAGIC *mg, SV *key)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);
#define PERL_ARGS_ASSERT_MAGIC_NEXTPACK	\
	assert(sv); assert(mg); assert(key)

PERL_CALLCONV U32	Perl_magic_regdata_cnt(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_REGDATA_CNT	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_regdatum_get(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_GET	\
	assert(sv); assert(mg)

PERL_CALLCONV SV*	Perl_magic_scalarpack(pTHX_ HV *hv, MAGIC *mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SCALARPACK	\
	assert(hv); assert(mg)

PERL_CALLCONV int	Perl_magic_set(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SET	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_set_all_env(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SET_ALL_ENV	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setarylen(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETARYLEN	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setdbline(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETDBLINE	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setdefelem(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETDEFELEM	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setenv(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETENV	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_sethint(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETHINT	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setisa(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETISA	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setmglob(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETMGLOB	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setnkeys(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETNKEYS	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setpack(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETPACK	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setpos(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETPOS	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setregexp(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETREGEXP	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setsig(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETSIG	\
	assert(mg)

PERL_CALLCONV int	Perl_magic_setsubstr(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETSUBSTR	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_settaint(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETTAINT	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setutf8(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETUTF8	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setuvar(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETUVAR	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_setvec(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SETVEC	\
	assert(sv); assert(mg)

PERL_CALLCONV U32	Perl_magic_sizepack(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_SIZEPACK	\
	assert(sv); assert(mg)

PERL_CALLCONV int	Perl_magic_wipepack(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MAGIC_WIPEPACK	\
	assert(sv); assert(mg)

PERL_CALLCONV Malloc_t	Perl_malloc(MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_markstack_grow(pTHX);
PERL_CALLCONV SV*	Perl_mess(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MESS	\
	assert(pat)

PERL_CALLCONV SV*	Perl_mess_sv(pTHX_ SV* basemsg, bool consume)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MESS_SV	\
	assert(basemsg)

PERL_CALLCONV Free_t	Perl_mfree(Malloc_t where);
PERL_CALLCONV int	Perl_mg_clear(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);
#define PERL_ARGS_ASSERT_MG_CLEAR	\
	assert(sv)

PERL_CALLCONV int	Perl_mg_copy(pTHX_ SV *sv, SV *nsv, const char *key, I32 klen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);
#define PERL_ARGS_ASSERT_MG_COPY	\
	assert(sv); assert(nsv)

PERL_CALLCONV MAGIC*	Perl_mg_find(pTHX_ const SV* sv, int ty