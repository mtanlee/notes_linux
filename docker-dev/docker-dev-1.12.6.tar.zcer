it was
		     * created with fill_size-1 extra bytes in the fixed part.
		     */
		    if(partial_bytes != 0){
			/* moved the fill_expression bytes foward */
			memmove(fragP->fr_literal +fragP->fr_fix +partial_bytes,
				fragP->fr_literal +fragP->fr_fix,
				fragP->fr_var);
    			/* zero out the partial_bytes */
    			memset(fragP->fr_literal + fragP->fr_fix,
			       '\0',
			       partial_bytes);
			/* adjust the fixed part of the frag */
    			fragP->fr_fix += partial_bytes;
		    }
		    break;

		case rs_fill:
		    break;

		case rs_machine_dependent:
		    md_convert_frag(fragP);
		    /*
		     * After md_convert_frag, we make the frag into a ".fill 0"
		     * md_convert_frag() should set up any fixSs and constants
		     * required.
		     */
		    frag_wane(fragP);
		    break;

		case rs_dwarf2dbg:
		    dwarf2dbg_convert_frag(fragP);
		    break;

		case rs_leb128:
		  {
		    int size;
#ifdef OLD
		    valueT value = S_GET_VALUE (fragP->fr_symbol);
#else
		    valueT value;
  		      expressionS *expression;
  		
		      if(fragP->fr_symbol->expression != NULL){
			expression =
			  (expressionS *)fragP->fr_symbol->expression;
			value = 0;
			if(expression->X_add_symbol != NULL)
			    value += expression->X_add_symbol->sy_nlist.n_value;
			if(expression->X_subtract_symbol != NULL)
			   value -= 
			     expression->X_subtract_symbol->sy_nlist.n_value;
			value += expression->X_add_number;
		      }
		      else{
			value = fragP->fr_symbol->sy_nlist.n_value +
				fragP->fr_address;
		      }
#endif

		    size = output_leb128 (fragP->fr_literal + fragP->fr_fix,
					  value,
					  fragP->fr_subtype);
	       
		    fragP->fr_fix += size;
		    fragP->fr_type = rs_fill;
		    fragP->fr_var = 0;
		    fragP->fr_offset = 0;
		    fragP->fr_symbol = NULL; 
		  }
		  break;


		default:
		    BAD_CASE(fragP->fr_type);
		    break;
		}
	    }
	}

	/*
	 * For each section do the fixups for the frags.
	 */
	for(frchainP = frchain_root; frchainP; frchainP = frchainP->frch_next){
	    now_seg = frchainP->frch_nsect;
	    fixup_section(frchainP->frch_fix_root, frchainP->frch_nsect);
	}
}

/*
 * fixup_section() does the fixups of the frags and prepares the fixes so
 * relocation entries can be created from them.  The fixups cause the contents
 * of the frag to have the value for the fixup expression.  A fix structure that
 * ends up with a non-NULL fx_addsy will have a relocation entry created for it.
 */
static
void
fixup_section(
fixS *fixP,
int nsect)
{
    symbolS *add_symbolP;
    symbolS *sub_symbolP;
    signed_expr_t value;
    int size;
    char *place;
    int32_t where;
    char pcrel;
    fragS *fragP;
    int	add_symbol_N_TYPE;
    int	add_symbol_nsect;
#ifndef SPARC
    int sub_symbol_nsect;
#endif

	/*
	 * The general fix expression is "fx_addsy - fx_subsy + fx_offset".
	 * The goal is to put the result of this expression into the frag at
	 * "place" for size "size".  The value of the expression is calculated
	 * in the variable "value" and starts with just the fx_offset.
	 */
	for( ; fixP != NULL; fixP = fixP->fx_next){
	    fragP       = fixP->fx_frag;
	    know(fragP);
	    where	= fixP->fx_where;
	    place       = fragP->fr_literal + where;
	    size	= fixP->fx_size;
#ifdef TC_FIXUP_SYMBOL
		fixP->fx_offset += TC_FIXUP_SYMBOL(fixP, nsect, &fixP->fx_addsy);
		fixP->fx_offset -= TC_FIXUP_SYMBOL(fixP, nsect, &fixP->fx_subsy);
#endif
#if defined(I386) && defined(ARCH64)
		if(fixP->fx_addsy == fixP->fx_subsy){
			/*
			 * If we've fixed up both symbols to the same location,
			 * we don't need a relocation entry.
			 */
			fixP->fx_addsy = NULL;
			fixP->fx_subsy = NULL;
		}
#endif
	    add_symbolP = fixP->fx_addsy;
	    sub_symbolP = fixP->fx_subsy;
	    value  	= fixP->fx_offset;
	    pcrel       = fixP->fx_pcrel;

#if ARM
	    /* If the symbol is defined in this file, the linker won't set the
	       low-order bit for a Thumb symbol, so we have to do it here.  */
	    if(add_symbolP != NULL && add_symbolP->sy_desc & N_ARM_THUMB_DEF &&
	       !(sub_symbolP != NULL && sub_symbolP->sy_desc & N_ARM_THUMB_DEF) &&
	       !pcrel){
	        value |= 1;
	    }
#endif

	    add_symbol_N_TYPE = 0;
	    add_symbol_nsect = 0;

	    if(add_symbolP != NULL){
		add_symbol_N_TYPE = add_symbolP->sy_type & N_TYPE;
		if(add_symbol_N_TYPE == N_SECT)
		    add_symbol_nsect = add_symbolP->sy_other;
	    }

	    /*
	     * Is there a subtract symbol?
	     */
	    if(sub_symbolP){
		/* is it just -sym ? */
		if(add_symbolP == NULL){
		    if(sub_symbolP->sy_type != N_ABS)
			as_warn("Negative of non-absolute symbol %s",
				sub_symbolP->sy_name);
#if !(defined(I386) && defined(ARCH64))
			/* Symbol offsets are not part of fixups for x86_64. */
		    value -= sub_symbolP->sy_value;
#endif
		    fixP->fx_subsy = NULL;
		}
		/*
		 * There are both an add symbol and a subtract symbol at this
		 * point.
		 *
		 * If both symbols are absolute then just calculate the
		 * value of the fix expression and no relocation entry will be
		 * needed.
		 */
		else if((sub_symbolP->sy_type & N_TYPE) == N_ABS &&
		        (add_symbolP->sy_type & N_TYPE) == N_ABS){
		    value += add_symbolP->sy_value - sub_symbolP->sy_value;
		    add_symbolP = NULL;
		    fixP->fx_addsy = NULL; /* no relocation entry */
		    fixP->fx_subsy = NULL;
		}
		/*
		 * If both symbols are defined in a section then calculate the
		 * value of the fix expression and let a section difference
		 * relocation entry be created.
		 */
		else if((sub_symbolP->sy_type & N_TYPE) == N_SECT &&
		        (add_symbolP->sy_type & N_TYPE) == N_SECT){
#if defined(I386) && !defined(ARCH64)
		    /*
		     * For 'symbol@TLVP - subtract_symbol' type relocations the
		     * subtract_symbol value is stored in the contents of the
		     * item to be relocated.
		     */
		    if(fixP->fx_r_type == GENERIC_RELOC_TLV){
			value += fixP->fx_frag->fr_address + where +
				 fixP->fx_size - sub_symbolP->sy_value;
			fixP->fx_subsy = NULL; /* no SECTDIFF reloc entry */
			fixP->fx_pcrel = TRUE; /* force pcrel */
			goto down;
		    }
#endif
		    /*
		     * We are use the new features that are incompatible with
		     * 3.2 then just calculate the value and let this create a
		     * SECTDIFF relocation type.
		     */
#ifdef SPARC
		    /*
		     * Special case dealing with assembler internal relocation
		     * entries SPARC_RELOC_13 and RELOC_22. The can not be
		     * output and must be resolved.
		     */
		    if((fixP->fx_r_type == SPARC_RELOC_13) ||
		       (fixP->fx_r_type == SPARC_RELOC_22)){
			if(sub_symbolP->sy_other == add_symbolP->sy_other){
			    value += add_symbolP->sy_value -
			    sub_symbolP->sy_value;
			    add_symbolP = NULL;
			    fixP->fx_addsy = NULL; /* no relocation entry */
			    fixP->fx_subsy = NULL;
			}
			else{
			    as_warn("Can't emit reloc type %u {-symbol \"%s\"} "
			            "@ file address %llu (mode?).",
				    fixP->fx_r_type, sub_symbolP->sy_name,
				    fragP->fr_address + where);
			}
		    }
		    else
			value += add_symbolP->sy_value - sub_symbolP->sy_value;
#else
#if !(defined(I386) && defined(ARCH64))
			/*
			 * Special case for x86_64.  'value' doesn't include
			 * the difference between the two symbols because
			 * that's handled by the subtractor/vanilla reloc pair.
			 */
		    value += add_symbolP->sy_value;
		    value -= sub_symbolP->sy_value;
#else
		    /*
		     * But for x86_64 expressions in the debug section must
		     * be the actual value of the expression.
		     */
		    if(is_section_debug(nsect)){
			value += add_symbolP->sy_value;
			value -= sub_symbolP->sy_value;
		    }
#endif
		    sub_symbol_nsect = sub_symbolP->sy_other;
		    /*
		     * If we have the special assembly time constant expression
		     * of the difference of two symbols defined in the same
		     * section then divided by exactly 2 adjust the value and
		     * make sure these symbols will produce an assembly time
		     * constant.
		     */
		    if(fixP->fx_sectdiff_divide_by_two == 1){
			value = value / 2;
			if(is_assembly_time_constant_subtraction_expression(
				add_symbolP, add_symbol_nsect,
				sub_symbolP, sub_symbol_nsect) == TRUE){
			    fixP->fx_addsy = NULL; /* no relocation entry */
			    goto down;
			}
			else{
			    layout_line = fixP->line;
			    layout_file = fixP->file;
			    as_warn("section difference divide by two "
				    "expression, \"%s\" minus \"%s\" divide by "
				    "2 will not produce an assembly time "
				    "constant", add_symbolP->sy_name,
				    sub_symbolP->sy_name);
			}
		    }
		    if(is_end_section_address(add_symbol_nsect,
					      add_symbolP->sy_value) ||
		       is_end_section_address(sub_symbol_nsect,
					      sub_symbolP->sy_value)){
			if(is_assembly_time_constant_subtraction_expression(
				add_symbolP, add_symbol_nsect,
				sub_symbolP, sub_symbol_nsect) == TRUE){
			    fixP->fx_addsy = NULL; /* no relocation entry */
			    goto down;
			}
			if(is_section_debug(nsect) &&
	   		   strcmp(add_symbolP->sy_name, FAKE_LABEL_NAME) == 0 &&
	   		   strcmp(sub_symbolP->sy_name, FAKE_LABEL_NAME) == 0){
			    fixP->fx_addsy = NULL; /* no relocation entry */
			    goto down;
			}
			layout_line = fixP->line;
			layout_file = fixP->file;
			as_warn("section difference relocatable subtraction "
				"expression, \"%s\" minus \"%s\" using a "
				"symbol at the end of section will not "
				"produce an assembly time constant",
				add_symbolP->sy_name, sub_symbolP->sy_name);
			as_warn("use a symbol with a constant value created "
				"with an assignment instead of the expression, "
				"L_const_sym = %s - %s", add_symbolP->sy_name,
				sub_symbolP->sy_name);
			layout_line = 0;
			layout_file = NULL;
		    }
#endif
		    goto down;
		}
		/*
		 * If the subtract symbol is absolute subtract it's value from
		 * the fix expression and let a relocation entry get created
		 * that is not a section difference type.
		 */
		else if(sub_symbolP->sy_type == N_ABS){
		    value -= sub_symbolP->sy_value;
		    fixP->fx_subsy = NULL; /* no SECTDIFF relocation entry */
		}
#if defined(I386) && !defined(ARCH64)
		/*
		 * For 'symbol@TLVP - subtract_symbol' type relocations the
		 * subtract_symbol value is stored in the contents of the item
		 * to be relocated.
		 */
		else if(fixP->fx_r_type == GENERIC_RELOC_TLV){
		    value += fixP->fx_frag->fr_address + where + fixP->fx_size -
			     sub_symbolP->sy_value;
		    fixP->fx_subsy = NULL; /* no SECTDIFF relocation entry */
		    fixP->fx_pcrel = TRUE; /* force pcrel */
		}
#endif
		/*
		 * At this point we have something we can't generate a
		 * relocation entry for (two undefined symbols, etc.).
		 */
	        else{
		     layout_line = fixP->line;
		     layout_file = fixP->file;
		     as_bad("non-relocatable subtraction expression, \"%s\" "
			     "minus \"%s\"", add_symbolP->sy_name,
			     sub_symbolP->sy_name);
		     if((add_symbolP->sy_type & N_TYPE) == N_UNDF)
			as_bad("symbol: \"%s\" can't be undefined in a "
				"subtraction expression", add_symbolP->sy_name);
		     if((sub_symbolP->sy_type & N_TYPE) == N_UNDF)
			as_bad("symbol: \"%s\" can't be undefined in a "
				"subtraction expression", sub_symbolP->sy_name);
		     layout_line = 0;
		     layout_file = NULL;
		}
	    }

	    /*
	     * If a there is an add symbol in the fixup expression then add
	     * the symbol value into the fixup expression's value.
	     */
	    if(add_symbolP){
		/*
		 * If this symbol is in this section and is pc-relative and we
		 * do not want to force a pc-relative relocation entry (to
		 * support scattered loading) then just calculate the value.
		 */
		if(add_symbol_nsect == nsect
		   /* FROM write.c line 2659 */
#ifdef ARM
		   && !TC_FORCE_RELOCATION_LOCAL (fixP)
#else
		   && pcrel
#endif
		   && !(fixP->fx_pcrel_reloc)){
		    /*
		     * This fixup was made when the symbol's section was
		     * unknown, but it is now in this section. So we know how
		     * to do the address without relocation.
		     */
		    value += add_symbolP->sy_value;
#ifdef ARM
		    /* FROM write.c line 2667 */
		    value -= MD_PCREL_FROM_SECTION (fixP, nsect);
#else
		    value -= size + where + fragP->fr_address;
#endif
		    pcrel = 0;	/* Lie. Don't want further pcrel processing. */
		    fixP->fx_addsy = NULL; /* No relocations please. */
		    /*
		     * It would be nice to check that the address does not
		     * overflow.
		     * I didn't do this check because:
		     * +  It is machine dependent in the general case (eg 32032)
		     * +  Compiler output will never need this checking, so why
		     *    slow down the usual case?
		     */
		}
		else{
		    switch(add_symbol_N_TYPE){
		    case N_ABS:
			/*
			 * If the value of the symbol was an expression then
			 * now evaluate the expression now.  This can happen
			 * when symbols like:
			 *	.set x,a-b
			 * are used and the value of x is not known till all
			 * of the symbols are seen and had their values set.
			 */
			if(add_symbolP->expression != NULL){
			    expressionS *exp;

			    exp = (expressionS *)add_symbolP->expression;
			    value +=
				exp->X_add_symbol->sy_value +
				exp->X_add_number -
				exp->X_subtract_symbol->sy_value;
			}
			else
			{
			    value += add_symbolP->sy_value;
			}
			fixP->fx_addsy = NULL; /* no relocation entry */
			add_symbolP = NULL;
			break;
			
		    case N_SECT:
#if (defined(I386) && defined(ARCH64))
			/*
			 * Symbol offsets are not part of fixups for external
			 * symbols for x86_64.
			 */
			if((is_section_debug(nsect) &&
			    add_symbol_N_TYPE != N_UNDF) ||
			   (add_symbol_N_TYPE == N_SECT &&
			    is_local_symbol(add_symbolP) &&
			    !is_section_cstring_literals(add_symbol_nsect)) )
#else
			if(((add_symbolP->sy_type & N_EXT) != N_EXT ||
			    add_symbol_N_TYPE != N_SECT ||
			    !is_section_coalesced(add_symbol_nsect)) &&
			   (add_symbolP->sy_desc & N_WEAK_DEF) != N_WEAK_DEF
#if defined(I386) && !defined(ARCH64)
			   &&
			   fixP->fx_r_type != GENERIC_RELOC_TLV
#endif
			  )
#endif
			    value += add_symbolP->sy_value;
			break;
			
		    case N_UNDF:
			break;
			
		    default:
			BAD_CASE(add_symbol_N_TYPE);
			break;
		    }
		}
	    }
down:
	    /*
	     * If the fixup expression is pc-relative then the value of the pc
	     * will be added to the expression when the machine executes the
	     * the instruction so we adjust the fixup expression's value by
	     * subtracting off the pc value (where) and adjust for insn size.
	     */
	    if(pcrel){
#ifdef ARM
	        /* This should work for both */
	        /* FROM write.c line 2688 */
		value -= MD_PCREL_FROM_SECTION (fixP, nsect);
#elif !(defined(I386) && defined(ARCH64))
		/* Symbol offsets are not part of fixups for x86_64. */
		value -= size + where + fragP->fr_address;
#endif
		if(add_symbolP == NULL){
		    fixP->fx_addsy = &abs_symbol; /* force relocation entry */
		}
	    }

	    if((size == 1 && (value & 0xffffff00) &&
			    ((value & 0xffffff80) != 0xffffff80)) ||
	       (size == 2 && (value & 0xffff0000) &&
			    ((value & 0xffff8000) != 0xffff8000))){
		layout_line = fixP->line;
		layout_file = fixP->file;
		as_bad("Fixup of %lld too large for field width of %d",
			value, size);
		layout_line = 0;
		layout_file = NULL;
	    }

	    /*
	     * Now place the fix expression's value in the place for the size.
	     * And save the fix expression's value to be used when creating
	     * a relocation entry if required.
	     */
	    md_number_to_imm((unsigned char *)place, value, size, fixP, nsect);
	    fixP->fx_value = value;

	    /*
	     * If this is a non-lazy pointer section and this fix is for a
	     * local symbol without an subtract symbol then cause this not to
	     * generate a relocation entry.  This is used with code gen for
	     * fix-n-continue where the compiler generates indirection for
	     * static data references.  So the assembly looks like this:
	     *
	     * 	.non_lazy_symbol_pointer
	     * 	L_i$non_lazy_ptr:
       	     * 	.indirect_symbol _i
       	     * 	.long   _i
	     *
	     * this allows the value of the symbol to be set into the pointer
	     * but not cause the relocation entry to be created.  The code in
	     * write_object() then changes the indirect symbol table entry to
	     * INDIRECT_SYMBOL_LOCAL when the symbol is local.  This is what
	     * the static and dynamic linkers expect and will then cause the
	     * pointer to be correctly relocated.
	     */
	    if(is_section_non_lazy_symbol_pointers(nsect) &&
	       (add_symbolP->sy_type & N_EXT) != N_EXT &&
	       sub_symbolP == NULL){
		fixP->fx_addsy = NULL; /* no relocation entry */
	    }
	}
}

#ifndef SPARC
/*
 * is_assembly_time_constant_subtraction_expression() is passed the symbols and
 * section numbers of a subtraction expression invloving symbols both defined in
 * some section.  If the subtraction expression is an assembly time constant
 * value then this returns 1 (TRUE) else this returns 0 (FALSE).
 *
 * Since the static link editor can break apart a section this routine can only
 * return TRUE when it is known for sure these symbols will not be moved apart
 * from each other.  So this is an assembly time constant subtraction expression
 * if the following are all true:
 * - the expression's symbols are assembly temporary symbols (starting with 'L')
 * - assembly temporary symbol are not being saved (no -L flag)
 * - the two symbols are in the same section
 * - the section is a regular section or coalesced section (non-literal section)
 * - there are no non-assembly temporary symbols defined between two symbols of
 *   the expression.  For example if the assembly code is:
 *	L1: nop
 *	foo: nop
 *	L2: nop
 *   the expression is L1-L2 is not an assembly time constant because the block
 *   of code after foo (including the address of L2) could be link edited away
 *   from the block of code with L1.
 */
static
int
is_assembly_time_constant_subtraction_expression(
symbolS *add_symbolP,
int add_symbol_nsect,
symbolS *sub_symbolP,
int sub_symbol_nsect)
{
    struct frchain *frchainP;
    uint32_t section_type, section_attributes;
    symbolS *prev_symbol;
    int non_assembly_temporary_symbol;

	/* see if both symbols are assembly temporary symbols */
	if(add_symbolP->sy_name == NULL || add_symbolP->sy_name[0] != 'L' ||
	   sub_symbolP->sy_name == NULL || sub_symbolP->sy_name[0] != 'L')
	    return(0);

	/* make sure we are not saving assembly temporary symbols */
	if(flagseen[(int)'L'])
	    return(0);

	/* make sure the two symbols are in the same section */
	if(add_symbol_nsect != sub_symbol_nsect)
	    return(0);

	/* make sure the section is a regular or coalesced section */
	section_attributes = 0;
	for(frchainP = frchain_root; frchainP; frchainP = frchainP->frch_next){
	    if(frchainP->frch_nsect == add_symbol_nsect){
		section_type = frchainP->frch_section.flags & SECTION_TYPE;
		section_attributes = frchainP->frch_section.flags &
				     SECTION_ATTRIBUTES;
		if(section_type == S_REGULAR || section_type == S_COALESCED)
		    break;
		else
		    return(0);
	    }
	}

	/*
	 * See if we can find the chain of symbols from the add_symbolP through
	 * its previous symbols to the sub_symbolP.  And check for non assembler
	 * temporary symbols along that chain.
	 */
	non_assembly_temporary_symbol = 0;
	for(prev_symbol = add_symbolP->sy_prev_by_index;
	    prev_symbol != NULL;
	    prev_symbol = prev_symbol->sy_prev_by_index){
	    if((prev_symbol->sy_type & N_SECT) == N_SECT &&
	       (prev_symbol->sy_type & N_STAB) == 0 &&
		prev_symbol->sy_other == add_symbol_nsect){
		if(prev_symbol == sub_symbolP){
		    if(non_assembly_temporary_symbol == 0)
			return(1);
		    else
			return(0);
		}
		if(prev_symbol->sy_name != NULL &&
		   prev_symbol->sy_name[0] != 'L')
		    non_assembly_temporary_symbol = 1;
	    }
	}

	/*
	 * Couldn't find the chain above, so now try we can find the chain of
	 * symbols from the sub_symbolP through its previous symbols to the
	 * add_symbolP.  And check for non assembler temporary symbols along
	 * that chain.
	 */
	non_assembly_temporary_symbol = 0;
	for(prev_symbol = sub_symbolP->sy_prev_by_index;
	    prev_symbol != NULL;
	    prev_symbol = prev_symbol->sy_prev_by_index){
	    if((prev_symbol->sy_type & N_SECT) == N_SECT &&
	       (prev_symbol->sy_type & N_STAB) == 0 &&
		prev_symbol->sy_other == sub_symbol_nsect){
		if(prev_symbol == add_symbolP){
		    if(non_assembly_temporary_symbol == 0)
			return(1);
		    else
			return(0);
		}
		if(prev_symbol->sy_name != NULL &&
		   prev_symbol->sy_name[0] != 'L')
		    non_assembly_temporary_symbol = 1;
	    }
	}

	/*
	 * It is possible that this expression is coming from a dwarf section
	 * made from .file and .loc directives.  If so both symbols would have
	 * the FAKE_LABEL_NAME and the section_type would be
	 * and in this case the then the expression is an assembly time
	 * constant.
	 */
	if((section_attributes & S_ATTR_DEBUG) == S_ATTR_DEBUG &&
	   strcmp(add_symbolP->sy_name, FAKE_LABEL_NAME) == 0 &&
	   strcmp(sub_symbolP->sy_name, FAKE_LABEL_NAME) == 0)
	    return(1);

	return(0);
}
#endif /* !defined(SPARC) */

/*
 * relax_section() here we set the fr_address values in the frags.
 * After this, all frags in this segment have addresses that are correct
 * relative to the section (that is the section starts at address zero).
 * After all of the sections have been processed by this call and their sizes
 * are know then they can be slid to their final address.
 */
static
int
relax_section(
struct frag *frag_root,
int nsect)
{
    struct frag *fragP;
    relax_addressT address;

    int32_t stretch; /* May be any size, 0 or negative. */
		     /* Cumulative number of addresses we have */
		     /* relaxed this pass. */
		     /* We may have relaxed more than one address. */
    int32_t stretched;  /* Have we stretched on this pass? */
		    /* This is 'cuz stretch may be zero, when,
		       in fact some piece of code grew, and
		       another shrank.  If a branch instruction
		       doesn't fit anymore, we need another pass */

#ifndef ARM
    const relax_typeS *this_type;
    const relax_typeS *start_type;
    relax_substateT next_state;
    relax_substateT this_state;
    int32_t aim;
#endif /* !defined(ARM) */

    int32_t growth;
    uint32_t was_address;
    int32_t offset;
    symbolS *symbolP;
    int32_t target;
    int32_t after;
    uint32_t oldoff, newoff;
    int ret;

	ret = 0;
	growth = 0;

	/*
	 * For each frag in segment count and store (a 1st guess of) fr_address.
	 */
	address = 0;
	for(fragP = frag_root; fragP != NULL; fragP = fragP->fr_next){
#ifdef ARM
            fragP->relax_marker = 0;
#endif /* ARM */
	    fragP->fr_address = address;
	    address += fragP->fr_fix;
	    switch(fragP->fr_type){
	    case rs_fill:
		address += fragP->fr_offset * fragP->fr_var;
		break;

	    case rs_align:
		offset = relax_align (address, (int) fragP->fr_offset);
		/*
		 * If a maximum number of bytes to fill was specified for this
		 * align (stored in fr_subtype) then check to see if this align
		 * can be done.  If not ignore it.  If so and this alignment is
		 * larger than any previous alignment then this becomes the
		 * section's alignment.
		 */
		if(fragP->fr_subtype != 0){
		    if(offset > (int32_t)fragP->fr_subtype){
			offset = 0;
		    }
		    else{
			if(frchain_now->frch_section.align <
			   (uint32_t)fragP->fr_offset)
			    frchain_now->frch_section.align = fragP->fr_offset;
		    }
		}
		address += offset;
		break;

	    case rs_org:
		/*
		 * Assume .org is nugatory. It will grow with 1st relax.
		 */
		break;

	    case rs_machine_dependent:
		address += md_estimate_size_before_relax(fragP, nsect);
		break;

	    case rs_dwarf2dbg:
		address += dwarf2dbg_estimate_size_before_relax(fragP);
		break;

	    case rs_leb128:
	      /* Initial guess is always 1; doing otherwise can result in
		 stable solutions that are larger than the minimum.  */
	      address += fragP->fr_offset = 1;
	      break;

	    default:
		BAD_CASE(fragP->fr_type);
		break;
	    }
	}

	/*
	 * Do relax().
	 * Make repeated passes over the chain of frags allowing each frag to
	 * grow if needed.  On each pass each frag's address is incremented by
	 * the accumulated growth, kept in stretched.  Passes are continued 
	 * until there is no stretch on the previous pass.
	 */
	do{
	    stretch = 0;
	    stretched = 0;
	    for(fragP = frag_root; fragP != NULL; fragP = fragP->fr_next){
#ifdef ARM
                fragP->relax_marker ^= 1;
#endif /* ARM */
		was_address = fragP->fr_address;
		fragP->fr_address += stretch;
		address = fragP->fr_address;
		symbolP = fragP->fr_symbol;
		offset = fragP->fr_offset;
		switch(fragP->fr_type){
		case rs_fill:	/* .fill never relaxes. */
		    growth = 0;
		    break;

		case rs_align:
		    oldoff = relax_align(was_address + fragP->fr_fix, offset);
		    newoff = relax_align(address + fragP->fr_fix, offset);
		    /*
		     * Check if a maximum number of bytes to fill was specified
		     * for this align (stored in fr_subtype).
		     */
		    if(fragP->fr_subtype != 0){
			if(oldoff > fragP->fr_subtype)
			    oldoff = 0;
			if(newoff > fragP->fr_subtype)
			    newoff = 0;
		    }
		    growth = newoff - oldoff;
		    break;

		case rs_org:
		    target = offset;
		    if(symbolP != NULL){
			know(((symbolP->sy_type & N_TYPE) == N_ABS) ||
			     ((symbolP->sy_type & N_TYPE) == N_SECT));
			know(symbolP->sy_frag);
			know((symbolP->sy_type & N_TYPE) != N_ABS ||
			     symbolP->sy_frag == &zero_address_frag );
			target += symbolP->sy_value +
				  symbolP->sy_frag->fr_address;
		    }
		    know(fragP->fr_next);
		    after = fragP->fr_next->fr_address;
		    /*
		     * Growth may be negative, but variable part of frag cannot
		     * have < 0 chars. That is, we can't .org backwards.
		     */
		    growth = ((target - after ) > 0) ? (target - after) : 0;

		    growth -= stretch;	/* This is an absolute growth factor */
		    break;

		case rs_machine_dependent:
#ifdef ARM
		    growth = arm_relax_frag(nsect, fragP, stretch);
#else /* !defined(ARM) */
		    this_state = fragP->fr_subtype;
		    this_type = md_relax_table + this_state;
		    start_type = this_type;

		    target = offset;
		    if(symbolP){
			know(((symbolP->sy_type & N_TYPE) == N_ABS) ||
			     ((symbolP->sy_type & N_TYPE) == N_SECT));
			know(symbolP->sy_frag);
			know((symbolP->sy_type & N_TYPE) != N_ABS ||
			     symbolP->sy_frag == &zero_address_frag);

			target += symbolP->sy_value +
				  symbolP->sy_frag->fr_address;
			/*
			 * If frag has yet to be reached on this pass,
			 * assume it will move by STRETCH just as we did.
			 * If this is not so, it will be because some frag
			 * between grows, and that will force another pass.
			 */
			if(symbolP->sy_frag->fr_address >= was_address &&
			   is_down_range(fragP, symbolP->sy_frag))
			    target += stretch;
		    }
		    aim = target - address - fragP->fr_fix;
		    if(aim < 0){
			/* Look backwards. */
			for(next_state = this_type->rlx_more; next_state; ){
			    if(aim >= this_type->rlx_backward)
				next_state = 0;
			    else{	/* Grow to next state. */
				this_state = next_state;
				this_type = md_relax_table + this_state;
				next_state = this_type->rlx_more;
			    }
			}
		    }
		    else{
			/* Look forwards. */
			for(next_state = this_type->rlx_more; next_state; ){
			    if(aim <= this_type->rlx_forward)
				next_state = 0;
			    else{	/* Grow to next state. */
				this_state = next_state;
				this_type = md_relax_table + this_state;
				next_state = this_type->rlx_more;
			    }
			}
		    }
		    if((growth = this_type->rlx_length -start_type->rlx_length))
			  fragP->fr_subtype = this_state;
#endif /* !defined(ARM) */
		    break;
		  case rs_dwarf2dbg:
		      growth = dwarf2dbg_relax_frag(fragP);
		      break;

		  case rs_leb128:
		    {
		      valueT value;
		      offsetT size;
#ifdef OLD
		      value = resolve_symbol_value (fragP->fr_symbol);
#else
  		      expressionS *expression;
  		
		      if(fragP->fr_symbol->expression != NULL){
			expression =
			  (expressionS *)fragP->fr_symbol->expression;
			value = 0;
			if(expression->X_add_symbol != NULL)
			    value +=
			     (expression->X_add_symbol->sy_nlist.n_value +
			      expression->X_add_symbol->sy_frag->fr_address);
			if(expression->X_subtract_symbol != NULL)
			   value -= 
			     (expression->X_subtract_symbol->sy_nlist.n_value +
			      expression->X_subtract_symbol->
							   sy_frag->fr_address);
			value += expression->X_add_number;
		      }
		      else{
			value = fragP->fr_symbol->sy_nlist.n_value +
				fragP->fr_address;
		      }
#endif
		      size = sizeof_leb128 (value, fragP->fr_subtype);
		      growth = size - fragP->fr_offset;
		      fragP->fr_offset = size;
		    }
		    break;

		  default:
		      BAD_CASE(fragP->fr_type);
		      break;
		}
		if(growth) {
		    stretch += growth;
		    stretched++;
		}
	    }			/* For each frag in the segment. */
	}while(stretched);	/* Until nothing further to relax. */

	/*
	 * We now have valid fr_address'es for each frag.  All fr_address's
	 * are correct, relative to their own section.  We have made all the
	 * fixS for this section that will be made.
	 */

	for(fragP = frag_root; fragP != NULL; fragP = fragP->fr_next){
	    if(fragP->last_fr_address != fragP->fr_address){
		fragP->last_fr_address = fragP->fr_address;
		ret = 1;
	    }
	}
	return(ret);
}

/*
 * Relax_align. Advance location counter to next address that has 'alignment'
 * lowest order bits all 0s.
 */
static
relax_addressT		/* How many addresses does the .align take? */
relax_align(
relax_addressT address, /* Address now. */
uint32_t alignment)		/* Alignment (binary). */
{
    relax_addressT mask;
    relax_addressT new_address;

	mask = ~ ( (~0) << alignment );
	new_address = (address + mask) & (~ mask);
	return(new_address - address);
}

#ifndef ARM
/*
 * is_down_range() is used in relax_section() to determine it one fragment is
 * after another to know if it will also be moved if the first is moved.
 */
static
int
is_down_range(
struct frag *f1,
struct frag *f2)
{
	while(f1){
	    if(f1->fr_next == f2)
		return(1);
	    f1 = f1->fr_next;
	}
	return(0);
}
#endif /* !defined(ARM) */
                                                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/layout.h                                 0100644 0001750 0001750 00000000134 12612724204 022525  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        extern void add_last_frags_to_sections(
    void);
extern void layout_addresses(
    void);
                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/m68k-check.c                             0100644 0001750 0001750 00000246432 12612724204 023060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <stdio.h>
#define DREG	0x1	/* Data Register Direct */
#define	AREG	0x2	/* Address Register Direct */
#define	AINDR	0x4	/* Address Register Indirect */
#define	AINC	0x8	/* Address Register Indirect with Postincrement */
#define	ADEC	0x10	/* Address Register Indirect with Predecrement */
#define	Ad16	0x20	/* Address Register Indirect with Displacement */
#define	Ad8Xn	0x40	/* Address Register Indirect with Index */
			/*  (8-Bit Displacement) */
#define	AbdXn	0x80	/* Address Register Indirect with Index */
			/*  (Base Displacement) */
#define	MIPRE	0x100	/* Memory Indirect with Preindexed */
#define	MIPOST	0x200	/* Memory Indirect with Postindexed */
#define	ABSW	0x400	/* Absolute Short */
#define	ABSL	0x800	/* Absolute Long */
#define	IMMED	0x1000	/* Immediate */
#define	PCd16	0x2000	/* Program Counter Indirect with Displacement */
#define	PCd8Xn	0x4000	/* Program Counter Indirect with Index */
			/*  (8-Bit Displacement) */
#define	PCbdXn	0x8000	/* Program Counter Indirect with Index */
			/*  (Base Displacement) */
#define	PCMIPRE	0x10000	/* Program Counter Memory Indirect with Preindexed */
#define	PCMIPOST 0x20000/* Program Counter Memory Indirect with Postindexed */
#define MOVEC_REG	0x40000
#define SPECIAL_1	0x80000
#define SPECIAL_2	0x100000
#define SPECIAL_3	0x200000

struct operand {
    char *string;
    int32_t type;
};

struct operand ops[] = {
/* Dn "Data Register Direct" Dn */
    { "d0",			DREG },
/* An "Address Register Direct" An */
    { "a1",			AREG },
/* An@ "Address Register Indirect" (An) */
    { "a3@",			AINDR },
/* An@+ "Address Register Indirect with Postincrement" (An)+ */
    { "a3@+",			AINC },
/* An@- "Address Register Indirect with Predecrement" -(An) */
    { "a3@-",			ADEC },
/* An@(d16) "Address Register Indirect with Displacement" (d16,An) */
    { "a3@(0x1234:w)",		Ad16 },
/* An@(d8,Xn) "Address Register Indirect with Index (8-Bit Displacement)"
   uses Brief Format Extension Word (d8,An,Xn) */
#ifdef ALL_OPERANDS
    { "a3@(0x12:b,d2:w:1)",	Ad8Xn },
    { "a3@(0x12:b,d2:w:2)",	Ad8Xn },
    { "a3@(0x12:b,d2:w:4)",	Ad8Xn },
    { "a3@(0x12:b,d2:w:8)",	Ad8Xn },
    { "a3@(0x12:b,d2:l:1)",	Ad8Xn },
    { "a3@(0x12:b,d2:l:2)",	Ad8Xn },
    { "a3@(0x12:b,d2:l:4)",	Ad8Xn },
    { "a3@(0x12:b,d2:l:8)",	Ad8Xn },
    { "a3@(0x12:b,a5:w:1)",	Ad8Xn },
    { "a3@(0x12:b,a5:w:2)",	Ad8Xn },
    { "a3@(0x12:b,a5:w:4)",	Ad8Xn },
    { "a3@(0x12:b,a5:w:8)",	Ad8Xn },
    { "a3@(0x12:b,a5:l:1)",	Ad8Xn },
    { "a3@(0x12:b,a5:l:2)",	Ad8Xn },
    { "a3@(0x12:b,a5:l:4)",	Ad8Xn },
#endif /* ALL_OPERANDS */
    { "a3@(0x12:b,a5:l:8)",	Ad8Xn },
/* An@(bd,Xn) "Address Register Indirect with Index (Base Displacement)",
   uses Full Format Extension Word(s) (bd,An,Xn) */
#ifdef ALL_OPERANDS
/* the form of An@(bd,Xn) with bd (base displacement) encoded as a null
   displacement will not be generated by the assembler because it will use
   the form An(d8,Xn).
    { "a3@(0)",			AbdXn },
    { "a3@(0,d2:w:1)",		AbdXn },
    { "a3@(0,d2:w:2)",		AbdXn },
    { "a3@(0,d2:w:4)",		AbdXn },
    { "a3@(0,d2:w:8)",		AbdXn },
    { "a3@(0,d2:l:1)",		AbdXn },
    { "a3@(0,d2:l:2)",		AbdXn },
    { "a3@(0,d2:l:4)",		AbdXn },
    { "a3@(0,d2:l:8)",		AbdXn },
    { "a3@(0,a5:w:1)",		AbdXn },
    { "a3@(0,a5:w:2)",		AbdXn },
    { "a3@(0,a5:w:4)",		AbdXn },
    { "a3@(0,a5:w:8)",		AbdXn },
    { "a3@(0,a5:l:1)",		AbdXn },
    { "a3@(0,a5:l:2)",		AbdXn },
    { "a3@(0,a5:l:4)",		AbdXn },
    { "a3@(0,a5:l:8)",		AbdXn },
*/
    { "a3@(0x1234:w,d2:w:1)",	AbdXn },
    { "a3@(0x1234:w,d2:w:2)",	AbdXn },
    { "a3@(0x1234:w,d2:w:4)",	AbdXn },
    { "a3@(0x1234:w,d2:w:8)",	AbdXn },
    { "a3@(0x1234:w,d2:l:1)",	AbdXn },
    { "a3@(0x1234:w,d2:l:2)",	AbdXn },
    { "a3@(0x1234:w,d2:l:4)",	AbdXn },
    { "a3@(0x1234:w,d2:l:8)",	AbdXn },
    { "a3@(0x1234:w,a5:w:1)",	AbdXn },
    { "a3@(0x1234:w,a5:w:2)",	AbdXn },
    { "a3@(0x1234:w,a5:w:4)",	AbdXn },
    { "a3@(0x1234:w,a5:w:8)",	AbdXn },
    { "a3@(0x1234:w,a5:l:1)",	AbdXn },
    { "a3@(0x1234:w,a5:l:2)",	AbdXn },
    { "a3@(0x1234:w,a5:l:4)",	AbdXn },
    { "a3@(0x1234:w,a5:l:8)",	AbdXn },
    { "a3@(0x1234abcd:l,d2:w:1)",	AbdXn },
    { "a3@(0x1234abcd:l,d2:w:2)",	AbdXn },
    { "a3@(0x1234abcd:l,d2:w:4)",	AbdXn },
    { "a3@(0x1234abcd:l,d2:w:8)",	AbdXn },
    { "a3@(0x1234abcd:l,d2:l:1)",	AbdXn },
    { "a3@(0x1234abcd:l,d2:l:2)",	AbdXn },
    { "a3@(0x1234abcd:l,d2:l:4)",	AbdXn },
    { "a3@(0x1234abcd:l,d2:l:8)",	AbdXn },
    { "a3@(0x1234abcd:l,a5:w:1)",	AbdXn },
    { "a3@(0x1234abcd:l,a5:w:2)",	AbdXn },
    { "a3@(0x1234abcd:l,a5:w:4)",	AbdXn },
    { "a3@(0x1234abcd:l,a5:w:8)",	AbdXn },
    { "a3@(0x1234abcd:l,a5:l:1)",	AbdXn },
    { "a3@(0x1234abcd:l,a5:l:2)",	AbdXn },
    { "a3@(0x1234abcd:l,a5:l:4)",	AbdXn },
#endif /* ALL_OPERANDS */
    { "a3@(0x1234abcd:l,a5:l:8)",	AbdXn },
#ifdef ALL_OPERANDS
    { "@(0)",				AbdXn },
    { "@(0,d2:w:1)",			AbdXn },
    { "@(0,d2:w:2)",			AbdXn },
    { "@(0,d2:w:4)",			AbdXn },
    { "@(0,d2:w:8)",			AbdXn },
    { "@(0,d2:l:1)",			AbdXn },
    { "@(0,d2:l:2)",			AbdXn },
    { "@(0,d2:l:4)",			AbdXn },
    { "@(0,d2:l:8)",			AbdXn },
    { "@(0,a5:w:1)",			AbdXn },
    { "@(0,a5:w:2)",			AbdXn },
    { "@(0,a5:w:4)",			AbdXn },
    { "@(0,a5:w:8)",			AbdXn },
    { "@(0,a5:l:1)",			AbdXn },
    { "@(0,a5:l:2)",			AbdXn },
    { "@(0,a5:l:4)",			AbdXn },
    { "@(0,a5:l:8)",			AbdXn },
    { "@(0x1234:w,d2:w:1)",			AbdXn },
    { "@(0x1234:w,d2:w:2)",			AbdXn },
    { "@(0x1234:w,d2:w:4)",			AbdXn },
    { "@(0x1234:w,d2:w:8)",			AbdXn },
    { "@(0x1234:w,d2:l:1)",			AbdXn },
    { "@(0x1234:w,d2:l:2)",			AbdXn },
    { "@(0x1234:w,d2:l:4)",			AbdXn },
    { "@(0x1234:w,d2:l:8)",			AbdXn },
    { "@(0x1234:w,a5:w:1)",			AbdXn },
    { "@(0x1234:w,a5:w:2)",			AbdXn },
    { "@(0x1234:w,a5:w:4)",			AbdXn },
    { "@(0x1234:w,a5:w:8)",			AbdXn },
    { "@(0x1234:w,a5:l:1)",			AbdXn },
    { "@(0x1234:w,a5:l:2)",			AbdXn },
    { "@(0x1234:w,a5:l:4)",			AbdXn },
    { "@(0x1234:w,a5:l:8)",			AbdXn },
    { "@(0x1234abcd:l,d2:w:1)",			AbdXn },
    { "@(0x1234abcd:l,d2:w:2)",			AbdXn },
    { "@(0x1234abcd:l,d2:w:4)",			AbdXn },
    { "@(0x1234abcd:l,d2:w:8)",			AbdXn },
    { "@(0x1234abcd:l,d2:l:1)",			AbdXn },
    { "@(0x1234abcd:l,d2:l:2)",			AbdXn },
    { "@(0x1234abcd:l,d2:l:4)",			AbdXn },
    { "@(0x1234abcd:l,d2:l:8)",			AbdXn },
    { "@(0x1234abcd:l,a5:w:1)",			AbdXn },
    { "@(0x1234abcd:l,a5:w:2)",			AbdXn },
    { "@(0x1234abcd:l,a5:w:4)",			AbdXn },
    { "@(0x1234abcd:l,a5:w:8)",			AbdXn },
    { "@(0x1234abcd:l,a5:l:1)",			AbdXn },
    { "@(0x1234abcd:l,a5:l:2)",			AbdXn },
    { "@(0x1234abcd:l,a5:l:4)",			AbdXn },
    { "@(0x1234abcd:l,a5:l:8)",			AbdXn },
#endif /* ALL_OPERANDS */
/* An@(bd,Xn)@(od) "Memory Indirect with Preindexed" ([bd,An,Xn],od)
   uses Full Format Extension Word(s) */
#ifdef ALL_OPERANDS
    { "a3@(0)@(0)",	MIPRE },
    { "a3@(0,d2:w:1)@(0)",	MIPRE },
    { "a3@(0,d2:w:2)@(0)",	MIPRE },
    { "a3@(0,d2:w:4)@(0)",	MIPRE },
    { "a3@(0,d2:w:8)@(0)",	MIPRE },
    { "a3@(0,d2:l:1)@(0)",	MIPRE },
    { "a3@(0,d2:l:2)@(0)",	MIPRE },
    { "a3@(0,d2:l:4)@(0)",	MIPRE },
    { "a3@(0,d2:l:8)@(0)",	MIPRE },
    { "a3@(0,a5:w:1)@(0)",	MIPRE },
    { "a3@(0,a5:w:2)@(0)",	MIPRE },
    { "a3@(0,a5:w:4)@(0)",	MIPRE },
    { "a3@(0,a5:w:8)@(0)",	MIPRE },
    { "a3@(0,a5:l:1)@(0)",	MIPRE },
    { "a3@(0,a5:l:2)@(0)",	MIPRE },
    { "a3@(0,a5:l:4)@(0)",	MIPRE },
    { "a3@(0,a5:l:8)@(0)",	MIPRE },
    { "a3@(0x1234:w,d2:w:1)@(0)",	MIPRE },
    { "a3@(0x1234:w,d2:w:2)@(0)",	MIPRE },
    { "a3@(0x1234:w,d2:w:4)@(0)",	MIPRE },
    { "a3@(0x1234:w,d2:w:8)@(0)",	MIPRE },
    { "a3@(0x1234:w,d2:l:1)@(0)",	MIPRE },
    { "a3@(0x1234:w,d2:l:2)@(0)",	MIPRE },
    { "a3@(0x1234:w,d2:l:4)@(0)",	MIPRE },
    { "a3@(0x1234:w,d2:l:8)@(0)",	MIPRE },
    { "a3@(0x1234:w,a5:w:1)@(0)",	MIPRE },
    { "a3@(0x1234:w,a5:w:2)@(0)",	MIPRE },
    { "a3@(0x1234:w,a5:w:4)@(0)",	MIPRE },
    { "a3@(0x1234:w,a5:w:8)@(0)",	MIPRE },
    { "a3@(0x1234:w,a5:l:1)@(0)",	MIPRE },
    { "a3@(0x1234:w,a5:l:2)@(0)",	MIPRE },
    { "a3@(0x1234:w,a5:l:4)@(0)",	MIPRE },
    { "a3@(0x1234:w,a5:l:8)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:1)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:2)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:4)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:8)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:1)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:2)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:4)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:8)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:1)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:2)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:4)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:8)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:l:1)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:l:2)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:l:4)@(0)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:l:8)@(0)",	MIPRE },
    { "@(0)@(0)",	MIPRE },
    { "@(0,d2:w:1)@(0)",	MIPRE },
    { "@(0,d2:w:2)@(0)",	MIPRE },
    { "@(0,d2:w:4)@(0)",	MIPRE },
    { "@(0,d2:w:8)@(0)",	MIPRE },
    { "@(0,d2:l:1)@(0)",	MIPRE },
    { "@(0,d2:l:2)@(0)",	MIPRE },
    { "@(0,d2:l:4)@(0)",	MIPRE },
    { "@(0,d2:l:8)@(0)",	MIPRE },
    { "@(0,a5:w:1)@(0)",	MIPRE },
    { "@(0,a5:w:2)@(0)",	MIPRE },
    { "@(0,a5:w:4)@(0)",	MIPRE },
    { "@(0,a5:w:8)@(0)",	MIPRE },
    { "@(0,a5:l:1)@(0)",	MIPRE },
    { "@(0,a5:l:2)@(0)",	MIPRE },
    { "@(0,a5:l:4)@(0)",	MIPRE },
    { "@(0,a5:l:8)@(0)",	MIPRE },
    { "@(0x1234:w,d2:w:1)@(0)",	MIPRE },
    { "@(0x1234:w,d2:w:2)@(0)",	MIPRE },
    { "@(0x1234:w,d2:w:4)@(0)",	MIPRE },
    { "@(0x1234:w,d2:w:8)@(0)",	MIPRE },
    { "@(0x1234:w,d2:l:1)@(0)",	MIPRE },
    { "@(0x1234:w,d2:l:2)@(0)",	MIPRE },
    { "@(0x1234:w,d2:l:4)@(0)",	MIPRE },
    { "@(0x1234:w,d2:l:8)@(0)",	MIPRE },
    { "@(0x1234:w,a5:w:1)@(0)",	MIPRE },
    { "@(0x1234:w,a5:w:2)@(0)",	MIPRE },
    { "@(0x1234:w,a5:w:4)@(0)",	MIPRE },
    { "@(0x1234:w,a5:w:8)@(0)",	MIPRE },
    { "@(0x1234:w,a5:l:1)@(0)",	MIPRE },
    { "@(0x1234:w,a5:l:2)@(0)",	MIPRE },
    { "@(0x1234:w,a5:l:4)@(0)",	MIPRE },
    { "@(0x1234:w,a5:l:8)@(0)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:1)@(0)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:2)@(0)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:4)@(0)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:8)@(0)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:1)@(0)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:2)@(0)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:4)@(0)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:8)@(0)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:1)@(0)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:2)@(0)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:4)@(0)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:8)@(0)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:1)@(0)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:2)@(0)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:4)@(0)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:8)@(0)",	MIPRE },
    { "a3@(0)@(0xfeed:w)",	MIPRE },
    { "a3@(0,d2:w:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0,d2:w:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0,d2:w:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0,d2:w:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0,d2:l:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0,d2:l:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0,d2:l:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0,d2:l:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0,a5:w:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0,a5:w:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0,a5:w:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0,a5:w:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0,a5:l:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0,a5:l:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0,a5:l:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0,a5:l:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,d2:w:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,d2:w:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,d2:w:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,d2:w:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,d2:l:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,d2:l:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,d2:l:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,d2:l:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,a5:w:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,a5:w:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,a5:w:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,a5:w:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,a5:l:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,a5:l:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,a5:l:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234:w,a5:l:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:l:1)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:l:2)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:l:4)@(0xfeed:w)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:l:8)@(0xfeed:w)",	MIPRE },
    { "@(0)@(0xfeed:w)",	MIPRE },
    { "@(0,d2:w:1)@(0xfeed:w)",	MIPRE },
    { "@(0,d2:w:2)@(0xfeed:w)",	MIPRE },
    { "@(0,d2:w:4)@(0xfeed:w)",	MIPRE },
    { "@(0,d2:w:8)@(0xfeed:w)",	MIPRE },
    { "@(0,d2:l:1)@(0xfeed:w)",	MIPRE },
    { "@(0,d2:l:2)@(0xfeed:w)",	MIPRE },
    { "@(0,d2:l:4)@(0xfeed:w)",	MIPRE },
    { "@(0,d2:l:8)@(0xfeed:w)",	MIPRE },
    { "@(0,a5:w:1)@(0xfeed:w)",	MIPRE },
    { "@(0,a5:w:2)@(0xfeed:w)",	MIPRE },
    { "@(0,a5:w:4)@(0xfeed:w)",	MIPRE },
    { "@(0,a5:w:8)@(0xfeed:w)",	MIPRE },
    { "@(0,a5:l:1)@(0xfeed:w)",	MIPRE },
    { "@(0,a5:l:2)@(0xfeed:w)",	MIPRE },
    { "@(0,a5:l:4)@(0xfeed:w)",	MIPRE },
    { "@(0,a5:l:8)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,d2:w:1)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,d2:w:2)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,d2:w:4)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,d2:w:8)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,d2:l:1)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,d2:l:2)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,d2:l:4)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,d2:l:8)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,a5:w:1)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,a5:w:2)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,a5:w:4)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,a5:w:8)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,a5:l:1)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,a5:l:2)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,a5:l:4)@(0xfeed:w)",	MIPRE },
    { "@(0x1234:w,a5:l:8)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:1)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:2)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:4)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:8)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:1)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:2)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:4)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:8)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:1)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:2)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:4)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:8)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:1)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:2)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:4)@(0xfeed:w)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:8)@(0xfeed:w)",	MIPRE },
    { "a3@(0)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,d2:w:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,d2:w:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,d2:w:4)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,d2:w:8)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,d2:l:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,d2:l:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,d2:l:4)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,d2:l:8)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,a5:w:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,a5:w:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,a5:w:4)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,a5:w:8)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,a5:l:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,a5:l:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,a5:l:4)@(0xfeedface:l)",	MIPRE },
    { "a3@(0,a5:l:8)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,d2:w:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,d2:w:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,d2:w:4)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,d2:w:8)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,d2:l:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,d2:l:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,d2:l:4)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,d2:l:8)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,a5:w:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,a5:w:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,a5:w:4)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,a5:w:8)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,a5:l:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,a5:l:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,a5:l:4)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234:w,a5:l:8)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:4)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:w:8)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:4)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,d2:l:8)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:4)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:w:8)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:l:1)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:l:2)@(0xfeedface:l)",	MIPRE },
    { "a3@(0x1234abcd:l,a5:l:4)@(0xfeedface:l)",	MIPRE },
#endif /* ALL_OPERANDS */
    { "a3@(0x1234abcd:l,a5:l:8)@(0xfeedface:l)",	MIPRE },
#ifdef ALL_OPERANDS
    { "@(0)@(0xfeedface:l)",	MIPRE },
    { "@(0,d2:w:1)@(0xfeedface:l)",	MIPRE },
    { "@(0,d2:w:2)@(0xfeedface:l)",	MIPRE },
    { "@(0,d2:w:4)@(0xfeedface:l)",	MIPRE },
    { "@(0,d2:w:8)@(0xfeedface:l)",	MIPRE },
    { "@(0,d2:l:1)@(0xfeedface:l)",	MIPRE },
    { "@(0,d2:l:2)@(0xfeedface:l)",	MIPRE },
    { "@(0,d2:l:4)@(0xfeedface:l)",	MIPRE },
    { "@(0,d2:l:8)@(0xfeedface:l)",	MIPRE },
    { "@(0,a5:w:1)@(0xfeedface:l)",	MIPRE },
    { "@(0,a5:w:2)@(0xfeedface:l)",	MIPRE },
    { "@(0,a5:w:4)@(0xfeedface:l)",	MIPRE },
    { "@(0,a5:w:8)@(0xfeedface:l)",	MIPRE },
    { "@(0,a5:l:1)@(0xfeedface:l)",	MIPRE },
    { "@(0,a5:l:2)@(0xfeedface:l)",	MIPRE },
    { "@(0,a5:l:4)@(0xfeedface:l)",	MIPRE },
    { "@(0,a5:l:8)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,d2:w:1)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,d2:w:2)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,d2:w:4)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,d2:w:8)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,d2:l:1)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,d2:l:2)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,d2:l:4)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,d2:l:8)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,a5:w:1)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,a5:w:2)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,a5:w:4)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,a5:w:8)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,a5:l:1)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,a5:l:2)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,a5:l:4)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234:w,a5:l:8)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:1)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:2)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:4)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,d2:w:8)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:1)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:2)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:4)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,d2:l:8)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:1)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:2)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:4)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,a5:w:8)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:1)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:2)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:4)@(0xfeedface:l)",	MIPRE },
    { "@(0x1234abcd:l,a5:l:8)@(0xfeedface:l)",	MIPRE },
#endif /* ALL_OPERANDS */
/* An@(bd)@(od,Xn) "Memory Indirect with Postindexed" ([bd,An],Xn,od)
   uses Full Format Extension Word(s) */
#ifdef ALL_OPERANDS
    { "a3@(0)@(0)",	MIPOST },
    { "a3@(0)@(0,d2:w:1)",	MIPOST },
    { "a3@(0)@(0,d2:w:2)",	MIPOST },
    { "a3@(0)@(0,d2:w:4)",	MIPOST },
    { "a3@(0)@(0,d2:w:8)",	MIPOST },
    { "a3@(0)@(0,d2:l:1)",	MIPOST },
    { "a3@(0)@(0,d2:l:2)",	MIPOST },
    { "a3@(0)@(0,d2:l:4)",	MIPOST },
    { "a3@(0)@(0,d2:l:8)",	MIPOST },
    { "a3@(0)@(0,a5:w:1)",	MIPOST },
    { "a3@(0)@(0,a5:w:2)",	MIPOST },
    { "a3@(0)@(0,a5:w:4)",	MIPOST },
    { "a3@(0)@(0,a5:w:8)",	MIPOST },
    { "a3@(0)@(0,a5:l:1)",	MIPOST },
    { "a3@(0)@(0,a5:l:2)",	MIPOST },
    { "a3@(0)@(0,a5:l:4)",	MIPOST },
    { "a3@(0)@(0,a5:l:8)",	MIPOST },
    { "a3@(0x1234:w)@(0,d2:w:1)",	MIPOST },
    { "a3@(0x1234:w)@(0,d2:w:2)",	MIPOST },
    { "a3@(0x1234:w)@(0,d2:w:4)",	MIPOST },
    { "a3@(0x1234:w)@(0,d2:w:8)",	MIPOST },
    { "a3@(0x1234:w)@(0,d2:l:1)",	MIPOST },
    { "a3@(0x1234:w)@(0,d2:l:2)",	MIPOST },
    { "a3@(0x1234:w)@(0,d2:l:4)",	MIPOST },
    { "a3@(0x1234:w)@(0,d2:l:8)",	MIPOST },
    { "a3@(0x1234:w)@(0,a5:w:1)",	MIPOST },
    { "a3@(0x1234:w)@(0,a5:w:2)",	MIPOST },
    { "a3@(0x1234:w)@(0,a5:w:4)",	MIPOST },
    { "a3@(0x1234:w)@(0,a5:w:8)",	MIPOST },
    { "a3@(0x1234:w)@(0,a5:l:1)",	MIPOST },
    { "a3@(0x1234:w)@(0,a5:l:2)",	MIPOST },
    { "a3@(0x1234:w)@(0,a5:l:4)",	MIPOST },
    { "a3@(0x1234:w)@(0,a5:l:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,d2:w:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,d2:w:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,d2:w:4)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,d2:w:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,d2:l:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,d2:l:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,d2:l:4)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,d2:l:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,a5:w:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,a5:w:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,a5:w:4)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,a5:w:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,a5:l:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,a5:l:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,a5:l:4)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0,a5:l:8)",	MIPOST },
    { "@(0)@(0)",	MIPOST },
    { "@(0)@(0,d2:w:1)",	MIPOST },
    { "@(0)@(0,d2:w:2)",	MIPOST },
    { "@(0)@(0,d2:w:4)",	MIPOST },
    { "@(0)@(0,d2:w:8)",	MIPOST },
    { "@(0)@(0,d2:l:1)",	MIPOST },
    { "@(0)@(0,d2:l:2)",	MIPOST },
    { "@(0)@(0,d2:l:4)",	MIPOST },
    { "@(0)@(0,d2:l:8)",	MIPOST },
    { "@(0)@(0,a5:w:1)",	MIPOST },
    { "@(0)@(0,a5:w:2)",	MIPOST },
    { "@(0)@(0,a5:w:4)",	MIPOST },
    { "@(0)@(0,a5:w:8)",	MIPOST },
    { "@(0)@(0,a5:l:1)",	MIPOST },
    { "@(0)@(0,a5:l:2)",	MIPOST },
    { "@(0)@(0,a5:l:4)",	MIPOST },
    { "@(0)@(0,a5:l:8)",	MIPOST },
    { "@(0x1234:w)@(0,d2:w:1)",	MIPOST },
    { "@(0x1234:w)@(0,d2:w:2)",	MIPOST },
    { "@(0x1234:w)@(0,d2:w:4)",	MIPOST },
    { "@(0x1234:w)@(0,d2:w:8)",	MIPOST },
    { "@(0x1234:w)@(0,d2:l:1)",	MIPOST },
    { "@(0x1234:w)@(0,d2:l:2)",	MIPOST },
    { "@(0x1234:w)@(0,d2:l:4)",	MIPOST },
    { "@(0x1234:w)@(0,d2:l:8)",	MIPOST },
    { "@(0x1234:w)@(0,a5:w:1)",	MIPOST },
    { "@(0x1234:w)@(0,a5:w:2)",	MIPOST },
    { "@(0x1234:w)@(0,a5:w:4)",	MIPOST },
    { "@(0x1234:w)@(0,a5:w:8)",	MIPOST },
    { "@(0x1234:w)@(0,a5:l:1)",	MIPOST },
    { "@(0x1234:w)@(0,a5:l:2)",	MIPOST },
    { "@(0x1234:w)@(0,a5:l:4)",	MIPOST },
    { "@(0x1234:w)@(0,a5:l:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0,d2:w:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0,d2:w:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0,d2:w:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0,d2:w:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0,d2:l:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0,d2:l:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0,d2:l:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0,d2:l:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0,a5:w:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0,a5:w:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0,a5:w:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0,a5:w:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0,a5:l:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0,a5:l:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0,a5:l:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0,a5:l:8)",	MIPOST },
    { "a3@(0)@(0xfeed:w)",	MIPOST },
    { "a3@(0)@(0xfeed:w,d2:w:1)",	MIPOST },
    { "a3@(0)@(0xfeed:w,d2:w:2)",	MIPOST },
    { "a3@(0)@(0xfeed:w,d2:w:4)",	MIPOST },
    { "a3@(0)@(0xfeed:w,d2:w:8)",	MIPOST },
    { "a3@(0)@(0xfeed:w,d2:l:1)",	MIPOST },
    { "a3@(0)@(0xfeed:w,d2:l:2)",	MIPOST },
    { "a3@(0)@(0xfeed:w,d2:l:4)",	MIPOST },
    { "a3@(0)@(0xfeed:w,d2:l:8)",	MIPOST },
    { "a3@(0)@(0xfeed:w,a5:w:1)",	MIPOST },
    { "a3@(0)@(0xfeed:w,a5:w:2)",	MIPOST },
    { "a3@(0)@(0xfeed:w,a5:w:4)",	MIPOST },
    { "a3@(0)@(0xfeed:w,a5:w:8)",	MIPOST },
    { "a3@(0)@(0xfeed:w,a5:l:1)",	MIPOST },
    { "a3@(0)@(0xfeed:w,a5:l:2)",	MIPOST },
    { "a3@(0)@(0xfeed:w,a5:l:4)",	MIPOST },
    { "a3@(0)@(0xfeed:w,a5:l:8)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,d2:w:1)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,d2:w:2)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,d2:w:4)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,d2:w:8)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,d2:l:1)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,d2:l:2)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,d2:l:4)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,d2:l:8)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,a5:w:1)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,a5:w:2)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,a5:w:4)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,a5:w:8)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,a5:l:1)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,a5:l:2)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,a5:l:4)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeed:w,a5:l:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,d2:w:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,d2:w:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,d2:w:4)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,d2:w:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,d2:l:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,d2:l:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,d2:l:4)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,d2:l:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,a5:w:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,a5:w:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,a5:w:4)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,a5:w:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,a5:l:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,a5:l:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,a5:l:4)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeed:w,a5:l:8)",	MIPOST },
    { "@(0)@(0xfeed:w)",	MIPOST },
    { "@(0)@(0xfeed:w,d2:w:1)",	MIPOST },
    { "@(0)@(0xfeed:w,d2:w:2)",	MIPOST },
    { "@(0)@(0xfeed:w,d2:w:4)",	MIPOST },
    { "@(0)@(0xfeed:w,d2:w:8)",	MIPOST },
    { "@(0)@(0xfeed:w,d2:l:1)",	MIPOST },
    { "@(0)@(0xfeed:w,d2:l:2)",	MIPOST },
    { "@(0)@(0xfeed:w,d2:l:4)",	MIPOST },
    { "@(0)@(0xfeed:w,d2:l:8)",	MIPOST },
    { "@(0)@(0xfeed:w,a5:w:1)",	MIPOST },
    { "@(0)@(0xfeed:w,a5:w:2)",	MIPOST },
    { "@(0)@(0xfeed:w,a5:w:4)",	MIPOST },
    { "@(0)@(0xfeed:w,a5:w:8)",	MIPOST },
    { "@(0)@(0xfeed:w,a5:l:1)",	MIPOST },
    { "@(0)@(0xfeed:w,a5:l:2)",	MIPOST },
    { "@(0)@(0xfeed:w,a5:l:4)",	MIPOST },
    { "@(0)@(0xfeed:w,a5:l:8)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,d2:w:1)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,d2:w:2)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,d2:w:4)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,d2:w:8)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,d2:l:1)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,d2:l:2)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,d2:l:4)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,d2:l:8)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,a5:w:1)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,a5:w:2)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,a5:w:4)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,a5:w:8)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,a5:l:1)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,a5:l:2)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,a5:l:4)",	MIPOST },
    { "@(0x1234:w)@(0xfeed:w,a5:l:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,d2:w:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,d2:w:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,d2:w:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,d2:w:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,d2:l:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,d2:l:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,d2:l:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,d2:l:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,a5:w:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,a5:w:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,a5:w:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,a5:w:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,a5:l:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,a5:l:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,a5:l:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeed:w,a5:l:8)",	MIPOST },
    { "a3@(0)@(0xfeedface:l)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,d2:w:1)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,d2:w:2)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,d2:w:4)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,d2:w:8)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,d2:l:1)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,d2:l:2)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,d2:l:4)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,d2:l:8)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,a5:w:1)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,a5:w:2)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,a5:w:4)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,a5:w:8)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,a5:l:1)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,a5:l:2)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,a5:l:4)",	MIPOST },
    { "a3@(0)@(0xfeedface:l,a5:l:8)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,d2:w:1)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,d2:w:2)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,d2:w:4)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,d2:w:8)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,d2:l:1)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,d2:l:2)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,d2:l:4)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,d2:l:8)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,a5:w:1)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,a5:w:2)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,a5:w:4)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,a5:w:8)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,a5:l:1)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,a5:l:2)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,a5:l:4)",	MIPOST },
    { "a3@(0x1234:w)@(0xfeedface:l,a5:l:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,d2:w:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,d2:w:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,d2:w:4)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,d2:w:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,d2:l:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,d2:l:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,d2:l:4)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,d2:l:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,a5:w:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,a5:w:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,a5:w:4)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,a5:w:8)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,a5:l:1)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,a5:l:2)",	MIPOST },
    { "a3@(0x1234abcd:l)@(0xfeedface:l,a5:l:4)",	MIPOST },
#endif /* ALL_OPERANDS */
    { "a3@(0x1234abcd:l)@(0xfeedface:l,a5:l:8)",	MIPOST },
#ifdef ALL_OPERANDS
    { "@(0)@(0xfeedface:l)",	MIPOST },
    { "@(0)@(0xfeedface:l,d2:w:1)",	MIPOST },
    { "@(0)@(0xfeedface:l,d2:w:2)",	MIPOST },
    { "@(0)@(0xfeedface:l,d2:w:4)",	MIPOST },
    { "@(0)@(0xfeedface:l,d2:w:8)",	MIPOST },
    { "@(0)@(0xfeedface:l,d2:l:1)",	MIPOST },
    { "@(0)@(0xfeedface:l,d2:l:2)",	MIPOST },
    { "@(0)@(0xfeedface:l,d2:l:4)",	MIPOST },
    { "@(0)@(0xfeedface:l,d2:l:8)",	MIPOST },
    { "@(0)@(0xfeedface:l,a5:w:1)",	MIPOST },
    { "@(0)@(0xfeedface:l,a5:w:2)",	MIPOST },
    { "@(0)@(0xfeedface:l,a5:w:4)",	MIPOST },
    { "@(0)@(0xfeedface:l,a5:w:8)",	MIPOST },
    { "@(0)@(0xfeedface:l,a5:l:1)",	MIPOST },
    { "@(0)@(0xfeedface:l,a5:l:2)",	MIPOST },
    { "@(0)@(0xfeedface:l,a5:l:4)",	MIPOST },
    { "@(0)@(0xfeedface:l,a5:l:8)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,d2:w:1)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,d2:w:2)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,d2:w:4)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,d2:w:8)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,d2:l:1)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,d2:l:2)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,d2:l:4)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,d2:l:8)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,a5:w:1)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,a5:w:2)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,a5:w:4)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,a5:w:8)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,a5:l:1)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,a5:l:2)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,a5:l:4)",	MIPOST },
    { "@(0x1234:w)@(0xfeedface:l,a5:l:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,d2:w:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,d2:w:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,d2:w:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,d2:w:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,d2:l:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,d2:l:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,d2:l:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,d2:l:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,a5:w:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,a5:w:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,a5:w:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,a5:w:8)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,a5:l:1)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,a5:l:2)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,a5:l:4)",	MIPOST },
    { "@(0x1234abcd:l)@(0xfeedface:l,a5:l:8)",	MIPOST },
#endif /* ALL_OPERANDS */

/* xxx:w "Absolute Short" (xxx).W */
    { "0x1bad:w",	ABSW },
/* xxx:l "Absolute Long" (xxx).L */
    { "0xbad1add2:l",	ABSL },
/* #data "Immediate" #<data> */
    { "#0x3",		IMMED },

/* pc@(d16) "Program Counter Indirect with Displacement" (d16,PC)
    { "pc@(0x1234)",	PCd16 },
/* pc@(d8,Xn) "Program Counter Indirect with Index (8-Bit Displacement)"
   uses Brief Format Extension Word (d8,PC,Xn) */
#ifdef ALL_OPERANDS
    { "pc@(0x12:b,d2:w:1)",	PCd8Xn },
    { "pc@(0x12:b,d2:w:2)",	PCd8Xn },
    { "pc@(0x12:b,d2:w:4)",	PCd8Xn },
    { "pc@(0x12:b,d2:w:8)",	PCd8Xn },
    { "pc@(0x12:b,d2:l:1)",	PCd8Xn },
    { "pc@(0x12:b,d2:l:2)",	PCd8Xn },
    { "pc@(0x12:b,d2:l:4)",	PCd8Xn },
    { "pc@(0x12:b,d2:l:8)",	PCd8Xn },
    { "pc@(0x12:b,a5:w:1)",	PCd8Xn },
    { "pc@(0x12:b,a5:w:2)",	PCd8Xn },
    { "pc@(0x12:b,a5:w:4)",	PCd8Xn },
    { "pc@(0x12:b,a5:w:8)",	PCd8Xn },
    { "pc@(0x12:b,a5:l:1)",	PCd8Xn },
    { "pc@(0x12:b,a5:l:2)",	PCd8Xn },
    { "pc@(0x12:b,a5:l:4)",	PCd8Xn },
#endif /* ALL_OPERANDS */
    { "pc@(0x12:b,a5:l:8)",	PCd8Xn },

/* pc@(bd,Xn) "Program Counter Indirect with Index (Base Displacement)"
   uses Full Format Extension Word(s) (bd,PC,Xn) */
#ifdef ALL_OPERANDS
/* the form of pc@(bd,Xn) with bd (base displacement) encoded as a null
   displacement will not be generated by the assembler because it will use
   the form pc(d8,Xn).
    { "pc@(0)",			PCbdXn },
    { "pc@(0,d2:w:1)",		PCbdXn },
    { "pc@(0,d2:w:2)",		PCbdXn },
    { "pc@(0,d2:w:4)",		PCbdXn },
    { "pc@(0,d2:w:8)",		PCbdXn },
    { "pc@(0,d2:l:1)",		PCbdXn },
    { "pc@(0,d2:l:2)",		PCbdXn },
    { "pc@(0,d2:l:4)",		PCbdXn },
    { "pc@(0,d2:l:8)",		PCbdXn },
    { "pc@(0,a5:w:1)",		PCbdXn },
    { "pc@(0,a5:w:2)",		PCbdXn },
    { "pc@(0,a5:w:4)",		PCbdXn },
    { "pc@(0,a5:w:8)",		PCbdXn },
    { "pc@(0,a5:l:1)",		PCbdXn },
    { "pc@(0,a5:l:2)",		PCbdXn },
    { "pc@(0,a5:l:4)",		PCbdXn },
    { "pc@(0,a5:l:8)",		PCbdXn },
*/
    { "pc@(0x1234:w,d2:w:1)",	PCbdXn },
    { "pc@(0x1234:w,d2:w:2)",	PCbdXn },
    { "pc@(0x1234:w,d2:w:4)",	PCbdXn },
    { "pc@(0x1234:w,d2:w:8)",	PCbdXn },
    { "pc@(0x1234:w,d2:l:1)",	PCbdXn },
    { "pc@(0x1234:w,d2:l:2)",	PCbdXn },
    { "pc@(0x1234:w,d2:l:4)",	PCbdXn },
    { "pc@(0x1234:w,d2:l:8)",	PCbdXn },
    { "pc@(0x1234:w,a5:w:1)",	PCbdXn },
    { "pc@(0x1234:w,a5:w:2)",	PCbdXn },
    { "pc@(0x1234:w,a5:w:4)",	PCbdXn },
    { "pc@(0x1234:w,a5:w:8)",	PCbdXn },
    { "pc@(0x1234:w,a5:l:1)",	PCbdXn },
    { "pc@(0x1234:w,a5:l:2)",	PCbdXn },
    { "pc@(0x1234:w,a5:l:4)",	PCbdXn },
    { "pc@(0x1234:w,a5:l:8)",	PCbdXn },
    { "pc@(0x1234abcd:l,d2:w:1)",	PCbdXn },
    { "pc@(0x1234abcd:l,d2:w:2)",	PCbdXn },
    { "pc@(0x1234abcd:l,d2:w:4)",	PCbdXn },
    { "pc@(0x1234abcd:l,d2:w:8)",	PCbdXn },
    { "pc@(0x1234abcd:l,d2:l:1)",	PCbdXn },
    { "pc@(0x1234abcd:l,d2:l:2)",	PCbdXn },
    { "pc@(0x1234abcd:l,d2:l:4)",	PCbdXn },
    { "pc@(0x1234abcd:l,d2:l:8)",	PCbdXn },
    { "pc@(0x1234abcd:l,a5:w:1)",	PCbdXn },
    { "pc@(0x1234abcd:l,a5:w:2)",	PCbdXn },
    { "pc@(0x1234abcd:l,a5:w:4)",	PCbdXn },
    { "pc@(0x1234abcd:l,a5:w:8)",	PCbdXn },
    { "pc@(0x1234abcd:l,a5:l:1)",	PCbdXn },
    { "pc@(0x1234abcd:l,a5:l:2)",	PCbdXn },
    { "pc@(0x1234abcd:l,a5:l:4)",	PCbdXn },
#endif /* ALL_OPERANDS */
    { "pc@(0x1234abcd:l,a5:l:8)",	PCbdXn },
#ifdef ALL_OPERANDS
    { "zpc@(0)",				PCbdXn },
    { "zpc@(0,d2:w:1)",			PCbdXn },
    { "zpc@(0,d2:w:2)",			PCbdXn },
    { "zpc@(0,d2:w:4)",			PCbdXn },
    { "zpc@(0,d2:w:8)",			PCbdXn },
    { "zpc@(0,d2:l:1)",			PCbdXn },
    { "zpc@(0,d2:l:2)",			PCbdXn },
    { "zpc@(0,d2:l:4)",			PCbdXn },
    { "zpc@(0,d2:l:8)",			PCbdXn },
    { "zpc@(0,a5:w:1)",			PCbdXn },
    { "zpc@(0,a5:w:2)",			PCbdXn },
    { "zpc@(0,a5:w:4)",			PCbdXn },
    { "zpc@(0,a5:w:8)",			PCbdXn },
    { "zpc@(0,a5:l:1)",			PCbdXn },
    { "zpc@(0,a5:l:2)",			PCbdXn },
    { "zpc@(0,a5:l:4)",			PCbdXn },
    { "zpc@(0,a5:l:8)",			PCbdXn },
    { "zpc@(0x1234:w,d2:w:1)",			PCbdXn },
    { "zpc@(0x1234:w,d2:w:2)",			PCbdXn },
    { "zpc@(0x1234:w,d2:w:4)",			PCbdXn },
    { "zpc@(0x1234:w,d2:w:8)",			PCbdXn },
    { "zpc@(0x1234:w,d2:l:1)",			PCbdXn },
    { "zpc@(0x1234:w,d2:l:2)",			PCbdXn },
    { "zpc@(0x1234:w,d2:l:4)",			PCbdXn },
    { "zpc@(0x1234:w,d2:l:8)",			PCbdXn },
    { "zpc@(0x1234:w,a5:w:1)",			PCbdXn },
    { "zpc@(0x1234:w,a5:w:2)",			PCbdXn },
    { "zpc@(0x1234:w,a5:w:4)",			PCbdXn },
    { "zpc@(0x1234:w,a5:w:8)",			PCbdXn },
    { "zpc@(0x1234:w,a5:l:1)",			PCbdXn },
    { "zpc@(0x1234:w,a5:l:2)",			PCbdXn },
    { "zpc@(0x1234:w,a5:l:4)",			PCbdXn },
    { "zpc@(0x1234:w,a5:l:8)",			PCbdXn },
    { "zpc@(0x1234abcd:l,d2:w:1)",			PCbdXn },
    { "zpc@(0x1234abcd:l,d2:w:2)",			PCbdXn },
    { "zpc@(0x1234abcd:l,d2:w:4)",			PCbdXn },
    { "zpc@(0x1234abcd:l,d2:w:8)",			PCbdXn },
    { "zpc@(0x1234abcd:l,d2:l:1)",			PCbdXn },
    { "zpc@(0x1234abcd:l,d2:l:2)",			PCbdXn },
    { "zpc@(0x1234abcd:l,d2:l:4)",			PCbdXn },
    { "zpc@(0x1234abcd:l,d2:l:8)",			PCbdXn },
    { "zpc@(0x1234abcd:l,a5:w:1)",			PCbdXn },
    { "zpc@(0x1234abcd:l,a5:w:2)",			PCbdXn },
    { "zpc@(0x1234abcd:l,a5:w:4)",			PCbdXn },
    { "zpc@(0x1234abcd:l,a5:w:8)",			PCbdXn },
    { "zpc@(0x1234abcd:l,a5:l:1)",			PCbdXn },
    { "zpc@(0x1234abcd:l,a5:l:2)",			PCbdXn },
    { "zpc@(0x1234abcd:l,a5:l:4)",			PCbdXn },
#endif /* ALL_OPERANDS */
    { "zpc@(0x1234abcd:l,a5:l:8)",			PCbdXn },
/* pc@(bd,Xn)@(od) "Program Counter Memory Indirect with Preindexed"
   uses Full Format Extension Word(s) ([bd,PC,Xn],od) */
#ifdef ALL_OPERANDS
    { "pc@(0)@(0)",	PCMIPRE },
    { "pc@(0,d2:w:1)@(0)",	PCMIPRE },
    { "pc@(0,d2:w:2)@(0)",	PCMIPRE },
    { "pc@(0,d2:w:4)@(0)",	PCMIPRE },
    { "pc@(0,d2:w:8)@(0)",	PCMIPRE },
    { "pc@(0,d2:l:1)@(0)",	PCMIPRE },
    { "pc@(0,d2:l:2)@(0)",	PCMIPRE },
    { "pc@(0,d2:l:4)@(0)",	PCMIPRE },
    { "pc@(0,d2:l:8)@(0)",	PCMIPRE },
    { "pc@(0,a5:w:1)@(0)",	PCMIPRE },
    { "pc@(0,a5:w:2)@(0)",	PCMIPRE },
    { "pc@(0,a5:w:4)@(0)",	PCMIPRE },
    { "pc@(0,a5:w:8)@(0)",	PCMIPRE },
    { "pc@(0,a5:l:1)@(0)",	PCMIPRE },
    { "pc@(0,a5:l:2)@(0)",	PCMIPRE },
    { "pc@(0,a5:l:4)@(0)",	PCMIPRE },
    { "pc@(0,a5:l:8)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:1)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:2)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:4)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:8)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:1)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:2)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:4)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:8)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:1)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:2)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:4)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:8)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:1)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:2)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:4)@(0)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:8)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:1)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:2)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:4)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:8)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:1)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:2)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:4)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:8)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:1)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:2)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:4)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:8)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:l:1)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:l:2)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:l:4)@(0)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:l:8)@(0)",	PCMIPRE },
    { "zpc@(0)@(0)",	PCMIPRE },
    { "zpc@(0,d2:w:1)@(0)",	PCMIPRE },
    { "zpc@(0,d2:w:2)@(0)",	PCMIPRE },
    { "zpc@(0,d2:w:4)@(0)",	PCMIPRE },
    { "zpc@(0,d2:w:8)@(0)",	PCMIPRE },
    { "zpc@(0,d2:l:1)@(0)",	PCMIPRE },
    { "zpc@(0,d2:l:2)@(0)",	PCMIPRE },
    { "zpc@(0,d2:l:4)@(0)",	PCMIPRE },
    { "zpc@(0,d2:l:8)@(0)",	PCMIPRE },
    { "zpc@(0,a5:w:1)@(0)",	PCMIPRE },
    { "zpc@(0,a5:w:2)@(0)",	PCMIPRE },
    { "zpc@(0,a5:w:4)@(0)",	PCMIPRE },
    { "zpc@(0,a5:w:8)@(0)",	PCMIPRE },
    { "zpc@(0,a5:l:1)@(0)",	PCMIPRE },
    { "zpc@(0,a5:l:2)@(0)",	PCMIPRE },
    { "zpc@(0,a5:l:4)@(0)",	PCMIPRE },
    { "zpc@(0,a5:l:8)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:1)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:2)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:4)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:8)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:1)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:2)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:4)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:8)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:1)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:2)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:4)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:8)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:1)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:2)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:4)@(0)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:8)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:1)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:2)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:4)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:8)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:1)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:2)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:4)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:8)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:1)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:2)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:4)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:8)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:l:1)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:l:2)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:l:4)@(0)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:l:8)@(0)",	PCMIPRE },
    { "pc@(0)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,d2:w:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,d2:w:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,d2:w:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,d2:w:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,d2:l:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,d2:l:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,d2:l:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,d2:l:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,a5:w:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,a5:w:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,a5:w:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,a5:w:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,a5:l:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,a5:l:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,a5:l:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0,a5:l:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:l:1)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:l:2)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:l:4)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:l:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,d2:w:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,d2:w:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,d2:w:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,d2:w:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,d2:l:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,d2:l:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,d2:l:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,d2:l:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,a5:w:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,a5:w:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,a5:w:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,a5:w:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,a5:l:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,a5:l:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,a5:l:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0,a5:l:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:8)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:l:1)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:l:2)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:l:4)@(0xfeed:w)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:l:8)@(0xfeed:w)",	PCMIPRE },
    { "pc@(0)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,d2:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,d2:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,d2:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,d2:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,d2:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,d2:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,d2:l:4)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,d2:l:8)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,a5:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,a5:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,a5:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,a5:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,a5:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,a5:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,a5:l:4)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0,a5:l:8)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,d2:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:4)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,d2:l:8)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,a5:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:4)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234:w,a5:l:8)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:4)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,d2:l:8)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "pc@(0x1234abcd:l,a5:l:4)@(0xfeedface:l)",	PCMIPRE },
#endif /* ALL_OPERANDS */
    { "pc@(0x1234abcd:l,a5:l:8)@(0xfeedface:l)",	PCMIPRE },
#ifdef ALL_OPERANDS
    { "zpc@(0)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,d2:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,d2:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,d2:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,d2:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,d2:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,d2:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,d2:l:4)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,d2:l:8)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,a5:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,a5:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,a5:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,a5:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,a5:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,a5:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,a5:l:4)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0,a5:l:8)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:4)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,d2:l:8)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:4)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234:w,a5:l:8)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:4)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,d2:l:8)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:4)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:w:8)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:l:1)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:l:2)@(0xfeedface:l)",	PCMIPRE },
    { "zpc@(0x1234abcd:l,a5:l:4)@(0xfeedface:l)",	PCMIPRE },
#endif /* ALL_OPERANDS */
    { "zpc@(0x1234abcd:l,a5:l:8)@(0xfeedface:l)",	PCMIPRE },
/* pc@(bd)@(od,Xn) "Program Counter Memory Indirect with Postindexed"
   uses Full Format Extension Word(s) ([bd,PC],Xn,od) */
#ifdef ALL_OPERANDS
    { "pc@(0)@(0)",	PCMIPOST },
    { "pc@(0)@(0,d2:w:1)",	PCMIPOST },
    { "pc@(0)@(0,d2:w:2)",	PCMIPOST },
    { "pc@(0)@(0,d2:w:4)",	PCMIPOST },
    { "pc@(0)@(0,d2:w:8)",	PCMIPOST },
    { "pc@(0)@(0,d2:l:1)",	PCMIPOST },
    { "pc@(0)@(0,d2:l:2)",	PCMIPOST },
    { "pc@(0)@(0,d2:l:4)",	PCMIPOST },
    { "pc@(0)@(0,d2:l:8)",	PCMIPOST },
    { "pc@(0)@(0,a5:w:1)",	PCMIPOST },
    { "pc@(0)@(0,a5:w:2)",	PCMIPOST },
    { "pc@(0)@(0,a5:w:4)",	PCMIPOST },
    { "pc@(0)@(0,a5:w:8)",	PCMIPOST },
    { "pc@(0)@(0,a5:l:1)",	PCMIPOST },
    { "pc@(0)@(0,a5:l:2)",	PCMIPOST },
    { "pc@(0)@(0,a5:l:4)",	PCMIPOST },
    { "pc@(0)@(0,a5:l:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,d2:w:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,d2:w:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,d2:w:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,d2:w:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,d2:l:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,d2:l:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,d2:l:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,d2:l:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,a5:w:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,a5:w:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,a5:w:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,a5:w:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,a5:l:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,a5:l:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,a5:l:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0,a5:l:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,d2:w:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,d2:w:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,d2:w:4)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,d2:w:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,d2:l:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,d2:l:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,d2:l:4)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,d2:l:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,a5:w:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,a5:w:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,a5:w:4)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,a5:w:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,a5:l:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,a5:l:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,a5:l:4)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0,a5:l:8)",	PCMIPOST },
    { "zpc@(0)@(0)",	PCMIPOST },
    { "zpc@(0)@(0,d2:w:1)",	PCMIPOST },
    { "zpc@(0)@(0,d2:w:2)",	PCMIPOST },
    { "zpc@(0)@(0,d2:w:4)",	PCMIPOST },
    { "zpc@(0)@(0,d2:w:8)",	PCMIPOST },
    { "zpc@(0)@(0,d2:l:1)",	PCMIPOST },
    { "zpc@(0)@(0,d2:l:2)",	PCMIPOST },
    { "zpc@(0)@(0,d2:l:4)",	PCMIPOST },
    { "zpc@(0)@(0,d2:l:8)",	PCMIPOST },
    { "zpc@(0)@(0,a5:w:1)",	PCMIPOST },
    { "zpc@(0)@(0,a5:w:2)",	PCMIPOST },
    { "zpc@(0)@(0,a5:w:4)",	PCMIPOST },
    { "zpc@(0)@(0,a5:w:8)",	PCMIPOST },
    { "zpc@(0)@(0,a5:l:1)",	PCMIPOST },
    { "zpc@(0)@(0,a5:l:2)",	PCMIPOST },
    { "zpc@(0)@(0,a5:l:4)",	PCMIPOST },
    { "zpc@(0)@(0,a5:l:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,d2:w:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,d2:w:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,d2:w:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,d2:w:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,d2:l:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,d2:l:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,d2:l:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,d2:l:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,a5:w:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,a5:w:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,a5:w:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,a5:w:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,a5:l:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,a5:l:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,a5:l:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0,a5:l:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,d2:w:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,d2:w:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,d2:w:4)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,d2:w:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,d2:l:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,d2:l:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,d2:l:4)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,d2:l:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,a5:w:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,a5:w:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,a5:w:4)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,a5:w:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,a5:l:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,a5:l:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,a5:l:4)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0,a5:l:8)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,d2:w:1)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,d2:w:2)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,d2:w:4)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,d2:w:8)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,d2:l:1)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,d2:l:2)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,d2:l:4)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,d2:l:8)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,a5:w:1)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,a5:w:2)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,a5:w:4)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,a5:w:8)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,a5:l:1)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,a5:l:2)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,a5:l:4)",	PCMIPOST },
    { "pc@(0)@(0xfeed:w,a5:l:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,d2:w:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,d2:w:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,d2:w:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,d2:w:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,d2:l:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,d2:l:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,d2:l:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,d2:l:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,a5:w:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,a5:w:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,a5:w:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,a5:w:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,a5:l:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,a5:l:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,a5:l:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeed:w,a5:l:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,d2:w:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,d2:w:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,d2:w:4)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,d2:w:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,d2:l:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,d2:l:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,d2:l:4)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,d2:l:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,a5:w:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,a5:w:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,a5:w:4)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,a5:w:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,a5:l:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,a5:l:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,a5:l:4)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeed:w,a5:l:8)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,d2:w:1)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,d2:w:2)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,d2:w:4)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,d2:w:8)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,d2:l:1)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,d2:l:2)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,d2:l:4)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,d2:l:8)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,a5:w:1)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,a5:w:2)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,a5:w:4)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,a5:w:8)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,a5:l:1)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,a5:l:2)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,a5:l:4)",	PCMIPOST },
    { "zpc@(0)@(0xfeed:w,a5:l:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,d2:w:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,d2:w:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,d2:w:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,d2:w:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,d2:l:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,d2:l:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,d2:l:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,d2:l:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,a5:w:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,a5:w:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,a5:w:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,a5:w:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,a5:l:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,a5:l:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,a5:l:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeed:w,a5:l:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,d2:w:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,d2:w:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,d2:w:4)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,d2:w:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,d2:l:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,d2:l:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,d2:l:4)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,d2:l:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,a5:w:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,a5:w:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,a5:w:4)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,a5:w:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,a5:l:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,a5:l:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,a5:l:4)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeed:w,a5:l:8)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,d2:w:1)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,d2:w:2)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,d2:w:4)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,d2:w:8)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,d2:l:1)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,d2:l:2)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,d2:l:4)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,d2:l:8)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,a5:w:1)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,a5:w:2)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,a5:w:4)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,a5:w:8)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,a5:l:1)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,a5:l:2)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,a5:l:4)",	PCMIPOST },
    { "pc@(0)@(0xfeedface:l,a5:l:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,d2:w:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,d2:w:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,d2:w:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,d2:w:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,d2:l:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,d2:l:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,d2:l:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,d2:l:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,a5:w:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,a5:w:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,a5:w:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,a5:w:8)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,a5:l:1)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,a5:l:2)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,a5:l:4)",	PCMIPOST },
    { "pc@(0x1234:w)@(0xfeedface:l,a5:l:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,d2:w:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,d2:w:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,d2:w:4)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,d2:w:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,d2:l:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,d2:l:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,d2:l:4)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,d2:l:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,a5:w:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,a5:w:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,a5:w:4)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,a5:w:8)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,a5:l:1)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,a5:l:2)",	PCMIPOST },
    { "pc@(0x1234abcd:l)@(0xfeedface:l,a5:l:4)",	PCMIPOST },
#endif /* ALL_OPERANDS */
    { "pc@(0x1234abcd:l)@(0xfeedface:l,a5:l:8)",	PCMIPOST },
#ifdef ALL_OPERANDS
    { "zpc@(0)@(0xfeedface:l)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,d2:w:1)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,d2:w:2)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,d2:w:4)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,d2:w:8)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,d2:l:1)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,d2:l:2)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,d2:l:4)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,d2:l:8)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,a5:w:1)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,a5:w:2)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,a5:w:4)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,a5:w:8)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,a5:l:1)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,a5:l:2)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,a5:l:4)",	PCMIPOST },
    { "zpc@(0)@(0xfeedface:l,a5:l:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,d2:w:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,d2:w:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,d2:w:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,d2:w:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,d2:l:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,d2:l:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,d2:l:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,d2:l:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,a5:w:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,a5:w:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,a5:w:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,a5:w:8)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,a5:l:1)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,a5:l:2)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,a5:l:4)",	PCMIPOST },
    { "zpc@(0x1234:w)@(0xfeedface:l,a5:l:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,d2:w:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,d2:w:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,d2:w:4)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,d2:w:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,d2:l:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,d2:l:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,d2:l:4)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,d2:l:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,a5:w:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,a5:w:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,a5:w:4)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,a5:w:8)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,a5:l:1)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,a5:l:2)",	PCMIPOST },
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,a5:l:4)",	PCMIPOST },
#endif /* ALL_OPERANDS */
    { "zpc@(0x1234abcd:l)@(0xfeedface:l,a5:l:8)",	PCMIPOST },

/* These are used by the movec instruction */
    { "sfc",	MOVEC_REG },
    { "dfc",	MOVEC_REG },
    { "cacr",	MOVEC_REG },
    { "usp",	MOVEC_REG },
    { "vbr",	MOVEC_REG },
    { "caar",	MOVEC_REG },
    { "msp",	MOVEC_REG },
    { "isp",	MOVEC_REG },
    { "tc",	MOVEC_REG },
    { "itt0",	MOVEC_REG },
    { "itt1",	MOVEC_REG },
    { "dtt0",	MOVEC_REG },
    { "dtt1",	MOVEC_REG },
    { "mmusr",	MOVEC_REG },
    { "urp",	MOVEC_REG },
    { "srp",	MOVEC_REG },
/* These are used by special case operand types */
    { "special 1",	SPECIAL_1 },
    { "special 2",	SPECIAL_2 },
    { "special 3",	SPECIAL_3 },

    { 0, 0 }
};

/*
bs = An, PC, ZPC or nothing (not present)
bdsize = null (0), word, long displacement
Xn = An, Dn or nothing (not present) (followed by :scale = 1 (assumed), 2, 4, 8)

IS = 0 (index register not suppressed, present)
"bs@(bd:bdsize,Xn)",		"No Memory Indirection"
"bs@(bd:bdsize,Xn)@",		"Indirect Preindexed with Null Displacement"
"bs@(bd:bdsize,Xn)@(od:w)",	"Indirect Preindexed with Word Displacement"
"bs@(bd:bdsize,Xn)@(od:l)",	"Indirect Preindexed with Long Displacement"
"bs@(bd:bdsize)@(Xn)",		"Indirect Postindexed with Null Displacement"
"bs@(bd:bdsize)@(od:w,Xn)",	"Indirect Postindexed with Word Displacement"
"bs@(bd:bdsize)@(od:l,Xn)",	"Indirect Postindexed with Long Displacement"

IS = 1 (index register suppressed, not present)
"bs@(bd:bdsize)",		"No Memory Indirection"
"bs@(bd:bdsize)@",		"Memory Indirect with Null Displacement"
"bs@(bd:bdsize)@(od:w)",	"Memory Indirect with Word Displacement"
"bs@(bd:bdsize)@(od:l)",	"Memory Indirect with Long Displacement"
*/

#if 1

#include "m68k-opcode.h"

#else
struct m68k_opcode
{
  char *name;
  uint32_t opcode;
  uint32_t  match;
  char *args;
  char *cpus;
};

#define one(x) ((x) << 16)
struct m68k_opcode m68k_opcodes[] =
{
{"abcd",	one(0140400),		one(0170770),		"DsDd"},
{"addal",	one(0150700),		one(0170700),		"*lAd"},
};

int numopcodes=sizeof(m68k_opcodes)/sizeof(m68k_opcodes[0]);
#endif

int32_t types[128]; /* initialized to zero */

static void print_op(
    struct operand *op,
    char *arg,
    char end_char);

void
main(
int argc,
char *argv[],
char *envp[])
{
    struct m68k_opcode *opcode;
    char *args;
    struct operand *op1, *op2, *op3, *op4, *op5, *op6;

/* Kinds of operands: */
   	/* D  data register only.  Stored as 3 bits. */
	types['D'] = DREG;
	/* A  address register only.  Stored as 3 bits. */
	types['A'] = AREG;
	/* R  either kind of register.  Stored as 4 bits. */
	types['R'] = DREG | AREG;
	/* F  floating point coprocessor register only.   Stored as 3 bits. */
	types['F'] = SPECIAL_1;
   	/* O  an offset (or width): immediate data 0-31 or data register.
	   Stored as 6 bits in special format for BF... insns. */
	types['O'] = SPECIAL_1 | DREG;
	/* +  autoincrement only.  Stored as 3 bits (number of the address
	   register). */
	types['+'] = AINC;
	/* -  autodecrement only.  Stored as 3 bits (number of the address
	   register). */
	types['-'] = ADEC;
	/* Q  quick immediate data.  Stored as 3 bits.  This matches an
	   immediate operand only when value is in range 1 .. 8. */
	types['Q'] = SPECIAL_1;
	/* M  moveq immediate data.  Stored as 8 bits.  This matches an
	   immediate operand only when value is in range -128..127 */
	types['M'] = SPECIAL_1;
	/* T  trap vector immediate data.  Stored as 4 bits. */
	types['T'] = SPECIAL_1;
	/* k  K-factor for fmove.p instruction.   Stored as a 7-bit constant or
	   a three bit register offset, depending on the field type. */
	types['k'] = SPECIAL_1 | SPECIAL_2;
	/* #  immediate data.  Stored in special places (b, w or l)
	   which say how many bits to store. */
	types['#'] = SPECIAL_1;
	/* ^  immediate data for floating point instructions.   Special places
	   are offset by 2 bytes from '#'... */
	types['^'] = SPECIAL_1;
	/* B  pc-relative address, converted to an offset
	   that is treated as immediate data. */
	types['B'] = SPECIAL_1;
	/* d  displacement and register.  Stores the register as 3 bits
	   and stores the displacement in the entire second word. */
	types['d'] = SPECIAL_1;
   	/* C  the CCR.  No need to store it; this is just for filtering
	   validity. */
	types['C'] = SPECIAL_1;
	/* S  the SR.  No need to store, just as with CCR.
	types['S'] = SPECIAL_1;
	/* U  the USP.  No need to store, just as with CCR.
	types['U'] = SPECIAL_1;
	/* I  Coprocessor ID.   Not printed if 1.   The Coprocessor ID is
	   always extracted from the 'd' field of word one, which means that an
	   extended coprocessor opcode can be skipped using the 'i' place, if
	   needed. */
	types['I'] = SPECIAL_1;
	/* s  System Control register for the floating point coprocessor. */
	types['s'] = SPECIAL_1 | SPECIAL_2 | SPECIAL_3;
	/* S  List of system control registers for floating point coprocessor.*/
	types['S'] = SPECIAL_1;
	/* J  Misc register for movec instruction, stored in 'j' format. */
	types['J'] = MOVEC_REG;
	/* L  Register list of the type d0-d7/a0-a7 etc.  Can also hold
	   fp0-fp7, as well. */
	types['L'] = SPECIAL_1;
	/* l  Register list like L, but with all the bits reversed.
	   Used for going the other way. . . */
	types['l'] = SPECIAL_1;
	/* 0  Address register indirect only */
	types['0'] = AINDR;

   	/* *  all (modes 0-6,7.*) */
	types['*'] = DREG | AREG | AINDR | AINC | ADEC | Ad16 | Ad8Xn | AbdXn |
		     MIPRE | MIPOST | ABSW | ABSL | IMMED | PCd16 | PCd8Xn |
		     PCbdXn | PCMIPRE | PCMIPOST;
	/* ~  alterable memory (modes 2-6,7.0,7.1)(not 0,1,7.~) */
	types['~'] = AINDR | AINC | ADEC | Ad16 | Ad8Xn | AbdXn | MIPRE |
		     MIPOST | ABSW | ABSL;
	/* %  alterable (modes 0-6,7.0,7.1)(not 7.~) */
	types['%'] = DREG | AREG | AINDR | AINC | ADEC | Ad16 | Ad8Xn | AbdXn |
		     MIPRE | MIPOST | ABSW | ABSL;
	/* ;  data (modes 0,2-6,7.*)(not 1) */
	types[';'] = DREG | AINDR | AINC | ADEC | Ad16 | Ad8Xn | AbdXn |
		     MIPRE | MIPOST | ABSW | ABSL | IMMED | PCd16 | PCd8Xn |
		     PCbdXn | PCMIPRE | PCMIPOST;
	/* @  data, but not immediate (modes 0,2-6,7.? ? ?)(not 1,7.4) */
	types['@'] = DREG | AINDR | AINC | ADEC | Ad16 | Ad8Xn | AbdXn |
		     MIPRE | MIPOST | ABSW | ABSL | PCd16 | PCd8Xn |
		     PCbdXn | PCMIPRE | PCMIPOST;
	/* !  control (modes 2,5,6,7.*-)(not 0,1,3,4,7.4) */
	types['!'] = AINDR | Ad16 | Ad8Xn | AbdXn | MIPRE | MIPOST | ABSW |
		     ABSL | PCd16 | PCd8Xn | PCbdXn | PCMIPRE | PCMIPOST;
	/* &  alterable control	(modes 2,5,6,7.0,7.1)(not 0,1,7.? ? ?) */
	types['&'] = AINDR | Ad16 | Ad8Xn | AbdXn | MIPRE | MIPOST | ABSW |
		     ABSL;
	/* $  alterable data (modes 0,2-6,7.0,7.1)(not 1,7.~) */
	types['$'] = DREG | AINDR | AINC | ADEC | Ad16 | Ad8Xn | AbdXn |
		     MIPRE | MIPOST | ABSW | ABSL;
	/* ?  alterable control, or data register (modes 0,2,5,6,7.0,7.1)		      (not 1,3,4,7.~) */
	types['?'] = DREG | AINDR | Ad16 | Ad8Xn | AbdXn |
		     MIPRE | MIPOST | ABSW | ABSL;
	/* /  control, or data register	(modes 0,2,5,6,7.0,7.1,7.2,7.3)
	      (not 1,3,4,7.4) */
	types['/'] = DREG | AINDR | Ad16 | Ad8Xn | AbdXn | MIPRE | MIPOST |
		     ABSW | ABSL | PCd16 | PCd8Xn | PCbdXn | PCMIPRE | PCMIPOST;

	/* f  function code register (sfc or dfc) */
	types['f'] = SPECIAL_1 | SPECIAL_2;
	/* a  030 mmu registers srp, crp or tc */
	types['a'] = SPECIAL_1 | SPECIAL_2 | SPECIAL_3;
	/* b  030 mmu register mmusr */
	types['b'] = SPECIAL_1;
	/* c  040 cache indicators ic, dc or bc */
	types['c'] = SPECIAL_1 | SPECIAL_2 | SPECIAL_3;
	/* e  030 mmu registers tt0 or tt1 */
	types['e'] = SPECIAL_1 | SPECIAL_2;

	for(opcode = (struct m68k_opcode *)m68k_opcodes;
	    opcode != endop;
	    opcode++){
	    args = opcode->args;

	    if(args[0] == '\0'){
		printf("\t%s\n", opcode->name);
		continue;
	    }
	    for(op1 = ops; op1->type; op1++){
		if((types[(int)args[0]] & op1->type) == 0)
		    continue;
		if(args[2] == '\0'){
		    printf("\t%s\t", opcode->name);
		    print_op(op1, &(args[0]), '\n');
		    continue;
		}
		for(op2 = ops; op2->type; op2++){
		    if((types[(int)args[2]] & op2->type) == 0)
			continue;
		    if(args[4] == '\0'){
			printf("\t%s\t", opcode->name);
			print_op(op1, &(args[0]), ',');
			print_op(op2, &(args[2]), '\n');
			continue;
		    }
		    for(op3 = ops; op3->type; op3++){
			if((types[(int)args[4]] & op3->type) == 0)
			    continue;
			if(args[6] == '\0'){
			    printf("\t%s\t", opcode->name);
			    print_op(op1, &(args[0]), ',');
			    print_op(op2, &(args[2]), ',');
			    print_op(op3, &(args[4]), '\n');
			    continue;
			}
			for(op4 = ops; op4->type; op4++){
			    if((types[(int)args[6]] & op4->type) == 0)
				continue;
			    if(args[8] == '\0'){
				printf("\t%s\t", opcode->name);
				print_op(op1, &(args[0]), ',');
				print_op(op2, &(args[2]), ',');
				print_op(op3, &(args[4]), ',');
				print_op(op4, &(args[6]), '\n');
				continue;
			    }
			    for(op5 = ops; op5->type; op5++){
				if((types[(int)args[8]] & op5->type) == 0)
				    continue;
				if(args[10] == '\0'){
				    printf("\t%s\t", opcode->name);
				    print_op(op1, &(args[0]), ',');
				    print_op(op2, &(args[2]), ',');
				    print_op(op3, &(args[4]), ',');
				    print_op(op4, &(args[6]), ',');
				    print_op(op5, &(args[8]), '\n');
				    continue;
				}
				for(op6 = ops; op6->type; op6++){
				    if((types[(int)args[10]] & op6->type) == 0)
					continue;
				    if(args[12] == '\0'){
					printf("\t%s\t", opcode->name);
					print_op(op1, &(args[0]), ',');
					print_op(op2, &(args[2]), ',');
					print_op(op3, &(args[4]), ',');
					print_op(op4, &(args[6]), ',');
					print_op(op5, &(args[8]), ',');
					print_op(op6, &(args[10]), '\n');
					continue;
				    }
				    printf("# more than 6 operands %s %s\n",
					   opcode->name, args);
				    printf(".abort\n");
				    exit(1);
				}
			    }
			}
		    }
		}
	    }
	}
}

static
void
print_op(
struct operand *op,
char *arg,
char end_char)
{
	switch(*arg){
	case 'F':
	/* F  floating point coprocessor register only.   Stored as 3 bits. */
	    printf("fp7");
	    break;

	case 'O':
   	/* O  an offset (or width): immediate data 0-31 or data register.
	   Stored as 6 bits in special format for BF... insns. */
	    if(op->type == DREG)
		printf("%s", op->string);
	    else
		printf("#0x13");
	    break;

	case 'Q':
	/* Q  quick immediate data.  Stored as 3 bits.  This matches an
	   immediate operand only when value is in range 1 .. 8. */
	    printf("#0x7");
	    break;
	
	case 'M':
	/* M  moveq immediate data.  Stored as 8 bits.  This matches an
	   immediate operand only when value is in range -128..127 */
	    printf("#0x7e");
	    break;
	   
	case 'T':
	/* T  trap vector immediate data.  Stored as 4 bits. */
	    printf("#0xe");
	    break;

	case 'k':
	/* k  K-factor for fmove.p instruction.   Stored as a 7-bit constant or
	   a three bit register offset, depending on the field type. */
	    if(op->type == SPECIAL_1)
		printf("{d4}");
	    else
		printf("{#0x3f}");
	    break;

	case '#':
	/* #  immediate data.  Stored in special places (b, w or l)
	   which say how many bits to store. */
	    if(arg[1] == 'b')
		printf("#0x81");
	    else if(arg[1] == 'w' || arg[1] == 'z')
		printf("#0x8001");
	    else if(arg[1] == 'l')
		printf("#0x80000001");
	    /* Used with the fmovecr (7 bits) */
	    else if(arg[1] == 'C')
		printf("#0x7f");
	    /* Used with the fmovemx (8 bits) */
	    else if(arg[1] == '3')
		printf("#0xff");
	    /* Used with the fmoveml (3 bits) */
	    else if(arg[1] == '8')
		printf("#0x3");
	    /* Used with the movec (12 bits) */
	    else if(arg[1] == 'j')
		printf("#0x801"); /* vbr register # */
	    else
		printf("#???");
	    break;

	case '^':
	/* ^  immediate data for floating point instructions.   Special places
	   are offset by 2 bytes from '#'... */
	    printf("#0x3");
	    break;

	case 'B':
	/* B  pc-relative address, converted to an offset
	   that is treated as immediate data. */
	    if(arg[1] == 'w')
		printf("0x7ace");
	    else
		printf("0x1badface");
	    break;

	case 'd':
	/* d  displacement and register.  Stores the register as 3 bits
	   and stores the displacement in the entire second word. */
	/* This is used for the movep instruction "movep Dx,(d,Ay) where
	   the displacement d is 16 bits */
	    printf("(0x4321,a6)");
	    break;

	case 'C':
   	/* C  the CCR.  No need to store it; this is just for filtering
	   validity. */
	    printf("ccr");
	    break;
	
	case 'S':
	/* S  the SR.  No need to store, just as with CCR. */
	    printf("sr");
	    break;

	case 'U':
	/* U  the USP.  No need to store, just as with CCR. */
	    printf("usp");
	    break;

	case 'I':
	/* I  Coprocessor ID.   Not printed if 1.   The Coprocessor ID is
	   always extracted from the 'd' field of word one, which means that an
	   extended coprocessor opcode can be skipped using the 'i' place, if
	   needed. */
	    break;
	
	case 's':
	/* s  System Control register for the floating point coprocessor. */
	    if(op->type == SPECIAL_1)
		printf("fpi");
	    else if(op->type == SPECIAL_2)
		printf("fpc");
	    else
		printf("fps");
	    break;

#if 0
	case 'S':
	/* S  List of system control registers for floating point coprocessor.*/
	    printf("fpc/fps/fpi");
	    break;
#endif /* 0 */

	case 'J':
	/* J  Misc register for movec instruction, stored in 'j' format. */
	    printf("%s", op->string);
	    break;

	case 'f':
	/* f  function code register (sfc or dfc) */
	    if(op->type == SPECIAL_1)
		printf("sfc");
	    else
		printf("dfc");
	    break;

	case 'a':
	/* a  030 mmu registers srp, crp or tc */
	    if(op->type == SPECIAL_1)
		printf("srp");
	    else if(op->type == SPECIAL_2)
		printf("crp");
	    else
		printf("tc");
	    break;

	case 'b':
	/* b  030 mmu register mmusr */
	    printf("mmusr");
	    break;

	case 'c':
	/* c  040 cache indicators ic, dc or bc */
	    if(op->type == SPECIAL_1)
		printf("ic");
	    else if(op->type == SPECIAL_2)
		printf("dc");
	    else
		printf("bc");
	    break;

	case 'e':
	/* e  030 mmu registers tt0 or tt1 */
	    if(op->type == SPECIAL_1)
		printf("tt0");
	    else
		printf("tt1");
	    break;

	case 'L':
	case 'l':
	/* L  Register list of the type d0-d7/a0-a7 etc.  Can also hold
	   fp0-fp7, as well. */
	/* l  Register list like L, but with all the bits reversed.
	   Used for going the other way. . . */
	    if(arg[1] == 'w')
		printf("a0/a1/a2/a3/a4/a5/a6/sp/d0/d1/d2/d3/d4/d5/d6/d7");
	    else if(arg[1] == '3')
		printf("fp0/fp1/fp2/fp3/fp4/fp5/fp6/fp7");
	    else if(arg[1] == '8')
		printf("fpc/fps/fpi");
	    else
		printf("???%c", arg[0]);
	    break;

	default:
	    printf("%s", op->string);
	    break;
	}
	if((arg[2] != 'k' && arg[0] != 'I') ||
	   (arg[0] == 'I' && arg[2] == '\0'))
	    printf("%c", end_char);
}
                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/m68k-opcode.h                            0100644 0001750 0001750 00000326140 12612724204 023254  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* Opcode table for m68000/m68020 and m68881.
   Copyright (C) 1989, Free Software Foundation.

This file is part of GDB, the GNU Debugger and GAS, the GNU Assembler.

Both GDB and GAS are free software; you can redistribute and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.

GDB and GAS are distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GDB or GAS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
   
#include <stdint.h>

struct m68k_opcode
{
  char *name;
  uint32_t opcode;
  uint32_t  match;
  char *args;
  char *cpus;
};

/* We store four bytes of opcode for all opcodes because that
   is the most any of them need.  The actual length of an instruction
   is always at least 2 bytes, and is as much longer as necessary to
   hold the operands it has.

   The match component is a mask saying which bits must match
   particular opcode in order for an instruction to be an instance
   of that opcode.

   The args component is a string containing two characters
   for each operand of the instruction.  The first specifies
   the kind of operand; the second, the place it is stored.  */

/* Kinds of operands:
   D  data register only.  Stored as 3 bits.
   A  address register only.  Stored as 3 bits.
   R  either kind of register.  Stored as 4 bits.
   F  floating point coprocessor register only.   Stored as 3 bits.
   O  an offset (or width): immediate data 0-31 or data register.
      Stored as 6 bits in special format for BF... insns.
   +  autoincrement only.  Stored as 3 bits (number of the address register).
   -  autodecrement only.  Stored as 3 bits (number of the address register).
   Q  quick immediate data.  Stored as 3 bits.
      This matches an immediate operand only when value is in range 1 .. 8.
   M  moveq immediate data.  Stored as 8 bits.
      This matches an immediate operand only when value is in range -128..127
   T  trap vector immediate data.  Stored as 4 bits.

   k  K-factor for fmove.p instruction.   Stored as a 7-bit constant or
      a three bit register offset, depending on the field type.

   #  immediate data.  Stored in special places (b, w or l)
      which say how many bits to store.
   ^  immediate data for floating point instructions.   Special places
      are offset by 2 bytes from '#'...
   B  pc-relative address, converted to an offset
      that is treated as immediate data.
   d  displacement and register.  Stores the register as 3 bits
      and stores the displacement in the entire second word.

   C  the CCR.  No need to store it; this is just for filtering validity.
   S  the SR.  No need to store, just as with CCR.
   U  the USP.  No need to store, just as with CCR.

   I  Coprocessor ID.   Not printed if 1.   The Coprocessor ID is always
      extracted from the 'd' field of word one, which means that an extended
      coprocessor opcode can be skipped using the 'i' place, if needed.

   s  System Control register for the floating point coprocessor.
   S  List of system control registers for floating point coprocessor.

   J  Misc register for movec instruction, stored in 'j' format.
	Possible values:
	000	SFC	Source Function Code reg
	001	DFC	Data Function Code reg
	002	CACR	Cache Control Register
	800	USP	User Stack Pointer
	801	VBR	Vector Base reg
	802	CAAR	Cache Address Register
	803	MSP	Master Stack Pointer
	804	ISP	Interrupt Stack Pointer

    L  Register list of the type d0-d7/a0-a7 etc.
       (New!  Improved!  Can also hold fp0-fp7, as well!)
       The assembler tries to see if the registers match the insn by
       looking at where the insn wants them stored.
#ifdef NeXT_MOD
	REGISTER LIST BUG:
	The above "New! Improved!" feature has a bug it.  The problem
	with the way it "Can also hold fp0-fp7" is that the instruction
	"fmovemx d0,a0@" fails unless the opcode table has all L and l kinds
	after the D kind (which was the way the 1.36 GAS was).  This happens
	because in m68_ip() in m68k.c when matching the operands of the
	instruction to the table entries it changes a DREG type operand to
	a REGLIST type operand but after it matches (when it shouldn't have)
	it figures out it has the wrong type of registers in the register list
	and fails.  So the fix is to put all L and l kinds last in the set
	for each operand that uses them.
#endif

    l  Register list like L, but with all the bits reversed.
       Used for going the other way. . .

    0  Address register indirect only

 They are all stored as 6 bits using an address mode and a register number;
 they differ in which addressing modes they match.

   *  all					(modes 0-6,7.*)
   ~  alterable memory				(modes 2-6,7.0,7.1)(not 0,1,7.~)
   %  alterable					(modes 0-6,7.0,7.1)(not 7.~)
   ;  data					(modes 0,2-6,7.*)(not 1)
   @  data, but not immediate			(modes 0,2-6,7.? ? ?)(not 1,7.?)  This may really be ;, the 68020 book says it is
   !  control					(modes 2,5,6,7.*-)(not 0,1,3,4,7.4)
   &  alterable control				(modes 2,5,6,7.0,7.1)(not 0,1,7.? ? ?)
   $  alterable data				(modes 0,2-6,7.0,7.1)(not 1,7.~)
   ?  alterable control, or data register	(modes 0,2,5,6,7.0,7.1)(not 1,3,4,7.~)
   /  control, or data register			(modes 0,2,5,6,7.0,7.1,7.2,7.3)(not 1,3,4,7.4)
*/

/* JF: for the 68851 */
/*
   I didn't use much imagination in choosing the 
   following codes, so many of them aren't very
   mnemonic. -rab

   P  pmmu register
	Possible values:
	000	TC	Translation Control reg
	100	CAL	Current Access Level
	101	VAL	Validate Access Level
	110	SCC	Stack Change Control
	111	AC	Access Control

   W  wide pmmu registers
	Possible values:
	001	DRP	Dma Root Pointer
	010	SRP	Supervisor Root Pointer
	011	CRP	Cpu Root Pointer

(f - is also used for the 030 pflush instruction)
   f	function code register
	0	SFC
	1	DFC

   V	VAL register only

   X	BADx, BACx
	100	BAD	Breakpoint Acknowledge Data
	101	BAC	Breakpoint Acknowledge Control

   Y	PSR
   Z	PCSR

   |	memory 		(modes 2-6, 7.*)

*/

/* for the builtin mmus (also see f above):
   a	SRP, CRP or TC registers (used for the 030 only)
	Possible values:
	010	SRP	supervisor root pointer
	011	CRP	cpu root pointer
	000	TC	translation control register
   b	MMUSR register only (used for the 030 only)
   d	TT0 or TT1 registers (used for the 030 only)
	Possible values:
	010	TT0	transparent translation register 0
	011	TT1	transparent translation register 1

   c	Cache selection (IC, DC or BC) (used for the 040 only)
	Possible values:
	10	IC	instruction cache
	01	DC	data cache
	11	BC	baoth instruction and data caches
*/

/* Places to put an operand, for non-general operands:
   s  source, low bits of first word.
   d  dest, shifted 9 in first word
   1  second word, shifted 12
   2  second word, shifted 6
   3  second word, shifted 0
   4  third word, shifted 12
   5  third word, shifted 6
   6  third word, shifted 0
   7  second word, shifted 7
   8  second word, shifted 10
   9  second word, shifted 5
   D  store in both place 1 and place 3; for divul and divsl.
   b  second word, low byte
   w  second word (entire)
#ifdef NeXT_MOD
   z  second word (entire) (also has long with the same form, the "link" inst)
#endif
   l  second and third word (entire)
   g  branch offset for bra and similar instructions.
      The place to store depends on the magnitude of offset.
   t  store in both place 7 and place 8; for floating point operations
   c  branch offset for cpBcc operations.
      The place to store is word two if bit six of word one is zero,
      and words two and three if bit six of word one is one.
   i  Increment by two, to skip over coprocessor extended operands.   Only
      works with the 'I' format.
   k  Dynamic K-factor field.   Bits 6-4 of word 2, used as a register number.
      Also used for dynamic fmovem instruction.
   C  floating point coprocessor constant - 7 bits.  Also used for static
      K-factors...
   j  Movec register #, stored in 12 low bits of second word.
   S  Cache indicator value, sorted in the first word shifted 6.

 Places to put operand, for general operands:
   d  destination, shifted 6 bits in first word
   b  source, at low bit of first word, and immediate uses one byte
   w  source, at low bit of first word, and immediate uses two bytes
   l  source, at low bit of first word, and immediate uses four bytes
   s  source, at low bit of first word.
      Used sometimes in contexts where immediate is not allowed anyway.
   f  single precision float, low bit of 1st word, immediate uses 4 bytes
   F  double precision float, low bit of 1st word, immediate uses 8 bytes
   x  extended precision float, low bit of 1st word, immediate uses 12 bytes
   p  packed float, low bit of 1st word, immediate uses 12 bytes
*/

/* The cpus string indicates instructions that only execute on a specific
   implementaion of the 68k processor family as defined by NeXT.  This is used
   to set the cpusubtype field in the mach_header of the output object file.
   
   Here are the possible values:
   2  Instruction is available on the MC68020 (only for callm and rtm)
   3  Instruction is available on the MC68030
   4  Instruction is available on the MC68040
*/

#define one(x) ((x) << 16)
#define two(x, y) (((x) << 16) + y)

/*
	*** DANGER WILL ROBINSON ***

   The assembler requires that all instances of the same mnemonic must be
   consecutive.  If they aren't, the assembler will bomb at runtime
 */
static const struct m68k_opcode m68k_opcodes[] =
{
{"abcd",	one(0140400),		one(0170770),		"DsDd"},
{"abcd",	one(0140410),		one(0170770),		"-s-d"},

		/* Add instructions */
{"addal",	one(0150700),		one(0170700),		"*lAd"},
{"addaw",	one(0150300),		one(0170700),		"*wAd"},
{"addib",	one(0003000),		one(0177700),		"#b$b"},
{"addil",	one(0003200),		one(0177700),		"#l$l"},
{"addiw",	one(0003100),		one(0177700),		"#w$w"},
{"addqb",	one(0050000),		one(0170700),		"Qd$b"},
{"addql",	one(0050200),		one(0170700),		"Qd%l"},
{"addqw",	one(0050100),		one(0170700),		"Qd%w"},

{"addb",	one(0050000),		one(0170700),		"Qd$b"},	/* addq written as add */
{"addb",	one(0003000),		one(0177700),		"#b$b"},	/* addi written as add */
{"addb",	one(0150000),		one(0170700),		";bDd"},	/* addb <ea>,	Dd */
{"addb",	one(0150400),		one(0170700),		"Dd~b"},	/* addb Dd,	<ea> */

{"addw",	one(0050100),		one(0170700),		"Qd%w"},	/* addq written as add */
{"addw",	one(0003100),		one(0177700),		"#w$w"},	/* addi written as add */
{"addw",	one(0150300),		one(0170700),		"*wAd"},	/* adda written as add */
{"addw",	one(0150100),		one(0170700),		"*wDd"},	/* addw <ea>,	Dd */
{"addw",	one(0150500),		one(0170700),		"Dd~w"},	/* addw Dd,	<ea> */

{"addl",	one(0050200),		one(0170700),		"Qd%l"},	/* addq written as add */
{"addl",	one(0003200),		one(0177700),		"#l$l"},	/* addi written as add */
{"addl",	one(0150700),		one(0170700),		"*lAd"},	/* adda written as add */
{"addl",	one(0150200),		one(0170700),		"*lDd"},	/* addl <ea>,	Dd */
{"addl",	one(0150600),		one(0170700),		"Dd~l"},	/* addl Dd,	<ea> */

{"addxb",	one(0150400),		one(0170770),		"DsDd"},
{"addxb",	one(0150410),		one(0170770),		"-s-d"},
{"addxl",	one(0150600),		one(0170770),		"DsDd"},
{"addxl",	one(0150610),		one(0170770),		"-s-d"},
{"addxw",	one(0150500),		one(0170770),		"DsDd"},
{"addxw",	one(0150510),		one(0170770),		"-s-d"},

{"andib",	one(0001000),		one(0177700),		"#b$b"},
{"andib",	one(0001074),		one(0177777),		"#bCb"},	/* andi to ccr */
{"andiw",	one(0001100),		one(0177700),		"#w$w"},
{"andiw",	one(0001174),		one(0177777),		"#wSw"},	/* andi to sr */
{"andil",	one(0001200),		one(0177700),		"#l$l"},

{"andb",	one(0001000),		one(0177700),		"#b$b"},	/* andi written as or */
{"andb",	one(0001074),		one(0177777),		"#bCb"},	/* andi to ccr */
{"andb",	one(0140000),		one(0170700),		";bDd"},	/* memory to register */
{"andb",	one(0140400),		one(0170700),		"Dd~b"},	/* register to memory */
{"andw",	one(0001100),		one(0177700),		"#w$w"},	/* andi written as or */
{"andw",	one(0001174),		one(0177777),		"#wSw"},	/* andi to sr */
{"andw",	one(0140100),		one(0170700),		";wDd"},	/* memory to register */
{"andw",	one(0140500),		one(0170700),		"Dd~w"},	/* register to memory */
{"andl",	one(0001200),		one(0177700),		"#l$l"},	/* andi written as or */
{"andl",	one(0140200),		one(0170700),		";lDd"},	/* memory to register */
{"andl",	one(0140600),		one(0170700),		"Dd~l"},	/* register to memory */

{"aslb",	one(0160400),		one(0170770),		"QdDs"},
{"aslb",	one(0160440),		one(0170770),		"DdDs"},
{"asll",	one(0160600),		one(0170770),		"QdDs"},
{"asll",	one(0160640),		one(0170770),		"DdDs"},
{"aslw",	one(0160500),		one(0170770),		"QdDs"},
{"aslw",	one(0160540),		one(0170770),		"DdDs"},
{"aslw",	one(0160700),		one(0177700),		"~s"},	/* Shift memory */
{"asrb",	one(0160000),		one(0170770),		"QdDs"},
{"asrb",	one(0160040),		one(0170770),		"DdDs"},
{"asrl",	one(0160200),		one(0170770),		"QdDs"},
{"asrl",	one(0160240),		one(0170770),		"DdDs"},
{"asrw",	one(0160100),		one(0170770),		"QdDs"},
{"asrw",	one(0160140),		one(0170770),		"DdDs"},
{"asrw",	one(0160300),		one(0177700),		"~s"},	/* Shift memory */

{"bhi",		one(0061000),		one(0177400),		"Bg"},
{"bls",		one(0061400),		one(0177400),		"Bg"},
{"bcc",		one(0062000),		one(0177400),		"Bg"},
{"bcs",		one(0062400),		one(0177400),		"Bg"},
{"bne",		one(0063000),		one(0177400),		"Bg"},
{"beq",		one(0063400),		one(0177400),		"Bg"},
{"bvc",		one(0064000),		one(0177400),		"Bg"},
{"bvs",		one(0064400),		one(0177400),		"Bg"},
{"bpl",		one(0065000),		one(0177400),		"Bg"},
{"bmi",		one(0065400),		one(0177400),		"Bg"},
{"bge",		one(0066000),		one(0177400),		"Bg"},
{"blt",		one(0066400),		one(0177400),		"Bg"},
{"bgt",		one(0067000),		one(0177400),		"Bg"},
{"ble",		one(0067400),		one(0177400),		"Bg"},

{"bchg",	one(0000500),		one(0170700),		"Dd$s"},
{"bchg",	one(0004100),		one(0177700),		"#b$s"},
{"bclr",	one(0000600),		one(0170700),		"Dd$s"},
{"bclr",	one(0004200),		one(0177700),		"#b$s"},
{"bfchg",	two(0165300, 0),	two(0177700, 0170000),	"?sO2O3"},
{"bfclr",	two(0166300, 0),	two(0177700, 0170000),	"?sO2O3"},
{"bfexts",	two(0165700, 0),	two(0177700, 0100000),	"/sO2O3D1"},
{"bfextu",	two(0164700, 0),	two(0177700, 0100000),	"/sO2O3D1"},
{"bfffo",	two(0166700, 0),	two(0177700, 0100000),	"/sO2O3D1"},
{"bfins",	two(0167700, 0),	two(0177700, 0100000),	"D1?sO2O3"},
{"bfset",	two(0167300, 0),	two(0177700, 0170000),	"?sO2O3"},
{"bftst",	two(0164300, 0),	two(0177700, 0170000),	"/sO2O3"},
{"bset",	one(0000700),		one(0170700),		"Dd$s"},
{"bset",	one(0004300),		one(0177700),		"#b$s"},
{"btst",	one(0000400),		one(0170700),		"Dd@s"},
{"btst",	one(0004000),		one(0177700),		"#b@s"},

{"bkpt",	one(0044110),		one(0177770),		"Qs"},
{"bra",		one(0060000),		one(0177400),		"Bg"},
#ifdef NeXT_MOD
{"bras",	one(0060000),		one(0177400),		"Bg"},
#else
{"bras",	one(0060000),		one(0177400),		"Bw"},
#endif
{"bsr",		one(0060400),		one(0177400),		"Bg"},
#ifdef NeXT_MOD
{"bsrs",	one(0060400),		one(0177400),		"Bg"},
#else
{"bsrs",	one(0060400),		one(0177400),		"Bw"},
#endif

{"callm",	one(0003300),		one(0177700),		"#b!s", "2"},
{"cas2l",	two(0007374, 0),	two(0177777, 0107070),	"D3D6D2D5R1R4"},	/* JF FOO this is really a 3 word ins */
{"cas2w",	two(0006374, 0),	two(0177777, 0107070),	"D3D6D2D5R1R4"},	/* JF ditto */
{"casb",	two(0005300, 0),	two(0177700, 0177070),	"D3D2~s"},
{"casl",	two(0007300, 0),	two(0177700, 0177070),	"D3D2~s"},
{"casw",	two(0006300, 0),	two(0177700, 0177070),	"D3D2~s"},

/*  {"chk",	one(0040600),		one(0170700),		";wDd"}, JF FOO this looks wrong */
{"chk2b",	two(0000300, 0004000),	two(0177700, 07777),	"!sR1"},
{"chk2l",	two(0002300, 0004000),	two(0177700, 07777),	"!sR1"},
{"chk2w",	two(0001300, 0004000),	two(0177700, 07777),	"!sR1"},
{"chkl",	one(0040400),		one(0170700),		";lDd"},
{"chkw",	one(0040600),		one(0170700),		";wDd"},
{"clrb",	one(0041000),		one(0177700),		"$s"},
{"clrl",	one(0041200),		one(0177700),		"$s"},
{"clrw",	one(0041100),		one(0177700),		"$s"},

{"cmp2b",	two(0000300, 0),	two(0177700, 07777),	"!sR1"},
{"cmp2l",	two(0002300, 0),	two(0177700, 07777),	"!sR1"},
{"cmp2w",	two(0001300, 0),	two(0177700, 07777),	"!sR1"},
{"cmpal",	one(0130700),		one(0170700),		"*lAd"},
{"cmpaw",	one(0130300),		one(0170700),		"*wAd"},
{"cmpib",	one(0006000),		one(0177700),		"#b;b"},
{"cmpil",	one(0006200),		one(0177700),		"#l;l"},
{"cmpiw",	one(0006100),		one(0177700),		"#w;w"},
{"cmpb",	one(0006000),		one(0177700),		"#b;b"},	/* cmpi written as cmp */
{"cmpb",	one(0130000),		one(0170700),		";bDd"},
{"cmpw",	one(0006100),		one(0177700),		"#w;w"},
{"cmpw",	one(0130100),		one(0170700),		"*wDd"},
{"cmpw",	one(0130300),		one(0170700),		"*wAd"},	/* cmpa written as cmp */
{"cmpl",	one(0006200),		one(0177700),		"#l;l"},
{"cmpl",	one(0130200),		one(0170700),		"*lDd"},
{"cmpl",	one(0130700),		one(0170700),		"*lAd"},
{"cmpmb",	one(0130410),		one(0170770),		"+s+d"},
{"cmpml",	one(0130610),		one(0170770),		"+s+d"},
{"cmpmw",	one(0130510),		one(0170770),		"+s+d"},

{"dbcc",	one(0052310),		one(0177770),		"DsBw"},
{"dbcs",	one(0052710),		one(0177770),		"DsBw"},
{"dbeq",	one(0053710),		one(0177770),		"DsBw"},
{"dbf",		one(0050710),		one(0177770),		"DsBw"},
{"dbge",	one(0056310),		one(0177770),		"DsBw"},
{"dbgt",	one(0057310),		one(0177770),		"DsBw"},
{"dbhi",	one(0051310),		one(0177770),		"DsBw"},
{"dble",	one(0057710),		one(0177770),		"DsBw"},
{"dbls",	one(0051710),		one(0177770),		"DsBw"},
{"dblt",	one(0056710),		one(0177770),		"DsBw"},
{"dbmi",	one(0055710),		one(0177770),		"DsBw"},
{"dbne",	one(0053310),		one(0177770),		"DsBw"},
{"dbpl",	one(0055310),		one(0177770),		"DsBw"},
{"dbra",	one(0050710),		one(0177770),		"DsBw"},
{"dbt",		one(0050310),		one(0177770),		"DsBw"},
{"dbvc",	one(0054310),		one(0177770),		"DsBw"},
{"dbvs",	one(0054710),		one(0177770),		"DsBw"},

{"divsl",	two(0046100, 0006000),	two(0177700, 0107770),	";lD3D1"},
{"divsl",	two(0046100, 0004000),	two(0177700, 0107770),	";lDD"},
{"divsll",	two(0046100, 0004000),	two(0177700, 0107770),	";lD3D1"},
{"divsw",	one(0100700),		one(0170700),		";wDd"},
{"divs",	one(0100700),		one(0170700),		";wDd"},
{"divul",	two(0046100, 0002000),	two(0177700, 0107770),	";lD3D1"},
{"divul",	two(0046100, 0000000),	two(0177700, 0107770),	";lDD"},
{"divull",	two(0046100, 0000000),	two(0177700, 0107770),	";lD3D1"},
{"divuw",	one(0100300),		one(0170700),		";wDd"},
{"divu",	one(0100300),		one(0170700),		";wDd"},
{"eorb",	one(0005000),		one(0177700),		"#b$s"},	/* eori written as eor */
{"eorb",	one(0005074),		one(0177777),		"#bCs"},	/* eori to ccr */
{"eorb",	one(0130400),		one(0170700),		"Dd$s"},	/* register to memory */
{"eorib",	one(0005000),		one(0177700),		"#b$s"},
{"eorib",	one(0005074),		one(0177777),		"#bCs"},	/* eori to ccr */
{"eoril",	one(0005200),		one(0177700),		"#l$s"},
{"eoriw",	one(0005100),		one(0177700),		"#w$s"},
{"eoriw",	one(0005174),		one(0177777),		"#wSs"},	/* eori to sr */
{"eorl",	one(0005200),		one(0177700),		"#l$s"},
{"eorl",	one(0130600),		one(0170700),		"Dd$s"},
{"eorw",	one(0005100),		one(0177700),		"#w$s"},
{"eorw",	one(0005174),		one(0177777),		"#wSs"},	/* eori to sr */
{"eorw",	one(0130500),		one(0170700),		"Dd$s"},

{"exg",		one(0140500),		one(0170770),		"DdDs"},
{"exg",		one(0140510),		one(0170770),		"AdAs"},
{"exg",		one(0140610),		one(0170770),		"DdAs"},
{"exg",		one(0140610),		one(0170770),		"AsDd"},

{"extw",	one(0044200),		one(0177770),		"Ds"},
{"extl",	one(0044300),		one(0177770),		"Ds"},
{"extbl",	one(0044700),		one(0177770),		"Ds"},
{"extb.l",	one(0044700),		one(0177770),		"Ds"},	/* Not sure we should support this one*/

{"illegal",	one(0045374),		one(0177777),		""},
{"jmp",		one(0047300),		one(0177700),		"!s"},
{"jsr",		one(0047200),		one(0177700),		"!s"},
{"lea",		one(0040700),		one(0170700),		"!sAd"},
{"linkw",	one(0047120),		one(0177770),		"As#w"},
{"linkl",	one(0044010),		one(0177770),		"As#l"},
#ifdef NeXT_MOD
{"link",	one(0047120),		one(0177770),		"As#z"},
#else
{"link",	one(0047120),		one(0177770),		"As#w"},
#endif
{"link",	one(0044010),		one(0177770),		"As#l"},

{"lslb",	one(0160410),		one(0170770),		"QdDs"},	/* lsrb #Q,	Ds */
{"lslb",	one(0160450),		one(0170770),		"DdDs"},	/* lsrb Dd,	Ds */
{"lslw",	one(0160510),		one(0170770),		"QdDs"},	/* lsrb #Q,	Ds */
{"lslw",	one(0160550),		one(0170770),		"DdDs"},	/* lsrb Dd,	Ds */
{"lslw",	one(0161700),		one(0177700),		"~s"},	/* Shift memory */
{"lsll",	one(0160610),		one(0170770),		"QdDs"},	/* lsrb #Q,	Ds */
{"lsll",	one(0160650),		one(0170770),		"DdDs"},	/* lsrb Dd,	Ds */

{"lsrb",	one(0160010),		one(0170770),		"QdDs"}, 	/* lsrb #Q,	Ds */
{"lsrb",	one(0160050),		one(0170770),		"DdDs"},	/* lsrb Dd,	Ds */
{"lsrl",	one(0160210),		one(0170770),		"QdDs"},	/* lsrb #Q,	Ds */
{"lsrl",	one(0160250),		one(0170770),		"DdDs"},	/* lsrb #Q,	Ds */
{"lsrw",	one(0160110),		one(0170770),		"QdDs"},	/* lsrb #Q,	Ds */
{"lsrw",	one(0160150),		one(0170770),		"DdDs"},	/* lsrb #Q,	Ds */
{"lsrw",	one(0161300),		one(0177700),		"~s"},	/* Shift memory */

{"moveal",	one(0020100),		one(0170700),		"*lAd"},
{"moveaw",	one(0030100),		one(0170700),		"*wAd"},
{"moveb",	one(0010000),		one(0170000),		";b$d"},	/* move */
{"movel",	one(0070000),		one(0170400),		"MsDd"},	/* moveq written as move */
{"movel",	one(0020000),		one(0170000),		"*l$d"},
{"movel",	one(0020100),		one(0170700),		"*lAd"},
{"movel",	one(0047140),		one(0177770),		"AsUd"},	/* move to USP */
{"movel",	one(0047150),		one(0177770),		"UdAs"},	/* move from USP */

{"movec",	one(0047173),		one(0177777),		"R1Jj"},
{"movec",	one(0047173),		one(0177777),		"R1#j"},
{"movec",	one(0047172),		one(0177777),		"JjR1"},
{"movec",	one(0047172),		one(0177777),		"#jR1"},

/* JF added these next four for the assembler */
{"moveml",	one(0044300),		one(0177700),		"Lw&s"},	/* movem reg to mem. */
{"moveml",	one(0044340),		one(0177770),		"lw-s"},	/* movem reg to autodecrement. */
{"moveml",	one(0046300),		one(0177700),		"!sLw"},	/* movem mem to reg. */
{"moveml",	one(0046330),		one(0177770),		"+sLw"},	/* movem autoinc to reg. */

{"moveml",	one(0044300),		one(0177700),		"#w&s"},	/* movem reg to mem. */
{"moveml",	one(0044340),		one(0177770),		"#w-s"},	/* movem reg to autodecrement. */
{"moveml",	one(0046300),		one(0177700),		"!s#w"},	/* movem mem to reg. */
{"moveml",	one(0046330),		one(0177770),		"+s#w"},	/* movem autoinc to reg. */

/* JF added these next four for the assembler */
{"movemw",	one(0044200),		one(0177700),		"Lw&s"},	/* movem reg to mem. */
{"movemw",	one(0044240),		one(0177770),		"lw-s"},	/* movem reg to autodecrement. */
{"movemw",	one(0046200),		one(0177700),		"!sLw"},	/* movem mem to reg. */
{"movemw",	one(0046230),		one(0177770),		"+sLw"},	/* movem autoinc to reg. */
{"movemw",	one(0044200),		one(0177700),		"#w&s"},	/* movem reg to mem. */
{"movemw",	one(0044240),		one(0177770),		"#w-s"},	/* movem reg to autodecrement. */
{"movemw",	one(0046200),		one(0177700),		"!s#w"},	/* movem mem to reg. */
{"movemw",	one(0046230),		one(0177770),		"+s#w"},	/* movem autoinc to reg. */

{"movepl",	one(0000510),		one(0170770),		"dsDd"},	/* memory to register */
{"movepl",	one(0000710),		one(0170770),		"Ddds"},	/* register to memory */
{"movepw",	one(0000410),		one(0170770),		"dsDd"},	/* memory to register */
{"movepw",	one(0000610),		one(0170770),		"Ddds"},	/* register to memory */
{"moveq",	one(0070000),		one(0170400),		"MsDd"},
{"movew",	one(0030000),		one(0170000),		"*w$d"},
{"movew",	one(0030100),		one(0170700),		"*wAd"},	/* movea, written as move */
{"movew",	one(0040300),		one(0177700),		"Ss$s"},	/* Move from sr */
{"movew",	one(0041300),		one(0177700),		"Cs$s"},
/* Move from ccr */
{"movew",	one(0042300),		one(0177700),		";wCd"},	/* move to ccr */
{"movew",	one(0043300),		one(0177700),		";wSd"},	/* move to sr */

{"movesb",	two(0007000, 0),	two(0177700, 07777),	"~sR1"}, /* moves from memory */
{"movesb",	two(0007000, 04000),	two(0177700, 07777),	"R1~s"}, /* moves to memory */
{"movesl",	two(0007200, 0),	two(0177700, 07777),	"~sR1"}, /* moves from memory */
{"movesl",	two(0007200, 04000),	two(0177700, 07777),	"R1~s"}, /* moves to memory */
{"movesw",	two(0007100, 0),	two(0177700, 07777),	"~sR1"}, /* moves from memory */
{"movesw",	two(0007100, 04000),	two(0177700, 07777),	"R1~s"}, /* moves to memory */

{"move16",	one(0173000),		one(0177770),		"+s#l", "4"},	/* (An)+,xxx.L */
{"move16",	one(0173010),		one(0177770),		"#l+s", "4"},	/* xxx.L,(An)+ */
{"move16",	one(0173020),		one(0177770),		"0s#l", "4"},	/* (An), xxx.L */
{"move16",	one(0173030),		one(0177770),		"#l0s", "4"},	/* xxx.L,(An) */
{"move16",	two(0173040, 0100000),	two(0177770, 0107777),	"+s+1", "4"},	/* (Ax)+,(Ay)+ */

{"mulsl",	two(0046000, 004000),	two(0177700, 0107770),	";lD1"},
{"mulsl",	two(0046000, 006000),	two(0177700, 0107770),	";lD3D1"},
{"mulsw",	one(0140700),		one(0170700),		";wDd"},
{"muls",	one(0140700),		one(0170700),		";wDd"},
{"mulul",	two(0046000, 000000),	two(0177700, 0107770),	";lD1"},
{"mulul",	two(0046000, 002000),	two(0177700, 0107770),	";lD3D1"},
{"muluw",	one(0140300),		one(0170700),		";wDd"},
{"mulu",	one(0140300),		one(0170700),		";wDd"},
{"nbcd",	one(0044000),		one(0177700),		"$s"},
{"negb",	one(0042000),		one(0177700),		"$s"},
{"negl",	one(0042200),		one(0177700),		"$s"},
{"negw",	one(0042100),		one(0177700),		"$s"},
{"negxb",	one(0040000),		one(0177700),		"$s"},
{"negxl",	one(0040200),		one(0177700),		"$s"},
{"negxw",	one(0040100),		one(0177700),		"$s"},
{"nop",		one(0047161),		one(0177777),		""},
{"notb",	one(0043000),		one(0177700),		"$s"},
{"notl",	one(0043200),		one(0177700),		"$s"},
{"notw",	one(0043100),		one(0177700),		"$s"},

{"orb",		one(0000000),		one(0177700),		"#b$s"},	/* ori written as or */
{"orb",		one(0000074),		one(0177777),		"#bCs"},	/* ori to ccr */
{"orb",		one(0100000),		one(0170700),		";bDd"},	/* memory to register */
{"orb",		one(0100400),		one(0170700),		"Dd~s"},	/* register to memory */
{"orib",	one(0000000),		one(0177700),		"#b$s"},
{"orib",	one(0000074),		one(0177777),		"#bCs"},	/* ori to ccr */
{"oril",	one(0000200),		one(0177700),		"#l$s"},
{"oriw",	one(0000100),		one(0177700),		"#w$s"},
{"oriw",	one(0000174),		one(0177777),		"#wSs"},	/* ori to sr */
{"orl",		one(0000200),		one(0177700),		"#l$s"},
{"orl",		one(0100200),		one(0170700),		";lDd"},	/* memory to register */
{"orl",		one(0100600),		one(0170700),		"Dd~s"},	/* register to memory */
{"orw",		one(0000100),		one(0177700),		"#w$s"},
{"orw",		one(0000174),		one(0177777),		"#wSs"},	/* ori to sr */
{"orw",		one(0100100),		one(0170700),		";wDd"},	/* memory to register */
{"orw",		one(0100500),		one(0170700),		"Dd~s"},	/* register to memory */

{"pack",	one(0100500),		one(0170770),		"DsDd#w"},	/* pack Ds,	Dd,	#w */
{"pack",	one(0100510),		one(0170770),		"-s-d#w"},	/* pack -(As),	-(Ad),	#w */
{"pea",		one(0044100),		one(0177700),		"!s"},
{"reset",	one(0047160),		one(0177777),		""},

{"rolb",	one(0160430),		one(0170770),		"QdDs"},	/* rorb #Q,	Ds */
{"rolb",	one(0160470),		one(0170770),		"DdDs"},	/* rorb Dd,	Ds */
{"roll",	one(0160630),		one(0170770),		"QdDs"},	/* rorb #Q,	Ds */
{"roll",	one(0160670),		one(0170770),		"DdDs"},	/* rorb Dd,	Ds */
{"rolw",	one(0160530),		one(0170770),		"QdDs"},	/* rorb #Q,	Ds */
{"rolw",	one(0160570),		one(0170770),		"DdDs"},	/* rorb Dd,	Ds */
{"rolw",	one(0163700),		one(0177700),		"~s"},	/* Rotate memory */
{"rorb",	one(0160030),		one(0170770),		"QdDs"},	/* rorb #Q,	Ds */
{"rorb",	one(0160070),		one(0170770),		"DdDs"},	/* rorb Dd,	Ds */
{"rorl",	one(0160230),		one(0170770),		"QdDs"},	/* rorb #Q,	Ds */
{"rorl",	one(0160270),		one(0170770),		"DdDs"},	/* rorb Dd,	Ds */
{"rorw",	one(0160130),		one(0170770),		"QdDs"},	/* rorb #Q,	Ds */
{"rorw",	one(0160170),		one(0170770),		"DdDs"},	/* rorb Dd,	Ds */
{"rorw",	one(0163300),		one(0177700),		"~s"},	/* Rotate memory */

{"roxlb",	one(0160420),		one(0170770),		"QdDs"},	/* roxrb #Q,	Ds */
{"roxlb",	one(0160460),		one(0170770),		"DdDs"},	/* roxrb Dd,	Ds */
{"roxll",	one(0160620),		one(0170770),		"QdDs"},	/* roxrb #Q,	Ds */
{"roxll",	one(0160660),		one(0170770),		"DdDs"},	/* roxrb Dd,	Ds */
{"roxlw",	one(0160520),		one(0170770),		"QdDs"},	/* roxrb #Q,	Ds */
{"roxlw",	one(0160560),		one(0170770),		"DdDs"},	/* roxrb Dd,	Ds */
{"roxlw",	one(0162700),		one(0177700),		"~s"},	/* Rotate memory */
{"roxrb",	one(0160020),		one(0170770),		"QdDs"},	/* roxrb #Q,	Ds */
{"roxrb",	one(0160060),		one(0170770),		"DdDs"},	/* roxrb Dd,	Ds */
{"roxrl",	one(0160220),		one(0170770),		"QdDs"},	/* roxrb #Q,	Ds */
{"roxrl",	one(0160260),		one(0170770),		"DdDs"},	/* roxrb Dd,	Ds */
{"roxrw",	one(0160120),		one(0170770),		"QdDs"},	/* roxrb #Q,	Ds */
{"roxrw",	one(0160160),		one(0170770),		"DdDs"},	/* roxrb Dd,	Ds */
{"roxrw",	one(0162300),		one(0177700),		"~s"},	/* Rotate memory */

{"rtd",		one(0047164),		one(0177777),		"#w"},
{"rte",		one(0047163),		one(0177777),		""},
{"rtm",		one(0003300),		one(0177760),		"Rs", "2"},
{"rtr",		one(0047167),		one(0177777),		""},
{"rts",		one(0047165),		one(0177777),		""},

{"scc",		one(0052300),		one(0177700),		"$s"},
{"scs",		one(0052700),		one(0177700),		"$s"},
{"seq",		one(0053700),		one(0177700),		"$s"},
{"sf",		one(0050700),		one(0177700),		"$s"},
{"sge",		one(0056300),		one(0177700),		"$s"},
{"sgt",		one(0057300),		one(0177700),		"$s"},
{"shi",		one(0051300),		one(0177700),		"$s"},
{"sle",		one(0057700),		one(0177700),		"$s"},
{"sls",		one(0051700),		one(0177700),		"$s"},
{"slt",		one(0056700),		one(0177700),		"$s"},
{"smi",		one(0055700),		one(0177700),		"$s"},
{"sne",		one(0053300),		one(0177700),		"$s"},
{"spl",		one(0055300),		one(0177700),		"$s"},
{"st",		one(0050300),		one(0177700),		"$s"},
{"svc",		one(0054300),		one(0177700),		"$s"},
{"svs",		one(0054700),		one(0177700),		"$s"},

{"sbcd",	one(0100400),		one(0170770),		"DsDd"},
{"sbcd",	one(0100410),		one(0170770),		"-s-d"},
{"stop",	one(0047162),		one(0177777),		"#w"},

{"subal",	one(0110700),		one(0170700),		"*lAd"},
{"subaw",	one(0110300),		one(0170700),		"*wAd"},
{"subb",	one(0050400),		one(0170700),		"Qd%s"},	/* subq written as sub */
{"subb",	one(0002000),		one(0177700),		"#b$s"},	/* subi written as sub */
{"subb",	one(0110000),		one(0170700),		";bDd"},	/* subb ? ?,	Dd */
{"subb",	one(0110400),		one(0170700),		"Dd~s"},	/* subb Dd,	? ? */
{"subib",	one(0002000),		one(0177700),		"#b$s"},
{"subil",	one(0002200),		one(0177700),		"#l$s"},
{"subiw",	one(0002100),		one(0177700),		"#w$s"},

{"subl",	one(0050600),		one(0170700),		"Qd%s"},
{"subl",	one(0002200),		one(0177700),		"#l$s"},
{"subl",	one(0110700),		one(0170700),		"*lAd"},
{"subl",	one(0110200),		one(0170700),		"*lDd"},
{"subl",	one(0110600),		one(0170700),		"Dd~s"},

{"subqb",	one(0050400),		one(0170700),		"Qd%s"},
{"subql",	one(0050600),		one(0170700),		"Qd%s"},
{"subqw",	one(0050500),		one(0170700),		"Qd%s"},
{"subw",	one(0050500),		one(0170700),		"Qd%s"},
{"subw",	one(0002100),		one(0177700),		"#w$s"},
{"subw",	one(0110100),		one(0170700),		"*wDd"},
{"subw",	one(0110300),		one(0170700),		"*wAd"},	/* suba written as sub */
{"subw",	one(0110500),		one(0170700),		"Dd~s"},

{"subxb",	one(0110400),		one(0170770),		"DsDd"},	/* subxb Ds,	Dd */
{"subxb",	one(0110410),		one(0170770),		"-s-d"},	/* subxb -(As),	-(Ad) */
{"subxl",	one(0110600),		one(0170770),		"DsDd"},
{"subxl",	one(0110610),		one(0170770),		"-s-d"},
{"subxw",	one(0110500),		one(0170770),		"DsDd"},
{"subxw",	one(0110510),		one(0170770),		"-s-d"},

{"swap",	one(0044100),		one(0177770),		"Ds"},
	
{"tas",		one(0045300),		one(0177700),		"$s"},
{"trap",	one(0047100),		one(0177760),		"Ts"},

{"trapcc",	one(0052374),		one(0177777),		""},
{"trapcs",	one(0052774),		one(0177777),		""},
{"trapeq",	one(0053774),		one(0177777),		""},
{"trapf",	one(0050774),		one(0177777),		""},
{"trapge",	one(0056374),		one(0177777),		""},
{"trapgt",	one(0057374),		one(0177777),		""},
{"traphi",	one(0051374),		one(0177777),		""},
{"traple",	one(0057774),		one(0177777),		""},
{"trapls",	one(0051774),		one(0177777),		""},
{"traplt",	one(0056774),		one(0177777),		""},
{"trapmi",	one(0055774),		one(0177777),		""},
{"trapne",	one(0053374),		one(0177777),		""},
{"trappl",	one(0055374),		one(0177777),		""},
{"trapt",	one(0050374),		one(0177777),		""},
{"trapvc",	one(0054374),		one(0177777),		""},
{"trapvs",	one(0054774),		one(0177777),		""},

{"trapcc.w",	one(0052372),		one(0177777),		"#w"},
{"trapcs.w",	one(0052772),		one(0177777),		"#w"},
{"trapeq.w",	one(0053772),		one(0177777),		"#w"},
{"trapf.w",	one(0050772),		one(0177777),		"#w"},
{"trapge.w",	one(0056372),		one(0177777),		"#w"},
{"trapgt.w",	one(0057372),		one(0177777),		"#w"},
{"traphi.w",	one(0051372),		one(0177777),		"#w"},
{"traple.w",	one(0057772),		one(0177777),		"#w"},
{"trapls.w",	one(0051772),		one(0177777),		"#w"},
{"traplt.w",	one(0056772),		one(0177777),		"#w"},
{"trapmi.w",	one(0055772),		one(0177777),		"#w"},
{"trapne.w",	one(0053372),		one(0177777),		"#w"},
{"trappl.w",	one(0055372),		one(0177777),		"#w"},
{"trapt.w",	one(0050372),		one(0177777),		"#w"},
{"trapvc.w",	one(0054372),		one(0177777),		"#w"},
{"trapvs.w",	one(0054772),		one(0177777),		"#w"},

{"trapcc.l",	one(0052373),		one(0177777),		"#l"},
{"trapcs.l",	one(0052773),		one(0177777),		"#l"},
{"trapeq.l",	one(0053773),		one(0177777),		"#l"},
{"trapf.l",	one(0050773),		one(0177777),		"#l"},
{"trapge.l",	one(0056373),		one(0177777),		"#l"},
{"trapgt.l",	one(0057373),		one(0177777),		"#l"},
{"traphi.l",	one(0051373),		one(0177777),		"#l"},
{"traple.l",	one(0057773),		one(0177777),		"#l"},
{"trapls.l",	one(0051773),		one(0177777),		"#l"},
{"traplt.l",	one(0056773),		one(0177777),		"#l"},
{"trapmi.l",	one(0055773),		one(0177777),		"#l"},
{"trapne.l",	one(0053373),		one(0177777),		"#l"},
{"trappl.l",	one(0055373),		one(0177777),		"#l"},
{"trapt.l",	one(0050373),		one(0177777),		"#l"},
{"trapvc.l",	one(0054373),		one(0177777),		"#l"},
{"trapvs.l",	one(0054773),		one(0177777),		"#l"},

{"trapv",	one(0047166),		one(0177777),		""},

{"tstb",	one(0045000),		one(0177700),		";b"},
{"tstw",	one(0045100),		one(0177700),		"*w"},
{"tstl",	one(0045200),		one(0177700),		"*l"},

{"unlk",	one(0047130),		one(0177770),		"As"},
{"unpk",	one(0100600),		one(0170770),		"DsDd#w"},
{"unpk",	one(0100610),		one(0170770),		"-s-d#w"},

	/* JF floating pt stuff moved down here */

{"fabsb",	two(0xF000, 0x5818),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fabsd",	two(0xF000, 0x5418),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fabsl",	two(0xF000, 0x4018),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fabsp",	two(0xF000, 0x4C18),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fabsp",	two(0xF000, 0x4C18),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fabss",	two(0xF000, 0x4418),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fabsw",	two(0xF000, 0x5018),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fabsx",	two(0xF000, 0x0018),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fabsx",	two(0xF000, 0x4818),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fabsx",	two(0xF000, 0x0018),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fsabsb",	two(0xF000, 0x5858),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fsabsd",	two(0xF000, 0x5458),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fsabsl",	two(0xF000, 0x4058),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fsabsp",	two(0xF000, 0x4C58),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fsabsp",	two(0xF000, 0x4C58),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fsabss",	two(0xF000, 0x4458),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fsabsw",	two(0xF000, 0x5058),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fsabsx",	two(0xF000, 0x0058),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fsabsx",	two(0xF000, 0x4858),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fsabsx",	two(0xF000, 0x0058),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fdabsb",	two(0xF000, 0x585C),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fdabsd",	two(0xF000, 0x545C),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fdabsl",	two(0xF000, 0x405C),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fdabsp",	two(0xF000, 0x4C5C),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fdabsp",	two(0xF000, 0x4C5C),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fdabss",	two(0xF000, 0x445C),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fdabsw",	two(0xF000, 0x505C),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fdabsx",	two(0xF000, 0x005C),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fdabsx",	two(0xF000, 0x485C),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fdabsx",	two(0xF000, 0x005C),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"facosb",	two(0xF000, 0x581C),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"facosd",	two(0xF000, 0x541C),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"facosl",	two(0xF000, 0x401C),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"facosp",	two(0xF000, 0x4C1C),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"facosp",	two(0xF000, 0x4C1C),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"facoss",	two(0xF000, 0x441C),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"facosw",	two(0xF000, 0x501C),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"facosx",	two(0xF000, 0x001C),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"facosx",	two(0xF000, 0x481C),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"facosx",	two(0xF000, 0x001C),	two(0xF1C0, 0xE07F),	"IiFt"},

{"faddb",	two(0xF000, 0x5822),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"faddd",	two(0xF000, 0x5422),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"faddl",	two(0xF000, 0x4022),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"faddp",	two(0xF000, 0x4C22),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"faddp",	two(0xF000, 0x4C22),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fadds",	two(0xF000, 0x4422),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"faddw",	two(0xF000, 0x5022),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"faddx",	two(0xF000, 0x0022),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"faddx",	two(0xF000, 0x4822),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
#ifdef NeXT_MOD
{"faddx",	two(0xF000, 0x0022),	two(0xF1C0, 0xE07F),	"IiFt"},
#else
/* {"faddx",	two(0xF000, 0x0022),	two(0xF1C0, 0xE07F),	"IiFt"}, JF removed */
#endif

{"fsaddb",	two(0xF000, 0x5862),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fsaddd",	two(0xF000, 0x5462),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fsaddl",	two(0xF000, 0x4062),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fsaddp",	two(0xF000, 0x4C62),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fsaddp",	two(0xF000, 0x4C62),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fsadds",	two(0xF000, 0x4462),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fsaddw",	two(0xF000, 0x5062),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fsaddx",	two(0xF000, 0x0062),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fsaddx",	two(0xF000, 0x4862),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fsaddx",	two(0xF000, 0x0062),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fdaddb",	two(0xF000, 0x5866),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fdaddd",	two(0xF000, 0x5466),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fdaddl",	two(0xF000, 0x4066),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fdaddp",	two(0xF000, 0x4C66),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fdaddp",	two(0xF000, 0x4C66),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fdadds",	two(0xF000, 0x4466),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fdaddw",	two(0xF000, 0x5066),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fdaddx",	two(0xF000, 0x0066),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fdaddx",	two(0xF000, 0x4866),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fdaddx",	two(0xF000, 0x0066),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fasinb",	two(0xF000, 0x580C),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fasind",	two(0xF000, 0x540C),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fasinl",	two(0xF000, 0x400C),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fasinp",	two(0xF000, 0x4C0C),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fasinp",	two(0xF000, 0x4C0C),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fasins",	two(0xF000, 0x440C),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fasinw",	two(0xF000, 0x500C),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fasinx",	two(0xF000, 0x000C),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fasinx",	two(0xF000, 0x480C),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fasinx",	two(0xF000, 0x000C),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fatanb",	two(0xF000, 0x580A),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fatand",	two(0xF000, 0x540A),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fatanl",	two(0xF000, 0x400A),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fatanp",	two(0xF000, 0x4C0A),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fatanp",	two(0xF000, 0x4C0A),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fatans",	two(0xF000, 0x440A),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fatanw",	two(0xF000, 0x500A),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fatanx",	two(0xF000, 0x000A),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fatanx",	two(0xF000, 0x480A),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fatanx",	two(0xF000, 0x000A),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fatanhb",	two(0xF000, 0x580D),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fatanhd",	two(0xF000, 0x540D),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fatanhl",	two(0xF000, 0x400D),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fatanhp",	two(0xF000, 0x4C0D),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fatanhp",	two(0xF000, 0x4C0D),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fatanhs",	two(0xF000, 0x440D),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fatanhw",	two(0xF000, 0x500D),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fatanhx",	two(0xF000, 0x000D),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fatanhx",	two(0xF000, 0x480D),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fatanhx",	two(0xF000, 0x000D),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fbeq",	one(0xF081),		one(0xF1BF),		"IdBc"},
{"fbf",		one(0xF080),		one(0xF1BF),		"IdBc"},
{"fbge",	one(0xF093),		one(0xF1BF),		"IdBc"},
{"fbgl",	one(0xF096),		one(0xF1BF),		"IdBc"},
{"fbgle",	one(0xF097),		one(0xF1BF),		"IdBc"},
{"fbgt",	one(0xF092),		one(0xF1BF),		"IdBc"},
{"fble",	one(0xF095),		one(0xF1BF),		"IdBc"},
{"fblt",	one(0xF094),		one(0xF1BF),		"IdBc"},
{"fbne",	one(0xF08E),		one(0xF1BF),		"IdBc"},
{"fbnge",	one(0xF09C),		one(0xF1BF),		"IdBc"},
{"fbngl",	one(0xF099),		one(0xF1BF),		"IdBc"},
{"fbngle",	one(0xF098),		one(0xF1BF),		"IdBc"},
{"fbngt",	one(0xF09D),		one(0xF1BF),		"IdBc"},
{"fbnle",	one(0xF09A),		one(0xF1BF),		"IdBc"},
{"fbnlt",	one(0xF09B),		one(0xF1BF),		"IdBc"},
{"fboge",	one(0xF083),		one(0xF1BF),		"IdBc"},
{"fbogl",	one(0xF086),		one(0xF1BF),		"IdBc"},
{"fbogt",	one(0xF082),		one(0xF1BF),		"IdBc"},
{"fbole",	one(0xF085),		one(0xF1BF),		"IdBc"},
{"fbolt",	one(0xF084),		one(0xF1BF),		"IdBc"},
{"fbor",	one(0xF087),		one(0xF1BF),		"IdBc"},
{"fbseq",	one(0xF091),		one(0xF1BF),		"IdBc"},
{"fbsf",	one(0xF090),		one(0xF1BF),		"IdBc"},
{"fbsne",	one(0xF09E),		one(0xF1BF),		"IdBc"},
{"fbst",	one(0xF09F),		one(0xF1BF),		"IdBc"},
{"fbt",		one(0xF08F),		one(0xF1BF),		"IdBc"},
{"fbueq",	one(0xF089),		one(0xF1BF),		"IdBc"},
{"fbuge",	one(0xF08B),		one(0xF1BF),		"IdBc"},
{"fbugt",	one(0xF08A),		one(0xF1BF),		"IdBc"},
{"fbule",	one(0xF08D),		one(0xF1BF),		"IdBc"},
{"fbult",	one(0xF08C),		one(0xF1BF),		"IdBc"},
{"fbun",	one(0xF088),		one(0xF1BF),		"IdBc"},

{"fcmpb",	two(0xF000, 0x5838),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fcmpd",	two(0xF000, 0x5438),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fcmpl",	two(0xF000, 0x4038),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fcmpp",	two(0xF000, 0x4C38),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fcmpp",	two(0xF000, 0x4C38),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fcmps",	two(0xF000, 0x4438),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fcmpw",	two(0xF000, 0x5038),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fcmpx",	two(0xF000, 0x0038),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fcmpx",	two(0xF000, 0x4838),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
#ifdef NeXT_MOD
{"fcmpx",	two(0xF000, 0x0038),	two(0xF1C0, 0xE07F),	"IiFt"},
#else
/* {"fcmpx",	two(0xF000, 0x0038),	two(0xF1C0, 0xE07F),	"IiFt"}, JF removed */
#endif

{"fcosb",	two(0xF000, 0x581D),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fcosd",	two(0xF000, 0x541D),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fcosl",	two(0xF000, 0x401D),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fcosp",	two(0xF000, 0x4C1D),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fcosp",	two(0xF000, 0x4C1D),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fcoss",	two(0xF000, 0x441D),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fcosw",	two(0xF000, 0x501D),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fcosx",	two(0xF000, 0x001D),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fcosx",	two(0xF000, 0x481D),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fcosx",	two(0xF000, 0x001D),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fcoshb",	two(0xF000, 0x5819),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fcoshd",	two(0xF000, 0x5419),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fcoshl",	two(0xF000, 0x4019),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fcoshp",	two(0xF000, 0x4C19),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fcoshp",	two(0xF000, 0x4C19),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fcoshs",	two(0xF000, 0x4419),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fcoshw",	two(0xF000, 0x5019),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fcoshx",	two(0xF000, 0x0019),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fcoshx",	two(0xF000, 0x4819),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fcoshx",	two(0xF000, 0x0019),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fdbeq",	two(0xF048, 0x0001),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbf",	two(0xF048, 0x0000),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbge",	two(0xF048, 0x0013),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbgl",	two(0xF048, 0x0016),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbgle",	two(0xF048, 0x0017),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbgt",	two(0xF048, 0x0012),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdble",	two(0xF048, 0x0015),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdblt",	two(0xF048, 0x0014),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbne",	two(0xF048, 0x000E),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbnge",	two(0xF048, 0x001C),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbngl",	two(0xF048, 0x0019),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbngle",	two(0xF048, 0x0018),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbngt",	two(0xF048, 0x001D),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbnle",	two(0xF048, 0x001A),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbnlt",	two(0xF048, 0x001B),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdboge",	two(0xF048, 0x0003),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbogl",	two(0xF048, 0x0006),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbogt",	two(0xF048, 0x0002),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbole",	two(0xF048, 0x0005),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbolt",	two(0xF048, 0x0004),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbor",	two(0xF048, 0x0007),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbseq",	two(0xF048, 0x0011),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbsf",	two(0xF048, 0x0010),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbsne",	two(0xF048, 0x001E),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbst",	two(0xF048, 0x001F),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbt",	two(0xF048, 0x000F),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbueq",	two(0xF048, 0x0009),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbuge",	two(0xF048, 0x000B),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbugt",	two(0xF048, 0x000A),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbule",	two(0xF048, 0x000D),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbult",	two(0xF048, 0x000C),	two(0xF1F8, 0xFFFF),	"IiDsBw"},
{"fdbun",	two(0xF048, 0x0008),	two(0xF1F8, 0xFFFF),	"IiDsBw"},

{"fdivb",	two(0xF000, 0x5820),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fdivd",	two(0xF000, 0x5420),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fdivl",	two(0xF000, 0x4020),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fdivp",	two(0xF000, 0x4C20),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fdivp",	two(0xF000, 0x4C20),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fdivs",	two(0xF000, 0x4420),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fdivw",	two(0xF000, 0x5020),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fdivx",	two(0xF000, 0x0020),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fdivx",	two(0xF000, 0x4820),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
#ifdef NeXT_MOD
{"fdivx",	two(0xF000, 0x0020),	two(0xF1C0, 0xE07F),	"IiFt"},
#else
/* {"fdivx",	two(0xF000, 0x0020),	two(0xF1C0, 0xE07F),	"IiFt"}, JF */
#endif

{"fsdivb",	two(0xF000, 0x5860),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fsdivd",	two(0xF000, 0x5460),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fsdivl",	two(0xF000, 0x4060),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fsdivp",	two(0xF000, 0x4C60),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fsdivp",	two(0xF000, 0x4C60),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fsdivs",	two(0xF000, 0x4460),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fsdivw",	two(0xF000, 0x5060),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fsdivx",	two(0xF000, 0x0060),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fsdivx",	two(0xF000, 0x4860),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fsdivx",	two(0xF000, 0x0060),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fddivb",	two(0xF000, 0x5864),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fddivd",	two(0xF000, 0x5464),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fddivl",	two(0xF000, 0x4064),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fddivp",	two(0xF000, 0x4C64),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fddivp",	two(0xF000, 0x4C64),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fddivs",	two(0xF000, 0x4464),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fddivw",	two(0xF000, 0x5064),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fddivx",	two(0xF000, 0x0064),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fddivx",	two(0xF000, 0x4864),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fddivx",	two(0xF000, 0x0064),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fetoxb",	two(0xF000, 0x5810),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fetoxd",	two(0xF000, 0x5410),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fetoxl",	two(0xF000, 0x4010),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fetoxp",	two(0xF000, 0x4C10),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fetoxp",	two(0xF000, 0x4C10),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fetoxs",	two(0xF000, 0x4410),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fetoxw",	two(0xF000, 0x5010),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fetoxx",	two(0xF000, 0x0010),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fetoxx",	two(0xF000, 0x4810),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fetoxx",	two(0xF000, 0x0010),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fetoxm1b",	two(0xF000, 0x5808),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fetoxm1d",	two(0xF000, 0x5408),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fetoxm1l",	two(0xF000, 0x4008),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fetoxm1p",	two(0xF000, 0x4C08),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fetoxm1p",	two(0xF000, 0x4C08),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fetoxm1s",	two(0xF000, 0x4408),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fetoxm1w",	two(0xF000, 0x5008),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fetoxm1x",	two(0xF000, 0x0008),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fetoxm1x",	two(0xF000, 0x4808),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fetoxm1x",	two(0xF000, 0x0008),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fgetexpb",	two(0xF000, 0x581E),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fgetexpd",	two(0xF000, 0x541E),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fgetexpl",	two(0xF000, 0x401E),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fgetexpp",	two(0xF000, 0x4C1E),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fgetexpp",	two(0xF000, 0x4C1E),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fgetexps",	two(0xF000, 0x441E),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fgetexpw",	two(0xF000, 0x501E),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fgetexpx",	two(0xF000, 0x001E),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fgetexpx",	two(0xF000, 0x481E),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fgetexpx",	two(0xF000, 0x001E),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fgetmanb",	two(0xF000, 0x581F),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fgetmand",	two(0xF000, 0x541F),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fgetmanl",	two(0xF000, 0x401F),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fgetmanp",	two(0xF000, 0x4C1F),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fgetmanp",	two(0xF000, 0x4C1F),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fgetmans",	two(0xF000, 0x441F),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fgetmanw",	two(0xF000, 0x501F),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fgetmanx",	two(0xF000, 0x001F),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fgetmanx",	two(0xF000, 0x481F),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fgetmanx",	two(0xF000, 0x001F),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fintb",	two(0xF000, 0x5801),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fintd",	two(0xF000, 0x5401),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fintl",	two(0xF000, 0x4001),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fintp",	two(0xF000, 0x4C01),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fintp",	two(0xF000, 0x4C01),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fints",	two(0xF000, 0x4401),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fintw",	two(0xF000, 0x5001),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fintx",	two(0xF000, 0x0001),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fintx",	two(0xF000, 0x4801),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fintx",	two(0xF000, 0x0001),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fintrzb",	two(0xF000, 0x5803),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fintrzd",	two(0xF000, 0x5403),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fintrzl",	two(0xF000, 0x4003),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fintrzp",	two(0xF000, 0x4C03),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fintrzp",	two(0xF000, 0x4C03),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fintrzs",	two(0xF000, 0x4403),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fintrzw",	two(0xF000, 0x5003),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fintrzx",	two(0xF000, 0x0003),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fintrzx",	two(0xF000, 0x4803),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fintrzx",	two(0xF000, 0x0003),	two(0xF1C0, 0xE07F),	"IiFt"},

{"flog10b",	two(0xF000, 0x5815),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"flog10d",	two(0xF000, 0x5415),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"flog10l",	two(0xF000, 0x4015),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"flog10p",	two(0xF000, 0x4C15),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"flog10p",	two(0xF000, 0x4C15),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"flog10s",	two(0xF000, 0x4415),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"flog10w",	two(0xF000, 0x5015),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"flog10x",	two(0xF000, 0x0015),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"flog10x",	two(0xF000, 0x4815),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"flog10x",	two(0xF000, 0x0015),	two(0xF1C0, 0xE07F),	"IiFt"},

{"flog2b",	two(0xF000, 0x5816),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"flog2d",	two(0xF000, 0x5416),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"flog2l",	two(0xF000, 0x4016),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"flog2p",	two(0xF000, 0x4C16),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"flog2p",	two(0xF000, 0x4C16),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"flog2s",	two(0xF000, 0x4416),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"flog2w",	two(0xF000, 0x5016),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"flog2x",	two(0xF000, 0x0016),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"flog2x",	two(0xF000, 0x4816),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"flog2x",	two(0xF000, 0x0016),	two(0xF1C0, 0xE07F),	"IiFt"},

{"flognb",	two(0xF000, 0x5814),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"flognd",	two(0xF000, 0x5414),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"flognl",	two(0xF000, 0x4014),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"flognp",	two(0xF000, 0x4C14),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"flognp",	two(0xF000, 0x4C14),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"flogns",	two(0xF000, 0x4414),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"flognw",	two(0xF000, 0x5014),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"flognx",	two(0xF000, 0x0014),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"flognx",	two(0xF000, 0x4814),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"flognx",	two(0xF000, 0x0014),	two(0xF1C0, 0xE07F),	"IiFt"},

{"flognp1b",	two(0xF000, 0x5806),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"flognp1d",	two(0xF000, 0x5406),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"flognp1l",	two(0xF000, 0x4006),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"flognp1p",	two(0xF000, 0x4C06),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"flognp1p",	two(0xF000, 0x4C06),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"flognp1s",	two(0xF000, 0x4406),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"flognp1w",	two(0xF000, 0x5006),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"flognp1x",	two(0xF000, 0x0006),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"flognp1x",	two(0xF000, 0x4806),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"flognp1x",	two(0xF000, 0x0006),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fmodb",	two(0xF000, 0x5821),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fmodd",	two(0xF000, 0x5421),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fmodl",	two(0xF000, 0x4021),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fmodp",	two(0xF000, 0x4C21),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fmodp",	two(0xF000, 0x4C21),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fmods",	two(0xF000, 0x4421),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fmodw",	two(0xF000, 0x5021),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fmodx",	two(0xF000, 0x0021),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fmodx",	two(0xF000, 0x4821),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
#ifdef NeXT_MOD
{"fmodx",	two(0xF000, 0x0021),	two(0xF1C0, 0xE07F),	"IiFt"},
#else
/* {"fmodx",	two(0xF000, 0x0021),	two(0xF1C0, 0xE07F),	"IiFt"}, JF */
#endif

{"fmoveb",	two(0xF000, 0x5800),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},	/* fmove from <ea> to fp<n> */
{"fmoveb",	two(0xF000, 0x7800),	two(0xF1C0, 0xFC7F),	"IiF7@b"},	/* fmove from fp<n> to <ea> */
{"fmoved",	two(0xF000, 0x5400),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},	/* fmove from <ea> to fp<n> */
{"fmoved",	two(0xF000, 0x7400),	two(0xF1C0, 0xFC7F),	"IiF7@F"},	/* fmove from fp<n> to <ea> */
{"fmovel",	two(0xF000, 0x4000),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},	/* fmove from <ea> to fp<n> */
{"fmovel",	two(0xF000, 0x6000),	two(0xF1C0, 0xFC7F),	"IiF7@l"},	/* fmove from fp<n> to <ea> */
/* Warning:  The addressing modes on these are probably not right:
   esp, Areg direct is only allowed for FPI */
		/* fmove.l from/to system control registers: */
{"fmovel",	two(0xF000, 0xA000),	two(0xF1C0, 0xE3FF),	"Iis8@s"},
{"fmovel",	two(0xF000, 0x8000),	two(0xF1C0, 0xE3FF),	"Ii*ls8"},

/* {"fmovel",	two(0xF000, 0xA000),	two(0xF1C0, 0xE3FF),	"Iis8@s"},
{"fmovel",	two(0xF000, 0x8000),	two(0xF2C0, 0xE3FF),	"Ii*ss8"}, */

#ifdef PACKED_IMMEDIATE
{"fmovep",	two(0xF000, 0x4C00),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},	/* fmove from <ea> to fp<n> */
#else
{"fmovep",	two(0xF000, 0x4C00),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},	/* fmove from <ea> to fp<n> */
#endif
{"fmovep",	two(0xF000, 0x6C00),	two(0xF1C0, 0xFC00),	"IiF7@pkC"},	/* fmove.p with k-factors: */
{"fmovep",	two(0xF000, 0x7C00),	two(0xF1C0, 0xFC0F),	"IiF7@pDk"},	/* fmove.p with k-factors: */

{"fmoves",	two(0xF000, 0x4400),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},	/* fmove from <ea> to fp<n> */
{"fmoves",	two(0xF000, 0x6400),	two(0xF1C0, 0xFC7F),	"IiF7@f"},	/* fmove from fp<n> to <ea> */
{"fmovew",	two(0xF000, 0x5000),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},	/* fmove from <ea> to fp<n> */
{"fmovew",	two(0xF000, 0x7000),	two(0xF1C0, 0xFC7F),	"IiF7@w"},	/* fmove from fp<n> to <ea> */
{"fmovex",	two(0xF000, 0x0000),	two(0xF1C0, 0xE07F),	"IiF8F7"},	/* fmove from <ea> to fp<n> */
{"fmovex",	two(0xF000, 0x4800),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},	/* fmove from <ea> to fp<n> */
{"fmovex",	two(0xF000, 0x6800),	two(0xF1C0, 0xFC7F),	"IiF7@x"},	/* fmove from fp<n> to <ea> */
#ifdef NeXT_MOD
{"fmovex",	two(0xF000, 0x0000),	two(0xF1C0, 0xE07F),	"IiFt"},	/* fmove from <ea> to fp<n> */
#else
/* JF removed {"fmovex",	two(0xF000, 0x0000),	two(0xF1C0, 0xE07F),	"IiFt"},	/ * fmove from <ea> to fp<n> */
#endif

{"fsmoveb",	two(0xF000, 0x5840),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fsmoved",	two(0xF000, 0x5440),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fsmovel",	two(0xF000, 0x4040),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fsmovep",	two(0xF000, 0x4C40),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fsmovep",	two(0xF000, 0x4C40),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fsmoves",	two(0xF000, 0x4440),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fsmovew",	two(0xF000, 0x5040),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fsmovex",	two(0xF000, 0x0040),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fsmovex",	two(0xF000, 0x4840),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fsmovex",	two(0xF000, 0x0040),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fdmoveb",	two(0xF000, 0x5844),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fdmoved",	two(0xF000, 0x5444),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fdmovel",	two(0xF000, 0x4044),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fdmovep",	two(0xF000, 0x4C44),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fdmovep",	two(0xF000, 0x4C44),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fdmoves",	two(0xF000, 0x4444),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fdmovew",	two(0xF000, 0x5044),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fdmovex",	two(0xF000, 0x0044),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fdmovex",	two(0xF000, 0x4844),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fdmovex",	two(0xF000, 0x0044),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fmovecrx",	two(0xF000, 0x5C00),	two(0xF1FF, 0xFC00),	"Ii#CF7"},	/* fmovecr.x #ccc,	FPn */
{"fmovecr",	two(0xF000, 0x5C00),	two(0xF1FF, 0xFC00),	"Ii#CF7"},

/* Other fmovemx.  */
{"fmovemx",	two(0xF020, 0xE000),	two(0xF1F8, 0xFF00),	"Id#3-s"},	/* fmovem.x to autodecrement, static and dynamic */
{"fmovemx",	two(0xF020, 0xE800),	two(0xF1F8, 0xFF8F),	"IiDk-s"},	/* fmovem.x to autodecrement, static and dynamic */

{"fmovemx",	two(0xF000, 0xF000),	two(0xF1C0, 0xFF00),	"Id#3&s"},	/* fmovem.x to control,	static and dynamic: */
{"fmovemx",	two(0xF000, 0xF800),	two(0xF1C0, 0xFF8F),	"IiDk&s"},	/* fmovem.x to control,	static and dynamic: */

{"fmovemx",	two(0xF018, 0xD000),	two(0xF1F8, 0xFF00),	"Id+s#3"},	/* fmovem.x from autoincrement, static and dynamic: */
{"fmovemx",	two(0xF018, 0xD800),	two(0xF1F8, 0xFF8F),	"Ii+sDk"},	/* fmovem.x from autoincrement, static and dynamic: */

{"fmovemx",	two(0xF000, 0xD000),	two(0xF1C0, 0xFF00),	"Id&s#3"},	/* fmovem.x from control, static and dynamic: */
{"fmovemx",	two(0xF000, 0xD800),	two(0xF1C0, 0xFF8F),	"Ii&sDk"},	/* fmovem.x from control, static and dynamic: */

#ifdef NeXT_MOD
/* These four must be the last fmovemx's.  See the comment above with the
   header "REGISTER LIST BUG:" */
#endif
{"fmovemx",	two(0xF020, 0xE000),	two(0xF1F8, 0xFF00),	"IdL3-s"},	/* fmovem.x to autodecrement, static and dynamic */
{"fmovemx",	two(0xF000, 0xF000),	two(0xF1C0, 0xFF00),	"Idl3&s"},	/* fmovem.x to control,	static and dynamic: */
{"fmovemx",	two(0xF018, 0xD000),	two(0xF1F8, 0xFF00),	"Id+sl3"},	/* fmovem.x from autoincrement,	static and dynamic: */
{"fmovemx",	two(0xF000, 0xD000),	two(0xF1C0, 0xFF00),	"Id&sl3"},	/* fmovem.x from control, static and dynamic: */

{"fmoveml",	two(0xF000, 0xA000),	two(0xF1C0, 0xE3FF),	"IiL8@s"},
{"fmoveml",	two(0xF000, 0xA000),	two(0xF1C0, 0xE3FF),	"Ii#8@s"},
{"fmoveml",	two(0xF000, 0xA000),	two(0xF1C0, 0xE3FF),	"Iis8@s"},

{"fmoveml",	two(0xF000, 0x8000),	two(0xF2C0, 0xE3FF),	"Ii*sL8"},
{"fmoveml",	two(0xF000, 0x8000),	two(0xF1C0, 0xE3FF),	"Ii*s#8"},
{"fmoveml",	two(0xF000, 0x8000),	two(0xF1C0, 0xE3FF),	"Ii*ss8"},

	/* Alternate mnemonics for GNU CC */
{"fmovem",	two(0xF020, 0xE000),	two(0xF1F8, 0xFF00),	"Id#3-s"},	/* fmovem.x to autodecrement, static and dynamic */
{"fmovem",	two(0xF020, 0xE800),	two(0xF1F8, 0xFF8F),	"IiDk-s"},	/* fmovem.x to autodecrement, static and dynamic */

{"fmovem",	two(0xF000, 0xF000),	two(0xF1C0, 0xFF00),	"Id#3&s"},	/* fmovem.x to control, static and dynamic: */
{"fmovem",	two(0xF000, 0xF800),	two(0xF1C0, 0xFF8F),	"IiDk&s"},	/* fmovem.x to control, static and dynamic: */

{"fmovem",	two(0xF018, 0xD000),	two(0xF1F8, 0xFF00),	"Id+s#3"},	/* fmovem.x from autoincrement, static and dynamic: */
{"fmovem",	two(0xF018, 0xD800),	two(0xF1F8, 0xFF8F),	"Ii+sDk"},	/* fmovem.x from autoincrement, static and dynamic: */
  
{"fmovem",	two(0xF000, 0xD000),	two(0xF1C0, 0xFF00),	"Id&s#3"},	/* fmovem.x from control, static and dynamic: */
{"fmovem",	two(0xF000, 0xD800),	two(0xF1C0, 0xFF8F),	"Ii&sDk"},	/* fmovem.x from control, static and dynamic: */

/* fmoveml a FP-control register */
{"fmovem",	two(0xF000, 0xA000),	two(0xF1C0, 0xE3FF),	"Iis8@s"},
{"fmovem",	two(0xF000, 0x8000),	two(0xF1C0, 0xE3FF),	"Ii*ss8"},

/* fmoveml a FP-control reglist */
{"fmovem",	two(0xF000, 0xA000),	two(0xF1C0, 0xE3FF),	"IiL8@s"},
{"fmovem",	two(0xF000, 0x8000),	two(0xF2C0, 0xE3FF),	"Ii*sL8"},

#ifdef NeXT_MOD
/* These four must be the last fmovem's.  See the comment above with the
   header "REGISTER LIST BUG:" */
#endif
/* fmovemx with register lists */
{"fmovem",	two(0xF020, 0xE000),	two(0xF1F8, 0xFF00),	"IdL3-s"},	/* fmovem.x to autodecrement, static and dynamic */
{"fmovem",	two(0xF000, 0xF000),	two(0xF1C0, 0xFF00),	"Idl3&s"},	/* fmovem.x to control, static and dynamic: */
{"fmovem",	two(0xF018, 0xD000),	two(0xF1F8, 0xFF00),	"Id+sl3"},	/* fmovem.x from autoincrement, static and dynamic: */
{"fmovem",	two(0xF000, 0xD000),	two(0xF1C0, 0xFF00),	"Id&sl3"},	/* fmovem.x from control, static and dynamic: */

{"fmulb",	two(0xF000, 0x5823),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fmuld",	two(0xF000, 0x5423),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fmull",	two(0xF000, 0x4023),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fmulp",	two(0xF000, 0x4C23),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fmulp",	two(0xF000, 0x4C23),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fmuls",	two(0xF000, 0x4423),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fmulw",	two(0xF000, 0x5023),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fmulx",	two(0xF000, 0x0023),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fmulx",	two(0xF000, 0x4823),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
#ifdef NeXT_MOD
{"fmulx",	two(0xF000, 0x0023),	two(0xF1C0, 0xE07F),	"IiFt"},
#else
/* {"fmulx",	two(0xF000, 0x0023),	two(0xF1C0, 0xE07F),	"IiFt"}, JF */
#endif

{"fsmulb",	two(0xF000, 0x5863),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fsmuld",	two(0xF000, 0x5463),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fsmull",	two(0xF000, 0x4063),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fsmulp",	two(0xF000, 0x4C63),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fsmulp",	two(0xF000, 0x4C63),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fsmuls",	two(0xF000, 0x4463),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fsmulw",	two(0xF000, 0x5063),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fsmulx",	two(0xF000, 0x0063),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fsmulx",	two(0xF000, 0x4863),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fsmulx",	two(0xF000, 0x0063),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fdmulb",	two(0xF000, 0x5867),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fdmuld",	two(0xF000, 0x5467),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fdmull",	two(0xF000, 0x4067),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fdmulp",	two(0xF000, 0x4C67),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fdmulp",	two(0xF000, 0x4C67),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fdmuls",	two(0xF000, 0x4467),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fdmulw",	two(0xF000, 0x5067),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fdmulx",	two(0xF000, 0x0067),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fdmulx",	two(0xF000, 0x4867),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fdmulx",	two(0xF000, 0x0067),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fnegb",	two(0xF000, 0x581A),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fnegd",	two(0xF000, 0x541A),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fnegl",	two(0xF000, 0x401A),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fnegp",	two(0xF000, 0x4C1A),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fnegp",	two(0xF000, 0x4C1A),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fnegs",	two(0xF000, 0x441A),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fnegw",	two(0xF000, 0x501A),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fnegx",	two(0xF000, 0x001A),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fnegx",	two(0xF000, 0x481A),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fnegx",	two(0xF000, 0x001A),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fsnegb",	two(0xF000, 0x585A),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fsnegd",	two(0xF000, 0x545A),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fsnegl",	two(0xF000, 0x405A),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fsnegp",	two(0xF000, 0x4C5A),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fsnegp",	two(0xF000, 0x4C5A),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fsnegs",	two(0xF000, 0x445A),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fsnegw",	two(0xF000, 0x505A),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fsnegx",	two(0xF000, 0x005A),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fsnegx",	two(0xF000, 0x485A),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fsnegx",	two(0xF000, 0x005A),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fdnegb",	two(0xF000, 0x585E),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fdnegd",	two(0xF000, 0x545E),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fdnegl",	two(0xF000, 0x405E),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fdnegp",	two(0xF000, 0x4C5E),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fdnegp",	two(0xF000, 0x4C5E),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fdnegs",	two(0xF000, 0x445E),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fdnegw",	two(0xF000, 0x505E),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fdnegx",	two(0xF000, 0x005E),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fdnegx",	two(0xF000, 0x485E),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fdnegx",	two(0xF000, 0x005E),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fnop",	two(0xF280, 0x0000),	two(0xFFFF, 0xFFFF),	"Ii"},

{"fremb",	two(0xF000, 0x5825),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fremd",	two(0xF000, 0x5425),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"freml",	two(0xF000, 0x4025),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fremp",	two(0xF000, 0x4C25),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fremp",	two(0xF000, 0x4C25),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"frems",	two(0xF000, 0x4425),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fremw",	two(0xF000, 0x5025),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fremx",	two(0xF000, 0x0025),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fremx",	two(0xF000, 0x4825),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
#ifdef NeXT_MOD
{"fremx",	two(0xF000, 0x0025),	two(0xF1C0, 0xE07F),	"IiFt"},
#else
/* {"fremx",	two(0xF000, 0x0025),	two(0xF1C0, 0xE07F),	"IiFt"}, JF */
#endif

{"frestore",	one(0xF140),		one(0xF1C0),		"Id&s"},
{"frestore",	one(0xF158),		one(0xF1F8),		"Id+s"},
{"fsave",	one(0xF100),		one(0xF1C0),		"Id&s"},
{"fsave",	one(0xF120),		one(0xF1F8),		"Id-s"},

{"fsincosb",	two(0xF000, 0x5830),	two(0xF1C0, 0xFC78),	"Ii;bFCF7"},
{"fsincosd",	two(0xF000, 0x5430),	two(0xF1C0, 0xFC78),	"Ii;FFCF7"},
{"fsincosl",	two(0xF000, 0x4030),	two(0xF1C0, 0xFC78),	"Ii;lFCF7"},
#ifdef PACKED_IMMEDIATE
{"fsincosp",	two(0xF000, 0x4C30),	two(0xF1C0, 0xFC78),	"Ii;pFCF7"},
#else
{"fsincosp",	two(0xF000, 0x4C30),	two(0xF1C0, 0xFC78),	"Ii@pFCF7"},
#endif
{"fsincoss",	two(0xF000, 0x4430),	two(0xF1C0, 0xFC78),	"Ii;fFCF7"},
{"fsincosw",	two(0xF000, 0x5030),	two(0xF1C0, 0xFC78),	"Ii;wFCF7"},
{"fsincosx",	two(0xF000, 0x0030),	two(0xF1C0, 0xE078),	"IiF8FCF7"},
{"fsincosx",	two(0xF000, 0x4830),	two(0xF1C0, 0xFC78),	"Ii;xFCF7"},

{"fscaleb",	two(0xF000, 0x5826),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fscaled",	two(0xF000, 0x5426),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fscalel",	two(0xF000, 0x4026),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fscalep",	two(0xF000, 0x4C26),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fscalep",	two(0xF000, 0x4C26),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fscales",	two(0xF000, 0x4426),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fscalew",	two(0xF000, 0x5026),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fscalex",	two(0xF000, 0x0026),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fscalex",	two(0xF000, 0x4826),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
#ifdef NeXT_MOD
{"fscalex",	two(0xF000, 0x0026),	two(0xF1C0, 0xE07F),	"IiFt"},
#else
/* {"fscalex",	two(0xF000, 0x0026),	two(0xF1C0, 0xE07F),	"IiFt"}, JF */
#endif

/* $ is necessary to prevent the assembler from using PC-relative.
   If @ were used, "label: fseq label" could produce "ftrapeq",
   because "label" became "pc@label".  */
{"fseq",	two(0xF040, 0x0001),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsf",		two(0xF040, 0x0000),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsge",	two(0xF040, 0x0013),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsgl",	two(0xF040, 0x0016),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsgle",	two(0xF040, 0x0017),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsgt",	two(0xF040, 0x0012),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsle",	two(0xF040, 0x0015),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fslt",	two(0xF040, 0x0014),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsne",	two(0xF040, 0x000E),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsnge",	two(0xF040, 0x001C),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsngl",	two(0xF040, 0x0019),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsngle",	two(0xF040, 0x0018),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsngt",	two(0xF040, 0x001D),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsnle",	two(0xF040, 0x001A),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsnlt",	two(0xF040, 0x001B),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsoge",	two(0xF040, 0x0003),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsogl",	two(0xF040, 0x0006),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsogt",	two(0xF040, 0x0002),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsole",	two(0xF040, 0x0005),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsolt",	two(0xF040, 0x0004),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsor",	two(0xF040, 0x0007),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsseq",	two(0xF040, 0x0011),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fssf",	two(0xF040, 0x0010),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fssne",	two(0xF040, 0x001E),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsst",	two(0xF040, 0x001F),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fst",		two(0xF040, 0x000F),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsueq",	two(0xF040, 0x0009),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsuge",	two(0xF040, 0x000B),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsugt",	two(0xF040, 0x000A),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsule",	two(0xF040, 0x000D),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsult",	two(0xF040, 0x000C),	two(0xF1C0, 0xFFFF),	"Ii$s"},
{"fsun",	two(0xF040, 0x0008),	two(0xF1C0, 0xFFFF),	"Ii$s"},

{"fsgldivb",	two(0xF000, 0x5824),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fsgldivd",	two(0xF000, 0x5424),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fsgldivl",	two(0xF000, 0x4024),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fsgldivp",	two(0xF000, 0x4C24),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fsgldivp",	two(0xF000, 0x4C24),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fsgldivs",	two(0xF000, 0x4424),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fsgldivw",	two(0xF000, 0x5024),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fsgldivx",	two(0xF000, 0x0024),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fsgldivx",	two(0xF000, 0x4824),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fsgldivx",	two(0xF000, 0x0024),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fsglmulb",	two(0xF000, 0x5827),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fsglmuld",	two(0xF000, 0x5427),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fsglmull",	two(0xF000, 0x4027),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fsglmulp",	two(0xF000, 0x4C27),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fsglmulp",	two(0xF000, 0x4C27),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fsglmuls",	two(0xF000, 0x4427),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fsglmulw",	two(0xF000, 0x5027),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fsglmulx",	two(0xF000, 0x0027),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fsglmulx",	two(0xF000, 0x4827),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fsglmulx",	two(0xF000, 0x0027),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fsinb",	two(0xF000, 0x580E),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fsind",	two(0xF000, 0x540E),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fsinl",	two(0xF000, 0x400E),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fsinp",	two(0xF000, 0x4C0E),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fsinp",	two(0xF000, 0x4C0E),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fsins",	two(0xF000, 0x440E),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fsinw",	two(0xF000, 0x500E),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fsinx",	two(0xF000, 0x000E),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fsinx",	two(0xF000, 0x480E),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fsinx",	two(0xF000, 0x000E),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fsinhb",	two(0xF000, 0x5802),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fsinhd",	two(0xF000, 0x5402),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fsinhl",	two(0xF000, 0x4002),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fsinhp",	two(0xF000, 0x4C02),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fsinhp",	two(0xF000, 0x4C02),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fsinhs",	two(0xF000, 0x4402),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fsinhw",	two(0xF000, 0x5002),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fsinhx",	two(0xF000, 0x0002),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fsinhx",	two(0xF000, 0x4802),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fsinhx",	two(0xF000, 0x0002),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fsqrtb",	two(0xF000, 0x5804),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fsqrtd",	two(0xF000, 0x5404),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fsqrtl",	two(0xF000, 0x4004),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fsqrtp",	two(0xF000, 0x4C04),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fsqrtp",	two(0xF000, 0x4C04),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fsqrts",	two(0xF000, 0x4404),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fsqrtw",	two(0xF000, 0x5004),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fsqrtx",	two(0xF000, 0x0004),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fsqrtx",	two(0xF000, 0x4804),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fsqrtx",	two(0xF000, 0x0004),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fssqrtb",	two(0xF000, 0x5841),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fssqrtd",	two(0xF000, 0x5441),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fssqrtl",	two(0xF000, 0x4041),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fssqrtp",	two(0xF000, 0x4C41),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fssqrtp",	two(0xF000, 0x4C41),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fssqrts",	two(0xF000, 0x4441),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fssqrtw",	two(0xF000, 0x5041),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fssqrtx",	two(0xF000, 0x4841),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fssqrt",	two(0xF000, 0x0041),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fssqrt",	two(0xF000, 0x0041),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fdsqrtb",	two(0xF000, 0x5845),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fdsqrtd",	two(0xF000, 0x5445),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fdsqrtl",	two(0xF000, 0x4045),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fdsqrtp",	two(0xF000, 0x4C45),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fdsqrtp",	two(0xF000, 0x4C45),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fdsqrts",	two(0xF000, 0x4445),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fdsqrtw",	two(0xF000, 0x5045),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fdsqrtx",	two(0xF000, 0x4845),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fdsqrt",	two(0xF000, 0x0045),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fdsqrt",	two(0xF000, 0x0045),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fsubb",	two(0xF000, 0x5828),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"fsubd",	two(0xF000, 0x5428),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"fsubl",	two(0xF000, 0x4028),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"fsubp",	two(0xF000, 0x4C28),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"fsubp",	two(0xF000, 0x4C28),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"fsubs",	two(0xF000, 0x4428),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"fsubw",	two(0xF000, 0x5028),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"fsubx",	two(0xF000, 0x0028),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"fsubx",	two(0xF000, 0x4828),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"fsubx",	two(0xF000, 0x0028),	two(0xF1C0, 0xE07F),	"IiFt"},

{"fssubb",	two(0xF000, 0x5868),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fssubd",	two(0xF000, 0x5468),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fssubl",	two(0xF000, 0x4068),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fssubp",	two(0xF000, 0x4C68),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fssubp",	two(0xF000, 0x4C68),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fssubs",	two(0xF000, 0x4468),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fssubw",	two(0xF000, 0x5068),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fssubx",	two(0xF000, 0x0068),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fssubx",	two(0xF000, 0x4868),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fssubx",	two(0xF000, 0x0068),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"fdsubb",	two(0xF000, 0x586C),	two(0xF1C0, 0xFC7F),	"Ii;bF7", "4"},
{"fdsubd",	two(0xF000, 0x546C),	two(0xF1C0, 0xFC7F),	"Ii;FF7", "4"},
{"fdsubl",	two(0xF000, 0x406C),	two(0xF1C0, 0xFC7F),	"Ii;lF7", "4"},
#ifdef PACKED_IMMEDIATE
{"fdsubp",	two(0xF000, 0x4C6C),	two(0xF1C0, 0xFC7F),	"Ii;pF7", "4"},
#else
{"fdsubp",	two(0xF000, 0x4C6C),	two(0xF1C0, 0xFC7F),	"Ii@pF7", "4"},
#endif
{"fdsubs",	two(0xF000, 0x446C),	two(0xF1C0, 0xFC7F),	"Ii;fF7", "4"},
{"fdsubw",	two(0xF000, 0x506C),	two(0xF1C0, 0xFC7F),	"Ii;wF7", "4"},
{"fdsubx",	two(0xF000, 0x006C),	two(0xF1C0, 0xE07F),	"IiF8F7", "4"},
{"fdsubx",	two(0xF000, 0x486C),	two(0xF1C0, 0xFC7F),	"Ii;xF7", "4"},
{"fdsubx",	two(0xF000, 0x006C),	two(0xF1C0, 0xE07F),	"IiFt", "4"},

{"ftanb",	two(0xF000, 0x580F),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"ftand",	two(0xF000, 0x540F),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"ftanl",	two(0xF000, 0x400F),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"ftanp",	two(0xF000, 0x4C0F),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"ftanp",	two(0xF000, 0x4C0F),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"ftans",	two(0xF000, 0x440F),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"ftanw",	two(0xF000, 0x500F),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"ftanx",	two(0xF000, 0x000F),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"ftanx",	two(0xF000, 0x480F),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"ftanx",	two(0xF000, 0x000F),	two(0xF1C0, 0xE07F),	"IiFt"},

{"ftanhb",	two(0xF000, 0x5809),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"ftanhd",	two(0xF000, 0x5409),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"ftanhl",	two(0xF000, 0x4009),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"ftanhp",	two(0xF000, 0x4C09),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"ftanhp",	two(0xF000, 0x4C09),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"ftanhs",	two(0xF000, 0x4409),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"ftanhw",	two(0xF000, 0x5009),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"ftanhx",	two(0xF000, 0x0009),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"ftanhx",	two(0xF000, 0x4809),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"ftanhx",	two(0xF000, 0x0009),	two(0xF1C0, 0xE07F),	"IiFt"},

{"ftentoxb",	two(0xF000, 0x5812),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"ftentoxd",	two(0xF000, 0x5412),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"ftentoxl",	two(0xF000, 0x4012),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"ftentoxp",	two(0xF000, 0x4C12),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"ftentoxp",	two(0xF000, 0x4C12),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"ftentoxs",	two(0xF000, 0x4412),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"ftentoxw",	two(0xF000, 0x5012),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"ftentoxx",	two(0xF000, 0x0012),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"ftentoxx",	two(0xF000, 0x4812),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"ftentoxx",	two(0xF000, 0x0012),	two(0xF1C0, 0xE07F),	"IiFt"},

{"ftrapeq",	two(0xF07C, 0x0001),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapf",	two(0xF07C, 0x0000),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapge",	two(0xF07C, 0x0013),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapgl",	two(0xF07C, 0x0016),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapgle",	two(0xF07C, 0x0017),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapgt",	two(0xF07C, 0x0012),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftraple",	two(0xF07C, 0x0015),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftraplt",	two(0xF07C, 0x0014),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapne",	two(0xF07C, 0x000E),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapnge",	two(0xF07C, 0x001C),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapngl",	two(0xF07C, 0x0019),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapngle",	two(0xF07C, 0x0018),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapngt",	two(0xF07C, 0x001D),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapnle",	two(0xF07C, 0x001A),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapnlt",	two(0xF07C, 0x001B),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapoge",	two(0xF07C, 0x0003),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapogl",	two(0xF07C, 0x0006),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapogt",	two(0xF07C, 0x0002),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapole",	two(0xF07C, 0x0005),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapolt",	two(0xF07C, 0x0004),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapor",	two(0xF07C, 0x0007),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapseq",	two(0xF07C, 0x0011),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapsf",	two(0xF07C, 0x0010),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapsne",	two(0xF07C, 0x001E),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapst",	two(0xF07C, 0x001F),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapt",	two(0xF07C, 0x000F),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapueq",	two(0xF07C, 0x0009),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapuge",	two(0xF07C, 0x000B),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapugt",	two(0xF07C, 0x000A),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapule",	two(0xF07C, 0x000D),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapult",	two(0xF07C, 0x000C),	two(0xF1FF, 0xFFFF),	"Ii"},
{"ftrapun",	two(0xF07C, 0x0008),	two(0xF1FF, 0xFFFF),	"Ii"},
        
{"ftrapeqw",	two(0xF07A, 0x0001),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapfw",	two(0xF07A, 0x0000),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapgew",	two(0xF07A, 0x0013),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapglw",	two(0xF07A, 0x0016),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapglew",	two(0xF07A, 0x0017),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapgtw",	two(0xF07A, 0x0012),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftraplew",	two(0xF07A, 0x0015),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapltw",	two(0xF07A, 0x0014),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapnew",	two(0xF07A, 0x000E),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapngew",	two(0xF07A, 0x001C),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapnglw",	two(0xF07A, 0x0019),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapnglew",	two(0xF07A, 0x0018),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapngtw",	two(0xF07A, 0x001D),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapnlew",	two(0xF07A, 0x001A),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapnltw",	two(0xF07A, 0x001B),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapogew",	two(0xF07A, 0x0003),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapoglw",	two(0xF07A, 0x0006),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapogtw",	two(0xF07A, 0x0002),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapolew",	two(0xF07A, 0x0005),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapoltw",	two(0xF07A, 0x0004),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftraporw",	two(0xF07A, 0x0007),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapseqw",	two(0xF07A, 0x0011),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapsfw",	two(0xF07A, 0x0010),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapsnew",	two(0xF07A, 0x001E),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapstw",	two(0xF07A, 0x001F),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftraptw",	two(0xF07A, 0x000F),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapueqw",	two(0xF07A, 0x0009),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapugew",	two(0xF07A, 0x000B),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapugtw",	two(0xF07A, 0x000A),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapulew",	two(0xF07A, 0x000D),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapultw",	two(0xF07A, 0x000C),	two(0xF1FF, 0xFFFF),	"Ii^w"},
{"ftrapunw",	two(0xF07A, 0x0008),	two(0xF1FF, 0xFFFF),	"Ii^w"},

{"ftrapeql",	two(0xF07B, 0x0001),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapfl",	two(0xF07B, 0x0000),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapgel",	two(0xF07B, 0x0013),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapgll",	two(0xF07B, 0x0016),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapglel",	two(0xF07B, 0x0017),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapgtl",	two(0xF07B, 0x0012),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftraplel",	two(0xF07B, 0x0015),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapltl",	two(0xF07B, 0x0014),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapnel",	two(0xF07B, 0x000E),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapngel",	two(0xF07B, 0x001C),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapngll",	two(0xF07B, 0x0019),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapnglel",	two(0xF07B, 0x0018),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapngtl",	two(0xF07B, 0x001D),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapnlel",	two(0xF07B, 0x001A),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapnltl",	two(0xF07B, 0x001B),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapogel",	two(0xF07B, 0x0003),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapogll",	two(0xF07B, 0x0006),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapogtl",	two(0xF07B, 0x0002),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapolel",	two(0xF07B, 0x0005),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapoltl",	two(0xF07B, 0x0004),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftraporl",	two(0xF07B, 0x0007),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapseql",	two(0xF07B, 0x0011),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapsfl",	two(0xF07B, 0x0010),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapsnel",	two(0xF07B, 0x001E),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapstl",	two(0xF07B, 0x001F),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftraptl",	two(0xF07B, 0x000F),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapueql",	two(0xF07B, 0x0009),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapugel",	two(0xF07B, 0x000B),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapugtl",	two(0xF07B, 0x000A),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapulel",	two(0xF07B, 0x000D),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapultl",	two(0xF07B, 0x000C),	two(0xF1FF, 0xFFFF),	"Ii^l"},
{"ftrapunl",	two(0xF07B, 0x0008),	two(0xF1FF, 0xFFFF),	"Ii^l"},

{"ftstb",	two(0xF000, 0x583A),	two(0xF1C0, 0xFC7F),	"Ii;b"},
{"ftstd",	two(0xF000, 0x543A),	two(0xF1C0, 0xFC7F),	"Ii;F"},
{"ftstl",	two(0xF000, 0x403A),	two(0xF1C0, 0xFC7F),	"Ii;l"},
#ifdef PACKED_IMMEDIATE
{"ftstp",	two(0xF000, 0x4C3A),	two(0xF1C0, 0xFC7F),	"Ii;p"},
#else
{"ftstp",	two(0xF000, 0x4C3A),	two(0xF1C0, 0xFC7F),	"Ii@p"},
#endif
{"ftsts",	two(0xF000, 0x443A),	two(0xF1C0, 0xFC7F),	"Ii;f"},
{"ftstw",	two(0xF000, 0x503A),	two(0xF1C0, 0xFC7F),	"Ii;w"},
{"ftstx",	two(0xF000, 0x003A),	two(0xF1C0, 0xE07F),	"IiF8"},
{"ftstx",	two(0xF000, 0x483A),	two(0xF1C0, 0xFC7F),	"Ii;x"},

{"ftwotoxb",	two(0xF000, 0x5811),	two(0xF1C0, 0xFC7F),	"Ii;bF7"},
{"ftwotoxd",	two(0xF000, 0x5411),	two(0xF1C0, 0xFC7F),	"Ii;FF7"},
{"ftwotoxl",	two(0xF000, 0x4011),	two(0xF1C0, 0xFC7F),	"Ii;lF7"},
#ifdef PACKED_IMMEDIATE
{"ftwotoxp",	two(0xF000, 0x4C11),	two(0xF1C0, 0xFC7F),	"Ii;pF7"},
#else
{"ftwotoxp",	two(0xF000, 0x4C11),	two(0xF1C0, 0xFC7F),	"Ii@pF7"},
#endif
{"ftwotoxs",	two(0xF000, 0x4411),	two(0xF1C0, 0xFC7F),	"Ii;fF7"},
{"ftwotoxw",	two(0xF000, 0x5011),	two(0xF1C0, 0xFC7F),	"Ii;wF7"},
{"ftwotoxx",	two(0xF000, 0x0011),	two(0xF1C0, 0xE07F),	"IiF8F7"},
{"ftwotoxx",	two(0xF000, 0x4811),	two(0xF1C0, 0xFC7F),	"Ii;xF7"},
{"ftwotoxx",	two(0xF000, 0x0011),	two(0xF1C0, 0xE07F),	"IiFt"},


{"fjeq",	one(0xF081),		one(0xF1FF),		"IdBc"},
{"fjf",		one(0xF080),		one(0xF1FF),		"IdBc"},
{"fjge",	one(0xF093),		one(0xF1FF),		"IdBc"},
{"fjgl",	one(0xF096),		one(0xF1FF),		"IdBc"},
{"fjgle",	one(0xF097),		one(0xF1FF),		"IdBc"},
{"fjgt",	one(0xF092),		one(0xF1FF),		"IdBc"},
{"fjle",	one(0xF095),		one(0xF1FF),		"IdBc"},
{"fjlt",	one(0xF094),		one(0xF1FF),		"IdBc"},
{"fjne",	one(0xF08E),		one(0xF1FF),		"IdBc"},
{"fjnge",	one(0xF09C),		one(0xF1FF),		"IdBc"},
{"fjngl",	one(0xF099),		one(0xF1FF),		"IdBc"},
{"fjngle",	one(0xF098),		one(0xF1FF),		"IdBc"},
{"fjngt",	one(0xF09D),		one(0xF1FF),		"IdBc"},
{"fjnle",	one(0xF09A),		one(0xF1FF),		"IdBc"},
{"fjnlt",	one(0xF09B),		one(0xF1FF),		"IdBc"},
{"fjoge",	one(0xF083),		one(0xF1FF),		"IdBc"},
{"fjogl",	one(0xF086),		one(0xF1FF),		"IdBc"},
{"fjogt",	one(0xF082),		one(0xF1FF),		"IdBc"},
{"fjole",	one(0xF085),		one(0xF1FF),		"IdBc"},
{"fjolt",	one(0xF084),		one(0xF1FF),		"IdBc"},
{"fjor",	one(0xF087),		one(0xF1FF),		"IdBc"},
{"fjseq",	one(0xF091),		one(0xF1FF),		"IdBc"},
{"fjsf",	one(0xF090),		one(0xF1FF),		"IdBc"},
{"fjsne",	one(0xF09E),		one(0xF1FF),		"IdBc"},
{"fjst",	one(0xF09F),		one(0xF1FF),		"IdBc"},
{"fjt",		one(0xF08F),		one(0xF1FF),		"IdBc"},
{"fjueq",	one(0xF089),		one(0xF1FF),		"IdBc"},
{"fjuge",	one(0xF08B),		one(0xF1FF),		"IdBc"},
{"fjugt",	one(0xF08A),		one(0xF1FF),		"IdBc"},
{"fjule",	one(0xF08D),		one(0xF1FF),		"IdBc"},
{"fjult",	one(0xF08C),		one(0xF1FF),		"IdBc"},
{"fjun",	one(0xF088),		one(0xF1FF),		"IdBc"},

/* The assembler will ignore attempts to force a short offset */

{"bhis",	one(0061000),		one(0177400),		"Bg"},
{"blss",	one(0061400),		one(0177400),		"Bg"},
{"bccs",	one(0062000),		one(0177400),		"Bg"},
{"bcss",	one(0062400),		one(0177400),		"Bg"},
{"bnes",	one(0063000),		one(0177400),		"Bg"},
{"beqs",	one(0063400),		one(0177400),		"Bg"},
{"bvcs",	one(0064000),		one(0177400),		"Bg"},
{"bvss",	one(0064400),		one(0177400),		"Bg"},
{"bpls",	one(0065000),		one(0177400),		"Bg"},
{"bmis",	one(0065400),		one(0177400),		"Bg"},
{"bges",	one(0066000),		one(0177400),		"Bg"},
{"blts",	one(0066400),		one(0177400),		"Bg"},
{"bgts",	one(0067000),		one(0177400),		"Bg"},
{"bles",	one(0067400),		one(0177400),		"Bg"},

/* Alternate mnemonics for SUN */

{"jbsr",	one(0060400),		one(0177400),		"Bg"},
{"jbsr",	one(0047200),		one(0177700),		"!s"},
{"jra",		one(0060000),		one(0177400),		"Bg"},
{"jra",		one(0047300),		one(0177700),		"!s"},
  
{"jhi",		one(0061000),		one(0177400),		"Bg"},
{"jls",		one(0061400),		one(0177400),		"Bg"},
{"jcc",		one(0062000),		one(0177400),		"Bg"},
{"jcs",		one(0062400),		one(0177400),		"Bg"},
{"jne",		one(0063000),		one(0177400),		"Bg"},
{"jeq",		one(0063400),		one(0177400),		"Bg"},
{"jvc",		one(0064000),		one(0177400),		"Bg"},
{"jvs",		one(0064400),		one(0177400),		"Bg"},
{"jpl",		one(0065000),		one(0177400),		"Bg"},
{"jmi",		one(0065400),		one(0177400),		"Bg"},
{"jge",		one(0066000),		one(0177400),		"Bg"},
{"jlt",		one(0066400),		one(0177400),		"Bg"},
{"jgt",		one(0067000),		one(0177400),		"Bg"},
{"jle",		one(0067400),		one(0177400),		"Bg"},

/* Short offsets are ignored */

{"jbsrs",	one(0060400),		one(0177400),		"Bg"},
{"jras",	one(0060000),		one(0177400),		"Bg"},
{"jhis",	one(0061000),		one(0177400),		"Bg"},
{"jlss",	one(0061400),		one(0177400),		"Bg"},
{"jccs",	one(0062000),		one(0177400),		"Bg"},
{"jcss",	one(0062400),		one(0177400),		"Bg"},
{"jnes",	one(0063000),		one(0177400),		"Bg"},
{"jeqs",	one(0063400),		one(0177400),		"Bg"},
{"jvcs",	one(0064000),		one(0177400),		"Bg"},
{"jvss",	one(0064400),		one(0177400),		"Bg"},
{"jpls",	one(0065000),		one(0177400),		"Bg"},
{"jmis",	one(0065400),		one(0177400),		"Bg"},
{"jges",	one(0066000),		one(0177400),		"Bg"},
{"jlts",	one(0066400),		one(0177400),		"Bg"},
{"jgts",	one(0067000),		one(0177400),		"Bg"},
{"jles",	one(0067400),		one(0177400),		"Bg"},

{"movql",	one(0070000),		one(0170400),		"MsDd"},
{"moveql",	one(0070000),		one(0170400),		"MsDd"},
{"moval",	one(0020100),		one(0170700),		"*lAd"},
{"movaw",	one(0030100),		one(0170700),		"*wAd"},
{"movb",	one(0010000),		one(0170000),		";b$d"},	/* mov */
{"movl",	one(0070000),		one(0170400),		"MsDd"},	/* movq written as mov */
{"movl",	one(0020000),		one(0170000),		"*l$d"},
{"movl",	one(0020100),		one(0170700),		"*lAd"},
{"movl",	one(0047140),		one(0177770),		"AsUd"},	/* mov to USP */
{"movl",	one(0047150),		one(0177770),		"UdAs"},	/* mov from USP */
{"movc",	one(0047173),		one(0177777),		"R1Jj"},
{"movc",	one(0047173),		one(0177777),		"R1#j"},
{"movc",	one(0047172),		one(0177777),		"JjR1"},
{"movc",	one(0047172),		one(0177777),		"#jR1"},
{"movml",	one(0044300),		one(0177700),		"#w&s"},	/* movm reg to mem. */
{"movml",	one(0044340),		one(0177770),		"#w-s"},	/* movm reg to autodecrement. */
{"movml",	one(0046300),		one(0177700),		"!s#w"},	/* movm mem to reg. */
{"movml",	one(0046330),		one(0177770),		"+s#w"},	/* movm autoinc to reg. */
{"movml",	one(0044300),		one(0177700),		"Lw&s"},	/* movm reg to mem. */
{"movml",	one(0044340),		one(0177770),		"lw-s"},	/* movm reg to autodecrement. */
{"movml",	one(0046300),		one(0177700),		"!sLw"},	/* movm mem to reg. */
{"movml",	one(0046330),		one(0177770),		"+sLw"},	/* movm autoinc to reg. */
{"movmw",	one(0044200),		one(0177700),		"#w&s"},	/* movm reg to mem. */
{"movmw",	one(0044240),		one(0177770),		"#w-s"},	/* movm reg to autodecrement. */
{"movmw",	one(0046200),		one(0177700),		"!s#w"},	/* movm mem to reg. */
{"movmw",	one(0046230),		one(0177770),		"+s#w"},	/* movm autoinc to reg. */
{"movmw",	one(0044200),		one(0177700),		"Lw&s"},	/* movm reg to mem. */
{"movmw",	one(0044240),		one(0177770),		"lw-s"},	/* movm reg to autodecrement. */
{"movmw",	one(0046200),		one(0177700),		"!sLw"},	/* movm mem to reg. */
{"movmw",	one(0046230),		one(0177770),		"+sLw"},	/* movm autoinc to reg. */
{"movpl",	one(0000510),		one(0170770),		"dsDd"},	/* memory to register */
{"movpl",	one(0000710),		one(0170770),		"Ddds"},	/* register to memory */
{"movpw",	one(0000410),		one(0170770),		"dsDd"},	/* memory to register */
{"movpw",	one(0000610),		one(0170770),		"Ddds"},	/* register to memory */
{"movq",	one(0070000),		one(0170400),		"MsDd"},
{"movw",	one(0030000),		one(0170000),		"*w$d"},
{"movw",	one(0030100),		one(0170700),		"*wAd"},	/* mova, written as mov */
{"movw",	one(0040300),		one(0177700),		"Ss$s"},	/* Move from sr */
{"movw",	one(0041300),		one(0177700),		"Cs$s"},	/* Move from ccr */
{"movw",	one(0042300),		one(0177700),		";wCd"},	/* mov to ccr */
{"movw",	one(0043300),		one(0177700),		";wSd"},	/* mov to sr */

{"movsb",	two(0007000, 0),	two(0177700, 07777),	"~sR1"},
{"movsb",	two(0007000, 04000),	two(0177700, 07777),	"R1~s"},
{"movsl",	two(0007200, 0),	two(0177700, 07777),	"~sR1"},
{"movsl",	two(0007200, 04000),	two(0177700, 07777),	"R1~s"},
{"movsw",	two(0007100, 0),	two(0177700, 07777),	"~sR1"},
{"movsw",	two(0007100, 04000),	two(0177700, 07777),	"R1~s"},

#ifdef BUILTIN_MMUS
 /* name */	/* opcode */		/* match */		/* args */

{"pflusha030",	two(0xf000, 0x2400),	two(0xffff, 0xffff),	"",	  "3" },
{"pflusha040",	one(0xf518),		one(0xfff8),		"",	  "4" },

{"pflush",	two(0xf000, 0x3010),	two(0xffc0, 0xfe10),	"Q3Q9",	  "3" },
{"pflush",	two(0xf000, 0x3810),	two(0xffc0, 0xfe10),	"Q3Q9&s", "3" },
{"pflush",	two(0xf000, 0x3008),	two(0xffc0, 0xfe18),	"D3Q9",	  "3" },
{"pflush",	two(0xf000, 0x3808),	two(0xffc0, 0xfe18),	"D3Q9&s", "3" },
{"pflush",	two(0xf000, 0x3000),	two(0xffc0, 0xfe1e),	"f3Q9",	  "3" },
{"pflush",	two(0xf000, 0x3800),	two(0xffc0, 0xfe1e),	"f3Q9&s", "3" },

{"pflush",	one(0xf508),		one(0xfff8),		"0s",	  "4" },
{"pflushn",	one(0xf500),		one(0xfff8),		"0s",	  "4" },
{"pflushan",	one(0xf510),		one(0xfff8),		"",	  "4" },

{"ploadr",	two(0xf000, 0x2210),	two(0xffc0, 0xfff0),	"Q3&s",	  "3" },
{"ploadr",	two(0xf000, 0x2208),	two(0xffc0, 0xfff8),	"D3&s",	  "3" },
{"ploadr",	two(0xf000, 0x2200),	two(0xffc0, 0xfffe),	"f3&s",	  "3" },
{"ploadw",	two(0xf000, 0x2010),	two(0xffc0, 0xfff0),	"Q3&s",	  "3" },
{"ploadw",	two(0xf000, 0x2008),	two(0xffc0, 0xfff8),	"D3&s",	  "3" },
{"ploadw",	two(0xf000, 0x2000),	two(0xffc0, 0xfffe),	"f3&s",	  "3" },

/* TC, CRP, SRP */
{"pmove",	two(0xf000, 0x4000),	two(0xffc0, 0xe3ff),	"&sa8",	  "3" },
{"pmove",	two(0xf000, 0x4200),	two(0xffc0, 0xe3ff),	"a8&s",	  "3" },
/* MMUSR */
{"pmove",	two(0xf000, 0x6000),	two(0xffc0, 0xffff),	"&sb3",	  "3" },
{"pmove",	two(0xf000, 0x6200),	two(0xffc0, 0xffff),	"b3&s",	  "3" },
/* TT0, TT1 */
{"pmove",	two(0xf000, 0x0000),	two(0xffc0, 0xe3ff),	"&se8",	  "3" },
{"pmove",	two(0xf000, 0x0200),	two(0xffc0, 0xe3ff),	"e8&s",	  "3" },

/* TC, CRP, SRP */
{"pmovefd",	two(0xf000, 0x4100),	two(0xffc0, 0xe3ff),	"&sa8",	  "3" },
/* TT0, TT1 */
{"pmovefd",	two(0xf000, 0x0100),	two(0xffc0, 0xe3ff),	"&se8",	  "3" },

{"ptestr",	two(0xf000, 0x8210),	two(0xffc0, 0xe3f0),	"Q3&sQ8",  "3"},
{"ptestr",	two(0xf000, 0x8310),	two(0xffc0, 0xe310),	"Q3&sQ8A9","3"},
{"ptestr",	two(0xf000, 0x8208),	two(0xffc0, 0xe3f8),	"D3&sQ8",  "3"},
{"ptestr",	two(0xf000, 0x8308),	two(0xffc0, 0xe318),	"D3&sQ8A9","3"},
{"ptestr",	two(0xf000, 0x8200),	two(0xffc0, 0xe3fe),	"f3&sQ8",  "3"},
{"ptestr",	two(0xf000, 0x8300),	two(0xffc0, 0xe31e),	"f3&sQ8A9","3"},
{"ptestr",	one(0xf568),		one(0xfff8),		"0s",	   "4"},

{"ptestw",	two(0xf000, 0x8010),	two(0xffc0, 0xe3f0),	"Q3&sQ8",  "3"},
{"ptestw",	two(0xf000, 0x8110),	two(0xffc0, 0xe310),	"Q3&sQ8A9","3"},
{"ptestw",	two(0xf000, 0x8008),	two(0xffc0, 0xe3f8),	"D3&sQ8",  "3"},
{"ptestw",	two(0xf000, 0x8108),	two(0xffc0, 0xe318),	"D3&sQ8A9","3"},
{"ptestw",	two(0xf000, 0x8000),	two(0xffc0, 0xe3fe),	"f3&sQ8",  "3"},
{"ptestw",	two(0xf000, 0x8100),	two(0xffc0, 0xe31e),	"f3&sQ8A9","3"},
{"ptestw",	one(0xf548),		one(0xfff8),		"0s",	   "4"},

{"cinva",	one(0xf418),		one(0xff38),		"cS",	"4" },
{"cinvl",	one(0xf408),		one(0xff38),		"cS0s",	"4" },
{"cinvp",	one(0xf410),		one(0xff38),		"cS0s",	"4" },

{"cpusha",	one(0xf438),		one(0xff38),		"cS",	"4" },
{"cpushl",	one(0xf428),		one(0xff38),		"cS0s",	"4" },
{"cpushp",	one(0xf430),		one(0xff38),		"cS0s",	"4" },

#endif /* BUILTIN_MMUS */

#ifdef m68851
 /* name */	/* opcode */		/* match */		/* args */

{"pbac",	one(0xf0c7),		one(0xffbf),		"Bc"},
{"pbacw",	one(0xf087),		one(0xffbf),		"Bc"},
{"pbas",	one(0xf0c6),		one(0xffbf),		"Bc"},
{"pbasw",	one(0xf086),		one(0xffbf),		"Bc"},
{"pbbc",	one(0xf0c1),		one(0xffbf),		"Bc"},
{"pbbcw",	one(0xf081),		one(0xffbf),		"Bc"},
{"pbbs",	one(0xf0c0),		one(0xffbf),		"Bc"},
{"pbbsw",	one(0xf080),		one(0xffbf),		"Bc"},
{"pbcc",	one(0xf0cf),		one(0xffbf),		"Bc"},
{"pbccw",	one(0xf08f),		one(0xffbf),		"Bc"},
{"pbcs",	one(0xf0ce),		one(0xffbf),		"Bc"},
{"pbcsw",	one(0xf08e),		one(0xffbf),		"Bc"},
{"pbgc",	one(0xf0cd),		one(0xffbf),		"Bc"},
{"pbgcw",	one(0xf08d),		one(0xffbf),		"Bc"},
{"pbgs",	one(0xf0cc),		one(0xffbf),		"Bc"},
{"pbgsw",	one(0xf08c),		one(0xffbf),		"Bc"},
{"pbic",	one(0xf0cb),		one(0xffbf),		"Bc"},
{"pbicw",	one(0xf08b),		one(0xffbf),		"Bc"},
{"pbis",	one(0xf0ca),		one(0xffbf),		"Bc"},
{"pbisw",	one(0xf08a),		one(0xffbf),		"Bc"},
{"pblc",	one(0xf0c3),		one(0xffbf),		"Bc"},
{"pblcw",	one(0xf083),		one(0xffbf),		"Bc"},
{"pbls",	one(0xf0c2),		one(0xffbf),		"Bc"},
{"pblsw",	one(0xf082),		one(0xffbf),		"Bc"},
{"pbsc",	one(0xf0c5),		one(0xffbf),		"Bc"},
{"pbscw",	one(0xf085),		one(0xffbf),		"Bc"},
{"pbss",	one(0xf0c4),		one(0xffbf),		"Bc"},
{"pbssw",	one(0xf084),		one(0xffbf),		"Bc"},
{"pbwc",	one(0xf0c9),		one(0xffbf),		"Bc"},
{"pbwcw",	one(0xf089),		one(0xffbf),		"Bc"},
{"pbws",	one(0xf0c8),		one(0xffbf),		"Bc"},
{"pbwsw",	one(0xf088),		one(0xffbf),		"Bc"},


{"pdbac",	two(0xf048, 0x0007),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbas",	two(0xf048, 0x0006),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbbc",	two(0xf048, 0x0001),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbbs",	two(0xf048, 0x0000),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbcc",	two(0xf048, 0x000f),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbcs",	two(0xf048, 0x000e),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbgc",	two(0xf048, 0x000d),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbgs",	two(0xf048, 0x000c),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbic",	two(0xf048, 0x000b),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbis",	two(0xf048, 0x000a),	two(0xfff8, 0xffff),	"DsBw"},
{"pdblc",	two(0xf048, 0x0003),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbls",	two(0xf048, 0x0002),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbsc",	two(0xf048, 0x0005),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbss",	two(0xf048, 0x0004),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbwc",	two(0xf048, 0x0009),	two(0xfff8, 0xffff),	"DsBw"},
{"pdbws",	two(0xf048, 0x0008),	two(0xfff8, 0xffff),	"DsBw"},

{"pflusha",	two(0xf000, 0x2400),	two(0xffff, 0xffff),	"" },

{"pflush",	two(0xf000, 0x3010),	two(0xffc0, 0xfe10),	"T3T9" },
{"pflush",	two(0xf000, 0x3810),	two(0xffc0, 0xfe10),	"T3T9&s" },
{"pflush",	two(0xf000, 0x3008),	two(0xffc0, 0xfe18),	"D3T9" },
{"pflush",	two(0xf000, 0x3808),	two(0xffc0, 0xfe18),	"D3T9&s" },
{"pflush",	two(0xf000, 0x3000),	two(0xffc0, 0xfe1e),	"f3T9" },
{"pflush",	two(0xf000, 0x3800),	two(0xffc0, 0xfe1e),	"f3T9&s" },

{"pflushs",	two(0xf000, 0x3410),	two(0xfff8, 0xfe10),	"T3T9" },
{"pflushs",	two(0xf000, 0x3c00),	two(0xfff8, 0xfe00),	"T3T9&s" },
{"pflushs",	two(0xf000, 0x3408),	two(0xfff8, 0xfe18),	"D3T9" },
{"pflushs",	two(0xf000, 0x3c08),	two(0xfff8, 0xfe18),	"D3T9&s" },
{"pflushs",	two(0xf000, 0x3400),	two(0xfff8, 0xfe1e),	"f3T9" },
{"pflushs",	two(0xf000, 0x3c00),	two(0xfff8, 0xfe1e),	"f3T9&s"},

{"pflushr",	two(0xf000, 0xa000),	two(0xffc0, 0xffff),	"|s" },

{"ploadr",	two(0xf000, 0x2210),	two(0xffc0, 0xfff0),	"T3&s" },
{"ploadr",	two(0xf000, 0x2208),	two(0xffc0, 0xfff8),	"D3&s" },
{"ploadr",	two(0xf000, 0x2200),	two(0xffc0, 0xfffe),	"f3&s" },
{"ploadw",	two(0xf000, 0x2010),	two(0xffc0, 0xfff0),	"T3&s" },
{"ploadw",	two(0xf000, 0x2008),	two(0xffc0, 0xfff8),	"D3&s" },
{"ploadw",	two(0xf000, 0x2000),	two(0xffc0, 0xfffe),	"f3&s" },

/* TC, CRP, DRP, SRP, CAL, VAL, SCC, AC */
{"pmove",	two(0xf000, 0x4000),	two(0xffc0, 0xe3ff),	"&sP8" },
{"pmove",	two(0xf000, 0x4200),	two(0xffc0, 0xe3ff),	"P8%s" },
{"pmove",	two(0xf000, 0x4000),	two(0xffc0, 0xe3ff),	"|sW8" },
{"pmove",	two(0xf000, 0x4200),	two(0xffc0, 0xe3ff),	"W8~s" },

/* BADx, BACx */
{"pmove",	two(0xf000, 0x6200),	two(0xffc0, 0xe3e3),	"*sX3" },
{"pmove",	two(0xf000, 0x6000),	two(0xffc0, 0xe3e3),	"X3%s" },

/* PSR, PCSR */
/* {"pmove",	two(0xf000, 0x6100),	two(oxffc0, oxffff),	"*sZ8" }, */
{"pmove",	two(0xf000, 0x6000),	two(0xffc0, 0xffff),	"*sY8" },
{"pmove",	two(0xf000, 0x6200),	two(0xffc0, 0xffff),	"Y8%s" },
{"pmove",	two(0xf000, 0x6600),	two(0xffc0, 0xffff),	"Z8%s" },

{"prestore",	one(0xf140),		one(0xffc0),		"&s"},
{"prestore",	one(0xf158),		one(0xfff8),		"+s"},
{"psave",	one(0xf100),		one(0xffc0),		"&s"},
{"psave",	one(0xf100),		one(0xffc0),		"+s"},

{"psac",	two(0xf040, 0x0007),	two(0xffc0, 0xffff),	"@s"},
{"psas",	two(0xf040, 0x0006),	two(0xffc0, 0xffff),	"@s"},
{"psbc",	two(0xf040, 0x0001),	two(0xffc0, 0xffff),	"@s"},
{"psbs",	two(0xf040, 0x0000),	two(0xffc0, 0xffff),	"@s"},
{"pscc",	two(0xf040, 0x000f),	two(0xffc0, 0xffff),	"@s"},
{"pscs",	two(0xf040, 0x000e),	two(0xffc0, 0xffff),	"@s"},
{"psgc",	two(0xf040, 0x000d),	two(0xffc0, 0xffff),	"@s"},
{"psgs",	two(0xf040, 0x000c),	two(0xffc0, 0xffff),	"@s"},
{"psic",	two(0xf040, 0x000b),	two(0xffc0, 0xffff),	"@s"},
{"psis",	two(0xf040, 0x000a),	two(0xffc0, 0xffff),	"@s"},
{"pslc",	two(0xf040, 0x0003),	two(0xffc0, 0xffff),	"@s"},
{"psls",	two(0xf040, 0x0002),	two(0xffc0, 0xffff),	"@s"},
{"pssc",	two(0xf040, 0x0005),	two(0xffc0, 0xffff),	"@s"},
{"psss",	two(0xf040, 0x0004),	two(0xffc0, 0xffff),	"@s"},
{"pswc",	two(0xf040, 0x0009),	two(0xffc0, 0xffff),	"@s"},
{"psws",	two(0xf040, 0x0008),	two(0xffc0, 0xffff),	"@s"},

{"ptestr",	two(0xf000, 0x8210),	two(0xffc0, 0xe3f0),	"T3&sQ8" },
{"ptestr",	two(0xf000, 0x8310),	two(0xffc0, 0xe310),	"T3&sQ8A9" },
{"ptestr",	two(0xf000, 0x8208),	two(0xffc0, 0xe3f8),	"D3&sQ8" },
{"ptestr",	two(0xf000, 0x8308),	two(0xffc0, 0xe318),	"D3&sQ8A9" },
{"ptestr",	two(0xf000, 0x8200),	two(0xffc0, 0xe3fe),	"f3&sQ8" },
{"ptestr",	two(0xf000, 0x8300),	two(0xffc0, 0xe31e),	"f3&sQ8A9" },

{"ptestw",	two(0xf000, 0x8010),	two(0xffc0, 0xe3f0),	"T3&sQ8" },
{"ptestw",	two(0xf000, 0x8110),	two(0xffc0, 0xe310),	"T3&sQ8A9" },
{"ptestw",	two(0xf000, 0x8008),	two(0xffc0, 0xe3f8),	"D3&sQ8" },
{"ptestw",	two(0xf000, 0x8108),	two(0xffc0, 0xe318),	"D3&sQ8A9" },
{"ptestw",	two(0xf000, 0x8000),	two(0xffc0, 0xe3fe),	"f3&sQ8" },
{"ptestw",	two(0xf000, 0x8100),	two(0xffc0, 0xe31e),	"f3&sQ8A9" },

{"ptrapacw",	two(0xf07a, 0x0007),	two(0xffff, 0xffff),	"#w"},
{"ptrapacl",	two(0xf07b, 0x0007),	two(0xffff, 0xffff),	"#l"},
{"ptrapac",	two(0xf07c, 0x0007),	two(0xffff, 0xffff),	""},

{"ptrapasw",	two(0xf07a, 0x0006),	two(0xffff, 0xffff),	"#w"},
{"ptrapasl",	two(0xf07b, 0x0006),	two(0xffff, 0xffff),	"#l"},
{"ptrapas",	two(0xf07c, 0x0006),	two(0xffff, 0xffff),	""},

{"ptrapbcw",	two(0xf07a, 0x0001),	two(0xffff, 0xffff),	"#w"},
{"ptrapbcl",	two(0xf07b, 0x0001),	two(0xffff, 0xffff),	"#l"},
{"ptrapbc",	two(0xf07c, 0x0001),	two(0xffff, 0xffff),	""},

{"ptrapbsw",	two(0xf07a, 0x0000),	two(0xffff, 0xffff),	"#w"},
{"ptrapbsl",	two(0xf07b, 0x0000),	two(0xffff, 0xffff),	"#l"},
{"ptrapbs",	two(0xf07c, 0x0000),	two(0xffff, 0xffff),	""},

{"ptrapccw",	two(0xf07a, 0x000f),	two(0xffff, 0xffff),	"#w"},
{"ptrapccl",	two(0xf07b, 0x000f),	two(0xffff, 0xffff),	"#l"},
{"ptrapcc",	two(0xf07c, 0x000f),	two(0xffff, 0xffff),	""},

{"ptrapcsw",	two(0xf07a, 0x000e),	two(0xffff, 0xffff),	"#w"},
{"ptrapcsl",	two(0xf07b, 0x000e),	two(0xffff, 0xffff),	"#l"},
{"ptrapcs",	two(0xf07c, 0x000e),	two(0xffff, 0xffff),	""},

{"ptrapgcw",	two(0xf07a, 0x000d),	two(0xffff, 0xffff),	"#w"},
{"ptrapgcl",	two(0xf07b, 0x000d),	two(0xffff, 0xffff),	"#l"},
{"ptrapgc",	two(0xf07c, 0x000d),	two(0xffff, 0xffff),	""},

{"ptrapgsw",	two(0xf07a, 0x000c),	two(0xffff, 0xffff),	"#w"},
{"ptrapgsl",	two(0xf07b, 0x000c),	two(0xffff, 0xffff),	"#l"},
{"ptrapgs",	two(0xf07c, 0x000c),	two(0xffff, 0xffff),	""},

{"ptrapicw",	two(0xf07a, 0x000b),	two(0xffff, 0xffff),	"#w"},
{"ptrapicl",	two(0xf07b, 0x000b),	two(0xffff, 0xffff),	"#l"},
{"ptrapic",	two(0xf07c, 0x000b),	two(0xffff, 0xffff),	""},

{"ptrapisw",	two(0xf07a, 0x000a),	two(0xffff, 0xffff),	"#w"},
{"ptrapisl",	two(0xf07b, 0x000a),	two(0xffff, 0xffff),	"#l"},
{"ptrapis",	two(0xf07c, 0x000a),	two(0xffff, 0xffff),	""},

{"ptraplcw",	two(0xf07a, 0x0003),	two(0xffff, 0xffff),	"#w"},
{"ptraplcl",	two(0xf07b, 0x0003),	two(0xffff, 0xffff),	"#l"},
{"ptraplc",	two(0xf07c, 0x0003),	two(0xffff, 0xffff),	""},

{"ptraplsw",	two(0xf07a, 0x0002),	two(0xffff, 0xffff),	"#w"},
{"ptraplsl",	two(0xf07b, 0x0002),	two(0xffff, 0xffff),	"#l"},
{"ptrapls",	two(0xf07c, 0x0002),	two(0xffff, 0xffff),	""},

{"ptrapscw",	two(0xf07a, 0x0005),	two(0xffff, 0xffff),	"#w"},
{"ptrapscl",	two(0xf07b, 0x0005),	two(0xffff, 0xffff),	"#l"},
{"ptrapsc",	two(0xf07c, 0x0005),	two(0xffff, 0xffff),	""},

{"ptrapssw",	two(0xf07a, 0x0004),	two(0xffff, 0xffff),	"#w"},
{"ptrapssl",	two(0xf07b, 0x0004),	two(0xffff, 0xffff),	"#l"},
{"ptrapss",	two(0xf07c, 0x0004),	two(0xffff, 0xffff),	""},

{"ptrapwcw",	two(0xf07a, 0x0009),	two(0xffff, 0xffff),	"#w"},
{"ptrapwcl",	two(0xf07b, 0x0009),	two(0xffff, 0xffff),	"#l"},
{"ptrapwc",	two(0xf07c, 0x0009),	two(0xffff, 0xffff),	""},

{"ptrapwsw",	two(0xf07a, 0x0008),	two(0xffff, 0xffff),	"#w"},
{"ptrapwsl",	two(0xf07b, 0x0008),	two(0xffff, 0xffff),	"#l"},
{"ptrapws",	two(0xf07c, 0x0008),	two(0xffff, 0xffff),	""},

{"pvalid",	two(0xf000, 0x2800),	two(0xffc0, 0xffff),	"Vs&s"},
{"pvalid",	two(0xf000, 0x2c00),	two(0xffc0, 0xfff8),	"A3&s" },

#endif /* m68851 */


};

static const struct m68k_opcode *endop =
	 m68k_opcodes + sizeof(m68k_opcodes) / sizeof(m68k_opcodes[0]);
                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/m68k.c                                   0100644 0001750 0001750 00000261205 12612724204 022000  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #undef CHECK_WORD_IMMEDIATES /* bug #26863 */

/* m68k.c  All the m68020 specific stuff in one convenient, huge,
   slow to compile, easy to find file.
   Copyright (C) 1987 Free Software Foundation, Inc.

This file is part of GAS, the GNU Assembler.

GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "m68k-opcode.h"
#include "as.h"
#include "obstack.h"
#include "struc-symbol.h"
#include "flonum.h"
#include "expr.h"
#include "hash.h"
#include "frags.h"
#include "fixes.h"
#include "read.h"
#include "md.h"
#ifndef NeXT_MOD
#include "m68k.h"
#endif /* NeXT_MOD */
#include "xmalloc.h"
#include "sections.h"
#include "messages.h"
#include "atof-ieee.h"
#include "input-scrub.h"
#include "symbols.h"

/*
 * These are the default cputype and cpusubtype for the m68k architecture.
 */
const cpu_type_t md_cputype = CPU_TYPE_MC680x0;
cpu_subtype_t md_cpusubtype = CPU_SUBTYPE_MC680x0_ALL;

/* This is the byte sex for the m68k architecture */
const enum byte_sex md_target_byte_sex = BIG_ENDIAN_BYTE_SEX;

/*
 * This array holds the chars that always start a comment.  If the
 * pre-processor is disabled, these aren't very useful.
 */
const char md_comment_chars[] = "|";

/*
 * This array holds the chars that only start a comment at the beginning of
 * a line.  If the line seems to have the form '# 123 filename'
 * .line and .file directives will appear in the pre-processed output.
 *
 * Note that input_file.c hand checks for '#' at the beginning of the
 * first line of the input file.  This is because the compiler outputs
 * #NO_APP at the beginning of its output.
 *
 * Also note that a '/' followed by a '*' will always start a comment.
 */
const char md_line_comment_chars[] = "#";

/* Chars that can be used to separate mant from exp in floating point nums. */
const char md_EXP_CHARS[] = "eE";

/*
 * Chars that mean this number is a floating point constant.
 * As in 0f12.456
 * or    0d1.2345e12
 *
 * Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
 * changed in read.c .  Ideally it shouldn't have to know about it at all,
 * but nothing is ideal around here.
 */
const char md_FLT_CHARS[] = "rRsSfFdDxXeEpP";

/* Its an arbitrary name:  This means I don't approve of it */
/* See flames below */
static struct obstack robyn;

/*
 * These macros are used to encode a mode for the rlx_more field of the struct
 * relax_typeS in the array md_relax_table below.  The array is indexed by a
 * TAB(x,y) value where x is one of BRANCH, FBRANCH, ... and y is BYTE, SHORT,
 * ...  Thus the array md_relax_table below is declared to match this use of
 * indexes.  The macro TABTYPE(xy) take the value and returns one of BRANCH,
 * FBRANCH, ...
 */
#define TAB(x,y)	(((x)<<2)+(y))
#define TABTYPE(xy)     ((xy) >> 2)

#define BRANCH		1
#define FBRANCH		2
#define PCREL		3
#define BCC68000        4
#define DBCC            5

#define BYTE		0
#define SHORT		1
#define LONG		2
#define SZ_UNDEF	3

/*
 * BCC68000 is for patching in an extra jmp instruction for long offsets
 * on the 68000.  The 68000 doesn't support long branches with branchs.
 */

/*
 * Note that calls to frag_var need to specify the maximum expansion needed.
 * This is currently 10 bytes for DBCC.
 */

/*
 * This table desribes how you change sizes for the various types of variable
 * size expressions.  This version only supports two kinds.
 * The fields are:
 *	How far Forward this mode will reach:
 *	How far Backward this mode will reach:
 *	How many bytes this mode will add to the size of the frag
 *	Which mode to go to if the offset won't fit in this one
 */
const
relax_typeS
md_relax_table[] = {
{ 1,		1,		0,	0 },	/* First entries aren't used */
{ 1,		1,		0,	0 },	/* For no good reason except */
{ 1,		1,		0,	0 },	/* that the VAX doesn't either */
{ 1,		1,		0,	0 },

{ (127),	(-128),		0,	TAB(BRANCH,SHORT)},
{ (32767),	(-32768),	2,	TAB(BRANCH,LONG) },
{ 0,		0,		4,	0 },
{ 1,		1,		0,	0 },

{ 1,		1,		0,	0 },	/* FBRANCH doesn't come BYTE */
{ (32767),	(-32768),	2,	TAB(FBRANCH,LONG)},
{ 0,		0,		4,	0 },
{ 1,		1,		0,	0 },

{ 1,		1,		0,	0 },	/* PCREL doesn't come BYTE */
{ (32767),	(-32768),	2,	TAB(PCREL,LONG)},
{ 0,		0,		4,	0 },
{ 1,		1,		0,	0 },

{ (127),	(-128),		0,	TAB(BCC68000,SHORT)},
{ (32767),	(-32768),	2,	TAB(BCC68000,LONG) },
{ 0,		0,		6,	0 },	/* jmp long space */
{ 1,		1,		0,	0 },

{ 1,		1,		0,	0 },	/* DBCC doesn't come BYTE */
{ (32767),	(-32768),	2,	TAB(DBCC,LONG) },
{ 0,		0,		10,	0 },	/* bra/jmp long space */
{ 1,		1,		0,	0 },

};

static void s_even(
    uintptr_t value);
static void s_proc(
    uintptr_t value);

/*
 * These are the machine dependent pseudo-ops.  These are included so
 * the assembler can work on the output from the SUN C compiler, which
 * generates these.
 */

/* This table describes all the machine specific pseudo-ops the assembler
 * has to support.  The fields are:
 * 	  pseudo-op name without dot
 *	  function to call to execute this pseudo-op
 *	  Integer arg to pass to the function
 */
const pseudo_typeS md_pseudo_table[] = {
	{ "float",	float_cons,	'f'	},
	{ "int",	cons,		4	},
	{ "word",	cons,		2	},
	{ "quad",	big_cons,	8	},
	{ "octa",	big_cons,	16	},
	{ "even",	s_even,		0	},
	{ "skip",	s_space,	0	},
	{ "proc",	s_proc,		0	},
	{ 0,		0,		0	}
};

#define issbyte(x)	((x)>=-128 && (x)<=127)
#define isubyte(x)	((x)>=0 && (x)<=255)
#define issword(x)	((x)>=-32768 && (x)<=32767)
#define isuword(x)	((x)>=0 && (x)<=65535)

#define isbyte(x)	((x)>=-128 && (x)<=255)
#define isword(x)	((x)>=-32768 && (x)<=65535)
#define islong(x)	(1)

/* Operands we can parse:  (And associated modes)

numb:	8 bit num
numw:	16 bit num
numl:	32 bit num
dreg:	data reg 0-7
reg:	address or data register
areg:	address register
apc:	address register, PC, ZPC or empty string
num:	16 or 32 bit num
num2:	like num
sz:	w or l		if omitted, l assumed
scale:	1 2 4 or 8	if omitted, 1 assumed

7.4 IMMED #num				--> NUM
0.? DREG  dreg				--> dreg
1.? AREG  areg				--> areg
2.? AINDR areg@				--> *(areg)
3.? AINC  areg@+			--> *(areg++)
4.? ADEC  areg@-			--> *(--areg)
5.? AOFF  apc@(numw)			--> *(apc+numw)	-- empty string and ZPC not allowed here
6.? AINDX apc@(num,reg:sz:scale)	--> *(apc+num+reg*scale)
6.? AINDX apc@(reg:sz:scale)		--> same, with num=0
6.? APODX apc@(num)@(num2,reg:sz:scale)	--> *(*(apc+num)+num2+reg*scale)
6.? APODX apc@(num)@(reg:sz:scale)	--> same, with num2=0
6.? AMIND apc@(num)@(num2)		--> *(*(apc+num)+num2) (previous mode without an index reg)
6.? APRDX apc@(num,reg:sz:scale)@(num2)	--> *(*(apc+num+reg*scale)+num2)
6.? APRDX apc@(reg:sz:scale)@(num2)	--> same, with num=0
7.0 ABSL  num:sz			--> *(num)
          num				--> *(num) (sz L assumed)
*** MSCR  otherreg			--> Magic
With -l option
5.? AOFF  apc@(num)			--> *(apc+num) -- empty string and ZPC not allowed here still

examples:
	#foo	#0x35	#12
	d2
	a4
	a3@
	a5@+
	a6@-
	a2@(12)	pc@(14)
	a1@(5,d2:w:1)	@(45,d6:l:4)
	pc@(a2)		@(d4)
	etc . . .


#name@(numw)	-->turn into PC rel mode
apc@(num8,reg:sz:scale)		--> *(apc+num8+reg*scale)

*/

#define IMMED	1
#define DREG	2
#define AREG	3
#define AINDR	4
#define ADEC	5
#define AINC	6
#define AOFF	7
#define AINDX	8
#define APODX	9
#define AMIND	10
#define APRDX	11
#define ABSL	12
#define MSCR	13
#define REGLST	14

#define FAIL	0
#define OK	1

/* DATA and ADDR have to be contiguous, so that reg-DATA gives 0-7==data reg,
   8-15==addr reg for operands that take both types */
#define DATA	1		/*   1- 8 == data registers 0-7 */
#define ADDR	(DATA+8)	/*   9-16 == address regs 0-7 */
#define FPREG	(ADDR+8)	/*  17-24 Eight FP registers */
#define COPNUM	(FPREG+8)	/*  25-32 Co-processor #1-#8 */
#undef PC
#define PC	(COPNUM+8)	/*  33 Program counter */
#define ZPC	(PC+1)		/*  34 Hack for Program space, but 0 addressing */
#define SR	(ZPC+1)		/*  35 Status Reg */
#define CCR	(SR+1)		/*  36 Condition code Reg */

#define FPI	(CCR+1)		/*  37 floating-point instruction register */
#define FPS	(FPI+1)		/*  38 floating-point status register */
#define FPC	(FPS+1)		/*  39 floating-point condition register */

/* These have to be in order for the movec instruction to work. */
/* The comment above should read: All the registers that can be in a movec
   instruction must be bounded by USP and MSP (or SRP if BUILTIN_MMUS is
   defined) for the 'J' kind of operand to be checked correctly in m68_ip() */
#define USP	(FPC+1)		/*  40 User Stack Pointer */
#define ISP	(USP+1)		/*  41 Interrupt stack pointer */
#define SFC	(ISP+1)		/*  42 Source function control code register */
#define DFC	(SFC+1)		/*  43 Destination function code register */
#define CACR	(DFC+1)		/*  44 Cashe control register */
#define VBR	(CACR+1)	/*  45 wector base register */
#define CAAR	(VBR+1)		/*  46 Cashe address register */
#define MSP	(CAAR+1)	/*  47 Master stack pointer */

#ifdef BUILTIN_MMUS
/* mc68040 mmu registers, can be used in a movec instruction  */
#define	ITT0	(MSP+1)	 /* 48 instruction transparent translation register 0 */
#define	ITT1	(ITT0+1) /* 49 instruction transparent translation register 1 */
#define	DTT0	(ITT1+1) /* 50 data transparent translation register 0 */
#define	DTT1	(DTT0+1) /* 51 data transparent translation register 1 */
#define	URP	(DTT1+1) /* 53 user root pointer */

/* mc68030 and mc68040 mmu registers, can be used in a movec instruction */
#define	MMUSR	(URP+1)  /* 52 MMU status register */
#define TC	(MMUSR+1)/* 54 MMU translation control register */
#define SRP	(TC+1)   /* 55 supervisor root pointer */

/* mc68030 mmu registers, can't be used in a movec instruction (but rather in a
   pmove instruction) */
#define CRP	(SRP+1)  /* 56 cpu root pointer */
#define	TT0	(CRP+1)  /* 57 transparent translation register 0 */
#define	TT1	(TT0+1)  /* 58 transparent translation register 0 */

/* mc68040 operands to cache instructions  */
#define	IC	(TT1+1)  /* 59 instruction cache */
#define	DC	(IC+1)   /* 60 data cache */
#define	BC	(DC+1)   /* 61 both instruction and data caches */
#endif /* BUILTIN_MMUS */

#ifdef m68851
/*
 * these defines should be in m68k.c but
 * i put them here to keep all the m68851 stuff
 * together -rab
 * JF--Make sure these #s don't clash with the ones in m68k.c
 * That would be BAD.
 */
#define TC	(MSP+1)		/* 48 */
#define DRP	(TC+1)		/* 49 */
#define SRP	(DRP+1)		/* 50 */
#define CRP	(SRP+1)		/* 51 */
#define CAL	(CRP+1)		/* 52 */
#define VAL	(CAL+1)		/* 53 */
#define SCC	(VAL+1)		/* 54 */
#define AC	(SCC+1)		/* 55 */
#define BAD	(AC+1)		/* 56,57,58,59, 60,61,62,63 */
#define BAC	(BAD+8)		/* 64,65,66,67, 68,69,70,71 */
#define PSR	(BAC+8)		/* 72 */
#define PCSR	(PSR+1)		/* 73 */
#endif /* m68851 */


/* Note that COPNUM==processor #1 -- COPNUM+7==#8, which stores as 000 */
/* I think. . .  */

#undef SP
#define	SP	ADDR+7

/* JF these tables here are for speed at the expense of size */
/* You can replace them with the #if 0 versions if you really
   need space and don't mind it running a bit slower */

static char mklower_table[256];
#define mklower(c) (mklower_table[(unsigned char)(c)])
static char notend_table[256];
static char alt_notend_table[256];
#define notend(s) ( !(notend_table[(unsigned char)(*s)] || (*s==':' &&\
 alt_notend_table[(unsigned char)(s[1])])))

#if 0
#define mklower(c)	(isupper(c) ? tolower(c) : c)
#endif


struct m68k_exp {
	char	*e_beg;
	char	*e_end;
	expressionS e_exp;
	short	e_siz;		/* 0== default 1==short/byte 2==word 3==long */
};

/* Internal form of an operand.  */
struct m68k_op {
	char	*error;		/* Couldn't parse it */
	int	mode;		/* What mode this instruction is in.  */
	uint32_t	reg;		/* Base register */
	struct m68k_exp *con1;
	int	ireg;		/* Index register */
	int	isiz;		/* 0==unspec  1==byte(?)  2==short  3==long  */
	int	imul;		/* Multipy ireg by this (1,2,4,or 8) */
	struct	m68k_exp *con2;
};

/* internal form of a 68020 instruction */
struct m68_it {
	char	*error;
	char	*args;		/* list of opcode info */
	int	numargs;

#ifdef NeXT_MOD
	char	*cpus;
#endif /* NeXT_MOD */
	int	numo;		/* Number of shorts in opcode */
	short	opcode[11];

	struct m68k_op operands[6];

	int	nexp;		/* number of exprs in use */
	struct m68k_exp exprs[4];

	int	nfrag;		/* Number of frags we have to produce */
	struct {
		int fragoff;	/* Where in the current opcode[] the frag ends */
		symbolS *fadd;
		int32_t foff;
		int fragty;
	} fragb[4];

	int	nrel;		/* Num of reloc strucs in use */
	struct	{
		int	n;
		symbolS	*add,
			*sub;
		int32_t off;
		char	wid;
		char	pcrel;
	} reloc[5];		/* Five is enough??? */
};

static struct m68_it the_ins;		/* the instruction being assembled */


/* Macros for adding things to the m68_it struct */

#define addword(w)	the_ins.opcode[the_ins.numo++]=(w)

/* Like addword, but goes BEFORE general operands */
#define insop(w)	{int z;\
 for(z=the_ins.numo;z>opcode->m_codenum;--z)\
   the_ins.opcode[z]=the_ins.opcode[z-1];\
 for(z=0;z<the_ins.nrel;z++)\
   the_ins.reloc[z].n+=2;\
 the_ins.opcode[opcode->m_codenum]=(w);\
 the_ins.numo++;\
}


#define add_exp(beg,end) (\
	the_ins.exprs[the_ins.nexp].e_beg=(beg),\
	the_ins.exprs[the_ins.nexp].e_end=(end),\
	&the_ins.exprs[the_ins.nexp++]\
)


/* The numo+1 kludge is so we can hit the low order byte of the prev word. Blecch*/
#define add_fix(width,exp,pc_rel) {\
	the_ins.reloc[the_ins.nrel].n= ((width)=='B') ? (the_ins.numo*2-1) : \
		(((width)=='b') ? ((the_ins.numo-1)*2) : (the_ins.numo*2));\
	the_ins.reloc[the_ins.nrel].add=adds((exp));\
	the_ins.reloc[the_ins.nrel].sub=subs((exp));\
	the_ins.reloc[the_ins.nrel].off=offs((exp));\
	the_ins.reloc[the_ins.nrel].wid=(width);\
	the_ins.reloc[the_ins.nrel++].pcrel=(pc_rel);\
}

#define add_frag(add,off,type)  {\
	the_ins.fragb[the_ins.nfrag].fragoff=the_ins.numo;\
	the_ins.fragb[the_ins.nfrag].fadd=(add);\
	the_ins.fragb[the_ins.nfrag].foff=(off);\
	the_ins.fragb[the_ins.nfrag++].fragty=(type);\
}

#define isvar(exp)	((exp) && (adds(exp) || subs(exp)))

#define seg(exp)	((exp)->e_exp.X_seg)
#define adds(exp)	((exp)->e_exp.X_add_symbol)
#define subs(exp)	((exp)->e_exp.X_subtract_symbol)
#define offs(exp)	((exp)->e_exp.X_add_number)


struct m68_incant {
	char *m_operands;
	uint32_t m_opcode;
	short m_opnum;
	short m_codenum;
#ifdef NeXT_MOD
	char *m_cpus;
#endif /* NeXT_MOD */
	struct m68_incant *m_next;
};

#define getone(x)	((((x)->m_opcode)>>16)&0xffff)
#define gettwo(x)	(((x)->m_opcode)&0xffff)

/*
 * Declarations static functions in this file.
 */
static int m68k_reg_parse(
    char **ccp);
static int m68k_ip_op(
    char *str,
    struct m68k_op *opP);
static int try_index(
    char **s,
    struct m68k_op *opP);
static void m68_ip(
    char *instring);
static int get_regs(
    int i,
    struct m68k_op *opP,
    char *str);
static int reverse_16_bits(
    int in);
static int reverse_8_bits(
    int in);
static void install_operand(
    int mode,
    int val);
static void install_gen_operand(
    int mode,
    int val);
static char *crack_operand(
    char *str,
    struct m68k_op *opP);
static int get_num(
    struct m68k_exp *exp,
    int ok);

/* JF modified this to handle cases where the first part of a symbol name
   looks like a register */

static
int
m68k_reg_parse(
char **ccp)
{
	register char c1,
		c2,
		c3,
		c4;
#ifdef BUILTIN_MMUS
	char    c5;
#endif
	register int n = 0,
		ret = 0;

	c1=mklower(ccp[0][0]);
	c2=mklower(ccp[0][1]);
	c3=mklower(ccp[0][2]);
	c4=mklower(ccp[0][3]);
#ifdef BUILTIN_MMUS
	c5=mklower(ccp[0][4]);
#endif

	switch(c1) {
	case 'a':
		if(c2>='0' && c2<='7') {
			n=2;
			ret=ADDR+c2-'0';
		}
#ifdef m68851
		else if (c2 == 'c') {
			n = 2;
			ret = AC;
		}
#endif
		break;
#ifdef m68851
	case 'b':
		if (c2 == 'a') {
			if (c3 == 'd') {
				if (c4 >= '0' && c4 <= '7') {
					n = 4;
					ret = BAD + c4 - '0';
				}
			}
			if (c3 == 'c') {
				if (c4 >= '0' && c4 <= '7') {
					n = 4;
					ret = BAC + c4 - '0';
				}
			}
		}
		break;
#endif
#ifdef BUILTIN_MMUS
	case 'b':
		if (c2 == 'c') {
			n = 2;
			ret = (BC);
		}
		break;
#endif
	case 'c':
#ifdef m68851
		if (c2 == 'a' && c3 == 'l') {
			n = 3;
			ret = CAL;
		} else
#endif
			/* This supports both CCR and CC as the ccr reg. */
		if(c2=='c' && c3=='r') {
			n=3;
			ret = CCR;
		} else if(c2=='c') {
			n=2;
			ret = CCR;
		} else if(c2=='a' && (c3=='a' || c3=='c') && c4=='r') {
			n=4;
			ret = c3=='a' ? CAAR : CACR;
		}
#if defined(m68851) || defined (BUILTIN_MMUS)
		else if (c2 == 'r' && c3 == 'p') {
			n = 3;
			ret = (CRP);
		}
#endif
		break;
	case 'd':
		if(c2>='0' && c2<='7') {
			n=2;
			ret = DATA+c2-'0';
		} else if(c2=='f' && c3=='c') {
			n=3;
			ret = DFC;
		}
#ifdef m68851
		else if (c2 == 'r' && c3 == 'p') {
			n = 3;
			ret = (DRP);
		}
#endif
#ifdef BUILTIN_MMUS
		else if (c2 == 't' && c3 == 't' && (c4 == '0' || c4 == '1')) {
			n = 4;
			if(c4 == '0')
			    ret = (DTT0);
			else
			    ret = (DTT1);
		}
		else if (c2 == 'c') {
			n = 2;
			ret = (DC);
		}
#endif
		break;
	case 'f':
		if(c2=='p') {
 			if(c3>='0' && c3<='7') {
				n=3;
				ret = FPREG+c3-'0';
				if(c4==':')
					ccp[0][3]=',';
			} else if(c3=='i') {
				n=3;
				ret = FPI;
			} else if(c3=='s') {
				n= (c4 == 'r' ? 4 : 3);
				ret = FPS;
			} else if(c3=='c') {
				n= (c4 == 'r' ? 4 : 3);
				ret = FPC;
			}
		}
		break;
	case 'i':
		if(c2=='s' && c3=='p') {
			n=3;
			ret = ISP;
		}
#ifdef BUILTIN_MMUS
		else if (c2 == 't' && c3 == 't' && (c4 == '0' || c4 == '1')) {
			n = 4;
			if(c4 == '0')
			    ret = (ITT0);
			else
			    ret = (ITT1);
		}
		else if (c2 == 'c') {
			n = 2;
			ret = (IC);
		}
#endif
		break;
	case 'm':
		if(c2=='s' && c3=='p') {
			n=3;
			ret = MSP;
		}
#ifdef BUILTIN_MMUS
		if(c2=='m' && c3=='u' && c4=='s' && c5=='r') {
			n=5;
			ret = MMUSR;
		}
#endif
		break;
	case 'p':
		if(c2=='c') {
#ifdef m68851
			if(c3 == 's' && c4=='r') {
				n=4;
				ret = (PCSR);
			} else
#endif
			{
				n=2;
				ret = PC;
			}
		}
#ifdef m68851
		else if (c2 == 's' && c3 == 'r') {
			n = 3;
			ret = (PSR);
		}
#endif
#ifdef BUILTIN_MMUS
		else if (c2 == 's' && c3 == 'r') {
			n = 3;
			ret = (MMUSR);
		}
#endif
		break;
	case 's':
#if defined(m68851) || defined(BUILTIN_MMUS)
		if (c2 == 'r' && c3 == 'p') {
			n = 3;
			ret = (SRP);
		}
#endif
#ifdef m68851
		else if (c2 == 'c' && c3 == 'c') {
			n = 3;
			ret = (SCC);
		}
#endif
#if defined(m68851) || defined(BUILTIN_MMUS)
		else
#endif
		if(c2=='r') {
			n=2;
			ret = SR;
		} else if(c2=='p') {
			n=2;
			ret = ADDR+7;
		} else if(c2=='f' && c3=='c') {
			n=3;
			ret = SFC;
		}
		break;
#if defined(m68851) || defined(BUILTIN_MMUS)
	case 't':
		if(c2 == 'c') {
			n=2;
			ret=TC;
		}
#ifdef BUILTIN_MMUS
		else if (c2 == 't' && (c3 == '0' || c3 == '1')) {
			n = 3;
			if(c3 == '0')
			    ret = (TT0);
			else
			    ret = (TT1);
		}
#endif
		break;
#endif
	case 'u':
		if(c2=='s' && c3=='p') {
			n=3;
			ret = USP;
		}
#ifdef BUILTIN_MMUS
		else if(c2=='r' && c3=='p') {
			n=3;
			ret = URP;
		}
#endif
		break;
	case 'v':
#ifdef m68851
		if (c2 == 'a' && c3 == 'l') {
			n = 3;
			ret = (VAL);
		} else
#endif
		if(c2=='b' && c3=='r') {
			n=3;
			ret = VBR;
		}
		break;
	case 'z':
		if(c2=='p' && c3=='c') {
			n=3;
			ret = ZPC;
		}
		break;
	default:
		break;
	}
	if(n) {
		if(isalnum(ccp[0][n]) || ccp[0][n]=='_')
			ret=FAIL;
		else
			ccp[0]+=n;
	} else
		ret = FAIL;
	return ret;
}

#define SKIP_WHITE()	{ str++; if(*str==' ') str++;}

static
int
m68k_ip_op(
char *str,
struct m68k_op *opP)
{
	char	*strend;
	int32_t	i;

	if(*str==' ')
		str++;
		/* Find the end of the string */
	if(!*str) {
		/* Out of gas */
		opP->error="Missing operand";
		return FAIL;
	}
	for(strend=str;*strend;strend++)
		;
	--strend;

		/* Guess what:  A constant.  Shar and enjoy */
	if(*str=='#') {
		str++;
		opP->con1=add_exp(str,strend);
		opP->mode=IMMED;
		return OK;
	}
	i=m68k_reg_parse(&str);
	if((i==FAIL || *str!='\0') && *str!='@') {
		char *stmp;

		if(i!=FAIL && (*str=='/' || *str=='-')) {
			opP->mode=REGLST;
			return get_regs(i,opP,str);
		}
		if((stmp=index(str,'@'))) {
			opP->con1=add_exp(str,stmp-1);
			if(stmp==strend) {
				opP->mode=AINDX;
				return OK;
			}
			stmp++;
			if(*stmp++!='(' || *strend--!=')') {
				opP->error="Malformed operand";
				return FAIL;
			}
			i=try_index(&stmp,opP);
			opP->con2=add_exp(stmp,strend);
			if(i==FAIL) opP->mode=AMIND;
			else opP->mode=APODX;
			return OK;
		}
		opP->mode=ABSL;
		opP->con1=add_exp(str,strend);
		return OK;
	}
	opP->reg=i;
	if(*str=='\0') {
		if(i>=DATA+0 && i<=DATA+7)
			opP->mode=DREG;
		else if(i>=ADDR+0 && i<=ADDR+7)
			opP->mode=AREG;
		else
			opP->mode=MSCR;
		return OK;
	}
	if((i<ADDR+0 || i>ADDR+7) && i!=PC && i!=ZPC && i!=FAIL) {	/* Can't indirect off non address regs */
		opP->error="Invalid indirect register";
		return FAIL;
	}
	if(*str!='@')
		abort();
	str++;
	switch(*str) {
	case '\0':
		opP->mode=AINDR;
		return OK;
	case '-':
		opP->mode=ADEC;
		return OK;
	case '+':
		opP->mode=AINC;
		return OK;
	case '(':
		str++;
		break;
	default:
		opP->error="Junk after indirect";
		return FAIL;
	}
		/* Some kind of indexing involved.  Lets find out how bad it is */
	i=try_index(&str,opP);
		/* Didn't start with an index reg, maybe its offset or offset,reg */
	if(i==FAIL) {
		char *beg_str;

		beg_str=str;
		for(i=1;i;) {
			switch(*str++) {
			case '\0':
				opP->error="Missing )";
				return FAIL;
			case ',': i=0; break;
			case '(': i++; break;
			case ')': --i; break;
			}
		}
		opP->con1=add_exp(beg_str,str-2);
			/* Should be offset,reg */
		if(str[-1]==',') {
			i=try_index(&str,opP);
			if(i==FAIL) {
				opP->error="Malformed index reg";
				return FAIL;
			}
		}
	}
		/* We've now got offset)   offset,reg)   or    reg) */

	if(*str=='\0') {
		/* Th-the-thats all folks */
#ifdef NeXT_MOD
	/* all forms using zpc must use pc@(bd,Xn) and not pc@(d16) because
	   you can only suppress the base register in the first form */
		if(opP->reg==FAIL || opP->reg==ZPC) opP->mode=AINDX;	/* Other form of indirect */
#else /* !defined(NeXT_MOD) */
		if(opP->reg==FAIL) opP->mode=AINDX;	/* Other form of indirect */
#endif /* NeXT_MOD */
		else if(opP->ireg==FAIL) opP->mode=AOFF;
		else opP->mode=AINDX;
		return OK;
	}
		/* Next thing had better be another @ */
	if(*str!='@' || str[1]!='(') {
		opP->error="junk after indirect";
		return FAIL;
	}
	str+=2;
	if(opP->ireg!=FAIL) {
		opP->mode=APRDX;
		i=try_index(&str,opP);
		if(i!=FAIL) {
			opP->error="Two index registers!  not allowed!";
			return FAIL;
		}
	} else
		i=try_index(&str,opP);
	if(i==FAIL) {
		char *beg_str;

		beg_str=str;
		for(i=1;i;) {
			switch(*str++) {
			case '\0':
				opP->error="Missing )";
				return FAIL;
			case ',': i=0; break;
			case '(': i++; break;
			case ')': --i; break;
			}
		}
		opP->con2=add_exp(beg_str,str-2);
		if(str[-1]==',') {
			if(opP->ireg!=FAIL) {
				opP->error="Can't have two index regs";
				return FAIL;
			}
			i=try_index(&str,opP);
			if(i==FAIL) {
				opP->error="malformed index reg";
				return FAIL;
			}
			opP->mode=APODX;
		} else if(opP->ireg!=FAIL)
			opP->mode=APRDX;
		else
			opP->mode=AMIND;
	} else
		opP->mode=APODX;
	if(*str!='\0') {
		opP->error="Junk after indirect";
		return FAIL;
	}
	return OK;
}

static
int
try_index(
char **s,
struct m68k_op *opP)
{
	register int	i;
	char	*ss;
#define SKIP_W()	{ ss++; if(*ss==' ') ss++;}

	ss= *s;
	/* SKIP_W(); */
	i=m68k_reg_parse(&ss);
	if(!(i>=DATA+0 && i<=ADDR+7)) {	/* if i is not DATA or ADDR reg */
		*s=ss;
		return FAIL;
	}
	opP->ireg=i;
	/* SKIP_W(); */
	if(*ss==')') {
		opP->isiz=0;
		opP->imul=1;
		SKIP_W();
		*s=ss;
		return OK;
	}
	if(*ss!=':') {
		opP->error="Missing : in index register";
		*s=ss;
		return FAIL;
	}
	SKIP_W();
	if(mklower(*ss)=='w') opP->isiz=2;
	else if(mklower(*ss)=='l') opP->isiz=3;
	else {
		opP->error="Size spec not :w or :l";
		*s=ss;
		return FAIL;
	}
	SKIP_W();
	if(*ss==':') {
		SKIP_W();
		switch(*ss) {
		case '1':
		case '2':
		case '4':
		case '8':
			opP->imul= *ss-'0';
			break;
		default:
			opP->error="index multiplier not 1, 2, 4 or 8";
			*s=ss;
			return FAIL;
		}
		SKIP_W();
	} else opP->imul=1;
	if(*ss!=')') {
		opP->error="Missing )";
		*s=ss;
		return FAIL;
	}
	SKIP_W();
	*s=ss;
	return OK;
}

#ifdef TEST1	/* TEST1 tests m68k_ip_op(), which parses operands */
void
main(
int argc,
char *argv[],
char *envp[])
{
    char buf[128];
    struct m68k_op thark;

	for(;;){
		if(!gets(buf))
		    break;
		memset(&thark, '\0', sizeof(thark));
		if(!m68k_ip_op(buf, &thark))
		    printf("FAIL:");
		if(thark.error)
		    printf("op1 error %s in %s\n",thark.error,buf);
		printf("mode %d, reg %d, ",thark.mode,thark.reg);
		if(thark.con1)
		    printf("con1: '%.*s',",
			   1 + thark.con1->e_end - thark.con1->e_beg,
			   thark.con1->e_beg);
		printf("ireg %d, isiz %d, imul %d ",
		       thark.ireg, thark.isiz, thark.imul);
		if(thark.con2)
		    printf("con2: '%.*s'",
			   1 + thark.con2->e_end - thark.con2->e_beg,
			   thark.con2->e_beg);
		printf("\n");
	}
	exit(0);
}
#endif /* TEST1 */


/*
 * Handle of the OPCODE hash table NULL means any use before m68_ip_begin()
 * will crash.
 */
static struct hash_control *op_hash = NULL;


/*
 *		m 6 8 _ i p ( )
 *
 * This converts a string into a 68k instruction.
 * The string must be a bare single instruction in sun format
 * with RMS-style 68020 indirects
 *  (example:  )
 *
 * It provides some error messages: at most one fatal error message (which
 * stops the scan) and at most one warning message for each operand.
 * The 68k instruction is returned in exploded form, since we have no
 * knowledge of how you parse (or evaluate) your expressions.
 * We do however strip off and decode addressing modes and operation
 * mnemonic.
 *
 * This function's value is a string. If it is not "" then an internal
 * logic error was found: read this code to assign meaning to the string.
 * No argument string should generate such an error string:
 * it means a bug in our code, not in the user's text.
 *
 * You MUST have called m86_ip_begin() once and m86_ip_end() never before using
 * this function.
 */

/* JF this function no longer returns a useful value.  Sorry */
static
void
m68_ip(
char *instring)
{
	register char *p;
	register struct m68k_op *opP;
	register struct m68_incant *opcode;
	register char *s;
	register int tmpreg = 0,
		baseo = 0,
		outro = 0,
		nextword;
	int	siz1,
		siz2;
	char	c;
	int	losing;
	int	opsfound;
	LITTLENUM_TYPE words[6];
	LITTLENUM_TYPE *wordp;

	if (*instring == ' ')
		instring++;			/* skip leading whitespace */

  /* Scan up to end of operation-code, which MUST end in end-of-string
     or exactly 1 space. */
	for (p = instring; *p != '\0'; p++)
		if (*p == ' ')
			break;


	if (p == instring) {
		the_ins.error = "No operator";
		the_ins.opcode[0] = 0;
		/* the_ins.numo=1; */
		return;
	}

  /* p now points to the end of the opcode name, probably whitespace.
     make sure the name is null terminated by clobbering the whitespace,
     look it up in the hash table, then fix it back. */   
	c = *p;
	*p = '\0';
	opcode = (struct m68_incant *)hash_find (op_hash, instring);
	*p = c;

	if (opcode == NULL) {
		the_ins.error = "Unknown operator";
		the_ins.opcode[0] = 0;
		/* the_ins.numo=1; */
		return;
	}

  /* found a legitimate opcode, start matching operands */
	for(opP= &the_ins.operands[0];*p;opP++) {
		p = crack_operand (p, opP);
		if(opP->error) {
			the_ins.error=opP->error;
			return;
		}
	}

	opsfound=opP- &the_ins.operands[0];
	/* This ugly hack is to support the floating pt opcodes in their standard form */
	/* Essentially, we fake a first enty of type COP#1 */
	if(opcode->m_operands[0]=='I') {
		int	n;

		for(n=opsfound;n>0;--n)
			the_ins.operands[n]=the_ins.operands[n-1];

		/* bcopy((char *)(&the_ins.operands[0]),(char *)(&the_ins.operands[1]),opsfound*sizeof(the_ins.operands[0])); */
		memset((char *)(&the_ins.operands[0]), '\0',
		       sizeof(the_ins.operands[0]));
		the_ins.operands[0].mode=MSCR;
		the_ins.operands[0].reg=COPNUM;		/* COP #1 */
		opsfound++;
	}
		/* We've got the operands.  Find an opcode that'll
		   accept them */
	for(losing=0;;) {
		if(opsfound!=opcode->m_opnum)
			losing++;
		else for(s=opcode->m_operands,opP= &the_ins.operands[0];*s && !losing;s+=2,opP++) {
				/* Warning: this switch is huge! */
				/* I've tried to organize the cases into  this order:
				   non-alpha first, then alpha by letter.  lower-case goes directly
				   before uppercase counterpart. */
				/* Code with multiple case ...: gets sorted by the lowest case ...
				   it belongs to.  I hope this makes sense. */
			switch(*s) {
			case '!':
				if(opP->mode==MSCR || opP->mode==IMMED ||
 opP->mode==DREG || opP->mode==AREG || opP->mode==AINC || opP->mode==ADEC || opP->mode==REGLST)
					losing++;
				break;

			case '#':
				if(opP->mode!=IMMED)
 					losing++;
				else {
					int32_t t;

					t=get_num(opP->con1,80);
					if(s[1]=='b' && !isbyte(t))
						losing++;
#ifdef CHECK_WORD_IMMEDIATES
					else if((s[1]=='w' || s[1]=='z') &&
						!isword(t))
						losing++;
#else
					else if(s[1]=='z' && !isword(t))
						losing++;
#endif
				}
				break;

			case '^':
			case 'T':
				if(opP->mode!=IMMED)
					losing++;
				break;

			case '$':
				if(opP->mode==MSCR || opP->mode==AREG ||
 opP->mode==IMMED || opP->reg==PC || opP->reg==ZPC || opP->mode==REGLST)
					losing++;
				break;

			case '%':
				if(opP->mode==MSCR || opP->reg==PC ||
 opP->reg==ZPC || opP->mode==REGLST)
					losing++;
				break;


			case '&':
				if(opP->mode==MSCR || opP->mode==DREG ||
 opP->mode==AREG || opP->mode==IMMED || opP->reg==PC || opP->reg==ZPC ||
 opP->mode==AINC || opP->mode==ADEC || opP->mode==REGLST)
					losing++;
				break;

			case '*':
				if(opP->mode==MSCR || opP->mode==REGLST)
					losing++;
				break;

			case '+':
				if(opP->mode!=AINC)
					losing++;
				break;

			case '-':
				if(opP->mode!=ADEC)
					losing++;
				break;

#ifdef NeXT_MOD
			case '0':
				if(opP->mode!=AINDR)
					losing++;
				break;
#endif /* NeXT_MOD */

			case '/':
				if(opP->mode==MSCR || opP->mode==AREG ||
 opP->mode==AINC || opP->mode==ADEC || opP->mode==IMMED || opP->mode==REGLST)
					losing++;
				break;

			case ';':
				if(opP->mode==MSCR || opP->mode==AREG || opP->mode==REGLST)
					losing++;
				break;

			case '?':
				if(opP->mode==MSCR || opP->mode==AREG ||
 opP->mode==AINC || opP->mode==ADEC || opP->mode==IMMED || opP->reg==PC ||
 opP->reg==ZPC || opP->mode==REGLST)
					losing++;
				break;

			case '@':
				if(opP->mode==MSCR || opP->mode==AREG ||
 opP->mode==IMMED || opP->mode==REGLST)
					losing++;
				break;

			case '~':		/* For now! (JF FOO is this right?) */
				if(opP->mode==MSCR || opP->mode==DREG ||
 opP->mode==AREG || opP->mode==IMMED || opP->reg==PC || opP->reg==ZPC || opP->mode==REGLST)
					losing++;
				break;

			case 'A':
				if(opP->mode!=AREG)
					losing++;
				break;

			case 'B':	/* FOO */
				if(opP->mode!=ABSL)
					losing++;
				break;

			case 'C':
				if(opP->mode!=MSCR || opP->reg!=CCR)
					losing++;
				break;

			case 'd':	/* FOO This mode is a KLUDGE!! */
				if(opP->mode!=AOFF && (opP->mode!=ABSL ||
 opP->con1->e_beg[0]!='(' || opP->con1->e_end[0]!=')'))
					losing++;
				break;

			case 'D':
				if(opP->mode!=DREG)
					losing++;
				break;

			case 'F':
				if(opP->mode!=MSCR || opP->reg<(FPREG+0) || opP->reg>(FPREG+7))
					losing++;
				break;

			case 'I':
				if(opP->mode!=MSCR || opP->reg<COPNUM ||
 opP->reg>=COPNUM+7)
					losing++;
				break;

			case 'J':
#ifdef BUILTIN_MMUS
				if(opP->mode!=MSCR || opP->reg<USP || opP->reg>SRP)
#else
				if(opP->mode!=MSCR || opP->reg<USP || opP->reg>MSP)
#endif
					losing++;
				break;

			case 'k':
				if(opP->mode!=IMMED)
					losing++;
				break;

			case 'l':
			case 'L':
				if(opP->mode==DREG || opP->mode==AREG || opP->mode==FPREG) {
					if(s[1]=='8')
						losing++;
					else {
						opP->mode=REGLST;
						opP->reg=1<<(opP->reg-DATA);
					}
				} else if(opP->mode!=REGLST) {
					losing++;
				} else if(s[1]=='8' && opP->reg&0x0FFffFF)
					losing++;
				else if(s[1]=='3' && opP->reg&0x7000000)
					losing++;
				break;

			case 'M':
				if(opP->mode!=IMMED)
					losing++;
				else {
					int32_t t;

					t=get_num(opP->con1,80);
#ifdef NeXT_MOD	/* feature to try to make expressions absolute */
					/* DJA -- Bug fix. allow absolute expressions */
					if(! (issbyte(t) && seg(opP->con1)==SEG_ABSOLUTE) )
#else /* !defined(NeXT_MOD) */
					if(!issbyte(t) || isvar(opP->con1))
#endif /* NeXT_MOD */
						losing++;
				}
				break;

			case 'O':
				if(opP->mode!=DREG && opP->mode!=IMMED)
					losing++;
				break;

			case 'Q':
				if(opP->mode!=IMMED)
					losing++;
				else {
					int32_t t;

					t=get_num(opP->con1,80);
					if(t<1 || t>8 || isvar(opP->con1))
						losing++;
				}
				break;

			case 'R':
				if(opP->mode!=DREG && opP->mode!=AREG)
					losing++;
				break;

			case 's':
				if(opP->mode!=MSCR || !(opP->reg==FPI || opP->reg==FPS || opP->reg==FPC))
					losing++;
				break;

			case 'S':
				if(opP->mode!=MSCR || opP->reg!=SR)
					losing++;
				break;

			case 'U':
				if(opP->mode!=MSCR || opP->reg!=USP)
					losing++;
				break;

			/* JF these are out of order.  We could put them
			   in order if we were willing to put up with
			   bunches of #ifdef m68851s in the code */
#ifdef m68851
			/* Memory addressing mode used by pflushr */
			case '|':
				if(opP->mode==MSCR || opP->mode==DREG ||
 opP->mode==AREG || opP->mode==REGLST)
					losing++;
				break;
#endif

#if defined(m68851) || defined(BUILTIN_MMUS)
			case 'f':
				if (opP->mode != MSCR || (opP->reg != SFC && opP->reg != DFC))
					losing++;
				break;
#endif

#ifdef m68851
			case 'P':
				if (opP->mode != MSCR || (opP->reg != TC && opP->reg != CAL &&
				    opP->reg != VAL && opP->reg != SCC && opP->reg != AC))
					losing++;
				break;

			case 'V':
				if (opP->reg != VAL)
					losing++;
				break;

			case 'W':
				if (opP->mode != MSCR || (opP->reg != DRP && opP->reg != SRP &&
				    opP->reg != CRP))
					losing++;
				break;

			case 'X':
				if (opP->mode != MSCR ||
				    (!(opP->reg >= BAD && opP->reg <= BAD+7) &&
				     !(opP->reg >= BAC && opP->reg <= BAC+7)))
					losing++;
				break;

			case 'Y':
				if (opP->reg != PSR)
					losing++;
				break;

			case 'Z':
				if (opP->reg != PCSR)
					losing++;
				break;
#endif
#ifdef BUILTIN_MMUS
			case 'a':
				if ((opP->mode != MSCR) || (opP->reg != SRP &&
				     opP->reg != CRP && opP->reg != TC))
					losing++;
				break;
			case 'b':
				if (opP->mode != MSCR || opP->reg != MMUSR)
					losing++;
				break;
			case 'c':
				if ((opP->mode != MSCR) || (opP->reg != IC &&
				     opP->reg != DC && opP->reg != BC))
					losing++;
				break;
			case 'e':
				if ((opP->mode != MSCR) || (opP->reg != TT0 &&
				     opP->reg != TT1))
					losing++;
				break;
#endif
			default:
				as_fatal("Internal error:  Operand mode %c unknown",*s);
			}
		}
		if(!losing)
			break;
		opcode=opcode->m_next;
		if(!opcode) {		/* Fell off the end */
			the_ins.error="instruction/operands mismatch";
			return;
		}
		losing=0;
	}
	the_ins.args=opcode->m_operands;
	the_ins.numargs=opcode->m_opnum;
	the_ins.numo=opcode->m_codenum;
	the_ins.opcode[0]=getone(opcode);
	the_ins.opcode[1]=gettwo(opcode);
#ifdef NeXT_MOD
	the_ins.cpus=opcode->m_cpus;
#endif /* NeXT_MOD */

	for(s=the_ins.args,opP= &the_ins.operands[0];*s;s+=2,opP++) {
			/* This switch is a doozy.
			   What the first step; its a big one! */
		switch(s[0]) {

		case '*':
		case '~':
		case '%':
		case ';':
		case '@':
		case '!':
		case '&':
		case '$':
		case '?':
		case '/':
#ifdef m68851
		case '|':
#endif
			switch(opP->mode) {
			case IMMED:
				tmpreg=0x3c;	/* 7.4 */
				if(index("bwzl",s[1]))
					nextword=get_num(opP->con1,80);
				else
					nextword=get_num(opP->con1,0);
				if(isvar(opP->con1))
					add_fix(s[1],opP->con1,0);
				switch(s[1]) {
				case 'b':
					if(!isbyte(nextword))
						opP->error="operand out of range";
					addword(nextword);
					baseo=0;
					break;
				case 'w':
				case 'z':
#ifdef CHECK_WORD_IMMEDIATES
					if(!isword(nextword))
						opP->error="operand out of range";
#endif
					addword(nextword);
					baseo=0;
					break;
#ifdef NeXT_MOD	/* Used in the fmoveml (control) registers */
				case 's':
#endif /* NeXT_MOD */
				case 'l':
					addword(nextword>>16);
					addword(nextword);
					baseo=0;
					break;

				case 'f':
					baseo=2;
					outro=8;
					break;
				case 'F':
					baseo=4;
					outro=11;
					break;
				case 'x':
					baseo=6;
					outro=15;
					break;
#ifdef PACKED_IMMEDIATE
/* This does not work.  The call to gen_to_words() below does not put out
   68k packed decimal format. */
				case 'p':
					baseo=6;
					outro= -1;
					break;
#endif
				default:
					as_fatal("Internal error:  Can't decode %c%c",*s,s[1]);
				}
				if(!baseo)
					break;

				/* We gotta put out some float */
				if(seg(opP->con1)!=SEG_BIG) {
					int_to_gen(nextword);
					gen_to_words(words,baseo,(int32_t)outro);
					for(wordp=words;baseo--;wordp++)
						addword(*wordp);
					break;
				}		/* Its BIG */
				if(offs(opP->con1)>0) {
#ifndef NeXT_MOD 	/* fix for bug #8331 */
					as_warn("Bignum assumed to be binary bit-pattern");
#endif /* NeXT_MOD */
					if(offs(opP->con1)>baseo) {
						as_warn("Bignum too big for %c format; truncated",s[1]);
						offs(opP->con1)=baseo;
					}
					baseo-=offs(opP->con1);
					for(wordp=generic_bignum+offs(opP->con1)-1;offs(opP->con1)--;--wordp)
						addword(*wordp);
					while(baseo--)
						addword(0);
					break;
				}
				gen_to_words(words,baseo,(int32_t)outro);
				for(wordp=words;baseo--;wordp++)
					addword(*wordp);
				break;
			case DREG:
				tmpreg=opP->reg-DATA; /* 0.dreg */
				break;
			case AREG:
				tmpreg=0x08+opP->reg-ADDR; /* 1.areg */
				break;
			case AINDR:
#ifdef NeXT_MOD
				/* fixes "pc@" operand */
				if(opP->reg==PC){
					tmpreg=0x3A; /* 7.2 */
					addword(0x0000);
				}
				else
#endif /* NeXT_MOD */
				tmpreg=0x10+opP->reg-ADDR; /* 2.areg */
				break;
			case ADEC:
				tmpreg=0x20+opP->reg-ADDR; /* 4.areg */
				break;
			case AINC:
				tmpreg=0x18+opP->reg-ADDR; /* 3.areg */
				break;
			case AOFF:
				if(opP->reg==PC)
					tmpreg=0x3A; /* 7.2 */
				else
					tmpreg=0x28+opP->reg-ADDR; /* 5.areg */
				nextword=get_num(opP->con1,80);
				/* Force into index mode.  Hope this works */
				if(!issword(nextword)) {
					if(opP->reg==PC)
						tmpreg=0x3B;	/* 7.3 */
					else
						tmpreg=0x30+opP->reg-ADDR;	/* 6.areg */
					/* addword(0x0171); */
/* 171 seems to be wrong, and I can't find the 68020 manual, so we'll try 170
   (which is what the Sun asm seems to generate */
					addword(0x0170);
					if(isvar(opP->con1))
						add_fix('l',opP->con1,0);
					addword(nextword>>16);
					/* addword(nextword); */
				} else if(isvar(opP->con1)) {
					if(opP->reg==PC)
					    tmpreg=0x3B; /* 7.3 */
					else
					    tmpreg=0x30+opP->reg-ADDR;
					addword(0x0170);
					/*
					 * If this is a pc register with
					 * a SEGDIFF where the -symbol
					 * is "." adjust the value of
					 * of "." to include the two
					 * bytes of opcode.
					 */
					if(opP->reg==PC &&
					   seg(opP->con1) == SEG_DIFFSECT &&
					   opP->con1-> e_exp.X_subtract_symbol->
					     sy_frag == frag_now &&
					   strcmp(opP->con1->
					      e_exp.X_subtract_symbol->sy_name,
						  "L0\001") == 0)
					   opP->con1-> e_exp.X_subtract_symbol->
					     sy_nlist.n_value += 2;
					add_fix('l',opP->con1,0);
					addword(nextword>>16);
				}
				addword(nextword);
				break;
			case AINDX:
			case APODX:
			case AMIND:
			case APRDX:
				nextword=0;
				baseo=get_num(opP->con1,80);
				outro=get_num(opP->con2,80);
					/* Figure out the 'addressing mode' */
					/* Also turn on the BASE_DISABLE bit, if needed */
				if(opP->reg==PC || opP->reg==ZPC) {
					tmpreg=0x3b; /* 7.3 */
					if(opP->reg==ZPC)
						nextword|=0x80;
				} else if(opP->reg==FAIL) {
					nextword|=0x80;
					tmpreg=0x30;	/* 6.garbage */
				} else tmpreg=0x30+opP->reg-ADDR; /* 6.areg */

				siz1= (opP->con1) ? opP->con1->e_siz : 0;
				siz2= (opP->con2) ? opP->con2->e_siz : 0;

					/* Index register stuff */
				if(opP->ireg>=DATA+0 && opP->ireg<=ADDR+7) {
					nextword|=(opP->ireg-DATA)<<12;

					if(opP->isiz==0 || opP->isiz==3)
						nextword|=0x800;
					switch(opP->imul) {
					case 1: break;
					case 2: nextword|=0x200; break;
					case 4: nextword|=0x400; break;
					case 8: nextword|=0x600; break;
					default: abort();
					}
						/* IF its simple, GET US OUT OF HERE! */
						/* Must be INDEX, with an index register.  Address register
						   cannot be ZERO-PC, and either :b was forced, or we know it'll fit */
					if(opP->mode==AINDX &&
 opP->reg!=FAIL && opP->reg!=ZPC && (siz1==1 || (issbyte(baseo) &&
 !isvar(opP->con1)))) {
						nextword +=baseo&0xff;
						addword(nextword);
						if(isvar(opP->con1))
							add_fix('B',opP->con1,0);
						break;
					}
				} else
					nextword|=0x40;	/* No index reg */

					/* It aint simple */
				nextword|=0x100;
					/* If the guy specified a width, we assume that
					   it is wide enough.  Maybe it isn't.  Ifso, we lose
					 */
				switch(siz1) {
				case 0:
					if(isvar(opP->con1) || !issword(baseo)) {
						siz1=3;
						nextword|=0x30;
					} else if(baseo==0)
						nextword|=0x10;
					else {	
						nextword|=0x20;
						siz1=2;
					}
					break;
				case 1:
					as_warn("Byte dispacement won't work.  Defaulting to :w");
				case 2:
					nextword|=0x20;
					break;
				case 3:
					nextword|=0x30;
					break;
				}

					/* Figure out innner displacement stuff */
				if(opP->mode!=AINDX) {
					switch(siz2) {
					case 0:
						if(isvar(opP->con2) || !issword(outro)) {
							siz2=3;
							nextword|=0x3;
						} else if(outro==0)
							nextword|=0x1;
						else {	
							nextword|=0x2;
							siz2=2;
						}
						break;
					case 1:
						as_warn("Byte dispacement won't work.  Defaulting to :w");
					case 2:
						nextword|=0x2;
						break;
					case 3:
						nextword|=0x3;
						break;
					}
					if(opP->mode==APODX) nextword|=0x04;
					else if(opP->mode==AMIND) nextword|=0x40;
				}
				addword(nextword);

				if(isvar(opP->con1))
					add_fix(siz1==3 ? 'l' : 'w',opP->con1,0);
				if(siz1==3)
					addword(baseo>>16);
				if(siz1)
					addword(baseo);

				if(isvar(opP->con2))
					add_fix(siz2==3 ? 'l' : 'w',opP->con2,0);
				if(siz2==3)
					addword(outro>>16);
				if(siz2)
					addword(outro);

				break;

			case ABSL:
				nextword=get_num(opP->con1,80);
				switch(opP->con1->e_siz) {
				case 1: /* treat like not there, fall through */
				    as_warn("ignoring :b suffix on %*s",
				       (int)(opP->con1->e_end-opP->con1->e_beg),
				       opP->con1->e_beg);
				case 0:
					if(!isvar(opP->con1) &&
					   issword(offs(opP->con1))) {
						tmpreg=0x38; /* 7.0 */
						addword(nextword);
						break;
					}
					/* Don't generate pc relative code
					   on 68010 and 68000 */
					if(isvar(opP->con1) &&
					   !subs(opP->con1) &&
					   seg(opP->con1) == SEG_SECT &&
					   frchain_now->frch_nsect ==
					       opP->con1->e_exp.X_add_symbol->
						    sy_nlist.n_sect &&
					   flagseen['m'] == 0 &&
					    !index("~%&$?", s[0])) {
						tmpreg=0x3A; /* 7.2 */
						add_frag(adds(opP->con1),
							 offs(opP->con1),
							 TAB(PCREL,SZ_UNDEF));
						break;
					}
				case 3:		/* Fall through into long */
					if(isvar(opP->con1))
						add_fix('l',opP->con1,0);

					tmpreg=0x39;	/* 7.1 mode */
					addword(nextword>>16);
					addword(nextword);
					break;

				case 2:		/* Word */
					if(isvar(opP->con1))
						add_fix('w',opP->con1,0);

					tmpreg=0x38;	/* 7.0 mode */
					addword(nextword);
					break;
				}
				break;
			case MSCR:
			default:
				as_bad("unknown/incorrect operand");
				/* abort(); */
			}
			install_gen_operand(s[1],tmpreg);
			break;

		case '#':
		case '^':
			switch(s[1]) {	/* JF: I hate floating point! */
			case 'j':
				tmpreg=70;
				break;
			case '8':
				tmpreg=20;
				break;
			case 'C':
				tmpreg=50;
				break;
			case '3':
			default:
				tmpreg=80;
				break;
			}
			tmpreg=get_num(opP->con1,tmpreg);
			if(isvar(opP->con1))
				add_fix(s[1],opP->con1,0);
			switch(s[1]) {
			case 'b':	/* Danger:  These do no check for
					   certain types of overflow.
					   user beware! */
				if(!isbyte(tmpreg))
					opP->error="out of range";
				insop(tmpreg);
				if(isvar(opP->con1))
					the_ins.reloc[the_ins.nrel-1].n=(opcode->m_codenum)*2;
				break;
#ifdef NeXT_MOD
			case 'j':
				if(tmpreg < 0 || tmpreg > 0xfff)
					opP->error="out of range";
				tmpreg&=0xFFF;
				install_operand(s[1],tmpreg);
				break;
#endif /* NeXT_MOD */
			case 'w':
			case 'z':
#ifdef CHECK_WORD_IMMEDIATES
				if(!isword(tmpreg))
					opP->error="out of range";
#endif
				insop(tmpreg);
				if(isvar(opP->con1))
					the_ins.reloc[the_ins.nrel-1].n=(opcode->m_codenum)*2;
				break;
			case 'l':
				insop(tmpreg);		/* Because of the way insop works, we put these two out backwards */
				insop(tmpreg>>16);
				if(isvar(opP->con1))
					the_ins.reloc[the_ins.nrel-1].n=(opcode->m_codenum)*2;
				break;
			case '3':
				tmpreg&=0xFF;
#ifdef NeXT_MOD
				if (isvar(opP->con1))
				  the_ins.reloc[the_ins.nrel-1].n = 
				    (opcode->m_codenum) + 1;
#endif /* NeXT_MOD */
			case '8':
			case 'C':
				install_operand(s[1],tmpreg);
				break;
			default:
				as_fatal("Internal error:  Unknown mode #%c",s[1]);
			}
			break;

		case '+':
		case '-':
		case 'A':
			install_operand(s[1],opP->reg-ADDR);
			break;

		case 'B':
			tmpreg = get_num(opP->con1, 80);
			switch(s[1]){
			case 'g':
			    /* Deal with fixed size stuff by hand */
			    if(opP->con1->e_siz){
				switch(opP->con1->e_siz){
				case 1:
				    add_fix('B', opP->con1, 1);
				    break;
				case 2:
				    if(strncmp(instring, "jbsr", 4) == 0){
					if(isvar(opP->con1))
					    add_fix('w', opP->con1, 0);
					/* force a jsr 7.0 mode (xxx):W */
					the_ins.opcode[the_ins.numo-1] = 0x4eb8;
					addword(tmpreg);
					break;
				    }
				    if(strncmp(instring, "jra", 3) == 0){
					if(isvar(opP->con1))
					    add_fix('w', opP->con1, 0);
					/* force a jmp 7.0 mode (xxx):W */
					the_ins.opcode[the_ins.numo-1] = 0x4ef8;
					addword(tmpreg);
					break;
				    }
				    opP->con1->e_exp.X_add_number += 2;
				    add_fix('w', opP->con1, 1);
				    addword(0);
				    break;
				case 3:
				    the_ins.opcode[the_ins.numo-1] |= 0xff;
				    opP->con1->e_exp.X_add_number += 4;
				    add_fix('l', opP->con1, 1);
				    addword(0);
				    addword(0);
				    break;
				default:
				    as_fatal("Bad size for expression %d",
					     opP->con1->e_siz);
				}
			    }
			    else if(subs(opP->con1)){
				/* We can't relax it */
				the_ins.opcode[the_ins.numo-1] |= 0xff;
				add_fix('l', opP->con1, 1);
				addword(0);
				addword(0);
			    }
			    else if(adds(opP->con1)){
				if(flagseen['m'] && 
				   (the_ins.opcode[0] >= 0x6200) &&
				   (the_ins.opcode[0] <= 0x6f00)){
				    add_frag(adds(opP->con1),
					     offs(opP->con1),
					     TAB(BCC68000, SZ_UNDEF));
				}
				else{
				    add_frag(adds(opP->con1),
					     offs(opP->con1),
					     TAB(BRANCH, SZ_UNDEF));
				}
			    }
			    else{
				the_ins.opcode[the_ins.numo-1] |= 0xff;
				opP->con1->e_exp.X_add_number += 4;
				add_fix('l', opP->con1, 1);
				addword(0);
				addword(0);
			    }
			    break;
			case 'w':
			    if(isvar(opP->con1)){
				/* check for DBcc instruction */
				if((the_ins.opcode[0] & 0xf0f8) ==0x50c8){
				    /* size varies if patch */
				    /* needed for long form */
				    add_frag(adds(opP->con1),
					     offs(opP->con1),
					     TAB(DBCC, SZ_UNDEF));
				    break;
				}
			    }
			    opP->con1->e_exp.X_add_number += 2;
			    add_fix('w', opP->con1, 1);
			    addword(0);
			    break;
			case 'c':
			    if(opP->con1->e_siz){
				switch(opP->con1->e_siz){
				case 2:
				    opP->con1->e_exp.X_add_number += 2;
				    add_fix('w', opP->con1, 1);
				    addword(0);
				    break;
				case 3:
				    the_ins.opcode[the_ins.numo-1] |= 0x40;
				    opP->con1->e_exp.X_add_number += 4;
				    add_fix('l', opP->con1, 1);
				    addword(0);
				    addword(0);
				    break;
				default:
				    as_bad("Bad size for offset, must be word "
					   "or long");
				    break;
				}
			    }
			    else if(subs(opP->con1)){
				/* We can't relax it */
				the_ins.opcode[the_ins.numo-1] |= 0x40;
				add_fix('l', opP->con1, 1);
				addword(0);
				addword(0);
			    }
			    else if(adds(opP->con1)){
				add_frag(adds(opP->con1),
					 offs(opP->con1),
					 TAB(FBRANCH, SZ_UNDEF));
			    }
			    else{
				the_ins.opcode[the_ins.numo-1] |= 0x40;
				opP->con1->e_exp.X_add_number += 4;
				add_fix('l', opP->con1, 1);
				addword(0);
				addword(0);
			    }
			    break;
			default:
			    as_fatal("Internal error: operand type B%c unknown",
				     s[1]);
			}
			break;

		case 'C':		/* Ignore it */
			break;

		case 'd':		/* JF this is a kludge */
			if(opP->mode==AOFF) {
				install_operand('s',opP->reg-ADDR);
			} else {
				char *tmpP;

				tmpP=opP->con1->e_end-2;
				opP->con1->e_beg++;
				opP->con1->e_end-=4;	/* point to the , */
				baseo=m68k_reg_parse(&tmpP);
				if(baseo<ADDR+0 || baseo>ADDR+7) {
					as_bad("Unknown address reg, using A0");
					baseo=0;
				} else baseo-=ADDR;
				install_operand('s',baseo);
			}
			tmpreg=get_num(opP->con1,80);
			if(!issword(tmpreg)) {
				as_warn("Expression out of range, using 0");
				tmpreg=0;
			}
			addword(tmpreg);
			break;

		case 'D':
			install_operand(s[1],opP->reg-DATA);
			break;

		case 'F':
			install_operand(s[1],opP->reg-FPREG);
			break;

		case 'I':
			tmpreg=1+opP->reg-COPNUM;
			if(tmpreg==8)
				tmpreg=0;
			install_operand(s[1],tmpreg);
			break;

		case 'J':		/* JF foo */
			switch(opP->reg) {
			case SFC:
				tmpreg=0;
				break;
			case DFC:
				tmpreg=0x001;
				break;
			case CACR:
				tmpreg=0x002;
				break;
			case USP:
				tmpreg=0x800;
				break;
			case VBR:
				tmpreg=0x801;
				break;
			case CAAR:
				tmpreg=0x802;
				break;
			case MSP:
				tmpreg=0x803;
				break;
			case ISP:
				tmpreg=0x804;
				break;
#ifdef BUILTIN_MMUS
			case TC:
				tmpreg=0x003;
				break;
			case ITT0:
				tmpreg=0x004;
				break;
			case ITT1:
				tmpreg=0x005;
				break;
			case DTT0:
				tmpreg=0x006;
				break;
			case DTT1:
				tmpreg=0x007;
				break;
			case MMUSR:
				tmpreg=0x805;
				break;
			case URP:
				tmpreg=0x806;
				break;
			case SRP:
				tmpreg=0x807;
				break;
#endif /* BUILTIN_MMUS */
			default:
				abort();
			}
			install_operand(s[1],tmpreg);
			break;
#ifdef NeXT_MOD
		case '0':
			tmpreg=opP->reg-ADDR;
			install_operand(s[1],tmpreg);
			break;
#endif /* NeXT_MOD */

		case 'k':
			tmpreg=get_num(opP->con1,55);
			install_operand(s[1],tmpreg&0x7f);
			break;

		case 'l':
			tmpreg=opP->reg;
			if(s[1]=='w') {
				if(tmpreg&0x7FF0000)
					as_bad("Floating point register in register list");
				insop(reverse_16_bits(tmpreg));
			} else {
				if(tmpreg&0x700FFFF)
					as_bad("Wrong register in floating-point reglist");
				install_operand(s[1],reverse_8_bits(tmpreg>>16));
			}
			break;

		case 'L':
			tmpreg=opP->reg;
			if(s[1]=='w') {
				if(tmpreg&0x7FF0000)
					as_bad("Floating point register in register list");
				insop(tmpreg);
			} else if(s[1]=='8') {
				if(tmpreg&0x0FFFFFF)
					as_bad("incorrect register in reglist");
				install_operand(s[1],tmpreg>>24);
			} else {
				if(tmpreg&0x700FFFF)
					as_bad("wrong register in floating-point reglist");
				else
					install_operand(s[1],tmpreg>>16);
			}
			break;

		case 'M':
			install_operand(s[1],get_num(opP->con1,60));
			break;

		case 'O':
			tmpreg= (opP->mode==DREG)
				? (int)(0x20+opP->reg-DATA)
				: (get_num(opP->con1,40)&0x1F);
			install_operand(s[1],tmpreg);
			break;

		case 'Q':
			tmpreg=get_num(opP->con1,10);
			if(tmpreg==8)
				tmpreg=0;
			install_operand(s[1],tmpreg);
			break;

		case 'R':
			/* This depends on the fact that ADDR registers are
			   eight more than their corresponding DATA regs, so
			   the result will have the ADDR_REG bit set */
			install_operand(s[1],opP->reg-DATA);
			break;

		case 's':
			if(opP->reg==FPI) tmpreg=0x1;
			else if(opP->reg==FPS) tmpreg=0x2;
			else if(opP->reg==FPC) tmpreg=0x4;
			else abort();
			install_operand(s[1],tmpreg);
			break;

		case 'S':	/* Ignore it */
			break;

		case 'T':
			install_operand(s[1],get_num(opP->con1,30));
			break;

		case 'U':	/* Ignore it */
			break;

#if defined(m68851) || defined(BUILTIN_MMUS)
			/* JF: These are out of order, I fear. */
		case 'f':
			switch (opP->reg) {
			case SFC:
				tmpreg=0;
				break;
			case DFC:
				tmpreg=1;
				break;
			default:
				abort();
			}
			install_operand(s[1],tmpreg);
			break;
#endif

#ifdef BUILTIN_MMUS
		case 'a':
			switch (opP->reg) {
			case SRP:
				tmpreg=2;
				break;
			case CRP:
				tmpreg=3;
				break;
			case TC:
				tmpreg=0;
				break;
			default:
				abort();
			}
			install_operand(s[1],tmpreg);
			break;
		case 'b':
			switch (opP->reg) {
			case MMUSR:
				tmpreg=0;
				break;
			default:
				abort();
			}
			install_operand(s[1],tmpreg);
			break;
		case 'c':
			switch (opP->reg) {
			case IC:
				tmpreg=2;
				break;
			case DC:
				tmpreg=1;
				break;
			case BC:
				tmpreg=3;
				break;
			default:
				abort();
			}
			install_operand(s[1],tmpreg);
			break;
		case 'e':
			switch (opP->reg) {
			case TT0:
				tmpreg=2;
				break;
			case TT1:
				tmpreg=3;
				break;
			default:
				abort();
			}
			install_operand(s[1],tmpreg);
			break;
#endif

#ifdef m68851
		case 'P':
			switch(opP->reg) {
			case TC:
				tmpreg=0;
				break;
			case CAL:
				tmpreg=4;
				break;
			case VAL:
				tmpreg=5;
				break;
			case SCC:
				tmpreg=6;
				break;
			case AC:
				tmpreg=7;
				break;
			default:
				abort();
			}
			install_operand(s[1],tmpreg);
			break;

		case 'V':
			if (opP->reg == VAL)
				break;
			abort();

		case 'W':
			switch(opP->reg) {

			case DRP:
				tmpreg=1;
				break;
			case SRP:
				tmpreg=2;
				break;
			case CRP:
				tmpreg=3;
				break;
			default:
				abort();
			}
			install_operand(s[1],tmpreg);
			break;

		case 'X':
			switch (opP->reg) {
			case BAD: case BAD+1: case BAD+2: case BAD+3:
			case BAD+4: case BAD+5: case BAD+6: case BAD+7:
				tmpreg = (4 << 10) | ((opP->reg - BAD) << 2);
				break;

			case BAC: case BAC+1: case BAC+2: case BAC+3:
			case BAC+4: case BAC+5: case BAC+6: case BAC+7:
				tmpreg = (5 << 10) | ((opP->reg - BAC) << 2);
				break;

			default:
				abort();
			}
			install_operand(s[1], tmpreg);
			break;
		case 'Y':
			if (opP->reg == PSR)
				break;
			abort();

		case 'Z':
			if (opP->reg == PCSR)
				break;
			abort();
#endif /* m68851 */
		default:
			as_fatal("Internal error:  Operand type %c unknown",s[0]);
		}
	}
	/* By the time whe get here (FINALLY) the_ins contains the complete
	   instruction, ready to be emitted. . . */
}

static
int
get_regs(
int i,
struct m68k_op *opP,
char *str)
{
	/*			     26, 25, 24, 23-16,  15-8, 0-7 */
	/* Low order 24 bits encoded fpc,fps,fpi,fp7-fp0,a7-a0,d7-d0 */
	uint32_t cur_regs = 0;
	int	reg1,
		reg2;

#define ADD_REG(x)	{     if(x==FPI) cur_regs|=(1<<24);\
			 else if(x==FPS) cur_regs|=(1<<25);\
			 else if(x==FPC) cur_regs|=(1<<26);\
			 else cur_regs|=(1<<(x-1));  }

	reg1=i;
	for(;;) {
		if(*str=='/') {
			ADD_REG(reg1);
			str++;
		} else if(*str=='-') {
			str++;
			reg2=m68k_reg_parse(&str);
			if(reg2<DATA || reg2>=FPREG+8 || reg1==FPI || reg1==FPS || reg1==FPC) {
				opP->error="unknown register in register list";
				return FAIL;
			}
			while(reg1<=reg2) {
				ADD_REG(reg1);
				reg1++;
			}
			if(*str=='\0')
				break;
		} else if(*str=='\0') {
			ADD_REG(reg1);
			break;
		} else {
			opP->error="unknow character in register list";
			return FAIL;
		}
/* DJA -- Bug Fix.  Did't handle d1-d2/a1 until the following instruction was added */
		if (*str=='/')
		  str ++;
		reg1=m68k_reg_parse(&str);
		if((reg1<DATA || reg1>=FPREG+8) && !(reg1==FPI || reg1==FPS || reg1==FPC)) {
			opP->error="unknown register in register list";
			return FAIL;
		}
	}
	opP->reg=cur_regs;
	return OK;
}

static
int
reverse_16_bits(
int in)
{
	int out=0;
	int n;

	static int mask[16] = {
0x0001,0x0002,0x0004,0x0008,0x0010,0x0020,0x0040,0x0080,
0x0100,0x0200,0x0400,0x0800,0x1000,0x2000,0x4000,0x8000
	};
	for(n=0;n<16;n++) {
		if(in&mask[n])
			out|=mask[15-n];
	}
	return out;
}

static
int
reverse_8_bits(
int in)
{
	int out=0;
	int n;

	static int mask[8] = {
0x0001,0x0002,0x0004,0x0008,0x0010,0x0020,0x0040,0x0080,
	};

	for(n=0;n<8;n++) {
		if(in&mask[n])
			out|=mask[7-n];
	}
	return out;
}

static
void
install_operand(
int mode,
int val)
{
	switch(mode) {
	case 's':
		the_ins.opcode[0]|=val & 0xFF;	/* JF FF is for M kludge */
		break;
	case 'd':
		the_ins.opcode[0]|=val<<9;
		break;
	case '1':
		the_ins.opcode[1]|=val<<12;
		break;
	case '2':
		the_ins.opcode[1]|=val<<6;
		break;
	case '3':
		the_ins.opcode[1]|=val;
		break;
	case '4':
		the_ins.opcode[2]|=val<<12;
		break;
	case '5':
		the_ins.opcode[2]|=val<<6;
		break;
	case '6':
			/* DANGER!  This is a hack to force cas2l and cas2w cmds
			   to be three words long! */
		the_ins.numo++;
		the_ins.opcode[2]|=val;
		break;
	case '7':
		the_ins.opcode[1]|=val<<7;
		break;
	case '8':
		the_ins.opcode[1]|=val<<10;
		break;
#if defined(m68851) || defined(BUILTIN_MMUS)
	case '9':
		the_ins.opcode[1]|=val<<5;
		break;
#endif
#ifdef BUILTIN_MMUS
	case 'S':
		the_ins.opcode[0]|=val<<6;
		break;
#endif
	case 't':
		the_ins.opcode[1]|=(val<<10)|(val<<7);
		break;
	case 'D':
		the_ins.opcode[1]|=(val<<12)|val;
		break;
	case 'g':
		the_ins.opcode[0]|=val=0xff;
		break;
	case 'i':
		the_ins.opcode[0]|=val<<9;
		break;
	case 'C':
		the_ins.opcode[1]|=val;
		break;
	case 'j':
		the_ins.opcode[1]|=val;
		the_ins.numo++;		/* What a hack */
		break;
	case 'k':
		the_ins.opcode[1]|=val<<4;
		break;
	case 'b':
	case 'w':
	case 'l':
		break;
	case 'c':
	default:
		abort();
	}
}

static
void
install_gen_operand(
int mode,
int val)
{
	switch(mode) {
	case 's':
		the_ins.opcode[0]|=val;
		break;
	case 'd':
			/* This is a kludge!!! */
		the_ins.opcode[0]|=(val&0x07)<<9|(val&0x38)<<3;
		break;
	case 'b':
	case 'w':
	case 'l':
	case 'f':
	case 'F':
	case 'x':
	case 'p':
		the_ins.opcode[0]|=val;
		break;
		/* more stuff goes here */
	default:
		abort();
	}
}

static
char *
crack_operand(
char *str,
struct m68k_op *opP)
{
	register int parens;
	register int c;
	register char *beg_str;

	if(!str) {
		return str;
	}
	beg_str=str;
	for(parens=0;*str && (parens>0 || notend(str));str++) {
		if(*str == '"') {
			str++;
			while(*str && *str != '"')
				str++;
			if(*str != '"'){	/* ERROR */
				opP->error="Missing \"";
				return str;
			}
		}
		else{	
			if(*str=='(')
				parens++;
			else if(*str==')') {
				if(!parens) {		/* ERROR */
					opP->error="Extra )";
					return str;
				}
				--parens;
			}
		}
	}
	if(!*str && parens) {		/* ERROR */
		opP->error="Missing )";
		return str;
	}
	c= *str;
	*str='\0';
	if(m68k_ip_op(beg_str,opP)==FAIL) {
		*str=c;
		return str;
	}
	*str=c;
	if(c=='}')
		c= *++str;		/* JF bitfield hack */
	if(c) {
 		c= *++str;
		if(!c)
			as_bad("Missing operand");
	}
	return str;
}

/* See the comment up above where the #define notend(... is */
#if 0
notend(s)
char *s;
{
	if(*s==',') return 0;
	if(*s=='{' || *s=='}')
		return 0;
	if(*s!=':') return 1;
		/* This kludge here is for the division cmd, which is a kludge */
	if(index("aAdD#",s[1])) return 0;
	return 1;
}
#endif /* 0 */

#ifdef NeXT_MOD
static char *file_030, *file_040;
static uint32_t line_030, line_040;
#endif /* NeXT_MOD */

/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This funciton is supposed to emit
   the frags/bytes it assembles to.
 */
void
md_assemble(
char *str)
{
	char *er;
	short	*fromP;
	char	*toP = NULL;
	int	m,n;
	char	*to_beg_P;
	int	shorts_this_frag;

	n = 0;
	memset((char *)(&the_ins), '\0', sizeof(the_ins));
	m68_ip(str);
	er=the_ins.error;
	if(!er) {
		for(n=the_ins.numargs;n;--n)
			if(the_ins.operands[n].error) {
				er=the_ins.operands[n].error;
				break;
			}
	}
	if(er) {
		as_bad("\"%s\" -- Statement '%s' ignored",er,str);
		return;
	}

#ifdef NeXT_MOD
	if(the_ins.cpus != NULL && !force_cpusubtype_ALL){
	    if(md_cpusubtype == CPU_SUBTYPE_MC680x0_ALL){
		switch(*the_ins.cpus){
		case '2':
		    as_bad("implementation specific instruction for the MC68020"
			   " and -force_cpusubtype_ALL not specified");
		    break;
		case '3':
		    if(archflag_cpusubtype == CPU_SUBTYPE_MC68040)
			as_bad("030 instruction not allowed with -arch m68040");
		    else{
			file_030 = logical_input_file ?
				   logical_input_file : physical_input_file;
			line_030 = logical_input_line ?
				   logical_input_line : physical_input_line;
			md_cpusubtype = CPU_SUBTYPE_MC68030_ONLY;
		    }
		    break;
		case '4':
		    if(archflag_cpusubtype == CPU_SUBTYPE_MC68030_ONLY)
			as_bad("040 instruction not allowed with -arch m68030");
		    else{
			file_040 = logical_input_file ?
				   logical_input_file : physical_input_file;
			line_040 = logical_input_line ?
				   logical_input_line : physical_input_line;
			md_cpusubtype = CPU_SUBTYPE_MC68040;
		    }
		    break;
		}
	    }
	    else{
		switch(*the_ins.cpus){
		case '2':
		    as_bad("implementation specific instruction for the MC68020"
			   " and -force_cpusubtype_ALL not specified");
		    break;
		case '3':
		    if(archflag_cpusubtype == CPU_SUBTYPE_MC68040)
			as_bad("030 instruction not allowed with -arch m68040");
		    else{
			if(md_cpusubtype != CPU_SUBTYPE_MC680x0_ALL &&
			   md_cpusubtype != CPU_SUBTYPE_MC68030_ONLY)
			    as_bad("more than one implementation specific "
				   "instruction seen and -force_cpusubtype_ALL "
				   " not specified (first 040 instruction in: "
				   "%s at line %u)", file_040, line_040);
			md_cpusubtype = CPU_SUBTYPE_MC68030_ONLY;
		    }
		    break;
		case '4':
		    if(archflag_cpusubtype == CPU_SUBTYPE_MC68030_ONLY)
			as_bad("040 instruction not allowed with -arch m68030");
		    else{
			if(md_cpusubtype != CPU_SUBTYPE_MC680x0_ALL &&
			   md_cpusubtype != CPU_SUBTYPE_MC68040)
			    as_bad("more than one implementation specific "
				   "instruction seen and -force_cpusubtype_ALL "
				   "not specified (first 030 instruction in: "
				   "%s at line %u)", file_030, line_030);
			md_cpusubtype = CPU_SUBTYPE_MC68040;
		    }
		    break;
		}
	    }
	}
#endif /* NeXT_MOD */

#ifdef NeXT_MOD	/* generate stabs for debugging assembly code */
	/*
	 * If the -g flag is present generate a line number stab for the
	 * instruction.
	 * 
	 * See the detailed comments about stabs in read_a_source_file() for a
	 * description of what is going on here.
	 */
	if(flagseen['g'] && frchain_now->frch_nsect == text_nsect){
	    (void)symbol_new(
		  "",
		  68 /* N_SLINE */,
		  text_nsect,
		  logical_input_line /* n_desc, line number */,
		  obstack_next_free(&frags) - frag_now->fr_literal,
		  frag_now);
	}
#endif /* NeXT_MOD */

#ifdef NeXT_MOD	/* mark sections containing instructions */
	/*
	 * We are putting a machine instruction in this section so mark it as
	 * containg some machine instructions.
	 */
	frchain_now->frch_section.flags |= S_ATTR_SOME_INSTRUCTIONS;
#endif /* NeXT_MOD */

	if(the_ins.nfrag==0) {	/* No frag hacking involved; just put it out */
		toP=frag_more(2*the_ins.numo);
		fromP= &the_ins.opcode[0];
		for(m=the_ins.numo;m;--m) {
			md_number_to_chars(toP,(int32_t)(*fromP),2);
			toP+=2;
			fromP++;
		}
			/* put out symbol-dependent info */
		for(m=0;m<the_ins.nrel;m++) {
			switch(the_ins.reloc[m].wid) {
			case 'B':
				n=1;
				break;
			case 'b':
				n=1;
				break;
			case '3':
#ifdef NeXT_MOD
				/* This is a bug fix that is not in the 1.36
				 * version of GAS for this construct:
				 *	fmovemx	#foo,a0@-
				 * foo = 0xffff;
				 * Where the width of the relocation should be
				 * one byte (the low 8 bits of the second word)
				 * for the floating point register mask. Other-					 * wise the next byte after this instruction
				 * gets trashed by this relocation.
				 */
				n=1;
#else /* !defined(NeXT_MOD) */
				n=2;
#endif /* NeXT_MOD */
				break;
			case 'w':
				n=2;
				break;
			case 'l':
				n=4;
				break;
			default:
				as_fatal("Don't know how to figure width of %c in md_assemble()",the_ins.reloc[m].wid);
			}

			fix_new(frag_now,
			        (toP - frag_now->fr_literal) -
				    the_ins.numo * 2 + the_ins.reloc[m].n,
				n,
				the_ins.reloc[m].add,
				the_ins.reloc[m].sub,
				the_ins.reloc[m].off,
				the_ins.reloc[m].pcrel,
				0,0);
		}
		return;
	}

		/* There's some frag hacking */
	for(n=0,fromP= &the_ins.opcode[0];n<the_ins.nfrag;n++) {
		int wid;

		if(n==0) wid=2*the_ins.fragb[n].fragoff;
		else wid=2*(the_ins.numo-the_ins.fragb[n-1].fragoff);
		toP=frag_more(wid);
		to_beg_P=toP;
		shorts_this_frag=0;
		for(m=wid/2;m;--m) {
			md_number_to_chars(toP,(int32_t)(*fromP),2);
			toP+=2;
			fromP++;
			shorts_this_frag++;
		}
		for(m=0;m<the_ins.nrel;m++) {
			if((the_ins.reloc[m].n)>= 2*shorts_this_frag /* 2*the_ins.fragb[n].fragoff */) {
				the_ins.reloc[m].n-= 2*shorts_this_frag /* 2*the_ins.fragb[n].fragoff */;
				break;
			}
			wid=the_ins.reloc[m].wid;
			if(wid==0)
				continue;
			the_ins.reloc[m].wid=0;
			wid = (wid=='b') ? 1 : (wid=='w') ? 2 : (wid=='l') ? 4 : 4000;

			fix_new(frag_now,
			        (toP - frag_now->fr_literal) -
				    the_ins.numo * 2 + the_ins.reloc[m].n,
				wid,
				the_ins.reloc[m].add,
				the_ins.reloc[m].sub,
				the_ins.reloc[m].off,
				the_ins.reloc[m].pcrel,
				0,0);
		}
		know(the_ins.fragb[n].fadd);
		(void)frag_var(rs_machine_dependent,10,0,(relax_substateT)(the_ins.fragb[n].fragty),
 the_ins.fragb[n].fadd,the_ins.fragb[n].foff,to_beg_P);
	}
	n=(the_ins.numo-the_ins.fragb[n-1].fragoff);
	shorts_this_frag=0;
	if(n) {
		toP=frag_more(n*sizeof(short));
		while(n--) {
			md_number_to_chars(toP,(int32_t)(*fromP),2);
			toP+=2;
			fromP++;
			shorts_this_frag++;
		}
	}
	for(m=0;m<the_ins.nrel;m++) {
		int wid;

		wid=the_ins.reloc[m].wid;
		if(wid==0)
			continue;
		the_ins.reloc[m].wid=0;
		wid = (wid=='b') ? 1 : (wid=='w') ? 2 : (wid=='l') ? 4 : 4000;

		fix_new(frag_now,
		        (the_ins.reloc[m].n + toP-frag_now->fr_literal) -
			    /* the_ins.numo */ shorts_this_frag * 2,
			wid,
			the_ins.reloc[m].add,
			the_ins.reloc[m].sub,
			the_ins.reloc[m].off,
			the_ins.reloc[m].pcrel,
			0,0);
	}
}

/* This function is called once, at assembler startup time.  This should
   set up all the tables, etc that the MD part of the assembler needs
 */
void
md_begin(
void)
{
/*
 * md_begin -- set up hash tables with 68000 instructions.
 * similar to what the vax assembler does.  ---phr
 */
	/* RMS claims the thing to do is take the m68k-opcode.h table, and make
	   a copy of it at runtime, adding in the information we want but isn't
	   there.  I think it'd be better to have an awk script hack the table
	   at compile time.  Or even just xstr the table and use it as-is.  But
	   my lord ghod hath spoken, so we do it this way.  Excuse the ugly var
	   names.  */

	register struct m68k_opcode *ins;
	register struct m68_incant *hack,
		*slak;
	const char *retval = 0;		/* empty string, or error msg text */
	register int i;
	register char c;

	if ((op_hash = hash_new()) == NULL)
		as_fatal("Virtual memory exhausted");

	obstack_begin(&robyn,4000);
	for (ins = (struct m68k_opcode *)m68k_opcodes; ins < endop; ins++) {
		hack=slak=(struct m68_incant *)obstack_alloc(&robyn,sizeof(struct m68_incant));
		do {
			slak->m_operands=ins->args;
			slak->m_opnum=strlen(slak->m_operands)/2;
			slak->m_opcode=ins->opcode;
				/* This is kludgey */
			slak->m_codenum=((ins->match)&0xffffL) ? 2 : 1;
#ifdef NeXT_MOD
			slak->m_cpus = ins->cpus;
#endif /* NeXT_MOD */
			if((ins+1)!=endop && !strcmp(ins->name,(ins+1)->name)) {
				slak->m_next=(struct m68_incant *)
obstack_alloc(&robyn,sizeof(struct m68_incant));
				ins++;
			} else
				slak->m_next=0;
			slak=slak->m_next;
		} while(slak);

		retval = hash_insert (op_hash, ins->name,(char *)hack);
			/* Didn't his mommy tell him about null pointers? */
		if(retval && *retval)
			as_fatal("Internal Error:  Can't hash %s: %s",ins->name,retval);
	}

	for (i = 0; i < (int)sizeof(mklower_table) ; i++)
		mklower_table[i] = (isupper(c = (char) i)) ? tolower(c) : c;

	for (i = 0 ; i < (int)sizeof(notend_table) ; i++) {
		notend_table[i] = 0;
		alt_notend_table[i] = 0;
	}
	notend_table[','] = 1;
	notend_table['{'] = 1;
	notend_table['}'] = 1;
	alt_notend_table['a'] = 1;
	alt_notend_table['A'] = 1;
	alt_notend_table['d'] = 1;
	alt_notend_table['D'] = 1;
	alt_notend_table['#'] = 1;
	alt_notend_table['f'] = 1;
	alt_notend_table['F'] = 1;
}

#if 0
#define notend(s) ((*s == ',' || *s == '}' || *s == '{' \
                   || (*s == ':' && index("aAdD#", s[1]))) \
               ? 0 : 1)
#endif

/* This funciton is called once, before the assembler exits.  It is
   supposed to do any final cleanup for this part of the assembler.
 */
void
md_end(
void)
{
}

/* Equal to MAX_PRECISION in atof-ieee.c */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
 */
char *
md_atof(
int type,
char *litP,
int *sizeP)
{
	int	prec;
	LITTLENUM_TYPE words[MAX_LITTLENUMS];
	LITTLENUM_TYPE *wordP;
	char	*t;

	switch(type) {
	case 'f':
	case 'F':
	case 's':
	case 'S':
		prec = 2;
		break;

	case 'd':
	case 'D':
	case 'r':
	case 'R':
		prec = 4;
		break;

	case 'x':
	case 'X':
		prec = 6;
		break;

	case 'p':
	case 'P':
		prec = 6;
		break;

	default:
		*sizeP=0;
		return "Bad call to MD_ATOF()";
	}
	t=atof_ieee(input_line_pointer,type,words);
	if(t)
		input_line_pointer=t;

	*sizeP=prec * sizeof(LITTLENUM_TYPE);
	for(wordP=words;prec--;) {
		md_number_to_chars(litP,(int32_t)(*wordP++),sizeof(LITTLENUM_TYPE));
		litP+=sizeof(LITTLENUM_TYPE);
	}
	return "";	/* Someone should teach Dean about null pointers */
}

/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
   for use in the a.out file, and stores them in the array pointed to by buf.
   This knows about the endian-ness of the target machine and does
   THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)
   2 (short) and 4 (long)  Floating numbers are put out as a series of
   LITTLENUMS (shorts, here at least)
 */
void
md_number_to_chars(
char *buf,
signed_expr_t val,
int n)
{
	switch(n) {
	case 1:
		*buf++=val;
		break;
	case 2:
		*buf++=(val>>8);
		*buf++=val;
		break;
	case 4:
		*buf++=(val>>24);
		*buf++=(val>>16);
		*buf++=(val>>8);
		*buf++=val;
		break;
	default:
		abort();
	}
}

void
md_number_to_imm(
unsigned char *buf,
signed_expr_t val,
int n,
fixS *fixP,
int nsect)
{
	switch(n) {
	case 1:
		*buf++=val;
		break;
	case 2:
		*buf++=(val>>8);
		*buf++=val;
		break;
	case 4:
		*buf++=(val>>24);
		*buf++=(val>>16);
		*buf++=(val>>8);
		*buf++=val;
		break;
	default:
		abort();
	}
}

/*
 * Force truly undefined symbols to their maximum size, and generally set up
 * the frag list to be relaxed.  It is the caller's responsiblity to set the
 * current section, frchain_now, to the corresponding nsect specified so that
 * calls to fix_new() will make fixes for this section.
 */
int
md_estimate_size_before_relax(
fragS *fragP,
int nsect)
{
    int old_fix;

	old_fix = fragP->fr_fix;

	/*
	 * Handle SZ_UNDEF first, it can be changed to BYTE or SHORT.
	 */
	switch(fragP->fr_subtype){
	case TAB(DBCC, SZ_UNDEF):
	    if(fragP->fr_symbol->sy_nlist.n_sect == nsect){
		fragP->fr_subtype = TAB(DBCC, SHORT);
		fragP->fr_var += 2;
		break;
	    }
	    /*
	     * Only DBcc 68000 instructions can come here.
	     * Change dbcc into dbcc/jmp absl long.
	     */
	    fragP->fr_opcode[2] = 0x00;  /* branch offset = 4 */
	    fragP->fr_opcode[3] = 0x04;  
	    fragP->fr_opcode[4] = 0x60;  /* put in bra pc+6 */ 
	    fragP->fr_opcode[5] = 0x06;  
	    fragP->fr_opcode[6] = 0x4e;  /* put in jmp long (0x4ef9) */ 
	    fragP->fr_opcode[7] = 0xf9;  
	    fragP->fr_fix += 6;	  /* account for bra/jmp instructions */
	    fix_new(fragP,
		    fragP->fr_fix,
		    4,
		    fragP->fr_symbol,
		    0,
		    fragP->fr_offset,
		    0,
		    0,
		    0);
	    fragP->fr_fix += 4;	/* account for jmp instruction displacement */
	    frag_wane(fragP);
	    break;

	case TAB(BCC68000, SZ_UNDEF):
	    if(fragP->fr_symbol->sy_nlist.n_sect == nsect){
		fragP->fr_subtype = TAB(BCC68000, BYTE);
		break;
	    }
	    /*
 	     * Only Bcc 68000 instructions can come here.
	     * Change bcc into b!cc/jmp absl long.
	     */
	    fragP->fr_opcode[0] ^= 0x01; /* invert bcc */
	    fragP->fr_opcode[1] = 0x6;   /* branch offset = 6 */
	    fragP->fr_opcode[2] = 0x4e;  /* put in jmp long (0x4ef9) */ 
	    fragP->fr_opcode[3] = 0xf9;  
	    fragP->fr_fix += 2;	     /* account for jmp instruction */
	    fix_new(fragP,
		    fragP->fr_fix,
		    4,
		    fragP->fr_symbol,
		    0, 
		    fragP->fr_offset,
		    0,
		    0,
		    0);
	    fragP->fr_fix += 4;	/* account for jmp instruction displacement */
	    frag_wane(fragP);
	    break;

	case TAB(BRANCH, SZ_UNDEF):
	    if(fragP->fr_symbol->sy_nlist.n_sect == nsect){
		/*
		 * The NeXT linker has the ability to scatter blocks of
		 * sections between labels.  This requires that brances to
		 * labels that survive to the link phase must be able to
		 * be relocated.
		 */
		if(fragP->fr_symbol->sy_name[0] != 'L' || flagseen ['L']){
		    fix_new(fragP,
			    fragP->fr_fix,
			    4,
			    fragP->fr_symbol,
			    0,
			    fragP->fr_offset + 4,
			    1,
			    1,
			    0);
		    fragP->fr_fix += 4;
		    fragP->fr_opcode[1] = 0xff;
		    frag_wane(fragP);
		    break;
		}
		else
		    fragP->fr_subtype = TAB(BRANCH, BYTE);
		break;
	    }
	    else if(flagseen['m']){
		if(fragP->fr_opcode[0] == 0x61){
		    fragP->fr_opcode[0] = 0x4E;
		    fragP->fr_opcode[1] = 0xB9;	/* JBSR with ABSL LONG offset */
		    fix_new(fragP,
			    fragP->fr_fix,
			    4, 
			    fragP->fr_symbol,
			    0,
			    fragP->fr_offset,
			    0,
			    0,
			    0);
		    fragP->fr_fix += 4;
		    frag_wane(fragP);
		}
		else if(fragP->fr_opcode[0] == 0x60){
		    fragP->fr_opcode[0] = 0x4E;
		    fragP->fr_opcode[1] = 0xF9;  /* JMP with ABSL LONG offset */
		    fix_new(fragP,
			    fragP->fr_fix,
			    4, 
			    fragP->fr_symbol,
			    0,
			    fragP->fr_offset,
			    0,
			    0,
			    0);
		    fragP->fr_fix += 4;
		    frag_wane(fragP);
		}
		else{
		    as_warn("Long branch offset to extern symbol not "
			    "supported.");
		}
		break;
	    }
	    else{
		/* Symbol is still undefined.  Make it simple */
		fix_new(fragP,
			fragP->fr_fix,
			4,
			fragP->fr_symbol,
			0,
			fragP->fr_offset + 4,
			1,
			1,
			0);
		fragP->fr_fix += 4;
		fragP->fr_opcode[1] = 0xff;
		frag_wane(fragP);
		break;
	    }
	    break;

	case TAB(FBRANCH, SZ_UNDEF):
	    if(fragP->fr_symbol->sy_nlist.n_sect == nsect){
		/*
		 * The NeXT linker has the ability to scatter blocks of
		 * sections between labels.  This requires that brances to
		 * labels that survive to the link phase must be able to
		 * be relocated.
		 */
		if(fragP->fr_symbol->sy_name[0] != 'L' || flagseen ['L']) {
		    fix_new(fragP,
			    fragP->fr_fix,
			    4,
			    fragP->fr_symbol,
			    0,
			    fragP->fr_offset + 4,
			    1,
			    1,
			    0);
		    fragP->fr_fix += 4;
		    fragP->fr_opcode[1] |= 0x40;
		    frag_wane(fragP);
		    break;
		}
		else{
		    fragP->fr_subtype = TAB(FBRANCH, SHORT);
		    fragP->fr_var += 2;
		}
	    }
	    else {
		/* Symbol is still undefined.  Make it long */
		fix_new(fragP,
			fragP->fr_fix,
			4,
			fragP->fr_symbol,
			0,
			fragP->fr_offset + 4,
			1,
			1,
			0);
		fragP->fr_fix += 4;
		fragP->fr_opcode[1] |= 0x40;
		frag_wane(fragP);
		break;
	    }
	    break;

	case TAB(PCREL, SZ_UNDEF):
	    if(fragP->fr_symbol->sy_nlist.n_sect == nsect){
		/*
		 * The NeXT linker has the ability to scatter blocks of
		 * sections between labels.  This requires that brances to
		 * labels that survive to the link phase must be able to
		 * be relocated.
		 */
		if(fragP->fr_symbol->sy_name[0] != 'L' || flagseen ['L']) {
		    /*
		     * The thing to do here is force it to ABSOLUTE LONG, since
		     * PCREL is really trying to shorten an ABSOLUTE address
		     * anyway.
		     */
		    if((fragP->fr_opcode[1] & 0x3F) != 0x3A)
			as_bad("Internal error (long PC-relative operand) for "
			       "insn 0x%04x at 0x%llx", fragP->fr_opcode[0],
			       fragP->fr_address);
		    fragP->fr_opcode[1] &= ~0x3F;
		    fragP->fr_opcode[1] |= 0x39;	/* Mode 7.1 */
		    fix_new(fragP,
			    fragP->fr_fix,
			    4,
			    fragP->fr_symbol,
			    0,
			    fragP->fr_offset,
			    0,
			    0,
			    0);
		    fragP->fr_fix += 4;
		    frag_wane(fragP);
		}
		else{
		    fragP->fr_subtype = TAB(PCREL, SHORT);
		    fragP->fr_var += 2;
		}
	    }
	    else {
		/* Symbol is still undefined.  Make it long */
		if((fragP->fr_opcode[1] & 0x3F) != 0x3A)
		    as_bad("Internal error (long PC-relative operand) for "
			   "insn 0x%04x at 0x%llx", fragP->fr_opcode[0],
			   fragP->fr_address);
		fragP->fr_opcode[1] &= ~0x3F;
		fragP->fr_opcode[1] |= 0x39;	/* Mode 7.1 */
		fix_new(fragP,
			fragP->fr_fix,
			4,
			fragP->fr_symbol,
			0,
			fragP->fr_offset,
			1,
			1,
			0);
		fragP->fr_fix += 4;
		frag_wane(fragP);
		break;
	    }
	    break;

	default:
	    break;
	}

	/*
	 * Now that SZ_UNDEF are taken care of, check others
	 */
	switch(fragP->fr_subtype) {
	case TAB(BCC68000, BYTE):
	case TAB(BRANCH, BYTE):
	    /*
	     * We can't do a short jump to the next instruction,
	     * so we force word mode.
	     */
	    if(fragP->fr_symbol != NULL &&
	       fragP->fr_symbol->sy_value == 0 &&
	       fragP->fr_symbol->sy_frag == fragP->fr_next) {
		fragP->fr_subtype = TAB(TABTYPE(fragP->fr_subtype), SHORT);
		fragP->fr_var += 2;
	    }
	    break;
	default:
	    break;
	}
	return(fragP->fr_var + fragP->fr_fix - old_fix);
}

/*
 * *fragP has been relaxed to its final size, and now needs to have
 * the bytes inside it modified to conform to the new size.  There is UGLY
 * MAGIC here interms of changing the addressing mode of some instructions
 * and using other instructions in place of the original in the case of the
 * 68000 and 68010 where long pc-relative forms don't exist.
 */
void
md_convert_frag(
fragS *fragP)
{
    int32_t disp;
    int32_t ext;
    char *buffer_address;
    int object_address;

	ext = 0;

	/* Address in gas core of the place to store the displacement.  */
	buffer_address = fragP->fr_fix + fragP->fr_literal;

	/* Address in object code of the displacement.  */
	object_address = fragP->fr_fix + fragP->fr_address;

	know(fragP->fr_symbol);

	/* The displacement of the address, from current location.  */
	disp = (fragP->fr_symbol->sy_value + fragP->fr_offset) - object_address;

	switch(fragP->fr_subtype){
	case TAB(BCC68000, BYTE):
	case TAB(BRANCH, BYTE):
	    know(issbyte(disp));
	    if(disp == 0){
		/* Replace this with a nop. */
		fragP->fr_opcode[0] = 0x4e;
		fragP->fr_opcode[1] = 0x71;
	    }
	    else{
		fragP->fr_opcode[1] = disp;
	    }
	    ext = 0;
	    break;

	case TAB(DBCC, SHORT):
	    know(issword(disp));
	    ext=2;
	    break;

	case TAB(BCC68000, SHORT):
	case TAB(BRANCH, SHORT):
	    know(issword(disp));
	    fragP->fr_opcode[1] = 0x00;
	    ext = 2;
	    break;

	case TAB(BRANCH,LONG):
	    if(flagseen['m']){
		if(fragP->fr_opcode[0] == 0x61){
		    fragP->fr_opcode[0] = 0x4E;
		    fragP->fr_opcode[1] = 0xB9;	/* JBSR with ABSL LONG offset */
		    fix_new(fragP,
			    fragP->fr_fix,
			    4,
			    fragP->fr_symbol,
			    0,
			    fragP->fr_offset,
			    0,
			    0,
			    0);
		    fragP->fr_fix += 4;
		    ext = 0;
		}
		else if(fragP->fr_opcode[0] == 0x60){
		    fragP->fr_opcode[0]= 0x4E;
		    fragP->fr_opcode[1]= 0xF9; /* JMP  with ABSL LONG offset */
		  fix_new(fragP,
			  fragP->fr_fix,
			  4,
			  fragP->fr_symbol,
			  0,
			  fragP->fr_offset,
			  0,
			  0,
			  0);
		  fragP->fr_fix += 4;
		  ext = 0;
		}
		else{
		    as_bad("Long branch offset not supported.");
		}
	    }
	    else{
		fragP->fr_opcode[1] = 0xff;
		ext = 4;
	    }
	    break;

	case TAB(BCC68000, LONG):
	    /*
	     * Only Bcc 68000 instructions can come here.
	     * Change bcc into b!cc/jmp absl long.
	     */
	    fragP->fr_opcode[0] ^= 0x01; /* invert bcc */
	    fragP->fr_opcode[1] = 0x6;   /* branch offset = 6 */
	    fragP->fr_opcode[2] = 0x4e;  /* put in jmp long (0x4ef9) */ 
	    fragP->fr_opcode[3] = 0xf9;  
	    fragP->fr_fix += 2;		 /* account for jmp instruction */
	    fix_new(fragP,
		    fragP->fr_fix,
		    4,
		    fragP->fr_symbol,
		    0,
		    fragP->fr_offset,
		    0,
		    0,
		    0);
	    fragP->fr_fix += 4; /* account for jmp instruction's displacement */
	    ext = 0;
	    break;

	case TAB(DBCC, LONG):
	    /*
	     * Only DBcc 68000 instructions can come here.
	     * Change dbcc into dbcc/jmp absl long.
	     */
	    fragP->fr_opcode[2] = 0x00;  /* branch offset = 4 */
	    fragP->fr_opcode[3] = 0x04;  
	    fragP->fr_opcode[4] = 0x60;  /* put in bra pc+6 */ 
	    fragP->fr_opcode[5] = 0x06;  
	    fragP->fr_opcode[6] = 0x4e;  /* put in jmp long (0x4ef9) */ 
	    fragP->fr_opcode[7] = 0xf9;  
	    fragP->fr_fix += 6;	     /* account for bra/jmp instructions */
	    fix_new(fragP,
		    fragP->fr_fix,
		    4,
		    fragP->fr_symbol,
		    0, 
		    fragP->fr_offset,
		    0,
		    0,
		    0);
	    fragP->fr_fix += 4; /* account for jmp instruction's displacement */
	    ext = 0;
	    break;

	case TAB(FBRANCH, SHORT):
	    know((fragP->fr_opcode[1] & 0x40) == 0);
	    ext = 2;
	    break;

	case TAB(FBRANCH, LONG):
	    fragP->fr_opcode[1] |= 0x40;	/* Turn on LONG bit */
	    ext = 4;
	    break;

	case TAB(PCREL,SHORT):
	    ext = 2;
	    break;

	case TAB(PCREL,LONG):
	    /*
	     * The thing to do here is force it to ABSOLUTE LONG, since
	     * PCREL is really trying to shorten an ABSOLUTE address anyway.
	     */
	    if((fragP->fr_opcode[1] & 0x3F) != 0x3A)
		as_bad("Internal error (long PC-relative operand) for insn "
		       "0x%04x at 0x%llx", fragP->fr_opcode[0],
		       fragP->fr_address);
	    fragP->fr_opcode[1] &= ~0x3F;
	    fragP->fr_opcode[1] |= 0x39;	/* Mode 7.1 */
	    fix_new(fragP,
		    fragP->fr_fix,
		    4,
		    fragP->fr_symbol,
		    0,
		    fragP->fr_offset,
		    0,
		    0,
		    0);
	    fragP->fr_fix += 4; /* account for the instruction's displacement */
	    ext = 0;
	    break;

	default:
	    break;
	}

	if(ext != 0){
	    md_number_to_chars(buffer_address, (int32_t)disp, (int)ext);
	    fragP->fr_fix += ext;
	}
}

/* Different values of OK tell what its OK to return.  Things that aren't OK are an error (what a shock, no?)

	0:  Everything is OK
	10:  Absolute 1:8	only
	20:  Absolute 0:7	only
	30:  absolute 0:15	only
	40:  Absolute 0:31	only
	50:  absolute 0:127	only
	55:  absolute -64:63    only
	60:  absolute -128:127	only
	70:  absolute 0:4095	only
	80:  No bignums

*/
static
int
get_num(
struct m68k_exp *exp,
int ok)
{
#ifdef TEST2
	int32_t	l = 0;

	if(!exp->e_beg)
		return 0;
	if(*exp->e_beg=='0') {
		if(exp->e_beg[1]=='x')
			sscanf(exp->e_beg+2,"%x",&l);
		else
			sscanf(exp->e_beg+1,"%O",&l);
		return l;
	}
	return atol(exp->e_beg);
#else /* !defined(TEST2) */
	char	*save_in;
	char	c_save;

	if(!exp) {
		/* Can't do anything */
		return 0;
	}
	if(!exp->e_beg || !exp->e_end) {
		seg(exp)=SEG_ABSOLUTE;
		adds(exp)=0;
		subs(exp)=0;
		offs(exp)= (ok==10) ? 1 : 0;
		as_warn("Null expression defaults to %lld", offs(exp));
		return 0;
	}

	exp->e_siz=0;
	if(/* ok!=80 && */exp->e_end[-1]==':' && (exp->e_end-exp->e_beg)>=2) {
		switch(exp->e_end[0]) {
		case 's':
		case 'b':
			exp->e_siz=1;
			break;
		case 'w':
			exp->e_siz=2;
			break;
		case 'l':
			exp->e_siz=3;
			break;
		default:
			as_bad("Unknown size for expression \"%c\"",exp->e_end[0]);
		}
		exp->e_end-=2;
	}
	c_save=exp->e_end[1];
	exp->e_end[1]='\0';
	save_in=input_line_pointer;
	input_line_pointer=exp->e_beg;
#ifdef NeXT_MOD	/* feature to try to make expressions absolute */
	(void) expression (&(exp->e_exp));
	/* DJA -- we will try to make an absolute number here */
	switch(try_to_make_absolute(&(exp->e_exp))) {
#else /* !defined(NeXT_MOD) */
	switch(expression(&(exp->e_exp))) {
#endif /* NeXT_MOD */
	case SEG_NONE:
		/* Do the same thing the VAX asm does */
		seg(exp)=SEG_ABSOLUTE;
		adds(exp)=0;
		subs(exp)=0;
		offs(exp)=0;
		if(ok==10) {
			as_warn("expression out of range: defaulting to 1");
			offs(exp)=1;
		}
		break;
	case SEG_ABSOLUTE:
		switch(ok) {
		case 10:
			if(offs(exp)<1 || offs(exp)>8) {
				as_warn("expression out of range: defaulting to 1");
				offs(exp)=1;
			}
			break;
		case 20:
			if(offs(exp)<0 || offs(exp)>7)
				goto outrange;
			break;
		case 30:
			if(offs(exp)<0 || offs(exp)>15)
				goto outrange;
			break;
		case 40:
			if(offs(exp)<0 || offs(exp)>32)
				goto outrange;
			break;
		case 50:
			if(offs(exp)<0 || offs(exp)>127)
				goto outrange;
			break;
		case 55:
			if(offs(exp)<-64 || offs(exp)>63)
				goto outrange;
			break;
		case 60:
			if(offs(exp)<-128 || offs(exp)>127)
				goto outrange;
			break;
		case 70:
			if(offs(exp)<0 || offs(exp)>4095) {
			outrange:
				as_warn("expression out of range: defaulting to 0");
				offs(exp)=0;
			}
			break;
		default:
			break;
		}
		break;
	case SEG_SECT:
	case SEG_UNKNOWN:
	case SEG_DIFFSECT:
		if(ok>=10 && ok<=70) {
			seg(exp)=SEG_ABSOLUTE;
			adds(exp)=0;
			subs(exp)=0;
			offs(exp)= (ok==10) ? 1 : 0;
			as_warn("Can't deal with expression \"%s\": defaulting "
				"to %lld", exp->e_beg, offs(exp));
		}
		break;
	case SEG_BIG:
#ifndef NeXT_MOD	/* fix for bug #8331 */ /* This hack is already done by expr */
		if(ok==80 && offs(exp)<0) {	/* HACK! Turn it into a long */
			LITTLENUM_TYPE words[6];

			gen_to_words(words,2,8L);/* These numbers are magic! */
			seg(exp)=SEG_ABSOLUTE;
			adds(exp)=0;
			subs(exp)=0;
			offs(exp)=words[1]|(words[0]<<16);
		} else if(ok!=0) {
#else /* defined(NeXT_MOD) */
		if(ok!=0) {
#endif /* NeXT_MOD */
			seg(exp)=SEG_ABSOLUTE;
			adds(exp)=0;
			subs(exp)=0;
			offs(exp)= (ok==10) ? 1 : 0;
			as_warn("Can't deal with expression \"%s\": defaulting "
				"to %lld", exp->e_beg, offs(exp));
		}
		break;
	default:
		abort();
	}
	if(input_line_pointer!=exp->e_end+1)
		as_bad("Ignoring junk after expression");
	exp->e_end[1]=c_save;
	input_line_pointer=save_in;
	if(exp->e_siz) {
		switch(exp->e_siz) {
		case 1:
			if(!isbyte(offs(exp)))
				as_warn("expression doesn't fit in BYTE");
			break;
		case 2:
			if(!isword(offs(exp)))
				as_warn("expression doesn't fit in WORD");
			break;
		}
	}
	return offs(exp);

#endif /* !defined(TEST2) */
}

/* These are the back-ends for the various machine dependent pseudo-ops.  */
void demand_empty_rest_of_line();	/* Hate those extra verbose names */

static
void
s_even(
uintptr_t value)
{
	register int power_of_2_alignment;
	register int32_t temp_fill;
	char fill;

	/* power of 2 alignment, 2^1 or 2 byte (even) alignment */
	power_of_2_alignment = 1;
	temp_fill = get_absolute_expression ();
	md_number_to_chars(&fill, temp_fill, 1);
	frag_align(power_of_2_alignment, &fill, 1, 0);
	/*
	 * If this alignment is larger than any previous alignment then this
	 * becomes the section's alignment.
	 */
	if(frchain_now->frch_section.align <
	   (uint32_t)power_of_2_alignment)
	    frchain_now->frch_section.align = power_of_2_alignment;
	demand_empty_rest_of_line();
}

static
void
s_proc(
uintptr_t value)
{
	demand_empty_rest_of_line();
}

/* s_space is defined in read.c .skip is simply an alias to it. */

int
md_parse_option(
char **argP,
int *cntP,
char ***vecP)
{
	switch(**argP) {
	case 'm':
		/* Gas simply ignores this option! */
		(*argP)++;
		if(**argP=='c')
			(*argP)++;
		if(!strcmp(*argP,"68000"))
			flagseen['m']=2;
		else if(!strcmp(*argP,"68010")) {
			flagseen['m']=1;
		} else if(!strcmp(*argP,"68020"))
			flagseen['m']=0;
		else
			as_warn("Unknown -m option ignored");
		while(**argP)
			(*argP)++;
		break;

	default:
		return 0;
	}
	return 1;
}


#ifdef TEST2

/* TEST2:  Test md_assemble() */

static
int
is_label(
char *str)
{
	while(*str == ' ')
	    str++;
	while(*str && *str != ' ')
	    str++;
	if(str[-1] == ':' || str[1] == '=')
	    return(1);
	return(0);
}

void
main(
int argc,
char *argv[],
char *envp[])
{
    char buf[120];
    char *cp;
    int n;

	m68_ip_begin();
	for(;;){
	    if(!gets(buf) || !*buf)
		break;
	    if(buf[0] == '|' || buf[1] == '.')
		continue;
	    for(cp = buf; *cp; cp++)
		if(*cp == '\t')
		    *cp = ' ';
	    if(is_label(buf))
		continue;
	    memset(&the_ins, '\0', sizeof(the_ins));
	    m68_ip(buf);
	    if(the_ins.error){
		printf("Error %s in %s\n", the_ins.error, buf);
	    }
	    else{
		printf("Opcode(%d.%s): ", the_ins.numo, the_ins.args);
		for(n = 0; n < the_ins.numo; n++)
		    printf(" 0x%x", the_ins.opcode[n] & 0xffff);
		printf("    ");
		print_the_insn(&the_ins.opcode[0], stdout);
		(void)putchar('\n');
	    }
	    for(n = 0; n < strlen(the_ins.args) / 2; n++){
		if(the_ins.operands[n].error){
		    printf("op%d Error %s in %s\n",
			   n, the_ins.operands[n].error, buf);
		    continue;
		}
		printf("mode %d, reg %d, ",
		       the_ins.operands[n].mode, the_ins.operands[n].reg);
		if(the_ins.operands[n].con1)
		    printf("con1: '%.*s', ",
			   1 + the_ins.operands[n].con1->e_end -
			       the_ins.operands[n].con1->e_beg,
			   the_ins.operands[n].con1->e_beg);
		printf("ireg %d, isiz %d, imul %d, ",
		       the_ins.operands[n].ireg,
		       the_ins.operands[n].isiz,
		       the_ins.operands[n].imul);
		if(the_ins.operands[n].con2)
		    printf("con2: '%.*s',",
			   1 + the_ins.operands[n].con2->e_end -
			       the_ins.operands[n].con2->e_beg,
			   the_ins.operands[n].con2->e_beg);
		(void)putchar('\n');
	    }
	}
	m68_ip_end();
}
#endif /* TEST2 */
                                                                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/m88k-check.c                             0100644 0001750 0001750 00000004465 12612724204 023060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <stdio.h>
#include "m88k-opcode.h"

static int reg(void);
static int creg(void);
static int cnst(void);
static void print_cond(void);
static void print_cmp(void);

void
main(
int argc,
char *argv[],
char *envp[])
{
    int32_t i, j;

	for(i = 0; i < NUMOPCODES - 1; i++){
	    printf("\t%s\t", m88k_opcodes[i].name);
	    if(m88k_opcodes[i].op[0].type == NIL)
		printf("\n");
	    for(j = 0; j < 3 && m88k_opcodes[i].op[j].type != NIL; j++){
		switch(m88k_opcodes[i].op[j].type){
		case CNST:
#ifdef SIGNED_IMMEDIATES
		case SCNST:
#endif
		    printf("0x%04x", cnst() );
		    break;
		case REG:
		    printf("r%d", reg() );
		    break;
		case BF:
		    printf("%d<%d>", reg(), reg() );
		    break;
		case REGSC:
		    printf("[r%d]", reg() );
		    break;
		case CRREG:
		    printf("cr%d", creg() );
		    break;
		case FCRREG:
		    printf("fcr%d", creg() );
		    break;
		case PCREL:
		    printf("undef");
		    break;
		case CONDMASK:
		    print_cond();
		    break;
		case CMPRSLT:
		    print_cmp();
		    break;
		case ROT:
		    printf("<%d>", reg() );
		    break;
		case E4ROT:
		    printf("<%d>", creg() & ~0x3);
		    break;
		case EREG:
		    printf("r%d", reg() & ~0x1);
		    break;
		case XREG:
		    printf("x%d", reg());
		    break;
		}
		if(j == 2 || m88k_opcodes[i].op[j+1].type == NIL)
		    printf("\n");
		else if(m88k_opcodes[i].op[j+1].type != REGSC)
		    printf(",");
	    }
	}
}

static
int
reg(void)
{
     static int x = 1;

	x = (x + 1) & 0x1f;
	return(x);
}

static
int
creg(void)
{
     static int x = 1;

	x = (x + 1) & 0x3f;
	return(x);
}

static
int
cnst(void)
{
     static int x = 1;

	x = (x + 1) & 0xffff;
	return(x);
}

static
void
print_cond(void)
{
     static int x = 1;

	x = (x + 1) & 0x1f;
	switch(x){
	case 0x02:
	    printf("eq0");
	    break;
	case 0x0d:
	    printf("ne0");
	    break;
	case 0x01:
	    printf("gt0");
	    break;
	case 0x0c:
	    printf("lt0");
	    break;
	case 0x03:
	    printf("ge0");
	    break;
	case 0x0e:
	    printf("le0");
	    break;
	default:
	    printf("%d", x);
	}
}

static
char *cmpslot[] = { "**", "**", "eq", "ne", "gt", "le", "lt", "ge",
		    "hi", "ls", "lo", "hs", "be", "nb", "he", "nh" };
static
void
print_cmp(void)
{
     static int x = 1;

	x = (x + 1) & 0x1f;
	if(x < 2 || x > 15)
	    printf("%d", x);
	else
	    printf("%s", cmpslot[x]);
}
                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/m88k-opcode.h                            0100644 0001750 0001750 00000123513 12612724204 023255  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * The 88110 implemention assumes signed immediate mode.
 */

/* m88k-opcode.h -- Instruction information for the 88100
   Copyright (C) 1989 Free Software Foundation, Inc.

This file is not yet part of GAS, the GNU Assembler.

GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* macros for shifting operand fields */

#define UEXT(src,off,wid)  ((((unsigned int)src)>>off) & ((1<<wid) - 1))
#define SEXT(src,off,wid)  (((((int)src)<<(32-(off+wid))) >>(32-wid)) )

/* operand decriptor structure */

struct opspec {
   unsigned int offset:5;
   unsigned int width:6;
   unsigned int type:5;
};

/* operands types */

#define NIL	     0    /* invalid parameter */
#define CNST         1    /* 16-bit constant */
#define REG          2    /* register */
#define BF           4    /* bit field */
#define REGSC        5    /* scaled register */
#define CRREG        6    /* control register */
#define FCRREG       7    /* floating point control register */
#define PCREL	     8    /* PC relative (branch offset) */
#define CONDMASK     9    /* bcnd mask */
#define CMPRSLT     10	  /* result of cmp instruction (bb0/1, tb0/1) */
#define ROT         11	  /* 5 bit value for rotation (rot instruction only)*/
#ifdef m88110
#define E4ROT       12	  /* even multiple of 4 value for pixel rotation */
#define EREG        13    /* even register from general register */
#define XREG        14    /* register from extended register file */
#endif /* m88110 */

/* instruction descriptor structure */

struct m88k_opcode {
   unsigned int   opcode;
   char           *name;
   struct opspec  op[3];
#ifdef NeXT_MOD
   int32_t	  delay_slot;
#endif
};

/* and introducing... the Motorola 88100 instruction set... */
   
static const struct m88k_opcode m88k_opcodes[] =   {
 
/*  Opcode     Mnemonic         Op 1 Spec        Op 2 Spec     Op 3 Spec */
                            
 { 0x70000000, "add",         { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4007000, "add",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4007200, "add.ci",      { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4007300, "add.cio",     { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4007100, "add.co",      { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x60000000, "addu",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4006000, "addu",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4006200, "addu.ci",     { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4006300, "addu.cio",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4006100, "addu.co",     { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x40000000, "and",         { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4004000, "and",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4004400, "and.c",       { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x44000000, "and.u",       { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xd0000000, "bb0",         { {21,5,CMPRSLT},  {16,5,REG},   {0,16,PCREL}} },
 { 0xd4000000, "bb0.n",       { {21,5,CMPRSLT},  {16,5,REG},   {0,16,PCREL}},1},
 { 0xd8000000, "bb1",         { {21,5,CMPRSLT},  {16,5,REG},   {0,16,PCREL}} },
 { 0xdc000000, "bb1.n",       { {21,5,CMPRSLT},  {16,5,REG},   {0,16,PCREL}},1},
 { 0xe8000000, "bcnd",        { {21,5,CONDMASK}, {16,5,REG},   {0,16,PCREL}} },
 { 0xec000000, "bcnd.n",      { {21,5,CONDMASK}, {16,5,REG},   {0,16,PCREL}},1},
 { 0xc0000000, "br",          { {0,26,PCREL},    {0,0,NIL},    {0,0,NIL}   } },
 { 0xc4000000, "br.n",        { {0,26,PCREL},    {0,0,NIL},    {0,0,NIL}   },1},
 { 0xc8000000, "bsr",         { {0,26,PCREL},    {0,0,NIL},    {0,0,NIL}   } },
 { 0xcc000000, "bsr.n",       { {0,26,PCREL},    {0,0,NIL},    {0,0,NIL}   },1},
 { 0XF0008000, "clr",         { {21,5,REG},      {16,5,REG},   {0,10,BF}   } },
 { 0XF4008000, "clr",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x7c000000, "cmp",         { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4007c00, "cmp",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x78000000, "div",         { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4007800, "div",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x78000000, "divs",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4007800, "divs",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0x68000000, "divu",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4006800, "divu",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0xf4006900, "divu.d",      { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0XF0009000, "ext",         { {21,5,REG},      {16,5,REG},   {0,10,BF}   } },
 { 0XF4009000, "ext",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0XF0009800, "extu",        { {21,5,REG},      {16,5,REG},   {0,10,BF}   } },
 { 0XF4009800, "extu",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0X84002AA0, "fadd.ddd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400AAA0, "fadd.ddd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84002A20, "fadd.dds",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400AA20, "fadd.dds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AB20, "fadd.ddx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X840028A0, "fadd.dsd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400A8A0, "fadd.dsd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84002820, "fadd.dss",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400A820, "fadd.dss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400A920, "fadd.dsx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400ACA0, "fadd.dxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AC20, "fadd.dxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AD20, "fadd.dxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84002A80, "fadd.sdd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400AA80, "fadd.sdd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84002A00, "fadd.sds",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400AA00, "fadd.sds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AB00, "fadd.sdx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84002880, "fadd.ssd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400A880, "fadd.ssd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84002800, "fadd.sss",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400A800, "fadd.sss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400A900, "fadd.ssx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AC80, "fadd.sxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AC00, "fadd.sxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AD00, "fadd.sxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AAC0, "fadd.xdd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AA40, "fadd.xds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AB40, "fadd.xdx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400A8C0, "fadd.xsd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400A840, "fadd.xss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400A940, "fadd.xsx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400ACC0, "fadd.xxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AC40, "fadd.xxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400AD40, "fadd.xxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0x84003a80, "fcmp.sdd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400BA80, "fcmp.sdd",    { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0x84003a00, "fcmp.sds",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400BA00, "fcmp.sds",    { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400BB00, "fcmp.sdx",    { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0x84003880, "fcmp.ssd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400B880, "fcmp.ssd",    { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0x84003800, "fcmp.sss",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400B800, "fcmp.sss",    { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B900, "fcmp.ssx",    { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400BC80, "fcmp.sxd",    { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400BC00, "fcmp.sxs",    { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400BD00, "fcmp.sxx",    { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X84003AA0, "fcmpu.sdd",   { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0X8400BAA0, "fcmpu.sdd",   { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X84003A20, "fcmpu.sds",   { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0X8400BA20, "fcmpu.sds",   { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400BB20, "fcmpu.sdx",   { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X840038A0, "fcmpu.ssd",   { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0X8400B8A0, "fcmpu.ssd",   { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X84003820, "fcmpu.sss",   { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0X8400B820, "fcmpu.sss",   { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B920, "fcmpu.ssx",   { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400BCA0, "fcmpu.sxd",   { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400BC20, "fcmpu.sxs",   { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400BD20, "fcmpu.sxx",   { {21,5,REG},      {16,5,XREG},  {0,5,XREG}  } },
 { 0X84000820, "fcvt.ds",     { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
 { 0X84008820, "fcvt.ds",     { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X84008920, "fcvt.dx",     { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X84000880, "fcvt.sd",     { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
 { 0X84008880, "fcvt.sd",     { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X84008900, "fcvt.sx",     { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X840088C0, "fcvt.xd",     { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X84008840, "fcvt.xs",     { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
#endif /* m88110 */
 { 0x840072a0, "fdiv.ddd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x8400f2a0, "fdiv.ddd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0x84007220, "fdiv.dds",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x8400f220, "fdiv.dds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f320, "fdiv.ddx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0x840070a0, "fdiv.dsd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x8400f0a0, "fdiv.dsd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0x84007020, "fdiv.dss",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x8400f020, "fdiv.dss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f120, "fdiv.dsx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f4a0, "fdiv.dxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f420, "fdiv.dxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f520, "fdiv.dxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0x84007280, "fdiv.sdd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x8400f280, "fdiv.sdd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0x84007200, "fdiv.sds",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x8400f200, "fdiv.sds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f300, "fdiv.sdx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0x84007080, "fdiv.ssd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x8400f080, "fdiv.ssd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84007000, "fdiv.sss",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x8400f000, "fdiv.sss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f100, "fdiv.ssx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f480, "fdiv.sxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f400, "fdiv.sxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f500, "fdiv.sxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f2c0, "fdiv.xdd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f240, "fdiv.xds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f340, "fdiv.xdx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f0c0, "fdiv.xsd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f040, "fdiv.xss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f140, "fdiv.xsx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f4c0, "fdiv.xxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f440, "fdiv.xxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0x8400f540, "fdiv.xxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0XF400EC00, "ff0",         { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
 { 0XF400E800, "ff1",         { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
 { 0x80004800, "fldcr",       { {21,5,REG},      {5,6,FCRREG}, {0,0,NIL}   } },
 { 0X84002020, "flt.ds",      { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
#ifdef m88110
 { 0X84002220, "flt.ds",      { {21,5,XREG},     {0,5,REG},    {0,0,NIL}   } },
#endif /* m88110 */
 { 0X84002000, "flt.ss",      { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
#ifdef m88110
 { 0X84002200, "flt.ss",      { {21,5,XREG},     {0,5,REG},    {0,0,NIL}   } },
 { 0X84002240, "flt.xs",      { {21,5,XREG},     {0,5,REG},    {0,0,NIL}   } },
#endif /* m88110 */
 { 0X840002A0, "fmul.ddd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X840082A0, "fmul.ddd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84000220, "fmul.dds",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X84008220, "fmul.dds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008320, "fmul.ddx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X840000A0, "fmul.dsd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X840080A0, "fmul.dsd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84000020, "fmul.dss",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X84008020, "fmul.dss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008120, "fmul.dsx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X840084A0, "fmul.dxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008420, "fmul.dxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008520, "fmul.dxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84000280, "fmul.sdd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X84008280, "fmul.sdd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84000200, "fmul.sds",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X84008200, "fmul.sds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008300, "fmul.sdx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84000080, "fmul.ssd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X84008080, "fmul.ssd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84000000, "fmul.sss",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X84008000, "fmul.sss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008100, "fmul.ssx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008480, "fmul.sxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008400, "fmul.sxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008500, "fmul.sxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X840082C0, "fmul.xdd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008240, "fmul.xds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008340, "fmul.xdx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X840080C0, "fmul.xsd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008040, "fmul.xss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008140, "fmul.xsx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X840084C0, "fmul.xxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008440, "fmul.xxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X84008540, "fmul.xxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X840078A0, "fsqrt.dd",    { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
 { 0X8400F8A0, "fsqrt.dd",    { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X84007820, "fsqrt.ds",    { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
 { 0X8400F820, "fsqrt.ds",    { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X8400F920, "fsqrt.dx",    { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X84007880, "fsqrt.sd",    { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
 { 0X8400F880, "fsqrt.sd",    { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X84007800, "fsqrt.ss",    { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
 { 0X8400F800, "fsqrt.ss",    { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X8400F900, "fsqrt.sx",    { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X8400F8C0, "fsqrt.xd",    { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X8400F840, "fsqrt.xs",    { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
 { 0X8400F940, "fsqrt.xx",    { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
#endif /* m88110 */
 { 0x80008800, "fstcr",       { {16,5,REG},      {5,6,FCRREG}, {0,0,NIL}   } },
 { 0X840032A0, "fsub.ddd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400B2A0, "fsub.ddd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84003220, "fsub.dds",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400B220, "fsub.dds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B320, "fsub.ddx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X840030A0, "fsub.dsd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400B0A0, "fsub.dsd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84003020, "fsub.dss",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400B020, "fsub.dss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B120, "fsub.dsx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B4A0, "fsub.dxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B420, "fsub.dxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B520, "fsub.dxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84003280, "fsub.sdd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400B280, "fsub.sdd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84003200, "fsub.sds",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400B200, "fsub.sds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B300, "fsub.sdx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84003080, "fsub.ssd",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400B080, "fsub.ssd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0X84003000, "fsub.sss",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0X8400B000, "fsub.sss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B100, "fsub.ssx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B480, "fsub.sxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B400, "fsub.sxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B500, "fsub.sxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B2C0, "fsub.xdd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B240, "fsub.xds",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B340, "fsub.xdx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B0C0, "fsub.xsd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B040, "fsub.xss",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B140, "fsub.xsx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B4C0, "fsub.xxd",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B440, "fsub.xxs",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
 { 0X8400B540, "fsub.xxx",    { {21,5,XREG},     {16,5,XREG},  {0,5,XREG}  } },
#endif /* m88110 */
 { 0x8000c800, "fxcr",        { {21,5,REG},      {16,5,REG},   {5,6,FCRREG}} },
 { 0xf400fc01, "illop1",      { {0,0,NIL},       {0,0,NIL},    {0,0,NIL}   } },
 { 0xf400fc02, "illop2",      { {0,0,NIL},       {0,0,NIL},    {0,0,NIL}   } },
 { 0xf400fc03, "illop3",      { {0,0,NIL},       {0,0,NIL},    {0,0,NIL}   } },
 { 0x84004880, "int.sd",      { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
#ifdef m88110
 { 0x8400c880, "int.sd",      { {21,5,REG},      {0,5,XREG},   {0,0,NIL}   } },
#endif /* m88110 */
 { 0x84004800, "int.ss",      { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
#ifdef m88110
 { 0x8400c800, "int.ss",      { {21,5,REG},      {0,5,XREG},   {0,0,NIL}   } },
 { 0x8400c900, "int.sx",      { {21,5,REG},      {0,5,XREG},   {0,0,NIL}   } },
#endif /* m88110 */
 { 0xf400c000, "jmp",         { {0,5,REG},       {0,0,NIL},    {0,0,NIL}   } },
 { 0xf400c400, "jmp.n",       { {0,5,REG},       {0,0,NIL},    {0,0,NIL}   },1},
 { 0xf400c800, "jsr",         { {0,5,REG},       {0,0,NIL},    {0,0,NIL}   } },
 { 0xf400cc00, "jsr.n",       { {0,5,REG},       {0,0,NIL},    {0,0,NIL}   },1},
 { 0x14000000, "ld",          { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4001600, "ld",          { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4001400, "ld",          { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x04000000, "ld",          { {21,5,XREG},     {16,5,REG},   {0,16,CNST} } },
 { 0xf0001600, "ld",          { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0001400, "ld",          { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0x1c000000, "ld.b",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4001e00, "ld.b",        { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4001c00, "ld.b",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4001f00, "ld.b.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4001d00, "ld.b.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x0c000000, "ld.bu",       { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4000e00, "ld.bu",       { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4000c00, "ld.bu",       { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4000f00, "ld.bu.usr",   { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4000d00, "ld.bu.usr",   { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x10000000, "ld.d",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4001200, "ld.d",        { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4001000, "ld.d",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x00000000, "ld.d",        { {21,5,XREG},     {16,5,REG},   {0,16,CNST} } },
 { 0xf0001200, "ld.d",        { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0001000, "ld.d",        { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0xf4001300, "ld.d.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
#ifdef m88110
 { 0xf0001300, "ld.d.usr",    { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
#endif /* m88110 */
 { 0xf4001100, "ld.d.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0xf0001100, "ld.d.usr",    { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0x18000000, "ld.h",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4001a00, "ld.h",        { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4001800, "ld.h",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4001b00, "ld.h.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4001900, "ld.h.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x08000000, "ld.hu",       { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4000a00, "ld.hu",       { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4000800, "ld.hu",       { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4000b00, "ld.hu.usr",   { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4000900, "ld.hu.usr",   { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4001700, "ld.usr",      { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
#ifdef m88110
 { 0xf0001700, "ld.usr",      { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
#endif /* m88110 */
 { 0xf4001500, "ld.usr",      { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0xf0001500, "ld.usr",      { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
 { 0x3c000000, "ld.x",        { {21,5,XREG},     {16,5,REG},   {0,16,CNST} } },
 { 0xf0001a00, "ld.x",        { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0001800, "ld.x",        { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
 { 0xf0001b00, "ld.x.usr",    { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0001900, "ld.x.usr",    { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
#ifndef m88110
 { 0x34000000, "lda",         { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
#endif /* !defined(m88110) */
 { 0xf4003600, "lda",         { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
#ifndef m88110
 { 0xf4003400, "lda",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x3c000000, "lda.b",       { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4003e00, "lda.b",       { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4003c00, "lda.b",       { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x30000000, "lda.d",       { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
#endif /* !defined(m88110) */
 { 0xf4003200, "lda.d",       { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
#ifndef m88110
 { 0xf4003000, "lda.d",       { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x38000000, "lda.h",       { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
#endif /* !defined(m88110) */
 { 0xf4003a00, "lda.h",       { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
#ifndef m88110
 { 0xf4003800, "lda.h",       { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#endif /* !defined(m88110) */
#ifdef m88110
 { 0xf4003e00, "lda.x",       { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
#endif /* m88110 */
 { 0x80004000, "ldcr",        { {21,5,REG},      {5,6,CRREG},  {0,0,NIL}   } },
 { 0XF000A000, "mak",         { {21,5,REG},      {16,5,REG},   {0,10,BF}   } },
 { 0XF400A000, "mak",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0X48000000, "mask",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0X4C000000, "mask.u",      { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
#ifdef m88110
 { 0X8400C080, "mov.d",       { {21,5,REG},      {0,5,XREG},   {0,0,NIL}   } },
 { 0X84004280, "mov.d",       { {21,5,XREG},     {0,5,REG},    {0,0,NIL}   } },
 { 0X8400C000, "mov.s",       { {21,5,REG},      {0,5,XREG},   {0,0,NIL}   } },
 { 0X84004200, "mov.s",       { {21,5,XREG},     {0,5,REG},    {0,0,NIL}   } },
 { 0X8400C300, "mov",         { {21,5,XREG},     {0,5,XREG},   {0,0,NIL}   } },
#endif /* m88110 */
 { 0x6c000000, "mul",         { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4006c00, "mul",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0xf4006e00, "muls",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x6c000000, "mulu",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4006c00, "mulu",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4006d00, "mulu.d",      { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0x84005080, "nint.sd",     { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
#ifdef m88110
 { 0x8400d080, "nint.sd",     { {21,5,REG},      {0,5,XREG},   {0,0,NIL}   } },
#endif /* m88110 */
 { 0x84005000, "nint.ss",     { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
#ifdef m88110
 { 0x8400d000, "nint.ss",     { {21,5,REG},      {0,5,XREG},   {0,0,NIL}   } },
 { 0x8400d100, "nint.sx",     { {21,5,REG},      {0,5,XREG},   {0,0,NIL}   } },
#endif /* m88110 */
 { 0X58000000, "or",          { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4005800, "or",          { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4005c00, "or.c",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0X5C000000, "or.u",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
#ifdef m88110
 { 0x88002060, "padd",        { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88002020, "padd.b",      { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88002040, "padd.h",      { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880021e0, "padds.s",     { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880021a0, "padds.s.b",   { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880021c0, "padds.s.h",   { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880020e0, "padds.u",     { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880020a0, "padds.u.b",   { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880020c0, "padds.u.h",   { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88002160, "padds.us",    { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88002120, "padds.us.b",  { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88002140, "padds.us.h",  { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88003860, "pcmp",        { {21,5,REG},      {16,5,EREG},  {0,5,EREG}  } },
 { 0x88000000, "pmul",        { {21,5,EREG},     {16,5,EREG},  {0,5,REG}   } },
 { 0x88006260, "ppack.16",    { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88006240, "ppack.16.h",  { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88006460, "ppack.32",    { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88006420, "ppack.32.b",  { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88006440, "ppack.32.h",  { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88006160, "ppack.8",     { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88007800, "prot",        { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88007000, "prot",        { {21,5,EREG},     {16,5,EREG},  {7,4,E4ROT} } },
 { 0x88003060, "psub",        { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88003020, "psub.b",      { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88003040, "psub.h",      { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880031e0, "psubs.s",     { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880031a0, "psubs.s.b",   { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880031c0, "psubs.s.h",   { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880030e0, "psubs.u",     { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880030a0, "psubs.u.b",   { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x880030c0, "psubs.u.h",   { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88003160, "psubs.us",    { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88003120, "psubs.us.b",  { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88003140, "psubs.us.h",  { {21,5,EREG},     {16,5,EREG},  {0,5,EREG}  } },
 { 0x88006820, "punpk.b",     { {21,5,EREG},     {16,5,REG},   {0,0,NIL}   } },
 { 0x88006840, "punpk.h",     { {21,5,EREG},     {16,5,REG},   {0,0,NIL}   } },
 { 0x88006800, "punpk.n",     { {21,5,EREG},     {16,5,REG},   {0,0,NIL}   } },
#endif /* m88110 */
 { 0XF000A800, "rot",         { {21,5,REG},      {16,5,REG},   {0,5,ROT}   } },
 { 0XF400A800, "rot",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf400fc00, "rte",         { {0,0,NIL},       {0,0,NIL},    {0,0,NIL}   } },
 { 0XF0008800, "set",         { {21,5,REG},      {16,5,REG},   {0,10,BF}   } },
 { 0XF4008800, "set",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x24000000, "st",          { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4002600, "st",          { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002400, "st",          { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x34000000, "st",          { {21,5,XREG},     {16,5,REG},   {0,16,CNST} } },
 { 0xf0002600, "st",          { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002400, "st",          { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
 { 0xf4002680, "st.wt",       { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002480, "st.wt",       { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf0002680, "st.wt",       { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002480, "st.wt",       { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0x2c000000, "st.b",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4002e00, "st.b",        { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002c00, "st.b",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0xf4002e80, "st.b.wt",     { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002c80, "st.b.wt",     { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0xf4002f00, "st.b.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002d00, "st.b.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0xf4002f80, "st.b.usr.wt", { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002d80, "st.b.usr.wt", { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0x20000000, "st.d",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4002200, "st.d",        { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002000, "st.d",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0x30000000, "st.d",        { {21,5,XREG},     {16,5,REG},   {0,16,CNST} } },
 { 0xf0002200, "st.d",        { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002000, "st.d",        { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
 { 0xf4002280, "st.d.wt",     { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002080, "st.d.wt",     { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf0002280, "st.d.wt",     { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002080, "st.d.wt",     { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0xf4002300, "st.d.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002100, "st.d.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0xf0002300, "st.d.usr",    { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002100, "st.d.usr",    { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
 { 0xf4002380, "st.d.usr.wt", { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002180, "st.d.usr.wt", { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
 { 0xf0002380, "st.d.usr.wt", { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002180, "st.d.usr.wt", { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0x28000000, "st.h",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4002a00, "st.h",        { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002800, "st.h",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0xf4002a80, "st.h.wt",     { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002880, "st.h.wt",     { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0xf4002b00, "st.h.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002900, "st.h.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0xf4002b80, "st.h.usr.wt", { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002980, "st.h.usr.wt", { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0xf4002700, "st.usr",      { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002500, "st.usr",      { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifdef m88110
 { 0xf0002700, "st.usr",      { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002500, "st.usr",      { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
 { 0xf4002780, "st.usr.wt",   { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4002580, "st.usr.wt",   { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf0002780, "st.usr.wt",   { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002580, "st.usr.wt",   { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
 { 0x38000000, "st.x",        { {21,5,XREG},     {16,5,REG},   {0,16,CNST} } },
 { 0xf0002a00, "st.x",        { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002800, "st.x",        { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
 { 0xf0002a80, "st.x.wt",     { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002880, "st.x.wt",     { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
 { 0xf0002b00, "st.x.usr",    { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002900, "st.x.usr",    { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
 { 0xf0002b80, "st.x.usr.wt", { {21,5,XREG},     {16,5,REG},   {0,5,REGSC} } },
 { 0xf0002980, "st.x.usr.wt", { {21,5,XREG},     {16,5,REG},   {0,5,REG}   } },
#endif /* m88110 */
 { 0x80008000, "stcr",        { {16,5,REG},      {5,6,CRREG},  {0,0,NIL}   } },
 { 0x74000000, "sub",         { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4007400, "sub",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4007600, "sub.ci",      { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4007700, "sub.cio",     { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4007500, "sub.co",      { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0x64000000, "subu",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0xf4006400, "subu",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4006600, "subu.ci",     { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4006700, "subu.cio",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4006500, "subu.co",     { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf000d000, "tb0",         { {21,5,CMPRSLT},  {16,5,REG},   {0,9,CNST}  } },
 { 0xf000d800, "tb1",         { {21,5,CMPRSLT},  {16,5,REG},   {0,9,CNST}  } },
 { 0xf8000000, "tbnd",        { {16,5,REG},      {0,16,CNST},  {0,0,NIL}   } },
 { 0xf400f800, "tbnd",        { {16,5,REG},      {0,5,REG},    {0,0,NIL}   } },
 { 0xf000e800, "tcnd",        { {21,5,CONDMASK}, {16,5,REG},   {0,9,CNST}  } },
 { 0x84005880, "trnc.sd",     { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
#ifdef m88110
 { 0x8400d880, "trnc.sd",     { {21,5,REG},      {0,5,XREG},   {0,0,NIL}   } },
#endif /* m88110 */
 { 0x84005800, "trnc.ss",     { {21,5,REG},      {0,5,REG},    {0,0,NIL}   } },
#ifdef m88110
 { 0x8400d800, "trnc.ss",     { {21,5,REG},      {0,5,XREG},   {0,0,NIL}   } },
 { 0x8400d900, "trnc.sx",     { {21,5,REG},      {0,5,XREG},   {0,0,NIL}   } },
#endif /* m88110 */
 { 0x8000c000, "xcr",         { {21,5,REG},      {16,5,REG},   {5,6,CRREG} } },
#ifndef m88110
 { 0x04000000, "xmem",        { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
#endif /* !defined(m88110) */
 { 0xf4000600, "xmem",        { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4000400, "xmem",        { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
#ifndef m88110
 { 0x00000000, "xmem.bu",     { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
#endif /* !defined(m88110) */
 { 0xf4000200, "xmem.bu",     { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4000000, "xmem.bu",     { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4000300, "xmem.bu.usr", { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4000100, "xmem.bu.usr", { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0xf4000700, "xmem.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REGSC} } },
 { 0xf4000500, "xmem.usr",    { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0X50000000, "xor",         { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0XF4005000, "xor",         { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0XF4005400, "xor.c",       { {21,5,REG},      {16,5,REG},   {0,5,REG}   } },
 { 0X54000000, "xor.u",       { {21,5,REG},      {16,5,REG},   {0,16,CNST} } },
 { 0x00000000, "",            { {0,0,NIL},       {0,0,NIL},    {0,0,NIL}   } },
};

#define NUMOPCODES ((sizeof m88k_opcodes)/(sizeof m88k_opcodes[0]))
                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/m88k.c                                   0100644 0001750 0001750 00000102001 12612724204 021766  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* m88k.c -- Assemble for the 88100
   Copyright (C) 1989 Free Software Foundation, Inc.

This file is not yet part of GAS, the GNU Assembler.

GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <mach-o/m88k/reloc.h>
#include "m88k-opcode.h"
#include "as.h"
#include "flonum.h"
#include "expr.h"
#include "hash.h"
#include "frags.h"
#include "fixes.h"
#include "read.h"
#include "md.h"
#include "obstack.h"
#include "symbols.h"
#include "messages.h"
#include "input-scrub.h"
#include "sections.h"

/*
 * These are the default cputype and cpusubtype for the m88k architecture.
 */
const cpu_type_t md_cputype = CPU_TYPE_MC88000;
cpu_subtype_t md_cpusubtype = CPU_SUBTYPE_MC88000_ALL;

/* This is the byte sex for the m88k architecture */
const enum byte_sex md_target_byte_sex = BIG_ENDIAN_BYTE_SEX;

#ifdef NeXT_MOD
static int32_t in_delay_slot = 0;
#endif

static char *cmpslot[] = { "**", "**", "eq", "ne", "gt", "le", "lt", "ge",
			   "hi", "ls", "lo", "hs",
#ifdef m88110
			   "be", "nb", "he", "nh",
#endif /* m88110 */
			    NULL };

static struct {
	char *name;
	unsigned int num;

} cndmsk[] = {
		{ "eq0", 0x02},
		{ "ne0", 0x0d},
		{ "gt0", 0x01},
		{ "lt0", 0x0c},
		{ "ge0", 0x03},
		{ "le0", 0x0e},
		{ NULL,  0x00},
	      };

struct m88k_insn {
        uint32_t opcode;
        expressionS exp;
#ifdef NeXT_MOD
        int reloc;
#else
        enum reloc_type reloc;
#endif
};

static struct hash_control *op_hash = NULL;

/* These chars start a comment anywhere in a source file (except inside
   another comment */
const char md_comment_chars[] = ";";

/* These chars only start a comment at the beginning of a line. */
const char md_line_comment_chars[] = "#";

/* Chars that can be used to separate mant from exp in floating point nums */
const char md_EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant */
/* as in 0f123.456 */
/* or    0H1.234E-12 (see exp chars above) */
const char md_FLT_CHARS[] = "dDfF";

static int calcop(
    struct m88k_opcode *format,
    char *param,
    struct m88k_insn *insn);
static char * parse_reg(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
#ifdef m88110
static char *parse_ereg(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
static char *parse_e4rot(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
static char *parse_xreg(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
#endif /* m88110 */
static char *parse_pcr(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
static char *parse_cmp(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
static char *parse_cnd(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
static char *parse_bf(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
static char *parse_rot(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
static char *parse_rsc(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
static char *parse_cr(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
static char *parse_fcr(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
static char *parse_cst(
    char *param,
    struct m88k_insn *insn,
    struct m88k_opcode *format,
    int parcnt);
static char *getval(
    char *param,
    unsigned int *val);
#ifdef NeXT_MOD
static void s_reg(
    uintptr_t reg);
static void s_scaled(
    uintptr_t value);
static void s_m88k_abs(
    uintptr_t value);
static void s_no_delay(
    uintptr_t value);
static void s_dot(
    uintptr_t value);
#endif /* NeXT_MOD */

const pseudo_typeS md_pseudo_table[] =
{
#ifdef NeXT_MOD
	{"greg", s_reg, 'r' },
	{"xreg", s_reg, 'x' },
	{"scaled", s_scaled, 0},
	{"abs", s_m88k_abs, 0},
	{"no_delay", s_no_delay, 0},
	{"dot", s_dot, 0},
#endif
#ifndef NeXT_MOD
  	/* At NeXT we don't allow these */
	{"dfloat", float_cons, 'd'},
	{"ffloat", float_cons, 'f'},
	{"global", s_globl, 0},
	{"half", cons, 2 },
	{"ln", s_line, 0},
	{"zero", s_space, 0},
	{"word", cons, 4 },
#endif
	{0}
};

#ifdef NeXT_MOD
static
void
s_dot(
uintptr_t value)
{
	char *name, *end_name, delim;
	symbolS *symbolP;

	if( * input_line_pointer == '"')
	  name = input_line_pointer + 1;
	else
	  name = input_line_pointer;
	delim = get_symbol_end();
	end_name = input_line_pointer;
	*end_name = 0;

	symbolP = symbol_find_or_make (name);
	symbolP -> sy_type = N_ABS;
	symbolP -> sy_other = 0; /* NO_SECT */
	symbolP -> sy_value = obstack_next_free(&frags) - frag_now->fr_literal;
	symbolP -> sy_frag = &zero_address_frag;

	*end_name = delim;
	totally_ignore_line();
}
/*
 * s_reg() is used to implement ".greg symbol,exp" and ".xreg symbol,exp"
 * which set symbol to 1 or 0 depending on if the expression is a general
 * register or extended register respectfully.  These are intended for use in
 * macros.
 */
static
void
s_reg(
uintptr_t reg)
{
	char *name, *end_name, delim;
	symbolS *symbolP;
	uint32_t n_value, val;

	if( * input_line_pointer == '"')
	  name = input_line_pointer + 1;
	else
	  name = input_line_pointer;
	delim = get_symbol_end();
	end_name = input_line_pointer;
	*end_name = delim;
	SKIP_WHITESPACE();
	if ( * input_line_pointer != ',' ) {
		*end_name = 0;
		as_warn("Expected comma after name \"%s\"", name);
		*end_name = delim;
		ignore_rest_of_line();
		return;
	}
	input_line_pointer ++;
	*end_name = 0;

	SKIP_WHITESPACE();
	n_value = 0;
	if (*input_line_pointer == reg || *input_line_pointer == toupper(reg)){
	    input_line_pointer++;
	    if(isdigit(*input_line_pointer)){
		val = 0;
		while (isdigit(*input_line_pointer)){
		    if ((val = val * 10 + *input_line_pointer++ - '0') > 31)
			break;
		}
		SKIP_WHITESPACE();
		if(val <= 31 &&
		   (*input_line_pointer == '\n' || *input_line_pointer == '@'))
		    n_value = 1;
	    }
	}

	symbolP = symbol_find_or_make (name);
	symbolP -> sy_type = N_ABS;
	symbolP -> sy_other = 0; /* NO_SECT */
	symbolP -> sy_value = n_value;
	symbolP -> sy_frag = &zero_address_frag;

	*end_name = delim;
	totally_ignore_line();
}

/*
 * s_scaled() is used to implement ".scaled symbol,exp" which sets symbol to 1
 * or 0 depending on if the expression is a scaled general register expression
 * "r1[r2]" or not respectfully.  This is intended for use in macros.
 */
static
void
s_scaled(
uintptr_t value)
{
	char *name, *end_name, delim;
	symbolS *symbolP;
	uint32_t n_value, val;

	if( * input_line_pointer == '"')
	  name = input_line_pointer + 1;
	else
	  name = input_line_pointer;
	delim = get_symbol_end();
	end_name = input_line_pointer;
	*end_name = delim;
	SKIP_WHITESPACE();
	if ( * input_line_pointer != ',' ) {
		*end_name = 0;
		as_warn("Expected comma after name \"%s\"", name);
		*end_name = delim;
		ignore_rest_of_line();
		return;
	}
	input_line_pointer ++;
	*end_name = 0;

	SKIP_WHITESPACE();
	n_value = 0;
	if (*input_line_pointer == 'r' || *input_line_pointer == 'R'){
	    input_line_pointer++;
	    if(isdigit(*input_line_pointer)){
		val = 0;
		while (isdigit(*input_line_pointer)){
		    if ((val = val * 10 + *input_line_pointer++ - '0') > 31)
			break;
		}
		SKIP_WHITESPACE();
		if(val <= 31 && *input_line_pointer == '['){
		    input_line_pointer++;
		    if (*input_line_pointer == 'r' ||
			*input_line_pointer == 'R'){
			input_line_pointer++;
			if(isdigit(*input_line_pointer)){
			    val = 0;
			    while (isdigit(*input_line_pointer)){
				if ((val = val * 10 +
					   *input_line_pointer++ - '0') > 31)
				    break;
			    }
			    if(val <= 31 && *input_line_pointer == ']'){
				input_line_pointer++;
				SKIP_WHITESPACE();
				if(*input_line_pointer == '\n' ||
				   *input_line_pointer == '@')
		    		    n_value = 1;
			    }
			}
		    }
		}
	    }
	}

	symbolP = symbol_find_or_make (name);
	symbolP -> sy_type = N_ABS;
	symbolP -> sy_other = 0; /* NO_SECT */
	symbolP -> sy_value = n_value;
	symbolP -> sy_frag = & zero_address_frag;

	*end_name = delim;
	totally_ignore_line();
}

/*
 * s_m88k_abs() is used to implement ".abs symbol,exp" which sets symbol to 1
 * or 0 depending on if the expression is an absolute expression or not
 * respectfully.  This is intended for use in macros.
 */
static
void
s_m88k_abs(
uintptr_t value)
{
	char *name, *end_name, delim, *start;
	symbolS *symbolP;
	uint32_t n_value, val, is_reg_exp;

	start = input_line_pointer;
	if( * input_line_pointer == '"')
	  name = input_line_pointer + 1;
	else
	  name = input_line_pointer;
	delim = get_symbol_end();
	end_name = input_line_pointer;
	*end_name = delim;
	SKIP_WHITESPACE();
	if ( * input_line_pointer != ',' ) {
		*end_name = 0;
		as_warn("Expected comma after name \"%s\"", name);
		*end_name = delim;
		ignore_rest_of_line();
		return;
	}
	input_line_pointer ++;
	*end_name = 0;

	SKIP_WHITESPACE();
	is_reg_exp = 0;
	n_value = 0;
	if(*input_line_pointer == 'r' || *input_line_pointer == 'R'){
	    input_line_pointer++;
	    if(isdigit(*input_line_pointer)){
		val = 0;
		while (isdigit(*input_line_pointer)){
		    if ((val = val * 10 + *input_line_pointer++ - '0') > 31)
			break;
		}
		SKIP_WHITESPACE();
		if(val <= 31)
		    is_reg_exp = 1;
	    }
	}
	if(is_reg_exp == 0){
	    *end_name = delim;
	    input_line_pointer = start;
	    s_abs(value);
	    return;
	}

	symbolP = symbol_find_or_make (name);
	symbolP -> sy_type = N_ABS;
	symbolP -> sy_other = 0; /* NO_SECT */
	symbolP -> sy_value = n_value;
	symbolP -> sy_frag = & zero_address_frag;
	*end_name = delim;

	totally_ignore_line();
}

/*
 * s_no_delay() is used to implement ".no_delay string" which will abort and
 * print the string if the last instruction assembled has a delay slot.
 * This is intended for use in macros that expand to more than one instruction
 * that could be put in delay slots.  This is not really correct in it's
 * operation in that it is not per-section and does not take into account
 * anything other than assembled instructions.
 */
static
void
s_no_delay(
uintptr_t value)
{
	char *p, c;

	p = input_line_pointer;
	while(*p != '\n' && *p != '@' && *p != '\0')
	    p++;
	c = *p;
	*p = '\0';
	
	if(in_delay_slot)
	    as_fatal("delay slot abort %s detected.  Assembly stopping.",
		     input_line_pointer);
	input_line_pointer = p;
	*p = c;
}
#endif /* NeXT_MOD */

void
md_begin(
void)
{
	const char *retval = NULL;
	register unsigned int i = 0;

	/* initialize hash table */

	op_hash = hash_new();
	if (op_hash == NULL)
		as_fatal("Could not initialize hash table");

	/* loop until you see the end of the list */

	while (*m88k_opcodes[i].name) {
		char *name = m88k_opcodes[i].name;

		/* hash each mnemonic and record its position */

		retval = hash_insert(op_hash, name, (char *)&m88k_opcodes[i]);

		if (retval != NULL && *retval != '\0')
			as_fatal("Can't hash instruction '%s':%s",
					m88k_opcodes[i].name, retval);

		/* skip to next unique mnemonic or end of list */

		for (i++; !strcmp(m88k_opcodes[i].name, name); i++);
	}
}

int
md_parse_option(
char **argP,
int *cntP,
char ***vecP)
{
	return (1);
}

void
md_assemble(
char *op)
{
	char *param, *thisfrag;
	struct m88k_opcode *format;
	struct m88k_insn insn;
#ifdef NeXT_MOD
	int32_t pcrel_reloc;
#endif

	assert(op);

	/* skip over instruction to find parameters */

	/* *param != '\0' is need for instructions that have no parameters
	   like rte */
	for (param = op; !isspace(*param) && *param != '\0' ; param++);
	*param++ = '\0';

	/* try to find the instruction in the hash table */

	if ((format = (struct m88k_opcode *) hash_find(op_hash, op)) == NULL) {
		as_warn("Invalid mnemonic '%s'", op);
		return;
	}

	/* try parsing this instruction into insn */

	while (!calcop(format,param,&insn))

		/* if it doesn't parse try the next instruction */

		if (!strcmp(format->name, format[1].name))
			format++;
		else {
			as_warn("Parameter syntax error");
			return;
		}

	/* grow the current frag and plop in the opcode */

	thisfrag = frag_more(4);
	md_number_to_chars(thisfrag, insn.opcode, 4);
#ifdef NeXT_MOD
	in_delay_slot = format->delay_slot;
#endif
#ifdef NeXT_MOD	/* generate stabs for debugging assembly code */
	/*
	 * If the -g flag is present generate a line number stab for the
	 * instruction.
	 * 
	 * See the detailed comments about stabs in read_a_source_file() for a
	 * description of what is going on here.
	 */
	if(flagseen['g'] && frchain_now->frch_nsect == text_nsect){
	    (void)symbol_new(
		  "",
		  68 /* N_SLINE */,
		  text_nsect,
		  logical_input_line /* n_desc, line number */,
		  obstack_next_free(&frags) - frag_now->fr_literal,
		  frag_now);
	}
#endif /* NeXT_MOD */

#ifdef NeXT_MOD	/* mark sections containing instructions */
	/*
	 * We are putting a machine instruction in this section so mark it as
	 * containg some machine instructions.
	 */
	frchain_now->frch_section.flags |= S_ATTR_SOME_INSTRUCTIONS;
#endif /* NeXT_MOD */

#ifdef NeXT_MOD
	pcrel_reloc = 0;
	if (insn.reloc == M88K_RELOC_PC16 || insn.reloc == M88K_RELOC_PC26){
	    /*
	     * The NeXT linker has the ability to scatter blocks of
	     * sections between labels.  This requires that brances to
	     * labels that survive to the link phase must be able to
	     * be relocated.
	     */
	    if(insn.exp.X_add_symbol != NULL &&
	       (insn.exp.X_add_symbol->sy_name[0] != 'L' || flagseen ['L']))
		pcrel_reloc = 1;
	    else
		pcrel_reloc = 0;
	}
#endif /* NeXT_MOD */

	/* if this instruction requires labels mark it for later */
	switch (insn.reloc) {

		case NO_RELOC:
				break;

		case M88K_RELOC_LO16:
		case M88K_RELOC_HI16:
				fix_new(
					frag_now,
#ifdef NeXT_MOD
					thisfrag - frag_now->fr_literal,
					4,
#else
					thisfrag - frag_now->fr_literal + 2,
					2,
#endif
					insn.exp.X_add_symbol,
					insn.exp.X_subtract_symbol,
					insn.exp.X_add_number,
					0, 0,
					insn.reloc
				);
				break;

#ifndef NeXT_MOD
		case M88K_RELOC_IW16:
				fix_new(
					frag_now,
					thisfrag - frag_now->fr_literal,
					4,
					insn.exp.X_add_symbol,
					insn.exp.X_subtract_symbol,
					insn.exp.X_add_number,
					0, 0,
					insn.reloc
				);
				break;
#endif /* !defined(NeXT_MOD) */

		case M88K_RELOC_PC16:
				fix_new(
					frag_now,
#ifdef NeXT_MOD
					thisfrag - frag_now->fr_literal,
					4,
#else
					thisfrag - frag_now->fr_literal + 2,
					2,
#endif
					insn.exp.X_add_symbol,
					insn.exp.X_subtract_symbol,
					insn.exp.X_add_number,
					1, pcrel_reloc,
					insn.reloc
				);
				break;

		case M88K_RELOC_PC26:
				fix_new(
					frag_now,
					thisfrag - frag_now->fr_literal,
					4,
					insn.exp.X_add_symbol,
					insn.exp.X_subtract_symbol,
					insn.exp.X_add_number,
					1, pcrel_reloc,
					insn.reloc
				);
				break;

		default:
				as_warn("Unknown relocation type");
				break;
	}
}

static
int
calcop(
struct m88k_opcode *format,
char *param,
struct m88k_insn *insn)
{
	int parcnt;

	/* initial the passed structure */

	memset(insn, '\0', sizeof(*insn));
	insn->reloc = NO_RELOC;
	insn->opcode = format->opcode;

	/* parse all parameters */

	for (parcnt=0; parcnt<3 && format->op[parcnt].type != NIL; parcnt++) {

		switch (format->op[parcnt].type) {

			case CNST:
				param = parse_cst(param, insn, format, parcnt);
				break;

			case REG:
				param = parse_reg(param, insn, format, parcnt);
				break;
#ifdef m88110
			case EREG:
				param = parse_ereg(param, insn, format, parcnt);
				break;

			case E4ROT:
				param = parse_e4rot(param, insn, format,parcnt);
				break;

			case XREG:
				param = parse_xreg(param, insn, format, parcnt);
				break;
#endif /* m88110 */
			case BF:
				param = parse_bf(param, insn, format, parcnt);
				break;

			case ROT:
				param = parse_rot(param, insn, format, parcnt);
				break;

			case REGSC:
				param = parse_rsc(param, insn, format, parcnt);
				break;

			case CRREG:
				param = parse_cr(param, insn, format, parcnt);
				break;

			case FCRREG:
				param = parse_fcr(param, insn, format, parcnt);
				break;

			case PCREL:
				param = parse_pcr(param, insn, format, parcnt);
				break;

			case CONDMASK:
				param = parse_cnd(param, insn, format, parcnt);
				break;

			case CMPRSLT:
				param = parse_cmp(param, insn, format, parcnt);
				break;

			default:
				as_fatal("Unknown parameter type");
		}

		/* see if parser failed or not */

		if (param == NULL)
			return 0;
	}

	return 1;
}

static
char *
parse_pcr(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	char *saveptr, *saveparam;
	segT seg;

	saveptr = input_line_pointer;
	input_line_pointer = param;

	seg = expression(&insn->exp);

	saveparam = input_line_pointer;
	input_line_pointer = saveptr;

	switch (format->op[parcnt].width) {

		case 16: insn->reloc = M88K_RELOC_PC16;
			 break;

		case 26: insn->reloc = M88K_RELOC_PC26;
			 break;

		default: as_warn("Strange PC relative width %d",
						format->op[parcnt].width);
			 break;
	}

	return saveparam;
}

static
char *
parse_reg(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	unsigned int val = 0;

	if (*param != 'r' && *param != 'R')
		return NULL;

	param++;

	if (!isdigit(*param))
		return NULL;

	while (isdigit(*param))
		if ((val = val * 10 + *param++ - '0') > 31)
			return NULL;

	insn->opcode |= val << format->op[parcnt].offset;

	switch (*param) {

		case '\0' :
			if (parcnt == 2 || format->op[parcnt+1].type == NIL)
				return param;
			else
				return NULL;

		case '['  :
			if (parcnt != 2 && format->op[parcnt+1].type == REGSC)
				return param+1;
			else
				return NULL;

		case ','  :
			if (parcnt != 2 && format->op[parcnt+1].type != NIL)
				return param+1;
			else
				return NULL;
	}

	return NULL;
}

#ifdef m88110
static
char *
parse_ereg(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	unsigned int val = 0;

	if (*param != 'r' && *param != 'R')
		return NULL;

	param++;

	if (!isdigit(*param))
		return NULL;

	while (isdigit(*param))
		if ((val = val * 10 + *param++ - '0') > 31)
			return NULL;

	if((val & 0x1) != 0)
		return NULL;

	insn->opcode |= val << format->op[parcnt].offset;

	switch (*param) {

		case '\0' :
			if (parcnt == 2 || format->op[parcnt+1].type == NIL)
				return param;
			else
				return NULL;

		case '['  :
			if (parcnt != 2 && format->op[parcnt+1].type == REGSC)
				return param+1;
			else
				return NULL;

		case ','  :
			if (parcnt != 2 && format->op[parcnt+1].type != NIL)
				return param+1;
			else
				return NULL;
	}

	return NULL;
}

static
char *
parse_e4rot(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	int val;
	char *saveptr, save_c, *offset_ptr;
        expressionS exp;
	segT seg;

	/* Now step over the '<' and look for the offset expression before a
	   '>' and the end of line (which is a '\0' when we get here).  We
	   know there is a '\0' where the end of line was because that is
	   what parse_a_buffer() in read.c does before calling md_assemble */
	if (*param++ != '<')
		return NULL;
	offset_ptr = param;
	while(*param != '\0')
		param++;
	if(param == offset_ptr || param[-1] != '>')
		return NULL;
	param--;
	save_c = *param;
	*param = '\0';
	saveptr = input_line_pointer;
	input_line_pointer = offset_ptr;
	seg = expression(&exp);
	*param = save_c;
	input_line_pointer = saveptr;
	val = exp.X_add_number;
	if(seg != SEG_ABSOLUTE || val > 60 || (val & 0x3) != 0)
		return NULL;

	val >>= 2;
	insn->opcode |= val << format->op[parcnt].offset;

	return param+1;
}

static
char *
parse_xreg(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	unsigned int val = 0;

	if (*param != 'x' && *param != 'X')
		return NULL;

	param++;

	if (!isdigit(*param))
		return NULL;

	while (isdigit(*param))
		if ((val = val * 10 + *param++ - '0') > 31)
			return NULL;

	insn->opcode |= val << format->op[parcnt].offset;

	switch (*param) {

		case '\0' :
			if (parcnt == 2 || format->op[parcnt+1].type == NIL)
				return param;
			else
				return NULL;

		case '['  :
			if (parcnt != 2 && format->op[parcnt+1].type == REGSC)
				return param+1;
			else
				return NULL;

		case ','  :
			if (parcnt != 2 && format->op[parcnt+1].type != NIL)
				return param+1;
			else
				return NULL;
	}

	return NULL;
}
#endif /* m88110 */

static
char *
parse_cmp(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	int val;
	char *saveptr, save_c, *offset_ptr, c;
        expressionS exp;
	segT seg;

	/* look for the offset expression before a ',' */
	c = *param;
	if (isdigit(c) || c == '(' || c == '-' || c == '+' || c == '!' ||
	    c == '~'){
		offset_ptr = param;
		while(*param != ',')
			param++;
		if(param == offset_ptr || *param != ',')
			return NULL;
		save_c = *param;
		*param = '\0';
		saveptr = input_line_pointer;
		input_line_pointer = offset_ptr;
		seg = expression(&exp);
		*param = save_c;
		input_line_pointer = saveptr;
		val = exp.X_add_number;
		if(seg != SEG_ABSOLUTE ||
		   val > (1 << format->op[parcnt].width) || val < 0)
			return NULL;
	} else {
		if (isupper(*param))
			*param = tolower(*param);

		if (isupper(*(param+1)))
			*(param+1) = tolower(*(param+1));

		for (val=0; cmpslot[val] != NULL; val++)
			if (!strncmp(param,cmpslot[val],2))
				break;

		if (cmpslot[val] == NULL)
			return NULL;

		param += 2;
	}

	if (*param++ != ',')
		return NULL;

	insn->opcode |= val << format->op[parcnt].offset;

	return param;
}

static
char *
parse_cnd(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	int val;
	char *saveptr, save_c, *offset_ptr, c;
        expressionS exp;
	segT seg;

	/* look for the offset expression before a ',' */
	c = *param;
	if (isdigit(c) || c == '(' || c == '-' || c == '+' || c == '!' ||
	    c == '~'){
		offset_ptr = param;
		while(*param != ',')
			param++;
		if(param == offset_ptr || *param != ',')
			return NULL;
		save_c = *param;
		*param = '\0';
		saveptr = input_line_pointer;
		input_line_pointer = offset_ptr;
		seg = expression(&exp);
		*param = save_c;
		input_line_pointer = saveptr;
		val = exp.X_add_number;
		if(seg != SEG_ABSOLUTE ||
		   val > (1 << format->op[parcnt].width) || val < 0)
			return NULL;
	} else {
		if (isupper(*param))
			*param = tolower(*param);

		if (isupper(*(param+1)))
			*(param+1) = tolower(*(param+1));

		for (val=0; cndmsk[val].name != NULL; val++)
			if (!strncmp(param,cndmsk[val].name,3))
				break;

		if (cndmsk[val].name == NULL)
			return NULL;

		val = cndmsk[val].num;

		param += 3;
	}

	if (*param++ != ',')
		return NULL;

	insn->opcode |= val << format->op[parcnt].offset;

	return param;
}

static
char *
parse_bf(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	int val, width;
	char *saveptr, save_c, *offset_ptr, c;
        expressionS exp;
	segT seg;

	/* We know there is a '\0' where the end of line was because that is
	   what parse_a_buffer() in read.c does before calling md_assemble */

	/* First look for the width expression before a '<' */
	saveptr = input_line_pointer;
	input_line_pointer = param;
	while(*param != '<' && *param != '\0')
		param++;
	if(*param == '\0'){
		input_line_pointer = saveptr;
		return NULL;
	}
	save_c = *param;
	*param = '\0';
	seg = expression(&exp);
	*param = save_c;
	input_line_pointer = saveptr;
	width = exp.X_add_number;
	if(seg != SEG_ABSOLUTE || width > 32 || width < 0)
		return NULL;

	/* Now step over the '<' and look for the offset expression before a
	   '>' and the end of line (which is a '\0' when we get here) */
	param++;
	c = *param;
	if (isdigit(c) || c == '(' || c == '-' || c == '+' || c == '!' ||
	    c == '~'){
		offset_ptr = param;
		while(*param != '\0')
			param++;
		if(param != offset_ptr && param[-1] != '>')
			return NULL;
		param--;
		save_c = *param;
		*param = '\0';
		saveptr = input_line_pointer;
		input_line_pointer = offset_ptr;
		seg = expression(&exp);
		*param = save_c;
		input_line_pointer = saveptr;
		val = exp.X_add_number;
		if(seg != SEG_ABSOLUTE || val > 32 || val < 0)
			return NULL;
	}
	else {
		if (isupper(*param))
			*param = tolower(*param);

		if (isupper(*(param+1)))
			*(param+1) = tolower(*(param+1));

		for (val=0; cmpslot[val] != NULL; val++)
			if (!strncmp(param,cmpslot[val],2))
				break;

		if (cmpslot[val] == NULL)
			return NULL;

		param += 2;
	}
	if (*param != '>')
		return NULL;
	insn->opcode |= width << 5;
	insn->opcode |= val;

	return param+1;
}

static
char *
parse_rot(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	int val;
	char *saveptr, save_c, *offset_ptr;
        expressionS exp;
	segT seg;

	/* Now step over the '<' and look for the offset expression before a
	   '>' and the end of line (which is a '\0' when we get here).  We
	   know there is a '\0' where the end of line was because that is
	   what parse_a_buffer() in read.c does before calling md_assemble */
	if (*param++ != '<')
		return NULL;
	offset_ptr = param;
	while(*param != '\0')
		param++;
	if(param != offset_ptr && param[-1] != '>')
		return NULL;
	param--;
	save_c = *param;
	*param = '\0';
	saveptr = input_line_pointer;
	input_line_pointer = offset_ptr;
	seg = expression(&exp);
	*param = save_c;
	input_line_pointer = saveptr;
	val = exp.X_add_number;
	if(seg != SEG_ABSOLUTE && (val > 32 || val < 0))
		return NULL;

	insn->opcode |= val;

	return param+1;
}

static
char *
parse_rsc(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	unsigned int val = 0;

	if (*param != 'r' && *param != 'R')
		return NULL;

	param++;

	if (!isdigit(*param))
		return NULL;

	while (isdigit(*param))
		if ((val = val * 10 + *param++ - '0') > 31)
			return NULL;

	insn->opcode |= val << format->op[parcnt].offset;

	if (*param != ']' || *(param+1) != '\0')
		return NULL;

	return param+1;
}

static
char *
parse_cr(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	unsigned int val = 0;

	if (strncmp(param, "cr", 2))
		return NULL;

	param += 2;

	if (!isdigit(*param))
		return NULL;

	while (isdigit(*param))
		if ((val = val * 10 + *param++ - '0') > 63)
			return NULL;

	/*
	 * the following fix is not as generic as I'd like, but the
	 * hardware is real picky about this.	- bowen@cs.buffalo.edu
	 * This fix is to make sure the S1 and S2 fields are the same.
	 */
	insn->opcode |= (insn->opcode & 0x001f0000) >> 16;

	insn->opcode |= val << format->op[parcnt].offset;

	if (*param != '\0')
		return NULL;

	return param;
}

static
char *
parse_fcr(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	unsigned int val = 0;

	if (strncmp(param, "fcr", 3))
		return NULL;

	param += 3;

	if (!isdigit(*param))
		return NULL;

	while (isdigit(*param))
		if ((val = val * 10 + *param++ - '0') > 63)
			return NULL;

	/*
	 * This is to make sure the S1 and S2 fields are the same.
	 */
	insn->opcode |= (insn->opcode & 0x001f0000) >> 16;

	insn->opcode |= val << format->op[parcnt].offset;

	if (*param != '\0')
		return NULL;

	return param;
}

static
char *
parse_cst(
char *param,
struct m88k_insn *insn,
struct m88k_opcode *format,
int parcnt)
{
	char c, *saveptr, *saveparam;
	int val, nohilo = 0;
	segT seg;
        expressionS exp;

	c = *param;
	if (isdigit(c) || c == '(' || c == '-' || c == '+' || c == '!' ||
	    c == '~'){
		saveptr = input_line_pointer;
		input_line_pointer = param;
		while(*param != '\0')
			param++;
		seg = expression(&exp);
		input_line_pointer = saveptr;
		val = exp.X_add_number;
		if(seg != SEG_ABSOLUTE || val > (1 << format->op[parcnt].width))
			return NULL;
	}
	else if (!strncmp(param,"hi16(",5))

		if (isdigit(*(param+5))) {
			param = getval(param+5, (unsigned int *)&val);
			val = (val & 0xffff0000) >> 16;
			if (*param++ != ')')
				return NULL;

		} else
			insn->reloc = M88K_RELOC_HI16;
	else if (!strncmp(param,"lo16(",5))

		if (isdigit(*(param+5))) {
			param = getval(param+5, (unsigned int *)&val);
			val &= 0x0000ffff;
			if (*param++ != ')')
				return NULL;

		} else
			insn->reloc = M88K_RELOC_LO16;

#ifndef NeXT_MOD
	else if (!strncmp(param,"iw16(",5))

		if (isdigit(*(param+5))) {
			param = getval(param+5,&val);
			val &= 0x0000ffff;
			if (*param++ != ')')
				return NULL;

		} else
			insn->reloc = M88K_RELOC_IW16;
#endif /* !defined(NeXT_MOD) */

	else if (*param == 'r' && isdigit(*(param+1)))

		return NULL;

	else {
		insn->reloc = M88K_RELOC_LO16;
		nohilo = 1;
	}

	if (insn->reloc != NO_RELOC) {

		saveptr = input_line_pointer;
		input_line_pointer = param + (nohilo ? 0 : 5);

		seg = expression(&insn->exp);

		saveparam = input_line_pointer;
		input_line_pointer = saveptr;

		if (nohilo) {

			if (*saveparam != '\0')
				return NULL;

			return saveparam;
		}

		if (*saveparam != ')')
			return NULL;

		return saveparam+1;
	}

	if ((1 << format->op[parcnt].width) <= val)
		return NULL;

	insn->opcode |= val << format->op[parcnt].offset;

	if (*param != '\0')
		return NULL;

	return param;
}

#define isoct(z) (z >= '0' && z <= '7')
#define ishex(z) ((z >= '0' && z <= '9') || (z >= 'a' && z <= 'f') || (z >= 'A' && z <= 'F'))
#define hexval(z) \
  (isdigit(z) ? (z) - '0' :		\
   islower(z) ? (z) - 'a' + 10 :	\
   (z) - 'A' + 10)

static
char *
getval(
char *param,
unsigned int *val)
{
	*val = 0;

	if (*param == '0' && (*(param+1) == 'x' || *(param+1) == 'X'))

		for (param += 2; ishex(*param); param++)

			if (*val > 0x0fffffff)
				return param;
			else
				*val = *val * 16 + hexval(*param);

	else if (*param == '0')

		for (param++; isoct(*param); param++)

			if (*val > 0x1fffffff)
				return param;
			else
				*val = *val * 8 + *param - '0';

	else

		for (; isdigit(*param); param++)

			*val = *val * 10 + *param - '0';

	return param;
}

void
md_number_to_chars(
char *buf,
signed_expr_t val,
int nbytes)
{
	switch(nbytes) {

		case 4:
			*buf++ = val >> 24;
			*buf++ = val >> 16;
		case 2:
			*buf++ = val >> 8;
		case 1:
			*buf = val;
			break;

		default:
			abort();
	}
}

void
md_number_to_imm(
unsigned char *buf,
signed_expr_t val,
int nbytes,
fixS *fixP,
int nsect)
{
	if(fixP->fx_r_type == NO_RELOC ||
	   fixP->fx_r_type == M88K_RELOC_VANILLA) {
		switch (nbytes) {
			case 4:
				*buf++ = val >> 24;
				*buf++ = val >> 16;
			case 2:
				*buf++ = val >> 8;
			case 1:
				*buf = val;
				break;

			default:
				abort();
		}
		return;
	}

	switch (fixP->fx_r_type) {
#ifdef NeXT_MOD
			case M88K_RELOC_LO16:
				buf[2] = val >> 8;
				buf[3] = val;
				break;
			case M88K_RELOC_HI16:
				buf[2] = val >> 24;
				buf[3] = val >> 16;
				break;

			case M88K_RELOC_PC16:
				val += 4;
				buf[2] = val >> 10;
				buf[3] = val >> 2;
				break;

			case M88K_RELOC_PC26:
				val += 4;
				buf[0] |= (val >> 26) & 0x03;
				buf[1] = val >> 18;
				buf[2] = val >> 10;
				buf[3] = val >> 2;
				break;
#else /* !defined NeXT_MOD */
			case M88K_RELOC_LO16:
				buf[0] = val >> 8;
				buf[1] = val;
				break;

			case M88K_RELOC_IW16:
				buf[2] = val >> 8;
				buf[3] = val;
				break;

			case M88K_RELOC_HI16:
				buf[0] = val >> 24;
				buf[1] = val >> 16;
				break;

			case M88K_RELOC_PC16:
				val += 4;
				buf[0] = val >> 10;
				buf[1] = val >> 2;
				break;

			case M88K_RELOC_PC26:
				val += 4;
				buf[0] |= (val >> 26) & 0x03;
				buf[1] = val >> 18;
				buf[2] = val >> 10;
				buf[3] = val >> 2;
				break;

			case M88K_RELOC_32:
				buf[0] = val >> 24;
				buf[1] = val >> 16;
				buf[2] = val >> 8;
				buf[3] = val;
				break;
#endif /* !defined(NeXT_MOD) */

			default:
				as_warn("Bad relocation type");
				break;
	}
}

#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
 */
char *
md_atof(
int type,
char *litP,
int *sizeP)
{
	int	prec;
	LITTLENUM_TYPE words[MAX_LITTLENUMS];
	LITTLENUM_TYPE *wordP;
	char	*t;
	char	*atof_ieee();

	switch(type) {
	case 'f':
	case 'F':
	case 's':
	case 'S':
		prec = 2;
		break;

	case 'd':
	case 'D':
	case 'r':
	case 'R':
		prec = 4;
		break;

	case 'x':
	case 'X':
		prec = 6;
		break;

	case 'p':
	case 'P':
		prec = 6;
		break;

	default:
		*sizeP=0;
		return "Bad call to MD_ATOF()";
	}
	t=atof_ieee(input_line_pointer,type,words);
	if(t)
		input_line_pointer=t;

	*sizeP=prec * sizeof(LITTLENUM_TYPE);
	for(wordP=words;prec--;) {
		md_number_to_chars(litP,(int32_t)(*wordP++),sizeof(LITTLENUM_TYPE));
		litP+=sizeof(LITTLENUM_TYPE);
	}
	return "";	/* Someone should teach Dean about null pointers */
}

const relax_typeS md_relax_table[] = { {0} };

int
md_estimate_size_before_relax(
fragS *fragP,
int segment_type)
{
	as_fatal("internal error: Relaxation should never occur");
	return(0);
}

void
md_convert_frag(
fragS *fragP)
{
	as_fatal("internal error: Relaxation should never occur");
}

void
md_end(
void)
{
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/md.h                                     0100644 0001750 0001750 00000013011 12612724204 021606  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* md.h -machine dependent- */

/* Copyright (C) 1987 Free Software Foundation, Inc.

This file is part of Gas, the GNU Assembler.

The GNU assembler is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY.  No author or distributor
accepts responsibility to anyone for the consequences of using it
or for whether it serves any particular purpose or works at all,
unless he says so in writing.  Refer to the GNU Assembler General
Public License for full details.

Everyone is granted permission to copy, modify and redistribute
the GNU Assembler, but only under the conditions described in the
GNU Assembler General Public License.  A copy of this license is
supposed to have been given to you along with the GNU Assembler
so you can know your rights and responsibilities.  It should be
in a file named COPYING.  Among other things, the copyright
notice and this notice must be preserved on all copies.  */

#import <mach/machine.h>
#import "stuff/bytesex.h"
#import "frags.h"
#import "relax.h"
#import "struc-symbol.h"
#import "fixes.h"
#import "read.h"

/* These are the default cputype and cpusubtype for this target MACHINE */
extern const cpu_type_t md_cputype;
extern cpu_subtype_t md_cpusubtype;

/* This is the byte sex for this target MACHINE */
extern const enum byte_sex md_target_byte_sex;

/* These characters start a comment anywhere on the line */
extern const char md_comment_chars[];

/* These characters only start a comment at the beginning of a line */
extern const char md_line_comment_chars[];

/*
 * These characters can be used to separate mantissa decimal digits from 
 * exponent decimal digits in floating point numbers.
 */
extern const char md_EXP_CHARS[];

/*
 * The characters after a leading 0 that means this number is a floating point
 * constant as in 0f123.456 or 0d1.234E-12 (the characters 'f' and 'd' in these
 * case).
 */
extern const char md_FLT_CHARS[];

/*
 * This is the machine dependent pseudo opcode table for this target MACHINE.
 */
extern const pseudo_typeS md_pseudo_table[];

/*
 * This is the machine dependent table that is used to drive the span dependent
 * branch algorithm in relax_section() in layout.c.  See the comments in relax.h
 * on how this table is used.  For machines with all instructions of the same
 * size (RISC machines) this this table is just a zero filled element and not
 * used.
 */
extern const relax_typeS md_relax_table[];

/*
 * md_parse_option() is called from main() in as.c to parse target machine
 * dependent command line options.  This routine returns 0 if it is passed an
 * option that is not recognized non-zero otherwise.
 */
extern int md_parse_option(
    char **argP,
    int *cntP,
    char ***vecP);

/*
 * md_begin() is called from main() in as.c before assembly begins.  It is used
 * to allow target machine dependent initialization.
 */
extern void md_begin(
    void);

/*
 * md_end() is called from main() in as.c after assembly ends.  It is used
 * to allow target machine dependent clean up.
 */
extern void md_end(
    void);

/*
 * md_assemble() is passed a pointer to a string that should be a assembly
 * statement for the target machine.  This routine assembles the string into
 * a machine instruction.
 */
extern void md_assemble(
    char *str);

/*
 * md_atof() turns a string pointed to by input_line_pointer into a floating
 * point constant of type type, and store the appropriate bytes in *litP.
 * The number of LITTLENUMS emitted is stored indirectly through *sizeP.
 * An error message is returned, or a string containg only a '\0' for OK.
 */
extern char *md_atof(
    int type,
    char *litP,
    int *sizeP);

/*
 * md_number_to_chars() is the target machine dependent routine that puts out
 * a binary value of size 8, 4, 2, or 1 bytes into the specified buffer.  This
 * is done in the target machine's byte sex.
 */
extern void md_number_to_chars(
    char *buf,
    signed_expr_t val,
    int n);
/* FROM tc.h line 55 */
void   md_apply_fix3 (fixS *, valueT *, segT);

/*
 * md_number_to_imm() is the target machine dependent routine that puts out
 * a binary value of size 4, 2, or 1 bytes into the specified buffer with
 * reguard to a possible relocation entry (the fixP->fx_r_type field in the fixS
 * structure pointed to by fixP) for the section with the ordinal nsect.  This
 * is done in the target machine's byte sex using it's relocation types.
 */
extern void md_number_to_imm(
    unsigned char *buf,
    signed_expr_t val,
    int n,
    fixS *fixP,
    int nsect);

/*
 * md_estimate_size_before_relax() is called as part of the algorithm in
 * relax_section() in layout.c that drives the span dependent branch algorithm.
 * It is called once for each machine dependent frag to allow things like
 * braches to undefined symbols to be "relaxed" to their maximum size.
 * For machines with all instructions of the same size (RISC machines) this
 * won't ever be called.
 */
extern int md_estimate_size_before_relax(
    fragS *fragP,
    int nsect);

/*
 * md_convert_frag() is called on each machine dependent frag after the span
 * dependent branch algorithm has been run to determine the sizes and addresses
 * of all the fragments.  This routine is to put the bytes inside the fragment
 * and make it conform to the "relaxed" final size.  For machines with all
 * instructions of the same size (RISC machines) this won't ever be called.
 */
extern void md_convert_frag(
    fragS *fragP);

/*
 * md_pcrel_from() returns the PC-relative offset from the given fixup.
 * This is not implemented or used for most targets.
 */
extern int32_t md_pcrel_from(
    const fixS *fixP);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/messages.c                               0100644 0001750 0001750 00000012555 12612724204 023024  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* messages.c - error reporter -
   Copyright (C) 1987 Free Software Foundation, Inc.

This file is part of GAS, the GNU Assembler.

GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <mach/mach.h>
#include <mach/mach_init.h>
#if defined(__OPENSTEP__) || defined(__GONZO_BUNSEN_BEAKER__)
#include <servers/netname.h>
#else
#include <servers/bootstrap.h>
#endif
#include "as.h"
#include "input-scrub.h"
#include "messages.h"

/*
		ERRORS

	We print the error message 1st, beginning in column 1.
	All ancillary info starts in column 2 on lines after the
	key error text.
	We try to print a location in logical and physical file
	just after the main error text.
	Caller then prints any appendices after that, begining all
	lines with at least 1 space.

	Optionally, we may die.
	There is no need for a trailing '\n' in your error text format
	because we supply one.

as_warn(fmt,args)  Like fprintf(stderr,fmt,args) but also call errwhere().

as_fatal(fmt,args) Like as_warn() but exit with a fatal status.

*/


/*
 * Nonzero if we've hit a 'bad error', and should not write an obj file,
 * and exit with a nonzero error code.
 */
int bad_error = 0;

/*
 * If set to non-zero in main() -arch_multiple as been specified so if any
 * error messages are printed print a single line first to start which errors
 * the architectures are for.
 */
int arch_multiple = 0;

/*
 * architecture_banner() returns the string to say what target we are assembling
 * for.
 */
static
const char *
architecture_banner(void)
{
#ifdef M68K
	return("as: for architecture m68k\n");
#endif
#ifdef M88K
	return("as: for architecture m88k\n");
#endif
#ifdef PPC
	return("as: for architecture ppc\n");
#endif
#ifdef I860
	return("as: for architecture i860\n");
#endif
#ifdef I386
	return("as: for architecture i386\n");
#endif
#ifdef HPPA
	return("as: for architecture hppa\n");
#endif
#ifdef SPARC
	return("as: for architecture sparc\n");
#endif
#ifdef ARM
	return("as: for architecture arm\n");
#endif
}

/*
 * print_architecture_banner() prints what architecture we are assembling for
 * if it has not previously been printed.
 */
static
void
print_architecture_banner(void)
{
    static int printed = 0;

	if(arch_multiple && !printed){
	    printf("%s", architecture_banner());
	    printed = 1;
	}
}

/*
 *			a s _ w a r n ( )
 *
 * Send to stderr a string as a warning, and locate warning in input file(s).
 * Please only use this for when we have some recovery action.
 * Please explain in string (which may have '\n's) what recovery was done.
 */
void
as_warn(
const char *format,
...)
{
    va_list ap;

	if(!flagseen['W']){
	    print_architecture_banner();
	    as_where();
	    va_start(ap, format);
	    vfprintf(stderr, format, ap);
	    fprintf(stderr, "\n");
	    va_end(ap);
	}
}

/* Like as_bad but the file name and line number are passed in.  */
void
as_warn_where (char *file, unsigned int line, const char *format, ...)
{
  va_list args;

  if (!flagseen['W'])
    {
	    print_architecture_banner();
		fprintf(stderr,"%s:%u:", file, line);
	    va_start (args, format);
	    vfprintf(stderr, format, args);
	    va_end (args);
    }
}

/*
 * Like as_warn_where but the file name and optional line number and column
 * are passed in.
 */
void
as_warn_where_with_column (char *file, unsigned int line, unsigned int column, const char *format, ...)
{
  va_list args;

  if (!flagseen['W'])
    {
	    print_architecture_banner();
	    fprintf(stderr, "%s:", file);
	    if (line)
	      {
		fprintf(stderr, "%u:", line);
		if (column)
		    fprintf(stderr, "%u:", column);
	      }
	    va_start (args, format);
	    vfprintf(stderr, format, args);
	    fprintf(stderr, "\n");
	    va_end (args);
    }
}

/*
 *			a s _ b a d ( )
 *
 * Send to stderr a string as a warning, * and locate warning in input file(s).
 * Please us when there is no recovery, but we want to continue processing
 * but not produce an object file.
 * Please explain in string (which may have '\n's) what recovery was done.
 */
void
as_bad(
const char *format,
...)
{
    va_list ap;

	print_architecture_banner();
	bad_error = 1;
	as_where();
	va_start(ap, format);
	vfprintf(stderr, format, ap);
	fprintf(stderr, "\n");
	va_end(ap);
}

/*
 *			a s _ f a t a l ( )
 *
 * Send to stderr a string (with bell) (JF: Bell is obnoxious!) as a fatal
 * message, and locate stdsource in input file(s).
 * Please only use this for when we DON'T have some recovery action.
 * It exit()s with a warning status.
 */
void
as_fatal(
const char *format,
...)
{
    va_list ap;

	print_architecture_banner();
	bad_error = 1;
	as_where();
	va_start(ap, format);
	fprintf (stderr, "FATAL:");
	vfprintf(stderr, format, ap);
	fprintf(stderr, "\n");
	va_end(ap);
	exit(1);
}

void
sprint_value (char *buf, signed_expr_t val)
{
    sprintf (buf, "%qd", val);
}
                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/messages.h                               0100644 0001750 0001750 00000001463 12612724204 023025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef MESSAGES_H_
#define MESSAGES_H_

#include "as.h"
#include "expr.h"
#include "struc-symbol.h"

extern int bad_error;
extern int arch_multiple;

extern void as_warn(
    const char *format,
     ...) __attribute__ ((format (printf, 1, 2)));

extern void as_warn_where(
    char *file,
	unsigned int line,
	const char *format,
	...) __attribute__ ((format (printf, 3, 4)));

extern void as_warn_where_with_column(
     char *file,
	unsigned int line,
	unsigned int column,
	const char *format,
	...)  __attribute__ ((format (printf, 4, 5)));

extern void as_bad(
    const char *format,
     ...) __attribute__ ((format (printf, 1, 2)));

extern void as_fatal(
    const char *format,
     ...) __attribute__ ((format (printf, 1, 2)));

extern void sprint_value(
	char *, signed_expr_t);

#endif /* MESSAGES_H_ */
                                                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/obstack.c                                0100644 0001750 0001750 00000021564 12612724204 022643  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* obstack.c - subroutines used implicitly by object stack macros
   Copyright (C) 1988 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 1, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <stdlib.h>
#include <stdint.h> /* cctools-port */
#include "obstack.h"

#ifdef __STDC__
#define POINTER void *
#else
#define POINTER char *
#endif

/* Determine default alignment.  */
struct fooalign {char x; double d;};
#define DEFAULT_ALIGNMENT ((char *)&((struct fooalign *) 0)->d - (char *)0)
/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
   But in fact it might be less smart and round addresses to as much as
   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
union fooround {int32_t x; double d;};
#define DEFAULT_ROUNDING (sizeof (union fooround))

/* When we copy a long block of data, this is the unit to do it with.
   On some machines, copying successive ints does not work;
   in such a case, redefine COPYING_UNIT to `long' (if that works)
   or `char' as a last resort.  */
#ifndef COPYING_UNIT
#define COPYING_UNIT int
#endif

/* The non-GNU-C macros copy the obstack into this global variable
   to avoid multiple evaluation.  */

struct obstack *_obstack = 0;

/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
   Objects start on multiples of ALIGNMENT (0 means use default).
   CHUNKFUN is the function to use to allocate chunks,
   and FREEFUN the function to free them.  */

void
_obstack_begin(
struct obstack *h,
int size,
int alignment,
void *(*chunkfun)(size_t n),
void (*freefun)() )
{
  register struct _obstack_chunk* chunk; /* points to new chunk */

  if (alignment == 0)
    alignment = DEFAULT_ALIGNMENT;
  if (size == 0)
    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
    {
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
	 Use the values for range checking, because if range checking is off,
	 the extra bytes won't be missed terribly, but if range checking is on
	 and we used a larger request, a whole extra 4096 bytes would be
	 allocated.

	 These number are irrelevant to the new GNU malloc.  I suspect it is
	 less sensitive to the size of the request.  */
      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
		    + 4 + DEFAULT_ROUNDING - 1)
		   & ~(DEFAULT_ROUNDING - 1));
      size = 4096 - extra;
    }

  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
  h->freefun = freefun;
  h->chunk_size = size;
  h->alignment_mask = alignment - 1;

  chunk	= h->chunk = (*h->chunkfun) (h->chunk_size);
  h->next_free = h->object_base = chunk->contents;
  h->chunk_limit = chunk->limit
   = (char *) chunk + h->chunk_size;
  chunk->prev = 0;
}

/* Allocate a new current chunk for the obstack *H
   on the assumption that LENGTH bytes need to be added
   to the current object, or a new object of length LENGTH allocated.
   Copies any partial object from the end of the old chunk
   to the beginning of the new one.  */

void
_obstack_newchunk(
struct obstack *h,
int length)
{
  register struct _obstack_chunk*	old_chunk = h->chunk;
  register struct _obstack_chunk*	new_chunk;
  register int32_t	new_size;
  register int obj_size = h->next_free - h->object_base;
  register int i;
  int already;

  /* Compute size for new chunk.  */
  new_size = (obj_size + length) + (obj_size >> 3) + 100;
  if (new_size < h->chunk_size)
    new_size = h->chunk_size;

  /* Allocate and initialize the new chunk.  */
  new_chunk = h->chunk = (*h->chunkfun) (new_size);
  new_chunk->prev = old_chunk;
  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;

  /* Move the existing object to the new chunk.
     Word at a time is fast and is safe if the object
     is sufficiently aligned.  */
  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
    {
      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
	   i >= 0; i--)
	((COPYING_UNIT *)new_chunk->contents)[i]
	  = ((COPYING_UNIT *)h->object_base)[i];
      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
	 but that can cross a page boundary on a machine
	 which does not do strict alignment for COPYING_UNITS.  */
      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
    }
  else
    already = 0;
  /* Copy remaining bytes one by one.  */
  for (i = already; i < obj_size; i++)
    new_chunk->contents[i] = h->object_base[i];

  h->object_base = new_chunk->contents;
  h->next_free = h->object_base + obj_size;
}

#ifdef DEBUG
/* Return nonzero if object OBJ has been allocated from obstack H.
   This is here for debugging.
   If you use it in a program, you are probably losing.  */

static
int
_obstack_allocated_p(
struct obstack *h,
POINTER obj)
{
  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */

  lp = (h)->chunk;
  while (lp != 0 && ((POINTER)lp > obj || (POINTER)(lp)->limit < obj))
    {
      plp = lp -> prev;
      lp = plp;
    }
  return lp != 0;
}
#endif /* DEBUG */

/* Free objects in obstack H, including OBJ and everything allocate
   more recently than OBJ.  If OBJ is zero, free everything in H.  */
#undef obstack_free
void
obstack_free(
struct obstack *h,
POINTER obj)
{
  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */

  lp = (h)->chunk;
  /* We use >= because there cannot be an object at the beginning of a chunk.
     But there can be an empty object at that address
     at the end of another chunk.  */
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
    {
      plp = lp -> prev;
      (*h->freefun) (lp);
      lp = plp;
    }
  if (lp)
    {
      (h)->object_base = (h)->next_free = (char *)(obj);
      (h)->chunk_limit = lp->limit;
      (h)->chunk = lp;
    }
  else if (obj != 0)
    /* obj is not in any of the chunks! */
    abort ();
}


#if 0
/* These are now turned off because the applications do not use it
   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */

/* Now define the functional versions of the obstack macros.
   Define them to simply use the corresponding macros to do the job.  */

#ifdef __STDC__
/* These function definitions do not work with non-ANSI preprocessors;
   they won't pass through the macro names in parentheses.  */

/* The function names appear in parentheses in order to prevent
   the macro-definitions of the names from being expanded there.  */

POINTER (obstack_base) (obstack)
     struct obstack *obstack;
{
  return obstack_base (obstack);
}

POINTER (obstack_next_free) (obstack)
     struct obstack *obstack;
{
  return obstack_next_free (obstack);
}

int (obstack_object_size) (obstack)
     struct obstack *obstack;
{
  return obstack_object_size (obstack);
}

int (obstack_room) (obstack)
     struct obstack *obstack;
{
  return obstack_room (obstack);
}

void (obstack_grow) (obstack, pointer, length)
     struct obstack *obstack;
     POINTER pointer;
     int length;
{
  obstack_grow (obstack, pointer, length);
}

void (obstack_grow0) (obstack, pointer, length)
     struct obstack *obstack;
     POINTER pointer;
     int length;
{
  obstack_grow0 (obstack, pointer, length);
}

void (obstack_1grow) (obstack, character)
     struct obstack *obstack;
     int character;
{
  obstack_1grow (obstack, character);
}

void (obstack_blank) (obstack, length)
     struct obstack *obstack;
     int length;
{
  obstack_blank (obstack, length);
}

void (obstack_1grow_fast) (obstack, character)
     struct obstack *obstack;
     int character;
{
  obstack_1grow_fast (obstack, character);
}

void (obstack_blank_fast) (obstack, length)
     struct obstack *obstack;
     int length;
{
  obstack_blank_fast (obstack, length);
}

POINTER (obstack_finish) (obstack)
     struct obstack *obstack;
{
  return obstack_finish (obstack);
}

POINTER (obstack_alloc) (obstack, length)
     struct obstack *obstack;
     int length;
{
  return obstack_alloc (obstack, length);
}

POINTER (obstack_copy) (obstack, pointer, length)
     struct obstack *obstack;
     POINTER pointer;
     int length;
{
  return obstack_copy (obstack, pointer, length);
}

POINTER (obstack_copy0) (obstack, pointer, length)
     struct obstack *obstack;
     POINTER pointer;
     int length;
{
  return obstack_copy0 (obstack, pointer, length);
}

#endif /* __STDC__ */

#endif /* 0 */
                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/obstack.h                                0100644 0001750 0001750 00000036623 12612724204 022652  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* obstack.h - object stack macros
   Copyright (C) 1988 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 1, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Summary:

All the apparent functions defined here are macros. The idea
is that you would use these pre-tested macros to solve a
very specific set of problems, and they would run fast.
Caution: no side-effects in arguments please!! They may be
evaluated MANY times!!

These macros operate a stack of objects.  Each object starts life
small, and may grow to maturity.  (Consider building a word syllable
by syllable.)  An object can move while it is growing.  Once it has
been "finished" it never changes address again.  So the "top of the
stack" is typically an immature growing object, while the rest of the
stack is of mature, fixed size and fixed address objects.

These routines grab large chunks of memory, using a function you
supply, called `obstack_chunk_alloc'.  On occasion, they free chunks,
by calling `obstack_chunk_free'.  You must define them and declare
them before using any obstack macros.

Each independent stack is represented by a `struct obstack'.
Each of the obstack macros expects a pointer to such a structure
as the first argument.

One motivation for this package is the problem of growing char strings
in symbol tables.  Unless you are "fascist pig with a read-only mind"
[Gosper's immortal quote from HAKMEM item 154, out of context] you
would not like to put any arbitrary upper limit on the length of your
symbols.

In practice this often means you will build many short symbols and a
few long symbols.  At the time you are reading a symbol you don't know
how long it is.  One traditional method is to read a symbol into a
buffer, realloc()ating the buffer every time you try to read a symbol
that is longer than the buffer.  This is beaut, but you still will
want to copy the symbol from the buffer to a more permanent
symbol-table entry say about half the time.

With obstacks, you can work differently.  Use one obstack for all symbol
names.  As you read a symbol, grow the name in the obstack gradually.
When the name is complete, finalize it.  Then, if the symbol exists already,
free the newly read name.

The way we do this is to take a large chunk, allocating memory from
low addresses.  When you want to build a symbol in the chunk you just
add chars above the current "high water mark" in the chunk.  When you
have finished adding chars, because you got to the end of the symbol,
you know how long the chars are, and you can create a new object.
Mostly the chars will not burst over the highest address of the chunk,
because you would typically expect a chunk to be (say) 100 times as
long as an average object.

In case that isn't clear, when we have enough chars to make up
the object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)
so we just point to it where it lies.  No moving of chars is
needed and this is the second win: potentially long strings need
never be explicitly shuffled. Once an object is formed, it does not
change its address during its lifetime.

When the chars burst over a chunk boundary, we allocate a larger
chunk, and then copy the partly formed object from the end of the old
chunk to the beginning of the new larger chunk.  We then carry on
accreting characters to the end of the object as we normally would.

A special macro is provided to add a single char at a time to a
growing object.  This allows the use of register variables, which
break the ordinary 'growth' macro.

Summary:
	We allocate large chunks.
	We carve out one object at a time from the current chunk.
	Once carved, an object never moves.
	We are free to append data of any size to the currently
	  growing object.
	Exactly one object is growing in an obstack at any one time.
	You can run one obstack per control block.
	You may have as many control blocks as you dare.
	Because of the way we do it, you can `unwind' a obstack
	  back to a previous state. (You may remove objects much
	  as you would with a stack.)
*/


/* Don't do the contents of this file more than once.  */

#ifndef __OBSTACKS__
#define __OBSTACKS__

#define obstack_chunk_alloc	xmalloc
#define obstack_chunk_free	xfree

/* We use subtraction of (char *)0 instead of casting to int
   because on word-addressable machines a simple cast to int
   may ignore the byte-within-word field of the pointer.  */

#ifndef __PTR_TO_INT
#define __PTR_TO_INT(P) ((P) - (char *)0)
#endif

#ifndef __INT_TO_PTR
#define __INT_TO_PTR(P) ((P) + (char *)0)
#endif

struct _obstack_chunk		/* Lives at front of each chunk. */
{
  char  *limit;			/* 1 past end of this chunk */
  struct _obstack_chunk *prev;	/* address of prior chunk or NULL */
  char	contents[4];		/* objects begin here */
};

struct obstack		/* control current object in current chunk */
{
  size_t chunk_size;		/* preferred size to allocate chunks in */
  struct _obstack_chunk* chunk;	/* address of current struct obstack_chunk */
  char	*object_base;		/* address of object we are building */
  char	*next_free;		/* where to add next char to current object */
  char	*chunk_limit;		/* address of char after current chunk */
  int	temp;			/* Temporary for some macros.  */
  int   alignment_mask;		/* Mask of alignment for each object. */
  struct _obstack_chunk *(*chunkfun) (); /* User's fcn to allocate a chunk.  */
  void (*freefun) ();		/* User's function to free a chunk.  */
};

#ifdef __STDC__

/* Do the function-declarations after the structs
   but before defining the macros.  */

void obstack_init (struct obstack *obstack);

void * obstack_alloc (struct obstack *obstack, int size);

void * obstack_copy (struct obstack *obstack, void *address, int size);
void * obstack_copy0 (struct obstack *obstack, void *address, int size);

void obstack_free (struct obstack *obstack, void *block);

void obstack_blank (struct obstack *obstack, int size);

void obstack_grow (struct obstack *obstack, void *data, int size);
void obstack_grow0 (struct obstack *obstack, void *data, int size);

void obstack_1grow (struct obstack *obstack, int data_char);
void obstack_ptr_grow (struct obstack *obstack, void *data);
void obstack_int_grow (struct obstack *obstack, int data);

void * obstack_finish (struct obstack *obstack);

int obstack_object_size (struct obstack *obstack);

int obstack_room (struct obstack *obstack);
void obstack_1grow_fast (struct obstack *obstack, int data_char);
void obstack_ptr_grow_fast (struct obstack *obstack, void *data);
void obstack_int_grow_fast (struct obstack *obstack, int data);
void obstack_blank_fast (struct obstack *obstack, int size);

void * obstack_base (struct obstack *obstack);
void * obstack_next_free (struct obstack *obstack);
int obstack_alignment_mask (struct obstack *obstack);
int obstack_chunk_size (struct obstack *obstack);

void _obstack_begin (struct obstack *h, int size, int alignment,
		     void * (*chunkfun)(size_t n), void (*freefun)());
void _obstack_newchunk (struct obstack *h, int length);
#endif /* __STDC__ */

/* Non-ANSI C cannot really support alternative functions for these macros,
   so we do not declare them.  */

/* Pointer to beginning of object being allocated or to be allocated next.
   Note that this might not be the final address of the object
   because a new chunk might be needed to hold the final size.  */

#define obstack_base(h) ((h)->object_base)

/* Size for allocating ordinary chunks.  */

#define obstack_chunk_size(h) ((h)->chunk_size)

/* Pointer to next byte not yet allocated in current chunk.  */

#define obstack_next_free(h)	((h)->next_free)

/* Mask specifying low bits that should be clear in address of an object.  */

#define obstack_alignment_mask(h) ((h)->alignment_mask)

#define obstack_init(h) \
  _obstack_begin ((h), 0, 0, obstack_chunk_alloc, obstack_chunk_free)

#define obstack_begin(h, size) \
  _obstack_begin ((h), (size), 0, obstack_chunk_alloc, obstack_chunk_free)

#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = achar)

#define obstack_blank_fast(h,n) ((h)->next_free += (n))

#if defined (__GNUC__) && defined (__STDC__)

/* For GNU C, if not -traditional,
   we can define these macros to compute all args only once
   without using a global variable.
   Also, we can avoid using the `temp' slot, to make faster code.  */

#define obstack_object_size(OBSTACK)					\
  ({ struct obstack *__o = (OBSTACK);					\
     (unsigned) (__o->next_free - __o->object_base); })

#define obstack_room(OBSTACK)						\
  ({ struct obstack *__o = (OBSTACK);					\
     (unsigned) (__o->chunk_limit - __o->next_free); })

#define obstack_grow(OBSTACK,where,length)				\
({ struct obstack *__o = (OBSTACK);					\
   int __len = (length);						\
   ((__o->next_free + __len > __o->chunk_limit)				\
    ? _obstack_newchunk (__o, __len) : 0);				\
   bcopy (where, __o->next_free, __len);				\
   __o->next_free += __len;						\
   (void) 0; })

#define obstack_grow0(OBSTACK,where,length)				\
({ struct obstack *__o = (OBSTACK);					\
   int __len = (length);						\
   ((__o->next_free + __len + 1 > __o->chunk_limit)			\
    ? _obstack_newchunk (__o, __len + 1) : 0),				\
   bcopy (where, __o->next_free, __len),				\
   __o->next_free += __len,						\
   *(__o->next_free)++ = 0;						\
   (void) 0; })

#define obstack_1grow(OBSTACK,datum)					\
(void)({ struct obstack *__o = (OBSTACK);				\
   (void)((__o->next_free + 1 > __o->chunk_limit)			\
    ? (void)(_obstack_newchunk (__o, 1)) : (void)0),			\
   (void)(*(__o->next_free)++ = (datum));				\
   (void) 0; })

/* These assume that the obstack alignment is good enough for pointers or ints,
   and that the data added so far to the current object
   shares that much alignment.  */
   
#define obstack_ptr_grow(OBSTACK,datum)					\
({ struct obstack *__o = (OBSTACK);					\
   ((__o->next_free + sizeof (void *) > __o->chunk_limit)		\
    ? _obstack_newchunk (__o, sizeof (void *)) : 0),			\
   *((void **)__o->next_free)++ = ((void *)datum);			\
   (void) 0; })

#define obstack_int_grow(OBSTACK,datum)					\
({ struct obstack *__o = (OBSTACK);					\
   ((__o->next_free + sizeof (int) > __o->chunk_limit)			\
    ? _obstack_newchunk (__o, sizeof (int)) : 0),			\
   *((int *)__o->next_free)++ = ((int)datum);				\
   (void) 0; })

#define obstack_ptr_grow_fast(h,aptr) (*((void **)(h)->next_free)++ = (void *)aptr)
#define obstack_int_grow_fast(h,aint) (*((int *)(h)->next_free)++ = (int)aint)

#define obstack_blank(OBSTACK,length)					\
({ struct obstack *__o = (OBSTACK);					\
   int __len = (length);						\
   ((__o->next_free + __len > __o->chunk_limit)				\
    ? _obstack_newchunk (__o, __len) : 0);				\
   __o->next_free += __len;						\
   (void) 0; })

#define obstack_alloc(OBSTACK,length)					\
({ struct obstack *__h = (OBSTACK);					\
   obstack_blank (__h, (length));					\
   obstack_finish (__h); })

#define obstack_copy(OBSTACK,where,length)				\
({ struct obstack *__h = (OBSTACK);					\
   obstack_grow (__h, (where), (length));				\
   obstack_finish (__h); })

#define obstack_copy0(OBSTACK,where,length)				\
({ struct obstack *__h = (OBSTACK);					\
   obstack_grow0 (__h, (where), (length));				\
   obstack_finish (__h); })

#define obstack_finish(OBSTACK)  					\
({ struct obstack *__o = (OBSTACK);					\
   void *value = (void *) __o->object_base;				\
   __o->next_free							\
     = __INT_TO_PTR ((__PTR_TO_INT (__o->next_free)+__o->alignment_mask)\
		     & ~ (__o->alignment_mask));			\
   ((__o->next_free - (char *)__o->chunk				\
     > __o->chunk_limit - (char *)__o->chunk)				\
    ? (void)(__o->next_free = __o->chunk_limit) : (void)0);		\
   __o->object_base = __o->next_free;					\
   value; })

#define obstack_free(OBSTACK, OBJ)					\
({ struct obstack *__o = (OBSTACK);					\
   void *__obj = (OBJ);							\
   if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \
     __o->next_free = __o->object_base = __obj;				\
   else (obstack_free) (__o, __obj); })

#else /* not __GNUC__ or not __STDC__ */

#define obstack_object_size(h) \
 (unsigned) ((h)->next_free - (h)->object_base)

#define obstack_room(h)		\
 (unsigned) ((h)->chunk_limit - (h)->next_free)

#define obstack_grow(h,where,length)					\
( (h)->temp = (length),							\
  (((h)->next_free + (h)->temp > (h)->chunk_limit)			\
   ? _obstack_newchunk ((h), (h)->temp) : (void)0),			\
  bcopy (where, (h)->next_free, (h)->temp),				\
  (h)->next_free += (h)->temp)

#define obstack_grow0(h,where,length)					\
( (h)->temp = (length),							\
  (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)			\
   ? _obstack_newchunk ((h), (h)->temp + 1) : 0),			\
  bcopy (where, (h)->next_free, (h)->temp),				\
  (h)->next_free += (h)->temp,						\
  *((h)->next_free)++ = 0)

#define obstack_1grow(h,datum)						\
( (((h)->next_free + 1 > (h)->chunk_limit)				\
   ? _obstack_newchunk ((h), 1) : (void)0),				\
  *((h)->next_free)++ = (datum))

#define obstack_ptr_grow(h,datum)					\
( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)		\
   ? _obstack_newchunk ((h), sizeof (char *)) : 0),			\
  *((char **)(h)->next_free)++ = ((char *)datum))

#define obstack_int_grow(h,datum)					\
( (((h)->next_free + sizeof (int) > (h)->chunk_limit)			\
   ? _obstack_newchunk ((h), sizeof (int)) : 0),			\
  *((int *)(h)->next_free)++ = ((int)datum))

#define obstack_ptr_grow_fast(h,aptr) (*((char **)(h)->next_free)++ = (char *)aptr)
#define obstack_int_grow_fast(h,aint) (*((int *)(h)->next_free)++ = (int)aint)

#define obstack_blank(h,length)						\
( (h)->temp = (length),							\
  (((h)->next_free + (h)->temp > (h)->chunk_limit)			\
   ? _obstack_newchunk ((h), (h)->temp) : (void)0),			\
  (h)->next_free += (h)->temp)

#define obstack_alloc(h,length)						\
 (obstack_blank ((h), (length)), obstack_finish ((h)))

#define obstack_copy(h,where,length)					\
 (obstack_grow ((h), (where), (length)), obstack_finish ((h)))

#define obstack_copy0(h,where,length)					\
 (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))

#define obstack_finish(h)  						\
( (h)->temp = __PTR_TO_INT ((h)->object_base),				\
  (h)->next_free							\
    = __INT_TO_PTR ((__PTR_TO_INT ((h)->next_free)+(h)->alignment_mask)	\
		    & ~ ((h)->alignment_mask)),				\
  (((h)->next_free - (char *)(h)->chunk					\
    > (h)->chunk_limit - (char *)(h)->chunk)				\
   ? ((h)->next_free = (h)->chunk_limit) : 0),				\
  (h)->object_base = (h)->next_free,					\
  __INT_TO_PTR ((h)->temp))

#ifdef __STDC__
#define obstack_free(h,obj)						\
( (h)->temp = (char *)(obj) - (char *) (h)->chunk,			\
  (((h)->temp >= 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
   ? (int) ((h)->next_free = (h)->object_base				\
	    = (h)->temp + (char *) (h)->chunk)				\
   : ((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0)))
#else
#define obstack_free(h,obj)						\
( (h)->temp = (char *)(obj) - (char *) (h)->chunk,			\
  (((h)->temp >= 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
   ? (int) ((h)->next_free = (h)->object_base				\
	    = (h)->temp + (char *) (h)->chunk)				\
   : (int) _obstack_free ((h), (h)->temp + (char *) (h)->chunk)))
#endif

#endif /* not __GNUC__ or not __STDC__ */

#endif /* not __OBSTACKS__ */

                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc/                                     0040755 0001750 0001750 00000000000 13101126720 021617  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc/.libs/                               0040755 0000000 0000000 00000000000 13101126720 022574  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc/Makefile                             0100644 0000000 0000000 00000105367 13101126656 023246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# as/ppc/Makefile.  Generated from Makefile.in by configure.

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.




am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/cctools
pkgincludedir = $(includedir)/cctools
pkglibdir = $(libdir)/cctools
pkglibexecdir = $(libexecdir)/cctools
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = x86_64-unknown-linux-gnu
host_triplet = x86_64-unknown-linux-gnu
target_triplet = x86_64-apple-darwin15
libexec_PROGRAMS = ppc-as$(EXEEXT)
subdir = as/ppc
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
am__installdirs = "$(DESTDIR)$(libexecdir)"
PROGRAMS = $(libexec_PROGRAMS)
am__dirstamp = $(am__leading_dot)dirstamp
am_ppc_as_OBJECTS = ../ppc_as-app.$(OBJEXT) ../ppc_as-as.$(OBJEXT) \
	../ppc_as-atof-generic.$(OBJEXT) ../ppc_as-atof-ieee.$(OBJEXT) \
	../ppc_as-expr.$(OBJEXT) ../ppc_as-fixes.$(OBJEXT) \
	../ppc_as-flonum-const.$(OBJEXT) \
	../ppc_as-flonum-copy.$(OBJEXT) \
	../ppc_as-flonum-mult.$(OBJEXT) ../ppc_as-frags.$(OBJEXT) \
	../ppc_as-hash.$(OBJEXT) ../ppc_as-hex-value.$(OBJEXT) \
	../ppc_as-input-file.$(OBJEXT) ../ppc_as-input-scrub.$(OBJEXT) \
	../ppc_as-layout.$(OBJEXT) ../ppc_as-messages.$(OBJEXT) \
	../ppc_as-obstack.$(OBJEXT) ../ppc_as-read.$(OBJEXT) \
	../ppc_as-sections.$(OBJEXT) ../ppc_as-symbols.$(OBJEXT) \
	../ppc_as-write_object.$(OBJEXT) ../ppc_as-xmalloc.$(OBJEXT) \
	../ppc_as-dwarf2dbg.$(OBJEXT) ../ppc_as-ppc.$(OBJEXT)
ppc_as_OBJECTS = $(am_ppc_as_OBJECTS)
ppc_as_DEPENDENCIES = $(top_builddir)/libstuff/libstuff.la
AM_V_lt = $(am__v_lt_$(V))
am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
am__v_lt_0 = --silent
am__v_lt_1 = 
ppc_as_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ppc_as_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_P = $(am__v_P_$(V))
am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_$(V))
am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_$(V))
am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
am__v_at_0 = @
am__v_at_1 = 
DEFAULT_INCLUDES = -I.
depcomp =
am__depfiles_maybe =
COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
	$(AM_CFLAGS) $(CFLAGS)
AM_V_CC = $(am__v_CC_$(V))
am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
am__v_CC_0 = @echo "  CC      " $@;
am__v_CC_1 = 
CCLD = $(CC)
LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_CCLD = $(am__v_CCLD_$(V))
am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
am__v_CCLD_0 = @echo "  CCLD    " $@;
am__v_CCLD_1 = 
SOURCES = $(ppc_as_SOURCES)
DIST_SOURCES = $(ppc_as_SOURCES)
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing aclocal-1.15
AMTAR = $${TAR-tar}
AM_DEFAULT_VERBOSITY = 1
AR = ar
ASLIBEXECDIR = ${libexecdir}/as
AUTOCONF = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoconf
AUTOHEADER = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoheader
AUTOMAKE = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing automake-1.15
AWK = mawk
CC = clang
CCAS = clang
CCASFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include
CFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include -DDISABLE_CLANG_AS
CPP = clang -E
CPPFLAGS = 
CXX = clang++
CXXABI_LIB = -lsupc++
CXXCPP = clang++ -E
CXXFLAGS = -O3 -std=c++0x -isystem /usr/local/include -isystem /usr/pkg/include  -fblocks
CYGPATH_W = echo
DEFS = -DPACKAGE_NAME=\"cctools\" -DPACKAGE_TARNAME=\"cctools\" -DPACKAGE_VERSION=\"877.5\" -DPACKAGE_STRING=\"cctools\ 877.5\" -DPACKAGE_BUGREPORT=\"t.poechtrager@gmail.com\" -DPACKAGE_URL=\"\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DLT_OBJDIR=\".libs/\" -DEMULATED_HOST_CPU_TYPE=16777223 -DEMULATED_HOST_CPU_SUBTYPE=3 -D__STDC_LIMIT_MACROS=1 -D__STDC_CONSTANT_MACROS=1 -DHAVE_EXECINFO_H=1
DLLTOOL = false
DL_LIB = -ldl
DSYMUTIL = 
DUMPBIN = 
ECHO_C = 
ECHO_N = -n
ECHO_T = 
EGREP = /bin/grep -E
ENDIAN_FLAG = -D__LITTLE_ENDIAN__=1
EXECINFO_LIB = 
EXEEXT = 
FGREP = /bin/grep -F
GREP = /bin/grep
HOST_AR = ar
HOST_RANLIB = ranlib
INSTALL = /usr/bin/install -c
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_PROGRAM = ${INSTALL}
INSTALL_SCRIPT = ${INSTALL}
INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
LD = /usr/bin/ld -m elf_x86_64
LDFLAGS =  -L/usr/local/lib -L/usr/pkg/lib 
LIBOBJS = 
LIBS = 
LIBTOOL = $(SHELL) $(top_builddir)/libtool
LIPO = 
LLVM_CONFIG = no
LLVM_INCLUDE_DIR = 
LLVM_LIB_DIR = 
LN_S = ln -s
LTLIBOBJS = 
LTO_DEF = 
LTO_LIB = 
LTO_RPATH = 
LT_SYS_LIBRARY_PATH = 
MAINT = #
MAKEINFO = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing makeinfo
MANIFEST_TOOL = :
MKDIR_P = /bin/mkdir -p
NM = /usr/bin/nm -B
NMEDIT = 
OBJC = clang
OBJCFLAGS = -O3
OBJCWARNINGS = -Wall -Wno-objc-root-class -Wno-deprecated-objc-isa-usage
OBJDUMP = objdump
OBJEXT = o
OTOOL = 
OTOOL64 = 
PACKAGE = cctools
PACKAGE_BUGREPORT = t.poechtrager@gmail.com
PACKAGE_NAME = cctools
PACKAGE_STRING = cctools 877.5
PACKAGE_TARNAME = cctools
PACKAGE_URL = 
PACKAGE_VERSION = 877.5
PATH_SEPARATOR = :
PROGRAM_PREFIX = ${target_alias}-
PTHREAD_FLAGS = -pthread
RANLIB = ranlib
SED = /bin/sed
SET_MAKE = 
SHELL = /bin/bash
STRIP = strip
UUID_LIB = 
VERSION = 877.5
WARNINGS =  -Wall -Wno-long-long -Wno-import -Wno-format -Wno-deprecated -Wno-unused-variable -Wno-unused-private-field -Wno-unused-function -Wno-invalid-offsetof -Wno-int-conversion -Wno-char-subscripts
XAR_LIB = 
abs_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc
abs_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc
abs_top_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
abs_top_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
ac_ct_AR = ar
ac_ct_CC = clang
ac_ct_CXX = 
ac_ct_DUMPBIN = 
ac_ct_OBJC = 
am__leading_dot = .
am__tar = tar --format=ustar -chf - "$$tardir"
am__untar = tar -xf -
bindir = ${exec_prefix}/bin
build = x86_64-unknown-linux-gnu
build_alias = 
build_cpu = x86_64
build_os = linux-gnu
build_vendor = unknown
builddir = .
datadir = ${datarootdir}
datarootdir = ${prefix}/share
docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
dvidir = ${docdir}
exec_prefix = ${prefix}
host = x86_64-unknown-linux-gnu
host_alias = 
host_cpu = x86_64
host_os = linux-gnu
host_vendor = unknown
htmldir = ${docdir}
includedir = ${prefix}/include
infodir = ${datarootdir}/info
install_sh = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/install-sh
libdir = ${exec_prefix}/lib
libexecdir = ${exec_prefix}/libexec
localedir = ${datarootdir}/locale
localstatedir = ${prefix}/var
mandir = ${datarootdir}/man
mkdir_p = $(MKDIR_P)
oldincludedir = /usr/include
pdfdir = ${docdir}
prefix = /osxcross/target
program_transform_name = s&^&x86_64-apple-darwin15-&
psdir = ${docdir}
sbindir = ${exec_prefix}/sbin
sharedstatedir = ${prefix}/com
srcdir = .
sysconfdir = ${prefix}/etc
target = x86_64-apple-darwin15
target_alias = x86_64-apple-darwin15
target_cpu = x86_64
target_os = darwin15
target_vendor = apple
top_build_prefix = ../../
top_builddir = ../..
top_srcdir = ../..
ppc_as_LDADD = \
        $(top_builddir)/libstuff/libstuff.la

ppc_as_CFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign -I$(top_srcdir)/libstuff -I$(top_srcdir)/as $(WARNINGS) $(LTO_DEF) -DNeXT_MOD -DASLIBEXECDIR="\"$(ASLIBEXECDIR)/\"" -D__DARWIN_UNIX03  -DPPC $(ENDIAN_FLAG)
ppc_as_SOURCES = ../app.c ../as.c ../atof-generic.c ../atof-ieee.c ../expr.c ../fixes.c ../flonum-const.c \
         ../flonum-copy.c ../flonum-mult.c ../frags.c ../hash.c ../hex-value.c ../input-file.c \
         ../input-scrub.c ../layout.c ../messages.c ../obstack.c ../read.c ../sections.c \
         ../symbols.c ../write_object.c ../xmalloc.c ../dwarf2dbg.c ../ppc.c

all: all-am

.SUFFIXES:
.SUFFIXES: .c .lo .o .obj
$(srcdir)/Makefile.in: # $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps as/ppc/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps as/ppc/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: # $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): # $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):
install-libexecPROGRAMS: $(libexec_PROGRAMS)
	@$(NORMAL_INSTALL)
	@list='$(libexec_PROGRAMS)'; test -n "$(libexecdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(libexecdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(libexecdir)" || exit 1; \
	fi; \
	for p in $$list; do echo "$$p $$p"; done | \
	sed 's/$(EXEEXT)$$//' | \
	while read p p1; do if test -f $$p \
	 || test -f $$p1 \
	  ; then echo "$$p"; echo "$$p"; else :; fi; \
	done | \
	sed -e 'p;s,.*/,,;n;h' \
	    -e 's|.*|.|' \
	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
	sed 'N;N;N;s,\n, ,g' | \
	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
	    else { print "f", $$3 "/" $$4, $$1; } } \
	  END { for (d in files) print "f", d, files[d] }' | \
	while read type dir files; do \
	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
	    test -z "$$files" || { \
	    echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(libexecdir)$$dir'"; \
	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(libexecdir)$$dir" || exit $$?; \
	    } \
	; done

uninstall-libexecPROGRAMS:
	@$(NORMAL_UNINSTALL)
	@list='$(libexec_PROGRAMS)'; test -n "$(libexecdir)" || list=; \
	files=`for p in $$list; do echo "$$p"; done | \
	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
	      -e 's/$$/$(EXEEXT)/' \
	`; \
	test -n "$$list" || exit 0; \
	echo " ( cd '$(DESTDIR)$(libexecdir)' && rm -f" $$files ")"; \
	cd "$(DESTDIR)$(libexecdir)" && rm -f $$files

clean-libexecPROGRAMS:
	@list='$(libexec_PROGRAMS)'; test -n "$$list" || exit 0; \
	echo " rm -f" $$list; \
	rm -f $$list || exit $$?; \
	test -n "$(EXEEXT)" || exit 0; \
	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
	echo " rm -f" $$list; \
	rm -f $$list
../$(am__dirstamp):
	@$(MKDIR_P) ..
	@: > ../$(am__dirstamp)
../ppc_as-app.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-as.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-atof-generic.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-atof-ieee.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-expr.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-fixes.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-flonum-const.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-flonum-copy.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-flonum-mult.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-frags.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-hash.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-hex-value.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-input-file.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-input-scrub.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-layout.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-messages.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-obstack.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-read.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-sections.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-symbols.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-write_object.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-xmalloc.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-dwarf2dbg.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-ppc.$(OBJEXT): ../$(am__dirstamp)

ppc-as$(EXEEXT): $(ppc_as_OBJECTS) $(ppc_as_DEPENDENCIES) $(EXTRA_ppc_as_DEPENDENCIES) 
	@rm -f ppc-as$(EXEEXT)
	$(AM_V_CCLD)$(ppc_as_LINK) $(ppc_as_OBJECTS) $(ppc_as_LDADD) $(LIBS)

mostlyclean-compile:
	-rm -f *.$(OBJEXT)
	-rm -f ../*.$(OBJEXT)

distclean-compile:
	-rm -f *.tab.c

.c.o:
	$(AM_V_CC)$(COMPILE) -c -o $@ $<

.c.obj:
	$(AM_V_CC)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`

.c.lo:
	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<

../ppc_as-app.o: ../app.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-app.o `test -f '../app.c' || echo '$(srcdir)/'`../app.c

../ppc_as-app.obj: ../app.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-app.obj `if test -f '../app.c'; then $(CYGPATH_W) '../app.c'; else $(CYGPATH_W) '$(srcdir)/../app.c'; fi`

../ppc_as-as.o: ../as.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-as.o `test -f '../as.c' || echo '$(srcdir)/'`../as.c

../ppc_as-as.obj: ../as.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-as.obj `if test -f '../as.c'; then $(CYGPATH_W) '../as.c'; else $(CYGPATH_W) '$(srcdir)/../as.c'; fi`

../ppc_as-atof-generic.o: ../atof-generic.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-atof-generic.o `test -f '../atof-generic.c' || echo '$(srcdir)/'`../atof-generic.c

../ppc_as-atof-generic.obj: ../atof-generic.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-atof-generic.obj `if test -f '../atof-generic.c'; then $(CYGPATH_W) '../atof-generic.c'; else $(CYGPATH_W) '$(srcdir)/../atof-generic.c'; fi`

../ppc_as-atof-ieee.o: ../atof-ieee.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-atof-ieee.o `test -f '../atof-ieee.c' || echo '$(srcdir)/'`../atof-ieee.c

../ppc_as-atof-ieee.obj: ../atof-ieee.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-atof-ieee.obj `if test -f '../atof-ieee.c'; then $(CYGPATH_W) '../atof-ieee.c'; else $(CYGPATH_W) '$(srcdir)/../atof-ieee.c'; fi`

../ppc_as-expr.o: ../expr.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-expr.o `test -f '../expr.c' || echo '$(srcdir)/'`../expr.c

../ppc_as-expr.obj: ../expr.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-expr.obj `if test -f '../expr.c'; then $(CYGPATH_W) '../expr.c'; else $(CYGPATH_W) '$(srcdir)/../expr.c'; fi`

../ppc_as-fixes.o: ../fixes.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-fixes.o `test -f '../fixes.c' || echo '$(srcdir)/'`../fixes.c

../ppc_as-fixes.obj: ../fixes.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-fixes.obj `if test -f '../fixes.c'; then $(CYGPATH_W) '../fixes.c'; else $(CYGPATH_W) '$(srcdir)/../fixes.c'; fi`

../ppc_as-flonum-const.o: ../flonum-const.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-const.o `test -f '../flonum-const.c' || echo '$(srcdir)/'`../flonum-const.c

../ppc_as-flonum-const.obj: ../flonum-const.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-const.obj `if test -f '../flonum-const.c'; then $(CYGPATH_W) '../flonum-const.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-const.c'; fi`

../ppc_as-flonum-copy.o: ../flonum-copy.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-copy.o `test -f '../flonum-copy.c' || echo '$(srcdir)/'`../flonum-copy.c

../ppc_as-flonum-copy.obj: ../flonum-copy.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-copy.obj `if test -f '../flonum-copy.c'; then $(CYGPATH_W) '../flonum-copy.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-copy.c'; fi`

../ppc_as-flonum-mult.o: ../flonum-mult.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-mult.o `test -f '../flonum-mult.c' || echo '$(srcdir)/'`../flonum-mult.c

../ppc_as-flonum-mult.obj: ../flonum-mult.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-mult.obj `if test -f '../flonum-mult.c'; then $(CYGPATH_W) '../flonum-mult.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-mult.c'; fi`

../ppc_as-frags.o: ../frags.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-frags.o `test -f '../frags.c' || echo '$(srcdir)/'`../frags.c

../ppc_as-frags.obj: ../frags.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-frags.obj `if test -f '../frags.c'; then $(CYGPATH_W) '../frags.c'; else $(CYGPATH_W) '$(srcdir)/../frags.c'; fi`

../ppc_as-hash.o: ../hash.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-hash.o `test -f '../hash.c' || echo '$(srcdir)/'`../hash.c

../ppc_as-hash.obj: ../hash.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-hash.obj `if test -f '../hash.c'; then $(CYGPATH_W) '../hash.c'; else $(CYGPATH_W) '$(srcdir)/../hash.c'; fi`

../ppc_as-hex-value.o: ../hex-value.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-hex-value.o `test -f '../hex-value.c' || echo '$(srcdir)/'`../hex-value.c

../ppc_as-hex-value.obj: ../hex-value.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-hex-value.obj `if test -f '../hex-value.c'; then $(CYGPATH_W) '../hex-value.c'; else $(CYGPATH_W) '$(srcdir)/../hex-value.c'; fi`

../ppc_as-input-file.o: ../input-file.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-input-file.o `test -f '../input-file.c' || echo '$(srcdir)/'`../input-file.c

../ppc_as-input-file.obj: ../input-file.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-input-file.obj `if test -f '../input-file.c'; then $(CYGPATH_W) '../input-file.c'; else $(CYGPATH_W) '$(srcdir)/../input-file.c'; fi`

../ppc_as-input-scrub.o: ../input-scrub.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-input-scrub.o `test -f '../input-scrub.c' || echo '$(srcdir)/'`../input-scrub.c

../ppc_as-input-scrub.obj: ../input-scrub.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-input-scrub.obj `if test -f '../input-scrub.c'; then $(CYGPATH_W) '../input-scrub.c'; else $(CYGPATH_W) '$(srcdir)/../input-scrub.c'; fi`

../ppc_as-layout.o: ../layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-layout.o `test -f '../layout.c' || echo '$(srcdir)/'`../layout.c

../ppc_as-layout.obj: ../layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-layout.obj `if test -f '../layout.c'; then $(CYGPATH_W) '../layout.c'; else $(CYGPATH_W) '$(srcdir)/../layout.c'; fi`

../ppc_as-messages.o: ../messages.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-messages.o `test -f '../messages.c' || echo '$(srcdir)/'`../messages.c

../ppc_as-messages.obj: ../messages.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-messages.obj `if test -f '../messages.c'; then $(CYGPATH_W) '../messages.c'; else $(CYGPATH_W) '$(srcdir)/../messages.c'; fi`

../ppc_as-obstack.o: ../obstack.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-obstack.o `test -f '../obstack.c' || echo '$(srcdir)/'`../obstack.c

../ppc_as-obstack.obj: ../obstack.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-obstack.obj `if test -f '../obstack.c'; then $(CYGPATH_W) '../obstack.c'; else $(CYGPATH_W) '$(srcdir)/../obstack.c'; fi`

../ppc_as-read.o: ../read.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-read.o `test -f '../read.c' || echo '$(srcdir)/'`../read.c

../ppc_as-read.obj: ../read.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-read.obj `if test -f '../read.c'; then $(CYGPATH_W) '../read.c'; else $(CYGPATH_W) '$(srcdir)/../read.c'; fi`

../ppc_as-sections.o: ../sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-sections.o `test -f '../sections.c' || echo '$(srcdir)/'`../sections.c

../ppc_as-sections.obj: ../sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-sections.obj `if test -f '../sections.c'; then $(CYGPATH_W) '../sections.c'; else $(CYGPATH_W) '$(srcdir)/../sections.c'; fi`

../ppc_as-symbols.o: ../symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-symbols.o `test -f '../symbols.c' || echo '$(srcdir)/'`../symbols.c

../ppc_as-symbols.obj: ../symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-symbols.obj `if test -f '../symbols.c'; then $(CYGPATH_W) '../symbols.c'; else $(CYGPATH_W) '$(srcdir)/../symbols.c'; fi`

../ppc_as-write_object.o: ../write_object.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-write_object.o `test -f '../write_object.c' || echo '$(srcdir)/'`../write_object.c

../ppc_as-write_object.obj: ../write_object.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-write_object.obj `if test -f '../write_object.c'; then $(CYGPATH_W) '../write_object.c'; else $(CYGPATH_W) '$(srcdir)/../write_object.c'; fi`

../ppc_as-xmalloc.o: ../xmalloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-xmalloc.o `test -f '../xmalloc.c' || echo '$(srcdir)/'`../xmalloc.c

../ppc_as-xmalloc.obj: ../xmalloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-xmalloc.obj `if test -f '../xmalloc.c'; then $(CYGPATH_W) '../xmalloc.c'; else $(CYGPATH_W) '$(srcdir)/../xmalloc.c'; fi`

../ppc_as-dwarf2dbg.o: ../dwarf2dbg.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-dwarf2dbg.o `test -f '../dwarf2dbg.c' || echo '$(srcdir)/'`../dwarf2dbg.c

../ppc_as-dwarf2dbg.obj: ../dwarf2dbg.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-dwarf2dbg.obj `if test -f '../dwarf2dbg.c'; then $(CYGPATH_W) '../dwarf2dbg.c'; else $(CYGPATH_W) '$(srcdir)/../dwarf2dbg.c'; fi`

../ppc_as-ppc.o: ../ppc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-ppc.o `test -f '../ppc.c' || echo '$(srcdir)/'`../ppc.c

../ppc_as-ppc.obj: ../ppc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-ppc.obj `if test -f '../ppc.c'; then $(CYGPATH_W) '../ppc.c'; else $(CYGPATH_W) '$(srcdir)/../ppc.c'; fi`

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-am
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-am

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-am

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(PROGRAMS)
installdirs:
	for dir in "$(DESTDIR)$(libexecdir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
	-rm -f ../$(am__dirstamp)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libexecPROGRAMS clean-libtool \
	mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-compile distclean-generic \
	distclean-tags

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am:

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am: install-libexecPROGRAMS
	@$(NORMAL_INSTALL)
	$(MAKE) $(AM_MAKEFLAGS) install-exec-hook
install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am: uninstall-libexecPROGRAMS

.MAKE: install-am install-exec-am install-strip

.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
	clean-libexecPROGRAMS clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-compile distclean-generic \
	distclean-libtool distclean-tags distdir dvi dvi-am html \
	html-am info info-am install install-am install-data \
	install-data-am install-dvi install-dvi-am install-exec \
	install-exec-am install-exec-hook install-html install-html-am \
	install-info install-info-am install-libexecPROGRAMS \
	install-man install-pdf install-pdf-am install-ps \
	install-ps-am install-strip installcheck installcheck-am \
	installdirs maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
	uninstall-am uninstall-libexecPROGRAMS

.PRECIOUS: Makefile

install-exec-hook:
	mkdir -p $(DESTDIR)$(libexecdir)/as/ppc
	mv $(DESTDIR)$(libexecdir)/*ppc-as* $(DESTDIR)$(libexecdir)/as/ppc/as

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc/Makefile.am                          0100644 0001750 0001750 00000001471 12612724204 023662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        libexec_PROGRAMS = ppc-as

ppc_as_LDADD =  \
        $(top_builddir)/libstuff/libstuff.la

ppc_as_CFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign -I$(top_srcdir)/libstuff -I$(top_srcdir)/as $(WARNINGS) $(LTO_DEF) -DNeXT_MOD -DASLIBEXECDIR="\"$(ASLIBEXECDIR)/\"" -D__DARWIN_UNIX03  -DPPC $(ENDIAN_FLAG)

ppc_as_SOURCES =  ../app.c ../as.c ../atof-generic.c ../atof-ieee.c ../expr.c ../fixes.c ../flonum-const.c \
         ../flonum-copy.c ../flonum-mult.c ../frags.c ../hash.c ../hex-value.c ../input-file.c \
         ../input-scrub.c ../layout.c ../messages.c ../obstack.c ../read.c ../sections.c \
         ../symbols.c ../write_object.c ../xmalloc.c ../dwarf2dbg.c ../ppc.c
install-exec-hook:
	mkdir -p $(DESTDIR)$(libexecdir)/as/ppc
	mv $(DESTDIR)$(libexecdir)/*ppc-as* $(DESTDIR)$(libexecdir)/as/ppc/as
                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc/Makefile.in                          0100644 0001750 0001750 00000102742 12612724226 023702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
libexec_PROGRAMS = ppc-as$(EXEEXT)
subdir = as/ppc
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
am__installdirs = "$(DESTDIR)$(libexecdir)"
PROGRAMS = $(libexec_PROGRAMS)
am__dirstamp = $(am__leading_dot)dirstamp
am_ppc_as_OBJECTS = ../ppc_as-app.$(OBJEXT) ../ppc_as-as.$(OBJEXT) \
	../ppc_as-atof-generic.$(OBJEXT) ../ppc_as-atof-ieee.$(OBJEXT) \
	../ppc_as-expr.$(OBJEXT) ../ppc_as-fixes.$(OBJEXT) \
	../ppc_as-flonum-const.$(OBJEXT) \
	../ppc_as-flonum-copy.$(OBJEXT) \
	../ppc_as-flonum-mult.$(OBJEXT) ../ppc_as-frags.$(OBJEXT) \
	../ppc_as-hash.$(OBJEXT) ../ppc_as-hex-value.$(OBJEXT) \
	../ppc_as-input-file.$(OBJEXT) ../ppc_as-input-scrub.$(OBJEXT) \
	../ppc_as-layout.$(OBJEXT) ../ppc_as-messages.$(OBJEXT) \
	../ppc_as-obstack.$(OBJEXT) ../ppc_as-read.$(OBJEXT) \
	../ppc_as-sections.$(OBJEXT) ../ppc_as-symbols.$(OBJEXT) \
	../ppc_as-write_object.$(OBJEXT) ../ppc_as-xmalloc.$(OBJEXT) \
	../ppc_as-dwarf2dbg.$(OBJEXT) ../ppc_as-ppc.$(OBJEXT)
ppc_as_OBJECTS = $(am_ppc_as_OBJECTS)
ppc_as_DEPENDENCIES = $(top_builddir)/libstuff/libstuff.la
AM_V_lt = $(am__v_lt_@AM_V@)
am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
am__v_lt_0 = --silent
am__v_lt_1 = 
ppc_as_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ppc_as_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
DEFAULT_INCLUDES = -I.@am__isrc@
depcomp =
am__depfiles_maybe =
COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
	$(AM_CFLAGS) $(CFLAGS)
AM_V_CC = $(am__v_CC_@AM_V@)
am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
am__v_CC_0 = @echo "  CC      " $@;
am__v_CC_1 = 
CCLD = $(CC)
LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_CCLD = $(am__v_CCLD_@AM_V@)
am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
am__v_CCLD_0 = @echo "  CCLD    " $@;
am__v_CCLD_1 = 
SOURCES = $(ppc_as_SOURCES)
DIST_SOURCES = $(ppc_as_SOURCES)
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = @ACLOCAL@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
ASLIBEXECDIR = @ASLIBEXECDIR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASFLAGS = @CCASFLAGS@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CXX = @CXX@
CXXABI_LIB = @CXXABI_LIB@
CXXCPP = @CXXCPP@
CXXFLAGS = @CXXFLAGS@
CYGPATH_W = @CYGPATH_W@
DEFS = @DEFS@
DLLTOOL = @DLLTOOL@
DL_LIB = @DL_LIB@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
ENDIAN_FLAG = @ENDIAN_FLAG@
EXECINFO_LIB = @EXECINFO_LIB@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
GREP = @GREP@
HOST_AR = @HOST_AR@
HOST_RANLIB = @HOST_RANLIB@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIPO = @LIPO@
LLVM_CONFIG = @LLVM_CONFIG@
LLVM_INCLUDE_DIR = @LLVM_INCLUDE_DIR@
LLVM_LIB_DIR = @LLVM_LIB_DIR@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
LTO_DEF = @LTO_DEF@
LTO_LIB = @LTO_LIB@
LTO_RPATH = @LTO_RPATH@
LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
OBJC = @OBJC@
OBJCFLAGS = @OBJCFLAGS@
OBJCWARNINGS = @OBJCWARNINGS@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
PROGRAM_PREFIX = @PROGRAM_PREFIX@
PTHREAD_FLAGS = @PTHREAD_FLAGS@
RANLIB = @RANLIB@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
STRIP = @STRIP@
UUID_LIB = @UUID_LIB@
VERSION = @VERSION@
WARNINGS = @WARNINGS@
XAR_LIB = @XAR_LIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_CXX = @ac_ct_CXX@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
ac_ct_OBJC = @ac_ct_OBJC@
am__leading_dot = @am__leading_dot@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
ppc_as_LDADD = \
        $(top_builddir)/libstuff/libstuff.la

ppc_as_CFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign -I$(top_srcdir)/libstuff -I$(top_srcdir)/as $(WARNINGS) $(LTO_DEF) -DNeXT_MOD -DASLIBEXECDIR="\"$(ASLIBEXECDIR)/\"" -D__DARWIN_UNIX03  -DPPC $(ENDIAN_FLAG)
ppc_as_SOURCES = ../app.c ../as.c ../atof-generic.c ../atof-ieee.c ../expr.c ../fixes.c ../flonum-const.c \
         ../flonum-copy.c ../flonum-mult.c ../frags.c ../hash.c ../hex-value.c ../input-file.c \
         ../input-scrub.c ../layout.c ../messages.c ../obstack.c ../read.c ../sections.c \
         ../symbols.c ../write_object.c ../xmalloc.c ../dwarf2dbg.c ../ppc.c

all: all-am

.SUFFIXES:
.SUFFIXES: .c .lo .o .obj
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps as/ppc/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps as/ppc/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):
install-libexecPROGRAMS: $(libexec_PROGRAMS)
	@$(NORMAL_INSTALL)
	@list='$(libexec_PROGRAMS)'; test -n "$(libexecdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(libexecdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(libexecdir)" || exit 1; \
	fi; \
	for p in $$list; do echo "$$p $$p"; done | \
	sed 's/$(EXEEXT)$$//' | \
	while read p p1; do if test -f $$p \
	 || test -f $$p1 \
	  ; then echo "$$p"; echo "$$p"; else :; fi; \
	done | \
	sed -e 'p;s,.*/,,;n;h' \
	    -e 's|.*|.|' \
	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
	sed 'N;N;N;s,\n, ,g' | \
	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
	    else { print "f", $$3 "/" $$4, $$1; } } \
	  END { for (d in files) print "f", d, files[d] }' | \
	while read type dir files; do \
	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
	    test -z "$$files" || { \
	    echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(libexecdir)$$dir'"; \
	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(libexecdir)$$dir" || exit $$?; \
	    } \
	; done

uninstall-libexecPROGRAMS:
	@$(NORMAL_UNINSTALL)
	@list='$(libexec_PROGRAMS)'; test -n "$(libexecdir)" || list=; \
	files=`for p in $$list; do echo "$$p"; done | \
	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
	      -e 's/$$/$(EXEEXT)/' \
	`; \
	test -n "$$list" || exit 0; \
	echo " ( cd '$(DESTDIR)$(libexecdir)' && rm -f" $$files ")"; \
	cd "$(DESTDIR)$(libexecdir)" && rm -f $$files

clean-libexecPROGRAMS:
	@list='$(libexec_PROGRAMS)'; test -n "$$list" || exit 0; \
	echo " rm -f" $$list; \
	rm -f $$list || exit $$?; \
	test -n "$(EXEEXT)" || exit 0; \
	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
	echo " rm -f" $$list; \
	rm -f $$list
../$(am__dirstamp):
	@$(MKDIR_P) ..
	@: > ../$(am__dirstamp)
../ppc_as-app.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-as.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-atof-generic.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-atof-ieee.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-expr.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-fixes.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-flonum-const.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-flonum-copy.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-flonum-mult.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-frags.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-hash.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-hex-value.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-input-file.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-input-scrub.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-layout.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-messages.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-obstack.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-read.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-sections.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-symbols.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-write_object.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-xmalloc.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-dwarf2dbg.$(OBJEXT): ../$(am__dirstamp)
../ppc_as-ppc.$(OBJEXT): ../$(am__dirstamp)

ppc-as$(EXEEXT): $(ppc_as_OBJECTS) $(ppc_as_DEPENDENCIES) $(EXTRA_ppc_as_DEPENDENCIES) 
	@rm -f ppc-as$(EXEEXT)
	$(AM_V_CCLD)$(ppc_as_LINK) $(ppc_as_OBJECTS) $(ppc_as_LDADD) $(LIBS)

mostlyclean-compile:
	-rm -f *.$(OBJEXT)
	-rm -f ../*.$(OBJEXT)

distclean-compile:
	-rm -f *.tab.c

.c.o:
	$(AM_V_CC)$(COMPILE) -c -o $@ $<

.c.obj:
	$(AM_V_CC)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`

.c.lo:
	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<

../ppc_as-app.o: ../app.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-app.o `test -f '../app.c' || echo '$(srcdir)/'`../app.c

../ppc_as-app.obj: ../app.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-app.obj `if test -f '../app.c'; then $(CYGPATH_W) '../app.c'; else $(CYGPATH_W) '$(srcdir)/../app.c'; fi`

../ppc_as-as.o: ../as.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-as.o `test -f '../as.c' || echo '$(srcdir)/'`../as.c

../ppc_as-as.obj: ../as.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-as.obj `if test -f '../as.c'; then $(CYGPATH_W) '../as.c'; else $(CYGPATH_W) '$(srcdir)/../as.c'; fi`

../ppc_as-atof-generic.o: ../atof-generic.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-atof-generic.o `test -f '../atof-generic.c' || echo '$(srcdir)/'`../atof-generic.c

../ppc_as-atof-generic.obj: ../atof-generic.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-atof-generic.obj `if test -f '../atof-generic.c'; then $(CYGPATH_W) '../atof-generic.c'; else $(CYGPATH_W) '$(srcdir)/../atof-generic.c'; fi`

../ppc_as-atof-ieee.o: ../atof-ieee.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-atof-ieee.o `test -f '../atof-ieee.c' || echo '$(srcdir)/'`../atof-ieee.c

../ppc_as-atof-ieee.obj: ../atof-ieee.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-atof-ieee.obj `if test -f '../atof-ieee.c'; then $(CYGPATH_W) '../atof-ieee.c'; else $(CYGPATH_W) '$(srcdir)/../atof-ieee.c'; fi`

../ppc_as-expr.o: ../expr.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-expr.o `test -f '../expr.c' || echo '$(srcdir)/'`../expr.c

../ppc_as-expr.obj: ../expr.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-expr.obj `if test -f '../expr.c'; then $(CYGPATH_W) '../expr.c'; else $(CYGPATH_W) '$(srcdir)/../expr.c'; fi`

../ppc_as-fixes.o: ../fixes.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-fixes.o `test -f '../fixes.c' || echo '$(srcdir)/'`../fixes.c

../ppc_as-fixes.obj: ../fixes.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-fixes.obj `if test -f '../fixes.c'; then $(CYGPATH_W) '../fixes.c'; else $(CYGPATH_W) '$(srcdir)/../fixes.c'; fi`

../ppc_as-flonum-const.o: ../flonum-const.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-const.o `test -f '../flonum-const.c' || echo '$(srcdir)/'`../flonum-const.c

../ppc_as-flonum-const.obj: ../flonum-const.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-const.obj `if test -f '../flonum-const.c'; then $(CYGPATH_W) '../flonum-const.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-const.c'; fi`

../ppc_as-flonum-copy.o: ../flonum-copy.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-copy.o `test -f '../flonum-copy.c' || echo '$(srcdir)/'`../flonum-copy.c

../ppc_as-flonum-copy.obj: ../flonum-copy.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-copy.obj `if test -f '../flonum-copy.c'; then $(CYGPATH_W) '../flonum-copy.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-copy.c'; fi`

../ppc_as-flonum-mult.o: ../flonum-mult.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-mult.o `test -f '../flonum-mult.c' || echo '$(srcdir)/'`../flonum-mult.c

../ppc_as-flonum-mult.obj: ../flonum-mult.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-flonum-mult.obj `if test -f '../flonum-mult.c'; then $(CYGPATH_W) '../flonum-mult.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-mult.c'; fi`

../ppc_as-frags.o: ../frags.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-frags.o `test -f '../frags.c' || echo '$(srcdir)/'`../frags.c

../ppc_as-frags.obj: ../frags.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-frags.obj `if test -f '../frags.c'; then $(CYGPATH_W) '../frags.c'; else $(CYGPATH_W) '$(srcdir)/../frags.c'; fi`

../ppc_as-hash.o: ../hash.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-hash.o `test -f '../hash.c' || echo '$(srcdir)/'`../hash.c

../ppc_as-hash.obj: ../hash.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-hash.obj `if test -f '../hash.c'; then $(CYGPATH_W) '../hash.c'; else $(CYGPATH_W) '$(srcdir)/../hash.c'; fi`

../ppc_as-hex-value.o: ../hex-value.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-hex-value.o `test -f '../hex-value.c' || echo '$(srcdir)/'`../hex-value.c

../ppc_as-hex-value.obj: ../hex-value.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-hex-value.obj `if test -f '../hex-value.c'; then $(CYGPATH_W) '../hex-value.c'; else $(CYGPATH_W) '$(srcdir)/../hex-value.c'; fi`

../ppc_as-input-file.o: ../input-file.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-input-file.o `test -f '../input-file.c' || echo '$(srcdir)/'`../input-file.c

../ppc_as-input-file.obj: ../input-file.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-input-file.obj `if test -f '../input-file.c'; then $(CYGPATH_W) '../input-file.c'; else $(CYGPATH_W) '$(srcdir)/../input-file.c'; fi`

../ppc_as-input-scrub.o: ../input-scrub.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-input-scrub.o `test -f '../input-scrub.c' || echo '$(srcdir)/'`../input-scrub.c

../ppc_as-input-scrub.obj: ../input-scrub.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-input-scrub.obj `if test -f '../input-scrub.c'; then $(CYGPATH_W) '../input-scrub.c'; else $(CYGPATH_W) '$(srcdir)/../input-scrub.c'; fi`

../ppc_as-layout.o: ../layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-layout.o `test -f '../layout.c' || echo '$(srcdir)/'`../layout.c

../ppc_as-layout.obj: ../layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-layout.obj `if test -f '../layout.c'; then $(CYGPATH_W) '../layout.c'; else $(CYGPATH_W) '$(srcdir)/../layout.c'; fi`

../ppc_as-messages.o: ../messages.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-messages.o `test -f '../messages.c' || echo '$(srcdir)/'`../messages.c

../ppc_as-messages.obj: ../messages.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-messages.obj `if test -f '../messages.c'; then $(CYGPATH_W) '../messages.c'; else $(CYGPATH_W) '$(srcdir)/../messages.c'; fi`

../ppc_as-obstack.o: ../obstack.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-obstack.o `test -f '../obstack.c' || echo '$(srcdir)/'`../obstack.c

../ppc_as-obstack.obj: ../obstack.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-obstack.obj `if test -f '../obstack.c'; then $(CYGPATH_W) '../obstack.c'; else $(CYGPATH_W) '$(srcdir)/../obstack.c'; fi`

../ppc_as-read.o: ../read.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-read.o `test -f '../read.c' || echo '$(srcdir)/'`../read.c

../ppc_as-read.obj: ../read.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-read.obj `if test -f '../read.c'; then $(CYGPATH_W) '../read.c'; else $(CYGPATH_W) '$(srcdir)/../read.c'; fi`

../ppc_as-sections.o: ../sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-sections.o `test -f '../sections.c' || echo '$(srcdir)/'`../sections.c

../ppc_as-sections.obj: ../sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-sections.obj `if test -f '../sections.c'; then $(CYGPATH_W) '../sections.c'; else $(CYGPATH_W) '$(srcdir)/../sections.c'; fi`

../ppc_as-symbols.o: ../symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-symbols.o `test -f '../symbols.c' || echo '$(srcdir)/'`../symbols.c

../ppc_as-symbols.obj: ../symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-symbols.obj `if test -f '../symbols.c'; then $(CYGPATH_W) '../symbols.c'; else $(CYGPATH_W) '$(srcdir)/../symbols.c'; fi`

../ppc_as-write_object.o: ../write_object.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-write_object.o `test -f '../write_object.c' || echo '$(srcdir)/'`../write_object.c

../ppc_as-write_object.obj: ../write_object.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-write_object.obj `if test -f '../write_object.c'; then $(CYGPATH_W) '../write_object.c'; else $(CYGPATH_W) '$(srcdir)/../write_object.c'; fi`

../ppc_as-xmalloc.o: ../xmalloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-xmalloc.o `test -f '../xmalloc.c' || echo '$(srcdir)/'`../xmalloc.c

../ppc_as-xmalloc.obj: ../xmalloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-xmalloc.obj `if test -f '../xmalloc.c'; then $(CYGPATH_W) '../xmalloc.c'; else $(CYGPATH_W) '$(srcdir)/../xmalloc.c'; fi`

../ppc_as-dwarf2dbg.o: ../dwarf2dbg.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-dwarf2dbg.o `test -f '../dwarf2dbg.c' || echo '$(srcdir)/'`../dwarf2dbg.c

../ppc_as-dwarf2dbg.obj: ../dwarf2dbg.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-dwarf2dbg.obj `if test -f '../dwarf2dbg.c'; then $(CYGPATH_W) '../dwarf2dbg.c'; else $(CYGPATH_W) '$(srcdir)/../dwarf2dbg.c'; fi`

../ppc_as-ppc.o: ../ppc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-ppc.o `test -f '../ppc.c' || echo '$(srcdir)/'`../ppc.c

../ppc_as-ppc.obj: ../ppc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc_as_CFLAGS) $(CFLAGS) -c -o ../ppc_as-ppc.obj `if test -f '../ppc.c'; then $(CYGPATH_W) '../ppc.c'; else $(CYGPATH_W) '$(srcdir)/../ppc.c'; fi`

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-am
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-am

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-am

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(PROGRAMS)
installdirs:
	for dir in "$(DESTDIR)$(libexecdir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
	-rm -f ../$(am__dirstamp)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libexecPROGRAMS clean-libtool \
	mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-compile distclean-generic \
	distclean-tags

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am:

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am: install-libexecPROGRAMS
	@$(NORMAL_INSTALL)
	$(MAKE) $(AM_MAKEFLAGS) install-exec-hook
install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am: uninstall-libexecPROGRAMS

.MAKE: install-am install-exec-am install-strip

.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
	clean-libexecPROGRAMS clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-compile distclean-generic \
	distclean-libtool distclean-tags distdir dvi dvi-am html \
	html-am info info-am install install-am install-data \
	install-data-am install-dvi install-dvi-am install-exec \
	install-exec-am install-exec-hook install-html install-html-am \
	install-info install-info-am install-libexecPROGRAMS \
	install-man install-pdf install-pdf-am install-ps \
	install-ps-am install-strip installcheck installcheck-am \
	installdirs maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
	uninstall-am uninstall-libexecPROGRAMS

.PRECIOUS: Makefile

install-exec-hook:
	mkdir -p $(DESTDIR)$(libexecdir)/as/ppc
	mv $(DESTDIR)$(libexecdir)/*ppc-as* $(DESTDIR)$(libexecdir)/as/ppc/as

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc/ppc-as                               0100755 0000000 0000000 00000771610 13101126720 022707  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF          >    @     @                @ 8  @          @       @ @     @ @                                      @      @                                          @       @     dr     dr                   hr     hrc     hrc     `      4                     v      vc      vc                                    @     @     D       D              Ptd   =     =C     =C     
      
             Qtd                                                  /lib64/ld-linux-x86-64.so.2          GNU                        GNU \BJ	%   @   9   "   &      +   )   >       %   ?       6          /   5   #   1       3   0   -       8          ,   *   =   4   7   ;      $      2                                          :                      <          
                                                                                  '      !   	                                 .   (                                     :          H  :   ;       `|&fUaN9                            p                                                                 f                                            W                      O                      .                                            j                     =                                                               7                                                                 >                      y                      V                                                                6                      C                                           !                     /                     '                                                                 r                                           ~                                                                 H                                                                                                                                                        ^                      P                                          )                                           (                                                                                                                                   6                                                                                                               `@     c      e     @             ]    @     _       l     ~c                 @     X            ~c             libc.so.6 strcpy exit sprintf _IO_putc fopen strncmp strrchr setbuffer signal strncpy unlink realloc abort stdin memchr mmap fgets calloc strlen ungetc memset strstr __errno_location fputc memcpy fclose strtoul malloc strcat __uflow __ctype_b_loc getenv stderr _obstack_newchunk readlink index strncat getcwd fwrite fread gettimeofday bcopy strchr obstack_free qsort __ctype_toupper_loc __ctype_tolower_loc __xpg_strerror_r __xstat memmove _obstack_begin access strcmp strerror __libc_start_main vfprintf __gmon_start__ GLIBC_2.14 GLIBC_2.3.4 GLIBC_2.2.5 GLIBC_2.3                                                                                    	     ti	        ui	         ii   ,      wc        %           wc        ?           ~c        ?           ~c        =           xc                   xc                   xc                    xc        ;           (xc                   0xc                   8xc                   @xc                   Hxc                   Pxc        	           Xxc        
           `xc                   hxc                   pxc                   xxc                   xc                   xc                   xc                   xc                   xc                   xc                   xc                   xc                   xc                   xc                   xc                   xc                   xc                   xc                   xc                   xc                    yc                   yc                    yc        !           yc        "            yc        #           (yc        $           0yc        %           8yc        &           @yc        '           Hyc        (           Pyc        )           Xyc        *           `yc        +           hyc        ,           pyc        -           xyc        .           yc        /           yc        0           yc        1           yc        2           yc        3           yc        4           yc        5           yc        6           yc        7           yc        8           yc        9           HHd# Hts  H              5d# %d# @ %d# h    %d# h   %d# h   %d# h   %d# h   %d# h   %d# h   %zd# h   p%rd# h   `%jd# h	   P%bd# h
   @%Zd# h   0%Rd# h    %Jd# h   %Bd# h    %:d# h   %2d# h   %*d# h   %"d# h   %d# h   %d# h   %
d# h   %d# h   %c# h   p%c# h   `%c# h   P%c# h   @%c# h   0%c# h    %c# h   %c# h    %c# h   %c# h    %c# h!   %c# h"   %c# h#   %c# h$   %c# h%   %c# h&   %zc# h'   p%rc# h(   `%jc# h)   P%bc# h*   @%Zc# h+   0%Rc# h,    %Jc# h-   %Bc# h.    %:c# h/   %2c# h0   %*c# h1   %"c# h2   %c# h3   %c# h4   %
c# h5   %c# h6   %b# h7   p%b# h8   `%b# h9   P1I^HHPTI@B HB H.@ 'fD  ~c UH-~c HHv    Ht]~c f     ]fffff.     ~c UH~c HHHH?HHt    Ht]~c  ]fD  =9g#  uUHn]&g# @ xrc H? u     HtUH]zf.     W)h# )g# )g# )g# )g# )g# )|g# )eg# )Ng# )7g# ) g# )	g# )f# )f# )f# )f# f# f# f# H$        HQB c Hc Hudf# h# uTf# zf# qf# ulf# B [B ffffff.     Hc HuB [B ffffff.     Hc Huff.     UAVSHf# 
wS$XB Hf# HHHf# D0x Y	  f# xf# ~f#    >	  f     H(HCH;C   HHHKD0A)  AA	t8   A?h  A95  A.   A z  ff.     HCH;CsHHHK Hcc uHAu  f   =e#  t%/   /0uq!HA;/tZuSuNH.Xe# '  e# uA      	e# 
   A/!  HCH;C   HHHK /   *t  HHCH;CsCHHHK t*u!HCH;Cs.HHHK8t*/u/
ud# HHB 1}      H_HHCH;CsHHHK 
tu(B 1z}  
   A  A=c#    B 1B}    H% HCH;CsHHHK 
uv  @   A@    HCH;C  HHHK c  H
sA@  ff.     HHHK Hcc   HCH;CrHAuO  HCH;Cd  HHHKD0c# K  A'A  b# b# A'     b#    HCH;C  HHHKD0A	%  Ar  B   HCH;C  HHHKD0rb#    xb#    8  H+HCH;CsGHHHKD0A
  A  A*uHCH;Cs$HHHK8t /uHRAHEa# a# A      A:  A:   =a#   a#       A  A\4  a#    A\   Z  A!oA
G  n   H8va# A\   ,  "Au{"   HHa#    .a# H+a# aB A@     A  A[   DA7   H      H     HHHKD0AtA
tHCH;CrHA`#     w  `# `# 
   HY2a# uciB 1y  A'   ;  A"1  f`# P`# A"     AFwAD  B 1Dy    B 1ny  A"     A
  `# 
   t_# 
   
   H_#     A  H-HAHAHAA"u\u_# _# e_#    A"   /  ^# u=G_#  y  p  HA/   >4A'u1_#   _# _# ^#    A'     Icc ^# t!tC   ^# 	   	      t"
t		   ^#       }   1tw     HCH;CsHHHK Hcc u   Hu{B 1w  A
     
u DH^#    A       u=t   ]#       u   H/"ffff.     HCH;CsHHHK 
t{H
r
tlBHk]#    ]# H]# B A.   IuJHHCH;CsHHHK 
t{B 1v  1]#     A
   D[A^]B HCH;CsaHHHK0c vB 1c\# \# \# H\# 1c D5\# A/   tHHu1QB 1u  fUAVS\# 
   $B HT[# HU[# H9  HPH4[# 0
  {  *uHH9  HHH[# H  /w  HPHZ# HHZ# HZ# H9Hu!  HZ# H-Z# H9G  A@   HQHZ#   
	t-  ?  9  .u        HH9  HFH<Z# H:H  c HHu{  =$[#    @/!  \  /'  H9  HQHY# q*tN/  HH9t"HAHY# A
   Hu(B 1t     Z# HH9t[HJHkY# *tt

HuH9t4HBHDY# Rt/t,H-Y# H$Y# H-%Y# B 1s  HY# HHHX# @ nHHX# _@/tGu@u;HFHX# @~Y# [  tZ# u    u  HFHX# @~HX# H-X# H9	  =sY#    B 1r    H]Y# HHHRY# x   GY# 1Y# 7Y#    f  HX# HX# H9J  HJHW# 2E  ~
@   Hcc G  H9v  HHH=W# 1HHu  HW# H;W# >  HAHjW# 	)Y# &  '  nX# XX# '     DX#    H%W# H;&W# t HHHW# 	5  U  B O  HV# H;V# tHHHV# W#    W#      HV# HV# HH9HtHJHV# 
u  @    W# W#       :  :   =dW#   TW#       H%t\   /W#    \   i  /W# W# HHHU# @
W# u>iB 1Rp  '   ,  !G
  HU#  nV# \     B 1p  "         /o"     "uoHAHaU# A"{V#    aV# H^V# aB @     HG"  HV# 2V# "   l  [NC[  VHHyH=T# Ht
tH9HtU#       CwAD  B 1o    
   U# A
   tU# HlT# xU#     D  "uZeU# oU# UU#    "     HpT# u=6U#      HBHT# @r/   5'u0U#   T#  U# T#    '      T# Hcc       HS# HS# fff.     H9   HJHtS# H2H   c HuHQ
   @
t~H9t!HHH5,S# 
tcHHuB >tpHS# HS# H)HtHQHR# 	
t#HHu{B 1Em  S#     S#     {B 1!m  
   [A^]tuS#    HR# @2S#    S# HS# B .   /   tHBH<R# @rH9tHAH&R# Yu1QB 1l  0c vB 1S# S# R# HR# 1c S# *fD  HQ# HR# GR# GHR# HGR# G((R# GR# G,R#     R#     HR#     W)R# R#     sR#     fffff.     HH&Q# G=R# GDR# HGH1R# G(PR# G)5R# G, R# f.     UAWAVAUATSH(IAI$HR#       BHt   p;@ -      Ht   p;@ 	      Ht   p;@       Ht   p;@ W)Q# )Q# )Q# )Q# )Q# )Q# )mQ# )VQ# Q# B eH   A   E   DL    H} ADLcHuL_ HH=Q# 1E~wI       ELfffff.     Hu WH} HHH HHcQ#  LH H=QQ# HHAu    HH=/Q#  I\$E~AH\$D|$$B H$(
  1HD$     H+Hl$E -	  B H>ttB H-tTB HtCB    Hf	  E-u} t5HHl$Dm E  e	  KI#    V	  P# J	  H B E	  H5GP# tB 1l  O#    H\$   H|$H-B s   APc   H#      H\$H{B <9  APc   HD$8    D$$   HL$H    D$$HD$HHHL$H@   H\$H{B   H{B   HD$ B N#   xp#    HD$ B   N#    HD$ B   tB   H5N# BB 1H$Hk  HHD$ B H$  .   )KhB    G# ttB 1Vk  HD$HH_N# qG#    V  3   )t"3upQ.uQ2uWAVM#   .   )A$G# ttB 1j  HD$HHM# F#      2   )t7B 1j    M#    F# ttB 1xj  HD$HHM# F#    x  F# ttB 1>j  HD$HHGM# YF#    >  NF# ttB 1j  HD$HHM# F#      F# ttB 1i  HD$HHL# E#      E# t	tB 1i  HD$HHL# E# 	     E# t
tB 1Vi  HD$HH_L# qE# 
   V  fE# ttB 1i  HD$HH%L# 7E#      p   )  2B H  7B $D# tdtB 1h  HD$HHK# D# d     c   )ffff.     HHl$AEAPc  t:AIt4Aat.Aft(Adt"AstAktH5K# B 1Dc  AAw  Hr@ APc AKBAI      HHE     H=K#    HD$H(       Au   Ar@  A`  AGE  $hB H\$H{B +(  HD$ B D$$HL$H    D$$HD$HHHL$HH3   )3y.y3qAv  H=H# B :C 1H=G# JB  zc 1Hl$}    XB HZtB 1f  Hl$}    H     Hl$}  Hmu  As  H\$H{B   HD$ B 2I#  P  H-kI# HD$8 t	HE(  D$$  HL$H    D$$HD$HHHL$H@HE  AG  $B H\$HkB HeB HPM  HD$ B D$$HL$H    D$$HD$HHHL$HXB HB H?B HB HB HB HB H B HoE#B HZj+B HEpKpvKcCefff.     H\$HH\$H|$Ht$$HT$T uH5tG# B 1Dd  HD$Ht)8 t$HHD$B 1c  HD$ B Hl$Hl$Dm EPH\$D|$$fD  H    H\$HH\$EAGD$$AF# uF# uB 1sc  =! ~ uiF#    
=^F#  tHXF# Ht
e?# B HxF# ;    g  
F# ui  kR B  EtD1Iff.     I<$Ht
BB  HuIAufHfj  Auu B B  HtHFj  1D  t=g# t/! L  H<$  A  R f# H([A\A]A^A_]fPB 1?a     D  UHAWAVAUATSH   HHH`HXL7A+t-u	EfIA+E1AH3  hAIt|NE  Aithn1  AF au6AF nu(HHA A    HHAIL7E1  E  AIt	i   AF n   AF f   +PtNHHAA    HHAIFAN iuCAN nu4AN iu%AN tuAN yuILHE1/  H8DE    M    u#1M   H8D1M1D  pHhAHXH   H`HupMMM6H BDpMMtPp0IV   ELDHhEeIEf1H8E1+  HXgH   M}Ee1E   ff.     XAH`(HuIHPsH HPDHtpX0p   OpEeLHEMIuE1IHhKE1HhgLE1I   MHhXMp A    HhXt(E1t!HcHcL 0u	HuAEtdHhAH`/HtVD`LLhDxHE1EtJ(B    DHt8HXHIu-d1H8   1HhH8xA+?DA+H E1fff.     HDHtAk
DdA]IuAD-AEHhH8D`D1M1L/A	  XHhHHHHH+HHHpA*Y  ^X ,A9DOWA*YXt ,AAAAAA\$CD$HcHBHII)L1LE   D`LcKL}L I9vfD`D    IADPt0t&      Iu~HHA    HHHADAE1  D`DI6ADpt4Lfffff.     k
f7HH9vt  IuHhD)XAD$HHAIcILM fHf9 uHSLmHIDEHEHEE    E+D<HpH!H       HH HBHII)LII)LI1L_E"B A0%B LHA1HpHfA E    LuLuILFHME+LxIDEHEtgI A   H]ffffff.     At5A   D;5} 8LILHxH&  HLL%  AAI EuE1H}HuHHH&  DCDHe[A\A]A^A_],f.     fUAVSHHH|$HE7# ,c WC7# HE7#     ~=#     Hk=#     A      ODteEtSF   two#c/F   $0B x   pt0rtst8ydteu'A      A      A   fuCHHH ,c Ht6# H|$<B [B zc t.u8ffB1CB 1T  CH>HDD   *ffC  fC  ffC  6# -ufHl$HH[A^]    UAWAVAUATSPAIL5# L5# 5# M9v;+fAIAIcH1L|1H[A\A]A^A_]PtNuAu3A  Au-A  u)AAtAFI  I  u;#    Lr;# MYM)IDi;# 1A   M@ Et)A~3AD-5;# E:DD   D  E1f     IcE:B D!   D)AD:# t8A   A)D-:# IrH5:# EzDDH#<B 	IE1fff.     HH94# A\AD))J   tH +L<>wEHA   A)Et[A   <$AD-%:# IL:# AD:#    HcB tIA9  fAfB  <$IL9# 9#    9#    A   A   P   )H1E  EA)S  D9# HAD#B   <$AD-b9# DIB,A E|1DD   )D9~4L   $fAfAF  A   I~fAF    jD)$fAL*9      AF    I~   H$   fAfAF  fAF  ffAF  B2# -fA1E  H)D)  \8# HcA#B   A   A  f   A1  fAF  1E$  A  AD-7# AD  w     H$I~|*AAHT1OH$HI|FD)2  D7# 1E     )Hc7# 9(  )t7# HHo7# #B   I  f-[fARIcA#B D)AD'7# t5A   A)D	7# MJL7# ArDH#4B 	MEE1	H	IvfAA   u[Au]fAF  1IE   A   AD6# AD    E1,$v  Dw6#   I  I  IcHA#B D)@AD?6# ,$+     )6# IRH6# ARHc#B 	   E1  1E  HD)  5# HcA#B X  E16  IcA#B    D)AD5#    A   A)Dy5# IrH5r5# AzDH#<B 	IzH5Q5# #B )AD?5#      ) 5# HnH-5# vH#4B 	  E1	I~fA.  E1t  E1z  E1   IvfAVA   IcIFEH9   IIIII@ 1uzA~AD4# AD[IcA#B    D)AD_4# t,DJ4# IjH-C4# AzDH#<B 	I	E1fD  fHEH9jEMK4N	EA~AD3# ADPIcA#B    D)AD3# t*   )3# IzH=3# AzH#<B 	HFL9r$   ftHHL9HHsAL1N%  fA@IcA#B    D)AD3#       )2# IrH52# ArH#4B 	aIcHA#B D)@AD2# tG   )2# IRH2# ARHc#B 	E1fHE1I~fAVE1I~fAFIcMFEL9   IIMIIHfD  1uzHc2# H~H2# H2#  SH51# .#,B    )AD1# t'1# HNH1# vHc#4B 	E1f+HEL9jEJ<G	EHcw1# H~i1# Hf1# QH5U1# #B    )AD>1# t)   )#1# HnH-1# vH#4B 	HGA|SHO  uAHAL9   Hf
HL9HHsf fffff.     SH0H\$PB 1HH\$H|$<B [B zc tB 1L  H0[f.     D  PuH uHZh     PZf.     AVSPI1LO   u<   I> u1IFHt$HpHcPzc H zc 1|B 1G  H[A^fUAWAVAUATSHHIL
  HP# L0F<B A   @A{9A;OA   A!   A&   &D<      A|uv|D|@   A<tA=u3A   =u_oA   s_HD<@B EuN:A>uA   >t8=u-A   +B   %B 1DK  IM  A	   Ml$D$  fffff.     HcB HO# Ht$ uB 1cF  WAD$A$HNO# H0D<B A   @{@;VA   !   &   &D<      f.     |uy|D|@   <t=u5=A       DDdA   sTHD<@B F>uA   >t3=  A   "E1B   %B 1I  f     A} u/I|$ B &B B 1D(E  WAD$A$l$8u0H|$0 B &B 1,B 1DD  WD$,)D$ t<   H\$0HL$ HD$(HD$ HL$(HtD$8           v)B   %B 1H     fff.     $B HD$(       ff.     A} tCt>L\  H|$ R  AD$L$8u%u!u1H|$0uAL$  ZB 	WA$  B 1C  AD$    ID$      HD$ HL$(H9u-D$8    W)D$ W)D$ HD$0    f.     Au Hv&B   %B 1G  ^fffff.     $B ID$    >I$I9L$u7AD$    WA$ WA$ID$    ffffff.     I$HD$ HtBQtNHtb@tMHqHP1/B 1B  I$    Efffff.     1Ht0I$@H   HtI$    	Pzc HL$(Il$HtJEtfHtyA   HuHQ1/B 1LB  ID$    1_ffffff.     1H    tDIL$AHPzc H+   Ht!ID$       Pzc f.     t{tvt9=)#  u&t!tt9tI$MP9  AE    A} upHD$0ID$ID$I;$uMAD$    :ID$    f     ZB 1TA  AD$    ID$    HD$0ID$WA$E  &  A\$HD$0ID$v;B   %B 1DE  Cw+$B ID$HD$0ID$$B ID$    B   %B 1D  rA	   GWA$HpHUB 1v@  AE     'HL$0H'  ID$HHID$HL$0H  ID$HHIT$L$0I|$L$0Id$ID$H;D$0   ID$H;D$0   ID$H;D$0   ID$H;D$0   ID$H;D$0qID$H;D$0bHD$0I!D$gHD$0I1D$XHD$0I	D$IHD$0HI	D$7I|$ t<H|$0 3I|$ u	H|$0 ID$B 1(?  I1ID$@ DB ;D$lAE HH[A\A]A^A_]f     AWAVATSPH{  &#    L3M   AF$   L{M   AG$   IN@Mg@L9tiH   M   1IN@I9toAL$8uAL$(AL$AD$!uoAD$AL$(   HcH Md$Mu(HtBHCIcNH4IcWH9x-)HHKIM;f@uAFA+GHCC    WCH[A\A^A_@ HF# "uQHBHF# HHHHF# tI
tA"Hu HeF# HAHZF# 	 fD  HBHEF# 
@|c HuHPH+F# @  Gff.     UAWAVAUATSHIL5E# A u
IL5E# InH-E# M>AHHBDxt]Ll$E1A
      A0u  InH-E# E~E1AAIcHD$A      jE  E1>  EA$tA.uE @|c A  A@|c uJA"tDA}  &O  A!  Y  AWQ  ABF  ^  A"L5D# MLDA"uSH-D# HLHH-D# tP
tH"Iu  HD# HhH-D# 'fff.     InH-uD# A@|c IuHEHZD# E L  H  HHPzc AUHHP  IE    IE H  AE   
  HE# D&## LG## AI@A)P\ B    1  HH8  IE    I] AE     w   AX   b  u F  fB    t$t$-t$E1H  InH-RC# E~A   cA~    111E1Azc L  IE IE    AE   H    AxE  InH-B# E~A      A     A'  A(  1Lu6I}  u/IEHt"HpHcPzc H zc |B 1t9  HmB# HHHbB#  )G    B 1J9  HCB# /     E#  Afuz+H  IE    IE AE   	  fuQ@u @  @t$}B    Hu[B t$E1H{     E   [B DE1   Hg  HH\$DXtH D<AIcLl$IEpc <B [B zc lt,uB 1;  AE     B 1j;  AE     E1E1   Hc@IEH@# A"uH@# @"IE      IFH@# IFIEM  A-u5Ltu7A-uHIE IEIE     AE   p  AE   L5p@# \  uA-  I]E  4 B 1DE7  1  L59@# A0   LA
   I@{c 1D9H}=1Hfffff.     IHHHFH?# L>A@{c D9H|EuHH)H9   f#   Pc H-?# L}A@{c D9}hPc vc H9Pc r fD  8Af8HH9vtH9sfYHHEHJ?# L} A@{c D9H|HTc H9   E   # # 	Hc   ATALHLl$     AULl$   f        HHI  HHu"111E1Azc H:  HH  Im AE   WAEW  Pc H)HH   ALLl$   H   HPH.>#       8L   HBH># L   HH=# H   b   1  Ht  HG  @=  IE IE    AE      Uu~HPH=#       (LuOHBH{=# Lu6HHh=# H>HH   H)HHK=# I]AE    $HH   H)HH%=# IMAE   HH=# AuHvB   %B 1?8  =$B IE    ,IEI;E u"AE    WAE WAE IE    H<#  u
HH<# AEH[A\A]A^A_]B 1Hu3  IE    AE    QIEA!uHIE5HIE)     UAWAVAUATSHAIl$`DT$XD\$PH># HpXL=># L9vWXc X   DMLl$ET$IDd$E8  EDd$LT$ELl$MAH=# L==# L5=# Hc5=# HD0XHH!Hp=# HH)LH)H9IOH5f=# H5W=# M.EfAV0INMFIcIF E^1EV2An3AfDI~8Iv@  H<# H@`IF(H<# Lp`LH[A\A]A^A_]ff.     UAWAVAUATSPEAIDD$@q1tu	HLcY!HEDMMMAEE1H<# HqXH<# H9vSXc X   D|$DDD$$AMIMN7  MLMDD$$AAD|$H<<# H=<# L5&<# Hc5;<# HL1XHH!H<# HH)HH)H9HOH5;# H5;# MEfAV0IFIF    M^ E~1EN2EF3AfDI~8Iv@k  H|;# H@`IF(Hm;# Lp`LH[A\A]A^A_] f.     fAWAVATSPIIAFAGI6I^H)HHxHI       I?IWH)IID)~6HcH4^H LH ^IGIGA^A_WIHIGJ}HcH|OA)Ic1HI?I6H LH HAFAGIFI+HIIGH[A\A^A_f     UAWAVAUATSG+t-.  N+t-  9+t-BLHOL)HLHFL)HvwH:LzI)ID4E)EADD!E!E   l$H|$HT$A1E11fHE11fD  A9%9!xCAEjDADAIHuA	uExAD$     ExIcHl$f|U AHD9ul$tE~(IcH|$fGHT$GB OHT$H|$A2AEEHT$H|$~HcHOf1fHH9sAIcHGHBj[A\A]A^A_] UAVSH=#  u&B 1$2  H# H# )9   H# @8    @(    @    1   L5# D9v	H# H# H# )9sHtC@ H# @8    @(    @    1m   Hn# H_# )9s9rIcH/# )9s&B 1[A^]O1  [A^]f.     G8    G(    G    f.     AWAVSH=#  u&B 11  H# H# H@))pLc# LLHH!H# H# HH)H# HH)H9~
H# HHw# L=7# MwHq@H9Hv2c @   2  H=R# D_# H<# H-# H># H@H=+# 5#     HH)HH)H9HOH=# H=# H!# D# WA0A AINH# IGH# H@    [A^A_fff.     SH# HcHH# [fUAWAVAUATSPDL$MAALL5e# HcI>HW# Hx# DhX8D`<Lx Hb# L$H(HL$@HH0%LH[A\A]A^A_] UAWAVAUATSPAIAlL=# HcI?H# H# X@8   Dh<H@     H# D`(H@0    w'   sHcLLH[A\A]A^A_]'B 1H[A\A]A^A_]-  ffffff.     HI# Hj# H@H)f.     H)# HJ# H@H)f.     AVSPP     HLs11NA A@ LD/  HS(LC0H~  L9v~  L/  HS(LC0H{ HcK<H
~  HH!HK(HSHH)LH)H9~LC(LHK H;1~  C  HH[A^SHH{11  H[(     UAWAVAUATSH(HT$IILH1HtvHtHH    tA$i  1   HrDHH)JT"f.     ri  12i  1HHui  11AvHT$ IHD$Lt$HE1ffff.     IE Ht^MIA9muMuLLHiuA< u2'B M   IE IHL$ HT$HIE L,2'B    H\$Hs(LC0HN L9vH{    -  Hs(LC0HK HcS<Ht HH!HS(HsHH)LH)H9~LC(LHS LaiHD$HAHT$ Ht$HHH1H([A\A]A^A_]UAWAVAUATSH(HT$ IILH1HtvHtHH    tA$i  1   HrDHH)JT"f.     ri  12i  1HHui  11AvHT$IHD$Lt$HE1ffff.     IE HtYMIA9muMuLLHuA< uMtIE IHL$HT$HIE L,HD$ IE   H\$Hs(LC0HN L9vH{    +  Hs(LC0HK HcS<Ht HH!HS(HsHH)LH)H9~LC(LHS LaiHD$ HAHT$Ht$HHH1H([A\A]A^A_]D  UAWAVAUATSH(HT$IILH1HtvHtHH    tAi  1   HrEHH)JT:ff.     ri  12i  1HHui  11At$HT$I$HD$HE1H    HL$    1HL$      MIA9mu$MuLLHuA< t    IE Hu5MtIE I$HL$HT$HIE L,IEHD$ HD$IEHD$ H([A\A]A^A_]fff.     UAWAVAUATSHIILI1MtkMtLH    tAi  1   Ir:LH)JT2ri  12i  1HHuAi  11AwHT$IH$HE1H    HL$t{1HL$fffff.     MIA9l$u#I\$HLL0uB<+ tD  I$Hu+MtI$IHL$H$HI$L$ID$HD$HD$H[A\A]A^A_]fD  UAWAVAUATSHII1MtvMtLH    tAi  1   IrELH)JT2ff.     ri  12i  1HHuAi  11wHT$HH$HE1H    HL$ty1HL$ffffff.     MIA9ou$I_HLLuB<+ t    IHu)MtII$HL$H$HIL<IGHD$HD$H[A\A]A^A_]f     UAWAVAUATSH(IILI1MtkMtLH    tAi  1   Ir:LH)JT2ri  12i  1HHuAi  11AwHT$IHD$HHD$E1H    HD$    1HD$ HD$ffffff.     MIA9l$u#I\$HLL`uB<+ tD  I$Hu@MHL$HT$tI$IHI$L$Ld$L;d$u&I$HID$HD$ HD$ H([A\A]A^A_]fff.     UAWAVSPHIAFt:E1     DIH,HtH}HuHm HuAFAA9rH[A^A_]fD   f.     fHe#     @ ffffff.        f.     H=8#  AVSHXH50# ; tC H~I9'B L5# L5# H# M           LH\H=# HGH;G   HHHO8H5# #   HFH;F   HHHN Nu^Hw# H$P   H?B Hu
[#     H<$
   MH56# Hu"J'B Hr  H5# 
u
   #   HX[A^CHw_fUAVSI   H# 1H   =#  t<H#    L    HH# Ht1u      L	   )xtHIL?H5P# k'B   H=7# tH5/# 'B m  H#     1[A^]f.     PC# D Hc  H4#  
#     H#     H#     X Kff.     AVSPH=x#  W; Hu9'B H# #     ; tZ/   H7HtHx tB)H I       IH       HH   H\# I HHL`#     HQ# HH[A^fffff.     AWAVSHIHc-# H   t0H=# HH5# H# # HHc=# HH=# Ht$H   L|$@ HHfff.     QH
uH=# HWH9   # t:)# 5x# T6LcHH)LHcD$H9,5V# Hc  HI# HIH=<# ># HcH|8LHUH"#     =#  ~('B 1E  H# )# #  H# H[A^A_     H=#  # #  HtH=t# x5# f     PH=O#  t3HI# HHD6# tP# DC# H=" X:# H=" tH# 'B 1AX'B 1Y}ffff.     SHH        H# Ht+H# HHEH=t# D# [fD  AWAVSIHIPc    cI    HPc A    HO# Ht]HK# HHEtQ# DD# AI/   HHtHKIH)Pc HH[A^A_[A^A_ffffff.     USHHHHH=" 'B 1HHKVH+H4$@   H=p" uH$(B 1(B 1H5G" 
       tHG # Hu #    HH[]H- # HHD # u8 # H=" u&'B 1 # D # H=" H" 'B 1dfAWAVAUATSI   tGA/t}H" HtqHILLH=   r(B 1HL1  ?M  APc Pc H4Pc LPc    h  H)" H   APc f.     LcLTILILH=   r(B 1LL  Vf.     #  HsPc Pc fPc / Pc LPc       HHhHi" Ac H   APc fff.     HILLH=   r"(B 1HL  Vfffff.     Y#  IuPc Pc AfPc / Pc LKPc    t#I] IHgE1>(B 1Le  L[A\A]A^A_     UAWAVAUATSHhHL5# L=" -V" L%/" L-0" H# HD$0HE" HD$(V" D$$`" D$ H]" HD$H" HD$&" D$D" D$" D$H|$8"     "    3N" D Hcl  H"  
"     H"     H"     }HH=M"  tH  H=" L5# L=" -C" L%" L-" HD$0H# HD$(H-" D$$?" D$ I" HD$HE" HD$H" D$" D$-" D$" H|$8Hh[A\A]A^A_]f.     AVSPL5# M  H=m" Ht) u#4" O@)GL5# Mo  Hc$" H	" HHHH!H" H" HH)H" HH)H9~
H" HH" Hp@H9Hv1c @   k  H=" H" " H" H" Hw@H5~" HcHt:@HcH!HH)HH)H9HOHT" HE" Hn" W@0@ @ HU" H@    Hc2" H" HHH!H" H" HH)H" HH)H9~
H" HH" H" INHAH" IFH=" MvH[A^UAWAVAUATSHHH# H  H=" Ht6 u0j" O@)G=H# 1H  ff.     HcM" H2" HHHH!H" H" HH)H-" HH)H9~
H-" HH" Hp@H9Hv1c @     H=" H" " H" H-" Hw@H5" HcHt:@HcH!HH)HH)H9HOH}" Hn" H" W@0@ @ H~" H@    Hc[" H@" HHH!H0" H" HH)H$" HH)H9~
H
" HH" H!" HKHAH" HCH=" H[HHV# 1f      H@Ht=@Su   u      H@       H@fffff.     T$8A0c E1IM6M   A9   uAFPttL5# M>1M   En\L1   D  $h(B CC(   K(S<!)t19Hk# 9JDsJD`HD% QH  EC(   :ffffff.     Hks8HkB   #)B 1  H[Hu1E1L10EA    A0c   1E11H[    HuE1    Lu2  HD$@HIcHHK(s81Hv-B 2  #)B 1  Ht$@    tAL[ $(B DKDC<D0!)D!)EtD9    GD9G)MtIC@ASHC+    HD)xDC<EMt@Is@LA{DH!I9Hr    1HtH@H9uDLHLbB )+KbB yh   H  ICPHtoH1Ht	HJ@	JHPHt	Hr@+J+HcHxH ALHLbB bB AIIbB ff.     th1;~A{Hs<SC  +s(C(ifD  ALHLbB bB AIIbB ff.     t1;}ArbB )DC<1MT$8t%f.     II9Ot	IO   MMuA=ffff.     H# H   1fffff.     CPtEt@KD   Hcz HK	t HHtHH!fD  H2HRHuH[HuH# H[Ht;CPtuKD   Hcez HHH!
H2HCHH# HtRHHHHt#P rQPHQ@QPH@H    H@8HuHl# fHH@	HH@8HuL=# MO  fffff.     L=# I@ H[H3  s8HvB   #)B 1$  f$(B C8    HC(+++ky(B 1	  1HcK1)C(tHcCHt@ALH|@HHcCH|@1LkH[XH  HTH[?Hc  H[.HK HAPHt"H1HtJHPHt+JHcHpqH3HcCH|@S<d@  CC8    WCH[f.     MMHl# f.     H$HIH  H$A\R# HY`HtH$@\D$$   L   )0   )   )uCHBLuH0uHu@L   )0   )   )tYC@" HC8H" IuHHU)B 1  IuHU]*B 1  p"     HM"     J  HD$(H     9  ffffff.     H3LkHc{C0HD$@HSLc DC11Mt)E}AAuAmA   ffff.     E1HD>@HD$8HCHD$(H  BM      AM   DD$H|$Ht$AEIJI)DrCD  LH?IILID    L|$0  fD  |   Ht$HrH|$/)B 1HT$0Eb  EH|$Ht$HT$0Fu9AMu*AE+BHT$0IWHD$( P  ff.     uBI)HC       l$DD$H|$Ht$C@" HC8Hf" IuIIV*B 1	  AEuIu+B 1  AFLHt$H|$DD$u&Hr+B 1HE  EH|$Ht$H"     H"     l$     Mtk;l$$uEt
{2    EtdAunHT$0AE   H|$IE  EH|$L   A  ff.     HT$0E1A  HT$0A  DD$H|$Ht$HT$0Au{IMPHHt$H|$DD$s  HHQ@HAJH)^  HT$0AEHL$@9HcI)IL+&HD$(H     As  AEt0A8  B \  #)B 1DO     HT$0CAEIA  C@" HC8He" IuIWL|$0R)B 1  AE  uHD$0pDs  t#LHT$0D  u#HD$(H     AHt$H|$DD$u|$$  AHT$00IELH0H@AEAIHD$(H     E1     Et$HD$@8HI)L+&MuHD$(H @~c E1HD$@uIL!tIFLH!H9u+HD$@u[I L!tOILH!H9t=C@" HC8H" @+B 1LHT$@  "     H"     H|$8LHT$@Hl$$A Dc4  tAEuH|$0 uHD$(H     H[(HD/HH[A\A]A^A_]LO1M  EAL  LBM  EAL  D" Ep  9h  H)# E1HA    t>ff.     9p\tH@HuE1 HPAA    t1  HG H@ Ht<HuH9uH9   HHHt	LtA   H@ HB HtF1	Lt1   *fD  HuH9uH9tiHHHuH@ HuA   tpAI0uAIuAA0   )   )u?A@0uA@uAH0   )   )   t1EfSH   Ht1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$HT$Ht$="  t	H   [=r#  t!m# uXB }+B 1zS# H$H$   H$   H$   $   0   $      H=" H$   H{H5~" 
   zi    UAVSH   IHt1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$="  tH   [A^]=q#  t!l# uXB }+B 1yR# H=" 'B 1HrzH$H$   H$   H$   $   0   $      H=" H$   Lzd@ UAWAVSH   IAHt1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ ="  tH   [A^A_]=o#  t!j# uXB }+B 1xP# H=" n+B 1Hryt0H=" 'B 1YyEtH=" 'B 1D>yH$H$   H$   H$   $   0   $       H=M" H$   LyH56" 
   txffffff.     SH   Ht1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$HT$Ht$=4#  t!/# uXB }+B 1Tw# #    NH$H$   H$   H$   $   0   $      H=M" H$   HxH56" 
   twH   [ff.     SH   Ht1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$HT$Ht$=4#  t!/# uXB }+B 1Tv# #    NH$H$   H$   H$   $   0   $      HM" r+B       xH=2" H$   HwH5" 
   Yv   wffffff.     Hy+B 1Hwf.     @ SHHc  HEBHK0LC8H;   ES,1HCHHHKHKHHHHK H@    [     UAWAVAUATSPIIMnInINH$II)DDL1dHcH9BE11AV0IFLhHcHIN HA~,  IMcIDl  MFIcHHH    HHH OtLV1I   M!   HH}HL8HH)L1I9wLH)HH9vXIM)HLI\OTHHfff.     C	AHHHuLLI9   Ottt+ttALHALHALHr>IHtzf     ).inininHHHILE9}KH$)D)D)IcttIV
THr IV
TIVT
THD9|HHINIcHDIFH[A\A]A^A_]ffff.     AWAVSIII~Ht+fff.     L9sHL9sH_1AV8HHuMtwqM~M~IF I~[A^A_@@}c @ AVSPGH # 03B E1     MtA> u H= # H3HIH{ H[u[B H5Y !    H=Q # HIHsHHtMtA> t     HAB  ,B 1ffff.     HHD@ HDHH(H(HH  uH      H3#f     H=" H!IHsHMHtuA> t
uA> tDB 1LFHz" c   1NA A@ ^Xc   1NA A@ H[A^;ff.     AVSPr" "  "  H" %EB 2B HYHHt9 tDB 1H     HHinclude HoII  I  CI  CI  CI  CI  CI  CH=q" 2B HHHt9 tDB 1HH=A" VB 2B HHt9 tDB 1H      end I  I  HI  HH=" 2B HHHt9 tDB 1HH[A^\H[A^@ UAWAVSPH<$-" D= " D5" =Z"  tS="  $  H" @\;"   H=6" D" L" AI@A)   1:     ="  u"yAB AB 1   E1x  @\n" ="     H=" Do" L" AA@A)>" d   1  t;B    11E1Azc   ;B    11E1Azc   ;B    11E1Azc z  =C" uH=B" 5" 5"   H<$H" HtKH$fffff.     H<$" u;  f       HHT" Hu9-q" uD9=p" uA9h" t;B 1nH5W" Ht;B 1V="  ua=D"  u"yAB AB 1   E1w  @\" ="  t-D" L" AA@A)"  B d   1L  H[A^A_]SH="  u$Cr% tH3t?B 1H{HsK DC v  K9HDsHD@\[fAWAVSIL5!" L95"" ;  @ " uAF
uL5" E>A@|c tjLt&IFfD  HH" D;HCA@|c u 1L  D;L5" A u
IL5" A:u
IL5w" A uIFHc" A^I@|c    @|c Lt*INfff.     HH&" HH@|c u  H=" L4H" H"  u
HH" Ht}HxPL5"    f.     @}c     ?B 1L5" A6@@}c     H<B 1L5q" Hr" b     @}c  u!HHHF" HH@}c  tH L  H!" L5" &fD  IL5" I9sA@}c  t@ IL5" L;5" [A^A_ UAWAVAUATSHHILt$L5" L95"   !  H-" H-" DLcMMd     IA
LHL%" L=" E1Ad   LL{dLL  ILHIdK\&d 19xtE HH9uE 
MtLhH" L= " L5" H-" 3" LuLgY" uH" L=" 
  HHE=B 1H`  f.     " MuAF
MuaL%Z" E<$Ml$I L-E" v   1?f.     H      L       sE|$Ml$L-"       A@|c u~"ty@}c  	  ="    AE @}c  uBH" I9s6ILffffff.     IL-" I9sAU IM@}c  tIL-u" Z	  I"L%c" MD@L-P" A$.uF@@	t  @=t&:t!   AM=   f.     =1"  t_Am H" @}c    H" H9  HHfD  HH" H9  0HP@}c  tx  H="    Am I LCH" HHH;" vc    DH" HHH" @(:tLs@}c  tH;&" 
  H"   H=" It$3H" @)@	t uH" ="  B  Ht<HH@ H9N  `@ H9@  @ H92  @ H9$  H" @}c  _  H" H9O  HHf     HHV" H9-  0HP@}c  t  H=p"  &  I    LCHp" HHH;m" vc    HM" HHHB" @(:tLs@}c  tH;"   H"   @  @	  .  H="    Ht@ H9H=  ILCH" HHH;" vc    4H" HHH" @(:tLs@}c  tH;"   H	"   EIchfHDZ)  A~IM DJ  IUfk
H" |1H
HHHRDKu  @ t5=t::u1Lz  H"  :Hw" \  HxQ  AM=uJ.uA|$   L  @tH H0" Q=   HH"    " u$H=" L*HL-" t	Am    Am H" @}c  u+Hff.     HH" HA@}c  tH  Lh  H" H" m  HtVHxP\  HQHg" =H]" 	t u
HHC" H+    Hx    A] AE  " 
  H=" L2H   A] H$    LHFH" :u
}w    L-" Etj[B DaHtX?B    L`z  "" uI?B LcIM  IGHZ" E1?B 1DDH9" 0@@}c    H<B 1gH" H" Y?B 1LHA] H" 0@@}c    H<B 1H" H"    HH" H9  @}c  tt  AE=uIL-" IEHr" AE =L-f" AE 	t u
IL-J" H|$ u?B 1zWD$,)D$ [  S     HD$ @H" ;A\1     HH" H9  @}c  t  L=" M)IcH  ILLH`Lt$f.     LHH" HHl$?B HaIMtLH)B,;HcL  IIcLHt$Hcp`MAtID$H" uIHD$ H B tHpHD$(H B tHPH>H5=B 1?B 1LD$ DL$0H$             15  H"  uHPHx" HH@}c  uFH<B 1HN" HO" 
HH;" H9s@}c  tf.     HH" L5" L;5" HH[A\A]A^A_] PH|$5  H(  H"  uHqH5" QH	w(Hfffff.     H" H
rHHu"  uHPHb" HH@}c  uKH<B 1H8" H9" ffffff.     HH" H9s@}c  tHH" =;"  t>H" @\;" u,H=i" D" L#" AI@A)   1Xdv  XfUAVSIH"  u
HH" " u
"u<u2'u*HHb" ]  HV" HQH9S" 1~1?B 1H-" 0@@}c    H<B 1[H" H"         HAH" @)  H" HAH9" xtXc    H" tXc    H" HAH"  Hm" Hc" Hg" HHH!HW" H5@" HH)H-K" HH)H9~
H-1" HH" ,D  HH" H9s@}c  tHH" 1A[A^]PH"  uHPH" HH@}c  u>H<B 1H" H" fHH" H9s@}c  tHH{" Xf     USPHf" @0 @HX"HE@Hw  H:" @)H0"  u
HH" H@,u0HAH" q uHAH" @q@

u uHAH" QH@}c  uEH<B 1H" H" f     HH" H9s@}c  tHHk" H[]@ H(H|$"tut$=B 1HD$    10H"  uHPH" HH@}c  u?H<B 13H" H"  HH" H9s@}c  tHH" H(fD  H(H|$btu	D$H(=B 1HD$    1H(@ UAWAVSH(HO" "uHAH-5" D} H*"  uHPH" HH,   HH" E  H|$AHt  @@ H@@zc EHD} H" @}c     H" H9   HHD  HH" H9sy0HP@}c  tgE  <B 1HD} HQ" 0@@}c  u9H<B 1H," H-" 
HH" H9s@}c  tHH" H([A^A_] PH" 0@@}c  uCH<B 1H" H" f.     HH" H9s@}c  tHH" Xf     Hy" @}c  uCHn" H9s7Hf.     @}c  HtH4" H9rHHH " ffffff.     USHHH|$tu\$=B 15HD$    1H" HHH" ,uH|$(t u@l$8 H" =B 1HD$8    1~uH$    1      1E1A@(HW"  uHPHD" HH@}c     H<B 1mH" H" W-<B 1QH" 0@@}c  ubH<B 1,H" H" 3fff.     HH" H9s)@}c  tHH" H9s@}c  tHH~" HH[]    Hi" @}c  u<H^" H9s0HHff.     HH6" H9s0HP@}c  tHH" fD  USH(HkH|$vB    =B 1*\  $+B @kC D$CHC@zc HCP    +  @kHD$HKHL$KH@@HC@  HD$H   HL$H   HP@H;Q@urx tly tf@+AHD$   HD$HCH   <B 1o<B H|$ <B <B 1O@kC C    HC@zc j      D$L$!HxP t'      HL$HIPIH HCP<B 1@kC D$CHC@zc H([]fUAWAVAUATSHHIW)D$0)D$ E1IwJ    IIH0"  uHPH" HH@}c  tHHH " &  MILt$    HD$0H~uHHHHwdHtHH        t Nc    HrXHH)HNc     H:H	HrH	HHH9|H<B <B HO<B 11HJ  D  Lu!H|$     DH!     DHw^$+B H=H" G@)HL$ LD$(DL$0D$    D$    $    DL$<PDPD   @ B   =B 1   HD$(Hp@HHcPzc H zc |B 1DH=B 1HD$0    @ Ht$0HL!HL!tL9t8=B 1HYD  HHD  H" HHH" ,H"  uH" H@}c  uIH<B 1H" H" ffff.     HHv" H9s@}c  tHH[" HH[A\A]A^A_]fff.     AWAVAUATSH IH)"  uHKH" CH@}c    L$$L|$     uHKH" CH0u Lk5QH BDhtHH" DLLq  HHt9 uK|$HcT$HLOHt"  u
HHb" HXHW"  ,[nZ=B 1HH3" 3@@}c  u>H<B 1eH" H" D  HH" H9s@}c  tHH" HCH" K uH" H@}c  uJH<B 1H" H" fffff.     HHv" H9s@}c  tHH[" H [A\A]A^A_ffff.     SH8"  uHPH%" HH@}c  tHH	"   H{  ff.      uHPH" HH"   HH" ffffff.     HHH"   xxH" H" )w!H=" 1H" H" HPH9vc    8Hq" ffffff.     s=B 1tgfHQ" HB" )w!H=Z" 1&H" H " HPH9vc    H" HHH"   H"  u
HH" HAH" 	,  fD   uHPHm" HH"   HHQ" ffffff.     HHHe" .  xtHY" HJ" )w!H=b" 1.H'" H(" HPH9vc    H" ffffff.     s=B 1H"  u
HH" HAH" 	,HHHy" P uHi" H@}c  uCH<B 1H@" HA"     HH&" H9s@}c  tHH" [f     AWAVSL5" IFH" E>A\t*A'uRA"   A'   DX  IFH" E~A!AA
#  A
   D*  A"   "   "     A[fAG
   1K1fA74IcH0V   ftALITH" E|H|IDHH" AHAaA\t<rAeAbufA   DpAm"AfuOA   DYA"tA'u8DHAntAruA   D1A
   D&AtuA	   DG?B 1A?   D[A^A_    USPHu1?B 1}WCbu]H B HtHpHC B HtHPHtHt=B 13HHE=B 1HWC1H[]fD  AVSPI1Ht0A~fD  8 t	HA    1>B 1HH[A^fSH="  t6>B 1S  H="  u)HH+" f     HHHu" H" HAH" HZ" HPH9W" @|c ttc    H%" tc    H	" HHH"   H" H5" Hc" H" HHH!H" H" HH)H" HH)H9~
H" HH" H5x" Huk>B 1wH5`" .u'H=" H9HtH5=" >B 1AH" @}c  u=H" H9s1HHfff.     HH" H9s0HP@}c  tHH" [D  PH="     H" HHH;" vc    NH" HHH"   H=" H5{" H" Hc" H" HHH!Hv" L_" IM)Lj" LL)I9~
LP" LH>" Ht8 tH5" >B 1H"     X>B 1H" 0@@}c  u9H<B 1H" H" 
HHl" H9s@}c  tHHQ" Xffffff.     AVSPHf     IAFH" HHH;|" vc    H\" HHHQ" :tI~@}c  tL;5" vL5" H[A^D  1t*f.     @	tu ufD  t*HcAAHH@AHuAH   BHffffff.        D@0H@urHff.     Ht   @0H+fff.     A	A   D HHAt%AAH@AHuuD HH)     H(" |LAB    1" H" HH@" (c H" H c u"    =v"  tdH5" @}c     H&" H9   HHffffff.     HH" H9   0HP@}c  t   H|$~tuD$=B 1HD$    1" " H"  uHPHz" HH@}c  u<H<B 1HP" HQ" 
HH=" H9s@}c  tHH"" H(ffff.     H(6" rAB 1C"    " tHH@<(c     1u#" uH|$}}t|ulD$}"    H" @}c     H~" H9   HH    HHV" H9   0HP@}c  t   =B 1|HD$    1O" E" H"  uHPH" HH@}c  u<H<B 1 H" H" 
HH" H9s@}c  tHH" H(fD  P" r@B 1"    " tHH@<(c     1=u"  k" H,"  uHPH" HH@}c  uBH<B 1FH" H" fD  HH" H9s@}c  tHH" Xf     P="  t
" u@B 1" " HH@(c " H c H" HY"  uHPHF" HH@}c  u?H<B 1sH" H"  HH" H9s@}c  tHH" Xf     UAWAVAUATSHXIu" |&@B    1Y" Q" E1E1ffffff.     H" ( uHHHv" @hH@1@}c  t(J       HHH" @(H;" @(@ u
HH%" HHH" @(t@))2fD   A(t!A@}c  ugA ta1A,tYf     @@}c  tU@B 1H" HHH;" Oc    H" 4@ H" HHH;" vc    MH" HHH"   H" Hc" H" HHH!H" H5l" HH)Hw" HH)H9~
H]" HHK" JAA@}c  t	H" )A u#H" @ ,uHH"     II
@@}c  ufl@B 1H" 0@@}c  u9H<B 1H^" H_" 
HHK" H9s@}c  tHH0" H" HHH;" vc    Hf" HHH["  
A0fHHHE" IA8  Io$   HE H$uIL   fffff.     	wkIHHt@+@tH    H" HHH;" vc    =H" HHH" @(@+H@uHnuPHy" HHH;v" vc    HV" IHHHG" D0ffffff.     H)" HHH;&" c    H" H" HHH;" vc    jH" HHH"  
H" HHH;" vc    2H" HHH"   H-." D5" L=" Hq" HAH" HW" Hcl" HHH!HH" H1" HH)H<" HH)H9~
H"" HH" I" H{" ulH;" vH;" sH" H" c H	   H4Ht1H;5" vH;5" sH5" H5" D  c HCH-" AD5" L=" " HX[A\A]A^A_]fffff.     SHH|$!HH   H"  uHPH" HH@}c  uDH<B 1H" H"      HHf" H9s@}c  tHHK" HC="  tBH" @\;>" u0H=" DJ" Lk" AI@A)   1H[P  H[fPH"  uHPH" HH@}c  u>H<B 1H" H" fHH" H9s@}c  tHH{" Xf     1>  f        >  fD  USHXH|$su1?B 1xWD$)D$hucHD$ B HtHpHD$ B HtHPHtHt=B 1(HHE=B 1HWD$)D$1H" ,u9HH" H|$8^rtu@l$H=B 1HD$H    1t&uHD$@H" ;A\t?B 1LD$DL$ H$             1@(H"  uHPH" HH@}c  uAH<B 1%H" H" D  HH" H9s@}c  tHH" HX[]@ USPH" @0 @HX"HE{@H!Q  HZ" @)HP"  u
HH>" H@,u0HAH&" q uHAH" @q@

u uHAH" QH@}c  uEH<B 1H" H" f     HH" H9s@}c  tHH" H[]@ USP="  uOB 1H)" Hu&B 1H" @P   tPtHJPB 1uH" 0@@}c     H<B 1LH" H"    H" "uH"z@H5 " " F@)HP  H" @(H"  uHPH" HH@}c  uYH<B 1Hg" Hh" 'HHT" H9s)@}c  tHH7" H9s@}c  tHH" H[]D  H	" HfD  HH@}c  t  H5" OB 1*f.     UAWAVATSH@H" "uHxAH-" Du H"  uHPH" HH,utHHm" H<$4n   D|$E   SOB 1DH8" 0@@}c    H<B 1fH" H"   cKB 1GH" 0@@}c  <  H<B 1H" H" sE1tE1=B 1H" E1,   HH" H|$ MmuHDd$0A|SA   KB    1WNHHK" H9  @}c  t  t%E1=B 1mEyE1KB 1E  HL  Du Hux up   uOB 1H" 0@@}c    H<B 1H" H" 
HH" H9   @}c  t   HHf" H9   @}c  t   PtD9t8HpOB 1D}#DxH  AAA	fD`H"  uHPH" HH@}c  u<H<B 1H" H" 
HH" H9s@}c  tHH" H@[A\A^A_]f     UAWAVSH(Ho" "uHuAH-U" HI  Du HB"  uHPH/" HH,u,HH" H|$j   u~D|$   E  <B 1H2Du H" 0@@}c  u9H<B 1	H" H" 
HH" H9s@}c  tHH" 4=B 1HD$    E1E  HJ  Du fDxHN"  uHPH;" HH@}c  uDH<B 1hH" H"      HH" H9s@}c  tHH" H([A^A_]UAVSH0H|$itu\$ =B 1HD$     1H" HHH" ,u H|$Di   uyD$    HW" NB 1HD" 0@@}c    H<B 1rH" H" 
HH" H9  @}c  t  =B 12HD$     1H" HQH" ,u	|d   NB    1cH" NB 1H" 0@@}c  \  H<B 1H]" H^" .xD  sCH,P;B D12OB 4HH&" H9  @}c  t   1NB 1OB 1EH|$gtuLct$ =B 1HD$     E1tAH$    11E1ADHHc1H*   NHL  Hw"  uHPHd" HH@}c  u<H<B 1H:" H;" 
HH'" H9s@}c  tHH" H0[A^] UAWAVATSH@H" "uH-qAH-" D} H"  uHPH" HH,uwHH" H<$dfE1   Lt$E   _NB 1DHe" 0@@}c    H<B 1H<" H=" j  ENB 1tH" 0@@}c  T  H<B 1KH" H" ptE1=B 1'H" E1,   HH" H|$ }euHDd$0A|SA   KB    1NHH{" H9  @}c  t  t%E1=B 1EyE1KB 17E  HD  HD} Cu
{    KB 1XH"  uHPH" HH@}c  #  H<B 1H" H" 
HH" H9   @}c  t   HD" Hu^:BB }NB    1E11  H" @   a  H" HH" HWA0A AHHHH" H H8   DHc H" HHCCA\CHS@IcH" HH
D9`DD`DHH" H9s@}c  tHH" H@[A\A^A_]fffff.     UAVSH H" "uHmAH-g" Du H\"  uHPHI" HH,unHH1" H<$b   HH4 zc 2NB 1YH" 0@@}c  U  H<B 10H" H"   E  <B 1H
Du H" 0@@}c    H<B 1H" H" *E  LD$u6H0" P\   +HHS" H9   @}c  t      11Azc H>  Du H"  uHPH" HH@}c  uYH<B 11H" H" 'HH" H9s)@}c  tHH" H9s@}c  tHH" H [A^]fD  UAWAVAUATSH8Hk" HLuL5]" E t,tP
LuJB 1H3" 0@@}c    H<B 1aH
" H" 
  A uLuL5" IFH     fff.     H" D`LhHI,wLsL9tfE  H#H   JB    1HH{" 0@@}c    H<B 1HR" HS" c  JB 1H3" 0@@}c    H<B 1aH
" H"    HH" H9  @}c  t  AE  L"HrP0KB    1LH" 0@@}c  u  H<B 1H" H"    H\$ @:B E1A,        t  Hl$HG" HD$(fIIGH2" A/H,   @}c  tD$    HH" H9  @}c  t  HH" H9s@}c  tHH" E ,  HH" H9  @}c  tx  D$@,A @:B MB @ Ht$(v"tH{HHuc  H; Y  A/SHT$D$  1HL$H1" HD$(HHEH" M r	@}c  tH$E  LB A9B Ht$(!tIIHu  I?   H$E HL$AO+HT$j  HL$,  L=" IoH-~" EH@}c  tHD$(E Ht$01LF"HL$09   ?LB 1LH2" 0@@}c    H<B 1`H	" H
"   LB 1Ht$(<H" 0@@}c    H<B 1H" H" 
HH" H9}  @}c  tl     lLB 1Ht$ LHk" 0@@}c  4  H<B 1HB" HC" L  !LB 1Ht$(uH" 0@@}c    H<B 1LH" H"    E11Hl$H" ="  u-Bw%H3LB 1HHT$MMHT$HH|$ L(  E ,Ee H"  uHPHs" HH@}c  :  H<B 1HE" HF" 
HH2" H9  @}c  t   HH" H9   @}c  t   HH" H9   @}c  t   E1Hl$lLB 1Ht$ LH" 0@@}c  uuH<B 1H" H" )HL$(M   Hl$HL$I|HHQ" H9s)@}c  tHH4" H9s@}c  tHH" H8[A\A]A^A_]f.     UAWAVAUATSHHII   :BB JB    1E1'  IAEB I? u)@   V  IIGW@0@ @ AEB H" "uHcAH-s" Dm Hh"  uHPHU" HH,2  HH9" H|$XE1  HD$LcE  KB 1LLQH" 0@@}c    H<B 1(H" H"    H5" H    HHH]H" M H,wHsH#ffff.     HHHr" HH,    tJB 1HF" 0@@}c  ;  H<B 1tH" H" -  cKB 1UH" 0@@}c    H<B 1,H" H"     uHH" HHIID$H" E,$A,  AE  A
u  tE1=B 1H]" E1,   HHD" H|$(
WulDd$8A|zA   KB    1uHH" H9  @}c  t  HH" H9  @}c  t  E1t%E1=B 1EyE1KB 1E9gDsEgDE  HG6  HDm Cu
{    KB 1H]"  uHPHJ" HH@}c  =  H<B 1sH" H" 
HH	" H9	  @}c  t  IH8   DHc ICSSAW\SHK@IL1KHH" H9  @}c  t  A,E1L9tkE  HH<$PH   JB    1H4$HJ" 0@@}c  s  H<B 1xH!" H"" A  JB 1YH" 0@@}c     H<B 10H" H"    A$ HHrP0KB    1HH" 0@@}c     H<B 1Hv" Hw"    1E1H<$HD!  II? u#@   Q  IIGW@0@ @ E ,E,$AEB Eu*~HH" H9s@}c  tHH" HH[A\A]A^A_]HH" H9s@}c  tHH" E ,HH" H9s@}c  tHH" E ,E,$@ AWAVSH!" u JB 1H="  u,JB 1L5B" INfffff.     HH&" XHH@}c  tHH"   H=" wJB IMt@H|$Ht$HD$H_B HEL$zJB 1LMLH5P" JB 1F" H" H"  uHPHr" HH@}c  uKH<B 1HH" HI" ffffff.     HH&" H9s@}c  tHH" H[A^A_P"  H"  uHPH" HH@}c  uGH<B 1H" H" ff.     HH" H9s@}c  tHH{" Xf     UAVSH0Ha" "uH[AH-G" Du H<"  uHPH)" HH,   HH" E  .u
{    H0  H Du HH"  uHPH" HH@}c     H<B 1H" H" sE  <B 1HDu Hp" 0@@}c  uVH<B 1HK" HL" 
HH8" H9s)@}c  tHH" H9s@}c  tHH " H0[A^]H|$Ou?B 1'WD$)D$otkuHD$@Hw" ;A\tQCu>HD$ B HtHpHD$ B HtHPHtSHtN=B 1?B 1LD$DL$ H$             1k  Du %HHE=B 1H_3f.     AWAVSH0ILt$ffffff.     LND$(tuJIB 1$fff.     H|$  $  IB 1HD$     1ff.        H\$ 1Et(     @	tu ujEtHH H'Iff.        DH@u   fff.     HH@@Hut0Ht
   	   H@u   f{fff.     HD$x11>0  H    J  D$L$ H HCPHC@zc H$          1E1DIiH"       H
" HPH" ,H"  uH" 
H@}c  uGH<B 1H" H" ff.     HH" H9s@}c  tHH{" H0[A^A_UAVSH0I B Isz  H|$1H3  L$  8      1t~)~t1tA1t71t-1t#1t1t1t          r)ffffff.      u9tgOT1tt,t%tttt	trffffff.     HD$    1>B 1^H"  uHPH" HH,u7HH" 111E1E1Hx'  HIstInuHC@zc LIB ~  Idu#HC    z" Hz" Q@)CHK@B j  =B 1DH|$)Jtu@l$ =B 1HD$     1H+" HHH "  ,u@kH|$ItuD$ <IB S=B 18HD$     1H" HQH" 	,uCH|$It,uD$ ,gIB 1H" q=B 1HD$     1fCInt
Is   H_" ,u+HHM" Int
Is~   H%@kz   IB 1pH" 0@@}c     H<B 1GH" H"     HH" H9   @}c  tuH" @\CH"  uHPH" HH@}c  u<H<B 1Hn" Ho" 
HH[" H9s@}c  tHH@" H0[A^]    UAVSH%" "uHeRAH-" E  H'  H Du H"  uHPH" HH@}c  uFH<B 1
H" H" f.     HH" H9s@}c  tHH{" [A^]fD  UAVS=v"  uHB 1HP" "uHQAH-6" E  H&  @u
x uHH Du H"  uHPH" HH@}c  uAH<B 1%H" H" D  HH" H9s@}c  tHH" [A^]fD  UAVS=u"  uyHB 1Hp" "uHPAH-V" E  H
&  @u
x uH@Du H/"  uHPH" HH@}c  uEH<B 1IH" H" f     HH" H9s@}c  tHH" [A^]fD  UAVSH" "uHOAH-" E  H?%  HDu Hp"  uHPH]" HH@}c  uFH<B 1H3" H4" f.     HH" H9s@}c  tHH" [A^]fD  UAVSH" "uH%OAH-" E  H$  HDu H"  uHPH" HH@}c  uFH<B 1Hs" Ht" f.     HHV" H9s@}c  tHH;" [A^]fD  UAVSH%" "uHeNAH-" E  H#  H Du H"  uHPH" HH@}c  uFH<B 1
H" H" f.     HH" H9s@}c  tHH{" [A^]fD  UAVSHe" "uHMAH-K" E  H"  HDu H0"  uHPH" HH@}c  uFH<B 1JH" H" f.     HH" H9s@}c  tHH" [A^]fD  PP"  H"  uHPH" HH@}c  uGH<B 1Hd" He" ff.     HHF" H9s@}c  tHH+" Xf     P" H"  uHPH" HH@}c  uGH<B 1+H" H" ff.     HH" H9s@}c  tHH" Xf     SHH|$HHtMHr"  uHPH_" HH@}c  uHH<B 1H5" H6" H[fD  HH" H9s@}c  tHH" THB HH" HtYH=k" `A QiH5r" =s" nH=" A -iH5N" =O" JH=;" H[YWHB 1HH[D  UAVSHH|$HHtMHO"  uHPH<" HH@}c  uEH<B 1iH" H" H[A^]HH" H9s@}c  tHH" GB HHH=l" Hu&2HB 1HH[A^]     H=A" HGH;G  HHHOH" HHH;" vc    MH" HHH" uL5" Hc" H" HHH!H" Hi" HH)Ht" HH)H9~
HZ" HHH" A> u    (fff.     H=q" HGH;GsHHHO(H" HHH;
" vc    H" HHH" @(@uH= " H" Hc" H" HHH!H" H5" HH)H" HH)H9~
H" HHs" L]HjGB 1LKVjH-" H|" H"  CHC@zc H=f" HGH;G   HHHOH" HHH;" vc    rH" HHH" uH=" H=" ?      HCH=" HGH;GsyHHHO CH=" HGH;GsaHHHO C	H=" HGH;GsIHHHO C
H=" HGH;Gs1HHHO H" H0" H-" H=*" H[A^]ED  PHh"  uHPHU" HH@}c  u>H<B 1H+" H," fHH" H9s@}c  tHH" ak"    Xffffff.     UAVSHH" HCH      H" hHPHH wHsH"  =j"     auKl   luKluCa   )))uD5E D  Ht	 )$H4$H  t7D5E HT$D9uH 5" D  t#zc" *VGB 8GB 1H.   tGB 1HH" @(H"  uHPH" HH@}c  u?H<B 1H|" H}"  HHf" H9s@}c  tHHK" H[A^]fH(=N" HK"     I"     C"     H"  u
HH" H    "   H|$.H" H   H"  uHPH" HH,   HH" H|$^9tuD$=B 1HD$    1" H["  uHPHH" HH,u@HH0" H|$8tuD$=B 1[HD$    1&" H"  uHPH" HH@}c  uIH<B 1H" H" ffff.     HH" H9s@}c  tHH{" H(fD  UAVSHH|$IMtMHO"  uHPH<" HH@}c  uEH<B 1iH" H" H[A^]HH" H9s@}c  tHH" LhHtC HHHu&GB 1LH[A^]f   T@(HCH;CsHHHK(HduHH[A^]-ffff.     PHH" 

tHHH     HH&" HHP
uHH"  uHPH" HH@}c  uEH<B 1)H" H" f     HH" H9s@}c  tHH" Xf     PH"  uHPHu" HH@}c  u>H<B 1HK" HL" fHH6" H9s@}c  tHH" Xf     AVSPIHHpH"    HLHpH~"    LH[A^fAVSPHIC$uDLHpH>"    LHH&"       HH[A^H[A^ffff.     UAWAVATSHpAAw   DrPB 1DoH|$4tuD$ =B 1JHD$     1t&1tQ1ttPB 1|   KB    1|y1KB 1|H" E1,       HHHn" @E1,    A    t<H|$04tu\$@A   =B 1|HD$@    A   1H" ,u9HH" H|$P3tuD|$`=B 1,HD$`    Eu*H" @Pt|	y~   `A   HcH|$D4  tHt$DDPEuH:" 9hDshDHc"  uHPHP" HH@}c  uIH<B 1}~H&" H'" ffff.     HH" H9s@}c  tHH" Hp[A\A^A_]f.     @ ffffff.     UAWAVAUATSHDD$L$AIHH=b"  uc      NA A@ 0c L=+" A    Eg\ALMHM   I(   HuI   LuAGPD9tPB 1zAuD$A9GXt QB 1yD$A	GPL9=" r  AV  DD$Au-B  E1Au
Dt$  ADt$A      H=a" Hta" O@)GLLca" Ha" LLHH!H~a" Lga" HL)Hra" HL)H9~
HXa" HHFa" E   T$tt
Aw\5" AP{  r  L=" tt
Aw\5" Hp@H9Hv2c @   ~H=`" H`" D`" L`" H`" Hw@H5`" IcH|>@HcH!HL)HL)H9HOH5`" H5y`" H`" W@0@ @ H`" H@    Hz`" H" HIHAHd`" H" HAL="      +-  IWAGpAG`AGPAG@AG0AG AGAI       MwI(   H   LLl$D$	AGPD$AGXA   r\QB    1{Eg\ttD%" L;      H]_" HQ@H-Z_" H9vc @   |H7_" H-8_" H!_" Hc56_" HL1@HH!H5_" H^" HH)HH)H9HOH5^" H5^" H	_" WB0B BH^" H@    H^" IH^" IGL=<" LH[A\A]A^A_]AtAtAG\" f.     OPDGXHG(Hw H`SHHCxHu{\H1  HCx[Ht"HHt    y uHIHu111fH" 1Ht19y\tHIHuHfff.     AWAVATSPIIHK" E1Ht;E1H{(   LuH{   LtH[HuILH[A\A^A_f     H"     HIHt9y\uQP   u1ffffff.     H"     HIHt9y\uQP   u1ffffff.     Hi" Ht4 ffffff.     9y\uqP!      tHIHu1ffff.     H"     HIHt9y\uQP   u1ffffff.     H~" 1	D  HIHt 9y\uQPttHAH90fD  H~" Ht;  ffffff.     9y\uqPs
   rHIHu11D  PH~"     H~"     IHM~" WX" lX" UX" >X" 'X" X" X" )~" )k~" H~"     Xfffff.     S	Hcc [H=]~" Ht{HcY~" H|$HHG(ff.     9   HH9r;9~" u.~" HcH(  H~" H=~" Hc5~" H'  H}" }" D@   '  H}" @   '  H}" }"    }" 
   
   H}" HcH}" Hc}"    }" [H)HHx}" [ff.     Sx}" LLL$D$ Lt:LAMcIigfffHH?H"k
AL
0HA	AAwHc D  H
HZHuD$ 	HcDc EL|" E1Mt6Hc|" H|)MIB(98tHL9rL)HH|" DAt<f.     IcHigfffHH?H"k
At00A1I	AwIff.     AHHIHHu c [UAWAVATSIAL4  InI^H E1DXt4Lf.     HAk
Dd7HZHHDXHuL   HQE1DPt0H    HAk
D|
HUHDPHHuHz" HQEHz" H9vXc E   uHz" Hz" L5z" Hcz" HLEHH!Hz" Hz" HH)HH)H9HOHz" Hwz" QB A|QB 1LDDtL[A\A^A_]     USH3z" LHD$$ Ht;H    HcHigfffHH?H"k
L0H	wHc f     HHJHu$ 	DHcH4c 6tnHcHigfffHH?H"k
t0@0H	w;Ly" Mt/Hc5y" H|"I<Ip(ffff.     9.t6HH9rHHHHHHu c    H[]L)HH5y" L AVSPIH=x"  u&B 11r=v"  t6u2H=v" Ht5v" v" QB 1oQB 1pH={x" LIHHt-C%  fCCp  RB 1LH[A^qHx" DU" LU" AI@A)P\   1L  HH=x" HsHEHHt9 tHs0RB 1HIqH{  tHsQB 12qHx" HC Hx" =T"  tH  =8M" P  HC L@  C$/  C;u"       !  IHCI_uHI9x" AFT" AFDCLK@S B    1   IFIF    H=x"     Hw" Lp   w" { uw" =  w{ t;CHHcPzc H zc KDCDKQB 1LH[A^oHS" HC@S" S" @)CKHGv" @\CcwL5Qw" L5w" H[A^f.     UAWAVAUATSHLL$DD$AAAIHH5v" HcH.H;v" vXc pH5u" LHH-u" Hu" Hc5u" HHHH!Hu" Hu" HH)H-u" HH)H9~
H-u" HHu" HP`H9Hv1Xc `   lpH=uu" Hfu" 5|u" HQu" H-bu" HW`HOu" HcHt:`HcH!HH)HH)H9HOH%u" Hu" HXDxDhfD`L$HHL$HH@H@     @(    H@8    W@HHu" HtHA8Ht" Ht" H[A\A]A^A_]I@11AKff.     SHH{  tHsQB 1mHt" HC Ht" [PHH=5t" H}EHt`ZfUAVSHH{L   C$   C;"r" uyH H       HH -  IHsLNkL:f3 A,DCLK@_Q" q" $   LOL[A^][A^]fffff.     SHH=Us" HsH9AHHt9 tHs0RB 1H[l[fD  AVSPIH=s" LZDHHtcM111E1Azc LHH=r" HsH@HHt9 tHs0RB 1HlHH[A^@ HH=r" HCfffff.     UAWAVAUATSPAIIHMr" H@pHt8HHy u.HQHt%f     Hy uy8 u	HQHuHHLHH52r" HcHH;,r" vXc mH5r" LHHq" L-q" Hcr" HHHH!H-q" Hq" HH)Hq" HH)H9~
Hq" HH-q" Hu(H9Hv1Xc (   lH5q" H-{q" q" Hfq" Hwq" H~(H=dq" HcHt2(HcH!HH)HH)H9HOH:q" H+q" Lm D}LuWEHp" Hxh t
H@pHh HhhHp" HhpHp" @PuH=p" L
BHt`HH[A\A]A^A_]ffffff.     HGff.     GD  HGXff.     GXf.     HGHt L=L"           HG@ff.     I@ B    1A So" ;LTM"  B    1A[D   B 111E1Azc w    SHCo" C:CHL" HC@[f.     UAWAVAUATSHH  H|$H3o" 1HA          E1f.     H	H8HP)P<AH@HuHn" H  CPuGHkhHm Ht7H} >HuH} 111E1Azc HY    H[HuHn" 1HK  D  CPwDHkhfffff.     Hm Ht'H} HuH} 0Hf.     H[HuL5n" 1M       AFPD%   t
A   HL$xInhE1fD  H]AHm Ht@H} 7HHuH} 111E1Azc HHLf.        AuANXAF<1D9    tIv(IVUB 1eHL$xANTDMvM2111c Hm"    H$   Ht
E1HL$x HL$x  m" DsAJ  @ Hffff.     Hs1HC          L   t=I"     tF   D  Nt(FuTB 1dffff.     UB 1dH[8H] Hc   fffff.     HuCttm"  DsAl" Wl" tH$   k/f.     C    -l" H$   kHlH$   HC8H8HHHk" ffff.     H[8Ht3CuCttuHs]UB 	Hs,UB 1cL#l" !l" =l" l" H  Hl" =	l" Hx  H	l" H-Rk" H   $       H$   1E1f     DuAtAt_Hk" _fH}HtZL$   DeEdL$   A   $      D$   *f.     DAH[k" H,E    fD  Hm8Hc$       H$   H=k" 5k"    NA H=k" 5j"    NA =j"  t<1Hj" H$   fff.     H4rQ;j" r|H$   =j"  t-1Hj"     H4rQ;aj" r|H$   $     L=i" E1M  f     AGc  =   <=   B=   `=      *   H    Hr   f=      =   uUM      AF    L   =   uwM       A~ t
AFIAI^L   =   u@   =   u4     HL;LsC    A Cy   fD  M    tiA~ t_IoE 1tMfLe(u/HL@ HHHDAIHHu A$LuA^LM8MI}[=" Di" E        tAkD8   L$   Et=C"  tD$phD$p1H$   	D$p    =C" t1W)$0  BHg" 1H   HT$PD$DE1ff.     QPt[tVHQfff.     HRHt'rPttr8Q8Dq<)ff.     Q8Dq<DA@AHIHu|$H\$@l$LHpf" fffff.     HIHtQPtuDq<Dq8M|$HD$@    l$LHT$PMD$DE1     Hf" 
fD  HIHt]AL    HQ`1     qLHR(HtHz     t   Hz uZ3   	wH<RB      He" 1HtBE1HD$0HLff.     yLHADYHH!HHIHHuHD$0L=A"  tVT$<Af" D$f" D$ f" D$$f" D$(e" D$,HL$xt9T$\L$8T$<AL$\D$D$,D$(D$$D$ D$D$\    D$    D$   DkAH$   DDHD$h   Hd  HD$`   HLO  H=f" HL!HT$H$(     )  tSB 1]  D$tH$(   QT$pQA   T$LQHT$PQT$HQD=x D9tH$(  D  H\$PA   EtxAkD8D9|$tH$(  A   A ($0  A$A4    Dq8D$DA<D$@A@AD   AH   DiLAP    AT   tH$(  HD  H(c" H   D9|$tuHH$(  DSXT@CK(S8[H\0T LADH[HuW@ H$(  DH<SXT@CK(S8[H\0T L   D  ADH[Hu  D9|$tH$(  D8   D8   $   L8l8HL$hL8HL$`L8tH$(  D  =>"     AT$tD9H$(  B    BD P   BD     L$BL L$ BL L$$BL L$(BL L$,BL WBD  BD 0    BD 4    L$\BL 8L$BL <BD @T$ptL$(  LD  D|$pHda" fH$   H@H   H$   L8MtH$   D`@ffffff.     DH$(  Iw@IcWIcGIcoA_(~EMl@A1ff.     AC<4H$(  LHFD9|A     AMMu?H- a" HD$   H$      D$       E   LuEE L}PMtsI@uHpNSB 1LYIG@uHpNSB 1LYIGIPq9tHqHP~SB 1LYIIGI+HMH$(  DUTHU HLuAHm8HA=`"  tQH1 AH`" JLAi)H$(  DY\=H	HL= JLAA;[`" rH=U`"  tR1f     AHN`" JLAi)H$(  Dy|H	HL JLAA;`" rT$p9T$tt$   H$(    L5^" fMvM)  L$   Mf`MtEnHfffff.     An8E1I|$   L$(  K/    IT$At$0tu6CD=          AD$3u'CD/      eD  uCD=    1NCD/      >ID$8H;" AD$@;" TB 1HxWHCL=!f     AD$1	CD/I$	)AL$C/AL$3%	CD/J^  u%zHHuBtI|$ ,  C\/%CD/B   	Cl/I|$ t:H$   At$3   @   
   $`RB      I|$    C4/   B$  L$          0   @AA A9t%TB 1H$   V$   HCl/   	D		   BC/CD/L$   =  @t(ID$8H:" AD$@:" 8TB 1UCl/ID$@$=8"        ED4    A   0   @C4/ 9t$   TB 1JU$   	D		   H$   BC,/CD/   ID$@vL$         L$            J)AL$    CD/   CD/J !%   	CD/AL$3   HG     H8  KD/    At$0tu CD=      uCD=      euHCD=    1S    H  sJ)AL$    	Cl=CD=      TB 1SCL=   !AT$1	CD=A\$3   	wk$RB AL$4CL/WAL$6CL/JAt$4xCt/:      	   CL/Ct/fffff.     AMd$(MDt$pD9t$ttH#|$0H$(  t$<Dp  =5"  L|$h   HWY" H      T$\D  pP@   t	   HphHx   uS Hn}@t}ffff.        DH$(  | Hv Hu&fD  H$(  H^[/Hv HuH@HSD9t$tt|$\H$(  Ht$xD  HD$`tH$(  D AH-X" H        H]Ht6Et0EL$(  H>HPLHH}&E|Hm8HuH-YX" ffffff.     Hm8HtAH]HtEuEL$(  HHPLH&H}E|=U"     H$      Hl$Ht$   tHA    1H4uSB 1HPH$(  HT$HL$PHcH9tSB 1PuSB 1yPHH  [A\A]A^A_]    P~|Hctt.tt@tHH@tHH@tHHr7     @tHHLHHTHLHH uXf.     P   tu7u"uB@7HH@7HH@7HHr5f.     @7HHOHHWHH OHuXfffff.     HHxHHpf.      SHHuUB 1NH[ffffff.     SHHuUB 1NH[f.     D  SHHt St=*" u9m/" u
9i/" u[[/" W/" =T" Hn2" HH[fD  UAWAVATSHI(   (II    M~CAF AFD%T" D=T" D9%U" uD9=U" uHU"    pc HU" HHHtD9cu$(   HH    DcHC    H] HCHffffff.     HH HtD9xt)~    cHHDxHHH@    HHHD%+U" D=(U" H)U" HHL1Lp[A\A^A_]ffff.     SHH=A)" u5HsH|$a/H|$15   C    C   -" C-" C-" H[UAWAVAUATSHAH-rT" AEuct_L%;T" ICD4Ht6H>T" H4D=CT" HLxu)B;/uI|K44K44HH  /   HHHHHDHCH9HDHL$E1H)   Dl$LaH$D=S" A   Ar>L-S" A   f.     Kl HHLuB|%  tIE9rE9ruD;5qS" r!Av 5eS" H=JS" HH:S" L<$L^DH$S" HHS" H<HL:HS" HBD8 AFR" Dl$IEDuYD=R"    ArGHR" H   ff.     D93uHsHtH|$   HHD9rD=R" D9r>] R" H=PR" HHH=R" LHHD)H1HEt<H\$HHxOHQ" HH
HQ" H<H[HQ" HHT$HHQ" HDtE9Q" sQ" -Q" D%Q" H[A\A]A^A_]f=*" f     SH bQ" u'*" D$*" )$=%" td8Q"  [=%"    HO" @\;=N"    Ht$H|$+H|$1$D$    D$   3*" D$$tPt$tH=N%" u95)" u9)" t/H)5)" )" =wO" H," iH4$H%)" H [SH H=}Q"     {;=1O"    @Q   =$" u?Ht$H|$*H|$1$D$    D$   S)" D$   #F)" D$+)" )$O"  D$D$%)" H4$HH [@ UAVSHHL"  uHHHL" H"u11`   eAH|$vH1Htktc=#" u	1UB ME~AD;5:O" }(IcH2O" HHH< t1SVB 1nFHDH19VB 1NFHH[A^]f{ff.     UAWAVSP4eHK"  u
HHK" e   Hc;N"    HN" HHH< tv'" '" HuK" + uHCHbK" @kHLIIBDxt,dy'" H2K" + uHCHK" @kHH0uVB 1H[A^A_]LE9VB 1H[A^A_]6EHIDA@  @VB HthVB Ht`VB HtXVB H   i   Ks   Ka   C   &" &" &" f.     H)J" @(HJ"  -HKHJ" CHHHI" @(Jcu&&" i   )uw%&" s   )a   )u5HI" @(cx=%" n`xL" H[A^A_]VB 1HCHgI" @(VB aVB Wfffff.     =r%" 5p%"  PbrWB 1iCX#dM" X`ffffff.     AWAVSIIF Ht	LxPMu#WB 1CIF LxPAuIHt	IOHuWB 1BIIOXH@@QHI@HH)H+I_A~(uA   Htt1vAAbGE1r   }vAA   H  w+HHkD=   wA"
=   wA15vE|E~<D[A^A_ S_<)[ AVSPHHC Ht	LpPMuWB 1AHC LpPA~uIHt	INHuBXB 1AIINp+qIvHcCHT@{(K<*   C<CC8    C    C(    H[A^    UAWAVATSHILcI=uH{IuP   ]hE1r'H{A      [uHH\1   u8Mu3H   1D,uHH|H fDH\gI  w2IkH=   wHDH=   wCH)H{1DtHEtD@lH\L9tBYB 1[A\A^A_]aA[A\A^A_]     UAWAVAUATSH  XB XB @@HtH@H=H"  u@tH" s+  x)
  H" 1XB XB 1   E1IHnH" HtBf     HHH    HIHrH1HHHuH HuH=*H"  uH"   @l$'LHIHH\$   aH=2$" O@)D$    D$    $       AHIv         H*N      H=#" O@)D$    D$    $       AILHv#" Hg#" )w!H=#" 21KHD#" HE#" HPH9vc    @H#" HHH#"  H#" H#" )w!H=#" 1H"" H"" HPH9vc    @H"" HHH""  H"" H"" )w!H="" h1Hz"" H{"" HPH9vc    @HT"" HHHI""  HG"" H8"" )w!H=P"" 1H"" H"" HPH9vc    ?H!" HHH!"  H!" H!" )w!H=!" 1H!" H!" HPH9vc    Q?H!" HHH!"  H}!" Hn!" )w!H=!" 91RHK!" HL!" HPH9vc    >H%!" HHH!"   H!" H	!" )w!H=!!" 1H " H " HPH9vc    >H " HHH "  H " H " )w!H= " o1H " H " HPH9vc    ">H[ " HHHP "  HN " H? " )w!H=W " 
1#H " H " HPH9vc    =H" HHH"  H" H" )w!H=" 
1
H" H" HPH9vc    X=H" HHH"  H" Hu" )w!H=" @
1Y
HR" HS" HPH9vc    <H," HHH!"   H" H" )w!H=(" 	1	H" H" HPH9vc    <H" HHH"   H" H" )w!H=" v	1	H" H" HPH9vc    )<Hb" HHHW"   HU" HF" )w!H=^" 	1*	H#" H$" HPH9vc    ;H" HHH"  H" H" )w!H=" 1H" H" HPH9vc    _;H" HHH"   H" H|" )w!H=" G1`HY" HZ" HPH9vc    :H3" HHH("   H&" H" )w!H=/" 1H" H" HPH9vc    :H" HHH"  =@" rG   fAH@" J<MHHHi@" J4HH;Z@" rHq" Hb" )w!H=z" -1FH?" H@" HPH9vc    9H" HHH"   =?"    A        EH?" LHH<(H   }HHH?" H4)HHHk?" \(1j1Hj11j11Hj11nj11Hj'f     uVB 1LQ6H>" H( B AD;=>" "H" H" )w!H=" 1H" H" HPH9vc    8H" HHH"   LH-n>" Hc  Ld$(E1ffff.     D|$4Hl$8ED$0HELhA       HD$`    HD$X   1HD$x1HD$pE1D$T   ffffff.     Ld$HHD$pHD$@Am9l$T   H" H" )w!H=" 1H" H" HPH9vc    s7H" HHH"  1h1Hhl$TAmHD$`9   Hn" H_" )w!H=w" *1CH<" H=" HPH9vc    6H" HHH"  1hH1H<hHD$`AmHD$X9   H" H" )w!H=" 1H" H" HPH9vc    D6H}" HHHr"  1vg1HgHD$XAm 1tpHA" H2" )w!H=J" 1H" H" HPH9vc    5H" HHH"  AE  tiH" H" )w!H=" 1H" H" HPH9vc    :5Hs" HHHh"  AE tiH^" HO" )w!H=g" 13H," H-" HPH9vc    4H" HHH"  
AE \$hteH" H" )w!H=" 1H" H" HPH9vc    \4H" HHH"  EuE)MeLHAD$HHck(HHD$xH   H9  Hl$pA|$11I    :W@ IGPIG@zc @   L HL$HHHH@    A  H\$x1d   H\$xH" H" )w!H="  1 H" H" LHPH9vc    83Hq" Hl$pHHHa"   -09" 1]d1HdH;" H," )w!H=D" 1 H	" H
" HPH9vc    2H" HHH"  -8" H=" O@)D$    D$    $    E1E1IL01fff.     H\$xHHl$pH+t$@D  TH\$xAF   r   DTc1CcH$          ME E}I] LHI\$hDt$0DHXH{ tHckD|$4Offff.     DHD|$4t"fffff.     H9X    tH@HuYB 1/1H;\$x   DHH{11H    YW@ HEPHE@zc @   HL`H@    1!bH$          AIZHl$8   H+l$pHu    IAH      71aIHcI~A1aHcIDHHl$8  fBD1HH9tBYB 1y.f     AHm HELd$(  H3" H$" )w!H=<" 1H" H" HPH9vc    /H" HHH"   H" H" )w!H=" 1H" H" HPH9vc    =/Hv" HHHk"  Hi" HZ" )w!H=r" %1>H7" H8" HPH9vc    .H" HHH"  H" H" )w!H=" 1H" H" HPH9vc    s.H" HHH"   H" H" )w!H=" [1tHm" Hn" HPH9vc    .HG" HHH<"   H:" H+" )w!H=C" 1H" H	" HPH9vc    -H" HHH"   H" H" )w!H=" 1H" H" HPH9vc    D-H}" HHHr"   Hp" Ha" )w!H=y" ,1EH>" H?" HPH9vc    ,H" HHH"   H" H" )w!H=" 1H" H" HPH9vc    z,H" HHH"  H" H" )w!H=" b1{Ht" Hu" HPH9vc    ,HN" HHHC"  H|$F@l$'@  XB XB 1   E1IXB XB 1   E1IXB XB 1   E1H1" H]  1H: Z  HD$`L|$pLl$xXB XB 1   E1HD$hD5_1" HE   D Hq" Hb" )w!H=z" -1FH?" H@" HPH9vc    *H" HHH"  uD@ H" H" )w!H=
" 1H" H" HPH9vc    p*H" HHH"   uLd$(L=[0"    DHHI_ DH=" O@)D$    D$    $    E1E1DLD|H=M" O@)D$    D$    $    E1E1DHM?MtoAHA1wIMgAHXEoH{ tk*DH@1HtH9Xu
YB 1'E   DLd$(L|$pf     Ha" HR" )w!H=j" 16H/" H0" HPH9vc    (H	" HHH
"   u    H
" H
" )w!H=
" 1H
" H
" HPH9vc    `(H
" HHH
"   AuHL$hLl$xLd$(HL$hLl$xL|$pHD$`H*." H  H; u="   Ld$(HHL$hD%." C$CL$HHHH)E1HLEIlfHHHuHD$`{   1H H    HH    H/4           H4  LKF  H	" H	" )w!H=	" S1lHe	" Hf	" HPH9vc    'H?	" HHH4	" D H2	" H#	" )w!H=;	" 1H 	" H	" HPH9vc    &H" L|$pLl$xHHH"   Mt3$    HT$`    E	H$      1zL5S,"    DHHI^ DH=" O@)D$    D$    $    E1E1DLDtH=E" O@)D$    D$    $    E1MDHM6MtpA~HA~1oIM~A~HXAnH{ t	Dk)H@E1HtH9Xu	YB 1#H|$`H1HD1  LH1D1  Hl$xH   1CV|   1HmV   1!VZ   1HKVH" H" )w!H=" 1H" H" HPH9vc    k$H" HHH"     1U   1HU   1xU   1HUH*" H8 Lt$(H\$pt<U   1?UxU   1HiU   1UV   ~   1U<   1H-U   1T   1HU   1T   1HT   1T   1HT   1{T   1HT   1YT   1HT   17Tp   1HaT   1TN   1H?TH=O"  tD?  1S"?  1HT   1S    1HS%   1S%   1HS   1S   1HS   1aS   1HS   1?Sx   1HiS11 SY11HMS11S=11H1S   1R   1HS.   1R.   1HRH" H" )w!H=" Z1sHl" Hm" HPH9vc    !HF" HHH;"     1<Ru   1HfR   1RS   1HDR:   1Q1:   1H"R   1Q   1H R;   1Q;   1HQ   1Q   1HQ   1pQ   1HQ   1NQ   1HxQ   1,Qe   1HVQ   1
QC   1H4Q'   1P!'   1HQ   1P   1HP11P11HP11P11HP   1lP   1HP   1JP   1HtPH%" H" )w!H=." 1H " H " HPH9vc    H " HHH "   11O11HO11O11HOH " Hy " )w!H= " D1]HV " HW " HPH9vc    H0 " HHH% "   HHI   PH=! " O@)D$    D$    $       AILe         H*  HQL  n#" H! H! )w!H=! S1lHe! Hf! HPH9vc    H?! HHH4!    16No   1H`NL  H"" H8 tH|$h     HX-"" !H=! O@)D$    D$    $    E1E1H<He"" HX -c"" H=! O@)D$    D$    $    E1E1HH"" H  !"   HHtMH"" H<H{^HH!" @H!" H4HcHHD /H!" HxHHH!" HqHcH    HHH>HHHcHHH=! Ht$HHH5! HcHSXB :C 11L$   XB A zc LLHHUHcHL   =     HK'  L= " M  ff.     Ht+HC@MoI;E@u!CA;EuII       Mo   1K   1HKI?HHI7HcHWIc_      HH&  Ic_   k   HH{&  I_-" JH=! O@)D$    D$    $    E1E1HeIGIOMHt)HP@HYH;S@up;suHIHu HuwDpD~HhH} t]Jfffff.     DX
fD  H@1HtH9huffff.     YB 1DDHH-" WH=(! O@)D$    D$    $    E1E1HrH! H! )w!H=! 1H! H! HPH9vc    BH{! HHHp!      1qI   1HIHL! H=! )w!H=U! 1!H! H! HPH9vc    H! HHH!   M?MLH! H! )w!H=! 1H! H! HPH9vc    GH! HHHu!   LzH  [A\A]A^A_]C PHP! HA! )w!H=Y! 1%H! H! HPH9vc    H! HHH!   H! H! )w!H=! 1H! H! HPH9vc    ZH! HHH!   H! Hw! )w!H=! B1[HT! HU! HPH9vc    H.! HHH#!   H!! H! )w!H=*! 1H! H! HPH9vc    H! HHH!   Xf     AWAVSIAAu   Itr1DFaAG1r   DxF   I  w)HIkD=   w!
=   w1D3F\hDLH[A^A_ UAWAVAUATSPHL=" A"uIL-" A] H"  uHPH" HH,   HHg" AE  L5[" A uINHG" AFIHH9t-=  wLcH B,E19   \$MfL%" InaHith1HH8wMItVk
IVH" A4$L1Anv7AE  <B 1LA] H[A\A]A^A_]1E1\$8L@ \$u
HHZ" E1w
t@uA   L@@ D`H@@zc A] H[A\A]A^A_]1f     " t1@ SJ/ rC 1%,"    Hcc    [fD  S
/ rC 1,Hcc     "     1fD  <c     u
H~
"    [ffff.     AWAVAUATSRH" A&C E1AhhB H    u"E1C 1SA&C AhhB 1D  KH`hB H=" LHHt9 tI4$<C 1HAfAKL,hhB LLtL$hhB q&C A}  MDuHHi" 1?HbB B1@HbB Hu[A\A]A^A_     ffffff.     UAVSII1stpurB H      [C HtfC H   " t" 4tzC 1" y" LnuSB HuBX" -Q" tG" tzC 11" +"  I B    [A^]fD  UAWAVAUATSH  IH LLfffff.     HIHHkDH uHuA-uMM9   AG-   " t" 4tC 1	" AG A   nE1+ucM9tNAG+uDP" tX" 4tC 1R	?" AG A   " Dl " Dl A ; t HH$   H=" L,IMt!Ll$X"     H"     1  
C 1LB  H" C   H" C   H" C r  H" C b  Ht" 0C R  Hd" 0C B  HT" 0C 2  HD" C HD$xL$gHD$hH-"   H" C   H" 0C H" I  H" C H" 0C D$gHL$xHD$hH" L$     Ak  H" C L$     H" 0C s  H" 0C c  Hu" 0C S  He" C C  HU" 0C 3  HE" 0C #  H5" 0C   L$   D$tW)$   )$   )$   )$   )$   H$       A$$   $      E1I,  fff.     $YB wC    L  }C    L,	  C    L!	  IcAD%   =   D $     H;" L-4" H$   HH<H=" H" $       $       IcAt%   =   ubH$   E1Ht9H@ Lu
! t#HA   H$    t@C 1	HD$   $      At  $        AuAD$
rIt$C 1	(   LhH    IwC    Lg  }C    LM
  C    L3
  IcAD%   =   D $   
  C   H" L-"      IILAU t,uT$gHL$hAE  Ll$xHM" AbB E1C ffffff.     H(   IIu I> uICD%   = D  H$(  HH$@   $8  CLL   9H|$xHL$hT$gy/$      :  IA$bB H|$xHL$hT$gHe" ,  AI=  *  L=@" L-9" }!   ,   L,~HH	   LEH,	  "<C B C LH$   LE+  H]  H" HD$xL-"   H" HD$hL-" f  L=" L-"   L=y" L-r"    D$    YD$    $   OD$    $    A   ;AuA}  
  H#" HD$xL-" e  D$   $    E1E1D$    $    E1A   LH$   LD  H_
    $      F
  fff.     IAM t,uL$hL$   AE  LHr
" AcB E1#/C @ HX}  IIu I> u  ff.     IAM t,uL$gAE  Ll$xL%
" LS  IA] t,uAE  H$h  HHL$   L=	" $x  @    D@,,  Ah	  ANAL   R	     fff.     IA] t,uAE  H$  HH@L$   L=	" g$  A,  A  ANAL      	       HxcB A    (C    +u HH-~" AbB E1C Hh{tII4$I> uIH+I$8   HxcB E1(C ffff.     HH{S  IH3H> Hua  fD  LzW  IH3H> u7  I    fff.     IA] t,uAE  H$H  HXH$`   A] HD$xHh" D$X  A  A}    D   A    11E1E1f.     D!tu   A"f      DEAE ut    AD$   D!$   AQE$      DAD$    !	$      $      _  $      IHC" L-<" H$   HHD$   H=" H" $   uB>$   IcAL
|    =     3)  G,u*A  AFHAD=  p  H#  _  HAFAHAD=     6  IE8 t#IA$cB HL$hHL$xH)" BH$   HH/$   $    HL$hHL$xH" -=  L$   S	,3  A    1  HrC 1H#  HC8   IA`cB (      wux  =,u4A  AVHcAT     	$   H    AtAVHcAT    	$   ]  AF  CD   D!	$   I}AIE    Y  Q  AtANAL  5  /  AtANAL     		$     $      IH" L-" H$   HH$   H" H" L($   u-H9  r$   t-=()U  HH9   D  =   IcAL      u}  LeHH$   HH$H! uH$   f	hH=" L=" ,  Hi  =   zHC8 tIIA$`cB AbB $H$  HUH$    s$  H$   BL   9YQH|$xL$gHL$hH)" ,u?AL$      ANAL      fCL	$   H   L$      AtANAL     fCL	$   ?D  ECD=   r@D5" CD
C 1LHtDAAIr LAIu
A}  LuAD$=  wX? tSH" C I\$(I|$It$0	s   IH$   |$t    XC 1*X	  $          L   @ur    tbH\$X  K   $   u$      u`       H5T" F" Ht/ C 1  HD$X   C 1   2C 1Z      tC 1%$   Cw\$   uu  ` 3uu!     @ +  C h   $   $         t`   |tP   tHn |t@   t8 |t0   t(n  |t  |t    tj  |u?   uoC 1E$   1uC 1!$         u           |@   @n |   n |    j |   n |    |   n |    | | |t%   uoC 1$   %   =   u'9wC 1$   % = |u   E9rD9wC 1$   D r$9sC 1S$   % =* |uH1u.C 1!$   1ukC 1$   @%@=@  |t   %  @=   ,u.=!  u%%    t=! dtC 1$   %   =   @t   Lu=!  u6   Lu,}! u"%  =  u  `tC 1G=7!  t@H! @\;! u.D! L&! AI@A)i!  B D   ^   $H$   M MeE   =!  J  AL$
w,   #$   <c     t}C 1{AL$
s,   #$   <c     t}C 19AL$
w,   #$   <c     t}C 1AL$
w,   #$   <c     t}C 1AL$ 
w,   #$   <c     t}C 1sAD$$R  p! D  ! uuIt$C 16AD$$t=Z! dtIt$C 1AD$$t%8! t!dtIt$C 1AD$$! uQr	d   C! t7   tum   H54! 6! C 1tuotu:H! HHD! H! ! D! ! !    +It$HK! C 1'It${C 1H! HP   H$   HwLHH $HZB H=! O@)H$   L$   D$   D$D$    $       C 1   H=! O@)H$   L$   D$   $   D$\$$<H=`! G@)H$   L$   D$   $   D$$D$      H$   Ht?H=! G@)L$   D$   D$   D$   $       MH  [A\A]A^A_]gC =PHwR$ZB HH8HH0OHH(OHH OHHHHHOH'HXgfffff.     AWAVSIHAN3udH   $[B HH8HH0CHH(CHH CHHHHHCH+H[A^A_   w$P[B A~1   HH  IF8H! AF@! QC 1[A^A_o:fA~1 tHH!t1   H9t'IF8H! AF@! C 1I,L@t'IF8H`! AF@n! C 1ILH	HHCs   C	CHcCH   HHCH@sHk   C   HH H!t:H H9Ht*IF8H! AF@! C 1HICLt*IF8Hx! AF@! C 1HILtaHK	HCS    t2s		AV3u    SkKHSHC(   	Cffffff.     AWAVATSHIHG/wpH@  @  HsA   A   H    HsBH! @Lt$HLHtH! C$ADEtuDmA    eC    u
Lt$D:u
Lt$DAL$Lt$D$#CHAI#CHAI#CH B ArF B f.     A3SAVsSAVsSAVMvsSH[uH[A\A^A_ffff.     P{C 1   Zfff.     {C 1@ UAWAVAUATSHIHE1(u+Au,HT$AB%   HK=   HDDHT$HT$DELD    (  u`0uXDkH1A,   1AG  A1CL   0  DHD$	8H  ff.     tHH19t   L+ELT$MeMLT$EH0Bn1       D1fLkHBnt;Ak
|   9r   Eu@AtjA1CL  vWd= (  H! 2C 1?1Et8)u31{ u+AtA1CL  wHDHD$	8HH[A\A]A^A_]UAWAVAUATSHHDL$DD$AHT$ Ht$H$   L-z! Hs! HD#Et	A,u Lt$(LLd|$@ D#L-5! tH(! C 1  T$8|$ MEL|$ C|t   19DtH   99}#   9~H! 0C 16  $    tp   ft$u$   fD  9}!t      @9@ HL$9  |utHD$  |   |$utH! C 1   1,uE1A   A1CL   rvCD   !HD$	0H>uLAtA1CL  w3CD   !HD$	0HHt! YC 1HH[A\A]A^A_] AWAVSIIH= HW!     L8`tH{HHu1MtW   MtA[A^A_@ H	!      UAVSH    H! D  9lut1 tDHH  uH= S  I1Mt H5) 1L`L[A^] 1   Lr! 1HHHB9|tHq8uILffff.     O     #   9w<@ r4  r&  t  t  u      t1@ O   w ru      t1ff.        W     &   1wOH5h   HcH     uH  _     uH   H  uH     1   0H CHH   4H        f.     O @       +t.t4t$(  t  t  u   u       f        t   ffffff.        t   ffffff.     fD  t0E1HfD  98uDHA1A 
  HAA9r1        v  DGAw
  L
  OcMAt,E1A H8uxD!B
  HAA9r 1%
  
  A H?uwD!
  H9r1    	  A 1:uzD!	  H9r	           tduE1    	  A Hfff.     8  uxD!d\	  H9r1    C	  1fffff.     :  uB B  H9r	     	   1tt?    A H@ ?   uwD!  H9r1      A H    8   uxD!|  H9r1    c  A 1     :   uzD!=  H9r-  1      A 1 :  uzD!t H9r        HH Fryt>   t61      A H8uxD!  H9r1    x  A H8uxD![  H9r1    B  A H8uxD!%  H9r1      A H8uxD!  H9r1      A H8uxD!     H9r1      A H8uxD!  H9r1l  E1A   t    t(A   :uBHHA   LL   MrIH4H|AA)MuwHL9LNHu7HL9LNHH(Au1I  ItNHzAII1u"HHL9u L9LNLLHHA9uKH1    `  1:uB Q  H9r=  A  L  KcLt!E1H8u
x  HAA9r   Lu  KcLt!E1H8u
x
  HAA9r
   Lg  KcLt!E1H8u
x	  HAA9r	wiLY  KcLt!E1H8u
xR  HAA9rw/   s%t!E1H8u
x  HAA9ru+1      H8u
x  H9r1      H8u
x  H9r1      H8u
x  H9r1    z  H8u
xh  H9r1    O  H8u
x=  H9r1    $  H8u
x   H9r1      1@ 9:u	B tH9r  H1      1:uB   H9r  1      1:uB   H9ro  1    `  1:uB ]  H9r=   c.          rLt  Hd  1      A H8uxD!d  H9r1      A H8uxD!  H9r1      A H8uxD!
c  H9r1    J  A H8uxD!	-  H9r1      A H8uxD!   H9r1       A H8uxD!   H9r1       A H8uxD!   H9r1    tvA H8uxD!t]H9r1    tHA H8uxD!t/H9r1    t1:u	B t#H9rHHHHHHHHyp>p@t@eeeee@e555555						  u   E%u    AA D9u     ,        	    u     u
Aa  u
AR  AAAA@AZ  A      u       A D    tSE   H  Hc<HA   A@      A   	 `  EU        D   	 	 t6tIEtj      A   D9G         A(   u4Au.H   HcHDA   DtoA   tQ   tGA;A   As,IcHu A   AsIcHt A	   D   4i|?wfff.      AA D9u   1  =,  H*  Hc<H1  AA     1    u     t-v  H  HcHS        A      AU  DA6  H8@   @ H   f     9  0  A]!  AA   .  1cHA   A
      DHrs    AAA   rd   A@
             HcHKs    w         1w!     rs1AV   te1A?   tR1AsA    s<DHsr u	A
3EEu   Ad   u1X%%@     HHf     fH~HfHnff~fnD     f.     GGt:H     GGGGGGGGHuGGGGGGGGGGGGf     GGGGGGGGGGGGGGGGGGGGGGG G G$G$G(G(G,G,G0G0G4G4GGHGHHGHG HHG HG(HHG(HG0HHG0G8G8G<G<G@G@GDGDD  tZH@     GGGGGGGGGGGGGGGGHDut`HH     HGHHGHGHHGGGGGGGGGGGGGHPuff.     GGGGGGGGGGGGGGGGGGGGGGGGG G G$G$G(G(G,G,G0G0G4G4G8G8G<G<G@G@GDGDGHGHGLGLGGGGGGGGGGGGGGf     GGGGGGGGGGGGGGf     GGGGf     GGGGf     GGGGf     GGGGGGGGf     GGGGf     GGGGGGGGGGGGGGGGGGGGGGG G G$G$G(G(G,G,G0G0G4G4G8G8G<G<fG@fGBGDGDffffff.     OOOGGOOOOGGOOO OG G$O(O(O,O$G,G0O4O4O8O0G8G<O@O@ODO<GDGHOLOLOPOHGPGTOXOXO\OTG\G`G`GdGdGhGhGlGlf     GGGGGGGGGGGGGGG G G$G$G(G(G,G,G0G0G4G4G8G8G<G<G@G@GDGDGHGHGLGLGPGPGTGTGXGXG\G\G`G`GdGdGhGhGlGlGpGpGtGtGxGxG|G|                                                HHHHGHHGHGHHGHGHHGHG HHG HG(HHG(HG0HHG0HG8HHG8HG@HHG@HGHHHGHHGPHHGPHGXHHGXHG`HHG`HGhHHGhHGpHHGpHGxHHGxH   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H  HH      H  HH  H  HH  H$  HH$  ,  ,  1fffff.     HHHHLHHLHH u          GGGGGGGGGGGGGGGGGGGGGGGGGGGGG G G$G$G(G(G,G,G0G0G4G4G8G8G<G<G@G@GDGDGHGHGLGLGPGPGTGTGXGXG\G\G`G`GdGdGhGhGlGlGpGpGtGtGxGxG|G|            D  GGGGGGGGGGGGGGG G G$G$G(G(G,G,G0G0G4G4G8G8G<G<G@G@GDGDGHGHGLGLGPGPGTGTGXGXG\G\G`G`GdGdGhGhGlGlGpGpGtGtGxGxG|G|                                                                                                                                                                                                                                        $  $  (  (  ,  ,  0  0  4  4  8  8  <  <  @  @  D  D  H  H  L  L  P  P  T  T  X  X  \  \  `  `  d  d  h  h  l  l  p  p  t  t  x  x  |  |                                                                                                                       %				   		    				%   	|				%   	    				%   	  D  f     GX  %   				OGGG%   				OO		   	AAAAA A@A	D				D	GO0|			AAAAAAA	 @   %   D				D	w0o  AAA   A		A
%   A	WWWOAAA      D	AAAD	D	
   		WGAAAA	   AA@AAA AAAA	D	D			D	D	OG0				 	   @%   			G0G G G$G$G(G(G,G,fD  ofpf~fnfpf~fnfbf~fnf~fnfbfboGfpf~fnfpf~fnfbf~fnf~fnfbfbOoG fpf~fnfpf~fnfbf~fnf~fnfbfbO oG0fpf~fnfpf~fnfbf~fnf~fnfbfbO0oG@fpf~fnfpf~fnfbf~fnf~fnfbfbO@oGPfpf~fnfpf~fnfbf~fnf~fnfbfbOPoG`fpf~fnfpf~fnfbf~fnf~fnfbfbO`GpGpGtGtGxGxoG|fpf~fnfpf~fnfbf~fnf~fnfbfbO|o   fpf~fnfpf~fnfbf~fnf~fnfbfb   o   fpf~fnfpf~fnfbf~fnf~fnfbfb   o   fpf~fnfpf~fnfbf~fnf~fnfbfb   o   fpf~fnfpf~fnfbf~fnf~fnfbfb   o   fpf~fnfpf~fnfbf~fnf~fnfbfb   o   fpf~fnfpf~fnfbf~fnf~fnfbfb                                           H  HH  H  HH  H  HH  H   HH   H(  HH(  H0  HH0  H8  HH8  H@  HH@  HH  HHH  HP  HHP  HX  HHX  H`  HH`  Hh  HHh  p  p  t  t  x  x  |  |      fD  GGGGGGGGGGGGGGG G G$G$G(G(G,G,G0G0G4G4G8G8G<G<HHHHGHHGHGHHGHGHHGHG HHG HG(HHG(HG0HHG0HG8HHG8H   HH   H   HH   HG@HHG@HGHHHGHHGPHHGPHGXHHGXHG`HHG`HGhHHGhHGpHHGpHGxHHGxH   HH   H   HH   H   HH   fff.     SGGO$  ffAA   0  	4       	 	AA	A	AE	A	A	A	fDOfG
fAA   	AAAA	A	@D A      @A	A	A	AAA 	D			 D	D		AA	A	fDG
  AA   A0A	AA AAAA	D	D				fDfGG
			AA 	AAA@A	 A   E	AA@AAA AAAA	   	D	D	D				fDfW
fGGGfGfGGGfGfGG G G$G$    [ff  GGGGf.     SGGO$  ffAA   0  	4       	 	AA	A	AE	A	A	A	fDOfG
fAA   	AAAA	A	@D A      @A	A	A	AAA 	D			 D	D		AA	A	fDG
  AA   A0A	AA AAAA	D	D				fDfGG
			AA 	AAA@A	 A   E	AA@AAA AAAA	   	D	D	D				fDfW
fGGGfGfGGGfGfGG G G$G$    [ff  GGHGHHG    GGGGGGGGGGGGGGHHHHGHHGHGHHGHGHHGHG HHG HG(HHG(HG0HHG0HG8HHG8f     GGGGGGGGGGGGGGGGG G G$G$G(G(G,G,G0G0G4G4G8G8G<G<G@G@GDGDGHGHGLGLGPGPGTGTGXGXG\G\G`G`GdGdGhGhGlGlGpGpGtGtGxGxG|G|                        f     GGGGGGGGGGGGGGG G f     HHHHGHHGHGHHGHGHHGHG HHG HG(HHG(HG0HHG0HG8HHG8HG@HHG@HGHHHGHHGPHHGPHGXHHGXHG`HHG`HGhHHGhHGpHHGpHGxHHGxH   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   H   HH   GGGGGGGGGGGGGGG G G$G$G(G(G,G,G0G0G4G4G8G8G<G<G@G@GDGDGHGH   %  	   @		AAAAA   A   A	     %   D			D	7    %   		AA@	AAA   A	A   AA   D    A          A  D	D	D			A      D			fD  HHHHGHHGHGHHGHGHHGHG HHG HG(HHG(HG0HHG0HG8HHG8HG@HHG@HGHHHGHHGPHHGPHGXHHGXHG`HHG`HGhHHGhHGpHHGpHGxHHGxH   HH   H   HH                             	  		AAD A  A ~  A	      
  0 D			D	     ? 		   	AA%  	A  ~ AA  D		A    AA
A   AAA     D	D	D			      			   GGGGGGGGGGGGGGG G G$G$G(G(G,G,G0G0G4G4G8G8G<G<G@G@f     1fffff.     HHHHHuH   HH   H   HH   H   HH   H   HH       f     GGGGGGGGGGGGGGGGG G G$G$GGHGHHGHGHHGHGHHGHG HHG HG(HHG(HG0HHG0HG8HHG8HG@HHG@f     GGGGGG  NLAI   M!Q  1M   HWHHD  oRo
fpf~fnfpf~fnfbf~fnf~fnfbfbfpf~fnfpf~fnfbf~fnf~fnfbfbfofrfofrfrfrffBH H:LI9  DFBD)A)ttHA  HD)f     HHHHua  E1M   HWHHfDoC foC foC f.     oZo"fofrfAfofrfAfofrfofrffffffffZ"H HuMM9   DFABD)A)tt.BAAA      %  D		BIArfJDD)    H        		H        		IHu     tW1ttG       r3HL)QQA    QQA    HHu@ GGGGf     GGGGGGGGGGGGf     GGGGf     GGGGGGGGf     GGGGGGGGf     GGGGf     GGGGGGGGGGGGGGG G G$G$G(G(G,G,GGHGHHGHGHHGff.     GGHGHHGfD  t'H     GGfGHu@ t*H     GGfGHHHHutW1ttGG   r2HL)QQQQQQHHu@   Huffffff.     GtGIfff.     GAAAA`A   D		D		Hu   fD  DGExgAAAAA`A   D	D		AAAA   %   D			DGf     ADGHwfD    NLA1I   M!  HQHHHE1HtHH   ooGfpf~fnfpf~fnfbf~fnf~fnfbfbfpf~fnfpf~fnfbf~fnf~fnfbfbWA   HK  JD0HHL)@ oPo@fpf~fnfpf~fnfbf~fnf~fnfbfbfpf~fnfpf~fnfbf~fnf~fnfbfbHPoPo fpf~fnfpf~fnfbf~fnf~fnfbfbfpf~fnfpf~fnfbf~fnf~fnfbfbHH@HLI9t{DFHD)A)tt+ttHHHAr2HL)QQQQQQHHu@   NLAI   M!Q  1M   HWHHD  oRo
fpf~fnfpf~fnfbf~fnf~fnfbfbfpf~fnfpf~fnfbf~fnf~fnfbfbfofrfofrfrfrffBH H:LI9  DFBD)A)ttHA  HD)f     HHHHu\  E1M   HWHHfDoz: fo: fo: f.     oZo"fofrfofrfAfAfofrfofrffffffffZ"H HuMM9   DFABD)A)tt,BAAA     D		BIArcJDD)f     x     		x   @  		IHuffff.     tzH0     GGGGGGGGGGGGGGGGGGGGGGGGH4ut~H0     GGGGGGGGGGGGGGGGGGGGGGHHHGHGH8uffff.     tW1ttGG   r2HL)QQQQQQHHu@ fGfGHGHHGHGHHGGGAVSPHIHcH=7 LptHA 1H[A^H7      1ffff.     uWB BH     HB1fff.     1ffff.     SH   HH   HtH1[ff.     1ffff.     _   f.     AVSPIH1      LAI   HtI1H[A^SH1H<$1uHi$@B H\$HH[@ H     H1P _   Zffff.     S     -  2  7_  <   tA    u>cI   u>s<   u1l/   u$-" `  ubp @  ud?--trFf twHNV%@  ?
u0F-#@t=   uFSFx=@  uFsHH --trtwHQA%  =  
uA-#=   uASuAx=  uAsHH--tr
twHJB    
uB-%   uBTuBx  uBtHHf  [fD  HHt8   H)Hffff.     HtHHHu D  8 H@uHHHf.      HD7HH!@ S1HtHHuH=4 11  H[fD  SHtuHHu0H=4 1Ht H5HHuH=3 11=  H[     AVSPI
1Ht HHHuH=3 11  HL	HH[A^    AWAVSH   It1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$HT$Ht$   M   L	H$H$   H$   H$   $   0   $      Lc$   I(wLH$   ED$   ;H$   HQH$   %fffff.     IcH$   AD$   H9HtH)	HA(w1Ht H
HHuH="2 11   M   HL H$H$   H$   H$   $   0   $      fff.     H
Hc$   H(wHH$   I$    H$   HHH$   H0HuHH   [A^A_@ AVSH   It1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$HT$Ht$H$H$   H$   H$   $   0   $      HDk! H;Hbt! H51 1H;H$   L	H3
   D   	f.     AVSH   It1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$HT$Ht$H$H$   H$   H$   $   0   $      Hdj! H;Hs! H500 1H;H$   LH8HH50 1HH   UAVSH   HAt1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$HT$H$H$   H$   H$   $   0   $      H-ui! H} Hr! H5@/ 1H} H$   HH] D$HH5!/ 1HH    AWAAVIAUIATL%c! UH-c! SL)1HHHt     LLDAHH9uH[]A\A]A^A_ff.       HH         @     l@     @     @     @     @     s@     @     8@     z@     @@     #@     &@     3$@     3$@     3$@     3$@     &@     o'@     '@     (@     B(@             $._ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789               @ .file  End of file in string: inserted ''' End of file in string: inserted '"' Unknown escape '\%c' in string: Ignored End of file in string: '"' inserted End of file in '/' '*' string: */ inserted End of file before newline in // comment End-of-file after a ': \000 inserted (%d) EOF in comment:  Newline inserted EOF in Comment: Newline inserted .line  End-of-File not at end of a line   7@     p9@     p9@     0@     p9@     0@     1@     p9@     p9@     p9@     9@     p9@     p9@     !1@     I1@     1@     9@     p9@     26@     p9@     p9@     p9@     0@     p9@     p9@     p9@     9@     9@     a.out RC_DEBUG_OPTIONS --gstabs --gdwarf2 -gdwarf-2 -mcpu %s: Flag option -%c has already been seen! force_cpusubtype_ALL %s: I expected a filename after -o. "%s" assumed. %s: -R option not supported (use the .const directive) Apple Inc version %s,  Unknown -v option ignored I expected a filename after -I. no_ppc601 ppcasm dynamic static NEXTSTEP-deployment-target I expected '3.2' or '3.3' after -NEXTSTEP-deployment-target. I expected a <release_tag> after -NEXTSTEP-deployment-target. arch_multiple arch can't specify more than one -arch flag  ppc603 ppc603e ppc603ev ppc604 ppc604e ppc750 ppc7400 ppc7450 ppc970 m98k I expected 'ppc' after -arch for this assembler. I expected an <arch_type> after -arch. %s: I don't understand '%c' flag! -g can't be specified if -n is specified AS_SECURE_LOG_FILE Interrupted by signal %d         0@qy	O
@       @      ?+-      <D@     D@     /D@     ND@     D@     D@     D@     D@     "D@                                ?                   ?           ?   ?Error converting number to floating point (Exponent overflow?) cannot create floating-point number                          U@     U@     U@     U@     U@     6V@     V@     "V@     V@     @V@     6V@     8X@     X@     W@     X@     X@     8X@     X@     Y@     )Y@     X@     X@     KY@     YY@     gY@     yY@     Y@     Y@     Y@     Y@     Y@     Y@     Y@     Y@     	Z@     Z@     e@     e@     e@     e@     e@     e@                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          


		                                                                            
      section difference unknown absent bignum/flonum Subtracting symbol "%s"(segment"%s") is too hard. Absolute segment assumed. Missing operand value assumed absolute 0. Left operand of %c is a %s integer 0 assumed bignum float Right operand of %c is a %s integer 0 assumed Can't relocate expression. Absolute 0 assumed. Expression too complex: forgetting %s - %s Relocation error. Absolute 0 assumed Division by 0. 0 assumed. Case value %d unexpected at line %d of file "%s"
 ../expr.c Expression too complex, 2 symbols forgotten: "%s" "%s" 0123456789abcdefABCDEF +-.0123456789 Backw. ref to unknown label "%lld",0 assumed. Bad floating-point constant: exponent overflow Bad floating-point constant: unknown error code=%d. L0 Missing ')' assumed Unary operator %c ignored because bad operand follows                             (\(\(\(\(\(\(\(\        5;N\C9#J{/L
F%u^)         W]K<_ZX`]OSOJp?sa*           VmBf)?`MMCua
o"4              xg63
R`i;.eNQG3 {t9SSz
      }JF<iy*hY>VPr^2>#n     q*}q+n`W1oZ7oi'23UD~NXP0          y!ewLD,s4C3o~rEl{Q-Hu=.3-!=-	    O8<9^@h g&RD7eEC15 ^+RASQ     t B     t B     t B         +    B      B      B     +    B      B      B     +    B     !B     !B     +   !B     4!B     4!B     +   @!B     `!B     `!B     +   p!B     !B     !B     +   !B     !B     !B     +   !B     !B     !B     +   !B     !B     !B     +    "B     :"B     :"B     x+   @"B     z"B     z"B     +   
 d ' o# [Am-      jd8n?O             >.	8Mc>]YZZJ3&N          LtrHm?9JuM4w}&jxMo_S     XH
0)	|(_dacO\I8P84c     ?O\&;t?)$Yd%0K_0%    t B     t B     t B         +    $B      $B      $B         +   $B     $B     $B         +   $B     $B     $B         +   $B     $B     $B         +   
$B     $B     $B        +   $B     $B     $B        +    $B     2$B     2$B        +   @$B     d$B     d$B        +   p$B     $B     $B        +   $B     $B     $B     M   +   $B     *%B     *%B        +   with -n a section directive must be seen before assembly can begin Can't extend frag %d. chars Invalid width for fill expression. exists {standard input} Can't open source file for input Can't read source file: end-of-file faked. Can't close source file -- continuing Partial line at end of file ignored %s:%u: %s:unknown: as:file(%s) %s!  Unknown error #%d. %s. include file name too long: "%s%s" Couldn't find the include file: "%s"      @     @     ;@     @     @     @     s@     @     0@     [@     @     @     p@     @     @     @     5@     F@     rs_org invalid, dot past value by %d bytes ../layout.c Negative of non-absolute symbol %s section difference divide by two expression, "%s" minus "%s" divide by 2 will not produce an assembly time constant section difference relocatable subtraction expression, "%s" minus "%s" using a symbol at the end of section will not produce an assembly time constant use a symbol with a constant value created with an assignment instead of the expression, L_const_sym = %s - %s non-relocatable subtraction expression, "%s" minus "%s" symbol: "%s" can't be undefined in a subtraction expression Fixup of %lld too large for field width of %d %s: FATAL: %qd as: for architecture ppc
          @     @     @     7@     E@     S@     @@     y@     @     y@     '@     @     AB     yAB     AB                    AB     yAB     AB                     AB     yAB     AB                     AB     yAB     AB                    AB     yAB     AB                   AB     yAB     AB                   AB     yAB     AB                   AB     yAB     AB                     AB     yAB     AB                     AB     yAB     AB                     AB     yAB     AB                     BB     yAB     BB                 BB     yAB     BB          $       "BB     :BB     ABB                   &BB     :BB     QBB                   cBB     :BB     aBB     	              sBB     :BB     qBB     
              BB     :BB     BB                     BB     :BB     BB                     BB     :BB     BB                     BB     :BB     AB                     BB     :BB     BB                    BB     :BB     BB                    BB     :BB     BB                    BB     BB     BB                    CB     BB     CB                    $CB     BB     7CB                    GCB     BB     UCB                    `CB     BB     rCB                    CB     BB     CB                    CB     BB     CB                    CB     BB     CB                    CB     BB     CB                  CB     BB     DB                  DB     yAB     AB                    #DB     BB     4DB                    BDB     BB     ODB                    YDB     BB     gDB                    rDB     yAB     AB                    DB     BB     DB                    DB     BB     DB                    DB     yAB     AB                    DB     BB     DB                                                            %EB     @             VB     @                                             7EB      @            -EB      @            5EB      @            =EB      @            FEB      @            OEB     @            VEB     @            ^EB     @            fEB      @             ,C     @             jEB     @             yEB     @             EB     `@             EB     0@             EB     0@            EB      @            EB     @             EB     @             EB     0@     d       EB     @             NB     @             EB      @             EB     p@             B     @             EB      @            EB      @            EB     @             LB     @             EB     p@            EB     p@            EB     @             EB     p@             C       A              FB      @            FB     0@     f       FB     `@             FB     pA            FB     pA             #FB      A     d       )FB      A     n       B      A     s       /FB      A     s       NFB     @	A             :FB      
A             IFB     
A             }UB     A             XFB     A             oFB     @A             }FB      A             %EB     @             {>B     @             FB     @             FB     @             FB     A             FB     PA             FB     @             AB     `@             @B     @             FB     @             FB     A             FB      A             FB      A             FB     A             FB     0A            FB     0A             FB      A             GB      A             GB     A                                             LB             LB            LB        @    LB             oFB            MB            MB            2MB                            MB             8MB            IMB            XMB            gMB            wMB            MB            MB            MB            MB     	       MB     
       MB            MB            MB            MB            NB                                                        int:t1=r1;-2147483648;2147483647; char:t2=r2;0;127; void:t3=3 file contains unmatched .ifs or .elses file contains unmatched .macro and .endmacro for: %s Expected comma after name "%s" Repeat < 0, .space ignored Rest of line ignored. 1st junk character valued %d (%c). %s number illegal. Absolute 0 assumed. Bignum Floating-Point No expression:  Using absolute 0 Complex expression. Absolute segment assumed. ../read.c 0 assumed for missing expression Value 0x%llx truncated to 0x%llx. Bad floating literal: %s Expected "-ed string Symbols "%s" "%s" are undefined: absolute 0 assumed. Symbol "%s" undefined: absolute 0 assumed. Bad Absolute Expression, absolute 0 assumed. This string may not contain '\0' Can't define a macro inside another macro definition Missing name of macro Pseudo-op name: %s can't be a macro name This .endmacro does not match with a preceding .macro The macro named "%s" is already defined Missing string Expected address expression: absolute 0 assumed Bad escaped character in string, '?' assumed incompatible feature used: directive .%s (must specify "-dynamic" to be used) Junk character %d (%c). Unknown pseudo-op: %s #NO_APP
 Illegal expression. current section assumed. You can't nest macros more than %d levels deep mismatched parenthesis More than 10 arguments not allowed for macros Encountered a .endif that doesn't follow a .if or .else Encountered a .else that doesn't follow a .if or an .elseif Encountered a .elseif that doesn't follow a .if or an .elseif You can't nest if's more than %d levels deep __TEXT __text __const __static_const __cstring __literal4 __literal8 __literal16 __constructor __destructor __fvmlib_init0 __fvmlib_init1 __symbol_stub __picsymbol_stub non_lazy_symbol_pointer __DATA __nl_symbol_ptr __la_symbol_ptr __mod_init_func __mod_term_func __dyld __data __static_data const_data tdata __thread_data tlv __thread_vars thread_init_func __thread_init objc_class __OBJC __class objc_meta_class __meta_class objc_string_object __string_object objc_protocol __protocol objc_cat_cls_meth __cat_cls_meth objc_cat_inst_meth __cat_inst_meth objc_cls_meth __cls_meth objc_inst_meth __inst_meth objc_message_refs __message_refs objc_cls_refs __cls_refs objc_class_names objc_module_info __module_info objc_symbols __symbols objc_category __category objc_meth_var_types objc_class_vars __class_vars objc_instance_vars __instance_vars objc_meth_var_names objc_selector_strs __selector_strs error constructing pseudo-op table (%s) include align32 p2align p2alignw p2alignl balign balignw balignl org private_extern indirect_symbol abort ascii asciz byte desc double appfile globl lcomm long quad lsym zerofill tbss secure_log_unique secure_log_reset short single space sleb128 uleb128 stabd stabn debug_note lazy_reference weak_reference weak_def_can_be_hidden no_dead_strip symbol_resolver endmacro endm macros_on macros_off endif dump load subsections_via_symbols machine inlineasmstart inlineasmend incbin end_data_region Couldn't find the .incbin file: "%s" unknown .machine argument: %s invalid .machine argument: %s .machine argument: %s can not be combined with previous .machine directives, -arch arguments or machine specific instructions r+ a macro named "%s" encountered in a .load is already defined Couldn't find the dump file: "%s" w+ couldn't write to dump file: "%s" incompatible feature used: .weak_reference (must specify "-dynamic" to be used) incompatible feature used: .lazy_reference (must specify "-dynamic" to be used) I need a comma after symbol's name I want a comma after the n_type expression I want a comma after the n_other expression I want a comma after the n_desc expression zero assumed for missing expression floating point number invalid .secure_log_unique specified multiple times .secure_log_unique used but AS_SECURE_LOG_FILE environment variable unset. a+ %s:%d:%s
 couldn't write to secure log file: "%s" __thread_bss Expected comma after segment-name Expected section-name after comma segment-name: %s too long (maximum %ld characters) section-name: %s too long (maximum %ld characters) Expected comma after symbol-name %s size (%lld.) <0! Ignored. Alignment too large: %d. assumed. Alignment negative. 0 assumed. Ignoring attempt to re-define symbol. unknown section type: %s unknown section attribute: %s size of stub section: %s not a proper number missing size of stub section (%s,%s) incompatible feature used: section type %s (must specify "-dynamic" to be used) none pure_instructions no_toc strip_static_syms live_support self_modifying_code debug cstring_literals 4byte_literals 8byte_literals 16byte_literals literal_pointers non_lazy_symbol_pointers symbol_stubs mod_init_funcs mod_term_funcs coalesced interposing thread_local_regular thread_local_variables thread_local_init_function_pointers Bad expression: %s Expected comma after name BSS length (%u.) <0! Ignored. __bss Expect comma after rep-size in .fill Expected comma after size in .fill .fill size clamped to %d. Size negative: .fill ignored. .fill size must be 0,1,2,4 or 8, .fill ignored .fill repeat <= 0, .fill ignored .COMMon length (%u.) <0! Ignored. Ignoring attempt to re-define symbol Length of .comm "%s" is already %u. Not changed to %u. .abort %s detected.  Assembly stopping. incompatible feature used: .indirect_symbol (must specify "-dynamic" to be used) indirect symbol not in a symbol pointer or stub section, .indirect_symbol ignored Internal error, s_align() called with bad fill_size %d alignment not a power of 2 section type does not match previous section type section stub size does not match previous section stub size too many sections (maximum %d)
 fb "%d" (instance number %d of a %s label) symbol %s already has an index label definition in inlineasm Symbol "%s" is already defined as "%s"/%d.%d.%u. Symbol %s already defined. Inserting "%s" into symbol table failed: %s     HA     GA     GA     GA     ;HA     /GA     FJA     PJA     JA     )JA     JA     )JA     JA     JA     JA     JA     JA     6JA                                   can't vm_allocate() buffer for output file of size %u undefined symbol `%s' in operation setting `%s' invalid sections for operation on `%s' and `%s' setting `%s' can't create output file: %s can't write output file can't close output file Bad fx_size (0x%x) in fix_to_relocation_info()
 Internal error: incorrect fx_r_type (%u) for fx_subsy != 0 in fix_to_relocation_info() Section too large, can't encode r_address (0x%x) into 24-bits of scattered relocation entry Undefined local symbol %c (%cf or %cb) Undefined local symbol %s Non-global symbol: %s can't be a weak_definition Undefined symbol: %s can't be a weak_definition missing indirect symbols for section (%s,%s) virtual memory exceeded input can't have .file dwarf directives when -g is used to generate dwarf debug info for assembly code file number less than one file number %ld already allocated unassigned file number %ld basic_block prologue_end epilogue_begin is_stmt is_stmt value not 0 or 1 isa number less than zero unknown .loc sub-directive `%s' expected 0 or 1 Internal error dwarf2dbg_estimate_size_before_relax() called with frag without symbol or expression
 Internal error dwarf2dbg_estimate_size_before_relax() called with frag symbol with bad expression
 Internal error dwarf2dbg_convert_frag() called with frag without symbol or expression
 Internal error dwarf2dbg_convert_frag() called with frag symbol with bad expression
 __DWARF __debug_info __debug_line __debug_abbrev __debug_aranges __debug_ranges %s %s, %s Apple Inc version internal error, did not find frag in section in get_frag_fix() internal error, p != end at the end of emit_inc_line_addr()   )A     .A     .A     A     A     A     A     A     A     A     |A     A     A     A     A     A     A     A     A     A     A     A     5A     ^A     uA     'A     aA     A     A     A     A     A     A     A     A     A     A     A     A     A     A     'A     iA     dA     mA     MA     mA     mA     mA     "A     A     A     QA     A     QA     QA     QA     A     A     VA     A     A     A     #A     +A     +A     +A     +A     +A     A     +A     +A     +A     +A     A           ; # eE dDfF     C     A     r       B     pA             C     A             C     A             TB     UA             C     VA                                             q&C     &C     C     C     &C     
&C     C     C      C     (C     @C     IC     bC     jC     C     C     C     C     C     C     C     C     !C     *C     >C     FC     ^C     gC     C     C     C     C     C     C     C     C     C     C     C      C     C     "C     5C     >C     RC     ZC     rC     {C     C     C     C     C     C     C      C     	C     $C     ,C     OC     XC     |C     C     C     C     C     C      C      C     J C     R C     h C     q C      C      C      C      C      C      C      C      C     "C     
!C     /"C     %!C     C     A!C      C     ]!C     z!C     !C     !C     !C     !C     !C     !C     !C     !C     "C     +"C     6"C     Z"C     a"C     m"C     t"C     "C     "C     "C     "C     "C     "C     "C     "C     "C     "C     "C     "C     "C     "C     
#C     #C     #C     %#C     2#C     9#C     F#C     N#C     [#C     c#C     p#C     x#C     #C     #C     #C     #C     #C     #C     #C     #C     #C     #C     #C     $C     $C     $C     $$C     +$C     9$C     @$C     N$C     U$C     c$C     m$C     {$C     $C     $C     $C     $C     $C     $C     $C     $C     $C     %C     %C     /%C     8%C     M%C     V%C     k%C     q%C     %C     %C     %C     %C     %C     %C     %C     %C     %C     %C     &C     &C     &C     &C     /&C     5&C     D&C     J&C     Y&C     `&C     p&C     u&C     &C     &C      B      B                             C            C            C            C            C            C            C            C              B             (C            (C            (C            |4C            )C              B             #/C            /C            //C            (/C            (C     	       (C            C            C            C            C            C            C            C           C           C           C           C           C           !C           F4C           W4C           %C           )C           0C           7C           >C           EC           LC           SC           ZC           aC           hC           oC           vC           }C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           C           "C           (C           .C              B        8    &C     $  (                    8    5C     $                        <    &C     $  (   "                 <    &C     $   "                     0    &C     $  $                    4    &C     $  $                  |    ,C     $  $  $               |    ,C     $  $  $               |    &C     $  $  $               |    &C     $  $  $                |    &C     $  $  $                |    &C     $  $  $               |    &C     $  $  $               |    &C     $  $  $               |    &C     $  $  $               |    &C     $  $  $               |    &C     $  $  $               |    &C     $  $  $               |    &C     $  $                   |    &C     $  $                   |    &C     $  $                   |    'C     $  $                   |    'C     $  $                   |    'C     $  $                   |    'C     $  $                   |    'C     $  $                     p    ''C     $  $                    t    -'C     $  $                 8  |    f+C     $  $  $              9  |    /C     $  $  $              x  |    X+C     $  $  $              y  |    4'C     $  $  $                 H    7C                             H    3C                             H    EB                             H    :'C                             H    >'C                             H    C'C                             @    x1C     P  P  	                @    G'C     P  P                  @    K'C     P  P  	                @    O'C     P  P                  L    T'C     P  P                    L    T'C     P  P  KP              ! L    Z'C     P  P                  ! L    Z'C     P  P  KP                 L    a'C     P  P                     L    a'C     P  P  KP              !  L    f'C     P  P                  !  L    f'C     P  P  KP                A    3C     <  	                   A    l'C     <  	                    @    3C     <  	                   @    p'C     <  	                     B    t'C     	                        B    y'C     	                         A    'C     <  	                    A    'C     <  	                     @    'C     <  	                    @    'C     <  	                    @B    'C     	                       @B    'C     	                        @A    'C     <  	                   @A    'C     <  	                    @@    'C     <  	                   @@    'C     <  	                   A    'C     <                     A    'C     <                     @    'C     <                     @    'C     <                      B    'C                             B    'C                             A    'C     <                      A    'C     <                      @    'C     <                      @    'C     <                     @B    'C                            @B    'C                            @A     (C     <                     @A    (C     <                     @@    (C     <                     @@    (C     <                      N    (C                               N    (C     KP                      ! N    (C                             ! N    (C     KP                        M    #(C     <                        M    #(C     <  KP                  ! M    ((C     <                      ! M    ((C     <  KP                    L    .(C     <                        L    .(C     <  KP                  ! L    3(C     <                      ! L    3(C     <  KP                     N    9(C                                N    9(C     KP                      !  N    @(C                             !  N    @(C     KP                         M    H(C     <                         M    H(C     <  KP                  !  M    P(C     <                      !  M    P(C     <  KP                     L    Y(C     <                         L    Y(C     <  KP                  !  L    a(C     <                      !  L    a(C     <  KP                    @N    j(C                               @N    j(C     KP                      ! @N    p(C                             ! @N    p(C     KP                        @M    w(C     <                        @M    w(C     <  KP                  ! @M    ~(C     <                      ! @M    ~(C     <  KP                    @L    (C     <                        @L    (C     <  KP                  ! @L    (C     <                      ! @L    (C     <  KP                    L    (C     P  P                   N    (C                              N    (C     KP                      ! L    (C     P  P                  !N    (C                             !N    (C     KP                       M    (C     <                       M    (C     <  KP                  !M    (C     <                      !M    (C     <  KP                   L    (C     <                       L    (C     <  KP                  !L    (C     <                      !L    (C     <  KP                    A    (C     @  	                    A    (C     	                       A    (C     @  	                   A    (C     	                        @    8C     @  	                    @    8C     	                       @    (C     @  	                   @    (C     	                        A    (C     @  	                    A    (C     	                       A    (C     @  	                   A    (C     	                        @    (C     @  	                    @    (C     	                       @    (C     @  	                   @    (C     	                        A    (C     @  	                    A    (C     	                       A    (C     @  	                   A    (C     	                        @    (C     @  	                    @    (C     	                       @    (C     @  	                   @    (C     	                        @    (C     @  	                    @    (C     	                       @    (C     @  	                   @    (C     	                        @    (C     @  	                    @    (C     	                       @    (C     @  	                   @    (C     	                        A    {4C     @  	                    A    {4C     	                       A    (C     @  	                   A    (C     	                        @    )C     @  	                    @    )C     	                       @    )C     @  	                   @    )C     	                        A    )C     @  	                    A    )C     	                       A    )C     @  	                   A    )C     	                        @    )C     @  	                    @    )C     	                       @    )C     @  	                   @    )C     	                       A    )C     @                     A    )C                            A    #)C     @                     A    #)C                            @    ))C     @                     @    ))C                            @    .)C     @                     @    .)C                            A    4)C     @                     A    4)C                            A    9)C     @                     A    9)C                            @    ?)C     @                     @    ?)C                            @    D)C     @                     @    D)C                            A    J)C     @                     A    J)C                            A    O)C     @                     A    O)C                            @    U)C     @                     @    U)C                            @    Z)C     @                     @    Z)C                            @    `)C     @                     @    `)C                            @    e)C     @                     @    e)C                            @    k)C     @                     @    k)C                            @    p)C     @                     @    p)C                            A    v)C     @                     A    v)C                            A    {)C     @                     A    {)C                            @    )C     @                     @    )C                            @    )C     @                     @    )C                            A    )C     @                     A    )C                            A    )C     @                     A    )C                            @    )C     @                     @    )C                            @    )C     @                     @    )C                             M    )C     @                        M    )C     @  KP                    M    )C                             ! M    )C     @                      ! M    )C     @  KP                  ! M    )C                               L    )C     @                        L    )C     @  KP                    L    )C                             ! L    )C     @                      ! L    )C     @  KP                  ! L    )C                               M    )C     @                        M    )C     @  KP                    M    )C                             ! M    )C     @                      ! M    )C     @  KP                  ! M    )C                               L    )C     @                        L    )C     @  KP                    L    )C                             ! L    )C     @                      ! L    )C     @  KP                  ! L    )C                               M    )C     @                        M    )C     @  KP                    M    )C                             ! M    )C     @                      ! M    )C     @  KP                  ! M    )C                               L    )C     @                        L    )C     @  KP                    L    )C                             ! L    )C     @                      ! L    )C     @  KP                  ! L    )C                               L    )C     @                        L    )C     @  KP                    L    )C                             ! L    )C     @                      ! L    )C     @  KP                  ! L    )C                               L    )C     @                        L    )C     @  KP                    L    )C                             ! L    *C     @                      ! L    *C     @  KP                  ! L    *C                               M    
*C     @                        M    
*C     @  KP                    M    
*C                             ! M    *C     @                      ! M    *C     @  KP                  ! M    *C                               L    *C     @                        L    *C     @  KP                    L    *C                             ! L    *C     @                      ! L    *C     @  KP                  ! L    *C                               M    $*C     @                        M    $*C     @  KP                    M    $*C                             ! M    **C     @                      ! M    **C     @  KP                  ! M    **C                               L    1*C     @                        L    1*C     @  KP                    L    1*C                             ! L    7*C     @                      ! L    7*C     @  KP                  ! L    7*C                              M    >*C     @                       M    >*C     @  KP                   M    >*C                             !M    E*C     @                      !M    E*C     @  KP                  !M    E*C                              L    M*C     @                       L    M*C     @  KP                   L    M*C                             !L    T*C     @                      !L    T*C     @  KP                  !L    T*C                              M    \*C     @                       M    \*C     @  KP                   M    \*C                             !M    c*C     @                      !M    c*C     @  KP                  !M    c*C                              L    k*C     @                       L    k*C     @  KP                   L    k*C                             !L    r*C     @                      !L    r*C     @  KP                  !L    r*C                              M    z*C     @                       M    z*C     @  KP                   M    z*C                             !M    *C     @                      !M    *C     @  KP                  !M    *C                              L    *C     @                       L    *C     @  KP                   L    *C                             !L    *C     @                      !L    *C     @  KP                  !L    *C                              L    *C     @                       L    *C     @  KP                   L    *C                             !L    *C     @                      !L    *C     @  KP                  !L    *C                              L    *C     @                       L    *C     @  KP                   L    *C                             !L    *C     @                      !L    *C     @  KP                  !L    *C                              M    *C     @                       M    *C     @  KP                   M    *C                             !M    *C     @                      !M    *C     @  KP                  !M    *C                              L    *C     @                       L    *C     @  KP                   L    *C                             !L    *C     @                      !L    *C     @  KP                  !L    *C                              M    *C     @                       M    *C     @  KP                   M    *C                             !M    *C     @                      !M    *C     @  KP                  !M    *C                              L    *C     @                       L    *C     @  KP                   L    *C                             !L    *C     @                      !L    *C     @  KP                  !L    *C                                ,    *C     D  $                    ,    *C     D  5P  $                ,    *C     wP  $                    ,    *C     wP  5P  $                ,    *C     $                        ,    *C     D  $                    ,    *C     wP  $                    ,    *C     $                        ,    *C     D  $                    ,    *C     wP  $                    |    C     D  $  $                 |    C     D  5P  $  $             |    C     wP  $  $                 |    C     wP  5P  $  $             |    +C     $  $                     |    +C     D  $  $                 |    +C     wP  $  $                 |    +C     $  $                     |    +C     D  $  $                 |    +C     wP  $  $                 (    +C     D  $                    (    +C     D  5P  $                (    +C     wP  $                    (    +C     wP  5P  $                (    +C     $                        (    +C     D  $                    (    +C     wP  $                    (    +C     $                        (    +C     D  $                    (    +C     wP  $                 @  |    !+C     D  $  $              @  |    !+C     D  5P  $  $          @  |    !+C     wP  $  $              @  |    !+C     wP  5P  $  $          @  |    &+C     $  $                  @  |    &+C     D  $  $              @  |    &+C     wP  $  $              @  |    ,+C     $  $                  @  |    ,+C     D  $  $              @  |    ,+C     wP  $  $              4  |    2+C     $  $                  5  |    9+C     $  $                  t  |    A+C     $  $                 u  |    H+C     $  $                  L    P+C     P  P  P               L    V+C     P  P  P              B L    ]+C     P  P  P               L    c+C     P  P  P              B  L    j+C     P  P  P               L    p+C     P  P  P              B L    u+C     P  P  P               L    {+C     P  P  P               |    +C     $  $  $              |    +C     $  $  $              |    +C     $  $  $              |    +C     $  $  $              |    +C     $  $  $              |    +C     $  $  $              |    +C     $  $  $              |    +C     $  $  $              |    +C     $  $  $               |    +C     $  $  $               |    +C     $  $  $               |    +C     $  $  $               |    +C     $  $  $               |    +C     $  $  $               |    +C     $  $  $               |    +C     $  $  $              8 |    _+C     $  $  $              9 |    +C     $  $  $              t |    +C     $  $                  u |    +C     $  $                  4 |    +C     $  $                  5 |    ,C     $  $                   |    ,C     $  $                  |    ,C     $  $                 *      ,C     ,  ,  ,              +      ,C     ,  ,  ,              *       ,C     ,  ,  ,              +      &,C     ,  ,  ,              (      -,C     ,  ,  ,              )      2,C     ,  ,  ,              (      8,C     ,  ,  ,              )      >,C     ,  ,  ,              2      E,C     ,  ,  ,              3      J,C     ,  ,  ,              2      P,C     ,  ,  ,              3      V,C     ,  ,  ,              $      ],C     ,  ,  ,              %      b,C     ,  ,  ,              $      h,C     ,  ,  ,              %      n,C     ,  ,  ,              :      u,C     ,  ,  ,  ,          ;      {,C     ,  ,  ,  ,          :      ,C     ,  ,  ,  ,          ;      ,C     ,  ,  ,  ,          8      ,C     ,  ,  ,  ,          9      ,C     ,  ,  ,  ,          8      ,C     ,  ,  ,  ,          9      ,C     ,  ,  ,  ,          >      ,C     ,  ,  ,  ,          ?      ,C     ,  ,  ,  ,          >      ,C     ,  ,  ,  ,          ?      ,C     ,  ,  ,  ,          <      ,C     ,  ,  ,  ,          =      ,C     ,  ,  ,  ,          <      ,C     ,  ,  ,  ,          =      ,C     ,  ,  ,  ,                ,C     ,  ,                        ,C     ,  ,                       ,C     ,  ,                       ,C     ,  ,                  P      -C     ,  ,                  Q      -C     ,  ,                       -C     ,  ,                       -C     ,  ,                  0      -C     ,  ,                  1      -C     ,  ,                        $-C     ,  ,                        )-C     ,  ,                  4      /-C     ,  ,                  5      7-C     ,  ,                  .      @-C     ,  ,  ,  ,          /      E-C     ,  ,  ,  ,          ,      K-C     ,  ,                 -      Q-C     ,  ,                 ,      X-C     ,  ,                 -      _-C     ,  ,                 \     g-C     ,  ,                 ]     m-C     ,  ,                 ^     t-C     ,  ,                 _     {-C     ,  ,                       -C     ,  ,                        -C     ,  ,                        -C     ,  ,                        -C     ,  ,                       -C     ,  ,                      -C     ,  ,                        -C     D  ,  ,                     -C     wP  ,  ,              @      -C     D  ,  ,              @      -C     wP  ,  ,                   -C     ,                           -C     ,                            -C     D  P                        -C     wP  P                       -C     wP  P                       -C     wP  P                       -C     Q  ,                       -C     Q  ,                        -C     P                            -C     P                      L      -C     P                      M      -C     P                             .C     $     (                |    .C     $  (  $                     .C     $     (                |    .C     $  $  $                     .C     $     (              . |    .C     $  (  $                      .C     $     (              n |    %.C     $  $  $                     +.C     $     (               |    /.C     $  (  $                     4.C     $     $               |    9.C     $  $  $                     ?.C     $     (              .  |    C.C     $  (  $                     H.C     $     $              n  |    M.C     $  $  $                    S.C     $    (              |    W.C     $  (  $              |    \.C     $  $  $                    VB     $    (             *  |    b.C     $  (  $                   f.C     $    $             j  |    j.C     $  $  $                    o.C     $     (                     s.C     $     (              , |    x.C     $  (  $              , |    ~.C     $  (  $              * |    .C     $  (  $              (  |    .C     $  (  $                |    .C     $  (  $             * |    .C     $  (  $             + |    .C     $  (  $              |    .C     $  (  X                     .C     ,     (                     .C     ,     $              . |    .C     ,  (  $              n |    .C     ,  $  $                     .C     ,     (                     .C     ,     $               |    .C     ,  (  $               |    .C     ,  $  $                 8    ;'C     $     (                 L    .C     D  D                     L    .C     wP  rP                   |    .C     $  K9                   |    .C     K9  $                    |    .C     a  $                    |    .C     a  $                    |    .C     D                        |    .C     wP                      &  |    .C     $                      & |    .C     $  a                  & |    .C     $  a                  |    .C     $                      |    /C     $                      	|    
/C     $                      |    /C     $                      |    /C     $                      	|    /C     $                       |    !/C     $                      |    &/C     $                      |    -/C     $                       |    4/C     $                      |    9/C     $                      |    @/C     $                       |    G/C     $  $  $               |    M/C     $  $  $               |    T/C     $  $  $               |    [/C     $  $  $                |    c/C     $  $  $               |    i/C     $  $  $               |    p/C     $  $  $                |    v/C     $  $  $                |    }/C     $  $  $               |    /C     $  $  $               |    /C     $  $  $                |    /C     $  $  $               |    /C     $  $  $              |    /C     $  $  $              |    /C     $  $  $              |    /C     $  $  $              |    e+C     $  $  $               |    /C     $  $  $                |    -C     $  $                    |    -C     $  $                   |    /C     $  $                   |    /C     $  $                    |    l+C     $  $  $                |    /C     $  $  $                 `    /C                                `    o3C     $  $                    `    o3C     d  d   f                 d    t3C     $  $                 x |    m+C     $  $  $              y |    /C     $  $  $              8 |    w+C     $  $  $              9 |    /C     $  $  $                 x    /C     $  $   H   L           x    /C     $  $   H   L           x    /C     $  $   H   L           x    /C     $  $   H   L           x    /C     $  $   H   L         	  x    /C     $  $   H   L           x    0C     $  $   H   L           x    0C     $  $   H   L           x    0C     $  $  $   L           x    0C     $  $  $   L           x    0C     $  $  $   L           x    #0C     $  $  $   L            T    *0C     $  $  X  \  \        T    10C     $  $  X  \  \         \    90C     $  $  $  \  \        \    ?0C     $  $  $  \  \         P    F0C     $  $  X  \  \        P    M0C     $  $  X  \  \        D    EB                             $  L    U0C                            0  |    7C     $  $  $              1  |    Z0C     $  $  $              6  |    _0C     $  $  $             7  |    c0C     $  $  $             0 |    7C     $  $  $              1 |    h0C     $  $  $              6 |    3C     $  $  $             7 |    m0C     $  $  $             p |    r0C     $  $  P              q |    x0C     $  $  P              t |    0C     $  $   H             u |    0C     $  $   H             0 |    7C     $  $  $              1 |    0C     $  $  $              4 |    0C     $  $  $             5 |    0C     $  $  $                    0C     $     (                     0C     $     $               |    0C     $  (  $               |    0C     $  $  $                     0C     $     (                     0C     $     $              . |    0C     $  (  $              n |    0C     $  $  $                     0C     $     (                     0C     $     $              . |    0C     $  (  $              n |    0C     $  $  $                     0C     $    (                   0C     $    $             * |    0C     $  (  $             j |    0C     $  $  $             , |    0C     $  (  $              , |    0C     $  (  $              * |    0C     $  (  $              - |    1C     $  (  $               |    1C     $  (  $              |    1C     $  (  X               |    1C     ,  (  $                     1C     ,     (                     !1C     ,     $              . |    '1C     ,  (  $              n |    -1C     ,  $  $                     41C     ,     (                     91C     ,     $               |    ?1C     ,  (  $               |    E1C     ,  $  $                      L1C     $  $                 P  |    .,C     $  $  $              Q  |    3,C     $  $  $              P |    S1C     $  $  $              Q |    X1C     $  $  $              P  |    ^1C     $  $  $              Q  |    c1C     $  $  $              P |    i1C     $  $  $              Q |    o1C     $  $  $                |    v1C     $  $  $                |    {1C     $  $  $               |    1C     $  $  $               |    1C     $  $  $                |    1C     $  $  $                |    1C     $  $  $               |    1C     $  $  $               |    1C     $  $  $               |    1C     $  $  $               |    1C     $  $  $               |    1C     $  $  $               |    1C     $  $  $               |    1C     $  $                   |    1C     $  $                   |    1C     $  $                   |    1C     $  $                   |    1C     $  $                   |    1C     $  $                   |    1C     $  $                   |    1C     $  $                   |    ?4C                              |    ?4C     UP                       |    2C                             @|    2C                                    2C     P  $                   
    2C     $                      
    2C     $                          %2C     $                      	    +2C     $                       	    12C     $                      	    72C     $                           =2C     $                      
    C2C     $                      @    I2C     $                          P2C     $                          W2C     $                           ^2C     $                          e2C     $                          l2C     $                      |    0C     P  $  $               ~    s2C     $  $                  ~    x2C     $  $                  |    }2C     $  $                  }    2C     $  $                   }    2C     $  $                  }    2C     $  $                       2C     $  $                  ~    2C     $  $                  @|    2C     $  $                  |    2C     $  $                  |    2C     $  $                   |    2C     $  $                  |    2C     $  $                  |    2C     $  $                        2C     P  $                        2C     $                           2C     $                           2C     $                           2C     $                            2C     $                           2C     $                            2C     $                           2C     $                       @    2C     $                           2C     $                           3C     $                            3C     $                           3C     $                           3C     $                       |    9C     P  $  $                |    9C     P  d  d                ~    3C     $  $                   ~    "3C     $  $                   |    '3C     $  $                   }    ,3C     $  $                    }    13C     $  $                   }    63C     $  $                        ;3C     $  $                   ~    @3C     $  $                   @|    E3C     $  $                   |    K3C     $  $                   |    Q3C     $  $                    |    W3C     $  $                   |    ]3C     $  $                   |    c3C     $  $                       i3C                                h    n3C     $  $                    l    s3C     $  $                 x |    }+C     $  $  $              y |    y3C     $  $  $               |    ~3C     (  $                  , L    3C                             , |    3C     (  $                  , |    3C     (  $  P               |    3C     (  $                  , |    3C     (  $  P              |    3C     (  $                   |    3C     (  $                   |    3C     (  $                 l  |    3C     (  $                    |    3C     (  $                  l |    3C     $  (  $             l |    3C     $  (  $              |    3C                             d  L    3C                             $ |    3C     $                      d |    3C     $                     d |    3C     $  0P                   |    3C     $                       |    3C     (  $                  |    3C     (  $                   |    3C     4  $                   |    3C     $  4                   |    3C     $  $                  & |    3C     $  $                  d |    4C     $                      |    4C                            $ |    4C     $  $                  |    4C     $  $                 & |    !4C     $  $                 d |    )4C     $                     d |    )4C     $  5P                 $ |    /4C     $                      |    64C                            l |    <4C                            C|    D4C     $                      C|    J4C     $                       |    P4C     $  K9                  B|    P4C     $                      B|    U4C     $                             [4C     Q                        $    `4C     $  $                 |    e4C     $  $  $              |    i4C     $  $  $              |    n4C     $  $  $              |    s4C     $  $  $              |    ,C     $  $                  |    ,C     $  $                  |    z4C     $  $                  |    4C     $  $                  |    -C     $  $                  |    -C     $  $                  |    y4C     $  $                  |    4C     $  $                        4C     $  $                   |    F,C     $  $  $               |    K,C     $  $  $              |    4C     $  $  $              |    4C     $  $  $              |    ^,C     $  $  $              |    c,C     $  $  $              |    4C     $  $  $              |    4C     $  $  $              |    i,C     $  $  $              |    o,C     $  $  $              |    4C     $  $  $              |    4C     $  $  $                X    4C     $  $  $  \  \       X    4C     $  $  $  \  \     2 |    4C     $  $  $             3 |    4C     $  $  $             :  |    4C     $  $  $             ;  |    4C     $  $  $             : |    4C     $  $  $             ; |    4C     $  $  $             0 |    4C     $  $  $             1 |    4C     $  $  $             0 |    4C     $  $  $             1 |    4C     $  $  $             p |    4C     $  $  P             q |    4C     $  $  P             p |    4C     $  $  P             q |    5C     $  $  P              |    	5C     $  $  P              |    5C     $  $  P              |    5C     $  $  P              |    5C     $  $  P              |    #5C     $  $  $              |    (5C     $  $  $              |    .5C     $  $  $              |    35C     $  $  $             2 |    95C     $  $  $             3 |    =5C     $  $  $             2 |    B5C     $  $  $             3 |    F5C     $  $  $              |    K5C     $  $  $              |    P5C     $  $  $              |    V5C     $  $  $              |    [5C     $  $  $             p |    a5C     $  $  P             q |    g5C     $  $  P             0 |    n5C     $  $  $             1 |    s5C     $  $  $             2 |    y5C     $  $  $             3 |    ~5C     $  $  $             & |    5C     $  $                  |    5C     $                      |    5C     $                       |    5C     0  (  $             N  |    5C     0  (  $               |    5C     0  (  $               |    5C     0  (  $              |    5C     0  (  $              |    5C     0  (  $             N |    5C     0  (  $              |    5C     0  (  $              |    5C     0  (  $              |    5C     0  (  $               |    5C     0  (  $             L  |    5C     0  (  $             D     5C     0                          5C     0                      |    5C     $  $  UP              ~    5C     $  $  UP              |    5C     $  $  UP              ~    5C     $  $  UP             l |    5C     UP                     l ~    6C                                   	6C     0  0  0                   6C     0  0  0                   6C     0  0  0             @      !6C     0  0  0             @     )6C     0  0  0             @     16C     0  0  0                   96C     0  0  0                  A6C     0  0  0                  I6C     0  0  0             
      Q6C     0  0  0                  X6C     0  0  0                   `6C     0  0  0                   h6C     0  0  0                   p6C     0  0  0             @     x6C     0  0  0             @     6C     0  0  0             @     6C     0  0  0                  6C     0  0  0                  6C     0  0  0                  6C     0  0  0             J      6C     0  0  0                  6C     0  0  0                   6C     0  0  0                  6C     0  0  0             H      6C     0  0  0             H     6C     0  0  0                  6C     0  0  0                  6C     0  0  0             H     6C     0  0  0             H     6C     0  0  0                    6C     0  0  0  0         !      7C     0  0  0  0         "      7C     0  0  0  0         .      7C     0  0  0  0         $      7C     0  0  0  0         %      '7C     0  0  0  0         &      07C     0  0  0  0         '      97C     0  0  0  0         (      B7C     0  0  0  0         )      K7C     0  0  0  0              T7C     0  0  0                  \7C     0  0  0                  e7C     0  0  0                  n7C     0  0  0             H     w7C     0  0  0                  7C     0  0  0             B     7C     0  0  0                  7C     0  0  0                  7C     0  0  0             B     7C     0  0  0                  7C     0  0  0                  7C     0  0  0                  7C     0  0  0                  7C     0  0  0             D     7C     0  0  0                  7C     0  0  0                   7C     0  0  0             D      7C     0  0  0                   7C     0  0  0                  7C     0  0  0             D     7C     0  0  0                  7C     0  0  0                  5C     0  0  0                  7C     0  0  0                  7C     0  0  0             D     7C     0  0  0             D     7C     0  0  0                  7C     0  0  0                  7C     0  0  0                  5C     0  0  0                  8C     0  0  0                  8C     0  0  0                  8C     0  0  0                  8C     0  0  0             F     (8C     0  0  0             F     18C     0  0  0             F     ;8C     0  0  0             F     D8C     0  0  0                  N8C     0  0  0                  W8C     0  0  0                  a8C     0  0  0                  j8C     0  0  0                  t8C     0  0  0                  }8C     0  0  0                   8C     0  0  0                  8C     0  0  0             F      8C     0  0  0             F     8C     0  0  0                   8C     0  0  0                  8C     0  0  0                   8C     0  0  0                  8C     0  0  0                  8C     0  0  0                  8C     0  0  0                  8C     0  0  0                  8C     0  0  0             *      8C     0  0  0  0               8C     0  0  0                   9C     0  0  0                  9C     0  0  0                  9C     0  0  0             N      9C     0  0  0                   $9C     0  0  0             N     ,9C     0  0  0                  49C     0  0  0                  <9C     0  0  0                  B9C     0  0                 N     J9C     0  0                 N     R9C     0  0                      Z9C     0  0                      b9C     0  0                      j9C     0  0                       r9C     0  0  0             L      y9C     0  0  0                   9C     0  0  0                  9C     0  0  0             L     9C     0  0  0                  9C     0  0  0                  9C     0  0  P             L     9C     0  0  P                  9C     0  0  P                  9C     0  T                 L     9C     0  T                      9C     0  T                 +      9C     0  0  0  0         ,      9C     0  0  0  P              9C     0  0  0             L     9C     0  0  0                   9C     0  0  0                  9C     0  0  0             B      9C     0  0  0             B     9C     0  0  0                   9C     0  0  0                  :C     0  0  0             
     :C     0  0  0                  :C     0  0  0                  :C     0  0  0             B     ":C     0  0  0             B     ):C     0  0  0                  0:C     0  0  0                  7:C     0  0  0             J     >:C     0  0  0             
     E:C     0  0                 J     K:C     0  0                      U:C     0  0                      ]:C     0  0                 /      f:C     0  0  0  0         
     o:C     0  0                 J     u:C     0  0                      {:C     0  0                      :C     0  0                      :C     0  0  P                  :C     0  0  P             
     :C     0  0  P             J     :C     0  0  P                      B                             greg loc Could not initialize the opcode hash table Can't hash instruction '%s':%s static_branch_prediction_Y_bit Can't specify both -static_branch_prediction_Y_bit and -static_branch_prediction_AT_bits branch prediction ++/-- syntax always sets the AT-bits Invalid mnemonic '%s' %s (parameter %u) Parameter syntax error (parameter %u) Parameter syntax error Invalid form of the instruction (RA must not be 0) Invalid form of the instruction (RA must not the same as RT) Invalid form of the instruction (RA is in the range of registers to be loaded) Invalid form of the instruction (RT must not the same as RA) Invalid form of the instruction (RT must not the same as RB) Invalid form of the instruction (64-bit compares not allowed without -force_cpusubtype_ALL option) Invalid form of the instruction (reserved bits in the BO field must be zero without -force_cpusubtype_ALL option) flagged register r%u used not allowed 601 instruction "%s" %s instruction is only for 64-bit implementations (not allowed without -force_cpusubtype_ALL option) %s instruction is optional for the PowerPC (not allowed without -force_cpusubtype_ALL option) %s vector instruction is optional for the PowerPC (not allowed without -force_cpusubtype_ALL option) %s 601 instruction not allowed with -arch %s more than one implementation specific instruction seen and -force_cpusubtype_ALL not specified (first implementation specific instruction in: %s at line %u) Unknown relocation type Fixup of %lld too large for field width of 16 bits Fixup of %lld is not to a 4 byte address Fixup of %lld too large for field width of 26 bits Bad relocation type Bad call to MD_ATOF() Relaxation should never occur Unknown parameter type too many parameters branch prediction ('-') ignored (specified operand has prediction bit set) branch prediction ('++') ignored (specified operand has does not allow this prediction) branch prediction ('--') ignored (specified operand has does not allow this prediction) branch prediction ignored (instruction is not a conditional branch) Parameter error: expression must be absolute Parameter error: expression out of range Parameter error: expression must have exactly one bit set Parameter error: expression must have a value of zero cr2 cr3 cr4 cr5 cr6 cr7 dsisr dar dec sdr1 srr0 srr1 VRsave sprg0 sprg1 sprg2 sprg3 asr ear pvr ibat0u ibat0l ibat1u ibat1l ibat2u ibat2l ibat3u ibat3l dbat0u dbat0l dbat1u dbat1l dbat2u dbat2l dbat3u dbat3l ummcr0 upmc1 upmc2 usia ummcr1 upmc3 upmc4 sda dmiss dcmp hash1 hash2 imiss icmp rpa hid0 hid1 hid2 iabr hid5 dabr l2cr ictc thrm1 thrm2 thrm3 hid15 pir Parameter error: r0 not allowed for parameter %lu (code as 0 not r0) hi16( ha16( lo16( internal error, bad table entry for instruction %s (displacement operand not second operand or general register not third operand) Parameter error: expression must be a multiple of 4 Stub label used in a JBSR must be non-relocatable Unknown branch instruction width %d register number (%d) out of range (0-31) for .noflag_reg register number (%d) out of range (0-31) for .flag_reg mr.
 not.
 nor. $0,$1,$1
 extldi
 rldicr $0,$1,$3,($2)-1
 extldi.
 rldicr. $0,$1,$3,($2)-1
 extrdi
 rldicl $0,$1,($2)+($3),64-($2)
 extrdi.
 rldicl. $0,$1,($2)+($3),64-($2)
 insrdi
 rldimi $0,$1,64-(($3)+($2)),$3
 insrdi.
 rldimi. $0,$1,64-(($3)+($2)),$3
 rotldi
 rldicl $0,$1,$2,0
 rotldi.
 rldicl. $0,$1,$2,0
 rotrdi
 rldicl $0,$1,64-($2),0
 rotrdi.
 rldicl. $0,$1,64-($2),0
 rotld
 rldcl $0,$1,$2,0
 rotld.
 rldcl. $0,$1,$2,0
 rldicr $0,$1,$2,63-($2)
 rldicr. $0,$1,$2,63-($2)
 rldicl $0,$1,64-($2),$2
 rldicl. $0,$1,64-($2),$2
 clrldi
 rldicl $0,$1,0,$2
 clrldi.
 rldicl. $0,$1,0,$2
 clrrdi
 rldicr $0,$1,0,63-($2)
 clrrdi.
 rldicr. $0,$1,0,63-($2)
 clrlsldi
 rldic $0,$1,$3,($2)-($3)
 clrlsldi.
 rldic. $0,$1,$3,($2)-($3)
 extlwi
 rlwinm $0,$1,$3,0,($2)-1
 extlwi.
 rlwinm. $0,$1,$3,0,($2)-1
 extrwi
 rlwinm $0,$1,($2)+($3),32-($2),31
 extrwi.
 rlwinm. $0,$1,($2)+($3),32-($2),31
 inslwi
 rlwimi $0,$1,32-($3),$3,(($3)+($2))-1
 inslwi.
 rlwimi. $0,$1,32-($3),$3,(($3)+($2))-1
 insrwi
 rlwimi $0,$1,32-(($3)+($2)),$3,(($3)+($2))-1
 insrwi.
 rlwimi. $0,$1,32-(($3)+($2)),$3,(($3)+($2))-1
 rotlwi
 rlwinm $0,$1,$2,0,31
 rotlwi.
 rlwinm. $0,$1,$2,0,31
 rotrwi
 rlwinm $0,$1,32-($2),0,31
 rotrwi.
 rlwinm. $0,$1,32-($2),0,31
 rotlw
 rlwnm $0,$1,$2,0,31
 rotlw.
 rlwnm. $0,$1,$2,0,31
 rlwinm $0,$1,$2,0,31-($2)
 rlwinm. $0,$1,$2,0,31-($2)
 rlwinm $0,$1,32-($2),$2,31
 rlwinm. $0,$1,32-($2),$2,31
 clrlwi
 rlwinm $0,$1,0,$2,31
 clrlwi.
 rlwinm. $0,$1,0,$2,31
 clrrwi
 rlwinm $0,$1,0,0,31-($2)
 clrrwi.
 rlwinm. $0,$1,0,0,31-($2)
 clrlslwi
 rlwinm $0,$1,$3,($2)-($3),31-($3)
 clrlslwi.
 rlwinm. $0,$1,$3,($2)-($3),31-($3)
 mtxer
 mtspr 1,$0
 mfxer
 mfspr $0,1
 mtlr
 mtspr 8,$0
 mflr
 mfspr $0,8
 mtctr
 mtspr 9,$0
 mfctr
 mfspr $0,9
 mtdsisr
 mtspr 18,$0
 mfdsisr
 mfspr $0,18
 mtdar
 mtspr 19,$0
 mfdar
 mfspr $0,19
 mtdec
 mtspr 22,$0
 mfdec
 mfspr $0,22
 mtsdr1
 mtspr 25,$0
 mfsdr1
 mfspr $0,25
 mtsrr0
 mtspr 26,$0
 mfsrr0
 mfspr $0,26
 mtsrr1
 mtspr 27,$0
 mfsrr1
 mfspr $0,27
 mtsprg
 mtspr 272+($0),$1
 mfsprg
 mfspr $0,272+($1)
 mtasr
 mtspr 280,$0
 mfasr
 mfspr $0,280
 mfear
 mfspr $0,282
 mtear
 mtspr 282,$0
 mfpvr
 mfspr $0,287
 mtvrsave
 mtspr 256,$0
 mtibatu
 mtspr 528+2*($0),$1
 mfibatu
 mfspr $0,528+2*($1)
 mtibatl
 mtspr 529+2*($0),$1
 mfibatl
 mfspr $0,529+2*($1)
 mtdbatu
 mtspr 536+2*($0),$1
 mfdbatu
 mfspr $0,536+2*($1)
 mtdbatl
 mtspr 537+2*($0),$1
 mfdbatl
 mfspr $0,537+2*($1)
 subi
 addi $0,$1,-($2)
 subis
 addis $0,$1,-($2)
 subic
 addic $0,$1,-($2)
 subic.
 addic. $0,$1,-($2)
 crclr
 crxor $0,$0,$0
 crmove
 cror $0,$1,$1
 crnot
 crnor $0,$1,$1
 crset
 creqv $0,$0,$0
 mtcr
 mtcrf 0xff,$0
 mtfs
 mtfsf 0xff,$0
 mtfs.
 mtfsf. 0xff,$0
 vmr
 vor $0,$1,$1
 vnot
 vnor $0,$1,$1
 addi addis lis addic addic. addo addo. addc addc. addco addco. adde adde. addeo addeo. addme addme. addmeo addmeo. addze addze. addzeo addzeo. andi. andis. andc. bla jbsr jmp bca bcl bcla bcctr bcctrl bclr bclrl btl bfl bdnz bdnzl bdnzt bdnztl bdnzf bdnzfl bdz bdzl bdzt bdztl bdzf bdzfl bta btla bfa bfla bdnza bdnzla bdnzta bdnztla bdnzfa bdnzfla bdza bdzla bdzta bdztla bdzfa bdzfla blr blrl btlr btlrl bflr bflrl bdnzlr bdnzlrl bdnztlr bdnztlrl bdnzflr bdnzflrl bdzlr bdzlrl bdztlr bdztlrl bdzflr bdzflrl bctr bctrl btctr btctrl bfctr bfctrl blt bltl blel beq beql bge bgel bgt bgtl bnl bnll bne bnel bng bngl bsol bns bnsl bun bunl bnu bnul blta bltla blea blela beqa beqla bgea bgela bgta bgtla bnla bnlla bnea bnela bnga bngla bsoa bsola bnsa bnsla buna bunla bnua bnula bltlr bltlrl blelr blelrl beqlr beqlrl bgelr bgelrl bgtlr bgtlrl bnllr bnllrl bnelr bnelrl bnglr bnglrl bsolr bsolrl bnslr bnslrl bunlr bunlrl bnulr bnulrl bltctr bltctrl blectr blectrl beqctr beqctrl bgectr bgectrl bgtctr bgtctrl bnlctr bnlctrl bnectr bnectrl bngctr bngctrl bsoctr bsoctrl bnsctr bnsctrl bunctr bunctrl bnuctr bnuctrl cmpi cmpwi cmpdi cmpw cmpd cmpli cmplwi cmpldi cmpl cmplw cmpld cntlzw cntlzw. cntlzd cntlzd. crand crandc creqv crnand crnor cror crorc crxor divd divd. divdo divdo. divdu divdu. divduo divduo. divw divw. divwo divwo. divwu divwu. divwuo divwuo. eqv. extsb extsb. extsh extsh. extsw extsw. fadd fadd. fadds fadds. fsub fsub. fsubs fsubs. fmul fmul. fmuls fmuls. fdiv fdiv. fdivs fdivs. fmadd fmadd. fmadds fmadds. fmsub fmsub. fmsubs fmsubs. fnmadd fnmadd. fnmadds fnmadds. fnmsub fnmsub. fnmsubs fnmsubs. fmr fmr. fabs fabs. fneg fneg. fnabs fnabs. fres fres. frsp frsp. frsqrte frsqrte. fsel fsel. fsqrt fsqrt. fsqrts fsqrts. fctid fctid. fctidz fctidz. fctiw fctiw. fctiwz fctiwz. fcfid fcfid. fcmpu fcmpo mffs mffs. mcrfs mtfsfi mtfsfi. mtfsf mtfsf. mtfsb0 mtfsb0. mtfsb1 mtfsb1. lbz lbzx lbzu lbzux lhz lhzx lhzu lhzux lha lhax lhau lhaux lwz lwzx lwzu lwzux lwa lwax lwaux ldx ldu ldux lmw stmw lhbrx lwbrx lswx lwarx ldarx lscbx lscbx. lswi lfs lfsu lfsx lfsux lfd lfdu lfdx lfdux mcrf mfspr mtspr mtcrf mtocrf mcrxr mfcr mfocrf mfxer mflr mfctr mtxer mtlr mtctr mfmq mfrtcl mfrtcu mtmq mtrtcl mtrtcu mullw mullw. mullwo mullwo. mulhd mulhd. mulhw mulhw. mulhdu mulhdu. mulhwu mulhwu. mulld mulld. mulldo mulldo. nand. nego nego. nor. nop orc. rldicl rldicl. rldicr rldicr. rldic rldic. rldimi rldimi. rldcl rldcl. rldcr rldcr. rlwinm rlwinm. rlwnm rlwnm. rlwimi rlwimi. rfid slw. sld sld. srw. srd. srawi srawi. sradi sradi. sraw. srad srad. stb stbu stbx stbux sth sthu sthx sthux stw stwu stwx stwux std stdu stdx stdux sthbrx stwbrx stswx stwcx. stdcx. stswi stfiwx stfs stfsu stfsx stfsux stfd stfdu stfdx stfdux subfic subo subo. subf subf. subfo subfo. subc subc. subco subco. subfc subfc. subfco subfco. subfe subfe. subfeo subfeo. subfme subfme. subfmeo subfmeo. subfze subfze. subfzeo subfzeo. lwsync ptesync tdi tdlti tdlei tdeqi tdgei tdgti tdnli tdnei tdngi tdllti tdllei tdlgei tdlgti tdlnli tdlngi tdlt tdle tdeq tdge tdgt tdnl tdne tdng tdllt tdlle tdlge tdlgt tdlnl tdlng twi twlti twlei tweqi twgei twgti twnli twnei twngi twllti twllei twlgei twlgti twlnli twlngi twlt twle tweq twge twgt twnl twne twng twllt twlle twlge twlgt twlnl twlng trap xori xoris xor. icbi isync dcbt dcbtst dcbt128 dcbz dcbzl dcbz128 dcbst dcbf eciwx ecowx eieio rfi mtmsr mtmsrd mfmsr dcba dcbi mtsr mfsr mtsrin mfsrin slbie slbia slbmte slbmfev slbmfee tlbie tlbiel tlbia tlbsync mttbl mttbu mftb mftbu attn dozi doz doz. dozo dozo. nabso nabso. mulli mulo mulo. divo divo. divso divso. rlmi rlmi. rrib rrib. maskg maskg. maskir maskir. slq slq. srq srq. sliq sliq. sriq sriq. slliq slliq. srliq srliq. sllq sllq. srlq srlq. sle sle. sre sre. sleq sleq. sreq sreq. sraiq sraiq. sraq sraq. srea srea. clcs tlbld tlbli lvebx lvehx lvewx lvx lvxl stvebx stvehx stvewx stvx stvxl lvsl lvsr mtvscr mfvscr dst dstt dstst dststt dss dssall vaddubm vaddubs vaddsbs vadduhm vadduhs vaddshs vadduwm vadduws vaddsws vaddfp vaddcuw vsububm vsububs vsubsbs vsubuhm vsubuhs vsubshs vsubuwm vsubuws vsubsws vsubfp vsubcuw vmuloub vmulosb vmulouh vmulosh vmuleub vmulesb vmuleuh vmulesh vmhaddshs vmhraddshs vmladduhm vmaddfp vmsumubm vmsummbm vmsumuhm vmsumuhs vmsumshm vmsumshs vsumsws vsum2sws vsum4ubs vsum4sbs vsum4shs vavgub vavguh vavguw vavgsb vavgsh vavgsw vand vor vxor vandc vnor vrlb vrlh vrlw vslb vslh vslw vsrb vsrab vsrh vsrah vsrw vsraw vcmpgtub vcmpgtub. vcmpgtsb vcmpgtsb. vcmpgtuh vcmpgtuh. vcmpgtsh vcmpgtsh. vcmpgtuw vcmpgtuw. vcmpgtsw vcmpgtsw. vcmpgtfp vcmpgtfp. vcmpequb vcmpequb. vcmpequh vcmpequh. vcmpequw vcmpequw. vcmpeqfp vcmpeqfp. vcmpgefp vcmpgefp. vcmpbfp vcmpbfp. vsel vpkuhum vpkuhus vpkshus vpkshss vpkuwum vpkuwus vpkswus vpkswss vpkpx vupkhsb vupkhsh vupkhpx vupklsb vupklsh vupklpx vmrghb vmrghh vmrghw vmrglb vmrglh vmrglw vspltb vsplth vspltw vspltisb vspltish vspltisw vperm vsldoi vslo vsro vmaxub vmaxsb vmaxuh vmaxsh vmaxuw vmaxsw vmaxfp vminub vminsb vminuh vminsh vminuw vminsw vminfp vrefp vrsqrtefp vlogefp vexptefp vnmsubfp vrfin vrfiz vrfip vrfim vctuxs vctsxs vcfux vcfsx                cctools-877.5   @(#)PROGRAM:ld  PROJECT:cctools-877.5
 cputype 1234567890 cpusubtype 1234567890 cputype %u cpusubtype %u any little big ppc64 x86_64 x86_64h arm64 ppc970-64 ppc i386 m68k hppa sparc m88k i860 veo arm i486 i486SX pentium i586 pentpro i686 pentIIm3 pentIIm5 pentium4 m68030 m68040 hppa7100LC veo1 veo2 veo3 veo4 armv4t armv5 xscale armv6 armv6m armv7 armv7f armv7s armv7k armv7m armv7em arm64v8             	                                                                                                                                                                               /proc/self/exe Unknown mach error virtual memory exhausted (malloc failed) virtual memory exhausted (realloc failed) fatal error: %s:   (%s)
   ;
  [  `0     p  p    P    0  0  H  p       0  P  `   @  x    p    `(  )@  +x  +  -  .  .  0(  00@  0x  p1  1  1  `2   2  `4P  @6  7   9  :0  <h  p<  <  <  <  <  <  >(  >H  @?`  P?x  @  A  A  A  A  @B   B8  @CX  PDx  F  `H   J   Y8  [P  \p  ]  ^  _   a   a   a8  cp  Pd  `d  e  g   j  `j(  lH  x  y  {   |  0}  }  0~   H  `  x          P  P8  P  @p    0     P       0  H   `  x            0  @0   P  p           (   X           0  X     `          (  `H   h    p              P@   X  @         @     8  Pp  p        `     (   0@   pX   p                @ !   !  @@!  x!   !  0!  P!  !  P!  "  0"  h"  "   "  "   "  P"  `"  #  (#  @#   X#  #  #  #  #   #  0$   $  P$   p$   $  $  $   %  (%  @%  Ph%  `%  %  %  %  `%   &  pJX&  Lp&  L&  N&  N&  N&  PO'  `P@'  pPX'  `Qx'  0n'  n'  `q'  r(  r((  r@(  tx(  0w(  w(  w(   x)  `x )  x8)   yP)  yh)  y)  @z)  `z)  z)  z)  p)  *  (*  @*  X*  p*  *  *  0*  p*  *   +  +  p0+  H+  @`+  px+  +  0+  `+  +  +  ,   ,  8,  @P,  `h,  ,  ,  0,  ,   ,  ,  -  (-  P@-  pX-  p-  -  -  -  -   -   .  .  `0.  H.  `.   x.  0.  p.  .  .  P.  /    /  8/  P/   h/  p/  /  p/  /  /   /   0  @(0  `@0  X0  p0  0  @0  p0  0  0   1  P1  p01  0H1  `1  x1   1  1  1  1   1  2  @(2  P@2  X2  p2  2  2  2   2  @2  3  P(3  `@3  X3  p3  03  03  3   3   4  `h4             zR x      *                  zR x  $      (   FJw ?;*3$"           zR x        U             4   .
   ABA    T   	   ABA    t                    E           4      0^   ABB B(B0A8D`            X    A    $      `   ACP    $        ABA D0     4   D     ABB B(B0A8A@         |  Q    AD@            8    A         @    A         8^    BAA   4     x   ABB B(B0A8D     $   $  0,   BBB A(A0   L  8              d             4   |  	   ABB B(B0A8DP      4     P5   ABB B(B0A8DP      4     Xa   ABB B(B0A8A@      $   $      BBB A(A0,   L  H   ABB B(B0A8    |      ABA                      D   BBA           A  4      }    ABB B(B0A8A@      4   $  0!    ABB B(B0A8A@         \  !              t  !                !    BAA        X"    A  4     `"   ABB B(B0A8D`      4     $   ABB B(B0A8D`      4   4  %t   ABB B(B0A8D`      4   l  &Z   ABB B(B0A8DP      4      (W   ABB B(B0A8DP      4     H)   ABB B(B0A8D`      $     *Z    ABB A(A0   <  *              T  *              l  *                *                *                *N   BADp       +    ABA      ,M    A         ,              $  ,    BAA   $   D  p-h   BBA D0        l  .                .                .                .s    A         /J    A       P/    BBA      /   AAD`  ,   $  08   BBB B(A0      4   T  2   ABB B(B0A8D          x4   BAA   4     6   ABB B(B0A8D          E               8G    AG      $   	  H    ABA G    ,   D	  HA   ABB A(G          t	  J    AG         	  J   AG         	  K              	  KX    A  4   	  @Lc   ABB B(B0A8A@         
  xN_    BBA    <
  N              T
  N   BAA      t
   P   BAA   $   
  Qo   ABB A(A0   
  S^    A     
  0T]   BBA 4   
  pV   ABB B(B0A8D        ,  b>   A       D  @c   ABA    d  dw    A       |  He   AAA        8f    D0         f<    D0    $     gm   ABB A(DP     Phg    A         ha              $   i   AAD`     D  jZ              \  j   AAD@  4   |  Hl$   ABB B(B0A8D     ,     @o   BBB B(A0DP        q7   A       8t   BBA      u    AAA      <  HvN    BAA      \  xv   A     t  0xA   A         hy{    BAA        y:                y                z   D0         0|z   D0         }    A       $  `~    A    4   <     ABB B(B0A8D        t      AD             w    A                         
                   AADp          AAA        k   AAA      <  6           ,   T  G   ABB B(A0Dp   $     0   ABB A(DP$        ABA DP     ,     `b   ABB B(A0Dp   $     
   ABA D@     4   ,  v   ABB B(B0A8Dp      4   d  |   ABB B(B0A8D     $        BBA D0          p    A    $     f   ABA DP     $     0   BBA DP     $   ,  9   ABA DP        T      ABA    t  P    ABA          ABA          ABA      p    ABA          ABA          ABA    4  P    A       L      A       d  @   AD        $     @   ABA D0              A    $        ABA D0             D0    $        ABA D0        ,      A       D  `w    A       \  N    BAA      |  c    BAA   ,     Hr   ABB B(A0D                  4     v   ABB B(B0A8DP                          4       A     L  .              d   $           $   |  g    BBB A(A0     `1                1                C                1                :                8K              4  pr    A       L     A     d  @   A  ,   |  X   ABB B(A0           8M   AAD0       h   BAA   4        ABB B(B0A8DP         $  `              <  h/    A     T      A       l      ABA      (:    A       P|    BAA                   4        ABB B(B0A8A@           p              ,  h              D  `              \  X              t  P(                h                `                h+    A                       &    A  4     y   ABB B(B0A8G        <      A       T  `    A       l                  !    A       !    A        Z    A  ,     h#   ABB B(A0           h_    AD        4        ABB B(B0A8DP         T  P              l  H    AD0            (    AD0       $         ABA D0          p           $     h   ABB A(A0                   ,  1    A       D      BBA    d      A     |      BAA   ,     h(   ABB B(A0      4     h+   ABB B(B0A8G          $   A         %    BBA 4   <  (&   ABB B(B0A8A@         t  '                ':    A       'c    A  ,     8(   BBB B(A0           )                )    ABA 4   $  )   ABB B(B0A8G        \  xFb    A       t  F   BBA $     pIS   BBB A(D@     J    A         J           4     J   ABB B(B0A8DP      4   $  `LM   ABB B(B0A8D        \  xN\    BBA    |  N                N}    ABA      O3                8O\                O5                O                `P              ,  XPW              D  P              \  P              t  P
                P
               p\+               _c               pb                hb                `b                Xb              4  Pb              L  Hb?              d  pb7              |  b?                b                bO                b[                8c_                ce                 c/              $   c              <   xd              T   d'              l   d/                 d                 d                 d                 d                 d'                 d              !  d              ,!  d              D!  d              \!  xe              t!  @f              !  8fo             !  g0             !  iO              !  i?              !  j             "  k+             "  (r              4"   r             L"  u             d"  z              |"  8{             "  0|   A     "  ~              "  ~   A     "  (              "  0?              #  XW              $#                <#  7             T#  G              l#               #               #  X?             #                #  w              #  `              #  XO              $  g              ,$                D$               \$  \              t$                 $                $                 $                $                $  '              %  0'              %  H              4%  P_              L%  %              d%                |%  ,              %  /              %  \              %  0             %  8             %               &                $&                <&  \              T&  /              l&  ?    BAA      &                &                 &  $              &                &  %    A     '                 '                4'  @    BAA      T'  0,    AD           t'  @              '  8    A       '  @   A     '  S              '                 '  *    A     (  0H    A     (  hI    BAA   $   <(     BBA G       d(  p    BAG    (  0    BAG $   (       ABA G    D   )  e    BEE E(H0H8M@l8A0A(B BBB    T)                     @     @             );C     -;C         4;C        8;C           >;C          E;C          M;C           S;C       d   ];C            a;C           f;C           k;C            p;C            v;C            {;C            ;C           ;C            B           B           B           B           B           B           B        	   B        
   #B           +B        d   ;C           ;C           ;C           ;C           ;C           ;C           ;C        6   ;C        V   ;C        
   ;C           ;C           ;C           ;C           ;C           ;C           ;C           ;C           ;C           <C           
<C           <C           <C        	   <C        
   $<C           +<C           2<C           9<C           A<C                                               @            DB            hrc                          prc                          `@     o     @            @
@            @@     
       6                                          wc            p                           @            H@            `       	              o    @     o           o    v@                                                                                                                      vc                     V@     f@     v@     @     @     @     @     @     @     @     @     @     @     &@     6@     F@     V@     f@     v@     @     @     @     @     @     @     @     @     @     @     &@     6@     F@     V@     f@     v@     @     @     @     @     @     @     @     @     @     @     &@     6@     F@     V@     f@     v@     @     @     @     @     @     @     @                                        GNU assembler version 1.38      'C     LB     TB     _B     gB     nB               \c     c                                                                                                     ************************************************ 	*******
**************************
*********************************************************************************************************************************************************                                                                                                                                                                                                                                                                                                                                                                                                                                                                      GCC: (Debian 4.9.2-10) 4.9.2 Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0) GCC: (Debian 4.8.4-1) 4.8.4  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .fini_array .jcr .data.rel.ro .dynamic .got .got.plt .data .bss .comment                                     @                   @                   <@                   `@                    @                   @@                   @
@                   v@                  	 @                  
 H@                   @                   @                   @@                   @                   DB                   PB                   =C                   HC                   hrc                   prc                   xrc                   rc                    vc                   wc                   wc                   yc                   ~c                                                            xrc                   @             .     `@             A     @             W     ~c            f     prc                  @                  hrc                                      $c                 c                  c                 0c                 c                 c                 B     B                          
    p;@                               $                   3     c            B    <c            Y    @c            k    Hc            {    B                                   Q@               B                B                B     P           `\@     	                                                 B     (            "B     <           @"B     <            B     (            B     (           !B     &           @!B     "       
    p!B                !B                !B            "    !B     6       *     $B            1    $B     <       9    $B     <       A    $B            H    $B            O    $B            V    
$B            ]    $B     
       d     $B            k    @$B     &       r    p$B     <       y    t B            ~                                                                                                                      c                                   Pc                $c            $    (c            1    Pc            R    0c            _    8c            m    @c            y                       @                                  Xc                                                      9B                 ,B               c            *    @           =    c            E    @           R    c            [    @}c            n     c            z     c                c                c                c     @           c                p@               @               c                @@     ]          c                2B     H           03B     x          `@     6       #     A     r      +    @     
       9     @            F    @     ^       X    @     G      _     A            m    @           t    A           {     c                @                `@     z          A     w           @                @               @                A               @                @     k          0A                
A                p@     b          (c                pA           #     A           *    c            C    @     
      J    A           T    PA            a    A            m    @A            }     @               @     w           @               @	A                @     v          p@                @               !c                  A     f           A                 A            "    A            ;    A            M    
A            ^    p@     |      i     A     9      n    c            }    @:B               `A     N           A     c                                                 c                c                c                 c                c                c     (       $    00A            9     c            p    c            u                       @c                ,c                4c                0c                (c                8c                NA                Hc                                                      pc            	    ~c            	    c            	    c            	    c            +	    ~c            H	    ~c            b	    pOA     #      y	    @[A     (      	    hc            	    c            	    dc            	     QA           	    c            	    c            	    c            
    c            )
    c            E
    `c            X
    PA           q
    A            
    xc            
                   
    bB            
    `cB     `       
    hc            
    pc            
    Xc            
    `c            	    dc            7    Pc            A    Hc            I    A     M      S    A           ]    \B            h    `hB           t    A     :           pA                A     c           A               cB               Rc                Qc                                                      rc                                                 $                   +                   1                   <                                       E    `rC             S    xrc                                  _     prc             p     vc             y     hrc                 wc                 'A     @          04A                @               @A                @B               A     W           A                                 9   pA     ,       D    @     w       ^    $A     C       o    z@     N                                E@                                     4A     (           `@               TA                Po@               A     c          /A                c            #     @             5    0A           >    Xc     @       D   A           [    po@            h    A               `B     /           PA                `@     c          A     %           B     @          pA     0         PA            	                                          :                     N    0}@            c                     x   B                                                            yc                 z@                l@     D          A               A                @{c                `B                                  4   c            =   pA            U    B     \       r     @           z   A     '          A     7          c                Pz@                @     _                                ~c                 |@     M           /A     /       &    @c            .                     A    `p@           M   A           g    ~c            z    YA               @4A               A                Pc                                     Pc                                      @           *    B            =    UA            S                     f    A     3            @                ZA                ~c                 c                ~c                 }@     h          1A               B     ,          @A     /       1    A     v      =    0@           H                     \   A            o   PA     _       |    ~c               pA               pA                A                 @     J           %A     K           DB                A     g       &    VA            2                     F                     ]                     o     B            {    p@                 t@     t          @$A     1          A                A                SA                0@                                                      %    `MA            ?    @            L                     b    `@            w    B     ?            c                0@     7          zc     H           c     @           (A     X          NA     !                                3A                u@     Z                               A            ;    p@     o      N   @A     '       f    A            u    3A                ;@                A     w          0A     ?          @     m                               Z@     ,         0	B                                                           4A     &       5    NA     !       =   @A            R                     g    PA     _       t     .A                                   A               p	B     H          A     7           |c                c                @@              A     /           zc             #    0@     8      8    c            L   A     ?       Z    p B            }                         Xc                                     @                                     A                                     {@            .   B           C     @           M    pC@           W    SA            f    [B            s    c                                     OA     Z           @                p@     A          yc                 B                c                                    A     ?       )   A            B                     V    %A     1       r    yc            }   A                 @     X           #A     $          `A                c               @A     \           @                                    @f@     5          @c               PA     +      :    Pzc            E                      T    4A     y      a    P#A             p   yc             }    @                [B                A                0A     :                               PA     ?           0B     %           xc               A     [          A            .    PB            =    c            U    -@     E       k    3A            y   A     }           c               A     _           @                P@     .
          B     $          A                %A     r           @r@              A            %    Pc     4       4    @     >      ?    c            K    0YA            V   A     '       j                         8c               A                p+A               @     A         A                y@     Z           @Q@     ^          PA                A     b           B     e          0A           5    pz@            D                     X    0@     {       p    @A     S      x   A     \           #@     	          h@               A               @     <          pB                [B                c                0#A             #                     7    c            H   PA            d    `z@            u    @A               0-@                @p@                c                 c                 B                :C                p@                w@     W          4A            	     @                  0%B           .     [B            ;     A     /       O    	B     I       W     B     S       _     Q@            p    A                 pc                 P\@                  c                 @YA     1            P@     Q           pA     
      !    c            !    p@            !   pA            5!    `4A     +       I!                     ^!    @     a       r!    z@            !   A     O       !    ~c             !    c            !    Pc            !   A           !    MA            !    xc            	"    .@     ^      "                     !"    c            1"    @     s       :"   A            S"    k@            ]"    m@            g"    bB            v"    A           "    ZA            "    @     U      "    Tc            "   A            "     B           "   A     O       "                     #   PA     G       %#   A           =#    "B           [#   pA           n#     @     $      s#    1A            #   PA           #    #A     g       #    A            #     zc     0       #    c            #   PA     \       #    @           #                     $                     $    `x@           $$    B            6$    @     :       D$    0A            X$    g@     a      d$                     w$    c            $    A           $   B            $    @@           $                      $   A     W       $    c            $    @     g       %                     )%    n@            4%     zc            C%    c            W%   pA            f%    `&A           |%    p#A     .       %                     %    l@            %   `A     
       %    i@           %    n@     }       %   A     \       %   A     O       &    @     N       !&                     5&   A            G&   A     5       e&   @	B     *       n&    p\A     +      |&    A     o      &    01A     |       &    c            &                     &    p@            &   0A           &    c            '                     '    c             '                     4'   ~c             @'    [B            P'    Pc            Y'                      s'    0Q@            '    :C     '       '   `A     ?       '   @A            '    3A            '   B            '    $A     1       (    c            #(   pA     '       >(    [B            Q(                     g(     @     Z       p(   B            v(    `c            (   A            (    c            (   A     e       (    0c            (    yc            (    @|c            (    @~c     `       (    o@            (    pB            (   A            )    Dc            ')    p@            :)    @             @)    `@           K)     }@            [)    [B            l)     *A     M      x)   A            )    VA           )    c            )                     )   
B           )   @A            )    [@            )                     *                     *    ~c            3*    c            F*    P%A     :       ]*   PA     +      p*   `A             crtstuff.c __JCR_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.6661 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry ../app.c add_newlines lex old_state out_buf out_string state symbol_chars ../as.c got_sig ../atof-generic.c ../atof-ieee.c atof_ieee.bits bits_left_in_littlenum littlenum_pointer littlenums_left mask ../expr.c expr op_encoding op_rank op_size operand ../fixes.c ../flonum-const.c minus_1 minus_10 minus_11 minus_2 minus_3 minus_4 minus_5 minus_6 minus_7 minus_8 minus_9 plus_1 plus_10 plus_11 plus_2 plus_3 plus_4 plus_5 plus_6 plus_7 plus_8 plus_9 zero ../flonum-copy.c ../flonum-mult.c ../frags.c ../hash.c ../hex-value.c ../input-file.c preprocess ../input-scrub.c as_where_ProjectBuilder.directory_buf buffer_length buffer_start find_an_include_file.name_buffer partial_size partial_where save_source ../layout.c is_assembly_time_constant_subtraction_expression ../messages.c print_architecture_banner.printed ../obstack.c ../read.c attribute_names builtin_sections count_lines demand_copy_string dump_fp expand_macro if_depth is_end_of_line_tab last_states ma_hash macro_depth macro_name macros macros_on next_char_of_string parse_a_buffer po_hash ppcasm_parse_a_buffer ppcasm_po_hash ppcasm_pseudo_table pseudo_table s_abort s_align s_align_bytes s_align_ptwo s_builtin_section s_comm s_data_region s_desc s_dump s_dump.null_string s_else s_elseif s_end_data_region s_endif s_fill s_if s_incbin s_include s_indirect_symbol s_inlineasm s_lazy_reference s_lcomm s_lcomm.bss s_leb128 s_load s_load.dump_symbol_lastP s_lsym s_machine s_macros_off s_macros_on s_no_dead_strip s_org s_ppcasm_end s_private_extern s_reference s_section s_secure_log_reset s_secure_log_unique s_secure_log_used s_set s_subsections_via_symbols s_symbol_resolver s_weak_def_can_be_hidden s_weak_definition s_weak_reference s_zerofill stab the_cond_state type_names write_macro write_symbol ../sections.c ../symbols.c fb_label_count fb_label_instances fb_label_max fb_label_name.symbol_name_build fb_labels fb_low_counter make_stab_for_symbol make_subprogram_for_symbol.last_dwarf2_subprogram_info temp ../write_object.c extdefsyms iextdefsym iundefsym nextdefsym nlocalsym nundefsym qsort_compare undefsyms ../xmalloc.c ../dwarf2dbg.c all_segs current dirs dirs_allocated dirs_in_use dwarf2_gen_line_info.filenum dwarf2_gen_line_info.line dwarf2_gen_line_info_1 emit_inc_line_addr files files_allocated files_in_use get_filenum get_filenum.last_used get_filenum.last_used_dir_len get_line_subseg.last_line_subseg get_line_subseg.last_seg get_line_subseg.last_subseg loc_directive_seen macho_dwarf2_emit_offset out_inc_line_addr sizeof_address ../ppc.c CR_fields condition_symbols error_param_count error_param_message md_assemble.file_spec md_assemble.line_spec md_assemble.syntax_warning_issued_for_AT_bits no_ppc601 op_hash parse_num parse_reg ppc_macros ppc_opcodes s_flag_reg s_no_ppc601 s_noflag_reg s_reg special_registers static_branch_prediction static_branch_prediction_specified apple_version.c arch.c arch_flags best_arch.c bytesex.c port.c rnd.c allocate.c fatals.c __FRAME_END__ __JCR_END__ __init_array_end _DYNAMIC __init_array_start _GLOBAL_OFFSET_TABLE_ fb_label_name symbol_get_frag ppcasm_read_begin md_end __libc_csu_fini get_segalign_from_flag swap_i386_exception_state __ctype_toupper_loc@@GLIBC_2.3 swap_nlist demand_empty_rest_of_line is_section_debug input_file_open __uflow@@GLIBC_2.2.5 gen_to_words getenv@@GLIBC_2.2.5 S_IS_LOCAL s_space dwarf2_emit_label frag_now_fix_octets cpusubtype_execute symbol_create physical_input_file free@@GLIBC_2.2.5 md_begin notes swap_x86_float_state64 frag_now_fix swap_version_min_command swap_xar_header md_parse_option _obstack_newchunk swap_entry_point_command map_fd swap_ppc_thread_state64_t swap_twolevel_hints_command abort@@GLIBC_2.2.5 __errno_location@@GLIBC_2.2.5 unlink@@GLIBC_2.2.5 input_scrub_new_file strncpy@@GLIBC_2.2.5 system_fatal strncmp@@GLIBC_2.2.5 _ITM_deregisterTMCloneTable data_start input_file_is_open frag_new swap_rpath_command swap_sub_client_command hex_value vm_deallocate strcpy@@GLIBC_2.2.5 progname swap_arm_thread_state_t swap_dylib_table_of_contents s_globl swap_prebound_dylib_command swap_hppa_integer_thread_state file_name hash_print_statistics obstack_free qsort@@GLIBC_2.2.5 scrub_file input_scrub_begin symbol_assign_index now_seg fread@@GLIBC_2.2.5 hash_insert swap_hppa_fp_thread_state stdin@@GLIBC_2.2.5 dwarf2dbg_estimate_size_before_relax symbol_temp_new get_stack_addr_from_flag bad_error __xpg_strerror_r@@GLIBC_2.3.4 dwarf2_file_number readlink@@GLIBC_2.2.5 layout_addresses mach_timebase_info dwarf2_directive_file write@@GLIBC_2.2.5 get_arch_family_from_cputype get_known_segmented_expression dwarf2dbg_convert_frag scrub_string scrub_last_string _edata input_scrub_next_buffer indirect_symbol_new mach_absolute_time swap_dylib_command section_new float_cons fclose@@GLIBC_2.2.5 swap_ident_command swap_section vm_page_size swap_i386_thread_state swap_m68k_thread_state_regs md_estimate_size_before_relax as_file_and_line section_has_fixed_size_data _fini swap_routines_command_64 dwarf2_file strlen@@GLIBC_2.2.5 setbuffer@@GLIBC_2.2.5 mmap@@GLIBC_2.2.5 getattrlist as_where_ProjectBuilder hash_replace is_section_coalesced swap_load_command swap_dylinker_command dwarf2_emit_insn is_end_of_line strchr@@GLIBC_2.2.5 printf@@GLIBC_2.2.5 number_to_chars_bigendian sprint_value _IO_putc@@GLIBC_2.2.5 seen_at_least_1_file _NSGetExecutablePath layout_line stringer zero_address_frag frags decode_local_label_name xrealloc strrchr@@GLIBC_2.2.5 S_IS_DEFINED hash_find gettimeofday@@GLIBC_2.2.5 swap_linker_option_command read_a_source_file swap_encryption_command sections_begin symbol_set_tc atof_generic swap_arm_thread_state64_t swap_sparc_thread_state_fpu s_abs memset@@GLIBC_2.2.5 try_to_make_absolute rnd index@@GLIBC_2.2.5 getcwd@@GLIBC_2.2.5 symbol_set_value_now xmalloc swap_fvmfile_command strncat@@GLIBC_2.2.5 dwarf2_where symbol_new close@@GLIBC_2.2.5 SWAP_LONG_LONG reallocate swap_mach_header dwarf2_loc_mark_labels inlineasm_column_number read_begin swap_nlist_64 generic_floating_point_number find_an_include_file physical_input_line swap_fat_arch table_size_of_flonum_powers_of_ten fputc@@GLIBC_2.2.5 dwarf2_subprograms_info memchr@@GLIBC_2.2.5 new_logical_line __libc_start_main@@GLIBC_2.2.5 swap_x86_state_hdr fgets@@GLIBC_2.2.5 input_file_give_next_buffer swap_dylib_reference as_perror atof_ieee dwarf2_set_isa md_FLT_CHARS symbol_rootP calloc@@GLIBC_2.2.5 dwarf2_gen_line_info s_line as_warn_where_with_column __data_start mach_host_self symbol_lastIndexedP strcmp@@GLIBC_2.2.5 swap_ppc_exception_state_t get_stack_size_from_flag signal@@GLIBC_2.2.5 is_section_cstring_literals debug_type SWAP_DOUBLE _obstack_begin get_section_by_nsect swap_sparc_thread_state_regs include get_byte_sex_from_flag as_fatal fprintf@@GLIBC_2.2.5 fix_new md_cpusubtype swap_m88k_thread_state_xrf_t N_TYPE_seg __gmon_start__ write_object section_symbol __dso_handle as_bad md_cputype md_convert_frag symbol_table_insert memcpy@@GLIBC_2.14 swap_mach_header_64 vm_allocate mach_task_self_ swap_segment_command_64 swap_m68k_thread_state_user_reg _IO_stdin_used subsections_via_symbols restore_scrub_context symbol_get_tc get_arch_name_from_types flag_gregs swap_dyld_info_command output_leb128 do_scrub_next_char host_info get_host_byte_sex symbol_begin hash_jam swap_m88k_thread_state_user_t generic_bignum s_app_file apple_flags dwarf2_loc swap_fvmlib_command __xstat@@GLIBC_2.2.5 frchain_now swap_sub_umbrella_command colon s_endmacro swap_fat_header hash_traverse expression swap_dysymtab_command md_number_to_chars __libc_csu_init swap_m88k_thread_state_grf_t input_file_end malloc@@GLIBC_2.2.5 add_to_macro_definition md_atof swap_ranlib do_scrub_next_char_from_string flonum_copy swap_m88110_thread_state_impl_t get_absolute_expression swap_dylib_module_64 md_line_comment_chars f_in section_set ungetc@@GLIBC_2.2.5 include_defaults swap_source_version_command input_file_begin md_assemble save_scrub_context hash_die _end target_big_endian mach_port_deallocate apple_version read_an_include_file hash_find_n symbol_temp_make _start flonum_positive_powers_of_ten md_EXP_CHARS swap_symtab_command savestr strlcpy make_expr_symbol swap_prebind_cksum_command input_line_pointer S_GET_SEGMENT logical_input_file dwarf2_directive_loc_mark_labels int_to_gen cpusubtype_findbestarch flag_registers as_warn swap_sub_framework_command symbol_temp_new_now realloc@@GLIBC_2.2.5 totally_ignore_line input_file_buffer_size swap_segment_command __bss_start inlineasm_checks sy_hash swap_i860_thread_state_regs number_to_chars_littleendian buffer_limit main bcopy@@GLIBC_2.2.5 secure_log_file as_where swap_sub_library_command frag_grow frag_more md_relax_table md_number_to_imm dwarf2dbg_relax_frag do_scrub_begin arch_multiple swap_linkedit_data_command strmode swap_ppc_float_state_t memmove@@GLIBC_2.2.5 swap_hppa_frame_thread_state swap_x86_thread_state64 flonum_negative_powers_of_ten swap_twolevel_hint cons symbol_find swap_indirect_symbols get_section_by_name get_segprot_from_flag seg_name input_dir swap_data_in_code_entry s_macro open@@GLIBC_2.2.5 access@@GLIBC_2.2.5 hash_delete mach_error_string sizeof_leb128 symbol_table_lookup fix_new_exp fopen@@GLIBC_2.2.5 text_nsect swap_i386_float_state mach_fatal add_last_frags_to_sections _Jv_RegisterClasses swap_x86_debug_state64 inlineasm_line_number ignore_rest_of_line vfprintf@@GLIBC_2.2.5 frag_align version_string inlineasm_file_name get_arch_flags fb_label_instance_inc seg_not_empty_p strtoul@@GLIBC_2.2.5 frag_wane force_cpusubtype_ALL_for_cputype flonum_multip frag_var get_arch_from_flag swap_routines_command demand_copy_C_string strcat@@GLIBC_2.2.5 swap_uuid_command get_stack_direction_from_flag allocate dwarf2_finish swap_ppc_thread_state_t symbol_find_or_make force_cpusubtype_ALL sprintf@@GLIBC_2.2.5 as_warn_where swap_relocation_info symbol_lastP exit@@GLIBC_2.2.5 layout_file fwrite@@GLIBC_2.2.5 __TMC_END__ md_pseudo_table flagseen _ITM_registerTMCloneTable expr_build_uconstant ldVersionString swap_x86_debug_state32 get_shared_region_size_from_flag S_GET_NAME swap_dylib_module is_section_non_lazy_symbol_pointers specific_archflag swap_encryption_command_64 md_target_byte_sex strerror@@GLIBC_2.2.5 s_ignore fatal _obstack swap_symseg_command doing_include swap_section_64 frchain_root archflag_cpusubtype lex_type abs_symbol hash_new host_statistics swap_m68k_thread_state_68882 now_subseg bump_line_counters _init pseudo_set input_scrub_end md_comment_chars local_colon SWAP_FLOAT dwarf2_directive_loc frag_now strstr@@GLIBC_2.2.5 makestr swap_x86_exception_state64 get_symbol_end __ctype_tolower_loc@@GLIBC_2.3 __ctype_b_loc@@GLIBC_2.3 stderr@@GLIBC_2.2.5 logical_input_line is_end_section_address cpusubtype_combine swap_thread_command                                                                                   @                                          #             @                                          1             <@     <      $                              H             `@     `                                 D   o        @            <                             N             @@     @                                 V             @
@     @
      6                             ^   o       v@     v                                  k   o       @           P                            z             H@     H      `                                  B       @           p                                       @                                                      @@     @                                               @           R                                         DB     D     	                                           PB     P     .                                         =C     =     
                                          HC     H     )                                          hrc     hr                                                prc     pr                                                xrc     xr                                                rc     r                                                vc      v                                             wc     w                                               wc     w                                             yc     y                                              ~c     ~     '                                  0               ~                                                        N                                                        h     @                         	                            *                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc-check.c                              0100644 0001750 0001750 00000010143 12612724204 023041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "ppc-opcode.h"

static int bits(
    uint32_t width);

static char *cond[] = { "lt", "gt", "eq", "un"};
static char *pred[] = { "+", "-" };

int
main(
int argc,
char *argv[],
char *envp[])
{
    int32_t i, j, x, d, p, doing_jbsr, add_pred;

	add_pred = 0;
	doing_jbsr = 0;
	p = 0;
	for(i = 0; *(ppc_opcodes[i].name) != '\0'; i++){
	    if(strcmp("jbsr", ppc_opcodes[i].name) == 0)
		continue;
	    printf("\t%s", ppc_opcodes[i].name);
	    if(IS_BRANCH_CONDITIONAL(ppc_opcodes[i].opcode)){
		if(add_pred == 1){
		    p = bits(5) & 1;
		    printf("%s", pred[p]);
		}
	    }
	    if(ppc_opcodes[i].ops[0].type == NONE)
		printf("\n");
	    else
		printf("\t");
	    d = 0;
	    for(j = 0; j < 5 && ppc_opcodes[i].ops[j].type != NONE; j++){
		switch(ppc_opcodes[i].ops[j].type){
		case PCREL:
		    if(doing_jbsr)
			printf("L1");
		    else
			printf("_relitive");
		    break;
		case BADDR:
		    printf("_absolute");
		    break;
		case D:
		    printf("0x%04x(", bits(16));
		    d = 1;
		    break;
		case DS:
		    printf("0x%04x(", bits(14) << 2);
		    d = 1;
		    break;
		case SI:
		case UI:
		case HI:
		    printf("0x%04x", bits(16));
		    break;
		case GREG:
		    if((strcmp("lmw", ppc_opcodes[i].name) == 0 && j == 0) ||
		       (strcmp("lswi", ppc_opcodes[i].name) == 0 && j == 0))
			printf("r31");
		    else
			printf("r%d", bits(5) );
		    break;
		case G0REG:
		    printf("r%d", bits(5) | 0x1 );
		    break;
		case FREG:
		    printf("f%d", bits(5) );
		    break;
		case SGREG:
		    printf("sr%d", bits(4) );
		    break;
		case SPREG:
		    printf("%d", bits(10) );
		    break;
		case BCND:
		    printf("cr%d+%s", bits(3), cond[bits(2)] );
		    break;
		case CRF:
		case CRFONLY:
		    x = bits(3);
		    printf("cr%ld", x == 0 ? 1 : x);
		    break;
		case sh:
		    printf("%d", bits(6) );
		    break;
		case mb:
		    printf("%d", bits(6) );
		    break;
		case NUM0:
		case NUM:
		    if(j == 0 &&
		       IS_BRANCH_CONDITIONAL(ppc_opcodes[i].opcode)){
		 	if(strcmp("bc", ppc_opcodes[i].name) == 0 ||
		 	   strcmp("bca", ppc_opcodes[i].name) == 0 ||
		 	   strcmp("bcl", ppc_opcodes[i].name) == 0 ||
		 	   strcmp("bcla", ppc_opcodes[i].name) == 0 ||
		 	   strcmp("bcctr", ppc_opcodes[i].name) == 0 ||
		 	   strcmp("bcctrl", ppc_opcodes[i].name) == 0 ||
		 	   strcmp("bclr", ppc_opcodes[i].name) == 0 ||
		 	   strcmp("bclrl", ppc_opcodes[i].name) == 0 ||
		 	   strcmp("bctr", ppc_opcodes[i].name) == 0 ||
		 	   strcmp("bctrl", ppc_opcodes[i].name) == 0 ||
		 	   strcmp("blr", ppc_opcodes[i].name) == 0 ||
		 	   strcmp("blrl", ppc_opcodes[i].name) == 0){
			   if(j == 0){
				printf("20");
				break;
			   }
			   if(j == 1){
				printf("31");
				break;
			   }
			}
			x = bits(ppc_opcodes[i].ops[j].width);
			if(ppc_opcodes[i].ops[2].type == PCREL)
			    if(p == 0) /* + with negative disp */
				x &= 0xfffffffe; 
			    else
				x |= 1; 
			else
			    if(p == 0) /* + with positive disp */
				x |= 1; 
			    else
				x &= 0xfffffffe; 
			if(x == 20)
			    x = 0;
			printf("%ld", x);
		    }
		    else
			printf("%d", bits(ppc_opcodes[i].ops[j].width) );
		    break;
		case SNUM:
		    printf("%d", bits(ppc_opcodes[i].ops[j].width - 1) );
		    break;
		case NONE:
		    break;
		case ZERO:
		    printf("0");
		    break;
		case JBSR:
		    printf("_mong_branch_stub");
		    doing_jbsr = 1;
		    break;
		case FXM:
		    printf("%d", 1 << bits(3));
		    break;
		case MBE:
		    printf("%d", bits(ppc_opcodes[i].ops[j].width));
		    break;
		case VREG:
		    printf("v%d", bits(5) );
		    break;
		default:
		    fprintf(stderr, "Unknown parameter type\n");
		    exit(1);
		}
		if(j == 4 || ppc_opcodes[i].ops[j+1].type == NONE){
		    if(d == 1)
			printf(")\n");
		    else{
			if(doing_jbsr){
			    printf("\n");
			    printf("L1:\n");
			    doing_jbsr = 0;
			}
			else
			    printf("\n");
		    }
		}
		else{
		    if(ppc_opcodes[i].ops[j].type != D &&
		       ppc_opcodes[i].ops[j].type != DS)
			printf(",");
		}
	    }
	}
	return(0);
}

static
int
bits(
uint32_t width)
{
     static int x = 1;

	x = (x + 1) & ((1 << width) - 1);
	return(x);
}
                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc-opcode.h                             0100644 0001750 0001750 00000207536 12612724204 023260  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <stdint.h>

/* operands types */
enum optype {
    NONE,	/* no operand */
    JBSR,	/* jbsr pseudo op */
    PCREL,	/* PC relative (branch offset) */
    BADDR,	/* Branch address (sign extended absolute address) */
    D,		/* 16 bit displacement */
    DS,		/* 14 bit displacement (double word) */
    SI,		/* signed 16 bit immediate */
    UI,		/* unsigned 16 bit immediate */
    HI,		/* high 16 bit immediate (with truncation) */
    GREG,	/* general register */
    G0REG,	/* general register r1-r31 or 0 */
    FREG,	/* float register */
    VREG,	/* vector register */
    SGREG,	/* segment register */
    SPREG,	/* special register (or 10 bit number, 5 bit halves reversed) */
    BCND,	/* branch condition opcode */
    CRF,	/* condition register field */
    CRFONLY,	/* condition register field only no expression allowed */
    sh,		/* 6 bit number (0 - 63) (sh field, split and reversed) */
    mb,		/* 6 bit number (0 - 63) (mb field, mb5 || mb0:4 reversed) */
    NUM,	/* number */
    SNUM,	/* signed number */
    NUM0,	/* number (where 1<<width is the same as 0) */
    MBE,	/* mask defined by MB and ME fields */
    FXM,	/* 8-bit mask with only one bit set */
    ZERO	/* the number zero */
};

struct op {
   uint32_t offset:5;
   uint32_t width:5;
   enum optype   type:6;
};

/*
 * These defines are use in the cpus field of the instructions.  If the field
 * is zero it can execute on all cpus.  The defines are or'ed together.  This
 * information is used to set the cpusubtype in the resulting object file.
 */
#define CPU601		0x1
#define IMPL64		0x2
#define OPTIONAL	0x4
#define VMX		0x8
#define CPU970		0x10 /* added to OPTIONAL insts that the 970 has */

struct ppc_opcode {
   uint32_t opcode;
   char         *name;
   struct op	 ops[5];
   uint32_t cpus;
};

#define IS_BRANCH_CONDITIONAL(opcode) \
	(((((opcode) & 0xfc0003fe) == 0x4c000020) || \
	  (((opcode) & 0xfc000000) == 0x40000000)) && \
	   (((opcode) & 0x03e00000) != 0x02800000) )
#define Y_BIT (1 << 21)

static const struct ppc_opcode ppc_opcodes[] = {
 { 0x38000000, "addi",    {{21,5,GREG}, {16,5,G0REG},{0,16,SI}} },
 { 0x38000000, "li",      {{21,5,GREG}, {0,16,SI}} },
 { 0x3c000000, "addis",   {{21,5,GREG}, {16,5,G0REG},{0,16,HI}} },
 { 0x3c000000, "lis",     {{21,5,GREG}, {0,16,HI}} },
 { 0x30000000, "addic",   {{21,5,GREG}, {16,5,GREG}, {0,16,SI}} },
 { 0x34000000, "addic.",  {{21,5,GREG}, {16,5,GREG}, {0,16,SI}} },
 { 0x7c000214, "add",     {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000215, "add.",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000614, "addo",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000615, "addo.",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },

 { 0x7c000014, "addc",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000015, "addc.",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000414, "addco",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000415, "addco.",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },

 { 0x7c000114, "adde",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000115, "adde.",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000514, "addeo",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000515, "addeo.",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },

 { 0x7c0001d4, "addme",   {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c0001d5, "addme.",  {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c0005d4, "addmeo",  {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c0005d5, "addmeo.", {{21,5,GREG}, {16,5,GREG}} },

 { 0x7c000194, "addze",   {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c000195, "addze.",  {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c000594, "addzeo",  {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c000595, "addzeo.", {{21,5,GREG}, {16,5,GREG}} },

 { 0x70000000, "andi.",   {{16,5,GREG}, {21,5,GREG}, {0,16,UI}} },
 { 0x74000000, "andis.",  {{16,5,GREG}, {21,5,GREG}, {0,16,UI}} },
 { 0x7c000038, "and",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000039, "and.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },

 { 0x7c000078, "andc",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000079, "andc.",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },

 { 0x48000000, "b",       {{2,24,PCREL}} },
 { 0x48000002, "ba",      {{2,24,BADDR}} },
 { 0x48000001, "bl",      {{2,24,PCREL}} },
 { 0x48000003, "bla",     {{2,24,BADDR}} },

 { 0x48000001, "jbsr",    {{0,0,JBSR}, {2,24,PCREL}} },
 { 0x48000000, "jmp",     {{0,0,JBSR}, {2,24,PCREL}} },

 { 0x40000000, "bc",      {{21,5,NUM},  {16,5,NUM}, {2,14,PCREL}} },
 { 0x40000002, "bca",     {{21,5,NUM},  {16,5,NUM}, {2,14,BADDR}} },
 { 0x40000001, "bcl",     {{21,5,NUM},  {16,5,NUM}, {2,14,PCREL}} },
 { 0x40000003, "bcla",    {{21,5,NUM},  {16,5,NUM}, {2,14,BADDR}} },

 { 0x4c000420, "bcctr",   {{21,5,NUM},  {16,5,NUM}} },
 { 0x4c000420, "bcctr",   {{21,5,NUM},  {16,5,NUM}, {11,2,NUM}} },
 { 0x4c000421, "bcctrl",  {{21,5,NUM},  {16,5,NUM}} },
 { 0x4c000421, "bcctrl",  {{21,5,NUM},  {16,5,NUM}, {11,2,NUM}} },
 { 0x4c000020, "bclr",    {{21,5,NUM},  {16,5,NUM}} },
 { 0x4c000020, "bclr",    {{21,5,NUM},  {16,5,NUM}, {11,2,NUM}} },
 { 0x4c000021, "bclrl",   {{21,5,NUM},  {16,5,NUM}} },
 { 0x4c000021, "bclrl",   {{21,5,NUM},  {16,5,NUM}, {11,2,NUM}} },

/* Basic branch mnemonics (assember extended mnemonics) */
/* { 0x42800000, "b",       {{2,14,PCREL}} }, overlaps */
/* { 0x42800001, "bl",      {{2,14,PCREL}} }, overlaps */
 { 0x41800000, "bt",      {{16,5,BCND}, {2,14,PCREL}} },
 { 0x41800001, "btl",     {{16,5,BCND}, {2,14,PCREL}} },
 { 0x40800000, "bf",      {{16,5,BCND}, {2,14,PCREL}} },
 { 0x40800001, "bfl",     {{16,5,BCND}, {2,14,PCREL}} },
 { 0x42000000, "bdnz",    {{2,14,PCREL}} },
 { 0x42000001, "bdnzl",   {{2,14,PCREL}} },
 { 0x41000000, "bdnzt",   {{16,5,BCND}, {2,14,PCREL}} },
 { 0x41000001, "bdnztl",  {{16,5,BCND}, {2,14,PCREL}} },
 { 0x40000000, "bdnzf",   {{16,5,BCND}, {2,14,PCREL}} },
 { 0x40000001, "bdnzfl",  {{16,5,BCND}, {2,14,PCREL}} },
 { 0x42400000, "bdz",     {{2,14,PCREL}} },
 { 0x42400001, "bdzl",    {{2,14,PCREL}} },
 { 0x41400000, "bdzt",    {{16,5,BCND}, {2,14,PCREL}} },
 { 0x41400001, "bdztl",   {{16,5,BCND}, {2,14,PCREL}} },
 { 0x40400000, "bdzf",    {{16,5,BCND}, {2,14,PCREL}} },
 { 0x40400001, "bdzfl",   {{16,5,BCND}, {2,14,PCREL}} },

/* { 0x42800002, "ba",      {{2,14,BADDR}} }, overlaps */
/* { 0x42800003, "bla",     {{2,14,BADDR}} }, overlaps */
 { 0x41800002, "bta",     {{16,5,BCND}, {2,14,BADDR}} },
 { 0x41800003, "btla",    {{16,5,BCND}, {2,14,BADDR}} },
 { 0x40800002, "bfa",     {{16,5,BCND}, {2,14,BADDR}} },
 { 0x40800003, "bfla",    {{16,5,BCND}, {2,14,BADDR}} },
 { 0x42000002, "bdnza",   {{2,14,BADDR}} },
 { 0x42000003, "bdnzla",  {{2,14,BADDR}} },
 { 0x41000002, "bdnzta",  {{16,5,BCND}, {2,14,BADDR}} },
 { 0x41000003, "bdnztla", {{16,5,BCND}, {2,14,BADDR}} },
 { 0x40000002, "bdnzfa",  {{16,5,BCND}, {2,14,BADDR}} },
 { 0x40000003, "bdnzfla", {{16,5,BCND}, {2,14,BADDR}} },
 { 0x42400002, "bdza",    {{2,14,BADDR}} },
 { 0x42400003, "bdzla",   {{2,14,BADDR}} },
 { 0x41400002, "bdzta",   {{16,5,BCND}, {2,14,BADDR}} },
 { 0x41400003, "bdztla",  {{16,5,BCND}, {2,14,BADDR}} },
 { 0x40400002, "bdzfa",   {{16,5,BCND}, {2,14,BADDR}} },
 { 0x40400003, "bdzfla",  {{16,5,BCND}, {2,14,BADDR}} },

 { 0x4e800020, "blr",     },
 { 0x4e800020, "blr",     {{11,2,NUM}} },
 { 0x4e800021, "blrl",    },
 { 0x4e800021, "blrl",    {{11,2,NUM}} },
 { 0x4d800020, "btlr",    {{16,5,BCND}} },
 { 0x4d800020, "btlr",    {{16,5,BCND}, {11,2,NUM}} },
 { 0x4d800021, "btlrl",   {{16,5,BCND}} },
 { 0x4d800021, "btlrl",   {{16,5,BCND}, {11,2,NUM}} },
 { 0x4c800020, "bflr",    {{16,5,BCND}} },
 { 0x4c800020, "bflr",    {{16,5,BCND}, {11,2,NUM}} },
 { 0x4c800021, "bflrl",   {{16,5,BCND}} },
 { 0x4c800021, "bflrl",   {{16,5,BCND}, {11,2,NUM}} },
 { 0x4e000020, "bdnzlr",  },
 { 0x4e000020, "bdnzlr",  {{11,2,NUM}} },
 { 0x4e000021, "bdnzlrl", },
 { 0x4e000021, "bdnzlrl", {{11,2,NUM}} },
 { 0x4d000020, "bdnztlr", {{16,5,BCND}} },
 { 0x4d000020, "bdnztlr", {{16,5,BCND}, {11,2,NUM}} },
 { 0x4d000021, "bdnztlrl",{{16,5,BCND}} },
 { 0x4d000021, "bdnztlrl",{{16,5,BCND}, {11,2,NUM}} },
 { 0x4c000020, "bdnzflr", {{16,5,BCND}} },
 { 0x4c000020, "bdnzflr", {{16,5,BCND}, {11,2,NUM}} },
 { 0x4c000021, "bdnzflrl",{{16,5,BCND}} },
 { 0x4c000021, "bdnzflrl",{{16,5,BCND}, {11,2,NUM}} },
 { 0x4e400020, "bdzlr",   },
 { 0x4e400020, "bdzlr",   {{11,2,NUM}} },
 { 0x4e400021, "bdzlrl",  },
 { 0x4e400021, "bdzlrl",  {{11,2,NUM}} },
 { 0x4d400020, "bdztlr",  {{16,5,BCND}} },
 { 0x4d400020, "bdztlr",  {{16,5,BCND}, {11,2,NUM}} },
 { 0x4d400021, "bdztlrl", {{16,5,BCND}} },
 { 0x4d400021, "bdztlrl", {{16,5,BCND}, {11,2,NUM}} },
 { 0x4c400020, "bdzflr",  {{16,5,BCND}} },
 { 0x4c400020, "bdzflr",  {{16,5,BCND}, {11,2,NUM}} },
 { 0x4c400021, "bdzflrl", {{16,5,BCND}} },
 { 0x4c400021, "bdzflrl", {{16,5,BCND}, {11,2,NUM}} },

 { 0x4c000420, "bctr",    {{21,5,NUM},  {16,5,NUM}} },
 { 0x4e800420, "bctr",    },
 { 0x4e800420, "bctr",    {{11,2,NUM}} },
 { 0x4c000421, "bctrl",   {{21,5,NUM},  {16,5,NUM}} },
 { 0x4e800421, "bctrl",   },
 { 0x4e800421, "bctrl",   {{11,2,NUM}} },
 { 0x4d800420, "btctr",   {{16,5,BCND}} },
 { 0x4d800420, "btctr",   {{16,5,BCND}, {11,2,NUM}} },
 { 0x4d800421, "btctrl",  {{16,5,BCND}} },
 { 0x4d800421, "btctrl",  {{16,5,BCND}, {11,2,NUM}} },
 { 0x4c800420, "bfctr",   {{16,5,BCND}} },
 { 0x4c800420, "bfctr",   {{16,5,BCND}, {11,2,NUM}} },
 { 0x4c800421, "bfctrl",  {{16,5,BCND}} },
 { 0x4c800421, "bfctrl",  {{16,5,BCND}, {11,2,NUM}} },

/* branch mnemonics incorporating conditions (assember extended mnemonics) */
 { 0x41800000, "blt",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x41800000, "blt",     {{2,14,PCREL}} },
 { 0x41800001, "bltl",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x41800001, "bltl",    {{2,14,PCREL}} },
 { 0x40810000, "ble",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40810000, "ble",     {{2,14,PCREL}} },
 { 0x40810001, "blel",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40810001, "blel",    {{2,14,PCREL}} },
 { 0x41820000, "beq",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x41820000, "beq",     {{2,14,PCREL}} },
 { 0x41820001, "beql",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x41820001, "beql",    {{2,14,PCREL}} },
 { 0x40800000, "bge",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40800000, "bge",     {{2,14,PCREL}} },
 { 0x40800001, "bgel",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40800001, "bgel",    {{2,14,PCREL}} },
 { 0x41810000, "bgt",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x41810000, "bgt",     {{2,14,PCREL}} },
 { 0x41810001, "bgtl",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x41810001, "bgtl",    {{2,14,PCREL}} },
 { 0x40800000, "bnl",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40800000, "bnl",     {{2,14,PCREL}} },
 { 0x40800001, "bnll",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40800001, "bnll",    {{2,14,PCREL}} },
 { 0x40820000, "bne",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40820000, "bne",     {{2,14,PCREL}} },
 { 0x40820001, "bnel",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40820001, "bnel",    {{2,14,PCREL}} },
 { 0x40810000, "bng",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40810000, "bng",     {{2,14,PCREL}} },
 { 0x40810001, "bngl",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40810001, "bngl",    {{2,14,PCREL}} },
 { 0x41830000, "bso",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x41830000, "bso",     {{2,14,PCREL}} },
 { 0x41830001, "bsol",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x41830001, "bsol",    {{2,14,PCREL}} },
 { 0x40830000, "bns",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40830000, "bns",     {{2,14,PCREL}} },
 { 0x40830001, "bnsl",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40830001, "bnsl",    {{2,14,PCREL}} },
 { 0x41830000, "bun",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x41830000, "bun",     {{2,14,PCREL}} },
 { 0x41830001, "bunl",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x41830001, "bunl",    {{2,14,PCREL}} },
 { 0x40830000, "bnu",     {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40830000, "bnu",     {{2,14,PCREL}} },
 { 0x40830001, "bnul",    {{16,5,CRF}, {2,14,PCREL}} },
 { 0x40830001, "bnul",    {{2,14,PCREL}} },

 { 0x41800002, "blta",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x41800002, "blta",    {{2,14,BADDR}} },
 { 0x41800003, "bltla",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x41800003, "bltla",   {{2,14,BADDR}} },
 { 0x40810002, "blea",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40810002, "blea",    {{2,14,BADDR}} },
 { 0x40810003, "blela",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40810003, "blela",   {{2,14,BADDR}} },
 { 0x41820002, "beqa",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x41820002, "beqa",    {{2,14,BADDR}} },
 { 0x41820003, "beqla",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x41820003, "beqla",   {{2,14,BADDR}} },
 { 0x40800002, "bgea",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40800002, "bgea",    {{2,14,BADDR}} },
 { 0x40800003, "bgela",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40800003, "bgela",   {{2,14,BADDR}} },
 { 0x41810002, "bgta",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x41810002, "bgta",    {{2,14,BADDR}} },
 { 0x41810003, "bgtla",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x41810003, "bgtla",   {{2,14,BADDR}} },
 { 0x40800002, "bnla",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40800002, "bnla",    {{2,14,BADDR}} },
 { 0x40800003, "bnlla",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40800003, "bnlla",   {{2,14,BADDR}} },
 { 0x40820002, "bnea",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40820002, "bnea",    {{2,14,BADDR}} },
 { 0x40820003, "bnela",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40820003, "bnela",   {{2,14,BADDR}} },
 { 0x40810002, "bnga",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40810002, "bnga",    {{2,14,BADDR}} },
 { 0x40810003, "bngla",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40810003, "bngla",   {{2,14,BADDR}} },
 { 0x41830002, "bsoa",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x41830002, "bsoa",    {{2,14,BADDR}} },
 { 0x41830003, "bsola",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x41830003, "bsola",   {{2,14,BADDR}} },
 { 0x40830002, "bnsa",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40830002, "bnsa",    {{2,14,BADDR}} },
 { 0x40830003, "bnsla",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40830003, "bnsla",   {{2,14,BADDR}} },
 { 0x41830002, "buna",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x41830002, "buna",    {{2,14,BADDR}} },
 { 0x41830003, "bunla",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x41830003, "bunla",   {{2,14,BADDR}} },
 { 0x40830002, "bnua",    {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40830002, "bnua",    {{2,14,BADDR}} },
 { 0x40830003, "bnula",   {{16,5,CRF}, {2,14,BADDR}} },
 { 0x40830003, "bnula",   {{2,14,BADDR}} },

 { 0x4d800020, "bltlr",   {{16,5,CRF}} },
 { 0x4d800020, "bltlr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d800020, "bltlr",   },
 { 0x4d800021, "bltlrl",  {{16,5,CRF}} },
 { 0x4d800021, "bltlrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d800021, "bltlrl",  },
 { 0x4c810020, "blelr",   {{16,5,CRF}} },
 { 0x4c810020, "blelr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c810020, "blelr",   },
 { 0x4c810021, "blelrl",  {{16,5,CRF}} },
 { 0x4c810021, "blelrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c810021, "blelrl",  },
 { 0x4d820020, "beqlr",   {{16,5,CRF}} },
 { 0x4d820020, "beqlr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d820020, "beqlr",   },
 { 0x4d820021, "beqlrl",  {{16,5,CRF}} },
 { 0x4d820021, "beqlrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d820021, "beqlrl",  },
 { 0x4c800020, "bgelr",   {{16,5,CRF}} },
 { 0x4c800020, "bgelr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c800020, "bgelr",   },
 { 0x4c800021, "bgelrl",  {{16,5,CRF}} },
 { 0x4c800021, "bgelrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c800021, "bgelrl",  },
 { 0x4d810020, "bgtlr",   {{16,5,CRF}} },
 { 0x4d810020, "bgtlr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d810020, "bgtlr",   },
 { 0x4d810021, "bgtlrl",  {{16,5,CRF}} },
 { 0x4d810021, "bgtlrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d810021, "bgtlrl",  },
 { 0x4c800020, "bnllr",   {{16,5,CRF}} },
 { 0x4c800020, "bnllr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c800020, "bnllr",   },
 { 0x4c800021, "bnllrl",  {{16,5,CRF}} },
 { 0x4c800021, "bnllrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c800021, "bnllrl",  },
 { 0x4c820020, "bnelr",   {{16,5,CRF}} },
 { 0x4c820020, "bnelr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c820020, "bnelr",   },
 { 0x4c820021, "bnelrl",  {{16,5,CRF}} },
 { 0x4c820021, "bnelrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c820021, "bnelrl",  },
 { 0x4c810020, "bnglr",   {{16,5,CRF}} },
 { 0x4c810020, "bnglr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c810020, "bnglr",   },
 { 0x4c810021, "bnglrl",  {{16,5,CRF}} },
 { 0x4c810021, "bnglrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c810021, "bnglrl",  },
 { 0x4d830020, "bsolr",   {{16,5,CRF}} },
 { 0x4d830020, "bsolr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d830020, "bsolr",   },
 { 0x4d830021, "bsolrl",  {{16,5,CRF}} },
 { 0x4d830021, "bsolrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d830021, "bsolrl",  },
 { 0x4c830020, "bnslr",   {{16,5,CRF}} },
 { 0x4c830020, "bnslr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c830020, "bnslr",   },
 { 0x4c830021, "bnslrl",  {{16,5,CRF}} },
 { 0x4c830021, "bnslrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c830021, "bnslrl",  },
 { 0x4d830020, "bunlr",   {{16,5,CRF}} },
 { 0x4d830020, "bunlr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d830020, "bunlr",   },
 { 0x4d830021, "bunlrl",  {{16,5,CRF}} },
 { 0x4d830021, "bunlrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d830021, "bunlrl",  },
 { 0x4c830020, "bnulr",   {{16,5,CRF}} },
 { 0x4c830020, "bnulr",   {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c830020, "bnulr",   },
 { 0x4c830021, "bnulrl",  {{16,5,CRF}} },
 { 0x4c830021, "bnulrl",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c830021, "bnulrl",  },

 { 0x4d800420, "bltctr",  {{16,5,CRF}} },
 { 0x4d800420, "bltctr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d800420, "bltctr",  },
 { 0x4d800421, "bltctrl", {{16,5,CRF}} },
 { 0x4d800421, "bltctrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d800421, "bltctrl", },
 { 0x4c810420, "blectr",  {{16,5,CRF}} },
 { 0x4c810420, "blectr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c810420, "blectr",  },
 { 0x4c810421, "blectrl", {{16,5,CRF}} },
 { 0x4c810421, "blectrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c810421, "blectrl", },
 { 0x4d820420, "beqctr",  {{16,5,CRF}} },
 { 0x4d820420, "beqctr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d820420, "beqctr",  },
 { 0x4d820421, "beqctrl", {{16,5,CRF}} },
 { 0x4d820421, "beqctrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d820421, "beqctrl", },
 { 0x4c800420, "bgectr",  {{16,5,CRF}} },
 { 0x4c800420, "bgectr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c800420, "bgectr",  },
 { 0x4c800421, "bgectrl", {{16,5,CRF}} },
 { 0x4c800421, "bgectrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c800421, "bgectrl", },
 { 0x4d810420, "bgtctr",  {{16,5,CRF}} },
 { 0x4d810420, "bgtctr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d810420, "bgtctr",  },
 { 0x4d810421, "bgtctrl", {{16,5,CRF}} },
 { 0x4d810421, "bgtctrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d810421, "bgtctrl", },
 { 0x4c800420, "bnlctr",  {{16,5,CRF}} },
 { 0x4c800420, "bnlctr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c800420, "bnlctr",  },
 { 0x4c800421, "bnlctrl", {{16,5,CRF}} },
 { 0x4c800421, "bnlctrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c800421, "bnlctrl", },
 { 0x4c820420, "bnectr",  {{16,5,CRF}} },
 { 0x4c820420, "bnectr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c820420, "bnectr",  },
 { 0x4c820421, "bnectrl", {{16,5,CRF}} },
 { 0x4c820421, "bnectrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c820421, "bnectrl", },
 { 0x4c810420, "bngctr",  {{16,5,CRF}} },
 { 0x4c810420, "bngctr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c810420, "bngctr",  },
 { 0x4c810421, "bngctrl", {{16,5,CRF}} },
 { 0x4c810421, "bngctrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c810421, "bngctrl", },
 { 0x4d830420, "bsoctr",  {{16,5,CRF}} },
 { 0x4d830420, "bsoctr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d830420, "bsoctr",  },
 { 0x4d830421, "bsoctrl", {{16,5,CRF}} },
 { 0x4d830421, "bsoctrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d830421, "bsoctrl", },
 { 0x4c830420, "bnsctr",  {{16,5,CRF}} },
 { 0x4c830420, "bnsctr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c830420, "bnsctr",  },
 { 0x4c830421, "bnsctrl", {{16,5,CRF}} },
 { 0x4c830421, "bnsctrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c830421, "bnsctrl", },
 { 0x4d830420, "bunctr",  {{16,5,CRF}} },
 { 0x4d830420, "bunctr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d830420, "bunctr",  },
 { 0x4d830421, "bunctrl", {{16,5,CRF}} },
 { 0x4d830421, "bunctrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4d830421, "bunctrl", },
 { 0x4c830420, "bnuctr",  {{16,5,CRF}} },
 { 0x4c830420, "bnuctr",  {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c830420, "bnuctr",  },
 { 0x4c830421, "bnuctrl", {{16,5,CRF}} },
 { 0x4c830421, "bnuctrl", {{16,5,CRF}, {11,2,NUM}} },
 { 0x4c830421, "bnuctrl", },

 { 0x2c000000, "cmpi",
	{{21,5,CRFONLY},{16,5,GREG}, {0,16,SI}} },
 { 0x2c000000, "cmpi",
	{{21,5,CRFONLY},{21,1,NUM},  {16,5,GREG}, {0,16,SI}} },
 { 0x2c000000, "cmpi",
	{{23,3,NUM},    {16,5,GREG}, {0,16,SI}} },
 { 0x2c000000, "cmpi",
	{{23,3,NUM},    {21,1,NUM},  {16,5,GREG}, {0,16,SI}} },
 { 0x2c000000, "cmpwi",   {{16,5,GREG},   {0,16,SI}} },
 { 0x2c000000, "cmpwi",   {{21,5,CRFONLY},{16,5,GREG}, {0,16,SI}} },
 { 0x2c000000, "cmpwi",   {{23,3,NUM},    {16,5,GREG}, {0,16,SI}} },
 { 0x2c200000, "cmpdi",   {{16,5,GREG},   {0,16,SI}} },
 { 0x2c200000, "cmpdi",   {{21,5,CRFONLY},{16,5,GREG}, {0,16,SI}} },
 { 0x2c200000, "cmpdi",   {{23,3,NUM},    {16,5,GREG}, {0,16,SI}} },

 { 0x7c000000, "cmp",    
	{{21,5,CRFONLY},{16,5,GREG}, {11,5,GREG}} },
 { 0x7c000000, "cmp",    
	{{21,5,CRFONLY},{21,1,NUM}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000000, "cmp",    
	{{23,3,NUM},    {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000000, "cmp",    
	{{23,3,NUM},    {21,1,NUM}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000000, "cmpw",    {{16,5,GREG},   {11,5,GREG}} },
 { 0x7c000000, "cmpw",    {{21,5,CRFONLY},{16,5,GREG}, {11,5,GREG}} },
 { 0x7c000000, "cmpw",    {{23,3,NUM},    {16,5,GREG}, {11,5,GREG}} },
 { 0x7c200000, "cmpd",    {{16,5,GREG},   {11,5,GREG}} },
 { 0x7c200000, "cmpd",    {{21,5,CRFONLY},{16,5,GREG}, {11,5,GREG}} },
 { 0x7c200000, "cmpd",    {{23,3,NUM},    {16,5,GREG}, {11,5,GREG}} },

 { 0x28000000, "cmpli",
	{{21,5,CRFONLY},{16,5,GREG}, {0,16,UI}} },
 { 0x28000000, "cmpli",
	{{21,5,CRFONLY},{21,1,NUM},  {16,5,GREG}, {0,16,UI}} },
 { 0x28000000, "cmpli",
	{{23,3,NUM},    {16,5,GREG}, {0,16,UI}} },
 { 0x28000000, "cmpli",
	{{23,3,NUM},    {21,1,NUM},  {16,5,GREG}, {0,16,UI}} },
 { 0x28000000, "cmplwi",  {{16,5,GREG},   {0,16,UI}} },
 { 0x28000000, "cmplwi",  {{21,5,CRFONLY},{16,5,GREG}, {0,16,UI}} },
 { 0x28000000, "cmplwi",  {{23,3,NUM},    {16,5,GREG}, {0,16,UI}} },
 { 0x28200000, "cmpldi",  {{16,5,GREG},   {0,16,UI}} },
 { 0x28200000, "cmpldi",  {{21,5,CRFONLY},{16,5,GREG}, {0,16,UI}} },
 { 0x28200000, "cmpldi",  {{23,3,NUM},    {16,5,GREG}, {0,16,UI}} },

 { 0x7c000040, "cmpl",    
	{{21,5,CRFONLY},{16,5,GREG}, {11,5,GREG}} },
 { 0x7c000040, "cmpl",    
	{{21,5,CRFONLY},{21,1,NUM}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000040, "cmpl",    
	{{23,3,NUM},    {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000040, "cmpl",    
	{{23,3,NUM},    {21,1,NUM}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000040, "cmplw",   {{16,5,GREG},   {11,5,GREG}} },
 { 0x7c000040, "cmplw",   {{21,5,CRFONLY},{16,5,GREG}, {11,5,GREG}} },
 { 0x7c000040, "cmplw",   {{23,3,NUM},    {16,5,GREG}, {11,5,GREG}} },
 { 0x7c200040, "cmpld",   {{16,5,GREG},   {11,5,GREG}} },
 { 0x7c200040, "cmpld",   {{21,5,CRFONLY},{16,5,GREG}, {11,5,GREG}} },
 { 0x7c200040, "cmpld",   {{23,3,NUM},    {16,5,GREG}, {11,5,GREG}} },

 { 0x7c000034, "cntlzw",  {{16,5,GREG}, {21,5,GREG}} },
 { 0x7c000035, "cntlzw.", {{16,5,GREG}, {21,5,GREG}} },
 { 0x7c000074, "cntlzd",  {{16,5,GREG}, {21,5,GREG}}, IMPL64 },
 { 0x7c000075, "cntlzd.", {{16,5,GREG}, {21,5,GREG}}, IMPL64 },

 { 0x4c000202, "crand",   {{21,5,NUM},  {16,5,NUM},  {11,5,NUM}} },
 { 0x4c000102, "crandc",  {{21,5,NUM},  {16,5,NUM},  {11,5,NUM}} },
 { 0x4c000242, "creqv",   {{21,5,NUM},  {16,5,NUM},  {11,5,NUM}} },
 { 0x4c0001c2, "crnand",  {{21,5,NUM},  {16,5,NUM},  {11,5,NUM}} },
 { 0x4c000042, "crnor",   {{21,5,NUM},  {16,5,NUM},  {11,5,NUM}} },
 { 0x4c000382, "cror",    {{21,5,NUM},  {16,5,NUM},  {11,5,NUM}} },
 { 0x4c000342, "crorc",   {{21,5,NUM},  {16,5,NUM},  {11,5,NUM}} },
 { 0x4c000182, "crxor",   {{21,5,NUM},  {16,5,NUM},  {11,5,NUM}} },

 { 0x7c0003d2, "divd",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c0003d3, "divd.",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c0007d2, "divdo",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c0007d3, "divdo.",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, IMPL64 },

 { 0x7c000392, "divdu",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c000393, "divdu.",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c000792, "divduo",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c000793, "divduo.", {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, IMPL64 },

 { 0x7c0003d6, "divw",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c0003d7, "divw.",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c0007d6, "divwo",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c0007d7, "divwo.",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },

 { 0x7c000396, "divwu",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000397, "divwu.",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000796, "divwuo",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000797, "divwuo.", {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },

 { 0x7c000238, "eqv",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000239, "eqv.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },

 { 0x7c000774, "extsb",   {{16,5,GREG}, {21,5,GREG}} },
 { 0x7c000775, "extsb.",  {{16,5,GREG}, {21,5,GREG}} },
 { 0x7c000734, "extsh",   {{16,5,GREG}, {21,5,GREG}} },
 { 0x7c000735, "extsh.",  {{16,5,GREG}, {21,5,GREG}} },
 { 0x7c0007b4, "extsw",   {{16,5,GREG}, {21,5,GREG}}, IMPL64 },
 { 0x7c0007b5, "extsw.",  {{16,5,GREG}, {21,5,GREG}}, IMPL64 },

 { 0xfc00002a, "fadd",    {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },
 { 0xfc00002b, "fadd.",   {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },
 { 0xec00002a, "fadds",   {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },
 { 0xec00002b, "fadds.",  {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },
 { 0xfc000028, "fsub",    {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },
 { 0xfc000029, "fsub.",   {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },
 { 0xec000028, "fsubs",   {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },
 { 0xec000029, "fsubs.",  {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },
 { 0xfc000032, "fmul",    {{21,5,FREG}, {16,5,FREG}, {6,5,FREG}}  },
 { 0xfc000033, "fmul.",   {{21,5,FREG}, {16,5,FREG}, {6,5,FREG}}  },
 { 0xec000032, "fmuls",   {{21,5,FREG}, {16,5,FREG}, {6,5,FREG}}  },
 { 0xec000033, "fmuls.",  {{21,5,FREG}, {16,5,FREG}, {6,5,FREG}}  },
 { 0xfc000024, "fdiv",    {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },
 { 0xfc000025, "fdiv.",   {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },
 { 0xec000024, "fdivs",   {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },
 { 0xec000025, "fdivs.",  {{21,5,FREG}, {16,5,FREG}, {11,5,FREG}} },

 { 0xfc00003a, "fmadd",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xfc00003b, "fmadd.",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xec00003a, "fmadds",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xec00003b, "fmadds.",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xfc000038, "fmsub",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xfc000039, "fmsub.",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xec000038, "fmsubs",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xec000039, "fmsubs.",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xfc00003e, "fnmadd",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xfc00003f, "fnmadd.",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xec00003e, "fnmadds",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xec00003f, "fnmadds.",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xfc00003c, "fnmsub",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xfc00003d, "fnmsub.",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xec00003c, "fnmsubs",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xec00003d, "fnmsubs.",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },

 { 0xfc000090, "fmr",     {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc000091, "fmr.",    {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc000210, "fabs",    {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc000211, "fabs.",   {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc000050, "fneg",    {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc000051, "fneg.",   {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc000110, "fnabs",   {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc000111, "fnabs.",  {{21,5,FREG}, {11,5,FREG}} },
 { 0xec000030, "fres",    {{21,5,FREG}, {11,5,FREG}} },
 { 0xec000031, "fres.",   {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc000018, "frsp",    {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc000019, "frsp.",   {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc000034, "frsqrte", {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc000035, "frsqrte.",{{21,5,FREG}, {11,5,FREG}} },
 { 0xfc00002e, "fsel",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xfc00002f, "fsel.",
	{{21,5,FREG}, {16,5,FREG}, {6,5,FREG}, {11,5,FREG}} },
 { 0xfc00002c, "fsqrt",   {{21,5,FREG}, {11,5,FREG}}, OPTIONAL|CPU970 },
 { 0xfc00002d, "fsqrt.",  {{21,5,FREG}, {11,5,FREG}}, OPTIONAL|CPU970 },
 { 0xec00002c, "fsqrts",  {{21,5,FREG}, {11,5,FREG}}, OPTIONAL|CPU970 },
 { 0xec00002d, "fsqrts.", {{21,5,FREG}, {11,5,FREG}}, OPTIONAL|CPU970 },
 { 0xfc00065c, "fctid",   {{21,5,FREG}, {11,5,FREG}}, IMPL64 },
 { 0xfc00065d, "fctid.",  {{21,5,FREG}, {11,5,FREG}}, IMPL64 },
 { 0xfc00065e, "fctidz",  {{21,5,FREG}, {11,5,FREG}}, IMPL64 },
 { 0xfc00065f, "fctidz.", {{21,5,FREG}, {11,5,FREG}}, IMPL64 },
 { 0xfc00001c, "fctiw",   {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc00001d, "fctiw.",  {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc00001e, "fctiwz",  {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc00001f, "fctiwz.", {{21,5,FREG}, {11,5,FREG}} },
 { 0xfc00069c, "fcfid",   {{21,5,FREG}, {11,5,FREG}}, IMPL64 },
 { 0xfc00069d, "fcfid.",  {{21,5,FREG}, {11,5,FREG}}, IMPL64 },

 { 0xfc000000, "fcmpu",   {{21,5,CRFONLY},{16,5,FREG}, {11,5,FREG}} },
 { 0xfc000000, "fcmpu",   {{23,3,NUM},    {16,5,FREG}, {11,5,FREG}} },
 { 0xfc000040, "fcmpo",   {{21,5,CRFONLY},{16,5,FREG}, {11,5,FREG}} },
 { 0xfc000040, "fcmpo",   {{23,3,NUM},    {16,5,FREG}, {11,5,FREG}} },
 { 0xfc00048e, "mffs",    {{21,5,FREG}} },
 { 0xfc00048f, "mffs.",   {{21,5,FREG}} },
 { 0xfc000080, "mcrfs",   {{21,5,CRFONLY},{18,5,NUM}} },
 { 0xfc000080, "mcrfs",   {{23,3,NUM},  {18,5,NUM}} },
 { 0xfc00010c, "mtfsfi",  {{23,3,NUM},  {12,4,NUM}} },
 { 0xfc00010d, "mtfsfi.", {{23,3,NUM},  {12,4,NUM}} },
 { 0xfc00058e, "mtfsf",   {{17,8,NUM},  {11,5,FREG}} },
 { 0xfc00058f, "mtfsf.",  {{17,8,NUM},  {11,5,FREG}} },
 { 0xfc00008c, "mtfsb0",  {{21,5,NUM}} },
 { 0xfc00008d, "mtfsb0.", {{21,5,NUM}} },
 { 0xfc00004c, "mtfsb1",  {{21,5,NUM}} },
 { 0xfc00004d, "mtfsb1.", {{21,5,NUM}} },

 { 0x88000000, "lbz",     {{21,5,GREG}, {0,16,D},     {16,5,G0REG}} },
 { 0x7c0000ae, "lbzx",    {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}} },
 { 0x8c000000, "lbzu",    {{21,5,GREG}, {0,16,D},     {16,5,G0REG}} },
 { 0x7c0000ee, "lbzux",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0xa0000000, "lhz",     {{21,5,GREG}, {0,16,D},     {16,5,G0REG}} },
 { 0x7c00022e, "lhzx",    {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}} },
 { 0xa4000000, "lhzu",    {{21,5,GREG}, {0,16,D},     {16,5,G0REG}} },
 { 0x7c00026e, "lhzux",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0xa8000000, "lha",     {{21,5,GREG}, {0,16,D},     {16,5,G0REG}} },
 { 0x7c0002ae, "lhax",    {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}} },
 { 0xac000000, "lhau",    {{21,5,GREG}, {0,16,D},     {16,5,GREG}} },
 { 0x7c0002ee, "lhaux",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0x80000000, "lwz",     {{21,5,GREG}, {0,16,D},     {16,5,G0REG}} },
 { 0x7c00002e, "lwzx",    {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}} },
 { 0x84000000, "lwzu",    {{21,5,GREG}, {0,16,D},     {16,5,GREG}} },
 { 0x7c00006e, "lwzux",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0xe8000002, "lwa",     {{21,5,GREG}, {2,14,DS},    {16,5,G0REG}}, IMPL64 },
 { 0x7c0002aa, "lwax",    {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}},  IMPL64 },
 { 0x7c0002ea, "lwaux",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}},  IMPL64 },
 { 0xe8000000, "ld",      {{21,5,GREG}, {2,14,DS},    {16,5,G0REG}}, IMPL64 },
 { 0x7c00002a, "ldx",     {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}},  IMPL64 },
 { 0xe8000001, "ldu",     {{21,5,GREG}, {2,14,DS},    {16,5,GREG}},  IMPL64 },
 { 0x7c00006a, "ldux",    {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}},  IMPL64 },

 { 0xb8000000, "lmw",     {{21,5,GREG}, {0,16,D},     {16,5,G0REG}} },
 { 0xbc000000, "stmw",    {{21,5,GREG}, {0,16,D},     {16,5,G0REG}} },

 { 0x7c00062c, "lhbrx",   {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}} },
 { 0x7c00042c, "lwbrx",   {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}} },
 { 0x7c00042a, "lswx",    {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}} },
 { 0x7c000028, "lwarx",   {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}} },
 { 0x7c0000a8, "ldarx",   {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}}, IMPL64 },

 { 0x7c00022a, "lscbx",   {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}}, CPU601 },
 { 0x7c00022b, "lscbx.",  {{21,5,GREG}, {16,5,G0REG}, {11,5,GREG}}, CPU601 },

 { 0x7c0004aa, "lswi",    {{21,5,GREG}, {16,5,G0REG}, {11,5,NUM0}} },

 { 0xc0000000, "lfs",     {{21,5,FREG}, {0,16,D},     {16,5,G0REG}} },
 { 0xc4000000, "lfsu",    {{21,5,FREG}, {0,16,D},     {16,5,GREG}} },
 { 0x7c00042e, "lfsx",    {{21,5,FREG}, {16,5,G0REG}, {11,5,GREG}} },
 { 0x7c00046e, "lfsux",   {{21,5,FREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0xc8000000, "lfd",     {{21,5,FREG}, {0,16,D},     {16,5,G0REG}} },
 { 0xcc000000, "lfdu",    {{21,5,FREG}, {0,16,D},     {16,5,GREG}} },
 { 0x7c0004ae, "lfdx",    {{21,5,FREG}, {16,5,G0REG}, {11,5,GREG}} },
 { 0x7c0004ee, "lfdux",   {{21,5,FREG}, {16,5,GREG},  {11,5,GREG}} },

 { 0x38000000, "la",      {{21,5,GREG}, {0,16,D},     {16,5,G0REG}} },

 { 0x4c000000, "mcrf",    {{21,5,CRFONLY},{16,5,CRFONLY}} },
 { 0x4c000000, "mcrf",    {{23,3,NUM},  {18,3,NUM}} },

 { 0x7c0002a6, "mfspr",   {{21,5,GREG}, {11,10,SPREG}} },
 { 0x7c0003a6, "mtspr",   {{11,10,SPREG},{21,5,GREG}} },
 { 0x7c000120, "mtcrf",   {{12,8,FXM},  {21,5,GREG}} },
 { 0x7c000120, "mtocrf",  {{12,8,FXM},  {21,5,GREG}} },
 { 0x7c000400, "mcrxr",   {{21,5,CRFONLY}}  },
 { 0x7c000400, "mcrxr",   {{23,3,NUM}}  },
 { 0x7c000026, "mfcr",    {{21,5,GREG}} },
 { 0x7c100026, "mfcr",    {{21,5,GREG}, {12,8,FXM}} },
 { 0x7c100026, "mfocrf",  {{21,5,GREG}, {12,8,FXM}} },

/* Move to/from spr mnemonics (assember extended mnemonics) */
 { 0x7c0102a6, "mfxer",   {{21,5,GREG}} },
 { 0x7c0802a6, "mflr",    {{21,5,GREG}} },
 { 0x7c0902a6, "mfctr",   {{21,5,GREG}} },
 { 0x7c0103a6, "mtxer",   {{21,5,GREG}} },
 { 0x7c0803a6, "mtlr",    {{21,5,GREG}} },
 { 0x7c0903a6, "mtctr",   {{21,5,GREG}} },
 { 0x7c0002a6, "mfmq",    {{21,5,GREG}} },
 { 0x7c0502a6, "mfrtcl",  {{21,5,GREG}} },
 { 0x7c0402a6, "mfrtcu",  {{21,5,GREG}} },
 { 0x7c0003a6, "mtmq",    {{21,5,GREG}} },
 { 0x7c1503a6, "mtrtcl",  {{21,5,GREG}} },
 { 0x7c1403a6, "mtrtcu",  {{21,5,GREG}} },

#ifdef NRW_COMPILER
 { 0x7c0001d6, "mull",    {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0x7c0001d7, "mull.",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0x7c0005d6, "mullo",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0x7c0005d7, "mullo.",  {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
#endif /* NRW_COMPILER */
 { 0x7c0001d6, "mullw",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0x7c0001d7, "mullw.",  {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0x7c0005d6, "mullwo",  {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0x7c0005d7, "mullwo.", {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },

 { 0x7c000092, "mulhd",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}}, IMPL64 },
 { 0x7c000093, "mulhd.",  {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}}, IMPL64 },

#ifdef NRW_COMPILER
 { 0x7c000096, "mulwd",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0x7c000097, "mulwd.",  {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
#endif /* NRW_COMPILER */
 { 0x7c000096, "mulhw",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0x7c000097, "mulhw.",  {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },

 { 0x7c000012, "mulhdu",  {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}}, IMPL64 },
 { 0x7c000013, "mulhdu.", {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}}, IMPL64 },

 { 0x7c000016, "mulhwu",  {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },
 { 0x7c000017, "mulhwu.", {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}} },

 { 0x7c0001d2, "mulld",   {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}}, IMPL64 },
 { 0x7c0001d3, "mulld.",  {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}}, IMPL64 },
 { 0x7c0005d2, "mulldo",  {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}}, IMPL64 },
 { 0x7c0005d3, "mulldo.", {{21,5,GREG}, {16,5,GREG},  {11,5,GREG}}, IMPL64 },

 { 0x7c0003b8, "nand",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c0003b9, "nand.",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },

 { 0x7c0000d0, "neg",     {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c0000d1, "neg.",    {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c0004d0, "nego",    {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c0004d1, "nego.",   {{21,5,GREG}, {16,5,GREG}} },

 { 0x7c0000f8, "nor",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c0000f9, "nor.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },

/* Miscellaneous mnemonics (assember extended mnemonics) */
 { 0x60000000, "nop",     },

 { 0x60000000, "ori",     {{16,5,GREG}, {21,5,GREG}, {0,16,UI}} },
 { 0x60000000, "ori",     {{16,5,ZERO}, {21,5,ZERO}, {0,16,ZERO}} },
 { 0x64000000, "oris",    {{16,5,GREG}, {21,5,GREG}, {0,16,UI}} },
 { 0x7c000378, "or",      {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000379, "or.",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },

 { 0x7c000338, "orc",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000339, "orc.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },

 { 0x78000000, "rldicl",
	{{16,5,GREG}, {21,5,GREG}, {0,0,sh}, {0,0,mb}}, IMPL64 },
 { 0x78000001, "rldicl.",
	{{16,5,GREG}, {21,5,GREG}, {0,0,sh}, {0,0,mb}}, IMPL64 },
 { 0x78000004, "rldicr",
	{{16,5,GREG}, {21,5,GREG}, {0,0,sh}, {0,0,mb}}, IMPL64 },
 { 0x78000005, "rldicr.",
	{{16,5,GREG}, {21,5,GREG}, {0,0,sh}, {0,0,mb}}, IMPL64 },
 { 0x78000008, "rldic",
	{{16,5,GREG}, {21,5,GREG}, {0,0,sh}, {0,0,mb}}, IMPL64 },
 { 0x78000009, "rldic.",
	{{16,5,GREG}, {21,5,GREG}, {0,0,sh}, {0,0,mb}}, IMPL64 },
 { 0x7800000c, "rldimi",
	{{16,5,GREG}, {21,5,GREG}, {0,0,sh}, {0,0,mb}}, IMPL64 },
 { 0x7800000d, "rldimi.",
	{{16,5,GREG}, {21,5,GREG}, {0,0,sh}, {0,0,mb}}, IMPL64 },
 { 0x78000010, "rldcl",
	{{16,5,GREG}, {21,5,GREG}, {11,5,GREG}, {0,0,mb}}, IMPL64 },
 { 0x78000011, "rldcl.",
	{{16,5,GREG}, {21,5,GREG}, {11,5,GREG}, {0,0,mb}}, IMPL64 },
 { 0x78000012, "rldcr",
	{{16,5,GREG}, {21,5,GREG}, {11,5,GREG}, {0,0,mb}}, IMPL64 },
 { 0x78000013, "rldcr.",
	{{16,5,GREG}, {21,5,GREG}, {11,5,GREG}, {0,0,mb}}, IMPL64 },

 { 0x54000000, "rlwinm",
	{{16,5,GREG}, {21,5,GREG}, {11,5,NUM0}, {6,5,MBE}, {1,5,MBE}} },
 { 0x54000001, "rlwinm.",
	{{16,5,GREG}, {21,5,GREG}, {11,5,NUM0}, {6,5,MBE}, {1,5,MBE}} },
 { 0x5c000000, "rlwnm",
	{{16,5,GREG}, {21,5,GREG}, {11,5,GREG}, {6,5,MBE}, {1,5,MBE}} },
 { 0x5c000001, "rlwnm.",
	{{16,5,GREG}, {21,5,GREG}, {11,5,GREG}, {6,5,MBE}, {1,5,MBE}} },
 { 0x50000000, "rlwimi",
	{{16,5,GREG}, {21,5,GREG}, {11,5,NUM0}, {6,5,MBE}, {1,5,MBE}} },
 { 0x50000001, "rlwimi.",
	{{16,5,GREG}, {21,5,GREG}, {11,5,NUM0}, {6,5,MBE}, {1,5,MBE}} },

 { 0x44000002, "sc", },
 { 0x4c000024, "rfid", {{0}}, IMPL64|OPTIONAL },

 { 0x7c000030, "slw",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000031, "slw.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000036, "sld",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c000037, "sld.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, IMPL64 },

 { 0x7c000430, "srw",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000431, "srw.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000436, "srd",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c000437, "srd.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, IMPL64 },

 { 0x7c000670, "srawi",   {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}  },
 { 0x7c000671, "srawi.",  {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}  },
 { 0x7c000674, "sradi",   {{16,5,GREG}, {21,5,GREG}, {0, 0,sh}}, IMPL64 },
 { 0x7c000675, "sradi.",  {{16,5,GREG}, {21,5,GREG}, {0, 0,sh}}, IMPL64 },

 { 0x7c000630, "sraw",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000631, "sraw.",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000634, "srad",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c000635, "srad.",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, IMPL64 },

 { 0x98000000, "stb",     {{21,5,GREG}, {0,16,D},    {16,5,G0REG}} },
 { 0x9c000000, "stbu",    {{21,5,GREG}, {0,16,D},    {16,5,GREG}} },
 { 0x7c0001ae, "stbx",    {{21,5,GREG}, {16,5,G0REG},{11,5,GREG}} },
 { 0x7c0001ee, "stbux",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0xb0000000, "sth",     {{21,5,GREG}, {0,16,D},    {16,5,G0REG}} },
 { 0xb4000000, "sthu",    {{21,5,GREG}, {0,16,D},    {16,5,GREG}} },
 { 0x7c00032e, "sthx",    {{21,5,GREG}, {16,5,G0REG},{11,5,GREG}} },
 { 0x7c00036e, "sthux",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x90000000, "stw",     {{21,5,GREG}, {0,16,D},    {16,5,G0REG}} },
 { 0x94000000, "stwu",    {{21,5,GREG}, {0,16,D},    {16,5,GREG}} },
 { 0x7c00012e, "stwx",    {{21,5,GREG}, {16,5,G0REG},{11,5,GREG}} },
 { 0x7c00016e, "stwux",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0xf8000000, "std",     {{21,5,GREG}, {2,14,DS},   {16,5,G0REG}}, IMPL64 },
 { 0xf8000001, "stdu",    {{21,5,GREG}, {2,14,DS},   {16,5,GREG}}, IMPL64 },
 { 0x7c00012a, "stdx",    {{21,5,GREG}, {16,5,G0REG},{11,5,GREG}}, IMPL64 },
 { 0x7c00016a, "stdux",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, IMPL64 },

 { 0x7c00072c, "sthbrx",  {{21,5,GREG}, {16,5,G0REG},{11,5,GREG}} },
 { 0x7c00052c, "stwbrx",  {{21,5,GREG}, {16,5,G0REG},{11,5,GREG}} },
 { 0x7c00052a, "stswx",   {{21,5,GREG}, {16,5,G0REG},{11,5,GREG}} },
 { 0x7c00012d, "stwcx.",  {{21,5,GREG}, {16,5,G0REG},{11,5,GREG}} },
 { 0x7c0001ad, "stdcx.",  {{21,5,GREG}, {16,5,G0REG},{11,5,GREG}}, IMPL64 },

 { 0x7c0005aa, "stswi",   {{21,5,GREG}, {16,5,G0REG},{11,5,NUM0}}  },

 { 0x7c0007ae, "stfiwx",  {{21,5,FREG}, {16,5,G0REG},{11,5,GREG}}, },

 { 0xd0000000, "stfs",    {{21,5,FREG}, {0,16,D},    {16,5,G0REG}} },
 { 0xd4000000, "stfsu",   {{21,5,FREG}, {0,16,D},    {16,5,GREG}} },
 { 0x7c00052e, "stfsx",   {{21,5,FREG}, {16,5,G0REG},{11,5,GREG}} },
 { 0x7c00056e, "stfsux",  {{21,5,FREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0xd8000000, "stfd",    {{21,5,FREG}, {0,16,D},    {16,5,G0REG}} },
 { 0xdc000000, "stfdu",   {{21,5,FREG}, {0,16,D},    {16,5,GREG}} },
 { 0x7c0005ae, "stfdx",   {{21,5,FREG}, {16,5,G0REG},{11,5,GREG}} },
 { 0x7c0005ee, "stfdux",  {{21,5,FREG}, {16,5,GREG}, {11,5,GREG}} },

 { 0x20000000, "subfic",  {{21,5,GREG}, {16,5,GREG}, {0,16,SI}} },
 { 0x7c000050, "sub",     {{21,5,GREG}, {11,5,GREG}, {16,5,GREG}} },
 { 0x7c000051, "sub.",    {{21,5,GREG}, {11,5,GREG}, {16,5,GREG}} },
 { 0x7c000450, "subo",    {{21,5,GREG}, {11,5,GREG}, {16,5,GREG}} },
 { 0x7c000451, "subo.",   {{21,5,GREG}, {11,5,GREG}, {16,5,GREG}} },
 { 0x7c000050, "subf",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000051, "subf.",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000450, "subfo",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000451, "subfo.",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },

 { 0x7c000010, "subc",    {{21,5,GREG}, {11,5,GREG}, {16,5,GREG}} },
 { 0x7c000011, "subc.",   {{21,5,GREG}, {11,5,GREG}, {16,5,GREG}} },
 { 0x7c000410, "subco",   {{21,5,GREG}, {11,5,GREG}, {16,5,GREG}} },
 { 0x7c000411, "subco.",  {{21,5,GREG}, {11,5,GREG}, {16,5,GREG}} },
 { 0x7c000010, "subfc",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000011, "subfc.",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000410, "subfco",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000411, "subfco.", {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },

 { 0x7c000110, "subfe",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000111, "subfe.",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000510, "subfeo",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000511, "subfeo.", {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}} },

 { 0x7c0001d0, "subfme",  {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c0001d1, "subfme.", {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c0005d0, "subfmeo", {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c0005d1, "subfmeo.",{{21,5,GREG}, {16,5,GREG}} },

 { 0x7c000190, "subfze",  {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c000191, "subfze.", {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c000590, "subfzeo", {{21,5,GREG}, {16,5,GREG}} },
 { 0x7c000591, "subfzeo.",{{21,5,GREG}, {16,5,GREG}} },

 { 0x7c0004ac, "sync", },
 { 0x7c0004ac, "sync",    {{21,2,NUM}} },
 { 0x7c2004ac, "lwsync", },
 { 0x7c4004ac, "ptesync", },

 { 0x08000000, "tdi",     {{21,5,NUM},  {16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x0a000000, "tdlti",   {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x0a800000, "tdlei",   {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x08800000, "tdeqi",   {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x09800000, "tdgei",   {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x09000000, "tdgti",   {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x09800000, "tdnli",   {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x0b000000, "tdnei",   {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x0a800000, "tdngi",   {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x08400000, "tdllti",  {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x08c00000, "tdllei",  {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x08a00000, "tdlgei",  {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x08200000, "tdlgti",  {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x08a00000, "tdlnli",  {{16,5,GREG}, {0,16,SI}}, IMPL64 },
 { 0x08c00000, "tdlngi",  {{16,5,GREG}, {0,16,SI}}, IMPL64 },

 { 0x7c000088, "td",      {{21,5,NUM},  {16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7e000088, "tdlt",    {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7e800088, "tdle",    {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c800088, "tdeq",    {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7d800088, "tdge",    {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7d000088, "tdgt",    {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7d800088, "tdnl",    {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7f000088, "tdne",    {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7e800088, "tdng",    {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c400088, "tdllt",   {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7cc00088, "tdlle",   {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7ca00088, "tdlge",   {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7c200088, "tdlgt",   {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7ca00088, "tdlnl",   {{16,5,GREG}, {11,5,GREG}}, IMPL64 },
 { 0x7cc00088, "tdlng",   {{16,5,GREG}, {11,5,GREG}}, IMPL64 },

 { 0x0c000000, "twi",     {{21,5,NUM},  {16,5,GREG}, {0,16,SI}} },
 { 0x0e000000, "twlti",   {{16,5,GREG}, {0,16,SI}} },
 { 0x0e800000, "twlei",   {{16,5,GREG}, {0,16,SI}} },
 { 0x0c800000, "tweqi",   {{16,5,GREG}, {0,16,SI}} },
 { 0x0d800000, "twgei",   {{16,5,GREG}, {0,16,SI}} },
 { 0x0d000000, "twgti",   {{16,5,GREG}, {0,16,SI}} },
 { 0x0d800000, "twnli",   {{16,5,GREG}, {0,16,SI}} },
 { 0x0f000000, "twnei",   {{16,5,GREG}, {0,16,SI}} },
 { 0x0e800000, "twngi",   {{16,5,GREG}, {0,16,SI}} },
 { 0x0c400000, "twllti",  {{16,5,GREG}, {0,16,SI}} },
 { 0x0cc00000, "twllei",  {{16,5,GREG}, {0,16,SI}} },
 { 0x0ca00000, "twlgei",  {{16,5,GREG}, {0,16,SI}} },
 { 0x0c200000, "twlgti",  {{16,5,GREG}, {0,16,SI}} },
 { 0x0ca00000, "twlnli",  {{16,5,GREG}, {0,16,SI}} },
 { 0x0cc00000, "twlngi",  {{16,5,GREG}, {0,16,SI}} },

 { 0x7c000008, "tw",      {{21,5,NUM},  {16,5,GREG}, {11,5,GREG}} },
 { 0x7c000008, "tw",      {{21,5,NUM},  {16,5,ZERO}, {11,5,ZERO}} },
 { 0x7e000008, "twlt",    {{16,5,GREG}, {11,5,GREG}} },
 { 0x7e800008, "twle",    {{16,5,GREG}, {11,5,GREG}} },
 { 0x7c800008, "tweq",    {{16,5,GREG}, {11,5,GREG}} },
 { 0x7d800008, "twge",    {{16,5,GREG}, {11,5,GREG}} },
 { 0x7d000008, "twgt",    {{16,5,GREG}, {11,5,GREG}} },
 { 0x7d800008, "twnl",    {{16,5,GREG}, {11,5,GREG}} },
 { 0x7f000008, "twne",    {{16,5,GREG}, {11,5,GREG}} },
 { 0x7e800008, "twng",    {{16,5,GREG}, {11,5,GREG}} },
 { 0x7c400008, "twllt",   {{16,5,GREG}, {11,5,GREG}} },
 { 0x7cc00008, "twlle",   {{16,5,GREG}, {11,5,GREG}} },
 { 0x7ca00008, "twlge",   {{16,5,GREG}, {11,5,GREG}} },
 { 0x7c200008, "twlgt",   {{16,5,GREG}, {11,5,GREG}} },
 { 0x7ca00008, "twlnl",   {{16,5,GREG}, {11,5,GREG}} },
 { 0x7cc00008, "twlng",   {{16,5,GREG}, {11,5,GREG}} },
 { 0x7fe00008, "trap",    },

 { 0x68000000, "xori",    {{16,5,GREG}, {21,5,GREG}, {0,16,UI}} },
 { 0x6c000000, "xoris",   {{16,5,GREG}, {21,5,GREG}, {0,16,UI}} },
 { 0x7c000278, "xor",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },
 { 0x7c000279, "xor.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}} },

/* Cache Management Instructions (from book II) */
 { 0x7c0007ac, "icbi",    {{16,5,G0REG}, {11,5,GREG}} },
 { 0x4c00012c, "isync",   },
 { 0x7c00022c, "dcbt",    {{16,5,G0REG}, {11,5,GREG}} },
 { 0x7c00022c, "dcbt",    {{16,5,G0REG}, {11,5,GREG}, {21,4,NUM}}, },
 { 0x7c0001ec, "dcbtst",  {{16,5,G0REG}, {11,5,GREG}} },
 { 0x7c00022c, "dcbt128", {{16,5,G0REG}, {11,5,GREG}, {21,4,NUM}},
   IMPL64|OPTIONAL },
 { 0x7c0007ec, "dcbz",    {{16,5,G0REG}, {11,5,GREG}} },
 { 0x7c2007ec, "dcbzl",   {{16,5,G0REG}, {11,5,GREG}} },
 { 0x7c2007ec, "dcbz128", {{16,5,G0REG}, {11,5,GREG}}, IMPL64|OPTIONAL },
 { 0x7c00006c, "dcbst",   {{16,5,G0REG}, {11,5,GREG}} },
 { 0x7c0000ac, "dcbf",    {{16,5,G0REG}, {11,5,GREG}} },
 { 0x7c00026c, "eciwx",   {{21,5,GREG},  {16,5,G0REG},{11,5,GREG}},
	OPTIONAL|CPU970 },
 { 0x7c00036c, "ecowx",   {{21,5,GREG},  {16,5,G0REG},{11,5,GREG}},
	OPTIONAL|CPU970 },
 { 0x7c0006ac, "eieio",   },
/* Instructions (from book III) */
 { 0x4c000064, "rfi",     },
 { 0x7c000124, "mtmsr",   {{21,5,GREG}} },
 { 0x7c000164, "mtmsrd",  {{21,5,GREG}}, IMPL64|OPTIONAL },
 { 0x7c000164, "mtmsrd",  {{21,5,GREG}, {16,1,NUM}}, IMPL64|OPTIONAL },
 { 0x7c0000a6, "mfmsr",   {{21,5,GREG}} },
 { 0x7c0005ec, "dcba",    {{16,5,G0REG},{11,5,GREG}}, OPTIONAL },
 { 0x7c0003ac, "dcbi",    {{16,5,G0REG},{11,5,GREG}} },
 { 0x7c0001a4, "mtsr",    {{16,4,SGREG},{21,5,GREG}} },
 { 0x7c0004a6, "mfsr",    {{21,5,GREG},{16,4,SGREG}} },
 { 0x7c0001e4, "mtsrin",  {{21,5,GREG}, {11,5,GREG}} },
 { 0x7c000526, "mfsrin",  {{21,5,GREG}, {11,5,GREG}} },
 { 0x7c000364, "slbie",   {{11,5,GREG}}, IMPL64|OPTIONAL },
 { 0x7c0003e4, "slbia",   {{0}},	 IMPL64|OPTIONAL },
 { 0x7c000324, "slbmte",  {{21,5,GREG}, {11,5,GREG}}, IMPL64|OPTIONAL },
 { 0x7c0006a6, "slbmfev", {{21,5,GREG}, {11,5,GREG}}, IMPL64|OPTIONAL },
 { 0x7c000726, "slbmfee", {{21,5,GREG}, {11,5,GREG}}, IMPL64|OPTIONAL },
 { 0x7c000264, "tlbie",   {{11,5,GREG}}, OPTIONAL|CPU970 },
 { 0x7c000264, "tlbie",   {{11,5,GREG}, {21,1,NUM}}, IMPL64|OPTIONAL|CPU970 },
 { 0x7c000224, "tlbiel",  {{11,5,GREG}}, IMPL64|OPTIONAL },
 { 0x7c0002e4, "tlbia",   {{0}},	 OPTIONAL|CPU970 },
 { 0x7c00046c, "tlbsync", {{0}},	 OPTIONAL|CPU970 },
 { 0x7c1c43a6, "mttbl",   {{21,5,GREG}} },
 { 0x7c1d43a6, "mttbu",   {{21,5,GREG}} },
 { 0x7c0002e6, "mftb",    {{21,5,GREG}, {11,10,SPREG}} },
 { 0x7c0c42e6, "mftb",    {{21,5,GREG}} },
 { 0x7c0d42e6, "mftbu",   {{21,5,GREG}} },
 { 0x00000200, "attn",    {{11,15,NUM}},	 OPTIONAL|CPU970 },

/* Instructions (from book IV) */
 { 0x24000000, "dozi",    {{21,5,GREG}, {16,5,GREG}, {0,16,SI}}, CPU601 },
 { 0x7c000210, "doz",     {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000211, "doz.",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000610, "dozo",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000611, "dozo.",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c0002d0, "abs",     {{21,5,GREG}, {16,5,GREG}}, CPU601 },
 { 0x7c0002d1, "abs.",    {{21,5,GREG}, {16,5,GREG}}, CPU601 },
 { 0x7c0006d0, "abso",    {{21,5,GREG}, {16,5,GREG}}, CPU601 },
 { 0x7c0006d1, "abso.",   {{21,5,GREG}, {16,5,GREG}}, CPU601 },

 { 0x7c0003d0, "nabs",    {{21,5,GREG}, {16,5,GREG}}, CPU601 },
 { 0x7c0003d1, "nabs.",   {{21,5,GREG}, {16,5,GREG}}, CPU601 },
 { 0x7c0007d0, "nabso",   {{21,5,GREG}, {16,5,GREG}}, CPU601 },
 { 0x7c0007d1, "nabso.",  {{21,5,GREG}, {16,5,GREG}}, CPU601 },

 { 0x1c000000, "mulli",   {{21,5,GREG}, {16,5,GREG}, {0,16,SI}} },

 { 0x7c0000d6, "mul",     {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c0000d7, "mul.",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c0004d6, "mulo",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c0004d7, "mulo.",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c000296, "div",     {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000297, "div.",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000696, "divo",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000697, "divo.",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c0002d6, "divs",    {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c0002d7, "divs.",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c0006d6, "divso",   {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c0006d7, "divso.",  {{21,5,GREG}, {16,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x58000000, "rlmi",
    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG},  {6,5,MBE}, {1,5,MBE}}, CPU601 },
 { 0x58000001, "rlmi.",
    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG},  {6,5,MBE}, {1,5,MBE}}, CPU601 },

 { 0x7c000432, "rrib",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000433, "rrib.",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c00003a, "maskg",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c00003b, "maskg.",  {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c00043a, "maskir",  {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c00043b, "maskir.", {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c000130, "slq",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000131, "slq.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c000530, "srq",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000531, "srq.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c000170, "sliq",    {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}, CPU601 },
 { 0x7c000171, "sliq.",   {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}, CPU601 },

 { 0x7c000570, "sriq",    {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}, CPU601 },
 { 0x7c000571, "sriq.",   {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}, CPU601 },

 { 0x7c0001f0, "slliq",   {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}, CPU601 },
 { 0x7c0001f1, "slliq.",  {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}, CPU601 },

 { 0x7c0005f0, "srliq",   {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}, CPU601 },
 { 0x7c0005f1, "srliq.",  {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}, CPU601 },

 { 0x7c0001b0, "sllq",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c0001b1, "sllq.",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c0005b0, "srlq",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c0005b1, "srlq.",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c000132, "sle",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000133, "sle.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c000532, "sre",     {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000533, "sre.",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c0001b2, "sleq",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c0001b3, "sleq.",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c0005b2, "sreq",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c0005b3, "sreq.",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c000770, "sraiq",   {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}, CPU601 },
 { 0x7c000771, "sraiq.",  {{16,5,GREG}, {21,5,GREG}, {11,5,NUM}}, CPU601 },

 { 0x7c000730, "sraq",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000731, "sraq.",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

 { 0x7c000732, "srea",    {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },
 { 0x7c000733, "srea.",   {{16,5,GREG}, {21,5,GREG}, {11,5,GREG}}, CPU601 },

/* Added from the PowerPC 601 book */
 { 0x7c000426, "clcs",    {{21,5,GREG}, {16,5,GREG}}, CPU601 },

/* Added from the PowerPC 603 book.
 * These are really 603 specific instructions but we mark them as OPTIONAL
 * so that the -force_cpusubtype_ALL flag as to be used.  This makes it so
 * only 601 instructions will cause the cputype to be set to other an ALL.
 */
 { 0x7c0007a4, "tlbld",   {{11,5,GREG}}, OPTIONAL },
 { 0x7c0007e4, "tlbli",   {{11,5,GREG}}, OPTIONAL },

/* VMX Instructions */
 { 0x7c00000e, "lvebx",   {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },
 { 0x7c00004e, "lvehx",   {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },
 { 0x7c00008e, "lvewx",   {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },
 { 0x7c0000ce, "lvx",     {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },
 { 0x7c0002ce, "lvxl",    {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },

 { 0x7c00010e, "stvebx",  {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },
 { 0x7c00014e, "stvehx",  {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },
 { 0x7c00018e, "stvewx",  {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },
 { 0x7c0001ce, "stvx",    {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },
 { 0x7c0003ce, "stvxl",   {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },

 { 0x7c00000c, "lvsl",    {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },
 { 0x7c00004c, "lvsr",    {{21,5,VREG}, {16,5,G0REG}, {11,5,GREG}}, VMX },

 { 0x10000644, "mtvscr",  {{11,5,VREG}}, VMX },
 { 0x10000604, "mfvscr",  {{21,5,VREG}}, VMX },

 { 0x7c0002ac, "dst",     {{16,5,GREG}, {11,5,GREG}, {21,2,NUM}}, VMX },
 { 0x7e0002ac, "dstt",    {{16,5,GREG}, {11,5,GREG}, {21,2,NUM}}, VMX },
 { 0x7c0002ec, "dstst",   {{16,5,GREG}, {11,5,GREG}, {21,2,NUM}}, VMX },
 { 0x7e0002ec, "dststt",  {{16,5,GREG}, {11,5,GREG}, {21,2,NUM}}, VMX },
 { 0x7c00066c, "dss",     {{21,2,NUM}}, VMX },
 { 0x7e00066c, "dssall",  {{0}}, VMX},

 { 0x10000000, "vaddubm", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000200, "vaddubs", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000300, "vaddsbs", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000040, "vadduhm", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000240, "vadduhs", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000340, "vaddshs", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000080, "vadduwm", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000280, "vadduws", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000380, "vaddsws", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000000a, "vaddfp",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000180, "vaddcuw", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000400, "vsububm", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000600, "vsububs", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000700, "vsubsbs", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000440, "vsubuhm", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000640, "vsubuhs", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000740, "vsubshs", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000480, "vsubuwm", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000680, "vsubuws", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000780, "vsubsws", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000004a, "vsubfp",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000580, "vsubcuw", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000008, "vmuloub", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000108, "vmulosb", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000048, "vmulouh", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000148, "vmulosh", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000208, "vmuleub", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000308, "vmulesb", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000248, "vmuleuh", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000348, "vmulesh", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000020, "vmhaddshs",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,5,VREG}}, VMX },
 { 0x10000021, "vmhraddshs",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,5,VREG}}, VMX },
 { 0x10000022, "vmladduhm",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,5,VREG}}, VMX },
 { 0x1000002e, "vmaddfp",
	{{21,5,VREG}, {16,5,VREG}, {6,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000024, "vmsumubm",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,5,VREG}}, VMX },
 { 0x10000025, "vmsummbm",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,5,VREG}}, VMX },
 { 0x10000026, "vmsumuhm",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,5,VREG}}, VMX },
 { 0x10000027, "vmsumuhs",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,5,VREG}}, VMX },
 { 0x10000028, "vmsumshm",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,5,VREG}}, VMX },
 { 0x10000029, "vmsumshs",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,5,VREG}}, VMX },

 { 0x10000788, "vsumsws",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000688, "vsum2sws", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000608, "vsum4ubs", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000708, "vsum4sbs", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000648, "vsum4shs", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000402, "vavgub", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000442, "vavguh", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000482, "vavguw", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000502, "vavgsb", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000542, "vavgsh", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000582, "vavgsw", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000404, "vand",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000484, "vor",    {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100004c4, "vxor",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000444, "vandc",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000504, "vnor",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000004, "vrlb",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000044, "vrlh",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000084, "vrlw",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000104, "vslb",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000144, "vslh",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000184, "vslw",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100001c4, "vsl",    {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000204, "vsrb",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000304, "vsrab",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000244, "vsrh",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000344, "vsrah",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000284, "vsrw",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000384, "vsraw",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100002c4, "vsr",    {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000206, "vcmpgtub",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000606, "vcmpgtub.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000306, "vcmpgtsb",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000706, "vcmpgtsb.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000246, "vcmpgtuh",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000646, "vcmpgtuh.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000346, "vcmpgtsh",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000746, "vcmpgtsh.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000286, "vcmpgtuw",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000686, "vcmpgtuw.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000386, "vcmpgtsw",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000786, "vcmpgtsw.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100002c6, "vcmpgtfp",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100006c6, "vcmpgtfp.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000006, "vcmpequb",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000406, "vcmpequb.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000046, "vcmpequh",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000446, "vcmpequh.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000086, "vcmpequw",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000486, "vcmpequw.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100000c6, "vcmpeqfp",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100004c6, "vcmpeqfp.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x100001c6, "vcmpgefp",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100005c6, "vcmpgefp.", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x100003c6, "vcmpbfp",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100007c6, "vcmpbfp.",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x1000002a, "vsel",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,5,VREG}}, VMX },

 { 0x1000000e, "vpkuhum", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000008e, "vpkuhus", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000010e, "vpkshus", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000018e, "vpkshss", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000004e, "vpkuwum", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100000ce, "vpkuwus", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000014e, "vpkswus", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100001ce, "vpkswss", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000030e, "vpkpx",   {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x1000020e, "vupkhsb", {{21,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000024e, "vupkhsh", {{21,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000034e, "vupkhpx", {{21,5,VREG}, {11,5,VREG}}, VMX },

 { 0x1000028e, "vupklsb", {{21,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100002ce, "vupklsh", {{21,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100003ce, "vupklpx", {{21,5,VREG}, {11,5,VREG}}, VMX },

 { 0x1000000c, "vmrghb",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000004c, "vmrghh",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000008c, "vmrghw",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x1000010c, "vmrglb",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000014c, "vmrglh",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000018c, "vmrglw",  {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x1000020c, "vspltb",  {{21,5,VREG}, {11,5,VREG}, {16,5,NUM}}, VMX },
 { 0x1000024c, "vsplth",  {{21,5,VREG}, {11,5,VREG}, {16,5,NUM}}, VMX },
 { 0x1000028c, "vspltw",  {{21,5,VREG}, {11,5,VREG}, {16,5,NUM}}, VMX },

 { 0x1000030c, "vspltisb",{{21,5,VREG}, {16,5,SNUM}}, VMX },
 { 0x1000034c, "vspltish",{{21,5,VREG}, {16,5,SNUM}}, VMX },
 { 0x1000038c, "vspltisw",{{21,5,VREG}, {16,5,SNUM}}, VMX },

 { 0x1000002b, "vperm",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,5,VREG}}, VMX },

 { 0x1000002c, "vsldoi",
	{{21,5,VREG}, {16,5,VREG}, {11,5,VREG}, {6,4,NUM}}, VMX },

 { 0x1000040c, "vslo",    {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000044c, "vsro",    {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000002, "vmaxub", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000102, "vmaxsb", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000042, "vmaxuh", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000142, "vmaxsh", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000082, "vmaxuw", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000182, "vmaxsw", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000040a, "vmaxfp", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x10000202, "vminub", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000302, "vminsb", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000242, "vminuh", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000342, "vminsh", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000282, "vminuw", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x10000382, "vminsw", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000044a, "vminfp", {{21,5,VREG}, {16,5,VREG}, {11,5,VREG}}, VMX },

 { 0x1000010a, "vrefp",    {{21,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000014a, "vrsqrtefp",{{21,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100001ca, "vlogefp",  {{21,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000018a, "vexptefp", {{21,5,VREG}, {11,5,VREG}}, VMX },

 { 0x1000002f, "vnmsubfp",
	{{21,5,VREG}, {16,5,VREG}, {6,5,VREG}, {11,5,VREG}}, VMX },

 { 0x1000020a, "vrfin",  {{21,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000024a, "vrfiz",  {{21,5,VREG}, {11,5,VREG}}, VMX },
 { 0x1000028a, "vrfip",  {{21,5,VREG}, {11,5,VREG}}, VMX },
 { 0x100002ca, "vrfim",  {{21,5,VREG}, {11,5,VREG}}, VMX },

 { 0x1000038a, "vctuxs", {{21,5,VREG}, {11,5,VREG}, {16,5,NUM}}, VMX },
 { 0x100003ca, "vctsxs", {{21,5,VREG}, {11,5,VREG}, {16,5,NUM}}, VMX },

 { 0x1000030a, "vcfux", {{21,5,VREG}, {11,5,VREG}, {16,5,NUM}}, VMX },
 { 0x1000034a, "vcfsx", {{21,5,VREG}, {11,5,VREG}, {16,5,NUM}}, VMX },

 { 0, "" } /* end of table marker */
};
                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc.c                                    0100644 0001750 0001750 00000177460 12612724204 022006  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <mach-o/ppc/reloc.h>
#include "ppc-opcode.h"
#include "as.h"
#include "flonum.h"
#include "expr.h"
#include "hash.h"
#include "read.h"
#include "md.h"
#include "obstack.h"
#include "symbols.h"
#include "messages.h"
#include "atof-ieee.h"
#include "input-scrub.h"
#include "sections.h"
#include "dwarf2dbg.h"

/*
 * The assembler can assemble the trailing +/- by setting either the Y-bit or
 * the AT-bits.  The default is setting the Y-bit and is the same as specifying:
 *  -static_branch_prediction_Y_bit
 *	Treat a single trailing '+' or '-' after a conditional PowerPC branch
 *	instruction as a static branch prediction that sets the Y-bit in the
 *	opcode.  Pairs of trailing "++" or "--" always set the AT-bits. This is
 *	the default for Mac OS X.
 * This can be changed by specifying:
 * -static_branch_prediction_AT_bits
 *	Treat a single trailing '+' or '-' after a conditional PowerPC branch
 *	instruction as a static branch prediction sets the AT-bits in the
 *	opcode. Pairs of trailing "++" or "--" always set the AT-bits but with
 *	this option a warning is issued if this syntax is used.  With this flag 
 *	the assembler behaves like the IBM tools.
 */
enum static_branch_prediction {
    STATIC_BRANCH_PREDICTION_Y_BIT,
    STATIC_BRANCH_PREDICTION_AT_BITS
};
static int static_branch_prediction_specified = 0;
static enum static_branch_prediction static_branch_prediction =
    STATIC_BRANCH_PREDICTION_Y_BIT;

/* relocation type for internal assembler use only for LIKELY_{,NOT_}TAKEN */
#define PPC_RELOC_BR14_predicted (0x10 | PPC_RELOC_BR14)
enum branch_prediction {
    BRANCH_PREDICTION_NONE,
    BRANCH_PREDICTION_LIKELY_TAKEN,
    BRANCH_PREDICTION_LIKELY_NOT_TAKEN,
    BRANCH_PREDICTION_VERY_LIKELY_TAKEN,
    BRANCH_PREDICTION_VERY_LIKELY_NOT_TAKEN
};

/*
 * Set if -no_ppc601 is specified or .no_pcc601 is seen.  It flags all 601
 * uses as errors.
 */
static int no_ppc601 = 0;

/*
 * The directive .flag_reg and .noflag_reg use these to flag register usage. 
 */
int flag_registers = 0;
int flag_gregs[32] = { 0 };

/*
 * These are the default cputype and cpusubtype for the ppc architecture.
 */
#ifdef ARCH64
const cpu_type_t md_cputype = CPU_TYPE_POWERPC64;
cpu_subtype_t md_cpusubtype = CPU_SUBTYPE_POWERPC_ALL;
#else
const cpu_type_t md_cputype = CPU_TYPE_POWERPC;
cpu_subtype_t md_cpusubtype = CPU_SUBTYPE_POWERPC_ALL;
#endif

/* This is the byte sex for the ppc architecture */
const enum byte_sex md_target_byte_sex = BIG_ENDIAN_BYTE_SEX;

/* These characters start a comment anywhere on the line */
const char md_comment_chars[] = ";";

/* These characters only start a comment at the beginning of a line */
const char md_line_comment_chars[] = "#";

/*
 * These characters can be used to separate mantissa decimal digits from 
 * exponent decimal digits in floating point numbers.
 */
const char md_EXP_CHARS[] = "eE";

/*
 * The characters after a leading 0 that means this number is a floating point
 * constant as in 0f123.456 or 0d1.234E-12 (see md_EXP_CHARS above).
 */
const char md_FLT_CHARS[] = "dDfF";

/*
 * This is the machine dependent pseudo opcode table for this target machine.
 */
static void s_reg(
    uintptr_t reg);
static void s_no_ppc601(
    uintptr_t ignore);
static void s_flag_reg(
    uintptr_t ignore);
static void s_noflag_reg(
    uintptr_t ignore);
const pseudo_typeS md_pseudo_table[] =
{
    {"greg",		s_reg,		'r' },
    {"no_ppc601",	s_no_ppc601,	0 },
    {"flag_reg",	s_flag_reg,	0 },
    {"noflag_reg",	s_noflag_reg,	0 },
    {"file", (void (*) (uintptr_t)) dwarf2_directive_file, 0},
    {"loc", dwarf2_directive_loc, 0},
    {0} /* end of table marker */
};

#define RT(x)           (((x) >> 21) & 0x1f)
#define RA(x)           (((x) >> 16) & 0x1f)
#define RB(x)           (((x) >> 11) & 0x1f)

struct ppc_insn {
    uint32_t opcode;
    expressionS exp;
    expressionS jbsr_exp;
    int reloc;
    int32_t pcrel;
    int32_t pcrel_reloc;
};

/*
 * The pointer to the opcode hash table built by md_begin() and used by
 * md_assemble() to look up opcodes.
 */
static struct hash_control *op_hash = NULL;

/*
 * These aid in the printing of better error messages for parameter syntax
 * errors when there is only one mnemonic in the tables.
 */
static uint32_t error_param_count = 0;
static char *error_param_message = NULL;

/*
 * These are name names of the known special registers and the numbers assigned
 * to them.
 */
struct special_register {
    uint32_t number;
    char *name;
};
static const struct special_register special_registers[] = {
    { 0,   "mq" },  /* 601 only */
    { 1,   "xer" }, /* user access */
    { 4,   "rtcu" },/* real time counter high (601 only, not in PowerPC arch)*/
    { 5,   "rtcl" },/* real time counter low (601 only, not in PowerPC arch) */
    { 8,   "lr" },  /* user access */
    { 9,   "ctr" }, /* user access */
    { 18,  "dsisr" },
    { 19,  "dar" },
    { 22,  "dec" },
    { 25,  "sdr1" },
    { 26,  "srr0" },
    { 27,  "srr1" },
    { 256, "VRsave" }, /* user access, VMX register save */
    { 272, "sprg0" },
    { 273, "sprg1" },
    { 274, "sprg2" },
    { 275, "sprg3" },
    { 280, "asr" },	/* 64-bit implementaions only */
    { 282, "ear" },	/* optional in the PowerPC architecure */
    { 284, "tbl" },
    { 285, "tbu" },
    { 287, "pvr" },
    { 528, "ibat0u" },
    { 529, "ibat0l" },
    { 530, "ibat1u" },
    { 531, "ibat1l" },
    { 532, "ibat2u" },
    { 533, "ibat2l" },
    { 534, "ibat3u" },
    { 535, "ibat3l" },
    { 536, "dbat0u" },
    { 537, "dbat0l" },
    { 538, "dbat1u" },
    { 539, "dbat1l" },
    { 540, "dbat2u" },
    { 541, "dbat2l" },
    { 542, "dbat3u" },
    { 543, "dbat3l" },
    { 936, "ummcr0" },/* 750 only */
    { 937, "upmc1" }, /* 750 only */
    { 938, "upmc2" }, /* 750 only */
    { 939, "usia" },  /* 750 only */
    { 940, "ummcr1" },/* 750 only */
    { 941, "upmc3" }, /* 750 only */
    { 942, "upmc4" }, /* 750 only */
    { 952, "mmcr0" }, /* 604, 604e, 750 only */
    { 953, "pmc1" },  /* 604, 604e & 750 only */
    { 954, "pmc2" },  /* 604, 604e & 750 only */
    { 955, "sia" },   /* 604, 604e & 750 only */
    { 956, "mmcr1" }, /* 604e & 750 only */
    { 957, "pmc3" },  /* 604e & 750 only */
    { 958, "pmc4" },  /* 604e & 750 only */
    { 959, "sda" },   /* 604 & 604e only */
    { 976, "dmiss" }, /* 603 only */
    { 977, "dcmp" },  /* 603 only */
    { 978, "hash1" }, /* 603 only */
    { 979, "hash2" }, /* 603 only */
    { 980, "imiss" }, /* 603 only */
    { 981, "icmp" },  /* 603 only */
    { 982, "rpa" },   /* 603 only */
    { 1008,"hid0" }, /* 601, 603, 603e, 604, 604e, 750 only */
    { 1009,"hid1" }, /* 601, 603e, 604e 750 only */
    { 1010,"hid2" }, /* 601 */
    { 1010,"iabr" }, /* 601, 603, 603e, 604, 604e & 750 only */
    { 1013,"hid5" }, /* 601 only */
    { 1013,"dabr" }, /* optional in the PowerPC architecure (604, 604e & 750) */
    { 1017,"l2cr" }, /* 750 only */
    { 1019,"ictc" }, /* 750 only */
    { 1020,"thrm1" },/* 750 only */
    { 1021,"thrm2" },/* 750 only */
    { 1022,"thrm3" },/* 750 only */
    { 1023,"hid15" }, /* 601 only */
    { 1023,"pir" }, /* 601, 604 & 604e only */
    { 0, "" } /* end of table marker */
};

/*
 * These are name names of the condition field special registers and the
 * numbers assigned to them.
 */
struct condition_symbol {
    uint32_t value;
    char *name;
};
static const struct condition_symbol condition_symbols[] = {
    { 0, "lt" }, /* less than */
    { 1, "gt" }, /* greater than */
    { 2, "eq" }, /* equal */
    { 3, "so" }, /* summary overflow */
    { 3, "un" }, /* unordered */
    { 0, "" } /* end of table marker */
};

struct CR_field {
    uint32_t value;
    char *name;
};
static const struct CR_field CR_fields[] = {
    { 0,  "cr0" }, /* CR field 0 */
    { 4,  "cr1" }, /* CR field 1 */
    { 8,  "cr2" }, /* CR field 2 */
    { 12, "cr3" }, /* CR field 3 */
    { 16, "cr4" }, /* CR field 4 */
    { 20, "cr5" }, /* CR field 5 */
    { 24, "cr6" }, /* CR field 6 */
    { 28, "cr7" }, /* CR field 7 */
    { 0, "" } /* end of table marker */
};

/*
 * These are built in macros because they are trivial to implement as macros
 * which otherwise be less obvious to do special entries for them.
 */
struct macros {
    char *name;
    char *body;
};
static const struct macros ppc_macros[] = {
    { "mr\n",      "or $0,$1,$1\n" },
    { "mr.\n",     "or. $0,$1,$1\n" },
    { "not\n",     "nor $0,$1,$1\n" },
    { "not.\n",    "nor. $0,$1,$1\n" },
    { "extldi\n",  "rldicr $0,$1,$3,($2)-1\n" },
    { "extldi.\n", "rldicr. $0,$1,$3,($2)-1\n" },
    { "extrdi\n",  "rldicl $0,$1,($2)+($3),64-($2)\n" },
    { "extrdi.\n", "rldicl. $0,$1,($2)+($3),64-($2)\n" },
    { "insrdi\n",  "rldimi $0,$1,64-(($3)+($2)),$3\n" },
    { "insrdi.\n", "rldimi. $0,$1,64-(($3)+($2)),$3\n" },
    { "rotldi\n",  "rldicl $0,$1,$2,0\n" },
    { "rotldi.\n", "rldicl. $0,$1,$2,0\n" },
    { "rotrdi\n",  "rldicl $0,$1,64-($2),0\n" },
    { "rotrdi.\n", "rldicl. $0,$1,64-($2),0\n" },
    { "rotld\n",   "rldcl $0,$1,$2,0\n" },
    { "rotld.\n",  "rldcl. $0,$1,$2,0\n" },
    { "sldi\n",    "rldicr $0,$1,$2,63-($2)\n" },
    { "sldi.\n",   "rldicr. $0,$1,$2,63-($2)\n" },
    { "srdi\n",    "rldicl $0,$1,64-($2),$2\n" },
    { "srdi.\n",   "rldicl. $0,$1,64-($2),$2\n" },
    { "clrldi\n",  "rldicl $0,$1,0,$2\n" },
    { "clrldi.\n", "rldicl. $0,$1,0,$2\n" },
    { "clrrdi\n",  "rldicr $0,$1,0,63-($2)\n" },
    { "clrrdi.\n", "rldicr. $0,$1,0,63-($2)\n" },
    { "clrlsldi\n","rldic $0,$1,$3,($2)-($3)\n" },
    { "clrlsldi.\n","rldic. $0,$1,$3,($2)-($3)\n" },

    { "extlwi\n",  "rlwinm $0,$1,$3,0,($2)-1\n" },
    { "extlwi.\n", "rlwinm. $0,$1,$3,0,($2)-1\n" },
    { "extrwi\n",  "rlwinm $0,$1,($2)+($3),32-($2),31\n" },
    { "extrwi.\n", "rlwinm. $0,$1,($2)+($3),32-($2),31\n" },
    { "inslwi\n",  "rlwimi $0,$1,32-($3),$3,(($3)+($2))-1\n" },
    { "inslwi.\n", "rlwimi. $0,$1,32-($3),$3,(($3)+($2))-1\n" },
    { "insrwi\n",  "rlwimi $0,$1,32-(($3)+($2)),$3,(($3)+($2))-1\n" },
    { "insrwi.\n", "rlwimi. $0,$1,32-(($3)+($2)),$3,(($3)+($2))-1\n" },
    { "rotlwi\n",  "rlwinm $0,$1,$2,0,31\n" },
    { "rotlwi.\n", "rlwinm. $0,$1,$2,0,31\n" },
    { "rotrwi\n",  "rlwinm $0,$1,32-($2),0,31\n" },
    { "rotrwi.\n", "rlwinm. $0,$1,32-($2),0,31\n" },
    { "rotlw\n",   "rlwnm $0,$1,$2,0,31\n" },
    { "rotlw.\n",  "rlwnm. $0,$1,$2,0,31\n" },
    { "slwi\n",    "rlwinm $0,$1,$2,0,31-($2)\n" },
    { "slwi.\n",   "rlwinm. $0,$1,$2,0,31-($2)\n" },
    { "srwi\n",    "rlwinm $0,$1,32-($2),$2,31\n" },
    { "srwi.\n",   "rlwinm. $0,$1,32-($2),$2,31\n" },
    { "clrlwi\n",  "rlwinm $0,$1,0,$2,31\n" },
    { "clrlwi.\n", "rlwinm. $0,$1,0,$2,31\n" },
    { "clrrwi\n",  "rlwinm $0,$1,0,0,31-($2)\n" },
    { "clrrwi.\n", "rlwinm. $0,$1,0,0,31-($2)\n" },
    { "clrlslwi\n","rlwinm $0,$1,$3,($2)-($3),31-($3)\n" },
    { "clrlslwi.\n","rlwinm. $0,$1,$3,($2)-($3),31-($3)\n" },

    { "mtxer\n",   "mtspr 1,$0\n"},
    { "mfxer\n",   "mfspr $0,1\n"},
    { "mtlr\n",    "mtspr 8,$0\n"},
    { "mflr\n",    "mfspr $0,8\n"},
    { "mtctr\n",   "mtspr 9,$0\n"},
    { "mfctr\n",   "mfspr $0,9\n"},
    { "mtdsisr\n", "mtspr 18,$0\n"},
    { "mfdsisr\n", "mfspr $0,18\n"},
    { "mtdar\n",   "mtspr 19,$0\n"},
    { "mfdar\n",   "mfspr $0,19\n"},
    { "mtdec\n",   "mtspr 22,$0\n"},
    { "mfdec\n",   "mfspr $0,22\n"},
    { "mtsdr1\n",  "mtspr 25,$0\n"},
    { "mfsdr1\n",  "mfspr $0,25\n"},
    { "mtsrr0\n",  "mtspr 26,$0\n"},
    { "mfsrr0\n",  "mfspr $0,26\n"},
    { "mtsrr1\n",  "mtspr 27,$0\n"},
    { "mfsrr1\n",  "mfspr $0,27\n"},
    { "mtsprg\n",  "mtspr 272+($0),$1\n"},
    { "mfsprg\n",  "mfspr $0,272+($1)\n"},
    { "mtasr\n",   "mtspr 280,$0\n"},
    { "mfasr\n",   "mfspr $0,280\n"},
    { "mfear\n",   "mfspr $0,282\n"},
    { "mtear\n",   "mtspr 282,$0\n"},
    { "mfpvr\n",   "mfspr $0,287\n"},
    { "mtvrsave\n","mtspr 256,$0\n"},
    { "mtibatu\n", "mtspr 528+2*($0),$1\n"},
    { "mfibatu\n", "mfspr $0,528+2*($1)\n"},
    { "mtibatl\n", "mtspr 529+2*($0),$1\n"},
    { "mfibatl\n", "mfspr $0,529+2*($1)\n"},
    { "mtdbatu\n", "mtspr 536+2*($0),$1\n"},
    { "mfdbatu\n", "mfspr $0,536+2*($1)\n"},
    { "mtdbatl\n", "mtspr 537+2*($0),$1\n"},
    { "mfdbatl\n", "mfspr $0,537+2*($1)\n"},

    { "subi\n",    "addi $0,$1,-($2)\n"},
    { "subis\n",   "addis $0,$1,-($2)\n"},
    { "subic\n",   "addic $0,$1,-($2)\n"},
    { "subic.\n",  "addic. $0,$1,-($2)\n"},

    { "crclr\n",   "crxor $0,$0,$0\n"},
    { "crmove\n",  "cror $0,$1,$1\n"},
    { "crnot\n",   "crnor $0,$1,$1\n"},
    { "crset\n",   "creqv $0,$0,$0\n"},
    { "mtcr\n",    "mtcrf 0xff,$0\n"},
    { "mtfs\n",    "mtfsf 0xff,$0\n"},
    { "mtfs.\n",   "mtfsf. 0xff,$0\n"},

    { "vmr\n",  "vor $0,$1,$1\n"},
    { "vnot\n",   "vnor $0,$1,$1\n"},

    {  "", "" } /* end of table marker */
};

static int calcop(
    struct ppc_opcode *format,
    char *param,
    struct ppc_insn *insn,
    char *op,
    enum branch_prediction prediction);
static char *parse_jbsr(
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    int parcnt);
static char *parse_branch(
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    int parcnt);
static char *parse_displacement(
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    int parcnt);
static char *parse_immediate(
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    int parcnt);
static char *parse_reg(
    char *reg_name,
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    uint32_t parcnt);
static char *parse_spreg(
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    uint32_t parcnt);
static char *parse_bcnd(
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    uint32_t parcnt);
static char *parse_crf(
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    uint32_t parcnt);
static char *parse_num(
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    uint32_t parcnt,
    int32_t max_width_zero,
    int32_t zero_only,
    int32_t signed_num,
    int32_t bit_mask_with_1_bit_set);
static char *parse_mbe(
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    uint32_t parcnt);
static char *parse_sh(
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    uint32_t parcnt);
static char *parse_mb(
    char *param,
    struct ppc_insn *insn,
    struct ppc_opcode *format,
    uint32_t parcnt);

/*
 * md_begin() is called from main() in as.c before assembly begins.  It is used
 * to allow target machine dependent initialization.
 */
void
md_begin(void)
{
    uint32_t i;
    char *name;
    const char *retval;

	/* initialize the opcode hash table */
	op_hash = hash_new();
	if(op_hash == NULL)
	    as_fatal("Could not initialize the opcode hash table");

	/* loop until you see the end of the list */
	i = 0;
	while(*ppc_opcodes[i].name){
	    name = ppc_opcodes[i].name;

	    /* hash each mnemonic and record its position */
	    retval = hash_insert(op_hash, name, (char *)&ppc_opcodes[i]);
	    if(retval != NULL && *retval != '\0')
		as_fatal("Can't hash instruction '%s':%s",
			 ppc_opcodes[i].name, retval);

	    /* skip to next unique mnemonic or end of list */
	    for(i++; strcmp(ppc_opcodes[i].name, name) == 0; i++)
		;
	}

	/*
	 * Load the builtin macros for extended mnemonics for rotate and
	 * shift mnemonics.
	 */
	for(i = 0; *ppc_macros[i].name != '\0'; i++){
	    input_line_pointer = ppc_macros[i].name;
	    s_macro(0);
	    add_to_macro_definition(ppc_macros[i].body);
	    s_endmacro(0);
	}
}

/*
 * md_end() is called from main() in as.c after assembly ends.  It is used
 * to allow target machine dependent clean up.
 */
void
md_end(void)
{
}

/*
 * md_parse_option() is called from main() in as.c to parse target machine
 * dependent command line options.  This routine returns 0 if it is passed an
 * option that is not recognized non-zero otherwise.
 */
int
md_parse_option(
char **argP,
int *cntP,
char ***vecP)
{
	switch(**argP) {
	case 'n':
	    if(strcmp(*argP, "no_ppc601") == 0){
		no_ppc601 = 1;
		*argP = "";
		return(1);
	    }
	    break;
	case 'p':
	    if(strcmp(*argP, "ppcasm") == 0){
		*argP = "";
		return(1);
	    }
	    break;
	case 's':
	    if(strcmp(*argP, "static_branch_prediction_Y_bit") == 0){
		if(static_branch_prediction_specified &&
		   static_branch_prediction != STATIC_BRANCH_PREDICTION_Y_BIT)
		    as_bad("Can't specify both -static_branch_prediction_Y_bit"
			    " and -static_branch_prediction_AT_bits");
		static_branch_prediction_specified = 1;
		static_branch_prediction = STATIC_BRANCH_PREDICTION_Y_BIT;
		*argP = "";
		return(1);
	    }
	    else if(strcmp(*argP, "static_branch_prediction_AT_bits") == 0){
		if(static_branch_prediction_specified &&
		   static_branch_prediction != STATIC_BRANCH_PREDICTION_AT_BITS)
		    as_bad("Can't specify both -static_branch_prediction_Y_bit"
			    " and -static_branch_prediction_AT_bits");
		static_branch_prediction_specified = 1;
		static_branch_prediction = STATIC_BRANCH_PREDICTION_AT_BITS;
		*argP = "";
		return(1);
	    }
	    break;
	}
	return(0);
}

/*
 * s_reg() is used to implement ".greg symbol,exp" which sets symbol to 1 or 0
 * depending on if the expression is a general register.  This is intended for
 * use in macros.
 */
static
void
s_reg(
uintptr_t reg)
{
	char *name, *end_name, delim;
	symbolS *symbolP;
	uint32_t n_value, val;

	if( * input_line_pointer == '"')
	  name = input_line_pointer + 1;
	else
	  name = input_line_pointer;
	delim = get_symbol_end();
	end_name = input_line_pointer;
	*end_name = delim;
	SKIP_WHITESPACE();
	if ( * input_line_pointer != ',' ) {
		*end_name = 0;
		as_bad("Expected comma after name \"%s\"", name);
		*end_name = delim;
		ignore_rest_of_line();
		return;
	}
	input_line_pointer ++;
	*end_name = 0;

	SKIP_WHITESPACE();
	n_value = 0;
	if (*input_line_pointer == reg || *input_line_pointer == toupper(reg)){
	    input_line_pointer++;
	    if(isdigit(*input_line_pointer)){
		val = 0;
		while (isdigit(*input_line_pointer)){
		    if ((val = val * 10 + *input_line_pointer++ - '0') > 31)
			break;
		}
		SKIP_WHITESPACE();
		if(val <= 31 &&
		   (*input_line_pointer == '\n' || *input_line_pointer == '@'))
		    n_value = 1;
	    }
	}

	symbolP = symbol_find_or_make (name);
	symbolP -> sy_type = N_ABS;
	symbolP -> sy_other = 0; /* NO_SECT */
	symbolP -> sy_value = n_value;
	symbolP -> sy_frag = & zero_address_frag;

	*end_name = delim;
	totally_ignore_line();
}

/*
 * s_no_ppc601() inplements .no_ppc601 which causes 601 instructions to be
 * flagged as errors.  This is the same as if -no_ppc601 is specified.
 */
static
void
s_no_ppc601(
uintptr_t ignore)
{
	no_ppc601 = 1;
	totally_ignore_line();
}

/*
 * s_flag_reg() implements .flag_reg <reg_number> so that uses of that register
 * get flagged as warnings.
 */
static
void
s_flag_reg(
uintptr_t ignore)
{
   int reg;

	reg = get_absolute_expression();
	if(reg < 0 || reg >= 32)
	    as_bad("register number (%d) out of range (0-31) for .flag_reg",
		    reg);
	demand_empty_rest_of_line();
	flag_registers = 1;
	flag_gregs[reg] = 1;
}

/*
 * s_noflag_reg() implements .noflag_reg <reg_number> so that uses of that
 * register no longer get flagged as warnings.
 */
static
void
s_noflag_reg(
uintptr_t ignore)
{
   int i, reg;

	reg = get_absolute_expression();
	if(reg < 0 || reg >= 32)
	    as_bad("register number (%d) out of range (0-31) for .noflag_reg",
		    reg);
	demand_empty_rest_of_line();
	flag_gregs[reg] = 0;
	flag_registers = 0;
	for(i = 0; i < 32; i++){
	    if(flag_gregs[i]){
		flag_registers = 1;
		return;
	    }
	}
}

/*
 * md_assemble() is passed a pointer to a string that should be a assembly
 * statement for the target machine.
 */
void
md_assemble(
char *op)
{
    char *param, *thisfrag, *start_op, *end_op;
    enum branch_prediction prediction;
    struct ppc_opcode *format;
    struct ppc_insn insn;
    uint32_t i, val, retry;

    static char *file_spec;
    static uint32_t line_spec;
    static int syntax_warning_issued_for_AT_bits = 0;

	/*
	 * Pick up the instruction and any trailing branch prediction character
	 * (a trailing '+', '-' on the instruction).
  	 */
	prediction = BRANCH_PREDICTION_NONE;
	start_op = op;
	end_op = op;
	for(param = op; !isspace(*param) && *param != '\0' ; param++)
	    end_op = param;
	if(*end_op == '+'){
	    if(end_op != start_op && end_op[-1] == '+'){
		if(static_branch_prediction ==
		   STATIC_BRANCH_PREDICTION_AT_BITS &&
		   syntax_warning_issued_for_AT_bits == 0){
		    as_warn("branch prediction ++/-- syntax always sets the "
			       "AT-bits");
		    syntax_warning_issued_for_AT_bits = 1;
		}
		prediction = BRANCH_PREDICTION_VERY_LIKELY_TAKEN;
		end_op[-1] = '\0';
	    }
	    else{
		if(static_branch_prediction == STATIC_BRANCH_PREDICTION_AT_BITS)
		    prediction = BRANCH_PREDICTION_VERY_LIKELY_TAKEN;
		else
		    prediction = BRANCH_PREDICTION_LIKELY_TAKEN;
		*end_op = '\0';
	    }
	}
	else if(*end_op == '-'){
	    if(end_op != start_op && end_op[-1] == '-'){
		if(static_branch_prediction ==
		   STATIC_BRANCH_PREDICTION_AT_BITS &&
		   syntax_warning_issued_for_AT_bits == 0){
		    as_warn("branch prediction ++/-- syntax always sets the "
			       "AT-bits");
		    syntax_warning_issued_for_AT_bits = 1;
		}
		prediction = BRANCH_PREDICTION_VERY_LIKELY_NOT_TAKEN;
		end_op[-1] = '\0';
	    }
	    else{
		if(static_branch_prediction == STATIC_BRANCH_PREDICTION_AT_BITS)
		    prediction = BRANCH_PREDICTION_VERY_LIKELY_NOT_TAKEN;
		else
		    prediction = BRANCH_PREDICTION_LIKELY_NOT_TAKEN;
		*end_op = '\0';
	    }
	}
	if(*param != '\0')
	    *param++ = '\0';

	/* try to find the instruction in the hash table */
	if((format = (struct ppc_opcode *)hash_find(op_hash, op)) == NULL){
	    as_bad("Invalid mnemonic '%s'", op);
	    return;
	}

	/* try parsing this instruction into insn */
	retry = 0;
	error_param_count = 0;
	error_param_message = NULL;
	while(calcop(format, param, &insn, op, prediction) == 0){
	    /* if it doesn't parse try the next instruction */
	    if(strcmp(format->name, format[1].name) == 0){
		format++;
		retry = 1;
	    }
	    else{
		if(retry == 0){
		    if(error_param_message != NULL)
			as_bad("%s (parameter %u)", error_param_message,
			       error_param_count + 1);
		    else
			as_bad("Parameter syntax error (parameter %u)",
				error_param_count + 1);
		}
		else
		    as_bad("Parameter syntax error");
		return;
	    }
	}

#ifndef ALLOW_INVALID_FORMS
	/*
	 * Check for invalid forms of instructions.  For the following
	 * instructions: lbzu, lbzux, lhzu, lhzux, lhau, lhaux, lwzu, lwzux,
	 * lwaux, ldu, ldux
	 * if RA == 0 or RA == RT the instruction form is invalid.
	 */
	if((insn.opcode & 0xfc000000) == 0x8c000000 || /* lbzu */
	   (insn.opcode & 0xfc0007fe) == 0x7c0000ee || /* lbzux */
	   (insn.opcode & 0xfc000000) == 0xa4000000 || /* lhzu */
	   (insn.opcode & 0xfc0007fe) == 0x7c00026e || /* lbzux */
	   (insn.opcode & 0xfc000000) == 0xac000000 || /* lhau */
	   (insn.opcode & 0xfc0007fe) == 0x7c0002ee || /* lhaux */
	   (insn.opcode & 0xfc000000) == 0x84000000 || /* lwzu */
	   (insn.opcode & 0xfc0007fe) == 0x7c00006e || /* lwzux */
	   (insn.opcode & 0xfc0007fe) == 0x7c0002ea || /* lwaux */
	   (insn.opcode & 0xfc000003) == 0xe8000001 || /* ldu */
	   (insn.opcode & 0xfc0007fe) == 0x7c00006a){  /* ldux */
	    if(RA(insn.opcode) == 0)
		as_bad("Invalid form of the instruction (RA must not be 0)");
	    if(RA(insn.opcode) == RT(insn.opcode))
		as_bad("Invalid form of the instruction (RA must not the same "
			"as RT)");
	}
	/*
	 * For the following instructions: stbu, stbux, sthu, sthux, stwu,
	 * stwux, stdu, stdux, lfsu, lfsux, lfdu, lfdux, stfsu, stfsux, stfdu,
	 * stfdux
	 * if RA == 0 the instruction form is invalid.
	 */
	if((insn.opcode & 0xfc000000) == 0x9c000000 || /* stbu */
	   (insn.opcode & 0xfc0007fe) == 0x7c0001ee || /* stbux */
	   (insn.opcode & 0xfc000000) == 0xb4000000 || /* sthu */
	   (insn.opcode & 0xfc0007fe) == 0x7c00036e || /* sthux */
	   (insn.opcode & 0xfc000000) == 0x94000000 || /* stwu */
	   (insn.opcode & 0xfc0007fe) == 0x7c00016e || /* stwux */
	   (insn.opcode & 0xfc000003) == 0xf8000001 || /* stdu */
	   (insn.opcode & 0xfc0007fe) == 0x7c00016a || /* stdux */
	   (insn.opcode & 0xfc000000) == 0xc4000000 || /* lfsu */
	   (insn.opcode & 0xfc0007fe) == 0x7c00046e || /* lfsux */
	   (insn.opcode & 0xfc000000) == 0xcc000000 || /* lfdu */
	   (insn.opcode & 0xfc0007fe) == 0x7c0004ee || /* lfdux */
	   (insn.opcode & 0xfc000000) == 0xd4000000 || /* stfsu */
	   (insn.opcode & 0xfc0007fe) == 0x7c00056e || /* stfsux */
	   (insn.opcode & 0xfc000000) == 0xdc000000 || /* stfdu */
	   (insn.opcode & 0xfc0007fe) == 0x7c0005ee || /* stfdux */
	   (insn.opcode & 0xfc0007fe) == 0x7c0002ac || /* dst, dstt */
	   (insn.opcode & 0xfc0007fe) == 0x7c0002ec){  /* dstst, dststt */
	    if(RA(insn.opcode) == 0)
		as_bad("Invalid form of the instruction (RA must not be 0)");
	}
	/*
	 * For the following instruction lmw if RA is in the range of
	 * registers to be loaded or RT == RA == 0 the instruction form is
	 * invalid.
	 */
	if((insn.opcode & 0xfc000000) == 0xb8000000){ /* lmw */
	    if(RT(insn.opcode) <= RA(insn.opcode))
		as_bad("Invalid form of the instruction (RA is in the range "
			"of registers to be loaded)");
	}
	/*
 	 * For the lswi instruction if RA is in the range of registers to be
	 * loaded the instruction form is invalid.
	 */
	if((insn.opcode & 0xfc0007fe) == 0x7c0004aa){ /* lswi */
	    uint32_t nb, nr;

		nb = (insn.opcode & 0x0000f800) >> 11;
		if(nb == 0)
		    nb = 32;
		nr = (nb + 3) / 4;
		if(RA(insn.opcode) >= RT(insn.opcode) &&
		   RA(insn.opcode) <= RT(insn.opcode) + nr - 1)
		    as_bad("Invalid form of the instruction (RA is in the "
			    "range of registers to be loaded)");
		if(RT(insn.opcode) + nr - 1 > 31 &&
		   RA(insn.opcode) < (RT(insn.opcode) + nr - 1) - 31)
		    as_bad("Invalid form of the instruction (RA is in the "
			    "range of registers to be loaded)");
	}
	/*
	 * For the lswx instruction if RT == RA or RT == RB the instruction
	 * form is invalid.  Of if RT and RA both specifiy r0 the form is
	 * invalid (covered by the RT == RA case).
	 */
	if((insn.opcode & 0xfc0007fe) == 0x7c00042a){  /* lswx */
	    if(RT(insn.opcode) == RA(insn.opcode))
		as_bad("Invalid form of the instruction (RT must not the same "
			"as RA)");
	    if(RT(insn.opcode) == RB(insn.opcode))
		as_bad("Invalid form of the instruction (RT must not the same "
			"as RB)");
	}
#if !defined(ARCH64)
	/*
	 * The 64-bit compares are invalid on 32-bit implementations.  Since
	 * we don't expect to ever use the 620 all 64-bit instructions require
	 * the -force_cpusubtype_ALL option to not be flagged as invalid.
	 */
	if(((insn.opcode & 0xfc4007ff) == 0x7c000000 ||  /* cmp */
	    (insn.opcode & 0xfc4007ff) == 0x7c000040 ||  /* cmpl */
	    (insn.opcode & 0xfc400000) == 0x2c000000 ||  /* cmpi */
	    (insn.opcode & 0xfc400000) == 0x28000000) && /* cmpli */
	   (insn.opcode & 0x00200000) == 0x00200000 &&   /* the L bit */
	   !force_cpusubtype_ALL &&
	   archflag_cpusubtype != CPU_SUBTYPE_POWERPC_970){
	    as_bad("Invalid form of the instruction (64-bit compares not "
		    "allowed without -force_cpusubtype_ALL option)");
	}
#endif /* !defined(ARCH64) */
	/*
	 * For branch conditional instructions certian BO fields are reserved.
	 * These are flagged as invalid forms unless the -force_cpusubtype_ALL
	 * option is specified.
	 */
	if(((insn.opcode & 0xfc000000) == 0x40000000 ||   /* bc */
	    (insn.opcode & 0xfc00fffe) == 0x4c000420 ||   /* bcctr */
	    (insn.opcode & 0xfc00fffe) == 0x4c000020) &&  /* bclr */
	    !force_cpusubtype_ALL){
	    /*
	     * We have a branch conditional instruction and force_cpusubtype_ALL
	     * is not specified.  So check for reserved BO fields where the z
	     * bits should be zero.
	     */
	    if((insn.opcode & 0x02800000) == 0x02800000 && /* 1z1zz */
	       (insn.opcode & 0x01600000) != 0x00000000){
		as_bad("Invalid form of the instruction (reserved bits in the "
			"BO field must be zero without -force_cpusubtype_ALL "
			"option)");
	    }
	}
#endif /* ALLOW_INVALID_FORMS */

	/*
	 * If the -g flag is present generate a line number stab for the
	 * instruction.
	 * 
	 * See the detailed comments about stabs in read_a_source_file() for a
	 * description of what is going on here.
	 */
	if(flagseen['g'] && frchain_now->frch_nsect == text_nsect){
	    (void)symbol_new(
		  "",
		  68 /* N_SLINE */,
		  text_nsect,
		  logical_input_line /* n_desc, line number */,
		  obstack_next_free(&frags) - frag_now->fr_literal,
		  frag_now);
	}

	/* grow the current frag and plop in the opcode */
	thisfrag = frag_more(4);
	md_number_to_chars(thisfrag, insn.opcode, 4);
	dwarf2_emit_insn(4);

	/*
	 * If we are to flag registers not to be used then check the instruction
	 * we just assembled for registers to be flagged.
	 */
	if(flag_registers){
	    for(i = 0; i < 5; i++){
		if(format->ops[i].type == GREG ||
		   format->ops[i].type == G0REG){
		    val = (insn.opcode & (0x1f << format->ops[i].offset)) >>
			  format->ops[i].offset;
		    if(flag_gregs[val])
			as_bad("flagged register r%u used", val);
		}
	    }
	}

	/*
	 * Deal with the instructions that are for specific cpusubtypes.
	 */
	if(format->cpus != 0 && !force_cpusubtype_ALL){
	    if(no_ppc601 == 1 && format->cpus == CPU601)
		as_bad("not allowed 601 instruction \"%s\"", format->name);
#if !defined(ARCH64)
	    if((format->cpus & IMPL64) == IMPL64
		&& archflag_cpusubtype != CPU_SUBTYPE_POWERPC_970
		){
		as_bad("%s instruction is only for 64-bit implementations (not "
		       "allowed without -force_cpusubtype_ALL option)",
		       format->name);
	    }
	    if((format->cpus & OPTIONAL) == OPTIONAL){
		if((format->cpus & CPU970) == CPU970 &&
		   archflag_cpusubtype != CPU_SUBTYPE_POWERPC_970)
		    as_bad("%s instruction is optional for the PowerPC (not "
			   "allowed without -force_cpusubtype_ALL option)",
			   format->name);
	    }
	    if(format->cpus == VMX &&
	       (archflag_cpusubtype != CPU_SUBTYPE_POWERPC_7400 &&
	        archflag_cpusubtype != CPU_SUBTYPE_POWERPC_7450 &&
	        archflag_cpusubtype != CPU_SUBTYPE_POWERPC_970)){
		as_bad("%s vector instruction is optional for the PowerPC (not "
		       "allowed without -force_cpusubtype_ALL option)",
		       format->name);
	    }
	    else
#endif /* !defined(ARCH64) */
	    if(md_cpusubtype == CPU_SUBTYPE_POWERPC_ALL){
		switch(format->cpus){
		case CPU601:
		    if(archflag_cpusubtype != -1 &&
		       archflag_cpusubtype != CPU_SUBTYPE_POWERPC_601)
			as_bad("%s 601 instruction not allowed with -arch %s",
			       format->name, specific_archflag);
		    else{
			file_spec = logical_input_file ?
				    logical_input_file : physical_input_file;
			line_spec = logical_input_line ?
				    logical_input_line : physical_input_line;
			md_cpusubtype = CPU_SUBTYPE_POWERPC_601;
		    }
		    break;
		}
	    } 
	    else{
		switch(format->cpus){
		case CPU601:
		    if(archflag_cpusubtype != -1 &&
		       archflag_cpusubtype != CPU_SUBTYPE_POWERPC_601)
			as_bad("%s 601 instruction not allowed with -arch %s",
			       format->name, specific_archflag);
		    else{
			if(md_cpusubtype != CPU_SUBTYPE_POWERPC_601)
			    as_bad("more than one implementation specific "
				   "instruction seen and -force_cpusubtype_ALL "
				   "not specified (first implementation "
				   "specific instruction in: %s at line %u)",
				   file_spec, line_spec);
		    }
		    break;
		}
	    }
	}

	/*
	 * We are putting a machine instruction in this section so mark it as
	 * containg some machine instructions.
	 */
	frchain_now->frch_section.flags |= S_ATTR_SOME_INSTRUCTIONS;

	/* if this instruction requires labels mark it for later */
	switch(insn.reloc){
	case NO_RELOC:
	    break;
	case PPC_RELOC_HI16:
	case PPC_RELOC_LO16:
	case PPC_RELOC_HA16:
	case PPC_RELOC_LO14:
	    fix_new(frag_now,
		    thisfrag - frag_now->fr_literal,
		    4,
		    insn.exp.X_add_symbol,
		    insn.exp.X_subtract_symbol,
		    insn.exp.X_add_number,
		    0, 0,
		    insn.reloc);
	    break;
	case PPC_RELOC_BR14:
	case PPC_RELOC_BR14_predicted:
	    fix_new(frag_now,
		    thisfrag - frag_now->fr_literal,
		    4,
		    insn.exp.X_add_symbol,
		    insn.exp.X_subtract_symbol,
		    insn.exp.X_add_number,
		    insn.pcrel,
		    insn.pcrel_reloc,
		    insn.reloc);
	    break;

	case PPC_RELOC_BR24:
	    fix_new(frag_now,
		    thisfrag - frag_now->fr_literal,
		    4,
		    insn.exp.X_add_symbol,
		    insn.exp.X_subtract_symbol,
		    insn.exp.X_add_number,
		    insn.pcrel,
		    insn.pcrel_reloc,
		    insn.reloc);
	    break;
	default:
	    as_bad("Unknown relocation type");
	    break;
	}
	if(insn.jbsr_exp.X_add_symbol != NULL){
	    fix_new(frag_now,
		    thisfrag - frag_now->fr_literal,
		    4,
		    insn.jbsr_exp.X_add_symbol,
		    insn.jbsr_exp.X_subtract_symbol,
		    insn.jbsr_exp.X_add_number,
		    0, /* pcrel */
		    1, /* pcrel_reloc */
		    PPC_RELOC_JBSR);
	}
}

static
int
calcop(
struct ppc_opcode *format,
char *param,
struct ppc_insn *insn,
char *op,
enum branch_prediction prediction)
{
    uint32_t parcnt, bo;

	/* initial the passed structure */
	memset(insn, '\0', sizeof(struct ppc_insn));
	insn->opcode = format->opcode;
	insn->reloc = NO_RELOC;

	/* parse all parameters */
	for(parcnt = 0; parcnt < 5 &&
			format->ops[parcnt].type != NONE; parcnt++){
	    error_param_count = parcnt;

	    switch(format->ops[parcnt].type){
	    case JBSR:
		param = parse_jbsr(param, insn, format, parcnt);
		break;
	    case PCREL:
	    case BADDR:
		param = parse_branch(param, insn, format, parcnt);
		break;
	    case D:
	    case DS:
		param = parse_displacement(param, insn, format, parcnt);
		break;
	    case SI:
	    case UI:
	    case HI:
		param = parse_immediate(param, insn, format, parcnt);
		break;
	    case GREG:
	    case G0REG:
		param = parse_reg("r", param, insn, format, parcnt);
		break;
	    case FREG:
		param = parse_reg("f", param, insn, format, parcnt);
		break;
	    case VREG:
		param = parse_reg("v", param, insn, format, parcnt);
		break;
	    case SGREG:
		param = parse_reg("sr", param, insn, format, parcnt);
		break;
	    case SPREG:
		param = parse_spreg(param, insn, format, parcnt);
		break;
	    case BCND:
		param = parse_bcnd(param, insn, format, parcnt);
		break;
	    case CRF:
	    case CRFONLY:
		param = parse_crf(param, insn, format, parcnt);
		break;
	    case SNUM:
		param = parse_num(param, insn, format, parcnt, 0, 0, 1, 0);
		break;
	    case FXM:
		param = parse_num(param, insn, format, parcnt, 0, 0, 0, 1);
		break;
	    case NUM:
		param = parse_num(param, insn, format, parcnt, 0, 0, 0, 0);
		break;
	    case NUM0:
		param = parse_num(param, insn, format, parcnt, 1, 0, 0, 0);
		break;
	    case MBE:
		param = parse_mbe(param, insn, format, parcnt);
		break;
	    case ZERO:
		param = parse_num(param, insn, format, parcnt, 0, 1, 0, 0);
		break;
	    case sh:
		param = parse_sh(param, insn, format, parcnt);
		break;
	    case mb:
		param = parse_mb(param, insn, format, parcnt);
		break;
	    default:
		as_fatal("Unknown parameter type");
	    }

	    /* see if parser failed or not */
	    if (param == NULL)
		return(0);
	}
	if((parcnt == 5 && *param != '\0') ||
	   (format->ops[0].type == NONE && *param != '\0')){
	    error_param_message = "too many parameters";
	    return(0);
	}

	if(IS_BRANCH_CONDITIONAL(insn->opcode)){
	    if(prediction != BRANCH_PREDICTION_NONE){
		if(prediction == BRANCH_PREDICTION_LIKELY_TAKEN ||
		   prediction == BRANCH_PREDICTION_LIKELY_NOT_TAKEN){
		    /*
		     * Set the Y_BIT assuming the displacement is non-negitive.
		     * If the displacement is negitive then the Y_BIT is flipped
		     * in md_number_to_imm() if the reloc is
		     * PPC_RELOC_BR14_predicted.
		     */
		    if(insn->reloc == PPC_RELOC_BR14)
			insn->reloc = PPC_RELOC_BR14_predicted;
		    if(prediction == BRANCH_PREDICTION_LIKELY_TAKEN)
			insn->opcode |= Y_BIT;
		    else{ /* prediction == BRANCH_PREDICTION_LIKELY_NOT_TAKEN */
			if((insn->opcode & Y_BIT) != 0)
			    as_warn("branch prediction ('-') ignored (specified"
				    " operand has prediction bit set)");
			else
			    insn->opcode &= ~(Y_BIT);
		    }
		}
		if(prediction == BRANCH_PREDICTION_VERY_LIKELY_TAKEN ||
		   prediction == BRANCH_PREDICTION_VERY_LIKELY_NOT_TAKEN){
		    bo = (insn->opcode >> 21) & 0x1f;
		    /*
		     * For 'branch if the condition is FALSE or TRUE' the AT
		     * bits are the lower 2 bits of the BO field (xxxAT).
		     */
		    if(bo == 0x04 || bo == 0x0c){
			if(prediction == BRANCH_PREDICTION_VERY_LIKELY_TAKEN)
			    insn->opcode |= 0x00600000; /* AT == 11 */
			else
			    insn->opcode |= 0x00400000; /* AT == 10 */
		    }
		    else if(bo == 0x10 || bo == 0x12){
			/*
			 * For 'decrement the CTR, then branch if the
			 * decremented CTR is non-zero or zero' the AT bits are
			 * the xAxxT bits of the BO field.
			 */
			if(prediction == BRANCH_PREDICTION_VERY_LIKELY_TAKEN)
			    insn->opcode |= 0x01200000;	/* AT == 11 */
			else
			    insn->opcode |= 0x01000000;	/* AT == 10 */
		    }
		    else{
			if(prediction == BRANCH_PREDICTION_VERY_LIKELY_TAKEN)
			    as_warn("branch prediction ('++') ignored "
				    "(specified operand has does not allow this"
				    " prediction)");
			else
			    as_warn("branch prediction ('--') ignored "
				    "(specified operand has does not allow this"
				    " prediction)");
		    }
		}
	    }
	}
	else{
	    if(prediction != '\0')
		as_warn("branch prediction ignored (instruction is not a "
			"conditional branch)");
	}
	return(1);
}

static
char *
parse_displacement(
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
int parcnt)
{
    signed_target_addr_t val;
    char *end, *saveptr, *saveparam;
    segT seg;


	if(parcnt != 1 ||
	   (format->ops[2].type != G0REG && format->ops[2].type != GREG))
	     as_fatal("internal error, bad table entry for instruction %s "
		      "(displacement operand not second operand or general "
		      "register not third operand)", format->name);

	/*
	 * There must be "(rX)" (where X is a number between 0-31) or "(0)"
	 * at the end of the parameter string.  To know out where the
	 * displacement expression ends determine the begining the "(rX)"
	 * by looking for the last '(' in the string.  The parsing of this
	 * trailing string will be done in another routine.
	 */
	end = strrchr(param, '(');
	if(end == NULL)
	    return(NULL);
	*end = '\0';

	/*
	 * The expression may have one of the following: hi16(exp), ha16(exp),
	 * or lo16(exp) around the expression which determines the relocation
	 * type.
	 */
	if(strncmp(param,"hi16(",5) == 0){
	    insn->reloc = PPC_RELOC_HI16;
	    param += 5;
	}
	else if(strncmp(param,"ha16(",5) == 0){
	    insn->reloc = PPC_RELOC_HA16;
	    param += 5;
	}
	else if(strncmp(param,"lo16(",5) == 0){
	    if(format->ops[parcnt].type == DS)
		insn->reloc = PPC_RELOC_LO14;
	    else
		insn->reloc = PPC_RELOC_LO16;
	    param += 5;
	}

	saveptr = input_line_pointer;
	input_line_pointer = param;

	seg = expression(&insn->exp);
	try_to_make_absolute(&insn->exp);
	seg = insn->exp.X_seg;

	saveparam = input_line_pointer;
	input_line_pointer = saveptr;
	*end = '(';

	if(insn->reloc != NO_RELOC){
	    if(*saveparam != ')' || ++saveparam != end)
		return(NULL);
	}
	else{
	    if(saveparam != end)
		return(NULL);
	    val = insn->exp.X_add_number;
	    if(seg != SEG_ABSOLUTE){
		error_param_message = "Parameter error: expression must be "
				      "absolute";
		return(NULL);
	    }
	    if(val & 0x8000){
		if((val & 0xffff0000) != 0xffff0000){
		    error_param_message = "Parameter error: expression out of "
					  "range";
		    return(NULL);
		}
		val = val & 0xffff;
	    }
	    else{
		if((val & 0xffff0000) != 0){
		    error_param_message = "Parameter error: expression out of "
					  "range";
		    return(NULL);
		}
	    }
	    if(format->ops[parcnt].type == DS){
		if((val & 0x3) != 0){
		    error_param_message = "Parameter error: expression must be "
					  "a multiple of 4";
		    return(NULL);
		}
		val >>= 2;
	    }
	    insn->opcode |= val << format->ops[parcnt].offset;
	}
	return(saveparam);
}

static
char *
parse_immediate(
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
int parcnt)
{
    uint32_t val;
    char *saveptr, *saveparam;
    segT seg;

	/*
	 * The expression may have one of the following: hi16(exp), ha16(exp),
	 * or lo16(exp) around the expression which determines the relocation
	 * type.
	 */
	if(strncmp(param,"hi16(",5) == 0){
	    insn->reloc = PPC_RELOC_HI16;
	    param += 5;
	}
	else if(strncmp(param,"ha16(",5) == 0){
	    insn->reloc = PPC_RELOC_HA16;
	    param += 5;
	}
	else if(strncmp(param,"lo16(",5) == 0){
	    if(format->ops[parcnt].type == DS)
		insn->reloc = PPC_RELOC_LO14;
	    else
		insn->reloc = PPC_RELOC_LO16;
	    param += 5;
	}

	saveptr = input_line_pointer;
	input_line_pointer = param;

	seg = expression(&insn->exp);
	try_to_make_absolute(&insn->exp);
	seg = insn->exp.X_seg;

	saveparam = input_line_pointer;
	input_line_pointer = saveptr;

	if(insn->reloc != NO_RELOC){
	    if(*saveparam != ')')
		return(NULL);
	    saveparam++;
	    if(*saveparam == '\0'){
		if(parcnt == 4 || format->ops[parcnt+1].type == NONE)
		    return(saveparam);
		else
		    return(NULL);
	    }
	    else if(*saveparam == ','){
		if(parcnt != 4 && format->ops[parcnt+1].type != NONE)
		    return(saveparam+1);
		else
		    return(NULL);
	    }
	    else
		return(NULL);
	}
	else{
	    val = insn->exp.X_add_number;
	    if(seg != SEG_ABSOLUTE){
		error_param_message = "Parameter error: expression must be "
				      "absolute";
		return(NULL);
	    }
	    if(format->ops[parcnt].type == SI){
		if(val & 0x8000){
		    if((val & 0xffff0000) != 0xffff0000){
			error_param_message = "Parameter error: expression out "
					      "of range";
			return(NULL);
		    }
		    val = val & 0xffff;
		}
		else{
		    if((val & 0xffff0000) != 0){
			error_param_message = "Parameter error: expression out "
					      "of range";
			return(NULL);
		    }
		}
	    }
	    else if(format->ops[parcnt].type == UI){
		if((val & 0xffff0000) != 0){
		    error_param_message = "Parameter error: expression out "
					  "of range";
		    return(NULL);
		}
	    }
	    else if(format->ops[parcnt].type == HI){
		if((val & 0xffff0000) != 0 &&
		   (val & 0xffff0000) != 0xffff0000){
		    error_param_message = "Parameter error: expression out "
					  "of range";
		    return(NULL);
		}
		val = val & 0xffff;
	    }
	    if(*saveparam == '\0'){
		if(parcnt == 4 || format->ops[parcnt+1].type == NONE){
		    insn->opcode |= val << format->ops[parcnt].offset;
		    return(saveparam);
		}
		else
		    return(NULL);
	    }
	    else if(*saveparam == ','){
		if(parcnt != 4 && format->ops[parcnt+1].type != NONE){
		    insn->opcode |= val << format->ops[parcnt].offset;
		    return(saveparam+1);
		}
		else
		    return(NULL);
	    }
	    else
		return(NULL);
	}
	return(saveparam);
}

static
char *
parse_jbsr(
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
int parcnt)
{
    char *saveptr, *saveparam, *p;
    segT seg;
    short reference;

	reference = 0;
	saveptr = input_line_pointer;
	input_line_pointer = param;

	/*
	 * If we are assembling -dynamic then if the symbol name before the ','
	 * has not yet been seen it will be marked as a non-lazy reference.
	 */
	if(flagseen[(int)'k'] == TRUE){
	    p = strchr(param, ',');
	    if(p != NULL)
		*p = '\0';
	    if(symbol_find(param) == NULL)
		reference = REFERENCE_FLAG_UNDEFINED_LAZY;
	    else
		reference = REFERENCE_FLAG_UNDEFINED_NON_LAZY;
	    if(p != NULL)
		*p = ',';
	}

	seg = expression(&insn->jbsr_exp);
	try_to_make_absolute(&insn->jbsr_exp);
	seg = insn->jbsr_exp.X_seg;

	if(flagseen[(int)'k'] == TRUE)
	    insn->jbsr_exp.X_add_symbol->sy_desc |= reference;

	saveparam = input_line_pointer;
	input_line_pointer = saveptr;

	if(*saveparam == ',')
	    return(saveparam+1);
	else
	    return(NULL);
}

static
char *
parse_branch(
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
int parcnt)
{
    char *saveptr, *saveparam;
    segT seg;

	saveptr = input_line_pointer;
	input_line_pointer = param;

	seg = expression(&insn->exp);
	try_to_make_absolute(&insn->exp);
	seg = insn->exp.X_seg;

	saveparam = input_line_pointer;
	input_line_pointer = saveptr;

	insn->pcrel = 0;
	insn->pcrel_reloc = 0;
	if(format->ops[parcnt].type == PCREL){
	    /*
	     * The NeXT linker has the ability to scatter blocks of
	     * sections between labels.  This requires that brances to
	     * labels that survive to the link phase must be able to
	     * be relocated.
	     */
	    if(insn->exp.X_add_symbol != NULL &&
	       (insn->exp.X_add_symbol->sy_name[0] != 'L' || flagseen ['L'])){
		if(insn->jbsr_exp.X_add_symbol != NULL)
		    as_fatal("Stub label used in a JBSR must be "
			     "non-relocatable");
		insn->pcrel_reloc = 1;
	    }
	    else{
		insn->pcrel_reloc = 0;
	    }
	    insn->pcrel = 1;
	}
	switch(format->ops[parcnt].width){
	case 14:
	    insn->reloc = PPC_RELOC_BR14;
	    break;
	case 24:
	    insn->reloc = PPC_RELOC_BR24;
	    break;
	default:
	    as_fatal("Unknown branch instruction width %d",
		    format->ops[parcnt].width);
	    break;
	}
	return(saveparam);
}

static
char *
parse_reg(
char *reg_name,
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
uint32_t parcnt)
{
    uint32_t val, d;

	d = 0;
	if(*param == '(' && parcnt == 2 &&
	   (format->ops[1].type == D || format->ops[1].type == DS)){
	    d = 1;
	    param++;
	}

	if(format->ops[parcnt].type == G0REG && *param == '0'){
	    val = 0;
	    param++;
	}
	else{
	    val = 0;
	    while(*reg_name){
		if(*param++ != *reg_name++)
		    return(NULL);
	    }
	    if(!isdigit(*param))
		return(NULL);

	    while(isdigit(*param))
		if((val = val * 10 + *param++ - '0') >=
		   (uint32_t)(1 << format->ops[parcnt].width))
		return(NULL);

	    if(format->ops[parcnt].type == G0REG && val == 0){
		error_param_message = "Parameter error: r0 not allowed "
				      "for parameter %lu (code as 0 not r0)";
		return(NULL);
	    }
	}

	if(*param == '\0'){
	    if(parcnt == 4 || format->ops[parcnt+1].type == NONE){
		insn->opcode |= val << format->ops[parcnt].offset;
		return(param);
	    }
	    else
		return(NULL);
	}
	else if(*param == ','){
	    if(parcnt != 4 && format->ops[parcnt+1].type != NONE){
		insn->opcode |= val << format->ops[parcnt].offset;
		return(param+1);
	    }
	    else
		return(NULL);
	}
	else if(d == 1 && *param == ')' && param[1] == '\0'){
	    if(parcnt == 4 || format->ops[parcnt+1].type == NONE){
		insn->opcode |= val << format->ops[parcnt].offset;
		return(++param);
	    }
	    else
		return(NULL);
	}
	return(NULL);
}

static
char *
parse_spreg(
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
uint32_t parcnt)
{
    signed_target_addr_t val;
    uint32_t i;
    char *saveptr, save_c;
    expressionS exp;
    segT seg;

	saveptr = input_line_pointer;
	input_line_pointer = param;
	while(*param != ',' && *param != '\0')
		param++;
	save_c = *param;
	*param = '\0';

	seg = SEG_ABSOLUTE;
	val = 0;
	for(i = 0; *special_registers[i].name != '\0'; i++){
	    if(strcmp(input_line_pointer, special_registers[i].name) == 0){
		val = special_registers[i].number;
		break;
	    }
	}
	if(*special_registers[i].name == '\0'){
	    seg = expression(&exp);
	    try_to_make_absolute(&exp);
	    seg = exp.X_seg;
	    val = exp.X_add_number;
	}
	*param = save_c;
	input_line_pointer = saveptr;

	if(seg != SEG_ABSOLUTE){
	    error_param_message = "Parameter error: expression must be "
				  "absolute";
	    return(NULL);
	}
	if(val > 1024 || val < 0){
	    error_param_message = "Parameter error: expression out "
				  "of range";
	    return(NULL);
	}

	val = ((val & 0x1f) << 5) | ((val >> 5) & 0x1f);

	if(*param == '\0'){
	    if(parcnt == 4 || format->ops[parcnt+1].type == NONE){
		insn->opcode |= val << format->ops[parcnt].offset;
		return(param);
	    }
	    else
		return(NULL);
	}
	else if(*param == ','){
	    if(parcnt != 4 && format->ops[parcnt+1].type != NONE){
		insn->opcode |= val << format->ops[parcnt].offset;
		return(param+1);
	    }
	    else
		return(NULL);
	}
	return(NULL);
}

static
char *
parse_bcnd(
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
uint32_t parcnt)
{
    signed_target_addr_t val;
    uint32_t i, j;
    char *saveptr, save_c, *plus, save_plus;
    expressionS exp;
    segT seg;

	saveptr = input_line_pointer;
	input_line_pointer = param;
	while(*param != ',' && *param != '\0')
	    param++;
	save_c = *param;
	*param = '\0';

	/*
	 * look for "[CR_field+]condition_symbol".
	 */
	val = -1;
	for(plus = input_line_pointer; *plus != '+' && *plus != '\0'; plus++)
	    ;
	if(*plus == '+'){
	    save_plus = *plus;
	    *plus = '\0';
	    for(i = 0; *CR_fields[i].name != '\0'; i++)
		if(strcmp(input_line_pointer, CR_fields[i].name) == 0)
		    break;
	    *plus = save_plus;
	    if(*CR_fields[i].name != '\0'){
		for(j = 0; *condition_symbols[j].name != '\0'; j++)
		    if(strcmp(plus+1, condition_symbols[j].name) == 0)
			break;
		if(*condition_symbols[j].name != '\0'){
		    val = CR_fields[i].value + condition_symbols[j].value;
		}
	    }
	}
	else{
	    for(i = 0; *condition_symbols[i].name != '\0'; i++)
		if(strcmp(input_line_pointer, condition_symbols[i].name) == 0)
		    break;
	    if(*condition_symbols[i].name != '\0')
		val = condition_symbols[i].value;
	}
	if(val == -1){
	    seg = expression(&exp);
	    try_to_make_absolute(&exp);
	    seg = exp.X_seg;
	    val = exp.X_add_number;
	    if(seg != SEG_ABSOLUTE){
		error_param_message = "Parameter error: expression must be "
				      "absolute";
		*param = save_c;
		input_line_pointer = saveptr;
		return(NULL);
	    }
	    if(val >= (1 << format->ops[parcnt].width) || val < 0){
		error_param_message = "Parameter error: expression out "
				      "of range";
		*param = save_c;
		input_line_pointer = saveptr;
		return(NULL);
	    }
	}

	*param = save_c;
	input_line_pointer = saveptr;


	if(*param == '\0'){
	    if(parcnt == 4 || format->ops[parcnt+1].type == NONE){
		insn->opcode |= val << format->ops[parcnt].offset;
		return(param);
	    }
	    else
		return(NULL);
	}
	else if(*param == ','){
	    if(parcnt != 4 && format->ops[parcnt+1].type != NONE){
		insn->opcode |= val << format->ops[parcnt].offset;
		return(param+1);
	    }
	    else
		return(NULL);
	}
	return(NULL);

}

static
char *
parse_crf(
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
uint32_t parcnt)
{
    signed_target_addr_t val;
    uint32_t i;
    char *saveptr, save_c;
    expressionS exp;
    segT seg;

	saveptr = input_line_pointer;
	input_line_pointer = param;
	while(*param != ',' && *param != '\0')
	    param++;
	save_c = *param;
	*param = '\0';
	val = -1;
	for(i = 0; *CR_fields[i].name != '\0'; i++){
	    if(strcmp(input_line_pointer, CR_fields[i].name) == 0){
		val = CR_fields[i].value;
		break;
	    }
	}
	if(val == -1){
	    if(format->ops[parcnt].type == CRFONLY){
		*param = save_c;
		input_line_pointer = saveptr;
		return(NULL);
	    }
	    seg = expression(&exp);
	    try_to_make_absolute(&exp);
	    seg = exp.X_seg;
	    val = exp.X_add_number;
	    if(seg != SEG_ABSOLUTE){
		error_param_message = "Parameter error: expression must be "
				      "absolute";
		*param = save_c;
		input_line_pointer = saveptr;
		return(NULL);
	    }
	    if(val >= (1 << format->ops[parcnt].width) || val < 0){
		error_param_message = "Parameter error: expression out "
				      "of range";
		*param = save_c;
		input_line_pointer = saveptr;
		return(NULL);
	    }
	}
	*param = save_c;
	input_line_pointer = saveptr;

	if(*param == '\0'){
	    if(parcnt == 4 || format->ops[parcnt+1].type == NONE){
		insn->opcode |= val << format->ops[parcnt].offset;
		return(param);
	    }
	    else
		return(NULL);
	}
	else if(*param == ','){
	    if(parcnt != 4 && format->ops[parcnt+1].type != NONE){
		insn->opcode |= val << format->ops[parcnt].offset;
		return(param+1);
	    }
	    else
		return(NULL);
	}
	return(NULL);
}

static
char *
parse_num(
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
uint32_t parcnt,
int32_t max_width_zero,
int32_t zero_only,
int32_t signed_num,
int32_t bit_mask_with_1_bit_set)
{
    signed_target_addr_t val;
    int i, max, min, mask, temp;
    char *saveptr, save_c;
    expressionS exp;
    segT seg;

	saveptr = input_line_pointer;
	input_line_pointer = param;
	while(*param != ',' && *param != '\0')
		param++;
	save_c = *param;
	*param = '\0';
	seg = expression(&exp);
	try_to_make_absolute(&exp);
	seg = exp.X_seg;
	*param = save_c;
	input_line_pointer = saveptr;

	val = exp.X_add_number;
	if(seg != SEG_ABSOLUTE){
	    error_param_message = "Parameter error: expression must be "
				  "absolute";
	    return(NULL);
	}
	if(max_width_zero){
	    if(val == (1 << format->ops[parcnt].width))
		val = 0;
	}
	if(signed_num){
	    max = (1 << (format->ops[parcnt].width - 1)) - 1;
	    min = (0xffffffff << (format->ops[parcnt].width - 1));
	    temp = val;
	    if(temp > max || temp < min){
		error_param_message = "Parameter error: expression out "
				      "of range";
		return(NULL);
	    }
	}
	else{
	    max = (1 << (format->ops[parcnt].width)) - 1;
	    if(val > max){
		error_param_message = "Parameter error: expression out "
				      "of range";
		return(NULL);
	    }
	}
	if(bit_mask_with_1_bit_set){
	    mask = 1;
	    for(i = 0; i < format->ops[parcnt].width; i++){
		if(mask & val)
		    break;
		mask = mask << 1;
	    }
	    /*
	     * If this is the mtcrf opcode (0x7c000120) and val is not zero and
	     * has exactly one bit set then use the new form of the mtcrf
	     * opcode.  This has bit 0x00100000 set and the FXM field is a bit
	     * mask. Else use the old form without bit 0x00100000 set.
	     */ 
	    if(insn->opcode == 0x7c000120){
		if(val != 0 && val == mask)
		    insn->opcode |= 0x00100000;
	    }
	    else{
		/*
		 * For instructions other than mtcrf if exactly one bit in val
		 * is not set it is an error.
		 */
		if(val == 0 || val != mask){
		    error_param_message = "Parameter error: expression must "
				  "have exactly one bit set";
		    return(NULL);
		}
	    }
	}
	if(zero_only == 1 && val != 0){
	    error_param_message = "Parameter error: expression must have a "
				  "value of zero";
	    return(NULL);
	}
	if(*param == '\0'){
	    if(parcnt == 4 || format->ops[parcnt+1].type == NONE){
		insn->opcode |= (val & ((1 << format->ops[parcnt].width)-1)) <<
				format->ops[parcnt].offset;
		return(param);
	    }
	    else
		return(NULL);
	}
	else if(*param == ','){
	    if(parcnt != 4 && format->ops[parcnt+1].type != NONE){
		insn->opcode |= (val & ((1 << format->ops[parcnt].width)-1)) <<
				format->ops[parcnt].offset;
		return(param+1);
	    }
	    else
		return(NULL);
	}
	return(NULL);
}

static
char *
parse_mbe(
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
uint32_t parcnt)
{
    signed_target_addr_t val;
    char *saveptr, save_c;
    expressionS exp;
    segT seg;

	if (parcnt == 4 && *param == '\0')
	  return param;

	saveptr = input_line_pointer;
	input_line_pointer = param;
	while(*param != ',' && *param != '\0')
		param++;
	save_c = *param;
	*param = '\0';
	seg = expression(&exp);
	try_to_make_absolute(&exp);
	seg = exp.X_seg;
	*param = save_c;
	input_line_pointer = saveptr;

	val = exp.X_add_number;
	if(seg != SEG_ABSOLUTE){
	    error_param_message = "Parameter error: expression must be "
				  "absolute";
	    return(NULL);
	}
	/* Note that we need to allow all 32-bit values for val. */

	/* Look for the special case. */

	if (parcnt == 3 && *param == '\0')
	  {
	    uint32_t uval, mask;
	    int mb, me, mx, count, last;

	    uval = val;

	    mb = 0;
	    me = 32;
	    if ((uval & 1) != 0)
	      last = 1;
	    else
	      last = 0;
	    count = 0;

	    /* mb: location of last 0->1 transition */
	    /* me: location of last 1->0 transition */
	    /* count: # transitions */

	    for (mx = 0, mask = 1 << 31; mx < 32; ++mx, mask >>= 1)
	      {
		if ((uval & mask) && !last)
		  {
		    ++count;
		    mb = mx;
		    last = 1;
		  }
		else if (!(uval & mask) && last)
		  {
		    ++count;
		    me = mx;
		    last = 0;
		  }
	      }
	    if (me == 0)
	      me = 32;
	  
	    if (count != 2 && (count != 0 || ! last))
	      {
		return NULL;
	      }

	    insn->opcode |= (mb & ((1 << format->ops[parcnt].width)-1)) <<
	      format->ops[parcnt].offset;
	    insn->opcode |= ((me - 1) & ((1 << format->ops[parcnt+1].width)-1)) <<
	      format->ops[parcnt+1].offset;

	    return param;
	  }

	    if((parcnt == 3 || parcnt == 4)){
		insn->opcode |= (val & ((1 << format->ops[parcnt].width)-1)) <<
				format->ops[parcnt].offset;
		return((parcnt == 3 ? param+1 : param));
	    }

	return(NULL);

}

static
char *
parse_sh(
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
uint32_t parcnt)
{
    signed_target_addr_t val;
    char *saveptr, save_c;
    expressionS exp;
    segT seg;

	saveptr = input_line_pointer;
	input_line_pointer = param;
	while(*param != ',' && *param != '\0')
		param++;
	save_c = *param;
	*param = '\0';
	seg = expression(&exp);
	try_to_make_absolute(&exp);
	seg = exp.X_seg;
	*param = save_c;
	input_line_pointer = saveptr;

	val = exp.X_add_number;
	if(seg != SEG_ABSOLUTE){
	    error_param_message = "Parameter error: expression must be "
				  "absolute";
	    return(NULL);
	}
	if(val == 64)
	    val = 0;
	if(val >= 64 || val < 0){
	    error_param_message = "Parameter error: expression out "
				  "of range";
	    return(NULL);
	}

	if(*param == '\0'){
	    if(parcnt == 4 || format->ops[parcnt+1].type == NONE){
		insn->opcode |= (val & 0x1f) << 11;
		insn->opcode |= ((val >> 5) & 0x1) << 1;
		return(param);
	    }
	    else
		return(NULL);
	}
	else if(*param == ','){
	    if(parcnt != 4 && format->ops[parcnt+1].type != NONE){
		insn->opcode |= (val & 0x1f) << 11;
		insn->opcode |= ((val >> 5) & 0x1) << 1;
		return(param+1);
	    }
	    else
		return(NULL);
	}
	return(NULL);

}

static
char *
parse_mb(
char *param,
struct ppc_insn *insn,
struct ppc_opcode *format,
uint32_t parcnt)
{
    signed_target_addr_t val;
    char *saveptr, save_c;
    expressionS exp;
    segT seg;

	saveptr = input_line_pointer;
	input_line_pointer = param;
	while(*param != ',' && *param != '\0')
		param++;
	save_c = *param;
	*param = '\0';
	seg = expression(&exp);
	try_to_make_absolute(&exp);
	seg = exp.X_seg;
	*param = save_c;
	input_line_pointer = saveptr;

	val = exp.X_add_number;
	if(seg != SEG_ABSOLUTE){
	    error_param_message = "Parameter error: expression must be "
				  "absolute";
	    return(NULL);
	}
	if(val > 64 || val < 0){
	    error_param_message = "Parameter error: expression out "
				  "of range";
	    return(NULL);
	}

	if(*param == '\0'){
	    if(parcnt == 4 || format->ops[parcnt+1].type == NONE){
		insn->opcode |= (val & 0x1f) << 6;
		insn->opcode |= ((val >> 5) & 0x1) << 5;
		return(param);
	    }
	    else
		return(NULL);
	}
	else if(*param == ','){
	    if(parcnt != 4 && format->ops[parcnt+1].type != NONE){
		insn->opcode |= (val & 0x1f) << 6;
		insn->opcode |= ((val >> 5) & 0x1) << 5;
		return(param+1);
	    }
	    else
		return(NULL);
	}
	return(NULL);

}

/*
 * md_number_to_chars() is the target machine dependent routine that puts out
 * a binary value of size 8, 4, 2, or 1 bytes into the specified buffer.  This
 * is done in the target machine's byte sex.  In this case the byte order is
 * big endian.
 */
void
md_number_to_chars(
char *buf,
signed_expr_t val,
int nbytes)
{
	switch(nbytes){
	case 8:
	    *buf++ = val >> 56;
	    *buf++ = val >> 48;
	    *buf++ = val >> 40;
	    *buf++ = val >> 32;
	case 4:
	    *buf++ = val >> 24;
	    *buf++ = val >> 16;
	case 2:
	    *buf++ = val >> 8;
	case 1:
	    *buf = val;
	    break;

	default:
	    abort();
	}
}

/*
 * md_number_to_imm() is the target machine dependent routine that puts out
 * a binary value of size 4, 2, or 1 bytes into the specified buffer with
 * reguard to a possible relocation entry (the fixP->fx_r_type field in the fixS
 * structure pointed to by fixP) for the section with the ordinal nsect.  This
 * is done in the target machine's byte sex using it's relocation types.
 * In this case the byte order is big endian.
 */
void
md_number_to_imm(
unsigned char *buf,
signed_expr_t val,
int nbytes,
fixS *fixP,
int nsect)
{
    uint32_t opcode;

	if(fixP->fx_r_type == NO_RELOC ||
	   fixP->fx_r_type == PPC_RELOC_VANILLA){
	    switch(nbytes){
            case 8:
                *buf++ = val >> 56;
                *buf++ = val >> 48;
                *buf++ = val >> 40;
                *buf++ = val >> 32;
	    case 4:
		*buf++ = val >> 24;
		*buf++ = val >> 16;
	    case 2:
		*buf++ = val >> 8;
	    case 1:
		*buf = val;
		break;

	    default:
		abort();
	    }
	    return;
	}
	switch(fixP->fx_r_type){
	case PPC_RELOC_HI16:
	    buf[2] = val >> 24;
	    buf[3] = val >> 16;
	    break;

	case PPC_RELOC_LO16:
	    buf[2] = val >> 8;
	    buf[3] = val;
	    break;

	case PPC_RELOC_HA16:
	    val += 0x00008000;
	    buf[2] = val >> 24;
	    buf[3] = val >> 16;
	    break;

	case PPC_RELOC_LO14:
	    buf[2] = val >> 8;
	    buf[3] |= val & 0xfc;
	    break;

	case PPC_RELOC_BR14:
	case PPC_RELOC_BR14_predicted:
	    if(fixP->fx_pcrel)
		val += 4;
	    if((val & 0xffff8000) && ((val & 0xffff8000) != 0xffff8000)){
		layout_file = fixP->file;
		layout_line = fixP->line;
		as_bad("Fixup of %lld too large for field width of 16 "
			"bits", val);
	    }
	    if((val & 0x3) != 0){
		layout_file = fixP->file;
		layout_line = fixP->line;
		as_bad("Fixup of %lld is not to a 4 byte address", val);
	    }
	    /*
	     * Note PPC_RELOC_BR14 are only used with bc, "branch conditional"
	     * instructions.  The Y_BIT was previously set assuming the
	     * displacement is non-negitive. If the displacement is negitive
	     * then the Y_BIT is flipped if the prediction was specified (the
	     * reloc type is PPC_RELOC_BR14_predicted).  If the prediction was
	     * not specified (the reloc type is PPC_RELOC_BR14) then the bit
	     * must remain cleared as per the PowerPC book.
	     */
	    if((val & 0x00008000) != 0){
		opcode = buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];
		/*
		 * The 5-bit BO encoding of branch always is 1z1zz. Where z is
		 * ignored but should be set to zero.  If the user as specified
		 * the BO "branch always" value with some of the z bits on then
		 * treat it like a branch always and don't change the Y bit
		 * based on the sign of the displacement.
		 */
		if(((opcode) & 0x02800000) != 0x02800000){
		    if(fixP->fx_r_type == PPC_RELOC_BR14_predicted)
			opcode ^= Y_BIT;
		    buf[0] = opcode >> 24;
		    buf[1] = opcode >> 16;
		    buf[2] = opcode >> 8;
		    buf[3] = opcode;
		}
	    }
	    buf[2] = val >> 8;
	    buf[3] |= val & 0xfc;
	    break;

	case PPC_RELOC_BR24:
	    if(fixP->fx_pcrel)
		val += 4;
	    if((val & 0xfc000000) && ((val & 0xfc000000) != 0xfc000000)){
		layout_file = fixP->file;
		layout_line = fixP->line;
		as_bad("Fixup of %lld too large for field width of 26 "
			"bits", val);
	    }
	    if((val & 0x3) != 0){
		layout_file = fixP->file;
		layout_line = fixP->line;
		as_bad("Fixup of %lld is not to a 4 byte address", val);
	    }
	    buf[0] |= (val >> 24) & 0x03;
	    buf[1] = val >> 16;
	    buf[2] = val >> 8;
	    buf[3] |= val & 0xfc;
	    break;

	case PPC_RELOC_JBSR:
	    /* no bytes are written for JBSR, only a relocation entry */
	    break;

	default:
	    layout_file = fixP->file;
	    layout_line = fixP->line;
	    as_bad("Bad relocation type");
	    break;
	}
}

/*
 * md_atof() turns a string pointed to by input_line_pointer into a floating
 * point constant of type type, and store the appropriate bytes in *litP.
 * The number of LITTLENUMS emitted is stored indirectly through *sizeP.
 * An error message is returned, or a string containg only a '\0' for OK.
 * For this machine only IEEE single and IEEE double floating-point formats
 * are allowed.
 */
char *
md_atof(
int type,
char *litP,
int *sizeP)
{
    int	prec;
    LITTLENUM_TYPE words[6];
    LITTLENUM_TYPE *wordP;
    char *t;

	switch(type){
	case 'f':
	case 'F':
	case 's':
	case 'S':
	    prec = 2;
	    break;

	case 'd':
	case 'D':
	case 'r':
	case 'R':
	    prec = 4;
	    break;

	default:
	    *sizeP = 0;
	    return("Bad call to MD_ATOF()");
	}
	t = atof_ieee(input_line_pointer, type, words);
	if(t != NULL)
	    input_line_pointer = t;

	*sizeP = prec * sizeof(LITTLENUM_TYPE);
	for(wordP = words; prec--; ){
	    md_number_to_chars(litP, (int32_t)(*wordP++), sizeof(LITTLENUM_TYPE));
	    litP += sizeof(LITTLENUM_TYPE);
	}
	return ""; /* OK */
}

int
md_estimate_size_before_relax(
fragS *fragP,
int segment_type)
{
	as_bad("Relaxation should never occur");
	return(sizeof(int32_t));
}

const relax_typeS md_relax_table[] = { {0} };

void
md_convert_frag(
fragS *fragP)
{
	as_bad("Relaxation should never occur");
}
                                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc64/                                   0040755 0001750 0001750 00000000000 13101126723 021774  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc64/.libs/                             0040755 0000000 0000000 00000000000 13101126723 022751  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc64/Makefile                           0100644 0000000 0000000 00000106301 13101126656 023405  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# as/ppc64/Makefile.  Generated from Makefile.in by configure.

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.




am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/cctools
pkgincludedir = $(includedir)/cctools
pkglibdir = $(libdir)/cctools
pkglibexecdir = $(libexecdir)/cctools
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = x86_64-unknown-linux-gnu
host_triplet = x86_64-unknown-linux-gnu
target_triplet = x86_64-apple-darwin15
libexec_PROGRAMS = ppc64-as$(EXEEXT)
subdir = as/ppc64
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
am__installdirs = "$(DESTDIR)$(libexecdir)"
PROGRAMS = $(libexec_PROGRAMS)
am__dirstamp = $(am__leading_dot)dirstamp
am_ppc64_as_OBJECTS = ../ppc64_as-app.$(OBJEXT) \
	../ppc64_as-as.$(OBJEXT) ../ppc64_as-atof-generic.$(OBJEXT) \
	../ppc64_as-atof-ieee.$(OBJEXT) ../ppc64_as-expr.$(OBJEXT) \
	../ppc64_as-fixes.$(OBJEXT) ../ppc64_as-flonum-const.$(OBJEXT) \
	../ppc64_as-flonum-copy.$(OBJEXT) \
	../ppc64_as-flonum-mult.$(OBJEXT) ../ppc64_as-frags.$(OBJEXT) \
	../ppc64_as-hash.$(OBJEXT) ../ppc64_as-hex-value.$(OBJEXT) \
	../ppc64_as-input-file.$(OBJEXT) \
	../ppc64_as-input-scrub.$(OBJEXT) ../ppc64_as-layout.$(OBJEXT) \
	../ppc64_as-messages.$(OBJEXT) ../ppc64_as-obstack.$(OBJEXT) \
	../ppc64_as-read.$(OBJEXT) ../ppc64_as-sections.$(OBJEXT) \
	../ppc64_as-symbols.$(OBJEXT) \
	../ppc64_as-write_object.$(OBJEXT) \
	../ppc64_as-xmalloc.$(OBJEXT) ../ppc64_as-dwarf2dbg.$(OBJEXT) \
	../ppc64_as-ppc.$(OBJEXT)
ppc64_as_OBJECTS = $(am_ppc64_as_OBJECTS)
ppc64_as_DEPENDENCIES = $(top_builddir)/libstuff/libstuff.la
AM_V_lt = $(am__v_lt_$(V))
am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
am__v_lt_0 = --silent
am__v_lt_1 = 
ppc64_as_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ppc64_as_CFLAGS) \
	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_P = $(am__v_P_$(V))
am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_$(V))
am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_$(V))
am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
am__v_at_0 = @
am__v_at_1 = 
DEFAULT_INCLUDES = -I.
depcomp =
am__depfiles_maybe =
COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
	$(AM_CFLAGS) $(CFLAGS)
AM_V_CC = $(am__v_CC_$(V))
am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
am__v_CC_0 = @echo "  CC      " $@;
am__v_CC_1 = 
CCLD = $(CC)
LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_CCLD = $(am__v_CCLD_$(V))
am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
am__v_CCLD_0 = @echo "  CCLD    " $@;
am__v_CCLD_1 = 
SOURCES = $(ppc64_as_SOURCES)
DIST_SOURCES = $(ppc64_as_SOURCES)
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing aclocal-1.15
AMTAR = $${TAR-tar}
AM_DEFAULT_VERBOSITY = 1
AR = ar
ASLIBEXECDIR = ${libexecdir}/as
AUTOCONF = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoconf
AUTOHEADER = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoheader
AUTOMAKE = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing automake-1.15
AWK = mawk
CC = clang
CCAS = clang
CCASFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include
CFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include -DDISABLE_CLANG_AS
CPP = clang -E
CPPFLAGS = 
CXX = clang++
CXXABI_LIB = -lsupc++
CXXCPP = clang++ -E
CXXFLAGS = -O3 -std=c++0x -isystem /usr/local/include -isystem /usr/pkg/include  -fblocks
CYGPATH_W = echo
DEFS = -DPACKAGE_NAME=\"cctools\" -DPACKAGE_TARNAME=\"cctools\" -DPACKAGE_VERSION=\"877.5\" -DPACKAGE_STRING=\"cctools\ 877.5\" -DPACKAGE_BUGREPORT=\"t.poechtrager@gmail.com\" -DPACKAGE_URL=\"\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DLT_OBJDIR=\".libs/\" -DEMULATED_HOST_CPU_TYPE=16777223 -DEMULATED_HOST_CPU_SUBTYPE=3 -D__STDC_LIMIT_MACROS=1 -D__STDC_CONSTANT_MACROS=1 -DHAVE_EXECINFO_H=1
DLLTOOL = false
DL_LIB = -ldl
DSYMUTIL = 
DUMPBIN = 
ECHO_C = 
ECHO_N = -n
ECHO_T = 
EGREP = /bin/grep -E
ENDIAN_FLAG = -D__LITTLE_ENDIAN__=1
EXECINFO_LIB = 
EXEEXT = 
FGREP = /bin/grep -F
GREP = /bin/grep
HOST_AR = ar
HOST_RANLIB = ranlib
INSTALL = /usr/bin/install -c
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_PROGRAM = ${INSTALL}
INSTALL_SCRIPT = ${INSTALL}
INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
LD = /usr/bin/ld -m elf_x86_64
LDFLAGS =  -L/usr/local/lib -L/usr/pkg/lib 
LIBOBJS = 
LIBS = 
LIBTOOL = $(SHELL) $(top_builddir)/libtool
LIPO = 
LLVM_CONFIG = no
LLVM_INCLUDE_DIR = 
LLVM_LIB_DIR = 
LN_S = ln -s
LTLIBOBJS = 
LTO_DEF = 
LTO_LIB = 
LTO_RPATH = 
LT_SYS_LIBRARY_PATH = 
MAINT = #
MAKEINFO = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing makeinfo
MANIFEST_TOOL = :
MKDIR_P = /bin/mkdir -p
NM = /usr/bin/nm -B
NMEDIT = 
OBJC = clang
OBJCFLAGS = -O3
OBJCWARNINGS = -Wall -Wno-objc-root-class -Wno-deprecated-objc-isa-usage
OBJDUMP = objdump
OBJEXT = o
OTOOL = 
OTOOL64 = 
PACKAGE = cctools
PACKAGE_BUGREPORT = t.poechtrager@gmail.com
PACKAGE_NAME = cctools
PACKAGE_STRING = cctools 877.5
PACKAGE_TARNAME = cctools
PACKAGE_URL = 
PACKAGE_VERSION = 877.5
PATH_SEPARATOR = :
PROGRAM_PREFIX = ${target_alias}-
PTHREAD_FLAGS = -pthread
RANLIB = ranlib
SED = /bin/sed
SET_MAKE = 
SHELL = /bin/bash
STRIP = strip
UUID_LIB = 
VERSION = 877.5
WARNINGS =  -Wall -Wno-long-long -Wno-import -Wno-format -Wno-deprecated -Wno-unused-variable -Wno-unused-private-field -Wno-unused-function -Wno-invalid-offsetof -Wno-int-conversion -Wno-char-subscripts
XAR_LIB = 
abs_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc64
abs_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc64
abs_top_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
abs_top_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
ac_ct_AR = ar
ac_ct_CC = clang
ac_ct_CXX = 
ac_ct_DUMPBIN = 
ac_ct_OBJC = 
am__leading_dot = .
am__tar = tar --format=ustar -chf - "$$tardir"
am__untar = tar -xf -
bindir = ${exec_prefix}/bin
build = x86_64-unknown-linux-gnu
build_alias = 
build_cpu = x86_64
build_os = linux-gnu
build_vendor = unknown
builddir = .
datadir = ${datarootdir}
datarootdir = ${prefix}/share
docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
dvidir = ${docdir}
exec_prefix = ${prefix}
host = x86_64-unknown-linux-gnu
host_alias = 
host_cpu = x86_64
host_os = linux-gnu
host_vendor = unknown
htmldir = ${docdir}
includedir = ${prefix}/include
infodir = ${datarootdir}/info
install_sh = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/install-sh
libdir = ${exec_prefix}/lib
libexecdir = ${exec_prefix}/libexec
localedir = ${datarootdir}/locale
localstatedir = ${prefix}/var
mandir = ${datarootdir}/man
mkdir_p = $(MKDIR_P)
oldincludedir = /usr/include
pdfdir = ${docdir}
prefix = /osxcross/target
program_transform_name = s&^&x86_64-apple-darwin15-&
psdir = ${docdir}
sbindir = ${exec_prefix}/sbin
sharedstatedir = ${prefix}/com
srcdir = .
sysconfdir = ${prefix}/etc
target = x86_64-apple-darwin15
target_alias = x86_64-apple-darwin15
target_cpu = x86_64
target_os = darwin15
target_vendor = apple
top_build_prefix = ../../
top_builddir = ../..
top_srcdir = ../..
ppc64_as_LDADD = \
        $(top_builddir)/libstuff/libstuff.la

ppc64_as_CFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign -I$(top_srcdir)/libstuff -I$(top_srcdir)/as $(WARNINGS) $(LTO_DEF) -DNeXT_MOD -DASLIBEXECDIR="\"$(ASLIBEXECDIR)/\"" -D__DARWIN_UNIX03  -DPPC -DARCH64 $(ENDIAN_FLAG)
ppc64_as_SOURCES = ../app.c ../as.c ../atof-generic.c ../atof-ieee.c ../expr.c ../fixes.c ../flonum-const.c \
         ../flonum-copy.c ../flonum-mult.c ../frags.c ../hash.c ../hex-value.c ../input-file.c \
         ../input-scrub.c ../layout.c ../messages.c ../obstack.c ../read.c ../sections.c \
         ../symbols.c ../write_object.c ../xmalloc.c ../dwarf2dbg.c ../ppc.c

all: all-am

.SUFFIXES:
.SUFFIXES: .c .lo .o .obj
$(srcdir)/Makefile.in: # $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps as/ppc64/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps as/ppc64/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: # $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): # $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):
install-libexecPROGRAMS: $(libexec_PROGRAMS)
	@$(NORMAL_INSTALL)
	@list='$(libexec_PROGRAMS)'; test -n "$(libexecdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(libexecdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(libexecdir)" || exit 1; \
	fi; \
	for p in $$list; do echo "$$p $$p"; done | \
	sed 's/$(EXEEXT)$$//' | \
	while read p p1; do if test -f $$p \
	 || test -f $$p1 \
	  ; then echo "$$p"; echo "$$p"; else :; fi; \
	done | \
	sed -e 'p;s,.*/,,;n;h' \
	    -e 's|.*|.|' \
	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
	sed 'N;N;N;s,\n, ,g' | \
	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
	    else { print "f", $$3 "/" $$4, $$1; } } \
	  END { for (d in files) print "f", d, files[d] }' | \
	while read type dir files; do \
	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
	    test -z "$$files" || { \
	    echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(libexecdir)$$dir'"; \
	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(libexecdir)$$dir" || exit $$?; \
	    } \
	; done

uninstall-libexecPROGRAMS:
	@$(NORMAL_UNINSTALL)
	@list='$(libexec_PROGRAMS)'; test -n "$(libexecdir)" || list=; \
	files=`for p in $$list; do echo "$$p"; done | \
	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
	      -e 's/$$/$(EXEEXT)/' \
	`; \
	test -n "$$list" || exit 0; \
	echo " ( cd '$(DESTDIR)$(libexecdir)' && rm -f" $$files ")"; \
	cd "$(DESTDIR)$(libexecdir)" && rm -f $$files

clean-libexecPROGRAMS:
	@list='$(libexec_PROGRAMS)'; test -n "$$list" || exit 0; \
	echo " rm -f" $$list; \
	rm -f $$list || exit $$?; \
	test -n "$(EXEEXT)" || exit 0; \
	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
	echo " rm -f" $$list; \
	rm -f $$list
../$(am__dirstamp):
	@$(MKDIR_P) ..
	@: > ../$(am__dirstamp)
../ppc64_as-app.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-as.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-atof-generic.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-atof-ieee.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-expr.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-fixes.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-flonum-const.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-flonum-copy.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-flonum-mult.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-frags.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-hash.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-hex-value.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-input-file.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-input-scrub.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-layout.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-messages.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-obstack.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-read.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-sections.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-symbols.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-write_object.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-xmalloc.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-dwarf2dbg.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-ppc.$(OBJEXT): ../$(am__dirstamp)

ppc64-as$(EXEEXT): $(ppc64_as_OBJECTS) $(ppc64_as_DEPENDENCIES) $(EXTRA_ppc64_as_DEPENDENCIES) 
	@rm -f ppc64-as$(EXEEXT)
	$(AM_V_CCLD)$(ppc64_as_LINK) $(ppc64_as_OBJECTS) $(ppc64_as_LDADD) $(LIBS)

mostlyclean-compile:
	-rm -f *.$(OBJEXT)
	-rm -f ../*.$(OBJEXT)

distclean-compile:
	-rm -f *.tab.c

.c.o:
	$(AM_V_CC)$(COMPILE) -c -o $@ $<

.c.obj:
	$(AM_V_CC)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`

.c.lo:
	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<

../ppc64_as-app.o: ../app.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-app.o `test -f '../app.c' || echo '$(srcdir)/'`../app.c

../ppc64_as-app.obj: ../app.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-app.obj `if test -f '../app.c'; then $(CYGPATH_W) '../app.c'; else $(CYGPATH_W) '$(srcdir)/../app.c'; fi`

../ppc64_as-as.o: ../as.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-as.o `test -f '../as.c' || echo '$(srcdir)/'`../as.c

../ppc64_as-as.obj: ../as.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-as.obj `if test -f '../as.c'; then $(CYGPATH_W) '../as.c'; else $(CYGPATH_W) '$(srcdir)/../as.c'; fi`

../ppc64_as-atof-generic.o: ../atof-generic.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-atof-generic.o `test -f '../atof-generic.c' || echo '$(srcdir)/'`../atof-generic.c

../ppc64_as-atof-generic.obj: ../atof-generic.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-atof-generic.obj `if test -f '../atof-generic.c'; then $(CYGPATH_W) '../atof-generic.c'; else $(CYGPATH_W) '$(srcdir)/../atof-generic.c'; fi`

../ppc64_as-atof-ieee.o: ../atof-ieee.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-atof-ieee.o `test -f '../atof-ieee.c' || echo '$(srcdir)/'`../atof-ieee.c

../ppc64_as-atof-ieee.obj: ../atof-ieee.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-atof-ieee.obj `if test -f '../atof-ieee.c'; then $(CYGPATH_W) '../atof-ieee.c'; else $(CYGPATH_W) '$(srcdir)/../atof-ieee.c'; fi`

../ppc64_as-expr.o: ../expr.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-expr.o `test -f '../expr.c' || echo '$(srcdir)/'`../expr.c

../ppc64_as-expr.obj: ../expr.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-expr.obj `if test -f '../expr.c'; then $(CYGPATH_W) '../expr.c'; else $(CYGPATH_W) '$(srcdir)/../expr.c'; fi`

../ppc64_as-fixes.o: ../fixes.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-fixes.o `test -f '../fixes.c' || echo '$(srcdir)/'`../fixes.c

../ppc64_as-fixes.obj: ../fixes.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-fixes.obj `if test -f '../fixes.c'; then $(CYGPATH_W) '../fixes.c'; else $(CYGPATH_W) '$(srcdir)/../fixes.c'; fi`

../ppc64_as-flonum-const.o: ../flonum-const.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-const.o `test -f '../flonum-const.c' || echo '$(srcdir)/'`../flonum-const.c

../ppc64_as-flonum-const.obj: ../flonum-const.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-const.obj `if test -f '../flonum-const.c'; then $(CYGPATH_W) '../flonum-const.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-const.c'; fi`

../ppc64_as-flonum-copy.o: ../flonum-copy.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-copy.o `test -f '../flonum-copy.c' || echo '$(srcdir)/'`../flonum-copy.c

../ppc64_as-flonum-copy.obj: ../flonum-copy.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-copy.obj `if test -f '../flonum-copy.c'; then $(CYGPATH_W) '../flonum-copy.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-copy.c'; fi`

../ppc64_as-flonum-mult.o: ../flonum-mult.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-mult.o `test -f '../flonum-mult.c' || echo '$(srcdir)/'`../flonum-mult.c

../ppc64_as-flonum-mult.obj: ../flonum-mult.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-mult.obj `if test -f '../flonum-mult.c'; then $(CYGPATH_W) '../flonum-mult.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-mult.c'; fi`

../ppc64_as-frags.o: ../frags.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-frags.o `test -f '../frags.c' || echo '$(srcdir)/'`../frags.c

../ppc64_as-frags.obj: ../frags.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-frags.obj `if test -f '../frags.c'; then $(CYGPATH_W) '../frags.c'; else $(CYGPATH_W) '$(srcdir)/../frags.c'; fi`

../ppc64_as-hash.o: ../hash.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-hash.o `test -f '../hash.c' || echo '$(srcdir)/'`../hash.c

../ppc64_as-hash.obj: ../hash.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-hash.obj `if test -f '../hash.c'; then $(CYGPATH_W) '../hash.c'; else $(CYGPATH_W) '$(srcdir)/../hash.c'; fi`

../ppc64_as-hex-value.o: ../hex-value.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-hex-value.o `test -f '../hex-value.c' || echo '$(srcdir)/'`../hex-value.c

../ppc64_as-hex-value.obj: ../hex-value.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-hex-value.obj `if test -f '../hex-value.c'; then $(CYGPATH_W) '../hex-value.c'; else $(CYGPATH_W) '$(srcdir)/../hex-value.c'; fi`

../ppc64_as-input-file.o: ../input-file.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-input-file.o `test -f '../input-file.c' || echo '$(srcdir)/'`../input-file.c

../ppc64_as-input-file.obj: ../input-file.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-input-file.obj `if test -f '../input-file.c'; then $(CYGPATH_W) '../input-file.c'; else $(CYGPATH_W) '$(srcdir)/../input-file.c'; fi`

../ppc64_as-input-scrub.o: ../input-scrub.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-input-scrub.o `test -f '../input-scrub.c' || echo '$(srcdir)/'`../input-scrub.c

../ppc64_as-input-scrub.obj: ../input-scrub.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-input-scrub.obj `if test -f '../input-scrub.c'; then $(CYGPATH_W) '../input-scrub.c'; else $(CYGPATH_W) '$(srcdir)/../input-scrub.c'; fi`

../ppc64_as-layout.o: ../layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-layout.o `test -f '../layout.c' || echo '$(srcdir)/'`../layout.c

../ppc64_as-layout.obj: ../layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-layout.obj `if test -f '../layout.c'; then $(CYGPATH_W) '../layout.c'; else $(CYGPATH_W) '$(srcdir)/../layout.c'; fi`

../ppc64_as-messages.o: ../messages.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-messages.o `test -f '../messages.c' || echo '$(srcdir)/'`../messages.c

../ppc64_as-messages.obj: ../messages.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-messages.obj `if test -f '../messages.c'; then $(CYGPATH_W) '../messages.c'; else $(CYGPATH_W) '$(srcdir)/../messages.c'; fi`

../ppc64_as-obstack.o: ../obstack.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-obstack.o `test -f '../obstack.c' || echo '$(srcdir)/'`../obstack.c

../ppc64_as-obstack.obj: ../obstack.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-obstack.obj `if test -f '../obstack.c'; then $(CYGPATH_W) '../obstack.c'; else $(CYGPATH_W) '$(srcdir)/../obstack.c'; fi`

../ppc64_as-read.o: ../read.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-read.o `test -f '../read.c' || echo '$(srcdir)/'`../read.c

../ppc64_as-read.obj: ../read.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-read.obj `if test -f '../read.c'; then $(CYGPATH_W) '../read.c'; else $(CYGPATH_W) '$(srcdir)/../read.c'; fi`

../ppc64_as-sections.o: ../sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-sections.o `test -f '../sections.c' || echo '$(srcdir)/'`../sections.c

../ppc64_as-sections.obj: ../sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-sections.obj `if test -f '../sections.c'; then $(CYGPATH_W) '../sections.c'; else $(CYGPATH_W) '$(srcdir)/../sections.c'; fi`

../ppc64_as-symbols.o: ../symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-symbols.o `test -f '../symbols.c' || echo '$(srcdir)/'`../symbols.c

../ppc64_as-symbols.obj: ../symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-symbols.obj `if test -f '../symbols.c'; then $(CYGPATH_W) '../symbols.c'; else $(CYGPATH_W) '$(srcdir)/../symbols.c'; fi`

../ppc64_as-write_object.o: ../write_object.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-write_object.o `test -f '../write_object.c' || echo '$(srcdir)/'`../write_object.c

../ppc64_as-write_object.obj: ../write_object.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-write_object.obj `if test -f '../write_object.c'; then $(CYGPATH_W) '../write_object.c'; else $(CYGPATH_W) '$(srcdir)/../write_object.c'; fi`

../ppc64_as-xmalloc.o: ../xmalloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-xmalloc.o `test -f '../xmalloc.c' || echo '$(srcdir)/'`../xmalloc.c

../ppc64_as-xmalloc.obj: ../xmalloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-xmalloc.obj `if test -f '../xmalloc.c'; then $(CYGPATH_W) '../xmalloc.c'; else $(CYGPATH_W) '$(srcdir)/../xmalloc.c'; fi`

../ppc64_as-dwarf2dbg.o: ../dwarf2dbg.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-dwarf2dbg.o `test -f '../dwarf2dbg.c' || echo '$(srcdir)/'`../dwarf2dbg.c

../ppc64_as-dwarf2dbg.obj: ../dwarf2dbg.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-dwarf2dbg.obj `if test -f '../dwarf2dbg.c'; then $(CYGPATH_W) '../dwarf2dbg.c'; else $(CYGPATH_W) '$(srcdir)/../dwarf2dbg.c'; fi`

../ppc64_as-ppc.o: ../ppc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-ppc.o `test -f '../ppc.c' || echo '$(srcdir)/'`../ppc.c

../ppc64_as-ppc.obj: ../ppc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-ppc.obj `if test -f '../ppc.c'; then $(CYGPATH_W) '../ppc.c'; else $(CYGPATH_W) '$(srcdir)/../ppc.c'; fi`

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-am
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-am

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-am

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(PROGRAMS)
installdirs:
	for dir in "$(DESTDIR)$(libexecdir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
	-rm -f ../$(am__dirstamp)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libexecPROGRAMS clean-libtool \
	mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-compile distclean-generic \
	distclean-tags

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am:

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am: install-libexecPROGRAMS
	@$(NORMAL_INSTALL)
	$(MAKE) $(AM_MAKEFLAGS) install-exec-hook
install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am: uninstall-libexecPROGRAMS

.MAKE: install-am install-exec-am install-strip

.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
	clean-libexecPROGRAMS clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-compile distclean-generic \
	distclean-libtool distclean-tags distdir dvi dvi-am html \
	html-am info info-am install install-am install-data \
	install-data-am install-dvi install-dvi-am install-exec \
	install-exec-am install-exec-hook install-html install-html-am \
	install-info install-info-am install-libexecPROGRAMS \
	install-man install-pdf install-pdf-am install-ps \
	install-ps-am install-strip installcheck installcheck-am \
	installdirs maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
	uninstall-am uninstall-libexecPROGRAMS

.PRECIOUS: Makefile


install-exec-hook:
	mkdir -p $(DESTDIR)$(libexecdir)/as/ppc64
	mv $(DESTDIR)$(libexecdir)/*ppc64-as* $(DESTDIR)$(libexecdir)/as/ppc64/as

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc64/Makefile.am                        0100644 0001750 0001750 00000001521 12612724204 024030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        libexec_PROGRAMS = ppc64-as

ppc64_as_LDADD =  \
        $(top_builddir)/libstuff/libstuff.la

ppc64_as_CFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign -I$(top_srcdir)/libstuff -I$(top_srcdir)/as $(WARNINGS) $(LTO_DEF) -DNeXT_MOD -DASLIBEXECDIR="\"$(ASLIBEXECDIR)/\"" -D__DARWIN_UNIX03  -DPPC -DARCH64 $(ENDIAN_FLAG)

ppc64_as_SOURCES =  ../app.c ../as.c ../atof-generic.c ../atof-ieee.c ../expr.c ../fixes.c ../flonum-const.c \
         ../flonum-copy.c ../flonum-mult.c ../frags.c ../hash.c ../hex-value.c ../input-file.c \
         ../input-scrub.c ../layout.c ../messages.c ../obstack.c ../read.c ../sections.c \
         ../symbols.c ../write_object.c ../xmalloc.c ../dwarf2dbg.c ../ppc.c

install-exec-hook:
	mkdir -p $(DESTDIR)$(libexecdir)/as/ppc64
	mv $(DESTDIR)$(libexecdir)/*ppc64-as* $(DESTDIR)$(libexecdir)/as/ppc64/as
                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc64/Makefile.in                        0100644 0001750 0001750 00000103646 12612724226 024060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@

VPATH = @srcdir@
am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
libexec_PROGRAMS = ppc64-as$(EXEEXT)
subdir = as/ppc64
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
am__installdirs = "$(DESTDIR)$(libexecdir)"
PROGRAMS = $(libexec_PROGRAMS)
am__dirstamp = $(am__leading_dot)dirstamp
am_ppc64_as_OBJECTS = ../ppc64_as-app.$(OBJEXT) \
	../ppc64_as-as.$(OBJEXT) ../ppc64_as-atof-generic.$(OBJEXT) \
	../ppc64_as-atof-ieee.$(OBJEXT) ../ppc64_as-expr.$(OBJEXT) \
	../ppc64_as-fixes.$(OBJEXT) ../ppc64_as-flonum-const.$(OBJEXT) \
	../ppc64_as-flonum-copy.$(OBJEXT) \
	../ppc64_as-flonum-mult.$(OBJEXT) ../ppc64_as-frags.$(OBJEXT) \
	../ppc64_as-hash.$(OBJEXT) ../ppc64_as-hex-value.$(OBJEXT) \
	../ppc64_as-input-file.$(OBJEXT) \
	../ppc64_as-input-scrub.$(OBJEXT) ../ppc64_as-layout.$(OBJEXT) \
	../ppc64_as-messages.$(OBJEXT) ../ppc64_as-obstack.$(OBJEXT) \
	../ppc64_as-read.$(OBJEXT) ../ppc64_as-sections.$(OBJEXT) \
	../ppc64_as-symbols.$(OBJEXT) \
	../ppc64_as-write_object.$(OBJEXT) \
	../ppc64_as-xmalloc.$(OBJEXT) ../ppc64_as-dwarf2dbg.$(OBJEXT) \
	../ppc64_as-ppc.$(OBJEXT)
ppc64_as_OBJECTS = $(am_ppc64_as_OBJECTS)
ppc64_as_DEPENDENCIES = $(top_builddir)/libstuff/libstuff.la
AM_V_lt = $(am__v_lt_@AM_V@)
am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
am__v_lt_0 = --silent
am__v_lt_1 = 
ppc64_as_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ppc64_as_CFLAGS) \
	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
DEFAULT_INCLUDES = -I.@am__isrc@
depcomp =
am__depfiles_maybe =
COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
	$(AM_CFLAGS) $(CFLAGS)
AM_V_CC = $(am__v_CC_@AM_V@)
am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
am__v_CC_0 = @echo "  CC      " $@;
am__v_CC_1 = 
CCLD = $(CC)
LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_CCLD = $(am__v_CCLD_@AM_V@)
am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
am__v_CCLD_0 = @echo "  CCLD    " $@;
am__v_CCLD_1 = 
SOURCES = $(ppc64_as_SOURCES)
DIST_SOURCES = $(ppc64_as_SOURCES)
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = @ACLOCAL@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
ASLIBEXECDIR = @ASLIBEXECDIR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASFLAGS = @CCASFLAGS@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CXX = @CXX@
CXXABI_LIB = @CXXABI_LIB@
CXXCPP = @CXXCPP@
CXXFLAGS = @CXXFLAGS@
CYGPATH_W = @CYGPATH_W@
DEFS = @DEFS@
DLLTOOL = @DLLTOOL@
DL_LIB = @DL_LIB@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
ENDIAN_FLAG = @ENDIAN_FLAG@
EXECINFO_LIB = @EXECINFO_LIB@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
GREP = @GREP@
HOST_AR = @HOST_AR@
HOST_RANLIB = @HOST_RANLIB@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIPO = @LIPO@
LLVM_CONFIG = @LLVM_CONFIG@
LLVM_INCLUDE_DIR = @LLVM_INCLUDE_DIR@
LLVM_LIB_DIR = @LLVM_LIB_DIR@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
LTO_DEF = @LTO_DEF@
LTO_LIB = @LTO_LIB@
LTO_RPATH = @LTO_RPATH@
LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
OBJC = @OBJC@
OBJCFLAGS = @OBJCFLAGS@
OBJCWARNINGS = @OBJCWARNINGS@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
PROGRAM_PREFIX = @PROGRAM_PREFIX@
PTHREAD_FLAGS = @PTHREAD_FLAGS@
RANLIB = @RANLIB@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
STRIP = @STRIP@
UUID_LIB = @UUID_LIB@
VERSION = @VERSION@
WARNINGS = @WARNINGS@
XAR_LIB = @XAR_LIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_CXX = @ac_ct_CXX@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
ac_ct_OBJC = @ac_ct_OBJC@
am__leading_dot = @am__leading_dot@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
ppc64_as_LDADD = \
        $(top_builddir)/libstuff/libstuff.la

ppc64_as_CFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign -I$(top_srcdir)/libstuff -I$(top_srcdir)/as $(WARNINGS) $(LTO_DEF) -DNeXT_MOD -DASLIBEXECDIR="\"$(ASLIBEXECDIR)/\"" -D__DARWIN_UNIX03  -DPPC -DARCH64 $(ENDIAN_FLAG)
ppc64_as_SOURCES = ../app.c ../as.c ../atof-generic.c ../atof-ieee.c ../expr.c ../fixes.c ../flonum-const.c \
         ../flonum-copy.c ../flonum-mult.c ../frags.c ../hash.c ../hex-value.c ../input-file.c \
         ../input-scrub.c ../layout.c ../messages.c ../obstack.c ../read.c ../sections.c \
         ../symbols.c ../write_object.c ../xmalloc.c ../dwarf2dbg.c ../ppc.c

all: all-am

.SUFFIXES:
.SUFFIXES: .c .lo .o .obj
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps as/ppc64/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps as/ppc64/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):
install-libexecPROGRAMS: $(libexec_PROGRAMS)
	@$(NORMAL_INSTALL)
	@list='$(libexec_PROGRAMS)'; test -n "$(libexecdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(libexecdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(libexecdir)" || exit 1; \
	fi; \
	for p in $$list; do echo "$$p $$p"; done | \
	sed 's/$(EXEEXT)$$//' | \
	while read p p1; do if test -f $$p \
	 || test -f $$p1 \
	  ; then echo "$$p"; echo "$$p"; else :; fi; \
	done | \
	sed -e 'p;s,.*/,,;n;h' \
	    -e 's|.*|.|' \
	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
	sed 'N;N;N;s,\n, ,g' | \
	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
	    else { print "f", $$3 "/" $$4, $$1; } } \
	  END { for (d in files) print "f", d, files[d] }' | \
	while read type dir files; do \
	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
	    test -z "$$files" || { \
	    echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(libexecdir)$$dir'"; \
	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(libexecdir)$$dir" || exit $$?; \
	    } \
	; done

uninstall-libexecPROGRAMS:
	@$(NORMAL_UNINSTALL)
	@list='$(libexec_PROGRAMS)'; test -n "$(libexecdir)" || list=; \
	files=`for p in $$list; do echo "$$p"; done | \
	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
	      -e 's/$$/$(EXEEXT)/' \
	`; \
	test -n "$$list" || exit 0; \
	echo " ( cd '$(DESTDIR)$(libexecdir)' && rm -f" $$files ")"; \
	cd "$(DESTDIR)$(libexecdir)" && rm -f $$files

clean-libexecPROGRAMS:
	@list='$(libexec_PROGRAMS)'; test -n "$$list" || exit 0; \
	echo " rm -f" $$list; \
	rm -f $$list || exit $$?; \
	test -n "$(EXEEXT)" || exit 0; \
	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
	echo " rm -f" $$list; \
	rm -f $$list
../$(am__dirstamp):
	@$(MKDIR_P) ..
	@: > ../$(am__dirstamp)
../ppc64_as-app.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-as.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-atof-generic.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-atof-ieee.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-expr.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-fixes.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-flonum-const.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-flonum-copy.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-flonum-mult.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-frags.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-hash.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-hex-value.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-input-file.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-input-scrub.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-layout.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-messages.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-obstack.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-read.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-sections.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-symbols.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-write_object.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-xmalloc.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-dwarf2dbg.$(OBJEXT): ../$(am__dirstamp)
../ppc64_as-ppc.$(OBJEXT): ../$(am__dirstamp)

ppc64-as$(EXEEXT): $(ppc64_as_OBJECTS) $(ppc64_as_DEPENDENCIES) $(EXTRA_ppc64_as_DEPENDENCIES) 
	@rm -f ppc64-as$(EXEEXT)
	$(AM_V_CCLD)$(ppc64_as_LINK) $(ppc64_as_OBJECTS) $(ppc64_as_LDADD) $(LIBS)

mostlyclean-compile:
	-rm -f *.$(OBJEXT)
	-rm -f ../*.$(OBJEXT)

distclean-compile:
	-rm -f *.tab.c

.c.o:
	$(AM_V_CC)$(COMPILE) -c -o $@ $<

.c.obj:
	$(AM_V_CC)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`

.c.lo:
	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<

../ppc64_as-app.o: ../app.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-app.o `test -f '../app.c' || echo '$(srcdir)/'`../app.c

../ppc64_as-app.obj: ../app.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-app.obj `if test -f '../app.c'; then $(CYGPATH_W) '../app.c'; else $(CYGPATH_W) '$(srcdir)/../app.c'; fi`

../ppc64_as-as.o: ../as.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-as.o `test -f '../as.c' || echo '$(srcdir)/'`../as.c

../ppc64_as-as.obj: ../as.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-as.obj `if test -f '../as.c'; then $(CYGPATH_W) '../as.c'; else $(CYGPATH_W) '$(srcdir)/../as.c'; fi`

../ppc64_as-atof-generic.o: ../atof-generic.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-atof-generic.o `test -f '../atof-generic.c' || echo '$(srcdir)/'`../atof-generic.c

../ppc64_as-atof-generic.obj: ../atof-generic.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-atof-generic.obj `if test -f '../atof-generic.c'; then $(CYGPATH_W) '../atof-generic.c'; else $(CYGPATH_W) '$(srcdir)/../atof-generic.c'; fi`

../ppc64_as-atof-ieee.o: ../atof-ieee.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-atof-ieee.o `test -f '../atof-ieee.c' || echo '$(srcdir)/'`../atof-ieee.c

../ppc64_as-atof-ieee.obj: ../atof-ieee.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-atof-ieee.obj `if test -f '../atof-ieee.c'; then $(CYGPATH_W) '../atof-ieee.c'; else $(CYGPATH_W) '$(srcdir)/../atof-ieee.c'; fi`

../ppc64_as-expr.o: ../expr.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-expr.o `test -f '../expr.c' || echo '$(srcdir)/'`../expr.c

../ppc64_as-expr.obj: ../expr.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-expr.obj `if test -f '../expr.c'; then $(CYGPATH_W) '../expr.c'; else $(CYGPATH_W) '$(srcdir)/../expr.c'; fi`

../ppc64_as-fixes.o: ../fixes.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-fixes.o `test -f '../fixes.c' || echo '$(srcdir)/'`../fixes.c

../ppc64_as-fixes.obj: ../fixes.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-fixes.obj `if test -f '../fixes.c'; then $(CYGPATH_W) '../fixes.c'; else $(CYGPATH_W) '$(srcdir)/../fixes.c'; fi`

../ppc64_as-flonum-const.o: ../flonum-const.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-const.o `test -f '../flonum-const.c' || echo '$(srcdir)/'`../flonum-const.c

../ppc64_as-flonum-const.obj: ../flonum-const.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-const.obj `if test -f '../flonum-const.c'; then $(CYGPATH_W) '../flonum-const.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-const.c'; fi`

../ppc64_as-flonum-copy.o: ../flonum-copy.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-copy.o `test -f '../flonum-copy.c' || echo '$(srcdir)/'`../flonum-copy.c

../ppc64_as-flonum-copy.obj: ../flonum-copy.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-copy.obj `if test -f '../flonum-copy.c'; then $(CYGPATH_W) '../flonum-copy.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-copy.c'; fi`

../ppc64_as-flonum-mult.o: ../flonum-mult.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-mult.o `test -f '../flonum-mult.c' || echo '$(srcdir)/'`../flonum-mult.c

../ppc64_as-flonum-mult.obj: ../flonum-mult.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-flonum-mult.obj `if test -f '../flonum-mult.c'; then $(CYGPATH_W) '../flonum-mult.c'; else $(CYGPATH_W) '$(srcdir)/../flonum-mult.c'; fi`

../ppc64_as-frags.o: ../frags.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-frags.o `test -f '../frags.c' || echo '$(srcdir)/'`../frags.c

../ppc64_as-frags.obj: ../frags.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-frags.obj `if test -f '../frags.c'; then $(CYGPATH_W) '../frags.c'; else $(CYGPATH_W) '$(srcdir)/../frags.c'; fi`

../ppc64_as-hash.o: ../hash.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-hash.o `test -f '../hash.c' || echo '$(srcdir)/'`../hash.c

../ppc64_as-hash.obj: ../hash.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-hash.obj `if test -f '../hash.c'; then $(CYGPATH_W) '../hash.c'; else $(CYGPATH_W) '$(srcdir)/../hash.c'; fi`

../ppc64_as-hex-value.o: ../hex-value.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-hex-value.o `test -f '../hex-value.c' || echo '$(srcdir)/'`../hex-value.c

../ppc64_as-hex-value.obj: ../hex-value.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-hex-value.obj `if test -f '../hex-value.c'; then $(CYGPATH_W) '../hex-value.c'; else $(CYGPATH_W) '$(srcdir)/../hex-value.c'; fi`

../ppc64_as-input-file.o: ../input-file.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-input-file.o `test -f '../input-file.c' || echo '$(srcdir)/'`../input-file.c

../ppc64_as-input-file.obj: ../input-file.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-input-file.obj `if test -f '../input-file.c'; then $(CYGPATH_W) '../input-file.c'; else $(CYGPATH_W) '$(srcdir)/../input-file.c'; fi`

../ppc64_as-input-scrub.o: ../input-scrub.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-input-scrub.o `test -f '../input-scrub.c' || echo '$(srcdir)/'`../input-scrub.c

../ppc64_as-input-scrub.obj: ../input-scrub.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-input-scrub.obj `if test -f '../input-scrub.c'; then $(CYGPATH_W) '../input-scrub.c'; else $(CYGPATH_W) '$(srcdir)/../input-scrub.c'; fi`

../ppc64_as-layout.o: ../layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-layout.o `test -f '../layout.c' || echo '$(srcdir)/'`../layout.c

../ppc64_as-layout.obj: ../layout.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-layout.obj `if test -f '../layout.c'; then $(CYGPATH_W) '../layout.c'; else $(CYGPATH_W) '$(srcdir)/../layout.c'; fi`

../ppc64_as-messages.o: ../messages.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-messages.o `test -f '../messages.c' || echo '$(srcdir)/'`../messages.c

../ppc64_as-messages.obj: ../messages.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-messages.obj `if test -f '../messages.c'; then $(CYGPATH_W) '../messages.c'; else $(CYGPATH_W) '$(srcdir)/../messages.c'; fi`

../ppc64_as-obstack.o: ../obstack.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-obstack.o `test -f '../obstack.c' || echo '$(srcdir)/'`../obstack.c

../ppc64_as-obstack.obj: ../obstack.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-obstack.obj `if test -f '../obstack.c'; then $(CYGPATH_W) '../obstack.c'; else $(CYGPATH_W) '$(srcdir)/../obstack.c'; fi`

../ppc64_as-read.o: ../read.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-read.o `test -f '../read.c' || echo '$(srcdir)/'`../read.c

../ppc64_as-read.obj: ../read.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-read.obj `if test -f '../read.c'; then $(CYGPATH_W) '../read.c'; else $(CYGPATH_W) '$(srcdir)/../read.c'; fi`

../ppc64_as-sections.o: ../sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-sections.o `test -f '../sections.c' || echo '$(srcdir)/'`../sections.c

../ppc64_as-sections.obj: ../sections.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-sections.obj `if test -f '../sections.c'; then $(CYGPATH_W) '../sections.c'; else $(CYGPATH_W) '$(srcdir)/../sections.c'; fi`

../ppc64_as-symbols.o: ../symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-symbols.o `test -f '../symbols.c' || echo '$(srcdir)/'`../symbols.c

../ppc64_as-symbols.obj: ../symbols.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-symbols.obj `if test -f '../symbols.c'; then $(CYGPATH_W) '../symbols.c'; else $(CYGPATH_W) '$(srcdir)/../symbols.c'; fi`

../ppc64_as-write_object.o: ../write_object.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-write_object.o `test -f '../write_object.c' || echo '$(srcdir)/'`../write_object.c

../ppc64_as-write_object.obj: ../write_object.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-write_object.obj `if test -f '../write_object.c'; then $(CYGPATH_W) '../write_object.c'; else $(CYGPATH_W) '$(srcdir)/../write_object.c'; fi`

../ppc64_as-xmalloc.o: ../xmalloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-xmalloc.o `test -f '../xmalloc.c' || echo '$(srcdir)/'`../xmalloc.c

../ppc64_as-xmalloc.obj: ../xmalloc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-xmalloc.obj `if test -f '../xmalloc.c'; then $(CYGPATH_W) '../xmalloc.c'; else $(CYGPATH_W) '$(srcdir)/../xmalloc.c'; fi`

../ppc64_as-dwarf2dbg.o: ../dwarf2dbg.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-dwarf2dbg.o `test -f '../dwarf2dbg.c' || echo '$(srcdir)/'`../dwarf2dbg.c

../ppc64_as-dwarf2dbg.obj: ../dwarf2dbg.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-dwarf2dbg.obj `if test -f '../dwarf2dbg.c'; then $(CYGPATH_W) '../dwarf2dbg.c'; else $(CYGPATH_W) '$(srcdir)/../dwarf2dbg.c'; fi`

../ppc64_as-ppc.o: ../ppc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-ppc.o `test -f '../ppc.c' || echo '$(srcdir)/'`../ppc.c

../ppc64_as-ppc.obj: ../ppc.c
	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ppc64_as_CFLAGS) $(CFLAGS) -c -o ../ppc64_as-ppc.obj `if test -f '../ppc.c'; then $(CYGPATH_W) '../ppc.c'; else $(CYGPATH_W) '$(srcdir)/../ppc.c'; fi`

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-am
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-am

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-am

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(PROGRAMS)
installdirs:
	for dir in "$(DESTDIR)$(libexecdir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
	-rm -f ../$(am__dirstamp)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libexecPROGRAMS clean-libtool \
	mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-compile distclean-generic \
	distclean-tags

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am:

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am: install-libexecPROGRAMS
	@$(NORMAL_INSTALL)
	$(MAKE) $(AM_MAKEFLAGS) install-exec-hook
install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am: uninstall-libexecPROGRAMS

.MAKE: install-am install-exec-am install-strip

.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
	clean-libexecPROGRAMS clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-compile distclean-generic \
	distclean-libtool distclean-tags distdir dvi dvi-am html \
	html-am info info-am install install-am install-data \
	install-data-am install-dvi install-dvi-am install-exec \
	install-exec-am install-exec-hook install-html install-html-am \
	install-info install-info-am install-libexecPROGRAMS \
	install-man install-pdf install-pdf-am install-ps \
	install-ps-am install-strip installcheck installcheck-am \
	installdirs maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
	uninstall-am uninstall-libexecPROGRAMS

.PRECIOUS: Makefile


install-exec-hook:
	mkdir -p $(DESTDIR)$(libexecdir)/as/ppc64
	mv $(DESTDIR)$(libexecdir)/*ppc64-as* $(DESTDIR)$(libexecdir)/as/ppc64/as

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/as/ppc64/ppc64-as                           0100755 0000000 0000000 00000770510 13101126723 023234  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF          >    @     @       H         @ 8  @          @       @ @     @ @                                      @      @                                          @       @     $p     $p                   (p     (pc     (pc     `      4                    s     sc     sc                                    @     @     D       D              Ptd   ;     ;C     ;C     
      
             Qtd                                                  /lib64/ld-linux-x86-64.so.2          GNU                        GNU +)iSf0%   @   9   "   &      +   )   >       %   ?       6          /   5   #   1       3   0   -       8          ,   *   =   4   7   ;      $      2                                          :                      <          
                                                                                  '      !   	                                 .   (                                     :          H  :   ;       `|&fUaN9                            p                                                                 f                                            W                      O                      .                                            j                     =                                                               7                                                                 >                      y                      V                                                                6                      C                                           !                     /                     '                                                                 r                                           ~                                                                 H                                                                                                                                                        ^                      P                                          )                                           (                                                                                                                                   6                                                                                                               `@     c      e     @             ]    @     _       l     |c                 @     X            |c             libc.so.6 strcpy exit sprintf _IO_putc fopen strncmp strrchr setbuffer signal strncpy unlink realloc abort stdin memchr mmap fgets calloc strlen ungetc memset strstr __errno_location fputc memcpy fclose strtoul malloc strcat __uflow __ctype_b_loc getenv stderr _obstack_newchunk readlink index strncat getcwd fwrite fread gettimeofday bcopy strchr obstack_free qsort __ctype_toupper_loc __ctype_tolower_loc __xpg_strerror_r __xstat memmove _obstack_begin access strcmp strerror __libc_start_main vfprintf __gmon_start__ GLIBC_2.14 GLIBC_2.3.4 GLIBC_2.2.5 GLIBC_2.3                                                                                    	     ti	        ui	         ii   ,      uc        %           uc        ?           |c        ?           |c        =           uc                   uc                   uc                   uc        ;           uc                   uc                   uc                    vc                   vc                   vc        	           vc        
            vc                   (vc                   0vc                   8vc                   @vc                   Hvc                   Pvc                   Xvc                   `vc                   hvc                   pvc                   xvc                   vc                   vc                   vc                   vc                   vc                   vc                   vc                   vc                   vc                   vc                    vc        !           vc        "           vc        #           vc        $           vc        %           vc        &            wc        '           wc        (           wc        )           wc        *            wc        +           (wc        ,           0wc        -           8wc        .           @wc        /           Hwc        0           Pwc        1           Xwc        2           `wc        3           hwc        4           pwc        5           xwc        6           wc        7           wc        8           wc        9           HH}b# Hts  H              5rb# %tb# @ %rb# h    %jb# h   %bb# h   %Zb# h   %Rb# h   %Jb# h   %Bb# h   %:b# h   p%2b# h   `%*b# h	   P%"b# h
   @%b# h   0%b# h    %
b# h   %b# h    %a# h   %a# h   %a# h   %a# h   %a# h   %a# h   %a# h   %a# h   %a# h   p%a# h   `%a# h   P%a# h   @%a# h   0%a# h    %a# h   %a# h    %za# h   %ra# h    %ja# h!   %ba# h"   %Za# h#   %Ra# h$   %Ja# h%   %Ba# h&   %:a# h'   p%2a# h(   `%*a# h)   P%"a# h*   @%a# h+   0%a# h,    %
a# h-   %a# h.    %`# h/   %`# h0   %`# h1   %`# h2   %`# h3   %`# h4   %`# h5   %`# h6   %`# h7   p%`# h8   `%`# h9   P1I^HHPTI B HB H.@ 'fD  |c UH-|c HHv    Ht]|c f     ]fffff.     |c UH|c HHHH?HHt    Ht]|c  ]fD  =d#  uUHn]d# @ 8pc H? u     HtUH]zf.     W)e# )e# )e# )e# )je# )Se# )<e# )%e# )e# )d# )d# )d# )d# )d# )d# )md# d# hd# ed# H$        HB |c H|c Hu$d# e# ud# :d# 1d# u,d# B [B ffffff.     H|c HuA [B ffffff.     H|c Huff.     UAVSHsd# 
wS$B Hed# HHHZd# D0x Y	  Nd# 8d# >d#    >	  f     H(HCH;C   HHHKD0A)  AA	t8   A?h  A95  A.   A z  ff.     HCH;CsHHHK Hc|c uHAu  f   =`c#  t%/   /0uq!HA;/tZuSuNH.c# '  c# uA      	b# 
   A/!  HCH;C   HHHK /   *t  HHCH;CsCHHHK t*u!HCH;Cs.HHHK8t*/u/
u^b# HHB 1z      H_HHCH;CsHHHK 
tuB 1zz  
   A  A=a#    B 1Bz    H% HCH;CsHHHK 
uv  @   A@    HCH;C  HHHK c  H
sA@  ff.     HHHK Hc|c   HCH;CrHAuO  HCH;Cd  HHHKD0ra# K  A'A  `# `# A'     `#    HCH;C  HHHKD0A	%  Ar  B   HCH;C  HHHKD02`#    8`#    8  H+HCH;CsGHHHKD0A
  A  A*uHCH;Cs$HHHK8t /uHRAHE_# _# A      A:  A:   =_#   s_#       A  A\4  P_#    A\   Z  A!oA
G  n   H86_# A\   ,  "Au{"   H_#    ^# H^# !B A@     A  A[   DA7   H      H     HHHKD0AtA
tHCH;CrHAg^#     w  l^# V^# 
   HY^# uc)B 1v  A'   ;  A"1  &^# ^# A"     AFwAD  qB 1Dv    MB 1nv  A"     A
  ]# 
   t]# 
   
   H]#     A  H-HAHAHAA"u\5]# ?]# %]#    A"   /  B\# u=]#  y  p  HA/   >4A'u1]#   \# \# \#    A'     Ic|c \# t!tC   ~\# 	   	      t"
t		   X\#       }   1tw     HCH;CsHHHK Hc|c u   Hu;B 1t  A
     
u DH[#    A       u=t   [#       u   H/"ffff.     HCH;CsHHHK 
t{H
r
tlBHka[#    G[# HD[# B A.   IuJHHCH;CsHHHK 
t;B 1s  Z#     A
   D[A^]]B HCH;CsaHHHK}c 6B 1cZ# Z# Z# HZ# }c D5Z# A/   tHHu1B 1r  fUAVSFZ# 
   $pB HY# HY# H9  HPHX# 0
  {  *uHH9  HHHX# H  /w  HPHX# HHX# HX# H9Hu!  H~X# H-X# H9G  A@   HQH]X#   
	t-  ?  9  .u        HH9  HFHW# H:H  |c HHu{  =X#    @/!  \  /'  H9  HQHW# q*tN/  HH9t"HAHlW# A
   HuB 1q     jX# HH9t[HJH+W# *tt

HuH9t4HBHW# Rt/t,HV# HV# H-V# B 1p  HV# HHHV# @ nHHV# _@/tGu@u;HFHV# @~W# [  4X# u    u  HFHMV# @~HBV# H-CV# H9	  =3W#    B 1o    HW# HHHW# x   W# V# V#    f  HU# HU# H9J  HJHU# 2E  ~
@   Hc|c G  H9v  HHH=\U# 1HHu  HBU# H;CU# >  HAH*U# 	V# &  '  .V# V# '     V#    HT# H;T# t HHHT# 	5  U  B O  HT# H;T# tHHHT# U#    U#      HoT# HpT# HH9HtHJHRT# 
u  @    YU# CU#       :  :   =$U#   U#       H%t\   T#    \   i  T# T# HHHS# @
sU# u>)B 1Rm  '   ,  !G
  H{S#  nT# \     MB 1m  "         /o"     "uoHAH!S# A";T#    !T# HT# !B @     HG"  T# S# "   l  [NC[  VHHyH=R# Ht
tH9HtS#       CwAD  qB 1l    
   qS# A
   t_S# H,R# 8S#     D  "uZ%S# /S# S#    "     H0R# u=R#      HBHQ# @r/   5'u0uS#   R# R# R#    '      R# Hc|c       H[Q# H\Q# fff.     H9   HJH4Q# H2H   |c HuHQ
   @
t~H9t!HHH5P# 
tcHHu]B >tpHP# HP# H)HtHQHP# 	
t#HHu;B 1Ej  Q#     Q#     ;B 1!j  
   [A^]tubQ#    HAP# @2\Q#    BQ# H?Q# B .   /   tHBHO# @rH9tHAHO# Yu1B 1i  }c 6B 1P# P# P# HP# }c P# *fD  HyO# HP# GP# GHP# HGP# G((P# GsP# G,RP#     XP#     HEP#     W)SP# YP#     3P#     fffff.     HHN# GO# GP# HGHO# G(P# G)O# G,O# f.     UAWAVAUATSH(IAI$HP#       BHt   `8@ -      Ht   `8@ 	      Ht   `8@       Ht   `8@ W)O# )O# )O# )rO# )[O# )DO# )-O# )O# zO# B eH   A   E   DL    H} ADLcHuL HH=mO# 1E~wI       ELfffff.     Hu WH} HHH HH#O#  LH H=O# HHAu   q HH=N#  I\$E~AH\$D|$$#  1HD$B H$     H+Hl$E -  B H>ttB H-tTB HtCB    Hf~  E-u} t5HHl$Dm Ej  U  G#    F  M# :  HB 5  H5N# 4B 1i  M#    H\$   H|$HB s   A~c   F#      H\$H{B <)  A~c   HD$8    D$$   HL$H    D$$HD$HHHL$H@   H\$H{B   H{B   HD$B L#   8n#    HD$B   L#    HD$B   4B    H5L# B 1H$Hh  HHD$B H$  .   )KB    `E# tdtB 1Vh  HD$H(H-L# 1E# d   F  3   )t"3u6Q.uQ2uAK#   .   )2   )tB 1g    K#    fffff.     HHl$AEA~c  t:AIt4Aat.Aft(Adt"AstAktH5K# B 1Dc  AAw  Hr@ A~c AKBAI      HHE     H=K#    HD$H(       Au   Ar@  A`  AGu  $(B H\$H{B kX  HD$B D$$HL$H    D$$HD$HHHL$HH3   )34y.y3qAv  H=H# kB @8C 1H=G# IB wc 1Hl$}    XB HtB 1e  Hl$}    H     Hl$}  Hmu  AsB  H\$H{B ?,  HD$B 2I#    H-kI# HD$8 t	HEX  D$$@  HL$H    D$$HD$HHHL$H@HE  AG   $B H\$HkrB HB H}   HD$B D$$GHL$H    D$$HD$HHHL$HhB HBB H-   B ff.     H\$HH\$H|$Ht$$HT$W uH5DH# B 1D%d  HD$Ht)8 t$HHD$B 1 d  HD$B Hl$Hl$Dm E H\$D|$$fD  H    H\$HH\$EAGD$$A	B H$LG# uGG# u9B 1xc  =#  u.G#    
=#G#  tHG# Ht
*@# bB H=G# p    g  F# ui  T A  Et91II<$Ht
2B  HuIAufHvj  AuuB B  HtHVj  !D  t=g# t! L  H<$  A  GU g# H([A\A]A^A_]fPuB 1Oa     D  UHAWAVAUATSH   HHH`HXL7A+t-u	EfIA+E1AH3  hAIt|NE  Aithn1  AF au6AF nu(HHA A    HHAIL7E1  E  AIt	i   AF n   AF f   +PtNHHAA    HHAIFAN iuCAN nu4AN iu%AN tuAN yuILHE1/  H8DE    M    u#1M   H8D1M1D  pHhAHXH   H`HupMMMFH BDpMMtPp0IV   ELDHhEeIEf1H8E1+  HXwH   M}Ee1E   ff.     XAH`8HuIHPH HPDHtpX0p   OpEeLHEMIuE1IHhKE1HhgLE1I   MHhXMp A    HhXt(E1t!HcHcL 0u	HuAEtdHhAH`?HtVD`LLhDxHE1EtJB    DHt8HXHIu-d1H8   1HhH8xA+?DA+"H E1fff.     HDHtAk
DdA]IuAD-AEHhH8D`D1M1L/A	  XHhHHHHH+HHHpA*Y' ' ^X# ,A9DOWA*YX ,AAAAAA\$CD$HcHBHII)L1LE   D`LcKL}L I9vfD`D    IADPt0t&      Iu~HHA    HHHADAE1  D`DI6ADpt4Lfffff.     k
f7HH9vt  IuHhD)XAD$HHAIcILM fHf9 uHSLmHIDEHEHEE    E+D<HpH!H       HH HBHII)LII)LI1LoE!B A#B LHA1HpHfA E    LuLuILFHME+LxIDEHEtgI A   H]ffffff.     At5A   D;5 8LILHxH&  HLL%  AAI EuE1H}HuHHH|&  DCDHe[A\A]A^A_]<f.     fUAVSHHH|$H8# ~c W8# H8#     N>#     H;>#     A      ODteEtSF   two#c/F   $B x   pt0rtst8ydteu'A      A      A   fuCHHH ~c HD7# H|$;B [B xc t.u8ffB1B 1T  CH>HDD   *ffC  fC  ffC  6# -ufHl$HH[A^]    UAWAVAUATSPAIL6# L6# 6# M9v;+fAIAIcH1L1H[A\A]A^A_]PtNuAu3A  Au-A  u)AAtAFI  I  E<#    LB<# MYM)ID9<# 1A   M@ Et)A~3AD-<# E:DD   D  E1f     IcE:B D!   D)AD;# t8A   A)D-;# IrH5;# EzDDH#<B 	IE1fff.     HH	5# A\AD))J   tH +L<>wEHA   A)Et[A   <$AD-:# IL:# AD:#    HcB tIA9  fAfB  <$IL:# :#    :#    A   A   P   )H1E  EA)S  DV:# HAD#B   <$AD-2:# DIB,A E|1DD   )D9~4L   $fAfAF  A   I~fAF    jD)$fAL*9      AF    I~   H$   fAfAF  fAF  ffAF  3# -fA1E  H)D)  ,9# HcA#B   A   A  f   A1  fAF  1E$  A  AD-8# AD  w     H$I~|*AAHT1_H$HI|FD)2  Dy8# 1E     )HcT8# 9(  )D8# HH?8# #B   I  f-[fARIcA#B D)AD7# t5A   A)D7# MJL7# ArDH#4B 	MEE1	H	IvfAA   u[Au]fAF  1IE   A   ADa7# AD    E1,$v  DG7#   I  I  IcHA#B D)@AD7# ,$+     )6# IRH6# ARHc#B 	   E1  1E  HD)  6# HcA#B X  E16  IcA#B    D)ADk6#    A   A)DI6# IrH5B6# AzDH#<B 	IzH5!6# #B )AD6#      )5# HnH-5# vH#4B 	  E1	I~fA.  E1t  E1z  E1   IvfAVA   IcIFEH9   IIIII@ 1uzA~ADU5# AD[IcA#B    D)AD/5# t,D5# IjH-5# AzDH#<B 	I	E1fD  fHEH9jEMK4N	EA~AD4# ADPIcA#B    D)AD4# t*   )j4# IzH=c4# AzH#<B 	HFL9r$   ftHHL9HHsAL1N%  fA@IcA#B    D)AD3#       )3# IrH53# ArH#4B 	aIcHA#B D)@AD3# tG   )p3# IRHi3# ARHc#B 	E1fHE1I~fAVE1I~fAFIcMFEL9   IIMIIHfD  1uzHc2# H~H2# H2#  SH52# .#,B    )AD2# t'2# HNH2# vHc#4B 	E1f+HEL9jEJ<G	EHcG2# H~92# H62# QH5%2# #B    )AD2# t)   )1# HnH-1# vH#4B 	HGA|SHO  uAHAL9   Hf
HL9HHsf fffff.     SH0H\$hOB 1HH\$H|$;B [B xc tB 1L  H0[f.     D  PuH uHZx     Pjf.     AVSPI1LO   u<   I> u1IFHt$HpHcxc Hwc 1B 1G  H[A^fUAWAVAUATSHHIL
  H~Q# L0F<`B A   @A{9A;OA   A!   A&   &D<      A|uv|D|@   A<tA=u3A   =u_oA   s_HD<B EuN:A>uA   >t8=u-A   +B   B 1D!K  IM  A	   Ml$D$  fffff.     HcB HQP# Ht$ uXB 1sF  WAD$A$HP# H0D<`B A   @{@;VA   !   &   &D<      f.     |uy|D|@   <t=u5=A       DDdA   sTHD<B F>uA   >t3=  A   "E1B   B 1I  f     A} u/I|$ B B B 1D8E  WAD$A$l$8u0H|$0 B B 1B 1DD  WD$,)D$ t<   H\$0HL$ HD$(HD$ HL$(HtD$8           v)B   B 1H     fff.     $B HD$(       ff.     A} tCt>L\  H|$ R  AD$L$8u%u!u1H|$0uAL$  B 	WA$  DB 1C  AD$    ID$      HD$ HL$(H9u-D$8    W)D$ W)D$ HD$0    f.     Au Hv&B   B 1G  ^fffff.     $8B ID$    >I$I9L$u7AD$    WA$ WA$ID$    ffffff.     I$HD$ HtBQtNHtb@tMHqHP1B 1B  I$    Efffff.     1Ht0I$@H   HtI$    	xc HL$(Il$HtJEtfHtyA   HuHQ1B 1\B  ID$    1_ffffff.     1H    tDIL$AHxc H+   Ht!ID$       xc f.     t{tvt9=)#  u&t!tt9tI$MP9  AE    A} upHD$0ID$ID$I;$uMAD$    :ID$    f     B 1dA  AD$    ID$    HD$0ID$WA$E  &  A\$HD$0ID$v;B   B 1TE  Cw+$B ID$HD$0ID$$hB ID$    B   B 1E  rA	   GWA$HpHUB 1@  AE     'HL$0H'  ID$HHID$HL$0H  ID$HHIT$L$0I|$L$0Id$ID$H;D$0   ID$H;D$0   ID$H;D$0   ID$H;D$0   ID$H;D$0qID$H;D$0bHD$0I!D$gHD$0I1D$XHD$0I	D$IHD$0HI	D$7I|$ t<H|$0 3I|$ u	H|$0 ID$iB 18?  I1ID$@ D`B ;D$lAE HH[A\A]A^A_]f     AWAVATSPH{  &#    L3M   AF$   L{M   AG$   IN@Mg@L9tiH   M   1IN@I9tqAL$8uAL$(AL$AD$!usAD$AL$(   HcH Md$Mu*HtFHKIFHcHIWHcH9x,HH)IM;f@uIFI+GHCC    WCH[A\A^A_HyG# "uQHBHfG# HHHHUG# tI
tA"Hu H5G# HAH*G# 	 fD  HBHG# 
 zc HuHPHF# @  Gff.     UAWAVAUATSHIL5F# A u
IL5F# InH-F# M>QHHBDxt]Ll$E1A
      A0u  InH-hF# E~E1AAIcHD$A      jE  E1>  EA$tA.uE  zc A  A zc uJA"tDA}  &O  A!  Y  AWQ  ABF  ^  A"L5E# MLDA"uSH-E# HLHH-E# tP
tH"Iu  HkE# HhH-`E# 'fff.     InH-EE# A zc IuHEH*E# E L>  H  HHxc AUHHP  IE    IE H  AE   
  HF# L## L$# II@I)PhB    1  HH  IE    I] AE     w   AX   b  u F  B    t$t$=t$E1H  InH-"D# E~A   cA~    111E1Axc L  IE IE    AE   H    AxE  InH-C# E~A      A     A'  A(  1Lu6I}  u/IEHt"HpHcxc Hwc B 19  H=C# HHH2C#  )G  B 1Z9  HC# /     E#  Afuz+H  IE    IE AE   	  fuQ@u @  @t$B    Hu[B t$E1H{     E   [B DE1   Hg  HH\$DXtH D<AIcLl$IE0c ;B [B xc lt,uIB 1;  AE     xB 1z;  AE     E1E1   H@IEHA# A"uHA# @"IE      IFHA# IFIEM  A-u5Ltu7A-uHIE IEIE     AE   p  AE   L5@A# \  uA-  I]E  B 1DU7  1  L5	A# A0   LA
   I yc 1D9H}=1Hfffff.     IHHHFH@# L>A yc D9H|EuHH)H9   fi#   c H-}@# L}A yc D9}hc 6c H9c r fD  8Af8HH9vtH9sfYHHEH@# L} A yc D9H|Hc H9   E   # # 	Hc   ATALHLl$     AULl$   f        HH  HHu"111E1Axc Hz  HHO  Im AE   WAEW  c H)HH   ALLl$   H   HPH>#       8L   HBH># L   HH># H   b   1,  H  HG  @=  IE IE    AE      Uu~HPHh>#       (LuOHBHK># Lu6HH8># H>HH   H)HH># I]AE    $HH   H)HH=# IMAE   HH=# AuHvB   B 1O8  =$0B IE    ,IEI;E u"AE    WAE WAE IE    Hy=#  u
HHg=# AEH[A\A]A^A_]B 1H3  IE    AE    QIEA!uHIE5HIE)     UAWAVAUATSHAIl$`\$XD|$PH># HpXL># L9vNc X   Ll$MMIDd$A8  DDd$LD|$PMMLl$H># L># L5k># Hc5># HD0XHH!LJ># HL)LL)H9IOH5@># H51># M.EfAV0INMFMN E~1A^2An3AfDI~8Iv@  H=# H@pIF(H=# LppLH[A\A]A^A_]     UAWAVAUATSPEAIDD$@q1tu	HLY!HEDM]MAEE1Hx=# HqXHu=# H9vSc X   D|$DDD$$AMIMn7  MLMDD$$AAD|$H=# H=# L5=# Hc5=# HL1XHH!H<# HH)HH)H9HOH5<# H5<# MEfAV0IFIF    M^ E~1EN2EF3AfDI~8Iv@k  H\<# H@pIF(HM<# LppLH[A\A]A^A_] f.     fAWAVATSPIIAFAGI6I^H)HHxHI       I?IWH)IID)~6HcH4^H LH ~IGIGA^A_WIHIGJ}HcH|OA)Ic1hI?I6H LH H/AFAGIFI+HIIGH[A\A^A_f     UAWAVAUATSG+t-.  N+t-  9+t-BLHOL)HLHFL)HvwH:LzI)ID4E)EADD!E!E   l$H|$HT$A1E11fHE11fD  A9%9!xCAEjDADAIHuA	uExAD$     ExIcHl$f|U AHD9ul$tE~(IcH|$fGHT$GB OHT$H|$A2AEEHT$H|$~HcHOf1fHH9sAIcHGHBj[A\A]A^A_] UAVSH=#  u@%B 1D2  H# H# )9   H# @8    @(    @    1   L5# D9v	Hw# H# H# )9sHtC@ H# @8    @(    @    1m   HN# H?# )9s9rIcH# )9s%B 1[A^]o1  [A^]f.     G8    G(    G    f.     AWAVSH=#  u@%B 1#1  H# H# H@))pLc# LLHH!H# Hx# HH)H# HH)H9~
Hi# HHW# L=7# MwHq@H9Hv2Hc @   92  H=2# D?# H# H# H# H@H=# #     HH)HH)H9HOH=# H=# H# D# WA0A AINH# IGH# H@    [A^A_fff.     SH# HcHHt# [fUAWAVAUATSPDL$MAALL5E# HcI>H7# HX# DhX8D`<Lx HB# L$H(HL$@HH0%LH[A\A]A^A_] UAWAVAUATSPAIAlL=# HcI?H# H# X@8   Dh<H@     H# D`(H@0    w'   sHcLLH[A\A]A^A_]%B 1H[A\A]A^A_]-  ffffff.     H)# HJ# H@H)f.     H	# H*# H@H)f.     AVSPP     HLs11@LA A@ Ld/  HS(LC0H~  L9v~  L/  HS(LC0H{ HcK<H
~  HH!HK(HSHH)LH)H9~LC(LHK H;1~  C  HH[A^SHH{11  H[H     UAWAVAUATSH(HT$IILH1HtvHtHH    tA$i  1   HrDHH)JT"f.     ri  12i  1HHui  11AvHT$ IHD$Lt$HE1ffff.     IE Ht^MIA9muMuLLHuA< u%B M   IE IHL$ HT$HIE L,%B    H\$Hs(LC0HN L9vH{    -  Hs(LC0HK HcS<Ht HH!HS(HsHH)LH)H9~LC(LHS LaiHD$HAHT$ Ht$HHH1H([A\A]A^A_]UAWAVAUATSH(HT$ IILH1HtvHtHH    tA$i  1   HrDHH)JT"f.     ri  12i  1HHui  11AvHT$IHD$Lt$HE1ffff.     IE HtYMIA9muMuLLHuA< uMtIE IHL$HT$HIE L,HD$ IE   H\$Hs(LC0HN L9vH{    +  Hs(LC0HK HcS<Ht HH!HS(HsHH)LH)H9~LC(LHS LaiHD$ HAHT$Ht$HHH1H([A\A]A^A_]D  UAWAVAUATSH(HT$IIL/H1HtvHtHH    tAi  1   HrEHH)JT:ff.     ri  12i  1HHui  11At$HT$I$HD$HE1H    HL$    1HL$      MIA9mu$MuLLHuA< t    IE Hu5MtIE I$HL$HT$HIE L,IEHD$ HD$IEHD$ H([A\A]A^A_]fff.     UAWAVAUATSHIILI1MtkMtLH    tAi  1   Ir:LH)JT2ri  12i  1HHuAi  11AwHT$IH$HE1H    HL$t{1HL$fffff.     MIA9l$u#I\$HLLPuB<+ tD  I$Hu+MtI$IHL$H$HI$L$ID$HD$HD$H[A\A]A^A_]fD  UAWAVAUATSHII1MtvMtLH    tAi  1   IrELH)JT2ff.     ri  12i  1HHuAi  11wHT$HH$HE1H    HL$ty1HL$ffffff.     MIA9ou$I_HLLuB<+ t    IHu)MtII$HL$H$HIL<IGHD$HD$H[A\A]A^A_]f     UAWAVAUATSH(IILI1MtkMtLH    tAi  1   Ir:LH)JT2ri  12i  1HHuAi  11AwHT$IHD$HHD$E1H    HD$    1HD$ HD$ffffff.     MIA9l$u#I\$HLLuB<+ tD  I$Hu@MHL$HT$tI$IHI$L$Ld$L;d$u&I$HID$HD$ HD$ H([A\A]A^A_]fff.     UAWAVSPHIAFt:E1     DIH,HtH}HuHm HuAFAA9rH[A^A_]fD   f.     fHE#     @ ffffff.        f.     H=#  AVSHXH5# ; t~C HI%B L5# L5# H# M      l     LH|H=# HGH;G   HHHO8H5# #   HFH;F   HHHN Nu^HW# H$P   H>B Hu
;#     H<$
   mH5# Hu"%B Hr  H5# 
u
   #   3HX[A^CH_fUAVSI   H# 1H   =#  t<H#    L    HH# H,t1u      L	   )xtHIL?H50# %B   H=# tH5# &&B m  H#     1[A^]f.     P## D Hcs  H#  
#     H#     H#     X Kff.     AVSPH=X#  W; Hu%B H{# #     ; tZ/   HWHtHx tB)H I       IH       HH   H<# I HHL@#     H1# HH[A^fffff.     AWAVSHIHc# H   t0H=# HH5# H# # HHc=# HH=# Ht$H   L|$@ HHfff.     QH
uH=# HWH9   z# t:)j# 5X# T6LcHH)LHcD$H9,56# Hc  H)# HIH=# # HcH|8LHUH#     =#  ~(L&B 1e  H# )# #  H# H[A^A_     H=p#  # #  HtH=T# x5f# f     PH=/#  t3H)# HHD# t0# D## H=" X# H=" tH# p&B 1AXw&B 1Yffff.     SHH        H# Ht+H# HHEH=t# D# [fD  AWAVSIHIc    I    Hc A    H/# Ht]H+# HHEt1# D$# AI/   HHtHKIH)c HH[A^A_[A^A_ffffff.     USHHHHH=" &B 1HHkvH+H4$@   H=P" uH$&B 16&B 1&H5'" 
   %    tH'# Hup!#    HH[]H# HHD # u# H=" u&w&B 1 # D # H=" H # p&B 1fAWAVAUATSI   
tGA/t}H # HtqH	ILLH=   r&B 1HLQ  ?M  Ac c HTc Lc      H	" H   Ac f.     LcLtILiLH=   r&B 1LL  Vf.     #  Hsc c !fc / c L+c       HHhHI" A~c H   Ac fff.     HILLH=   r"&B 1HL   Vfffff.     9#  Iuc c afc / c Lkc    t#I] IHgE1&B 1L  L[A\A]A^A_     UAWAVAUATSHhHL5# L=t" -6" L%" L-" H# HD$0H%" HD$(6" D$$@" D$ H=" HD$H" HD$" D$$" D$" D$H|$8<"     "    3N" D Hc  H"  
"     H}"     Hj"     HH=-"  tH   H=t" L5# L=a" -#" L%" L-" HD$0H# HD$(H" D$$" D$ )" HD$H%" HD$H" D$" D$" D$" H|$8Hh[A\A]A^A_]f.     AVSPL5# M  H=M" Ht) u#" O@)GL5# Mo  Hc" H" HHHH!H" H" HH)H" HH)H9~
H" HH" Hp@H9Hv1Hc @     H=" Hu" " H`" Hq" Hw@H5^" HcHt:@HcH!HH)HH)H9HOH4" H%" HN" W@0@ @ H5" H@    Hc" H" HHH!H" H" HH)H" HH)H9~
H" HH" H" INHAH" IFH=" MvH[A^UAWAVAUATSHHH# H  H=" Ht6 u0J" O@)G=H# 1H  ff.     Hc-" H" HHHH!H" H" HH)H-" HH)H9~
H-" HH" Hp@H9Hv1Hc @     H=" H" " H" H-" Hw@H5" HcHt:@HcH!HH)HH)H9HOH]" HN" Hw" W@0@ @ H^" H@    Hc;" H " HHH!H" H" HH)H" HH)H9~
H" HH" H" HKHAH" HCH=" H[HH6# 1f      H@Ht=@[u   u      H@       H@fffff.     T$8Ac E1IM6M   A9   uAFXttL5# M>1M  EnhL1f.     HHHckHs8Hv*B   'B 1$     ffffff.     $&B CC(ZK(S<HH4(HH!H)t9    H# 9JLsJLHHcH+HD@' H  HHC(   HD  H[H31E1L17    EA    Ac   1E11H[    HuE1    LuB  HD$@HIcHH;K(s81Hv-B 2  'B 1  Ht$@    tAL[ $('B DKDC<D0!)D!)EtD9    GD9G)MtIC@ASHC+    HD)xDC<EMt@Is@LASD H  H!I9Hr1HtH@H9uDLHLaB )+KaB yx   Hq  ICPHtHH    tHQ@H:HyHHHtHQ@H+yH+:HxQffffff.     ALHLaB aB AIIaB ff.     th1;~I{s<VC  +s(C(\f     ALHLaB aB AIIaB ff.     t1;}AraB )DC<1MT$8t%f.     II9Ot	IO   MMuDA
f.     H# 1H    CXtFtAKL   Hc| HKH9Ht Hffffff.     HHIHuHH[HuHQ# ffffff.     H[Ht5CXtuKL   Hc| HH9HHHCH8Hc# HtjfD  HHHHt&P rQPHQ@HHQHPH@H    H@8HuH# ffffff.     HH@H	HHH@8HuL=# M)  fff.     L=q# I@ H[H3  s8HvB   'B 1  f$X'B C8    HC(+++ky'B 1	  1HcK1)C(tHcCHt@ALH|@HHcCH|@1LkH[XH," HH[?H  H[.HK HAPHt$HH    tHqHHHtH+qHpH3HqHcCH|@S<a@  CC8    WCH[    MMH# f.     H$HIH  H$Ah# HYpHtH$@hD$$   L   )0   )   )uCHBLuH0uHu@L   )0   )   )tYC@P" HC8H-" IuHHUV(B 1  IuHU(B 1  "     H"     1  HD$(H        ffffff.     H3LkHc{C0HD$@HSLc DC11Mt)E}AAuAmA   ffff.     E1HD>@HD$8HCHD$(H  BM      AM   DD$H|$Ht$IuIL+bDrCD  LH?IILID    L|$0       tpHt$HrH|$'B 1HT$0EF  EH|$Ht$HT$0:u-AMuMeL+bHT$0WHD$( F  uL+bHC       l$DD$H|$Ht$C@;" HC8H" IuIIV\)B 1  AEuIu)B 1  AFLHt$H|$DD$u&Hr)B 1HE  EH|$Ht$H"     H"     l$f.     Mtk;l$$uEt
{2    EtdAunHT$0AE   H|$IE  EH|$L   A   ff.     HT$0E1A   HT$0A   DD$H|$Ht$HT$0AuvIMPHHt$H|$DD$j  HAHHIHBH+AV  HT$0HD$@8HI)MeL+&HD$(H     A h  AEt0A -  B \  'B 1DD     HT$0@MeA    C@@" HC8H" IuIWL|$0'B 1  Iu  uHD$0HpD  t#LHT$0D  u#HD$(H     A Ht$H|$DD$n|$$  A HT$0IIELH0H@IEA IHD$(H     E1Et$HD$@8HI)L+&MuHD$(H  |c E1HD$@uI   L!tI  LH!H9u$HD$@uTI L!tHLL!L9t=C@" HC8H" )B 1LHT$@  "     H"     H|$8LHT$@Hl$$A Dc4D  tAEuH|$0 uHD$(H     H[(HhSHH[A\A]A^A_]@ LO1M  EAL  LBM  EAL  Dm" Ep  9h  H# E1HA    t>ff.     9phtH@HuE1 HXAA    t1  HG H@ Ht<HuH9uH9   HHHt	LtA   H@ HB HtF1	Lt1   *fD  HuH9uH9tiHHHuH@ HuA   tpAI0uAIuAA0   )   )u?A@0uA@uAH0   )   )   t1EfSH   Ht1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$HT$Ht$="  t	H   [=2	#  t!-	# uXB *B 1}	# vH$H$   H$   H$   $   0   $      H=U" H$   H~H5>" 
   }i    UAVSH   IHt1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$="  tH   [A^]=1#  t!,# uXB *B 1|# H=" p&B 1Hr}H$H$   H$   H$   $   0   $      H=A" H$   L}d@ UAWAVSH   IAHt1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ ="  tH   [A^A_]=/#  t!*# uXB *B 1{# H=" )B 1Hr|t0H=o" s&B 1Y|EtH=U" s&B 1D>|H$H$   H$   H$   $   0   $       H=" H$   L|H5" 
   t{ffffff.     SH   Ht1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$HT$Ht$=#  t!# uXB *B 1Tz# #    .H$H$   H$   H$   $   0   $      H=" H$   H{H5" 
   tzH   [ff.     SH   Ht1)D$0)L$@)T$P)\$`)d$p)$   )$   )$   LL$(LD$ HL$HT$Ht$=#  t!# uXB *B 1Ty# #    .H$H$   H$   H$   $   0   $      H" *B       {H=" H$   HzH5" 
   Yy   zffffff.     H	*B 1Hzf.     @ SHHc  HEBHK0LC8H;   ES,1HCHHHKHKHHHHK H@    [     UAWAVAUATSPIIMnInINH$II)DDL1dHcH9BE11AV0IFLhHcHIN HA~,  IMcIDl  MFIcHHH    HHH OtLV1I   M!   HH}HL8HH)L1I9wLH)HH9vXIM)HLI\OTHHfff.     C	AHHHuLLI9   Ottt+ttALHALHALHr>IHtzf     ).inininHHHILE9}KH$)D)D)IcttIV
THr IV
TIVT
THD9|HHINIcHDIFH[A\A]A^A_]ffff.     AWAVSIII~Ht+fff.     L9sHL9sH_1AV8HHuMtwtM~M~IF I~[A^A_@ {c @ AVSP'Hh# 1B E1     MtA> u H=F# H3HIH{ H[u[B H5y !    H=# HIHsHHtMtA> t   l  H@B *B 1ffff.     HHD@ HDHH(H(HH  uH      H3#f     H= # HIHsHMHtuA> t
uA> tCB 1LFH: # xc   1@LA A@ ^c   1@LA A@ H[A^;ff.     AVSP2" ^"  Q"  H" CB p1B H9HHt9 tCB 1H     HHinclude HrII  I  CI  CI  CI  CI  CI  CH=1" p1B HHHt9 tCB 1HH=" UB 1B bHHt9 tCB 1H   <   end I  I  HI  HH=" 1B HHHt9 tCB 1HH[A^\H[A^@ UAWAVSPH<$-" D=" D5" ="  tS="  $  HL" @h;"   H=" L" L" II@I)   1j     ="  u"	@B @B 1   E1x  @h." =Z"     H=" L/" LP" IA@I)" d   1  :B    11E1Axc   &:B    11E1Axc   8:B    11E1Axc   =" uH=" 5T" 5L" g  H<$H_" HtKH$fffff.     H<$" u;  f       HH" Hu9-1" uD9=0" uA9(" tB:B 1nH5" Hti:B 1V=?"  ua="  u"	@B @B 1   E1;w  @h" ="  t-L" L" IA@I)" B d   1|  H[A^A_]SH="  u$Cr% tH3>B 1H{HsK DC v  K9HLsHL@h[fAWAVSIL5" L95" ;  @ b" uAF
uL5" E>A zc tjLt&IFfD  HH" D;HCA zc u 1L  D;L5]" A u
IL5J" A:u
IL57" A uIFH#" A^I zc     zc Lt*INfff.     HH" HH zc u  H=l" LH" H"  u
HH" Ht}HxPL5"    f.      {c     R>B 1L5[" A6@ {c     :B 1L51" H2" b      {c  u!HHH" HH {c  tH LH  H" L5" &fD  IL5" I9sA {c  t@ IL5" L;5" [A^A_ UAWAVAUATSHHILt$L5s" L95t"   !  H-Z" H-[" DLcMMd   M  IA
LHL%" L=" E1Ad   LL{dLLE  ILHIdK\&d 19{tE HH9uE 
MtLkH" L=" L5" H-" " LuLj" uHq" L=r" 
  HHEM<B 1H`  f.     " MuAF
MuAL%" E<$Ml$I L-" v   1?f.     H      L       sE|$Ml$L-"       A zc u~"ty {c  	  ="    AE  {c  uBH" I9s6ILffffff.     IL-V" I9sAU IM {c  tIL-5" Z	  I"L%#" MD@L-" A$.uF@@	t  @=t&:t!   AM=   f.     ="  t_Am H"  {c    H" H9  HHfD  HHv" H9  0HP {c  tx  H="    Am I LCH" HHH;" vxc    DHm" HHHb" @(:tLs {c  tH;" 
  H"   H=U" It$H" @)@	t uH" ="  B  Ht<HH@ H9N  p@ H9@  @ H92  @ H9$  HO"  {c  _  H@" H9O  HHf     HH" H9-  0HP {c  t  H=0"  &  I    LCH0" HHH;-" vxc    H" HHH" @(:tLs {c  tH;"   Hy"   @  @	  .  H="    Ht@ H9H=  ILCH" HHH;}" vxc    4H]" HHHR" @(:tLs {c  tH;"   H"   EIchiHDZ)  A~IM DJ  IUfk
H" |1H
HHHRDKu  @ t5=t::u1Lz  HA"  :H7" \  HxQ  AM=uJ.uA|$   LA  @tH H" Q=   HH"    u" u$H=R" L
HL-" t	Am    Am H"  {c  u+Hff.     HHv" HA {c  tH  L  HQ" HH" m  HtVHxP\  HQH'" =H" 	t u
HH" H+    Hx    A] AE  " 
  H=Z" LH   A] H$    LHFH" :u
w    L-" Etj[B DdHtX>B    Lcz  " uaI>B LfIM  IGH" E1R>B 1DDH" 0@ {c    :B 1gH" H" Yj>B 1LHA] H" 0@ {c    :B 1H" H"    HHn" H9   {c  tt  AE=uIL-?" IEH2" AE =L-&" AE 	t u
IL-
" H|$  u=B 1zWD$,)D$ [  S     HD$ @H" ;Ah1     HH" H9   {c  t  L=" M)IcH  ILLHcLt$f.     LHHF" HHl$>B HdIMtLH)B,;HcLF  IIcLHt$HcpcMAtID$H" uIHD$ HB tHpHD$(HB tHPH>H5<B 1>B 1LD$ DL$0H$             1  HK"  uHPH8" HH {c  uF:B 1H" H" 
HH" H9s {c  tf.     HH" L5" L;5" HH[A\A]A^A_] PH|$5  H(  H"  uHqH5" QH	w(Hfffff.     HY" H
rHlH5"  uHPH"" HH {c  uK:B 1H" H" ffffff.     HH" H9s {c  tHH" ="  t>Hs" @h;" u,H=)" L" L" II@I)   1Xv  XfUAVSIHb"  u
HHP" " u
"u<u2'u*HH"" m  H" HQH9" 1~1=B 1H" 0@ {c    :B 1[H" H"         HAH" @)  H" HAH9" xtc    Hf" tc    HJ" HAH?"  H-" HcB" H'" HHH!H" H5 " HH)H-" HH)H9~
H-" HH" ,D  HH" H9s {c  tHH" 1A[A^]PH"  uHPH" HH {c  u>:B 1Hk" Hl" fHHV" H9s {c  tHH;" Xf     USPH&" @0 @HX"HE@HAw  H" @)H"  u
HH" H@,u0HAH" q uHAH" @q@

u uHAH" QH {c  uE:B 1Hb" Hc" f     HHF" H9s {c  tHH+" H[]@ H(H|$tut$x<B 1HD$    1H"  uHPH" HH {c  u?:B 13H" H"  HH" H9s {c  tHHk" H(fD  H(H|$Rtu
HD$H(x<B 1HD$    1H( UAWAVSH(H" "uHAH-" D} H"  uHPH" HH,   HH" E  H|$AHt  @@ H@@xc EHHD} Hz"  {c     Hk" H9   HH@ HHF" H9sy0HP {c  tgE  :B 1HD} H" 0@ {c  u9:B 1H" H" 
HH" H9s {c  tHH" H([A^A_] PH" 0@ {c  uC:B 1H" H" f.     HHf" H9s {c  tHHK" Xf     H9"  {c  uCH." H9s7Hf.      {c  HtH" H9rHHH" ffffff.     USHHH|$tu\$x<B 15HD$    1H" HHH" ,uH|$(vt u@l$8 H_" x<B 1HD$8    1~uH$    1      1E1A@(H"  uHPH" HH {c     :B 1mH" H" W:B 1QH" 0@ {c  ub:B 1,H" H" 3fff.     HHv" H9s) {c  tHHY" H9s {c  tHH>" HH[]    H)"  {c  u<H" H9s0HHff.     HH" H9s0HP {c  tHH" fD  USH(HkH|$vB    ;B 1*f  $0*B @kC HD$HCHC@xc HCP    3  @kHD$HKHHHL$HKH@@HC@  HD$H   HL$H   HP@H;Q@uux toy tiH@H+AHD$   HD$HCH   N;B 1h8;B H|$ ?;B ;B 1H@kC HC    HC@xc l      D$L$!HxP t'      HL$HIPIH HCPo;B 1@kC HD$HCHC@xc H([]     UAWAVAUATSHHIW)D$0)D$ E1IwJ    IIH"  uHPH" HH {c  tHHH" &  MILt$    HD$0H~uHHHHwdHtHH        t c    HrXHH)Hc     H:H	HrH	HHH9|H?;B 8;B HO;B 11HJ  D  Lu!H|$     DmH!     DXHw^$`*B H=" G@)HL$ LD$(LL$0D$    D$    $    DkL$<PDPD   @ B   ;B 1   HD$(Hp@HHcxc Hwc B 1DH;B 1}HD$0    @ Ht$0HL!HL!tL9t;B 1HID  HHD3  H" HHH" ,H~"  uHo" H {c  uI:B 1HF" HG" ffff.     HH&" H9s {c  tHH" HH[A\A]A^A_]fff.     AWAVAUATSH IH"  uHKH" CH {c    L$$L|$     uHKH" CH0u Lk%TH BDhtHH_" DLL  HHt9 uK|$HcT$HLRH$"  u
HH" HXH"  ,[n;B 1HzH" 3@ {c  u>:B 1UH" H" D  HH" H9s {c  tHH" HCH" K uHp" H {c  uJ:B 1HG" HH" fffff.     HH&" H9s {c  tHH" H [A\A]A^A_ffff.     SH"  uHPH" HH {c  tHH"   H{  ff.      uHPH" HH"   HHq" ffffff.     HHH"   xxHy" Hj" )w!H=" U1nHG" HH" HPH9vHc    (H!" ffffff.     <B 1dgfH" H" )w!H=
" 1H" H" HPH9vHc    H" HHH"   Hd"  u
HHR" HAHG" 	,  fD   uHPH" HH"   HH" ffffff.     HHH" .  xtH	" H" )w!H=" 1H" H" HPH9vHc    H" ffffff.     <B 1H]"  u
HHK" HAH@" 	,HHH)" P uH" H {c  uC:B 1H" H"     HH" H9s {c  tHH" [f     AWAVSL5" IFH" E>A\t*A'uRA"   A'   DX  IFHZ" E~A!AA
#  A
   D*  A"   "   q"     A[fAG
   1N1fA74IcH0V   ftALITH" E|H|IDHH" AHAaA\t<rAeAbufA   DpAm"AfuOA   DYA"tA'u8DHAntAruA   D1A
   D&AtuA	   D=B 1A?   D[A^A_    USPHu1=B 1mWCbu]HB HtHpHCB HtHPHtHt<B 1#HHEM<B 1HWC1H[]fD  AVSPI1Ht0A~fD  8 t	HA    1<B 1HH[A^fSH=G"  t<B 1S  H"  u)HH" f     HHH%" H" HAH" H
" HPH9"  zc ttxc    H" txc    H" HHH"   HD" H5" Hc" H" HHH!H" Hh" HH)Hs" HH)H9~
HY" HHG" H5(" Hu<B 1gH5" .u'H=I" H	HtH5" =B 11H"  {c  u=H" H9s1HHfff.     HHf" H9s0HP {c  tHHG" [D  PH=w"     H" HHH;" vxc    >Hg" HHH\"   H=" H5+" H<" HcQ" H6" HHH!H&" L" IM)L" LL)I9~
L " LH" Ht8 tH5" p=B 1H"     X:=B 1HT" 0@ {c  u9:B 1H/" H0" 
HH" H9s {c  tHH" Xffffff.     AVSPHf     IAFH/" HHH;," vxc    H" HHH" :tI~ {c  tL;5" vL5}" H[A^D  1t:f.     HHH@HH	tufffff.     HHu@ t)AAHH@AHu6H   3HHH   HD@0H@HunH    Ht   @0H+fff.     A	A   DHHAt%AAH@AHuuDHH)     H(" |?B    1f" H]" HH@M" c H7" Hc %"    =&"  tdH"  {c     H" H9   HHffffff.     HH" H9   0HP {c  t   H|$~~tuD$x<B 1HD$    1" |" H="  uHPH*" HH {c  u<:B 1H " H" 
HH" H9s {c  tHH" H(ffff.     H(" r?B 13"    " tHH@<c     1u#" uH|$]}t|ulD$}|"    H="  {c     H." H9   HH    HH" H9   0HP {c  t   x<B 1lHD$    1" " H"  uHPH" HH {c  u<:B 1Hy" Hz" 
HHf" H9s {c  tHHK" H(fD  Pi" rb?B 1L"    R" tHH@<c     1=%"  " H"  uHPH" HH {c  uB:B 16H" H" fD  HH" H9s {c  tHHk" Xf     P="  t
" u*?B 1v" n" HH@c W" Hc H@" H	"  uHPH" HH {c  u?:B 1cH" H"  HH" H9s {c  tHH" Xf     UAWAVAUATSHXI%" |>B    1	" " E1E1ffffff.     H9" ( uHHH&" @hH@1 {c  t(J       HHHU" @(H" @(@ u
HH" HHH" @(t@))2fD   A(t!A {c  ugA ta1A,tYf     @ {c  t>B 1H" HHH;" Oxc    pH" 4@ H" HHH;" vxc    =Hf" HHH["   HI" Hc^" HC" HHH!H3" H5" HH)H'" HH)H9~
H" HH" JAA {c  t	H" )A u#H|" @ ,uHHg"     II
@ {c  uf>B 1H3" 0@ {c  u9:B 1H" H" 
HH" H9s {c  tHH" H9" HHH;6" vxc    H" HHH"  
A0fHHH" IA8  Io$   HE H$uIL   fffff.     	wkIHHt@+@tH    Hy" HHH;v" vxc    -HV" HHHK" @(@+H@uHnuPH)" HHH;&" vxc    H" IHHH" D0ffffff.     H" HHH;" xc    H" H" HHH;" vxc    ZH" HHHx"  
Hn" HHH;k" vxc    "HK" HHH@"   H-" D5g" L=" H!" HAH" H" Hc" HHH!H" H" HH)H" HH)H9~
H" HH" " H{" u\H;" vH;" sH" H" xc H	   H4Ht1H;5P" vH;5_" sH5F" H5G" D  xc vHCH-" AD5R" L=" Y" HX[A\A]A^A_]fffff.     SHH|$HH   Hn"  uHPH[" HH {c  uD:B 1H1" H2"      HH" H9s {c  tHH" H=3"  tBH" @h;" u0H=Y" L" L" II@I)   1H[P  H[fPH"  uHPH" HH {c  u>:B 1H[" H\" fHHF" H9s {c  tHH+" Xf     1)>  f        >  fD  USHXH|$ru1=B 1hWD$)D$hucHD$B HtHpHD$B HtHPHtHt<B 1HHEM<B 1H WD$)D$1HZ" ,u9HHH" H|$8>rtu@l$Hx<B 1HD$H    1t&uHD$@H" ;Aht>B 1}LD$DL$ H$             1@(H"  uHPH" HH {c  uA:B 1H~" H" D  HHf" H9s {c  tHHK" HX[]@ USPH6" @0 @HX"HE{@HQQ  H
" @)H "  u
HH" H@,u0HAH" q uHAH" @q@

u uHAH" QH {c  uE:B 1	Hr" Hs" f     HHV" H9s {c  tHH;" H[]@ 