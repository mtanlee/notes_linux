ange
counterparts.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
The \s-1POSIX\s0 class matches the same as its Full-range counterpart.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rules are in effect ..." 4
.IX Item "if locale rules are in effect ..."
.PD
The \s-1POSIX\s0 class matches according to the locale, except that
\&\f(CW\*(C`word\*(C'\fR uses the platform's native underscore character, no matter what
the locale is.
.IP "if Unicode rules are in effect ..." 4
.IX Item "if Unicode rules are in effect ..."
The \s-1POSIX\s0 class matches the same as the Full-range counterpart.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
The \s-1POSIX\s0 class matches the same as the \s-1ASCII\s0 range counterpart.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rules apply are determined as described in
\&\*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
It is proposed to change this behavior in a future release of Perl so that
whether or not Unicode rules are in effect would not change the
behavior:  Outside of locale, the \s-1POSIX\s0 classes
would behave like their ASCII-range counterparts.  If you wish to
comment on this proposal, send email to \f(CW\*(C`perl5\-porters@perl.org\*(C'\fR.
.PP
Negation of \s-1POSIX\s0 character classes
.IX Xref "character class, negation"
.IX Subsection "Negation of POSIX character classes"
.PP
A Perl extension to the \s-1POSIX\s0 character class is the ability to
negate it. This is done by prefixing the class name with a caret (\f(CW\*(C`^\*(C'\fR).
Some examples:
.PP
.Vb 7
\&     POSIX         ASCII\-range     Full\-range  backslash
\&                    Unicode         Unicode    sequence
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& [[:^digit:]]   \eP{PosixDigit}  \eP{XPosixDigit}   \eD
\& [[:^space:]]   \eP{PosixSpace}  \eP{XPosixSpace}
\&                \eP{PerlSpace}   \eP{XPerlSpace}    \eS
\& [[:^word:]]    \eP{PerlWord}    \eP{XPosixWord}    \eW
.Ve
.PP
The backslash sequence can mean either \s-1ASCII\-\s0 or Full-range Unicode,
depending on various factors as described in \*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
[= =] and [. .]
.IX Subsection "[= =] and [. .]"
.PP
Perl recognizes the \s-1POSIX\s0 character classes \f(CW\*(C`[=class=]\*(C'\fR and
\&\f(CW\*(C`[.class.]\*(C'\fR, but does not (yet?) support them.  Any attempt to use
either construct raises an exception.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 12
\& /[[:digit:]]/            # Matches a character that is a digit.
\& /[01[:lower:]]/          # Matches a character that is either a
\&                          # lowercase letter, or \*(Aq0\*(Aq or \*(Aq1\*(Aq.
\& /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything
\&                          # except the letters \*(Aqa\*(Aq to \*(Aqf\*(Aq and \*(AqA\*(Aq to
\&                          # \*(AqF\*(Aq.  This is because the main character
\&                          # class is composed of two POSIX character
\&                          # classes that are ORed together, one that
\&                          # matches any digit, and the other that
\&                          # matches anything that isn\*(Aqt a hex digit.
\&                          # The OR adds the digits, leaving only the
\&                          # letters \*(Aqa\*(Aq to \*(Aqf\*(Aq and \*(AqA\*(Aq to \*(AqF\*(Aq excluded.
.Ve
.PP
\fIExtended Bracketed Character Classes\fR
.IX Xref "character class set operations"
.IX Subsection "Extended Bracketed Character Classes"
.PP
This is a fancy bracketed character class that can be used for more
readable and less error-prone classes, and to perform set operations,
such as intersection. An example is
.PP
.Vb 1
\& /(?[ \ep{Thai} & \ep{Digit} ])/
.Ve
.PP
This will match all the digit characters that are in the Thai script.
.PP
This is an experimental feature available starting in 5.18, and is
subject to change as we gain field experience with it.  Any attempt to
use it will raise a warning, unless disabled via
.PP
.Vb 1
\& no warnings "experimental::regex_sets";
.Ve
.PP
Comments on this feature are welcome; send email to
\&\f(CW\*(C`perl5\-porters@perl.org\*(C'\fR.
.PP
We can extend the example above:
.PP
.Vb 1
\& /(?[ ( \ep{Thai} + \ep{Lao} ) & \ep{Digit} ])/
.Ve
.PP
This matches digits that are in either the Thai or Laotian scripts.
.PP
Notice the white space in these examples.  This construct always has
the \f(CW\*(C`/x\*(C'\fR modifier turned on.
.PP
The available binary operators are:
.PP
.Vb 10
\& &    intersection
\& +    union
\& |    another name for \*(Aq+\*(Aq, hence means union
\& \-    subtraction (the result matches the set consisting of those
\&      code points matched by the first operand, excluding any that
\&      are also matched by the second operand)
\& ^    symmetric difference (the union minus the intersection).  This
\&      is like an exclusive or, in that the result is the set of code
\&      points that are matched by either, but not both, of the
\&      operands.
.Ve
.PP
There is one unary operator:
.PP
.Vb 1
\& !    complement
.Ve
.PP
All the binary operators left associate, and are of equal precedence.
The unary operator right associates, and has higher precedence.  Use
parentheses to override the default associations.  Some feedback we've
received indicates a desire for intersection to have higher precedence
than union.  This is something that feedback from the field may cause us
to change in future releases; you may want to parenthesize copiously to
avoid such changes affecting your code, until this feature is no longer
considered experimental.
.PP
The main restriction is that everything is a metacharacter.  Thus,
you cannot refer to single characters by doing something like this:
.PP
.Vb 1
\& /(?[ a + b ])/ # Syntax error!
.Ve
.PP
The easiest way to specify an individual typable character is to enclose
it in brackets:
.PP
.Vb 1
\& /(?[ [a] + [b] ])/
.Ve
.PP
(This is the same thing as \f(CW\*(C`[ab]\*(C'\fR.)  You could also have said the
equivalent:
.PP
.Vb 1
\& /(?[[ a b ]])/
.Ve
.PP
(You can, of course, specify single characters by using, \f(CW\*(C`\ex{ }\*(C'\fR,
\&\f(CW\*(C`\eN{ }\*(C'\fR, etc.)
.PP
This last example shows the use of this construct to specify an ordinary
bracketed character class without additional set operations.  Note the
white space within it; \f(CW\*(C`/x\*(C'\fR is turned on even within bracketed
character classes, except you can't have comments inside them.  Hence,
.PP
.Vb 1
\& (?[ [#] ])
.Ve
.PP
matches the literal character \*(L"#\*(R".  To specify a literal white space character,
you can escape it with a backslash, like:
.PP
.Vb 1
\& /(?[ [ a e i o u \e  ] ])/
.Ve
.PP
This matches the English vowels plus the \s-1SPACE\s0 character.
All the other escapes accepted by normal bracketed character classes are
accepted here as well; but unrecognized escapes that generate warnings
in normal classes are fatal errors here.
.PP
All warnings from these class elements are fatal, as well as some
practices that don't currently warn.  For example you cannot say
.PP
.Vb 1
\& /(?[ [ \exF ] ])/     # Syntax error!
.Ve
.PP
You have to have two hex digits after a braceless \f(CW\*(C`\ex\*(C'\fR (use a leading
zero to make two).  These restrictions are to lower the incidence of
typos causing the class to not match what you thought it would.
.PP
The final difference between regular bracketed character classes and
these, is that it is not possible to get these to match a
multi-character fold.  Thus,
.PP
.Vb 1
\& /(?[ [\exDF] ])/iu
.Ve
.PP
does not match the string \f(CW\*(C`ss\*(C'\fR.
.PP
You don't have to enclose \s-1POSIX\s0 class names inside double brackets,
hence both of the following work:
.PP
.Vb 2
\& /(?[ [:word:] \- [:lower:] ])/
\& /(?[ [[:word:]] \- [[:lower:]] ])/
.Ve
.PP
Any contained \s-1POSIX\s0 character classes, including things like \f(CW\*(C`\ew\*(C'\fR and \f(CW\*(C`\eD\*(C'\fR
respect the \f(CW\*(C`/a\*(C'\fR (and \f(CW\*(C`/aa\*(C'\fR) modifiers.
.PP
\&\f(CW\*(C`(?[ ])\*(C'\fR is a regex-compile-time construct.  Any attempt to use
something which isn't knowable at the time the containing regular
expression is compiled is a fatal error.  In practice, this means
just three limitiations:
.IP "1." 4
This construct cannot be used within the scope of
\&\f(CW\*(C`use locale\*(C'\fR (or the \f(CW\*(C`/l\*(C'\fR regex modifier).
.IP "2." 4
Any
user-defined property
used must be already defined by the time the regular expression is
compiled (but note that this construct can be used instead of such
properties).
.IP "3." 4
A regular expression that otherwise would compile
using \f(CW\*(C`/d\*(C'\fR rules, and which uses this construct will instead
use \f(CW\*(C`/u\*(C'\fR.  Thus this construct tells Perl that you don't want
\&\f(CW\*(C`/d\*(C'\fR rules for the entire regular expression containing it.
.PP
The \f(CW\*(C`/x\*(C'\fR processing within this class is an extended form.
Besides the characters that are considered white space in normal \f(CW\*(C`/x\*(C'\fR
processing, there are 5 others, recommended by the Unicode standard:
.PP
.Vb 5
\& U+0085 NEXT LINE
\& U+200E LEFT\-TO\-RIGHT MARK
\& U+200F RIGHT\-TO\-LEFT MARK
\& U+2028 LINE SEPARATOR
\& U+2029 PARAGRAPH SEPARATOR
.Ve
.PP
Note that skipping white space applies only to the interior of this
construct.  There must not be any space between any of the characters
that form the initial \f(CW\*(C`(?[\*(C'\fR.  Nor may there be space between the
closing \f(CW\*(C`])\*(C'\fR characters.
.PP
Just as in all regular expressions, the pattern can can be built up by
including variables that are interpolated at regex compilation time.
Care must be taken to ensure that you are getting what you expect.  For
example:
.PP
.Vb 3
\& my $thai_or_lao = \*(Aq\ep{Thai} + \ep{Lao}\*(Aq;
\& ...
\& qr/(?[ \ep{Digit} & $thai_or_lao ])/;
.Ve
.PP
compiles to
.PP
.Vb 1
\& qr/(?[ \ep{Digit} & \ep{Thai} + \ep{Lao} ])/;
.Ve
.PP
But this does not have the effect that someone reading the code would
likely expect, as the intersection applies just to \f(CW\*(C`\ep{Thai}\*(C'\fR,
excluding the Laotian.  Pitfalls like this can be avoided by
parenthesizing the component pieces:
.PP
.Vb 1
\& my $thai_or_lao = \*(Aq( \ep{Thai} + \ep{Lao} )\*(Aq;
.Ve
.PP
But any modifiers will still apply to all the components:
.PP
.Vb 2
\& my $lower = \*(Aq\ep{Lower} + \ep{Digit}\*(Aq;
\& qr/(?[ \ep{Greek} & $lower ])/i;
.Ve
.PP
matches upper case things.  You can avoid surprises by making the
components into instances of this construct by compiling them:
.PP
.Vb 2
\& my $thai_or_lao = qr/(?[ \ep{Thai} + \ep{Lao} ])/;
\& my $lower = qr/(?[ \ep{Lower} + \ep{Digit} ])/;
.Ve
.PP
When these are embedded in another pattern, what they match does not
change, regardless of parenthesization or what modifiers are in effect
in that outer pattern.
.PP
Due to the way that Perl parses things, your parentheses and brackets
may need to be balanced, even including comments.  If you run into any
examples, please send them to \f(CW\*(C`perlbug@perl.org\*(C'\fR, so that we can have a
concrete example for this man page.
.PP
We may change it so that things that remain legal uses in normal bracketed
character classes might become illegal within this experimental
construct.  One proposal, for example, is to forbid adjacent uses of the
same character, as in \f(CW\*(C`(?[ [aa] ])\*(C'\fR.  The motivation for such a change
is that this usage is likely a typo, as the second \*(L"a\*(R" adds nothing.
                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlrecharclass5.16.1                        0100644 0001750 0001750 00000132452 12566207423 024435  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRECHARCLASS 1"
.TH PERLRECHARCLASS 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrecharclass \- Perl Regular Expression Character Classes
.IX Xref "character class"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The top level documentation about Perl regular expressions
is found in perlre.
.PP
This manual page discusses the syntax and use of character
classes in Perl regular expressions.
.PP
A character class is a way of denoting a set of characters
in such a way that one character of the set is matched.
It's important to remember that: matching a character class
consumes exactly one character in the source string. (The source
string is the string the regular expression is matched against.)
.PP
There are three types of character classes in Perl regular
expressions: the dot, backslash sequences, and the form enclosed in square
brackets.  Keep in mind, though, that often the term \*(L"character class\*(R" is used
to mean just the bracketed form.  Certainly, most Perl documentation does that.
.SS "The dot"
.IX Subsection "The dot"
The dot (or period), \f(CW\*(C`.\*(C'\fR is probably the most used, and certainly
the most well-known character class. By default, a dot matches any
character, except for the newline. That default can be changed to
add matching the newline by using the \fIsingle line\fR modifier: either
for the entire regular expression with the \f(CW\*(C`/s\*(C'\fR modifier, or
locally with \f(CW\*(C`(?s)\*(C'\fR.  (The experimental \f(CW\*(C`\eN\*(C'\fR backslash sequence, described
below, matches any character except newline without regard to the
\&\fIsingle line\fR modifier.)
.PP
Here are some examples:
.PP
.Vb 7
\& "a"  =~  /./       # Match
\& "."  =~  /./       # Match
\& ""   =~  /./       # No match (dot has to match a character)
\& "\en" =~  /./       # No match (dot does not match a newline)
\& "\en" =~  /./s      # Match (global \*(Aqsingle line\*(Aq modifier)
\& "\en" =~  /(?s:.)/  # Match (local \*(Aqsingle line\*(Aq modifier)
\& "ab" =~  /^.$/     # No match (dot matches one character)
.Ve
.SS "Backslash sequences"
.IX Xref "\\w \\W \\s \\S \\d \\D \\p \\P \\N \\v \\V \\h \\H word whitespace"
.IX Subsection "Backslash sequences"
A backslash sequence is a sequence of characters, the first one of which is a
backslash.  Perl ascribes special meaning to many such sequences, and some of
these are character classes.  That is, they match a single character each,
provided that the character belongs to the specific set of characters defined
by the sequence.
.PP
Here's a list of the backslash sequences that are character classes.  They
are discussed in more detail below.  (For the backslash sequences that aren't
character classes, see perlrebackslash.)
.PP
.Vb 10
\& \ed             Match a decimal digit character.
\& \eD             Match a non\-decimal\-digit character.
\& \ew             Match a "word" character.
\& \eW             Match a non\-"word" character.
\& \es             Match a whitespace character.
\& \eS             Match a non\-whitespace character.
\& \eh             Match a horizontal whitespace character.
\& \eH             Match a character that isn\*(Aqt horizontal whitespace.
\& \ev             Match a vertical whitespace character.
\& \eV             Match a character that isn\*(Aqt vertical whitespace.
\& \eN             Match a character that isn\*(Aqt a newline.  Experimental.
\& \epP, \ep{Prop}  Match a character that has the given Unicode property.
\& \ePP, \eP{Prop}  Match a character that doesn\*(Aqt have the Unicode property
.Ve
.PP
\fI\eN\fR
.IX Subsection "N"
.PP
\&\f(CW\*(C`\eN\*(C'\fR is new in 5.12, and is experimental.  It, like the dot, matches any
character that is not a newline. The difference is that \f(CW\*(C`\eN\*(C'\fR is not influenced
by the \fIsingle line\fR regular expression modifier (see \*(L"The dot\*(R" above).  Note
that the form \f(CW\*(C`\eN{...}\*(C'\fR may mean something completely different.  When the
\&\f(CW\*(C`{...}\*(C'\fR is a quantifier, it means to match a non-newline
character that many times.  For example, \f(CW\*(C`\eN{3}\*(C'\fR means to match 3
non-newlines; \f(CW\*(C`\eN{5,}\*(C'\fR means to match 5 or more non-newlines.  But if \f(CW\*(C`{...}\*(C'\fR
is not a legal quantifier, it is presumed to be a named character.  See
charnames for those.  For example, none of \f(CW\*(C`\eN{COLON}\*(C'\fR, \f(CW\*(C`\eN{4F}\*(C'\fR, and
\&\f(CW\*(C`\eN{F4}\*(C'\fR contain legal quantifiers, so Perl will try to find characters whose
names are respectively \f(CW\*(C`COLON\*(C'\fR, \f(CW\*(C`4F\*(C'\fR, and \f(CW\*(C`F4\*(C'\fR.
.PP
\fIDigits\fR
.IX Subsection "Digits"
.PP
\&\f(CW\*(C`\ed\*(C'\fR matches a single character considered to be a decimal \fIdigit\fR.
If the \f(CW\*(C`/a\*(C'\fR regular expression modifier is in effect, it matches [0\-9].
Otherwise, it
matches anything that is matched by \f(CW\*(C`\ep{Digit}\*(C'\fR, which includes [0\-9].
(An unlikely possible exception is that under locale matching rules, the
current locale might not have [0\-9] matched by \f(CW\*(C`\ed\*(C'\fR, and/or might match
other characters whose code point is less than 256.  Such a locale
definition would be in violation of the C language standard, but Perl
doesn't currently assume anything in regard to this.)
.PP
What this means is that unless the \f(CW\*(C`/a\*(C'\fR modifier is in effect \f(CW\*(C`\ed\*(C'\fR not
only matches the digits '0' \- '9', but also Arabic, Devanagari, and
digits from other languages.  This may cause some confusion, and some
security issues.
.PP
Some digits that \f(CW\*(C`\ed\*(C'\fR matches look like some of the [0\-9] ones, but
have different values.  For example, \s-1BENGALI\s0 \s-1DIGIT\s0 \s-1FOUR\s0 (U+09EA) looks
very much like an \s-1ASCII\s0 \s-1DIGIT\s0 \s-1EIGHT\s0 (U+0038).  An application that
is expecting only the \s-1ASCII\s0 digits might be misled, or if the match is
\&\f(CW\*(C`\ed+\*(C'\fR, the matched string might contain a mixture of digits from
different writing systems that look like they signify a number different
than they actually do.  \*(L"\fInum()\fR\*(R" in Unicode::UCD can
be used to safely
calculate the value, returning \f(CW\*(C`undef\*(C'\fR if the input string contains
such a mixture.
.PP
What \f(CW\*(C`\ep{Digit}\*(C'\fR means (and hence \f(CW\*(C`\ed\*(C'\fR except under the \f(CW\*(C`/a\*(C'\fR
modifier) is \f(CW\*(C`\ep{General_Category=Decimal_Number}\*(C'\fR, or synonymously,
\&\f(CW\*(C`\ep{General_Category=Digit}\*(C'\fR.  Starting with Unicode version 4.1, this
is the same set of characters matched by \f(CW\*(C`\ep{Numeric_Type=Decimal}\*(C'\fR.
But Unicode also has a different property with a similar name,
\&\f(CW\*(C`\ep{Numeric_Type=Digit}\*(C'\fR, which matches a completely different set of
characters.  These characters are things such as \f(CW\*(C`CIRCLED DIGIT ONE\*(C'\fR
or subscripts, or are from writing systems that lack all ten digits.
.PP
The design intent is for \f(CW\*(C`\ed\*(C'\fR to exactly match the set of characters
that can safely be used with \*(L"normal\*(R" big-endian positional decimal
syntax, where, for example 123 means one 'hundred', plus two 'tens',
plus three 'ones'.  This positional notation does not necessarily apply
to characters that match the other type of \*(L"digit\*(R",
\&\f(CW\*(C`\ep{Numeric_Type=Digit}\*(C'\fR, and so \f(CW\*(C`\ed\*(C'\fR doesn't match them.
.PP
The Tamil digits (U+0BE6 \- U+0BEF) can also legally be
used in old-style Tamil numbers in which they would appear no more than
one in a row, separated by characters that mean \*(L"times 10\*(R", \*(L"times 100\*(R",
etc.  (See <http://www.unicode.org/notes/tn21>.)
.PP
Any character not matched by \f(CW\*(C`\ed\*(C'\fR is matched by \f(CW\*(C`\eD\*(C'\fR.
.PP
\fIWord characters\fR
.IX Subsection "Word characters"
.PP
A \f(CW\*(C`\ew\*(C'\fR matches a single alphanumeric character (an alphabetic character, or a
decimal digit) or a connecting punctuation character, such as an
underscore (\*(L"_\*(R").  It does not match a whole word.  To match a whole
word, use \f(CW\*(C`\ew+\*(C'\fR.  This isn't the same thing as matching an English word, but
in the \s-1ASCII\s0 range it is the same as a string of Perl-identifier
characters.
.ie n .IP "If the ""/a"" modifier is in effect ..." 4
.el .IP "If the \f(CW/a\fR modifier is in effect ..." 4
.IX Item "If the /a modifier is in effect ..."
\&\f(CW\*(C`\ew\*(C'\fR matches the 63 characters [a\-zA\-Z0\-9_].
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
\&\f(CW\*(C`\ew\*(C'\fR matches the same as \f(CW\*(C`\ep{Word}\*(C'\fR matches in this range.  That is,
it matches Thai letters, Greek letters, etc.  This includes connector
punctuation (like the underscore) which connect two words together, or
diacritics, such as a \f(CW\*(C`COMBINING TILDE\*(C'\fR and the modifier letters, which
are generally used to add auxiliary markings to letters.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rules are in effect ..." 4
.IX Item "if locale rules are in effect ..."
.PD
\&\f(CW\*(C`\ew\*(C'\fR matches the platform's native underscore character plus whatever
the locale considers to be alphanumeric.
.IP "if Unicode rules are in effect or if on an \s-1EBCDIC\s0 platform ..." 4
.IX Item "if Unicode rules are in effect or if on an EBCDIC platform ..."
\&\f(CW\*(C`\ew\*(C'\fR matches exactly what \f(CW\*(C`\ep{Word}\*(C'\fR matches.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
\&\f(CW\*(C`\ew\*(C'\fR matches [a\-zA\-Z0\-9_].
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rules apply are determined as described in \*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
There are a number of security issues with the full Unicode list of word
characters.  See <http://unicode.org/reports/tr36>.
.PP
Also, for a somewhat finer-grained set of characters that are in programming
language identifiers beyond the \s-1ASCII\s0 range, you may wish to instead use the
more customized \*(L"Unicode Properties\*(R", \f(CW\*(C`\ep{ID_Start}\*(C'\fR,
\&\f(CW\*(C`\ep{ID_Continue}\*(C'\fR, \f(CW\*(C`\ep{XID_Start}\*(C'\fR, and \f(CW\*(C`\ep{XID_Continue}\*(C'\fR.  See
<http://unicode.org/reports/tr31>.
.PP
Any character not matched by \f(CW\*(C`\ew\*(C'\fR is matched by \f(CW\*(C`\eW\*(C'\fR.
.PP
\fIWhitespace\fR
.IX Subsection "Whitespace"
.PP
\&\f(CW\*(C`\es\*(C'\fR matches any single character considered whitespace.
.ie n .IP "If the ""/a"" modifier is in effect ..." 4
.el .IP "If the \f(CW/a\fR modifier is in effect ..." 4
.IX Item "If the /a modifier is in effect ..."
\&\f(CW\*(C`\es\*(C'\fR matches the 5 characters [\et\en\ef\er ]; that is, the horizontal tab,
the newline, the form feed, the carriage return, and the space.  (Note
that it doesn't match the vertical tab, \f(CW\*(C`\ecK\*(C'\fR on \s-1ASCII\s0 platforms.)
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
\&\f(CW\*(C`\es\*(C'\fR matches exactly the code points above 255 shown with an \*(L"s\*(R" column
in the table below.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rules are in effect ..." 4
.IX Item "if locale rules are in effect ..."
.PD
\&\f(CW\*(C`\es\*(C'\fR matches whatever the locale considers to be whitespace.  Note that
this is likely to include the vertical space, unlike non-locale \f(CW\*(C`\es\*(C'\fR
matching.
.IP "if Unicode rules are in effect or if on an \s-1EBCDIC\s0 platform ..." 4
.IX Item "if Unicode rules are in effect or if on an EBCDIC platform ..."
\&\f(CW\*(C`\es\*(C'\fR matches exactly the characters shown with an \*(L"s\*(R" column in the
table below.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
\&\f(CW\*(C`\es\*(C'\fR matches [\et\en\ef\er ].
Note that this list doesn't include the non-breaking space.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rules apply are determined as described in \*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
Any character not matched by \f(CW\*(C`\es\*(C'\fR is matched by \f(CW\*(C`\eS\*(C'\fR.
.PP
\&\f(CW\*(C`\eh\*(C'\fR matches any character considered horizontal whitespace;
this includes the platform's space and tab characters and several others
listed in the table below.  \f(CW\*(C`\eH\*(C'\fR matches any character
not considered horizontal whitespace.  They use the platform's native
character set, and do not consider any locale that may otherwise be in
use.
.PP
\&\f(CW\*(C`\ev\*(C'\fR matches any character considered vertical whitespace;
this includes the platform's carriage return and line feed characters (newline)
plus several other characters, all listed in the table below.
\&\f(CW\*(C`\eV\*(C'\fR matches any character not considered vertical whitespace.
They use the platform's native character set, and do not consider any
locale that may otherwise be in use.
.PP
\&\f(CW\*(C`\eR\*(C'\fR matches anything that can be considered a newline under Unicode
rules. It's not a character class, as it can match a multi-character
sequence. Therefore, it cannot be used inside a bracketed character
class; use \f(CW\*(C`\ev\*(C'\fR instead (vertical whitespace).  It uses the platform's
native character set, and does not consider any locale that may
otherwise be in use.
Details are discussed in perlrebackslash.
.PP
Note that unlike \f(CW\*(C`\es\*(C'\fR (and \f(CW\*(C`\ed\*(C'\fR and \f(CW\*(C`\ew\*(C'\fR), \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR always match
the same characters, without regard to other factors, such as the active
locale or whether the source string is in \s-1UTF\-8\s0 format.
.PP
One might think that \f(CW\*(C`\es\*(C'\fR is equivalent to \f(CW\*(C`[\eh\ev]\*(C'\fR. This is not true.
The difference is that the vertical tab (\f(CW"\ex0b"\fR) is not matched by
\&\f(CW\*(C`\es\*(C'\fR; it is however considered vertical whitespace.
.PP
The following table is a complete listing of characters matched by
\&\f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR as of Unicode 6.0.
.PP
The first column gives the Unicode code point of the character (in hex format),
the second column gives the (Unicode) name. The third column indicates
by which class(es) the character is matched (assuming no locale or \s-1EBCDIC\s0 code
page is in effect that changes the \f(CW\*(C`\es\*(C'\fR matching).
.PP
.Vb 10
\& 0x0009        CHARACTER TABULATION   h s
\& 0x000a              LINE FEED (LF)    vs
\& 0x000b             LINE TABULATION    v
\& 0x000c              FORM FEED (FF)    vs
\& 0x000d        CARRIAGE RETURN (CR)    vs
\& 0x0020                       SPACE   h s
\& 0x0085             NEXT LINE (NEL)    vs  [1]
\& 0x00a0              NO\-BREAK SPACE   h s  [1]
\& 0x1680            OGHAM SPACE MARK   h s
\& 0x180e   MONGOLIAN VOWEL SEPARATOR   h s
\& 0x2000                     EN QUAD   h s
\& 0x2001                     EM QUAD   h s
\& 0x2002                    EN SPACE   h s
\& 0x2003                    EM SPACE   h s
\& 0x2004          THREE\-PER\-EM SPACE   h s
\& 0x2005           FOUR\-PER\-EM SPACE   h s
\& 0x2006            SIX\-PER\-EM SPACE   h s
\& 0x2007                FIGURE SPACE   h s
\& 0x2008           PUNCTUATION SPACE   h s
\& 0x2009                  THIN SPACE   h s
\& 0x200a                  HAIR SPACE   h s
\& 0x2028              LINE SEPARATOR    vs
\& 0x2029         PARAGRAPH SEPARATOR    vs
\& 0x202f       NARROW NO\-BREAK SPACE   h s
\& 0x205f   MEDIUM MATHEMATICAL SPACE   h s
\& 0x3000           IDEOGRAPHIC SPACE   h s
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\s-1NEXT\s0 \s-1LINE\s0 and NO-BREAK \s-1SPACE\s0 may or may not match \f(CW\*(C`\es\*(C'\fR depending
on the rules in effect.  See
the beginning of this section.
.PP
\fIUnicode Properties\fR
.IX Subsection "Unicode Properties"
.PP
\&\f(CW\*(C`\epP\*(C'\fR and \f(CW\*(C`\ep{Prop}\*(C'\fR are character classes to match characters that fit given
Unicode properties.  One letter property names can be used in the \f(CW\*(C`\epP\*(C'\fR form,
with the property name following the \f(CW\*(C`\ep\*(C'\fR, otherwise, braces are required.
When using braces, there is a single form, which is just the property name
enclosed in the braces, and a compound form which looks like \f(CW\*(C`\ep{name=value}\*(C'\fR,
which means to match if the property \*(L"name\*(R" for the character has that particular
\&\*(L"value\*(R".
For instance, a match for a number can be written as \f(CW\*(C`/\epN/\*(C'\fR or as
\&\f(CW\*(C`/\ep{Number}/\*(C'\fR, or as \f(CW\*(C`/\ep{Number=True}/\*(C'\fR.
Lowercase letters are matched by the property \fILowercase_Letter\fR which
has the short form \fILl\fR. They need the braces, so are written as \f(CW\*(C`/\ep{Ll}/\*(C'\fR or
\&\f(CW\*(C`/\ep{Lowercase_Letter}/\*(C'\fR, or \f(CW\*(C`/\ep{General_Category=Lowercase_Letter}/\*(C'\fR
(the underscores are optional).
\&\f(CW\*(C`/\epLl/\*(C'\fR is valid, but means something different.
It matches a two character string: a letter (Unicode property \f(CW\*(C`\epL\*(C'\fR),
followed by a lowercase \f(CW\*(C`l\*(C'\fR.
.PP
If neither the \f(CW\*(C`/a\*(C'\fR modifier nor locale rules are in effect, the use of
a Unicode property will force the regular expression into using Unicode
rules.
.PP
Note that almost all properties are immune to case-insensitive matching.
That is, adding a \f(CW\*(C`/i\*(C'\fR regular expression modifier does not change what
they match.  There are two sets that are affected.  The first set is
\&\f(CW\*(C`Uppercase_Letter\*(C'\fR,
\&\f(CW\*(C`Lowercase_Letter\*(C'\fR,
and \f(CW\*(C`Titlecase_Letter\*(C'\fR,
all of which match \f(CW\*(C`Cased_Letter\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching.
The second set is
\&\f(CW\*(C`Uppercase\*(C'\fR,
\&\f(CW\*(C`Lowercase\*(C'\fR,
and \f(CW\*(C`Titlecase\*(C'\fR,
all of which match \f(CW\*(C`Cased\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case, so they are \f(CW\*(C`Cased\*(C'\fR, but
aren't considered to be letters, so they aren't \f(CW\*(C`Cased_Letter\*(C'\fRs. They're
actually \f(CW\*(C`Letter_Number\*(C'\fRs.)
This set also includes its subsets \f(CW\*(C`PosixUpper\*(C'\fR and \f(CW\*(C`PosixLower\*(C'\fR, both
of which under \f(CW\*(C`/i\*(C'\fR match \f(CW\*(C`PosixAlpha\*(C'\fR.
.PP
For more details on Unicode properties, see \*(L"Unicode
Character Properties\*(R" in perlunicode; for a
complete list of possible properties, see
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops,
which notes all forms that have \f(CW\*(C`/i\*(C'\fR differences.
It is also possible to define your own properties. This is discussed in
\&\*(L"User-Defined Character Properties\*(R" in perlunicode.
.PP
Unicode properties are defined (surprise!) only on Unicode code points.
A warning is raised and all matches fail on non-Unicode code points
(those above the legal Unicode maximum of 0x10FFFF).  This can be
somewhat surprising,
.PP
.Vb 2
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=True}      # Fails.
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=False}     # Also fails!
.Ve
.PP
Even though these two matches might be thought of as complements, they
are so only on Unicode code points.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 8
\& "a"  =~  /\ew/      # Match, "a" is a \*(Aqword\*(Aq character.
\& "7"  =~  /\ew/      # Match, "7" is a \*(Aqword\*(Aq character as well.
\& "a"  =~  /\ed/      # No match, "a" isn\*(Aqt a digit.
\& "7"  =~  /\ed/      # Match, "7" is a digit.
\& " "  =~  /\es/      # Match, a space is whitespace.
\& "a"  =~  /\eD/      # Match, "a" is a non\-digit.
\& "7"  =~  /\eD/      # No match, "7" is not a non\-digit.
\& " "  =~  /\eS/      # No match, a space is not non\-whitespace.
\&
\& " "  =~  /\eh/      # Match, space is horizontal whitespace.
\& " "  =~  /\ev/      # No match, space is not vertical whitespace.
\& "\er" =~  /\ev/      # Match, a return is vertical whitespace.
\&
\& "a"  =~  /\epL/     # Match, "a" is a letter.
\& "a"  =~  /\ep{Lu}/  # No match, /\ep{Lu}/ matches upper case letters.
\&
\& "\ex{0e0b}" =~ /\ep{Thai}/  # Match, \ex{0e0b} is the character
\&                           # \*(AqTHAI CHARACTER SO SO\*(Aq, and that\*(Aqs in
\&                           # Thai Unicode class.
\& "a"  =~  /\eP{Lao}/ # Match, as "a" is not a Laotian character.
.Ve
.PP
It is worth emphasizing that \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, etc, match single characters, not
complete numbers or words. To match a number (that consists of digits),
use \f(CW\*(C`\ed+\*(C'\fR; to match a word, use \f(CW\*(C`\ew+\*(C'\fR.  But be aware of the security
considerations in doing so, as mentioned above.
.SS "Bracketed Character Classes"
.IX Subsection "Bracketed Character Classes"
The third form of character class you can use in Perl regular expressions
is the bracketed character class.  In its simplest form, it lists the characters
that may be matched, surrounded by square brackets, like this: \f(CW\*(C`[aeiou]\*(C'\fR.
This matches one of \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`e\*(C'\fR, \f(CW\*(C`i\*(C'\fR, \f(CW\*(C`o\*(C'\fR or \f(CW\*(C`u\*(C'\fR.  Like the other
character classes, exactly one character is matched.* To match
a longer string consisting of characters mentioned in the character
class, follow the character class with a quantifier.  For
instance, \f(CW\*(C`[aeiou]+\*(C'\fR matches one or more lowercase English vowels.
.PP
Repeating a character in a character class has no
effect; it's considered to be in the set only once.
.PP
Examples:
.PP
.Vb 5
\& "e"  =~  /[aeiou]/        # Match, as "e" is listed in the class.
\& "p"  =~  /[aeiou]/        # No match, "p" is not listed in the class.
\& "ae" =~  /^[aeiou]$/      # No match, a character class only matches
\&                           # a single character.
\& "ae" =~  /^[aeiou]+$/     # Match, due to the quantifier.
\&
\& \-\-\-\-\-\-\-
.Ve
.PP
* There is an exception to a bracketed character class matching a
single character only.  When the class is to match caselessly under \f(CW\*(C`/i\*(C'\fR
matching rules, and a character inside the class matches a
multiple-character sequence caselessly under Unicode rules, the class
(when not inverted) will also match that sequence.  For
example, Unicode says that the letter \f(CW\*(C`LATIN SMALL LETTER SHARP S\*(C'\fR
should match the sequence \f(CW\*(C`ss\*(C'\fR under \f(CW\*(C`/i\*(C'\fR rules.  Thus,
.PP
.Vb 2
\& \*(Aqss\*(Aq =~ /\eA\eN{LATIN SMALL LETTER SHARP S}\ez/i             # Matches
\& \*(Aqss\*(Aq =~ /\eA[aeioust\eN{LATIN SMALL LETTER SHARP S}]\ez/i    # Matches
.Ve
.PP
\fISpecial Characters Inside a Bracketed Character Class\fR
.IX Subsection "Special Characters Inside a Bracketed Character Class"
.PP
Most characters that are meta characters in regular expressions (that
is, characters that carry a special meaning like \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`*\*(C'\fR, or \f(CW\*(C`(\*(C'\fR) lose
their special meaning and can be used inside a character class without
the need to escape them. For instance, \f(CW\*(C`[()]\*(C'\fR matches either an opening
parenthesis, or a closing parenthesis, and the parens inside the character
class don't group or capture.
.PP
Characters that may carry a special meaning inside a character class are:
\&\f(CW\*(C`\e\*(C'\fR, \f(CW\*(C`^\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`[\*(C'\fR and \f(CW\*(C`]\*(C'\fR, and are discussed below. They can be
escaped with a backslash, although this is sometimes not needed, in which
case the backslash may be omitted.
.PP
The sequence \f(CW\*(C`\eb\*(C'\fR is special inside a bracketed character class. While
outside the character class, \f(CW\*(C`\eb\*(C'\fR is an assertion indicating a point
that does not have either two word characters or two non-word characters
on either side, inside a bracketed character class, \f(CW\*(C`\eb\*(C'\fR matches a
backspace character.
.PP
The sequences
\&\f(CW\*(C`\ea\*(C'\fR,
\&\f(CW\*(C`\ec\*(C'\fR,
\&\f(CW\*(C`\ee\*(C'\fR,
\&\f(CW\*(C`\ef\*(C'\fR,
\&\f(CW\*(C`\en\*(C'\fR,
\&\f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR,
\&\f(CW\*(C`\eN{U+\f(CIhex char\f(CW}\*(C'\fR,
\&\f(CW\*(C`\er\*(C'\fR,
\&\f(CW\*(C`\et\*(C'\fR,
and
\&\f(CW\*(C`\ex\*(C'\fR
are also special and have the same meanings as they do outside a
bracketed character class.  (However, inside a bracketed character
class, if \f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR expands to a sequence of characters, only the first
one in the sequence is used, with a warning.)
.PP
Also, a backslash followed by two or three octal digits is considered an octal
number.
.PP
A \f(CW\*(C`[\*(C'\fR is not special inside a character class, unless it's the start of a
\&\s-1POSIX\s0 character class (see \*(L"\s-1POSIX\s0 Character Classes\*(R" below). It normally does
not need escaping.
.PP
A \f(CW\*(C`]\*(C'\fR is normally either the end of a \s-1POSIX\s0 character class (see
\&\*(L"\s-1POSIX\s0 Character Classes\*(R" below), or it signals the end of the bracketed
character class.  If you want to include a \f(CW\*(C`]\*(C'\fR in the set of characters, you
must generally escape it.
.PP
However, if the \f(CW\*(C`]\*(C'\fR is the \fIfirst\fR (or the second if the first
character is a caret) character of a bracketed character class, it
does not denote the end of the class (as you cannot have an empty class)
and is considered part of the set of characters that can be matched without
escaping.
.PP
Examples:
.PP
.Vb 8
\& "+"   =~ /[+?*]/     #  Match, "+" in a character class is not special.
\& "\ecH" =~ /[\eb]/      #  Match, \eb inside in a character class
\&                      #  is equivalent to a backspace.
\& "]"   =~ /[][]/      #  Match, as the character class contains.
\&                      #  both [ and ].
\& "[]"  =~ /[[]]/      #  Match, the pattern contains a character class
\&                      #  containing just ], and the character class is
\&                      #  followed by a ].
.Ve
.PP
\fICharacter Ranges\fR
.IX Subsection "Character Ranges"
.PP
It is not uncommon to want to match a range of characters. Luckily, instead
of listing all characters in the range, one may use the hyphen (\f(CW\*(C`\-\*(C'\fR).
If inside a bracketed character class you have two characters separated
by a hyphen, it's treated as if all characters between the two were in
the class. For instance, \f(CW\*(C`[0\-9]\*(C'\fR matches any \s-1ASCII\s0 digit, and \f(CW\*(C`[a\-m]\*(C'\fR
matches any lowercase letter from the first half of the \s-1ASCII\s0 alphabet.
.PP
Note that the two characters on either side of the hyphen are not
necessarily both letters or both digits. Any character is possible,
although not advisable.  \f(CW\*(C`[\*(Aq\-?]\*(C'\fR contains a range of characters, but
most people will not know which characters that means.  Furthermore,
such ranges may lead to portability problems if the code has to run on
a platform that uses a different character set, such as \s-1EBCDIC\s0.
.PP
If a hyphen in a character class cannot syntactically be part of a range, for
instance because it is the first or the last character of the character class,
or if it immediately follows a range, the hyphen isn't special, and so is
considered a character to be matched literally.  If you want a hyphen in
your set of characters to be matched and its position in the class is such
that it could be considered part of a range, you must escape that hyphen
with a backslash.
.PP
Examples:
.PP
.Vb 8
\& [a\-z]       #  Matches a character that is a lower case ASCII letter.
\& [a\-fz]      #  Matches any letter between \*(Aqa\*(Aq and \*(Aqf\*(Aq (inclusive) or
\&             #  the letter \*(Aqz\*(Aq.
\& [\-z]        #  Matches either a hyphen (\*(Aq\-\*(Aq) or the letter \*(Aqz\*(Aq.
\& [a\-f\-m]     #  Matches any letter between \*(Aqa\*(Aq and \*(Aqf\*(Aq (inclusive), the
\&             #  hyphen (\*(Aq\-\*(Aq), or the letter \*(Aqm\*(Aq.
\& [\*(Aq\-?]       #  Matches any of the characters  \*(Aq()*+,\-./0123456789:;<=>?
\&             #  (But not on an EBCDIC platform).
.Ve
.PP
\fINegation\fR
.IX Subsection "Negation"
.PP
It is also possible to instead list the characters you do not want to
match. You can do so by using a caret (\f(CW\*(C`^\*(C'\fR) as the first character in the
character class. For instance, \f(CW\*(C`[^a\-z]\*(C'\fR matches any character that is not a
lowercase \s-1ASCII\s0 letter, which therefore includes more than a million
Unicode code points.  The class is said to be \*(L"negated\*(R" or \*(L"inverted\*(R".
.PP
This syntax make the caret a special character inside a bracketed character
class, but only if it is the first character of the class. So if you want
the caret as one of the characters to match, either escape the caret or
else don't list it first.
.PP
In inverted bracketed character classes, Perl ignores the Unicode rules
that normally say that certain characters should match a sequence of
multiple characters under caseless \f(CW\*(C`/i\*(C'\fR matching.  Following those
rules could lead to highly confusing situations:
.PP
.Vb 1
\& "ss" =~ /^[^\exDF]+$/ui;   # Matches!
.Ve
.PP
This should match any sequences of characters that aren't \f(CW\*(C`\exDF\*(C'\fR nor
what \f(CW\*(C`\exDF\*(C'\fR matches under \f(CW\*(C`/i\*(C'\fR.  \f(CW"s"\fR isn't \f(CW\*(C`\exDF\*(C'\fR, but Unicode
says that \f(CW"ss"\fR is what \f(CW\*(C`\exDF\*(C'\fR matches under \f(CW\*(C`/i\*(C'\fR.  So which one
\&\*(L"wins\*(R"? Do you fail the match because the string has \f(CW\*(C`ss\*(C'\fR or accept it
because it has an \f(CW\*(C`s\*(C'\fR followed by another \f(CW\*(C`s\*(C'\fR?  Perl has chosen the
latter.
.PP
Examples:
.PP
.Vb 4
\& "e"  =~  /[^aeiou]/   #  No match, the \*(Aqe\*(Aq is listed.
\& "x"  =~  /[^aeiou]/   #  Match, as \*(Aqx\*(Aq isn\*(Aqt a lowercase vowel.
\& "^"  =~  /[^^]/       #  No match, matches anything that isn\*(Aqt a caret.
\& "^"  =~  /[x^]/       #  Match, caret is not special here.
.Ve
.PP
\fIBackslash Sequences\fR
.IX Subsection "Backslash Sequences"
.PP
You can put any backslash sequence character class (with the exception of
\&\f(CW\*(C`\eN\*(C'\fR and \f(CW\*(C`\eR\*(C'\fR) inside a bracketed character class, and it will act just
as if you had put all characters matched by the backslash sequence inside the
character class. For instance, \f(CW\*(C`[a\-f\ed]\*(C'\fR matches any decimal digit, or any
of the lowercase letters between 'a' and 'f' inclusive.
.PP
\&\f(CW\*(C`\eN\*(C'\fR within a bracketed character class must be of the forms \f(CW\*(C`\eN{\f(CIname\f(CW}\*(C'\fR
or \f(CW\*(C`\eN{U+\f(CIhex char\f(CW}\*(C'\fR, and \s-1NOT\s0 be the form that matches non-newlines,
for the same reason that a dot \f(CW\*(C`.\*(C'\fR inside a bracketed character class loses
its special meaning: it matches nearly anything, which generally isn't what you
want to happen.
.PP
Examples:
.PP
.Vb 4
\& /[\ep{Thai}\ed]/     # Matches a character that is either a Thai
\&                    # character, or a digit.
\& /[^\ep{Arabic}()]/  # Matches a character that is neither an Arabic
\&                    # character, nor a parenthesis.
.Ve
.PP
Backslash sequence character classes cannot form one of the endpoints
of a range.  Thus, you can't say:
.PP
.Vb 1
\& /[\ep{Thai}\-\ed]/     # Wrong!
.Ve
.PP
\fI\s-1POSIX\s0 Character Classes\fR
.IX Xref "character class \\p \\p{} alpha alnum ascii blank cntrl digit graph lower print punct space upper word xdigit"
.IX Subsection "POSIX Character Classes"
.PP
\&\s-1POSIX\s0 character classes have the form \f(CW\*(C`[:class:]\*(C'\fR, where \fIclass\fR is
name, and the \f(CW\*(C`[:\*(C'\fR and \f(CW\*(C`:]\*(C'\fR delimiters. \s-1POSIX\s0 character classes only appear
\&\fIinside\fR bracketed character classes, and are a convenient and descriptive
way of listing a group of characters.
.PP
Be careful about the syntax,
.PP
.Vb 2
\& # Correct:
\& $string =~ /[[:alpha:]]/
\&
\& # Incorrect (will warn):
\& $string =~ /[:alpha:]/
.Ve
.PP
The latter pattern would be a character class consisting of a colon,
and the letters \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`p\*(C'\fR and \f(CW\*(C`h\*(C'\fR.
\&\s-1POSIX\s0 character classes can be part of a larger bracketed character class.
For example,
.PP
.Vb 1
\& [01[:alpha:]%]
.Ve
.PP
is valid and matches '0', '1', any alphabetic character, and the percent sign.
.PP
Perl recognizes the following \s-1POSIX\s0 character classes:
.PP
.Vb 10
\& alpha  Any alphabetical character ("[A\-Za\-z]").
\& alnum  Any alphanumeric character. ("[A\-Za\-z0\-9]")
\& ascii  Any character in the ASCII character set.
\& blank  A GNU extension, equal to a space or a horizontal tab ("\et").
\& cntrl  Any control character.  See Note [2] below.
\& digit  Any decimal digit ("[0\-9]"), equivalent to "\ed".
\& graph  Any printable character, excluding a space.  See Note [3] below.
\& lower  Any lowercase character ("[a\-z]").
\& print  Any printable character, including a space.  See Note [4] below.
\& punct  Any graphical character excluding "word" characters.  Note [5].
\& space  Any whitespace character. "\es" plus the vertical tab ("\ecK").
\& upper  Any uppercase character ("[A\-Z]").
\& word   A Perl extension ("[A\-Za\-z0\-9_]"), equivalent to "\ew".
\& xdigit Any hexadecimal digit ("[0\-9a\-fA\-F]").
.Ve
.PP
Most \s-1POSIX\s0 character classes have two Unicode-style \f(CW\*(C`\ep\*(C'\fR property
counterparts.  (They are not official Unicode properties, but Perl extensions
derived from official Unicode properties.)  The table below shows the relation
between \s-1POSIX\s0 character classes and these counterparts.
.PP
One counterpart, in the column labelled \*(L"ASCII-range Unicode\*(R" in
the table, matches only characters in the \s-1ASCII\s0 character set.
.PP
The other counterpart, in the column labelled \*(L"Full-range Unicode\*(R", matches any
appropriate characters in the full Unicode character set.  For example,
\&\f(CW\*(C`\ep{Alpha}\*(C'\fR matches not just the \s-1ASCII\s0 alphabetic characters, but any
character in the entire Unicode character set considered alphabetic.
An entry in the column labelled \*(L"backslash sequence\*(R" is a (short)
equivalent.
.PP
.Vb 10
\& [[:...:]]      ASCII\-range          Full\-range  backslash  Note
\&                 Unicode              Unicode     sequence
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   alpha      \ep{PosixAlpha}       \ep{XPosixAlpha}
\&   alnum      \ep{PosixAlnum}       \ep{XPosixAlnum}
\&   ascii      \ep{ASCII}
\&   blank      \ep{PosixBlank}       \ep{XPosixBlank}  \eh      [1]
\&                                   or \ep{HorizSpace}        [1]
\&   cntrl      \ep{PosixCntrl}       \ep{XPosixCntrl}          [2]
\&   digit      \ep{PosixDigit}       \ep{XPosixDigit}  \ed
\&   graph      \ep{PosixGraph}       \ep{XPosixGraph}          [3]
\&   lower      \ep{PosixLower}       \ep{XPosixLower}
\&   print      \ep{PosixPrint}       \ep{XPosixPrint}          [4]
\&   punct      \ep{PosixPunct}       \ep{XPosixPunct}          [5]
\&              \ep{PerlSpace}        \ep{XPerlSpace}   \es      [6]
\&   space      \ep{PosixSpace}       \ep{XPosixSpace}          [6]
\&   upper      \ep{PosixUpper}       \ep{XPosixUpper}
\&   word       \ep{PosixWord}        \ep{XPosixWord}   \ew
\&   xdigit     \ep{PosixXDigit}      \ep{XPosixXDigit}
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\f(CW\*(C`\ep{Blank}\*(C'\fR and \f(CW\*(C`\ep{HorizSpace}\*(C'\fR are synonyms.
.IP "[2]" 4
.IX Item "[2]"
Control characters don't produce output as such, but instead usually control
the terminal somehow: for example, newline and backspace are control characters.
In the \s-1ASCII\s0 range, characters whose code points are between 0 and 31 inclusive,
plus 127 (\f(CW\*(C`DEL\*(C'\fR) are control characters.
.Sp
On \s-1EBCDIC\s0 platforms, it is likely that the code page will define \f(CW\*(C`[[:cntrl:]]\*(C'\fR
to be the \s-1EBCDIC\s0 equivalents of the \s-1ASCII\s0 controls, plus the controls
that in Unicode have code pointss from 128 through 159.
.IP "[3]" 4
.IX Item "[3]"
Any character that is \fIgraphical\fR, that is, visible. This class consists
of all alphanumeric characters and all punctuation characters.
.IP "[4]" 4
.IX Item "[4]"
All printable characters, which is the set of all graphical characters
plus those whitespace characters which are not also controls.
.IP "[5]" 4
.IX Item "[5]"
\&\f(CW\*(C`\ep{PosixPunct}\*(C'\fR and \f(CW\*(C`[[:punct:]]\*(C'\fR in the \s-1ASCII\s0 range match all
non-controls, non-alphanumeric, non-space characters:
\&\f(CW\*(C`[\-!"#$%&\*(Aq()*+,./:;<=>?@[\e\e\e]^_\`{|}~]\*(C'\fR (although if a locale is in effect,
it could alter the behavior of \f(CW\*(C`[[:punct:]]\*(C'\fR).
.Sp
The similarly named property, \f(CW\*(C`\ep{Punct}\*(C'\fR, matches a somewhat different
set in the \s-1ASCII\s0 range, namely
\&\f(CW\*(C`[\-!"#%&\*(Aq()*,./:;?@[\e\e\e]_{}]\*(C'\fR.  That is, it is missing the nine
characters \f(CW\*(C`[$+<=>^\`|~]\*(C'\fR.
This is because Unicode splits what \s-1POSIX\s0 considers to be punctuation into two
categories, Punctuation and Symbols.
.Sp
\&\f(CW\*(C`\ep{XPosixPunct}\*(C'\fR and (under Unicode rules) \f(CW\*(C`[[:punct:]]\*(C'\fR, match what
\&\f(CW\*(C`\ep{PosixPunct}\*(C'\fR matches in the \s-1ASCII\s0 range, plus what \f(CW\*(C`\ep{Punct}\*(C'\fR
matches.  This is different than strictly matching according to
\&\f(CW\*(C`\ep{Punct}\*(C'\fR.  Another way to say it is that
if Unicode rules are in effect, \f(CW\*(C`[[:punct:]]\*(C'\fR matches all characters
that Unicode considers punctuation, plus all ASCII-range characters that
Unicode considers symbols.
.IP "[6]" 4
.IX Item "[6]"
\&\f(CW\*(C`\ep{SpacePerl}\*(C'\fR and \f(CW\*(C`\ep{Space}\*(C'\fR differ only in that in non-locale
matching, \f(CW\*(C`\ep{Space}\*(C'\fR additionally
matches the vertical tab, \f(CW\*(C`\ecK\*(C'\fR.   Same for the two ASCII-only range forms.
.PP
There are various other synonyms that can be used besides the names
listed in the table.  For example, \f(CW\*(C`\ep{PosixAlpha}\*(C'\fR can be written as
\&\f(CW\*(C`\ep{Alpha}\*(C'\fR.  All are listed in
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops,
plus all characters matched by each ASCII-range property.
.PP
Both the \f(CW\*(C`\ep\*(C'\fR counterparts always assume Unicode rules are in effect.
On \s-1ASCII\s0 platforms, this means they assume that the code points from 128
to 255 are Latin\-1, and that means that using them under locale rules is
unwise unless the locale is guaranteed to be Latin\-1 or \s-1UTF\-8\s0.  In contrast, the
\&\s-1POSIX\s0 character classes are useful under locale rules.  They are
affected by the actual rules in effect, as follows:
.ie n .IP "If the ""/a"" modifier, is in effect ..." 4
.el .IP "If the \f(CW/a\fR modifier, is in effect ..." 4
.IX Item "If the /a modifier, is in effect ..."
Each of the \s-1POSIX\s0 classes matches exactly the same as their ASCII-range
counterparts.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
The \s-1POSIX\s0 class matches the same as its Full-range counterpart.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rules are in effect ..." 4
.IX Item "if locale rules are in effect ..."
.PD
The \s-1POSIX\s0 class matches according to the locale, except that
\&\f(CW\*(C`word\*(C'\fR uses the platform's native underscore character, no matter what
the locale is.
.IP "if Unicode rules are in effect or if on an \s-1EBCDIC\s0 platform ..." 4
.IX Item "if Unicode rules are in effect or if on an EBCDIC platform ..."
The \s-1POSIX\s0 class matches the same as the Full-range counterpart.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
The \s-1POSIX\s0 class matches the same as the \s-1ASCII\s0 range counterpart.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rules apply are determined as described in
\&\*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
It is proposed to change this behavior in a future release of Perl so that
whether or not Unicode rules are in effect would not change the
behavior:  Outside of locale or an \s-1EBCDIC\s0 code page, the \s-1POSIX\s0 classes
would behave like their ASCII-range counterparts.  If you wish to
comment on this proposal, send email to \f(CW\*(C`perl5\-porters@perl.org\*(C'\fR.
.PP
Negation of \s-1POSIX\s0 character classes
.IX Xref "character class, negation"
.IX Subsection "Negation of POSIX character classes"
.PP
A Perl extension to the \s-1POSIX\s0 character class is the ability to
negate it. This is done by prefixing the class name with a caret (\f(CW\*(C`^\*(C'\fR).
Some examples:
.PP
.Vb 7
\&     POSIX         ASCII\-range     Full\-range  backslash
\&                    Unicode         Unicode    sequence
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& [[:^digit:]]   \eP{PosixDigit}  \eP{XPosixDigit}   \eD
\& [[:^space:]]   \eP{PosixSpace}  \eP{XPosixSpace}
\&                \eP{PerlSpace}   \eP{XPerlSpace}    \eS
\& [[:^word:]]    \eP{PerlWord}    \eP{XPosixWord}    \eW
.Ve
.PP
The backslash sequence can mean either \s-1ASCII\-\s0 or Full-range Unicode,
depending on various factors as described in \*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
[= =] and [. .]
.IX Subsection "[= =] and [. .]"
.PP
Perl recognizes the \s-1POSIX\s0 character classes \f(CW\*(C`[=class=]\*(C'\fR and
\&\f(CW\*(C`[.class.]\*(C'\fR, but does not (yet?) support them.  Any attempt to use
either construct raises an exception.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 12
\& /[[:digit:]]/            # Matches a character that is a digit.
\& /[01[:lower:]]/          # Matches a character that is either a
\&                          # lowercase letter, or \*(Aq0\*(Aq or \*(Aq1\*(Aq.
\& /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything
\&                          # except the letters \*(Aqa\*(Aq to \*(Aqf\*(Aq.  This is
\&                          # because the main character class is composed
\&                          # of two POSIX character classes that are ORed
\&                          # together, one that matches any digit, and
\&                          # the other that matches anything that isn\*(Aqt a
\&                          # hex digit.  The result matches all
\&                          # characters except the letters \*(Aqa\*(Aq to \*(Aqf\*(Aq and
\&                          # \*(AqA\*(Aq to \*(AqF\*(Aq.
.Ve
                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlrecharclass5.18.1                        0100644 0001750 0001750 00000154624 12566207444 024447  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRECHARCLASS 1"
.TH PERLRECHARCLASS 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrecharclass \- Perl Regular Expression Character Classes
.IX Xref "character class"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The top level documentation about Perl regular expressions
is found in perlre.
.PP
This manual page discusses the syntax and use of character
classes in Perl regular expressions.
.PP
A character class is a way of denoting a set of characters
in such a way that one character of the set is matched.
It's important to remember that: matching a character class
consumes exactly one character in the source string. (The source
string is the string the regular expression is matched against.)
.PP
There are three types of character classes in Perl regular
expressions: the dot, backslash sequences, and the form enclosed in square
brackets.  Keep in mind, though, that often the term \*(L"character class\*(R" is used
to mean just the bracketed form.  Certainly, most Perl documentation does that.
.SS "The dot"
.IX Subsection "The dot"
The dot (or period), \f(CW\*(C`.\*(C'\fR is probably the most used, and certainly
the most well-known character class. By default, a dot matches any
character, except for the newline. That default can be changed to
add matching the newline by using the \fIsingle line\fR modifier: either
for the entire regular expression with the \f(CW\*(C`/s\*(C'\fR modifier, or
locally with \f(CW\*(C`(?s)\*(C'\fR.  (The \f(CW\*(C`\eN\*(C'\fR backslash sequence, described
below, matches any character except newline without regard to the
\&\fIsingle line\fR modifier.)
.PP
Here are some examples:
.PP
.Vb 7
\& "a"  =~  /./       # Match
\& "."  =~  /./       # Match
\& ""   =~  /./       # No match (dot has to match a character)
\& "\en" =~  /./       # No match (dot does not match a newline)
\& "\en" =~  /./s      # Match (global \*(Aqsingle line\*(Aq modifier)
\& "\en" =~  /(?s:.)/  # Match (local \*(Aqsingle line\*(Aq modifier)
\& "ab" =~  /^.$/     # No match (dot matches one character)
.Ve
.SS "Backslash sequences"
.IX Xref "\\w \\W \\s \\S \\d \\D \\p \\P \\N \\v \\V \\h \\H word whitespace"
.IX Subsection "Backslash sequences"
A backslash sequence is a sequence of characters, the first one of which is a
backslash.  Perl ascribes special meaning to many such sequences, and some of
these are character classes.  That is, they match a single character each,
provided that the character belongs to the specific set of characters defined
by the sequence.
.PP
Here's a list of the backslash sequences that are character classes.  They
are discussed in more detail below.  (For the backslash sequences that aren't
character classes, see perlrebackslash.)
.PP
.Vb 10
\& \ed             Match a decimal digit character.
\& \eD             Match a non\-decimal\-digit character.
\& \ew             Match a "word" character.
\& \eW             Match a non\-"word" character.
\& \es             Match a whitespace character.
\& \eS             Match a non\-whitespace character.
\& \eh             Match a horizontal whitespace character.
\& \eH             Match a character that isn\*(Aqt horizontal whitespace.
\& \ev             Match a vertical whitespace character.
\& \eV             Match a character that isn\*(Aqt vertical whitespace.
\& \eN             Match a character that isn\*(Aqt a newline.
\& \epP, \ep{Prop}  Match a character that has the given Unicode property.
\& \ePP, \eP{Prop}  Match a character that doesn\*(Aqt have the Unicode property
.Ve
.PP
\fI\eN\fR
.IX Subsection "N"
.PP
\&\f(CW\*(C`\eN\*(C'\fR, available starting in v5.12, like the dot, matches any
character that is not a newline. The difference is that \f(CW\*(C`\eN\*(C'\fR is not influenced
by the \fIsingle line\fR regular expression modifier (see \*(L"The dot\*(R" above).  Note
that the form \f(CW\*(C`\eN{...}\*(C'\fR may mean something completely different.  When the
\&\f(CW\*(C`{...}\*(C'\fR is a quantifier, it means to match a non-newline
character that many times.  For example, \f(CW\*(C`\eN{3}\*(C'\fR means to match 3
non-newlines; \f(CW\*(C`\eN{5,}\*(C'\fR means to match 5 or more non-newlines.  But if \f(CW\*(C`{...}\*(C'\fR
is not a legal quantifier, it is presumed to be a named character.  See
charnames for those.  For example, none of \f(CW\*(C`\eN{COLON}\*(C'\fR, \f(CW\*(C`\eN{4F}\*(C'\fR, and
\&\f(CW\*(C`\eN{F4}\*(C'\fR contain legal quantifiers, so Perl will try to find characters whose
names are respectively \f(CW\*(C`COLON\*(C'\fR, \f(CW\*(C`4F\*(C'\fR, and \f(CW\*(C`F4\*(C'\fR.
.PP
\fIDigits\fR
.IX Subsection "Digits"
.PP
\&\f(CW\*(C`\ed\*(C'\fR matches a single character considered to be a decimal \fIdigit\fR.
If the \f(CW\*(C`/a\*(C'\fR regular expression modifier is in effect, it matches [0\-9].
Otherwise, it
matches anything that is matched by \f(CW\*(C`\ep{Digit}\*(C'\fR, which includes [0\-9].
(An unlikely possible exception is that under locale matching rules, the
current locale might not have [0\-9] matched by \f(CW\*(C`\ed\*(C'\fR, and/or might match
other characters whose code point is less than 256.  Such a locale
definition would be in violation of the C language standard, but Perl
doesn't currently assume anything in regard to this.)
.PP
What this means is that unless the \f(CW\*(C`/a\*(C'\fR modifier is in effect \f(CW\*(C`\ed\*(C'\fR not
only matches the digits '0' \- '9', but also Arabic, Devanagari, and
digits from other languages.  This may cause some confusion, and some
security issues.
.PP
Some digits that \f(CW\*(C`\ed\*(C'\fR matches look like some of the [0\-9] ones, but
have different values.  For example, \s-1BENGALI DIGIT FOUR \s0(U+09EA) looks
very much like an \s-1ASCII DIGIT EIGHT \s0(U+0038).  An application that
is expecting only the \s-1ASCII\s0 digits might be misled, or if the match is
\&\f(CW\*(C`\ed+\*(C'\fR, the matched string might contain a mixture of digits from
different writing systems that look like they signify a number different
than they actually do.  \*(L"\fInum()\fR\*(R" in Unicode::UCD can
be used to safely
calculate the value, returning \f(CW\*(C`undef\*(C'\fR if the input string contains
such a mixture.
.PP
What \f(CW\*(C`\ep{Digit}\*(C'\fR means (and hence \f(CW\*(C`\ed\*(C'\fR except under the \f(CW\*(C`/a\*(C'\fR
modifier) is \f(CW\*(C`\ep{General_Category=Decimal_Number}\*(C'\fR, or synonymously,
\&\f(CW\*(C`\ep{General_Category=Digit}\*(C'\fR.  Starting with Unicode version 4.1, this
is the same set of characters matched by \f(CW\*(C`\ep{Numeric_Type=Decimal}\*(C'\fR.
But Unicode also has a different property with a similar name,
\&\f(CW\*(C`\ep{Numeric_Type=Digit}\*(C'\fR, which matches a completely different set of
characters.  These characters are things such as \f(CW\*(C`CIRCLED DIGIT ONE\*(C'\fR
or subscripts, or are from writing systems that lack all ten digits.
.PP
The design intent is for \f(CW\*(C`\ed\*(C'\fR to exactly match the set of characters
that can safely be used with \*(L"normal\*(R" big-endian positional decimal
syntax, where, for example 123 means one 'hundred', plus two 'tens',
plus three 'ones'.  This positional notation does not necessarily apply
to characters that match the other type of \*(L"digit\*(R",
\&\f(CW\*(C`\ep{Numeric_Type=Digit}\*(C'\fR, and so \f(CW\*(C`\ed\*(C'\fR doesn't match them.
.PP
The Tamil digits (U+0BE6 \- U+0BEF) can also legally be
used in old-style Tamil numbers in which they would appear no more than
one in a row, separated by characters that mean \*(L"times 10\*(R", \*(L"times 100\*(R",
etc.  (See <http://www.unicode.org/notes/tn21>.)
.PP
Any character not matched by \f(CW\*(C`\ed\*(C'\fR is matched by \f(CW\*(C`\eD\*(C'\fR.
.PP
\fIWord characters\fR
.IX Subsection "Word characters"
.PP
A \f(CW\*(C`\ew\*(C'\fR matches a single alphanumeric character (an alphabetic character, or a
decimal digit); or a connecting punctuation character, such as an
underscore (\*(L"_\*(R"); or a \*(L"mark\*(R" character (like some sort of accent) that
attaches to one of those.  It does not match a whole word.  To match a
whole word, use \f(CW\*(C`\ew+\*(C'\fR.  This isn't the same thing as matching an
English word, but in the \s-1ASCII\s0 range it is the same as a string of
Perl-identifier characters.
.ie n .IP "If the ""/a"" modifier is in effect ..." 4
.el .IP "If the \f(CW/a\fR modifier is in effect ..." 4
.IX Item "If the /a modifier is in effect ..."
\&\f(CW\*(C`\ew\*(C'\fR matches the 63 characters [a\-zA\-Z0\-9_].
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
\&\f(CW\*(C`\ew\*(C'\fR matches the same as \f(CW\*(C`\ep{Word}\*(C'\fR matches in this range.  That is,
it matches Thai letters, Greek letters, etc.  This includes connector
punctuation (like the underscore) which connect two words together, or
diacritics, such as a \f(CW\*(C`COMBINING TILDE\*(C'\fR and the modifier letters, which
are generally used to add auxiliary markings to letters.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rules are in effect ..." 4
.IX Item "if locale rules are in effect ..."
.PD
\&\f(CW\*(C`\ew\*(C'\fR matches the platform's native underscore character plus whatever
the locale considers to be alphanumeric.
.IP "if Unicode rules are in effect ..." 4
.IX Item "if Unicode rules are in effect ..."
\&\f(CW\*(C`\ew\*(C'\fR matches exactly what \f(CW\*(C`\ep{Word}\*(C'\fR matches.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
\&\f(CW\*(C`\ew\*(C'\fR matches [a\-zA\-Z0\-9_].
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rules apply are determined as described in \*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
There are a number of security issues with the full Unicode list of word
characters.  See <http://unicode.org/reports/tr36>.
.PP
Also, for a somewhat finer-grained set of characters that are in programming
language identifiers beyond the \s-1ASCII\s0 range, you may wish to instead use the
more customized \*(L"Unicode Properties\*(R", \f(CW\*(C`\ep{ID_Start}\*(C'\fR,
\&\f(CW\*(C`\ep{ID_Continue}\*(C'\fR, \f(CW\*(C`\ep{XID_Start}\*(C'\fR, and \f(CW\*(C`\ep{XID_Continue}\*(C'\fR.  See
<http://unicode.org/reports/tr31>.
.PP
Any character not matched by \f(CW\*(C`\ew\*(C'\fR is matched by \f(CW\*(C`\eW\*(C'\fR.
.PP
\fIWhitespace\fR
.IX Subsection "Whitespace"
.PP
\&\f(CW\*(C`\es\*(C'\fR matches any single character considered whitespace.
.ie n .IP "If the ""/a"" modifier is in effect ..." 4
.el .IP "If the \f(CW/a\fR modifier is in effect ..." 4
.IX Item "If the /a modifier is in effect ..."
In all Perl versions, \f(CW\*(C`\es\*(C'\fR matches the 5 characters [\et\en\ef\er ]; that
is, the horizontal tab,
the newline, the form feed, the carriage return, and the space.
Starting in Perl v5.18, experimentally, it also matches the vertical tab, \f(CW\*(C`\ecK\*(C'\fR.
See note \f(CW\*(C`[1]\*(C'\fR below for a discussion of this.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
\&\f(CW\*(C`\es\*(C'\fR matches exactly the code points above 255 shown with an \*(L"s\*(R" column
in the table below.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rules are in effect ..." 4
.IX Item "if locale rules are in effect ..."
.PD
\&\f(CW\*(C`\es\*(C'\fR matches whatever the locale considers to be whitespace.
.IP "if Unicode rules are in effect ..." 4
.IX Item "if Unicode rules are in effect ..."
\&\f(CW\*(C`\es\*(C'\fR matches exactly the characters shown with an \*(L"s\*(R" column in the
table below.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
\&\f(CW\*(C`\es\*(C'\fR matches [\et\en\ef\er\ecK ] and, starting, experimentally in Perl
v5.18, the vertical tab, \f(CW\*(C`\ecK\*(C'\fR.
(See note \f(CW\*(C`[1]\*(C'\fR below for a discussion of this.)
Note that this list doesn't include the non-breaking space.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rules apply are determined as described in \*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
Any character not matched by \f(CW\*(C`\es\*(C'\fR is matched by \f(CW\*(C`\eS\*(C'\fR.
.PP
\&\f(CW\*(C`\eh\*(C'\fR matches any character considered horizontal whitespace;
this includes the platform's space and tab characters and several others
listed in the table below.  \f(CW\*(C`\eH\*(C'\fR matches any character
not considered horizontal whitespace.  They use the platform's native
character set, and do not consider any locale that may otherwise be in
use.
.PP
\&\f(CW\*(C`\ev\*(C'\fR matches any character considered vertical whitespace;
this includes the platform's carriage return and line feed characters (newline)
plus several other characters, all listed in the table below.
\&\f(CW\*(C`\eV\*(C'\fR matches any character not considered vertical whitespace.
They use the platform's native character set, and do not consider any
locale that may otherwise be in use.
.PP
\&\f(CW\*(C`\eR\*(C'\fR matches anything that can be considered a newline under Unicode
rules. It's not a character class, as it can match a multi-character
sequence. Therefore, it cannot be used inside a bracketed character
class; use \f(CW\*(C`\ev\*(C'\fR instead (vertical whitespace).  It uses the platform's
native character set, and does not consider any locale that may
otherwise be in use.
Details are discussed in perlrebackslash.
.PP
Note that unlike \f(CW\*(C`\es\*(C'\fR (and \f(CW\*(C`\ed\*(C'\fR and \f(CW\*(C`\ew\*(C'\fR), \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR always match
the same characters, without regard to other factors, such as the active
locale or whether the source string is in \s-1UTF\-8\s0 format.
.PP
One might think that \f(CW\*(C`\es\*(C'\fR is equivalent to \f(CW\*(C`[\eh\ev]\*(C'\fR. This is indeed true
starting in Perl v5.18, but prior to that, the sole difference was that the
vertical tab (\f(CW"\ecK"\fR) was not matched by \f(CW\*(C`\es\*(C'\fR.
.PP
The following table is a complete listing of characters matched by
\&\f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eh\*(C'\fR and \f(CW\*(C`\ev\*(C'\fR as of Unicode 6.0.
.PP
The first column gives the Unicode code point of the character (in hex format),
the second column gives the (Unicode) name. The third column indicates
by which class(es) the character is matched (assuming no locale is in
effect that changes the \f(CW\*(C`\es\*(C'\fR matching).
.PP
.Vb 10
\& 0x0009        CHARACTER TABULATION   h s
\& 0x000a              LINE FEED (LF)    vs
\& 0x000b             LINE TABULATION    vs  [1]
\& 0x000c              FORM FEED (FF)    vs
\& 0x000d        CARRIAGE RETURN (CR)    vs
\& 0x0020                       SPACE   h s
\& 0x0085             NEXT LINE (NEL)    vs  [2]
\& 0x00a0              NO\-BREAK SPACE   h s  [2]
\& 0x1680            OGHAM SPACE MARK   h s
\& 0x180e   MONGOLIAN VOWEL SEPARATOR   h s
\& 0x2000                     EN QUAD   h s
\& 0x2001                     EM QUAD   h s
\& 0x2002                    EN SPACE   h s
\& 0x2003                    EM SPACE   h s
\& 0x2004          THREE\-PER\-EM SPACE   h s
\& 0x2005           FOUR\-PER\-EM SPACE   h s
\& 0x2006            SIX\-PER\-EM SPACE   h s
\& 0x2007                FIGURE SPACE   h s
\& 0x2008           PUNCTUATION SPACE   h s
\& 0x2009                  THIN SPACE   h s
\& 0x200a                  HAIR SPACE   h s
\& 0x2028              LINE SEPARATOR    vs
\& 0x2029         PARAGRAPH SEPARATOR    vs
\& 0x202f       NARROW NO\-BREAK SPACE   h s
\& 0x205f   MEDIUM MATHEMATICAL SPACE   h s
\& 0x3000           IDEOGRAPHIC SPACE   h s
.Ve
.IP "[1]" 4
.IX Item "[1]"
Prior to Perl v5.18, \f(CW\*(C`\es\*(C'\fR did not match the vertical tab.  The change
in v5.18 is considered an experiment, which means it could be backed out
in v5.20 or v5.22 if experience indicates that it breaks too much
existing code.  If this change adversely affects you, send email to
\&\f(CW\*(C`perlbug@perl.org\*(C'\fR; if it affects you positively, email
\&\f(CW\*(C`perlthanks@perl.org\*(C'\fR.  In the meantime, \f(CW\*(C`[^\eS\ecK]\*(C'\fR (obscurely)
matches what \f(CW\*(C`\es\*(C'\fR traditionally did.
.IP "[2]" 4
.IX Item "[2]"
\&\s-1NEXT LINE\s0 and NO-BREAK \s-1SPACE\s0 may or may not match \f(CW\*(C`\es\*(C'\fR depending
on the rules in effect.  See
the beginning of this section.
.PP
\fIUnicode Properties\fR
.IX Subsection "Unicode Properties"
.PP
\&\f(CW\*(C`\epP\*(C'\fR and \f(CW\*(C`\ep{Prop}\*(C'\fR are character classes to match characters that fit given
Unicode properties.  One letter property names can be used in the \f(CW\*(C`\epP\*(C'\fR form,
with the property name following the \f(CW\*(C`\ep\*(C'\fR, otherwise, braces are required.
When using braces, there is a single form, which is just the property name
enclosed in the braces, and a compound form which looks like \f(CW\*(C`\ep{name=value}\*(C'\fR,
which means to match if the property \*(L"name\*(R" for the character has that particular
\&\*(L"value\*(R".
For instance, a match for a number can be written as \f(CW\*(C`/\epN/\*(C'\fR or as
\&\f(CW\*(C`/\ep{Number}/\*(C'\fR, or as \f(CW\*(C`/\ep{Number=True}/\*(C'\fR.
Lowercase letters are matched by the property \fILowercase_Letter\fR which
has the short form \fILl\fR. They need the braces, so are written as \f(CW\*(C`/\ep{Ll}/\*(C'\fR or
\&\f(CW\*(C`/\ep{Lowercase_Letter}/\*(C'\fR, or \f(CW\*(C`/\ep{General_Category=Lowercase_Letter}/\*(C'\fR
(the underscores are optional).
\&\f(CW\*(C`/\epLl/\*(C'\fR is valid, but means something different.
It matches a two character string: a letter (Unicode property \f(CW\*(C`\epL\*(C'\fR),
followed by a lowercase \f(CW\*(C`l\*(C'\fR.
.PP
If locale rules are not in effect, the use of
a Unicode property will force the regular expression into using Unicode
rules, if it isn't already.
.PP
Note that almost all properties are immune to case-insensitive matching.
That is, adding a \f(CW\*(C`/i\*(C'\fR regular expression modifier does not change what
they match.  There are two sets that are affected.  The first set is
\&\f(CW\*(C`Uppercase_Letter\*(C'\fR,
\&\f(CW\*(C`Lowercase_Letter\*(C'\fR,
and \f(CW\*(C`Titlecase_Letter\*(C'\fR,
all of which match \f(CW\*(C`Cased_Letter\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching.
The second set is
\&\f(CW\*(C`Uppercase\*(C'\fR,
\&\f(CW\*(C`Lowercase\*(C'\fR,
and \f(CW\*(C`Titlecase\*(C'\fR,
all of which match \f(CW\*(C`Cased\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case, so they are \f(CW\*(C`Cased\*(C'\fR, but
aren't considered to be letters, so they aren't \f(CW\*(C`Cased_Letter\*(C'\fRs. They're
actually \f(CW\*(C`Letter_Number\*(C'\fRs.)
This set also includes its subsets \f(CW\*(C`PosixUpper\*(C'\fR and \f(CW\*(C`PosixLower\*(C'\fR, both
of which under \f(CW\*(C`/i\*(C'\fR match \f(CW\*(C`PosixAlpha\*(C'\fR.
.PP
For more details on Unicode properties, see \*(L"Unicode
Character Properties\*(R" in perlunicode; for a
complete list of possible properties, see
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops,
which notes all forms that have \f(CW\*(C`/i\*(C'\fR differences.
It is also possible to define your own properties. This is discussed in
\&\*(L"User-Defined Character Properties\*(R" in perlunicode.
.PP
Unicode properties are defined (surprise!) only on Unicode code points.
A warning is raised and all matches fail on non-Unicode code points
(those above the legal Unicode maximum of 0x10FFFF).  This can be
somewhat surprising,
.PP
.Vb 2
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=True}      # Fails.
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=False}     # Also fails!
.Ve
.PP
Even though these two matches might be thought of as complements, they
are so only on Unicode code points.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 8
\& "a"  =~  /\ew/      # Match, "a" is a \*(Aqword\*(Aq character.
\& "7"  =~  /\ew/      # Match, "7" is a \*(Aqword\*(Aq character as well.
\& "a"  =~  /\ed/      # No match, "a" isn\*(Aqt a digit.
\& "7"  =~  /\ed/      # Match, "7" is a digit.
\& " "  =~  /\es/      # Match, a space is whitespace.
\& "a"  =~  /\eD/      # Match, "a" is a non\-digit.
\& "7"  =~  /\eD/      # No match, "7" is not a non\-digit.
\& " "  =~  /\eS/      # No match, a space is not non\-whitespace.
\&
\& " "  =~  /\eh/      # Match, space is horizontal whitespace.
\& " "  =~  /\ev/      # No match, space is not vertical whitespace.
\& "\er" =~  /\ev/      # Match, a return is vertical whitespace.
\&
\& "a"  =~  /\epL/     # Match, "a" is a letter.
\& "a"  =~  /\ep{Lu}/  # No match, /\ep{Lu}/ matches upper case letters.
\&
\& "\ex{0e0b}" =~ /\ep{Thai}/  # Match, \ex{0e0b} is the character
\&                           # \*(AqTHAI CHARACTER SO SO\*(Aq, and that\*(Aqs in
\&                           # Thai Unicode class.
\& "a"  =~  /\eP{Lao}/ # Match, as "a" is not a Laotian character.
.Ve
.PP
It is worth emphasizing that \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, etc, match single characters, not
complete numbers or words. To match a number (that consists of digits),
use \f(CW\*(C`\ed+\*(C'\fR; to match a word, use \f(CW\*(C`\ew+\*(C'\fR.  But be aware of the security
considerations in doing so, as mentioned above.
.SS "Bracketed Character Classes"
.IX Subsection "Bracketed Character Classes"
The third form of character class you can use in Perl regular expressions
is the bracketed character class.  In its simplest form, it lists the characters
that may be matched, surrounded by square brackets, like this: \f(CW\*(C`[aeiou]\*(C'\fR.
This matches one of \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`e\*(C'\fR, \f(CW\*(C`i\*(C'\fR, \f(CW\*(C`o\*(C'\fR or \f(CW\*(C`u\*(C'\fR.  Like the other
character classes, exactly one character is matched.* To match
a longer string consisting of characters mentioned in the character
class, follow the character class with a quantifier.  For
instance, \f(CW\*(C`[aeiou]+\*(C'\fR matches one or more lowercase English vowels.
.PP
Repeating a character in a character class has no
effect; it's considered to be in the set only once.
.PP
Examples:
.PP
.Vb 5
\& "e"  =~  /[aeiou]/        # Match, as "e" is listed in the class.
\& "p"  =~  /[aeiou]/        # No match, "p" is not listed in the class.
\& "ae" =~  /^[aeiou]$/      # No match, a character class only matches
\&                           # a single character.
\& "ae" =~  /^[aeiou]+$/     # Match, due to the quantifier.
\&
\& \-\-\-\-\-\-\-
.Ve
.PP
* There is an exception to a bracketed character class matching a
single character only.  When the class is to match caselessly under \f(CW\*(C`/i\*(C'\fR
matching rules, and a character that is explicitly mentioned inside the
class matches a
multiple-character sequence caselessly under Unicode rules, the class
(when not inverted) will also match that sequence.  For
example, Unicode says that the letter \f(CW\*(C`LATIN SMALL LETTER SHARP S\*(C'\fR
should match the sequence \f(CW\*(C`ss\*(C'\fR under \f(CW\*(C`/i\*(C'\fR rules.  Thus,
.PP
.Vb 2
\& \*(Aqss\*(Aq =~ /\eA\eN{LATIN SMALL LETTER SHARP S}\ez/i             # Matches
\& \*(Aqss\*(Aq =~ /\eA[aeioust\eN{LATIN SMALL LETTER SHARP S}]\ez/i    # Matches
.Ve
.PP
For this to happen, the character must be explicitly specified, and not
be part of a multi-character range (not even as one of its endpoints).
(\*(L"Character Ranges\*(R" will be explained shortly.)  Therefore,
.PP
.Vb 5
\& \*(Aqss\*(Aq =~ /\eA[\e0\-\ex{ff}]\ez/i        # Doesn\*(Aqt match
\& \*(Aqss\*(Aq =~ /\eA[\e0\-\eN{LATIN SMALL LETTER SHARP S}]\ez/i    # No match
\& \*(Aqss\*(Aq =~ /\eA[\exDF\-\exDF]\ez/i    # Matches on ASCII platforms, since \eXDF
\&                               # is LATIN SMALL LETTER SHARP S, and the
\&                               # range is just a single element
.Ve
.PP
Note that it isn't a good idea to specify these types of ranges anyway.
.PP
\fISpecial Characters Inside a Bracketed Character Class\fR
.IX Subsection "Special Characters Inside a Bracketed Character Class"
.PP
Most characters that are meta characters in regular expressions (that
is, characters that carry a special meaning like \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`*\*(C'\fR, or \f(CW\*(C`(\*(C'\fR) lose
their special meaning and can be used inside a character class without
the need to escape them. For instance, \f(CW\*(C`[()]\*(C'\fR matches either an opening
parenthesis, or a closing parenthesis, and the parens inside the character
class don't group or capture.
.PP
Characters that may carry a special meaning inside a character class are:
\&\f(CW\*(C`\e\*(C'\fR, \f(CW\*(C`^\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`[\*(C'\fR and \f(CW\*(C`]\*(C'\fR, and are discussed below. They can be
escaped with a backslash, although this is sometimes not needed, in which
case the backslash may be omitted.
.PP
The sequence \f(CW\*(C`\eb\*(C'\fR is special inside a bracketed character class. While
outside the character class, \f(CW\*(C`\eb\*(C'\fR is an assertion indicating a point
that does not have either two word characters or two non-word characters
on either side, inside a bracketed character class, \f(CW\*(C`\eb\*(C'\fR matches a
backspace character.
.PP
The sequences
\&\f(CW\*(C`\ea\*(C'\fR,
\&\f(CW\*(C`\ec\*(C'\fR,
\&\f(CW\*(C`\ee\*(C'\fR,
\&\f(CW\*(C`\ef\*(C'\fR,
\&\f(CW\*(C`\en\*(C'\fR,
\&\f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR,
\&\f(CW\*(C`\eN{U+\f(CIhex char\f(CW}\*(C'\fR,
\&\f(CW\*(C`\er\*(C'\fR,
\&\f(CW\*(C`\et\*(C'\fR,
and
\&\f(CW\*(C`\ex\*(C'\fR
are also special and have the same meanings as they do outside a
bracketed character class.  (However, inside a bracketed character
class, if \f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR expands to a sequence of characters, only the first
one in the sequence is used, with a warning.)
.PP
Also, a backslash followed by two or three octal digits is considered an octal
number.
.PP
A \f(CW\*(C`[\*(C'\fR is not special inside a character class, unless it's the start of a
\&\s-1POSIX\s0 character class (see \*(L"\s-1POSIX\s0 Character Classes\*(R" below). It normally does
not need escaping.
.PP
A \f(CW\*(C`]\*(C'\fR is normally either the end of a \s-1POSIX\s0 character class (see
\&\*(L"\s-1POSIX\s0 Character Classes\*(R" below), or it signals the end of the bracketed
character class.  If you want to include a \f(CW\*(C`]\*(C'\fR in the set of characters, you
must generally escape it.
.PP
However, if the \f(CW\*(C`]\*(C'\fR is the \fIfirst\fR (or the second if the first
character is a caret) character of a bracketed character class, it
does not denote the end of the class (as you cannot have an empty class)
and is considered part of the set of characters that can be matched without
escaping.
.PP
Examples:
.PP
.Vb 8
\& "+"   =~ /[+?*]/     #  Match, "+" in a character class is not special.
\& "\ecH" =~ /[\eb]/      #  Match, \eb inside in a character class.
\&                      #  is equivalent to a backspace.
\& "]"   =~ /[][]/      #  Match, as the character class contains.
\&                      #  both [ and ].
\& "[]"  =~ /[[]]/      #  Match, the pattern contains a character class
\&                      #  containing just ], and the character class is
\&                      #  followed by a ].
.Ve
.PP
\fICharacter Ranges\fR
.IX Subsection "Character Ranges"
.PP
It is not uncommon to want to match a range of characters. Luckily, instead
of listing all characters in the range, one may use the hyphen (\f(CW\*(C`\-\*(C'\fR).
If inside a bracketed character class you have two characters separated
by a hyphen, it's treated as if all characters between the two were in
the class. For instance, \f(CW\*(C`[0\-9]\*(C'\fR matches any \s-1ASCII\s0 digit, and \f(CW\*(C`[a\-m]\*(C'\fR
matches any lowercase letter from the first half of the \s-1ASCII\s0 alphabet.
.PP
Note that the two characters on either side of the hyphen are not
necessarily both letters or both digits. Any character is possible,
although not advisable.  \f(CW\*(C`[\*(Aq\-?]\*(C'\fR contains a range of characters, but
most people will not know which characters that means.  Furthermore,
such ranges may lead to portability problems if the code has to run on
a platform that uses a different character set, such as \s-1EBCDIC.\s0
.PP
If a hyphen in a character class cannot syntactically be part of a range, for
instance because it is the first or the last character of the character class,
or if it immediately follows a range, the hyphen isn't special, and so is
considered a character to be matched literally.  If you want a hyphen in
your set of characters to be matched and its position in the class is such
that it could be considered part of a range, you must escape that hyphen
with a backslash.
.PP
Examples:
.PP
.Vb 8
\& [a\-z]       #  Matches a character that is a lower case ASCII letter.
\& [a\-fz]      #  Matches any letter between \*(Aqa\*(Aq and \*(Aqf\*(Aq (inclusive) or
\&             #  the letter \*(Aqz\*(Aq.
\& [\-z]        #  Matches either a hyphen (\*(Aq\-\*(Aq) or the letter \*(Aqz\*(Aq.
\& [a\-f\-m]     #  Matches any letter between \*(Aqa\*(Aq and \*(Aqf\*(Aq (inclusive), the
\&             #  hyphen (\*(Aq\-\*(Aq), or the letter \*(Aqm\*(Aq.
\& [\*(Aq\-?]       #  Matches any of the characters  \*(Aq()*+,\-./0123456789:;<=>?
\&             #  (But not on an EBCDIC platform).
.Ve
.PP
\fINegation\fR
.IX Subsection "Negation"
.PP
It is also possible to instead list the characters you do not want to
match. You can do so by using a caret (\f(CW\*(C`^\*(C'\fR) as the first character in the
character class. For instance, \f(CW\*(C`[^a\-z]\*(C'\fR matches any character that is not a
lowercase \s-1ASCII\s0 letter, which therefore includes more than a million
Unicode code points.  The class is said to be \*(L"negated\*(R" or \*(L"inverted\*(R".
.PP
This syntax make the caret a special character inside a bracketed character
class, but only if it is the first character of the class. So if you want
the caret as one of the characters to match, either escape the caret or
else don't list it first.
.PP
In inverted bracketed character classes, Perl ignores the Unicode rules
that normally say that certain characters should match a sequence of
multiple characters under caseless \f(CW\*(C`/i\*(C'\fR matching.  Following those
rules could lead to highly confusing situations:
.PP
.Vb 1
\& "ss" =~ /^[^\exDF]+$/ui;   # Matches!
.Ve
.PP
This should match any sequences of characters that aren't \f(CW\*(C`\exDF\*(C'\fR nor
what \f(CW\*(C`\exDF\*(C'\fR matches under \f(CW\*(C`/i\*(C'\fR.  \f(CW"s"\fR isn't \f(CW\*(C`\exDF\*(C'\fR, but Unicode
says that \f(CW"ss"\fR is what \f(CW\*(C`\exDF\*(C'\fR matches under \f(CW\*(C`/i\*(C'\fR.  So which one
\&\*(L"wins\*(R"? Do you fail the match because the string has \f(CW\*(C`ss\*(C'\fR or accept it
because it has an \f(CW\*(C`s\*(C'\fR followed by another \f(CW\*(C`s\*(C'\fR?  Perl has chosen the
latter.
.PP
Examples:
.PP
.Vb 4
\& "e"  =~  /[^aeiou]/   #  No match, the \*(Aqe\*(Aq is listed.
\& "x"  =~  /[^aeiou]/   #  Match, as \*(Aqx\*(Aq isn\*(Aqt a lowercase vowel.
\& "^"  =~  /[^^]/       #  No match, matches anything that isn\*(Aqt a caret.
\& "^"  =~  /[x^]/       #  Match, caret is not special here.
.Ve
.PP
\fIBackslash Sequences\fR
.IX Subsection "Backslash Sequences"
.PP
You can put any backslash sequence character class (with the exception of
\&\f(CW\*(C`\eN\*(C'\fR and \f(CW\*(C`\eR\*(C'\fR) inside a bracketed character class, and it will act just
as if you had put all characters matched by the backslash sequence inside the
character class. For instance, \f(CW\*(C`[a\-f\ed]\*(C'\fR matches any decimal digit, or any
of the lowercase letters between 'a' and 'f' inclusive.
.PP
\&\f(CW\*(C`\eN\*(C'\fR within a bracketed character class must be of the forms \f(CW\*(C`\eN{\f(CIname\f(CW}\*(C'\fR
or \f(CW\*(C`\eN{U+\f(CIhex char\f(CW}\*(C'\fR, and \s-1NOT\s0 be the form that matches non-newlines,
for the same reason that a dot \f(CW\*(C`.\*(C'\fR inside a bracketed character class loses
its special meaning: it matches nearly anything, which generally isn't what you
want to happen.
.PP
Examples:
.PP
.Vb 4
\& /[\ep{Thai}\ed]/     # Matches a character that is either a Thai
\&                    # character, or a digit.
\& /[^\ep{Arabic}()]/  # Matches a character that is neither an Arabic
\&                    # character, nor a parenthesis.
.Ve
.PP
Backslash sequence character classes cannot form one of the endpoints
of a range.  Thus, you can't say:
.PP
.Vb 1
\& /[\ep{Thai}\-\ed]/     # Wrong!
.Ve
.PP
\fI\s-1POSIX\s0 Character Classes\fR
.IX Xref "character class \\p \\p{} alpha alnum ascii blank cntrl digit graph lower print punct space upper word xdigit"
.IX Subsection "POSIX Character Classes"
.PP
\&\s-1POSIX\s0 character classes have the form \f(CW\*(C`[:class:]\*(C'\fR, where \fIclass\fR is
name, and the \f(CW\*(C`[:\*(C'\fR and \f(CW\*(C`:]\*(C'\fR delimiters. \s-1POSIX\s0 character classes only appear
\&\fIinside\fR bracketed character classes, and are a convenient and descriptive
way of listing a group of characters.
.PP
Be careful about the syntax,
.PP
.Vb 2
\& # Correct:
\& $string =~ /[[:alpha:]]/
\&
\& # Incorrect (will warn):
\& $string =~ /[:alpha:]/
.Ve
.PP
The latter pattern would be a character class consisting of a colon,
and the letters \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`p\*(C'\fR and \f(CW\*(C`h\*(C'\fR.
\&\s-1POSIX\s0 character classes can be part of a larger bracketed character class.
For example,
.PP
.Vb 1
\& [01[:alpha:]%]
.Ve
.PP
is valid and matches '0', '1', any alphabetic character, and the percent sign.
.PP
Perl recognizes the following \s-1POSIX\s0 character classes:
.PP
.Vb 10
\& alpha  Any alphabetical character ("[A\-Za\-z]").
\& alnum  Any alphanumeric character ("[A\-Za\-z0\-9]").
\& ascii  Any character in the ASCII character set.
\& blank  A GNU extension, equal to a space or a horizontal tab ("\et").
\& cntrl  Any control character.  See Note [2] below.
\& digit  Any decimal digit ("[0\-9]"), equivalent to "\ed".
\& graph  Any printable character, excluding a space.  See Note [3] below.
\& lower  Any lowercase character ("[a\-z]").
\& print  Any printable character, including a space.  See Note [4] below.
\& punct  Any graphical character excluding "word" characters.  Note [5].
\& space  Any whitespace character. "\es" including the vertical tab
\&        ("\ecK").
\& upper  Any uppercase character ("[A\-Z]").
\& word   A Perl extension ("[A\-Za\-z0\-9_]"), equivalent to "\ew".
\& xdigit Any hexadecimal digit ("[0\-9a\-fA\-F]").
.Ve
.PP
Most \s-1POSIX\s0 character classes have two Unicode-style \f(CW\*(C`\ep\*(C'\fR property
counterparts.  (They are not official Unicode properties, but Perl extensions
derived from official Unicode properties.)  The table below shows the relation
between \s-1POSIX\s0 character classes and these counterparts.
.PP
One counterpart, in the column labelled \*(L"ASCII-range Unicode\*(R" in
the table, matches only characters in the \s-1ASCII\s0 character set.
.PP
The other counterpart, in the column labelled \*(L"Full-range Unicode\*(R", matches any
appropriate characters in the full Unicode character set.  For example,
\&\f(CW\*(C`\ep{Alpha}\*(C'\fR matches not just the \s-1ASCII\s0 alphabetic characters, but any
character in the entire Unicode character set considered alphabetic.
An entry in the column labelled \*(L"backslash sequence\*(R" is a (short)
equivalent.
.PP
.Vb 10
\& [[:...:]]      ASCII\-range          Full\-range  backslash  Note
\&                 Unicode              Unicode     sequence
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   alpha      \ep{PosixAlpha}       \ep{XPosixAlpha}
\&   alnum      \ep{PosixAlnum}       \ep{XPosixAlnum}
\&   ascii      \ep{ASCII}
\&   blank      \ep{PosixBlank}       \ep{XPosixBlank}  \eh      [1]
\&                                   or \ep{HorizSpace}        [1]
\&   cntrl      \ep{PosixCntrl}       \ep{XPosixCntrl}          [2]
\&   digit      \ep{PosixDigit}       \ep{XPosixDigit}  \ed
\&   graph      \ep{PosixGraph}       \ep{XPosixGraph}          [3]
\&   lower      \ep{PosixLower}       \ep{XPosixLower}
\&   print      \ep{PosixPrint}       \ep{XPosixPrint}          [4]
\&   punct      \ep{PosixPunct}       \ep{XPosixPunct}          [5]
\&              \ep{PerlSpace}        \ep{XPerlSpace}   \es      [6]
\&   space      \ep{PosixSpace}       \ep{XPosixSpace}          [6]
\&   upper      \ep{PosixUpper}       \ep{XPosixUpper}
\&   word       \ep{PosixWord}        \ep{XPosixWord}   \ew
\&   xdigit     \ep{PosixXDigit}      \ep{XPosixXDigit}
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\f(CW\*(C`\ep{Blank}\*(C'\fR and \f(CW\*(C`\ep{HorizSpace}\*(C'\fR are synonyms.
.IP "[2]" 4
.IX Item "[2]"
Control characters don't produce output as such, but instead usually control
the terminal somehow: for example, newline and backspace are control characters.
In the \s-1ASCII\s0 range, characters whose code points are between 0 and 31 inclusive,
plus 127 (\f(CW\*(C`DEL\*(C'\fR) are control characters.
.IP "[3]" 4
.IX Item "[3]"
Any character that is \fIgraphical\fR, that is, visible. This class consists
of all alphanumeric characters and all punctuation characters.
.IP "[4]" 4
.IX Item "[4]"
All printable characters, which is the set of all graphical characters
plus those whitespace characters which are not also controls.
.IP "[5]" 4
.IX Item "[5]"
\&\f(CW\*(C`\ep{PosixPunct}\*(C'\fR and \f(CW\*(C`[[:punct:]]\*(C'\fR in the \s-1ASCII\s0 range match all
non-controls, non-alphanumeric, non-space characters:
\&\f(CW\*(C`[\-!"#$%&\*(Aq()*+,./:;<=>?@[\e\e\e]^_\`{|}~]\*(C'\fR (although if a locale is in effect,
it could alter the behavior of \f(CW\*(C`[[:punct:]]\*(C'\fR).
.Sp
The similarly named property, \f(CW\*(C`\ep{Punct}\*(C'\fR, matches a somewhat different
set in the \s-1ASCII\s0 range, namely
\&\f(CW\*(C`[\-!"#%&\*(Aq()*,./:;?@[\e\e\e]_{}]\*(C'\fR.  That is, it is missing the nine
characters \f(CW\*(C`[$+<=>^\`|~]\*(C'\fR.
This is because Unicode splits what \s-1POSIX\s0 considers to be punctuation into two
categories, Punctuation and Symbols.
.Sp
\&\f(CW\*(C`\ep{XPosixPunct}\*(C'\fR and (under Unicode rules) \f(CW\*(C`[[:punct:]]\*(C'\fR, match what
\&\f(CW\*(C`\ep{PosixPunct}\*(C'\fR matches in the \s-1ASCII\s0 range, plus what \f(CW\*(C`\ep{Punct}\*(C'\fR
matches.  This is different than strictly matching according to
\&\f(CW\*(C`\ep{Punct}\*(C'\fR.  Another way to say it is that
if Unicode rules are in effect, \f(CW\*(C`[[:punct:]]\*(C'\fR matches all characters
that Unicode considers punctuation, plus all ASCII-range characters that
Unicode considers symbols.
.IP "[6]" 4
.IX Item "[6]"
\&\f(CW\*(C`\ep{SpacePerl}\*(C'\fR and \f(CW\*(C`\ep{Space}\*(C'\fR match identically starting with Perl
v5.18.  In earlier versions, these differ only in that in non-locale
matching, \f(CW\*(C`\ep{SpacePerl}\*(C'\fR does not match the vertical tab, \f(CW\*(C`\ecK\*(C'\fR.
Same for the two ASCII-only range forms.
.PP
There are various other synonyms that can be used besides the names
listed in the table.  For example, \f(CW\*(C`\ep{PosixAlpha}\*(C'\fR can be written as
\&\f(CW\*(C`\ep{Alpha}\*(C'\fR.  All are listed in
\&\*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops,
plus all characters matched by each ASCII-range property.
.PP
Both the \f(CW\*(C`\ep\*(C'\fR counterparts always assume Unicode rules are in effect.
On \s-1ASCII\s0 platforms, this means they assume that the code points from 128
to 255 are Latin\-1, and that means that using them under locale rules is
unwise unless the locale is guaranteed to be Latin\-1 or \s-1UTF\-8. \s0 In contrast, the
\&\s-1POSIX\s0 character classes are useful under locale rules.  They are
affected by the actual rules in effect, as follows:
.ie n .IP "If the ""/a"" modifier, is in effect ..." 4
.el .IP "If the \f(CW/a\fR modifier, is in effect ..." 4
.IX Item "If the /a modifier, is in effect ..."
Each of the \s-1POSIX\s0 classes matches exactly the same as their ASCII-range
counterparts.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
The \s-1POSIX\s0 class matches the same as its Full-range counterpart.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rules are in effect ..." 4
.IX Item "if locale rules are in effect ..."
.PD
The \s-1POSIX\s0 class matches according to the locale, except that
\&\f(CW\*(C`word\*(C'\fR uses the platform's native underscore character, no matter what
the locale is.
.IP "if Unicode rules are in effect ..." 4
.IX Item "if Unicode rules are in effect ..."
The \s-1POSIX\s0 class matches the same as the Full-range counterpart.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
The \s-1POSIX\s0 class matches the same as the \s-1ASCII\s0 range counterpart.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rules apply are determined as described in
\&\*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
It is proposed to change this behavior in a future release of Perl so that
whether or not Unicode rules are in effect would not change the
behavior:  Outside of locale, the \s-1POSIX\s0 classes
would behave like their ASCII-range counterparts.  If you wish to
comment on this proposal, send email to \f(CW\*(C`perl5\-porters@perl.org\*(C'\fR.
.PP
Negation of \s-1POSIX\s0 character classes
.IX Xref "character class, negation"
.IX Subsection "Negation of POSIX character classes"
.PP
A Perl extension to the \s-1POSIX\s0 character class is the ability to
negate it. This is done by prefixing the class name with a caret (\f(CW\*(C`^\*(C'\fR).
Some examples:
.PP
.Vb 7
\&     POSIX         ASCII\-range     Full\-range  backslash
\&                    Unicode         Unicode    sequence
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& [[:^digit:]]   \eP{PosixDigit}  \eP{XPosixDigit}   \eD
\& [[:^space:]]   \eP{PosixSpace}  \eP{XPosixSpace}
\&                \eP{PerlSpace}   \eP{XPerlSpace}    \eS
\& [[:^word:]]    \eP{PerlWord}    \eP{XPosixWord}    \eW
.Ve
.PP
The backslash sequence can mean either \s-1ASCII\-\s0 or Full-range Unicode,
depending on various factors as described in \*(L"Which character set modifier is in effect?\*(R" in perlre.
.PP
[= =] and [. .]
.IX Subsection "[= =] and [. .]"
.PP
Perl recognizes the \s-1POSIX\s0 character classes \f(CW\*(C`[=class=]\*(C'\fR and
\&\f(CW\*(C`[.class.]\*(C'\fR, but does not (yet?) support them.  Any attempt to use
either construct raises an exception.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 12
\& /[[:digit:]]/            # Matches a character that is a digit.
\& /[01[:lower:]]/          # Matches a character that is either a
\&                          # lowercase letter, or \*(Aq0\*(Aq or \*(Aq1\*(Aq.
\& /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything
\&                          # except the letters \*(Aqa\*(Aq to \*(Aqf\*(Aq and \*(AqA\*(Aq to
\&                          # \*(AqF\*(Aq.  This is because the main character
\&                          # class is composed of two POSIX character
\&                          # classes that are ORed together, one that
\&                          # matches any digit, and the other that
\&                          # matches anything that isn\*(Aqt a hex digit.
\&                          # The OR adds the digits, leaving only the
\&                          # letters \*(Aqa\*(Aq to \*(Aqf\*(Aq and \*(AqA\*(Aq to \*(AqF\*(Aq excluded.
.Ve
.PP
\fIExtended Bracketed Character Classes\fR
.IX Xref "character class set operations"
.IX Subsection "Extended Bracketed Character Classes"
.PP
This is a fancy bracketed character class that can be used for more
readable and less error-prone classes, and to perform set operations,
such as intersection. An example is
.PP
.Vb 1
\& /(?[ \ep{Thai} & \ep{Digit} ])/
.Ve
.PP
This will match all the digit characters that are in the Thai script.
.PP
This is an experimental feature available starting in 5.18, and is
subject to change as we gain field experience with it.  Any attempt to
use it will raise a warning, unless disabled via
.PP
.Vb 1
\& no warnings "experimental::regex_sets";
.Ve
.PP
Comments on this feature are welcome; send email to
\&\f(CW\*(C`perl5\-porters@perl.org\*(C'\fR.
.PP
We can extend the example above:
.PP
.Vb 1
\& /(?[ ( \ep{Thai} + \ep{Lao} ) & \ep{Digit} ])/
.Ve
.PP
This matches digits that are in either the Thai or Laotian scripts.
.PP
Notice the white space in these examples.  This construct always has
the \f(CW\*(C`/x\*(C'\fR modifier turned on.
.PP
The available binary operators are:
.PP
.Vb 10
\& &    intersection
\& +    union
\& |    another name for \*(Aq+\*(Aq, hence means union
\& \-    subtraction (the result matches the set consisting of those
\&      code points matched by the first operand, excluding any that
\&      are also matched by the second operand)
\& ^    symmetric difference (the union minus the intersection).  This
\&      is like an exclusive or, in that the result is the set of code
\&      points that are matched by either, but not both, of the
\&      operands.
.Ve
.PP
There is one unary operator:
.PP
.Vb 1
\& !    complement
.Ve
.PP
All the binary operators left associate, and are of equal precedence.
The unary operator right associates, and has higher precedence.  Use
parentheses to override the default associations.  Some feedback we've
received indicates a desire for intersection to have higher precedence
than union.  This is something that feedback from the field may cause us
to change in future releases; you may want to parenthesize copiously to
avoid such changes affecting your code, until this feature is no longer
considered experimental.
.PP
The main restriction is that everything is a metacharacter.  Thus,
you cannot refer to single characters by doing something like this:
.PP
.Vb 1
\& /(?[ a + b ])/ # Syntax error!
.Ve
.PP
The easiest way to specify an individual typable character is to enclose
it in brackets:
.PP
.Vb 1
\& /(?[ [a] + [b] ])/
.Ve
.PP
(This is the same thing as \f(CW\*(C`[ab]\*(C'\fR.)  You could also have said the
equivalent:
.PP
.Vb 1
\& /(?[[ a b ]])/
.Ve
.PP
(You can, of course, specify single characters by using, \f(CW\*(C`\ex{ }\*(C'\fR,
\&\f(CW\*(C`\eN{ }\*(C'\fR, etc.)
.PP
This last example shows the use of this construct to specify an ordinary
bracketed character class without additional set operations.  Note the
white space within it; \f(CW\*(C`/x\*(C'\fR is turned on even within bracketed
character classes, except you can't have comments inside them.  Hence,
.PP
.Vb 1
\& (?[ [#] ])
.Ve
.PP
matches the literal character \*(L"#\*(R".  To specify a literal white space character,
you can escape it with a backslash, like:
.PP
.Vb 1
\& /(?[ [ a e i o u \e  ] ])/
.Ve
.PP
This matches the English vowels plus the \s-1SPACE\s0 character.
All the other escapes accepted by normal bracketed character classes are
accepted here as well; but unrecognized escapes that generate warnings
in normal classes are fatal errors here.
.PP
All warnings from these class elements are fatal, as well as some
practices that don't currently warn.  For example you cannot say
.PP
.Vb 1
\& /(?[ [ \exF ] ])/     # Syntax error!
.Ve
.PP
You have to have two hex digits after a braceless \f(CW\*(C`\ex\*(C'\fR (use a leading
zero to make two).  These restrictions are to lower the incidence of
typos causing the class to not match what you thought it would.
.PP
The final difference between regular bracketed character classes and
these, is that it is not possible to get these to match a
multi-character fold.  Thus,
.PP
.Vb 1
\& /(?[ [\exDF] ])/iu
.Ve
.PP
does not match the string \f(CW\*(C`ss\*(C'\fR.
.PP
You don't have to enclose \s-1POSIX\s0 class names inside double brackets,
hence both of the following work:
.PP
.Vb 2
\& /(?[ [:word:] \- [:lower:] ])/
\& /(?[ [[:word:]] \- [[:lower:]] ])/
.Ve
.PP
Any contained \s-1POSIX\s0 character classes, including things like \f(CW\*(C`\ew\*(C'\fR and \f(CW\*(C`\eD\*(C'\fR
respect the \f(CW\*(C`/a\*(C'\fR (and \f(CW\*(C`/aa\*(C'\fR) modifiers.
.PP
\&\f(CW\*(C`(?[ ])\*(C'\fR is a regex-compile-time construct.  Any attempt to use
something which isn't knowable at the time the containing regular
expression is compiled is a fatal error.  In practice, this means
just three limitiations:
.IP "1." 4
This construct cannot be used within the scope of
\&\f(CW\*(C`use locale\*(C'\fR (or the \f(CW\*(C`/l\*(C'\fR regex modifier).
.IP "2." 4
Any
user-defined property
used must be already defined by the time the regular expression is
compiled (but note that this construct can be used instead of such
properties).
.IP "3." 4
A regular expression that otherwise would compile
using \f(CW\*(C`/d\*(C'\fR rules, and which uses this construct will instead
use \f(CW\*(C`/u\*(C'\fR.  Thus this construct tells Perl that you don't want
\&\f(CW\*(C`/d\*(C'\fR rules for the entire regular expression containing it.
.PP
The \f(CW\*(C`/x\*(C'\fR processing within this class is an extended form.
Besides the characters that are considered white space in normal \f(CW\*(C`/x\*(C'\fR
processing, there are 5 others, recommended by the Unicode standard:
.PP
.Vb 5
\& U+0085 NEXT LINE
\& U+200E LEFT\-TO\-RIGHT MARK
\& U+200F RIGHT\-TO\-LEFT MARK
\& U+2028 LINE SEPARATOR
\& U+2029 PARAGRAPH SEPARATOR
.Ve
.PP
Note that skipping white space applies only to the interior of this
construct.  There must not be any space between any of the characters
that form the initial \f(CW\*(C`(?[\*(C'\fR.  Nor may there be space between the
closing \f(CW\*(C`])\*(C'\fR characters.
.PP
Just as in all regular expressions, the pattern can can be built up by
including variables that are interpolated at regex compilation time.
Care must be taken to ensure that you are getting what you expect.  For
example:
.PP
.Vb 3
\& my $thai_or_lao = \*(Aq\ep{Thai} + \ep{Lao}\*(Aq;
\& ...
\& qr/(?[ \ep{Digit} & $thai_or_lao ])/;
.Ve
.PP
compiles to
.PP
.Vb 1
\& qr/(?[ \ep{Digit} & \ep{Thai} + \ep{Lao} ])/;
.Ve
.PP
But this does not have the effect that someone reading the code would
likely expect, as the intersection applies just to \f(CW\*(C`\ep{Thai}\*(C'\fR,
excluding the Laotian.  Pitfalls like this can be avoided by
parenthesizing the component pieces:
.PP
.Vb 1
\& my $thai_or_lao = \*(Aq( \ep{Thai} + \ep{Lao} )\*(Aq;
.Ve
.PP
But any modifiers will still apply to all the components:
.PP
.Vb 2
\& my $lower = \*(Aq\ep{Lower} + \ep{Digit}\*(Aq;
\& qr/(?[ \ep{Greek} & $lower ])/i;
.Ve
.PP
matches upper case things.  You can avoid surprises by making the
components into instances of this construct by compiling them:
.PP
.Vb 2
\& my $thai_or_lao = qr/(?[ \ep{Thai} + \ep{Lao} ])/;
\& my $lower = qr/(?[ \ep{Lower} + \ep{Digit} ])/;
.Ve
.PP
When these are embedded in another pattern, what they match does not
change, regardless of parenthesization or what modifiers are in effect
in that outer pattern.
.PP
Due to the way that Perl parses things, your parentheses and brackets
may need to be balanced, even including comments.  If you run into any
examples, please send them to \f(CW\*(C`perlbug@perl.org\*(C'\fR, so that we can have a
concrete example for this man page.
.PP
We may change it so that things that remain legal uses in normal bracketed
character classes might become illegal within this experimental
construct.  One proposal, for example, is to forbid adjacent uses of the
same character, as in \f(CW\*(C`(?[ [aa] ])\*(C'\fR.  The motivation for such a change
is that this usage is likely a typo, as the second \*(L"a\*(R" adds nothing.
                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlref.1                                    0100644 0001750 0001750 00000106415 12566207444 022410  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREF 1"
.TH PERLREF 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlref \- Perl references and nested data structures
.IX Xref "reference pointer data structure structure struct"
.SH "NOTE"
.IX Header "NOTE"
This is complete documentation about all aspects of references.
For a shorter, tutorial introduction to just the essential features,
see perlreftut.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Before release 5 of Perl it was difficult to represent complex data
structures, because all references had to be symbolic\*(--and even then
it was difficult to refer to a variable instead of a symbol table entry.
Perl now not only makes it easier to use symbolic references to variables,
but also lets you have \*(L"hard\*(R" references to any piece of data or code.
Any scalar may hold a hard reference.  Because arrays and hashes contain
scalars, you can now easily build arrays of arrays, arrays of hashes,
hashes of arrays, arrays of hashes of functions, and so on.
.PP
Hard references are smart\*(--they keep track of reference counts for you,
automatically freeing the thing referred to when its reference count goes
to zero.  (Reference counts for values in self-referential or
cyclic data structures may not go to zero without a little help; see
\&\*(L"Circular References\*(R" for a detailed explanation.)
If that thing happens to be an object, the object is destructed.  See
perlobj for more about objects.  (In a sense, everything in Perl is an
object, but we usually reserve the word for references to objects that
have been officially \*(L"blessed\*(R" into a class package.)
.PP
Symbolic references are names of variables or other objects, just as a
symbolic link in a Unix filesystem contains merely the name of a file.
The \f(CW*glob\fR notation is something of a symbolic reference.  (Symbolic
references are sometimes called \*(L"soft references\*(R", but please don't call
them that; references are confusing enough without useless synonyms.)
.IX Xref "reference, symbolic reference, soft symbolic reference soft reference"
.PP
In contrast, hard references are more like hard links in a Unix file
system: They are used to access an underlying object without concern for
what its (other) name is.  When the word \*(L"reference\*(R" is used without an
adjective, as in the following paragraph, it is usually talking about a
hard reference.
.IX Xref "reference, hard hard reference"
.PP
References are easy to use in Perl.  There is just one overriding
principle: in general, Perl does no implicit referencing or dereferencing.
When a scalar is holding a reference, it always behaves as a simple scalar.
It doesn't magically start being an array or hash or subroutine; you have to
tell it explicitly to do so, by dereferencing it.
.PP
That said, be aware that Perl version 5.14 introduces an exception
to the rule, for syntactic convenience.  Experimental array and hash container
function behavior allows array and hash references to be handled by Perl as
if they had been explicitly syntactically dereferenced.  See
\&\*(L"Syntactical Enhancements\*(R" in perl5140delta
and perlfunc for details.
.SS "Making References"
.IX Xref "reference, creation referencing"
.IX Subsection "Making References"
References can be created in several ways.
.IP "1." 4
.IX Xref "\\ backslash"
.IX Item "1."
By using the backslash operator on a variable, subroutine, or value.
(This works much like the & (address-of) operator in C.)  
This typically creates \fIanother\fR reference to a variable, because
there's already a reference to the variable in the symbol table.  But
the symbol table reference might go away, and you'll still have the
reference that the backslash returned.  Here are some examples:
.Sp
.Vb 5
\&    $scalarref = \e$foo;
\&    $arrayref  = \e@ARGV;
\&    $hashref   = \e%ENV;
\&    $coderef   = \e&handler;
\&    $globref   = \e*foo;
.Ve
.Sp
It isn't possible to create a true reference to an \s-1IO\s0 handle (filehandle
or dirhandle) using the backslash operator.  The most you can get is a
reference to a typeglob, which is actually a complete symbol table entry.
But see the explanation of the \f(CW*foo{THING}\fR syntax below.  However,
you can still use type globs and globrefs as though they were \s-1IO\s0 handles.
.IP "2." 4
.IX Xref "array, anonymous [ [] square bracket bracket, square arrayref array reference reference, array"
.IX Item "2."
A reference to an anonymous array can be created using square
brackets:
.Sp
.Vb 1
\&    $arrayref = [1, 2, [\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq]];
.Ve
.Sp
Here we've created a reference to an anonymous array of three elements
whose final element is itself a reference to another anonymous array of three
elements.  (The multidimensional syntax described later can be used to
access this.  For example, after the above, \f(CW\*(C`$arrayref\->[2][1]\*(C'\fR would have
the value \*(L"b\*(R".)
.Sp
Taking a reference to an enumerated list is not the same
as using square brackets\*(--instead it's the same as creating
a list of references!
.Sp
.Vb 2
\&    @list = (\e$a, \e@b, \e%c);
\&    @list = \e($a, @b, %c);      # same thing!
.Ve
.Sp
As a special case, \f(CW\*(C`\e(@foo)\*(C'\fR returns a list of references to the contents
of \f(CW@foo\fR, not a reference to \f(CW@foo\fR itself.  Likewise for \f(CW%foo\fR,
except that the key references are to copies (since the keys are just
strings rather than full-fledged scalars).
.IP "3." 4
.IX Xref "hash, anonymous { {} curly bracket bracket, curly brace hashref hash reference reference, hash"
.IX Item "3."
A reference to an anonymous hash can be created using curly
brackets:
.Sp
.Vb 4
\&    $hashref = {
\&        \*(AqAdam\*(Aq  => \*(AqEve\*(Aq,
\&        \*(AqClyde\*(Aq => \*(AqBonnie\*(Aq,
\&    };
.Ve
.Sp
Anonymous hash and array composers like these can be intermixed freely to
produce as complicated a structure as you want.  The multidimensional
syntax described below works for these too.  The values above are
literals, but variables and expressions would work just as well, because
assignment operators in Perl (even within \fIlocal()\fR or \fImy()\fR) are executable
statements, not compile-time declarations.
.Sp
Because curly brackets (braces) are used for several other things
including BLOCKs, you may occasionally have to disambiguate braces at the
beginning of a statement by putting a \f(CW\*(C`+\*(C'\fR or a \f(CW\*(C`return\*(C'\fR in front so
that Perl realizes the opening brace isn't starting a \s-1BLOCK. \s0 The economy and
mnemonic value of using curlies is deemed worth this occasional extra
hassle.
.Sp
For example, if you wanted a function to make a new hash and return a
reference to it, you have these options:
.Sp
.Vb 3
\&    sub hashem {        { @_ } }   # silently wrong
\&    sub hashem {       +{ @_ } }   # ok
\&    sub hashem { return { @_ } }   # ok
.Ve
.Sp
On the other hand, if you want the other meaning, you can do this:
.Sp
.Vb 3
\&    sub showem {        { @_ } }   # ambiguous (currently ok, but may change)
\&    sub showem {       {; @_ } }   # ok
\&    sub showem { { return @_ } }   # ok
.Ve
.Sp
The leading \f(CW\*(C`+{\*(C'\fR and \f(CW\*(C`{;\*(C'\fR always serve to disambiguate
the expression to mean either the \s-1HASH\s0 reference, or the \s-1BLOCK.\s0
.IP "4." 4
.IX Xref "subroutine, anonymous subroutine, reference reference, subroutine scope, lexical closure lexical lexical scope"
.IX Item "4."
A reference to an anonymous subroutine can be created by using
\&\f(CW\*(C`sub\*(C'\fR without a subname:
.Sp
.Vb 1
\&    $coderef = sub { print "Boink!\en" };
.Ve
.Sp
Note the semicolon.  Except for the code
inside not being immediately executed, a \f(CW\*(C`sub {}\*(C'\fR is not so much a
declaration as it is an operator, like \f(CW\*(C`do{}\*(C'\fR or \f(CW\*(C`eval{}\*(C'\fR.  (However, no
matter how many times you execute that particular line (unless you're in an
\&\f(CW\*(C`eval("...")\*(C'\fR), \f(CW$coderef\fR will still have a reference to the \fIsame\fR
anonymous subroutine.)
.Sp
Anonymous subroutines act as closures with respect to \fImy()\fR variables,
that is, variables lexically visible within the current scope.  Closure
is a notion out of the Lisp world that says if you define an anonymous
function in a particular lexical context, it pretends to run in that
context even when it's called outside the context.
.Sp
In human terms, it's a funny way of passing arguments to a subroutine when
you define it as well as when you call it.  It's useful for setting up
little bits of code to run later, such as callbacks.  You can even
do object-oriented stuff with it, though Perl already provides a different
mechanism to do that\*(--see perlobj.
.Sp
You might also think of closure as a way to write a subroutine
template without using \fIeval()\fR.  Here's a small example of how
closures work:
.Sp
.Vb 6
\&    sub newprint {
\&        my $x = shift;
\&        return sub { my $y = shift; print "$x, $y!\en"; };
\&    }
\&    $h = newprint("Howdy");
\&    $g = newprint("Greetings");
\&
\&    # Time passes...
\&
\&    &$h("world");
\&    &$g("earthlings");
.Ve
.Sp
This prints
.Sp
.Vb 2
\&    Howdy, world!
\&    Greetings, earthlings!
.Ve
.Sp
Note particularly that \f(CW$x\fR continues to refer to the value passed
into \fInewprint()\fR \fIdespite\fR \*(L"my \f(CW$x\fR\*(R" having gone out of scope by the
time the anonymous subroutine runs.  That's what a closure is all
about.
.Sp
This applies only to lexical variables, by the way.  Dynamic variables
continue to work as they have always worked.  Closure is not something
that most Perl programmers need trouble themselves about to begin with.
.IP "5." 4
.IX Xref "constructor new"
.IX Item "5."
References are often returned by special subroutines called constructors.  Perl
objects are just references to a special type of object that happens to know
which package it's associated with.  Constructors are just special subroutines
that know how to create that association.  They do so by starting with an
ordinary reference, and it remains an ordinary reference even while it's also
being an object.  Constructors are often named \f(CW\*(C`new()\*(C'\fR.  You \fIcan\fR call them
indirectly:
.Sp
.Vb 1
\&    $objref = new Doggie( Tail => \*(Aqshort\*(Aq, Ears => \*(Aqlong\*(Aq );
.Ve
.Sp
But that can produce ambiguous syntax in certain cases, so it's often
better to use the direct method invocation approach:
.Sp
.Vb 1
\&    $objref   = Doggie\->new(Tail => \*(Aqshort\*(Aq, Ears => \*(Aqlong\*(Aq);
\&
\&    use Term::Cap;
\&    $terminal = Term::Cap\->Tgetent( { OSPEED => 9600 });
\&
\&    use Tk;
\&    $main    = MainWindow\->new();
\&    $menubar = $main\->Frame(\-relief              => "raised",
\&                            \-borderwidth         => 2)
.Ve
.IP "6." 4
.IX Xref "autovivification"
.IX Item "6."
References of the appropriate type can spring into existence if you
dereference them in a context that assumes they exist.  Because we haven't
talked about dereferencing yet, we can't show you any examples yet.
.IP "7." 4
.IX Xref "*foo{THING} *"
.IX Item "7."
A reference can be created by using a special syntax, lovingly known as
the *foo{\s-1THING\s0} syntax.  *foo{\s-1THING\s0} returns a reference to the \s-1THING\s0
slot in *foo (which is the symbol table entry which holds everything
known as foo).
.Sp
.Vb 9
\&    $scalarref = *foo{SCALAR};
\&    $arrayref  = *ARGV{ARRAY};
\&    $hashref   = *ENV{HASH};
\&    $coderef   = *handler{CODE};
\&    $ioref     = *STDIN{IO};
\&    $globref   = *foo{GLOB};
\&    $formatref = *foo{FORMAT};
\&    $globname  = *foo{NAME};    # "foo"
\&    $pkgname   = *foo{PACKAGE}; # "main"
.Ve
.Sp
Most of these are self-explanatory, but \f(CW*foo{IO}\fR
deserves special attention.  It returns
the \s-1IO\s0 handle, used for file handles (\*(L"open\*(R" in perlfunc), sockets
(\*(L"socket\*(R" in perlfunc and \*(L"socketpair\*(R" in perlfunc), and directory
handles (\*(L"opendir\*(R" in perlfunc).  For compatibility with previous
versions of Perl, \f(CW*foo{FILEHANDLE}\fR is a synonym for \f(CW*foo{IO}\fR, though it
is deprecated as of 5.8.0.  If deprecation warnings are in effect, it will warn
of its use.
.Sp
\&\f(CW*foo{THING}\fR returns undef if that particular \s-1THING\s0 hasn't been used yet,
except in the case of scalars.  \f(CW*foo{SCALAR}\fR returns a reference to an
anonymous scalar if \f(CW$foo\fR hasn't been used yet.  This might change in a
future release.
.Sp
\&\f(CW*foo{NAME}\fR and \f(CW*foo{PACKAGE}\fR are the exception, in that they return
strings, rather than references.  These return the package and name of the
typeglob itself, rather than one that has been assigned to it.  So, after
\&\f(CW\*(C`*foo=*Foo::bar\*(C'\fR, \f(CW*foo\fR will become \*(L"*Foo::bar\*(R" when used as a string,
but \f(CW*foo{PACKAGE}\fR and \f(CW*foo{NAME}\fR will continue to produce \*(L"main\*(R" and
\&\*(L"foo\*(R", respectively.
.Sp
\&\f(CW*foo{IO}\fR is an alternative to the \f(CW*HANDLE\fR mechanism given in
\&\*(L"Typeglobs and Filehandles\*(R" in perldata for passing filehandles
into or out of subroutines, or storing into larger data structures.
Its disadvantage is that it won't create a new filehandle for you.
Its advantage is that you have less risk of clobbering more than
you want to with a typeglob assignment.  (It still conflates file
and directory handles, though.)  However, if you assign the incoming
value to a scalar instead of a typeglob as we do in the examples
below, there's no risk of that happening.
.Sp
.Vb 2
\&    splutter(*STDOUT);          # pass the whole glob
\&    splutter(*STDOUT{IO});      # pass both file and dir handles
\&
\&    sub splutter {
\&        my $fh = shift;
\&        print $fh "her um well a hmmm\en";
\&    }
\&
\&    $rec = get_rec(*STDIN);     # pass the whole glob
\&    $rec = get_rec(*STDIN{IO}); # pass both file and dir handles
\&
\&    sub get_rec {
\&        my $fh = shift;
\&        return scalar <$fh>;
\&    }
.Ve
.SS "Using References"
.IX Xref "reference, use dereferencing dereference"
.IX Subsection "Using References"
That's it for creating references.  By now you're probably dying to
know how to use references to get back to your long-lost data.  There
are several basic methods.
.IP "1." 4
Anywhere you'd put an identifier (or chain of identifiers) as part
of a variable or subroutine name, you can replace the identifier with
a simple scalar variable containing a reference of the correct type:
.Sp
.Vb 6
\&    $bar = $$scalarref;
\&    push(@$arrayref, $filename);
\&    $$arrayref[0] = "January";
\&    $$hashref{"KEY"} = "VALUE";
\&    &$coderef(1,2,3);
\&    print $globref "output\en";
.Ve
.Sp
It's important to understand that we are specifically \fInot\fR dereferencing
\&\f(CW$arrayref[0]\fR or \f(CW$hashref{"KEY"}\fR there.  The dereference of the
scalar variable happens \fIbefore\fR it does any key lookups.  Anything more
complicated than a simple scalar variable must use methods 2 or 3 below.
However, a \*(L"simple scalar\*(R" includes an identifier that itself uses method
1 recursively.  Therefore, the following prints \*(L"howdy\*(R".
.Sp
.Vb 2
\&    $refrefref = \e\e\e"howdy";
\&    print $$$$refrefref;
.Ve
.IP "2." 4
Anywhere you'd put an identifier (or chain of identifiers) as part of a
variable or subroutine name, you can replace the identifier with a
\&\s-1BLOCK\s0 returning a reference of the correct type.  In other words, the
previous examples could be written like this:
.Sp
.Vb 6
\&    $bar = ${$scalarref};
\&    push(@{$arrayref}, $filename);
\&    ${$arrayref}[0] = "January";
\&    ${$hashref}{"KEY"} = "VALUE";
\&    &{$coderef}(1,2,3);
\&    $globref\->print("output\en");  # iff IO::Handle is loaded
.Ve
.Sp
Admittedly, it's a little silly to use the curlies in this case, but
the \s-1BLOCK\s0 can contain any arbitrary expression, in particular,
subscripted expressions:
.Sp
.Vb 1
\&    &{ $dispatch{$index} }(1,2,3);      # call correct routine
.Ve
.Sp
Because of being able to omit the curlies for the simple case of \f(CW$$x\fR,
people often make the mistake of viewing the dereferencing symbols as
proper operators, and wonder about their precedence.  If they were,
though, you could use parentheses instead of braces.  That's not the case.
Consider the difference below; case 0 is a short-hand version of case 1,
\&\fInot\fR case 2:
.Sp
.Vb 4
\&    $$hashref{"KEY"}   = "VALUE";       # CASE 0
\&    ${$hashref}{"KEY"} = "VALUE";       # CASE 1
\&    ${$hashref{"KEY"}} = "VALUE";       # CASE 2
\&    ${$hashref\->{"KEY"}} = "VALUE";     # CASE 3
.Ve
.Sp
Case 2 is also deceptive in that you're accessing a variable
called \f(CW%hashref\fR, not dereferencing through \f(CW$hashref\fR to the hash
it's presumably referencing.  That would be case 3.
.IP "3." 4
Subroutine calls and lookups of individual array elements arise often
enough that it gets cumbersome to use method 2.  As a form of
syntactic sugar, the examples for method 2 may be written:
.Sp
.Vb 3
\&    $arrayref\->[0] = "January";   # Array element
\&    $hashref\->{"KEY"} = "VALUE";  # Hash element
\&    $coderef\->(1,2,3);            # Subroutine call
.Ve
.Sp
The left side of the arrow can be any expression returning a reference,
including a previous dereference.  Note that \f(CW$array[$x]\fR is \fInot\fR the
same thing as \f(CW\*(C`$array\->[$x]\*(C'\fR here:
.Sp
.Vb 1
\&    $array[$x]\->{"foo"}\->[0] = "January";
.Ve
.Sp
This is one of the cases we mentioned earlier in which references could
spring into existence when in an lvalue context.  Before this
statement, \f(CW$array[$x]\fR may have been undefined.  If so, it's
automatically defined with a hash reference so that we can look up
\&\f(CW\*(C`{"foo"}\*(C'\fR in it.  Likewise \f(CW\*(C`$array[$x]\->{"foo"}\*(C'\fR will automatically get
defined with an array reference so that we can look up \f(CW\*(C`[0]\*(C'\fR in it.
This process is called \fIautovivification\fR.
.Sp
One more thing here.  The arrow is optional \fIbetween\fR brackets
subscripts, so you can shrink the above down to
.Sp
.Vb 1
\&    $array[$x]{"foo"}[0] = "January";
.Ve
.Sp
Which, in the degenerate case of using only ordinary arrays, gives you
multidimensional arrays just like C's:
.Sp
.Vb 1
\&    $score[$x][$y][$z] += 42;
.Ve
.Sp
Well, okay, not entirely like C's arrays, actually.  C doesn't know how
to grow its arrays on demand.  Perl does.
.IP "4." 4
If a reference happens to be a reference to an object, then there are
probably methods to access the things referred to, and you should probably
stick to those methods unless you're in the class package that defines the
object's methods.  In other words, be nice, and don't violate the object's
encapsulation without a very good reason.  Perl does not enforce
encapsulation.  We are not totalitarians here.  We do expect some basic
civility though.
.PP
Using a string or number as a reference produces a symbolic reference,
as explained above.  Using a reference as a number produces an
integer representing its storage location in memory.  The only
useful thing to be done with this is to compare two references
numerically to see whether they refer to the same location.
.IX Xref "reference, numeric context"
.PP
.Vb 3
\&    if ($ref1 == $ref2) {  # cheap numeric compare of references
\&        print "refs 1 and 2 refer to the same thing\en";
\&    }
.Ve
.PP
Using a reference as a string produces both its referent's type,
including any package blessing as described in perlobj, as well
as the numeric address expressed in hex.  The \fIref()\fR operator returns
just the type of thing the reference is pointing to, without the
address.  See \*(L"ref\*(R" in perlfunc for details and examples of its use.
.IX Xref "reference, string context"
.PP
The \fIbless()\fR operator may be used to associate the object a reference
points to with a package functioning as an object class.  See perlobj.
.PP
A typeglob may be dereferenced the same way a reference can, because
the dereference syntax always indicates the type of reference desired.
So \f(CW\*(C`${*foo}\*(C'\fR and \f(CW\*(C`${\e$foo}\*(C'\fR both indicate the same scalar variable.
.PP
Here's a trick for interpolating a subroutine call into a string:
.PP
.Vb 1
\&    print "My sub returned @{[mysub(1,2,3)]} that time.\en";
.Ve
.PP
The way it works is that when the \f(CW\*(C`@{...}\*(C'\fR is seen in the double-quoted
string, it's evaluated as a block.  The block creates a reference to an
anonymous array containing the results of the call to \f(CW\*(C`mysub(1,2,3)\*(C'\fR.  So
the whole block returns a reference to an array, which is then
dereferenced by \f(CW\*(C`@{...}\*(C'\fR and stuck into the double-quoted string. This
chicanery is also useful for arbitrary expressions:
.PP
.Vb 1
\&    print "That yields @{[$n + 5]} widgets\en";
.Ve
.PP
Similarly, an expression that returns a reference to a scalar can be
dereferenced via \f(CW\*(C`${...}\*(C'\fR. Thus, the above expression may be written
as:
.PP
.Vb 1
\&    print "That yields ${\e($n + 5)} widgets\en";
.Ve
.SS "Circular References"
.IX Xref "circular reference reference, circular"
.IX Subsection "Circular References"
It is possible to create a \*(L"circular reference\*(R" in Perl, which can lead
to memory leaks. A circular reference occurs when two references
contain a reference to each other, like this:
.PP
.Vb 3
\&    my $foo = {};
\&    my $bar = { foo => $foo };
\&    $foo\->{bar} = $bar;
.Ve
.PP
You can also create a circular reference with a single variable:
.PP
.Vb 2
\&    my $foo;
\&    $foo = \e$foo;
.Ve
.PP
In this case, the reference count for the variables will never reach 0,
and the references will never be garbage-collected. This can lead to
memory leaks.
.PP
Because objects in Perl are implemented as references, it's possible to
have circular references with objects as well. Imagine a TreeNode class
where each node references its parent and child nodes. Any node with a
parent will be part of a circular reference.
.PP
You can break circular references by creating a \*(L"weak reference\*(R". A
weak reference does not increment the reference count for a variable,
which means that the object can go out of scope and be destroyed. You
can weaken a reference with the \f(CW\*(C`weaken\*(C'\fR function exported by the
Scalar::Util module.
.PP
Here's how we can make the first example safer:
.PP
.Vb 1
\&    use Scalar::Util \*(Aqweaken\*(Aq;
\&
\&    my $foo = {};
\&    my $bar = { foo => $foo };
\&    $foo\->{bar} = $bar;
\&
\&    weaken $foo\->{bar};
.Ve
.PP
The reference from \f(CW$foo\fR to \f(CW$bar\fR has been weakened. When the
\&\f(CW$bar\fR variable goes out of scope, it will be garbage-collected. The
next time you look at the value of the \f(CW\*(C`$foo\->{bar}\*(C'\fR key, it will
be \f(CW\*(C`undef\*(C'\fR.
.PP
This action at a distance can be confusing, so you should be careful
with your use of weaken. You should weaken the reference in the
variable that will go out of scope \fIfirst\fR. That way, the longer-lived
variable will contain the expected reference until it goes out of
scope.
.SS "Symbolic references"
.IX Xref "reference, symbolic reference, soft symbolic reference soft reference"
.IX Subsection "Symbolic references"
We said that references spring into existence as necessary if they are
undefined, but we didn't say what happens if a value used as a
reference is already defined, but \fIisn't\fR a hard reference.  If you
use it as a reference, it'll be treated as a symbolic
reference.  That is, the value of the scalar is taken to be the \fIname\fR
of a variable, rather than a direct link to a (possibly) anonymous
value.
.PP
People frequently expect it to work like this.  So it does.
.PP
.Vb 9
\&    $name = "foo";
\&    $$name = 1;                 # Sets $foo
\&    ${$name} = 2;               # Sets $foo
\&    ${$name x 2} = 3;           # Sets $foofoo
\&    $name\->[0] = 4;             # Sets $foo[0]
\&    @$name = ();                # Clears @foo
\&    &$name();                   # Calls &foo()
\&    $pack = "THAT";
\&    ${"${pack}::$name"} = 5;    # Sets $THAT::foo without eval
.Ve
.PP
This is powerful, and slightly dangerous, in that it's possible
to intend (with the utmost sincerity) to use a hard reference, and
accidentally use a symbolic reference instead.  To protect against
that, you can say
.PP
.Vb 1
\&    use strict \*(Aqrefs\*(Aq;
.Ve
.PP
and then only hard references will be allowed for the rest of the enclosing
block.  An inner block may countermand that with
.PP
.Vb 1
\&    no strict \*(Aqrefs\*(Aq;
.Ve
.PP
Only package variables (globals, even if localized) are visible to
symbolic references.  Lexical variables (declared with \fImy()\fR) aren't in
a symbol table, and thus are invisible to this mechanism.  For example:
.PP
.Vb 6
\&    local $value = 10;
\&    $ref = "value";
\&    {
\&        my $value = 20;
\&        print $$ref;
\&    }
.Ve
.PP
This will still print 10, not 20.  Remember that \fIlocal()\fR affects package
variables, which are all \*(L"global\*(R" to the package.
.SS "Not-so-symbolic references"
.IX Subsection "Not-so-symbolic references"
Brackets around a symbolic reference can simply
serve to isolate an identifier or variable name from the rest of an
expression, just as they always have within a string.  For example,
.PP
.Vb 2
\&    $push = "pop on ";
\&    print "${push}over";
.Ve
.PP
has always meant to print \*(L"pop on over\*(R", even though push is
a reserved word.  This is generalized to work the same
without the enclosing double quotes, so that
.PP
.Vb 1
\&    print ${push} . "over";
.Ve
.PP
and even
.PP
.Vb 1
\&    print ${ push } . "over";
.Ve
.PP
will have the same effect.  This
construct is \fInot\fR considered to be a symbolic reference when you're
using strict refs:
.PP
.Vb 3
\&    use strict \*(Aqrefs\*(Aq;
\&    ${ bareword };      # Okay, means $bareword.
\&    ${ "bareword" };    # Error, symbolic reference.
.Ve
.PP
Similarly, because of all the subscripting that is done using single words,
the same rule applies to any bareword that is used for subscripting a hash.
So now, instead of writing
.PP
.Vb 1
\&    $array{ "aaa" }{ "bbb" }{ "ccc" }
.Ve
.PP
you can write just
.PP
.Vb 1
\&    $array{ aaa }{ bbb }{ ccc }
.Ve
.PP
and not worry about whether the subscripts are reserved words.  In the
rare event that you do wish to do something like
.PP
.Vb 1
\&    $array{ shift }
.Ve
.PP
you can force interpretation as a reserved word by adding anything that
makes it more than a bareword:
.PP
.Vb 3
\&    $array{ shift() }
\&    $array{ +shift }
\&    $array{ shift @_ }
.Ve
.PP
The \f(CW\*(C`use warnings\*(C'\fR pragma or the \fB\-w\fR switch will warn you if it
interprets a reserved word as a string.
But it will no longer warn you about using lowercase words, because the
string is effectively quoted.
.SS "Pseudo-hashes: Using an array as a hash"
.IX Xref "pseudo-hash pseudo hash pseudohash"
.IX Subsection "Pseudo-hashes: Using an array as a hash"
Pseudo-hashes have been removed from Perl.  The 'fields' pragma
remains available.
.SS "Function Templates"
.IX Xref "scope, lexical closure lexical lexical scope subroutine, nested sub, nested subroutine, local sub, local"
.IX Subsection "Function Templates"
As explained above, an anonymous function with access to the lexical
variables visible when that function was compiled, creates a closure.  It
retains access to those variables even though it doesn't get run until
later, such as in a signal handler or a Tk callback.
.PP
Using a closure as a function template allows us to generate many functions
that act similarly.  Suppose you wanted functions named after the colors
that generated \s-1HTML\s0 font changes for the various colors:
.PP
.Vb 1
\&    print "Be ", red("careful"), "with that ", green("light");
.Ve
.PP
The \fIred()\fR and \fIgreen()\fR functions would be similar.  To create these,
we'll assign a closure to a typeglob of the name of the function we're
trying to build.
.PP
.Vb 5
\&    @colors = qw(red blue green yellow orange purple violet);
\&    for my $name (@colors) {
\&        no strict \*(Aqrefs\*(Aq;       # allow symbol table manipulation
\&        *$name = *{uc $name} = sub { "<FONT COLOR=\*(Aq$name\*(Aq>@_</FONT>" };
\&    }
.Ve
.PP
Now all those different functions appear to exist independently.  You can
call \fIred()\fR, \s-1\fIRED\s0()\fR, \fIblue()\fR, \s-1\fIBLUE\s0()\fR, \fIgreen()\fR, etc.  This technique saves on
both compile time and memory use, and is less error-prone as well, since
syntax checks happen at compile time.  It's critical that any variables in
the anonymous subroutine be lexicals in order to create a proper closure.
That's the reasons for the \f(CW\*(C`my\*(C'\fR on the loop iteration variable.
.PP
This is one of the only places where giving a prototype to a closure makes
much sense.  If you wanted to impose scalar context on the arguments of
these functions (probably not a wise idea for this particular example),
you could have written it this way instead:
.PP
.Vb 1
\&    *$name = sub ($) { "<FONT COLOR=\*(Aq$name\*(Aq>$_[0]</FONT>" };
.Ve
.PP
However, since prototype checking happens at compile time, the assignment
above happens too late to be of much use.  You could address this by
putting the whole loop of assignments within a \s-1BEGIN\s0 block, forcing it
to occur during compilation.
.PP
Access to lexicals that change over time\*(--like those in the \f(CW\*(C`for\*(C'\fR loop
above, basically aliases to elements from the surrounding lexical scopes\*(--
only works with anonymous subs, not with named subroutines. Generally
said, named subroutines do not nest properly and should only be declared
in the main package scope.
.PP
This is because named subroutines are created at compile time so their
lexical variables get assigned to the parent lexicals from the first
execution of the parent block. If a parent scope is entered a second
time, its lexicals are created again, while the nested subs still
reference the old ones.
.PP
Anonymous subroutines get to capture each time you execute the \f(CW\*(C`sub\*(C'\fR
operator, as they are created on the fly. If you are accustomed to using
nested subroutines in other programming languages with their own private
variables, you'll have to work at it a bit in Perl.  The intuitive coding
of this type of thing incurs mysterious warnings about \*(L"will not stay
shared\*(R" due to the reasons explained above. 
For example, this won't work:
.PP
.Vb 5
\&    sub outer {
\&        my $x = $_[0] + 35;
\&        sub inner { return $x * 19 }   # WRONG
\&        return $x + inner();
\&    }
.Ve
.PP
A work-around is the following:
.PP
.Vb 5
\&    sub outer {
\&        my $x = $_[0] + 35;
\&        local *inner = sub { return $x * 19 };
\&        return $x + inner();
\&    }
.Ve
.PP
Now \fIinner()\fR can only be called from within \fIouter()\fR, because of the
temporary assignments of the anonymous subroutine. But when it does,
it has normal access to the lexical variable \f(CW$x\fR from the scope of
\&\fIouter()\fR at the time outer is invoked.
.PP
This has the interesting effect of creating a function local to another
function, something not normally supported in Perl.
.SH "WARNING"
.IX Xref "reference, string context reference, use as hash key"
.IX Header "WARNING"
You may not (usefully) use a reference as the key to a hash.  It will be
converted into a string:
.PP
.Vb 1
\&    $x{ \e$a } = $a;
.Ve
.PP
If you try to dereference the key, it won't do a hard dereference, and
you won't accomplish what you're attempting.  You might want to do something
more like
.PP
.Vb 2
\&    $r = \e@a;
\&    $x{ $r } = $r;
.Ve
.PP
And then at least you can use the \fIvalues()\fR, which will be
real refs, instead of the \fIkeys()\fR, which won't.
.PP
The standard Tie::RefHash module provides a convenient workaround to this.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Besides the obvious documents, source code can be instructive.
Some pathological examples of the use of references can be found
in the \fIt/op/ref.t\fR regression test in the Perl source directory.
.PP
See also perldsc and perllol for how to use references to create
complex data structures, and perlootut and perlobj
for how to use them to create objects.
                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlref5.16.1                                0100644 0001750 0001750 00000105751 12566207423 022721  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREF 1"
.TH PERLREF 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlref \- Perl references and nested data structures
.IX Xref "reference pointer data structure structure struct"
.SH "NOTE"
.IX Header "NOTE"
This is complete documentation about all aspects of references.
For a shorter, tutorial introduction to just the essential features,
see perlreftut.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Before release 5 of Perl it was difficult to represent complex data
structures, because all references had to be symbolic\*(--and even then
it was difficult to refer to a variable instead of a symbol table entry.
Perl now not only makes it easier to use symbolic references to variables,
but also lets you have \*(L"hard\*(R" references to any piece of data or code.
Any scalar may hold a hard reference.  Because arrays and hashes contain
scalars, you can now easily build arrays of arrays, arrays of hashes,
hashes of arrays, arrays of hashes of functions, and so on.
.PP
Hard references are smart\*(--they keep track of reference counts for you,
automatically freeing the thing referred to when its reference count goes
to zero.  (Reference counts for values in self-referential or
cyclic data structures may not go to zero without a little help; see
\&\*(L"Circular References\*(R" for a detailed explanation.)
If that thing happens to be an object, the object is destructed.  See
perlobj for more about objects.  (In a sense, everything in Perl is an
object, but we usually reserve the word for references to objects that
have been officially \*(L"blessed\*(R" into a class package.)
.PP
Symbolic references are names of variables or other objects, just as a
symbolic link in a Unix filesystem contains merely the name of a file.
The \f(CW*glob\fR notation is something of a symbolic reference.  (Symbolic
references are sometimes called \*(L"soft references\*(R", but please don't call
them that; references are confusing enough without useless synonyms.)
.IX Xref "reference, symbolic reference, soft symbolic reference soft reference"
.PP
In contrast, hard references are more like hard links in a Unix file
system: They are used to access an underlying object without concern for
what its (other) name is.  When the word \*(L"reference\*(R" is used without an
adjective, as in the following paragraph, it is usually talking about a
hard reference.
.IX Xref "reference, hard hard reference"
.PP
References are easy to use in Perl.  There is just one overriding
principle: Perl does no implicit referencing or dereferencing.  When a
scalar is holding a reference, it always behaves as a simple scalar.  It
doesn't magically start being an array or hash or subroutine; you have to
tell it explicitly to do so, by dereferencing it.
.PP
References are easy to use in Perl.  There is just one overriding
principle: in general, Perl does no implicit referencing or dereferencing.
When a scalar is holding a reference, it always behaves as a simple scalar.
It doesn't magically start being an array or hash or subroutine; you have to
tell it explicitly to do so, by dereferencing it.
.PP
That said, be aware that Perl version 5.14 introduces an exception
to the rule, for syntactic convenience.  Experimental array and hash container
function behavior allows array and hash references to be handled by Perl as
if they had been explicitly syntactically dereferenced.  See
\&\*(L"Syntactical Enhancements\*(R" in perl5140delta
and perlfunc for details.
.SS "Making References"
.IX Xref "reference, creation referencing"
.IX Subsection "Making References"
References can be created in several ways.
.IP "1." 4
.IX Xref "\\ backslash"
.IX Item "1."
By using the backslash operator on a variable, subroutine, or value.
(This works much like the & (address-of) operator in C.)  
This typically creates \fIanother\fR reference to a variable, because
there's already a reference to the variable in the symbol table.  But
the symbol table reference might go away, and you'll still have the
reference that the backslash returned.  Here are some examples:
.Sp
.Vb 5
\&    $scalarref = \e$foo;
\&    $arrayref  = \e@ARGV;
\&    $hashref   = \e%ENV;
\&    $coderef   = \e&handler;
\&    $globref   = \e*foo;
.Ve
.Sp
It isn't possible to create a true reference to an \s-1IO\s0 handle (filehandle
or dirhandle) using the backslash operator.  The most you can get is a
reference to a typeglob, which is actually a complete symbol table entry.
But see the explanation of the \f(CW*foo{THING}\fR syntax below.  However,
you can still use type globs and globrefs as though they were \s-1IO\s0 handles.
.IP "2." 4
.IX Xref "array, anonymous [ [] square bracket bracket, square arrayref array reference reference, array"
.IX Item "2."
A reference to an anonymous array can be created using square
brackets:
.Sp
.Vb 1
\&    $arrayref = [1, 2, [\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq]];
.Ve
.Sp
Here we've created a reference to an anonymous array of three elements
whose final element is itself a reference to another anonymous array of three
elements.  (The multidimensional syntax described later can be used to
access this.  For example, after the above, \f(CW\*(C`$arrayref\->[2][1]\*(C'\fR would have
the value \*(L"b\*(R".)
.Sp
Taking a reference to an enumerated list is not the same
as using square brackets\*(--instead it's the same as creating
a list of references!
.Sp
.Vb 2
\&    @list = (\e$a, \e@b, \e%c);
\&    @list = \e($a, @b, %c);      # same thing!
.Ve
.Sp
As a special case, \f(CW\*(C`\e(@foo)\*(C'\fR returns a list of references to the contents
of \f(CW@foo\fR, not a reference to \f(CW@foo\fR itself.  Likewise for \f(CW%foo\fR,
except that the key references are to copies (since the keys are just
strings rather than full-fledged scalars).
.IP "3." 4
.IX Xref "hash, anonymous { {} curly bracket bracket, curly brace hashref hash reference reference, hash"
.IX Item "3."
A reference to an anonymous hash can be created using curly
brackets:
.Sp
.Vb 4
\&    $hashref = {
\&        \*(AqAdam\*(Aq  => \*(AqEve\*(Aq,
\&        \*(AqClyde\*(Aq => \*(AqBonnie\*(Aq,
\&    };
.Ve
.Sp
Anonymous hash and array composers like these can be intermixed freely to
produce as complicated a structure as you want.  The multidimensional
syntax described below works for these too.  The values above are
literals, but variables and expressions would work just as well, because
assignment operators in Perl (even within \fIlocal()\fR or \fImy()\fR) are executable
statements, not compile-time declarations.
.Sp
Because curly brackets (braces) are used for several other things
including BLOCKs, you may occasionally have to disambiguate braces at the
beginning of a statement by putting a \f(CW\*(C`+\*(C'\fR or a \f(CW\*(C`return\*(C'\fR in front so
that Perl realizes the opening brace isn't starting a \s-1BLOCK\s0.  The economy and
mnemonic value of using curlies is deemed worth this occasional extra
hassle.
.Sp
For example, if you wanted a function to make a new hash and return a
reference to it, you have these options:
.Sp
.Vb 3
\&    sub hashem {        { @_ } }   # silently wrong
\&    sub hashem {       +{ @_ } }   # ok
\&    sub hashem { return { @_ } }   # ok
.Ve
.Sp
On the other hand, if you want the other meaning, you can do this:
.Sp
.Vb 3
\&    sub showem {        { @_ } }   # ambiguous (currently ok, but may change)
\&    sub showem {       {; @_ } }   # ok
\&    sub showem { { return @_ } }   # ok
.Ve
.Sp
The leading \f(CW\*(C`+{\*(C'\fR and \f(CW\*(C`{;\*(C'\fR always serve to disambiguate
the expression to mean either the \s-1HASH\s0 reference, or the \s-1BLOCK\s0.
.IP "4." 4
.IX Xref "subroutine, anonymous subroutine, reference reference, subroutine scope, lexical closure lexical lexical scope"
.IX Item "4."
A reference to an anonymous subroutine can be created by using
\&\f(CW\*(C`sub\*(C'\fR without a subname:
.Sp
.Vb 1
\&    $coderef = sub { print "Boink!\en" };
.Ve
.Sp
Note the semicolon.  Except for the code
inside not being immediately executed, a \f(CW\*(C`sub {}\*(C'\fR is not so much a
declaration as it is an operator, like \f(CW\*(C`do{}\*(C'\fR or \f(CW\*(C`eval{}\*(C'\fR.  (However, no
matter how many times you execute that particular line (unless you're in an
\&\f(CW\*(C`eval("...")\*(C'\fR), \f(CW$coderef\fR will still have a reference to the \fIsame\fR
anonymous subroutine.)
.Sp
Anonymous subroutines act as closures with respect to \fImy()\fR variables,
that is, variables lexically visible within the current scope.  Closure
is a notion out of the Lisp world that says if you define an anonymous
function in a particular lexical context, it pretends to run in that
context even when it's called outside the context.
.Sp
In human terms, it's a funny way of passing arguments to a subroutine when
you define it as well as when you call it.  It's useful for setting up
little bits of code to run later, such as callbacks.  You can even
do object-oriented stuff with it, though Perl already provides a different
mechanism to do that\*(--see perlobj.
.Sp
You might also think of closure as a way to write a subroutine
template without using \fIeval()\fR.  Here's a small example of how
closures work:
.Sp
.Vb 6
\&    sub newprint {
\&        my $x = shift;
\&        return sub { my $y = shift; print "$x, $y!\en"; };
\&    }
\&    $h = newprint("Howdy");
\&    $g = newprint("Greetings");
\&
\&    # Time passes...
\&
\&    &$h("world");
\&    &$g("earthlings");
.Ve
.Sp
This prints
.Sp
.Vb 2
\&    Howdy, world!
\&    Greetings, earthlings!
.Ve
.Sp
Note particularly that \f(CW$x\fR continues to refer to the value passed
into \fInewprint()\fR \fIdespite\fR \*(L"my \f(CW$x\fR\*(R" having gone out of scope by the
time the anonymous subroutine runs.  That's what a closure is all
about.
.Sp
This applies only to lexical variables, by the way.  Dynamic variables
continue to work as they have always worked.  Closure is not something
that most Perl programmers need trouble themselves about to begin with.
.IP "5." 4
.IX Xref "constructor new"
.IX Item "5."
References are often returned by special subroutines called constructors.  Perl
objects are just references to a special type of object that happens to know
which package it's associated with.  Constructors are just special subroutines
that know how to create that association.  They do so by starting with an
ordinary reference, and it remains an ordinary reference even while it's also
being an object.  Constructors are often named \f(CW\*(C`new()\*(C'\fR.  You \fIcan\fR call them
indirectly:
.Sp
.Vb 1
\&    $objref = new Doggie( Tail => \*(Aqshort\*(Aq, Ears => \*(Aqlong\*(Aq );
.Ve
.Sp
But that can produce ambiguous syntax in certain cases, so it's often
better to use the direct method invocation approach:
.Sp
.Vb 1
\&    $objref   = Doggie\->new(Tail => \*(Aqshort\*(Aq, Ears => \*(Aqlong\*(Aq);
\&
\&    use Term::Cap;
\&    $terminal = Term::Cap\->Tgetent( { OSPEED => 9600 });
\&
\&    use Tk;
\&    $main    = MainWindow\->new();
\&    $menubar = $main\->Frame(\-relief              => "raised",
\&                            \-borderwidth         => 2)
.Ve
.IP "6." 4
.IX Xref "autovivification"
.IX Item "6."
References of the appropriate type can spring into existence if you
dereference them in a context that assumes they exist.  Because we haven't
talked about dereferencing yet, we can't show you any examples yet.
.IP "7." 4
.IX Xref "*foo{THING} *"
.IX Item "7."
A reference can be created by using a special syntax, lovingly known as
the *foo{\s-1THING\s0} syntax.  *foo{\s-1THING\s0} returns a reference to the \s-1THING\s0
slot in *foo (which is the symbol table entry which holds everything
known as foo).
.Sp
.Vb 7
\&    $scalarref = *foo{SCALAR};
\&    $arrayref  = *ARGV{ARRAY};
\&    $hashref   = *ENV{HASH};
\&    $coderef   = *handler{CODE};
\&    $ioref     = *STDIN{IO};
\&    $globref   = *foo{GLOB};
\&    $formatref = *foo{FORMAT};
.Ve
.Sp
All of these are self-explanatory except for \f(CW*foo{IO}\fR.  It returns
the \s-1IO\s0 handle, used for file handles (\*(L"open\*(R" in perlfunc), sockets
(\*(L"socket\*(R" in perlfunc and \*(L"socketpair\*(R" in perlfunc), and directory
handles (\*(L"opendir\*(R" in perlfunc).  For compatibility with previous
versions of Perl, \f(CW*foo{FILEHANDLE}\fR is a synonym for \f(CW*foo{IO}\fR, though it
is deprecated as of 5.8.0.  If deprecation warnings are in effect, it will warn
of its use.
.Sp
\&\f(CW*foo{THING}\fR returns undef if that particular \s-1THING\s0 hasn't been used yet,
except in the case of scalars.  \f(CW*foo{SCALAR}\fR returns a reference to an
anonymous scalar if \f(CW$foo\fR hasn't been used yet.  This might change in a
future release.
.Sp
\&\f(CW*foo{IO}\fR is an alternative to the \f(CW*HANDLE\fR mechanism given in
\&\*(L"Typeglobs and Filehandles\*(R" in perldata for passing filehandles
into or out of subroutines, or storing into larger data structures.
Its disadvantage is that it won't create a new filehandle for you.
Its advantage is that you have less risk of clobbering more than
you want to with a typeglob assignment.  (It still conflates file
and directory handles, though.)  However, if you assign the incoming
value to a scalar instead of a typeglob as we do in the examples
below, there's no risk of that happening.
.Sp
.Vb 2
\&    splutter(*STDOUT);          # pass the whole glob
\&    splutter(*STDOUT{IO});      # pass both file and dir handles
\&
\&    sub splutter {
\&        my $fh = shift;
\&        print $fh "her um well a hmmm\en";
\&    }
\&
\&    $rec = get_rec(*STDIN);     # pass the whole glob
\&    $rec = get_rec(*STDIN{IO}); # pass both file and dir handles
\&
\&    sub get_rec {
\&        my $fh = shift;
\&        return scalar <$fh>;
\&    }
.Ve
.SS "Using References"
.IX Xref "reference, use dereferencing dereference"
.IX Subsection "Using References"
That's it for creating references.  By now you're probably dying to
know how to use references to get back to your long-lost data.  There
are several basic methods.
.IP "1." 4
Anywhere you'd put an identifier (or chain of identifiers) as part
of a variable or subroutine name, you can replace the identifier with
a simple scalar variable containing a reference of the correct type:
.Sp
.Vb 6
\&    $bar = $$scalarref;
\&    push(@$arrayref, $filename);
\&    $$arrayref[0] = "January";
\&    $$hashref{"KEY"} = "VALUE";
\&    &$coderef(1,2,3);
\&    print $globref "output\en";
.Ve
.Sp
It's important to understand that we are specifically \fInot\fR dereferencing
\&\f(CW$arrayref[0]\fR or \f(CW$hashref{"KEY"}\fR there.  The dereference of the
scalar variable happens \fIbefore\fR it does any key lookups.  Anything more
complicated than a simple scalar variable must use methods 2 or 3 below.
However, a \*(L"simple scalar\*(R" includes an identifier that itself uses method
1 recursively.  Therefore, the following prints \*(L"howdy\*(R".
.Sp
.Vb 2
\&    $refrefref = \e\e\e"howdy";
\&    print $$$$refrefref;
.Ve
.IP "2." 4
Anywhere you'd put an identifier (or chain of identifiers) as part of a
variable or subroutine name, you can replace the identifier with a
\&\s-1BLOCK\s0 returning a reference of the correct type.  In other words, the
previous examples could be written like this:
.Sp
.Vb 6
\&    $bar = ${$scalarref};
\&    push(@{$arrayref}, $filename);
\&    ${$arrayref}[0] = "January";
\&    ${$hashref}{"KEY"} = "VALUE";
\&    &{$coderef}(1,2,3);
\&    $globref\->print("output\en");  # iff IO::Handle is loaded
.Ve
.Sp
Admittedly, it's a little silly to use the curlies in this case, but
the \s-1BLOCK\s0 can contain any arbitrary expression, in particular,
subscripted expressions:
.Sp
.Vb 1
\&    &{ $dispatch{$index} }(1,2,3);      # call correct routine
.Ve
.Sp
Because of being able to omit the curlies for the simple case of \f(CW$$x\fR,
people often make the mistake of viewing the dereferencing symbols as
proper operators, and wonder about their precedence.  If they were,
though, you could use parentheses instead of braces.  That's not the case.
Consider the difference below; case 0 is a short-hand version of case 1,
\&\fInot\fR case 2:
.Sp
.Vb 4
\&    $$hashref{"KEY"}   = "VALUE";       # CASE 0
\&    ${$hashref}{"KEY"} = "VALUE";       # CASE 1
\&    ${$hashref{"KEY"}} = "VALUE";       # CASE 2
\&    ${$hashref\->{"KEY"}} = "VALUE";     # CASE 3
.Ve
.Sp
Case 2 is also deceptive in that you're accessing a variable
called \f(CW%hashref\fR, not dereferencing through \f(CW$hashref\fR to the hash
it's presumably referencing.  That would be case 3.
.IP "3." 4
Subroutine calls and lookups of individual array elements arise often
enough that it gets cumbersome to use method 2.  As a form of
syntactic sugar, the examples for method 2 may be written:
.Sp
.Vb 3
\&    $arrayref\->[0] = "January";   # Array element
\&    $hashref\->{"KEY"} = "VALUE";  # Hash element
\&    $coderef\->(1,2,3);            # Subroutine call
.Ve
.Sp
The left side of the arrow can be any expression returning a reference,
including a previous dereference.  Note that \f(CW$array[$x]\fR is \fInot\fR the
same thing as \f(CW\*(C`$array\->[$x]\*(C'\fR here:
.Sp
.Vb 1
\&    $array[$x]\->{"foo"}\->[0] = "January";
.Ve
.Sp
This is one of the cases we mentioned earlier in which references could
spring into existence when in an lvalue context.  Before this
statement, \f(CW$array[$x]\fR may have been undefined.  If so, it's
automatically defined with a hash reference so that we can look up
\&\f(CW\*(C`{"foo"}\*(C'\fR in it.  Likewise \f(CW\*(C`$array[$x]\->{"foo"}\*(C'\fR will automatically get
defined with an array reference so that we can look up \f(CW\*(C`[0]\*(C'\fR in it.
This process is called \fIautovivification\fR.
.Sp
One more thing here.  The arrow is optional \fIbetween\fR brackets
subscripts, so you can shrink the above down to
.Sp
.Vb 1
\&    $array[$x]{"foo"}[0] = "January";
.Ve
.Sp
Which, in the degenerate case of using only ordinary arrays, gives you
multidimensional arrays just like C's:
.Sp
.Vb 1
\&    $score[$x][$y][$z] += 42;
.Ve
.Sp
Well, okay, not entirely like C's arrays, actually.  C doesn't know how
to grow its arrays on demand.  Perl does.
.IP "4." 4
If a reference happens to be a reference to an object, then there are
probably methods to access the things referred to, and you should probably
stick to those methods unless you're in the class package that defines the
object's methods.  In other words, be nice, and don't violate the object's
encapsulation without a very good reason.  Perl does not enforce
encapsulation.  We are not totalitarians here.  We do expect some basic
civility though.
.PP
Using a string or number as a reference produces a symbolic reference,
as explained above.  Using a reference as a number produces an
integer representing its storage location in memory.  The only
useful thing to be done with this is to compare two references
numerically to see whether they refer to the same location.
.IX Xref "reference, numeric context"
.PP
.Vb 3
\&    if ($ref1 == $ref2) {  # cheap numeric compare of references
\&        print "refs 1 and 2 refer to the same thing\en";
\&    }
.Ve
.PP
Using a reference as a string produces both its referent's type,
including any package blessing as described in perlobj, as well
as the numeric address expressed in hex.  The \fIref()\fR operator returns
just the type of thing the reference is pointing to, without the
address.  See \*(L"ref\*(R" in perlfunc for details and examples of its use.
.IX Xref "reference, string context"
.PP
The \fIbless()\fR operator may be used to associate the object a reference
points to with a package functioning as an object class.  See perlobj.
.PP
A typeglob may be dereferenced the same way a reference can, because
the dereference syntax always indicates the type of reference desired.
So \f(CW\*(C`${*foo}\*(C'\fR and \f(CW\*(C`${\e$foo}\*(C'\fR both indicate the same scalar variable.
.PP
Here's a trick for interpolating a subroutine call into a string:
.PP
.Vb 1
\&    print "My sub returned @{[mysub(1,2,3)]} that time.\en";
.Ve
.PP
The way it works is that when the \f(CW\*(C`@{...}\*(C'\fR is seen in the double-quoted
string, it's evaluated as a block.  The block creates a reference to an
anonymous array containing the results of the call to \f(CW\*(C`mysub(1,2,3)\*(C'\fR.  So
the whole block returns a reference to an array, which is then
dereferenced by \f(CW\*(C`@{...}\*(C'\fR and stuck into the double-quoted string. This
chicanery is also useful for arbitrary expressions:
.PP
.Vb 1
\&    print "That yields @{[$n + 5]} widgets\en";
.Ve
.PP
Similarly, an expression that returns a reference to a scalar can be
dereferenced via \f(CW\*(C`${...}\*(C'\fR. Thus, the above expression may be written
as:
.PP
.Vb 1
\&    print "That yields ${\e($n + 5)} widgets\en";
.Ve
.SS "Circular References"
.IX Xref "circular reference reference, circular"
.IX Subsection "Circular References"
It is possible to create a \*(L"circular reference\*(R" in Perl, which can lead
to memory leaks. A circular reference occurs when two references
contain a reference to each other, like this:
.PP
.Vb 3
\&    my $foo = {};
\&    my $bar = { foo => $foo };
\&    $foo\->{bar} = $bar;
.Ve
.PP
You can also create a circular reference with a single variable:
.PP
.Vb 2
\&    my $foo;
\&    $foo = \e$foo;
.Ve
.PP
In this case, the reference count for the variables will never reach 0,
and the references will never be garbage-collected. This can lead to
memory leaks.
.PP
Because objects in Perl are implemented as references, it's possible to
have circular references with objects as well. Imagine a TreeNode class
where each node references its parent and child nodes. Any node with a
parent will be part of a circular reference.
.PP
You can break circular references by creating a \*(L"weak reference\*(R". A
weak reference does not increment the reference count for a variable,
which means that the object can go out of scope and be destroyed. You
can weaken a reference with the \f(CW\*(C`weaken\*(C'\fR function exported by the
Scalar::Util module.
.PP
Here's how we can make the first example safer:
.PP
.Vb 1
\&    use Scalar::Util \*(Aqweaken\*(Aq;
\&
\&    my $foo = {};
\&    my $bar = { foo => $foo };
\&    $foo\->{bar} = $bar;
\&
\&    weaken $foo\->{bar};
.Ve
.PP
The reference from \f(CW$foo\fR to \f(CW$bar\fR has been weakened. When the
\&\f(CW$bar\fR variable goes out of scope, it will be garbage-collected. The
next time you look at the value of the \f(CW\*(C`$foo\->{bar}\*(C'\fR key, it will
be \f(CW\*(C`undef\*(C'\fR.
.PP
This action at a distance can be confusing, so you should be careful
with your use of weaken. You should weaken the reference in the
variable that will go out of scope \fIfirst\fR. That way, the longer-lived
variable will contain the expected reference until it goes out of
scope.
.SS "Symbolic references"
.IX Xref "reference, symbolic reference, soft symbolic reference soft reference"
.IX Subsection "Symbolic references"
We said that references spring into existence as necessary if they are
undefined, but we didn't say what happens if a value used as a
reference is already defined, but \fIisn't\fR a hard reference.  If you
use it as a reference, it'll be treated as a symbolic
reference.  That is, the value of the scalar is taken to be the \fIname\fR
of a variable, rather than a direct link to a (possibly) anonymous
value.
.PP
People frequently expect it to work like this.  So it does.
.PP
.Vb 9
\&    $name = "foo";
\&    $$name = 1;                 # Sets $foo
\&    ${$name} = 2;               # Sets $foo
\&    ${$name x 2} = 3;           # Sets $foofoo
\&    $name\->[0] = 4;             # Sets $foo[0]
\&    @$name = ();                # Clears @foo
\&    &$name();                   # Calls &foo() (as in Perl 4)
\&    $pack = "THAT";
\&    ${"${pack}::$name"} = 5;    # Sets $THAT::foo without eval
.Ve
.PP
This is powerful, and slightly dangerous, in that it's possible
to intend (with the utmost sincerity) to use a hard reference, and
accidentally use a symbolic reference instead.  To protect against
that, you can say
.PP
.Vb 1
\&    use strict \*(Aqrefs\*(Aq;
.Ve
.PP
and then only hard references will be allowed for the rest of the enclosing
block.  An inner block may countermand that with
.PP
.Vb 1
\&    no strict \*(Aqrefs\*(Aq;
.Ve
.PP
Only package variables (globals, even if localized) are visible to
symbolic references.  Lexical variables (declared with \fImy()\fR) aren't in
a symbol table, and thus are invisible to this mechanism.  For example:
.PP
.Vb 6
\&    local $value = 10;
\&    $ref = "value";
\&    {
\&        my $value = 20;
\&        print $$ref;
\&    }
.Ve
.PP
This will still print 10, not 20.  Remember that \fIlocal()\fR affects package
variables, which are all \*(L"global\*(R" to the package.
.SS "Not-so-symbolic references"
.IX Subsection "Not-so-symbolic references"
Since Perl verion 5.001, brackets around a symbolic reference can simply
serve to isolate an identifier or variable name from the rest of an
expression, just as they always have within a string.  For example,
.PP
.Vb 2
\&    $push = "pop on ";
\&    print "${push}over";
.Ve
.PP
has always meant to print \*(L"pop on over\*(R", even though push is
a reserved word.  In 5.001, this was generalized to work the same
without the enclosing double quotes, so that
.PP
.Vb 1
\&    print ${push} . "over";
.Ve
.PP
and even
.PP
.Vb 1
\&    print ${ push } . "over";
.Ve
.PP
will have the same effect.  (This would have been a syntax error in
Perl 5.000, though Perl 4 allowed it in the spaceless form.)  This
construct is \fInot\fR considered to be a symbolic reference when you're
using strict refs:
.PP
.Vb 3
\&    use strict \*(Aqrefs\*(Aq;
\&    ${ bareword };      # Okay, means $bareword.
\&    ${ "bareword" };    # Error, symbolic reference.
.Ve
.PP
Similarly, because of all the subscripting that is done using single words,
the same rule applies to any bareword that is used for subscripting a hash.
So now, instead of writing
.PP
.Vb 1
\&    $array{ "aaa" }{ "bbb" }{ "ccc" }
.Ve
.PP
you can write just
.PP
.Vb 1
\&    $array{ aaa }{ bbb }{ ccc }
.Ve
.PP
and not worry about whether the subscripts are reserved words.  In the
rare event that you do wish to do something like
.PP
.Vb 1
\&    $array{ shift }
.Ve
.PP
you can force interpretation as a reserved word by adding anything that
makes it more than a bareword:
.PP
.Vb 3
\&    $array{ shift() }
\&    $array{ +shift }
\&    $array{ shift @_ }
.Ve
.PP
The \f(CW\*(C`use warnings\*(C'\fR pragma or the \fB\-w\fR switch will warn you if it
interprets a reserved word as a string.
But it will no longer warn you about using lowercase words, because the
string is effectively quoted.
.SS "Pseudo-hashes: Using an array as a hash"
.IX Xref "pseudo-hash pseudo hash pseudohash"
.IX Subsection "Pseudo-hashes: Using an array as a hash"
Pseudo-hashes have been removed from Perl.  The 'fields' pragma
remains available.
.SS "Function Templates"
.IX Xref "scope, lexical closure lexical lexical scope subroutine, nested sub, nested subroutine, local sub, local"
.IX Subsection "Function Templates"
As explained above, an anonymous function with access to the lexical
variables visible when that function was compiled, creates a closure.  It
retains access to those variables even though it doesn't get run until
later, such as in a signal handler or a Tk callback.
.PP
Using a closure as a function template allows us to generate many functions
that act similarly.  Suppose you wanted functions named after the colors
that generated \s-1HTML\s0 font changes for the various colors:
.PP
.Vb 1
\&    print "Be ", red("careful"), "with that ", green("light");
.Ve
.PP
The \fIred()\fR and \fIgreen()\fR functions would be similar.  To create these,
we'll assign a closure to a typeglob of the name of the function we're
trying to build.
.PP
.Vb 5
\&    @colors = qw(red blue green yellow orange purple violet);
\&    for my $name (@colors) {
\&        no strict \*(Aqrefs\*(Aq;       # allow symbol table manipulation
\&        *$name = *{uc $name} = sub { "<FONT COLOR=\*(Aq$name\*(Aq>@_</FONT>" };
\&    }
.Ve
.PP
Now all those different functions appear to exist independently.  You can
call \fIred()\fR, \s-1\fIRED\s0()\fR, \fIblue()\fR, \s-1\fIBLUE\s0()\fR, \fIgreen()\fR, etc.  This technique saves on
both compile time and memory use, and is less error-prone as well, since
syntax checks happen at compile time.  It's critical that any variables in
the anonymous subroutine be lexicals in order to create a proper closure.
That's the reasons for the \f(CW\*(C`my\*(C'\fR on the loop iteration variable.
.PP
This is one of the only places where giving a prototype to a closure makes
much sense.  If you wanted to impose scalar context on the arguments of
these functions (probably not a wise idea for this particular example),
you could have written it this way instead:
.PP
.Vb 1
\&    *$name = sub ($) { "<FONT COLOR=\*(Aq$name\*(Aq>$_[0]</FONT>" };
.Ve
.PP
However, since prototype checking happens at compile time, the assignment
above happens too late to be of much use.  You could address this by
putting the whole loop of assignments within a \s-1BEGIN\s0 block, forcing it
to occur during compilation.
.PP
Access to lexicals that change over time\*(--like those in the \f(CW\*(C`for\*(C'\fR loop
above, basically aliases to elements from the surrounding lexical scopes\*(--
only works with anonymous subs, not with named subroutines. Generally
said, named subroutines do not nest properly and should only be declared
in the main package scope.
.PP
This is because named subroutines are created at compile time so their
lexical variables get assigned to the parent lexicals from the first
execution of the parent block. If a parent scope is entered a second
time, its lexicals are created again, while the nested subs still
reference the old ones.
.PP
Anonymous subroutines get to capture each time you execute the \f(CW\*(C`sub\*(C'\fR
operator, as they are created on the fly. If you are accustomed to using
nested subroutines in other programming languages with their own private
variables, you'll have to work at it a bit in Perl.  The intuitive coding
of this type of thing incurs mysterious warnings about \*(L"will not stay
shared\*(R" due to the reasons explained above. 
For example, this won't work:
.PP
.Vb 5
\&    sub outer {
\&        my $x = $_[0] + 35;
\&        sub inner { return $x * 19 }   # WRONG
\&        return $x + inner();
\&    }
.Ve
.PP
A work-around is the following:
.PP
.Vb 5
\&    sub outer {
\&        my $x = $_[0] + 35;
\&        local *inner = sub { return $x * 19 };
\&        return $x + inner();
\&    }
.Ve
.PP
Now \fIinner()\fR can only be called from within \fIouter()\fR, because of the
temporary assignments of the anonymous subroutine. But when it does,
it has normal access to the lexical variable \f(CW$x\fR from the scope of
\&\fIouter()\fR at the time outer is invoked.
.PP
This has the interesting effect of creating a function local to another
function, something not normally supported in Perl.
.SH "WARNING"
.IX Xref "reference, string context reference, use as hash key"
.IX Header "WARNING"
You may not (usefully) use a reference as the key to a hash.  It will be
converted into a string:
.PP
.Vb 1
\&    $x{ \e$a } = $a;
.Ve
.PP
If you try to dereference the key, it won't do a hard dereference, and
you won't accomplish what you're attempting.  You might want to do something
more like
.PP
.Vb 2
\&    $r = \e@a;
\&    $x{ $r } = $r;
.Ve
.PP
And then at least you can use the \fIvalues()\fR, which will be
real refs, instead of the \fIkeys()\fR, which won't.
.PP
The standard Tie::RefHash module provides a convenient workaround to this.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Besides the obvious documents, source code can be instructive.
Some pathological examples of the use of references can be found
in the \fIt/op/ref.t\fR regression test in the Perl source directory.
.PP
See also perldsc and perllol for how to use references to create
complex data structures, and perlootut and perlobj
for how to use them to create objects.
                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlref5.18.1                                0100644 0001750 0001750 00000106415 12566207444 022724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREF 1"
.TH PERLREF 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlref \- Perl references and nested data structures
.IX Xref "reference pointer data structure structure struct"
.SH "NOTE"
.IX Header "NOTE"
This is complete documentation about all aspects of references.
For a shorter, tutorial introduction to just the essential features,
see perlreftut.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Before release 5 of Perl it was difficult to represent complex data
structures, because all references had to be symbolic\*(--and even then
it was difficult to refer to a variable instead of a symbol table entry.
Perl now not only makes it easier to use symbolic references to variables,
but also lets you have \*(L"hard\*(R" references to any piece of data or code.
Any scalar may hold a hard reference.  Because arrays and hashes contain
scalars, you can now easily build arrays of arrays, arrays of hashes,
hashes of arrays, arrays of hashes of functions, and so on.
.PP
Hard references are smart\*(--they keep track of reference counts for you,
automatically freeing the thing referred to when its reference count goes
to zero.  (Reference counts for values in self-referential or
cyclic data structures may not go to zero without a little help; see
\&\*(L"Circular References\*(R" for a detailed explanation.)
If that thing happens to be an object, the object is destructed.  See
perlobj for more about objects.  (In a sense, everything in Perl is an
object, but we usually reserve the word for references to objects that
have been officially \*(L"blessed\*(R" into a class package.)
.PP
Symbolic references are names of variables or other objects, just as a
symbolic link in a Unix filesystem contains merely the name of a file.
The \f(CW*glob\fR notation is something of a symbolic reference.  (Symbolic
references are sometimes called \*(L"soft references\*(R", but please don't call
them that; references are confusing enough without useless synonyms.)
.IX Xref "reference, symbolic reference, soft symbolic reference soft reference"
.PP
In contrast, hard references are more like hard links in a Unix file
system: They are used to access an underlying object without concern for
what its (other) name is.  When the word \*(L"reference\*(R" is used without an
adjective, as in the following paragraph, it is usually talking about a
hard reference.
.IX Xref "reference, hard hard reference"
.PP
References are easy to use in Perl.  There is just one overriding
principle: in general, Perl does no implicit referencing or dereferencing.
When a scalar is holding a reference, it always behaves as a simple scalar.
It doesn't magically start being an array or hash or subroutine; you have to
tell it explicitly to do so, by dereferencing it.
.PP
That said, be aware that Perl version 5.14 introduces an exception
to the rule, for syntactic convenience.  Experimental array and hash container
function behavior allows array and hash references to be handled by Perl as
if they had been explicitly syntactically dereferenced.  See
\&\*(L"Syntactical Enhancements\*(R" in perl5140delta
and perlfunc for details.
.SS "Making References"
.IX Xref "reference, creation referencing"
.IX Subsection "Making References"
References can be created in several ways.
.IP "1." 4
.IX Xref "\\ backslash"
.IX Item "1."
By using the backslash operator on a variable, subroutine, or value.
(This works much like the & (address-of) operator in C.)  
This typically creates \fIanother\fR reference to a variable, because
there's already a reference to the variable in the symbol table.  But
the symbol table reference might go away, and you'll still have the
reference that the backslash returned.  Here are some examples:
.Sp
.Vb 5
\&    $scalarref = \e$foo;
\&    $arrayref  = \e@ARGV;
\&    $hashref   = \e%ENV;
\&    $coderef   = \e&handler;
\&    $globref   = \e*foo;
.Ve
.Sp
It isn't possible to create a true reference to an \s-1IO\s0 handle (filehandle
or dirhandle) using the backslash operator.  The most you can get is a
reference to a typeglob, which is actually a complete symbol table entry.
But see the explanation of the \f(CW*foo{THING}\fR syntax below.  However,
you can still use type globs and globrefs as though they were \s-1IO\s0 handles.
.IP "2." 4
.IX Xref "array, anonymous [ [] square bracket bracket, square arrayref array reference reference, array"
.IX Item "2."
A reference to an anonymous array can be created using square
brackets:
.Sp
.Vb 1
\&    $arrayref = [1, 2, [\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq]];
.Ve
.Sp
Here we've created a reference to an anonymous array of three elements
whose final element is itself a reference to another anonymous array of three
elements.  (The multidimensional syntax described later can be used to
access this.  For example, after the above, \f(CW\*(C`$arrayref\->[2][1]\*(C'\fR would have
the value \*(L"b\*(R".)
.Sp
Taking a reference to an enumerated list is not the same
as using square brackets\*(--instead it's the same as creating
a list of references!
.Sp
.Vb 2
\&    @list = (\e$a, \e@b, \e%c);
\&    @list = \e($a, @b, %c);      # same thing!
.Ve
.Sp
As a special case, \f(CW\*(C`\e(@foo)\*(C'\fR returns a list of references to the contents
of \f(CW@foo\fR, not a reference to \f(CW@foo\fR itself.  Likewise for \f(CW%foo\fR,
except that the key references are to copies (since the keys are just
strings rather than full-fledged scalars).
.IP "3." 4
.IX Xref "hash, anonymous { {} curly bracket bracket, curly brace hashref hash reference reference, hash"
.IX Item "3."
A reference to an anonymous hash can be created using curly
brackets:
.Sp
.Vb 4
\&    $hashref = {
\&        \*(AqAdam\*(Aq  => \*(AqEve\*(Aq,
\&        \*(AqClyde\*(Aq => \*(AqBonnie\*(Aq,
\&    };
.Ve
.Sp
Anonymous hash and array composers like these can be intermixed freely to
produce as complicated a structure as you want.  The multidimensional
syntax described below works for these too.  The values above are
literals, but variables and expressions would work just as well, because
assignment operators in Perl (even within \fIlocal()\fR or \fImy()\fR) are executable
statements, not compile-time declarations.
.Sp
Because curly brackets (braces) are used for several other things
including BLOCKs, you may occasionally have to disambiguate braces at the
beginning of a statement by putting a \f(CW\*(C`+\*(C'\fR or a \f(CW\*(C`return\*(C'\fR in front so
that Perl realizes the opening brace isn't starting a \s-1BLOCK. \s0 The economy and
mnemonic value of using curlies is deemed worth this occasional extra
hassle.
.Sp
For example, if you wanted a function to make a new hash and return a
reference to it, you have these options:
.Sp
.Vb 3
\&    sub hashem {        { @_ } }   # silently wrong
\&    sub hashem {       +{ @_ } }   # ok
\&    sub hashem { return { @_ } }   # ok
.Ve
.Sp
On the other hand, if you want the other meaning, you can do this:
.Sp
.Vb 3
\&    sub showem {        { @_ } }   # ambiguous (currently ok, but may change)
\&    sub showem {       {; @_ } }   # ok
\&    sub showem { { return @_ } }   # ok
.Ve
.Sp
The leading \f(CW\*(C`+{\*(C'\fR and \f(CW\*(C`{;\*(C'\fR always serve to disambiguate
the expression to mean either the \s-1HASH\s0 reference, or the \s-1BLOCK.\s0
.IP "4." 4
.IX Xref "subroutine, anonymous subroutine, reference reference, subroutine scope, lexical closure lexical lexical scope"
.IX Item "4."
A reference to an anonymous subroutine can be created by using
\&\f(CW\*(C`sub\*(C'\fR without a subname:
.Sp
.Vb 1
\&    $coderef = sub { print "Boink!\en" };
.Ve
.Sp
Note the semicolon.  Except for the code
inside not being immediately executed, a \f(CW\*(C`sub {}\*(C'\fR is not so much a
declaration as it is an operator, like \f(CW\*(C`do{}\*(C'\fR or \f(CW\*(C`eval{}\*(C'\fR.  (However, no
matter how many times you execute that particular line (unless you're in an
\&\f(CW\*(C`eval("...")\*(C'\fR), \f(CW$coderef\fR will still have a reference to the \fIsame\fR
anonymous subroutine.)
.Sp
Anonymous subroutines act as closures with respect to \fImy()\fR variables,
that is, variables lexically visible within the current scope.  Closure
is a notion out of the Lisp world that says if you define an anonymous
function in a particular lexical context, it pretends to run in that
context even when it's called outside the context.
.Sp
In human terms, it's a funny way of passing arguments to a subroutine when
you define it as well as when you call it.  It's useful for setting up
little bits of code to run later, such as callbacks.  You can even
do object-oriented stuff with it, though Perl already provides a different
mechanism to do that\*(--see perlobj.
.Sp
You might also think of closure as a way to write a subroutine
template without using \fIeval()\fR.  Here's a small example of how
closures work:
.Sp
.Vb 6
\&    sub newprint {
\&        my $x = shift;
\&        return sub { my $y = shift; print "$x, $y!\en"; };
\&    }
\&    $h = newprint("Howdy");
\&    $g = newprint("Greetings");
\&
\&    # Time passes...
\&
\&    &$h("world");
\&    &$g("earthlings");
.Ve
.Sp
This prints
.Sp
.Vb 2
\&    Howdy, world!
\&    Greetings, earthlings!
.Ve
.Sp
Note particularly that \f(CW$x\fR continues to refer to the value passed
into \fInewprint()\fR \fIdespite\fR \*(L"my \f(CW$x\fR\*(R" having gone out of scope by the
time the anonymous subroutine runs.  That's what a closure is all
about.
.Sp
This applies only to lexical variables, by the way.  Dynamic variables
continue to work as they have always worked.  Closure is not something
that most Perl programmers need trouble themselves about to begin with.
.IP "5." 4
.IX Xref "constructor new"
.IX Item "5."
References are often returned by special subroutines called constructors.  Perl
objects are just references to a special type of object that happens to know
which package it's associated with.  Constructors are just special subroutines
that know how to create that association.  They do so by starting with an
ordinary reference, and it remains an ordinary reference even while it's also
being an object.  Constructors are often named \f(CW\*(C`new()\*(C'\fR.  You \fIcan\fR call them
indirectly:
.Sp
.Vb 1
\&    $objref = new Doggie( Tail => \*(Aqshort\*(Aq, Ears => \*(Aqlong\*(Aq );
.Ve
.Sp
But that can produce ambiguous syntax in certain cases, so it's often
better to use the direct method invocation approach:
.Sp
.Vb 1
\&    $objref   = Doggie\->new(Tail => \*(Aqshort\*(Aq, Ears => \*(Aqlong\*(Aq);
\&
\&    use Term::Cap;
\&    $terminal = Term::Cap\->Tgetent( { OSPEED => 9600 });
\&
\&    use Tk;
\&    $main    = MainWindow\->new();
\&    $menubar = $main\->Frame(\-relief              => "raised",
\&                            \-borderwidth         => 2)
.Ve
.IP "6." 4
.IX Xref "autovivification"
.IX Item "6."
References of the appropriate type can spring into existence if you
dereference them in a context that assumes they exist.  Because we haven't
talked about dereferencing yet, we can't show you any examples yet.
.IP "7." 4
.IX Xref "*foo{THING} *"
.IX Item "7."
A reference can be created by using a special syntax, lovingly known as
the *foo{\s-1THING\s0} syntax.  *foo{\s-1THING\s0} returns a reference to the \s-1THING\s0
slot in *foo (which is the symbol table entry which holds everything
known as foo).
.Sp
.Vb 9
\&    $scalarref = *foo{SCALAR};
\&    $arrayref  = *ARGV{ARRAY};
\&    $hashref   = *ENV{HASH};
\&    $coderef   = *handler{CODE};
\&    $ioref     = *STDIN{IO};
\&    $globref   = *foo{GLOB};
\&    $formatref = *foo{FORMAT};
\&    $globname  = *foo{NAME};    # "foo"
\&    $pkgname   = *foo{PACKAGE}; # "main"
.Ve
.Sp
Most of these are self-explanatory, but \f(CW*foo{IO}\fR
deserves special attention.  It returns
the \s-1IO\s0 handle, used for file handles (\*(L"open\*(R" in perlfunc), sockets
(\*(L"socket\*(R" in perlfunc and \*(L"socketpair\*(R" in perlfunc), and directory
handles (\*(L"opendir\*(R" in perlfunc).  For compatibility with previous
versions of Perl, \f(CW*foo{FILEHANDLE}\fR is a synonym for \f(CW*foo{IO}\fR, though it
is deprecated as of 5.8.0.  If deprecation warnings are in effect, it will warn
of its use.
.Sp
\&\f(CW*foo{THING}\fR returns undef if that particular \s-1THING\s0 hasn't been used yet,
except in the case of scalars.  \f(CW*foo{SCALAR}\fR returns a reference to an
anonymous scalar if \f(CW$foo\fR hasn't been used yet.  This might change in a
future release.
.Sp
\&\f(CW*foo{NAME}\fR and \f(CW*foo{PACKAGE}\fR are the exception, in that they return
strings, rather than references.  These return the package and name of the
typeglob itself, rather than one that has been assigned to it.  So, after
\&\f(CW\*(C`*foo=*Foo::bar\*(C'\fR, \f(CW*foo\fR will become \*(L"*Foo::bar\*(R" when used as a string,
but \f(CW*foo{PACKAGE}\fR and \f(CW*foo{NAME}\fR will continue to produce \*(L"main\*(R" and
\&\*(L"foo\*(R", respectively.
.Sp
\&\f(CW*foo{IO}\fR is an alternative to the \f(CW*HANDLE\fR mechanism given in
\&\*(L"Typeglobs and Filehandles\*(R" in perldata for passing filehandles
into or out of subroutines, or storing into larger data structures.
Its disadvantage is that it won't create a new filehandle for you.
Its advantage is that you have less risk of clobbering more than
you want to with a typeglob assignment.  (It still conflates file
and directory handles, though.)  However, if you assign the incoming
value to a scalar instead of a typeglob as we do in the examples
below, there's no risk of that happening.
.Sp
.Vb 2
\&    splutter(*STDOUT);          # pass the whole glob
\&    splutter(*STDOUT{IO});      # pass both file and dir handles
\&
\&    sub splutter {
\&        my $fh = shift;
\&        print $fh "her um well a hmmm\en";
\&    }
\&
\&    $rec = get_rec(*STDIN);     # pass the whole glob
\&    $rec = get_rec(*STDIN{IO}); # pass both file and dir handles
\&
\&    sub get_rec {
\&        my $fh = shift;
\&        return scalar <$fh>;
\&    }
.Ve
.SS "Using References"
.IX Xref "reference, use dereferencing dereference"
.IX Subsection "Using References"
That's it for creating references.  By now you're probably dying to
know how to use references to get back to your long-lost data.  There
are several basic methods.
.IP "1." 4
Anywhere you'd put an identifier (or chain of identifiers) as part
of a variable or subroutine name, you can replace the identifier with
a simple scalar variable containing a reference of the correct type:
.Sp
.Vb 6
\&    $bar = $$scalarref;
\&    push(@$arrayref, $filename);
\&    $$arrayref[0] = "January";
\&    $$hashref{"KEY"} = "VALUE";
\&    &$coderef(1,2,3);
\&    print $globref "output\en";
.Ve
.Sp
It's important to understand that we are specifically \fInot\fR dereferencing
\&\f(CW$arrayref[0]\fR or \f(CW$hashref{"KEY"}\fR there.  The dereference of the
scalar variable happens \fIbefore\fR it does any key lookups.  Anything more
complicated than a simple scalar variable must use methods 2 or 3 below.
However, a \*(L"simple scalar\*(R" includes an identifier that itself uses method
1 recursively.  Therefore, the following prints \*(L"howdy\*(R".
.Sp
.Vb 2
\&    $refrefref = \e\e\e"howdy";
\&    print $$$$refrefref;
.Ve
.IP "2." 4
Anywhere you'd put an identifier (or chain of identifiers) as part of a
variable or subroutine name, you can replace the identifier with a
\&\s-1BLOCK\s0 returning a reference of the correct type.  In other words, the
previous examples could be written like this:
.Sp
.Vb 6
\&    $bar = ${$scalarref};
\&    push(@{$arrayref}, $filename);
\&    ${$arrayref}[0] = "January";
\&    ${$hashref}{"KEY"} = "VALUE";
\&    &{$coderef}(1,2,3);
\&    $globref\->print("output\en");  # iff IO::Handle is loaded
.Ve
.Sp
Admittedly, it's a little silly to use the curlies in this case, but
the \s-1BLOCK\s0 can contain any arbitrary expression, in particular,
subscripted expressions:
.Sp
.Vb 1
\&    &{ $dispatch{$index} }(1,2,3);      # call correct routine
.Ve
.Sp
Because of being able to omit the curlies for the simple case of \f(CW$$x\fR,
people often make the mistake of viewing the dereferencing symbols as
proper operators, and wonder about their precedence.  If they were,
though, you could use parentheses instead of braces.  That's not the case.
Consider the difference below; case 0 is a short-hand version of case 1,
\&\fInot\fR case 2:
.Sp
.Vb 4
\&    $$hashref{"KEY"}   = "VALUE";       # CASE 0
\&    ${$hashref}{"KEY"} = "VALUE";       # CASE 1
\&    ${$hashref{"KEY"}} = "VALUE";       # CASE 2
\&    ${$hashref\->{"KEY"}} = "VALUE";     # CASE 3
.Ve
.Sp
Case 2 is also deceptive in that you're accessing a variable
called \f(CW%hashref\fR, not dereferencing through \f(CW$hashref\fR to the hash
it's presumably referencing.  That would be case 3.
.IP "3." 4
Subroutine calls and lookups of individual array elements arise often
enough that it gets cumbersome to use method 2.  As a form of
syntactic sugar, the examples for method 2 may be written:
.Sp
.Vb 3
\&    $arrayref\->[0] = "January";   # Array element
\&    $hashref\->{"KEY"} = "VALUE";  # Hash element
\&    $coderef\->(1,2,3);            # Subroutine call
.Ve
.Sp
The left side of the arrow can be any expression returning a reference,
including a previous dereference.  Note that \f(CW$array[$x]\fR is \fInot\fR the
same thing as \f(CW\*(C`$array\->[$x]\*(C'\fR here:
.Sp
.Vb 1
\&    $array[$x]\->{"foo"}\->[0] = "January";
.Ve
.Sp
This is one of the cases we mentioned earlier in which references could
spring into existence when in an lvalue context.  Before this
statement, \f(CW$array[$x]\fR may have been undefined.  If so, it's
automatically defined with a hash reference so that we can look up
\&\f(CW\*(C`{"foo"}\*(C'\fR in it.  Likewise \f(CW\*(C`$array[$x]\->{"foo"}\*(C'\fR will automatically get
defined with an array reference so that we can look up \f(CW\*(C`[0]\*(C'\fR in it.
This process is called \fIautovivification\fR.
.Sp
One more thing here.  The arrow is optional \fIbetween\fR brackets
subscripts, so you can shrink the above down to
.Sp
.Vb 1
\&    $array[$x]{"foo"}[0] = "January";
.Ve
.Sp
Which, in the degenerate case of using only ordinary arrays, gives you
multidimensional arrays just like C's:
.Sp
.Vb 1
\&    $score[$x][$y][$z] += 42;
.Ve
.Sp
Well, okay, not entirely like C's arrays, actually.  C doesn't know how
to grow its arrays on demand.  Perl does.
.IP "4." 4
If a reference happens to be a reference to an object, then there are
probably methods to access the things referred to, and you should probably
stick to those methods unless you're in the class package that defines the
object's methods.  In other words, be nice, and don't violate the object's
encapsulation without a very good reason.  Perl does not enforce
encapsulation.  We are not totalitarians here.  We do expect some basic
civility though.
.PP
Using a string or number as a reference produces a symbolic reference,
as explained above.  Using a reference as a number produces an
integer representing its storage location in memory.  The only
useful thing to be done with this is to compare two references
numerically to see whether they refer to the same location.
.IX Xref "reference, numeric context"
.PP
.Vb 3
\&    if ($ref1 == $ref2) {  # cheap numeric compare of references
\&        print "refs 1 and 2 refer to the same thing\en";
\&    }
.Ve
.PP
Using a reference as a string produces both its referent's type,
including any package blessing as described in perlobj, as well
as the numeric address expressed in hex.  The \fIref()\fR operator returns
just the type of thing the reference is pointing to, without the
address.  See \*(L"ref\*(R" in perlfunc for details and examples of its use.
.IX Xref "reference, string context"
.PP
The \fIbless()\fR operator may be used to associate the object a reference
points to with a package functioning as an object class.  See perlobj.
.PP
A typeglob may be dereferenced the same way a reference can, because
the dereference syntax always indicates the type of reference desired.
So \f(CW\*(C`${*foo}\*(C'\fR and \f(CW\*(C`${\e$foo}\*(C'\fR both indicate the same scalar variable.
.PP
Here's a trick for interpolating a subroutine call into a string:
.PP
.Vb 1
\&    print "My sub returned @{[mysub(1,2,3)]} that time.\en";
.Ve
.PP
The way it works is that when the \f(CW\*(C`@{...}\*(C'\fR is seen in the double-quoted
string, it's evaluated as a block.  The block creates a reference to an
anonymous array containing the results of the call to \f(CW\*(C`mysub(1,2,3)\*(C'\fR.  So
the whole block returns a reference to an array, which is then
dereferenced by \f(CW\*(C`@{...}\*(C'\fR and stuck into the double-quoted string. This
chicanery is also useful for arbitrary expressions:
.PP
.Vb 1
\&    print "That yields @{[$n + 5]} widgets\en";
.Ve
.PP
Similarly, an expression that returns a reference to a scalar can be
dereferenced via \f(CW\*(C`${...}\*(C'\fR. Thus, the above expression may be written
as:
.PP
.Vb 1
\&    print "That yields ${\e($n + 5)} widgets\en";
.Ve
.SS "Circular References"
.IX Xref "circular reference reference, circular"
.IX Subsection "Circular References"
It is possible to create a \*(L"circular reference\*(R" in Perl, which can lead
to memory leaks. A circular reference occurs when two references
contain a reference to each other, like this:
.PP
.Vb 3
\&    my $foo = {};
\&    my $bar = { foo => $foo };
\&    $foo\->{bar} = $bar;
.Ve
.PP
You can also create a circular reference with a single variable:
.PP
.Vb 2
\&    my $foo;
\&    $foo = \e$foo;
.Ve
.PP
In this case, the reference count for the variables will never reach 0,
and the references will never be garbage-collected. This can lead to
memory leaks.
.PP
Because objects in Perl are implemented as references, it's possible to
have circular references with objects as well. Imagine a TreeNode class
where each node references its parent and child nodes. Any node with a
parent will be part of a circular reference.
.PP
You can break circular references by creating a \*(L"weak reference\*(R". A
weak reference does not increment the reference count for a variable,
which means that the object can go out of scope and be destroyed. You
can weaken a reference with the \f(CW\*(C`weaken\*(C'\fR function exported by the
Scalar::Util module.
.PP
Here's how we can make the first example safer:
.PP
.Vb 1
\&    use Scalar::Util \*(Aqweaken\*(Aq;
\&
\&    my $foo = {};
\&    my $bar = { foo => $foo };
\&    $foo\->{bar} = $bar;
\&
\&    weaken $foo\->{bar};
.Ve
.PP
The reference from \f(CW$foo\fR to \f(CW$bar\fR has been weakened. When the
\&\f(CW$bar\fR variable goes out of scope, it will be garbage-collected. The
next time you look at the value of the \f(CW\*(C`$foo\->{bar}\*(C'\fR key, it will
be \f(CW\*(C`undef\*(C'\fR.
.PP
This action at a distance can be confusing, so you should be careful
with your use of weaken. You should weaken the reference in the
variable that will go out of scope \fIfirst\fR. That way, the longer-lived
variable will contain the expected reference until it goes out of
scope.
.SS "Symbolic references"
.IX Xref "reference, symbolic reference, soft symbolic reference soft reference"
.IX Subsection "Symbolic references"
We said that references spring into existence as necessary if they are
undefined, but we didn't say what happens if a value used as a
reference is already defined, but \fIisn't\fR a hard reference.  If you
use it as a reference, it'll be treated as a symbolic
reference.  That is, the value of the scalar is taken to be the \fIname\fR
of a variable, rather than a direct link to a (possibly) anonymous
value.
.PP
People frequently expect it to work like this.  So it does.
.PP
.Vb 9
\&    $name = "foo";
\&    $$name = 1;                 # Sets $foo
\&    ${$name} = 2;               # Sets $foo
\&    ${$name x 2} = 3;           # Sets $foofoo
\&    $name\->[0] = 4;             # Sets $foo[0]
\&    @$name = ();                # Clears @foo
\&    &$name();                   # Calls &foo()
\&    $pack = "THAT";
\&    ${"${pack}::$name"} = 5;    # Sets $THAT::foo without eval
.Ve
.PP
This is powerful, and slightly dangerous, in that it's possible
to intend (with the utmost sincerity) to use a hard reference, and
accidentally use a symbolic reference instead.  To protect against
that, you can say
.PP
.Vb 1
\&    use strict \*(Aqrefs\*(Aq;
.Ve
.PP
and then only hard references will be allowed for the rest of the enclosing
block.  An inner block may countermand that with
.PP
.Vb 1
\&    no strict \*(Aqrefs\*(Aq;
.Ve
.PP
Only package variables (globals, even if localized) are visible to
symbolic references.  Lexical variables (declared with \fImy()\fR) aren't in
a symbol table, and thus are invisible to this mechanism.  For example:
.PP
.Vb 6
\&    local $value = 10;
\&    $ref = "value";
\&    {
\&        my $value = 20;
\&        print $$ref;
\&    }
.Ve
.PP
This will still print 10, not 20.  Remember that \fIlocal()\fR affects package
variables, which are all \*(L"global\*(R" to the package.
.SS "Not-so-symbolic references"
.IX Subsection "Not-so-symbolic references"
Brackets around a symbolic reference can simply
serve to isolate an identifier or variable name from the rest of an
expression, just as they always have within a string.  For example,
.PP
.Vb 2
\&    $push = "pop on ";
\&    print "${push}over";
.Ve
.PP
has always meant to print \*(L"pop on over\*(R", even though push is
a reserved word.  This is generalized to work the same
without the enclosing double quotes, so that
.PP
.Vb 1
\&    print ${push} . "over";
.Ve
.PP
and even
.PP
.Vb 1
\&    print ${ push } . "over";
.Ve
.PP
will have the same effect.  This
construct is \fInot\fR considered to be a symbolic reference when you're
using strict refs:
.PP
.Vb 3
\&    use strict \*(Aqrefs\*(Aq;
\&    ${ bareword };      # Okay, means $bareword.
\&    ${ "bareword" };    # Error, symbolic reference.
.Ve
.PP
Similarly, because of all the subscripting that is done using single words,
the same rule applies to any bareword that is used for subscripting a hash.
So now, instead of writing
.PP
.Vb 1
\&    $array{ "aaa" }{ "bbb" }{ "ccc" }
.Ve
.PP
you can write just
.PP
.Vb 1
\&    $array{ aaa }{ bbb }{ ccc }
.Ve
.PP
and not worry about whether the subscripts are reserved words.  In the
rare event that you do wish to do something like
.PP
.Vb 1
\&    $array{ shift }
.Ve
.PP
you can force interpretation as a reserved word by adding anything that
makes it more than a bareword:
.PP
.Vb 3
\&    $array{ shift() }
\&    $array{ +shift }
\&    $array{ shift @_ }
.Ve
.PP
The \f(CW\*(C`use warnings\*(C'\fR pragma or the \fB\-w\fR switch will warn you if it
interprets a reserved word as a string.
But it will no longer warn you about using lowercase words, because the
string is effectively quoted.
.SS "Pseudo-hashes: Using an array as a hash"
.IX Xref "pseudo-hash pseudo hash pseudohash"
.IX Subsection "Pseudo-hashes: Using an array as a hash"
Pseudo-hashes have been removed from Perl.  The 'fields' pragma
remains available.
.SS "Function Templates"
.IX Xref "scope, lexical closure lexical lexical scope subroutine, nested sub, nested subroutine, local sub, local"
.IX Subsection "Function Templates"
As explained above, an anonymous function with access to the lexical
variables visible when that function was compiled, creates a closure.  It
retains access to those variables even though it doesn't get run until
later, such as in a signal handler or a Tk callback.
.PP
Using a closure as a function template allows us to generate many functions
that act similarly.  Suppose you wanted functions named after the colors
that generated \s-1HTML\s0 font changes for the various colors:
.PP
.Vb 1
\&    print "Be ", red("careful"), "with that ", green("light");
.Ve
.PP
The \fIred()\fR and \fIgreen()\fR functions would be similar.  To create these,
we'll assign a closure to a typeglob of the name of the function we're
trying to build.
.PP
.Vb 5
\&    @colors = qw(red blue green yellow orange purple violet);
\&    for my $name (@colors) {
\&        no strict \*(Aqrefs\*(Aq;       # allow symbol table manipulation
\&        *$name = *{uc $name} = sub { "<FONT COLOR=\*(Aq$name\*(Aq>@_</FONT>" };
\&    }
.Ve
.PP
Now all those different functions appear to exist independently.  You can
call \fIred()\fR, \s-1\fIRED\s0()\fR, \fIblue()\fR, \s-1\fIBLUE\s0()\fR, \fIgreen()\fR, etc.  This technique saves on
both compile time and memory use, and is less error-prone as well, since
syntax checks happen at compile time.  It's critical that any variables in
the anonymous subroutine be lexicals in order to create a proper closure.
That's the reasons for the \f(CW\*(C`my\*(C'\fR on the loop iteration variable.
.PP
This is one of the only places where giving a prototype to a closure makes
much sense.  If you wanted to impose scalar context on the arguments of
these functions (probably not a wise idea for this particular example),
you could have written it this way instead:
.PP
.Vb 1
\&    *$name = sub ($) { "<FONT COLOR=\*(Aq$name\*(Aq>$_[0]</FONT>" };
.Ve
.PP
However, since prototype checking happens at compile time, the assignment
above happens too late to be of much use.  You could address this by
putting the whole loop of assignments within a \s-1BEGIN\s0 block, forcing it
to occur during compilation.
.PP
Access to lexicals that change over time\*(--like those in the \f(CW\*(C`for\*(C'\fR loop
above, basically aliases to elements from the surrounding lexical scopes\*(--
only works with anonymous subs, not with named subroutines. Generally
said, named subroutines do not nest properly and should only be declared
in the main package scope.
.PP
This is because named subroutines are created at compile time so their
lexical variables get assigned to the parent lexicals from the first
execution of the parent block. If a parent scope is entered a second
time, its lexicals are created again, while the nested subs still
reference the old ones.
.PP
Anonymous subroutines get to capture each time you execute the \f(CW\*(C`sub\*(C'\fR
operator, as they are created on the fly. If you are accustomed to using
nested subroutines in other programming languages with their own private
variables, you'll have to work at it a bit in Perl.  The intuitive coding
of this type of thing incurs mysterious warnings about \*(L"will not stay
shared\*(R" due to the reasons explained above. 
For example, this won't work:
.PP
.Vb 5
\&    sub outer {
\&        my $x = $_[0] + 35;
\&        sub inner { return $x * 19 }   # WRONG
\&        return $x + inner();
\&    }
.Ve
.PP
A work-around is the following:
.PP
.Vb 5
\&    sub outer {
\&        my $x = $_[0] + 35;
\&        local *inner = sub { return $x * 19 };
\&        return $x + inner();
\&    }
.Ve
.PP
Now \fIinner()\fR can only be called from within \fIouter()\fR, because of the
temporary assignments of the anonymous subroutine. But when it does,
it has normal access to the lexical variable \f(CW$x\fR from the scope of
\&\fIouter()\fR at the time outer is invoked.
.PP
This has the interesting effect of creating a function local to another
function, something not normally supported in Perl.
.SH "WARNING"
.IX Xref "reference, string context reference, use as hash key"
.IX Header "WARNING"
You may not (usefully) use a reference as the key to a hash.  It will be
converted into a string:
.PP
.Vb 1
\&    $x{ \e$a } = $a;
.Ve
.PP
If you try to dereference the key, it won't do a hard dereference, and
you won't accomplish what you're attempting.  You might want to do something
more like
.PP
.Vb 2
\&    $r = \e@a;
\&    $x{ $r } = $r;
.Ve
.PP
And then at least you can use the \fIvalues()\fR, which will be
real refs, instead of the \fIkeys()\fR, which won't.
.PP
The standard Tie::RefHash module provides a convenient workaround to this.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Besides the obvious documents, source code can be instructive.
Some pathological examples of the use of references can be found
in the \fIt/op/ref.t\fR regression test in the Perl source directory.
.PP
See also perldsc and perllol for how to use references to create
complex data structures, and perlootut and perlobj
for how to use them to create objects.
                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreftut.1                                 0100644 0001750 0001750 00000061246 12566207444 023147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREFTUT 1"
.TH PERLREFTUT 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreftut \- Mark's very short tutorial about references
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
One of the most important new features in Perl 5 was the capability to
manage complicated data structures like multidimensional arrays and
nested hashes.  To enable these, Perl 5 introduced a feature called
\&'references', and using references is the key to managing complicated,
structured data in Perl.  Unfortunately, there's a lot of funny syntax
to learn, and the main manual page can be hard to follow.  The manual
is quite complete, and sometimes people find that a problem, because
it can be hard to tell what is important and what isn't.
.PP
Fortunately, you only need to know 10% of what's in the main page to get
90% of the benefit.  This page will show you that 10%.
.SH "Who Needs Complicated Data Structures?"
.IX Header "Who Needs Complicated Data Structures?"
One problem that comes up all the time is needing a hash whose values are
lists.  Perl has hashes, of course, but the values have to be scalars;
they can't be lists.
.PP
Why would you want a hash of lists?  Let's take a simple example: You
have a file of city and country names, like this:
.PP
.Vb 6
\&        Chicago, USA
\&        Frankfurt, Germany
\&        Berlin, Germany
\&        Washington, USA
\&        Helsinki, Finland
\&        New York, USA
.Ve
.PP
and you want to produce an output like this, with each country mentioned
once, and then an alphabetical list of the cities in that country:
.PP
.Vb 3
\&        Finland: Helsinki.
\&        Germany: Berlin, Frankfurt.
\&        USA:  Chicago, New York, Washington.
.Ve
.PP
The natural way to do this is to have a hash whose keys are country
names.  Associated with each country name key is a list of the cities in
that country.  Each time you read a line of input, split it into a country
and a city, look up the list of cities already known to be in that
country, and append the new city to the list.  When you're done reading
the input, iterate over the hash as usual, sorting each list of cities
before you print it out.
.PP
If hash values couldn't be lists, you lose.  You'd probably have to
combine all the cities into a single string somehow, and then when
time came to write the output, you'd have to break the string into a
list, sort the list, and turn it back into a string.  This is messy
and error-prone.  And it's frustrating, because Perl already has
perfectly good lists that would solve the problem if only you could
use them.
.SH "The Solution"
.IX Header "The Solution"
By the time Perl 5 rolled around, we were already stuck with this
design: Hash values must be scalars.  The solution to this is
references.
.PP
A reference is a scalar value that \fIrefers to\fR an entire array or an
entire hash (or to just about anything else).  Names are one kind of
reference that you're already familiar with.  Think of the President
of the United States: a messy, inconvenient bag of blood and bones.
But to talk about him, or to represent him in a computer program, all
you need is the easy, convenient scalar string \*(L"Barack Obama\*(R".
.PP
References in Perl are like names for arrays and hashes.  They're
Perl's private, internal names, so you can be sure they're
unambiguous.  Unlike \*(L"Barack Obama\*(R", a reference only refers to one
thing, and you always know what it refers to.  If you have a reference
to an array, you can recover the entire array from it.  If you have a
reference to a hash, you can recover the entire hash.  But the
reference is still an easy, compact scalar value.
.PP
You can't have a hash whose values are arrays; hash values can only be
scalars.  We're stuck with that.  But a single reference can refer to
an entire array, and references are scalars, so you can have a hash of
references to arrays, and it'll act a lot like a hash of arrays, and
it'll be just as useful as a hash of arrays.
.PP
We'll come back to this city-country problem later, after we've seen
some syntax for managing references.
.SH "Syntax"
.IX Header "Syntax"
There are just two ways to make a reference, and just two ways to use
it once you have it.
.SS "Making References"
.IX Subsection "Making References"
\fI\f(BIMake Rule 1\fI\fR
.IX Subsection "Make Rule 1"
.PP
If you put a \f(CW\*(C`\e\*(C'\fR in front of a variable, you get a
reference to that variable.
.PP
.Vb 3
\&    $aref = \e@array;         # $aref now holds a reference to @array
\&    $href = \e%hash;          # $href now holds a reference to %hash
\&    $sref = \e$scalar;        # $sref now holds a reference to $scalar
.Ve
.PP
Once the reference is stored in a variable like \f(CW$aref\fR or \f(CW$href\fR, you
can copy it or store it just the same as any other scalar value:
.PP
.Vb 3
\&    $xy = $aref;             # $xy now holds a reference to @array
\&    $p[3] = $href;           # $p[3] now holds a reference to %hash
\&    $z = $p[3];              # $z now holds a reference to %hash
.Ve
.PP
These examples show how to make references to variables with names.
Sometimes you want to make an array or a hash that doesn't have a
name.  This is analogous to the way you like to be able to use the
string \f(CW"\en"\fR or the number 80 without having to store it in a named
variable first.
.PP
\&\fBMake Rule 2\fR
.PP
\&\f(CW\*(C`[ ITEMS ]\*(C'\fR makes a new, anonymous array, and returns a reference to
that array.  \f(CW\*(C`{ ITEMS }\*(C'\fR makes a new, anonymous hash, and returns a
reference to that hash.
.PP
.Vb 2
\&    $aref = [ 1, "foo", undef, 13 ];
\&    # $aref now holds a reference to an array
\&
\&    $href = { APR => 4, AUG => 8 };
\&    # $href now holds a reference to a hash
.Ve
.PP
The references you get from rule 2 are the same kind of
references that you get from rule 1:
.PP
.Vb 2
\&        # This:
\&        $aref = [ 1, 2, 3 ];
\&
\&        # Does the same as this:
\&        @array = (1, 2, 3);
\&        $aref = \e@array;
.Ve
.PP
The first line is an abbreviation for the following two lines, except
that it doesn't create the superfluous array variable \f(CW@array\fR.
.PP
If you write just \f(CW\*(C`[]\*(C'\fR, you get a new, empty anonymous array.
If you write just \f(CW\*(C`{}\*(C'\fR, you get a new, empty anonymous hash.
.SS "Using References"
.IX Subsection "Using References"
What can you do with a reference once you have it?  It's a scalar
value, and we've seen that you can store it as a scalar and get it back
again just like any scalar.  There are just two more ways to use it:
.PP
\fI\f(BIUse Rule 1\fI\fR
.IX Subsection "Use Rule 1"
.PP
You can always use an array reference, in curly braces, in place of
the name of an array.  For example, \f(CW\*(C`@{$aref}\*(C'\fR instead of \f(CW@array\fR.
.PP
Here are some examples of that:
.PP
Arrays:
.PP
.Vb 4
\&        @a              @{$aref}                An array
\&        reverse @a      reverse @{$aref}        Reverse the array
\&        $a[3]           ${$aref}[3]             An element of the array
\&        $a[3] = 17;     ${$aref}[3] = 17        Assigning an element
.Ve
.PP
On each line are two expressions that do the same thing.  The
left-hand versions operate on the array \f(CW@a\fR.  The right-hand
versions operate on the array that is referred to by \f(CW$aref\fR.  Once
they find the array they're operating on, both versions do the same
things to the arrays.
.PP
Using a hash reference is \fIexactly\fR the same:
.PP
.Vb 4
\&        %h              %{$href}              A hash
\&        keys %h         keys %{$href}         Get the keys from the hash
\&        $h{\*(Aqred\*(Aq}       ${$href}{\*(Aqred\*(Aq}       An element of the hash
\&        $h{\*(Aqred\*(Aq} = 17  ${$href}{\*(Aqred\*(Aq} = 17  Assigning an element
.Ve
.PP
Whatever you want to do with a reference, \fBUse Rule 1\fR tells you how
to do it.  You just write the Perl code that you would have written
for doing the same thing to a regular array or hash, and then replace
the array or hash name with \f(CW\*(C`{$reference}\*(C'\fR.  \*(L"How do I loop over an
array when all I have is a reference?\*(R"  Well, to loop over an array, you
would write
.PP
.Vb 3
\&        for my $element (@array) {
\&           ...
\&        }
.Ve
.PP
so replace the array name, \f(CW@array\fR, with the reference:
.PP
.Vb 3
\&        for my $element (@{$aref}) {
\&           ...
\&        }
.Ve
.PP
\&\*(L"How do I print out the contents of a hash when all I have is a
reference?\*(R"  First write the code for printing out a hash:
.PP
.Vb 3
\&        for my $key (keys %hash) {
\&          print "$key => $hash{$key}\en";
\&        }
.Ve
.PP
And then replace the hash name with the reference:
.PP
.Vb 3
\&        for my $key (keys %{$href}) {
\&          print "$key => ${$href}{$key}\en";
\&        }
.Ve
.PP
\fI\f(BIUse Rule 2\fI\fR
.IX Subsection "Use Rule 2"
.PP
\&\fBUse Rule 1\fR is all you really need, because it tells you how to do
absolutely everything you ever need to do with references.  But the
most common thing to do with an array or a hash is to extract a single
element, and the \fBUse Rule 1\fR notation is cumbersome.  So there is an
abbreviation.
.PP
\&\f(CW\*(C`${$aref}[3]\*(C'\fR is too hard to read, so you can write \f(CW\*(C`$aref\->[3]\*(C'\fR
instead.
.PP
\&\f(CW\*(C`${$href}{red}\*(C'\fR is too hard to read, so you can write
\&\f(CW\*(C`$href\->{red}\*(C'\fR instead.
.PP
If \f(CW$aref\fR holds a reference to an array, then \f(CW\*(C`$aref\->[3]\*(C'\fR is
the fourth element of the array.  Don't confuse this with \f(CW$aref[3]\fR,
which is the fourth element of a totally different array, one
deceptively named \f(CW@aref\fR.  \f(CW$aref\fR and \f(CW@aref\fR are unrelated the
same way that \f(CW$item\fR and \f(CW@item\fR are.
.PP
Similarly, \f(CW\*(C`$href\->{\*(Aqred\*(Aq}\*(C'\fR is part of the hash referred to by
the scalar variable \f(CW$href\fR, perhaps even one with no name.
\&\f(CW$href{\*(Aqred\*(Aq}\fR is part of the deceptively named \f(CW%href\fR hash.  It's
easy to forget to leave out the \f(CW\*(C`\->\*(C'\fR, and if you do, you'll get
bizarre results when your program gets array and hash elements out of
totally unexpected hashes and arrays that weren't the ones you wanted
to use.
.SS "An Example"
.IX Subsection "An Example"
Let's see a quick example of how all this is useful.
.PP
First, remember that \f(CW\*(C`[1, 2, 3]\*(C'\fR makes an anonymous array containing
\&\f(CW\*(C`(1, 2, 3)\*(C'\fR, and gives you a reference to that array.
.PP
Now think about
.PP
.Vb 4
\&        @a = ( [1, 2, 3],
\&               [4, 5, 6],
\&               [7, 8, 9]
\&             );
.Ve
.PP
\&\f(CW@a\fR is an array with three elements, and each one is a reference to
another array.
.PP
\&\f(CW$a[1]\fR is one of these references.  It refers to an array, the array
containing \f(CW\*(C`(4, 5, 6)\*(C'\fR, and because it is a reference to an array,
\&\fBUse Rule 2\fR says that we can write \f(CW$a[1]\->[2]\fR to get the
third element from that array.  \f(CW$a[1]\->[2]\fR is the 6.
Similarly, \f(CW$a[0]\->[1]\fR is the 2.  What we have here is like a
two-dimensional array; you can write \f(CW$a[ROW]\->[COLUMN]\fR to get
or set the element in any row and any column of the array.
.PP
The notation still looks a little cumbersome, so there's one more
abbreviation:
.SS "Arrow Rule"
.IX Subsection "Arrow Rule"
In between two \fBsubscripts\fR, the arrow is optional.
.PP
Instead of \f(CW$a[1]\->[2]\fR, we can write \f(CW$a[1][2]\fR; it means the
same thing.  Instead of \f(CW\*(C`$a[0]\->[1] = 23\*(C'\fR, we can write
\&\f(CW\*(C`$a[0][1] = 23\*(C'\fR; it means the same thing.
.PP
Now it really looks like two-dimensional arrays!
.PP
You can see why the arrows are important.  Without them, we would have
had to write \f(CW\*(C`${$a[1]}[2]\*(C'\fR instead of \f(CW$a[1][2]\fR.  For
three-dimensional arrays, they let us write \f(CW$x[2][3][5]\fR instead of
the unreadable \f(CW\*(C`${${$x[2]}[3]}[5]\*(C'\fR.
.SH "Solution"
.IX Header "Solution"
Here's the answer to the problem I posed earlier, of reformatting a
file of city and country names.
.PP
.Vb 1
\&    1   my %table;
\&
\&    2   while (<>) {
\&    3    chomp;
\&    4     my ($city, $country) = split /, /;
\&    5     $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
\&
\&    8   foreach $country (sort keys %table) {
\&    9     print "$country: ";
\&   10     my @cities = @{$table{$country}};
\&   11     print join \*(Aq, \*(Aq, sort @cities;
\&   12     print ".\en";
\&   13   }
.Ve
.PP
The program has two pieces: Lines 2\-\-7 read the input and build a data
structure, and lines 8\-13 analyze the data and print out the report.
We're going to have a hash, \f(CW%table\fR, whose keys are country names,
and whose values are references to arrays of city names.  The data
structure will look like this:
.PP
.Vb 10
\&           %table
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\&        |Germany| *\-\-\-\->| Frankfurt | Berlin |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-+
\&        |Finland| *\-\-\-\->| Helsinki |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&        |  USA  | *\-\-\-\->| Chicago | Washington | New York |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
.Ve
.PP
We'll look at output first.  Supposing we already have this structure,
how do we print it out?
.PP
.Vb 6
\&    8   foreach $country (sort keys %table) {
\&    9     print "$country: ";
\&   10     my @cities = @{$table{$country}};
\&   11     print join \*(Aq, \*(Aq, sort @cities;
\&   12     print ".\en";
\&   13   }
.Ve
.PP
\&\f(CW%table\fR is an
ordinary hash, and we get a list of keys from it, sort the keys, and
loop over the keys as usual.  The only use of references is in line 10.
\&\f(CW$table{$country}\fR looks up the key \f(CW$country\fR in the hash
and gets the value, which is a reference to an array of cities in that country.
\&\fBUse Rule 1\fR says that
we can recover the array by saying
\&\f(CW\*(C`@{$table{$country}}\*(C'\fR.  Line 10 is just like
.PP
.Vb 1
\&        @cities = @array;
.Ve
.PP
except that the name \f(CW\*(C`array\*(C'\fR has been replaced by the reference
\&\f(CW\*(C`{$table{$country}}\*(C'\fR.  The \f(CW\*(C`@\*(C'\fR tells Perl to get the entire array.
Having gotten the list of cities, we sort it, join it, and print it
out as usual.
.PP
Lines 2\-7 are responsible for building the structure in the first
place.  Here they are again:
.PP
.Vb 6
\&    2   while (<>) {
\&    3    chomp;
\&    4     my ($city, $country) = split /, /;
\&    5     $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
.Ve
.PP
Lines 2\-4 acquire a city and country name.  Line 5 looks to see if the
country is already present as a key in the hash.  If it's not, the
program uses the \f(CW\*(C`[]\*(C'\fR notation (\fBMake Rule 2\fR) to manufacture a new,
empty anonymous array of cities, and installs a reference to it into
the hash under the appropriate key.
.PP
Line 6 installs the city name into the appropriate array.
\&\f(CW$table{$country}\fR now holds a reference to the array of cities seen
in that country so far.  Line 6 is exactly like
.PP
.Vb 1
\&        push @array, $city;
.Ve
.PP
except that the name \f(CW\*(C`array\*(C'\fR has been replaced by the reference
\&\f(CW\*(C`{$table{$country}}\*(C'\fR.  The \f(CW\*(C`push\*(C'\fR adds a city name to the end of the
referred-to array.
.PP
There's one fine point I skipped.  Line 5 is unnecessary, and we can
get rid of it.
.PP
.Vb 6
\&    2   while (<>) {
\&    3    chomp;
\&    4     my ($city, $country) = split /, /;
\&    5   ####  $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
.Ve
.PP
If there's already an entry in \f(CW%table\fR for the current \f(CW$country\fR,
then nothing is different.  Line 6 will locate the value in
\&\f(CW$table{$country}\fR, which is a reference to an array, and push
\&\f(CW$city\fR into the array.  But
what does it do when
\&\f(CW$country\fR holds a key, say \f(CW\*(C`Greece\*(C'\fR, that is not yet in \f(CW%table\fR?
.PP
This is Perl, so it does the exact right thing.  It sees that you want
to push \f(CW\*(C`Athens\*(C'\fR onto an array that doesn't exist, so it helpfully
makes a new, empty, anonymous array for you, installs it into
\&\f(CW%table\fR, and then pushes \f(CW\*(C`Athens\*(C'\fR onto it.  This is called
\&'autovivification'\-\-bringing things to life automatically.  Perl saw
that the key wasn't in the hash, so it created a new hash entry
automatically. Perl saw that you wanted to use the hash value as an
array, so it created a new empty array and installed a reference to it
in the hash automatically.  And as usual, Perl made the array one
element longer to hold the new city name.
.SH "The Rest"
.IX Header "The Rest"
I promised to give you 90% of the benefit with 10% of the details, and
that means I left out 90% of the details.  Now that you have an
overview of the important parts, it should be easier to read the
perlref manual page, which discusses 100% of the details.
.PP
Some of the highlights of perlref:
.IP "\(bu" 4
You can make references to anything, including scalars, functions, and
other references.
.IP "\(bu" 4
In \fBUse Rule 1\fR, you can omit the curly brackets whenever the thing
inside them is an atomic scalar variable like \f(CW$aref\fR.  For example,
\&\f(CW@$aref\fR is the same as \f(CW\*(C`@{$aref}\*(C'\fR, and \f(CW$$aref[1]\fR is the same as
\&\f(CW\*(C`${$aref}[1]\*(C'\fR.  If you're just starting out, you may want to adopt
the habit of always including the curly brackets.
.IP "\(bu" 4
This doesn't copy the underlying array:
.Sp
.Vb 1
\&        $aref2 = $aref1;
.Ve
.Sp
You get two references to the same array.  If you modify
\&\f(CW\*(C`$aref1\->[23]\*(C'\fR and then look at
\&\f(CW\*(C`$aref2\->[23]\*(C'\fR you'll see the change.
.Sp
To copy the array, use
.Sp
.Vb 1
\&        $aref2 = [@{$aref1}];
.Ve
.Sp
This uses \f(CW\*(C`[...]\*(C'\fR notation to create a new anonymous array, and
\&\f(CW$aref2\fR is assigned a reference to the new array.  The new array is
initialized with the contents of the array referred to by \f(CW$aref1\fR.
.Sp
Similarly, to copy an anonymous hash, you can use
.Sp
.Vb 1
\&        $href2 = {%{$href1}};
.Ve
.IP "\(bu" 4
To see if a variable contains a reference, use the \f(CW\*(C`ref\*(C'\fR function.  It
returns true if its argument is a reference.  Actually it's a little
better than that: It returns \f(CW\*(C`HASH\*(C'\fR for hash references and \f(CW\*(C`ARRAY\*(C'\fR
for array references.
.IP "\(bu" 4
If you try to use a reference like a string, you get strings like
.Sp
.Vb 1
\&        ARRAY(0x80f5dec)   or    HASH(0x826afc0)
.Ve
.Sp
If you ever see a string that looks like this, you'll know you
printed out a reference by mistake.
.Sp
A side effect of this representation is that you can use \f(CW\*(C`eq\*(C'\fR to see
if two references refer to the same thing.  (But you should usually use
\&\f(CW\*(C`==\*(C'\fR instead because it's much faster.)
.IP "\(bu" 4
You can use a string as if it were a reference.  If you use the string
\&\f(CW"foo"\fR as an array reference, it's taken to be a reference to the
array \f(CW@foo\fR.  This is called a \fIsoft reference\fR or \fIsymbolic
reference\fR.  The declaration \f(CW\*(C`use strict \*(Aqrefs\*(Aq\*(C'\fR disables this
feature, which can cause all sorts of trouble if you use it by accident.
.PP
You might prefer to go on to perllol instead of perlref; it
discusses lists of lists and multidimensional arrays in detail.  After
that, you should move on to perldsc; it's a Data Structure Cookbook
that shows recipes for using and printing out arrays of hashes, hashes
of arrays, and other kinds of data.
.SH "Summary"
.IX Header "Summary"
Everyone needs compound data structures, and in Perl the way you get
them is with references.  There are four important rules for managing
references: Two for making references and two for using them.  Once
you know these rules you can do most of the important things you need
to do with references.
.SH "Credits"
.IX Header "Credits"
Author: Mark Jason Dominus, Plover Systems (\f(CW\*(C`mjd\-perl\-ref+@plover.com\*(C'\fR)
.PP
This article originally appeared in \fIThe Perl Journal\fR
( http://www.tpj.com/ ) volume 3, #2.  Reprinted with permission.
.PP
The original title was \fIUnderstand References Today\fR.
.SS "Distribution Conditions"
.IX Subsection "Distribution Conditions"
Copyright 1998 The Perl Journal.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in these files are
hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun or for profit
as you see fit.  A simple comment in the code giving credit would be
courteous but is not required.
                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreftut5.16.1                             0100644 0001750 0001750 00000061070 12566207423 023451  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREFTUT 1"
.TH PERLREFTUT 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreftut \- Mark's very short tutorial about references
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
One of the most important new features in Perl 5 was the capability to
manage complicated data structures like multidimensional arrays and
nested hashes.  To enable these, Perl 5 introduced a feature called
\&'references', and using references is the key to managing complicated,
structured data in Perl.  Unfortunately, there's a lot of funny syntax
to learn, and the main manual page can be hard to follow.  The manual
is quite complete, and sometimes people find that a problem, because
it can be hard to tell what is important and what isn't.
.PP
Fortunately, you only need to know 10% of what's in the main page to get
90% of the benefit.  This page will show you that 10%.
.SH "Who Needs Complicated Data Structures?"
.IX Header "Who Needs Complicated Data Structures?"
One problem that came up all the time in Perl 4 was how to represent a
hash whose values were lists.  Perl 4 had hashes, of course, but the
values had to be scalars; they couldn't be lists.
.PP
Why would you want a hash of lists?  Let's take a simple example: You
have a file of city and country names, like this:
.PP
.Vb 6
\&        Chicago, USA
\&        Frankfurt, Germany
\&        Berlin, Germany
\&        Washington, USA
\&        Helsinki, Finland
\&        New York, USA
.Ve
.PP
and you want to produce an output like this, with each country mentioned
once, and then an alphabetical list of the cities in that country:
.PP
.Vb 3
\&        Finland: Helsinki.
\&        Germany: Berlin, Frankfurt.
\&        USA:  Chicago, New York, Washington.
.Ve
.PP
The natural way to do this is to have a hash whose keys are country
names.  Associated with each country name key is a list of the cities in
that country.  Each time you read a line of input, split it into a country
and a city, look up the list of cities already known to be in that
country, and append the new city to the list.  When you're done reading
the input, iterate over the hash as usual, sorting each list of cities
before you print it out.
.PP
If hash values can't be lists, you lose.  In Perl 4, hash values can't
be lists; they can only be strings.  You lose.  You'd probably have to
combine all the cities into a single string somehow, and then when
time came to write the output, you'd have to break the string into a
list, sort the list, and turn it back into a string.  This is messy
and error-prone.  And it's frustrating, because Perl already has
perfectly good lists that would solve the problem if only you could
use them.
.SH "The Solution"
.IX Header "The Solution"
By the time Perl 5 rolled around, we were already stuck with this
design: Hash values must be scalars.  The solution to this is
references.
.PP
A reference is a scalar value that \fIrefers to\fR an entire array or an
entire hash (or to just about anything else).  Names are one kind of
reference that you're already familiar with.  Think of the President
of the United States: a messy, inconvenient bag of blood and bones.
But to talk about him, or to represent him in a computer program, all
you need is the easy, convenient scalar string \*(L"Barack Obama\*(R".
.PP
References in Perl are like names for arrays and hashes.  They're
Perl's private, internal names, so you can be sure they're
unambiguous.  Unlike \*(L"Barack Obama\*(R", a reference only refers to one
thing, and you always know what it refers to.  If you have a reference
to an array, you can recover the entire array from it.  If you have a
reference to a hash, you can recover the entire hash.  But the
reference is still an easy, compact scalar value.
.PP
You can't have a hash whose values are arrays; hash values can only be
scalars.  We're stuck with that.  But a single reference can refer to
an entire array, and references are scalars, so you can have a hash of
references to arrays, and it'll act a lot like a hash of arrays, and
it'll be just as useful as a hash of arrays.
.PP
We'll come back to this city-country problem later, after we've seen
some syntax for managing references.
.SH "Syntax"
.IX Header "Syntax"
There are just two ways to make a reference, and just two ways to use
it once you have it.
.SS "Making References"
.IX Subsection "Making References"
\fI\f(BIMake Rule 1\fI\fR
.IX Subsection "Make Rule 1"
.PP
If you put a \f(CW\*(C`\e\*(C'\fR in front of a variable, you get a
reference to that variable.
.PP
.Vb 3
\&    $aref = \e@array;         # $aref now holds a reference to @array
\&    $href = \e%hash;          # $href now holds a reference to %hash
\&    $sref = \e$scalar;        # $sref now holds a reference to $scalar
.Ve
.PP
Once the reference is stored in a variable like \f(CW$aref\fR or \f(CW$href\fR, you
can copy it or store it just the same as any other scalar value:
.PP
.Vb 3
\&    $xy = $aref;             # $xy now holds a reference to @array
\&    $p[3] = $href;           # $p[3] now holds a reference to %hash
\&    $z = $p[3];              # $z now holds a reference to %hash
.Ve
.PP
These examples show how to make references to variables with names.
Sometimes you want to make an array or a hash that doesn't have a
name.  This is analogous to the way you like to be able to use the
string \f(CW"\en"\fR or the number 80 without having to store it in a named
variable first.
.PP
\&\fBMake Rule 2\fR
.PP
\&\f(CW\*(C`[ ITEMS ]\*(C'\fR makes a new, anonymous array, and returns a reference to
that array.  \f(CW\*(C`{ ITEMS }\*(C'\fR makes a new, anonymous hash, and returns a
reference to that hash.
.PP
.Vb 2
\&    $aref = [ 1, "foo", undef, 13 ];
\&    # $aref now holds a reference to an array
\&
\&    $href = { APR => 4, AUG => 8 };
\&    # $href now holds a reference to a hash
.Ve
.PP
The references you get from rule 2 are the same kind of
references that you get from rule 1:
.PP
.Vb 2
\&        # This:
\&        $aref = [ 1, 2, 3 ];
\&
\&        # Does the same as this:
\&        @array = (1, 2, 3);
\&        $aref = \e@array;
.Ve
.PP
The first line is an abbreviation for the following two lines, except
that it doesn't create the superfluous array variable \f(CW@array\fR.
.PP
If you write just \f(CW\*(C`[]\*(C'\fR, you get a new, empty anonymous array.
If you write just \f(CW\*(C`{}\*(C'\fR, you get a new, empty anonymous hash.
.SS "Using References"
.IX Subsection "Using References"
What can you do with a reference once you have it?  It's a scalar
value, and we've seen that you can store it as a scalar and get it back
again just like any scalar.  There are just two more ways to use it:
.PP
\fI\f(BIUse Rule 1\fI\fR
.IX Subsection "Use Rule 1"
.PP
You can always use an array reference, in curly braces, in place of
the name of an array.  For example, \f(CW\*(C`@{$aref}\*(C'\fR instead of \f(CW@array\fR.
.PP
Here are some examples of that:
.PP
Arrays:
.PP
.Vb 4
\&        @a              @{$aref}                An array
\&        reverse @a      reverse @{$aref}        Reverse the array
\&        $a[3]           ${$aref}[3]             An element of the array
\&        $a[3] = 17;     ${$aref}[3] = 17        Assigning an element
.Ve
.PP
On each line are two expressions that do the same thing.  The
left-hand versions operate on the array \f(CW@a\fR.  The right-hand
versions operate on the array that is referred to by \f(CW$aref\fR.  Once
they find the array they're operating on, both versions do the same
things to the arrays.
.PP
Using a hash reference is \fIexactly\fR the same:
.PP
.Vb 4
\&        %h              %{$href}              A hash
\&        keys %h         keys %{$href}         Get the keys from the hash
\&        $h{\*(Aqred\*(Aq}       ${$href}{\*(Aqred\*(Aq}       An element of the hash
\&        $h{\*(Aqred\*(Aq} = 17  ${$href}{\*(Aqred\*(Aq} = 17  Assigning an element
.Ve
.PP
Whatever you want to do with a reference, \fBUse Rule 1\fR tells you how
to do it.  You just write the Perl code that you would have written
for doing the same thing to a regular array or hash, and then replace
the array or hash name with \f(CW\*(C`{$reference}\*(C'\fR.  \*(L"How do I loop over an
array when all I have is a reference?\*(R"  Well, to loop over an array, you
would write
.PP
.Vb 3
\&        for my $element (@array) {
\&           ...
\&        }
.Ve
.PP
so replace the array name, \f(CW@array\fR, with the reference:
.PP
.Vb 3
\&        for my $element (@{$aref}) {
\&           ...
\&        }
.Ve
.PP
\&\*(L"How do I print out the contents of a hash when all I have is a
reference?\*(R"  First write the code for printing out a hash:
.PP
.Vb 3
\&        for my $key (keys %hash) {
\&          print "$key => $hash{$key}\en";
\&        }
.Ve
.PP
And then replace the hash name with the reference:
.PP
.Vb 3
\&        for my $key (keys %{$href}) {
\&          print "$key => ${$href}{$key}\en";
\&        }
.Ve
.PP
\fI\f(BIUse Rule 2\fI\fR
.IX Subsection "Use Rule 2"
.PP
\&\fBUse Rule 1\fR is all you really need, because it tells you how to do
absolutely everything you ever need to do with references.  But the
most common thing to do with an array or a hash is to extract a single
element, and the \fBUse Rule 1\fR notation is cumbersome.  So there is an
abbreviation.
.PP
\&\f(CW\*(C`${$aref}[3]\*(C'\fR is too hard to read, so you can write \f(CW\*(C`$aref\->[3]\*(C'\fR
instead.
.PP
\&\f(CW\*(C`${$href}{red}\*(C'\fR is too hard to read, so you can write
\&\f(CW\*(C`$href\->{red}\*(C'\fR instead.
.PP
If \f(CW$aref\fR holds a reference to an array, then \f(CW\*(C`$aref\->[3]\*(C'\fR is
the fourth element of the array.  Don't confuse this with \f(CW$aref[3]\fR,
which is the fourth element of a totally different array, one
deceptively named \f(CW@aref\fR.  \f(CW$aref\fR and \f(CW@aref\fR are unrelated the
same way that \f(CW$item\fR and \f(CW@item\fR are.
.PP
Similarly, \f(CW\*(C`$href\->{\*(Aqred\*(Aq}\*(C'\fR is part of the hash referred to by
the scalar variable \f(CW$href\fR, perhaps even one with no name.
\&\f(CW$href{\*(Aqred\*(Aq}\fR is part of the deceptively named \f(CW%href\fR hash.  It's
easy to forget to leave out the \f(CW\*(C`\->\*(C'\fR, and if you do, you'll get
bizarre results when your program gets array and hash elements out of
totally unexpected hashes and arrays that weren't the ones you wanted
to use.
.SS "An Example"
.IX Subsection "An Example"
Let's see a quick example of how all this is useful.
.PP
First, remember that \f(CW\*(C`[1, 2, 3]\*(C'\fR makes an anonymous array containing
\&\f(CW\*(C`(1, 2, 3)\*(C'\fR, and gives you a reference to that array.
.PP
Now think about
.PP
.Vb 4
\&        @a = ( [1, 2, 3],
\&               [4, 5, 6],
\&               [7, 8, 9]
\&             );
.Ve
.PP
\&\f(CW@a\fR is an array with three elements, and each one is a reference to
another array.
.PP
\&\f(CW$a[1]\fR is one of these references.  It refers to an array, the array
containing \f(CW\*(C`(4, 5, 6)\*(C'\fR, and because it is a reference to an array,
\&\fBUse Rule 2\fR says that we can write \f(CW$a[1]\->[2]\fR to get the
third element from that array.  \f(CW$a[1]\->[2]\fR is the 6.
Similarly, \f(CW$a[0]\->[1]\fR is the 2.  What we have here is like a
two-dimensional array; you can write \f(CW$a[ROW]\->[COLUMN]\fR to get
or set the element in any row and any column of the array.
.PP
The notation still looks a little cumbersome, so there's one more
abbreviation:
.SS "Arrow Rule"
.IX Subsection "Arrow Rule"
In between two \fBsubscripts\fR, the arrow is optional.
.PP
Instead of \f(CW$a[1]\->[2]\fR, we can write \f(CW$a[1][2]\fR; it means the
same thing.  Instead of \f(CW\*(C`$a[0]\->[1] = 23\*(C'\fR, we can write
\&\f(CW\*(C`$a[0][1] = 23\*(C'\fR; it means the same thing.
.PP
Now it really looks like two-dimensional arrays!
.PP
You can see why the arrows are important.  Without them, we would have
had to write \f(CW\*(C`${$a[1]}[2]\*(C'\fR instead of \f(CW$a[1][2]\fR.  For
three-dimensional arrays, they let us write \f(CW$x[2][3][5]\fR instead of
the unreadable \f(CW\*(C`${${$x[2]}[3]}[5]\*(C'\fR.
.SH "Solution"
.IX Header "Solution"
Here's the answer to the problem I posed earlier, of reformatting a
file of city and country names.
.PP
.Vb 1
\&    1   my %table;
\&
\&    2   while (<>) {
\&    3    chomp;
\&    4     my ($city, $country) = split /, /;
\&    5     $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
\&
\&    8   foreach $country (sort keys %table) {
\&    9     print "$country: ";
\&   10     my @cities = @{$table{$country}};
\&   11     print join \*(Aq, \*(Aq, sort @cities;
\&   12     print ".\en";
\&   13   }
.Ve
.PP
The program has two pieces: Lines 2\-\-7 read the input and build a data
structure, and lines 8\-13 analyze the data and print out the report.
We're going to have a hash, \f(CW%table\fR, whose keys are country names,
and whose values are references to arrays of city names.  The data
structure will look like this:
.PP
.Vb 10
\&           %table
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\&        |Germany| *\-\-\-\->| Frankfurt | Berlin |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-+
\&        |Finland| *\-\-\-\->| Helsinki |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&        |  USA  | *\-\-\-\->| Chicago | Washington | New York |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
.Ve
.PP
We'll look at output first.  Supposing we already have this structure,
how do we print it out?
.PP
.Vb 6
\&    8   foreach $country (sort keys %table) {
\&    9     print "$country: ";
\&   10     my @cities = @{$table{$country}};
\&   11     print join \*(Aq, \*(Aq, sort @cities;
\&   12     print ".\en";
\&   13   }
.Ve
.PP
\&\f(CW%table\fR is an
ordinary hash, and we get a list of keys from it, sort the keys, and
loop over the keys as usual.  The only use of references is in line 10.
\&\f(CW$table{$country}\fR looks up the key \f(CW$country\fR in the hash
and gets the value, which is a reference to an array of cities in that country.
\&\fBUse Rule 1\fR says that
we can recover the array by saying
\&\f(CW\*(C`@{$table{$country}}\*(C'\fR.  Line 10 is just like
.PP
.Vb 1
\&        @cities = @array;
.Ve
.PP
except that the name \f(CW\*(C`array\*(C'\fR has been replaced by the reference
\&\f(CW\*(C`{$table{$country}}\*(C'\fR.  The \f(CW\*(C`@\*(C'\fR tells Perl to get the entire array.
Having gotten the list of cities, we sort it, join it, and print it
out as usual.
.PP
Lines 2\-7 are responsible for building the structure in the first
place.  Here they are again:
.PP
.Vb 6
\&    2   while (<>) {
\&    3    chomp;
\&    4     my ($city, $country) = split /, /;
\&    5     $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
.Ve
.PP
Lines 2\-4 acquire a city and country name.  Line 5 looks to see if the
country is already present as a key in the hash.  If it's not, the
program uses the \f(CW\*(C`[]\*(C'\fR notation (\fBMake Rule 2\fR) to manufacture a new,
empty anonymous array of cities, and installs a reference to it into
the hash under the appropriate key.
.PP
Line 6 installs the city name into the appropriate array.
\&\f(CW$table{$country}\fR now holds a reference to the array of cities seen
in that country so far.  Line 6 is exactly like
.PP
.Vb 1
\&        push @array, $city;
.Ve
.PP
except that the name \f(CW\*(C`array\*(C'\fR has been replaced by the reference
\&\f(CW\*(C`{$table{$country}}\*(C'\fR.  The \f(CW\*(C`push\*(C'\fR adds a city name to the end of the
referred-to array.
.PP
There's one fine point I skipped.  Line 5 is unnecessary, and we can
get rid of it.
.PP
.Vb 6
\&    2   while (<>) {
\&    3    chomp;
\&    4     my ($city, $country) = split /, /;
\&    5   ####  $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
.Ve
.PP
If there's already an entry in \f(CW%table\fR for the current \f(CW$country\fR,
then nothing is different.  Line 6 will locate the value in
\&\f(CW$table{$country}\fR, which is a reference to an array, and push
\&\f(CW$city\fR into the array.  But
what does it do when
\&\f(CW$country\fR holds a key, say \f(CW\*(C`Greece\*(C'\fR, that is not yet in \f(CW%table\fR?
.PP
This is Perl, so it does the exact right thing.  It sees that you want
to push \f(CW\*(C`Athens\*(C'\fR onto an array that doesn't exist, so it helpfully
makes a new, empty, anonymous array for you, installs it into
\&\f(CW%table\fR, and then pushes \f(CW\*(C`Athens\*(C'\fR onto it.  This is called
\&'autovivification'\-\-bringing things to life automatically.  Perl saw
that they key wasn't in the hash, so it created a new hash entry
automatically. Perl saw that you wanted to use the hash value as an
array, so it created a new empty array and installed a reference to it
in the hash automatically.  And as usual, Perl made the array one
element longer to hold the new city name.
.SH "The Rest"
.IX Header "The Rest"
I promised to give you 90% of the benefit with 10% of the details, and
that means I left out 90% of the details.  Now that you have an
overview of the important parts, it should be easier to read the
perlref manual page, which discusses 100% of the details.
.PP
Some of the highlights of perlref:
.IP "\(bu" 4
You can make references to anything, including scalars, functions, and
other references.
.IP "\(bu" 4
In \fBUse Rule 1\fR, you can omit the curly brackets whenever the thing
inside them is an atomic scalar variable like \f(CW$aref\fR.  For example,
\&\f(CW@$aref\fR is the same as \f(CW\*(C`@{$aref}\*(C'\fR, and \f(CW$$aref[1]\fR is the same as
\&\f(CW\*(C`${$aref}[1]\*(C'\fR.  If you're just starting out, you may want to adopt
the habit of always including the curly brackets.
.IP "\(bu" 4
This doesn't copy the underlying array:
.Sp
.Vb 1
\&        $aref2 = $aref1;
.Ve
.Sp
You get two references to the same array.  If you modify
\&\f(CW\*(C`$aref1\->[23]\*(C'\fR and then look at
\&\f(CW\*(C`$aref2\->[23]\*(C'\fR you'll see the change.
.Sp
To copy the array, use
.Sp
.Vb 1
\&        $aref2 = [@{$aref1}];
.Ve
.Sp
This uses \f(CW\*(C`[...]\*(C'\fR notation to create a new anonymous array, and
\&\f(CW$aref2\fR is assigned a reference to the new array.  The new array is
initialized with the contents of the array referred to by \f(CW$aref1\fR.
.Sp
Similarly, to copy an anonymous hash, you can use
.Sp
.Vb 1
\&        $href2 = {%{$href1}};
.Ve
.IP "\(bu" 4
To see if a variable contains a reference, use the \f(CW\*(C`ref\*(C'\fR function.  It
returns true if its argument is a reference.  Actually it's a little
better than that: It returns \f(CW\*(C`HASH\*(C'\fR for hash references and \f(CW\*(C`ARRAY\*(C'\fR
for array references.
.IP "\(bu" 4
If you try to use a reference like a string, you get strings like
.Sp
.Vb 1
\&        ARRAY(0x80f5dec)   or    HASH(0x826afc0)
.Ve
.Sp
If you ever see a string that looks like this, you'll know you
printed out a reference by mistake.
.Sp
A side effect of this representation is that you can use \f(CW\*(C`eq\*(C'\fR to see
if two references refer to the same thing.  (But you should usually use
\&\f(CW\*(C`==\*(C'\fR instead because it's much faster.)
.IP "\(bu" 4
You can use a string as if it were a reference.  If you use the string
\&\f(CW"foo"\fR as an array reference, it's taken to be a reference to the
array \f(CW@foo\fR.  This is called a \fIsoft reference\fR or \fIsymbolic
reference\fR.  The declaration \f(CW\*(C`use strict \*(Aqrefs\*(Aq\*(C'\fR disables this
feature, which can cause all sorts of trouble if you use it by accident.
.PP
You might prefer to go on to perllol instead of perlref; it
discusses lists of lists and multidimensional arrays in detail.  After
that, you should move on to perldsc; it's a Data Structure Cookbook
that shows recipes for using and printing out arrays of hashes, hashes
of arrays, and other kinds of data.
.SH "Summary"
.IX Header "Summary"
Everyone needs compound data structures, and in Perl the way you get
them is with references.  There are four important rules for managing
references: Two for making references and two for using them.  Once
you know these rules you can do most of the important things you need
to do with references.
.SH "Credits"
.IX Header "Credits"
Author: Mark Jason Dominus, Plover Systems (\f(CW\*(C`mjd\-perl\-ref+@plover.com\*(C'\fR)
.PP
This article originally appeared in \fIThe Perl Journal\fR
( http://www.tpj.com/ ) volume 3, #2.  Reprinted with permission.
.PP
The original title was \fIUnderstand References Today\fR.
.SS "Distribution Conditions"
.IX Subsection "Distribution Conditions"
Copyright 1998 The Perl Journal.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in these files are
hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun or for profit
as you see fit.  A simple comment in the code giving credit would be
courteous but is not required.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreftut5.18.1                             0100644 0001750 0001750 00000061246 12566207444 023463  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREFTUT 1"
.TH PERLREFTUT 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreftut \- Mark's very short tutorial about references
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
One of the most important new features in Perl 5 was the capability to
manage complicated data structures like multidimensional arrays and
nested hashes.  To enable these, Perl 5 introduced a feature called
\&'references', and using references is the key to managing complicated,
structured data in Perl.  Unfortunately, there's a lot of funny syntax
to learn, and the main manual page can be hard to follow.  The manual
is quite complete, and sometimes people find that a problem, because
it can be hard to tell what is important and what isn't.
.PP
Fortunately, you only need to know 10% of what's in the main page to get
90% of the benefit.  This page will show you that 10%.
.SH "Who Needs Complicated Data Structures?"
.IX Header "Who Needs Complicated Data Structures?"
One problem that comes up all the time is needing a hash whose values are
lists.  Perl has hashes, of course, but the values have to be scalars;
they can't be lists.
.PP
Why would you want a hash of lists?  Let's take a simple example: You
have a file of city and country names, like this:
.PP
.Vb 6
\&        Chicago, USA
\&        Frankfurt, Germany
\&        Berlin, Germany
\&        Washington, USA
\&        Helsinki, Finland
\&        New York, USA
.Ve
.PP
and you want to produce an output like this, with each country mentioned
once, and then an alphabetical list of the cities in that country:
.PP
.Vb 3
\&        Finland: Helsinki.
\&        Germany: Berlin, Frankfurt.
\&        USA:  Chicago, New York, Washington.
.Ve
.PP
The natural way to do this is to have a hash whose keys are country
names.  Associated with each country name key is a list of the cities in
that country.  Each time you read a line of input, split it into a country
and a city, look up the list of cities already known to be in that
country, and append the new city to the list.  When you're done reading
the input, iterate over the hash as usual, sorting each list of cities
before you print it out.
.PP
If hash values couldn't be lists, you lose.  You'd probably have to
combine all the cities into a single string somehow, and then when
time came to write the output, you'd have to break the string into a
list, sort the list, and turn it back into a string.  This is messy
and error-prone.  And it's frustrating, because Perl already has
perfectly good lists that would solve the problem if only you could
use them.
.SH "The Solution"
.IX Header "The Solution"
By the time Perl 5 rolled around, we were already stuck with this
design: Hash values must be scalars.  The solution to this is
references.
.PP
A reference is a scalar value that \fIrefers to\fR an entire array or an
entire hash (or to just about anything else).  Names are one kind of
reference that you're already familiar with.  Think of the President
of the United States: a messy, inconvenient bag of blood and bones.
But to talk about him, or to represent him in a computer program, all
you need is the easy, convenient scalar string \*(L"Barack Obama\*(R".
.PP
References in Perl are like names for arrays and hashes.  They're
Perl's private, internal names, so you can be sure they're
unambiguous.  Unlike \*(L"Barack Obama\*(R", a reference only refers to one
thing, and you always know what it refers to.  If you have a reference
to an array, you can recover the entire array from it.  If you have a
reference to a hash, you can recover the entire hash.  But the
reference is still an easy, compact scalar value.
.PP
You can't have a hash whose values are arrays; hash values can only be
scalars.  We're stuck with that.  But a single reference can refer to
an entire array, and references are scalars, so you can have a hash of
references to arrays, and it'll act a lot like a hash of arrays, and
it'll be just as useful as a hash of arrays.
.PP
We'll come back to this city-country problem later, after we've seen
some syntax for managing references.
.SH "Syntax"
.IX Header "Syntax"
There are just two ways to make a reference, and just two ways to use
it once you have it.
.SS "Making References"
.IX Subsection "Making References"
\fI\f(BIMake Rule 1\fI\fR
.IX Subsection "Make Rule 1"
.PP
If you put a \f(CW\*(C`\e\*(C'\fR in front of a variable, you get a
reference to that variable.
.PP
.Vb 3
\&    $aref = \e@array;         # $aref now holds a reference to @array
\&    $href = \e%hash;          # $href now holds a reference to %hash
\&    $sref = \e$scalar;        # $sref now holds a reference to $scalar
.Ve
.PP
Once the reference is stored in a variable like \f(CW$aref\fR or \f(CW$href\fR, you
can copy it or store it just the same as any other scalar value:
.PP
.Vb 3
\&    $xy = $aref;             # $xy now holds a reference to @array
\&    $p[3] = $href;           # $p[3] now holds a reference to %hash
\&    $z = $p[3];              # $z now holds a reference to %hash
.Ve
.PP
These examples show how to make references to variables with names.
Sometimes you want to make an array or a hash that doesn't have a
name.  This is analogous to the way you like to be able to use the
string \f(CW"\en"\fR or the number 80 without having to store it in a named
variable first.
.PP
\&\fBMake Rule 2\fR
.PP
\&\f(CW\*(C`[ ITEMS ]\*(C'\fR makes a new, anonymous array, and returns a reference to
that array.  \f(CW\*(C`{ ITEMS }\*(C'\fR makes a new, anonymous hash, and returns a
reference to that hash.
.PP
.Vb 2
\&    $aref = [ 1, "foo", undef, 13 ];
\&    # $aref now holds a reference to an array
\&
\&    $href = { APR => 4, AUG => 8 };
\&    # $href now holds a reference to a hash
.Ve
.PP
The references you get from rule 2 are the same kind of
references that you get from rule 1:
.PP
.Vb 2
\&        # This:
\&        $aref = [ 1, 2, 3 ];
\&
\&        # Does the same as this:
\&        @array = (1, 2, 3);
\&        $aref = \e@array;
.Ve
.PP
The first line is an abbreviation for the following two lines, except
that it doesn't create the superfluous array variable \f(CW@array\fR.
.PP
If you write just \f(CW\*(C`[]\*(C'\fR, you get a new, empty anonymous array.
If you write just \f(CW\*(C`{}\*(C'\fR, you get a new, empty anonymous hash.
.SS "Using References"
.IX Subsection "Using References"
What can you do with a reference once you have it?  It's a scalar
value, and we've seen that you can store it as a scalar and get it back
again just like any scalar.  There are just two more ways to use it:
.PP
\fI\f(BIUse Rule 1\fI\fR
.IX Subsection "Use Rule 1"
.PP
You can always use an array reference, in curly braces, in place of
the name of an array.  For example, \f(CW\*(C`@{$aref}\*(C'\fR instead of \f(CW@array\fR.
.PP
Here are some examples of that:
.PP
Arrays:
.PP
.Vb 4
\&        @a              @{$aref}                An array
\&        reverse @a      reverse @{$aref}        Reverse the array
\&        $a[3]           ${$aref}[3]             An element of the array
\&        $a[3] = 17;     ${$aref}[3] = 17        Assigning an element
.Ve
.PP
On each line are two expressions that do the same thing.  The
left-hand versions operate on the array \f(CW@a\fR.  The right-hand
versions operate on the array that is referred to by \f(CW$aref\fR.  Once
they find the array they're operating on, both versions do the same
things to the arrays.
.PP
Using a hash reference is \fIexactly\fR the same:
.PP
.Vb 4
\&        %h              %{$href}              A hash
\&        keys %h         keys %{$href}         Get the keys from the hash
\&        $h{\*(Aqred\*(Aq}       ${$href}{\*(Aqred\*(Aq}       An element of the hash
\&        $h{\*(Aqred\*(Aq} = 17  ${$href}{\*(Aqred\*(Aq} = 17  Assigning an element
.Ve
.PP
Whatever you want to do with a reference, \fBUse Rule 1\fR tells you how
to do it.  You just write the Perl code that you would have written
for doing the same thing to a regular array or hash, and then replace
the array or hash name with \f(CW\*(C`{$reference}\*(C'\fR.  \*(L"How do I loop over an
array when all I have is a reference?\*(R"  Well, to loop over an array, you
would write
.PP
.Vb 3
\&        for my $element (@array) {
\&           ...
\&        }
.Ve
.PP
so replace the array name, \f(CW@array\fR, with the reference:
.PP
.Vb 3
\&        for my $element (@{$aref}) {
\&           ...
\&        }
.Ve
.PP
\&\*(L"How do I print out the contents of a hash when all I have is a
reference?\*(R"  First write the code for printing out a hash:
.PP
.Vb 3
\&        for my $key (keys %hash) {
\&          print "$key => $hash{$key}\en";
\&        }
.Ve
.PP
And then replace the hash name with the reference:
.PP
.Vb 3
\&        for my $key (keys %{$href}) {
\&          print "$key => ${$href}{$key}\en";
\&        }
.Ve
.PP
\fI\f(BIUse Rule 2\fI\fR
.IX Subsection "Use Rule 2"
.PP
\&\fBUse Rule 1\fR is all you really need, because it tells you how to do
absolutely everything you ever need to do with references.  But the
most common thing to do with an array or a hash is to extract a single
element, and the \fBUse Rule 1\fR notation is cumbersome.  So there is an
abbreviation.
.PP
\&\f(CW\*(C`${$aref}[3]\*(C'\fR is too hard to read, so you can write \f(CW\*(C`$aref\->[3]\*(C'\fR
instead.
.PP
\&\f(CW\*(C`${$href}{red}\*(C'\fR is too hard to read, so you can write
\&\f(CW\*(C`$href\->{red}\*(C'\fR instead.
.PP
If \f(CW$aref\fR holds a reference to an array, then \f(CW\*(C`$aref\->[3]\*(C'\fR is
the fourth element of the array.  Don't confuse this with \f(CW$aref[3]\fR,
which is the fourth element of a totally different array, one
deceptively named \f(CW@aref\fR.  \f(CW$aref\fR and \f(CW@aref\fR are unrelated the
same way that \f(CW$item\fR and \f(CW@item\fR are.
.PP
Similarly, \f(CW\*(C`$href\->{\*(Aqred\*(Aq}\*(C'\fR is part of the hash referred to by
the scalar variable \f(CW$href\fR, perhaps even one with no name.
\&\f(CW$href{\*(Aqred\*(Aq}\fR is part of the deceptively named \f(CW%href\fR hash.  It's
easy to forget to leave out the \f(CW\*(C`\->\*(C'\fR, and if you do, you'll get
bizarre results when your program gets array and hash elements out of
totally unexpected hashes and arrays that weren't the ones you wanted
to use.
.SS "An Example"
.IX Subsection "An Example"
Let's see a quick example of how all this is useful.
.PP
First, remember that \f(CW\*(C`[1, 2, 3]\*(C'\fR makes an anonymous array containing
\&\f(CW\*(C`(1, 2, 3)\*(C'\fR, and gives you a reference to that array.
.PP
Now think about
.PP
.Vb 4
\&        @a = ( [1, 2, 3],
\&               [4, 5, 6],
\&               [7, 8, 9]
\&             );
.Ve
.PP
\&\f(CW@a\fR is an array with three elements, and each one is a reference to
another array.
.PP
\&\f(CW$a[1]\fR is one of these references.  It refers to an array, the array
containing \f(CW\*(C`(4, 5, 6)\*(C'\fR, and because it is a reference to an array,
\&\fBUse Rule 2\fR says that we can write \f(CW$a[1]\->[2]\fR to get the
third element from that array.  \f(CW$a[1]\->[2]\fR is the 6.
Similarly, \f(CW$a[0]\->[1]\fR is the 2.  What we have here is like a
two-dimensional array; you can write \f(CW$a[ROW]\->[COLUMN]\fR to get
or set the element in any row and any column of the array.
.PP
The notation still looks a little cumbersome, so there's one more
abbreviation:
.SS "Arrow Rule"
.IX Subsection "Arrow Rule"
In between two \fBsubscripts\fR, the arrow is optional.
.PP
Instead of \f(CW$a[1]\->[2]\fR, we can write \f(CW$a[1][2]\fR; it means the
same thing.  Instead of \f(CW\*(C`$a[0]\->[1] = 23\*(C'\fR, we can write
\&\f(CW\*(C`$a[0][1] = 23\*(C'\fR; it means the same thing.
.PP
Now it really looks like two-dimensional arrays!
.PP
You can see why the arrows are important.  Without them, we would have
had to write \f(CW\*(C`${$a[1]}[2]\*(C'\fR instead of \f(CW$a[1][2]\fR.  For
three-dimensional arrays, they let us write \f(CW$x[2][3][5]\fR instead of
the unreadable \f(CW\*(C`${${$x[2]}[3]}[5]\*(C'\fR.
.SH "Solution"
.IX Header "Solution"
Here's the answer to the problem I posed earlier, of reformatting a
file of city and country names.
.PP
.Vb 1
\&    1   my %table;
\&
\&    2   while (<>) {
\&    3    chomp;
\&    4     my ($city, $country) = split /, /;
\&    5     $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
\&
\&    8   foreach $country (sort keys %table) {
\&    9     print "$country: ";
\&   10     my @cities = @{$table{$country}};
\&   11     print join \*(Aq, \*(Aq, sort @cities;
\&   12     print ".\en";
\&   13   }
.Ve
.PP
The program has two pieces: Lines 2\-\-7 read the input and build a data
structure, and lines 8\-13 analyze the data and print out the report.
We're going to have a hash, \f(CW%table\fR, whose keys are country names,
and whose values are references to arrays of city names.  The data
structure will look like this:
.PP
.Vb 10
\&           %table
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\&        |Germany| *\-\-\-\->| Frankfurt | Berlin |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-+
\&        |Finland| *\-\-\-\->| Helsinki |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&        |  USA  | *\-\-\-\->| Chicago | Washington | New York |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
.Ve
.PP
We'll look at output first.  Supposing we already have this structure,
how do we print it out?
.PP
.Vb 6
\&    8   foreach $country (sort keys %table) {
\&    9     print "$country: ";
\&   10     my @cities = @{$table{$country}};
\&   11     print join \*(Aq, \*(Aq, sort @cities;
\&   12     print ".\en";
\&   13   }
.Ve
.PP
\&\f(CW%table\fR is an
ordinary hash, and we get a list of keys from it, sort the keys, and
loop over the keys as usual.  The only use of references is in line 10.
\&\f(CW$table{$country}\fR looks up the key \f(CW$country\fR in the hash
and gets the value, which is a reference to an array of cities in that country.
\&\fBUse Rule 1\fR says that
we can recover the array by saying
\&\f(CW\*(C`@{$table{$country}}\*(C'\fR.  Line 10 is just like
.PP
.Vb 1
\&        @cities = @array;
.Ve
.PP
except that the name \f(CW\*(C`array\*(C'\fR has been replaced by the reference
\&\f(CW\*(C`{$table{$country}}\*(C'\fR.  The \f(CW\*(C`@\*(C'\fR tells Perl to get the entire array.
Having gotten the list of cities, we sort it, join it, and print it
out as usual.
.PP
Lines 2\-7 are responsible for building the structure in the first
place.  Here they are again:
.PP
.Vb 6
\&    2   while (<>) {
\&    3    chomp;
\&    4     my ($city, $country) = split /, /;
\&    5     $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
.Ve
.PP
Lines 2\-4 acquire a city and country name.  Line 5 looks to see if the
country is already present as a key in the hash.  If it's not, the
program uses the \f(CW\*(C`[]\*(C'\fR notation (\fBMake Rule 2\fR) to manufacture a new,
empty anonymous array of cities, and installs a reference to it into
the hash under the appropriate key.
.PP
Line 6 installs the city name into the appropriate array.
\&\f(CW$table{$country}\fR now holds a reference to the array of cities seen
in that country so far.  Line 6 is exactly like
.PP
.Vb 1
\&        push @array, $city;
.Ve
.PP
except that the name \f(CW\*(C`array\*(C'\fR has been replaced by the reference
\&\f(CW\*(C`{$table{$country}}\*(C'\fR.  The \f(CW\*(C`push\*(C'\fR adds a city name to the end of the
referred-to array.
.PP
There's one fine point I skipped.  Line 5 is unnecessary, and we can
get rid of it.
.PP
.Vb 6
\&    2   while (<>) {
\&    3    chomp;
\&    4     my ($city, $country) = split /, /;
\&    5   ####  $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
.Ve
.PP
If there's already an entry in \f(CW%table\fR for the current \f(CW$country\fR,
then nothing is different.  Line 6 will locate the value in
\&\f(CW$table{$country}\fR, which is a reference to an array, and push
\&\f(CW$city\fR into the array.  But
what does it do when
\&\f(CW$country\fR holds a key, say \f(CW\*(C`Greece\*(C'\fR, that is not yet in \f(CW%table\fR?
.PP
This is Perl, so it does the exact right thing.  It sees that you want
to push \f(CW\*(C`Athens\*(C'\fR onto an array that doesn't exist, so it helpfully
makes a new, empty, anonymous array for you, installs it into
\&\f(CW%table\fR, and then pushes \f(CW\*(C`Athens\*(C'\fR onto it.  This is called
\&'autovivification'\-\-bringing things to life automatically.  Perl saw
that the key wasn't in the hash, so it created a new hash entry
automatically. Perl saw that you wanted to use the hash value as an
array, so it created a new empty array and installed a reference to it
in the hash automatically.  And as usual, Perl made the array one
element longer to hold the new city name.
.SH "The Rest"
.IX Header "The Rest"
I promised to give you 90% of the benefit with 10% of the details, and
that means I left out 90% of the details.  Now that you have an
overview of the important parts, it should be easier to read the
perlref manual page, which discusses 100% of the details.
.PP
Some of the highlights of perlref:
.IP "\(bu" 4
You can make references to anything, including scalars, functions, and
other references.
.IP "\(bu" 4
In \fBUse Rule 1\fR, you can omit the curly brackets whenever the thing
inside them is an atomic scalar variable like \f(CW$aref\fR.  For example,
\&\f(CW@$aref\fR is the same as \f(CW\*(C`@{$aref}\*(C'\fR, and \f(CW$$aref[1]\fR is the same as
\&\f(CW\*(C`${$aref}[1]\*(C'\fR.  If you're just starting out, you may want to adopt
the habit of always including the curly brackets.
.IP "\(bu" 4
This doesn't copy the underlying array:
.Sp
.Vb 1
\&        $aref2 = $aref1;
.Ve
.Sp
You get two references to the same array.  If you modify
\&\f(CW\*(C`$aref1\->[23]\*(C'\fR and then look at
\&\f(CW\*(C`$aref2\->[23]\*(C'\fR you'll see the change.
.Sp
To copy the array, use
.Sp
.Vb 1
\&        $aref2 = [@{$aref1}];
.Ve
.Sp
This uses \f(CW\*(C`[...]\*(C'\fR notation to create a new anonymous array, and
\&\f(CW$aref2\fR is assigned a reference to the new array.  The new array is
initialized with the contents of the array referred to by \f(CW$aref1\fR.
.Sp
Similarly, to copy an anonymous hash, you can use
.Sp
.Vb 1
\&        $href2 = {%{$href1}};
.Ve
.IP "\(bu" 4
To see if a variable contains a reference, use the \f(CW\*(C`ref\*(C'\fR function.  It
returns true if its argument is a reference.  Actually it's a little
better than that: It returns \f(CW\*(C`HASH\*(C'\fR for hash references and \f(CW\*(C`ARRAY\*(C'\fR
for array references.
.IP "\(bu" 4
If you try to use a reference like a string, you get strings like
.Sp
.Vb 1
\&        ARRAY(0x80f5dec)   or    HASH(0x826afc0)
.Ve
.Sp
If you ever see a string that looks like this, you'll know you
printed out a reference by mistake.
.Sp
A side effect of this representation is that you can use \f(CW\*(C`eq\*(C'\fR to see
if two references refer to the same thing.  (But you should usually use
\&\f(CW\*(C`==\*(C'\fR instead because it's much faster.)
.IP "\(bu" 4
You can use a string as if it were a reference.  If you use the string
\&\f(CW"foo"\fR as an array reference, it's taken to be a reference to the
array \f(CW@foo\fR.  This is called a \fIsoft reference\fR or \fIsymbolic
reference\fR.  The declaration \f(CW\*(C`use strict \*(Aqrefs\*(Aq\*(C'\fR disables this
feature, which can cause all sorts of trouble if you use it by accident.
.PP
You might prefer to go on to perllol instead of perlref; it
discusses lists of lists and multidimensional arrays in detail.  After
that, you should move on to perldsc; it's a Data Structure Cookbook
that shows recipes for using and printing out arrays of hashes, hashes
of arrays, and other kinds of data.
.SH "Summary"
.IX Header "Summary"
Everyone needs compound data structures, and in Perl the way you get
them is with references.  There are four important rules for managing
references: Two for making references and two for using them.  Once
you know these rules you can do most of the important things you need
to do with references.
.SH "Credits"
.IX Header "Credits"
Author: Mark Jason Dominus, Plover Systems (\f(CW\*(C`mjd\-perl\-ref+@plover.com\*(C'\fR)
.PP
This article originally appeared in \fIThe Perl Journal\fR
( http://www.tpj.com/ ) volume 3, #2.  Reprinted with permission.
.PP
The original title was \fIUnderstand References Today\fR.
.SS "Distribution Conditions"
.IX Subsection "Distribution Conditions"
Copyright 1998 The Perl Journal.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in these files are
hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun or for profit
as you see fit.  A simple comment in the code giving credit would be
courteous but is not required.
                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreguts.1                                 0100644 0001750 0001750 00000140200 12566207444 023133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREGUTS 1"
.TH PERLREGUTS 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreguts \- Description of the Perl regular expression engine.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is an attempt to shine some light on the guts of the regex
engine and how it works. The regex engine represents a significant chunk
of the perl codebase, but is relatively poorly understood. This document
is a meagre attempt at addressing this situation. It is derived from the
author's experience, comments in the source code, other papers on the
regex engine, feedback on the perl5\-porters mail list, and no doubt other
places as well.
.PP
\&\fB\s-1NOTICE\s0!\fR It should be clearly understood that the behavior and
structures discussed in this represents the state of the engine as the
author understood it at the time of writing. It is \fB\s-1NOT\s0\fR an \s-1API\s0
definition, it is purely an internals guide for those who want to hack
the regex engine, or understand how the regex engine works. Readers of
this document are expected to understand perl's regex syntax and its
usage in detail. If you want to learn about the basics of Perl's
regular expressions, see perlre. And if you want to replace the
regex engine with your own, see perlreapi.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
.SS "A quick note on terms"
.IX Subsection "A quick note on terms"
There is some debate as to whether to say \*(L"regexp\*(R" or \*(L"regex\*(R". In this
document we will use the term \*(L"regex\*(R" unless there is a special reason
not to, in which case we will explain why.
.PP
When speaking about regexes we need to distinguish between their source
code form and their internal form. In this document we will use the term
\&\*(L"pattern\*(R" when we speak of their textual, source code form, and the term
\&\*(L"program\*(R" when we speak of their internal representation. These
correspond to the terms \fIS\-regex\fR and \fIB\-regex\fR that Mark Jason
Dominus employs in his paper on \*(L"Rx\*(R" ([1] in \*(L"\s-1REFERENCES\*(R"\s0).
.SS "What is a regular expression engine?"
.IX Subsection "What is a regular expression engine?"
A regular expression engine is a program that takes a set of constraints
specified in a mini-language, and then applies those constraints to a
target string, and determines whether or not the string satisfies the
constraints. See perlre for a full definition of the language.
.PP
In less grandiose terms, the first part of the job is to turn a pattern into
something the computer can efficiently use to find the matching point in
the string, and the second part is performing the search itself.
.PP
To do this we need to produce a program by parsing the text. We then
need to execute the program to find the point in the string that
matches. And we need to do the whole thing efficiently.
.SS "Structure of a Regexp Program"
.IX Subsection "Structure of a Regexp Program"
\fIHigh Level\fR
.IX Subsection "High Level"
.PP
Although it is a bit confusing and some people object to the terminology, it
is worth taking a look at a comment that has
been in \fIregexp.h\fR for years:
.PP
\&\fIThis is essentially a linear encoding of a nondeterministic
finite-state machine (aka syntax charts or \*(L"railroad normal form\*(R" in
parsing technology).\fR
.PP
The term \*(L"railroad normal form\*(R" is a bit esoteric, with \*(L"syntax
diagram/charts\*(R", or \*(L"railroad diagram/charts\*(R" being more common terms.
Nevertheless it provides a useful mental image of a regex program: each
node can be thought of as a unit of track, with a single entry and in
most cases a single exit point (there are pieces of track that fork, but
statistically not many), and the whole forms a layout with a
single entry and single exit point. The matching process can be thought
of as a car that moves along the track, with the particular route through
the system being determined by the character read at each possible
connector point. A car can fall off the track at any point but it may
only proceed as long as it matches the track.
.PP
Thus the pattern \f(CW\*(C`/foo(?:\ew+|\ed+|\es+)bar/\*(C'\fR can be thought of as the
following chart:
.PP
.Vb 10
\&                      [start]
\&                         |
\&                       <foo>
\&                         |
\&                   +\-\-\-\-\-+\-\-\-\-\-+
\&                   |     |     |
\&                 <\ew+> <\ed+> <\es+>
\&                   |     |     |
\&                   +\-\-\-\-\-+\-\-\-\-\-+
\&                         |
\&                       <bar>
\&                         |
\&                       [end]
.Ve
.PP
The truth of the matter is that perl's regular expressions these days are
much more complex than this kind of structure, but visualising it this way
can help when trying to get your bearings, and it matches the
current implementation pretty closely.
.PP
To be more precise, we will say that a regex program is an encoding
of a graph. Each node in the graph corresponds to part of
the original regex pattern, such as a literal string or a branch,
and has a pointer to the nodes representing the next component
to be matched. Since \*(L"node\*(R" and \*(L"opcode\*(R" already have other meanings in the
perl source, we will call the nodes in a regex program \*(L"regops\*(R".
.PP
The program is represented by an array of \f(CW\*(C`regnode\*(C'\fR structures, one or
more of which represent a single regop of the program. Struct
\&\f(CW\*(C`regnode\*(C'\fR is the smallest struct needed, and has a field structure which is
shared with all the other larger structures.
.PP
The \*(L"next\*(R" pointers of all regops except \f(CW\*(C`BRANCH\*(C'\fR implement concatenation;
a \*(L"next\*(R" pointer with a \f(CW\*(C`BRANCH\*(C'\fR on both ends of it is connecting two
alternatives.  [Here we have one of the subtle syntax dependencies: an
individual \f(CW\*(C`BRANCH\*(C'\fR (as opposed to a collection of them) is never
concatenated with anything because of operator precedence.]
.PP
The operand of some types of regop is a literal string; for others,
it is a regop leading into a sub-program.  In particular, the operand
of a \f(CW\*(C`BRANCH\*(C'\fR node is the first regop of the branch.
.PP
\&\fB\s-1NOTE\s0\fR: As the railroad metaphor suggests, this is \fBnot\fR a tree
structure:  the tail of the branch connects to the thing following the
set of \f(CW\*(C`BRANCH\*(C'\fRes.  It is a like a single line of railway track that
splits as it goes into a station or railway yard and rejoins as it comes
out the other side.
.PP
\fIRegops\fR
.IX Subsection "Regops"
.PP
The base structure of a regop is defined in \fIregexp.h\fR as follows:
.PP
.Vb 5
\&    struct regnode {
\&        U8  flags;    /* Various purposes, sometimes overridden */
\&        U8  type;     /* Opcode value as specified by regnodes.h */
\&        U16 next_off; /* Offset in size regnode */
\&    };
.Ve
.PP
Other larger \f(CW\*(C`regnode\*(C'\fR\-like structures are defined in \fIregcomp.h\fR. They
are almost like subclasses in that they have the same fields as
\&\f(CW\*(C`regnode\*(C'\fR, with possibly additional fields following in
the structure, and in some cases the specific meaning (and name)
of some of base fields are overridden. The following is a more
complete description.
.ie n .IP """regnode_1""" 4
.el .IP "\f(CWregnode_1\fR" 4
.IX Item "regnode_1"
.PD 0
.ie n .IP """regnode_2""" 4
.el .IP "\f(CWregnode_2\fR" 4
.IX Item "regnode_2"
.PD
\&\f(CW\*(C`regnode_1\*(C'\fR structures have the same header, followed by a single
four-byte argument; \f(CW\*(C`regnode_2\*(C'\fR structures contain two two-byte
arguments instead:
.Sp
.Vb 2
\&    regnode_1                U32 arg1;
\&    regnode_2                U16 arg1;  U16 arg2;
.Ve
.ie n .IP """regnode_string""" 4
.el .IP "\f(CWregnode_string\fR" 4
.IX Item "regnode_string"
\&\f(CW\*(C`regnode_string\*(C'\fR structures, used for literal strings, follow the header
with a one-byte length and then the string data. Strings are padded on
the end with zero bytes so that the total length of the node is a
multiple of four bytes:
.Sp
.Vb 2
\&    regnode_string           char string[1];
\&                             U8 str_len; /* overrides flags */
.Ve
.ie n .IP """regnode_charclass""" 4
.el .IP "\f(CWregnode_charclass\fR" 4
.IX Item "regnode_charclass"
Character classes are represented by \f(CW\*(C`regnode_charclass\*(C'\fR structures,
which have a four-byte argument and then a 32\-byte (256\-bit) bitmap
indicating which characters are included in the class.
.Sp
.Vb 2
\&    regnode_charclass        U32 arg1;
\&                             char bitmap[ANYOF_BITMAP_SIZE];
.Ve
.ie n .IP """regnode_charclass_class""" 4
.el .IP "\f(CWregnode_charclass_class\fR" 4
.IX Item "regnode_charclass_class"
There is also a larger form of a char class structure used to represent
\&\s-1POSIX\s0 char classes called \f(CW\*(C`regnode_charclass_class\*(C'\fR which has an
additional 4\-byte (32\-bit) bitmap indicating which \s-1POSIX\s0 char classes
have been included.
.Sp
.Vb 3
\&   regnode_charclass_class  U32 arg1;
\&                            char bitmap[ANYOF_BITMAP_SIZE];
\&                            char classflags[ANYOF_CLASSBITMAP_SIZE];
.Ve
.PP
\&\fIregnodes.h\fR defines an array called \f(CW\*(C`regarglen[]\*(C'\fR which gives the size
of each opcode in units of \f(CW\*(C`size regnode\*(C'\fR (4\-byte). A macro is used
to calculate the size of an \f(CW\*(C`EXACT\*(C'\fR node based on its \f(CW\*(C`str_len\*(C'\fR field.
.PP
The regops are defined in \fIregnodes.h\fR which is generated from
\&\fIregcomp.sym\fR by \fIregcomp.pl\fR. Currently the maximum possible number
of distinct regops is restricted to 256, with about a quarter already
used.
.PP
A set of macros makes accessing the fields
easier and more consistent. These include \f(CW\*(C`OP()\*(C'\fR, which is used to determine
the type of a \f(CW\*(C`regnode\*(C'\fR\-like structure; \f(CW\*(C`NEXT_OFF()\*(C'\fR, which is the offset to
the next node (more on this later); \f(CW\*(C`ARG()\*(C'\fR, \f(CW\*(C`ARG1()\*(C'\fR, \f(CW\*(C`ARG2()\*(C'\fR, \f(CW\*(C`ARG_SET()\*(C'\fR,
and equivalents for reading and setting the arguments; and \f(CW\*(C`STR_LEN()\*(C'\fR,
\&\f(CW\*(C`STRING()\*(C'\fR and \f(CW\*(C`OPERAND()\*(C'\fR for manipulating strings and regop bearing
types.
.PP
\fIWhat regop is next?\fR
.IX Subsection "What regop is next?"
.PP
There are three distinct concepts of \*(L"next\*(R" in the regex engine, and
it is important to keep them clear.
.IP "\(bu" 4
There is the \*(L"next regnode\*(R" from a given regnode, a value which is
rarely useful except that sometimes it matches up in terms of value
with one of the others, and that sometimes the code assumes this to
always be so.
.IP "\(bu" 4
There is the \*(L"next regop\*(R" from a given regop/regnode. This is the
regop physically located after the current one, as determined by
the size of the current regop. This is often useful, such as when
dumping the structure we use this order to traverse. Sometimes the code
assumes that the \*(L"next regnode\*(R" is the same as the \*(L"next regop\*(R", or in
other words assumes that the sizeof a given regop type is always going
to be one regnode large.
.IP "\(bu" 4
There is the \*(L"regnext\*(R" from a given regop. This is the regop which
is reached by jumping forward by the value of \f(CW\*(C`NEXT_OFF()\*(C'\fR,
or in a few cases for longer jumps by the \f(CW\*(C`arg1\*(C'\fR field of the \f(CW\*(C`regnode_1\*(C'\fR
structure. The subroutine \f(CW\*(C`regnext()\*(C'\fR handles this transparently.
This is the logical successor of the node, which in some cases, like
that of the \f(CW\*(C`BRANCH\*(C'\fR regop, has special meaning.
.SH "Process Overview"
.IX Header "Process Overview"
Broadly speaking, performing a match of a string against a pattern
involves the following steps:
.IP "A. Compilation" 5
.IX Item "A. Compilation"
.RS 5
.PD 0
.IP "1. Parsing for size" 5
.IX Item "1. Parsing for size"
.IP "2. Parsing for construction" 5
.IX Item "2. Parsing for construction"
.IP "3. Peep-hole optimisation and analysis" 5
.IX Item "3. Peep-hole optimisation and analysis"
.RE
.RS 5
.RE
.IP "B. Execution" 5
.IX Item "B. Execution"
.RS 5
.IP "4. Start position and no-match optimisations" 5
.IX Item "4. Start position and no-match optimisations"
.IP "5. Program execution" 5
.IX Item "5. Program execution"
.RE
.RS 5
.RE
.PD
.PP
Where these steps occur in the actual execution of a perl program is
determined by whether the pattern involves interpolating any string
variables. If interpolation occurs, then compilation happens at run time. If it
does not, then compilation is performed at compile time. (The \f(CW\*(C`/o\*(C'\fR modifier changes this,
as does \f(CW\*(C`qr//\*(C'\fR to a certain extent.) The engine doesn't really care that
much.
.SS "Compilation"
.IX Subsection "Compilation"
This code resides primarily in \fIregcomp.c\fR, along with the header files
\&\fIregcomp.h\fR, \fIregexp.h\fR and \fIregnodes.h\fR.
.PP
Compilation starts with \f(CW\*(C`pregcomp()\*(C'\fR, which is mostly an initialisation
wrapper which farms work out to two other routines for the heavy lifting: the
first is \f(CW\*(C`reg()\*(C'\fR, which is the start point for parsing; the second,
\&\f(CW\*(C`study_chunk()\*(C'\fR, is responsible for optimisation.
.PP
Initialisation in \f(CW\*(C`pregcomp()\*(C'\fR mostly involves the creation and data-filling
of a special structure, \f(CW\*(C`RExC_state_t\*(C'\fR (defined in \fIregcomp.c\fR).
Almost all internally-used routines in \fIregcomp.h\fR take a pointer to one
of these structures as their first argument, with the name \f(CW\*(C`pRExC_state\*(C'\fR.
This structure is used to store the compilation state and contains many
fields. Likewise there are many macros which operate on this
variable: anything that looks like \f(CW\*(C`RExC_xxxx\*(C'\fR is a macro that operates on
this pointer/structure.
.PP
\fIParsing for size\fR
.IX Subsection "Parsing for size"
.PP
In this pass the input pattern is parsed in order to calculate how much
space is needed for each regop we would need to emit. The size is also
used to determine whether long jumps will be required in the program.
.PP
This stage is controlled by the macro \f(CW\*(C`SIZE_ONLY\*(C'\fR being set.
.PP
The parse proceeds pretty much exactly as it does during the
construction phase, except that most routines are short-circuited to
change the size field \f(CW\*(C`RExC_size\*(C'\fR and not do anything else.
.PP
\fIParsing for construction\fR
.IX Subsection "Parsing for construction"
.PP
Once the size of the program has been determined, the pattern is parsed
again, but this time for real. Now \f(CW\*(C`SIZE_ONLY\*(C'\fR will be false, and the
actual construction can occur.
.PP
\&\f(CW\*(C`reg()\*(C'\fR is the start of the parse process. It is responsible for
parsing an arbitrary chunk of pattern up to either the end of the
string, or the first closing parenthesis it encounters in the pattern.
This means it can be used to parse the top-level regex, or any section
inside of a grouping parenthesis. It also handles the \*(L"special parens\*(R"
that perl's regexes have. For instance when parsing \f(CW\*(C`/x(?:foo)y/\*(C'\fR \f(CW\*(C`reg()\*(C'\fR
will at one point be called to parse from the \*(L"?\*(R" symbol up to and
including the \*(L")\*(R".
.PP
Additionally, \f(CW\*(C`reg()\*(C'\fR is responsible for parsing the one or more
branches from the pattern, and for \*(L"finishing them off\*(R" by correctly
setting their next pointers. In order to do the parsing, it repeatedly
calls out to \f(CW\*(C`regbranch()\*(C'\fR, which is responsible for handling up to the
first \f(CW\*(C`|\*(C'\fR symbol it sees.
.PP
\&\f(CW\*(C`regbranch()\*(C'\fR in turn calls \f(CW\*(C`regpiece()\*(C'\fR which
handles \*(L"things\*(R" followed by a quantifier. In order to parse the
\&\*(L"things\*(R", \f(CW\*(C`regatom()\*(C'\fR is called. This is the lowest level routine, which
parses out constant strings, character classes, and the
various special symbols like \f(CW\*(C`$\*(C'\fR. If \f(CW\*(C`regatom()\*(C'\fR encounters a \*(L"(\*(R"
character it in turn calls \f(CW\*(C`reg()\*(C'\fR.
.PP
The routine \f(CW\*(C`regtail()\*(C'\fR is called by both \f(CW\*(C`reg()\*(C'\fR and \f(CW\*(C`regbranch()\*(C'\fR
in order to \*(L"set the tail pointer\*(R" correctly. When executing and
we get to the end of a branch, we need to go to the node following the
grouping parens. When parsing, however, we don't know where the end will
be until we get there, so when we do we must go back and update the
offsets as appropriate. \f(CW\*(C`regtail\*(C'\fR is used to make this easier.
.PP
A subtlety of the parsing process means that a regex like \f(CW\*(C`/foo/\*(C'\fR is
originally parsed into an alternation with a single branch. It is only
afterwards that the optimiser converts single branch alternations into the
simpler form.
.PP
\fIParse Call Graph and a Grammar\fR
.IX Subsection "Parse Call Graph and a Grammar"
.PP
The call graph looks like this:
.PP
.Vb 10
\& reg()                        # parse a top level regex, or inside of
\&                              # parens
\&     regbranch()              # parse a single branch of an alternation
\&         regpiece()           # parse a pattern followed by a quantifier
\&             regatom()        # parse a simple pattern
\&                 regclass()   #   used to handle a class
\&                 reg()        #   used to handle a parenthesised
\&                              #   subpattern
\&                 ....
\&         ...
\&         regtail()            # finish off the branch
\&     ...
\&     regtail()                # finish off the branch sequence. Tie each
\&                              # branch\*(Aqs tail to the tail of the
\&                              # sequence
\&                              # (NEW) In Debug mode this is
\&                              # regtail_study().
.Ve
.PP
A grammar form might be something like this:
.PP
.Vb 11
\&    atom  : constant | class
\&    quant : \*(Aq*\*(Aq | \*(Aq+\*(Aq | \*(Aq?\*(Aq | \*(Aq{min,max}\*(Aq
\&    _branch: piece
\&           | piece _branch
\&           | nothing
\&    branch: _branch
\&          | _branch \*(Aq|\*(Aq branch
\&    group : \*(Aq(\*(Aq branch \*(Aq)\*(Aq
\&    _piece: atom | group
\&    piece : _piece
\&          | _piece quant
.Ve
.PP
\fIParsing complications\fR
.IX Subsection "Parsing complications"
.PP
The implication of the above description is that a pattern containing nested
parentheses will result in a call graph which cycles through \f(CW\*(C`reg()\*(C'\fR,
\&\f(CW\*(C`regbranch()\*(C'\fR, \f(CW\*(C`regpiece()\*(C'\fR, \f(CW\*(C`regatom()\*(C'\fR, \f(CW\*(C`reg()\*(C'\fR, \f(CW\*(C`regbranch()\*(C'\fR \fIetc\fR
multiple times, until the deepest level of nesting is reached. All the above
routines return a pointer to a \f(CW\*(C`regnode\*(C'\fR, which is usually the last regnode
added to the program. However, one complication is that \fIreg()\fR returns \s-1NULL\s0
for parsing \f(CW\*(C`(?:)\*(C'\fR syntax for embedded modifiers, setting the flag
\&\f(CW\*(C`TRYAGAIN\*(C'\fR. The \f(CW\*(C`TRYAGAIN\*(C'\fR propagates upwards until it is captured, in
some cases by by \f(CW\*(C`regatom()\*(C'\fR, but otherwise unconditionally by
\&\f(CW\*(C`regbranch()\*(C'\fR. Hence it will never be returned by \f(CW\*(C`regbranch()\*(C'\fR to
\&\f(CW\*(C`reg()\*(C'\fR. This flag permits patterns such as \f(CW\*(C`(?i)+\*(C'\fR to be detected as
errors (\fIQuantifier follows nothing in regex; marked by <\-\- \s-1HERE\s0 in m/(?i)+
<\-\- \s-1HERE /\s0\fR).
.PP
Another complication is that the representation used for the program differs
if it needs to store Unicode, but it's not always possible to know for sure
whether it does until midway through parsing. The Unicode representation for
the program is larger, and cannot be matched as efficiently. (See \*(L"Unicode
and Localisation Support\*(R" below for more details as to why.)  If the pattern
contains literal Unicode, it's obvious that the program needs to store
Unicode. Otherwise, the parser optimistically assumes that the more
efficient representation can be used, and starts sizing on this basis.
However, if it then encounters something in the pattern which must be stored
as Unicode, such as an \f(CW\*(C`\ex{...}\*(C'\fR escape sequence representing a character
literal, then this means that all previously calculated sizes need to be
redone, using values appropriate for the Unicode representation. Currently,
all regular expression constructions which can trigger this are parsed by code
in \f(CW\*(C`regatom()\*(C'\fR.
.PP
To avoid wasted work when a restart is needed, the sizing pass is abandoned
\&\- \f(CW\*(C`regatom()\*(C'\fR immediately returns \s-1NULL,\s0 setting the flag \f(CW\*(C`RESTART_UTF8\*(C'\fR.
(This action is encapsulated using the macro \f(CW\*(C`REQUIRE_UTF8\*(C'\fR.) This restart
request is propagated up the call chain in a similar fashion, until it is
\&\*(L"caught\*(R" in \f(CW\*(C`Perl_re_op_compile()\*(C'\fR, which marks the pattern as containing
Unicode, and restarts the sizing pass. It is also possible for constructions
within run-time code blocks to turn out to need Unicode representation.,
which is signalled by \f(CW\*(C`S_compile_runtime_code()\*(C'\fR returning false to
\&\f(CW\*(C`Perl_re_op_compile()\*(C'\fR.
.PP
The restart was previously implemented using a \f(CW\*(C`longjmp\*(C'\fR in \f(CW\*(C`regatom()\*(C'\fR
back to a \f(CW\*(C`setjmp\*(C'\fR in \f(CW\*(C`Perl_re_op_compile()\*(C'\fR, but this proved to be
problematic as the latter is a large function containing many automatic
variables, which interact badly with the emergent control flow of \f(CW\*(C`setjmp\*(C'\fR.
.PP
\fIDebug Output\fR
.IX Subsection "Debug Output"
.PP
In the 5.9.x development version of perl you can \f(CW\*(C`use re Debug => \*(AqPARSE\*(Aq\*(C'\fR
to see some trace information about the parse process. We will start with some
simple patterns and build up to more complex patterns.
.PP
So when we parse \f(CW\*(C`/foo/\*(C'\fR we see something like the following table. The
left shows what is being parsed, and the number indicates where the next regop
would go. The stuff on the right is the trace output of the graph. The
names are chosen to be short to make it less dense on the screen. 'tsdy'
is a special form of \f(CW\*(C`regtail()\*(C'\fR which does some extra analysis.
.PP
.Vb 6
\& >foo<             1    reg
\&                          brnc
\&                            piec
\&                              atom
\& ><                4      tsdy~ EXACT <foo> (EXACT) (1)
\&                              ~ attach to END (3) offset to 2
.Ve
.PP
The resulting program then looks like:
.PP
.Vb 2
\&   1: EXACT <foo>(3)
\&   3: END(0)
.Ve
.PP
As you can see, even though we parsed out a branch and a piece, it was ultimately
only an atom. The final program shows us how things work. We have an \f(CW\*(C`EXACT\*(C'\fR regop,
followed by an \f(CW\*(C`END\*(C'\fR regop. The number in parens indicates where the \f(CW\*(C`regnext\*(C'\fR of
the node goes. The \f(CW\*(C`regnext\*(C'\fR of an \f(CW\*(C`END\*(C'\fR regop is unused, as \f(CW\*(C`END\*(C'\fR regops mean
we have successfully matched. The number on the left indicates the position of
the regop in the regnode array.
.PP
Now let's try a harder pattern. We will add a quantifier, so now we have the pattern
\&\f(CW\*(C`/foo+/\*(C'\fR. We will see that \f(CW\*(C`regbranch()\*(C'\fR calls \f(CW\*(C`regpiece()\*(C'\fR twice.
.PP
.Vb 10
\& >foo+<            1    reg
\&                          brnc
\&                            piec
\&                              atom
\& >o+<              3        piec
\&                              atom
\& ><                6        tail~ EXACT <fo> (1)
\&                   7      tsdy~ EXACT <fo> (EXACT) (1)
\&                              ~ PLUS (END) (3)
\&                              ~ attach to END (6) offset to 3
.Ve
.PP
And we end up with the program:
.PP
.Vb 4
\&   1: EXACT <fo>(3)
\&   3: PLUS(6)
\&   4:   EXACT <o>(0)
\&   6: END(0)
.Ve
.PP
Now we have a special case. The \f(CW\*(C`EXACT\*(C'\fR regop has a \f(CW\*(C`regnext\*(C'\fR of 0. This is
because if it matches it should try to match itself again. The \f(CW\*(C`PLUS\*(C'\fR regop
handles the actual failure of the \f(CW\*(C`EXACT\*(C'\fR regop and acts appropriately (going
to regnode 6 if the \f(CW\*(C`EXACT\*(C'\fR matched at least once, or failing if it didn't).
.PP
Now for something much more complex: \f(CW\*(C`/x(?:foo*|b[a][rR])(foo|bar)$/\*(C'\fR
.PP
.Vb 10
\& >x(?:foo*|b...    1    reg
\&                          brnc
\&                            piec
\&                              atom
\& >(?:foo*|b[...    3        piec
\&                              atom
\& >?:foo*|b[a...                 reg
\& >foo*|b[a][...                   brnc
\&                                    piec
\&                                      atom
\& >o*|b[a][rR...    5                piec
\&                                      atom
\& >|b[a][rR])...    8                tail~ EXACT <fo> (3)
\& >b[a][rR])(...    9              brnc
\&                  10                piec
\&                                      atom
\& >[a][rR])(f...   12                piec
\&                                      atom
\& >a][rR])(fo...                         clas
\& >[rR])(foo|...   14                tail~ EXACT <b> (10)
\&                                    piec
\&                                      atom
\& >rR])(foo|b...                         clas
\& >)(foo|bar)...   25                tail~ EXACT <a> (12)
\&                                  tail~ BRANCH (3)
\&                  26              tsdy~ BRANCH (END) (9)
\&                                      ~ attach to TAIL (25) offset to 16
\&                                  tsdy~ EXACT <fo> (EXACT) (4)
\&                                      ~ STAR (END) (6)
\&                                      ~ attach to TAIL (25) offset to 19
\&                                  tsdy~ EXACT <b> (EXACT) (10)
\&                                      ~ EXACT <a> (EXACT) (12)
\&                                      ~ ANYOF[Rr] (END) (14)
\&                                      ~ attach to TAIL (25) offset to 11
\& >(foo|bar)$<               tail~ EXACT <x> (1)
\&                            piec
\&                              atom
\& >foo|bar)$<                    reg
\&                  28              brnc
\&                                    piec
\&                                      atom
\& >|bar)$<         31              tail~ OPEN1 (26)
\& >bar)$<                          brnc
\&                  32                piec
\&                                      atom
\& >)$<             34              tail~ BRANCH (28)
\&                  36              tsdy~ BRANCH (END) (31)
\&                                     ~ attach to CLOSE1 (34) offset to 3
\&                                  tsdy~ EXACT <foo> (EXACT) (29)
\&                                     ~ attach to CLOSE1 (34) offset to 5
\&                                  tsdy~ EXACT <bar> (EXACT) (32)
\&                                     ~ attach to CLOSE1 (34) offset to 2
\& >$<                        tail~ BRANCH (3)
\&                                ~ BRANCH (9)
\&                                ~ TAIL (25)
\&                            piec
\&                              atom
\& ><               37        tail~ OPEN1 (26)
\&                                ~ BRANCH (28)
\&                                ~ BRANCH (31)
\&                                ~ CLOSE1 (34)
\&                  38      tsdy~ EXACT <x> (EXACT) (1)
\&                              ~ BRANCH (END) (3)
\&                              ~ BRANCH (END) (9)
\&                              ~ TAIL (END) (25)
\&                              ~ OPEN1 (END) (26)
\&                              ~ BRANCH (END) (28)
\&                              ~ BRANCH (END) (31)
\&                              ~ CLOSE1 (END) (34)
\&                              ~ EOL (END) (36)
\&                              ~ attach to END (37) offset to 1
.Ve
.PP
Resulting in the program
.PP
.Vb 10
\&   1: EXACT <x>(3)
\&   3: BRANCH(9)
\&   4:   EXACT <fo>(6)
\&   6:   STAR(26)
\&   7:     EXACT <o>(0)
\&   9: BRANCH(25)
\&  10:   EXACT <ba>(14)
\&  12:   OPTIMIZED (2 nodes)
\&  14:   ANYOF[Rr](26)
\&  25: TAIL(26)
\&  26: OPEN1(28)
\&  28:   TRIE\-EXACT(34)
\&        [StS:1 Wds:2 Cs:6 Uq:5 #Sts:7 Mn:3 Mx:3 Stcls:bf]
\&          <foo>
\&          <bar>
\&  30:   OPTIMIZED (4 nodes)
\&  34: CLOSE1(36)
\&  36: EOL(37)
\&  37: END(0)
.Ve
.PP
Here we can see a much more complex program, with various optimisations in
play. At regnode 10 we see an example where a character class with only
one character in it was turned into an \f(CW\*(C`EXACT\*(C'\fR node. We can also see where
an entire alternation was turned into a \f(CW\*(C`TRIE\-EXACT\*(C'\fR node. As a consequence,
some of the regnodes have been marked as optimised away. We can see that
the \f(CW\*(C`$\*(C'\fR symbol has been converted into an \f(CW\*(C`EOL\*(C'\fR regop, a special piece of
code that looks for \f(CW\*(C`\en\*(C'\fR or the end of the string.
.PP
The next pointer for \f(CW\*(C`BRANCH\*(C'\fRes is interesting in that it points at where
execution should go if the branch fails. When executing, if the engine
tries to traverse from a branch to a \f(CW\*(C`regnext\*(C'\fR that isn't a branch then
the engine will know that the entire set of branches has failed.
.PP
\fIPeep-hole Optimisation and Analysis\fR
.IX Subsection "Peep-hole Optimisation and Analysis"
.PP
The regular expression engine can be a weighty tool to wield. On long
strings and complex patterns it can end up having to do a lot of work
to find a match, and even more to decide that no match is possible.
Consider a situation like the following pattern.
.PP
.Vb 1
\&   \*(Aqababababababababababab\*(Aq =~ /(a|b)*z/
.Ve
.PP
The \f(CW\*(C`(a|b)*\*(C'\fR part can match at every char in the string, and then fail
every time because there is no \f(CW\*(C`z\*(C'\fR in the string. So obviously we can
avoid using the regex engine unless there is a \f(CW\*(C`z\*(C'\fR in the string.
Likewise in a pattern like:
.PP
.Vb 1
\&   /foo(\ew+)bar/
.Ve
.PP
In this case we know that the string must contain a \f(CW\*(C`foo\*(C'\fR which must be
followed by \f(CW\*(C`bar\*(C'\fR. We can use Fast Boyer-Moore matching as implemented
in \f(CW\*(C`fbm_instr()\*(C'\fR to find the location of these strings. If they don't exist
then we don't need to resort to the much more expensive regex engine.
Even better, if they do exist then we can use their positions to
reduce the search space that the regex engine needs to cover to determine
if the entire pattern matches.
.PP
There are various aspects of the pattern that can be used to facilitate
optimisations along these lines:
.IP "\(bu" 5
anchored fixed strings
.IP "\(bu" 5
floating fixed strings
.IP "\(bu" 5
minimum and maximum length requirements
.IP "\(bu" 5
start class
.IP "\(bu" 5
Beginning/End of line positions
.PP
Another form of optimisation that can occur is the post-parse \*(L"peep-hole\*(R"
optimisation, where inefficient constructs are replaced by more efficient
constructs. The \f(CW\*(C`TAIL\*(C'\fR regops which are used during parsing to mark the end
of branches and the end of groups are examples of this. These regops are used
as place-holders during construction and \*(L"always match\*(R" so they can be
\&\*(L"optimised away\*(R" by making the things that point to the \f(CW\*(C`TAIL\*(C'\fR point to the
thing that \f(CW\*(C`TAIL\*(C'\fR points to, thus \*(L"skipping\*(R" the node.
.PP
Another optimisation that can occur is that of "\f(CW\*(C`EXACT\*(C'\fR merging" which is
where two consecutive \f(CW\*(C`EXACT\*(C'\fR nodes are merged into a single
regop. An even more aggressive form of this is that a branch
sequence of the form \f(CW\*(C`EXACT BRANCH ... EXACT\*(C'\fR can be converted into a
\&\f(CW\*(C`TRIE\-EXACT\*(C'\fR regop.
.PP
All of this occurs in the routine \f(CW\*(C`study_chunk()\*(C'\fR which uses a special
structure \f(CW\*(C`scan_data_t\*(C'\fR to store the analysis that it has performed, and
does the \*(L"peep-hole\*(R" optimisations as it goes.
.PP
The code involved in \f(CW\*(C`study_chunk()\*(C'\fR is extremely cryptic. Be careful. :\-)
.SS "Execution"
.IX Subsection "Execution"
Execution of a regex generally involves two phases, the first being
finding the start point in the string where we should match from,
and the second being running the regop interpreter.
.PP
If we can tell that there is no valid start point then we don't bother running
interpreter at all. Likewise, if we know from the analysis phase that we
cannot detect a short-cut to the start position, we go straight to the
interpreter.
.PP
The two entry points are \f(CW\*(C`re_intuit_start()\*(C'\fR and \f(CW\*(C`pregexec()\*(C'\fR. These routines
have a somewhat incestuous relationship with overlap between their functions,
and \f(CW\*(C`pregexec()\*(C'\fR may even call \f(CW\*(C`re_intuit_start()\*(C'\fR on its own. Nevertheless
other parts of the perl source code may call into either, or both.
.PP
Execution of the interpreter itself used to be recursive, but thanks to the
efforts of Dave Mitchell in the 5.9.x development track, that has changed: now an
internal stack is maintained on the heap and the routine is fully
iterative. This can make it tricky as the code is quite conservative
about what state it stores, with the result that two consecutive lines in the
code can actually be running in totally different contexts due to the
simulated recursion.
.PP
\fIStart position and no-match optimisations\fR
.IX Subsection "Start position and no-match optimisations"
.PP
\&\f(CW\*(C`re_intuit_start()\*(C'\fR is responsible for handling start points and no-match
optimisations as determined by the results of the analysis done by
\&\f(CW\*(C`study_chunk()\*(C'\fR (and described in \*(L"Peep-hole Optimisation and Analysis\*(R").
.PP
The basic structure of this routine is to try to find the start\- and/or
end-points of where the pattern could match, and to ensure that the string
is long enough to match the pattern. It tries to use more efficient
methods over less efficient methods and may involve considerable
cross-checking of constraints to find the place in the string that matches.
For instance it may try to determine that a given fixed string must be
not only present but a certain number of chars before the end of the
string, or whatever.
.PP
It calls several other routines, such as \f(CW\*(C`fbm_instr()\*(C'\fR which does
Fast Boyer Moore matching and \f(CW\*(C`find_byclass()\*(C'\fR which is responsible for
finding the start using the first mandatory regop in the program.
.PP
When the optimisation criteria have been satisfied, \f(CW\*(C`reg_try()\*(C'\fR is called
to perform the match.
.PP
\fIProgram execution\fR
.IX Subsection "Program execution"
.PP
\&\f(CW\*(C`pregexec()\*(C'\fR is the main entry point for running a regex. It contains
support for initialising the regex interpreter's state, running
\&\f(CW\*(C`re_intuit_start()\*(C'\fR if needed, and running the interpreter on the string
from various start positions as needed. When it is necessary to use
the regex interpreter \f(CW\*(C`pregexec()\*(C'\fR calls \f(CW\*(C`regtry()\*(C'\fR.
.PP
\&\f(CW\*(C`regtry()\*(C'\fR is the entry point into the regex interpreter. It expects
as arguments a pointer to a \f(CW\*(C`regmatch_info\*(C'\fR structure and a pointer to
a string.  It returns an integer 1 for success and a 0 for failure.
It is basically a set-up wrapper around \f(CW\*(C`regmatch()\*(C'\fR.
.PP
\&\f(CW\*(C`regmatch\*(C'\fR is the main \*(L"recursive loop\*(R" of the interpreter. It is
basically a giant switch statement that implements a state machine, where
the possible states are the regops themselves, plus a number of additional
intermediate and failure states. A few of the states are implemented as
subroutines but the bulk are inline code.
.SH "MISCELLANEOUS"
.IX Header "MISCELLANEOUS"
.SS "Unicode and Localisation Support"
.IX Subsection "Unicode and Localisation Support"
When dealing with strings containing characters that cannot be represented
using an eight-bit character set, perl uses an internal representation
that is a permissive version of Unicode's \s-1UTF\-8\s0 encoding[2]. This uses single
bytes to represent characters from the \s-1ASCII\s0 character set, and sequences
of two or more bytes for all other characters. (See perlunitut
for more information about the relationship between \s-1UTF\-8\s0 and perl's
encoding, utf8. The difference isn't important for this discussion.)
.PP
No matter how you look at it, Unicode support is going to be a pain in a
regex engine. Tricks that might be fine when you have 256 possible
characters often won't scale to handle the size of the \s-1UTF\-8\s0 character
set.  Things you can take for granted with \s-1ASCII\s0 may not be true with
Unicode. For instance, in \s-1ASCII,\s0 it is safe to assume that
\&\f(CW\*(C`sizeof(char1) == sizeof(char2)\*(C'\fR, but in \s-1UTF\-8\s0 it isn't. Unicode case folding is
vastly more complex than the simple rules of \s-1ASCII,\s0 and even when not
using Unicode but only localised single byte encodings, things can get
tricky (for example, \fB\s-1LATIN SMALL LETTER SHARP S\s0\fR (U+00DF, \*8)
should match '\s-1SS\s0' in localised case-insensitive matching).
.PP
Making things worse is that \s-1UTF\-8\s0 support was a later addition to the
regex engine (as it was to perl) and this necessarily  made things a lot
more complicated. Obviously it is easier to design a regex engine with
Unicode support in mind from the beginning than it is to retrofit it to
one that wasn't.
.PP
Nearly all regops that involve looking at the input string have
two cases, one for \s-1UTF\-8,\s0 and one not. In fact, it's often more complex
than that, as the pattern may be \s-1UTF\-8\s0 as well.
.PP
Care must be taken when making changes to make sure that you handle
\&\s-1UTF\-8\s0 properly, both at compile time and at execution time, including
when the string and pattern are mismatched.
.PP
The following comment in \fIregcomp.h\fR gives an example of exactly how
tricky this can be:
.PP
.Vb 1
\&    Two problematic code points in Unicode casefolding of EXACT nodes:
\&
\&    U+0390 \- GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
\&    U+03B0 \- GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
\&
\&    which casefold to
\&
\&    Unicode                      UTF\-8
\&
\&    U+03B9 U+0308 U+0301         0xCE 0xB9 0xCC 0x88 0xCC 0x81
\&    U+03C5 U+0308 U+0301         0xCF 0x85 0xCC 0x88 0xCC 0x81
\&
\&    This means that in case\-insensitive matching (or "loose matching",
\&    as Unicode calls it), an EXACTF of length six (the UTF\-8 encoded
\&    byte length of the above casefolded versions) can match a target
\&    string of length two (the byte length of UTF\-8 encoded U+0390 or
\&    U+03B0). This would rather mess up the minimum length computation.
\&
\&    What we\*(Aqll do is to look for the tail four bytes, and then peek
\&    at the preceding two bytes to see whether we need to decrease
\&    the minimum length by four (six minus two).
\&
\&    Thanks to the design of UTF\-8, there cannot be false matches:
\&    A sequence of valid UTF\-8 bytes cannot be a subsequence of
\&    another valid sequence of UTF\-8 bytes.
.Ve
.SS "Base Structures"
.IX Subsection "Base Structures"
The \f(CW\*(C`regexp\*(C'\fR structure described in perlreapi is common to all
regex engines. Two of its fields that are intended for the private use
of the regex engine that compiled the pattern. These are the
\&\f(CW\*(C`intflags\*(C'\fR and pprivate members. The \f(CW\*(C`pprivate\*(C'\fR is a void pointer to
an arbitrary structure whose use and management is the responsibility
of the compiling engine. perl will never modify either of these
values. In the case of the stock engine the structure pointed to by
\&\f(CW\*(C`pprivate\*(C'\fR is called \f(CW\*(C`regexp_internal\*(C'\fR.
.PP
Its \f(CW\*(C`pprivate\*(C'\fR and \f(CW\*(C`intflags\*(C'\fR fields contain data
specific to each engine.
.PP
There are two structures used to store a compiled regular expression.
One, the \f(CW\*(C`regexp\*(C'\fR structure described in perlreapi is populated by
the engine currently being. used and some of its fields read by perl to
implement things such as the stringification of \f(CW\*(C`qr//\*(C'\fR.
.PP
The other structure is pointed to be the \f(CW\*(C`regexp\*(C'\fR struct's
\&\f(CW\*(C`pprivate\*(C'\fR and is in addition to \f(CW\*(C`intflags\*(C'\fR in the same struct
considered to be the property of the regex engine which compiled the
regular expression;
.PP
The regexp structure contains all the data that perl needs to be aware of
to properly work with the regular expression. It includes data about
optimisations that perl can use to determine if the regex engine should
really be used, and various other control info that is needed to properly
execute patterns in various contexts such as is the pattern anchored in
some way, or what flags were used during the compile, or whether the
program contains special constructs that perl needs to be aware of.
.PP
In addition it contains two fields that are intended for the private use
of the regex engine that compiled the pattern. These are the \f(CW\*(C`intflags\*(C'\fR
and pprivate members. The \f(CW\*(C`pprivate\*(C'\fR is a void pointer to an arbitrary
structure whose use and management is the responsibility of the compiling
engine. perl will never modify either of these values.
.PP
As mentioned earlier, in the case of the default engines, the \f(CW\*(C`pprivate\*(C'\fR
will be a pointer to a regexp_internal structure which holds the compiled
program and any additional data that is private to the regex engine
implementation.
.PP
\fIPerl's \f(CI\*(C`pprivate\*(C'\fI structure\fR
.IX Subsection "Perl's pprivate structure"
.PP
The following structure is used as the \f(CW\*(C`pprivate\*(C'\fR struct by perl's
regex engine. Since it is specific to perl it is only of curiosity
value to other engine implementations.
.PP
.Vb 10
\& typedef struct regexp_internal {
\&         U32 *offsets;           /* offset annotations 20001228 MJD
\&                                  * data about mapping the program to
\&                                  * the string*/
\&         regnode *regstclass;    /* Optional startclass as identified or
\&                                  * constructed by the optimiser */
\&         struct reg_data *data;  /* Additional miscellaneous data used
\&                                  * by the program.  Used to make it
\&                                  * easier to clone and free arbitrary
\&                                  * data that the regops need. Often the
\&                                  * ARG field of a regop is an index
\&                                  * into this structure */
\&         regnode program[1];     /* Unwarranted chumminess with
\&                                  * compiler. */
\& } regexp_internal;
.Ve
.ie n .IP """offsets""" 5
.el .IP "\f(CWoffsets\fR" 5
.IX Item "offsets"
Offsets holds a mapping of offset in the \f(CW\*(C`program\*(C'\fR
to offset in the \f(CW\*(C`precomp\*(C'\fR string. This is only used by ActiveState's
visual regex debugger.
.ie n .IP """regstclass""" 5
.el .IP "\f(CWregstclass\fR" 5
.IX Item "regstclass"
Special regop that is used by \f(CW\*(C`re_intuit_start()\*(C'\fR to check if a pattern
can match at a certain position. For instance if the regex engine knows
that the pattern must start with a 'Z' then it can scan the string until
it finds one and then launch the regex engine from there. The routine
that handles this is called \f(CW\*(C`find_by_class()\*(C'\fR. Sometimes this field
points at a regop embedded in the program, and sometimes it points at
an independent synthetic regop that has been constructed by the optimiser.
.ie n .IP """data""" 5
.el .IP "\f(CWdata\fR" 5
.IX Item "data"
This field points at a reg_data structure, which is defined as follows
.Sp
.Vb 5
\&    struct reg_data {
\&        U32 count;
\&        U8 *what;
\&        void* data[1];
\&    };
.Ve
.Sp
This structure is used for handling data structures that the regex engine
needs to handle specially during a clone or free operation on the compiled
product. Each element in the data array has a corresponding element in the
what array. During compilation regops that need special structures stored
will add an element to each array using the \fIadd_data()\fR routine and then store
the index in the regop.
.ie n .IP """program""" 5
.el .IP "\f(CWprogram\fR" 5
.IX Item "program"
Compiled program. Inlined into the structure so the entire struct can be
treated as a single blob.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlreapi
.PP
perlre
.PP
perlunitut
.SH "AUTHOR"
.IX Header "AUTHOR"
by Yves Orton, 2006.
.PP
With excerpts from Perl, and contributions and suggestions from
Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus,
Stephen McCamant, and David Landgren.
.SH "LICENCE"
.IX Header "LICENCE"
Same terms as Perl.
.SH "REFERENCES"
.IX Header "REFERENCES"
[1] <http://perl.plover.com/Rx/paper/>
.PP
[2] <http://www.unicode.org>
                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreguts5.16.1                             0100644 0001750 0001750 00000132133 12566207423 023450  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREGUTS 1"
.TH PERLREGUTS 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreguts \- Description of the Perl regular expression engine.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is an attempt to shine some light on the guts of the regex
engine and how it works. The regex engine represents a significant chunk
of the perl codebase, but is relatively poorly understood. This document
is a meagre attempt at addressing this situation. It is derived from the
author's experience, comments in the source code, other papers on the
regex engine, feedback on the perl5\-porters mail list, and no doubt other
places as well.
.PP
\&\fB\s-1NOTICE\s0!\fR It should be clearly understood that the behavior and
structures discussed in this represents the state of the engine as the
author understood it at the time of writing. It is \fB\s-1NOT\s0\fR an \s-1API\s0
definition, it is purely an internals guide for those who want to hack
the regex engine, or understand how the regex engine works. Readers of
this document are expected to understand perl's regex syntax and its
usage in detail. If you want to learn about the basics of Perl's
regular expressions, see perlre. And if you want to replace the
regex engine with your own, see perlreapi.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
.SS "A quick note on terms"
.IX Subsection "A quick note on terms"
There is some debate as to whether to say \*(L"regexp\*(R" or \*(L"regex\*(R". In this
document we will use the term \*(L"regex\*(R" unless there is a special reason
not to, in which case we will explain why.
.PP
When speaking about regexes we need to distinguish between their source
code form and their internal form. In this document we will use the term
\&\*(L"pattern\*(R" when we speak of their textual, source code form, and the term
\&\*(L"program\*(R" when we speak of their internal representation. These
correspond to the terms \fIS\-regex\fR and \fIB\-regex\fR that Mark Jason
Dominus employs in his paper on \*(L"Rx\*(R" ([1] in \*(L"\s-1REFERENCES\s0\*(R").
.SS "What is a regular expression engine?"
.IX Subsection "What is a regular expression engine?"
A regular expression engine is a program that takes a set of constraints
specified in a mini-language, and then applies those constraints to a
target string, and determines whether or not the string satisfies the
constraints. See perlre for a full definition of the language.
.PP
In less grandiose terms, the first part of the job is to turn a pattern into
something the computer can efficiently use to find the matching point in
the string, and the second part is performing the search itself.
.PP
To do this we need to produce a program by parsing the text. We then
need to execute the program to find the point in the string that
matches. And we need to do the whole thing efficiently.
.SS "Structure of a Regexp Program"
.IX Subsection "Structure of a Regexp Program"
\fIHigh Level\fR
.IX Subsection "High Level"
.PP
Although it is a bit confusing and some people object to the terminology, it
is worth taking a look at a comment that has
been in \fIregexp.h\fR for years:
.PP
\&\fIThis is essentially a linear encoding of a nondeterministic
finite-state machine (aka syntax charts or \*(L"railroad normal form\*(R" in
parsing technology).\fR
.PP
The term \*(L"railroad normal form\*(R" is a bit esoteric, with \*(L"syntax
diagram/charts\*(R", or \*(L"railroad diagram/charts\*(R" being more common terms.
Nevertheless it provides a useful mental image of a regex program: each
node can be thought of as a unit of track, with a single entry and in
most cases a single exit point (there are pieces of track that fork, but
statistically not many), and the whole forms a layout with a
single entry and single exit point. The matching process can be thought
of as a car that moves along the track, with the particular route through
the system being determined by the character read at each possible
connector point. A car can fall off the track at any point but it may
only proceed as long as it matches the track.
.PP
Thus the pattern \f(CW\*(C`/foo(?:\ew+|\ed+|\es+)bar/\*(C'\fR can be thought of as the
following chart:
.PP
.Vb 10
\&                      [start]
\&                         |
\&                       <foo>
\&                         |
\&                   +\-\-\-\-\-+\-\-\-\-\-+
\&                   |     |     |
\&                 <\ew+> <\ed+> <\es+>
\&                   |     |     |
\&                   +\-\-\-\-\-+\-\-\-\-\-+
\&                         |
\&                       <bar>
\&                         |
\&                       [end]
.Ve
.PP
The truth of the matter is that perl's regular expressions these days are
much more complex than this kind of structure, but visualising it this way
can help when trying to get your bearings, and it matches the
current implementation pretty closely.
.PP
To be more precise, we will say that a regex program is an encoding
of a graph. Each node in the graph corresponds to part of
the original regex pattern, such as a literal string or a branch,
and has a pointer to the nodes representing the next component
to be matched. Since \*(L"node\*(R" and \*(L"opcode\*(R" already have other meanings in the
perl source, we will call the nodes in a regex program \*(L"regops\*(R".
.PP
The program is represented by an array of \f(CW\*(C`regnode\*(C'\fR structures, one or
more of which represent a single regop of the program. Struct
\&\f(CW\*(C`regnode\*(C'\fR is the smallest struct needed, and has a field structure which is
shared with all the other larger structures.
.PP
The \*(L"next\*(R" pointers of all regops except \f(CW\*(C`BRANCH\*(C'\fR implement concatenation;
a \*(L"next\*(R" pointer with a \f(CW\*(C`BRANCH\*(C'\fR on both ends of it is connecting two
alternatives.  [Here we have one of the subtle syntax dependencies: an
individual \f(CW\*(C`BRANCH\*(C'\fR (as opposed to a collection of them) is never
concatenated with anything because of operator precedence.]
.PP
The operand of some types of regop is a literal string; for others,
it is a regop leading into a sub-program.  In particular, the operand
of a \f(CW\*(C`BRANCH\*(C'\fR node is the first regop of the branch.
.PP
\&\fB\s-1NOTE\s0\fR: As the railroad metaphor suggests, this is \fBnot\fR a tree
structure:  the tail of the branch connects to the thing following the
set of \f(CW\*(C`BRANCH\*(C'\fRes.  It is a like a single line of railway track that
splits as it goes into a station or railway yard and rejoins as it comes
out the other side.
.PP
\fIRegops\fR
.IX Subsection "Regops"
.PP
The base structure of a regop is defined in \fIregexp.h\fR as follows:
.PP
.Vb 5
\&    struct regnode {
\&        U8  flags;    /* Various purposes, sometimes overridden */
\&        U8  type;     /* Opcode value as specified by regnodes.h */
\&        U16 next_off; /* Offset in size regnode */
\&    };
.Ve
.PP
Other larger \f(CW\*(C`regnode\*(C'\fR\-like structures are defined in \fIregcomp.h\fR. They
are almost like subclasses in that they have the same fields as
\&\f(CW\*(C`regnode\*(C'\fR, with possibly additional fields following in
the structure, and in some cases the specific meaning (and name)
of some of base fields are overridden. The following is a more
complete description.
.ie n .IP """regnode_1""" 4
.el .IP "\f(CWregnode_1\fR" 4
.IX Item "regnode_1"
.PD 0
.ie n .IP """regnode_2""" 4
.el .IP "\f(CWregnode_2\fR" 4
.IX Item "regnode_2"
.PD
\&\f(CW\*(C`regnode_1\*(C'\fR structures have the same header, followed by a single
four-byte argument; \f(CW\*(C`regnode_2\*(C'\fR structures contain two two-byte
arguments instead:
.Sp
.Vb 2
\&    regnode_1                U32 arg1;
\&    regnode_2                U16 arg1;  U16 arg2;
.Ve
.ie n .IP """regnode_string""" 4
.el .IP "\f(CWregnode_string\fR" 4
.IX Item "regnode_string"
\&\f(CW\*(C`regnode_string\*(C'\fR structures, used for literal strings, follow the header
with a one-byte length and then the string data. Strings are padded on
the end with zero bytes so that the total length of the node is a
multiple of four bytes:
.Sp
.Vb 2
\&    regnode_string           char string[1];
\&                             U8 str_len; /* overrides flags */
.Ve
.ie n .IP """regnode_charclass""" 4
.el .IP "\f(CWregnode_charclass\fR" 4
.IX Item "regnode_charclass"
Character classes are represented by \f(CW\*(C`regnode_charclass\*(C'\fR structures,
which have a four-byte argument and then a 32\-byte (256\-bit) bitmap
indicating which characters are included in the class.
.Sp
.Vb 2
\&    regnode_charclass        U32 arg1;
\&                             char bitmap[ANYOF_BITMAP_SIZE];
.Ve
.ie n .IP """regnode_charclass_class""" 4
.el .IP "\f(CWregnode_charclass_class\fR" 4
.IX Item "regnode_charclass_class"
There is also a larger form of a char class structure used to represent
\&\s-1POSIX\s0 char classes called \f(CW\*(C`regnode_charclass_class\*(C'\fR which has an
additional 4\-byte (32\-bit) bitmap indicating which \s-1POSIX\s0 char classes
have been included.
.Sp
.Vb 3
\&    regnode_charclass_class  U32 arg1;
\&                             char bitmap[ANYOF_BITMAP_SIZE];
\&                             char classflags[ANYOF_CLASSBITMAP_SIZE];
.Ve
.PP
\&\fIregnodes.h\fR defines an array called \f(CW\*(C`regarglen[]\*(C'\fR which gives the size
of each opcode in units of \f(CW\*(C`size regnode\*(C'\fR (4\-byte). A macro is used
to calculate the size of an \f(CW\*(C`EXACT\*(C'\fR node based on its \f(CW\*(C`str_len\*(C'\fR field.
.PP
The regops are defined in \fIregnodes.h\fR which is generated from
\&\fIregcomp.sym\fR by \fIregcomp.pl\fR. Currently the maximum possible number
of distinct regops is restricted to 256, with about a quarter already
used.
.PP
A set of macros makes accessing the fields
easier and more consistent. These include \f(CW\*(C`OP()\*(C'\fR, which is used to determine
the type of a \f(CW\*(C`regnode\*(C'\fR\-like structure; \f(CW\*(C`NEXT_OFF()\*(C'\fR, which is the offset to
the next node (more on this later); \f(CW\*(C`ARG()\*(C'\fR, \f(CW\*(C`ARG1()\*(C'\fR, \f(CW\*(C`ARG2()\*(C'\fR, \f(CW\*(C`ARG_SET()\*(C'\fR,
and equivalents for reading and setting the arguments; and \f(CW\*(C`STR_LEN()\*(C'\fR,
\&\f(CW\*(C`STRING()\*(C'\fR and \f(CW\*(C`OPERAND()\*(C'\fR for manipulating strings and regop bearing
types.
.PP
\fIWhat regop is next?\fR
.IX Subsection "What regop is next?"
.PP
There are three distinct concepts of \*(L"next\*(R" in the regex engine, and
it is important to keep them clear.
.IP "\(bu" 4
There is the \*(L"next regnode\*(R" from a given regnode, a value which is
rarely useful except that sometimes it matches up in terms of value
with one of the others, and that sometimes the code assumes this to
always be so.
.IP "\(bu" 4
There is the \*(L"next regop\*(R" from a given regop/regnode. This is the
regop physically located after the current one, as determined by
the size of the current regop. This is often useful, such as when
dumping the structure we use this order to traverse. Sometimes the code
assumes that the \*(L"next regnode\*(R" is the same as the \*(L"next regop\*(R", or in
other words assumes that the sizeof a given regop type is always going
to be one regnode large.
.IP "\(bu" 4
There is the \*(L"regnext\*(R" from a given regop. This is the regop which
is reached by jumping forward by the value of \f(CW\*(C`NEXT_OFF()\*(C'\fR,
or in a few cases for longer jumps by the \f(CW\*(C`arg1\*(C'\fR field of the \f(CW\*(C`regnode_1\*(C'\fR
structure. The subroutine \f(CW\*(C`regnext()\*(C'\fR handles this transparently.
This is the logical successor of the node, which in some cases, like
that of the \f(CW\*(C`BRANCH\*(C'\fR regop, has special meaning.
.SH "Process Overview"
.IX Header "Process Overview"
Broadly speaking, performing a match of a string against a pattern
involves the following steps:
.IP "A. Compilation" 5
.IX Item "A. Compilation"
.RS 5
.PD 0
.IP "1. Parsing for size" 5
.IX Item "1. Parsing for size"
.IP "2. Parsing for construction" 5
.IX Item "2. Parsing for construction"
.IP "3. Peep-hole optimisation and analysis" 5
.IX Item "3. Peep-hole optimisation and analysis"
.RE
.RS 5
.RE
.IP "B. Execution" 5
.IX Item "B. Execution"
.RS 5
.IP "4. Start position and no-match optimisations" 5
.IX Item "4. Start position and no-match optimisations"
.IP "5. Program execution" 5
.IX Item "5. Program execution"
.RE
.RS 5
.RE
.PD
.PP
Where these steps occur in the actual execution of a perl program is
determined by whether the pattern involves interpolating any string
variables. If interpolation occurs, then compilation happens at run time. If it
does not, then compilation is performed at compile time. (The \f(CW\*(C`/o\*(C'\fR modifier changes this,
as does \f(CW\*(C`qr//\*(C'\fR to a certain extent.) The engine doesn't really care that
much.
.SS "Compilation"
.IX Subsection "Compilation"
This code resides primarily in \fIregcomp.c\fR, along with the header files
\&\fIregcomp.h\fR, \fIregexp.h\fR and \fIregnodes.h\fR.
.PP
Compilation starts with \f(CW\*(C`pregcomp()\*(C'\fR, which is mostly an initialisation
wrapper which farms work out to two other routines for the heavy lifting: the
first is \f(CW\*(C`reg()\*(C'\fR, which is the start point for parsing; the second,
\&\f(CW\*(C`study_chunk()\*(C'\fR, is responsible for optimisation.
.PP
Initialisation in \f(CW\*(C`pregcomp()\*(C'\fR mostly involves the creation and data-filling
of a special structure, \f(CW\*(C`RExC_state_t\*(C'\fR (defined in \fIregcomp.c\fR).
Almost all internally-used routines in \fIregcomp.h\fR take a pointer to one
of these structures as their first argument, with the name \f(CW\*(C`pRExC_state\*(C'\fR.
This structure is used to store the compilation state and contains many
fields. Likewise there are many macros which operate on this
variable: anything that looks like \f(CW\*(C`RExC_xxxx\*(C'\fR is a macro that operates on
this pointer/structure.
.PP
\fIParsing for size\fR
.IX Subsection "Parsing for size"
.PP
In this pass the input pattern is parsed in order to calculate how much
space is needed for each regop we would need to emit. The size is also
used to determine whether long jumps will be required in the program.
.PP
This stage is controlled by the macro \f(CW\*(C`SIZE_ONLY\*(C'\fR being set.
.PP
The parse proceeds pretty much exactly as it does during the
construction phase, except that most routines are short-circuited to
change the size field \f(CW\*(C`RExC_size\*(C'\fR and not do anything else.
.PP
\fIParsing for construction\fR
.IX Subsection "Parsing for construction"
.PP
Once the size of the program has been determined, the pattern is parsed
again, but this time for real. Now \f(CW\*(C`SIZE_ONLY\*(C'\fR will be false, and the
actual construction can occur.
.PP
\&\f(CW\*(C`reg()\*(C'\fR is the start of the parse process. It is responsible for
parsing an arbitrary chunk of pattern up to either the end of the
string, or the first closing parenthesis it encounters in the pattern.
This means it can be used to parse the top-level regex, or any section
inside of a grouping parenthesis. It also handles the \*(L"special parens\*(R"
that perl's regexes have. For instance when parsing \f(CW\*(C`/x(?:foo)y/\*(C'\fR \f(CW\*(C`reg()\*(C'\fR
will at one point be called to parse from the \*(L"?\*(R" symbol up to and
including the \*(L")\*(R".
.PP
Additionally, \f(CW\*(C`reg()\*(C'\fR is responsible for parsing the one or more
branches from the pattern, and for \*(L"finishing them off\*(R" by correctly
setting their next pointers. In order to do the parsing, it repeatedly
calls out to \f(CW\*(C`regbranch()\*(C'\fR, which is responsible for handling up to the
first \f(CW\*(C`|\*(C'\fR symbol it sees.
.PP
\&\f(CW\*(C`regbranch()\*(C'\fR in turn calls \f(CW\*(C`regpiece()\*(C'\fR which
handles \*(L"things\*(R" followed by a quantifier. In order to parse the
\&\*(L"things\*(R", \f(CW\*(C`regatom()\*(C'\fR is called. This is the lowest level routine, which
parses out constant strings, character classes, and the
various special symbols like \f(CW\*(C`$\*(C'\fR. If \f(CW\*(C`regatom()\*(C'\fR encounters a \*(L"(\*(R"
character it in turn calls \f(CW\*(C`reg()\*(C'\fR.
.PP
The routine \f(CW\*(C`regtail()\*(C'\fR is called by both \f(CW\*(C`reg()\*(C'\fR and \f(CW\*(C`regbranch()\*(C'\fR
in order to \*(L"set the tail pointer\*(R" correctly. When executing and
we get to the end of a branch, we need to go to the node following the
grouping parens. When parsing, however, we don't know where the end will
be until we get there, so when we do we must go back and update the
offsets as appropriate. \f(CW\*(C`regtail\*(C'\fR is used to make this easier.
.PP
A subtlety of the parsing process means that a regex like \f(CW\*(C`/foo/\*(C'\fR is
originally parsed into an alternation with a single branch. It is only
afterwards that the optimiser converts single branch alternations into the
simpler form.
.PP
\fIParse Call Graph and a Grammar\fR
.IX Subsection "Parse Call Graph and a Grammar"
.PP
The call graph looks like this:
.PP
.Vb 10
\&    reg()                        # parse a top level regex, or inside of parens
\&        regbranch()              # parse a single branch of an alternation
\&            regpiece()           # parse a pattern followed by a quantifier
\&                regatom()        # parse a simple pattern
\&                    regclass()   #   used to handle a class
\&                    reg()        #   used to handle a parenthesised subpattern
\&                    ....
\&            ...
\&            regtail()            # finish off the branch
\&        ...
\&        regtail()                # finish off the branch sequence. Tie each
\&                                 # branch\*(Aqs tail to the tail of the sequence
\&                                 # (NEW) In Debug mode this is
\&                                 # regtail_study().
.Ve
.PP
A grammar form might be something like this:
.PP
.Vb 11
\&    atom  : constant | class
\&    quant : \*(Aq*\*(Aq | \*(Aq+\*(Aq | \*(Aq?\*(Aq | \*(Aq{min,max}\*(Aq
\&    _branch: piece
\&           | piece _branch
\&           | nothing
\&    branch: _branch
\&          | _branch \*(Aq|\*(Aq branch
\&    group : \*(Aq(\*(Aq branch \*(Aq)\*(Aq
\&    _piece: atom | group
\&    piece : _piece
\&          | _piece quant
.Ve
.PP
\fIDebug Output\fR
.IX Subsection "Debug Output"
.PP
In the 5.9.x development version of perl you can \f(CW\*(C`use re Debug => \*(AqPARSE\*(Aq\*(C'\fR
to see some trace information about the parse process. We will start with some
simple patterns and build up to more complex patterns.
.PP
So when we parse \f(CW\*(C`/foo/\*(C'\fR we see something like the following table. The
left shows what is being parsed, and the number indicates where the next regop
would go. The stuff on the right is the trace output of the graph. The
names are chosen to be short to make it less dense on the screen. 'tsdy'
is a special form of \f(CW\*(C`regtail()\*(C'\fR which does some extra analysis.
.PP
.Vb 6
\& >foo<             1    reg
\&                          brnc
\&                            piec
\&                              atom
\& ><                4      tsdy~ EXACT <foo> (EXACT) (1)
\&                              ~ attach to END (3) offset to 2
.Ve
.PP
The resulting program then looks like:
.PP
.Vb 2
\&   1: EXACT <foo>(3)
\&   3: END(0)
.Ve
.PP
As you can see, even though we parsed out a branch and a piece, it was ultimately
only an atom. The final program shows us how things work. We have an \f(CW\*(C`EXACT\*(C'\fR regop,
followed by an \f(CW\*(C`END\*(C'\fR regop. The number in parens indicates where the \f(CW\*(C`regnext\*(C'\fR of
the node goes. The \f(CW\*(C`regnext\*(C'\fR of an \f(CW\*(C`END\*(C'\fR regop is unused, as \f(CW\*(C`END\*(C'\fR regops mean
we have successfully matched. The number on the left indicates the position of
the regop in the regnode array.
.PP
Now let's try a harder pattern. We will add a quantifier, so now we have the pattern
\&\f(CW\*(C`/foo+/\*(C'\fR. We will see that \f(CW\*(C`regbranch()\*(C'\fR calls \f(CW\*(C`regpiece()\*(C'\fR twice.
.PP
.Vb 10
\& >foo+<            1    reg
\&                          brnc
\&                            piec
\&                              atom
\& >o+<              3        piec
\&                              atom
\& ><                6        tail~ EXACT <fo> (1)
\&                   7      tsdy~ EXACT <fo> (EXACT) (1)
\&                              ~ PLUS (END) (3)
\&                              ~ attach to END (6) offset to 3
.Ve
.PP
And we end up with the program:
.PP
.Vb 4
\&   1: EXACT <fo>(3)
\&   3: PLUS(6)
\&   4:   EXACT <o>(0)
\&   6: END(0)
.Ve
.PP
Now we have a special case. The \f(CW\*(C`EXACT\*(C'\fR regop has a \f(CW\*(C`regnext\*(C'\fR of 0. This is
because if it matches it should try to match itself again. The \f(CW\*(C`PLUS\*(C'\fR regop
handles the actual failure of the \f(CW\*(C`EXACT\*(C'\fR regop and acts appropriately (going
to regnode 6 if the \f(CW\*(C`EXACT\*(C'\fR matched at least once, or failing if it didn't).
.PP
Now for something much more complex: \f(CW\*(C`/x(?:foo*|b[a][rR])(foo|bar)$/\*(C'\fR
.PP
.Vb 10
\& >x(?:foo*|b...    1    reg
\&                          brnc
\&                            piec
\&                              atom
\& >(?:foo*|b[...    3        piec
\&                              atom
\& >?:foo*|b[a...                 reg
\& >foo*|b[a][...                   brnc
\&                                    piec
\&                                      atom
\& >o*|b[a][rR...    5                piec
\&                                      atom
\& >|b[a][rR])...    8                tail~ EXACT <fo> (3)
\& >b[a][rR])(...    9              brnc
\&                  10                piec
\&                                      atom
\& >[a][rR])(f...   12                piec
\&                                      atom
\& >a][rR])(fo...                         clas
\& >[rR])(foo|...   14                tail~ EXACT <b> (10)
\&                                    piec
\&                                      atom
\& >rR])(foo|b...                         clas
\& >)(foo|bar)...   25                tail~ EXACT <a> (12)
\&                                  tail~ BRANCH (3)
\&                  26              tsdy~ BRANCH (END) (9)
\&                                      ~ attach to TAIL (25) offset to 16
\&                                  tsdy~ EXACT <fo> (EXACT) (4)
\&                                      ~ STAR (END) (6)
\&                                      ~ attach to TAIL (25) offset to 19
\&                                  tsdy~ EXACT <b> (EXACT) (10)
\&                                      ~ EXACT <a> (EXACT) (12)
\&                                      ~ ANYOF[Rr] (END) (14)
\&                                      ~ attach to TAIL (25) offset to 11
\& >(foo|bar)$<               tail~ EXACT <x> (1)
\&                            piec
\&                              atom
\& >foo|bar)$<                    reg
\&                  28              brnc
\&                                    piec
\&                                      atom
\& >|bar)$<         31              tail~ OPEN1 (26)
\& >bar)$<                          brnc
\&                  32                piec
\&                                      atom
\& >)$<             34              tail~ BRANCH (28)
\&                  36              tsdy~ BRANCH (END) (31)
\&                                      ~ attach to CLOSE1 (34) offset to 3
\&                                  tsdy~ EXACT <foo> (EXACT) (29)
\&                                      ~ attach to CLOSE1 (34) offset to 5
\&                                  tsdy~ EXACT <bar> (EXACT) (32)
\&                                      ~ attach to CLOSE1 (34) offset to 2
\& >$<                        tail~ BRANCH (3)
\&                                ~ BRANCH (9)
\&                                ~ TAIL (25)
\&                            piec
\&                              atom
\& ><               37        tail~ OPEN1 (26)
\&                                ~ BRANCH (28)
\&                                ~ BRANCH (31)
\&                                ~ CLOSE1 (34)
\&                  38      tsdy~ EXACT <x> (EXACT) (1)
\&                              ~ BRANCH (END) (3)
\&                              ~ BRANCH (END) (9)
\&                              ~ TAIL (END) (25)
\&                              ~ OPEN1 (END) (26)
\&                              ~ BRANCH (END) (28)
\&                              ~ BRANCH (END) (31)
\&                              ~ CLOSE1 (END) (34)
\&                              ~ EOL (END) (36)
\&                              ~ attach to END (37) offset to 1
.Ve
.PP
Resulting in the program
.PP
.Vb 10
\&   1: EXACT <x>(3)
\&   3: BRANCH(9)
\&   4:   EXACT <fo>(6)
\&   6:   STAR(26)
\&   7:     EXACT <o>(0)
\&   9: BRANCH(25)
\&  10:   EXACT <ba>(14)
\&  12:   OPTIMIZED (2 nodes)
\&  14:   ANYOF[Rr](26)
\&  25: TAIL(26)
\&  26: OPEN1(28)
\&  28:   TRIE\-EXACT(34)
\&        [StS:1 Wds:2 Cs:6 Uq:5 #Sts:7 Mn:3 Mx:3 Stcls:bf]
\&          <foo>
\&          <bar>
\&  30:   OPTIMIZED (4 nodes)
\&  34: CLOSE1(36)
\&  36: EOL(37)
\&  37: END(0)
.Ve
.PP
Here we can see a much more complex program, with various optimisations in
play. At regnode 10 we see an example where a character class with only
one character in it was turned into an \f(CW\*(C`EXACT\*(C'\fR node. We can also see where
an entire alternation was turned into a \f(CW\*(C`TRIE\-EXACT\*(C'\fR node. As a consequence,
some of the regnodes have been marked as optimised away. We can see that
the \f(CW\*(C`$\*(C'\fR symbol has been converted into an \f(CW\*(C`EOL\*(C'\fR regop, a special piece of
code that looks for \f(CW\*(C`\en\*(C'\fR or the end of the string.
.PP
The next pointer for \f(CW\*(C`BRANCH\*(C'\fRes is interesting in that it points at where
execution should go if the branch fails. When executing, if the engine
tries to traverse from a branch to a \f(CW\*(C`regnext\*(C'\fR that isn't a branch then
the engine will know that the entire set of branches has failed.
.PP
\fIPeep-hole Optimisation and Analysis\fR
.IX Subsection "Peep-hole Optimisation and Analysis"
.PP
The regular expression engine can be a weighty tool to wield. On long
strings and complex patterns it can end up having to do a lot of work
to find a match, and even more to decide that no match is possible.
Consider a situation like the following pattern.
.PP
.Vb 1
\&   \*(Aqababababababababababab\*(Aq =~ /(a|b)*z/
.Ve
.PP
The \f(CW\*(C`(a|b)*\*(C'\fR part can match at every char in the string, and then fail
every time because there is no \f(CW\*(C`z\*(C'\fR in the string. So obviously we can
avoid using the regex engine unless there is a \f(CW\*(C`z\*(C'\fR in the string.
Likewise in a pattern like:
.PP
.Vb 1
\&   /foo(\ew+)bar/
.Ve
.PP
In this case we know that the string must contain a \f(CW\*(C`foo\*(C'\fR which must be
followed by \f(CW\*(C`bar\*(C'\fR. We can use Fast Boyer-Moore matching as implemented
in \f(CW\*(C`fbm_instr()\*(C'\fR to find the location of these strings. If they don't exist
then we don't need to resort to the much more expensive regex engine.
Even better, if they do exist then we can use their positions to
reduce the search space that the regex engine needs to cover to determine
if the entire pattern matches.
.PP
There are various aspects of the pattern that can be used to facilitate
optimisations along these lines:
.IP "\(bu" 5
anchored fixed strings
.IP "\(bu" 5
floating fixed strings
.IP "\(bu" 5
minimum and maximum length requirements
.IP "\(bu" 5
start class
.IP "\(bu" 5
Beginning/End of line positions
.PP
Another form of optimisation that can occur is the post-parse \*(L"peep-hole\*(R"
optimisation, where inefficient constructs are replaced by more efficient
constructs. The \f(CW\*(C`TAIL\*(C'\fR regops which are used during parsing to mark the end
of branches and the end of groups are examples of this. These regops are used
as place-holders during construction and \*(L"always match\*(R" so they can be
\&\*(L"optimised away\*(R" by making the things that point to the \f(CW\*(C`TAIL\*(C'\fR point to the
thing that \f(CW\*(C`TAIL\*(C'\fR points to, thus \*(L"skipping\*(R" the node.
.PP
Another optimisation that can occur is that of "\f(CW\*(C`EXACT\*(C'\fR merging" which is
where two consecutive \f(CW\*(C`EXACT\*(C'\fR nodes are merged into a single
regop. An even more aggressive form of this is that a branch
sequence of the form \f(CW\*(C`EXACT BRANCH ... EXACT\*(C'\fR can be converted into a
\&\f(CW\*(C`TRIE\-EXACT\*(C'\fR regop.
.PP
All of this occurs in the routine \f(CW\*(C`study_chunk()\*(C'\fR which uses a special
structure \f(CW\*(C`scan_data_t\*(C'\fR to store the analysis that it has performed, and
does the \*(L"peep-hole\*(R" optimisations as it goes.
.PP
The code involved in \f(CW\*(C`study_chunk()\*(C'\fR is extremely cryptic. Be careful. :\-)
.SS "Execution"
.IX Subsection "Execution"
Execution of a regex generally involves two phases, the first being
finding the start point in the string where we should match from,
and the second being running the regop interpreter.
.PP
If we can tell that there is no valid start point then we don't bother running
interpreter at all. Likewise, if we know from the analysis phase that we
cannot detect a short-cut to the start position, we go straight to the
interpreter.
.PP
The two entry points are \f(CW\*(C`re_intuit_start()\*(C'\fR and \f(CW\*(C`pregexec()\*(C'\fR. These routines
have a somewhat incestuous relationship with overlap between their functions,
and \f(CW\*(C`pregexec()\*(C'\fR may even call \f(CW\*(C`re_intuit_start()\*(C'\fR on its own. Nevertheless
other parts of the perl source code may call into either, or both.
.PP
Execution of the interpreter itself used to be recursive, but thanks to the
efforts of Dave Mitchell in the 5.9.x development track, that has changed: now an
internal stack is maintained on the heap and the routine is fully
iterative. This can make it tricky as the code is quite conservative
about what state it stores, with the result that two consecutive lines in the
code can actually be running in totally different contexts due to the
simulated recursion.
.PP
\fIStart position and no-match optimisations\fR
.IX Subsection "Start position and no-match optimisations"
.PP
\&\f(CW\*(C`re_intuit_start()\*(C'\fR is responsible for handling start points and no-match
optimisations as determined by the results of the analysis done by
\&\f(CW\*(C`study_chunk()\*(C'\fR (and described in \*(L"Peep-hole Optimisation and Analysis\*(R").
.PP
The basic structure of this routine is to try to find the start\- and/or
end-points of where the pattern could match, and to ensure that the string
is long enough to match the pattern. It tries to use more efficient
methods over less efficient methods and may involve considerable
cross-checking of constraints to find the place in the string that matches.
For instance it may try to determine that a given fixed string must be
not only present but a certain number of chars before the end of the
string, or whatever.
.PP
It calls several other routines, such as \f(CW\*(C`fbm_instr()\*(C'\fR which does
Fast Boyer Moore matching and \f(CW\*(C`find_byclass()\*(C'\fR which is responsible for
finding the start using the first mandatory regop in the program.
.PP
When the optimisation criteria have been satisfied, \f(CW\*(C`reg_try()\*(C'\fR is called
to perform the match.
.PP
\fIProgram execution\fR
.IX Subsection "Program execution"
.PP
\&\f(CW\*(C`pregexec()\*(C'\fR is the main entry point for running a regex. It contains
support for initialising the regex interpreter's state, running
\&\f(CW\*(C`re_intuit_start()\*(C'\fR if needed, and running the interpreter on the string
from various start positions as needed. When it is necessary to use
the regex interpreter \f(CW\*(C`pregexec()\*(C'\fR calls \f(CW\*(C`regtry()\*(C'\fR.
.PP
\&\f(CW\*(C`regtry()\*(C'\fR is the entry point into the regex interpreter. It expects
as arguments a pointer to a \f(CW\*(C`regmatch_info\*(C'\fR structure and a pointer to
a string.  It returns an integer 1 for success and a 0 for failure.
It is basically a set-up wrapper around \f(CW\*(C`regmatch()\*(C'\fR.
.PP
\&\f(CW\*(C`regmatch\*(C'\fR is the main \*(L"recursive loop\*(R" of the interpreter. It is
basically a giant switch statement that implements a state machine, where
the possible states are the regops themselves, plus a number of additional
intermediate and failure states. A few of the states are implemented as
subroutines but the bulk are inline code.
.SH "MISCELLANEOUS"
.IX Header "MISCELLANEOUS"
.SS "Unicode and Localisation Support"
.IX Subsection "Unicode and Localisation Support"
When dealing with strings containing characters that cannot be represented
using an eight-bit character set, perl uses an internal representation
that is a permissive version of Unicode's \s-1UTF\-8\s0 encoding[2]. This uses single
bytes to represent characters from the \s-1ASCII\s0 character set, and sequences
of two or more bytes for all other characters. (See perlunitut
for more information about the relationship between \s-1UTF\-8\s0 and perl's
encoding, utf8. The difference isn't important for this discussion.)
.PP
No matter how you look at it, Unicode support is going to be a pain in a
regex engine. Tricks that might be fine when you have 256 possible
characters often won't scale to handle the size of the \s-1UTF\-8\s0 character
set.  Things you can take for granted with \s-1ASCII\s0 may not be true with
Unicode. For instance, in \s-1ASCII\s0, it is safe to assume that
\&\f(CW\*(C`sizeof(char1) == sizeof(char2)\*(C'\fR, but in \s-1UTF\-8\s0 it isn't. Unicode case folding is
vastly more complex than the simple rules of \s-1ASCII\s0, and even when not
using Unicode but only localised single byte encodings, things can get
tricky (for example, \fB\s-1LATIN\s0 \s-1SMALL\s0 \s-1LETTER\s0 \s-1SHARP\s0 S\fR (U+00DF, \*8)
should match '\s-1SS\s0' in localised case-insensitive matching).
.PP
Making things worse is that \s-1UTF\-8\s0 support was a later addition to the
regex engine (as it was to perl) and this necessarily  made things a lot
more complicated. Obviously it is easier to design a regex engine with
Unicode support in mind from the beginning than it is to retrofit it to
one that wasn't.
.PP
Nearly all regops that involve looking at the input string have
two cases, one for \s-1UTF\-8\s0, and one not. In fact, it's often more complex
than that, as the pattern may be \s-1UTF\-8\s0 as well.
.PP
Care must be taken when making changes to make sure that you handle
\&\s-1UTF\-8\s0 properly, both at compile time and at execution time, including
when the string and pattern are mismatched.
.PP
The following comment in \fIregcomp.h\fR gives an example of exactly how
tricky this can be:
.PP
.Vb 1
\&    Two problematic code points in Unicode casefolding of EXACT nodes:
\&
\&    U+0390 \- GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
\&    U+03B0 \- GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
\&
\&    which casefold to
\&
\&    Unicode                      UTF\-8
\&
\&    U+03B9 U+0308 U+0301         0xCE 0xB9 0xCC 0x88 0xCC 0x81
\&    U+03C5 U+0308 U+0301         0xCF 0x85 0xCC 0x88 0xCC 0x81
\&
\&    This means that in case\-insensitive matching (or "loose matching",
\&    as Unicode calls it), an EXACTF of length six (the UTF\-8 encoded
\&    byte length of the above casefolded versions) can match a target
\&    string of length two (the byte length of UTF\-8 encoded U+0390 or
\&    U+03B0). This would rather mess up the minimum length computation.
\&
\&    What we\*(Aqll do is to look for the tail four bytes, and then peek
\&    at the preceding two bytes to see whether we need to decrease
\&    the minimum length by four (six minus two).
\&
\&    Thanks to the design of UTF\-8, there cannot be false matches:
\&    A sequence of valid UTF\-8 bytes cannot be a subsequence of
\&    another valid sequence of UTF\-8 bytes.
.Ve
.SS "Base Structures"
.IX Subsection "Base Structures"
The \f(CW\*(C`regexp\*(C'\fR structure described in perlreapi is common to all
regex engines. Two of its fields that are intended for the private use
of the regex engine that compiled the pattern. These are the
\&\f(CW\*(C`intflags\*(C'\fR and pprivate members. The \f(CW\*(C`pprivate\*(C'\fR is a void pointer to
an arbitrary structure whose use and management is the responsibility
of the compiling engine. perl will never modify either of these
values. In the case of the stock engine the structure pointed to by
\&\f(CW\*(C`pprivate\*(C'\fR is called \f(CW\*(C`regexp_internal\*(C'\fR.
.PP
Its \f(CW\*(C`pprivate\*(C'\fR and \f(CW\*(C`intflags\*(C'\fR fields contain data
specific to each engine.
.PP
There are two structures used to store a compiled regular expression.
One, the \f(CW\*(C`regexp\*(C'\fR structure described in perlreapi is populated by
the engine currently being. used and some of its fields read by perl to
implement things such as the stringification of \f(CW\*(C`qr//\*(C'\fR.
.PP
The other structure is pointed to be the \f(CW\*(C`regexp\*(C'\fR struct's
\&\f(CW\*(C`pprivate\*(C'\fR and is in addition to \f(CW\*(C`intflags\*(C'\fR in the same struct
considered to be the property of the regex engine which compiled the
regular expression;
.PP
The regexp structure contains all the data that perl needs to be aware of
to properly work with the regular expression. It includes data about
optimisations that perl can use to determine if the regex engine should
really be used, and various other control info that is needed to properly
execute patterns in various contexts such as is the pattern anchored in
some way, or what flags were used during the compile, or whether the
program contains special constructs that perl needs to be aware of.
.PP
In addition it contains two fields that are intended for the private use
of the regex engine that compiled the pattern. These are the \f(CW\*(C`intflags\*(C'\fR
and pprivate members. The \f(CW\*(C`pprivate\*(C'\fR is a void pointer to an arbitrary
structure whose use and management is the responsibility of the compiling
engine. perl will never modify either of these values.
.PP
As mentioned earlier, in the case of the default engines, the \f(CW\*(C`pprivate\*(C'\fR
will be a pointer to a regexp_internal structure which holds the compiled
program and any additional data that is private to the regex engine
implementation.
.PP
\fIPerl's \f(CI\*(C`pprivate\*(C'\fI structure\fR
.IX Subsection "Perl's pprivate structure"
.PP
The following structure is used as the \f(CW\*(C`pprivate\*(C'\fR struct by perl's
regex engine. Since it is specific to perl it is only of curiosity
value to other engine implementations.
.PP
.Vb 10
\&    typedef struct regexp_internal {
\&            regexp_paren_ofs *swap; /* Swap copy of *startp / *endp */
\&            U32 *offsets;           /* offset annotations 20001228 MJD 
\&                                       data about mapping the program to the 
\&                                       string*/
\&            regnode *regstclass;    /* Optional startclass as identified or constructed
\&                                       by the optimiser */
\&            struct reg_data *data;  /* Additional miscellaneous data used by the program.
\&                                       Used to make it easier to clone and free arbitrary
\&                                       data that the regops need. Often the ARG field of
\&                                       a regop is an index into this structure */
\&            regnode program[1];     /* Unwarranted chumminess with compiler. */
\&    } regexp_internal;
.Ve
.ie n .IP """swap""" 5
.el .IP "\f(CWswap\fR" 5
.IX Item "swap"
\&\f(CW\*(C`swap\*(C'\fR formerly was an extra set of startp/endp stored in a
\&\f(CW\*(C`regexp_paren_ofs\*(C'\fR struct. This was used when the last successful match
was from the same pattern as the current pattern, so that a partial
match didn't overwrite the previous match's results, but it caused a
problem with re-entrant code such as trying to build the \s-1UTF\-8\s0 swashes.
Currently unused and left for backward compatibility with 5.10.0.
.ie n .IP """offsets""" 5
.el .IP "\f(CWoffsets\fR" 5
.IX Item "offsets"
Offsets holds a mapping of offset in the \f(CW\*(C`program\*(C'\fR
to offset in the \f(CW\*(C`precomp\*(C'\fR string. This is only used by ActiveState's
visual regex debugger.
.ie n .IP """regstclass""" 5
.el .IP "\f(CWregstclass\fR" 5
.IX Item "regstclass"
Special regop that is used by \f(CW\*(C`re_intuit_start()\*(C'\fR to check if a pattern
can match at a certain position. For instance if the regex engine knows
that the pattern must start with a 'Z' then it can scan the string until
it finds one and then launch the regex engine from there. The routine
that handles this is called \f(CW\*(C`find_by_class()\*(C'\fR. Sometimes this field
points at a regop embedded in the program, and sometimes it points at
an independent synthetic regop that has been constructed by the optimiser.
.ie n .IP """data""" 5
.el .IP "\f(CWdata\fR" 5
.IX Item "data"
This field points at a reg_data structure, which is defined as follows
.Sp
.Vb 5
\&    struct reg_data {
\&        U32 count;
\&        U8 *what;
\&        void* data[1];
\&    };
.Ve
.Sp
This structure is used for handling data structures that the regex engine
needs to handle specially during a clone or free operation on the compiled
product. Each element in the data array has a corresponding element in the
what array. During compilation regops that need special structures stored
will add an element to each array using the \fIadd_data()\fR routine and then store
the index in the regop.
.ie n .IP """program""" 5
.el .IP "\f(CWprogram\fR" 5
.IX Item "program"
Compiled program. Inlined into the structure so the entire struct can be
treated as a single blob.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlreapi
.PP
perlre
.PP
perlunitut
.SH "AUTHOR"
.IX Header "AUTHOR"
by Yves Orton, 2006.
.PP
With excerpts from Perl, and contributions and suggestions from
Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus,
Stephen McCamant, and David Landgren.
.SH "LICENCE"
.IX Header "LICENCE"
Same terms as Perl.
.SH "REFERENCES"
.IX Header "REFERENCES"
[1] <http://perl.plover.com/Rx/paper/>
.PP
[2] <http://www.unicode.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreguts5.18.1                             0100644 0001750 0001750 00000140200 12566207444 023447  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREGUTS 1"
.TH PERLREGUTS 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreguts \- Description of the Perl regular expression engine.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is an attempt to shine some light on the guts of the regex
engine and how it works. The regex engine represents a significant chunk
of the perl codebase, but is relatively poorly understood. This document
is a meagre attempt at addressing this situation. It is derived from the
author's experience, comments in the source code, other papers on the
regex engine, feedback on the perl5\-porters mail list, and no doubt other
places as well.
.PP
\&\fB\s-1NOTICE\s0!\fR It should be clearly understood that the behavior and
structures discussed in this represents the state of the engine as the
author understood it at the time of writing. It is \fB\s-1NOT\s0\fR an \s-1API\s0
definition, it is purely an internals guide for those who want to hack
the regex engine, or understand how the regex engine works. Readers of
this document are expected to understand perl's regex syntax and its
usage in detail. If you want to learn about the basics of Perl's
regular expressions, see perlre. And if you want to replace the
regex engine with your own, see perlreapi.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
.SS "A quick note on terms"
.IX Subsection "A quick note on terms"
There is some debate as to whether to say \*(L"regexp\*(R" or \*(L"regex\*(R". In this
document we will use the term \*(L"regex\*(R" unless there is a special reason
not to, in which case we will explain why.
.PP
When speaking about regexes we need to distinguish between their source
code form and their internal form. In this document we will use the term
\&\*(L"pattern\*(R" when we speak of their textual, source code form, and the term
\&\*(L"program\*(R" when we speak of their internal representation. These
correspond to the terms \fIS\-regex\fR and \fIB\-regex\fR that Mark Jason
Dominus employs in his paper on \*(L"Rx\*(R" ([1] in \*(L"\s-1REFERENCES\*(R"\s0).
.SS "What is a regular expression engine?"
.IX Subsection "What is a regular expression engine?"
A regular expression engine is a program that takes a set of constraints
specified in a mini-language, and then applies those constraints to a
target string, and determines whether or not the string satisfies the
constraints. See perlre for a full definition of the language.
.PP
In less grandiose terms, the first part of the job is to turn a pattern into
something the computer can efficiently use to find the matching point in
the string, and the second part is performing the search itself.
.PP
To do this we need to produce a program by parsing the text. We then
need to execute the program to find the point in the string that
matches. And we need to do the whole thing efficiently.
.SS "Structure of a Regexp Program"
.IX Subsection "Structure of a Regexp Program"
\fIHigh Level\fR
.IX Subsection "High Level"
.PP
Although it is a bit confusing and some people object to the terminology, it
is worth taking a look at a comment that has
been in \fIregexp.h\fR for years:
.PP
\&\fIThis is essentially a linear encoding of a nondeterministic
finite-state machine (aka syntax charts or \*(L"railroad normal form\*(R" in
parsing technology).\fR
.PP
The term \*(L"railroad normal form\*(R" is a bit esoteric, with \*(L"syntax
diagram/charts\*(R", or \*(L"railroad diagram/charts\*(R" being more common terms.
Nevertheless it provides a useful mental image of a regex program: each
node can be thought of as a unit of track, with a single entry and in
most cases a single exit point (there are pieces of track that fork, but
statistically not many), and the whole forms a layout with a
single entry and single exit point. The matching process can be thought
of as a car that moves along the track, with the particular route through
the system being determined by the character read at each possible
connector point. A car can fall off the track at any point but it may
only proceed as long as it matches the track.
.PP
Thus the pattern \f(CW\*(C`/foo(?:\ew+|\ed+|\es+)bar/\*(C'\fR can be thought of as the
following chart:
.PP
.Vb 10
\&                      [start]
\&                         |
\&                       <foo>
\&                         |
\&                   +\-\-\-\-\-+\-\-\-\-\-+
\&                   |     |     |
\&                 <\ew+> <\ed+> <\es+>
\&                   |     |     |
\&                   +\-\-\-\-\-+\-\-\-\-\-+
\&                         |
\&                       <bar>
\&                         |
\&                       [end]
.Ve
.PP
The truth of the matter is that perl's regular expressions these days are
much more complex than this kind of structure, but visualising it this way
can help when trying to get your bearings, and it matches the
current implementation pretty closely.
.PP
To be more precise, we will say that a regex program is an encoding
of a graph. Each node in the graph corresponds to part of
the original regex pattern, such as a literal string or a branch,
and has a pointer to the nodes representing the next component
to be matched. Since \*(L"node\*(R" and \*(L"opcode\*(R" already have other meanings in the
perl source, we will call the nodes in a regex program \*(L"regops\*(R".
.PP
The program is represented by an array of \f(CW\*(C`regnode\*(C'\fR structures, one or
more of which represent a single regop of the program. Struct
\&\f(CW\*(C`regnode\*(C'\fR is the smallest struct needed, and has a field structure which is
shared with all the other larger structures.
.PP
The \*(L"next\*(R" pointers of all regops except \f(CW\*(C`BRANCH\*(C'\fR implement concatenation;
a \*(L"next\*(R" pointer with a \f(CW\*(C`BRANCH\*(C'\fR on both ends of it is connecting two
alternatives.  [Here we have one of the subtle syntax dependencies: an
individual \f(CW\*(C`BRANCH\*(C'\fR (as opposed to a collection of them) is never
concatenated with anything because of operator precedence.]
.PP
The operand of some types of regop is a literal string; for others,
it is a regop leading into a sub-program.  In particular, the operand
of a \f(CW\*(C`BRANCH\*(C'\fR node is the first regop of the branch.
.PP
\&\fB\s-1NOTE\s0\fR: As the railroad metaphor suggests, this is \fBnot\fR a tree
structure:  the tail of the branch connects to the thing following the
set of \f(CW\*(C`BRANCH\*(C'\fRes.  It is a like a single line of railway track that
splits as it goes into a station or railway yard and rejoins as it comes
out the other side.
.PP
\fIRegops\fR
.IX Subsection "Regops"
.PP
The base structure of a regop is defined in \fIregexp.h\fR as follows:
.PP
.Vb 5
\&    struct regnode {
\&        U8  flags;    /* Various purposes, sometimes overridden */
\&        U8  type;     /* Opcode value as specified by regnodes.h */
\&        U16 next_off; /* Offset in size regnode */
\&    };
.Ve
.PP
Other larger \f(CW\*(C`regnode\*(C'\fR\-like structures are defined in \fIregcomp.h\fR. They
are almost like subclasses in that they have the same fields as
\&\f(CW\*(C`regnode\*(C'\fR, with possibly additional fields following in
the structure, and in some cases the specific meaning (and name)
of some of base fields are overridden. The following is a more
complete description.
.ie n .IP """regnode_1""" 4
.el .IP "\f(CWregnode_1\fR" 4
.IX Item "regnode_1"
.PD 0
.ie n .IP """regnode_2""" 4
.el .IP "\f(CWregnode_2\fR" 4
.IX Item "regnode_2"
.PD
\&\f(CW\*(C`regnode_1\*(C'\fR structures have the same header, followed by a single
four-byte argument; \f(CW\*(C`regnode_2\*(C'\fR structures contain two two-byte
arguments instead:
.Sp
.Vb 2
\&    regnode_1                U32 arg1;
\&    regnode_2                U16 arg1;  U16 arg2;
.Ve
.ie n .IP """regnode_string""" 4
.el .IP "\f(CWregnode_string\fR" 4
.IX Item "regnode_string"
\&\f(CW\*(C`regnode_string\*(C'\fR structures, used for literal strings, follow the header
with a one-byte length and then the string data. Strings are padded on
the end with zero bytes so that the total length of the node is a
multiple of four bytes:
.Sp
.Vb 2
\&    regnode_string           char string[1];
\&                             U8 str_len; /* overrides flags */
.Ve
.ie n .IP """regnode_charclass""" 4
.el .IP "\f(CWregnode_charclass\fR" 4
.IX Item "regnode_charclass"
Character classes are represented by \f(CW\*(C`regnode_charclass\*(C'\fR structures,
which have a four-byte argument and then a 32\-byte (256\-bit) bitmap
indicating which characters are included in the class.
.Sp
.Vb 2
\&    regnode_charclass        U32 arg1;
\&                             char bitmap[ANYOF_BITMAP_SIZE];
.Ve
.ie n .IP """regnode_charclass_class""" 4
.el .IP "\f(CWregnode_charclass_class\fR" 4
.IX Item "regnode_charclass_class"
There is also a larger form of a char class structure used to represent
\&\s-1POSIX\s0 char classes called \f(CW\*(C`regnode_charclass_class\*(C'\fR which has an
additional 4\-byte (32\-bit) bitmap indicating which \s-1POSIX\s0 char classes
have been included.
.Sp
.Vb 3
\&   regnode_charclass_class  U32 arg1;
\&                            char bitmap[ANYOF_BITMAP_SIZE];
\&                            char classflags[ANYOF_CLASSBITMAP_SIZE];
.Ve
.PP
\&\fIregnodes.h\fR defines an array called \f(CW\*(C`regarglen[]\*(C'\fR which gives the size
of each opcode in units of \f(CW\*(C`size regnode\*(C'\fR (4\-byte). A macro is used
to calculate the size of an \f(CW\*(C`EXACT\*(C'\fR node based on its \f(CW\*(C`str_len\*(C'\fR field.
.PP
The regops are defined in \fIregnodes.h\fR which is generated from
\&\fIregcomp.sym\fR by \fIregcomp.pl\fR. Currently the maximum possible number
of distinct regops is restricted to 256, with about a quarter already
used.
.PP
A set of macros makes accessing the fields
easier and more consistent. These include \f(CW\*(C`OP()\*(C'\fR, which is used to determine
the type of a \f(CW\*(C`regnode\*(C'\fR\-like structure; \f(CW\*(C`NEXT_OFF()\*(C'\fR, which is the offset to
the next node (more on this later); \f(CW\*(C`ARG()\*(C'\fR, \f(CW\*(C`ARG1()\*(C'\fR, \f(CW\*(C`ARG2()\*(C'\fR, \f(CW\*(C`ARG_SET()\*(C'\fR,
and equivalents for reading and setting the arguments; and \f(CW\*(C`STR_LEN()\*(C'\fR,
\&\f(CW\*(C`STRING()\*(C'\fR and \f(CW\*(C`OPERAND()\*(C'\fR for manipulating strings and regop bearing
types.
.PP
\fIWhat regop is next?\fR
.IX Subsection "What regop is next?"
.PP
There are three distinct concepts of \*(L"next\*(R" in the regex engine, and
it is important to keep them clear.
.IP "\(bu" 4
There is the \*(L"next regnode\*(R" from a given regnode, a value which is
rarely useful except that sometimes it matches up in terms of value
with one of the others, and that sometimes the code assumes this to
always be so.
.IP "\(bu" 4
There is the \*(L"next regop\*(R" from a given regop/regnode. This is the
regop physically located after the current one, as determined by
the size of the current regop. This is often useful, such as when
dumping the structure we use this order to traverse. Sometimes the code
assumes that the \*(L"next regnode\*(R" is the same as the \*(L"next regop\*(R", or in
other words assumes that the sizeof a given regop type is always going
to be one regnode large.
.IP "\(bu" 4
There is the \*(L"regnext\*(R" from a given regop. This is the regop which
is reached by jumping forward by the value of \f(CW\*(C`NEXT_OFF()\*(C'\fR,
or in a few cases for longer jumps by the \f(CW\*(C`arg1\*(C'\fR field of the \f(CW\*(C`regnode_1\*(C'\fR
structure. The subroutine \f(CW\*(C`regnext()\*(C'\fR handles this transparently.
This is the logical successor of the node, which in some cases, like
that of the \f(CW\*(C`BRANCH\*(C'\fR regop, has special meaning.
.SH "Process Overview"
.IX Header "Process Overview"
Broadly speaking, performing a match of a string against a pattern
involves the following steps:
.IP "A. Compilation" 5
.IX Item "A. Compilation"
.RS 5
.PD 0
.IP "1. Parsing for size" 5
.IX Item "1. Parsing for size"
.IP "2. Parsing for construction" 5
.IX Item "2. Parsing for construction"
.IP "3. Peep-hole optimisation and analysis" 5
.IX Item "3. Peep-hole optimisation and analysis"
.RE
.RS 5
.RE
.IP "B. Execution" 5
.IX Item "B. Execution"
.RS 5
.IP "4. Start position and no-match optimisations" 5
.IX Item "4. Start position and no-match optimisations"
.IP "5. Program execution" 5
.IX Item "5. Program execution"
.RE
.RS 5
.RE
.PD
.PP
Where these steps occur in the actual execution of a perl program is
determined by whether the pattern involves interpolating any string
variables. If interpolation occurs, then compilation happens at run time. If it
does not, then compilation is performed at compile time. (The \f(CW\*(C`/o\*(C'\fR modifier changes this,
as does \f(CW\*(C`qr//\*(C'\fR to a certain extent.) The engine doesn't really care that
much.
.SS "Compilation"
.IX Subsection "Compilation"
This code resides primarily in \fIregcomp.c\fR, along with the header files
\&\fIregcomp.h\fR, \fIregexp.h\fR and \fIregnodes.h\fR.
.PP
Compilation starts with \f(CW\*(C`pregcomp()\*(C'\fR, which is mostly an initialisation
wrapper which farms work out to two other routines for the heavy lifting: the
first is \f(CW\*(C`reg()\*(C'\fR, which is the start point for parsing; the second,
\&\f(CW\*(C`study_chunk()\*(C'\fR, is responsible for optimisation.
.PP
Initialisation in \f(CW\*(C`pregcomp()\*(C'\fR mostly involves the creation and data-filling
of a special structure, \f(CW\*(C`RExC_state_t\*(C'\fR (defined in \fIregcomp.c\fR).
Almost all internally-used routines in \fIregcomp.h\fR take a pointer to one
of these structures as their first argument, with the name \f(CW\*(C`pRExC_state\*(C'\fR.
This structure is used to store the compilation state and contains many
fields. Likewise there are many macros which operate on this
variable: anything that looks like \f(CW\*(C`RExC_xxxx\*(C'\fR is a macro that operates on
this pointer/structure.
.PP
\fIParsing for size\fR
.IX Subsection "Parsing for size"
.PP
In this pass the input pattern is parsed in order to calculate how much
space is needed for each regop we would need to emit. The size is also
used to determine whether long jumps will be required in the program.
.PP
This stage is controlled by the macro \f(CW\*(C`SIZE_ONLY\*(C'\fR being set.
.PP
The parse proceeds pretty much exactly as it does during the
construction phase, except that most routines are short-circuited to
change the size field \f(CW\*(C`RExC_size\*(C'\fR and not do anything else.
.PP
\fIParsing for construction\fR
.IX Subsection "Parsing for construction"
.PP
Once the size of the program has been determined, the pattern is parsed
again, but this time for real. Now \f(CW\*(C`SIZE_ONLY\*(C'\fR will be false, and the
actual construction can occur.
.PP
\&\f(CW\*(C`reg()\*(C'\fR is the start of the parse process. It is responsible for
parsing an arbitrary chunk of pattern up to either the end of the
string, or the first closing parenthesis it encounters in the pattern.
This means it can be used to parse the top-level regex, or any section
inside of a grouping parenthesis. It also handles the \*(L"special parens\*(R"
that perl's regexes have. For instance when parsing \f(CW\*(C`/x(?:foo)y/\*(C'\fR \f(CW\*(C`reg()\*(C'\fR
will at one point be called to parse from the \*(L"?\*(R" symbol up to and
including the \*(L")\*(R".
.PP
Additionally, \f(CW\*(C`reg()\*(C'\fR is responsible for parsing the one or more
branches from the pattern, and for \*(L"finishing them off\*(R" by correctly
setting their next pointers. In order to do the parsing, it repeatedly
calls out to \f(CW\*(C`regbranch()\*(C'\fR, which is responsible for handling up to the
first \f(CW\*(C`|\*(C'\fR symbol it sees.
.PP
\&\f(CW\*(C`regbranch()\*(C'\fR in turn calls \f(CW\*(C`regpiece()\*(C'\fR which
handles \*(L"things\*(R" followed by a quantifier. In order to parse the
\&\*(L"things\*(R", \f(CW\*(C`regatom()\*(C'\fR is called. This is the lowest level routine, which
parses out constant strings, character classes, and the
various special symbols like \f(CW\*(C`$\*(C'\fR. If \f(CW\*(C`regatom()\*(C'\fR encounters a \*(L"(\*(R"
character it in turn calls \f(CW\*(C`reg()\*(C'\fR.
.PP
The routine \f(CW\*(C`regtail()\*(C'\fR is called by both \f(CW\*(C`reg()\*(C'\fR and \f(CW\*(C`regbranch()\*(C'\fR
in order to \*(L"set the tail pointer\*(R" correctly. When executing and
we get to the end of a branch, we need to go to the node following the
grouping parens. When parsing, however, we don't know where the end will
be until we get there, so when we do we must go back and update the
offsets as appropriate. \f(CW\*(C`regtail\*(C'\fR is used to make this easier.
.PP
A subtlety of the parsing process means that a regex like \f(CW\*(C`/foo/\*(C'\fR is
originally parsed into an alternation with a single branch. It is only
afterwards that the optimiser converts single branch alternations into the
simpler form.
.PP
\fIParse Call Graph and a Grammar\fR
.IX Subsection "Parse Call Graph and a Grammar"
.PP
The call graph looks like this:
.PP
.Vb 10
\& reg()                        # parse a top level regex, or inside of
\&                              # parens
\&     regbranch()              # parse a single branch of an alternation
\&         regpiece()           # parse a pattern followed by a quantifier
\&             regatom()        # parse a simple pattern
\&                 regclass()   #   used to handle a class
\&                 reg()        #   used to handle a parenthesised
\&                              #   subpattern
\&                 ....
\&         ...
\&         regtail()            # finish off the branch
\&     ...
\&     regtail()                # finish off the branch sequence. Tie each
\&                              # branch\*(Aqs tail to the tail of the
\&                              # sequence
\&                              # (NEW) In Debug mode this is
\&                              # regtail_study().
.Ve
.PP
A grammar form might be something like this:
.PP
.Vb 11
\&    atom  : constant | class
\&    quant : \*(Aq*\*(Aq | \*(Aq+\*(Aq | \*(Aq?\*(Aq | \*(Aq{min,max}\*(Aq
\&    _branch: piece
\&           | piece _branch
\&           | nothing
\&    branch: _branch
\&          | _branch \*(Aq|\*(Aq branch
\&    group : \*(Aq(\*(Aq branch \*(Aq)\*(Aq
\&    _piece: atom | group
\&    piece : _piece
\&          | _piece quant
.Ve
.PP
\fIParsing complications\fR
.IX Subsection "Parsing complications"
.PP
The implication of the above description is that a pattern containing nested
parentheses will result in a call graph which cycles through \f(CW\*(C`reg()\*(C'\fR,
\&\f(CW\*(C`regbranch()\*(C'\fR, \f(CW\*(C`regpiece()\*(C'\fR, \f(CW\*(C`regatom()\*(C'\fR, \f(CW\*(C`reg()\*(C'\fR, \f(CW\*(C`regbranch()\*(C'\fR \fIetc\fR
multiple times, until the deepest level of nesting is reached. All the above
routines return a pointer to a \f(CW\*(C`regnode\*(C'\fR, which is usually the last regnode
added to the program. However, one complication is that \fIreg()\fR returns \s-1NULL\s0
for parsing \f(CW\*(C`(?:)\*(C'\fR syntax for embedded modifiers, setting the flag
\&\f(CW\*(C`TRYAGAIN\*(C'\fR. The \f(CW\*(C`TRYAGAIN\*(C'\fR propagates upwards until it is captured, in
some cases by by \f(CW\*(C`regatom()\*(C'\fR, but otherwise unconditionally by
\&\f(CW\*(C`regbranch()\*(C'\fR. Hence it will never be returned by \f(CW\*(C`regbranch()\*(C'\fR to
\&\f(CW\*(C`reg()\*(C'\fR. This flag permits patterns such as \f(CW\*(C`(?i)+\*(C'\fR to be detected as
errors (\fIQuantifier follows nothing in regex; marked by <\-\- \s-1HERE\s0 in m/(?i)+
<\-\- \s-1HERE /\s0\fR).
.PP
Another complication is that the representation used for the program differs
if it needs to store Unicode, but it's not always possible to know for sure
whether it does until midway through parsing. The Unicode representation for
the program is larger, and cannot be matched as efficiently. (See \*(L"Unicode
and Localisation Support\*(R" below for more details as to why.)  If the pattern
contains literal Unicode, it's obvious that the program needs to store
Unicode. Otherwise, the parser optimistically assumes that the more
efficient representation can be used, and starts sizing on this basis.
However, if it then encounters something in the pattern which must be stored
as Unicode, such as an \f(CW\*(C`\ex{...}\*(C'\fR escape sequence representing a character
literal, then this means that all previously calculated sizes need to be
redone, using values appropriate for the Unicode representation. Currently,
all regular expression constructions which can trigger this are parsed by code
in \f(CW\*(C`regatom()\*(C'\fR.
.PP
To avoid wasted work when a restart is needed, the sizing pass is abandoned
\&\- \f(CW\*(C`regatom()\*(C'\fR immediately returns \s-1NULL,\s0 setting the flag \f(CW\*(C`RESTART_UTF8\*(C'\fR.
(This action is encapsulated using the macro \f(CW\*(C`REQUIRE_UTF8\*(C'\fR.) This restart
request is propagated up the call chain in a similar fashion, until it is
\&\*(L"caught\*(R" in \f(CW\*(C`Perl_re_op_compile()\*(C'\fR, which marks the pattern as containing
Unicode, and restarts the sizing pass. It is also possible for constructions
within run-time code blocks to turn out to need Unicode representation.,
which is signalled by \f(CW\*(C`S_compile_runtime_code()\*(C'\fR returning false to
\&\f(CW\*(C`Perl_re_op_compile()\*(C'\fR.
.PP
The restart was previously implemented using a \f(CW\*(C`longjmp\*(C'\fR in \f(CW\*(C`regatom()\*(C'\fR
back to a \f(CW\*(C`setjmp\*(C'\fR in \f(CW\*(C`Perl_re_op_compile()\*(C'\fR, but this proved to be
problematic as the latter is a large function containing many automatic
variables, which interact badly with the emergent control flow of \f(CW\*(C`setjmp\*(C'\fR.
.PP
\fIDebug Output\fR
.IX Subsection "Debug Output"
.PP
In the 5.9.x development version of perl you can \f(CW\*(C`use re Debug => \*(AqPARSE\*(Aq\*(C'\fR
to see some trace information about the parse process. We will start with some
simple patterns and build up to more complex patterns.
.PP
So when we parse \f(CW\*(C`/foo/\*(C'\fR we see something like the following table. The
left shows what is being parsed, and the number indicates where the next regop
would go. The stuff on the right is the trace output of the graph. The
names are chosen to be short to make it less dense on the screen. 'tsdy'
is a special form of \f(CW\*(C`regtail()\*(C'\fR which does some extra analysis.
.PP
.Vb 6
\& >foo<             1    reg
\&                          brnc
\&                            piec
\&                              atom
\& ><                4      tsdy~ EXACT <foo> (EXACT) (1)
\&                              ~ attach to END (3) offset to 2
.Ve
.PP
The resulting program then looks like:
.PP
.Vb 2
\&   1: EXACT <foo>(3)
\&   3: END(0)
.Ve
.PP
As you can see, even though we parsed out a branch and a piece, it was ultimately
only an atom. The final program shows us how things work. We have an \f(CW\*(C`EXACT\*(C'\fR regop,
followed by an \f(CW\*(C`END\*(C'\fR regop. The number in parens indicates where the \f(CW\*(C`regnext\*(C'\fR of
the node goes. The \f(CW\*(C`regnext\*(C'\fR of an \f(CW\*(C`END\*(C'\fR regop is unused, as \f(CW\*(C`END\*(C'\fR regops mean
we have successfully matched. The number on the left indicates the position of
the regop in the regnode array.
.PP
Now let's try a harder pattern. We will add a quantifier, so now we have the pattern
\&\f(CW\*(C`/foo+/\*(C'\fR. We will see that \f(CW\*(C`regbranch()\*(C'\fR calls \f(CW\*(C`regpiece()\*(C'\fR twice.
.PP
.Vb 10
\& >foo+<            1    reg
\&                          brnc
\&                            piec
\&                              atom
\& >o+<              3        piec
\&                              atom
\& ><                6        tail~ EXACT <fo> (1)
\&                   7      tsdy~ EXACT <fo> (EXACT) (1)
\&                              ~ PLUS (END) (3)
\&                              ~ attach to END (6) offset to 3
.Ve
.PP
And we end up with the program:
.PP
.Vb 4
\&   1: EXACT <fo>(3)
\&   3: PLUS(6)
\&   4:   EXACT <o>(0)
\&   6: END(0)
.Ve
.PP
Now we have a special case. The \f(CW\*(C`EXACT\*(C'\fR regop has a \f(CW\*(C`regnext\*(C'\fR of 0. This is
because if it matches it should try to match itself again. The \f(CW\*(C`PLUS\*(C'\fR regop
handles the actual failure of the \f(CW\*(C`EXACT\*(C'\fR regop and acts appropriately (going
to regnode 6 if the \f(CW\*(C`EXACT\*(C'\fR matched at least once, or failing if it didn't).
.PP
Now for something much more complex: \f(CW\*(C`/x(?:foo*|b[a][rR])(foo|bar)$/\*(C'\fR
.PP
.Vb 10
\& >x(?:foo*|b...    1    reg
\&                          brnc
\&                            piec
\&                              atom
\& >(?:foo*|b[...    3        piec
\&                              atom
\& >?:foo*|b[a...                 reg
\& >foo*|b[a][...                   brnc
\&                                    piec
\&                                      atom
\& >o*|b[a][rR...    5                piec
\&                                      atom
\& >|b[a][rR])...    8                tail~ EXACT <fo> (3)
\& >b[a][rR])(...    9              brnc
\&                  10                piec
\&                                      atom
\& >[a][rR])(f...   12                piec
\&                                      atom
\& >a][rR])(fo...                         clas
\& >[rR])(foo|...   14                tail~ EXACT <b> (10)
\&                                    piec
\&                                      atom
\& >rR])(foo|b...                         clas
\& >)(foo|bar)...   25                tail~ EXACT <a> (12)
\&                                  tail~ BRANCH (3)
\&                  26              tsdy~ BRANCH (END) (9)
\&                                      ~ attach to TAIL (25) offset to 16
\&                                  tsdy~ EXACT <fo> (EXACT) (4)
\&                                      ~ STAR (END) (6)
\&                                      ~ attach to TAIL (25) offset to 19
\&                                  tsdy~ EXACT <b> (EXACT) (10)
\&                                      ~ EXACT <a> (EXACT) (12)
\&                                      ~ ANYOF[Rr] (END) (14)
\&                                      ~ attach to TAIL (25) offset to 11
\& >(foo|bar)$<               tail~ EXACT <x> (1)
\&                            piec
\&                              atom
\& >foo|bar)$<                    reg
\&                  28              brnc
\&                                    piec
\&                                      atom
\& >|bar)$<         31              tail~ OPEN1 (26)
\& >bar)$<                          brnc
\&                  32                piec
\&                                      atom
\& >)$<             34              tail~ BRANCH (28)
\&                  36              tsdy~ BRANCH (END) (31)
\&                                     ~ attach to CLOSE1 (34) offset to 3
\&                                  tsdy~ EXACT <foo> (EXACT) (29)
\&                                     ~ attach to CLOSE1 (34) offset to 5
\&                                  tsdy~ EXACT <bar> (EXACT) (32)
\&                                     ~ attach to CLOSE1 (34) offset to 2
\& >$<                        tail~ BRANCH (3)
\&                                ~ BRANCH (9)
\&                                ~ TAIL (25)
\&                            piec
\&                              atom
\& ><               37        tail~ OPEN1 (26)
\&                                ~ BRANCH (28)
\&                                ~ BRANCH (31)
\&                                ~ CLOSE1 (34)
\&                  38      tsdy~ EXACT <x> (EXACT) (1)
\&                              ~ BRANCH (END) (3)
\&                              ~ BRANCH (END) (9)
\&                              ~ TAIL (END) (25)
\&                              ~ OPEN1 (END) (26)
\&                              ~ BRANCH (END) (28)
\&                              ~ BRANCH (END) (31)
\&                              ~ CLOSE1 (END) (34)
\&                              ~ EOL (END) (36)
\&                              ~ attach to END (37) offset to 1
.Ve
.PP
Resulting in the program
.PP
.Vb 10
\&   1: EXACT <x>(3)
\&   3: BRANCH(9)
\&   4:   EXACT <fo>(6)
\&   6:   STAR(26)
\&   7:     EXACT <o>(0)
\&   9: BRANCH(25)
\&  10:   EXACT <ba>(14)
\&  12:   OPTIMIZED (2 nodes)
\&  14:   ANYOF[Rr](26)
\&  25: TAIL(26)
\&  26: OPEN1(28)
\&  28:   TRIE\-EXACT(34)
\&        [StS:1 Wds:2 Cs:6 Uq:5 #Sts:7 Mn:3 Mx:3 Stcls:bf]
\&          <foo>
\&          <bar>
\&  30:   OPTIMIZED (4 nodes)
\&  34: CLOSE1(36)
\&  36: EOL(37)
\&  37: END(0)
.Ve
.PP
Here we can see a much more complex program, with various optimisations in
play. At regnode 10 we see an example where a character class with only
one character in it was turned into an \f(CW\*(C`EXACT\*(C'\fR node. We can also see where
an entire alternation was turned into a \f(CW\*(C`TRIE\-EXACT\*(C'\fR node. As a consequence,
some of the regnodes have been marked as optimised away. We can see that
the \f(CW\*(C`$\*(C'\fR symbol has been converted into an \f(CW\*(C`EOL\*(C'\fR regop, a special piece of
code that looks for \f(CW\*(C`\en\*(C'\fR or the end of the string.
.PP
The next pointer for \f(CW\*(C`BRANCH\*(C'\fRes is interesting in that it points at where
execution should go if the branch fails. When executing, if the engine
tries to traverse from a branch to a \f(CW\*(C`regnext\*(C'\fR that isn't a branch then
the engine will know that the entire set of branches has failed.
.PP
\fIPeep-hole Optimisation and Analysis\fR
.IX Subsection "Peep-hole Optimisation and Analysis"
.PP
The regular expression engine can be a weighty tool to wield. On long
strings and complex patterns it can end up having to do a lot of work
to find a match, and even more to decide that no match is possible.
Consider a situation like the following pattern.
.PP
.Vb 1
\&   \*(Aqababababababababababab\*(Aq =~ /(a|b)*z/
.Ve
.PP
The \f(CW\*(C`(a|b)*\*(C'\fR part can match at every char in the string, and then fail
every time because there is no \f(CW\*(C`z\*(C'\fR in the string. So obviously we can
avoid using the regex engine unless there is a \f(CW\*(C`z\*(C'\fR in the string.
Likewise in a pattern like:
.PP
.Vb 1
\&   /foo(\ew+)bar/
.Ve
.PP
In this case we know that the string must contain a \f(CW\*(C`foo\*(C'\fR which must be
followed by \f(CW\*(C`bar\*(C'\fR. We can use Fast Boyer-Moore matching as implemented
in \f(CW\*(C`fbm_instr()\*(C'\fR to find the location of these strings. If they don't exist
then we don't need to resort to the much more expensive regex engine.
Even better, if they do exist then we can use their positions to
reduce the search space that the regex engine needs to cover to determine
if the entire pattern matches.
.PP
There are various aspects of the pattern that can be used to facilitate
optimisations along these lines:
.IP "\(bu" 5
anchored fixed strings
.IP "\(bu" 5
floating fixed strings
.IP "\(bu" 5
minimum and maximum length requirements
.IP "\(bu" 5
start class
.IP "\(bu" 5
Beginning/End of line positions
.PP
Another form of optimisation that can occur is the post-parse \*(L"peep-hole\*(R"
optimisation, where inefficient constructs are replaced by more efficient
constructs. The \f(CW\*(C`TAIL\*(C'\fR regops which are used during parsing to mark the end
of branches and the end of groups are examples of this. These regops are used
as place-holders during construction and \*(L"always match\*(R" so they can be
\&\*(L"optimised away\*(R" by making the things that point to the \f(CW\*(C`TAIL\*(C'\fR point to the
thing that \f(CW\*(C`TAIL\*(C'\fR points to, thus \*(L"skipping\*(R" the node.
.PP
Another optimisation that can occur is that of "\f(CW\*(C`EXACT\*(C'\fR merging" which is
where two consecutive \f(CW\*(C`EXACT\*(C'\fR nodes are merged into a single
regop. An even more aggressive form of this is that a branch
sequence of the form \f(CW\*(C`EXACT BRANCH ... EXACT\*(C'\fR can be converted into a
\&\f(CW\*(C`TRIE\-EXACT\*(C'\fR regop.
.PP
All of this occurs in the routine \f(CW\*(C`study_chunk()\*(C'\fR which uses a special
structure \f(CW\*(C`scan_data_t\*(C'\fR to store the analysis that it has performed, and
does the \*(L"peep-hole\*(R" optimisations as it goes.
.PP
The code involved in \f(CW\*(C`study_chunk()\*(C'\fR is extremely cryptic. Be careful. :\-)
.SS "Execution"
.IX Subsection "Execution"
Execution of a regex generally involves two phases, the first being
finding the start point in the string where we should match from,
and the second being running the regop interpreter.
.PP
If we can tell that there is no valid start point then we don't bother running
interpreter at all. Likewise, if we know from the analysis phase that we
cannot detect a short-cut to the start position, we go straight to the
interpreter.
.PP
The two entry points are \f(CW\*(C`re_intuit_start()\*(C'\fR and \f(CW\*(C`pregexec()\*(C'\fR. These routines
have a somewhat incestuous relationship with overlap between their functions,
and \f(CW\*(C`pregexec()\*(C'\fR may even call \f(CW\*(C`re_intuit_start()\*(C'\fR on its own. Nevertheless
other parts of the perl source code may call into either, or both.
.PP
Execution of the interpreter itself used to be recursive, but thanks to the
efforts of Dave Mitchell in the 5.9.x development track, that has changed: now an
internal stack is maintained on the heap and the routine is fully
iterative. This can make it tricky as the code is quite conservative
about what state it stores, with the result that two consecutive lines in the
code can actually be running in totally different contexts due to the
simulated recursion.
.PP
\fIStart position and no-match optimisations\fR
.IX Subsection "Start position and no-match optimisations"
.PP
\&\f(CW\*(C`re_intuit_start()\*(C'\fR is responsible for handling start points and no-match
optimisations as determined by the results of the analysis done by
\&\f(CW\*(C`study_chunk()\*(C'\fR (and described in \*(L"Peep-hole Optimisation and Analysis\*(R").
.PP
The basic structure of this routine is to try to find the start\- and/or
end-points of where the pattern could match, and to ensure that the string
is long enough to match the pattern. It tries to use more efficient
methods over less efficient methods and may involve considerable
cross-checking of constraints to find the place in the string that matches.
For instance it may try to determine that a given fixed string must be
not only present but a certain number of chars before the end of the
string, or whatever.
.PP
It calls several other routines, such as \f(CW\*(C`fbm_instr()\*(C'\fR which does
Fast Boyer Moore matching and \f(CW\*(C`find_byclass()\*(C'\fR which is responsible for
finding the start using the first mandatory regop in the program.
.PP
When the optimisation criteria have been satisfied, \f(CW\*(C`reg_try()\*(C'\fR is called
to perform the match.
.PP
\fIProgram execution\fR
.IX Subsection "Program execution"
.PP
\&\f(CW\*(C`pregexec()\*(C'\fR is the main entry point for running a regex. It contains
support for initialising the regex interpreter's state, running
\&\f(CW\*(C`re_intuit_start()\*(C'\fR if needed, and running the interpreter on the string
from various start positions as needed. When it is necessary to use
the regex interpreter \f(CW\*(C`pregexec()\*(C'\fR calls \f(CW\*(C`regtry()\*(C'\fR.
.PP
\&\f(CW\*(C`regtry()\*(C'\fR is the entry point into the regex interpreter. It expects
as arguments a pointer to a \f(CW\*(C`regmatch_info\*(C'\fR structure and a pointer to
a string.  It returns an integer 1 for success and a 0 for failure.
It is basically a set-up wrapper around \f(CW\*(C`regmatch()\*(C'\fR.
.PP
\&\f(CW\*(C`regmatch\*(C'\fR is the main \*(L"recursive loop\*(R" of the interpreter. It is
basically a giant switch statement that implements a state machine, where
the possible states are the regops themselves, plus a number of additional
intermediate and failure states. A few of the states are implemented as
subroutines but the bulk are inline code.
.SH "MISCELLANEOUS"
.IX Header "MISCELLANEOUS"
.SS "Unicode and Localisation Support"
.IX Subsection "Unicode and Localisation Support"
When dealing with strings containing characters that cannot be represented
using an eight-bit character set, perl uses an internal representation
that is a permissive version of Unicode's \s-1UTF\-8\s0 encoding[2]. This uses single
bytes to represent characters from the \s-1ASCII\s0 character set, and sequences
of two or more bytes for all other characters. (See perlunitut
for more information about the relationship between \s-1UTF\-8\s0 and perl's
encoding, utf8. The difference isn't important for this discussion.)
.PP
No matter how you look at it, Unicode support is going to be a pain in a
regex engine. Tricks that might be fine when you have 256 possible
characters often won't scale to handle the size of the \s-1UTF\-8\s0 character
set.  Things you can take for granted with \s-1ASCII\s0 may not be true with
Unicode. For instance, in \s-1ASCII,\s0 it is safe to assume that
\&\f(CW\*(C`sizeof(char1) == sizeof(char2)\*(C'\fR, but in \s-1UTF\-8\s0 it isn't. Unicode case folding is
vastly more complex than the simple rules of \s-1ASCII,\s0 and even when not
using Unicode but only localised single byte encodings, things can get
tricky (for example, \fB\s-1LATIN SMALL LETTER SHARP S\s0\fR (U+00DF, \*8)
should match '\s-1SS\s0' in localised case-insensitive matching).
.PP
Making things worse is that \s-1UTF\-8\s0 support was a later addition to the
regex engine (as it was to perl) and this necessarily  made things a lot
more complicated. Obviously it is easier to design a regex engine with
Unicode support in mind from the beginning than it is to retrofit it to
one that wasn't.
.PP
Nearly all regops that involve looking at the input string have
two cases, one for \s-1UTF\-8,\s0 and one not. In fact, it's often more complex
than that, as the pattern may be \s-1UTF\-8\s0 as well.
.PP
Care must be taken when making changes to make sure that you handle
\&\s-1UTF\-8\s0 properly, both at compile time and at execution time, including
when the string and pattern are mismatched.
.PP
The following comment in \fIregcomp.h\fR gives an example of exactly how
tricky this can be:
.PP
.Vb 1
\&    Two problematic code points in Unicode casefolding of EXACT nodes:
\&
\&    U+0390 \- GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
\&    U+03B0 \- GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
\&
\&    which casefold to
\&
\&    Unicode                      UTF\-8
\&
\&    U+03B9 U+0308 U+0301         0xCE 0xB9 0xCC 0x88 0xCC 0x81
\&    U+03C5 U+0308 U+0301         0xCF 0x85 0xCC 0x88 0xCC 0x81
\&
\&    This means that in case\-insensitive matching (or "loose matching",
\&    as Unicode calls it), an EXACTF of length six (the UTF\-8 encoded
\&    byte length of the above casefolded versions) can match a target
\&    string of length two (the byte length of UTF\-8 encoded U+0390 or
\&    U+03B0). This would rather mess up the minimum length computation.
\&
\&    What we\*(Aqll do is to look for the tail four bytes, and then peek
\&    at the preceding two bytes to see whether we need to decrease
\&    the minimum length by four (six minus two).
\&
\&    Thanks to the design of UTF\-8, there cannot be false matches:
\&    A sequence of valid UTF\-8 bytes cannot be a subsequence of
\&    another valid sequence of UTF\-8 bytes.
.Ve
.SS "Base Structures"
.IX Subsection "Base Structures"
The \f(CW\*(C`regexp\*(C'\fR structure described in perlreapi is common to all
regex engines. Two of its fields that are intended for the private use
of the regex engine that compiled the pattern. These are the
\&\f(CW\*(C`intflags\*(C'\fR and pprivate members. The \f(CW\*(C`pprivate\*(C'\fR is a void pointer to
an arbitrary structure whose use and management is the responsibility
of the compiling engine. perl will never modify either of these
values. In the case of the stock engine the structure pointed to by
\&\f(CW\*(C`pprivate\*(C'\fR is called \f(CW\*(C`regexp_internal\*(C'\fR.
.PP
Its \f(CW\*(C`pprivate\*(C'\fR and \f(CW\*(C`intflags\*(C'\fR fields contain data
specific to each engine.
.PP
There are two structures used to store a compiled regular expression.
One, the \f(CW\*(C`regexp\*(C'\fR structure described in perlreapi is populated by
the engine currently being. used and some of its fields read by perl to
implement things such as the stringification of \f(CW\*(C`qr//\*(C'\fR.
.PP
The other structure is pointed to be the \f(CW\*(C`regexp\*(C'\fR struct's
\&\f(CW\*(C`pprivate\*(C'\fR and is in addition to \f(CW\*(C`intflags\*(C'\fR in the same struct
considered to be the property of the regex engine which compiled the
regular expression;
.PP
The regexp structure contains all the data that perl needs to be aware of
to properly work with the regular expression. It includes data about
optimisations that perl can use to determine if the regex engine should
really be used, and various other control info that is needed to properly
execute patterns in various contexts such as is the pattern anchored in
some way, or what flags were used during the compile, or whether the
program contains special constructs that perl needs to be aware of.
.PP
In addition it contains two fields that are intended for the private use
of the regex engine that compiled the pattern. These are the \f(CW\*(C`intflags\*(C'\fR
and pprivate members. The \f(CW\*(C`pprivate\*(C'\fR is a void pointer to an arbitrary
structure whose use and management is the responsibility of the compiling
engine. perl will never modify either of these values.
.PP
As mentioned earlier, in the case of the default engines, the \f(CW\*(C`pprivate\*(C'\fR
will be a pointer to a regexp_internal structure which holds the compiled
program and any additional data that is private to the regex engine
implementation.
.PP
\fIPerl's \f(CI\*(C`pprivate\*(C'\fI structure\fR
.IX Subsection "Perl's pprivate structure"
.PP
The following structure is used as the \f(CW\*(C`pprivate\*(C'\fR struct by perl's
regex engine. Since it is specific to perl it is only of curiosity
value to other engine implementations.
.PP
.Vb 10
\& typedef struct regexp_internal {
\&         U32 *offsets;           /* offset annotations 20001228 MJD
\&                                  * data about mapping the program to
\&                                  * the string*/
\&         regnode *regstclass;    /* Optional startclass as identified or
\&                                  * constructed by the optimiser */
\&         struct reg_data *data;  /* Additional miscellaneous data used
\&                                  * by the program.  Used to make it
\&                                  * easier to clone and free arbitrary
\&                                  * data that the regops need. Often the
\&                                  * ARG field of a regop is an index
\&                                  * into this structure */
\&         regnode program[1];     /* Unwarranted chumminess with
\&                                  * compiler. */
\& } regexp_internal;
.Ve
.ie n .IP """offsets""" 5
.el .IP "\f(CWoffsets\fR" 5
.IX Item "offsets"
Offsets holds a mapping of offset in the \f(CW\*(C`program\*(C'\fR
to offset in the \f(CW\*(C`precomp\*(C'\fR string. This is only used by ActiveState's
visual regex debugger.
.ie n .IP """regstclass""" 5
.el .IP "\f(CWregstclass\fR" 5
.IX Item "regstclass"
Special regop that is used by \f(CW\*(C`re_intuit_start()\*(C'\fR to check if a pattern
can match at a certain position. For instance if the regex engine knows
that the pattern must start with a 'Z' then it can scan the string until
it finds one and then launch the regex engine from there. The routine
that handles this is called \f(CW\*(C`find_by_class()\*(C'\fR. Sometimes this field
points at a regop embedded in the program, and sometimes it points at
an independent synthetic regop that has been constructed by the optimiser.
.ie n .IP """data""" 5
.el .IP "\f(CWdata\fR" 5
.IX Item "data"
This field points at a reg_data structure, which is defined as follows
.Sp
.Vb 5
\&    struct reg_data {
\&        U32 count;
\&        U8 *what;
\&        void* data[1];
\&    };
.Ve
.Sp
This structure is used for handling data structures that the regex engine
needs to handle specially during a clone or free operation on the compiled
product. Each element in the data array has a corresponding element in the
what array. During compilation regops that need special structures stored
will add an element to each array using the \fIadd_data()\fR routine and then store
the index in the regop.
.ie n .IP """program""" 5
.el .IP "\f(CWprogram\fR" 5
.IX Item "program"
Compiled program. Inlined into the structure so the entire struct can be
treated as a single blob.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlreapi
.PP
perlre
.PP
perlunitut
.SH "AUTHOR"
.IX Header "AUTHOR"
by Yves Orton, 2006.
.PP
With excerpts from Perl, and contributions and suggestions from
Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus,
Stephen McCamant, and David Landgren.
.SH "LICENCE"
.IX Header "LICENCE"
Same terms as Perl.
.SH "REFERENCES"
.IX Header "REFERENCES"
[1] <http://perl.plover.com/Rx/paper/>
.PP
[2] <http://www.unicode.org>
                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlrepository.1                             0100644 0001750 0001750 00000010615 12566207444 024047  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREPOSITORY 1"
.TH PERLREPOSITORY 1 "2013-12-21" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrepository \- Links to current information on the Perl source repository
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl's source code is stored in a Git repository.
.PP
See perlhack for an explanation of Perl development, including the
Super Quick Patch Guide for making and
submitting a small patch.
.PP
See perlgit for detailed information about Perl's Git repository.
.PP
(The above documents supersede the information that was formerly here in
perlrepository.)
                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlrepository5.18.1                         0100644 0001750 0001750 00000010615 12566207444 024363  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREPOSITORY 1"
.TH PERLREPOSITORY 1 "2013-12-21" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrepository \- Links to current information on the Perl source repository
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl's source code is stored in a Git repository.
.PP
See perlhack for an explanation of Perl development, including the
Super Quick Patch Guide for making and
submitting a small patch.
.PP
See perlgit for detailed information about Perl's Git repository.
.PP
(The above documents supersede the information that was formerly here in
perlrepository.)
                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlrequick.1                                0100644 0001750 0001750 00000062615 12566207444 023302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREQUICK 1"
.TH PERLREQUICK 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrequick \- Perl regular expressions quick start
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page covers the very basics of understanding, creating and
using regular expressions ('regexes') in Perl.
.SH "The Guide"
.IX Header "The Guide"
.SS "Simple word matching"
.IX Subsection "Simple word matching"
The simplest regex is simply a word, or more generally, a string of
characters.  A regex consisting of a word matches any string that
contains that word:
.PP
.Vb 1
\&    "Hello World" =~ /World/;  # matches
.Ve
.PP
In this statement, \f(CW\*(C`World\*(C'\fR is a regex and the \f(CW\*(C`//\*(C'\fR enclosing
\&\f(CW\*(C`/World/\*(C'\fR tells Perl to search a string for a match.  The operator
\&\f(CW\*(C`=~\*(C'\fR associates the string with the regex match and produces a true
value if the regex matched, or false if the regex did not match.  In
our case, \f(CW\*(C`World\*(C'\fR matches the second word in \f(CW"Hello World"\fR, so the
expression is true.  This idea has several variations.
.PP
Expressions like this are useful in conditionals:
.PP
.Vb 1
\&    print "It matches\en" if "Hello World" =~ /World/;
.Ve
.PP
The sense of the match can be reversed by using \f(CW\*(C`!~\*(C'\fR operator:
.PP
.Vb 1
\&    print "It doesn\*(Aqt match\en" if "Hello World" !~ /World/;
.Ve
.PP
The literal string in the regex can be replaced by a variable:
.PP
.Vb 2
\&    $greeting = "World";
\&    print "It matches\en" if "Hello World" =~ /$greeting/;
.Ve
.PP
If you're matching against \f(CW$_\fR, the \f(CW\*(C`$_ =~\*(C'\fR part can be omitted:
.PP
.Vb 2
\&    $_ = "Hello World";
\&    print "It matches\en" if /World/;
.Ve
.PP
Finally, the \f(CW\*(C`//\*(C'\fR default delimiters for a match can be changed to
arbitrary delimiters by putting an \f(CW\*(Aqm\*(Aq\fR out front:
.PP
.Vb 4
\&    "Hello World" =~ m!World!;   # matches, delimited by \*(Aq!\*(Aq
\&    "Hello World" =~ m{World};   # matches, note the matching \*(Aq{}\*(Aq
\&    "/usr/bin/perl" =~ m"/perl"; # matches after \*(Aq/usr/bin\*(Aq,
\&                                 # \*(Aq/\*(Aq becomes an ordinary char
.Ve
.PP
Regexes must match a part of the string \fIexactly\fR in order for the
statement to be true:
.PP
.Vb 3
\&    "Hello World" =~ /world/;  # doesn\*(Aqt match, case sensitive
\&    "Hello World" =~ /o W/;    # matches, \*(Aq \*(Aq is an ordinary char
\&    "Hello World" =~ /World /; # doesn\*(Aqt match, no \*(Aq \*(Aq at end
.Ve
.PP
Perl will always match at the earliest possible point in the string:
.PP
.Vb 2
\&    "Hello World" =~ /o/;       # matches \*(Aqo\*(Aq in \*(AqHello\*(Aq
\&    "That hat is red" =~ /hat/; # matches \*(Aqhat\*(Aq in \*(AqThat\*(Aq
.Ve
.PP
Not all characters can be used 'as is' in a match.  Some characters,
called \fBmetacharacters\fR, are reserved for use in regex notation.
The metacharacters are
.PP
.Vb 1
\&    {}[]()^$.|*+?\e
.Ve
.PP
A metacharacter can be matched by putting a backslash before it:
.PP
.Vb 4
\&    "2+2=4" =~ /2+2/;    # doesn\*(Aqt match, + is a metacharacter
\&    "2+2=4" =~ /2\e+2/;   # matches, \e+ is treated like an ordinary +
\&    \*(AqC:\eWIN32\*(Aq =~ /C:\e\eWIN/;                       # matches
\&    "/usr/bin/perl" =~ /\e/usr\e/bin\e/perl/;  # matches
.Ve
.PP
In the last regex, the forward slash \f(CW\*(Aq/\*(Aq\fR is also backslashed,
because it is used to delimit the regex.
.PP
Non-printable \s-1ASCII\s0 characters are represented by \fBescape sequences\fR.
Common examples are \f(CW\*(C`\et\*(C'\fR for a tab, \f(CW\*(C`\en\*(C'\fR for a newline, and \f(CW\*(C`\er\*(C'\fR
for a carriage return.  Arbitrary bytes are represented by octal
escape sequences, e.g., \f(CW\*(C`\e033\*(C'\fR, or hexadecimal escape sequences,
e.g., \f(CW\*(C`\ex1B\*(C'\fR:
.PP
.Vb 2
\&    "1000\et2000" =~ m(0\et2)      # matches
\&    "cat"      =~ /\e143\ex61\ex74/ # matches in ASCII, but a weird way to spell cat
.Ve
.PP
Regexes are treated mostly as double-quoted strings, so variable
substitution works:
.PP
.Vb 3
\&    $foo = \*(Aqhouse\*(Aq;
\&    \*(Aqcathouse\*(Aq =~ /cat$foo/;   # matches
\&    \*(Aqhousecat\*(Aq =~ /${foo}cat/; # matches
.Ve
.PP
With all of the regexes above, if the regex matched anywhere in the
string, it was considered a match.  To specify \fIwhere\fR it should
match, we would use the \fBanchor\fR metacharacters \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR.  The
anchor \f(CW\*(C`^\*(C'\fR means match at the beginning of the string and the anchor
\&\f(CW\*(C`$\*(C'\fR means match at the end of the string, or before a newline at the
end of the string.  Some examples:
.PP
.Vb 5
\&    "housekeeper" =~ /keeper/;         # matches
\&    "housekeeper" =~ /^keeper/;        # doesn\*(Aqt match
\&    "housekeeper" =~ /keeper$/;        # matches
\&    "housekeeper\en" =~ /keeper$/;      # matches
\&    "housekeeper" =~ /^housekeeper$/;  # matches
.Ve
.SS "Using character classes"
.IX Subsection "Using character classes"
A \fBcharacter class\fR allows a set of possible characters, rather than
just a single character, to match at a particular point in a regex.
Character classes are denoted by brackets \f(CW\*(C`[...]\*(C'\fR, with the set of
characters to be possibly matched inside.  Here are some examples:
.PP
.Vb 3
\&    /cat/;            # matches \*(Aqcat\*(Aq
\&    /[bcr]at/;        # matches \*(Aqbat\*(Aq, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&    "abc" =~ /[cab]/; # matches \*(Aqa\*(Aq
.Ve
.PP
In the last statement, even though \f(CW\*(Aqc\*(Aq\fR is the first character in
the class, the earliest point at which the regex can match is \f(CW\*(Aqa\*(Aq\fR.
.PP
.Vb 3
\&    /[yY][eE][sS]/; # match \*(Aqyes\*(Aq in a case\-insensitive way
\&                    # \*(Aqyes\*(Aq, \*(AqYes\*(Aq, \*(AqYES\*(Aq, etc.
\&    /yes/i;         # also match \*(Aqyes\*(Aq in a case\-insensitive way
.Ve
.PP
The last example shows a match with an \f(CW\*(Aqi\*(Aq\fR \fBmodifier\fR, which makes
the match case-insensitive.
.PP
Character classes also have ordinary and special characters, but the
sets of ordinary and special characters inside a character class are
different than those outside a character class.  The special
characters for a character class are \f(CW\*(C`\-]\e^$\*(C'\fR and are matched using an
escape:
.PP
.Vb 5
\&   /[\e]c]def/; # matches \*(Aq]def\*(Aq or \*(Aqcdef\*(Aq
\&   $x = \*(Aqbcr\*(Aq;
\&   /[$x]at/;   # matches \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&   /[\e$x]at/;  # matches \*(Aq$at\*(Aq or \*(Aqxat\*(Aq
\&   /[\e\e$x]at/; # matches \*(Aq\eat\*(Aq, \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
.Ve
.PP
The special character \f(CW\*(Aq\-\*(Aq\fR acts as a range operator within character
classes, so that the unwieldy \f(CW\*(C`[0123456789]\*(C'\fR and \f(CW\*(C`[abc...xyz]\*(C'\fR
become the svelte \f(CW\*(C`[0\-9]\*(C'\fR and \f(CW\*(C`[a\-z]\*(C'\fR:
.PP
.Vb 2
\&    /item[0\-9]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    /[0\-9a\-fA\-F]/;  # matches a hexadecimal digit
.Ve
.PP
If \f(CW\*(Aq\-\*(Aq\fR is the first or last character in a character class, it is
treated as an ordinary character.
.PP
The special character \f(CW\*(C`^\*(C'\fR in the first position of a character class
denotes a \fBnegated character class\fR, which matches any character but
those in the brackets.  Both \f(CW\*(C`[...]\*(C'\fR and \f(CW\*(C`[^...]\*(C'\fR must match a
character, or the match fails.  Then
.PP
.Vb 4
\&    /[^a]at/;  # doesn\*(Aqt match \*(Aqaat\*(Aq or \*(Aqat\*(Aq, but matches
\&               # all other \*(Aqbat\*(Aq, \*(Aqcat, \*(Aq0at\*(Aq, \*(Aq%at\*(Aq, etc.
\&    /[^0\-9]/;  # matches a non\-numeric character
\&    /[a^]at/;  # matches \*(Aqaat\*(Aq or \*(Aq^at\*(Aq; here \*(Aq^\*(Aq is ordinary
.Ve
.PP
Perl has several abbreviations for common character classes. (These
definitions are those that Perl uses in ASCII-safe mode with the \f(CW\*(C`/a\*(C'\fR modifier.
Otherwise they could match many more non-ASCII Unicode characters as
well.  See \*(L"Backslash sequences\*(R" in perlrecharclass for details.)
.IP "\(bu" 4
\&\ed is a digit and represents
.Sp
.Vb 1
\&    [0\-9]
.Ve
.IP "\(bu" 4
\&\es is a whitespace character and represents
.Sp
.Vb 1
\&    [\e \et\er\en\ef]
.Ve
.IP "\(bu" 4
\&\ew is a word character (alphanumeric or _) and represents
.Sp
.Vb 1
\&    [0\-9a\-zA\-Z_]
.Ve
.IP "\(bu" 4
\&\eD is a negated \ed; it represents any character but a digit
.Sp
.Vb 1
\&    [^0\-9]
.Ve
.IP "\(bu" 4
\&\eS is a negated \es; it represents any non-whitespace character
.Sp
.Vb 1
\&    [^\es]
.Ve
.IP "\(bu" 4
\&\eW is a negated \ew; it represents any non-word character
.Sp
.Vb 1
\&    [^\ew]
.Ve
.IP "\(bu" 4
The period '.' matches any character but \*(L"\en\*(R"
.PP
The \f(CW\*(C`\ed\es\ew\eD\eS\eW\*(C'\fR abbreviations can be used both inside and outside
of character classes.  Here are some in use:
.PP
.Vb 7
\&    /\ed\ed:\ed\ed:\ed\ed/; # matches a hh:mm:ss time format
\&    /[\ed\es]/;         # matches any digit or whitespace character
\&    /\ew\eW\ew/;         # matches a word char, followed by a
\&                      # non\-word char, followed by a word char
\&    /..rt/;           # matches any two chars, followed by \*(Aqrt\*(Aq
\&    /end\e./;          # matches \*(Aqend.\*(Aq
\&    /end[.]/;         # same thing, matches \*(Aqend.\*(Aq
.Ve
.PP
The \fBword\ anchor\fR\  \f(CW\*(C`\eb\*(C'\fR matches a boundary between a word
character and a non-word character \f(CW\*(C`\ew\eW\*(C'\fR or \f(CW\*(C`\eW\ew\*(C'\fR:
.PP
.Vb 4
\&    $x = "Housecat catenates house and cat";
\&    $x =~ /\ebcat/;  # matches cat in \*(Aqcatenates\*(Aq
\&    $x =~ /cat\eb/;  # matches cat in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq at end of string
.Ve
.PP
In the last example, the end of the string is considered a word
boundary.
.SS "Matching this or that"
.IX Subsection "Matching this or that"
We can match different character strings with the \fBalternation\fR
metacharacter \f(CW\*(Aq|\*(Aq\fR.  To match \f(CW\*(C`dog\*(C'\fR or \f(CW\*(C`cat\*(C'\fR, we form the regex
\&\f(CW\*(C`dog|cat\*(C'\fR.  As before, Perl will try to match the regex at the
earliest possible point in the string.  At each character position,
Perl will first try to match the first alternative, \f(CW\*(C`dog\*(C'\fR.  If
\&\f(CW\*(C`dog\*(C'\fR doesn't match, Perl will then try the next alternative, \f(CW\*(C`cat\*(C'\fR.
If \f(CW\*(C`cat\*(C'\fR doesn't match either, then the match fails and Perl moves to
the next position in the string.  Some examples:
.PP
.Vb 2
\&    "cats and dogs" =~ /cat|dog|bird/;  # matches "cat"
\&    "cats and dogs" =~ /dog|cat|bird/;  # matches "cat"
.Ve
.PP
Even though \f(CW\*(C`dog\*(C'\fR is the first alternative in the second regex,
\&\f(CW\*(C`cat\*(C'\fR is able to match earlier in the string.
.PP
.Vb 2
\&    "cats"          =~ /c|ca|cat|cats/; # matches "c"
\&    "cats"          =~ /cats|cat|ca|c/; # matches "cats"
.Ve
.PP
At a given character position, the first alternative that allows the
regex match to succeed will be the one that matches. Here, all the
alternatives match at the first string position, so the first matches.
.SS "Grouping things and hierarchical matching"
.IX Subsection "Grouping things and hierarchical matching"
The \fBgrouping\fR metacharacters \f(CW\*(C`()\*(C'\fR allow a part of a regex to be
treated as a single unit.  Parts of a regex are grouped by enclosing
them in parentheses.  The regex \f(CW\*(C`house(cat|keeper)\*(C'\fR means match
\&\f(CW\*(C`house\*(C'\fR followed by either \f(CW\*(C`cat\*(C'\fR or \f(CW\*(C`keeper\*(C'\fR.  Some more examples
are
.PP
.Vb 2
\&    /(a|b)b/;    # matches \*(Aqab\*(Aq or \*(Aqbb\*(Aq
\&    /(^a|b)c/;   # matches \*(Aqac\*(Aq at start of string or \*(Aqbc\*(Aq anywhere
\&
\&    /house(cat|)/;  # matches either \*(Aqhousecat\*(Aq or \*(Aqhouse\*(Aq
\&    /house(cat(s|)|)/;  # matches either \*(Aqhousecats\*(Aq or \*(Aqhousecat\*(Aq or
\&                        # \*(Aqhouse\*(Aq.  Note groups can be nested.
\&
\&    "20" =~ /(19|20|)\ed\ed/;  # matches the null alternative \*(Aq()\ed\ed\*(Aq,
\&                             # because \*(Aq20\ed\ed\*(Aq can\*(Aqt match
.Ve
.SS "Extracting matches"
.IX Subsection "Extracting matches"
The grouping metacharacters \f(CW\*(C`()\*(C'\fR also allow the extraction of the
parts of a string that matched.  For each grouping, the part that
matched inside goes into the special variables \f(CW$1\fR, \f(CW$2\fR, etc.
They can be used just as ordinary variables:
.PP
.Vb 5
\&    # extract hours, minutes, seconds
\&    $time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/;  # match hh:mm:ss format
\&    $hours = $1;
\&    $minutes = $2;
\&    $seconds = $3;
.Ve
.PP
In list context, a match \f(CW\*(C`/regex/\*(C'\fR with groupings will return the
list of matched values \f(CW\*(C`($1,$2,...)\*(C'\fR.  So we could rewrite it as
.PP
.Vb 1
\&    ($hours, $minutes, $second) = ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/);
.Ve
.PP
If the groupings in a regex are nested, \f(CW$1\fR gets the group with the
leftmost opening parenthesis, \f(CW$2\fR the next opening parenthesis,
etc.  For example, here is a complex regex and the matching variables
indicated below it:
.PP
.Vb 2
\&    /(ab(cd|ef)((gi)|j))/;
\&     1  2      34
.Ve
.PP
Associated with the matching variables \f(CW$1\fR, \f(CW$2\fR, ... are
the \fBbackreferences\fR \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR, ...  Backreferences are
matching variables that can be used \fIinside\fR a regex:
.PP
.Vb 1
\&    /(\ew\ew\ew)\es\eg1/; # find sequences like \*(Aqthe the\*(Aq in string
.Ve
.PP
\&\f(CW$1\fR, \f(CW$2\fR, ... should only be used outside of a regex, and \f(CW\*(C`\eg1\*(C'\fR,
\&\f(CW\*(C`\eg2\*(C'\fR, ... only inside a regex.
.SS "Matching repetitions"
.IX Subsection "Matching repetitions"
The \fBquantifier\fR metacharacters \f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR, and \f(CW\*(C`{}\*(C'\fR allow us
to determine the number of repeats of a portion of a regex we
consider to be a match.  Quantifiers are put immediately after the
character, character class, or grouping that we want to specify.  They
have the following meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a?\*(C'\fR = match 'a' 1 or 0 times
.IP "\(bu" 4
\&\f(CW\*(C`a*\*(C'\fR = match 'a' 0 or more times, i.e., any number of times
.IP "\(bu" 4
\&\f(CW\*(C`a+\*(C'\fR = match 'a' 1 or more times, i.e., at least once
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}\*(C'\fR = match at least \f(CW\*(C`n\*(C'\fR times, but not more than \f(CW\*(C`m\*(C'\fR
times.
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}\*(C'\fR = match at least \f(CW\*(C`n\*(C'\fR or more times
.IP "\(bu" 4
\&\f(CW\*(C`a{n}\*(C'\fR = match exactly \f(CW\*(C`n\*(C'\fR times
.PP
Here are some examples:
.PP
.Vb 6
\&    /[a\-z]+\es+\ed*/;  # match a lowercase word, at least some space, and
\&                     # any number of digits
\&    /(\ew+)\es+\eg1/;    # match doubled words of arbitrary length
\&    $year =~ /^\ed{2,4}$/;  # make sure year is at least 2 but not more
\&                           # than 4 digits
\&    $year =~ /^\ed{4}$|^\ed{2}$/;    # better match; throw out 3 digit dates
.Ve
.PP
These quantifiers will try to match as much of the string as possible,
while still allowing the regex to match.  So we have
.PP
.Vb 5
\&    $x = \*(Aqthe cat in the hat\*(Aq;
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe cat in the h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 matches)
.Ve
.PP
The first quantifier \f(CW\*(C`.*\*(C'\fR grabs as much of the string as possible
while still having the regex match. The second quantifier \f(CW\*(C`.*\*(C'\fR has
no string left to it, so it matches 0 times.
.SS "More matching"
.IX Subsection "More matching"
There are a few more things you might want to know about matching
operators.
The global modifier \f(CW\*(C`//g\*(C'\fR allows the matching operator to match
within a string as many times as possible.  In scalar context,
successive matches against a string will have \f(CW\*(C`//g\*(C'\fR jump from match
to match, keeping track of position in the string as it goes along.
You can get or set the position with the \f(CW\*(C`pos()\*(C'\fR function.
For example,
.PP
.Vb 4
\&    $x = "cat dog house"; # 3 words
\&    while ($x =~ /(\ew+)/g) {
\&        print "Word is $1, ends at position ", pos $x, "\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 3
\&    Word is cat, ends at position 3
\&    Word is dog, ends at position 7
\&    Word is house, ends at position 13
.Ve
.PP
A failed match or changing the target string resets the position.  If
you don't want the position reset after failure to match, add the
\&\f(CW\*(C`//c\*(C'\fR, as in \f(CW\*(C`/regex/gc\*(C'\fR.
.PP
In list context, \f(CW\*(C`//g\*(C'\fR returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole regex.  So
.PP
.Vb 4
\&    @words = ($x =~ /(\ew+)/g);  # matches,
\&                                # $word[0] = \*(Aqcat\*(Aq
\&                                # $word[1] = \*(Aqdog\*(Aq
\&                                # $word[2] = \*(Aqhouse\*(Aq
.Ve
.SS "Search and replace"
.IX Subsection "Search and replace"
Search and replace is performed using \f(CW\*(C`s/regex/replacement/modifiers\*(C'\fR.
The \f(CW\*(C`replacement\*(C'\fR is a Perl double-quoted string that replaces in the
string whatever is matched with the \f(CW\*(C`regex\*(C'\fR.  The operator \f(CW\*(C`=~\*(C'\fR is
also used here to associate a string with \f(CW\*(C`s///\*(C'\fR.  If matching
against \f(CW$_\fR, the \f(CW\*(C`$_\ =~\*(C'\fR can be dropped.  If there is a match,
\&\f(CW\*(C`s///\*(C'\fR returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:
.PP
.Vb 5
\&    $x = "Time to feed the cat!";
\&    $x =~ s/cat/hacker/;   # $x contains "Time to feed the hacker!"
\&    $y = "\*(Aqquoted words\*(Aq";
\&    $y =~ s/^\*(Aq(.*)\*(Aq$/$1/;  # strip single quotes,
\&                           # $y contains "quoted words"
.Ve
.PP
With the \f(CW\*(C`s///\*(C'\fR operator, the matched variables \f(CW$1\fR, \f(CW$2\fR, etc.
are immediately available for use in the replacement expression. With
the global modifier, \f(CW\*(C`s///g\*(C'\fR will search and replace all occurrences
of the regex in the string:
.PP
.Vb 4
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/;   # $x contains "I batted four for 4"
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/g;  # $x contains "I batted four for four"
.Ve
.PP
The non-destructive modifier \f(CW\*(C`s///r\*(C'\fR causes the result of the substitution
to be returned instead of modifying \f(CW$_\fR (or whatever variable the
substitute was bound to with \f(CW\*(C`=~\*(C'\fR):
.PP
.Vb 3
\&    $x = "I like dogs.";
\&    $y = $x =~ s/dogs/cats/r;
\&    print "$x $y\en"; # prints "I like dogs. I like cats."
\&
\&    $x = "Cats are great.";
\&    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, "\en";
\&    # prints "Hedgehogs are great."
\&
\&    @foo = map { s/[a\-z]/X/r } qw(a b c 1 2 3);
\&    # @foo is now qw(X X X 1 2 3)
.Ve
.PP
The evaluation modifier \f(CW\*(C`s///e\*(C'\fR wraps an \f(CW\*(C`eval{...}\*(C'\fR around the
replacement string and the evaluated result is substituted for the
matched substring.  Some examples:
.PP
.Vb 3
\&    # reverse all the words in a string
\&    $x = "the cat in the hat";
\&    $x =~ s/(\ew+)/reverse $1/ge;   # $x contains "eht tac ni eht tah"
\&
\&    # convert percentage to decimal
\&    $x = "A 39% hit rate";
\&    $x =~ s!(\ed+)%!$1/100!e;       # $x contains "A 0.39 hit rate"
.Ve
.PP
The last example shows that \f(CW\*(C`s///\*(C'\fR can use other delimiters, such as
\&\f(CW\*(C`s!!!\*(C'\fR and \f(CW\*(C`s{}{}\*(C'\fR, and even \f(CW\*(C`s{}//\*(C'\fR.  If single quotes are used
\&\f(CW\*(C`s\*(Aq\*(Aq\*(Aq\*(C'\fR, then the regex and replacement are treated as single-quoted
strings.
.SS "The split operator"
.IX Subsection "The split operator"
\&\f(CW\*(C`split /regex/, string\*(C'\fR splits \f(CW\*(C`string\*(C'\fR into a list of substrings
and returns that list.  The regex determines the character sequence
that \f(CW\*(C`string\*(C'\fR is split with respect to.  For example, to split a
string into words, use
.PP
.Vb 4
\&    $x = "Calvin and Hobbes";
\&    @word = split /\es+/, $x;  # $word[0] = \*(AqCalvin\*(Aq
\&                              # $word[1] = \*(Aqand\*(Aq
\&                              # $word[2] = \*(AqHobbes\*(Aq
.Ve
.PP
To extract a comma-delimited list of numbers, use
.PP
.Vb 4
\&    $x = "1.618,2.718,   3.142";
\&    @const = split /,\es*/, $x;  # $const[0] = \*(Aq1.618\*(Aq
\&                                # $const[1] = \*(Aq2.718\*(Aq
\&                                # $const[2] = \*(Aq3.142\*(Aq
.Ve
.PP
If the empty regex \f(CW\*(C`//\*(C'\fR is used, the string is split into individual
characters.  If the regex has groupings, then the list produced contains
the matched substrings from the groupings as well:
.PP
.Vb 6
\&    $x = "/usr/bin";
\&    @parts = split m!(/)!, $x;  # $parts[0] = \*(Aq\*(Aq
\&                                # $parts[1] = \*(Aq/\*(Aq
\&                                # $parts[2] = \*(Aqusr\*(Aq
\&                                # $parts[3] = \*(Aq/\*(Aq
\&                                # $parts[4] = \*(Aqbin\*(Aq
.Ve
.PP
Since the first character of \f(CW$x\fR matched the regex, \f(CW\*(C`split\*(C'\fR prepended
an empty initial element to the list.
.SH "BUGS"
.IX Header "BUGS"
None.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This is just a quick start guide.  For a more in-depth tutorial on
regexes, see perlretut and for the reference page, see perlre.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 2000 Mark Kvale
All rights reserved.
.PP
This document may be distributed under the same terms as Perl itself.
.SS "Acknowledgments"
.IX Subsection "Acknowledgments"
The author would like to thank Mark-Jason Dominus, Tom Christiansen,
Ilya Zakharevich, Brad Hughes, and Mike Giroux for all their helpful
comments.
                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlrequick5.16.1                            0100644 0001750 0001750 00000062274 12566207423 023612  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREQUICK 1"
.TH PERLREQUICK 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrequick \- Perl regular expressions quick start
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page covers the very basics of understanding, creating and
using regular expressions ('regexes') in Perl.
.SH "The Guide"
.IX Header "The Guide"
.SS "Simple word matching"
.IX Subsection "Simple word matching"
The simplest regex is simply a word, or more generally, a string of
characters.  A regex consisting of a word matches any string that
contains that word:
.PP
.Vb 1
\&    "Hello World" =~ /World/;  # matches
.Ve
.PP
In this statement, \f(CW\*(C`World\*(C'\fR is a regex and the \f(CW\*(C`//\*(C'\fR enclosing
\&\f(CW\*(C`/World/\*(C'\fR tells Perl to search a string for a match.  The operator
\&\f(CW\*(C`=~\*(C'\fR associates the string with the regex match and produces a true
value if the regex matched, or false if the regex did not match.  In
our case, \f(CW\*(C`World\*(C'\fR matches the second word in \f(CW"Hello World"\fR, so the
expression is true.  This idea has several variations.
.PP
Expressions like this are useful in conditionals:
.PP
.Vb 1
\&    print "It matches\en" if "Hello World" =~ /World/;
.Ve
.PP
The sense of the match can be reversed by using \f(CW\*(C`!~\*(C'\fR operator:
.PP
.Vb 1
\&    print "It doesn\*(Aqt match\en" if "Hello World" !~ /World/;
.Ve
.PP
The literal string in the regex can be replaced by a variable:
.PP
.Vb 2
\&    $greeting = "World";
\&    print "It matches\en" if "Hello World" =~ /$greeting/;
.Ve
.PP
If you're matching against \f(CW$_\fR, the \f(CW\*(C`$_ =~\*(C'\fR part can be omitted:
.PP
.Vb 2
\&    $_ = "Hello World";
\&    print "It matches\en" if /World/;
.Ve
.PP
Finally, the \f(CW\*(C`//\*(C'\fR default delimiters for a match can be changed to
arbitrary delimiters by putting an \f(CW\*(Aqm\*(Aq\fR out front:
.PP
.Vb 4
\&    "Hello World" =~ m!World!;   # matches, delimited by \*(Aq!\*(Aq
\&    "Hello World" =~ m{World};   # matches, note the matching \*(Aq{}\*(Aq
\&    "/usr/bin/perl" =~ m"/perl"; # matches after \*(Aq/usr/bin\*(Aq,
\&                                 # \*(Aq/\*(Aq becomes an ordinary char
.Ve
.PP
Regexes must match a part of the string \fIexactly\fR in order for the
statement to be true:
.PP
.Vb 3
\&    "Hello World" =~ /world/;  # doesn\*(Aqt match, case sensitive
\&    "Hello World" =~ /o W/;    # matches, \*(Aq \*(Aq is an ordinary char
\&    "Hello World" =~ /World /; # doesn\*(Aqt match, no \*(Aq \*(Aq at end
.Ve
.PP
Perl will always match at the earliest possible point in the string:
.PP
.Vb 2
\&    "Hello World" =~ /o/;       # matches \*(Aqo\*(Aq in \*(AqHello\*(Aq
\&    "That hat is red" =~ /hat/; # matches \*(Aqhat\*(Aq in \*(AqThat\*(Aq
.Ve
.PP
Not all characters can be used 'as is' in a match.  Some characters,
called \fBmetacharacters\fR, are reserved for use in regex notation.
The metacharacters are
.PP
.Vb 1
\&    {}[]()^$.|*+?\e
.Ve
.PP
A metacharacter can be matched by putting a backslash before it:
.PP
.Vb 4
\&    "2+2=4" =~ /2+2/;    # doesn\*(Aqt match, + is a metacharacter
\&    "2+2=4" =~ /2\e+2/;   # matches, \e+ is treated like an ordinary +
\&    \*(AqC:\eWIN32\*(Aq =~ /C:\e\eWIN/;                       # matches
\&    "/usr/bin/perl" =~ /\e/usr\e/bin\e/perl/;  # matches
.Ve
.PP
In the last regex, the forward slash \f(CW\*(Aq/\*(Aq\fR is also backslashed,
because it is used to delimit the regex.
.PP
Non-printable \s-1ASCII\s0 characters are represented by \fBescape sequences\fR.
Common examples are \f(CW\*(C`\et\*(C'\fR for a tab, \f(CW\*(C`\en\*(C'\fR for a newline, and \f(CW\*(C`\er\*(C'\fR
for a carriage return.  Arbitrary bytes are represented by octal
escape sequences, e.g., \f(CW\*(C`\e033\*(C'\fR, or hexadecimal escape sequences,
e.g., \f(CW\*(C`\ex1B\*(C'\fR:
.PP
.Vb 2
\&    "1000\et2000" =~ m(0\et2)      # matches
\&    "cat"      =~ /\e143\ex61\ex74/ # matches in ASCII, but a weird way to spell cat
.Ve
.PP
Regexes are treated mostly as double-quoted strings, so variable
substitution works:
.PP
.Vb 3
\&    $foo = \*(Aqhouse\*(Aq;
\&    \*(Aqcathouse\*(Aq =~ /cat$foo/;   # matches
\&    \*(Aqhousecat\*(Aq =~ /${foo}cat/; # matches
.Ve
.PP
With all of the regexes above, if the regex matched anywhere in the
string, it was considered a match.  To specify \fIwhere\fR it should
match, we would use the \fBanchor\fR metacharacters \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR.  The
anchor \f(CW\*(C`^\*(C'\fR means match at the beginning of the string and the anchor
\&\f(CW\*(C`$\*(C'\fR means match at the end of the string, or before a newline at the
end of the string.  Some examples:
.PP
.Vb 5
\&    "housekeeper" =~ /keeper/;         # matches
\&    "housekeeper" =~ /^keeper/;        # doesn\*(Aqt match
\&    "housekeeper" =~ /keeper$/;        # matches
\&    "housekeeper\en" =~ /keeper$/;      # matches
\&    "housekeeper" =~ /^housekeeper$/;  # matches
.Ve
.SS "Using character classes"
.IX Subsection "Using character classes"
A \fBcharacter class\fR allows a set of possible characters, rather than
just a single character, to match at a particular point in a regex.
Character classes are denoted by brackets \f(CW\*(C`[...]\*(C'\fR, with the set of
characters to be possibly matched inside.  Here are some examples:
.PP
.Vb 3
\&    /cat/;            # matches \*(Aqcat\*(Aq
\&    /[bcr]at/;        # matches \*(Aqbat\*(Aq, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&    "abc" =~ /[cab]/; # matches \*(Aqa\*(Aq
.Ve
.PP
In the last statement, even though \f(CW\*(Aqc\*(Aq\fR is the first character in
the class, the earliest point at which the regex can match is \f(CW\*(Aqa\*(Aq\fR.
.PP
.Vb 3
\&    /[yY][eE][sS]/; # match \*(Aqyes\*(Aq in a case\-insensitive way
\&                    # \*(Aqyes\*(Aq, \*(AqYes\*(Aq, \*(AqYES\*(Aq, etc.
\&    /yes/i;         # also match \*(Aqyes\*(Aq in a case\-insensitive way
.Ve
.PP
The last example shows a match with an \f(CW\*(Aqi\*(Aq\fR \fBmodifier\fR, which makes
the match case-insensitive.
.PP
Character classes also have ordinary and special characters, but the
sets of ordinary and special characters inside a character class are
different than those outside a character class.  The special
characters for a character class are \f(CW\*(C`\-]\e^$\*(C'\fR and are matched using an
escape:
.PP
.Vb 5
\&   /[\e]c]def/; # matches \*(Aq]def\*(Aq or \*(Aqcdef\*(Aq
\&   $x = \*(Aqbcr\*(Aq;
\&   /[$x]at/;   # matches \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&   /[\e$x]at/;  # matches \*(Aq$at\*(Aq or \*(Aqxat\*(Aq
\&   /[\e\e$x]at/; # matches \*(Aq\eat\*(Aq, \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
.Ve
.PP
The special character \f(CW\*(Aq\-\*(Aq\fR acts as a range operator within character
classes, so that the unwieldy \f(CW\*(C`[0123456789]\*(C'\fR and \f(CW\*(C`[abc...xyz]\*(C'\fR
become the svelte \f(CW\*(C`[0\-9]\*(C'\fR and \f(CW\*(C`[a\-z]\*(C'\fR:
.PP
.Vb 2
\&    /item[0\-9]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    /[0\-9a\-fA\-F]/;  # matches a hexadecimal digit
.Ve
.PP
If \f(CW\*(Aq\-\*(Aq\fR is the first or last character in a character class, it is
treated as an ordinary character.
.PP
The special character \f(CW\*(C`^\*(C'\fR in the first position of a character class
denotes a \fBnegated character class\fR, which matches any character but
those in the brackets.  Both \f(CW\*(C`[...]\*(C'\fR and \f(CW\*(C`[^...]\*(C'\fR must match a
character, or the match fails.  Then
.PP
.Vb 4
\&    /[^a]at/;  # doesn\*(Aqt match \*(Aqaat\*(Aq or \*(Aqat\*(Aq, but matches
\&               # all other \*(Aqbat\*(Aq, \*(Aqcat, \*(Aq0at\*(Aq, \*(Aq%at\*(Aq, etc.
\&    /[^0\-9]/;  # matches a non\-numeric character
\&    /[a^]at/;  # matches \*(Aqaat\*(Aq or \*(Aq^at\*(Aq; here \*(Aq^\*(Aq is ordinary
.Ve
.PP
Perl has several abbreviations for common character classes. (These
definitions are those that Perl uses in ASCII-safe mode with the \f(CW\*(C`/a\*(C'\fR modifier.
Otherwise they could match many more non-ASCII Unicode characters as
well.  See \*(L"Backslash sequences\*(R" in perlrecharclass for details.)
.IP "\(bu" 4
\&\ed is a digit and represents
.Sp
.Vb 1
\&    [0\-9]
.Ve
.IP "\(bu" 4
\&\es is a whitespace character and represents
.Sp
.Vb 1
\&    [\e \et\er\en\ef]
.Ve
.IP "\(bu" 4
\&\ew is a word character (alphanumeric or _) and represents
.Sp
.Vb 1
\&    [0\-9a\-zA\-Z_]
.Ve
.IP "\(bu" 4
\&\eD is a negated \ed; it represents any character but a digit
.Sp
.Vb 1
\&    [^0\-9]
.Ve
.IP "\(bu" 4
\&\eS is a negated \es; it represents any non-whitespace character
.Sp
.Vb 1
\&    [^\es]
.Ve
.IP "\(bu" 4
\&\eW is a negated \ew; it represents any non-word character
.Sp
.Vb 1
\&    [^\ew]
.Ve
.IP "\(bu" 4
The period '.' matches any character but \*(L"\en\*(R"
.PP
The \f(CW\*(C`\ed\es\ew\eD\eS\eW\*(C'\fR abbreviations can be used both inside and outside
of character classes.  Here are some in use:
.PP
.Vb 7
\&    /\ed\ed:\ed\ed:\ed\ed/; # matches a hh:mm:ss time format
\&    /[\ed\es]/;         # matches any digit or whitespace character
\&    /\ew\eW\ew/;         # matches a word char, followed by a
\&                      # non\-word char, followed by a word char
\&    /..rt/;           # matches any two chars, followed by \*(Aqrt\*(Aq
\&    /end\e./;          # matches \*(Aqend.\*(Aq
\&    /end[.]/;         # same thing, matches \*(Aqend.\*(Aq
.Ve
.PP
The \fBword\ anchor\fR\  \f(CW\*(C`\eb\*(C'\fR matches a boundary between a word
character and a non-word character \f(CW\*(C`\ew\eW\*(C'\fR or \f(CW\*(C`\eW\ew\*(C'\fR:
.PP
.Vb 4
\&    $x = "Housecat catenates house and cat";
\&    $x =~ /\ebcat/;  # matches cat in \*(Aqcatenates\*(Aq
\&    $x =~ /cat\eb/;  # matches cat in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq at end of string
.Ve
.PP
In the last example, the end of the string is considered a word
boundary.
.SS "Matching this or that"
.IX Subsection "Matching this or that"
We can match different character strings with the \fBalternation\fR
metacharacter \f(CW\*(Aq|\*(Aq\fR.  To match \f(CW\*(C`dog\*(C'\fR or \f(CW\*(C`cat\*(C'\fR, we form the regex
\&\f(CW\*(C`dog|cat\*(C'\fR.  As before, Perl will try to match the regex at the
earliest possible point in the string.  At each character position,
Perl will first try to match the first alternative, \f(CW\*(C`dog\*(C'\fR.  If
\&\f(CW\*(C`dog\*(C'\fR doesn't match, Perl will then try the next alternative, \f(CW\*(C`cat\*(C'\fR.
If \f(CW\*(C`cat\*(C'\fR doesn't match either, then the match fails and Perl moves to
the next position in the string.  Some examples:
.PP
.Vb 2
\&    "cats and dogs" =~ /cat|dog|bird/;  # matches "cat"
\&    "cats and dogs" =~ /dog|cat|bird/;  # matches "cat"
.Ve
.PP
Even though \f(CW\*(C`dog\*(C'\fR is the first alternative in the second regex,
\&\f(CW\*(C`cat\*(C'\fR is able to match earlier in the string.
.PP
.Vb 2
\&    "cats"          =~ /c|ca|cat|cats/; # matches "c"
\&    "cats"          =~ /cats|cat|ca|c/; # matches "cats"
.Ve
.PP
At a given character position, the first alternative that allows the
regex match to succeed will be the one that matches. Here, all the
alternatives match at the first string position, so the first matches.
.SS "Grouping things and hierarchical matching"
.IX Subsection "Grouping things and hierarchical matching"
The \fBgrouping\fR metacharacters \f(CW\*(C`()\*(C'\fR allow a part of a regex to be
treated as a single unit.  Parts of a regex are grouped by enclosing
them in parentheses.  The regex \f(CW\*(C`house(cat|keeper)\*(C'\fR means match
\&\f(CW\*(C`house\*(C'\fR followed by either \f(CW\*(C`cat\*(C'\fR or \f(CW\*(C`keeper\*(C'\fR.  Some more examples
are
.PP
.Vb 2
\&    /(a|b)b/;    # matches \*(Aqab\*(Aq or \*(Aqbb\*(Aq
\&    /(^a|b)c/;   # matches \*(Aqac\*(Aq at start of string or \*(Aqbc\*(Aq anywhere
\&
\&    /house(cat|)/;  # matches either \*(Aqhousecat\*(Aq or \*(Aqhouse\*(Aq
\&    /house(cat(s|)|)/;  # matches either \*(Aqhousecats\*(Aq or \*(Aqhousecat\*(Aq or
\&                        # \*(Aqhouse\*(Aq.  Note groups can be nested.
\&
\&    "20" =~ /(19|20|)\ed\ed/;  # matches the null alternative \*(Aq()\ed\ed\*(Aq,
\&                             # because \*(Aq20\ed\ed\*(Aq can\*(Aqt match
.Ve
.SS "Extracting matches"
.IX Subsection "Extracting matches"
The grouping metacharacters \f(CW\*(C`()\*(C'\fR also allow the extraction of the
parts of a string that matched.  For each grouping, the part that
matched inside goes into the special variables \f(CW$1\fR, \f(CW$2\fR, etc.
They can be used just as ordinary variables:
.PP
.Vb 5
\&    # extract hours, minutes, seconds
\&    $time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/;  # match hh:mm:ss format
\&    $hours = $1;
\&    $minutes = $2;
\&    $seconds = $3;
.Ve
.PP
In list context, a match \f(CW\*(C`/regex/\*(C'\fR with groupings will return the
list of matched values \f(CW\*(C`($1,$2,...)\*(C'\fR.  So we could rewrite it as
.PP
.Vb 1
\&    ($hours, $minutes, $second) = ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/);
.Ve
.PP
If the groupings in a regex are nested, \f(CW$1\fR gets the group with the
leftmost opening parenthesis, \f(CW$2\fR the next opening parenthesis,
etc.  For example, here is a complex regex and the matching variables
indicated below it:
.PP
.Vb 2
\&    /(ab(cd|ef)((gi)|j))/;
\&     1  2      34
.Ve
.PP
Associated with the matching variables \f(CW$1\fR, \f(CW$2\fR, ... are
the \fBbackreferences\fR \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR, ...  Backreferences are
matching variables that can be used \fIinside\fR a regex:
.PP
.Vb 1
\&    /(\ew\ew\ew)\es\eg1/; # find sequences like \*(Aqthe the\*(Aq in string
.Ve
.PP
\&\f(CW$1\fR, \f(CW$2\fR, ... should only be used outside of a regex, and \f(CW\*(C`\eg1\*(C'\fR,
\&\f(CW\*(C`\eg2\*(C'\fR, ... only inside a regex.
.SS "Matching repetitions"
.IX Subsection "Matching repetitions"
The \fBquantifier\fR metacharacters \f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR, and \f(CW\*(C`{}\*(C'\fR allow us
to determine the number of repeats of a portion of a regex we
consider to be a match.  Quantifiers are put immediately after the
character, character class, or grouping that we want to specify.  They
have the following meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a?\*(C'\fR = match 'a' 1 or 0 times
.IP "\(bu" 4
\&\f(CW\*(C`a*\*(C'\fR = match 'a' 0 or more times, i.e., any number of times
.IP "\(bu" 4
\&\f(CW\*(C`a+\*(C'\fR = match 'a' 1 or more times, i.e., at least once
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}\*(C'\fR = match at least \f(CW\*(C`n\*(C'\fR times, but not more than \f(CW\*(C`m\*(C'\fR
times.
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}\*(C'\fR = match at least \f(CW\*(C`n\*(C'\fR or more times
.IP "\(bu" 4
\&\f(CW\*(C`a{n}\*(C'\fR = match exactly \f(CW\*(C`n\*(C'\fR times
.PP
Here are some examples:
.PP
.Vb 6
\&    /[a\-z]+\es+\ed*/;  # match a lowercase word, at least some space, and
\&                     # any number of digits
\&    /(\ew+)\es+\eg1/;    # match doubled words of arbitrary length
\&    $year =~ /^\ed{2,4}$/;  # make sure year is at least 2 but not more
\&                           # than 4 digits
\&    $year =~ /^\ed{4}$|^\ed{2}$/;    # better match; throw out 3 digit dates
.Ve
.PP
These quantifiers will try to match as much of the string as possible,
while still allowing the regex to match.  So we have
.PP
.Vb 5
\&    $x = \*(Aqthe cat in the hat\*(Aq;
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe cat in the h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 matches)
.Ve
.PP
The first quantifier \f(CW\*(C`.*\*(C'\fR grabs as much of the string as possible
while still having the regex match. The second quantifier \f(CW\*(C`.*\*(C'\fR has
no string left to it, so it matches 0 times.
.SS "More matching"
.IX Subsection "More matching"
There are a few more things you might want to know about matching
operators.
The global modifier \f(CW\*(C`//g\*(C'\fR allows the matching operator to match
within a string as many times as possible.  In scalar context,
successive matches against a string will have \f(CW\*(C`//g\*(C'\fR jump from match
to match, keeping track of position in the string as it goes along.
You can get or set the position with the \f(CW\*(C`pos()\*(C'\fR function.
For example,
.PP
.Vb 4
\&    $x = "cat dog house"; # 3 words
\&    while ($x =~ /(\ew+)/g) {
\&        print "Word is $1, ends at position ", pos $x, "\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 3
\&    Word is cat, ends at position 3
\&    Word is dog, ends at position 7
\&    Word is house, ends at position 13
.Ve
.PP
A failed match or changing the target string resets the position.  If
you don't want the position reset after failure to match, add the
\&\f(CW\*(C`//c\*(C'\fR, as in \f(CW\*(C`/regex/gc\*(C'\fR.
.PP
In list context, \f(CW\*(C`//g\*(C'\fR returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole regex.  So
.PP
.Vb 4
\&    @words = ($x =~ /(\ew+)/g);  # matches,
\&                                # $word[0] = \*(Aqcat\*(Aq
\&                                # $word[1] = \*(Aqdog\*(Aq
\&                                # $word[2] = \*(Aqhouse\*(Aq
.Ve
.SS "Search and replace"
.IX Subsection "Search and replace"
Search and replace is performed using \f(CW\*(C`s/regex/replacement/modifiers\*(C'\fR.
The \f(CW\*(C`replacement\*(C'\fR is a Perl double-quoted string that replaces in the
string whatever is matched with the \f(CW\*(C`regex\*(C'\fR.  The operator \f(CW\*(C`=~\*(C'\fR is
also used here to associate a string with \f(CW\*(C`s///\*(C'\fR.  If matching
against \f(CW$_\fR, the \f(CW\*(C`$_\ =~\*(C'\fR can be dropped.  If there is a match,
\&\f(CW\*(C`s///\*(C'\fR returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:
.PP
.Vb 5
\&    $x = "Time to feed the cat!";
\&    $x =~ s/cat/hacker/;   # $x contains "Time to feed the hacker!"
\&    $y = "\*(Aqquoted words\*(Aq";
\&    $y =~ s/^\*(Aq(.*)\*(Aq$/$1/;  # strip single quotes,
\&                           # $y contains "quoted words"
.Ve
.PP
With the \f(CW\*(C`s///\*(C'\fR operator, the matched variables \f(CW$1\fR, \f(CW$2\fR, etc.
are immediately available for use in the replacement expression. With
the global modifier, \f(CW\*(C`s///g\*(C'\fR will search and replace all occurrences
of the regex in the string:
.PP
.Vb 4
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/;   # $x contains "I batted four for 4"
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/g;  # $x contains "I batted four for four"
.Ve
.PP
The non-destructive modifier \f(CW\*(C`s///r\*(C'\fR causes the result of the substitution
to be returned instead of modifying \f(CW$_\fR (or whatever variable the
substitute was bound to with \f(CW\*(C`=~\*(C'\fR):
.PP
.Vb 3
\&    $x = "I like dogs.";
\&    $y = $x =~ s/dogs/cats/r;
\&    print "$x $y\en"; # prints "I like dogs. I like cats."
\&
\&    $x = "Cats are great.";
\&    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, "\en";
\&    # prints "Hedgehogs are great."
\&
\&    @foo = map { s/[a\-z]/X/r } qw(a b c 1 2 3);
\&    # @foo is now qw(X X X 1 2 3)
.Ve
.PP
The evaluation modifier \f(CW\*(C`s///e\*(C'\fR wraps an \f(CW\*(C`eval{...}\*(C'\fR around the
replacement string and the evaluated result is substituted for the
matched substring.  Some examples:
.PP
.Vb 3
\&    # reverse all the words in a string
\&    $x = "the cat in the hat";
\&    $x =~ s/(\ew+)/reverse $1/ge;   # $x contains "eht tac ni eht tah"
\&
\&    # convert percentage to decimal
\&    $x = "A 39% hit rate";
\&    $x =~ s!(\ed+)%!$1/100!e;       # $x contains "A 0.39 hit rate"
.Ve
.PP
The last example shows that \f(CW\*(C`s///\*(C'\fR can use other delimiters, such as
\&\f(CW\*(C`s!!!\*(C'\fR and \f(CW\*(C`s{}{}\*(C'\fR, and even \f(CW\*(C`s{}//\*(C'\fR.  If single quotes are used
\&\f(CW\*(C`s\*(Aq\*(Aq\*(Aq\*(C'\fR, then the regex and replacement are treated as single-quoted
strings.
.SS "The split operator"
.IX Subsection "The split operator"
\&\f(CW\*(C`split /regex/, string\*(C'\fR splits \f(CW\*(C`string\*(C'\fR into a list of substrings
and returns that list.  The regex determines the character sequence
that \f(CW\*(C`string\*(C'\fR is split with respect to.  For example, to split a
string into words, use
.PP
.Vb 4
\&    $x = "Calvin and Hobbes";
\&    @word = split /\es+/, $x;  # $word[0] = \*(AqCalvin\*(Aq
\&                              # $word[1] = \*(Aqand\*(Aq
\&                              # $word[2] = \*(AqHobbes\*(Aq
.Ve
.PP
To extract a comma-delimited list of numbers, use
.PP
.Vb 4
\&    $x = "1.618,2.718,   3.142";
\&    @const = split /,\es*/, $x;  # $const[0] = \*(Aq1.618\*(Aq
\&                                # $const[1] = \*(Aq2.718\*(Aq
\&                                # $const[2] = \*(Aq3.142\*(Aq
.Ve
.PP
If the empty regex \f(CW\*(C`//\*(C'\fR is used, the string is split into individual
characters.  If the regex has groupings, then the list produced contains
the matched substrings from the groupings as well:
.PP
.Vb 6
\&    $x = "/usr/bin";
\&    @parts = split m!(/)!, $x;  # $parts[0] = \*(Aq\*(Aq
\&                                # $parts[1] = \*(Aq/\*(Aq
\&                                # $parts[2] = \*(Aqusr\*(Aq
\&                                # $parts[3] = \*(Aq/\*(Aq
\&                                # $parts[4] = \*(Aqbin\*(Aq
.Ve
.PP
Since the first character of \f(CW$x\fR matched the regex, \f(CW\*(C`split\*(C'\fR prepended
an empty initial element to the list.
.SH "BUGS"
.IX Header "BUGS"
None.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This is just a quick start guide.  For a more in-depth tutorial on
regexes, see perlretut and for the reference page, see perlre.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 2000 Mark Kvale
All rights reserved.
.PP
This document may be distributed under the same terms as Perl itself.
.SS "Acknowledgments"
.IX Subsection "Acknowledgments"
The author would like to thank Mark-Jason Dominus, Tom Christiansen,
Ilya Zakharevich, Brad Hughes, and Mike Giroux for all their helpful
comments.
                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlrequick5.18.1                            0100644 0001750 0001750 00000062615 12566207444 023616  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREQUICK 1"
.TH PERLREQUICK 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrequick \- Perl regular expressions quick start
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page covers the very basics of understanding, creating and
using regular expressions ('regexes') in Perl.
.SH "The Guide"
.IX Header "The Guide"
.SS "Simple word matching"
.IX Subsection "Simple word matching"
The simplest regex is simply a word, or more generally, a string of
characters.  A regex consisting of a word matches any string that
contains that word:
.PP
.Vb 1
\&    "Hello World" =~ /World/;  # matches
.Ve
.PP
In this statement, \f(CW\*(C`World\*(C'\fR is a regex and the \f(CW\*(C`//\*(C'\fR enclosing
\&\f(CW\*(C`/World/\*(C'\fR tells Perl to search a string for a match.  The operator
\&\f(CW\*(C`=~\*(C'\fR associates the string with the regex match and produces a true
value if the regex matched, or false if the regex did not match.  In
our case, \f(CW\*(C`World\*(C'\fR matches the second word in \f(CW"Hello World"\fR, so the
expression is true.  This idea has several variations.
.PP
Expressions like this are useful in conditionals:
.PP
.Vb 1
\&    print "It matches\en" if "Hello World" =~ /World/;
.Ve
.PP
The sense of the match can be reversed by using \f(CW\*(C`!~\*(C'\fR operator:
.PP
.Vb 1
\&    print "It doesn\*(Aqt match\en" if "Hello World" !~ /World/;
.Ve
.PP
The literal string in the regex can be replaced by a variable:
.PP
.Vb 2
\&    $greeting = "World";
\&    print "It matches\en" if "Hello World" =~ /$greeting/;
.Ve
.PP
If you're matching against \f(CW$_\fR, the \f(CW\*(C`$_ =~\*(C'\fR part can be omitted:
.PP
.Vb 2
\&    $_ = "Hello World";
\&    print "It matches\en" if /World/;
.Ve
.PP
Finally, the \f(CW\*(C`//\*(C'\fR default delimiters for a match can be changed to
arbitrary delimiters by putting an \f(CW\*(Aqm\*(Aq\fR out front:
.PP
.Vb 4
\&    "Hello World" =~ m!World!;   # matches, delimited by \*(Aq!\*(Aq
\&    "Hello World" =~ m{World};   # matches, note the matching \*(Aq{}\*(Aq
\&    "/usr/bin/perl" =~ m"/perl"; # matches after \*(Aq/usr/bin\*(Aq,
\&                                 # \*(Aq/\*(Aq becomes an ordinary char
.Ve
.PP
Regexes must match a part of the string \fIexactly\fR in order for the
statement to be true:
.PP
.Vb 3
\&    "Hello World" =~ /world/;  # doesn\*(Aqt match, case sensitive
\&    "Hello World" =~ /o W/;    # matches, \*(Aq \*(Aq is an ordinary char
\&    "Hello World" =~ /World /; # doesn\*(Aqt match, no \*(Aq \*(Aq at end
.Ve
.PP
Perl will always match at the earliest possible point in the string:
.PP
.Vb 2
\&    "Hello World" =~ /o/;       # matches \*(Aqo\*(Aq in \*(AqHello\*(Aq
\&    "That hat is red" =~ /hat/; # matches \*(Aqhat\*(Aq in \*(AqThat\*(Aq
.Ve
.PP
Not all characters can be used 'as is' in a match.  Some characters,
called \fBmetacharacters\fR, are reserved for use in regex notation.
The metacharacters are
.PP
.Vb 1
\&    {}[]()^$.|*+?\e
.Ve
.PP
A metacharacter can be matched by putting a backslash before it:
.PP
.Vb 4
\&    "2+2=4" =~ /2+2/;    # doesn\*(Aqt match, + is a metacharacter
\&    "2+2=4" =~ /2\e+2/;   # matches, \e+ is treated like an ordinary +
\&    \*(AqC:\eWIN32\*(Aq =~ /C:\e\eWIN/;                       # matches
\&    "/usr/bin/perl" =~ /\e/usr\e/bin\e/perl/;  # matches
.Ve
.PP
In the last regex, the forward slash \f(CW\*(Aq/\*(Aq\fR is also backslashed,
because it is used to delimit the regex.
.PP
Non-printable \s-1ASCII\s0 characters are represented by \fBescape sequences\fR.
Common examples are \f(CW\*(C`\et\*(C'\fR for a tab, \f(CW\*(C`\en\*(C'\fR for a newline, and \f(CW\*(C`\er\*(C'\fR
for a carriage return.  Arbitrary bytes are represented by octal
escape sequences, e.g., \f(CW\*(C`\e033\*(C'\fR, or hexadecimal escape sequences,
e.g., \f(CW\*(C`\ex1B\*(C'\fR:
.PP
.Vb 2
\&    "1000\et2000" =~ m(0\et2)      # matches
\&    "cat"      =~ /\e143\ex61\ex74/ # matches in ASCII, but a weird way to spell cat
.Ve
.PP
Regexes are treated mostly as double-quoted strings, so variable
substitution works:
.PP
.Vb 3
\&    $foo = \*(Aqhouse\*(Aq;
\&    \*(Aqcathouse\*(Aq =~ /cat$foo/;   # matches
\&    \*(Aqhousecat\*(Aq =~ /${foo}cat/; # matches
.Ve
.PP
With all of the regexes above, if the regex matched anywhere in the
string, it was considered a match.  To specify \fIwhere\fR it should
match, we would use the \fBanchor\fR metacharacters \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR.  The
anchor \f(CW\*(C`^\*(C'\fR means match at the beginning of the string and the anchor
\&\f(CW\*(C`$\*(C'\fR means match at the end of the string, or before a newline at the
end of the string.  Some examples:
.PP
.Vb 5
\&    "housekeeper" =~ /keeper/;         # matches
\&    "housekeeper" =~ /^keeper/;        # doesn\*(Aqt match
\&    "housekeeper" =~ /keeper$/;        # matches
\&    "housekeeper\en" =~ /keeper$/;      # matches
\&    "housekeeper" =~ /^housekeeper$/;  # matches
.Ve
.SS "Using character classes"
.IX Subsection "Using character classes"
A \fBcharacter class\fR allows a set of possible characters, rather than
just a single character, to match at a particular point in a regex.
Character classes are denoted by brackets \f(CW\*(C`[...]\*(C'\fR, with the set of
characters to be possibly matched inside.  Here are some examples:
.PP
.Vb 3
\&    /cat/;            # matches \*(Aqcat\*(Aq
\&    /[bcr]at/;        # matches \*(Aqbat\*(Aq, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&    "abc" =~ /[cab]/; # matches \*(Aqa\*(Aq
.Ve
.PP
In the last statement, even though \f(CW\*(Aqc\*(Aq\fR is the first character in
the class, the earliest point at which the regex can match is \f(CW\*(Aqa\*(Aq\fR.
.PP
.Vb 3
\&    /[yY][eE][sS]/; # match \*(Aqyes\*(Aq in a case\-insensitive way
\&                    # \*(Aqyes\*(Aq, \*(AqYes\*(Aq, \*(AqYES\*(Aq, etc.
\&    /yes/i;         # also match \*(Aqyes\*(Aq in a case\-insensitive way
.Ve
.PP
The last example shows a match with an \f(CW\*(Aqi\*(Aq\fR \fBmodifier\fR, which makes
the match case-insensitive.
.PP
Character classes also have ordinary and special characters, but the
sets of ordinary and special characters inside a character class are
different than those outside a character class.  The special
characters for a character class are \f(CW\*(C`\-]\e^$\*(C'\fR and are matched using an
escape:
.PP
.Vb 5
\&   /[\e]c]def/; # matches \*(Aq]def\*(Aq or \*(Aqcdef\*(Aq
\&   $x = \*(Aqbcr\*(Aq;
\&   /[$x]at/;   # matches \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&   /[\e$x]at/;  # matches \*(Aq$at\*(Aq or \*(Aqxat\*(Aq
\&   /[\e\e$x]at/; # matches \*(Aq\eat\*(Aq, \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
.Ve
.PP
The special character \f(CW\*(Aq\-\*(Aq\fR acts as a range operator within character
classes, so that the unwieldy \f(CW\*(C`[0123456789]\*(C'\fR and \f(CW\*(C`[abc...xyz]\*(C'\fR
become the svelte \f(CW\*(C`[0\-9]\*(C'\fR and \f(CW\*(C`[a\-z]\*(C'\fR:
.PP
.Vb 2
\&    /item[0\-9]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    /[0\-9a\-fA\-F]/;  # matches a hexadecimal digit
.Ve
.PP
If \f(CW\*(Aq\-\*(Aq\fR is the first or last character in a character class, it is
treated as an ordinary character.
.PP
The special character \f(CW\*(C`^\*(C'\fR in the first position of a character class
denotes a \fBnegated character class\fR, which matches any character but
those in the brackets.  Both \f(CW\*(C`[...]\*(C'\fR and \f(CW\*(C`[^...]\*(C'\fR must match a
character, or the match fails.  Then
.PP
.Vb 4
\&    /[^a]at/;  # doesn\*(Aqt match \*(Aqaat\*(Aq or \*(Aqat\*(Aq, but matches
\&               # all other \*(Aqbat\*(Aq, \*(Aqcat, \*(Aq0at\*(Aq, \*(Aq%at\*(Aq, etc.
\&    /[^0\-9]/;  # matches a non\-numeric character
\&    /[a^]at/;  # matches \*(Aqaat\*(Aq or \*(Aq^at\*(Aq; here \*(Aq^\*(Aq is ordinary
.Ve
.PP
Perl has several abbreviations for common character classes. (These
definitions are those that Perl uses in ASCII-safe mode with the \f(CW\*(C`/a\*(C'\fR modifier.
Otherwise they could match many more non-ASCII Unicode characters as
well.  See \*(L"Backslash sequences\*(R" in perlrecharclass for details.)
.IP "\(bu" 4
\&\ed is a digit and represents
.Sp
.Vb 1
\&    [0\-9]
.Ve
.IP "\(bu" 4
\&\es is a whitespace character and represents
.Sp
.Vb 1
\&    [\e \et\er\en\ef]
.Ve
.IP "\(bu" 4
\&\ew is a word character (alphanumeric or _) and represents
.Sp
.Vb 1
\&    [0\-9a\-zA\-Z_]
.Ve
.IP "\(bu" 4
\&\eD is a negated \ed; it represents any character but a digit
.Sp
.Vb 1
\&    [^0\-9]
.Ve
.IP "\(bu" 4
\&\eS is a negated \es; it represents any non-whitespace character
.Sp
.Vb 1
\&    [^\es]
.Ve
.IP "\(bu" 4
\&\eW is a negated \ew; it represents any non-word character
.Sp
.Vb 1
\&    [^\ew]
.Ve
.IP "\(bu" 4
The period '.' matches any character but \*(L"\en\*(R"
.PP
The \f(CW\*(C`\ed\es\ew\eD\eS\eW\*(C'\fR abbreviations can be used both inside and outside
of character classes.  Here are some in use:
.PP
.Vb 7
\&    /\ed\ed:\ed\ed:\ed\ed/; # matches a hh:mm:ss time format
\&    /[\ed\es]/;         # matches any digit or whitespace character
\&    /\ew\eW\ew/;         # matches a word char, followed by a
\&                      # non\-word char, followed by a word char
\&    /..rt/;           # matches any two chars, followed by \*(Aqrt\*(Aq
\&    /end\e./;          # matches \*(Aqend.\*(Aq
\&    /end[.]/;         # same thing, matches \*(Aqend.\*(Aq
.Ve
.PP
The \fBword\ anchor\fR\  \f(CW\*(C`\eb\*(C'\fR matches a boundary between a word
character and a non-word character \f(CW\*(C`\ew\eW\*(C'\fR or \f(CW\*(C`\eW\ew\*(C'\fR:
.PP
.Vb 4
\&    $x = "Housecat catenates house and cat";
\&    $x =~ /\ebcat/;  # matches cat in \*(Aqcatenates\*(Aq
\&    $x =~ /cat\eb/;  # matches cat in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq at end of string
.Ve
.PP
In the last example, the end of the string is considered a word
boundary.
.SS "Matching this or that"
.IX Subsection "Matching this or that"
We can match different character strings with the \fBalternation\fR
metacharacter \f(CW\*(Aq|\*(Aq\fR.  To match \f(CW\*(C`dog\*(C'\fR or \f(CW\*(C`cat\*(C'\fR, we form the regex
\&\f(CW\*(C`dog|cat\*(C'\fR.  As before, Perl will try to match the regex at the
earliest possible point in the string.  At each character position,
Perl will first try to match the first alternative, \f(CW\*(C`dog\*(C'\fR.  If
\&\f(CW\*(C`dog\*(C'\fR doesn't match, Perl will then try the next alternative, \f(CW\*(C`cat\*(C'\fR.
If \f(CW\*(C`cat\*(C'\fR doesn't match either, then the match fails and Perl moves to
the next position in the string.  Some examples:
.PP
.Vb 2
\&    "cats and dogs" =~ /cat|dog|bird/;  # matches "cat"
\&    "cats and dogs" =~ /dog|cat|bird/;  # matches "cat"
.Ve
.PP
Even though \f(CW\*(C`dog\*(C'\fR is the first alternative in the second regex,
\&\f(CW\*(C`cat\*(C'\fR is able to match earlier in the string.
.PP
.Vb 2
\&    "cats"          =~ /c|ca|cat|cats/; # matches "c"
\&    "cats"          =~ /cats|cat|ca|c/; # matches "cats"
.Ve
.PP
At a given character position, the first alternative that allows the
regex match to succeed will be the one that matches. Here, all the
alternatives match at the first string position, so the first matches.
.SS "Grouping things and hierarchical matching"
.IX Subsection "Grouping things and hierarchical matching"
The \fBgrouping\fR metacharacters \f(CW\*(C`()\*(C'\fR allow a part of a regex to be
treated as a single unit.  Parts of a regex are grouped by enclosing
them in parentheses.  The regex \f(CW\*(C`house(cat|keeper)\*(C'\fR means match
\&\f(CW\*(C`house\*(C'\fR followed by either \f(CW\*(C`cat\*(C'\fR or \f(CW\*(C`keeper\*(C'\fR.  Some more examples
are
.PP
.Vb 2
\&    /(a|b)b/;    # matches \*(Aqab\*(Aq or \*(Aqbb\*(Aq
\&    /(^a|b)c/;   # matches \*(Aqac\*(Aq at start of string or \*(Aqbc\*(Aq anywhere
\&
\&    /house(cat|)/;  # matches either \*(Aqhousecat\*(Aq or \*(Aqhouse\*(Aq
\&    /house(cat(s|)|)/;  # matches either \*(Aqhousecats\*(Aq or \*(Aqhousecat\*(Aq or
\&                        # \*(Aqhouse\*(Aq.  Note groups can be nested.
\&
\&    "20" =~ /(19|20|)\ed\ed/;  # matches the null alternative \*(Aq()\ed\ed\*(Aq,
\&                             # because \*(Aq20\ed\ed\*(Aq can\*(Aqt match
.Ve
.SS "Extracting matches"
.IX Subsection "Extracting matches"
The grouping metacharacters \f(CW\*(C`()\*(C'\fR also allow the extraction of the
parts of a string that matched.  For each grouping, the part that
matched inside goes into the special variables \f(CW$1\fR, \f(CW$2\fR, etc.
They can be used just as ordinary variables:
.PP
.Vb 5
\&    # extract hours, minutes, seconds
\&    $time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/;  # match hh:mm:ss format
\&    $hours = $1;
\&    $minutes = $2;
\&    $seconds = $3;
.Ve
.PP
In list context, a match \f(CW\*(C`/regex/\*(C'\fR with groupings will return the
list of matched values \f(CW\*(C`($1,$2,...)\*(C'\fR.  So we could rewrite it as
.PP
.Vb 1
\&    ($hours, $minutes, $second) = ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/);
.Ve
.PP
If the groupings in a regex are nested, \f(CW$1\fR gets the group with the
leftmost opening parenthesis, \f(CW$2\fR the next opening parenthesis,
etc.  For example, here is a complex regex and the matching variables
indicated below it:
.PP
.Vb 2
\&    /(ab(cd|ef)((gi)|j))/;
\&     1  2      34
.Ve
.PP
Associated with the matching variables \f(CW$1\fR, \f(CW$2\fR, ... are
the \fBbackreferences\fR \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR, ...  Backreferences are
matching variables that can be used \fIinside\fR a regex:
.PP
.Vb 1
\&    /(\ew\ew\ew)\es\eg1/; # find sequences like \*(Aqthe the\*(Aq in string
.Ve
.PP
\&\f(CW$1\fR, \f(CW$2\fR, ... should only be used outside of a regex, and \f(CW\*(C`\eg1\*(C'\fR,
\&\f(CW\*(C`\eg2\*(C'\fR, ... only inside a regex.
.SS "Matching repetitions"
.IX Subsection "Matching repetitions"
The \fBquantifier\fR metacharacters \f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR, and \f(CW\*(C`{}\*(C'\fR allow us
to determine the number of repeats of a portion of a regex we
consider to be a match.  Quantifiers are put immediately after the
character, character class, or grouping that we want to specify.  They
have the following meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a?\*(C'\fR = match 'a' 1 or 0 times
.IP "\(bu" 4
\&\f(CW\*(C`a*\*(C'\fR = match 'a' 0 or more times, i.e., any number of times
.IP "\(bu" 4
\&\f(CW\*(C`a+\*(C'\fR = match 'a' 1 or more times, i.e., at least once
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}\*(C'\fR = match at least \f(CW\*(C`n\*(C'\fR times, but not more than \f(CW\*(C`m\*(C'\fR
times.
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}\*(C'\fR = match at least \f(CW\*(C`n\*(C'\fR or more times
.IP "\(bu" 4
\&\f(CW\*(C`a{n}\*(C'\fR = match exactly \f(CW\*(C`n\*(C'\fR times
.PP
Here are some examples:
.PP
.Vb 6
\&    /[a\-z]+\es+\ed*/;  # match a lowercase word, at least some space, and
\&                     # any number of digits
\&    /(\ew+)\es+\eg1/;    # match doubled words of arbitrary length
\&    $year =~ /^\ed{2,4}$/;  # make sure year is at least 2 but not more
\&                           # than 4 digits
\&    $year =~ /^\ed{4}$|^\ed{2}$/;    # better match; throw out 3 digit dates
.Ve
.PP
These quantifiers will try to match as much of the string as possible,
while still allowing the regex to match.  So we have
.PP
.Vb 5
\&    $x = \*(Aqthe cat in the hat\*(Aq;
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe cat in the h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 matches)
.Ve
.PP
The first quantifier \f(CW\*(C`.*\*(C'\fR grabs as much of the string as possible
while still having the regex match. The second quantifier \f(CW\*(C`.*\*(C'\fR has
no string left to it, so it matches 0 times.
.SS "More matching"
.IX Subsection "More matching"
There are a few more things you might want to know about matching
operators.
The global modifier \f(CW\*(C`//g\*(C'\fR allows the matching operator to match
within a string as many times as possible.  In scalar context,
successive matches against a string will have \f(CW\*(C`//g\*(C'\fR jump from match
to match, keeping track of position in the string as it goes along.
You can get or set the position with the \f(CW\*(C`pos()\*(C'\fR function.
For example,
.PP
.Vb 4
\&    $x = "cat dog house"; # 3 words
\&    while ($x =~ /(\ew+)/g) {
\&        print "Word is $1, ends at position ", pos $x, "\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 3
\&    Word is cat, ends at position 3
\&    Word is dog, ends at position 7
\&    Word is house, ends at position 13
.Ve
.PP
A failed match or changing the target string resets the position.  If
you don't want the position reset after failure to match, add the
\&\f(CW\*(C`//c\*(C'\fR, as in \f(CW\*(C`/regex/gc\*(C'\fR.
.PP
In list context, \f(CW\*(C`//g\*(C'\fR returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole regex.  So
.PP
.Vb 4
\&    @words = ($x =~ /(\ew+)/g);  # matches,
\&                                # $word[0] = \*(Aqcat\*(Aq
\&                                # $word[1] = \*(Aqdog\*(Aq
\&                                # $word[2] = \*(Aqhouse\*(Aq
.Ve
.SS "Search and replace"
.IX Subsection "Search and replace"
Search and replace is performed using \f(CW\*(C`s/regex/replacement/modifiers\*(C'\fR.
The \f(CW\*(C`replacement\*(C'\fR is a Perl double-quoted string that replaces in the
string whatever is matched with the \f(CW\*(C`regex\*(C'\fR.  The operator \f(CW\*(C`=~\*(C'\fR is
also used here to associate a string with \f(CW\*(C`s///\*(C'\fR.  If matching
against \f(CW$_\fR, the \f(CW\*(C`$_\ =~\*(C'\fR can be dropped.  If there is a match,
\&\f(CW\*(C`s///\*(C'\fR returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:
.PP
.Vb 5
\&    $x = "Time to feed the cat!";
\&    $x =~ s/cat/hacker/;   # $x contains "Time to feed the hacker!"
\&    $y = "\*(Aqquoted words\*(Aq";
\&    $y =~ s/^\*(Aq(.*)\*(Aq$/$1/;  # strip single quotes,
\&                           # $y contains "quoted words"
.Ve
.PP
With the \f(CW\*(C`s///\*(C'\fR operator, the matched variables \f(CW$1\fR, \f(CW$2\fR, etc.
are immediately available for use in the replacement expression. With
the global modifier, \f(CW\*(C`s///g\*(C'\fR will search and replace all occurrences
of the regex in the string:
.PP
.Vb 4
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/;   # $x contains "I batted four for 4"
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/g;  # $x contains "I batted four for four"
.Ve
.PP
The non-destructive modifier \f(CW\*(C`s///r\*(C'\fR causes the result of the substitution
to be returned instead of modifying \f(CW$_\fR (or whatever variable the
substitute was bound to with \f(CW\*(C`=~\*(C'\fR):
.PP
.Vb 3
\&    $x = "I like dogs.";
\&    $y = $x =~ s/dogs/cats/r;
\&    print "$x $y\en"; # prints "I like dogs. I like cats."
\&
\&    $x = "Cats are great.";
\&    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, "\en";
\&    # prints "Hedgehogs are great."
\&
\&    @foo = map { s/[a\-z]/X/r } qw(a b c 1 2 3);
\&    # @foo is now qw(X X X 1 2 3)
.Ve
.PP
The evaluation modifier \f(CW\*(C`s///e\*(C'\fR wraps an \f(CW\*(C`eval{...}\*(C'\fR around the
replacement string and the evaluated result is substituted for the
matched substring.  Some examples:
.PP
.Vb 3
\&    # reverse all the words in a string
\&    $x = "the cat in the hat";
\&    $x =~ s/(\ew+)/reverse $1/ge;   # $x contains "eht tac ni eht tah"
\&
\&    # convert percentage to decimal
\&    $x = "A 39% hit rate";
\&    $x =~ s!(\ed+)%!$1/100!e;       # $x contains "A 0.39 hit rate"
.Ve
.PP
The last example shows that \f(CW\*(C`s///\*(C'\fR can use other delimiters, such as
\&\f(CW\*(C`s!!!\*(C'\fR and \f(CW\*(C`s{}{}\*(C'\fR, and even \f(CW\*(C`s{}//\*(C'\fR.  If single quotes are used
\&\f(CW\*(C`s\*(Aq\*(Aq\*(Aq\*(C'\fR, then the regex and replacement are treated as single-quoted
strings.
.SS "The split operator"
.IX Subsection "The split operator"
\&\f(CW\*(C`split /regex/, string\*(C'\fR splits \f(CW\*(C`string\*(C'\fR into a list of substrings
and returns that list.  The regex determines the character sequence
that \f(CW\*(C`string\*(C'\fR is split with respect to.  For example, to split a
string into words, use
.PP
.Vb 4
\&    $x = "Calvin and Hobbes";
\&    @word = split /\es+/, $x;  # $word[0] = \*(AqCalvin\*(Aq
\&                              # $word[1] = \*(Aqand\*(Aq
\&                              # $word[2] = \*(AqHobbes\*(Aq
.Ve
.PP
To extract a comma-delimited list of numbers, use
.PP
.Vb 4
\&    $x = "1.618,2.718,   3.142";
\&    @const = split /,\es*/, $x;  # $const[0] = \*(Aq1.618\*(Aq
\&                                # $const[1] = \*(Aq2.718\*(Aq
\&                                # $const[2] = \*(Aq3.142\*(Aq
.Ve
.PP
If the empty regex \f(CW\*(C`//\*(C'\fR is used, the string is split into individual
characters.  If the regex has groupings, then the list produced contains
the matched substrings from the groupings as well:
.PP
.Vb 6
\&    $x = "/usr/bin";
\&    @parts = split m!(/)!, $x;  # $parts[0] = \*(Aq\*(Aq
\&                                # $parts[1] = \*(Aq/\*(Aq
\&                                # $parts[2] = \*(Aqusr\*(Aq
\&                                # $parts[3] = \*(Aq/\*(Aq
\&                                # $parts[4] = \*(Aqbin\*(Aq
.Ve
.PP
Since the first character of \f(CW$x\fR matched the regex, \f(CW\*(C`split\*(C'\fR prepended
an empty initial element to the list.
.SH "BUGS"
.IX Header "BUGS"
None.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This is just a quick start guide.  For a more in-depth tutorial on
regexes, see perlretut and for the reference page, see perlre.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 2000 Mark Kvale
All rights reserved.
.PP
This document may be distributed under the same terms as Perl itself.
.SS "Acknowledgments"
.IX Subsection "Acknowledgments"
The author would like to thank Mark-Jason Dominus, Tom Christiansen,
Ilya Zakharevich, Brad Hughes, and Mike Giroux for all their helpful
comments.
                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreref.1                                  0100644 0001750 0001750 00000050061 12566207444 022732  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREREF 1"
.TH PERLREREF 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreref \- Perl Regular Expressions Reference
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a quick reference to Perl's regular expressions.
For full information see perlre and perlop, as well
as the \*(L"\s-1SEE ALSO\*(R"\s0 section in this document.
.SS "\s-1OPERATORS\s0"
.IX Subsection "OPERATORS"
\&\f(CW\*(C`=~\*(C'\fR determines to which variable the regex is applied.
In its absence, \f(CW$_\fR is used.
.PP
.Vb 1
\&    $var =~ /foo/;
.Ve
.PP
\&\f(CW\*(C`!~\*(C'\fR determines to which variable the regex is applied,
and negates the result of the match; it returns
false if the match succeeds, and true if it fails.
.PP
.Vb 1
\&    $var !~ /foo/;
.Ve
.PP
\&\f(CW\*(C`m/pattern/msixpogcdual\*(C'\fR searches a string for a pattern match,
applying the given options.
.PP
.Vb 10
\&    m  Multiline mode \- ^ and $ match internal lines
\&    s  match as a Single line \- . matches \en
\&    i  case\-Insensitive
\&    x  eXtended legibility \- free whitespace and comments
\&    p  Preserve a copy of the matched string \-
\&       ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be defined.
\&    o  compile pattern Once
\&    g  Global \- all occurrences
\&    c  don\*(Aqt reset pos on failed matches when using /g
\&    a  restrict \ed, \es, \ew and [:posix:] to match ASCII only
\&    aa (two a\*(Aqs) also /i matches exclude ASCII/non\-ASCII
\&    l  match according to current locale
\&    u  match according to Unicode rules
\&    d  match according to native rules unless something indicates
\&       Unicode
.Ve
.PP
If 'pattern' is an empty string, the last \fIsuccessfully\fR matched
regex is used. Delimiters other than '/' may be used for both this
operator and the following ones. The leading \f(CW\*(C`m\*(C'\fR can be omitted
if the delimiter is '/'.
.PP
\&\f(CW\*(C`qr/pattern/msixpodual\*(C'\fR lets you store a regex in a variable,
or pass one around. Modifiers as for \f(CW\*(C`m//\*(C'\fR, and are stored
within the regex.
.PP
\&\f(CW\*(C`s/pattern/replacement/msixpogcedual\*(C'\fR substitutes matches of
\&'pattern' with 'replacement'. Modifiers as for \f(CW\*(C`m//\*(C'\fR,
with two additions:
.PP
.Vb 2
\&    e  Evaluate \*(Aqreplacement\*(Aq as an expression
\&    r  Return substitution and leave the original string untouched.
.Ve
.PP
\&'e' may be specified multiple times. 'replacement' is interpreted
as a double quoted string unless a single-quote (\f(CW\*(C`\*(Aq\*(C'\fR) is the delimiter.
.PP
\&\f(CW\*(C`?pattern?\*(C'\fR is like \f(CW\*(C`m/pattern/\*(C'\fR but matches only once. No alternate
delimiters can be used.  Must be reset with \fIreset()\fR.
.SS "\s-1SYNTAX\s0"
.IX Subsection "SYNTAX"
.Vb 10
\& \e       Escapes the character immediately following it
\& .       Matches any single character except a newline (unless /s is
\&           used)
\& ^       Matches at the beginning of the string (or line, if /m is used)
\& $       Matches at the end of the string (or line, if /m is used)
\& *       Matches the preceding element 0 or more times
\& +       Matches the preceding element 1 or more times
\& ?       Matches the preceding element 0 or 1 times
\& {...}   Specifies a range of occurrences for the element preceding it
\& [...]   Matches any one of the characters contained within the brackets
\& (...)   Groups subexpressions for capturing to $1, $2...
\& (?:...) Groups subexpressions without capturing (cluster)
\& |       Matches either the subexpression preceding or following it
\& \eg1 or \eg{1}, \eg2 ...    Matches the text from the Nth group
\& \e1, \e2, \e3 ...           Matches the text from the Nth group
\& \eg\-1 or \eg{\-1}, \eg\-2 ... Matches the text from the Nth previous group
\& \eg{name}     Named backreference
\& \ek<name>     Named backreference
\& \ek\*(Aqname\*(Aq     Named backreference
\& (?P=name)    Named backreference (python syntax)
.Ve
.SS "\s-1ESCAPE SEQUENCES\s0"
.IX Subsection "ESCAPE SEQUENCES"
These work as in normal strings.
.PP
.Vb 10
\&   \ea       Alarm (beep)
\&   \ee       Escape
\&   \ef       Formfeed
\&   \en       Newline
\&   \er       Carriage return
\&   \et       Tab
\&   \e037     Char whose ordinal is the 3 octal digits, max \e777
\&   \eo{2307} Char whose ordinal is the octal number, unrestricted
\&   \ex7f     Char whose ordinal is the 2 hex digits, max \exFF
\&   \ex{263a} Char whose ordinal is the hex number, unrestricted
\&   \ecx      Control\-x
\&   \eN{name} A named Unicode character or character sequence
\&   \eN{U+263D} A Unicode character by hex ordinal
\&
\&   \el  Lowercase next character
\&   \eu  Titlecase next character
\&   \eL  Lowercase until \eE
\&   \eU  Uppercase until \eE
\&   \eF  Foldcase until \eE
\&   \eQ  Disable pattern metacharacters until \eE
\&   \eE  End modification
.Ve
.PP
For Titlecase, see \*(L"Titlecase\*(R".
.PP
This one works differently from normal strings:
.PP
.Vb 1
\&   \eb  An assertion, not backspace, except in a character class
.Ve
.SS "\s-1CHARACTER CLASSES\s0"
.IX Subsection "CHARACTER CLASSES"
.Vb 4
\&   [amy]    Match \*(Aqa\*(Aq, \*(Aqm\*(Aq or \*(Aqy\*(Aq
\&   [f\-j]    Dash specifies "range"
\&   [f\-j\-]   Dash escaped or at start or end means \*(Aqdash\*(Aq
\&   [^f\-j]   Caret indicates "match any character _except_ these"
.Ve
.PP
The following sequences (except \f(CW\*(C`\eN\*(C'\fR) work within or without a character class.
The first six are locale aware, all are Unicode aware. See perllocale
and perlunicode for details.
.PP
.Vb 10
\&   \ed      A digit
\&   \eD      A nondigit
\&   \ew      A word character
\&   \eW      A non\-word character
\&   \es      A whitespace character
\&   \eS      A non\-whitespace character
\&   \eh      An horizontal whitespace
\&   \eH      A non horizontal whitespace
\&   \eN      A non newline (when not followed by \*(Aq{NAME}\*(Aq;;
\&           not valid in a character class; equivalent to [^\en]; it\*(Aqs
\&           like \*(Aq.\*(Aq without /s modifier)
\&   \ev      A vertical whitespace
\&   \eV      A non vertical whitespace
\&   \eR      A generic newline           (?>\ev|\ex0D\ex0A)
\&
\&   \eC      Match a byte (with Unicode, \*(Aq.\*(Aq matches a character)
\&   \epP     Match P\-named (Unicode) property
\&   \ep{...} Match Unicode property with name longer than 1 character
\&   \ePP     Match non\-P
\&   \eP{...} Match lack of Unicode property with name longer than 1 char
\&   \eX      Match Unicode extended grapheme cluster
.Ve
.PP
\&\s-1POSIX\s0 character classes and their Unicode and Perl equivalents:
.PP
.Vb 3
\&            ASCII\-         Full\-
\&   POSIX    range          range    backslash
\& [[:...:]]  \ep{...}        \ep{...}   sequence    Description
\&
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& alnum   PosixAlnum       XPosixAlnum            Alpha plus Digit
\& alpha   PosixAlpha       XPosixAlpha            Alphabetic characters
\& ascii   ASCII                                   Any ASCII character
\& blank   PosixBlank       XPosixBlank   \eh       Horizontal whitespace;
\&                                                   full\-range also
\&                                                   written as
\&                                                   \ep{HorizSpace} (GNU
\&                                                   extension)
\& cntrl   PosixCntrl       XPosixCntrl            Control characters
\& digit   PosixDigit       XPosixDigit   \ed       Decimal digits
\& graph   PosixGraph       XPosixGraph            Alnum plus Punct
\& lower   PosixLower       XPosixLower            Lowercase characters
\& print   PosixPrint       XPosixPrint            Graph plus Print, but
\&                                                   not any Cntrls
\& punct   PosixPunct       XPosixPunct            Punctuation and Symbols
\&                                                   in ASCII\-range; just
\&                                                   punct outside it
\& space   PosixSpace       XPosixSpace            [\es\ecK]
\&         PerlSpace        XPerlSpace    \es       Perl\*(Aqs whitespace def\*(Aqn
\& upper   PosixUpper       XPosixUpper            Uppercase characters
\& word    PosixWord        XPosixWord    \ew       Alnum + Unicode marks +
\&                                                   connectors, like \*(Aq_\*(Aq
\&                                                   (Perl extension)
\& xdigit  ASCII_Hex_Digit  XPosixDigit            Hexadecimal digit,
\&                                                    ASCII\-range is
\&                                                    [0\-9A\-Fa\-f]
.Ve
.PP
Also, various synonyms like \f(CW\*(C`\ep{Alpha}\*(C'\fR for \f(CW\*(C`\ep{XPosixAlpha}\*(C'\fR; all listed
in \*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops
.PP
Within a character class:
.PP
.Vb 3
\&    POSIX      traditional   Unicode
\&  [:digit:]       \ed        \ep{Digit}
\&  [:^digit:]      \eD        \eP{Digit}
.Ve
.SS "\s-1ANCHORS\s0"
.IX Subsection "ANCHORS"
All are zero-width assertions.
.PP
.Vb 9
\&   ^  Match string start (or line, if /m is used)
\&   $  Match string end (or line, if /m is used) or before newline
\&   \eb Match word boundary (between \ew and \eW)
\&   \eB Match except at word boundary (between \ew and \ew or \eW and \eW)
\&   \eA Match string start (regardless of /m)
\&   \eZ Match string end (before optional newline)
\&   \ez Match absolute string end
\&   \eG Match where previous m//g left off
\&   \eK Keep the stuff left of the \eK, don\*(Aqt include it in $&
.Ve
.SS "\s-1QUANTIFIERS\s0"
.IX Subsection "QUANTIFIERS"
Quantifiers are greedy by default and match the \fBlongest\fR leftmost.
.PP
.Vb 9
\&   Maximal Minimal Possessive Allowed range
\&   \-\-\-\-\-\-\- \-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-
\&   {n,m}   {n,m}?  {n,m}+     Must occur at least n times
\&                              but no more than m times
\&   {n,}    {n,}?   {n,}+      Must occur at least n times
\&   {n}     {n}?    {n}+       Must occur exactly n times
\&   *       *?      *+         0 or more times (same as {0,})
\&   +       +?      ++         1 or more times (same as {1,})
\&   ?       ??      ?+         0 or 1 time (same as {0,1})
.Ve
.PP
The possessive forms (new in Perl 5.10) prevent backtracking: what gets
matched by a pattern with a possessive quantifier will not be backtracked
into, even if that causes the whole match to fail.
.PP
There is no quantifier \f(CW\*(C`{,n}\*(C'\fR. That's interpreted as a literal string.
.SS "\s-1EXTENDED CONSTRUCTS\s0"
.IX Subsection "EXTENDED CONSTRUCTS"
.Vb 10
\&   (?#text)          A comment
\&   (?:...)           Groups subexpressions without capturing (cluster)
\&   (?pimsx\-imsx:...) Enable/disable option (as per m// modifiers)
\&   (?=...)           Zero\-width positive lookahead assertion
\&   (?!...)           Zero\-width negative lookahead assertion
\&   (?<=...)          Zero\-width positive lookbehind assertion
\&   (?<!...)          Zero\-width negative lookbehind assertion
\&   (?>...)           Grab what we can, prohibit backtracking
\&   (?|...)           Branch reset
\&   (?<name>...)      Named capture
\&   (?\*(Aqname\*(Aq...)      Named capture
\&   (?P<name>...)     Named capture (python syntax)
\&   (?{ code })       Embedded code, return value becomes $^R
\&   (??{ code })      Dynamic regex, return value used as regex
\&   (?N)              Recurse into subpattern number N
\&   (?\-N), (?+N)      Recurse into Nth previous/next subpattern
\&   (?R), (?0)        Recurse at the beginning of the whole pattern
\&   (?&name)          Recurse into a named subpattern
\&   (?P>name)         Recurse into a named subpattern (python syntax)
\&   (?(cond)yes|no)
\&   (?(cond)yes)      Conditional expression, where "cond" can be:
\&                     (?=pat)   look\-ahead
\&                     (?!pat)   negative look\-ahead
\&                     (?<=pat)  look\-behind
\&                     (?<!pat)  negative look\-behind
\&                     (N)       subpattern N has matched something
\&                     (<name>)  named subpattern has matched something
\&                     (\*(Aqname\*(Aq)  named subpattern has matched something
\&                     (?{code}) code condition
\&                     (R)       true if recursing
\&                     (RN)      true if recursing into Nth subpattern
\&                     (R&name)  true if recursing into named subpattern
\&                     (DEFINE)  always false, no no\-pattern allowed
.Ve
.SS "\s-1VARIABLES\s0"
.IX Subsection "VARIABLES"
.Vb 1
\&   $_    Default variable for operators to use
\&
\&   $\`    Everything prior to matched string
\&   $&    Entire matched string
\&   $\*(Aq    Everything after to matched string
\&
\&   ${^PREMATCH}   Everything prior to matched string
\&   ${^MATCH}      Entire matched string
\&   ${^POSTMATCH}  Everything after to matched string
.Ve
.PP
The use of \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR or \f(CW\*(C`$\*(Aq\*(C'\fR will slow down \fBall\fR regex use
within your program. Consult perlvar for \f(CW\*(C`@\-\*(C'\fR
to see equivalent expressions that won't cause slow down.
See also Devel::SawAmpersand. Starting with Perl 5.10, you
can also use the equivalent variables \f(CW\*(C`${^PREMATCH}\*(C'\fR, \f(CW\*(C`${^MATCH}\*(C'\fR
and \f(CW\*(C`${^POSTMATCH}\*(C'\fR, but for them to be defined, you have to
specify the \f(CW\*(C`/p\*(C'\fR (preserve) modifier on your regular expression.
.PP
.Vb 8
\&   $1, $2 ...  hold the Xth captured expr
\&   $+    Last parenthesized pattern match
\&   $^N   Holds the most recently closed capture
\&   $^R   Holds the result of the last (?{...}) expr
\&   @\-    Offsets of starts of groups. $\-[0] holds start of whole match
\&   @+    Offsets of ends of groups. $+[0] holds end of whole match
\&   %+    Named capture groups
\&   %\-    Named capture groups, as array refs
.Ve
.PP
Captured groups are numbered according to their \fIopening\fR paren.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
.Vb 5
\&   lc          Lowercase a string
\&   lcfirst     Lowercase first char of a string
\&   uc          Uppercase a string
\&   ucfirst     Titlecase first char of a string
\&   fc          Foldcase a string
\&
\&   pos         Return or set current match position
\&   quotemeta   Quote metacharacters
\&   reset       Reset ?pattern? status
\&   study       Analyze string for optimizing matching
\&
\&   split       Use a regex to split a string into parts
.Ve
.PP
The first five of these are like the escape sequences \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\el\*(C'\fR,
\&\f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, and \f(CW\*(C`\eF\*(C'\fR.  For Titlecase, see \*(L"Titlecase\*(R"; For
Foldcase, see \*(L"Foldcase\*(R".
.SS "\s-1TERMINOLOGY\s0"
.IX Subsection "TERMINOLOGY"
\fITitlecase\fR
.IX Subsection "Titlecase"
.PP
Unicode concept which most often is equal to uppercase, but for
certain characters like the German \*(L"sharp s\*(R" there is a difference.
.PP
\fIFoldcase\fR
.IX Subsection "Foldcase"
.PP
Unicode form that is useful when comparing strings regardless of case,
as certain characters have compex one-to-many case mappings. Primarily a
variant of lowercase.
.SH "AUTHOR"
.IX Header "AUTHOR"
Iain Truskett. Updated by the Perl 5 Porters.
.PP
This document may be distributed under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
perlretut for a tutorial on regular expressions.
.IP "\(bu" 4
perlrequick for a rapid tutorial.
.IP "\(bu" 4
perlre for more details.
.IP "\(bu" 4
perlvar for details on the variables.
.IP "\(bu" 4
perlop for details on the operators.
.IP "\(bu" 4
perlfunc for details on the functions.
.IP "\(bu" 4
perlfaq6 for FAQs on regular expressions.
.IP "\(bu" 4
perlrebackslash for a reference on backslash sequences.
.IP "\(bu" 4
perlrecharclass for a reference on character classes.
.IP "\(bu" 4
The re module to alter behaviour and aid
debugging.
.IP "\(bu" 4
\&\*(L"Debugging Regular Expressions\*(R" in perldebug
.IP "\(bu" 4
perluniintro, perlunicode, charnames and perllocale
for details on regexes and internationalisation.
.IP "\(bu" 4
\&\fIMastering Regular Expressions\fR by Jeffrey Friedl
(\fIhttp://oreilly.com/catalog/9780596528126/\fR) for a thorough grounding and
reference on the topic.
.SH "THANKS"
.IX Header "THANKS"
David P.C. Wollmann,
Richard Soderberg,
Sean M. Burke,
Tom Christiansen,
Jim Cromie,
and
Jeffrey Goff
for useful advice.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreref5.16.1                              0100644 0001750 0001750 00000047611 12566207423 023250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREREF 1"
.TH PERLREREF 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreref \- Perl Regular Expressions Reference
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a quick reference to Perl's regular expressions.
For full information see perlre and perlop, as well
as the \*(L"\s-1SEE\s0 \s-1ALSO\s0\*(R" section in this document.
.SS "\s-1OPERATORS\s0"
.IX Subsection "OPERATORS"
\&\f(CW\*(C`=~\*(C'\fR determines to which variable the regex is applied.
In its absence, \f(CW$_\fR is used.
.PP
.Vb 1
\&    $var =~ /foo/;
.Ve
.PP
\&\f(CW\*(C`!~\*(C'\fR determines to which variable the regex is applied,
and negates the result of the match; it returns
false if the match succeeds, and true if it fails.
.PP
.Vb 1
\&    $var !~ /foo/;
.Ve
.PP
\&\f(CW\*(C`m/pattern/msixpogcdual\*(C'\fR searches a string for a pattern match,
applying the given options.
.PP
.Vb 10
\&    m  Multiline mode \- ^ and $ match internal lines
\&    s  match as a Single line \- . matches \en
\&    i  case\-Insensitive
\&    x  eXtended legibility \- free whitespace and comments
\&    p  Preserve a copy of the matched string \-
\&       ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be defined.
\&    o  compile pattern Once
\&    g  Global \- all occurrences
\&    c  don\*(Aqt reset pos on failed matches when using /g
\&    a  restrict \ed, \es, \ew and [:posix:] to match ASCII only
\&    aa (two a\*(Aqs) also /i matches exclude ASCII/non\-ASCII
\&    l  match according to current locale
\&    u  match according to Unicode rules
\&    d  match according to native rules unless something indicates
\&       Unicode
.Ve
.PP
If 'pattern' is an empty string, the last \fIsuccessfully\fR matched
regex is used. Delimiters other than '/' may be used for both this
operator and the following ones. The leading \f(CW\*(C`m\*(C'\fR can be omitted
if the delimiter is '/'.
.PP
\&\f(CW\*(C`qr/pattern/msixpodual\*(C'\fR lets you store a regex in a variable,
or pass one around. Modifiers as for \f(CW\*(C`m//\*(C'\fR, and are stored
within the regex.
.PP
\&\f(CW\*(C`s/pattern/replacement/msixpogcedual\*(C'\fR substitutes matches of
\&'pattern' with 'replacement'. Modifiers as for \f(CW\*(C`m//\*(C'\fR,
with two additions:
.PP
.Vb 2
\&    e  Evaluate \*(Aqreplacement\*(Aq as an expression
\&    r  Return substitution and leave the original string untouched.
.Ve
.PP
\&'e' may be specified multiple times. 'replacement' is interpreted
as a double quoted string unless a single-quote (\f(CW\*(C`\*(Aq\*(C'\fR) is the delimiter.
.PP
\&\f(CW\*(C`?pattern?\*(C'\fR is like \f(CW\*(C`m/pattern/\*(C'\fR but matches only once. No alternate
delimiters can be used.  Must be reset with \fIreset()\fR.
.SS "\s-1SYNTAX\s0"
.IX Subsection "SYNTAX"
.Vb 10
\& \e       Escapes the character immediately following it
\& .       Matches any single character except a newline (unless /s is
\&           used)
\& ^       Matches at the beginning of the string (or line, if /m is used)
\& $       Matches at the end of the string (or line, if /m is used)
\& *       Matches the preceding element 0 or more times
\& +       Matches the preceding element 1 or more times
\& ?       Matches the preceding element 0 or 1 times
\& {...}   Specifies a range of occurrences for the element preceding it
\& [...]   Matches any one of the characters contained within the brackets
\& (...)   Groups subexpressions for capturing to $1, $2...
\& (?:...) Groups subexpressions without capturing (cluster)
\& |       Matches either the subexpression preceding or following it
\& \eg1 or \eg{1}, \eg2 ...    Matches the text from the Nth group
\& \e1, \e2, \e3 ...           Matches the text from the Nth group
\& \eg\-1 or \eg{\-1}, \eg\-2 ... Matches the text from the Nth previous group
\& \eg{name}     Named backreference
\& \ek<name>     Named backreference
\& \ek\*(Aqname\*(Aq     Named backreference
\& (?P=name)    Named backreference (python syntax)
.Ve
.SS "\s-1ESCAPE\s0 \s-1SEQUENCES\s0"
.IX Subsection "ESCAPE SEQUENCES"
These work as in normal strings.
.PP
.Vb 10
\&   \ea       Alarm (beep)
\&   \ee       Escape
\&   \ef       Formfeed
\&   \en       Newline
\&   \er       Carriage return
\&   \et       Tab
\&   \e037     Char whose ordinal is the 3 octal digits, max \e777
\&   \eo{2307} Char whose ordinal is the octal number, unrestricted
\&   \ex7f     Char whose ordinal is the 2 hex digits, max \exFF
\&   \ex{263a} Char whose ordinal is the hex number, unrestricted
\&   \ecx      Control\-x
\&   \eN{name} A named Unicode character or character sequence
\&   \eN{U+263D} A Unicode character by hex ordinal
\&
\&   \el  Lowercase next character
\&   \eu  Titlecase next character
\&   \eL  Lowercase until \eE
\&   \eU  Uppercase until \eE
\&   \eF  Foldcase until \eE
\&   \eQ  Disable pattern metacharacters until \eE
\&   \eE  End modification
.Ve
.PP
For Titlecase, see \*(L"Titlecase\*(R".
.PP
This one works differently from normal strings:
.PP
.Vb 1
\&   \eb  An assertion, not backspace, except in a character class
.Ve
.SS "\s-1CHARACTER\s0 \s-1CLASSES\s0"
.IX Subsection "CHARACTER CLASSES"
.Vb 4
\&   [amy]    Match \*(Aqa\*(Aq, \*(Aqm\*(Aq or \*(Aqy\*(Aq
\&   [f\-j]    Dash specifies "range"
\&   [f\-j\-]   Dash escaped or at start or end means \*(Aqdash\*(Aq
\&   [^f\-j]   Caret indicates "match any character _except_ these"
.Ve
.PP
The following sequences (except \f(CW\*(C`\eN\*(C'\fR) work within or without a character class.
The first six are locale aware, all are Unicode aware. See perllocale
and perlunicode for details.
.PP
.Vb 10
\&   \ed      A digit
\&   \eD      A nondigit
\&   \ew      A word character
\&   \eW      A non\-word character
\&   \es      A whitespace character
\&   \eS      A non\-whitespace character
\&   \eh      An horizontal whitespace
\&   \eH      A non horizontal whitespace
\&   \eN      A non newline (when not followed by \*(Aq{NAME}\*(Aq; experimental;
\&           not valid in a character class; equivalent to [^\en]; it\*(Aqs
\&           like \*(Aq.\*(Aq without /s modifier)
\&   \ev      A vertical whitespace
\&   \eV      A non vertical whitespace
\&   \eR      A generic newline           (?>\ev|\ex0D\ex0A)
\&
\&   \eC      Match a byte (with Unicode, \*(Aq.\*(Aq matches a character)
\&   \epP     Match P\-named (Unicode) property
\&   \ep{...} Match Unicode property with name longer than 1 character
\&   \ePP     Match non\-P
\&   \eP{...} Match lack of Unicode property with name longer than 1 char
\&   \eX      Match Unicode extended grapheme cluster
.Ve
.PP
\&\s-1POSIX\s0 character classes and their Unicode and Perl equivalents:
.PP
.Vb 3
\&            ASCII\-         Full\-
\&   POSIX    range          range    backslash
\& [[:...:]]  \ep{...}        \ep{...}   sequence    Description
\&
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& alnum   PosixAlnum       XPosixAlnum            Alpha plus Digit
\& alpha   PosixAlpha       XPosixAlpha            Alphabetic characters
\& ascii   ASCII                                   Any ASCII character
\& blank   PosixBlank       XPosixBlank   \eh       Horizontal whitespace;
\&                                                   full\-range also
\&                                                   written as
\&                                                   \ep{HorizSpace} (GNU
\&                                                   extension)
\& cntrl   PosixCntrl       XPosixCntrl            Control characters
\& digit   PosixDigit       XPosixDigit   \ed       Decimal digits
\& graph   PosixGraph       XPosixGraph            Alnum plus Punct
\& lower   PosixLower       XPosixLower            Lowercase characters
\& print   PosixPrint       XPosixPrint            Graph plus Print, but
\&                                                   not any Cntrls
\& punct   PosixPunct       XPosixPunct            Punctuation and Symbols
\&                                                   in ASCII\-range; just
\&                                                   punct outside it
\& space   PosixSpace       XPosixSpace            [\es\ecK]
\&         PerlSpace        XPerlSpace    \es       Perl\*(Aqs whitespace def\*(Aqn
\& upper   PosixUpper       XPosixUpper            Uppercase characters
\& word    PosixWord        XPosixWord    \ew       Alnum + Unicode marks +
\&                                                   connectors, like \*(Aq_\*(Aq
\&                                                   (Perl extension)
\& xdigit  ASCII_Hex_Digit  XPosixDigit            Hexadecimal digit,
\&                                                    ASCII\-range is
\&                                                    [0\-9A\-Fa\-f]
.Ve
.PP
Also, various synonyms like \f(CW\*(C`\ep{Alpha}\*(C'\fR for \f(CW\*(C`\ep{XPosixAlpha}\*(C'\fR; all listed
in \*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops
.PP
Within a character class:
.PP
.Vb 3
\&    POSIX      traditional   Unicode
\&  [:digit:]       \ed        \ep{Digit}
\&  [:^digit:]      \eD        \eP{Digit}
.Ve
.SS "\s-1ANCHORS\s0"
.IX Subsection "ANCHORS"
All are zero-width assertions.
.PP
.Vb 9
\&   ^  Match string start (or line, if /m is used)
\&   $  Match string end (or line, if /m is used) or before newline
\&   \eb Match word boundary (between \ew and \eW)
\&   \eB Match except at word boundary (between \ew and \ew or \eW and \eW)
\&   \eA Match string start (regardless of /m)
\&   \eZ Match string end (before optional newline)
\&   \ez Match absolute string end
\&   \eG Match where previous m//g left off
\&   \eK Keep the stuff left of the \eK, don\*(Aqt include it in $&
.Ve
.SS "\s-1QUANTIFIERS\s0"
.IX Subsection "QUANTIFIERS"
Quantifiers are greedy by default and match the \fBlongest\fR leftmost.
.PP
.Vb 9
\&   Maximal Minimal Possessive Allowed range
\&   \-\-\-\-\-\-\- \-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-
\&   {n,m}   {n,m}?  {n,m}+     Must occur at least n times
\&                              but no more than m times
\&   {n,}    {n,}?   {n,}+      Must occur at least n times
\&   {n}     {n}?    {n}+       Must occur exactly n times
\&   *       *?      *+         0 or more times (same as {0,})
\&   +       +?      ++         1 or more times (same as {1,})
\&   ?       ??      ?+         0 or 1 time (same as {0,1})
.Ve
.PP
The possessive forms (new in Perl 5.10) prevent backtracking: what gets
matched by a pattern with a possessive quantifier will not be backtracked
into, even if that causes the whole match to fail.
.PP
There is no quantifier \f(CW\*(C`{,n}\*(C'\fR. That's interpreted as a literal string.
.SS "\s-1EXTENDED\s0 \s-1CONSTRUCTS\s0"
.IX Subsection "EXTENDED CONSTRUCTS"
.Vb 10
\&   (?#text)          A comment
\&   (?:...)           Groups subexpressions without capturing (cluster)
\&   (?pimsx\-imsx:...) Enable/disable option (as per m// modifiers)
\&   (?=...)           Zero\-width positive lookahead assertion
\&   (?!...)           Zero\-width negative lookahead assertion
\&   (?<=...)          Zero\-width positive lookbehind assertion
\&   (?<!...)          Zero\-width negative lookbehind assertion
\&   (?>...)           Grab what we can, prohibit backtracking
\&   (?|...)           Branch reset
\&   (?<name>...)      Named capture
\&   (?\*(Aqname\*(Aq...)      Named capture
\&   (?P<name>...)     Named capture (python syntax)
\&   (?{ code })       Embedded code, return value becomes $^R
\&   (??{ code })      Dynamic regex, return value used as regex
\&   (?N)              Recurse into subpattern number N
\&   (?\-N), (?+N)      Recurse into Nth previous/next subpattern
\&   (?R), (?0)        Recurse at the beginning of the whole pattern
\&   (?&name)          Recurse into a named subpattern
\&   (?P>name)         Recurse into a named subpattern (python syntax)
\&   (?(cond)yes|no)
\&   (?(cond)yes)      Conditional expression, where "cond" can be:
\&                     (?=pat)   look\-ahead
\&                     (?!pat)   negative look\-ahead
\&                     (?<=pat)  look\-behind
\&                     (?<!pat)  negative look\-behind
\&                     (N)       subpattern N has matched something
\&                     (<name>)  named subpattern has matched something
\&                     (\*(Aqname\*(Aq)  named subpattern has matched something
\&                     (?{code}) code condition
\&                     (R)       true if recursing
\&                     (RN)      true if recursing into Nth subpattern
\&                     (R&name)  true if recursing into named subpattern
\&                     (DEFINE)  always false, no no\-pattern allowed
.Ve
.SS "\s-1VARIABLES\s0"
.IX Subsection "VARIABLES"
.Vb 1
\&   $_    Default variable for operators to use
\&
\&   $\`    Everything prior to matched string
\&   $&    Entire matched string
\&   $\*(Aq    Everything after to matched string
\&
\&   ${^PREMATCH}   Everything prior to matched string
\&   ${^MATCH}      Entire matched string
\&   ${^POSTMATCH}  Everything after to matched string
.Ve
.PP
The use of \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR or \f(CW\*(C`$\*(Aq\*(C'\fR will slow down \fBall\fR regex use
within your program. Consult perlvar for \f(CW\*(C`@\-\*(C'\fR
to see equivalent expressions that won't cause slow down.
See also Devel::SawAmpersand. Starting with Perl 5.10, you
can also use the equivalent variables \f(CW\*(C`${^PREMATCH}\*(C'\fR, \f(CW\*(C`${^MATCH}\*(C'\fR
and \f(CW\*(C`${^POSTMATCH}\*(C'\fR, but for them to be defined, you have to
specify the \f(CW\*(C`/p\*(C'\fR (preserve) modifier on your regular expression.
.PP
.Vb 8
\&   $1, $2 ...  hold the Xth captured expr
\&   $+    Last parenthesized pattern match
\&   $^N   Holds the most recently closed capture
\&   $^R   Holds the result of the last (?{...}) expr
\&   @\-    Offsets of starts of groups. $\-[0] holds start of whole match
\&   @+    Offsets of ends of groups. $+[0] holds end of whole match
\&   %+    Named capture groups
\&   %\-    Named capture groups, as array refs
.Ve
.PP
Captured groups are numbered according to their \fIopening\fR paren.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
.Vb 5
\&   lc          Lowercase a string
\&   lcfirst     Lowercase first char of a string
\&   uc          Uppercase a string
\&   ucfirst     Titlecase first char of a string
\&   fc          Foldcase a string
\&
\&   pos         Return or set current match position
\&   quotemeta   Quote metacharacters
\&   reset       Reset ?pattern? status
\&   study       Analyze string for optimizing matching
\&
\&   split       Use a regex to split a string into parts
.Ve
.PP
The first five of these are like the escape sequences \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\el\*(C'\fR,
\&\f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, and \f(CW\*(C`\eF\*(C'\fR.  For Titlecase, see \*(L"Titlecase\*(R"; For
Foldcase, see \*(L"Foldcase\*(R".
.SS "\s-1TERMINOLOGY\s0"
.IX Subsection "TERMINOLOGY"
\fITitlecase\fR
.IX Subsection "Titlecase"
.PP
Unicode concept which most often is equal to uppercase, but for
certain characters like the German \*(L"sharp s\*(R" there is a difference.
.PP
\fIFoldcase\fR
.IX Subsection "Foldcase"
.PP
Unicode form that is useful when comparing strings regardless of case,
as certain characters have compex one-to-many case mappings. Primarily a
variant of lowercase.
.SH "AUTHOR"
.IX Header "AUTHOR"
Iain Truskett. Updated by the Perl 5 Porters.
.PP
This document may be distributed under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
perlretut for a tutorial on regular expressions.
.IP "\(bu" 4
perlrequick for a rapid tutorial.
.IP "\(bu" 4
perlre for more details.
.IP "\(bu" 4
perlvar for details on the variables.
.IP "\(bu" 4
perlop for details on the operators.
.IP "\(bu" 4
perlfunc for details on the functions.
.IP "\(bu" 4
perlfaq6 for FAQs on regular expressions.
.IP "\(bu" 4
perlrebackslash for a reference on backslash sequences.
.IP "\(bu" 4
perlrecharclass for a reference on character classes.
.IP "\(bu" 4
The re module to alter behaviour and aid
debugging.
.IP "\(bu" 4
\&\*(L"Debugging Regular Expressions\*(R" in perldebug
.IP "\(bu" 4
perluniintro, perlunicode, charnames and perllocale
for details on regexes and internationalisation.
.IP "\(bu" 4
\&\fIMastering Regular Expressions\fR by Jeffrey Friedl
(\fIhttp://oreilly.com/catalog/9780596528126/\fR) for a thorough grounding and
reference on the topic.
.SH "THANKS"
.IX Header "THANKS"
David P.C. Wollmann,
Richard Soderberg,
Sean M. Burke,
Tom Christiansen,
Jim Cromie,
and
Jeffrey Goff
for useful advice.
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlreref5.18.1                              0100644 0001750 0001750 00000050061 12566207444 023246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREREF 1"
.TH PERLREREF 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreref \- Perl Regular Expressions Reference
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a quick reference to Perl's regular expressions.
For full information see perlre and perlop, as well
as the \*(L"\s-1SEE ALSO\*(R"\s0 section in this document.
.SS "\s-1OPERATORS\s0"
.IX Subsection "OPERATORS"
\&\f(CW\*(C`=~\*(C'\fR determines to which variable the regex is applied.
In its absence, \f(CW$_\fR is used.
.PP
.Vb 1
\&    $var =~ /foo/;
.Ve
.PP
\&\f(CW\*(C`!~\*(C'\fR determines to which variable the regex is applied,
and negates the result of the match; it returns
false if the match succeeds, and true if it fails.
.PP
.Vb 1
\&    $var !~ /foo/;
.Ve
.PP
\&\f(CW\*(C`m/pattern/msixpogcdual\*(C'\fR searches a string for a pattern match,
applying the given options.
.PP
.Vb 10
\&    m  Multiline mode \- ^ and $ match internal lines
\&    s  match as a Single line \- . matches \en
\&    i  case\-Insensitive
\&    x  eXtended legibility \- free whitespace and comments
\&    p  Preserve a copy of the matched string \-
\&       ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be defined.
\&    o  compile pattern Once
\&    g  Global \- all occurrences
\&    c  don\*(Aqt reset pos on failed matches when using /g
\&    a  restrict \ed, \es, \ew and [:posix:] to match ASCII only
\&    aa (two a\*(Aqs) also /i matches exclude ASCII/non\-ASCII
\&    l  match according to current locale
\&    u  match according to Unicode rules
\&    d  match according to native rules unless something indicates
\&       Unicode
.Ve
.PP
If 'pattern' is an empty string, the last \fIsuccessfully\fR matched
regex is used. Delimiters other than '/' may be used for both this
operator and the following ones. The leading \f(CW\*(C`m\*(C'\fR can be omitted
if the delimiter is '/'.
.PP
\&\f(CW\*(C`qr/pattern/msixpodual\*(C'\fR lets you store a regex in a variable,
or pass one around. Modifiers as for \f(CW\*(C`m//\*(C'\fR, and are stored
within the regex.
.PP
\&\f(CW\*(C`s/pattern/replacement/msixpogcedual\*(C'\fR substitutes matches of
\&'pattern' with 'replacement'. Modifiers as for \f(CW\*(C`m//\*(C'\fR,
with two additions:
.PP
.Vb 2
\&    e  Evaluate \*(Aqreplacement\*(Aq as an expression
\&    r  Return substitution and leave the original string untouched.
.Ve
.PP
\&'e' may be specified multiple times. 'replacement' is interpreted
as a double quoted string unless a single-quote (\f(CW\*(C`\*(Aq\*(C'\fR) is the delimiter.
.PP
\&\f(CW\*(C`?pattern?\*(C'\fR is like \f(CW\*(C`m/pattern/\*(C'\fR but matches only once. No alternate
delimiters can be used.  Must be reset with \fIreset()\fR.
.SS "\s-1SYNTAX\s0"
.IX Subsection "SYNTAX"
.Vb 10
\& \e       Escapes the character immediately following it
\& .       Matches any single character except a newline (unless /s is
\&           used)
\& ^       Matches at the beginning of the string (or line, if /m is used)
\& $       Matches at the end of the string (or line, if /m is used)
\& *       Matches the preceding element 0 or more times
\& +       Matches the preceding element 1 or more times
\& ?       Matches the preceding element 0 or 1 times
\& {...}   Specifies a range of occurrences for the element preceding it
\& [...]   Matches any one of the characters contained within the brackets
\& (...)   Groups subexpressions for capturing to $1, $2...
\& (?:...) Groups subexpressions without capturing (cluster)
\& |       Matches either the subexpression preceding or following it
\& \eg1 or \eg{1}, \eg2 ...    Matches the text from the Nth group
\& \e1, \e2, \e3 ...           Matches the text from the Nth group
\& \eg\-1 or \eg{\-1}, \eg\-2 ... Matches the text from the Nth previous group
\& \eg{name}     Named backreference
\& \ek<name>     Named backreference
\& \ek\*(Aqname\*(Aq     Named backreference
\& (?P=name)    Named backreference (python syntax)
.Ve
.SS "\s-1ESCAPE SEQUENCES\s0"
.IX Subsection "ESCAPE SEQUENCES"
These work as in normal strings.
.PP
.Vb 10
\&   \ea       Alarm (beep)
\&   \ee       Escape
\&   \ef       Formfeed
\&   \en       Newline
\&   \er       Carriage return
\&   \et       Tab
\&   \e037     Char whose ordinal is the 3 octal digits, max \e777
\&   \eo{2307} Char whose ordinal is the octal number, unrestricted
\&   \ex7f     Char whose ordinal is the 2 hex digits, max \exFF
\&   \ex{263a} Char whose ordinal is the hex number, unrestricted
\&   \ecx      Control\-x
\&   \eN{name} A named Unicode character or character sequence
\&   \eN{U+263D} A Unicode character by hex ordinal
\&
\&   \el  Lowercase next character
\&   \eu  Titlecase next character
\&   \eL  Lowercase until \eE
\&   \eU  Uppercase until \eE
\&   \eF  Foldcase until \eE
\&   \eQ  Disable pattern metacharacters until \eE
\&   \eE  End modification
.Ve
.PP
For Titlecase, see \*(L"Titlecase\*(R".
.PP
This one works differently from normal strings:
.PP
.Vb 1
\&   \eb  An assertion, not backspace, except in a character class
.Ve
.SS "\s-1CHARACTER CLASSES\s0"
.IX Subsection "CHARACTER CLASSES"
.Vb 4
\&   [amy]    Match \*(Aqa\*(Aq, \*(Aqm\*(Aq or \*(Aqy\*(Aq
\&   [f\-j]    Dash specifies "range"
\&   [f\-j\-]   Dash escaped or at start or end means \*(Aqdash\*(Aq
\&   [^f\-j]   Caret indicates "match any character _except_ these"
.Ve
.PP
The following sequences (except \f(CW\*(C`\eN\*(C'\fR) work within or without a character class.
The first six are locale aware, all are Unicode aware. See perllocale
and perlunicode for details.
.PP
.Vb 10
\&   \ed      A digit
\&   \eD      A nondigit
\&   \ew      A word character
\&   \eW      A non\-word character
\&   \es      A whitespace character
\&   \eS      A non\-whitespace character
\&   \eh      An horizontal whitespace
\&   \eH      A non horizontal whitespace
\&   \eN      A non newline (when not followed by \*(Aq{NAME}\*(Aq;;
\&           not valid in a character class; equivalent to [^\en]; it\*(Aqs
\&           like \*(Aq.\*(Aq without /s modifier)
\&   \ev      A vertical whitespace
\&   \eV      A non vertical whitespace
\&   \eR      A generic newline           (?>\ev|\ex0D\ex0A)
\&
\&   \eC      Match a byte (with Unicode, \*(Aq.\*(Aq matches a character)
\&   \epP     Match P\-named (Unicode) property
\&   \ep{...} Match Unicode property with name longer than 1 character
\&   \ePP     Match non\-P
\&   \eP{...} Match lack of Unicode property with name longer than 1 char
\&   \eX      Match Unicode extended grapheme cluster
.Ve
.PP
\&\s-1POSIX\s0 character classes and their Unicode and Perl equivalents:
.PP
.Vb 3
\&            ASCII\-         Full\-
\&   POSIX    range          range    backslash
\& [[:...:]]  \ep{...}        \ep{...}   sequence    Description
\&
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& alnum   PosixAlnum       XPosixAlnum            Alpha plus Digit
\& alpha   PosixAlpha       XPosixAlpha            Alphabetic characters
\& ascii   ASCII                                   Any ASCII character
\& blank   PosixBlank       XPosixBlank   \eh       Horizontal whitespace;
\&                                                   full\-range also
\&                                                   written as
\&                                                   \ep{HorizSpace} (GNU
\&                                                   extension)
\& cntrl   PosixCntrl       XPosixCntrl            Control characters
\& digit   PosixDigit       XPosixDigit   \ed       Decimal digits
\& graph   PosixGraph       XPosixGraph            Alnum plus Punct
\& lower   PosixLower       XPosixLower            Lowercase characters
\& print   PosixPrint       XPosixPrint            Graph plus Print, but
\&                                                   not any Cntrls
\& punct   PosixPunct       XPosixPunct            Punctuation and Symbols
\&                                                   in ASCII\-range; just
\&                                                   punct outside it
\& space   PosixSpace       XPosixSpace            [\es\ecK]
\&         PerlSpace        XPerlSpace    \es       Perl\*(Aqs whitespace def\*(Aqn
\& upper   PosixUpper       XPosixUpper            Uppercase characters
\& word    PosixWord        XPosixWord    \ew       Alnum + Unicode marks +
\&                                                   connectors, like \*(Aq_\*(Aq
\&                                                   (Perl extension)
\& xdigit  ASCII_Hex_Digit  XPosixDigit            Hexadecimal digit,
\&                                                    ASCII\-range is
\&                                                    [0\-9A\-Fa\-f]
.Ve
.PP
Also, various synonyms like \f(CW\*(C`\ep{Alpha}\*(C'\fR for \f(CW\*(C`\ep{XPosixAlpha}\*(C'\fR; all listed
in \*(L"Properties accessible through \ep{} and \eP{}\*(R" in perluniprops
.PP
Within a character class:
.PP
.Vb 3
\&    POSIX      traditional   Unicode
\&  [:digit:]       \ed        \ep{Digit}
\&  [:^digit:]      \eD        \eP{Digit}
.Ve
.SS "\s-1ANCHORS\s0"
.IX Subsection "ANCHORS"
All are zero-width assertions.
.PP
.Vb 9
\&   ^  Match string start (or line, if /m is used)
\&   $  Match string end (or line, if /m is used) or before newline
\&   \eb Match word boundary (between \ew and \eW)
\&   \eB Match except at word boundary (between \ew and \ew or \eW and \eW)
\&   \eA Match string start (regardless of /m)
\&   \eZ Match string end (before optional newline)
\&   \ez Match absolute string end
\&   \eG Match where previous m//g left off
\&   \eK Keep the stuff left of the \eK, don\*(Aqt include it in $&
.Ve
.SS "\s-1QUANTIFIERS\s0"
.IX Subsection "QUANTIFIERS"
Quantifiers are greedy by default and match the \fBlongest\fR leftmost.
.PP
.Vb 9
\&   Maximal Minimal Possessive Allowed range
\&   \-\-\-\-\-\-\- \-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-
\&   {n,m}   {n,m}?  {n,m}+     Must occur at least n times
\&                              but no more than m times
\&   {n,}    {n,}?   {n,}+      Must occur at least n times
\&   {n}     {n}?    {n}+       Must occur exactly n times
\&   *       *?      *+         0 or more times (same as {0,})
\&   +       +?      ++         1 or more times (same as {1,})
\&   ?       ??      ?+         0 or 1 time (same as {0,1})
.Ve
.PP
The possessive forms (new in Perl 5.10) prevent backtracking: what gets
matched by a pattern with a possessive quantifier will not be backtracked
into, even if that causes the whole match to fail.
.PP
There is no quantifier \f(CW\*(C`{,n}\*(C'\fR. That's interpreted as a literal string.
.SS "\s-1EXTENDED CONSTRUCTS\s0"
.IX Subsection "EXTENDED CONSTRUCTS"
.Vb 10
\&   (?#text)          A comment
\&   (?:...)           Groups subexpressions without capturing (cluster)
\&   (?pimsx\-imsx:...) Enable/disable option (as per m// modifiers)
\&   (?=...)           Zero\-width positive lookahead assertion
\&   (?!...)           Zero\-width negative lookahead assertion
\&   (?<=...)          Zero\-width positive lookbehind assertion
\&   (?<!...)          Zero\-width negative lookbehind assertion
\&   (?>...)           Grab what we can, prohibit backtracking
\&   (?|...)           Branch reset
\&   (?<name>...)      Named capture
\&   (?\*(Aqname\*(Aq...)      Named capture
\&   (?P<name>...)     Named capture (python syntax)
\&   (?{ code })       Embedded code, return value becomes $^R
\&   (??{ code })      Dynamic regex, return value used as regex
\&   (?N)              Recurse into subpattern number N
\&   (?\-N), (?+N)      Recurse into Nth previous/next subpattern
\&   (?R), (?0)        Recurse at the beginning of the whole pattern
\&   (?&name)          Recurse into a named subpattern
\&   (?P>name)         Recurse into a named subpattern (python syntax)
\&   (?(cond)yes|no)
\&   (?(cond)yes)      Conditional expression, where "cond" can be:
\&                     (?=pat)   look\-ahead
\&                     (?!pat)   negative look\-ahead
\&                     (?<=pat)  look\-behind
\&                     (?<!pat)  negative look\-behind
\&                     (N)       subpattern N has matched something
\&                     (<name>)  named subpattern has matched something
\&                     (\*(Aqname\*(Aq)  named subpattern has matched something
\&                     (?{code}) code condition
\&                     (R)       true if recursing
\&                     (RN)      true if recursing into Nth subpattern
\&                     (R&name)  true if recursing into named subpattern
\&                     (DEFINE)  always false, no no\-pattern allowed
.Ve
.SS "\s-1VARIABLES\s0"
.IX Subsection "VARIABLES"
.Vb 1
\&   $_    Default variable for operators to use
\&
\&   $\`    Everything prior to matched string
\&   $&    Entire matched string
\&   $\*(Aq    Everything after to matched string
\&
\&   ${^PREMATCH}   Everything prior to matched string
\&   ${^MATCH}      Entire matched string
\&   ${^POSTMATCH}  Everything after to matched string
.Ve
.PP
The use of \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR or \f(CW\*(C`$\*(Aq\*(C'\fR will slow down \fBall\fR regex use
within your program. Consult perlvar for \f(CW\*(C`@\-\*(C'\fR
to see equivalent expressions that won't cause slow down.
See also Devel::SawAmpersand. Starting with Perl 5.10, you
can also use the equivalent variables \f(CW\*(C`${^PREMATCH}\*(C'\fR, \f(CW\*(C`${^MATCH}\*(C'\fR
and \f(CW\*(C`${^POSTMATCH}\*(C'\fR, but for them to be defined, you have to
specify the \f(CW\*(C`/p\*(C'\fR (preserve) modifier on your regular expression.
.PP
.Vb 8
\&   $1, $2 ...  hold the Xth captured expr
\&   $+    Last parenthesized pattern match
\&   $^N   Holds the most recently closed capture
\&   $^R   Holds the result of the last (?{...}) expr
\&   @\-    Offsets of starts of groups. $\-[0] holds start of whole match
\&   @+    Offsets of ends of groups. $+[0] holds end of whole match
\&   %+    Named capture groups
\&   %\-    Named capture groups, as array refs
.Ve
.PP
Captured groups are numbered according to their \fIopening\fR paren.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
.Vb 5
\&   lc          Lowercase a string
\&   lcfirst     Lowercase first char of a string
\&   uc          Uppercase a string
\&   ucfirst     Titlecase first char of a string
\&   fc          Foldcase a string
\&
\&   pos         Return or set current match position
\&   quotemeta   Quote metacharacters
\&   reset       Reset ?pattern? status
\&   study       Analyze string for optimizing matching
\&
\&   split       Use a regex to split a string into parts
.Ve
.PP
The first five of these are like the escape sequences \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\el\*(C'\fR,
\&\f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, and \f(CW\*(C`\eF\*(C'\fR.  For Titlecase, see \*(L"Titlecase\*(R"; For
Foldcase, see \*(L"Foldcase\*(R".
.SS "\s-1TERMINOLOGY\s0"
.IX Subsection "TERMINOLOGY"
\fITitlecase\fR
.IX Subsection "Titlecase"
.PP
Unicode concept which most often is equal to uppercase, but for
certain characters like the German \*(L"sharp s\*(R" there is a difference.
.PP
\fIFoldcase\fR
.IX Subsection "Foldcase"
.PP
Unicode form that is useful when comparing strings regardless of case,
as certain characters have compex one-to-many case mappings. Primarily a
variant of lowercase.
.SH "AUTHOR"
.IX Header "AUTHOR"
Iain Truskett. Updated by the Perl 5 Porters.
.PP
This document may be distributed under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
perlretut for a tutorial on regular expressions.
.IP "\(bu" 4
perlrequick for a rapid tutorial.
.IP "\(bu" 4
perlre for more details.
.IP "\(bu" 4
perlvar for details on the variables.
.IP "\(bu" 4
perlop for details on the operators.
.IP "\(bu" 4
perlfunc for details on the functions.
.IP "\(bu" 4
perlfaq6 for FAQs on regular expressions.
.IP "\(bu" 4
perlrebackslash for a reference on backslash sequences.
.IP "\(bu" 4
perlrecharclass for a reference on character classes.
.IP "\(bu" 4
The re module to alter behaviour and aid
debugging.
.IP "\(bu" 4
\&\*(L"Debugging Regular Expressions\*(R" in perldebug
.IP "\(bu" 4
perluniintro, perlunicode, charnames and perllocale
for details on regexes and internationalisation.
.IP "\(bu" 4
\&\fIMastering Regular Expressions\fR by Jeffrey Friedl
(\fIhttp://oreilly.com/catalog/9780596528126/\fR) for a thorough grounding and
reference on the topic.
.SH "THANKS"
.IX Header "THANKS"
David P.C. Wollmann,
Richard Soderberg,
Sean M. Burke,
Tom Christiansen,
Jim Cromie,
and
Jeffrey Goff
for useful advice.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlretut.1                                  0100644 0001750 0001750 00000427372 12566207444 023007  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRETUT 1"
.TH PERLRETUT 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlretut \- Perl regular expressions tutorial
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page provides a basic tutorial on understanding, creating and
using regular expressions in Perl.  It serves as a complement to the
reference page on regular expressions perlre.  Regular expressions
are an integral part of the \f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`qr//\*(C'\fR and \f(CW\*(C`split\*(C'\fR
operators and so this tutorial also overlaps with
\&\*(L"Regexp Quote-Like Operators\*(R" in perlop and \*(L"split\*(R" in perlfunc.
.PP
Perl is widely renowned for excellence in text processing, and regular
expressions are one of the big factors behind this fame.  Perl regular
expressions display an efficiency and flexibility unknown in most
other computer languages.  Mastering even the basics of regular
expressions will allow you to manipulate text with surprising ease.
.PP
What is a regular expression?  A regular expression is simply a string
that describes a pattern.  Patterns are in common use these days;
examples are the patterns typed into a search engine to find web pages
and the patterns used to list files in a directory, e.g., \f(CW\*(C`ls *.txt\*(C'\fR
or \f(CW\*(C`dir *.*\*(C'\fR.  In Perl, the patterns described by regular expressions
are used to search strings, extract desired parts of strings, and to
do search and replace operations.
.PP
Regular expressions have the undeserved reputation of being abstract
and difficult to understand.  Regular expressions are constructed using
simple concepts like conditionals and loops and are no more difficult
to understand than the corresponding \f(CW\*(C`if\*(C'\fR conditionals and \f(CW\*(C`while\*(C'\fR
loops in the Perl language itself.  In fact, the main challenge in
learning regular expressions is just getting used to the terse
notation used to express these concepts.
.PP
This tutorial flattens the learning curve by discussing regular
expression concepts, along with their notation, one at a time and with
many examples.  The first part of the tutorial will progress from the
simplest word searches to the basic regular expression concepts.  If
you master the first part, you will have all the tools needed to solve
about 98% of your needs.  The second part of the tutorial is for those
comfortable with the basics and hungry for more power tools.  It
discusses the more advanced regular expression operators and
introduces the latest cutting-edge innovations.
.PP
A note: to save time, 'regular expression' is often abbreviated as
regexp or regex.  Regexp is a more natural abbreviation than regex, but
is harder to pronounce.  The Perl pod documentation is evenly split on
regexp vs regex; in Perl, there is more than one way to abbreviate it.
We'll use regexp in this tutorial.
.SH "Part 1: The basics"
.IX Header "Part 1: The basics"
.SS "Simple word matching"
.IX Subsection "Simple word matching"
The simplest regexp is simply a word, or more generally, a string of
characters.  A regexp consisting of a word matches any string that
contains that word:
.PP
.Vb 1
\&    "Hello World" =~ /World/;  # matches
.Ve
.PP
What is this Perl statement all about? \f(CW"Hello World"\fR is a simple
double-quoted string.  \f(CW\*(C`World\*(C'\fR is the regular expression and the
\&\f(CW\*(C`//\*(C'\fR enclosing \f(CW\*(C`/World/\*(C'\fR tells Perl to search a string for a match.
The operator \f(CW\*(C`=~\*(C'\fR associates the string with the regexp match and
produces a true value if the regexp matched, or false if the regexp
did not match.  In our case, \f(CW\*(C`World\*(C'\fR matches the second word in
\&\f(CW"Hello World"\fR, so the expression is true.  Expressions like this
are useful in conditionals:
.PP
.Vb 6
\&    if ("Hello World" =~ /World/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It doesn\*(Aqt match\en";
\&    }
.Ve
.PP
There are useful variations on this theme.  The sense of the match can
be reversed by using the \f(CW\*(C`!~\*(C'\fR operator:
.PP
.Vb 6
\&    if ("Hello World" !~ /World/) {
\&        print "It doesn\*(Aqt match\en";
\&    }
\&    else {
\&        print "It matches\en";
\&    }
.Ve
.PP
The literal string in the regexp can be replaced by a variable:
.PP
.Vb 7
\&    $greeting = "World";
\&    if ("Hello World" =~ /$greeting/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It doesn\*(Aqt match\en";
\&    }
.Ve
.PP
If you're matching against the special default variable \f(CW$_\fR, the
\&\f(CW\*(C`$_ =~\*(C'\fR part can be omitted:
.PP
.Vb 7
\&    $_ = "Hello World";
\&    if (/World/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It doesn\*(Aqt match\en";
\&    }
.Ve
.PP
And finally, the \f(CW\*(C`//\*(C'\fR default delimiters for a match can be changed
to arbitrary delimiters by putting an \f(CW\*(Aqm\*(Aq\fR out front:
.PP
.Vb 4
\&    "Hello World" =~ m!World!;   # matches, delimited by \*(Aq!\*(Aq
\&    "Hello World" =~ m{World};   # matches, note the matching \*(Aq{}\*(Aq
\&    "/usr/bin/perl" =~ m"/perl"; # matches after \*(Aq/usr/bin\*(Aq,
\&                                 # \*(Aq/\*(Aq becomes an ordinary char
.Ve
.PP
\&\f(CW\*(C`/World/\*(C'\fR, \f(CW\*(C`m!World!\*(C'\fR, and \f(CW\*(C`m{World}\*(C'\fR all represent the
same thing.  When, e.g., the quote (\f(CW\*(C`"\*(C'\fR) is used as a delimiter, the forward
slash \f(CW\*(Aq/\*(Aq\fR becomes an ordinary character and can be used in this regexp
without trouble.
.PP
Let's consider how different regexps would match \f(CW"Hello World"\fR:
.PP
.Vb 4
\&    "Hello World" =~ /world/;  # doesn\*(Aqt match
\&    "Hello World" =~ /o W/;    # matches
\&    "Hello World" =~ /oW/;     # doesn\*(Aqt match
\&    "Hello World" =~ /World /; # doesn\*(Aqt match
.Ve
.PP
The first regexp \f(CW\*(C`world\*(C'\fR doesn't match because regexps are
case-sensitive.  The second regexp matches because the substring
\&\f(CW\*(Aqo\ W\*(Aq\fR occurs in the string \f(CW"Hello\ World"\fR.  The space
character ' ' is treated like any other character in a regexp and is
needed to match in this case.  The lack of a space character is the
reason the third regexp \f(CW\*(AqoW\*(Aq\fR doesn't match.  The fourth regexp
\&\f(CW\*(AqWorld \*(Aq\fR doesn't match because there is a space at the end of the
regexp, but not at the end of the string.  The lesson here is that
regexps must match a part of the string \fIexactly\fR in order for the
statement to be true.
.PP
If a regexp matches in more than one place in the string, Perl will
always match at the earliest possible point in the string:
.PP
.Vb 2
\&    "Hello World" =~ /o/;       # matches \*(Aqo\*(Aq in \*(AqHello\*(Aq
\&    "That hat is red" =~ /hat/; # matches \*(Aqhat\*(Aq in \*(AqThat\*(Aq
.Ve
.PP
With respect to character matching, there are a few more points you
need to know about.   First of all, not all characters can be used 'as
is' in a match.  Some characters, called \fImetacharacters\fR, are reserved
for use in regexp notation.  The metacharacters are
.PP
.Vb 1
\&    {}[]()^$.|*+?\e
.Ve
.PP
The significance of each of these will be explained
in the rest of the tutorial, but for now, it is important only to know
that a metacharacter can be matched by putting a backslash before it:
.PP
.Vb 5
\&    "2+2=4" =~ /2+2/;    # doesn\*(Aqt match, + is a metacharacter
\&    "2+2=4" =~ /2\e+2/;   # matches, \e+ is treated like an ordinary +
\&    "The interval is [0,1)." =~ /[0,1)./     # is a syntax error!
\&    "The interval is [0,1)." =~ /\e[0,1\e)\e./  # matches
\&    "#!/usr/bin/perl" =~ /#!\e/usr\e/bin\e/perl/;  # matches
.Ve
.PP
In the last regexp, the forward slash \f(CW\*(Aq/\*(Aq\fR is also backslashed,
because it is used to delimit the regexp.  This can lead to \s-1LTS
\&\s0(leaning toothpick syndrome), however, and it is often more readable
to change delimiters.
.PP
.Vb 1
\&    "#!/usr/bin/perl" =~ m!#\e!/usr/bin/perl!;  # easier to read
.Ve
.PP
The backslash character \f(CW\*(Aq\e\*(Aq\fR is a metacharacter itself and needs to
be backslashed:
.PP
.Vb 1
\&    \*(AqC:\eWIN32\*(Aq =~ /C:\e\eWIN/;   # matches
.Ve
.PP
In addition to the metacharacters, there are some \s-1ASCII\s0 characters
which don't have printable character equivalents and are instead
represented by \fIescape sequences\fR.  Common examples are \f(CW\*(C`\et\*(C'\fR for a
tab, \f(CW\*(C`\en\*(C'\fR for a newline, \f(CW\*(C`\er\*(C'\fR for a carriage return and \f(CW\*(C`\ea\*(C'\fR for a
bell (or alert).  If your string is better thought of as a sequence of arbitrary
bytes, the octal escape sequence, e.g., \f(CW\*(C`\e033\*(C'\fR, or hexadecimal escape
sequence, e.g., \f(CW\*(C`\ex1B\*(C'\fR may be a more natural representation for your
bytes.  Here are some examples of escapes:
.PP
.Vb 5
\&    "1000\et2000" =~ m(0\et2)   # matches
\&    "1000\en2000" =~ /0\en20/   # matches
\&    "1000\et2000" =~ /\e000\et2/ # doesn\*(Aqt match, "0" ne "\e000"
\&    "cat"   =~ /\eo{143}\ex61\ex74/ # matches in ASCII, but a weird way
\&                                 # to spell cat
.Ve
.PP
If you've been around Perl a while, all this talk of escape sequences
may seem familiar.  Similar escape sequences are used in double-quoted
strings and in fact the regexps in Perl are mostly treated as
double-quoted strings.  This means that variables can be used in
regexps as well.  Just like double-quoted strings, the values of the
variables in the regexp will be substituted in before the regexp is
evaluated for matching purposes.  So we have:
.PP
.Vb 4
\&    $foo = \*(Aqhouse\*(Aq;
\&    \*(Aqhousecat\*(Aq =~ /$foo/;      # matches
\&    \*(Aqcathouse\*(Aq =~ /cat$foo/;   # matches
\&    \*(Aqhousecat\*(Aq =~ /${foo}cat/; # matches
.Ve
.PP
So far, so good.  With the knowledge above you can already perform
searches with just about any literal string regexp you can dream up.
Here is a \fIvery simple\fR emulation of the Unix grep program:
.PP
.Vb 7
\&    % cat > simple_grep
\&    #!/usr/bin/perl
\&    $regexp = shift;
\&    while (<>) {
\&        print if /$regexp/;
\&    }
\&    ^D
\&
\&    % chmod +x simple_grep
\&
\&    % simple_grep abba /usr/dict/words
\&    Babbage
\&    cabbage
\&    cabbages
\&    sabbath
\&    Sabbathize
\&    Sabbathizes
\&    sabbatical
\&    scabbard
\&    scabbards
.Ve
.PP
This program is easy to understand.  \f(CW\*(C`#!/usr/bin/perl\*(C'\fR is the standard
way to invoke a perl program from the shell.
\&\f(CW\*(C`$regexp\ =\ shift;\*(C'\fR saves the first command line argument as the
regexp to be used, leaving the rest of the command line arguments to
be treated as files.  \f(CW\*(C`while\ (<>)\*(C'\fR loops over all the lines in
all the files.  For each line, \f(CW\*(C`print\ if\ /$regexp/;\*(C'\fR prints the
line if the regexp matches the line.  In this line, both \f(CW\*(C`print\*(C'\fR and
\&\f(CW\*(C`/$regexp/\*(C'\fR use the default variable \f(CW$_\fR implicitly.
.PP
With all of the regexps above, if the regexp matched anywhere in the
string, it was considered a match.  Sometimes, however, we'd like to
specify \fIwhere\fR in the string the regexp should try to match.  To do
this, we would use the \fIanchor\fR metacharacters \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR.  The
anchor \f(CW\*(C`^\*(C'\fR means match at the beginning of the string and the anchor
\&\f(CW\*(C`$\*(C'\fR means match at the end of the string, or before a newline at the
end of the string.  Here is how they are used:
.PP
.Vb 4
\&    "housekeeper" =~ /keeper/;    # matches
\&    "housekeeper" =~ /^keeper/;   # doesn\*(Aqt match
\&    "housekeeper" =~ /keeper$/;   # matches
\&    "housekeeper\en" =~ /keeper$/; # matches
.Ve
.PP
The second regexp doesn't match because \f(CW\*(C`^\*(C'\fR constrains \f(CW\*(C`keeper\*(C'\fR to
match only at the beginning of the string, but \f(CW"housekeeper"\fR has
keeper starting in the middle.  The third regexp does match, since the
\&\f(CW\*(C`$\*(C'\fR constrains \f(CW\*(C`keeper\*(C'\fR to match only at the end of the string.
.PP
When both \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR are used at the same time, the regexp has to
match both the beginning and the end of the string, i.e., the regexp
matches the whole string.  Consider
.PP
.Vb 3
\&    "keeper" =~ /^keep$/;      # doesn\*(Aqt match
\&    "keeper" =~ /^keeper$/;    # matches
\&    ""       =~ /^$/;          # ^$ matches an empty string
.Ve
.PP
The first regexp doesn't match because the string has more to it than
\&\f(CW\*(C`keep\*(C'\fR.  Since the second regexp is exactly the string, it
matches.  Using both \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR in a regexp forces the complete
string to match, so it gives you complete control over which strings
match and which don't.  Suppose you are looking for a fellow named
bert, off in a string by himself:
.PP
.Vb 1
\&    "dogbert" =~ /bert/;   # matches, but not what you want
\&
\&    "dilbert" =~ /^bert/;  # doesn\*(Aqt match, but ..
\&    "bertram" =~ /^bert/;  # matches, so still not good enough
\&
\&    "bertram" =~ /^bert$/; # doesn\*(Aqt match, good
\&    "dilbert" =~ /^bert$/; # doesn\*(Aqt match, good
\&    "bert"    =~ /^bert$/; # matches, perfect
.Ve
.PP
Of course, in the case of a literal string, one could just as easily
use the string comparison \f(CW\*(C`$string\ eq\ \*(Aqbert\*(Aq\*(C'\fR and it would be
more efficient.   The  \f(CW\*(C`^...$\*(C'\fR regexp really becomes useful when we
add in the more powerful regexp tools below.
.SS "Using character classes"
.IX Subsection "Using character classes"
Although one can already do quite a lot with the literal string
regexps above, we've only scratched the surface of regular expression
technology.  In this and subsequent sections we will introduce regexp
concepts (and associated metacharacter notations) that will allow a
regexp to represent not just a single character sequence, but a \fIwhole
class\fR of them.
.PP
One such concept is that of a \fIcharacter class\fR.  A character class
allows a set of possible characters, rather than just a single
character, to match at a particular point in a regexp.  Character
classes are denoted by brackets \f(CW\*(C`[...]\*(C'\fR, with the set of characters
to be possibly matched inside.  Here are some examples:
.PP
.Vb 4
\&    /cat/;       # matches \*(Aqcat\*(Aq
\&    /[bcr]at/;   # matches \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&    /item[0123456789]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    "abc" =~ /[cab]/;    # matches \*(Aqa\*(Aq
.Ve
.PP
In the last statement, even though \f(CW\*(Aqc\*(Aq\fR is the first character in
the class, \f(CW\*(Aqa\*(Aq\fR matches because the first character position in the
string is the earliest point at which the regexp can match.
.PP
.Vb 2
\&    /[yY][eE][sS]/;      # match \*(Aqyes\*(Aq in a case\-insensitive way
\&                         # \*(Aqyes\*(Aq, \*(AqYes\*(Aq, \*(AqYES\*(Aq, etc.
.Ve
.PP
This regexp displays a common task: perform a case-insensitive
match.  Perl provides a way of avoiding all those brackets by simply
appending an \f(CW\*(Aqi\*(Aq\fR to the end of the match.  Then \f(CW\*(C`/[yY][eE][sS]/;\*(C'\fR
can be rewritten as \f(CW\*(C`/yes/i;\*(C'\fR.  The \f(CW\*(Aqi\*(Aq\fR stands for
case-insensitive and is an example of a \fImodifier\fR of the matching
operation.  We will meet other modifiers later in the tutorial.
.PP
We saw in the section above that there were ordinary characters, which
represented themselves, and special characters, which needed a
backslash \f(CW\*(C`\e\*(C'\fR to represent themselves.  The same is true in a
character class, but the sets of ordinary and special characters
inside a character class are different than those outside a character
class.  The special characters for a character class are \f(CW\*(C`\-]\e^$\*(C'\fR (and
the pattern delimiter, whatever it is).
\&\f(CW\*(C`]\*(C'\fR is special because it denotes the end of a character class.  \f(CW\*(C`$\*(C'\fR is
special because it denotes a scalar variable.  \f(CW\*(C`\e\*(C'\fR is special because
it is used in escape sequences, just like above.  Here is how the
special characters \f(CW\*(C`]$\e\*(C'\fR are handled:
.PP
.Vb 5
\&   /[\e]c]def/; # matches \*(Aq]def\*(Aq or \*(Aqcdef\*(Aq
\&   $x = \*(Aqbcr\*(Aq;
\&   /[$x]at/;   # matches \*(Aqbat\*(Aq, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&   /[\e$x]at/;  # matches \*(Aq$at\*(Aq or \*(Aqxat\*(Aq
\&   /[\e\e$x]at/; # matches \*(Aq\eat\*(Aq, \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
.Ve
.PP
The last two are a little tricky.  In \f(CW\*(C`[\e$x]\*(C'\fR, the backslash protects
the dollar sign, so the character class has two members \f(CW\*(C`$\*(C'\fR and \f(CW\*(C`x\*(C'\fR.
In \f(CW\*(C`[\e\e$x]\*(C'\fR, the backslash is protected, so \f(CW$x\fR is treated as a
variable and substituted in double quote fashion.
.PP
The special character \f(CW\*(Aq\-\*(Aq\fR acts as a range operator within character
classes, so that a contiguous set of characters can be written as a
range.  With ranges, the unwieldy \f(CW\*(C`[0123456789]\*(C'\fR and \f(CW\*(C`[abc...xyz]\*(C'\fR
become the svelte \f(CW\*(C`[0\-9]\*(C'\fR and \f(CW\*(C`[a\-z]\*(C'\fR.  Some examples are
.PP
.Vb 6
\&    /item[0\-9]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    /[0\-9bx\-z]aa/;  # matches \*(Aq0aa\*(Aq, ..., \*(Aq9aa\*(Aq,
\&                    # \*(Aqbaa\*(Aq, \*(Aqxaa\*(Aq, \*(Aqyaa\*(Aq, or \*(Aqzaa\*(Aq
\&    /[0\-9a\-fA\-F]/;  # matches a hexadecimal digit
\&    /[0\-9a\-zA\-Z_]/; # matches a "word" character,
\&                    # like those in a Perl variable name
.Ve
.PP
If \f(CW\*(Aq\-\*(Aq\fR is the first or last character in a character class, it is
treated as an ordinary character; \f(CW\*(C`[\-ab]\*(C'\fR, \f(CW\*(C`[ab\-]\*(C'\fR and \f(CW\*(C`[a\e\-b]\*(C'\fR are
all equivalent.
.PP
The special character \f(CW\*(C`^\*(C'\fR in the first position of a character class
denotes a \fInegated character class\fR, which matches any character but
those in the brackets.  Both \f(CW\*(C`[...]\*(C'\fR and \f(CW\*(C`[^...]\*(C'\fR must match a
character, or the match fails.  Then
.PP
.Vb 4
\&    /[^a]at/;  # doesn\*(Aqt match \*(Aqaat\*(Aq or \*(Aqat\*(Aq, but matches
\&               # all other \*(Aqbat\*(Aq, \*(Aqcat, \*(Aq0at\*(Aq, \*(Aq%at\*(Aq, etc.
\&    /[^0\-9]/;  # matches a non\-numeric character
\&    /[a^]at/;  # matches \*(Aqaat\*(Aq or \*(Aq^at\*(Aq; here \*(Aq^\*(Aq is ordinary
.Ve
.PP
Now, even \f(CW\*(C`[0\-9]\*(C'\fR can be a bother to write multiple times, so in the
interest of saving keystrokes and making regexps more readable, Perl
has several abbreviations for common character classes, as shown below.
Since the introduction of Unicode, unless the \f(CW\*(C`//a\*(C'\fR modifier is in
effect, these character classes match more than just a few characters in
the \s-1ASCII\s0 range.
.IP "\(bu" 4
\&\ed matches a digit, not just [0\-9] but also digits from non-roman scripts
.IP "\(bu" 4
\&\es matches a whitespace character, the set [\e \et\er\en\ef] and others
.IP "\(bu" 4
\&\ew matches a word character (alphanumeric or _), not just [0\-9a\-zA\-Z_]
but also digits and characters from non-roman scripts
.IP "\(bu" 4
\&\eD is a negated \ed; it represents any other character than a digit, or [^\ed]
.IP "\(bu" 4
\&\eS is a negated \es; it represents any non-whitespace character [^\es]
.IP "\(bu" 4
\&\eW is a negated \ew; it represents any non-word character [^\ew]
.IP "\(bu" 4
The period '.' matches any character but \*(L"\en\*(R" (unless the modifier \f(CW\*(C`//s\*(C'\fR is
in effect, as explained below).
.IP "\(bu" 4
\&\eN, like the period, matches any character but \*(L"\en\*(R", but it does so
regardless of whether the modifier \f(CW\*(C`//s\*(C'\fR is in effect.
.PP
The \f(CW\*(C`//a\*(C'\fR modifier, available starting in Perl 5.14,  is used to
restrict the matches of \ed, \es, and \ew to just those in the \s-1ASCII\s0 range.
It is useful to keep your program from being needlessly exposed to full
Unicode (and its accompanying security considerations) when all you want
is to process English-like text.  (The \*(L"a\*(R" may be doubled, \f(CW\*(C`//aa\*(C'\fR, to
provide even more restrictions, preventing case-insensitive matching of
\&\s-1ASCII\s0 with non-ASCII characters; otherwise a Unicode \*(L"Kelvin Sign\*(R"
would caselessly match a \*(L"k\*(R" or \*(L"K\*(R".)
.PP
The \f(CW\*(C`\ed\es\ew\eD\eS\eW\*(C'\fR abbreviations can be used both inside and outside
of character classes.  Here are some in use:
.PP
.Vb 7
\&    /\ed\ed:\ed\ed:\ed\ed/; # matches a hh:mm:ss time format
\&    /[\ed\es]/;         # matches any digit or whitespace character
\&    /\ew\eW\ew/;         # matches a word char, followed by a
\&                      # non\-word char, followed by a word char
\&    /..rt/;           # matches any two chars, followed by \*(Aqrt\*(Aq
\&    /end\e./;          # matches \*(Aqend.\*(Aq
\&    /end[.]/;         # same thing, matches \*(Aqend.\*(Aq
.Ve
.PP
Because a period is a metacharacter, it needs to be escaped to match
as an ordinary period. Because, for example, \f(CW\*(C`\ed\*(C'\fR and \f(CW\*(C`\ew\*(C'\fR are sets
of characters, it is incorrect to think of \f(CW\*(C`[^\ed\ew]\*(C'\fR as \f(CW\*(C`[\eD\eW]\*(C'\fR; in
fact \f(CW\*(C`[^\ed\ew]\*(C'\fR is the same as \f(CW\*(C`[^\ew]\*(C'\fR, which is the same as
\&\f(CW\*(C`[\eW]\*(C'\fR. Think DeMorgan's laws.
.PP
An anchor useful in basic regexps is the \fIword anchor\fR
\&\f(CW\*(C`\eb\*(C'\fR.  This matches a boundary between a word character and a non-word
character \f(CW\*(C`\ew\eW\*(C'\fR or \f(CW\*(C`\eW\ew\*(C'\fR:
.PP
.Vb 5
\&    $x = "Housecat catenates house and cat";
\&    $x =~ /cat/;    # matches cat in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat/;  # matches cat in \*(Aqcatenates\*(Aq
\&    $x =~ /cat\eb/;  # matches cat in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq at end of string
.Ve
.PP
Note in the last example, the end of the string is considered a word
boundary.
.PP
You might wonder why \f(CW\*(Aq.\*(Aq\fR matches everything but \f(CW"\en"\fR \- why not
every character? The reason is that often one is matching against
lines and would like to ignore the newline characters.  For instance,
while the string \f(CW"\en"\fR represents one line, we would like to think
of it as empty.  Then
.PP
.Vb 2
\&    ""   =~ /^$/;    # matches
\&    "\en" =~ /^$/;    # matches, $ anchors before "\en"
\&
\&    ""   =~ /./;      # doesn\*(Aqt match; it needs a char
\&    ""   =~ /^.$/;    # doesn\*(Aqt match; it needs a char
\&    "\en" =~ /^.$/;    # doesn\*(Aqt match; it needs a char other than "\en"
\&    "a"  =~ /^.$/;    # matches
\&    "a\en"  =~ /^.$/;  # matches, $ anchors before "\en"
.Ve
.PP
This behavior is convenient, because we usually want to ignore
newlines when we count and match characters in a line.  Sometimes,
however, we want to keep track of newlines.  We might even want \f(CW\*(C`^\*(C'\fR
and \f(CW\*(C`$\*(C'\fR to anchor at the beginning and end of lines within the
string, rather than just the beginning and end of the string.  Perl
allows us to choose between ignoring and paying attention to newlines
by using the \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//m\*(C'\fR modifiers.  \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//m\*(C'\fR stand for
single line and multi-line and they determine whether a string is to
be treated as one continuous string, or as a set of lines.  The two
modifiers affect two aspects of how the regexp is interpreted: 1) how
the \f(CW\*(Aq.\*(Aq\fR character class is defined, and 2) where the anchors \f(CW\*(C`^\*(C'\fR
and \f(CW\*(C`$\*(C'\fR are able to match.  Here are the four possible combinations:
.IP "\(bu" 4
no modifiers (//): Default behavior.  \f(CW\*(Aq.\*(Aq\fR matches any character
except \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR matches only at the beginning of the string and
\&\f(CW\*(C`$\*(C'\fR matches only at the end or before a newline at the end.
.IP "\(bu" 4
s modifier (//s): Treat string as a single long line.  \f(CW\*(Aq.\*(Aq\fR matches
any character, even \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR matches only at the beginning of
the string and \f(CW\*(C`$\*(C'\fR matches only at the end or before a newline at the
end.
.IP "\(bu" 4
m modifier (//m): Treat string as a set of multiple lines.  \f(CW\*(Aq.\*(Aq\fR
matches any character except \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR are able to match
at the start or end of \fIany\fR line within the string.
.IP "\(bu" 4
both s and m modifiers (//sm): Treat string as a single long line, but
detect multiple lines.  \f(CW\*(Aq.\*(Aq\fR matches any character, even
\&\f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR, however, are able to match at the start or end
of \fIany\fR line within the string.
.PP
Here are examples of \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//m\*(C'\fR in action:
.PP
.Vb 1
\&    $x = "There once was a girl\enWho programmed in Perl\en";
\&
\&    $x =~ /^Who/;   # doesn\*(Aqt match, "Who" not at start of string
\&    $x =~ /^Who/s;  # doesn\*(Aqt match, "Who" not at start of string
\&    $x =~ /^Who/m;  # matches, "Who" at start of second line
\&    $x =~ /^Who/sm; # matches, "Who" at start of second line
\&
\&    $x =~ /girl.Who/;   # doesn\*(Aqt match, "." doesn\*(Aqt match "\en"
\&    $x =~ /girl.Who/s;  # matches, "." matches "\en"
\&    $x =~ /girl.Who/m;  # doesn\*(Aqt match, "." doesn\*(Aqt match "\en"
\&    $x =~ /girl.Who/sm; # matches, "." matches "\en"
.Ve
.PP
Most of the time, the default behavior is what is wanted, but \f(CW\*(C`//s\*(C'\fR and
\&\f(CW\*(C`//m\*(C'\fR are occasionally very useful.  If \f(CW\*(C`//m\*(C'\fR is being used, the start
of the string can still be matched with \f(CW\*(C`\eA\*(C'\fR and the end of the string
can still be matched with the anchors \f(CW\*(C`\eZ\*(C'\fR (matches both the end and
the newline before, like \f(CW\*(C`$\*(C'\fR), and \f(CW\*(C`\ez\*(C'\fR (matches only the end):
.PP
.Vb 2
\&    $x =~ /^Who/m;   # matches, "Who" at start of second line
\&    $x =~ /\eAWho/m;  # doesn\*(Aqt match, "Who" is not at start of string
\&
\&    $x =~ /girl$/m;  # matches, "girl" at end of first line
\&    $x =~ /girl\eZ/m; # doesn\*(Aqt match, "girl" is not at end of string
\&
\&    $x =~ /Perl\eZ/m; # matches, "Perl" is at newline before end
\&    $x =~ /Perl\ez/m; # doesn\*(Aqt match, "Perl" is not at end of string
.Ve
.PP
We now know how to create choices among classes of characters in a
regexp.  What about choices among words or character strings? Such
choices are described in the next section.
.SS "Matching this or that"
.IX Subsection "Matching this or that"
Sometimes we would like our regexp to be able to match different
possible words or character strings.  This is accomplished by using
the \fIalternation\fR metacharacter \f(CW\*(C`|\*(C'\fR.  To match \f(CW\*(C`dog\*(C'\fR or \f(CW\*(C`cat\*(C'\fR, we
form the regexp \f(CW\*(C`dog|cat\*(C'\fR.  As before, Perl will try to match the
regexp at the earliest possible point in the string.  At each
character position, Perl will first try to match the first
alternative, \f(CW\*(C`dog\*(C'\fR.  If \f(CW\*(C`dog\*(C'\fR doesn't match, Perl will then try the
next alternative, \f(CW\*(C`cat\*(C'\fR.  If \f(CW\*(C`cat\*(C'\fR doesn't match either, then the
match fails and Perl moves to the next position in the string.  Some
examples:
.PP
.Vb 2
\&    "cats and dogs" =~ /cat|dog|bird/;  # matches "cat"
\&    "cats and dogs" =~ /dog|cat|bird/;  # matches "cat"
.Ve
.PP
Even though \f(CW\*(C`dog\*(C'\fR is the first alternative in the second regexp,
\&\f(CW\*(C`cat\*(C'\fR is able to match earlier in the string.
.PP
.Vb 2
\&    "cats"          =~ /c|ca|cat|cats/; # matches "c"
\&    "cats"          =~ /cats|cat|ca|c/; # matches "cats"
.Ve
.PP
Here, all the alternatives match at the first string position, so the
first alternative is the one that matches.  If some of the
alternatives are truncations of the others, put the longest ones first
to give them a chance to match.
.PP
.Vb 2
\&    "cab" =~ /a|b|c/ # matches "c"
\&                     # /a|b|c/ == /[abc]/
.Ve
.PP
The last example points out that character classes are like
alternations of characters.  At a given character position, the first
alternative that allows the regexp match to succeed will be the one
that matches.
.SS "Grouping things and hierarchical matching"
.IX Subsection "Grouping things and hierarchical matching"
Alternation allows a regexp to choose among alternatives, but by
itself it is unsatisfying.  The reason is that each alternative is a whole
regexp, but sometime we want alternatives for just part of a
regexp.  For instance, suppose we want to search for housecats or
housekeepers.  The regexp \f(CW\*(C`housecat|housekeeper\*(C'\fR fits the bill, but is
inefficient because we had to type \f(CW\*(C`house\*(C'\fR twice.  It would be nice to
have parts of the regexp be constant, like \f(CW\*(C`house\*(C'\fR, and some
parts have alternatives, like \f(CW\*(C`cat|keeper\*(C'\fR.
.PP
The \fIgrouping\fR metacharacters \f(CW\*(C`()\*(C'\fR solve this problem.  Grouping
allows parts of a regexp to be treated as a single unit.  Parts of a
regexp are grouped by enclosing them in parentheses.  Thus we could solve
the \f(CW\*(C`housecat|housekeeper\*(C'\fR by forming the regexp as
\&\f(CW\*(C`house(cat|keeper)\*(C'\fR.  The regexp \f(CW\*(C`house(cat|keeper)\*(C'\fR means match
\&\f(CW\*(C`house\*(C'\fR followed by either \f(CW\*(C`cat\*(C'\fR or \f(CW\*(C`keeper\*(C'\fR.  Some more examples
are
.PP
.Vb 4
\&    /(a|b)b/;    # matches \*(Aqab\*(Aq or \*(Aqbb\*(Aq
\&    /(ac|b)b/;   # matches \*(Aqacb\*(Aq or \*(Aqbb\*(Aq
\&    /(^a|b)c/;   # matches \*(Aqac\*(Aq at start of string or \*(Aqbc\*(Aq anywhere
\&    /(a|[bc])d/; # matches \*(Aqad\*(Aq, \*(Aqbd\*(Aq, or \*(Aqcd\*(Aq
\&
\&    /house(cat|)/;  # matches either \*(Aqhousecat\*(Aq or \*(Aqhouse\*(Aq
\&    /house(cat(s|)|)/;  # matches either \*(Aqhousecats\*(Aq or \*(Aqhousecat\*(Aq or
\&                        # \*(Aqhouse\*(Aq.  Note groups can be nested.
\&
\&    /(19|20|)\ed\ed/;  # match years 19xx, 20xx, or the Y2K problem, xx
\&    "20" =~ /(19|20|)\ed\ed/;  # matches the null alternative \*(Aq()\ed\ed\*(Aq,
\&                             # because \*(Aq20\ed\ed\*(Aq can\*(Aqt match
.Ve
.PP
Alternations behave the same way in groups as out of them: at a given
string position, the leftmost alternative that allows the regexp to
match is taken.  So in the last example at the first string position,
\&\f(CW"20"\fR matches the second alternative, but there is nothing left over
to match the next two digits \f(CW\*(C`\ed\ed\*(C'\fR.  So Perl moves on to the next
alternative, which is the null alternative and that works, since
\&\f(CW"20"\fR is two digits.
.PP
The process of trying one alternative, seeing if it matches, and
moving on to the next alternative, while going back in the string
from where the previous alternative was tried, if it doesn't, is called
\&\fIbacktracking\fR.  The term 'backtracking' comes from the idea that
matching a regexp is like a walk in the woods.  Successfully matching
a regexp is like arriving at a destination.  There are many possible
trailheads, one for each string position, and each one is tried in
order, left to right.  From each trailhead there may be many paths,
some of which get you there, and some which are dead ends.  When you
walk along a trail and hit a dead end, you have to backtrack along the
trail to an earlier point to try another trail.  If you hit your
destination, you stop immediately and forget about trying all the
other trails.  You are persistent, and only if you have tried all the
trails from all the trailheads and not arrived at your destination, do
you declare failure.  To be concrete, here is a step-by-step analysis
of what Perl does when it tries to match the regexp
.PP
.Vb 1
\&    "abcde" =~ /(abd|abc)(df|d|de)/;
.Ve
.IP "0" 4
Start with the first letter in the string 'a'.
.IP "1" 4
.IX Item "1"
Try the first alternative in the first group 'abd'.
.IP "2" 4
.IX Item "2"
Match 'a' followed by 'b'. So far so good.
.IP "3" 4
.IX Item "3"
\&'d' in the regexp doesn't match 'c' in the string \- a dead
end.  So backtrack two characters and pick the second alternative in
the first group 'abc'.
.IP "4" 4
.IX Item "4"
Match 'a' followed by 'b' followed by 'c'.  We are on a roll
and have satisfied the first group. Set \f(CW$1\fR to 'abc'.
.IP "5" 4
.IX Item "5"
Move on to the second group and pick the first alternative
\&'df'.
.IP "6" 4
.IX Item "6"
Match the 'd'.
.IP "7" 4
.IX Item "7"
\&'f' in the regexp doesn't match 'e' in the string, so a dead
end.  Backtrack one character and pick the second alternative in the
second group 'd'.
.IP "8" 4
.IX Item "8"
\&'d' matches. The second grouping is satisfied, so set \f(CW$2\fR to
\&'d'.
.IP "9" 4
.IX Item "9"
We are at the end of the regexp, so we are done! We have
matched 'abcd' out of the string \*(L"abcde\*(R".
.PP
There are a couple of things to note about this analysis.  First, the
third alternative in the second group 'de' also allows a match, but we
stopped before we got to it \- at a given character position, leftmost
wins.  Second, we were able to get a match at the first character
position of the string 'a'.  If there were no matches at the first
position, Perl would move to the second character position 'b' and
attempt the match all over again.  Only when all possible paths at all
possible character positions have been exhausted does Perl give
up and declare \f(CW\*(C`$string\ =~\ /(abd|abc)(df|d|de)/;\*(C'\fR to be false.
.PP
Even with all this work, regexp matching happens remarkably fast.  To
speed things up, Perl compiles the regexp into a compact sequence of
opcodes that can often fit inside a processor cache.  When the code is
executed, these opcodes can then run at full throttle and search very
quickly.
.SS "Extracting matches"
.IX Subsection "Extracting matches"
The grouping metacharacters \f(CW\*(C`()\*(C'\fR also serve another completely
different function: they allow the extraction of the parts of a string
that matched.  This is very useful to find out what matched and for
text processing in general.  For each grouping, the part that matched
inside goes into the special variables \f(CW$1\fR, \f(CW$2\fR, etc.  They can be
used just as ordinary variables:
.PP
.Vb 6
\&    # extract hours, minutes, seconds
\&    if ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/) {    # match hh:mm:ss format
\&        $hours = $1;
\&        $minutes = $2;
\&        $seconds = $3;
\&    }
.Ve
.PP
Now, we know that in scalar context,
\&\f(CW\*(C`$time\ =~\ /(\ed\ed):(\ed\ed):(\ed\ed)/\*(C'\fR returns a true or false
value.  In list context, however, it returns the list of matched values
\&\f(CW\*(C`($1,$2,$3)\*(C'\fR.  So we could write the code more compactly as
.PP
.Vb 2
\&    # extract hours, minutes, seconds
\&    ($hours, $minutes, $second) = ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/);
.Ve
.PP
If the groupings in a regexp are nested, \f(CW$1\fR gets the group with the
leftmost opening parenthesis, \f(CW$2\fR the next opening parenthesis,
etc.  Here is a regexp with nested groups:
.PP
.Vb 2
\&    /(ab(cd|ef)((gi)|j))/;
\&     1  2      34
.Ve
.PP
If this regexp matches, \f(CW$1\fR contains a string starting with
\&\f(CW\*(Aqab\*(Aq\fR, \f(CW$2\fR is either set to \f(CW\*(Aqcd\*(Aq\fR or \f(CW\*(Aqef\*(Aq\fR, \f(CW$3\fR equals either
\&\f(CW\*(Aqgi\*(Aq\fR or \f(CW\*(Aqj\*(Aq\fR, and \f(CW$4\fR is either set to \f(CW\*(Aqgi\*(Aq\fR, just like \f(CW$3\fR,
or it remains undefined.
.PP
For convenience, Perl sets \f(CW$+\fR to the string held by the highest numbered
\&\f(CW$1\fR, \f(CW$2\fR,... that got assigned (and, somewhat related, \f(CW$^N\fR to the
value of the \f(CW$1\fR, \f(CW$2\fR,... most-recently assigned; i.e. the \f(CW$1\fR,
\&\f(CW$2\fR,... associated with the rightmost closing parenthesis used in the
match).
.SS "Backreferences"
.IX Subsection "Backreferences"
Closely associated with the matching variables \f(CW$1\fR, \f(CW$2\fR, ... are
the \fIbackreferences\fR \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR,...  Backreferences are simply
matching variables that can be used \fIinside\fR a regexp.  This is a
really nice feature; what matches later in a regexp is made to depend on
what matched earlier in the regexp.  Suppose we wanted to look
for doubled words in a text, like 'the the'.  The following regexp finds
all 3\-letter doubles with a space in between:
.PP
.Vb 1
\&    /\eb(\ew\ew\ew)\es\eg1\eb/;
.Ve
.PP
The grouping assigns a value to \eg1, so that the same 3\-letter sequence
is used for both parts.
.PP
A similar task is to find words consisting of two identical parts:
.PP
.Vb 7
\&    % simple_grep \*(Aq^(\ew\ew\ew\ew|\ew\ew\ew|\ew\ew|\ew)\eg1$\*(Aq /usr/dict/words
\&    beriberi
\&    booboo
\&    coco
\&    mama
\&    murmur
\&    papa
.Ve
.PP
The regexp has a single grouping which considers 4\-letter
combinations, then 3\-letter combinations, etc., and uses \f(CW\*(C`\eg1\*(C'\fR to look for
a repeat.  Although \f(CW$1\fR and \f(CW\*(C`\eg1\*(C'\fR represent the same thing, care should be
taken to use matched variables \f(CW$1\fR, \f(CW$2\fR,... only \fIoutside\fR a regexp
and backreferences \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR,... only \fIinside\fR a regexp; not doing
so may lead to surprising and unsatisfactory results.
.SS "Relative backreferences"
.IX Subsection "Relative backreferences"
Counting the opening parentheses to get the correct number for a
backreference is error-prone as soon as there is more than one
capturing group.  A more convenient technique became available
with Perl 5.10: relative backreferences. To refer to the immediately
preceding capture group one now may write \f(CW\*(C`\eg{\-1}\*(C'\fR, the next but
last is available via \f(CW\*(C`\eg{\-2}\*(C'\fR, and so on.
.PP
Another good reason in addition to readability and maintainability
for using relative backreferences is illustrated by the following example,
where a simple pattern for matching peculiar strings is used:
.PP
.Vb 1
\&    $a99a = \*(Aq([a\-z])(\ed)\eg2\eg1\*(Aq;   # matches a11a, g22g, x33x, etc.
.Ve
.PP
Now that we have this pattern stored as a handy string, we might feel
tempted to use it as a part of some other pattern:
.PP
.Vb 6
\&    $line = "code=e99e";
\&    if ($line =~ /^(\ew+)=$a99a$/){   # unexpected behavior!
\&        print "$1 is valid\en";
\&    } else {
\&        print "bad line: \*(Aq$line\*(Aq\en";
\&    }
.Ve
.PP
But this doesn't match, at least not the way one might expect. Only
after inserting the interpolated \f(CW$a99a\fR and looking at the resulting
full text of the regexp is it obvious that the backreferences have
backfired. The subexpression \f(CW\*(C`(\ew+)\*(C'\fR has snatched number 1 and
demoted the groups in \f(CW$a99a\fR by one rank. This can be avoided by
using relative backreferences:
.PP
.Vb 1
\&    $a99a = \*(Aq([a\-z])(\ed)\eg{\-1}\eg{\-2}\*(Aq;  # safe for being interpolated
.Ve
.SS "Named backreferences"
.IX Subsection "Named backreferences"
Perl 5.10 also introduced named capture groups and named backreferences.
To attach a name to a capturing group, you write either
\&\f(CW\*(C`(?<name>...)\*(C'\fR or \f(CW\*(C`(?\*(Aqname\*(Aq...)\*(C'\fR.  The backreference may
then be written as \f(CW\*(C`\eg{name}\*(C'\fR.  It is permissible to attach the
same name to more than one group, but then only the leftmost one of the
eponymous set can be referenced.  Outside of the pattern a named
capture group is accessible through the \f(CW\*(C`%+\*(C'\fR hash.
.PP
Assuming that we have to match calendar dates which may be given in one
of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write
three suitable patterns where we use 'd', 'm' and 'y' respectively as the
names of the groups capturing the pertaining components of a date. The
matching operation combines the three patterns as alternatives:
.PP
.Vb 8
\&    $fmt1 = \*(Aq(?<y>\ed\ed\ed\ed)\-(?<m>\ed\ed)\-(?<d>\ed\ed)\*(Aq;
\&    $fmt2 = \*(Aq(?<m>\ed\ed)/(?<d>\ed\ed)/(?<y>\ed\ed\ed\ed)\*(Aq;
\&    $fmt3 = \*(Aq(?<d>\ed\ed)\e.(?<m>\ed\ed)\e.(?<y>\ed\ed\ed\ed)\*(Aq;
\&    for my $d qw( 2006\-10\-21 15.01.2007 10/31/2005 ){
\&        if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
\&            print "day=$+{d} month=$+{m} year=$+{y}\en";
\&        }
\&    }
.Ve
.PP
If any of the alternatives matches, the hash \f(CW\*(C`%+\*(C'\fR is bound to contain the
three key-value pairs.
.SS "Alternative capture group numbering"
.IX Subsection "Alternative capture group numbering"
Yet another capturing group numbering technique (also as from Perl 5.10)
deals with the problem of referring to groups within a set of alternatives.
Consider a pattern for matching a time of the day, civil or military style:
.PP
.Vb 3
\&    if ( $time =~ /(\ed\ed|\ed):(\ed\ed)|(\ed\ed)(\ed\ed)/ ){
\&        # process hour and minute
\&    }
.Ve
.PP
Processing the results requires an additional if statement to determine
whether \f(CW$1\fR and \f(CW$2\fR or \f(CW$3\fR and \f(CW$4\fR contain the goodies. It would
be easier if we could use group numbers 1 and 2 in second alternative as
well, and this is exactly what the parenthesized construct \f(CW\*(C`(?|...)\*(C'\fR,
set around an alternative achieves. Here is an extended version of the
previous pattern:
.PP
.Vb 3
\&    if ( $time =~ /(?|(\ed\ed|\ed):(\ed\ed)|(\ed\ed)(\ed\ed))\es+([A\-Z][A\-Z][A\-Z])/ ){
\&        print "hour=$1 minute=$2 zone=$3\en";
\&    }
.Ve
.PP
Within the alternative numbering group, group numbers start at the same
position for each alternative. After the group, numbering continues
with one higher than the maximum reached across all the alternatives.
.SS "Position information"
.IX Subsection "Position information"
In addition to what was matched, Perl also provides the
positions of what was matched as contents of the \f(CW\*(C`@\-\*(C'\fR and \f(CW\*(C`@+\*(C'\fR
arrays. \f(CW\*(C`$\-[0]\*(C'\fR is the position of the start of the entire match and
\&\f(CW$+[0]\fR is the position of the end. Similarly, \f(CW\*(C`$\-[n]\*(C'\fR is the
position of the start of the \f(CW$n\fR match and \f(CW$+[n]\fR is the position
of the end. If \f(CW$n\fR is undefined, so are \f(CW\*(C`$\-[n]\*(C'\fR and \f(CW$+[n]\fR. Then
this code
.PP
.Vb 5
\&    $x = "Mmm...donut, thought Homer";
\&    $x =~ /^(Mmm|Yech)\e.\e.\e.(donut|peas)/; # matches
\&    foreach $expr (1..$#\-) {
\&        print "Match $expr: \*(Aq${$expr}\*(Aq at position ($\-[$expr],$+[$expr])\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 2
\&    Match 1: \*(AqMmm\*(Aq at position (0,3)
\&    Match 2: \*(Aqdonut\*(Aq at position (6,11)
.Ve
.PP
Even if there are no groupings in a regexp, it is still possible to
find out what exactly matched in a string.  If you use them, Perl
will set \f(CW\*(C`$\`\*(C'\fR to the part of the string before the match, will set \f(CW$&\fR
to the part of the string that matched, and will set \f(CW\*(C`$\*(Aq\*(C'\fR to the part
of the string after the match.  An example:
.PP
.Vb 3
\&    $x = "the cat caught the mouse";
\&    $x =~ /cat/;  # $\` = \*(Aqthe \*(Aq, $& = \*(Aqcat\*(Aq, $\*(Aq = \*(Aq caught the mouse\*(Aq
\&    $x =~ /the/;  # $\` = \*(Aq\*(Aq, $& = \*(Aqthe\*(Aq, $\*(Aq = \*(Aq cat caught the mouse\*(Aq
.Ve
.PP
In the second match, \f(CW\*(C`$\`\*(C'\fR equals \f(CW\*(Aq\*(Aq\fR because the regexp matched at the
first character position in the string and stopped; it never saw the
second 'the'.  It is important to note that using \f(CW\*(C`$\`\*(C'\fR and \f(CW\*(C`$\*(Aq\*(C'\fR
slows down regexp matching quite a bit, while \f(CW$&\fR slows it down to a
lesser extent, because if they are used in one regexp in a program,
they are generated for \fIall\fR regexps in the program.  So if raw
performance is a goal of your application, they should be avoided.
If you need to extract the corresponding substrings, use \f(CW\*(C`@\-\*(C'\fR and
\&\f(CW\*(C`@+\*(C'\fR instead:
.PP
.Vb 3
\&    $\` is the same as substr( $x, 0, $\-[0] )
\&    $& is the same as substr( $x, $\-[0], $+[0]\-$\-[0] )
\&    $\*(Aq is the same as substr( $x, $+[0] )
.Ve
.PP
As of Perl 5.10, the \f(CW\*(C`${^PREMATCH}\*(C'\fR, \f(CW\*(C`${^MATCH}\*(C'\fR and \f(CW\*(C`${^POSTMATCH}\*(C'\fR
variables may be used. These are only set if the \f(CW\*(C`/p\*(C'\fR modifier is present.
Consequently they do not penalize the rest of the program.
.SS "Non-capturing groupings"
.IX Subsection "Non-capturing groupings"
A group that is required to bundle a set of alternatives may or may not be
useful as a capturing group.  If it isn't, it just creates a superfluous
addition to the set of available capture group values, inside as well as
outside the regexp.  Non-capturing groupings, denoted by \f(CW\*(C`(?:regexp)\*(C'\fR,
still allow the regexp to be treated as a single unit, but don't establish
a capturing group at the same time.  Both capturing and non-capturing
groupings are allowed to co-exist in the same regexp.  Because there is
no extraction, non-capturing groupings are faster than capturing
groupings.  Non-capturing groupings are also handy for choosing exactly
which parts of a regexp are to be extracted to matching variables:
.PP
.Vb 2
\&    # match a number, $1\-$4 are set, but we only want $1
\&    /([+\-]?\e *(\ed+(\e.\ed*)?|\e.\ed+)([eE][+\-]?\ed+)?)/;
\&
\&    # match a number faster , only $1 is set
\&    /([+\-]?\e *(?:\ed+(?:\e.\ed*)?|\e.\ed+)(?:[eE][+\-]?\ed+)?)/;
\&
\&    # match a number, get $1 = whole number, $2 = exponent
\&    /([+\-]?\e *(?:\ed+(?:\e.\ed*)?|\e.\ed+)(?:[eE]([+\-]?\ed+))?)/;
.Ve
.PP
Non-capturing groupings are also useful for removing nuisance
elements gathered from a split operation where parentheses are
required for some reason:
.PP
.Vb 3
\&    $x = \*(Aq12aba34ba5\*(Aq;
\&    @num = split /(a|b)+/, $x;    # @num = (\*(Aq12\*(Aq,\*(Aqa\*(Aq,\*(Aq34\*(Aq,\*(Aqa\*(Aq,\*(Aq5\*(Aq)
\&    @num = split /(?:a|b)+/, $x;  # @num = (\*(Aq12\*(Aq,\*(Aq34\*(Aq,\*(Aq5\*(Aq)
.Ve
.SS "Matching repetitions"
.IX Subsection "Matching repetitions"
The examples in the previous section display an annoying weakness.  We
were only matching 3\-letter words, or chunks of words of 4 letters or
less.  We'd like to be able to match words or, more generally, strings
of any length, without writing out tedious alternatives like
\&\f(CW\*(C`\ew\ew\ew\ew|\ew\ew\ew|\ew\ew|\ew\*(C'\fR.
.PP
This is exactly the problem the \fIquantifier\fR metacharacters \f(CW\*(C`?\*(C'\fR,
\&\f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR, and \f(CW\*(C`{}\*(C'\fR were created for.  They allow us to delimit the
number of repeats for a portion of a regexp we consider to be a
match.  Quantifiers are put immediately after the character, character
class, or grouping that we want to specify.  They have the following
meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a?\*(C'\fR means: match 'a' 1 or 0 times
.IP "\(bu" 4
\&\f(CW\*(C`a*\*(C'\fR means: match 'a' 0 or more times, i.e., any number of times
.IP "\(bu" 4
\&\f(CW\*(C`a+\*(C'\fR means: match 'a' 1 or more times, i.e., at least once
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, but not more than \f(CW\*(C`m\*(C'\fR
times.
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR or more times
.IP "\(bu" 4
\&\f(CW\*(C`a{n}\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times
.PP
Here are some examples:
.PP
.Vb 10
\&    /[a\-z]+\es+\ed*/;  # match a lowercase word, at least one space, and
\&                     # any number of digits
\&    /(\ew+)\es+\eg1/;    # match doubled words of arbitrary length
\&    /y(es)?/i;       # matches \*(Aqy\*(Aq, \*(AqY\*(Aq, or a case\-insensitive \*(Aqyes\*(Aq
\&    $year =~ /^\ed{2,4}$/;  # make sure year is at least 2 but not more
\&                           # than 4 digits
\&    $year =~ /^\ed{4}$|^\ed{2}$/;    # better match; throw out 3\-digit dates
\&    $year =~ /^\ed{2}(\ed{2})?$/;  # same thing written differently. However,
\&                                 # this captures the last two digits in $1
\&                                 # and the other does not.
\&
\&    % simple_grep \*(Aq^(\ew+)\eg1$\*(Aq /usr/dict/words   # isn\*(Aqt this easier?
\&    beriberi
\&    booboo
\&    coco
\&    mama
\&    murmur
\&    papa
.Ve
.PP
For all of these quantifiers, Perl will try to match as much of the
string as possible, while still allowing the regexp to succeed.  Thus
with \f(CW\*(C`/a?.../\*(C'\fR, Perl will first try to match the regexp with the \f(CW\*(C`a\*(C'\fR
present; if that fails, Perl will try to match the regexp without the
\&\f(CW\*(C`a\*(C'\fR present.  For the quantifier \f(CW\*(C`*\*(C'\fR, we get the following:
.PP
.Vb 5
\&    $x = "the cat in the hat";
\&    $x =~ /^(.*)(cat)(.*)$/; # matches,
\&                             # $1 = \*(Aqthe \*(Aq
\&                             # $2 = \*(Aqcat\*(Aq
\&                             # $3 = \*(Aq in the hat\*(Aq
.Ve
.PP
Which is what we might expect, the match finds the only \f(CW\*(C`cat\*(C'\fR in the
string and locks onto it.  Consider, however, this regexp:
.PP
.Vb 4
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe cat in the h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 characters match)
.Ve
.PP
One might initially guess that Perl would find the \f(CW\*(C`at\*(C'\fR in \f(CW\*(C`cat\*(C'\fR and
stop there, but that wouldn't give the longest possible string to the
first quantifier \f(CW\*(C`.*\*(C'\fR.  Instead, the first quantifier \f(CW\*(C`.*\*(C'\fR grabs as
much of the string as possible while still having the regexp match.  In
this example, that means having the \f(CW\*(C`at\*(C'\fR sequence with the final \f(CW\*(C`at\*(C'\fR
in the string.  The other important principle illustrated here is that,
when there are two or more elements in a regexp, the \fIleftmost\fR
quantifier, if there is one, gets to grab as much of the string as
possible, leaving the rest of the regexp to fight over scraps.  Thus in
our example, the first quantifier \f(CW\*(C`.*\*(C'\fR grabs most of the string, while
the second quantifier \f(CW\*(C`.*\*(C'\fR gets the empty string.   Quantifiers that
grab as much of the string as possible are called \fImaximal match\fR or
\&\fIgreedy\fR quantifiers.
.PP
When a regexp can match a string in several different ways, we can use
the principles above to predict which way the regexp will match:
.IP "\(bu" 4
Principle 0: Taken as a whole, any regexp will be matched at the
earliest possible position in the string.
.IP "\(bu" 4
Principle 1: In an alternation \f(CW\*(C`a|b|c...\*(C'\fR, the leftmost alternative
that allows a match for the whole regexp will be the one used.
.IP "\(bu" 4
Principle 2: The maximal matching quantifiers \f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR and
\&\f(CW\*(C`{n,m}\*(C'\fR will in general match as much of the string as possible while
still allowing the whole regexp to match.
.IP "\(bu" 4
Principle 3: If there are two or more elements in a regexp, the
leftmost greedy quantifier, if any, will match as much of the string
as possible while still allowing the whole regexp to match.  The next
leftmost greedy quantifier, if any, will try to match as much of the
string remaining available to it as possible, while still allowing the
whole regexp to match.  And so on, until all the regexp elements are
satisfied.
.PP
As we have seen above, Principle 0 overrides the others. The regexp
will be matched as early as possible, with the other principles
determining how the regexp matches at that earliest character
position.
.PP
Here is an example of these principles in action:
.PP
.Vb 5
\&    $x = "The programming republic of Perl";
\&    $x =~ /^(.+)(e|r)(.*)$/;  # matches,
\&                              # $1 = \*(AqThe programming republic of Pe\*(Aq
\&                              # $2 = \*(Aqr\*(Aq
\&                              # $3 = \*(Aql\*(Aq
.Ve
.PP
This regexp matches at the earliest string position, \f(CW\*(AqT\*(Aq\fR.  One
might think that \f(CW\*(C`e\*(C'\fR, being leftmost in the alternation, would be
matched, but \f(CW\*(C`r\*(C'\fR produces the longest string in the first quantifier.
.PP
.Vb 3
\&    $x =~ /(m{1,2})(.*)$/;  # matches,
\&                            # $1 = \*(Aqmm\*(Aq
\&                            # $2 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Here, The earliest possible match is at the first \f(CW\*(Aqm\*(Aq\fR in
\&\f(CW\*(C`programming\*(C'\fR. \f(CW\*(C`m{1,2}\*(C'\fR is the first quantifier, so it gets to match
a maximal \f(CW\*(C`mm\*(C'\fR.
.PP
.Vb 3
\&    $x =~ /.*(m{1,2})(.*)$/;  # matches,
\&                              # $1 = \*(Aqm\*(Aq
\&                              # $2 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Here, the regexp matches at the start of the string. The first
quantifier \f(CW\*(C`.*\*(C'\fR grabs as much as possible, leaving just a single
\&\f(CW\*(Aqm\*(Aq\fR for the second quantifier \f(CW\*(C`m{1,2}\*(C'\fR.
.PP
.Vb 4
\&    $x =~ /(.?)(m{1,2})(.*)$/;  # matches,
\&                                # $1 = \*(Aqa\*(Aq
\&                                # $2 = \*(Aqmm\*(Aq
\&                                # $3 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Here, \f(CW\*(C`.?\*(C'\fR eats its maximal one character at the earliest possible
position in the string, \f(CW\*(Aqa\*(Aq\fR in \f(CW\*(C`programming\*(C'\fR, leaving \f(CW\*(C`m{1,2}\*(C'\fR
the opportunity to match both \f(CW\*(C`m\*(C'\fR's. Finally,
.PP
.Vb 1
\&    "aXXXb" =~ /(X*)/; # matches with $1 = \*(Aq\*(Aq
.Ve
.PP
because it can match zero copies of \f(CW\*(AqX\*(Aq\fR at the beginning of the
string.  If you definitely want to match at least one \f(CW\*(AqX\*(Aq\fR, use
\&\f(CW\*(C`X+\*(C'\fR, not \f(CW\*(C`X*\*(C'\fR.
.PP
Sometimes greed is not good.  At times, we would like quantifiers to
match a \fIminimal\fR piece of string, rather than a maximal piece.  For
this purpose, Larry Wall created the \fIminimal match\fR or
\&\fInon-greedy\fR quantifiers \f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, and \f(CW\*(C`{}?\*(C'\fR.  These are
the usual quantifiers with a \f(CW\*(C`?\*(C'\fR appended to them.  They have the
following meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a??\*(C'\fR means: match 'a' 0 or 1 times. Try 0 first, then 1.
.IP "\(bu" 4
\&\f(CW\*(C`a*?\*(C'\fR means: match 'a' 0 or more times, i.e., any number of times,
but as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a+?\*(C'\fR means: match 'a' 1 or more times, i.e., at least once, but
as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}?\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, not more than \f(CW\*(C`m\*(C'\fR
times, as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}?\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, but as few times as
possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n}?\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times.  Because we match exactly
\&\f(CW\*(C`n\*(C'\fR times, \f(CW\*(C`a{n}?\*(C'\fR is equivalent to \f(CW\*(C`a{n}\*(C'\fR and is just there for
notational consistency.
.PP
Let's look at the example above, but with minimal quantifiers:
.PP
.Vb 5
\&    $x = "The programming republic of Perl";
\&    $x =~ /^(.+?)(e|r)(.*)$/; # matches,
\&                              # $1 = \*(AqTh\*(Aq
\&                              # $2 = \*(Aqe\*(Aq
\&                              # $3 = \*(Aq programming republic of Perl\*(Aq
.Ve
.PP
The minimal string that will allow both the start of the string \f(CW\*(C`^\*(C'\fR
and the alternation to match is \f(CW\*(C`Th\*(C'\fR, with the alternation \f(CW\*(C`e|r\*(C'\fR
matching \f(CW\*(C`e\*(C'\fR.  The second quantifier \f(CW\*(C`.*\*(C'\fR is free to gobble up the
rest of the string.
.PP
.Vb 3
\&    $x =~ /(m{1,2}?)(.*?)$/;  # matches,
\&                              # $1 = \*(Aqm\*(Aq
\&                              # $2 = \*(Aqming republic of Perl\*(Aq
.Ve
.PP
The first string position that this regexp can match is at the first
\&\f(CW\*(Aqm\*(Aq\fR in \f(CW\*(C`programming\*(C'\fR. At this position, the minimal \f(CW\*(C`m{1,2}?\*(C'\fR
matches just one \f(CW\*(Aqm\*(Aq\fR.  Although the second quantifier \f(CW\*(C`.*?\*(C'\fR would
prefer to match no characters, it is constrained by the end-of-string
anchor \f(CW\*(C`$\*(C'\fR to match the rest of the string.
.PP
.Vb 4
\&    $x =~ /(.*?)(m{1,2}?)(.*)$/;  # matches,
\&                                  # $1 = \*(AqThe progra\*(Aq
\&                                  # $2 = \*(Aqm\*(Aq
\&                                  # $3 = \*(Aqming republic of Perl\*(Aq
.Ve
.PP
In this regexp, you might expect the first minimal quantifier \f(CW\*(C`.*?\*(C'\fR
to match the empty string, because it is not constrained by a \f(CW\*(C`^\*(C'\fR
anchor to match the beginning of the word.  Principle 0 applies here,
however.  Because it is possible for the whole regexp to match at the
start of the string, it \fIwill\fR match at the start of the string.  Thus
the first quantifier has to match everything up to the first \f(CW\*(C`m\*(C'\fR.  The
second minimal quantifier matches just one \f(CW\*(C`m\*(C'\fR and the third
quantifier matches the rest of the string.
.PP
.Vb 4
\&    $x =~ /(.??)(m{1,2})(.*)$/;  # matches,
\&                                 # $1 = \*(Aqa\*(Aq
\&                                 # $2 = \*(Aqmm\*(Aq
\&                                 # $3 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Just as in the previous regexp, the first quantifier \f(CW\*(C`.??\*(C'\fR can match
earliest at position \f(CW\*(Aqa\*(Aq\fR, so it does.  The second quantifier is
greedy, so it matches \f(CW\*(C`mm\*(C'\fR, and the third matches the rest of the
string.
.PP
We can modify principle 3 above to take into account non-greedy
quantifiers:
.IP "\(bu" 4
Principle 3: If there are two or more elements in a regexp, the
leftmost greedy (non-greedy) quantifier, if any, will match as much
(little) of the string as possible while still allowing the whole
regexp to match.  The next leftmost greedy (non-greedy) quantifier, if
any, will try to match as much (little) of the string remaining
available to it as possible, while still allowing the whole regexp to
match.  And so on, until all the regexp elements are satisfied.
.PP
Just like alternation, quantifiers are also susceptible to
backtracking.  Here is a step-by-step analysis of the example
.PP
.Vb 5
\&    $x = "the cat in the hat";
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe cat in the h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 matches)
.Ve
.IP "0" 4
Start with the first letter in the string 't'.
.IP "1" 4
.IX Item "1"
The first quantifier '.*' starts out by matching the whole
string 'the cat in the hat'.
.IP "2" 4
.IX Item "2"
\&'a' in the regexp element 'at' doesn't match the end of the
string.  Backtrack one character.
.IP "3" 4
.IX Item "3"
\&'a' in the regexp element 'at' still doesn't match the last
letter of the string 't', so backtrack one more character.
.IP "4" 4
.IX Item "4"
Now we can match the 'a' and the 't'.
.IP "5" 4
.IX Item "5"
Move on to the third element '.*'.  Since we are at the end of
the string and '.*' can match 0 times, assign it the empty string.
.IP "6" 4
.IX Item "6"
We are done!
.PP
Most of the time, all this moving forward and backtracking happens
quickly and searching is fast. There are some pathological regexps,
however, whose execution time exponentially grows with the size of the
string.  A typical structure that blows up in your face is of the form
.PP
.Vb 1
\&    /(a|b+)*/;
.Ve
.PP
The problem is the nested indeterminate quantifiers.  There are many
different ways of partitioning a string of length n between the \f(CW\*(C`+\*(C'\fR
and \f(CW\*(C`*\*(C'\fR: one repetition with \f(CW\*(C`b+\*(C'\fR of length n, two repetitions with
the first \f(CW\*(C`b+\*(C'\fR length k and the second with length n\-k, m repetitions
whose bits add up to length n, etc.  In fact there are an exponential
number of ways to partition a string as a function of its length.  A
regexp may get lucky and match early in the process, but if there is
no match, Perl will try \fIevery\fR possibility before giving up.  So be
careful with nested \f(CW\*(C`*\*(C'\fR's, \f(CW\*(C`{n,m}\*(C'\fR's, and \f(CW\*(C`+\*(C'\fR's.  The book
\&\fIMastering Regular Expressions\fR by Jeffrey Friedl gives a wonderful
discussion of this and other efficiency issues.
.SS "Possessive quantifiers"
.IX Subsection "Possessive quantifiers"
Backtracking during the relentless search for a match may be a waste
of time, particularly when the match is bound to fail.  Consider
the simple pattern
.PP
.Vb 1
\&    /^\ew+\es+\ew+$/; # a word, spaces, a word
.Ve
.PP
Whenever this is applied to a string which doesn't quite meet the
pattern's expectations such as \f(CW"abc\ \ "\fR or \f(CW"abc\ \ def\ "\fR,
the regex engine will backtrack, approximately once for each character
in the string.  But we know that there is no way around taking \fIall\fR
of the initial word characters to match the first repetition, that \fIall\fR
spaces must be eaten by the middle part, and the same goes for the second
word.
.PP
With the introduction of the \fIpossessive quantifiers\fR in Perl 5.10, we
have a way of instructing the regex engine not to backtrack, with the
usual quantifiers with a \f(CW\*(C`+\*(C'\fR appended to them.  This makes them greedy as
well as stingy; once they succeed they won't give anything back to permit
another solution. They have the following meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}+\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, not more than \f(CW\*(C`m\*(C'\fR times,
as many times as possible, and don't give anything up. \f(CW\*(C`a?+\*(C'\fR is short
for \f(CW\*(C`a{0,1}+\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}+\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, but as many times as possible,
and don't give anything up. \f(CW\*(C`a*+\*(C'\fR is short for \f(CW\*(C`a{0,}+\*(C'\fR and \f(CW\*(C`a++\*(C'\fR is
short for \f(CW\*(C`a{1,}+\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`a{n}+\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times.  It is just there for
notational consistency.
.PP
These possessive quantifiers represent a special case of a more general
concept, the \fIindependent subexpression\fR, see below.
.PP
As an example where a possessive quantifier is suitable we consider
matching a quoted string, as it appears in several programming languages.
The backslash is used as an escape character that indicates that the
next character is to be taken literally, as another character for the
string.  Therefore, after the opening quote, we expect a (possibly
empty) sequence of alternatives: either some character except an
unescaped quote or backslash or an escaped character.
.PP
.Vb 1
\&    /"(?:[^"\e\e]++|\e\e.)*+"/;
.Ve
.SS "Building a regexp"
.IX Subsection "Building a regexp"
At this point, we have all the basic regexp concepts covered, so let's
give a more involved example of a regular expression.  We will build a
regexp that matches numbers.
.PP
The first task in building a regexp is to decide what we want to match
and what we want to exclude.  In our case, we want to match both
integers and floating point numbers and we want to reject any string
that isn't a number.
.PP
The next task is to break the problem down into smaller problems that
are easily converted into a regexp.
.PP
The simplest case is integers.  These consist of a sequence of digits,
with an optional sign in front.  The digits we can represent with
\&\f(CW\*(C`\ed+\*(C'\fR and the sign can be matched with \f(CW\*(C`[+\-]\*(C'\fR.  Thus the integer
regexp is
.PP
.Vb 1
\&    /[+\-]?\ed+/;  # matches integers
.Ve
.PP
A floating point number potentially has a sign, an integral part, a
decimal point, a fractional part, and an exponent.  One or more of these
parts is optional, so we need to check out the different
possibilities.  Floating point numbers which are in proper form include
123., 0.345, .34, \-1e6, and 25.4E\-72.  As with integers, the sign out
front is completely optional and can be matched by \f(CW\*(C`[+\-]?\*(C'\fR.  We can
see that if there is no exponent, floating point numbers must have a
decimal point, otherwise they are integers.  We might be tempted to
model these with \f(CW\*(C`\ed*\e.\ed*\*(C'\fR, but this would also match just a single
decimal point, which is not a number.  So the three cases of floating
point number without exponent are
.PP
.Vb 3
\&   /[+\-]?\ed+\e./;  # 1., 321., etc.
\&   /[+\-]?\e.\ed+/;  # .1, .234, etc.
\&   /[+\-]?\ed+\e.\ed+/;  # 1.0, 30.56, etc.
.Ve
.PP
These can be combined into a single regexp with a three-way alternation:
.PP
.Vb 1
\&   /[+\-]?(\ed+\e.\ed+|\ed+\e.|\e.\ed+)/;  # floating point, no exponent
.Ve
.PP
In this alternation, it is important to put \f(CW\*(Aq\ed+\e.\ed+\*(Aq\fR before
\&\f(CW\*(Aq\ed+\e.\*(Aq\fR.  If \f(CW\*(Aq\ed+\e.\*(Aq\fR were first, the regexp would happily match that
and ignore the fractional part of the number.
.PP
Now consider floating point numbers with exponents.  The key
observation here is that \fIboth\fR integers and numbers with decimal
points are allowed in front of an exponent.  Then exponents, like the
overall sign, are independent of whether we are matching numbers with
or without decimal points, and can be 'decoupled' from the
mantissa.  The overall form of the regexp now becomes clear:
.PP
.Vb 1
\&    /^(optional sign)(integer | f.p. mantissa)(optional exponent)$/;
.Ve
.PP
The exponent is an \f(CW\*(C`e\*(C'\fR or \f(CW\*(C`E\*(C'\fR, followed by an integer.  So the
exponent regexp is
.PP
.Vb 1
\&   /[eE][+\-]?\ed+/;  # exponent
.Ve
.PP
Putting all the parts together, we get a regexp that matches numbers:
.PP
.Vb 1
\&   /^[+\-]?(\ed+\e.\ed+|\ed+\e.|\e.\ed+|\ed+)([eE][+\-]?\ed+)?$/;  # Ta da!
.Ve
.PP
Long regexps like this may impress your friends, but can be hard to
decipher.  In complex situations like this, the \f(CW\*(C`//x\*(C'\fR modifier for a
match is invaluable.  It allows one to put nearly arbitrary whitespace
and comments into a regexp without affecting their meaning.  Using it,
we can rewrite our 'extended' regexp in the more pleasing form
.PP
.Vb 10
\&   /^
\&      [+\-]?         # first, match an optional sign
\&      (             # then match integers or f.p. mantissas:
\&          \ed+\e.\ed+  # mantissa of the form a.b
\&         |\ed+\e.     # mantissa of the form a.
\&         |\e.\ed+     # mantissa of the form .b
\&         |\ed+       # integer of the form a
\&      )
\&      ([eE][+\-]?\ed+)?  # finally, optionally match an exponent
\&   $/x;
.Ve
.PP
If whitespace is mostly irrelevant, how does one include space
characters in an extended regexp? The answer is to backslash it
\&\f(CW\*(Aq\e\ \*(Aq\fR or put it in a character class \f(CW\*(C`[\ ]\*(C'\fR.  The same thing
goes for pound signs: use \f(CW\*(C`\e#\*(C'\fR or \f(CW\*(C`[#]\*(C'\fR.  For instance, Perl allows
a space between the sign and the mantissa or integer, and we could add
this to our regexp as follows:
.PP
.Vb 10
\&   /^
\&      [+\-]?\e *      # first, match an optional sign *and space*
\&      (             # then match integers or f.p. mantissas:
\&          \ed+\e.\ed+  # mantissa of the form a.b
\&         |\ed+\e.     # mantissa of the form a.
\&         |\e.\ed+     # mantissa of the form .b
\&         |\ed+       # integer of the form a
\&      )
\&      ([eE][+\-]?\ed+)?  # finally, optionally match an exponent
\&   $/x;
.Ve
.PP
In this form, it is easier to see a way to simplify the
alternation.  Alternatives 1, 2, and 4 all start with \f(CW\*(C`\ed+\*(C'\fR, so it
could be factored out:
.PP
.Vb 11
\&   /^
\&      [+\-]?\e *      # first, match an optional sign
\&      (             # then match integers or f.p. mantissas:
\&          \ed+       # start out with a ...
\&          (
\&              \e.\ed* # mantissa of the form a.b or a.
\&          )?        # ? takes care of integers of the form a
\&         |\e.\ed+     # mantissa of the form .b
\&      )
\&      ([eE][+\-]?\ed+)?  # finally, optionally match an exponent
\&   $/x;
.Ve
.PP
or written in the compact form,
.PP
.Vb 1
\&    /^[+\-]?\e *(\ed+(\e.\ed*)?|\e.\ed+)([eE][+\-]?\ed+)?$/;
.Ve
.PP
This is our final regexp.  To recap, we built a regexp by
.IP "\(bu" 4
specifying the task in detail,
.IP "\(bu" 4
breaking down the problem into smaller parts,
.IP "\(bu" 4
translating the small parts into regexps,
.IP "\(bu" 4
combining the regexps,
.IP "\(bu" 4
and optimizing the final combined regexp.
.PP
These are also the typical steps involved in writing a computer
program.  This makes perfect sense, because regular expressions are
essentially programs written in a little computer language that specifies
patterns.
.SS "Using regular expressions in Perl"
.IX Subsection "Using regular expressions in Perl"
The last topic of Part 1 briefly covers how regexps are used in Perl
programs.  Where do they fit into Perl syntax?
.PP
We have already introduced the matching operator in its default
\&\f(CW\*(C`/regexp/\*(C'\fR and arbitrary delimiter \f(CW\*(C`m!regexp!\*(C'\fR forms.  We have used
the binding operator \f(CW\*(C`=~\*(C'\fR and its negation \f(CW\*(C`!~\*(C'\fR to test for string
matches.  Associated with the matching operator, we have discussed the
single line \f(CW\*(C`//s\*(C'\fR, multi-line \f(CW\*(C`//m\*(C'\fR, case-insensitive \f(CW\*(C`//i\*(C'\fR and
extended \f(CW\*(C`//x\*(C'\fR modifiers.  There are a few more things you might
want to know about matching operators.
.PP
\fIProhibiting substitution\fR
.IX Subsection "Prohibiting substitution"
.PP
If you change \f(CW$pattern\fR after the first substitution happens, Perl
will ignore it.  If you don't want any substitutions at all, use the
special delimiter \f(CW\*(C`m\*(Aq\*(Aq\*(C'\fR:
.PP
.Vb 4
\&    @pattern = (\*(AqSeuss\*(Aq);
\&    while (<>) {
\&        print if m\*(Aq@pattern\*(Aq;  # matches literal \*(Aq@pattern\*(Aq, not \*(AqSeuss\*(Aq
\&    }
.Ve
.PP
Similar to strings, \f(CW\*(C`m\*(Aq\*(Aq\*(C'\fR acts like apostrophes on a regexp; all other
\&\f(CW\*(C`m\*(C'\fR delimiters act like quotes.  If the regexp evaluates to the empty string,
the regexp in the \fIlast successful match\fR is used instead.  So we have
.PP
.Vb 2
\&    "dog" =~ /d/;  # \*(Aqd\*(Aq matches
\&    "dogbert =~ //;  # this matches the \*(Aqd\*(Aq regexp used before
.Ve
.PP
\fIGlobal matching\fR
.IX Subsection "Global matching"
.PP
The final two modifiers we will discuss here,
\&\f(CW\*(C`//g\*(C'\fR and \f(CW\*(C`//c\*(C'\fR, concern multiple matches.
The modifier \f(CW\*(C`//g\*(C'\fR stands for global matching and allows the
matching operator to match within a string as many times as possible.
In scalar context, successive invocations against a string will have
\&\f(CW\*(C`//g\*(C'\fR jump from match to match, keeping track of position in the
string as it goes along.  You can get or set the position with the
\&\f(CW\*(C`pos()\*(C'\fR function.
.PP
The use of \f(CW\*(C`//g\*(C'\fR is shown in the following example.  Suppose we have
a string that consists of words separated by spaces.  If we know how
many words there are in advance, we could extract the words using
groupings:
.PP
.Vb 5
\&    $x = "cat dog house"; # 3 words
\&    $x =~ /^\es*(\ew+)\es+(\ew+)\es+(\ew+)\es*$/; # matches,
\&                                           # $1 = \*(Aqcat\*(Aq
\&                                           # $2 = \*(Aqdog\*(Aq
\&                                           # $3 = \*(Aqhouse\*(Aq
.Ve
.PP
But what if we had an indeterminate number of words? This is the sort
of task \f(CW\*(C`//g\*(C'\fR was made for.  To extract all words, form the simple
regexp \f(CW\*(C`(\ew+)\*(C'\fR and loop over all matches with \f(CW\*(C`/(\ew+)/g\*(C'\fR:
.PP
.Vb 3
\&    while ($x =~ /(\ew+)/g) {
\&        print "Word is $1, ends at position ", pos $x, "\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 3
\&    Word is cat, ends at position 3
\&    Word is dog, ends at position 7
\&    Word is house, ends at position 13
.Ve
.PP
A failed match or changing the target string resets the position.  If
you don't want the position reset after failure to match, add the
\&\f(CW\*(C`//c\*(C'\fR, as in \f(CW\*(C`/regexp/gc\*(C'\fR.  The current position in the string is
associated with the string, not the regexp.  This means that different
strings have different positions and their respective positions can be
set or read independently.
.PP
In list context, \f(CW\*(C`//g\*(C'\fR returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole regexp.  So if
we wanted just the words, we could use
.PP
.Vb 4
\&    @words = ($x =~ /(\ew+)/g);  # matches,
\&                                # $words[0] = \*(Aqcat\*(Aq
\&                                # $words[1] = \*(Aqdog\*(Aq
\&                                # $words[2] = \*(Aqhouse\*(Aq
.Ve
.PP
Closely associated with the \f(CW\*(C`//g\*(C'\fR modifier is the \f(CW\*(C`\eG\*(C'\fR anchor.  The
\&\f(CW\*(C`\eG\*(C'\fR anchor matches at the point where the previous \f(CW\*(C`//g\*(C'\fR match left
off.  \f(CW\*(C`\eG\*(C'\fR allows us to easily do context-sensitive matching:
.PP
.Vb 12
\&    $metric = 1;  # use metric units
\&    ...
\&    $x = <FILE>;  # read in measurement
\&    $x =~ /^([+\-]?\ed+)\es*/g;  # get magnitude
\&    $weight = $1;
\&    if ($metric) { # error checking
\&        print "Units error!" unless $x =~ /\eGkg\e./g;
\&    }
\&    else {
\&        print "Units error!" unless $x =~ /\eGlbs\e./g;
\&    }
\&    $x =~ /\eG\es+(widget|sprocket)/g;  # continue processing
.Ve
.PP
The combination of \f(CW\*(C`//g\*(C'\fR and \f(CW\*(C`\eG\*(C'\fR allows us to process the string a
bit at a time and use arbitrary Perl logic to decide what to do next.
Currently, the \f(CW\*(C`\eG\*(C'\fR anchor is only fully supported when used to anchor
to the start of the pattern.
.PP
\&\f(CW\*(C`\eG\*(C'\fR is also invaluable in processing fixed-length records with
regexps.  Suppose we have a snippet of coding region \s-1DNA,\s0 encoded as
base pair letters \f(CW\*(C`ATCGTTGAAT...\*(C'\fR and we want to find all the stop
codons \f(CW\*(C`TGA\*(C'\fR.  In a coding region, codons are 3\-letter sequences, so
we can think of the \s-1DNA\s0 snippet as a sequence of 3\-letter records.  The
naive regexp
.PP
.Vb 3
\&    # expanded, this is "ATC GTT GAA TGC AAA TGA CAT GAC"
\&    $dna = "ATCGTTGAATGCAAATGACATGAC";
\&    $dna =~ /TGA/;
.Ve
.PP
doesn't work; it may match a \f(CW\*(C`TGA\*(C'\fR, but there is no guarantee that
the match is aligned with codon boundaries, e.g., the substring
\&\f(CW\*(C`GTT\ GAA\*(C'\fR gives a match.  A better solution is
.PP
.Vb 3
\&    while ($dna =~ /(\ew\ew\ew)*?TGA/g) {  # note the minimal *?
\&        print "Got a TGA stop codon at position ", pos $dna, "\en";
\&    }
.Ve
.PP
which prints
.PP
.Vb 2
\&    Got a TGA stop codon at position 18
\&    Got a TGA stop codon at position 23
.Ve
.PP
Position 18 is good, but position 23 is bogus.  What happened?
.PP
The answer is that our regexp works well until we get past the last
real match.  Then the regexp will fail to match a synchronized \f(CW\*(C`TGA\*(C'\fR
and start stepping ahead one character position at a time, not what we
want.  The solution is to use \f(CW\*(C`\eG\*(C'\fR to anchor the match to the codon
alignment:
.PP
.Vb 3
\&    while ($dna =~ /\eG(\ew\ew\ew)*?TGA/g) {
\&        print "Got a TGA stop codon at position ", pos $dna, "\en";
\&    }
.Ve
.PP
This prints
.PP
.Vb 1
\&    Got a TGA stop codon at position 18
.Ve
.PP
which is the correct answer.  This example illustrates that it is
important not only to match what is desired, but to reject what is not
desired.
.PP
(There are other regexp modifiers that are available, such as
\&\f(CW\*(C`//o\*(C'\fR, but their specialized uses are beyond the
scope of this introduction.  )
.PP
\fISearch and replace\fR
.IX Subsection "Search and replace"
.PP
Regular expressions also play a big role in \fIsearch and replace\fR
operations in Perl.  Search and replace is accomplished with the
\&\f(CW\*(C`s///\*(C'\fR operator.  The general form is
\&\f(CW\*(C`s/regexp/replacement/modifiers\*(C'\fR, with everything we know about
regexps and modifiers applying in this case as well.  The
\&\f(CW\*(C`replacement\*(C'\fR is a Perl double-quoted string that replaces in the
string whatever is matched with the \f(CW\*(C`regexp\*(C'\fR.  The operator \f(CW\*(C`=~\*(C'\fR is
also used here to associate a string with \f(CW\*(C`s///\*(C'\fR.  If matching
against \f(CW$_\fR, the \f(CW\*(C`$_\ =~\*(C'\fR can be dropped.  If there is a match,
\&\f(CW\*(C`s///\*(C'\fR returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:
.PP
.Vb 8
\&    $x = "Time to feed the cat!";
\&    $x =~ s/cat/hacker/;   # $x contains "Time to feed the hacker!"
\&    if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
\&        $more_insistent = 1;
\&    }
\&    $y = "\*(Aqquoted words\*(Aq";
\&    $y =~ s/^\*(Aq(.*)\*(Aq$/$1/;  # strip single quotes,
\&                           # $y contains "quoted words"
.Ve
.PP
In the last example, the whole string was matched, but only the part
inside the single quotes was grouped.  With the \f(CW\*(C`s///\*(C'\fR operator, the
matched variables \f(CW$1\fR, \f(CW$2\fR, etc. are immediately available for use
in the replacement expression, so we use \f(CW$1\fR to replace the quoted
string with just what was quoted.  With the global modifier, \f(CW\*(C`s///g\*(C'\fR
will search and replace all occurrences of the regexp in the string:
.PP
.Vb 6
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/;   # doesn\*(Aqt do it all:
\&                       # $x contains "I batted four for 4"
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/g;  # does it all:
\&                       # $x contains "I batted four for four"
.Ve
.PP
If you prefer 'regex' over 'regexp' in this tutorial, you could use
the following program to replace it:
.PP
.Vb 9
\&    % cat > simple_replace
\&    #!/usr/bin/perl
\&    $regexp = shift;
\&    $replacement = shift;
\&    while (<>) {
\&        s/$regexp/$replacement/g;
\&        print;
\&    }
\&    ^D
\&
\&    % simple_replace regexp regex perlretut.pod
.Ve
.PP
In \f(CW\*(C`simple_replace\*(C'\fR we used the \f(CW\*(C`s///g\*(C'\fR modifier to replace all
occurrences of the regexp on each line.  (Even though the regular
expression appears in a loop, Perl is smart enough to compile it
only once.)  As with \f(CW\*(C`simple_grep\*(C'\fR, both the
\&\f(CW\*(C`print\*(C'\fR and the \f(CW\*(C`s/$regexp/$replacement/g\*(C'\fR use \f(CW$_\fR implicitly.
.PP
If you don't want \f(CW\*(C`s///\*(C'\fR to change your original variable you can use
the non-destructive substitute modifier, \f(CW\*(C`s///r\*(C'\fR.  This changes the
behavior so that \f(CW\*(C`s///r\*(C'\fR returns the final substituted string
(instead of the number of substitutions):
.PP
.Vb 3
\&    $x = "I like dogs.";
\&    $y = $x =~ s/dogs/cats/r;
\&    print "$x $y\en";
.Ve
.PP
That example will print \*(L"I like dogs. I like cats\*(R". Notice the original
\&\f(CW$x\fR variable has not been affected. The overall
result of the substitution is instead stored in \f(CW$y\fR. If the
substitution doesn't affect anything then the original string is
returned:
.PP
.Vb 3
\&    $x = "I like dogs.";
\&    $y = $x =~ s/elephants/cougars/r;
\&    print "$x $y\en"; # prints "I like dogs. I like dogs."
.Ve
.PP
One other interesting thing that the \f(CW\*(C`s///r\*(C'\fR flag allows is chaining
substitutions:
.PP
.Vb 3
\&    $x = "Cats are great.";
\&    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, "\en";
\&    # prints "Hedgehogs are great."
.Ve
.PP
A modifier available specifically to search and replace is the
\&\f(CW\*(C`s///e\*(C'\fR evaluation modifier.  \f(CW\*(C`s///e\*(C'\fR treats the
replacement text as Perl code, rather than a double-quoted
string.  The value that the code returns is substituted for the
matched substring.  \f(CW\*(C`s///e\*(C'\fR is useful if you need to do a bit of
computation in the process of replacing text.  This example counts
character frequencies in a line:
.PP
.Vb 4
\&    $x = "Bill the cat";
\&    $x =~ s/(.)/$chars{$1}++;$1/eg;  # final $1 replaces char with itself
\&    print "frequency of \*(Aq$_\*(Aq is $chars{$_}\en"
\&        foreach (sort {$chars{$b} <=> $chars{$a}} keys %chars);
.Ve
.PP
This prints
.PP
.Vb 9
\&    frequency of \*(Aq \*(Aq is 2
\&    frequency of \*(Aqt\*(Aq is 2
\&    frequency of \*(Aql\*(Aq is 2
\&    frequency of \*(AqB\*(Aq is 1
\&    frequency of \*(Aqc\*(Aq is 1
\&    frequency of \*(Aqe\*(Aq is 1
\&    frequency of \*(Aqh\*(Aq is 1
\&    frequency of \*(Aqi\*(Aq is 1
\&    frequency of \*(Aqa\*(Aq is 1
.Ve
.PP
As with the match \f(CW\*(C`m//\*(C'\fR operator, \f(CW\*(C`s///\*(C'\fR can use other delimiters,
such as \f(CW\*(C`s!!!\*(C'\fR and \f(CW\*(C`s{}{}\*(C'\fR, and even \f(CW\*(C`s{}//\*(C'\fR.  If single quotes are
used \f(CW\*(C`s\*(Aq\*(Aq\*(Aq\*(C'\fR, then the regexp and replacement are
treated as single-quoted strings and there are no
variable substitutions.  \f(CW\*(C`s///\*(C'\fR in list context
returns the same thing as in scalar context, i.e., the number of
matches.
.PP
\fIThe split function\fR
.IX Subsection "The split function"
.PP
The \f(CW\*(C`split()\*(C'\fR function is another place where a regexp is used.
\&\f(CW\*(C`split /regexp/, string, limit\*(C'\fR separates the \f(CW\*(C`string\*(C'\fR operand into
a list of substrings and returns that list.  The regexp must be designed
to match whatever constitutes the separators for the desired substrings.
The \f(CW\*(C`limit\*(C'\fR, if present, constrains splitting into no more than \f(CW\*(C`limit\*(C'\fR
number of strings.  For example, to split a string into words, use
.PP
.Vb 4
\&    $x = "Calvin and Hobbes";
\&    @words = split /\es+/, $x;  # $word[0] = \*(AqCalvin\*(Aq
\&                               # $word[1] = \*(Aqand\*(Aq
\&                               # $word[2] = \*(AqHobbes\*(Aq
.Ve
.PP
If the empty regexp \f(CW\*(C`//\*(C'\fR is used, the regexp always matches and
the string is split into individual characters.  If the regexp has
groupings, then the resulting list contains the matched substrings from the
groupings as well.  For instance,
.PP
.Vb 12
\&    $x = "/usr/bin/perl";
\&    @dirs = split m!/!, $x;  # $dirs[0] = \*(Aq\*(Aq
\&                             # $dirs[1] = \*(Aqusr\*(Aq
\&                             # $dirs[2] = \*(Aqbin\*(Aq
\&                             # $dirs[3] = \*(Aqperl\*(Aq
\&    @parts = split m!(/)!, $x;  # $parts[0] = \*(Aq\*(Aq
\&                                # $parts[1] = \*(Aq/\*(Aq
\&                                # $parts[2] = \*(Aqusr\*(Aq
\&                                # $parts[3] = \*(Aq/\*(Aq
\&                                # $parts[4] = \*(Aqbin\*(Aq
\&                                # $parts[5] = \*(Aq/\*(Aq
\&                                # $parts[6] = \*(Aqperl\*(Aq
.Ve
.PP
Since the first character of \f(CW$x\fR matched the regexp, \f(CW\*(C`split\*(C'\fR prepended
an empty initial element to the list.
.PP
If you have read this far, congratulations! You now have all the basic
tools needed to use regular expressions to solve a wide range of text
processing problems.  If this is your first time through the tutorial,
why not stop here and play around with regexps a while....  Part\ 2
concerns the more esoteric aspects of regular expressions and those
concepts certainly aren't needed right at the start.
.SH "Part 2: Power tools"
.IX Header "Part 2: Power tools"
\&\s-1OK,\s0 you know the basics of regexps and you want to know more.  If
matching regular expressions is analogous to a walk in the woods, then
the tools discussed in Part 1 are analogous to topo maps and a
compass, basic tools we use all the time.  Most of the tools in part 2
are analogous to flare guns and satellite phones.  They aren't used
too often on a hike, but when we are stuck, they can be invaluable.
.PP
What follows are the more advanced, less used, or sometimes esoteric
capabilities of Perl regexps.  In Part 2, we will assume you are
comfortable with the basics and concentrate on the advanced features.
.SS "More on characters, strings, and character classes"
.IX Subsection "More on characters, strings, and character classes"
There are a number of escape sequences and character classes that we
haven't covered yet.
.PP
There are several escape sequences that convert characters or strings
between upper and lower case, and they are also available within
patterns.  \f(CW\*(C`\el\*(C'\fR and \f(CW\*(C`\eu\*(C'\fR convert the next character to lower or
upper case, respectively:
.PP
.Vb 4
\&    $x = "perl";
\&    $string =~ /\eu$x/;  # matches \*(AqPerl\*(Aq in $string
\&    $x = "M(rs?|s)\e\e."; # note the double backslash
\&    $string =~ /\el$x/;  # matches \*(Aqmr.\*(Aq, \*(Aqmrs.\*(Aq, and \*(Aqms.\*(Aq,
.Ve
.PP
A \f(CW\*(C`\eL\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR indicates a lasting conversion of case, until
terminated by \f(CW\*(C`\eE\*(C'\fR or thrown over by another \f(CW\*(C`\eU\*(C'\fR or \f(CW\*(C`\eL\*(C'\fR:
.PP
.Vb 4
\&    $x = "This word is in lower case:\eL SHOUT\eE";
\&    $x =~ /shout/;       # matches
\&    $x = "I STILL KEYPUNCH CARDS FOR MY 360"
\&    $x =~ /\eUkeypunch/;  # matches punch card string
.Ve
.PP
If there is no \f(CW\*(C`\eE\*(C'\fR, case is converted until the end of the
string. The regexps \f(CW\*(C`\eL\eu$word\*(C'\fR or \f(CW\*(C`\eu\eL$word\*(C'\fR convert the first
character of \f(CW$word\fR to uppercase and the rest of the characters to
lowercase.
.PP
Control characters can be escaped with \f(CW\*(C`\ec\*(C'\fR, so that a control-Z
character would be matched with \f(CW\*(C`\ecZ\*(C'\fR.  The escape sequence
\&\f(CW\*(C`\eQ\*(C'\fR...\f(CW\*(C`\eE\*(C'\fR quotes, or protects most non-alphabetic characters.   For
instance,
.PP
.Vb 2
\&    $x = "\eQThat !^*&%~& cat!";
\&    $x =~ /\eQ!^*&%~&\eE/;  # check for rough language
.Ve
.PP
It does not protect \f(CW\*(C`$\*(C'\fR or \f(CW\*(C`@\*(C'\fR, so that variables can still be
substituted.
.PP
\&\f(CW\*(C`\eQ\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR and \f(CW\*(C`\eE\*(C'\fR are actually part of
double-quotish syntax, and not part of regexp syntax proper.  They will
work if they appear in a regular expression embedded directly in a
program, but not when contained in a string that is interpolated in a
pattern.
.PP
Perl regexps can handle more than just the
standard \s-1ASCII\s0 character set.  Perl supports \fIUnicode\fR, a standard
for representing the alphabets from virtually all of the world's written
languages, and a host of symbols.  Perl's text strings are Unicode strings, so
they can contain characters with a value (codepoint or character number) higher
than 255.
.PP
What does this mean for regexps? Well, regexp users don't need to know
much about Perl's internal representation of strings.  But they do need
to know 1) how to represent Unicode characters in a regexp and 2) that
a matching operation will treat the string to be searched as a sequence
of characters, not bytes.  The answer to 1) is that Unicode characters
greater than \f(CW\*(C`chr(255)\*(C'\fR are represented using the \f(CW\*(C`\ex{hex}\*(C'\fR notation, because
\&\ex hex (without curly braces) doesn't go further than 255.  (Starting in Perl
5.14, if you're an octal fan, you can also use \f(CW\*(C`\eo{oct}\*(C'\fR.)
.PP
.Vb 1
\&    /\ex{263a}/;  # match a Unicode smiley face :)
.Ve
.PP
\&\fB\s-1NOTE\s0\fR: In Perl 5.6.0 it used to be that one needed to say \f(CW\*(C`use
utf8\*(C'\fR to use any Unicode features.  This is no more the case: for
almost all Unicode processing, the explicit \f(CW\*(C`utf8\*(C'\fR pragma is not
needed.  (The only case where it matters is if your Perl script is in
Unicode and encoded in \s-1UTF\-8,\s0 then an explicit \f(CW\*(C`use utf8\*(C'\fR is needed.)
.PP
Figuring out the hexadecimal sequence of a Unicode character you want
or deciphering someone else's hexadecimal Unicode regexp is about as
much fun as programming in machine code.  So another way to specify
Unicode characters is to use the \fInamed character\fR escape
sequence \f(CW\*(C`\eN{\f(CIname\f(CW}\*(C'\fR.  \fIname\fR is a name for the Unicode character, as
specified in the Unicode standard.  For instance, if we wanted to
represent or match the astrological sign for the planet Mercury, we
could use
.PP
.Vb 2
\&    $x = "abc\eN{MERCURY}def";
\&    $x =~ /\eN{MERCURY}/;   # matches
.Ve
.PP
One can also use \*(L"short\*(R" names:
.PP
.Vb 2
\&    print "\eN{GREEK SMALL LETTER SIGMA} is called sigma.\en";
\&    print "\eN{greek:Sigma} is an upper\-case sigma.\en";
.Ve
.PP
You can also restrict names to a certain alphabet by specifying the
charnames pragma:
.PP
.Vb 2
\&    use charnames qw(greek);
\&    print "\eN{sigma} is Greek sigma\en";
.Ve
.PP
An index of character names is available on-line from the Unicode
Consortium, <http://www.unicode.org/charts/charindex.html>; explanatory
material with links to other resources at
<http://www.unicode.org/standard/where>.
.PP
The answer to requirement 2) is that a regexp (mostly)
uses Unicode characters.  The \*(L"mostly\*(R" is for messy backward
compatibility reasons, but starting in Perl 5.14, any regex compiled in
the scope of a \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR (which is automatically
turned on within the scope of a \f(CW\*(C`use 5.012\*(C'\fR or higher) will turn that
\&\*(L"mostly\*(R" into \*(L"always\*(R".  If you want to handle Unicode properly, you
should ensure that \f(CW\*(Aqunicode_strings\*(Aq\fR is turned on.
Internally, this is encoded to bytes using either \s-1UTF\-8\s0 or a native 8
bit encoding, depending on the history of the string, but conceptually
it is a sequence of characters, not bytes. See perlunitut for a
tutorial about that.
.PP
Let us now discuss Unicode character classes.  Just as with Unicode
characters, there are named Unicode character classes represented by the
\&\f(CW\*(C`\ep{name}\*(C'\fR escape sequence.  Closely associated is the \f(CW\*(C`\eP{name}\*(C'\fR
character class, which is the negation of the \f(CW\*(C`\ep{name}\*(C'\fR class.  For
example, to match lower and uppercase characters,
.PP
.Vb 5
\&    $x = "BOB";
\&    $x =~ /^\ep{IsUpper}/;   # matches, uppercase char class
\&    $x =~ /^\eP{IsUpper}/;   # doesn\*(Aqt match, char class sans uppercase
\&    $x =~ /^\ep{IsLower}/;   # doesn\*(Aqt match, lowercase char class
\&    $x =~ /^\eP{IsLower}/;   # matches, char class sans lowercase
.Ve
.PP
(The \*(L"Is\*(R" is optional.)
.PP
Here is the association between some Perl named classes and the
traditional Unicode classes:
.PP
.Vb 1
\&    Perl class name  Unicode class name or regular expression
\&
\&    IsAlpha          /^[LM]/
\&    IsAlnum          /^[LMN]/
\&    IsASCII          $code <= 127
\&    IsCntrl          /^C/
\&    IsBlank          $code =~ /^(0020|0009)$/ || /^Z[^lp]/
\&    IsDigit          Nd
\&    IsGraph          /^([LMNPS]|Co)/
\&    IsLower          Ll
\&    IsPrint          /^([LMNPS]|Co|Zs)/
\&    IsPunct          /^P/
\&    IsSpace          /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/
\&    IsSpacePerl      /^Z/ || ($code =~ /^(0009|000A|000C|000D|0085|2028|2029)$/
\&    IsUpper          /^L[ut]/
\&    IsWord           /^[LMN]/ || $code eq "005F"
\&    IsXDigit         $code =~ /^00(3[0\-9]|[46][1\-6])$/
.Ve
.PP
You can also use the official Unicode class names with \f(CW\*(C`\ep\*(C'\fR and
\&\f(CW\*(C`\eP\*(C'\fR, like \f(CW\*(C`\ep{L}\*(C'\fR for Unicode 'letters', \f(CW\*(C`\ep{Lu}\*(C'\fR for uppercase
letters, or \f(CW\*(C`\eP{Nd}\*(C'\fR for non-digits.  If a \f(CW\*(C`name\*(C'\fR is just one
letter, the braces can be dropped.  For instance, \f(CW\*(C`\epM\*(C'\fR is the
character class of Unicode 'marks', for example accent marks.
For the full list see perlunicode.
.PP
Unicode has also been separated into various sets of characters
which you can test with \f(CW\*(C`\ep{...}\*(C'\fR (in) and \f(CW\*(C`\eP{...}\*(C'\fR (not in).
To test whether a character is (or is not) an element of a script
you would use the script name, for example \f(CW\*(C`\ep{Latin}\*(C'\fR, \f(CW\*(C`\ep{Greek}\*(C'\fR,
or \f(CW\*(C`\eP{Katakana}\*(C'\fR.
.PP
What we have described so far is the single form of the \f(CW\*(C`\ep{...}\*(C'\fR character
classes.  There is also a compound form which you may run into.  These
look like \f(CW\*(C`\ep{name=value}\*(C'\fR or \f(CW\*(C`\ep{name:value}\*(C'\fR (the equals sign and colon
can be used interchangeably).  These are more general than the single form,
and in fact most of the single forms are just Perl-defined shortcuts for common
compound forms.  For example, the script examples in the previous paragraph
could be written equivalently as \f(CW\*(C`\ep{Script=Latin}\*(C'\fR, \f(CW\*(C`\ep{Script:Greek}\*(C'\fR, and
\&\f(CW\*(C`\eP{script=katakana}\*(C'\fR (case is irrelevant between the \f(CW\*(C`{}\*(C'\fR braces).  You may
never have to use the compound forms, but sometimes it is necessary, and their
use can make your code easier to understand.
.PP
\&\f(CW\*(C`\eX\*(C'\fR is an abbreviation for a character class that comprises
a Unicode \fIextended grapheme cluster\fR.  This represents a \*(L"logical character\*(R":
what appears to be a single character, but may be represented internally by more
than one.  As an example, using the Unicode full names, e.g., \f(CW\*(C`A\ +\ COMBINING\ RING\*(C'\fR is a grapheme cluster with base character \f(CW\*(C`A\*(C'\fR and combining character
\&\f(CW\*(C`COMBINING\ RING\*(C'\fR, which translates in Danish to A with the circle atop it,
as in the word Angstrom.
.PP
For the full and latest information about Unicode see the latest
Unicode standard, or the Unicode Consortium's website <http://www.unicode.org>
.PP
As if all those classes weren't enough, Perl also defines POSIX-style
character classes.  These have the form \f(CW\*(C`[:name:]\*(C'\fR, with \f(CW\*(C`name\*(C'\fR the
name of the \s-1POSIX\s0 class.  The \s-1POSIX\s0 classes are \f(CW\*(C`alpha\*(C'\fR, \f(CW\*(C`alnum\*(C'\fR,
\&\f(CW\*(C`ascii\*(C'\fR, \f(CW\*(C`cntrl\*(C'\fR, \f(CW\*(C`digit\*(C'\fR, \f(CW\*(C`graph\*(C'\fR, \f(CW\*(C`lower\*(C'\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`punct\*(C'\fR,
\&\f(CW\*(C`space\*(C'\fR, \f(CW\*(C`upper\*(C'\fR, and \f(CW\*(C`xdigit\*(C'\fR, and two extensions, \f(CW\*(C`word\*(C'\fR (a Perl
extension to match \f(CW\*(C`\ew\*(C'\fR), and \f(CW\*(C`blank\*(C'\fR (a \s-1GNU\s0 extension).  The \f(CW\*(C`//a\*(C'\fR
modifier restricts these to matching just in the \s-1ASCII\s0 range; otherwise
they can match the same as their corresponding Perl Unicode classes:
\&\f(CW\*(C`[:upper:]\*(C'\fR is the same as \f(CW\*(C`\ep{IsUpper}\*(C'\fR, etc.  (There are some
exceptions and gotchas with this; see perlrecharclass for a full
discussion.) The \f(CW\*(C`[:digit:]\*(C'\fR, \f(CW\*(C`[:word:]\*(C'\fR, and
\&\f(CW\*(C`[:space:]\*(C'\fR correspond to the familiar \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, and \f(CW\*(C`\es\*(C'\fR
character classes.  To negate a \s-1POSIX\s0 class, put a \f(CW\*(C`^\*(C'\fR in front of
the name, so that, e.g., \f(CW\*(C`[:^digit:]\*(C'\fR corresponds to \f(CW\*(C`\eD\*(C'\fR and, under
Unicode, \f(CW\*(C`\eP{IsDigit}\*(C'\fR.  The Unicode and \s-1POSIX\s0 character classes can
be used just like \f(CW\*(C`\ed\*(C'\fR, with the exception that \s-1POSIX\s0 character
classes can only be used inside of a character class:
.PP
.Vb 6
\&    /\es+[abc[:digit:]xyz]\es*/;  # match a,b,c,x,y,z, or a digit
\&    /^=item\es[[:digit:]]/;      # match \*(Aq=item\*(Aq,
\&                                # followed by a space and a digit
\&    /\es+[abc\ep{IsDigit}xyz]\es+/;  # match a,b,c,x,y,z, or a digit
\&    /^=item\es\ep{IsDigit}/;        # match \*(Aq=item\*(Aq,
\&                                  # followed by a space and a digit
.Ve
.PP
Whew! That is all the rest of the characters and character classes.
.SS "Compiling and saving regular expressions"
.IX Subsection "Compiling and saving regular expressions"
In Part 1 we mentioned that Perl compiles a regexp into a compact
sequence of opcodes.  Thus, a compiled regexp is a data structure
that can be stored once and used again and again.  The regexp quote
\&\f(CW\*(C`qr//\*(C'\fR does exactly that: \f(CW\*(C`qr/string/\*(C'\fR compiles the \f(CW\*(C`string\*(C'\fR as a
regexp and transforms the result into a form that can be assigned to a
variable:
.PP
.Vb 1
\&    $reg = qr/foo+bar?/;  # reg contains a compiled regexp
.Ve
.PP
Then \f(CW$reg\fR can be used as a regexp:
.PP
.Vb 3
\&    $x = "fooooba";
\&    $x =~ $reg;     # matches, just like /foo+bar?/
\&    $x =~ /$reg/;   # same thing, alternate form
.Ve
.PP
\&\f(CW$reg\fR can also be interpolated into a larger regexp:
.PP
.Vb 1
\&    $x =~ /(abc)?$reg/;  # still matches
.Ve
.PP
As with the matching operator, the regexp quote can use different
delimiters, e.g., \f(CW\*(C`qr!!\*(C'\fR, \f(CW\*(C`qr{}\*(C'\fR or \f(CW\*(C`qr~~\*(C'\fR.  Apostrophes
as delimiters (\f(CW\*(C`qr\*(Aq\*(Aq\*(C'\fR) inhibit any interpolation.
.PP
Pre-compiled regexps are useful for creating dynamic matches that
don't need to be recompiled each time they are encountered.  Using
pre-compiled regexps, we write a \f(CW\*(C`grep_step\*(C'\fR program which greps
for a sequence of patterns, advancing to the next pattern as soon
as one has been satisfied.
.PP
.Vb 4
\&    % cat > grep_step
\&    #!/usr/bin/perl
\&    # grep_step \- match <number> regexps, one after the other
\&    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...
\&
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
\&    @compiled = map qr/$_/, @regexp;
\&    while ($line = <>) {
\&        if ($line =~ /$compiled[0]/) {
\&            print $line;
\&            shift @compiled;
\&            last unless @compiled;
\&        }
\&    }
\&    ^D
\&
\&    % grep_step 3 shift print last grep_step
\&    $number = shift;
\&            print $line;
\&            last unless @compiled;
.Ve
.PP
Storing pre-compiled regexps in an array \f(CW@compiled\fR allows us to
simply loop through the regexps without any recompilation, thus gaining
flexibility without sacrificing speed.
.SS "Composing regular expressions at runtime"
.IX Subsection "Composing regular expressions at runtime"
Backtracking is more efficient than repeated tries with different regular
expressions.  If there are several regular expressions and a match with
any of them is acceptable, then it is possible to combine them into a set
of alternatives.  If the individual expressions are input data, this
can be done by programming a join operation.  We'll exploit this idea in
an improved version of the \f(CW\*(C`simple_grep\*(C'\fR program: a program that matches
multiple patterns:
.PP
.Vb 4
\&    % cat > multi_grep
\&    #!/usr/bin/perl
\&    # multi_grep \- match any of <number> regexps
\&    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...
\&
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
\&    $pattern = join \*(Aq|\*(Aq, @regexp;
\&
\&    while ($line = <>) {
\&        print $line if $line =~ /$pattern/;
\&    }
\&    ^D
\&
\&    % multi_grep 2 shift for multi_grep
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
.Ve
.PP
Sometimes it is advantageous to construct a pattern from the \fIinput\fR
that is to be analyzed and use the permissible values on the left
hand side of the matching operations.  As an example for this somewhat
paradoxical situation, let's assume that our input contains a command
verb which should match one out of a set of available command verbs,
with the additional twist that commands may be abbreviated as long as
the given string is unique. The program below demonstrates the basic
algorithm.
.PP
.Vb 10
\&    % cat > keymatch
\&    #!/usr/bin/perl
\&    $kwds = \*(Aqcopy compare list print\*(Aq;
\&    while( $command = <> ){
\&        $command =~ s/^\es+|\es+$//g;  # trim leading and trailing spaces
\&        if( ( @matches = $kwds =~ /\eb$command\ew*/g ) == 1 ){
\&            print "command: \*(Aq@matches\*(Aq\en";
\&        } elsif( @matches == 0 ){
\&            print "no such command: \*(Aq$command\*(Aq\en";
\&        } else {
\&            print "not unique: \*(Aq$command\*(Aq (could be one of: @matches)\en";
\&        }
\&    }
\&    ^D
\&
\&    % keymatch
\&    li
\&    command: \*(Aqlist\*(Aq
\&    co
\&    not unique: \*(Aqco\*(Aq (could be one of: copy compare)
\&    printer
\&    no such command: \*(Aqprinter\*(Aq
.Ve
.PP
Rather than trying to match the input against the keywords, we match the
combined set of keywords against the input.  The pattern matching
operation \f(CW\*(C`$kwds\ =~\ /\eb($command\ew*)/g\*(C'\fR does several things at the
same time. It makes sure that the given command begins where a keyword
begins (\f(CW\*(C`\eb\*(C'\fR). It tolerates abbreviations due to the added \f(CW\*(C`\ew*\*(C'\fR. It
tells us the number of matches (\f(CW\*(C`scalar @matches\*(C'\fR) and all the keywords
that were actually matched.  You could hardly ask for more.
.SS "Embedding comments and modifiers in a regular expression"
.IX Subsection "Embedding comments and modifiers in a regular expression"
Starting with this section, we will be discussing Perl's set of
\&\fIextended patterns\fR.  These are extensions to the traditional regular
expression syntax that provide powerful new tools for pattern
matching.  We have already seen extensions in the form of the minimal
matching constructs \f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{n,m}?\*(C'\fR, and \f(CW\*(C`{n,}?\*(C'\fR.  Most
of the extensions below have the form \f(CW\*(C`(?char...)\*(C'\fR, where the
\&\f(CW\*(C`char\*(C'\fR is a character that determines the type of extension.
.PP
The first extension is an embedded comment \f(CW\*(C`(?#text)\*(C'\fR.  This embeds a
comment into the regular expression without affecting its meaning.  The
comment should not have any closing parentheses in the text.  An
example is
.PP
.Vb 1
\&    /(?# Match an integer:)[+\-]?\ed+/;
.Ve
.PP
This style of commenting has been largely superseded by the raw,
freeform commenting that is allowed with the \f(CW\*(C`//x\*(C'\fR modifier.
.PP
Most modifiers, such as \f(CW\*(C`//i\*(C'\fR, \f(CW\*(C`//m\*(C'\fR, \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//x\*(C'\fR (or any
combination thereof) can also be embedded in
a regexp using \f(CW\*(C`(?i)\*(C'\fR, \f(CW\*(C`(?m)\*(C'\fR, \f(CW\*(C`(?s)\*(C'\fR, and \f(CW\*(C`(?x)\*(C'\fR.  For instance,
.PP
.Vb 7
\&    /(?i)yes/;  # match \*(Aqyes\*(Aq case insensitively
\&    /yes/i;     # same thing
\&    /(?x)(          # freeform version of an integer regexp
\&             [+\-]?  # match an optional sign
\&             \ed+    # match a sequence of digits
\&         )
\&    /x;
.Ve
.PP
Embedded modifiers can have two important advantages over the usual
modifiers.  Embedded modifiers allow a custom set of modifiers to
\&\fIeach\fR regexp pattern.  This is great for matching an array of regexps
that must have different modifiers:
.PP
.Vb 8
\&    $pattern[0] = \*(Aq(?i)doctor\*(Aq;
\&    $pattern[1] = \*(AqJohnson\*(Aq;
\&    ...
\&    while (<>) {
\&        foreach $patt (@pattern) {
\&            print if /$patt/;
\&        }
\&    }
.Ve
.PP
The second advantage is that embedded modifiers (except \f(CW\*(C`//p\*(C'\fR, which
modifies the entire regexp) only affect the regexp
inside the group the embedded modifier is contained in.  So grouping
can be used to localize the modifier's effects:
.PP
.Vb 1
\&    /Answer: ((?i)yes)/;  # matches \*(AqAnswer: yes\*(Aq, \*(AqAnswer: YES\*(Aq, etc.
.Ve
.PP
Embedded modifiers can also turn off any modifiers already present
by using, e.g., \f(CW\*(C`(?\-i)\*(C'\fR.  Modifiers can also be combined into
a single expression, e.g., \f(CW\*(C`(?s\-i)\*(C'\fR turns on single line mode and
turns off case insensitivity.
.PP
Embedded modifiers may also be added to a non-capturing grouping.
\&\f(CW\*(C`(?i\-m:regexp)\*(C'\fR is a non-capturing grouping that matches \f(CW\*(C`regexp\*(C'\fR
case insensitively and turns off multi-line mode.
.SS "Looking ahead and looking behind"
.IX Subsection "Looking ahead and looking behind"
This section concerns the lookahead and lookbehind assertions.  First,
a little background.
.PP
In Perl regular expressions, most regexp elements 'eat up' a certain
amount of string when they match.  For instance, the regexp element
\&\f(CW\*(C`[abc}]\*(C'\fR eats up one character of the string when it matches, in the
sense that Perl moves to the next character position in the string
after the match.  There are some elements, however, that don't eat up
characters (advance the character position) if they match.  The examples
we have seen so far are the anchors.  The anchor \f(CW\*(C`^\*(C'\fR matches the
beginning of the line, but doesn't eat any characters.  Similarly, the
word boundary anchor \f(CW\*(C`\eb\*(C'\fR matches wherever a character matching \f(CW\*(C`\ew\*(C'\fR
is next to a character that doesn't, but it doesn't eat up any
characters itself.  Anchors are examples of \fIzero-width assertions\fR:
zero-width, because they consume
no characters, and assertions, because they test some property of the
string.  In the context of our walk in the woods analogy to regexp
matching, most regexp elements move us along a trail, but anchors have
us stop a moment and check our surroundings.  If the local environment
checks out, we can proceed forward.  But if the local environment
doesn't satisfy us, we must backtrack.
.PP
Checking the environment entails either looking ahead on the trail,
looking behind, or both.  \f(CW\*(C`^\*(C'\fR looks behind, to see that there are no
characters before.  \f(CW\*(C`$\*(C'\fR looks ahead, to see that there are no
characters after.  \f(CW\*(C`\eb\*(C'\fR looks both ahead and behind, to see if the
characters on either side differ in their \*(L"word-ness\*(R".
.PP
The lookahead and lookbehind assertions are generalizations of the
anchor concept.  Lookahead and lookbehind are zero-width assertions
that let us specify which characters we want to test for.  The
lookahead assertion is denoted by \f(CW\*(C`(?=regexp)\*(C'\fR and the lookbehind
assertion is denoted by \f(CW\*(C`(?<=fixed\-regexp)\*(C'\fR.  Some examples are
.PP
.Vb 8
\&    $x = "I catch the housecat \*(AqTom\-cat\*(Aq with catnip";
\&    $x =~ /cat(?=\es)/;   # matches \*(Aqcat\*(Aq in \*(Aqhousecat\*(Aq
\&    @catwords = ($x =~ /(?<=\es)cat\ew+/g);  # matches,
\&                                           # $catwords[0] = \*(Aqcatch\*(Aq
\&                                           # $catwords[1] = \*(Aqcatnip\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq in \*(AqTom\-cat\*(Aq
\&    $x =~ /(?<=\es)cat(?=\es)/; # doesn\*(Aqt match; no isolated \*(Aqcat\*(Aq in
\&                              # middle of $x
.Ve
.PP
Note that the parentheses in \f(CW\*(C`(?=regexp)\*(C'\fR and \f(CW\*(C`(?<=regexp)\*(C'\fR are
non-capturing, since these are zero-width assertions.  Thus in the
second regexp, the substrings captured are those of the whole regexp
itself.  Lookahead \f(CW\*(C`(?=regexp)\*(C'\fR can match arbitrary regexps, but
lookbehind \f(CW\*(C`(?<=fixed\-regexp)\*(C'\fR only works for regexps of fixed
width, i.e., a fixed number of characters long.  Thus
\&\f(CW\*(C`(?<=(ab|bc))\*(C'\fR is fine, but \f(CW\*(C`(?<=(ab)*)\*(C'\fR is not.  The
negated versions of the lookahead and lookbehind assertions are
denoted by \f(CW\*(C`(?!regexp)\*(C'\fR and \f(CW\*(C`(?<!fixed\-regexp)\*(C'\fR respectively.
They evaluate true if the regexps do \fInot\fR match:
.PP
.Vb 4
\&    $x = "foobar";
\&    $x =~ /foo(?!bar)/;  # doesn\*(Aqt match, \*(Aqbar\*(Aq follows \*(Aqfoo\*(Aq
\&    $x =~ /foo(?!baz)/;  # matches, \*(Aqbaz\*(Aq doesn\*(Aqt follow \*(Aqfoo\*(Aq
\&    $x =~ /(?<!\es)foo/;  # matches, there is no \es before \*(Aqfoo\*(Aq
.Ve
.PP
The \f(CW\*(C`\eC\*(C'\fR is unsupported in lookbehind, because the already
treacherous definition of \f(CW\*(C`\eC\*(C'\fR would become even more so
when going backwards.
.PP
Here is an example where a string containing blank-separated words,
numbers and single dashes is to be split into its components.
Using \f(CW\*(C`/\es+/\*(C'\fR alone won't work, because spaces are not required between
dashes, or a word or a dash. Additional places for a split are established
by looking ahead and behind:
.PP
.Vb 5
\&    $str = "one two \- \-\-6\-8";
\&    @toks = split / \es+              # a run of spaces
\&                  | (?<=\eS) (?=\-)    # any non\-space followed by \*(Aq\-\*(Aq
\&                  | (?<=\-)  (?=\eS)   # a \*(Aq\-\*(Aq followed by any non\-space
\&                  /x, $str;          # @toks = qw(one two \- \- \- 6 \- 8)
.Ve
.SS "Using independent subexpressions to prevent backtracking"
.IX Subsection "Using independent subexpressions to prevent backtracking"
\&\fIIndependent subexpressions\fR are regular expressions, in the
context of a larger regular expression, that function independently of
the larger regular expression.  That is, they consume as much or as
little of the string as they wish without regard for the ability of
the larger regexp to match.  Independent subexpressions are represented
by \f(CW\*(C`(?>regexp)\*(C'\fR.  We can illustrate their behavior by first
considering an ordinary regexp:
.PP
.Vb 2
\&    $x = "ab";
\&    $x =~ /a*ab/;  # matches
.Ve
.PP
This obviously matches, but in the process of matching, the
subexpression \f(CW\*(C`a*\*(C'\fR first grabbed the \f(CW\*(C`a\*(C'\fR.  Doing so, however,
wouldn't allow the whole regexp to match, so after backtracking, \f(CW\*(C`a*\*(C'\fR
eventually gave back the \f(CW\*(C`a\*(C'\fR and matched the empty string.  Here, what
\&\f(CW\*(C`a*\*(C'\fR matched was \fIdependent\fR on what the rest of the regexp matched.
.PP
Contrast that with an independent subexpression:
.PP
.Vb 1
\&    $x =~ /(?>a*)ab/;  # doesn\*(Aqt match!
.Ve
.PP
The independent subexpression \f(CW\*(C`(?>a*)\*(C'\fR doesn't care about the rest
of the regexp, so it sees an \f(CW\*(C`a\*(C'\fR and grabs it.  Then the rest of the
regexp \f(CW\*(C`ab\*(C'\fR cannot match.  Because \f(CW\*(C`(?>a*)\*(C'\fR is independent, there
is no backtracking and the independent subexpression does not give
up its \f(CW\*(C`a\*(C'\fR.  Thus the match of the regexp as a whole fails.  A similar
behavior occurs with completely independent regexps:
.PP
.Vb 3
\&    $x = "ab";
\&    $x =~ /a*/g;   # matches, eats an \*(Aqa\*(Aq
\&    $x =~ /\eGab/g; # doesn\*(Aqt match, no \*(Aqa\*(Aq available
.Ve
.PP
Here \f(CW\*(C`//g\*(C'\fR and \f(CW\*(C`\eG\*(C'\fR create a 'tag team' handoff of the string from
one regexp to the other.  Regexps with an independent subexpression are
much like this, with a handoff of the string to the independent
subexpression, and a handoff of the string back to the enclosing
regexp.
.PP
The ability of an independent subexpression to prevent backtracking
can be quite useful.  Suppose we want to match a non-empty string
enclosed in parentheses up to two levels deep.  Then the following
regexp matches:
.PP
.Vb 2
\&    $x = "abc(de(fg)h";  # unbalanced parentheses
\&    $x =~ /\e( ( [^()]+ | \e([^()]*\e) )+ \e)/x;
.Ve
.PP
The regexp matches an open parenthesis, one or more copies of an
alternation, and a close parenthesis.  The alternation is two-way, with
the first alternative \f(CW\*(C`[^()]+\*(C'\fR matching a substring with no
parentheses and the second alternative \f(CW\*(C`\e([^()]*\e)\*(C'\fR  matching a
substring delimited by parentheses.  The problem with this regexp is
that it is pathological: it has nested indeterminate quantifiers
of the form \f(CW\*(C`(a+|b)+\*(C'\fR.  We discussed in Part 1 how nested quantifiers
like this could take an exponentially long time to execute if there
was no match possible.  To prevent the exponential blowup, we need to
prevent useless backtracking at some point.  This can be done by
enclosing the inner quantifier as an independent subexpression:
.PP
.Vb 1
\&    $x =~ /\e( ( (?>[^()]+) | \e([^()]*\e) )+ \e)/x;
.Ve
.PP
Here, \f(CW\*(C`(?>[^()]+)\*(C'\fR breaks the degeneracy of string partitioning
by gobbling up as much of the string as possible and keeping it.   Then
match failures fail much more quickly.
.SS "Conditional expressions"
.IX Subsection "Conditional expressions"
A \fIconditional expression\fR is a form of if-then-else statement
that allows one to choose which patterns are to be matched, based on
some condition.  There are two types of conditional expression:
\&\f(CW\*(C`(?(condition)yes\-regexp)\*(C'\fR and
\&\f(CW\*(C`(?(condition)yes\-regexp|no\-regexp)\*(C'\fR.  \f(CW\*(C`(?(condition)yes\-regexp)\*(C'\fR is
like an \f(CW\*(Aqif\ ()\ {}\*(Aq\fR statement in Perl.  If the \f(CW\*(C`condition\*(C'\fR is true,
the \f(CW\*(C`yes\-regexp\*(C'\fR will be matched.  If the \f(CW\*(C`condition\*(C'\fR is false, the
\&\f(CW\*(C`yes\-regexp\*(C'\fR will be skipped and Perl will move onto the next regexp
element.  The second form is like an \f(CW\*(Aqif\ ()\ {}\ else\ {}\*(Aq\fR statement
in Perl.  If the \f(CW\*(C`condition\*(C'\fR is true, the \f(CW\*(C`yes\-regexp\*(C'\fR will be
matched, otherwise the \f(CW\*(C`no\-regexp\*(C'\fR will be matched.
.PP
The \f(CW\*(C`condition\*(C'\fR can have several forms.  The first form is simply an
integer in parentheses \f(CW\*(C`(integer)\*(C'\fR.  It is true if the corresponding
backreference \f(CW\*(C`\einteger\*(C'\fR matched earlier in the regexp.  The same
thing can be done with a name associated with a capture group, written
as \f(CW\*(C`(<name>)\*(C'\fR or \f(CW\*(C`(\*(Aqname\*(Aq)\*(C'\fR.  The second form is a bare
zero-width assertion \f(CW\*(C`(?...)\*(C'\fR, either a lookahead, a lookbehind, or a
code assertion (discussed in the next section).  The third set of forms
provides tests that return true if the expression is executed within
a recursion (\f(CW\*(C`(R)\*(C'\fR) or is being called from some capturing group,
referenced either by number (\f(CW\*(C`(R1)\*(C'\fR, \f(CW\*(C`(R2)\*(C'\fR,...) or by name
(\f(CW\*(C`(R&name)\*(C'\fR).
.PP
The integer or name form of the \f(CW\*(C`condition\*(C'\fR allows us to choose,
with more flexibility, what to match based on what matched earlier in the
regexp. This searches for words of the form \f(CW"$x$x"\fR or \f(CW"$x$y$y$x"\fR:
.PP
.Vb 9
\&    % simple_grep \*(Aq^(\ew+)(\ew+)?(?(2)\eg2\eg1|\eg1)$\*(Aq /usr/dict/words
\&    beriberi
\&    coco
\&    couscous
\&    deed
\&    ...
\&    toot
\&    toto
\&    tutu
.Ve
.PP
The lookbehind \f(CW\*(C`condition\*(C'\fR allows, along with backreferences,
an earlier part of the match to influence a later part of the
match.  For instance,
.PP
.Vb 1
\&    /[ATGC]+(?(?<=AA)G|C)$/;
.Ve
.PP
matches a \s-1DNA\s0 sequence such that it either ends in \f(CW\*(C`AAG\*(C'\fR, or some
other base pair combination and \f(CW\*(C`C\*(C'\fR.  Note that the form is
\&\f(CW\*(C`(?(?<=AA)G|C)\*(C'\fR and not \f(CW\*(C`(?((?<=AA))G|C)\*(C'\fR; for the
lookahead, lookbehind or code assertions, the parentheses around the
conditional are not needed.
.SS "Defining named patterns"
.IX Subsection "Defining named patterns"
Some regular expressions use identical subpatterns in several places.
Starting with Perl 5.10, it is possible to define named subpatterns in
a section of the pattern so that they can be called up by name
anywhere in the pattern.  This syntactic pattern for this definition
group is \f(CW\*(C`(?(DEFINE)(?<name>pattern)...)\*(C'\fR.  An insertion
of a named pattern is written as \f(CW\*(C`(?&name)\*(C'\fR.
.PP
The example below illustrates this feature using the pattern for
floating point numbers that was presented earlier on.  The three
subpatterns that are used more than once are the optional sign, the
digit sequence for an integer and the decimal fraction.  The \s-1DEFINE\s0
group at the end of the pattern contains their definition.  Notice
that the decimal fraction pattern is the first place where we can
reuse the integer pattern.
.PP
.Vb 8
\&   /^ (?&osg)\e * ( (?&int)(?&dec)? | (?&dec) )
\&      (?: [eE](?&osg)(?&int) )?
\&    $
\&    (?(DEFINE)
\&      (?<osg>[\-+]?)         # optional sign
\&      (?<int>\ed++)          # integer
\&      (?<dec>\e.(?&int))     # decimal fraction
\&    )/x
.Ve
.SS "Recursive patterns"
.IX Subsection "Recursive patterns"
This feature (introduced in Perl 5.10) significantly extends the
power of Perl's pattern matching.  By referring to some other
capture group anywhere in the pattern with the construct
\&\f(CW\*(C`(?group\-ref)\*(C'\fR, the \fIpattern\fR within the referenced group is used
as an independent subpattern in place of the group reference itself.
Because the group reference may be contained \fIwithin\fR the group it
refers to, it is now possible to apply pattern matching to tasks that
hitherto required a recursive parser.
.PP
To illustrate this feature, we'll design a pattern that matches if
a string contains a palindrome. (This is a word or a sentence that,
while ignoring spaces, interpunctuation and case, reads the same backwards
as forwards. We begin by observing that the empty string or a string
containing just one word character is a palindrome. Otherwise it must
have a word character up front and the same at its end, with another
palindrome in between.
.PP
.Vb 1
\&    /(?: (\ew) (?...Here be a palindrome...) \eg{\-1} | \ew? )/x
.Ve
.PP
Adding \f(CW\*(C`\eW*\*(C'\fR at either end to eliminate what is to be ignored, we already
have the full pattern:
.PP
.Vb 4
\&    my $pp = qr/^(\eW* (?: (\ew) (?1) \eg{\-1} | \ew? ) \eW*)$/ix;
\&    for $s ( "saippuakauppias", "A man, a plan, a canal: Panama!" ){
\&        print "\*(Aq$s\*(Aq is a palindrome\en" if $s =~ /$pp/;
\&    }
.Ve
.PP
In \f(CW\*(C`(?...)\*(C'\fR both absolute and relative backreferences may be used.
The entire pattern can be reinserted with \f(CW\*(C`(?R)\*(C'\fR or \f(CW\*(C`(?0)\*(C'\fR.
If you prefer to name your groups, you can use \f(CW\*(C`(?&name)\*(C'\fR to
recurse into that group.
.SS "A bit of magic: executing Perl code in a regular expression"
.IX Subsection "A bit of magic: executing Perl code in a regular expression"
Normally, regexps are a part of Perl expressions.
\&\fICode evaluation\fR expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp.  A code evaluation
expression is denoted \f(CW\*(C`(?{code})\*(C'\fR, with \fIcode\fR a string of Perl
statements.
.PP
Be warned that this feature is considered experimental, and may be
changed without notice.
.PP
Code expressions are zero-width assertions, and the value they return
depends on their environment.  There are two possibilities: either the
code expression is used as a conditional in a conditional expression
\&\f(CW\*(C`(?(condition)...)\*(C'\fR, or it is not.  If the code expression is a
conditional, the code is evaluated and the result (i.e., the result of
the last statement) is used to determine truth or falsehood.  If the
code expression is not used as a conditional, the assertion always
evaluates true and the result is put into the special variable
\&\f(CW$^R\fR.  The variable \f(CW$^R\fR can then be used in code expressions later
in the regexp.  Here are some silly examples:
.PP
.Vb 5
\&    $x = "abcdef";
\&    $x =~ /abc(?{print "Hi Mom!";})def/; # matches,
\&                                         # prints \*(AqHi Mom!\*(Aq
\&    $x =~ /aaa(?{print "Hi Mom!";})def/; # doesn\*(Aqt match,
\&                                         # no \*(AqHi Mom!\*(Aq
.Ve
.PP
Pay careful attention to the next example:
.PP
.Vb 3
\&    $x =~ /abc(?{print "Hi Mom!";})ddd/; # doesn\*(Aqt match,
\&                                         # no \*(AqHi Mom!\*(Aq
\&                                         # but why not?
.Ve
.PP
At first glance, you'd think that it shouldn't print, because obviously
the \f(CW\*(C`ddd\*(C'\fR isn't going to match the target string. But look at this
example:
.PP
.Vb 2
\&    $x =~ /abc(?{print "Hi Mom!";})[dD]dd/; # doesn\*(Aqt match,
\&                                            # but _does_ print
.Ve
.PP
Hmm. What happened here? If you've been following along, you know that
the above pattern should be effectively (almost) the same as the last one;
enclosing the \f(CW\*(C`d\*(C'\fR in a character class isn't going to change what it
matches. So why does the first not print while the second one does?
.PP
The answer lies in the optimizations the regex engine makes. In the first
case, all the engine sees are plain old characters (aside from the
\&\f(CW\*(C`?{}\*(C'\fR construct). It's smart enough to realize that the string 'ddd'
doesn't occur in our target string before actually running the pattern
through. But in the second case, we've tricked it into thinking that our
pattern is more complicated. It takes a look, sees our
character class, and decides that it will have to actually run the
pattern to determine whether or not it matches, and in the process of
running it hits the print statement before it discovers that we don't
have a match.
.PP
To take a closer look at how the engine does optimizations, see the
section \*(L"Pragmas and debugging\*(R" below.
.PP
More fun with \f(CW\*(C`?{}\*(C'\fR:
.PP
.Vb 6
\&    $x =~ /(?{print "Hi Mom!";})/;       # matches,
\&                                         # prints \*(AqHi Mom!\*(Aq
\&    $x =~ /(?{$c = 1;})(?{print "$c";})/;  # matches,
\&                                           # prints \*(Aq1\*(Aq
\&    $x =~ /(?{$c = 1;})(?{print "$^R";})/; # matches,
\&                                           # prints \*(Aq1\*(Aq
.Ve
.PP
The bit of magic mentioned in the section title occurs when the regexp
backtracks in the process of searching for a match.  If the regexp
backtracks over a code expression and if the variables used within are
localized using \f(CW\*(C`local\*(C'\fR, the changes in the variables produced by the
code expression are undone! Thus, if we wanted to count how many times
a character got matched inside a group, we could use, e.g.,
.PP
.Vb 11
\&    $x = "aaaa";
\&    $count = 0;  # initialize \*(Aqa\*(Aq count
\&    $c = "bob";  # test if $c gets clobbered
\&    $x =~ /(?{local $c = 0;})         # initialize count
\&           ( a                        # match \*(Aqa\*(Aq
\&             (?{local $c = $c + 1;})  # increment count
\&           )*                         # do this any number of times,
\&           aa                         # but match \*(Aqaa\*(Aq at the end
\&           (?{$count = $c;})          # copy local $c var into $count
\&          /x;
\&    print "\*(Aqa\*(Aq count is $count, \e$c variable is \*(Aq$c\*(Aq\en";
.Ve
.PP
This prints
.PP
.Vb 1
\&    \*(Aqa\*(Aq count is 2, $c variable is \*(Aqbob\*(Aq
.Ve
.PP
If we replace the \f(CW\*(C`\ (?{local\ $c\ =\ $c\ +\ 1;})\*(C'\fR with
\&\f(CW\*(C`\ (?{$c\ =\ $c\ +\ 1;})\*(C'\fR, the variable changes are \fInot\fR undone
during backtracking, and we get
.PP
.Vb 1
\&    \*(Aqa\*(Aq count is 4, $c variable is \*(Aqbob\*(Aq
.Ve
.PP
Note that only localized variable changes are undone.  Other side
effects of code expression execution are permanent.  Thus
.PP
.Vb 2
\&    $x = "aaaa";
\&    $x =~ /(a(?{print "Yow\en";}))*aa/;
.Ve
.PP
produces
.PP
.Vb 4
\&   Yow
\&   Yow
\&   Yow
\&   Yow
.Ve
.PP
The result \f(CW$^R\fR is automatically localized, so that it will behave
properly in the presence of backtracking.
.PP
This example uses a code expression in a conditional to match a
definite article, either 'the' in English or 'der|die|das' in German:
.PP
.Vb 11
\&    $lang = \*(AqDE\*(Aq;  # use German
\&    ...
\&    $text = "das";
\&    print "matched\en"
\&        if $text =~ /(?(?{
\&                          $lang eq \*(AqEN\*(Aq; # is the language English?
\&                         })
\&                       the |             # if so, then match \*(Aqthe\*(Aq
\&                       (der|die|das)     # else, match \*(Aqder|die|das\*(Aq
\&                     )
\&                    /xi;
.Ve
.PP
Note that the syntax here is \f(CW\*(C`(?(?{...})yes\-regexp|no\-regexp)\*(C'\fR, not
\&\f(CW\*(C`(?((?{...}))yes\-regexp|no\-regexp)\*(C'\fR.  In other words, in the case of a
code expression, we don't need the extra parentheses around the
conditional.
.PP
If you try to use code expressions where the code text is contained within
an interpolated variable, rather than appearing literally in the pattern,
Perl may surprise you:
.PP
.Vb 5
\&    $bar = 5;
\&    $pat = \*(Aq(?{ 1 })\*(Aq;
\&    /foo(?{ $bar })bar/; # compiles ok, $bar not interpolated
\&    /foo(?{ 1 })$bar/;   # compiles ok, $bar interpolated
\&    /foo${pat}bar/;      # compile error!
\&
\&    $pat = qr/(?{ $foo = 1 })/;  # precompile code regexp
\&    /foo${pat}bar/;      # compiles ok
.Ve
.PP
If a regexp has a variable that interpolates a code expression, Perl
treats the regexp as an error. If the code expression is precompiled into
a variable, however, interpolating is ok. The question is, why is this an
error?
.PP
The reason is that variable interpolation and code expressions
together pose a security risk.  The combination is dangerous because
many programmers who write search engines often take user input and
plug it directly into a regexp:
.PP
.Vb 3
\&    $regexp = <>;       # read user\-supplied regexp
\&    $chomp $regexp;     # get rid of possible newline
\&    $text =~ /$regexp/; # search $text for the $regexp
.Ve
.PP
If the \f(CW$regexp\fR variable contains a code expression, the user could
then execute arbitrary Perl code.  For instance, some joker could
search for \f(CW\*(C`system(\*(Aqrm\ \-rf\ *\*(Aq);\*(C'\fR to erase your files.  In this
sense, the combination of interpolation and code expressions \fItaints\fR
your regexp.  So by default, using both interpolation and code
expressions in the same regexp is not allowed.  If you're not
concerned about malicious users, it is possible to bypass this
security check by invoking \f(CW\*(C`use\ re\ \*(Aqeval\*(Aq\*(C'\fR:
.PP
.Vb 4
\&    use re \*(Aqeval\*(Aq;       # throw caution out the door
\&    $bar = 5;
\&    $pat = \*(Aq(?{ 1 })\*(Aq;
\&    /foo${pat}bar/;      # compiles ok
.Ve
.PP
Another form of code expression is the \fIpattern code expression\fR.
The pattern code expression is like a regular code expression, except
that the result of the code evaluation is treated as a regular
expression and matched immediately.  A simple example is
.PP
.Vb 4
\&    $length = 5;
\&    $char = \*(Aqa\*(Aq;
\&    $x = \*(Aqaaaaabb\*(Aq;
\&    $x =~ /(??{$char x $length})/x; # matches, there are 5 of \*(Aqa\*(Aq
.Ve
.PP
This final example contains both ordinary and pattern code
expressions.  It detects whether a binary string \f(CW1101010010001...\fR has a
Fibonacci spacing 0,1,1,2,3,5,...  of the \f(CW1\fR's:
.PP
.Vb 12
\&    $x = "1101010010001000001";
\&    $z0 = \*(Aq\*(Aq; $z1 = \*(Aq0\*(Aq;   # initial conditions
\&    print "It is a Fibonacci sequence\en"
\&        if $x =~ /^1         # match an initial \*(Aq1\*(Aq
\&                    (?:
\&                       ((??{ $z0 })) # match some \*(Aq0\*(Aq
\&                       1             # and then a \*(Aq1\*(Aq
\&                       (?{ $z0 = $z1; $z1 .= $^N; })
\&                    )+   # repeat as needed
\&                  $      # that is all there is
\&                 /x;
\&    printf "Largest sequence matched was %d\en", length($z1)\-length($z0);
.Ve
.PP
Remember that \f(CW$^N\fR is set to whatever was matched by the last
completed capture group. This prints
.PP
.Vb 2
\&    It is a Fibonacci sequence
\&    Largest sequence matched was 5
.Ve
.PP
Ha! Try that with your garden variety regexp package...
.PP
Note that the variables \f(CW$z0\fR and \f(CW$z1\fR are not substituted when the
regexp is compiled, as happens for ordinary variables outside a code
expression.  Rather, the whole code block is parsed as perl code at the
same time as perl is compiling the code containing the literal regexp
pattern.
.PP
The regexp without the \f(CW\*(C`//x\*(C'\fR modifier is
.PP
.Vb 1
\&    /^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N; }))+$/
.Ve
.PP
which shows that spaces are still possible in the code parts. Nevertheless,
when working with code and conditional expressions, the extended form of
regexps is almost necessary in creating and debugging regexps.
.SS "Backtracking control verbs"
.IX Subsection "Backtracking control verbs"
Perl 5.10 introduced a number of control verbs intended to provide
detailed control over the backtracking process, by directly influencing
the regexp engine and by providing monitoring techniques.  As all
the features in this group are experimental and subject to change or
removal in a future version of Perl, the interested reader is
referred to \*(L"Special Backtracking Control Verbs\*(R" in perlre for a
detailed description.
.PP
Below is just one example, illustrating the control verb \f(CW\*(C`(*FAIL)\*(C'\fR,
which may be abbreviated as \f(CW\*(C`(*F)\*(C'\fR. If this is inserted in a regexp
it will cause it to fail, just as it would at some
mismatch between the pattern and the string. Processing
of the regexp continues as it would after any \*(L"normal\*(R"
failure, so that, for instance, the next position in the string or another
alternative will be tried. As failing to match doesn't preserve capture
groups or produce results, it may be necessary to use this in
combination with embedded code.
.PP
.Vb 4
\&   %count = ();
\&   "supercalifragilisticexpialidocious" =~
\&       /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
\&   printf "%3d \*(Aq%s\*(Aq\en", $count{$_}, $_ for (sort keys %count);
.Ve
.PP
The pattern begins with a class matching a subset of letters.  Whenever
this matches, a statement like \f(CW\*(C`$count{\*(Aqa\*(Aq}++;\*(C'\fR is executed, incrementing
the letter's counter. Then \f(CW\*(C`(*FAIL)\*(C'\fR does what it says, and
the regexp engine proceeds according to the book: as long as the end of
the string hasn't been reached, the position is advanced before looking
for another vowel. Thus, match or no match makes no difference, and the
regexp engine proceeds until the entire string has been inspected.
(It's remarkable that an alternative solution using something like
.PP
.Vb 2
\&   $count{lc($_)}++ for split(\*(Aq\*(Aq, "supercalifragilisticexpialidocious");
\&   printf "%3d \*(Aq%s\*(Aq\en", $count2{$_}, $_ for ( qw{ a e i o u } );
.Ve
.PP
is considerably slower.)
.SS "Pragmas and debugging"
.IX Subsection "Pragmas and debugging"
Speaking of debugging, there are several pragmas available to control
and debug regexps in Perl.  We have already encountered one pragma in
the previous section, \f(CW\*(C`use\ re\ \*(Aqeval\*(Aq;\*(C'\fR, that allows variable
interpolation and code expressions to coexist in a regexp.  The other
pragmas are
.PP
.Vb 3
\&    use re \*(Aqtaint\*(Aq;
\&    $tainted = <>;
\&    @parts = ($tainted =~ /(\ew+)\es+(\ew+)/; # @parts is now tainted
.Ve
.PP
The \f(CW\*(C`taint\*(C'\fR pragma causes any substrings from a match with a tainted
variable to be tainted as well.  This is not normally the case, as
regexps are often used to extract the safe bits from a tainted
variable.  Use \f(CW\*(C`taint\*(C'\fR when you are not extracting safe bits, but are
performing some other processing.  Both \f(CW\*(C`taint\*(C'\fR and \f(CW\*(C`eval\*(C'\fR pragmas
are lexically scoped, which means they are in effect only until
the end of the block enclosing the pragmas.
.PP
.Vb 2
\&    use re \*(Aq/m\*(Aq;  # or any other flags
\&    $multiline_string =~ /^foo/; # /m is implied
.Ve
.PP
The \f(CW\*(C`re \*(Aq/flags\*(Aq\*(C'\fR pragma (introduced in Perl
5.14) turns on the given regular expression flags
until the end of the lexical scope.  See
\&\*(L"'/flags' mode\*(R" in re for more
detail.
.PP
.Vb 2
\&    use re \*(Aqdebug\*(Aq;
\&    /^(.*)$/s;       # output debugging info
\&
\&    use re \*(Aqdebugcolor\*(Aq;
\&    /^(.*)$/s;       # output debugging info in living color
.Ve
.PP
The global \f(CW\*(C`debug\*(C'\fR and \f(CW\*(C`debugcolor\*(C'\fR pragmas allow one to get
detailed debugging info about regexp compilation and
execution.  \f(CW\*(C`debugcolor\*(C'\fR is the same as debug, except the debugging
information is displayed in color on terminals that can display
termcap color sequences.  Here is example output:
.PP
.Vb 10
\&    % perl \-e \*(Aquse re "debug"; "abc" =~ /a*b+c/;\*(Aq
\&    Compiling REx \*(Aqa*b+c\*(Aq
\&    size 9 first at 1
\&       1: STAR(4)
\&       2:   EXACT <a>(0)
\&       4: PLUS(7)
\&       5:   EXACT <b>(0)
\&       7: EXACT <c>(9)
\&       9: END(0)
\&    floating \*(Aqbc\*(Aq at 0..2147483647 (checking floating) minlen 2
\&    Guessing start of match, REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq...
\&    Found floating substr \*(Aqbc\*(Aq at offset 1...
\&    Guessed: match at offset 0
\&    Matching REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq
\&      Setting an EVAL scope, savestack=3
\&       0 <> <abc>             |  1:  STAR
\&                               EXACT <a> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       1 <a> <bc>             |  4:    PLUS
\&                               EXACT <b> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       2 <ab> <c>             |  7:      EXACT <c>
\&       3 <abc> <>             |  9:      END
\&    Match successful!
\&    Freeing REx: \*(Aqa*b+c\*(Aq
.Ve
.PP
If you have gotten this far into the tutorial, you can probably guess
what the different parts of the debugging output tell you.  The first
part
.PP
.Vb 8
\&    Compiling REx \*(Aqa*b+c\*(Aq
\&    size 9 first at 1
\&       1: STAR(4)
\&       2:   EXACT <a>(0)
\&       4: PLUS(7)
\&       5:   EXACT <b>(0)
\&       7: EXACT <c>(9)
\&       9: END(0)
.Ve
.PP
describes the compilation stage.  \f(CWSTAR(4)\fR means that there is a
starred object, in this case \f(CW\*(Aqa\*(Aq\fR, and if it matches, goto line 4,
i.e., \f(CWPLUS(7)\fR.  The middle lines describe some heuristics and
optimizations performed before a match:
.PP
.Vb 4
\&    floating \*(Aqbc\*(Aq at 0..2147483647 (checking floating) minlen 2
\&    Guessing start of match, REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq...
\&    Found floating substr \*(Aqbc\*(Aq at offset 1...
\&    Guessed: match at offset 0
.Ve
.PP
Then the match is executed and the remaining lines describe the
process:
.PP
.Vb 12
\&    Matching REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq
\&      Setting an EVAL scope, savestack=3
\&       0 <> <abc>             |  1:  STAR
\&                               EXACT <a> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       1 <a> <bc>             |  4:    PLUS
\&                               EXACT <b> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       2 <ab> <c>             |  7:      EXACT <c>
\&       3 <abc> <>             |  9:      END
\&    Match successful!
\&    Freeing REx: \*(Aqa*b+c\*(Aq
.Ve
.PP
Each step is of the form \f(CW\*(C`n\ <x>\ <y>\*(C'\fR, with \f(CW\*(C`<x>\*(C'\fR the
part of the string matched and \f(CW\*(C`<y>\*(C'\fR the part not yet
matched.  The \f(CW\*(C`|\ \ 1:\ \ STAR\*(C'\fR says that Perl is at line number 1
in the compilation list above.  See
\&\*(L"Debugging Regular Expressions\*(R" in perldebguts for much more detail.
.PP
An alternative method of debugging regexps is to embed \f(CW\*(C`print\*(C'\fR
statements within the regexp.  This provides a blow-by-blow account of
the backtracking in an alternation:
.PP
.Vb 12
\&    "that this" =~ m@(?{print "Start at position ", pos, "\en";})
\&                     t(?{print "t1\en";})
\&                     h(?{print "h1\en";})
\&                     i(?{print "i1\en";})
\&                     s(?{print "s1\en";})
\&                         |
\&                     t(?{print "t2\en";})
\&                     h(?{print "h2\en";})
\&                     a(?{print "a2\en";})
\&                     t(?{print "t2\en";})
\&                     (?{print "Done at position ", pos, "\en";})
\&                    @x;
.Ve
.PP
prints
.PP
.Vb 8
\&    Start at position 0
\&    t1
\&    h1
\&    t2
\&    h2
\&    a2
\&    t2
\&    Done at position 4
.Ve
.SH "BUGS"
.IX Header "BUGS"
Code expressions, conditional expressions, and independent expressions
are \fIexperimental\fR.  Don't use them in production code.  Yet.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This is just a tutorial.  For the full story on Perl regular
expressions, see the perlre regular expressions reference page.
.PP
For more information on the matching \f(CW\*(C`m//\*(C'\fR and substitution \f(CW\*(C`s///\*(C'\fR
operators, see \*(L"Regexp Quote-Like Operators\*(R" in perlop.  For
information on the \f(CW\*(C`split\*(C'\fR operation, see \*(L"split\*(R" in perlfunc.
.PP
For an excellent all-around resource on the care and feeding of
regular expressions, see the book \fIMastering Regular Expressions\fR by
Jeffrey Friedl (published by O'Reilly, \s-1ISBN 1556592\-257\-3\s0).
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 2000 Mark Kvale
All rights reserved.
.PP
This document may be distributed under the same terms as Perl itself.
.SS "Acknowledgments"
.IX Subsection "Acknowledgments"
The inspiration for the stop codon \s-1DNA\s0 example came from the \s-1ZIP\s0
code example in chapter 7 of \fIMastering Regular Expressions\fR.
.PP
The author would like to thank Jeff Pinyan, Andrew Johnson, Peter
Haworth, Ronald J Kimball, and Joe Smith for all their helpful
comments.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 643:" 4
.IX Item "Around line 643:"
Expected text after =item, not a number
.IP "Around line 647:" 4
.IX Item "Around line 647:"
Expected text after =item, not a number
.IP "Around line 651:" 4
.IX Item "Around line 651:"
Expected text after =item, not a number
.IP "Around line 657:" 4
.IX Item "Around line 657:"
Expected text after =item, not a number
.IP "Around line 662:" 4
.IX Item "Around line 662:"
Expected text after =item, not a number
.IP "Around line 667:" 4
.IX Item "Around line 667:"
Expected text after =item, not a number
.IP "Around line 671:" 4
.IX Item "Around line 671:"
Expected text after =item, not a number
.IP "Around line 677:" 4
.IX Item "Around line 677:"
Expected text after =item, not a number
.IP "Around line 682:" 4
.IX Item "Around line 682:"
Expected text after =item, not a number
.IP "Around line 1250:" 4
.IX Item "Around line 1250:"
Expected text after =item, not a number
.IP "Around line 1255:" 4
.IX Item "Around line 1255:"
Expected text after =item, not a number
.IP "Around line 1260:" 4
.IX Item "Around line 1260:"
Expected text after =item, not a number
.IP "Around line 1265:" 4
.IX Item "Around line 1265:"
Expected text after =item, not a number
.IP "Around line 1269:" 4
.IX Item "Around line 1269:"
Expected text after =item, not a number
.IP "Around line 1274:" 4
.IX Item "Around line 1274:"
Expected text after =item, not a number
                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlretut5.16.1                              0100644 0001750 0001750 00000424102 12566207423 023302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRETUT 1"
.TH PERLRETUT 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlretut \- Perl regular expressions tutorial
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page provides a basic tutorial on understanding, creating and
using regular expressions in Perl.  It serves as a complement to the
reference page on regular expressions perlre.  Regular expressions
are an integral part of the \f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`qr//\*(C'\fR and \f(CW\*(C`split\*(C'\fR
operators and so this tutorial also overlaps with
\&\*(L"Regexp Quote-Like Operators\*(R" in perlop and \*(L"split\*(R" in perlfunc.
.PP
Perl is widely renowned for excellence in text processing, and regular
expressions are one of the big factors behind this fame.  Perl regular
expressions display an efficiency and flexibility unknown in most
other computer languages.  Mastering even the basics of regular
expressions will allow you to manipulate text with surprising ease.
.PP
What is a regular expression?  A regular expression is simply a string
that describes a pattern.  Patterns are in common use these days;
examples are the patterns typed into a search engine to find web pages
and the patterns used to list files in a directory, e.g., \f(CW\*(C`ls *.txt\*(C'\fR
or \f(CW\*(C`dir *.*\*(C'\fR.  In Perl, the patterns described by regular expressions
are used to search strings, extract desired parts of strings, and to
do search and replace operations.
.PP
Regular expressions have the undeserved reputation of being abstract
and difficult to understand.  Regular expressions are constructed using
simple concepts like conditionals and loops and are no more difficult
to understand than the corresponding \f(CW\*(C`if\*(C'\fR conditionals and \f(CW\*(C`while\*(C'\fR
loops in the Perl language itself.  In fact, the main challenge in
learning regular expressions is just getting used to the terse
notation used to express these concepts.
.PP
This tutorial flattens the learning curve by discussing regular
expression concepts, along with their notation, one at a time and with
many examples.  The first part of the tutorial will progress from the
simplest word searches to the basic regular expression concepts.  If
you master the first part, you will have all the tools needed to solve
about 98% of your needs.  The second part of the tutorial is for those
comfortable with the basics and hungry for more power tools.  It
discusses the more advanced regular expression operators and
introduces the latest cutting-edge innovations.
.PP
A note: to save time, 'regular expression' is often abbreviated as
regexp or regex.  Regexp is a more natural abbreviation than regex, but
is harder to pronounce.  The Perl pod documentation is evenly split on
regexp vs regex; in Perl, there is more than one way to abbreviate it.
We'll use regexp in this tutorial.
.SH "Part 1: The basics"
.IX Header "Part 1: The basics"
.SS "Simple word matching"
.IX Subsection "Simple word matching"
The simplest regexp is simply a word, or more generally, a string of
characters.  A regexp consisting of a word matches any string that
contains that word:
.PP
.Vb 1
\&    "Hello World" =~ /World/;  # matches
.Ve
.PP
What is this Perl statement all about? \f(CW"Hello World"\fR is a simple
double-quoted string.  \f(CW\*(C`World\*(C'\fR is the regular expression and the
\&\f(CW\*(C`//\*(C'\fR enclosing \f(CW\*(C`/World/\*(C'\fR tells Perl to search a string for a match.
The operator \f(CW\*(C`=~\*(C'\fR associates the string with the regexp match and
produces a true value if the regexp matched, or false if the regexp
did not match.  In our case, \f(CW\*(C`World\*(C'\fR matches the second word in
\&\f(CW"Hello World"\fR, so the expression is true.  Expressions like this
are useful in conditionals:
.PP
.Vb 6
\&    if ("Hello World" =~ /World/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It doesn\*(Aqt match\en";
\&    }
.Ve
.PP
There are useful variations on this theme.  The sense of the match can
be reversed by using the \f(CW\*(C`!~\*(C'\fR operator:
.PP
.Vb 6
\&    if ("Hello World" !~ /World/) {
\&        print "It doesn\*(Aqt match\en";
\&    }
\&    else {
\&        print "It matches\en";
\&    }
.Ve
.PP
The literal string in the regexp can be replaced by a variable:
.PP
.Vb 7
\&    $greeting = "World";
\&    if ("Hello World" =~ /$greeting/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It doesn\*(Aqt match\en";
\&    }
.Ve
.PP
If you're matching against the special default variable \f(CW$_\fR, the
\&\f(CW\*(C`$_ =~\*(C'\fR part can be omitted:
.PP
.Vb 7
\&    $_ = "Hello World";
\&    if (/World/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It doesn\*(Aqt match\en";
\&    }
.Ve
.PP
And finally, the \f(CW\*(C`//\*(C'\fR default delimiters for a match can be changed
to arbitrary delimiters by putting an \f(CW\*(Aqm\*(Aq\fR out front:
.PP
.Vb 4
\&    "Hello World" =~ m!World!;   # matches, delimited by \*(Aq!\*(Aq
\&    "Hello World" =~ m{World};   # matches, note the matching \*(Aq{}\*(Aq
\&    "/usr/bin/perl" =~ m"/perl"; # matches after \*(Aq/usr/bin\*(Aq,
\&                                 # \*(Aq/\*(Aq becomes an ordinary char
.Ve
.PP
\&\f(CW\*(C`/World/\*(C'\fR, \f(CW\*(C`m!World!\*(C'\fR, and \f(CW\*(C`m{World}\*(C'\fR all represent the
same thing.  When, e.g., the quote (\f(CW\*(C`"\*(C'\fR) is used as a delimiter, the forward
slash \f(CW\*(Aq/\*(Aq\fR becomes an ordinary character and can be used in this regexp
without trouble.
.PP
Let's consider how different regexps would match \f(CW"Hello World"\fR:
.PP
.Vb 4
\&    "Hello World" =~ /world/;  # doesn\*(Aqt match
\&    "Hello World" =~ /o W/;    # matches
\&    "Hello World" =~ /oW/;     # doesn\*(Aqt match
\&    "Hello World" =~ /World /; # doesn\*(Aqt match
.Ve
.PP
The first regexp \f(CW\*(C`world\*(C'\fR doesn't match because regexps are
case-sensitive.  The second regexp matches because the substring
\&\f(CW\*(Aqo\ W\*(Aq\fR occurs in the string \f(CW"Hello\ World"\fR.  The space
character ' ' is treated like any other character in a regexp and is
needed to match in this case.  The lack of a space character is the
reason the third regexp \f(CW\*(AqoW\*(Aq\fR doesn't match.  The fourth regexp
\&\f(CW\*(AqWorld \*(Aq\fR doesn't match because there is a space at the end of the
regexp, but not at the end of the string.  The lesson here is that
regexps must match a part of the string \fIexactly\fR in order for the
statement to be true.
.PP
If a regexp matches in more than one place in the string, Perl will
always match at the earliest possible point in the string:
.PP
.Vb 2
\&    "Hello World" =~ /o/;       # matches \*(Aqo\*(Aq in \*(AqHello\*(Aq
\&    "That hat is red" =~ /hat/; # matches \*(Aqhat\*(Aq in \*(AqThat\*(Aq
.Ve
.PP
With respect to character matching, there are a few more points you
need to know about.   First of all, not all characters can be used 'as
is' in a match.  Some characters, called \fImetacharacters\fR, are reserved
for use in regexp notation.  The metacharacters are
.PP
.Vb 1
\&    {}[]()^$.|*+?\e
.Ve
.PP
The significance of each of these will be explained
in the rest of the tutorial, but for now, it is important only to know
that a metacharacter can be matched by putting a backslash before it:
.PP
.Vb 5
\&    "2+2=4" =~ /2+2/;    # doesn\*(Aqt match, + is a metacharacter
\&    "2+2=4" =~ /2\e+2/;   # matches, \e+ is treated like an ordinary +
\&    "The interval is [0,1)." =~ /[0,1)./     # is a syntax error!
\&    "The interval is [0,1)." =~ /\e[0,1\e)\e./  # matches
\&    "#!/usr/bin/perl" =~ /#!\e/usr\e/bin\e/perl/;  # matches
.Ve
.PP
In the last regexp, the forward slash \f(CW\*(Aq/\*(Aq\fR is also backslashed,
because it is used to delimit the regexp.  This can lead to \s-1LTS\s0
(leaning toothpick syndrome), however, and it is often more readable
to change delimiters.
.PP
.Vb 1
\&    "#!/usr/bin/perl" =~ m!#\e!/usr/bin/perl!;  # easier to read
.Ve
.PP
The backslash character \f(CW\*(Aq\e\*(Aq\fR is a metacharacter itself and needs to
be backslashed:
.PP
.Vb 1
\&    \*(AqC:\eWIN32\*(Aq =~ /C:\e\eWIN/;   # matches
.Ve
.PP
In addition to the metacharacters, there are some \s-1ASCII\s0 characters
which don't have printable character equivalents and are instead
represented by \fIescape sequences\fR.  Common examples are \f(CW\*(C`\et\*(C'\fR for a
tab, \f(CW\*(C`\en\*(C'\fR for a newline, \f(CW\*(C`\er\*(C'\fR for a carriage return and \f(CW\*(C`\ea\*(C'\fR for a
bell (or alert).  If your string is better thought of as a sequence of arbitrary
bytes, the octal escape sequence, e.g., \f(CW\*(C`\e033\*(C'\fR, or hexadecimal escape
sequence, e.g., \f(CW\*(C`\ex1B\*(C'\fR may be a more natural representation for your
bytes.  Here are some examples of escapes:
.PP
.Vb 5
\&    "1000\et2000" =~ m(0\et2)   # matches
\&    "1000\en2000" =~ /0\en20/   # matches
\&    "1000\et2000" =~ /\e000\et2/ # doesn\*(Aqt match, "0" ne "\e000"
\&    "cat"   =~ /\eo{143}\ex61\ex74/ # matches in ASCII, but a weird way
\&                                 # to spell cat
.Ve
.PP
If you've been around Perl a while, all this talk of escape sequences
may seem familiar.  Similar escape sequences are used in double-quoted
strings and in fact the regexps in Perl are mostly treated as
double-quoted strings.  This means that variables can be used in
regexps as well.  Just like double-quoted strings, the values of the
variables in the regexp will be substituted in before the regexp is
evaluated for matching purposes.  So we have:
.PP
.Vb 4
\&    $foo = \*(Aqhouse\*(Aq;
\&    \*(Aqhousecat\*(Aq =~ /$foo/;      # matches
\&    \*(Aqcathouse\*(Aq =~ /cat$foo/;   # matches
\&    \*(Aqhousecat\*(Aq =~ /${foo}cat/; # matches
.Ve
.PP
So far, so good.  With the knowledge above you can already perform
searches with just about any literal string regexp you can dream up.
Here is a \fIvery simple\fR emulation of the Unix grep program:
.PP
.Vb 7
\&    % cat > simple_grep
\&    #!/usr/bin/perl
\&    $regexp = shift;
\&    while (<>) {
\&        print if /$regexp/;
\&    }
\&    ^D
\&
\&    % chmod +x simple_grep
\&
\&    % simple_grep abba /usr/dict/words
\&    Babbage
\&    cabbage
\&    cabbages
\&    sabbath
\&    Sabbathize
\&    Sabbathizes
\&    sabbatical
\&    scabbard
\&    scabbards
.Ve
.PP
This program is easy to understand.  \f(CW\*(C`#!/usr/bin/perl\*(C'\fR is the standard
way to invoke a perl program from the shell.
\&\f(CW\*(C`$regexp\ =\ shift;\*(C'\fR saves the first command line argument as the
regexp to be used, leaving the rest of the command line arguments to
be treated as files.  \f(CW\*(C`while\ (<>)\*(C'\fR loops over all the lines in
all the files.  For each line, \f(CW\*(C`print\ if\ /$regexp/;\*(C'\fR prints the
line if the regexp matches the line.  In this line, both \f(CW\*(C`print\*(C'\fR and
\&\f(CW\*(C`/$regexp/\*(C'\fR use the default variable \f(CW$_\fR implicitly.
.PP
With all of the regexps above, if the regexp matched anywhere in the
string, it was considered a match.  Sometimes, however, we'd like to
specify \fIwhere\fR in the string the regexp should try to match.  To do
this, we would use the \fIanchor\fR metacharacters \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR.  The
anchor \f(CW\*(C`^\*(C'\fR means match at the beginning of the string and the anchor
\&\f(CW\*(C`$\*(C'\fR means match at the end of the string, or before a newline at the
end of the string.  Here is how they are used:
.PP
.Vb 4
\&    "housekeeper" =~ /keeper/;    # matches
\&    "housekeeper" =~ /^keeper/;   # doesn\*(Aqt match
\&    "housekeeper" =~ /keeper$/;   # matches
\&    "housekeeper\en" =~ /keeper$/; # matches
.Ve
.PP
The second regexp doesn't match because \f(CW\*(C`^\*(C'\fR constrains \f(CW\*(C`keeper\*(C'\fR to
match only at the beginning of the string, but \f(CW"housekeeper"\fR has
keeper starting in the middle.  The third regexp does match, since the
\&\f(CW\*(C`$\*(C'\fR constrains \f(CW\*(C`keeper\*(C'\fR to match only at the end of the string.
.PP
When both \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR are used at the same time, the regexp has to
match both the beginning and the end of the string, i.e., the regexp
matches the whole string.  Consider
.PP
.Vb 3
\&    "keeper" =~ /^keep$/;      # doesn\*(Aqt match
\&    "keeper" =~ /^keeper$/;    # matches
\&    ""       =~ /^$/;          # ^$ matches an empty string
.Ve
.PP
The first regexp doesn't match because the string has more to it than
\&\f(CW\*(C`keep\*(C'\fR.  Since the second regexp is exactly the string, it
matches.  Using both \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR in a regexp forces the complete
string to match, so it gives you complete control over which strings
match and which don't.  Suppose you are looking for a fellow named
bert, off in a string by himself:
.PP
.Vb 1
\&    "dogbert" =~ /bert/;   # matches, but not what you want
\&
\&    "dilbert" =~ /^bert/;  # doesn\*(Aqt match, but ..
\&    "bertram" =~ /^bert/;  # matches, so still not good enough
\&
\&    "bertram" =~ /^bert$/; # doesn\*(Aqt match, good
\&    "dilbert" =~ /^bert$/; # doesn\*(Aqt match, good
\&    "bert"    =~ /^bert$/; # matches, perfect
.Ve
.PP
Of course, in the case of a literal string, one could just as easily
use the string comparison \f(CW\*(C`$string\ eq\ \*(Aqbert\*(Aq\*(C'\fR and it would be
more efficient.   The  \f(CW\*(C`^...$\*(C'\fR regexp really becomes useful when we
add in the more powerful regexp tools below.
.SS "Using character classes"
.IX Subsection "Using character classes"
Although one can already do quite a lot with the literal string
regexps above, we've only scratched the surface of regular expression
technology.  In this and subsequent sections we will introduce regexp
concepts (and associated metacharacter notations) that will allow a
regexp to represent not just a single character sequence, but a \fIwhole
class\fR of them.
.PP
One such concept is that of a \fIcharacter class\fR.  A character class
allows a set of possible characters, rather than just a single
character, to match at a particular point in a regexp.  Character
classes are denoted by brackets \f(CW\*(C`[...]\*(C'\fR, with the set of characters
to be possibly matched inside.  Here are some examples:
.PP
.Vb 4
\&    /cat/;       # matches \*(Aqcat\*(Aq
\&    /[bcr]at/;   # matches \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&    /item[0123456789]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    "abc" =~ /[cab]/;    # matches \*(Aqa\*(Aq
.Ve
.PP
In the last statement, even though \f(CW\*(Aqc\*(Aq\fR is the first character in
the class, \f(CW\*(Aqa\*(Aq\fR matches because the first character position in the
string is the earliest point at which the regexp can match.
.PP
.Vb 2
\&    /[yY][eE][sS]/;      # match \*(Aqyes\*(Aq in a case\-insensitive way
\&                         # \*(Aqyes\*(Aq, \*(AqYes\*(Aq, \*(AqYES\*(Aq, etc.
.Ve
.PP
This regexp displays a common task: perform a case-insensitive
match.  Perl provides a way of avoiding all those brackets by simply
appending an \f(CW\*(Aqi\*(Aq\fR to the end of the match.  Then \f(CW\*(C`/[yY][eE][sS]/;\*(C'\fR
can be rewritten as \f(CW\*(C`/yes/i;\*(C'\fR.  The \f(CW\*(Aqi\*(Aq\fR stands for
case-insensitive and is an example of a \fImodifier\fR of the matching
operation.  We will meet other modifiers later in the tutorial.
.PP
We saw in the section above that there were ordinary characters, which
represented themselves, and special characters, which needed a
backslash \f(CW\*(C`\e\*(C'\fR to represent themselves.  The same is true in a
character class, but the sets of ordinary and special characters
inside a character class are different than those outside a character
class.  The special characters for a character class are \f(CW\*(C`\-]\e^$\*(C'\fR (and
the pattern delimiter, whatever it is).
\&\f(CW\*(C`]\*(C'\fR is special because it denotes the end of a character class.  \f(CW\*(C`$\*(C'\fR is
special because it denotes a scalar variable.  \f(CW\*(C`\e\*(C'\fR is special because
it is used in escape sequences, just like above.  Here is how the
special characters \f(CW\*(C`]$\e\*(C'\fR are handled:
.PP
.Vb 5
\&   /[\e]c]def/; # matches \*(Aq]def\*(Aq or \*(Aqcdef\*(Aq
\&   $x = \*(Aqbcr\*(Aq;
\&   /[$x]at/;   # matches \*(Aqbat\*(Aq, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&   /[\e$x]at/;  # matches \*(Aq$at\*(Aq or \*(Aqxat\*(Aq
\&   /[\e\e$x]at/; # matches \*(Aq\eat\*(Aq, \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
.Ve
.PP
The last two are a little tricky.  In \f(CW\*(C`[\e$x]\*(C'\fR, the backslash protects
the dollar sign, so the character class has two members \f(CW\*(C`$\*(C'\fR and \f(CW\*(C`x\*(C'\fR.
In \f(CW\*(C`[\e\e$x]\*(C'\fR, the backslash is protected, so \f(CW$x\fR is treated as a
variable and substituted in double quote fashion.
.PP
The special character \f(CW\*(Aq\-\*(Aq\fR acts as a range operator within character
classes, so that a contiguous set of characters can be written as a
range.  With ranges, the unwieldy \f(CW\*(C`[0123456789]\*(C'\fR and \f(CW\*(C`[abc...xyz]\*(C'\fR
become the svelte \f(CW\*(C`[0\-9]\*(C'\fR and \f(CW\*(C`[a\-z]\*(C'\fR.  Some examples are
.PP
.Vb 6
\&    /item[0\-9]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    /[0\-9bx\-z]aa/;  # matches \*(Aq0aa\*(Aq, ..., \*(Aq9aa\*(Aq,
\&                    # \*(Aqbaa\*(Aq, \*(Aqxaa\*(Aq, \*(Aqyaa\*(Aq, or \*(Aqzaa\*(Aq
\&    /[0\-9a\-fA\-F]/;  # matches a hexadecimal digit
\&    /[0\-9a\-zA\-Z_]/; # matches a "word" character,
\&                    # like those in a Perl variable name
.Ve
.PP
If \f(CW\*(Aq\-\*(Aq\fR is the first or last character in a character class, it is
treated as an ordinary character; \f(CW\*(C`[\-ab]\*(C'\fR, \f(CW\*(C`[ab\-]\*(C'\fR and \f(CW\*(C`[a\e\-b]\*(C'\fR are
all equivalent.
.PP
The special character \f(CW\*(C`^\*(C'\fR in the first position of a character class
denotes a \fInegated character class\fR, which matches any character but
those in the brackets.  Both \f(CW\*(C`[...]\*(C'\fR and \f(CW\*(C`[^...]\*(C'\fR must match a
character, or the match fails.  Then
.PP
.Vb 4
\&    /[^a]at/;  # doesn\*(Aqt match \*(Aqaat\*(Aq or \*(Aqat\*(Aq, but matches
\&               # all other \*(Aqbat\*(Aq, \*(Aqcat, \*(Aq0at\*(Aq, \*(Aq%at\*(Aq, etc.
\&    /[^0\-9]/;  # matches a non\-numeric character
\&    /[a^]at/;  # matches \*(Aqaat\*(Aq or \*(Aq^at\*(Aq; here \*(Aq^\*(Aq is ordinary
.Ve
.PP
Now, even \f(CW\*(C`[0\-9]\*(C'\fR can be a bother to write multiple times, so in the
interest of saving keystrokes and making regexps more readable, Perl
has several abbreviations for common character classes, as shown below.
Since the introduction of Unicode, unless the \f(CW\*(C`//a\*(C'\fR modifier is in
effect, these character classes match more than just a few characters in
the \s-1ASCII\s0 range.
.IP "\(bu" 4
\&\ed matches a digit, not just [0\-9] but also digits from non-roman scripts
.IP "\(bu" 4
\&\es matches a whitespace character, the set [\e \et\er\en\ef] and others
.IP "\(bu" 4
\&\ew matches a word character (alphanumeric or _), not just [0\-9a\-zA\-Z_]
but also digits and characters from non-roman scripts
.IP "\(bu" 4
\&\eD is a negated \ed; it represents any other character than a digit, or [^\ed]
.IP "\(bu" 4
\&\eS is a negated \es; it represents any non-whitespace character [^\es]
.IP "\(bu" 4
\&\eW is a negated \ew; it represents any non-word character [^\ew]
.IP "\(bu" 4
The period '.' matches any character but \*(L"\en\*(R" (unless the modifier \f(CW\*(C`//s\*(C'\fR is
in effect, as explained below).
.IP "\(bu" 4
\&\eN, like the period, matches any character but \*(L"\en\*(R", but it does so
regardless of whether the modifier \f(CW\*(C`//s\*(C'\fR is in effect.
.PP
The \f(CW\*(C`//a\*(C'\fR modifier, available starting in Perl 5.14,  is used to
restrict the matches of \ed, \es, and \ew to just those in the \s-1ASCII\s0 range.
It is useful to keep your program from being needlessly exposed to full
Unicode (and its accompanying security considerations) when all you want
is to process English-like text.  (The \*(L"a\*(R" may be doubled, \f(CW\*(C`//aa\*(C'\fR, to
provide even more restrictions, preventing case-insensitive matching of
\&\s-1ASCII\s0 with non-ASCII characters; otherwise a Unicode \*(L"Kelvin Sign\*(R"
would caselessly match a \*(L"k\*(R" or \*(L"K\*(R".)
.PP
The \f(CW\*(C`\ed\es\ew\eD\eS\eW\*(C'\fR abbreviations can be used both inside and outside
of character classes.  Here are some in use:
.PP
.Vb 7
\&    /\ed\ed:\ed\ed:\ed\ed/; # matches a hh:mm:ss time format
\&    /[\ed\es]/;         # matches any digit or whitespace character
\&    /\ew\eW\ew/;         # matches a word char, followed by a
\&                      # non\-word char, followed by a word char
\&    /..rt/;           # matches any two chars, followed by \*(Aqrt\*(Aq
\&    /end\e./;          # matches \*(Aqend.\*(Aq
\&    /end[.]/;         # same thing, matches \*(Aqend.\*(Aq
.Ve
.PP
Because a period is a metacharacter, it needs to be escaped to match
as an ordinary period. Because, for example, \f(CW\*(C`\ed\*(C'\fR and \f(CW\*(C`\ew\*(C'\fR are sets
of characters, it is incorrect to think of \f(CW\*(C`[^\ed\ew]\*(C'\fR as \f(CW\*(C`[\eD\eW]\*(C'\fR; in
fact \f(CW\*(C`[^\ed\ew]\*(C'\fR is the same as \f(CW\*(C`[^\ew]\*(C'\fR, which is the same as
\&\f(CW\*(C`[\eW]\*(C'\fR. Think DeMorgan's laws.
.PP
An anchor useful in basic regexps is the \fIword anchor\fR
\&\f(CW\*(C`\eb\*(C'\fR.  This matches a boundary between a word character and a non-word
character \f(CW\*(C`\ew\eW\*(C'\fR or \f(CW\*(C`\eW\ew\*(C'\fR:
.PP
.Vb 5
\&    $x = "Housecat catenates house and cat";
\&    $x =~ /cat/;    # matches cat in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat/;  # matches cat in \*(Aqcatenates\*(Aq
\&    $x =~ /cat\eb/;  # matches cat in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq at end of string
.Ve
.PP
Note in the last example, the end of the string is considered a word
boundary.
.PP
You might wonder why \f(CW\*(Aq.\*(Aq\fR matches everything but \f(CW"\en"\fR \- why not
every character? The reason is that often one is matching against
lines and would like to ignore the newline characters.  For instance,
while the string \f(CW"\en"\fR represents one line, we would like to think
of it as empty.  Then
.PP
.Vb 2
\&    ""   =~ /^$/;    # matches
\&    "\en" =~ /^$/;    # matches, $ anchors before "\en"
\&
\&    ""   =~ /./;      # doesn\*(Aqt match; it needs a char
\&    ""   =~ /^.$/;    # doesn\*(Aqt match; it needs a char
\&    "\en" =~ /^.$/;    # doesn\*(Aqt match; it needs a char other than "\en"
\&    "a"  =~ /^.$/;    # matches
\&    "a\en"  =~ /^.$/;  # matches, $ anchors before "\en"
.Ve
.PP
This behavior is convenient, because we usually want to ignore
newlines when we count and match characters in a line.  Sometimes,
however, we want to keep track of newlines.  We might even want \f(CW\*(C`^\*(C'\fR
and \f(CW\*(C`$\*(C'\fR to anchor at the beginning and end of lines within the
string, rather than just the beginning and end of the string.  Perl
allows us to choose between ignoring and paying attention to newlines
by using the \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//m\*(C'\fR modifiers.  \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//m\*(C'\fR stand for
single line and multi-line and they determine whether a string is to
be treated as one continuous string, or as a set of lines.  The two
modifiers affect two aspects of how the regexp is interpreted: 1) how
the \f(CW\*(Aq.\*(Aq\fR character class is defined, and 2) where the anchors \f(CW\*(C`^\*(C'\fR
and \f(CW\*(C`$\*(C'\fR are able to match.  Here are the four possible combinations:
.IP "\(bu" 4
no modifiers (//): Default behavior.  \f(CW\*(Aq.\*(Aq\fR matches any character
except \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR matches only at the beginning of the string and
\&\f(CW\*(C`$\*(C'\fR matches only at the end or before a newline at the end.
.IP "\(bu" 4
s modifier (//s): Treat string as a single long line.  \f(CW\*(Aq.\*(Aq\fR matches
any character, even \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR matches only at the beginning of
the string and \f(CW\*(C`$\*(C'\fR matches only at the end or before a newline at the
end.
.IP "\(bu" 4
m modifier (//m): Treat string as a set of multiple lines.  \f(CW\*(Aq.\*(Aq\fR
matches any character except \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR are able to match
at the start or end of \fIany\fR line within the string.
.IP "\(bu" 4
both s and m modifiers (//sm): Treat string as a single long line, but
detect multiple lines.  \f(CW\*(Aq.\*(Aq\fR matches any character, even
\&\f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR, however, are able to match at the start or end
of \fIany\fR line within the string.
.PP
Here are examples of \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//m\*(C'\fR in action:
.PP
.Vb 1
\&    $x = "There once was a girl\enWho programmed in Perl\en";
\&
\&    $x =~ /^Who/;   # doesn\*(Aqt match, "Who" not at start of string
\&    $x =~ /^Who/s;  # doesn\*(Aqt match, "Who" not at start of string
\&    $x =~ /^Who/m;  # matches, "Who" at start of second line
\&    $x =~ /^Who/sm; # matches, "Who" at start of second line
\&
\&    $x =~ /girl.Who/;   # doesn\*(Aqt match, "." doesn\*(Aqt match "\en"
\&    $x =~ /girl.Who/s;  # matches, "." matches "\en"
\&    $x =~ /girl.Who/m;  # doesn\*(Aqt match, "." doesn\*(Aqt match "\en"
\&    $x =~ /girl.Who/sm; # matches, "." matches "\en"
.Ve
.PP
Most of the time, the default behavior is what is wanted, but \f(CW\*(C`//s\*(C'\fR and
\&\f(CW\*(C`//m\*(C'\fR are occasionally very useful.  If \f(CW\*(C`//m\*(C'\fR is being used, the start
of the string can still be matched with \f(CW\*(C`\eA\*(C'\fR and the end of the string
can still be matched with the anchors \f(CW\*(C`\eZ\*(C'\fR (matches both the end and
the newline before, like \f(CW\*(C`$\*(C'\fR), and \f(CW\*(C`\ez\*(C'\fR (matches only the end):
.PP
.Vb 2
\&    $x =~ /^Who/m;   # matches, "Who" at start of second line
\&    $x =~ /\eAWho/m;  # doesn\*(Aqt match, "Who" is not at start of string
\&
\&    $x =~ /girl$/m;  # matches, "girl" at end of first line
\&    $x =~ /girl\eZ/m; # doesn\*(Aqt match, "girl" is not at end of string
\&
\&    $x =~ /Perl\eZ/m; # matches, "Perl" is at newline before end
\&    $x =~ /Perl\ez/m; # doesn\*(Aqt match, "Perl" is not at end of string
.Ve
.PP
We now know how to create choices among classes of characters in a
regexp.  What about choices among words or character strings? Such
choices are described in the next section.
.SS "Matching this or that"
.IX Subsection "Matching this or that"
Sometimes we would like our regexp to be able to match different
possible words or character strings.  This is accomplished by using
the \fIalternation\fR metacharacter \f(CW\*(C`|\*(C'\fR.  To match \f(CW\*(C`dog\*(C'\fR or \f(CW\*(C`cat\*(C'\fR, we
form the regexp \f(CW\*(C`dog|cat\*(C'\fR.  As before, Perl will try to match the
regexp at the earliest possible point in the string.  At each
character position, Perl will first try to match the first
alternative, \f(CW\*(C`dog\*(C'\fR.  If \f(CW\*(C`dog\*(C'\fR doesn't match, Perl will then try the
next alternative, \f(CW\*(C`cat\*(C'\fR.  If \f(CW\*(C`cat\*(C'\fR doesn't match either, then the
match fails and Perl moves to the next position in the string.  Some
examples:
.PP
.Vb 2
\&    "cats and dogs" =~ /cat|dog|bird/;  # matches "cat"
\&    "cats and dogs" =~ /dog|cat|bird/;  # matches "cat"
.Ve
.PP
Even though \f(CW\*(C`dog\*(C'\fR is the first alternative in the second regexp,
\&\f(CW\*(C`cat\*(C'\fR is able to match earlier in the string.
.PP
.Vb 2
\&    "cats"          =~ /c|ca|cat|cats/; # matches "c"
\&    "cats"          =~ /cats|cat|ca|c/; # matches "cats"
.Ve
.PP
Here, all the alternatives match at the first string position, so the
first alternative is the one that matches.  If some of the
alternatives are truncations of the others, put the longest ones first
to give them a chance to match.
.PP
.Vb 2
\&    "cab" =~ /a|b|c/ # matches "c"
\&                     # /a|b|c/ == /[abc]/
.Ve
.PP
The last example points out that character classes are like
alternations of characters.  At a given character position, the first
alternative that allows the regexp match to succeed will be the one
that matches.
.SS "Grouping things and hierarchical matching"
.IX Subsection "Grouping things and hierarchical matching"
Alternation allows a regexp to choose among alternatives, but by
itself it is unsatisfying.  The reason is that each alternative is a whole
regexp, but sometime we want alternatives for just part of a
regexp.  For instance, suppose we want to search for housecats or
housekeepers.  The regexp \f(CW\*(C`housecat|housekeeper\*(C'\fR fits the bill, but is
inefficient because we had to type \f(CW\*(C`house\*(C'\fR twice.  It would be nice to
have parts of the regexp be constant, like \f(CW\*(C`house\*(C'\fR, and some
parts have alternatives, like \f(CW\*(C`cat|keeper\*(C'\fR.
.PP
The \fIgrouping\fR metacharacters \f(CW\*(C`()\*(C'\fR solve this problem.  Grouping
allows parts of a regexp to be treated as a single unit.  Parts of a
regexp are grouped by enclosing them in parentheses.  Thus we could solve
the \f(CW\*(C`housecat|housekeeper\*(C'\fR by forming the regexp as
\&\f(CW\*(C`house(cat|keeper)\*(C'\fR.  The regexp \f(CW\*(C`house(cat|keeper)\*(C'\fR means match
\&\f(CW\*(C`house\*(C'\fR followed by either \f(CW\*(C`cat\*(C'\fR or \f(CW\*(C`keeper\*(C'\fR.  Some more examples
are
.PP
.Vb 4
\&    /(a|b)b/;    # matches \*(Aqab\*(Aq or \*(Aqbb\*(Aq
\&    /(ac|b)b/;   # matches \*(Aqacb\*(Aq or \*(Aqbb\*(Aq
\&    /(^a|b)c/;   # matches \*(Aqac\*(Aq at start of string or \*(Aqbc\*(Aq anywhere
\&    /(a|[bc])d/; # matches \*(Aqad\*(Aq, \*(Aqbd\*(Aq, or \*(Aqcd\*(Aq
\&
\&    /house(cat|)/;  # matches either \*(Aqhousecat\*(Aq or \*(Aqhouse\*(Aq
\&    /house(cat(s|)|)/;  # matches either \*(Aqhousecats\*(Aq or \*(Aqhousecat\*(Aq or
\&                        # \*(Aqhouse\*(Aq.  Note groups can be nested.
\&
\&    /(19|20|)\ed\ed/;  # match years 19xx, 20xx, or the Y2K problem, xx
\&    "20" =~ /(19|20|)\ed\ed/;  # matches the null alternative \*(Aq()\ed\ed\*(Aq,
\&                             # because \*(Aq20\ed\ed\*(Aq can\*(Aqt match
.Ve
.PP
Alternations behave the same way in groups as out of them: at a given
string position, the leftmost alternative that allows the regexp to
match is taken.  So in the last example at the first string position,
\&\f(CW"20"\fR matches the second alternative, but there is nothing left over
to match the next two digits \f(CW\*(C`\ed\ed\*(C'\fR.  So Perl moves on to the next
alternative, which is the null alternative and that works, since
\&\f(CW"20"\fR is two digits.
.PP
The process of trying one alternative, seeing if it matches, and
moving on to the next alternative, while going back in the string
from where the previous alternative was tried, if it doesn't, is called
\&\fIbacktracking\fR.  The term 'backtracking' comes from the idea that
matching a regexp is like a walk in the woods.  Successfully matching
a regexp is like arriving at a destination.  There are many possible
trailheads, one for each string position, and each one is tried in
order, left to right.  From each trailhead there may be many paths,
some of which get you there, and some which are dead ends.  When you
walk along a trail and hit a dead end, you have to backtrack along the
trail to an earlier point to try another trail.  If you hit your
destination, you stop immediately and forget about trying all the
other trails.  You are persistent, and only if you have tried all the
trails from all the trailheads and not arrived at your destination, do
you declare failure.  To be concrete, here is a step-by-step analysis
of what Perl does when it tries to match the regexp
.PP
.Vb 1
\&    "abcde" =~ /(abd|abc)(df|d|de)/;
.Ve
.IP "0" 4
Start with the first letter in the string 'a'.
.IP "1" 4
.IX Item "1"
Try the first alternative in the first group 'abd'.
.IP "2" 4
.IX Item "2"
Match 'a' followed by 'b'. So far so good.
.IP "3" 4
.IX Item "3"
\&'d' in the regexp doesn't match 'c' in the string \- a dead
end.  So backtrack two characters and pick the second alternative in
the first group 'abc'.
.IP "4" 4
.IX Item "4"
Match 'a' followed by 'b' followed by 'c'.  We are on a roll
and have satisfied the first group. Set \f(CW$1\fR to 'abc'.
.IP "5" 4
.IX Item "5"
Move on to the second group and pick the first alternative
\&'df'.
.IP "6" 4
.IX Item "6"
Match the 'd'.
.IP "7" 4
.IX Item "7"
\&'f' in the regexp doesn't match 'e' in the string, so a dead
end.  Backtrack one character and pick the second alternative in the
second group 'd'.
.IP "8" 4
.IX Item "8"
\&'d' matches. The second grouping is satisfied, so set \f(CW$2\fR to
\&'d'.
.IP "9" 4
.IX Item "9"
We are at the end of the regexp, so we are done! We have
matched 'abcd' out of the string \*(L"abcde\*(R".
.PP
There are a couple of things to note about this analysis.  First, the
third alternative in the second group 'de' also allows a match, but we
stopped before we got to it \- at a given character position, leftmost
wins.  Second, we were able to get a match at the first character
position of the string 'a'.  If there were no matches at the first
position, Perl would move to the second character position 'b' and
attempt the match all over again.  Only when all possible paths at all
possible character positions have been exhausted does Perl give
up and declare \f(CW\*(C`$string\ =~\ /(abd|abc)(df|d|de)/;\*(C'\fR to be false.
.PP
Even with all this work, regexp matching happens remarkably fast.  To
speed things up, Perl compiles the regexp into a compact sequence of
opcodes that can often fit inside a processor cache.  When the code is
executed, these opcodes can then run at full throttle and search very
quickly.
.SS "Extracting matches"
.IX Subsection "Extracting matches"
The grouping metacharacters \f(CW\*(C`()\*(C'\fR also serve another completely
different function: they allow the extraction of the parts of a string
that matched.  This is very useful to find out what matched and for
text processing in general.  For each grouping, the part that matched
inside goes into the special variables \f(CW$1\fR, \f(CW$2\fR, etc.  They can be
used just as ordinary variables:
.PP
.Vb 6
\&    # extract hours, minutes, seconds
\&    if ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/) {    # match hh:mm:ss format
\&        $hours = $1;
\&        $minutes = $2;
\&        $seconds = $3;
\&    }
.Ve
.PP
Now, we know that in scalar context,
\&\f(CW\*(C`$time\ =~\ /(\ed\ed):(\ed\ed):(\ed\ed)/\*(C'\fR returns a true or false
value.  In list context, however, it returns the list of matched values
\&\f(CW\*(C`($1,$2,$3)\*(C'\fR.  So we could write the code more compactly as
.PP
.Vb 2
\&    # extract hours, minutes, seconds
\&    ($hours, $minutes, $second) = ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/);
.Ve
.PP
If the groupings in a regexp are nested, \f(CW$1\fR gets the group with the
leftmost opening parenthesis, \f(CW$2\fR the next opening parenthesis,
etc.  Here is a regexp with nested groups:
.PP
.Vb 2
\&    /(ab(cd|ef)((gi)|j))/;
\&     1  2      34
.Ve
.PP
If this regexp matches, \f(CW$1\fR contains a string starting with
\&\f(CW\*(Aqab\*(Aq\fR, \f(CW$2\fR is either set to \f(CW\*(Aqcd\*(Aq\fR or \f(CW\*(Aqef\*(Aq\fR, \f(CW$3\fR equals either
\&\f(CW\*(Aqgi\*(Aq\fR or \f(CW\*(Aqj\*(Aq\fR, and \f(CW$4\fR is either set to \f(CW\*(Aqgi\*(Aq\fR, just like \f(CW$3\fR,
or it remains undefined.
.PP
For convenience, Perl sets \f(CW$+\fR to the string held by the highest numbered
\&\f(CW$1\fR, \f(CW$2\fR,... that got assigned (and, somewhat related, \f(CW$^N\fR to the
value of the \f(CW$1\fR, \f(CW$2\fR,... most-recently assigned; i.e. the \f(CW$1\fR,
\&\f(CW$2\fR,... associated with the rightmost closing parenthesis used in the
match).
.SS "Backreferences"
.IX Subsection "Backreferences"
Closely associated with the matching variables \f(CW$1\fR, \f(CW$2\fR, ... are
the \fIbackreferences\fR \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR,...  Backreferences are simply
matching variables that can be used \fIinside\fR a regexp.  This is a
really nice feature; what matches later in a regexp is made to depend on
what matched earlier in the regexp.  Suppose we wanted to look
for doubled words in a text, like 'the the'.  The following regexp finds
all 3\-letter doubles with a space in between:
.PP
.Vb 1
\&    /\eb(\ew\ew\ew)\es\eg1\eb/;
.Ve
.PP
The grouping assigns a value to \eg1, so that the same 3\-letter sequence
is used for both parts.
.PP
A similar task is to find words consisting of two identical parts:
.PP
.Vb 7
\&    % simple_grep \*(Aq^(\ew\ew\ew\ew|\ew\ew\ew|\ew\ew|\ew)\eg1$\*(Aq /usr/dict/words
\&    beriberi
\&    booboo
\&    coco
\&    mama
\&    murmur
\&    papa
.Ve
.PP
The regexp has a single grouping which considers 4\-letter
combinations, then 3\-letter combinations, etc., and uses \f(CW\*(C`\eg1\*(C'\fR to look for
a repeat.  Although \f(CW$1\fR and \f(CW\*(C`\eg1\*(C'\fR represent the same thing, care should be
taken to use matched variables \f(CW$1\fR, \f(CW$2\fR,... only \fIoutside\fR a regexp
and backreferences \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR,... only \fIinside\fR a regexp; not doing
so may lead to surprising and unsatisfactory results.
.SS "Relative backreferences"
.IX Subsection "Relative backreferences"
Counting the opening parentheses to get the correct number for a
backreference is error-prone as soon as there is more than one
capturing group.  A more convenient technique became available
with Perl 5.10: relative backreferences. To refer to the immediately
preceding capture group one now may write \f(CW\*(C`\eg{\-1}\*(C'\fR, the next but
last is available via \f(CW\*(C`\eg{\-2}\*(C'\fR, and so on.
.PP
Another good reason in addition to readability and maintainability
for using relative backreferences is illustrated by the following example,
where a simple pattern for matching peculiar strings is used:
.PP
.Vb 1
\&    $a99a = \*(Aq([a\-z])(\ed)\eg2\eg1\*(Aq;   # matches a11a, g22g, x33x, etc.
.Ve
.PP
Now that we have this pattern stored as a handy string, we might feel
tempted to use it as a part of some other pattern:
.PP
.Vb 6
\&    $line = "code=e99e";
\&    if ($line =~ /^(\ew+)=$a99a$/){   # unexpected behavior!
\&        print "$1 is valid\en";
\&    } else {
\&        print "bad line: \*(Aq$line\*(Aq\en";
\&    }
.Ve
.PP
But this doesn't match, at least not the way one might expect. Only
after inserting the interpolated \f(CW$a99a\fR and looking at the resulting
full text of the regexp is it obvious that the backreferences have
backfired. The subexpression \f(CW\*(C`(\ew+)\*(C'\fR has snatched number 1 and
demoted the groups in \f(CW$a99a\fR by one rank. This can be avoided by
using relative backreferences:
.PP
.Vb 1
\&    $a99a = \*(Aq([a\-z])(\ed)\eg{\-1}\eg{\-2}\*(Aq;  # safe for being interpolated
.Ve
.SS "Named backreferences"
.IX Subsection "Named backreferences"
Perl 5.10 also introduced named capture groups and named backreferences.
To attach a name to a capturing group, you write either
\&\f(CW\*(C`(?<name>...)\*(C'\fR or \f(CW\*(C`(?\*(Aqname\*(Aq...)\*(C'\fR.  The backreference may
then be written as \f(CW\*(C`\eg{name}\*(C'\fR.  It is permissible to attach the
same name to more than one group, but then only the leftmost one of the
eponymous set can be referenced.  Outside of the pattern a named
capture group is accessible through the \f(CW\*(C`%+\*(C'\fR hash.
.PP
Assuming that we have to match calendar dates which may be given in one
of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write
three suitable patterns where we use 'd', 'm' and 'y' respectively as the
names of the groups capturing the pertaining components of a date. The
matching operation combines the three patterns as alternatives:
.PP
.Vb 8
\&    $fmt1 = \*(Aq(?<y>\ed\ed\ed\ed)\-(?<m>\ed\ed)\-(?<d>\ed\ed)\*(Aq;
\&    $fmt2 = \*(Aq(?<m>\ed\ed)/(?<d>\ed\ed)/(?<y>\ed\ed\ed\ed)\*(Aq;
\&    $fmt3 = \*(Aq(?<d>\ed\ed)\e.(?<m>\ed\ed)\e.(?<y>\ed\ed\ed\ed)\*(Aq;
\&    for my $d qw( 2006\-10\-21 15.01.2007 10/31/2005 ){
\&        if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
\&            print "day=$+{d} month=$+{m} year=$+{y}\en";
\&        }
\&    }
.Ve
.PP
If any of the alternatives matches, the hash \f(CW\*(C`%+\*(C'\fR is bound to contain the
three key-value pairs.
.SS "Alternative capture group numbering"
.IX Subsection "Alternative capture group numbering"
Yet another capturing group numbering technique (also as from Perl 5.10)
deals with the problem of referring to groups within a set of alternatives.
Consider a pattern for matching a time of the day, civil or military style:
.PP
.Vb 3
\&    if ( $time =~ /(\ed\ed|\ed):(\ed\ed)|(\ed\ed)(\ed\ed)/ ){
\&        # process hour and minute
\&    }
.Ve
.PP
Processing the results requires an additional if statement to determine
whether \f(CW$1\fR and \f(CW$2\fR or \f(CW$3\fR and \f(CW$4\fR contain the goodies. It would
be easier if we could use group numbers 1 and 2 in second alternative as
well, and this is exactly what the parenthesized construct \f(CW\*(C`(?|...)\*(C'\fR,
set around an alternative achieves. Here is an extended version of the
previous pattern:
.PP
.Vb 3
\&    if ( $time =~ /(?|(\ed\ed|\ed):(\ed\ed)|(\ed\ed)(\ed\ed))\es+([A\-Z][A\-Z][A\-Z])/ ){
\&        print "hour=$1 minute=$2 zone=$3\en";
\&    }
.Ve
.PP
Within the alternative numbering group, group numbers start at the same
position for each alternative. After the group, numbering continues
with one higher than the maximum reached across all the alternatives.
.SS "Position information"
.IX Subsection "Position information"
In addition to what was matched, Perl (since 5.6.0) also provides the
positions of what was matched as contents of the \f(CW\*(C`@\-\*(C'\fR and \f(CW\*(C`@+\*(C'\fR
arrays. \f(CW\*(C`$\-[0]\*(C'\fR is the position of the start of the entire match and
\&\f(CW$+[0]\fR is the position of the end. Similarly, \f(CW\*(C`$\-[n]\*(C'\fR is the
position of the start of the \f(CW$n\fR match and \f(CW$+[n]\fR is the position
of the end. If \f(CW$n\fR is undefined, so are \f(CW\*(C`$\-[n]\*(C'\fR and \f(CW$+[n]\fR. Then
this code
.PP
.Vb 5
\&    $x = "Mmm...donut, thought Homer";
\&    $x =~ /^(Mmm|Yech)\e.\e.\e.(donut|peas)/; # matches
\&    foreach $expr (1..$#\-) {
\&        print "Match $expr: \*(Aq${$expr}\*(Aq at position ($\-[$expr],$+[$expr])\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 2
\&    Match 1: \*(AqMmm\*(Aq at position (0,3)
\&    Match 2: \*(Aqdonut\*(Aq at position (6,11)
.Ve
.PP
Even if there are no groupings in a regexp, it is still possible to
find out what exactly matched in a string.  If you use them, Perl
will set \f(CW\*(C`$\`\*(C'\fR to the part of the string before the match, will set \f(CW$&\fR
to the part of the string that matched, and will set \f(CW\*(C`$\*(Aq\*(C'\fR to the part
of the string after the match.  An example:
.PP
.Vb 3
\&    $x = "the cat caught the mouse";
\&    $x =~ /cat/;  # $\` = \*(Aqthe \*(Aq, $& = \*(Aqcat\*(Aq, $\*(Aq = \*(Aq caught the mouse\*(Aq
\&    $x =~ /the/;  # $\` = \*(Aq\*(Aq, $& = \*(Aqthe\*(Aq, $\*(Aq = \*(Aq cat caught the mouse\*(Aq
.Ve
.PP
In the second match, \f(CW\*(C`$\`\*(C'\fR equals \f(CW\*(Aq\*(Aq\fR because the regexp matched at the
first character position in the string and stopped; it never saw the
second 'the'.  It is important to note that using \f(CW\*(C`$\`\*(C'\fR and \f(CW\*(C`$\*(Aq\*(C'\fR
slows down regexp matching quite a bit, while \f(CW$&\fR slows it down to a
lesser extent, because if they are used in one regexp in a program,
they are generated for \fIall\fR regexps in the program.  So if raw
performance is a goal of your application, they should be avoided.
If you need to extract the corresponding substrings, use \f(CW\*(C`@\-\*(C'\fR and
\&\f(CW\*(C`@+\*(C'\fR instead:
.PP
.Vb 3
\&    $\` is the same as substr( $x, 0, $\-[0] )
\&    $& is the same as substr( $x, $\-[0], $+[0]\-$\-[0] )
\&    $\*(Aq is the same as substr( $x, $+[0] )
.Ve
.PP
As of Perl 5.10, the \f(CW\*(C`${^PREMATCH}\*(C'\fR, \f(CW\*(C`${^MATCH}\*(C'\fR and \f(CW\*(C`${^POSTMATCH}\*(C'\fR
variables may be used. These are only set if the \f(CW\*(C`/p\*(C'\fR modifier is present.
Consequently they do not penalize the rest of the program.
.SS "Non-capturing groupings"
.IX Subsection "Non-capturing groupings"
A group that is required to bundle a set of alternatives may or may not be
useful as a capturing group.  If it isn't, it just creates a superfluous
addition to the set of available capture group values, inside as well as
outside the regexp.  Non-capturing groupings, denoted by \f(CW\*(C`(?:regexp)\*(C'\fR,
still allow the regexp to be treated as a single unit, but don't establish
a capturing group at the same time.  Both capturing and non-capturing
groupings are allowed to co-exist in the same regexp.  Because there is
no extraction, non-capturing groupings are faster than capturing
groupings.  Non-capturing groupings are also handy for choosing exactly
which parts of a regexp are to be extracted to matching variables:
.PP
.Vb 2
\&    # match a number, $1\-$4 are set, but we only want $1
\&    /([+\-]?\e *(\ed+(\e.\ed*)?|\e.\ed+)([eE][+\-]?\ed+)?)/;
\&
\&    # match a number faster , only $1 is set
\&    /([+\-]?\e *(?:\ed+(?:\e.\ed*)?|\e.\ed+)(?:[eE][+\-]?\ed+)?)/;
\&
\&    # match a number, get $1 = whole number, $2 = exponent
\&    /([+\-]?\e *(?:\ed+(?:\e.\ed*)?|\e.\ed+)(?:[eE]([+\-]?\ed+))?)/;
.Ve
.PP
Non-capturing groupings are also useful for removing nuisance
elements gathered from a split operation where parentheses are
required for some reason:
.PP
.Vb 3
\&    $x = \*(Aq12aba34ba5\*(Aq;
\&    @num = split /(a|b)+/, $x;    # @num = (\*(Aq12\*(Aq,\*(Aqa\*(Aq,\*(Aq34\*(Aq,\*(Aqa\*(Aq,\*(Aq5\*(Aq)
\&    @num = split /(?:a|b)+/, $x;  # @num = (\*(Aq12\*(Aq,\*(Aq34\*(Aq,\*(Aq5\*(Aq)
.Ve
.SS "Matching repetitions"
.IX Subsection "Matching repetitions"
The examples in the previous section display an annoying weakness.  We
were only matching 3\-letter words, or chunks of words of 4 letters or
less.  We'd like to be able to match words or, more generally, strings
of any length, without writing out tedious alternatives like
\&\f(CW\*(C`\ew\ew\ew\ew|\ew\ew\ew|\ew\ew|\ew\*(C'\fR.
.PP
This is exactly the problem the \fIquantifier\fR metacharacters \f(CW\*(C`?\*(C'\fR,
\&\f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR, and \f(CW\*(C`{}\*(C'\fR were created for.  They allow us to delimit the
number of repeats for a portion of a regexp we consider to be a
match.  Quantifiers are put immediately after the character, character
class, or grouping that we want to specify.  They have the following
meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a?\*(C'\fR means: match 'a' 1 or 0 times
.IP "\(bu" 4
\&\f(CW\*(C`a*\*(C'\fR means: match 'a' 0 or more times, i.e., any number of times
.IP "\(bu" 4
\&\f(CW\*(C`a+\*(C'\fR means: match 'a' 1 or more times, i.e., at least once
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, but not more than \f(CW\*(C`m\*(C'\fR
times.
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR or more times
.IP "\(bu" 4
\&\f(CW\*(C`a{n}\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times
.PP
Here are some examples:
.PP
.Vb 10
\&    /[a\-z]+\es+\ed*/;  # match a lowercase word, at least one space, and
\&                     # any number of digits
\&    /(\ew+)\es+\eg1/;    # match doubled words of arbitrary length
\&    /y(es)?/i;       # matches \*(Aqy\*(Aq, \*(AqY\*(Aq, or a case\-insensitive \*(Aqyes\*(Aq
\&    $year =~ /^\ed{2,4}$/;  # make sure year is at least 2 but not more
\&                           # than 4 digits
\&    $year =~ /^\ed{4}$|^\ed{2}$/;    # better match; throw out 3\-digit dates
\&    $year =~ /^\ed{2}(\ed{2})?$/;  # same thing written differently. However,
\&                                 # this captures the last two digits in $1
\&                                 # and the other does not.
\&
\&    % simple_grep \*(Aq^(\ew+)\eg1$\*(Aq /usr/dict/words   # isn\*(Aqt this easier?
\&    beriberi
\&    booboo
\&    coco
\&    mama
\&    murmur
\&    papa
.Ve
.PP
For all of these quantifiers, Perl will try to match as much of the
string as possible, while still allowing the regexp to succeed.  Thus
with \f(CW\*(C`/a?.../\*(C'\fR, Perl will first try to match the regexp with the \f(CW\*(C`a\*(C'\fR
present; if that fails, Perl will try to match the regexp without the
\&\f(CW\*(C`a\*(C'\fR present.  For the quantifier \f(CW\*(C`*\*(C'\fR, we get the following:
.PP
.Vb 5
\&    $x = "the cat in the hat";
\&    $x =~ /^(.*)(cat)(.*)$/; # matches,
\&                             # $1 = \*(Aqthe \*(Aq
\&                             # $2 = \*(Aqcat\*(Aq
\&                             # $3 = \*(Aq in the hat\*(Aq
.Ve
.PP
Which is what we might expect, the match finds the only \f(CW\*(C`cat\*(C'\fR in the
string and locks onto it.  Consider, however, this regexp:
.PP
.Vb 4
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe cat in the h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 characters match)
.Ve
.PP
One might initially guess that Perl would find the \f(CW\*(C`at\*(C'\fR in \f(CW\*(C`cat\*(C'\fR and
stop there, but that wouldn't give the longest possible string to the
first quantifier \f(CW\*(C`.*\*(C'\fR.  Instead, the first quantifier \f(CW\*(C`.*\*(C'\fR grabs as
much of the string as possible while still having the regexp match.  In
this example, that means having the \f(CW\*(C`at\*(C'\fR sequence with the final \f(CW\*(C`at\*(C'\fR
in the string.  The other important principle illustrated here is that,
when there are two or more elements in a regexp, the \fIleftmost\fR
quantifier, if there is one, gets to grab as much of the string as
possible, leaving the rest of the regexp to fight over scraps.  Thus in
our example, the first quantifier \f(CW\*(C`.*\*(C'\fR grabs most of the string, while
the second quantifier \f(CW\*(C`.*\*(C'\fR gets the empty string.   Quantifiers that
grab as much of the string as possible are called \fImaximal match\fR or
\&\fIgreedy\fR quantifiers.
.PP
When a regexp can match a string in several different ways, we can use
the principles above to predict which way the regexp will match:
.IP "\(bu" 4
Principle 0: Taken as a whole, any regexp will be matched at the
earliest possible position in the string.
.IP "\(bu" 4
Principle 1: In an alternation \f(CW\*(C`a|b|c...\*(C'\fR, the leftmost alternative
that allows a match for the whole regexp will be the one used.
.IP "\(bu" 4
Principle 2: The maximal matching quantifiers \f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR and
\&\f(CW\*(C`{n,m}\*(C'\fR will in general match as much of the string as possible while
still allowing the whole regexp to match.
.IP "\(bu" 4
Principle 3: If there are two or more elements in a regexp, the
leftmost greedy quantifier, if any, will match as much of the string
as possible while still allowing the whole regexp to match.  The next
leftmost greedy quantifier, if any, will try to match as much of the
string remaining available to it as possible, while still allowing the
whole regexp to match.  And so on, until all the regexp elements are
satisfied.
.PP
As we have seen above, Principle 0 overrides the others. The regexp
will be matched as early as possible, with the other principles
determining how the regexp matches at that earliest character
position.
.PP
Here is an example of these principles in action:
.PP
.Vb 5
\&    $x = "The programming republic of Perl";
\&    $x =~ /^(.+)(e|r)(.*)$/;  # matches,
\&                              # $1 = \*(AqThe programming republic of Pe\*(Aq
\&                              # $2 = \*(Aqr\*(Aq
\&                              # $3 = \*(Aql\*(Aq
.Ve
.PP
This regexp matches at the earliest string position, \f(CW\*(AqT\*(Aq\fR.  One
might think that \f(CW\*(C`e\*(C'\fR, being leftmost in the alternation, would be
matched, but \f(CW\*(C`r\*(C'\fR produces the longest string in the first quantifier.
.PP
.Vb 3
\&    $x =~ /(m{1,2})(.*)$/;  # matches,
\&                            # $1 = \*(Aqmm\*(Aq
\&                            # $2 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Here, The earliest possible match is at the first \f(CW\*(Aqm\*(Aq\fR in
\&\f(CW\*(C`programming\*(C'\fR. \f(CW\*(C`m{1,2}\*(C'\fR is the first quantifier, so it gets to match
a maximal \f(CW\*(C`mm\*(C'\fR.
.PP
.Vb 3
\&    $x =~ /.*(m{1,2})(.*)$/;  # matches,
\&                              # $1 = \*(Aqm\*(Aq
\&                              # $2 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Here, the regexp matches at the start of the string. The first
quantifier \f(CW\*(C`.*\*(C'\fR grabs as much as possible, leaving just a single
\&\f(CW\*(Aqm\*(Aq\fR for the second quantifier \f(CW\*(C`m{1,2}\*(C'\fR.
.PP
.Vb 4
\&    $x =~ /(.?)(m{1,2})(.*)$/;  # matches,
\&                                # $1 = \*(Aqa\*(Aq
\&                                # $2 = \*(Aqmm\*(Aq
\&                                # $3 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Here, \f(CW\*(C`.?\*(C'\fR eats its maximal one character at the earliest possible
position in the string, \f(CW\*(Aqa\*(Aq\fR in \f(CW\*(C`programming\*(C'\fR, leaving \f(CW\*(C`m{1,2}\*(C'\fR
the opportunity to match both \f(CW\*(C`m\*(C'\fR's. Finally,
.PP
.Vb 1
\&    "aXXXb" =~ /(X*)/; # matches with $1 = \*(Aq\*(Aq
.Ve
.PP
because it can match zero copies of \f(CW\*(AqX\*(Aq\fR at the beginning of the
string.  If you definitely want to match at least one \f(CW\*(AqX\*(Aq\fR, use
\&\f(CW\*(C`X+\*(C'\fR, not \f(CW\*(C`X*\*(C'\fR.
.PP
Sometimes greed is not good.  At times, we would like quantifiers to
match a \fIminimal\fR piece of string, rather than a maximal piece.  For
this purpose, Larry Wall created the \fIminimal match\fR or
\&\fInon-greedy\fR quantifiers \f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, and \f(CW\*(C`{}?\*(C'\fR.  These are
the usual quantifiers with a \f(CW\*(C`?\*(C'\fR appended to them.  They have the
following meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a??\*(C'\fR means: match 'a' 0 or 1 times. Try 0 first, then 1.
.IP "\(bu" 4
\&\f(CW\*(C`a*?\*(C'\fR means: match 'a' 0 or more times, i.e., any number of times,
but as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a+?\*(C'\fR means: match 'a' 1 or more times, i.e., at least once, but
as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}?\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, not more than \f(CW\*(C`m\*(C'\fR
times, as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}?\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, but as few times as
possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n}?\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times.  Because we match exactly
\&\f(CW\*(C`n\*(C'\fR times, \f(CW\*(C`a{n}?\*(C'\fR is equivalent to \f(CW\*(C`a{n}\*(C'\fR and is just there for
notational consistency.
.PP
Let's look at the example above, but with minimal quantifiers:
.PP
.Vb 5
\&    $x = "The programming republic of Perl";
\&    $x =~ /^(.+?)(e|r)(.*)$/; # matches,
\&                              # $1 = \*(AqTh\*(Aq
\&                              # $2 = \*(Aqe\*(Aq
\&                              # $3 = \*(Aq programming republic of Perl\*(Aq
.Ve
.PP
The minimal string that will allow both the start of the string \f(CW\*(C`^\*(C'\fR
and the alternation to match is \f(CW\*(C`Th\*(C'\fR, with the alternation \f(CW\*(C`e|r\*(C'\fR
matching \f(CW\*(C`e\*(C'\fR.  The second quantifier \f(CW\*(C`.*\*(C'\fR is free to gobble up the
rest of the string.
.PP
.Vb 3
\&    $x =~ /(m{1,2}?)(.*?)$/;  # matches,
\&                              # $1 = \*(Aqm\*(Aq
\&                              # $2 = \*(Aqming republic of Perl\*(Aq
.Ve
.PP
The first string position that this regexp can match is at the first
\&\f(CW\*(Aqm\*(Aq\fR in \f(CW\*(C`programming\*(C'\fR. At this position, the minimal \f(CW\*(C`m{1,2}?\*(C'\fR
matches just one \f(CW\*(Aqm\*(Aq\fR.  Although the second quantifier \f(CW\*(C`.*?\*(C'\fR would
prefer to match no characters, it is constrained by the end-of-string
anchor \f(CW\*(C`$\*(C'\fR to match the rest of the string.
.PP
.Vb 4
\&    $x =~ /(.*?)(m{1,2}?)(.*)$/;  # matches,
\&                                  # $1 = \*(AqThe progra\*(Aq
\&                                  # $2 = \*(Aqm\*(Aq
\&                                  # $3 = \*(Aqming republic of Perl\*(Aq
.Ve
.PP
In this regexp, you might expect the first minimal quantifier \f(CW\*(C`.*?\*(C'\fR
to match the empty string, because it is not constrained by a \f(CW\*(C`^\*(C'\fR
anchor to match the beginning of the word.  Principle 0 applies here,
however.  Because it is possible for the whole regexp to match at the
start of the string, it \fIwill\fR match at the start of the string.  Thus
the first quantifier has to match everything up to the first \f(CW\*(C`m\*(C'\fR.  The
second minimal quantifier matches just one \f(CW\*(C`m\*(C'\fR and the third
quantifier matches the rest of the string.
.PP
.Vb 4
\&    $x =~ /(.??)(m{1,2})(.*)$/;  # matches,
\&                                 # $1 = \*(Aqa\*(Aq
\&                                 # $2 = \*(Aqmm\*(Aq
\&                                 # $3 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Just as in the previous regexp, the first quantifier \f(CW\*(C`.??\*(C'\fR can match
earliest at position \f(CW\*(Aqa\*(Aq\fR, so it does.  The second quantifier is
greedy, so it matches \f(CW\*(C`mm\*(C'\fR, and the third matches the rest of the
string.
.PP
We can modify principle 3 above to take into account non-greedy
quantifiers:
.IP "\(bu" 4
Principle 3: If there are two or more elements in a regexp, the
leftmost greedy (non-greedy) quantifier, if any, will match as much
(little) of the string as possible while still allowing the whole
regexp to match.  The next leftmost greedy (non-greedy) quantifier, if
any, will try to match as much (little) of the string remaining
available to it as possible, while still allowing the whole regexp to
match.  And so on, until all the regexp elements are satisfied.
.PP
Just like alternation, quantifiers are also susceptible to
backtracking.  Here is a step-by-step analysis of the example
.PP
.Vb 5
\&    $x = "the cat in the hat";
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe cat in the h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 matches)
.Ve
.IP "0" 4
Start with the first letter in the string 't'.
.IP "1" 4
.IX Item "1"
The first quantifier '.*' starts out by matching the whole
string 'the cat in the hat'.
.IP "2" 4
.IX Item "2"
\&'a' in the regexp element 'at' doesn't match the end of the
string.  Backtrack one character.
.IP "3" 4
.IX Item "3"
\&'a' in the regexp element 'at' still doesn't match the last
letter of the string 't', so backtrack one more character.
.IP "4" 4
.IX Item "4"
Now we can match the 'a' and the 't'.
.IP "5" 4
.IX Item "5"
Move on to the third element '.*'.  Since we are at the end of
the string and '.*' can match 0 times, assign it the empty string.
.IP "6" 4
.IX Item "6"
We are done!
.PP
Most of the time, all this moving forward and backtracking happens
quickly and searching is fast. There are some pathological regexps,
however, whose execution time exponentially grows with the size of the
string.  A typical structure that blows up in your face is of the form
.PP
.Vb 1
\&    /(a|b+)*/;
.Ve
.PP
The problem is the nested indeterminate quantifiers.  There are many
different ways of partitioning a string of length n between the \f(CW\*(C`+\*(C'\fR
and \f(CW\*(C`*\*(C'\fR: one repetition with \f(CW\*(C`b+\*(C'\fR of length n, two repetitions with
the first \f(CW\*(C`b+\*(C'\fR length k and the second with length n\-k, m repetitions
whose bits add up to length n, etc.  In fact there are an exponential
number of ways to partition a string as a function of its length.  A
regexp may get lucky and match early in the process, but if there is
no match, Perl will try \fIevery\fR possibility before giving up.  So be
careful with nested \f(CW\*(C`*\*(C'\fR's, \f(CW\*(C`{n,m}\*(C'\fR's, and \f(CW\*(C`+\*(C'\fR's.  The book
\&\fIMastering Regular Expressions\fR by Jeffrey Friedl gives a wonderful
discussion of this and other efficiency issues.
.SS "Possessive quantifiers"
.IX Subsection "Possessive quantifiers"
Backtracking during the relentless search for a match may be a waste
of time, particularly when the match is bound to fail.  Consider
the simple pattern
.PP
.Vb 1
\&    /^\ew+\es+\ew+$/; # a word, spaces, a word
.Ve
.PP
Whenever this is applied to a string which doesn't quite meet the
pattern's expectations such as \f(CW"abc\ \ "\fR or \f(CW"abc\ \ def\ "\fR,
the regex engine will backtrack, approximately once for each character
in the string.  But we know that there is no way around taking \fIall\fR
of the initial word characters to match the first repetition, that \fIall\fR
spaces must be eaten by the middle part, and the same goes for the second
word.
.PP
With the introduction of the \fIpossessive quantifiers\fR in Perl 5.10, we
have a way of instructing the regex engine not to backtrack, with the
usual quantifiers with a \f(CW\*(C`+\*(C'\fR appended to them.  This makes them greedy as
well as stingy; once they succeed they won't give anything back to permit
another solution. They have the following meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}+\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, not more than \f(CW\*(C`m\*(C'\fR times,
as many times as possible, and don't give anything up. \f(CW\*(C`a?+\*(C'\fR is short
for \f(CW\*(C`a{0,1}+\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}+\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, but as many times as possible,
and don't give anything up. \f(CW\*(C`a*+\*(C'\fR is short for \f(CW\*(C`a{0,}+\*(C'\fR and \f(CW\*(C`a++\*(C'\fR is
short for \f(CW\*(C`a{1,}+\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`a{n}+\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times.  It is just there for
notational consistency.
.PP
These possessive quantifiers represent a special case of a more general
concept, the \fIindependent subexpression\fR, see below.
.PP
As an example where a possessive quantifier is suitable we consider
matching a quoted string, as it appears in several programming languages.
The backslash is used as an escape character that indicates that the
next character is to be taken literally, as another character for the
string.  Therefore, after the opening quote, we expect a (possibly
empty) sequence of alternatives: either some character except an
unescaped quote or backslash or an escaped character.
.PP
.Vb 1
\&    /"(?:[^"\e\e]++|\e\e.)*+"/;
.Ve
.SS "Building a regexp"
.IX Subsection "Building a regexp"
At this point, we have all the basic regexp concepts covered, so let's
give a more involved example of a regular expression.  We will build a
regexp that matches numbers.
.PP
The first task in building a regexp is to decide what we want to match
and what we want to exclude.  In our case, we want to match both
integers and floating point numbers and we want to reject any string
that isn't a number.
.PP
The next task is to break the problem down into smaller problems that
are easily converted into a regexp.
.PP
The simplest case is integers.  These consist of a sequence of digits,
with an optional sign in front.  The digits we can represent with
\&\f(CW\*(C`\ed+\*(C'\fR and the sign can be matched with \f(CW\*(C`[+\-]\*(C'\fR.  Thus the integer
regexp is
.PP
.Vb 1
\&    /[+\-]?\ed+/;  # matches integers
.Ve
.PP
A floating point number potentially has a sign, an integral part, a
decimal point, a fractional part, and an exponent.  One or more of these
parts is optional, so we need to check out the different
possibilities.  Floating point numbers which are in proper form include
123., 0.345, .34, \-1e6, and 25.4E\-72.  As with integers, the sign out
front is completely optional and can be matched by \f(CW\*(C`[+\-]?\*(C'\fR.  We can
see that if there is no exponent, floating point numbers must have a
decimal point, otherwise they are integers.  We might be tempted to
model these with \f(CW\*(C`\ed*\e.\ed*\*(C'\fR, but this would also match just a single
decimal point, which is not a number.  So the three cases of floating
point number without exponent are
.PP
.Vb 3
\&   /[+\-]?\ed+\e./;  # 1., 321., etc.
\&   /[+\-]?\e.\ed+/;  # .1, .234, etc.
\&   /[+\-]?\ed+\e.\ed+/;  # 1.0, 30.56, etc.
.Ve
.PP
These can be combined into a single regexp with a three-way alternation:
.PP
.Vb 1
\&   /[+\-]?(\ed+\e.\ed+|\ed+\e.|\e.\ed+)/;  # floating point, no exponent
.Ve
.PP
In this alternation, it is important to put \f(CW\*(Aq\ed+\e.\ed+\*(Aq\fR before
\&\f(CW\*(Aq\ed+\e.\*(Aq\fR.  If \f(CW\*(Aq\ed+\e.\*(Aq\fR were first, the regexp would happily match that
and ignore the fractional part of the number.
.PP
Now consider floating point numbers with exponents.  The key
observation here is that \fIboth\fR integers and numbers with decimal
points are allowed in front of an exponent.  Then exponents, like the
overall sign, are independent of whether we are matching numbers with
or without decimal points, and can be 'decoupled' from the
mantissa.  The overall form of the regexp now becomes clear:
.PP
.Vb 1
\&    /^(optional sign)(integer | f.p. mantissa)(optional exponent)$/;
.Ve
.PP
The exponent is an \f(CW\*(C`e\*(C'\fR or \f(CW\*(C`E\*(C'\fR, followed by an integer.  So the
exponent regexp is
.PP
.Vb 1
\&   /[eE][+\-]?\ed+/;  # exponent
.Ve
.PP
Putting all the parts together, we get a regexp that matches numbers:
.PP
.Vb 1
\&   /^[+\-]?(\ed+\e.\ed+|\ed+\e.|\e.\ed+|\ed+)([eE][+\-]?\ed+)?$/;  # Ta da!
.Ve
.PP
Long regexps like this may impress your friends, but can be hard to
decipher.  In complex situations like this, the \f(CW\*(C`//x\*(C'\fR modifier for a
match is invaluable.  It allows one to put nearly arbitrary whitespace
and comments into a regexp without affecting their meaning.  Using it,
we can rewrite our 'extended' regexp in the more pleasing form
.PP
.Vb 10
\&   /^
\&      [+\-]?         # first, match an optional sign
\&      (             # then match integers or f.p. mantissas:
\&          \ed+\e.\ed+  # mantissa of the form a.b
\&         |\ed+\e.     # mantissa of the form a.
\&         |\e.\ed+     # mantissa of the form .b
\&         |\ed+       # integer of the form a
\&      )
\&      ([eE][+\-]?\ed+)?  # finally, optionally match an exponent
\&   $/x;
.Ve
.PP
If whitespace is mostly irrelevant, how does one include space
characters in an extended regexp? The answer is to backslash it
\&\f(CW\*(Aq\e\ \*(Aq\fR or put it in a character class \f(CW\*(C`[\ ]\*(C'\fR.  The same thing
goes for pound signs: use \f(CW\*(C`\e#\*(C'\fR or \f(CW\*(C`[#]\*(C'\fR.  For instance, Perl allows
a space between the sign and the mantissa or integer, and we could add
this to our regexp as follows:
.PP
.Vb 10
\&   /^
\&      [+\-]?\e *      # first, match an optional sign *and space*
\&      (             # then match integers or f.p. mantissas:
\&          \ed+\e.\ed+  # mantissa of the form a.b
\&         |\ed+\e.     # mantissa of the form a.
\&         |\e.\ed+     # mantissa of the form .b
\&         |\ed+       # integer of the form a
\&      )
\&      ([eE][+\-]?\ed+)?  # finally, optionally match an exponent
\&   $/x;
.Ve
.PP
In this form, it is easier to see a way to simplify the
alternation.  Alternatives 1, 2, and 4 all start with \f(CW\*(C`\ed+\*(C'\fR, so it
could be factored out:
.PP
.Vb 11
\&   /^
\&      [+\-]?\e *      # first, match an optional sign
\&      (             # then match integers or f.p. mantissas:
\&          \ed+       # start out with a ...
\&          (
\&              \e.\ed* # mantissa of the form a.b or a.
\&          )?        # ? takes care of integers of the form a
\&         |\e.\ed+     # mantissa of the form .b
\&      )
\&      ([eE][+\-]?\ed+)?  # finally, optionally match an exponent
\&   $/x;
.Ve
.PP
or written in the compact form,
.PP
.Vb 1
\&    /^[+\-]?\e *(\ed+(\e.\ed*)?|\e.\ed+)([eE][+\-]?\ed+)?$/;
.Ve
.PP
This is our final regexp.  To recap, we built a regexp by
.IP "\(bu" 4
specifying the task in detail,
.IP "\(bu" 4
breaking down the problem into smaller parts,
.IP "\(bu" 4
translating the small parts into regexps,
.IP "\(bu" 4
combining the regexps,
.IP "\(bu" 4
and optimizing the final combined regexp.
.PP
These are also the typical steps involved in writing a computer
program.  This makes perfect sense, because regular expressions are
essentially programs written in a little computer language that specifies
patterns.
.SS "Using regular expressions in Perl"
.IX Subsection "Using regular expressions in Perl"
The last topic of Part 1 briefly covers how regexps are used in Perl
programs.  Where do they fit into Perl syntax?
.PP
We have already introduced the matching operator in its default
\&\f(CW\*(C`/regexp/\*(C'\fR and arbitrary delimiter \f(CW\*(C`m!regexp!\*(C'\fR forms.  We have used
the binding operator \f(CW\*(C`=~\*(C'\fR and its negation \f(CW\*(C`!~\*(C'\fR to test for string
matches.  Associated with the matching operator, we have discussed the
single line \f(CW\*(C`//s\*(C'\fR, multi-line \f(CW\*(C`//m\*(C'\fR, case-insensitive \f(CW\*(C`//i\*(C'\fR and
extended \f(CW\*(C`//x\*(C'\fR modifiers.  There are a few more things you might
want to know about matching operators.
.PP
\fIProhibiting substitution\fR
.IX Subsection "Prohibiting substitution"
.PP
If you change \f(CW$pattern\fR after the first substitution happens, Perl
will ignore it.  If you don't want any substitutions at all, use the
special delimiter \f(CW\*(C`m\*(Aq\*(Aq\*(C'\fR:
.PP
.Vb 4
\&    @pattern = (\*(AqSeuss\*(Aq);
\&    while (<>) {
\&        print if m\*(Aq@pattern\*(Aq;  # matches literal \*(Aq@pattern\*(Aq, not \*(AqSeuss\*(Aq
\&    }
.Ve
.PP
Similar to strings, \f(CW\*(C`m\*(Aq\*(Aq\*(C'\fR acts like apostrophes on a regexp; all other
\&\f(CW\*(C`m\*(C'\fR delimiters act like quotes.  If the regexp evaluates to the empty string,
the regexp in the \fIlast successful match\fR is used instead.  So we have
.PP
.Vb 2
\&    "dog" =~ /d/;  # \*(Aqd\*(Aq matches
\&    "dogbert =~ //;  # this matches the \*(Aqd\*(Aq regexp used before
.Ve
.PP
\fIGlobal matching\fR
.IX Subsection "Global matching"
.PP
The final two modifiers we will discuss here,
\&\f(CW\*(C`//g\*(C'\fR and \f(CW\*(C`//c\*(C'\fR, concern multiple matches.
The modifier \f(CW\*(C`//g\*(C'\fR stands for global matching and allows the
matching operator to match within a string as many times as possible.
In scalar context, successive invocations against a string will have
\&\f(CW\*(C`//g\*(C'\fR jump from match to match, keeping track of position in the
string as it goes along.  You can get or set the position with the
\&\f(CW\*(C`pos()\*(C'\fR function.
.PP
The use of \f(CW\*(C`//g\*(C'\fR is shown in the following example.  Suppose we have
a string that consists of words separated by spaces.  If we know how
many words there are in advance, we could extract the words using
groupings:
.PP
.Vb 5
\&    $x = "cat dog house"; # 3 words
\&    $x =~ /^\es*(\ew+)\es+(\ew+)\es+(\ew+)\es*$/; # matches,
\&                                           # $1 = \*(Aqcat\*(Aq
\&                                           # $2 = \*(Aqdog\*(Aq
\&                                           # $3 = \*(Aqhouse\*(Aq
.Ve
.PP
But what if we had an indeterminate number of words? This is the sort
of task \f(CW\*(C`//g\*(C'\fR was made for.  To extract all words, form the simple
regexp \f(CW\*(C`(\ew+)\*(C'\fR and loop over all matches with \f(CW\*(C`/(\ew+)/g\*(C'\fR:
.PP
.Vb 3
\&    while ($x =~ /(\ew+)/g) {
\&        print "Word is $1, ends at position ", pos $x, "\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 3
\&    Word is cat, ends at position 3
\&    Word is dog, ends at position 7
\&    Word is house, ends at position 13
.Ve
.PP
A failed match or changing the target string resets the position.  If
you don't want the position reset after failure to match, add the
\&\f(CW\*(C`//c\*(C'\fR, as in \f(CW\*(C`/regexp/gc\*(C'\fR.  The current position in the string is
associated with the string, not the regexp.  This means that different
strings have different positions and their respective positions can be
set or read independently.
.PP
In list context, \f(CW\*(C`//g\*(C'\fR returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole regexp.  So if
we wanted just the words, we could use
.PP
.Vb 4
\&    @words = ($x =~ /(\ew+)/g);  # matches,
\&                                # $words[0] = \*(Aqcat\*(Aq
\&                                # $words[1] = \*(Aqdog\*(Aq
\&                                # $words[2] = \*(Aqhouse\*(Aq
.Ve
.PP
Closely associated with the \f(CW\*(C`//g\*(C'\fR modifier is the \f(CW\*(C`\eG\*(C'\fR anchor.  The
\&\f(CW\*(C`\eG\*(C'\fR anchor matches at the point where the previous \f(CW\*(C`//g\*(C'\fR match left
off.  \f(CW\*(C`\eG\*(C'\fR allows us to easily do context-sensitive matching:
.PP
.Vb 12
\&    $metric = 1;  # use metric units
\&    ...
\&    $x = <FILE>;  # read in measurement
\&    $x =~ /^([+\-]?\ed+)\es*/g;  # get magnitude
\&    $weight = $1;
\&    if ($metric) { # error checking
\&        print "Units error!" unless $x =~ /\eGkg\e./g;
\&    }
\&    else {
\&        print "Units error!" unless $x =~ /\eGlbs\e./g;
\&    }
\&    $x =~ /\eG\es+(widget|sprocket)/g;  # continue processing
.Ve
.PP
The combination of \f(CW\*(C`//g\*(C'\fR and \f(CW\*(C`\eG\*(C'\fR allows us to process the string a
bit at a time and use arbitrary Perl logic to decide what to do next.
Currently, the \f(CW\*(C`\eG\*(C'\fR anchor is only fully supported when used to anchor
to the start of the pattern.
.PP
\&\f(CW\*(C`\eG\*(C'\fR is also invaluable in processing fixed-length records with
regexps.  Suppose we have a snippet of coding region \s-1DNA\s0, encoded as
base pair letters \f(CW\*(C`ATCGTTGAAT...\*(C'\fR and we want to find all the stop
codons \f(CW\*(C`TGA\*(C'\fR.  In a coding region, codons are 3\-letter sequences, so
we can think of the \s-1DNA\s0 snippet as a sequence of 3\-letter records.  The
naive regexp
.PP
.Vb 3
\&    # expanded, this is "ATC GTT GAA TGC AAA TGA CAT GAC"
\&    $dna = "ATCGTTGAATGCAAATGACATGAC";
\&    $dna =~ /TGA/;
.Ve
.PP
doesn't work; it may match a \f(CW\*(C`TGA\*(C'\fR, but there is no guarantee that
the match is aligned with codon boundaries, e.g., the substring
\&\f(CW\*(C`GTT\ GAA\*(C'\fR gives a match.  A better solution is
.PP
.Vb 3
\&    while ($dna =~ /(\ew\ew\ew)*?TGA/g) {  # note the minimal *?
\&        print "Got a TGA stop codon at position ", pos $dna, "\en";
\&    }
.Ve
.PP
which prints
.PP
.Vb 2
\&    Got a TGA stop codon at position 18
\&    Got a TGA stop codon at position 23
.Ve
.PP
Position 18 is good, but position 23 is bogus.  What happened?
.PP
The answer is that our regexp works well until we get past the last
real match.  Then the regexp will fail to match a synchronized \f(CW\*(C`TGA\*(C'\fR
and start stepping ahead one character position at a time, not what we
want.  The solution is to use \f(CW\*(C`\eG\*(C'\fR to anchor the match to the codon
alignment:
.PP
.Vb 3
\&    while ($dna =~ /\eG(\ew\ew\ew)*?TGA/g) {
\&        print "Got a TGA stop codon at position ", pos $dna, "\en";
\&    }
.Ve
.PP
This prints
.PP
.Vb 1
\&    Got a TGA stop codon at position 18
.Ve
.PP
which is the correct answer.  This example illustrates that it is
important not only to match what is desired, but to reject what is not
desired.
.PP
(There are other regexp modifiers that are available, such as
\&\f(CW\*(C`//o\*(C'\fR, but their specialized uses are beyond the
scope of this introduction.  )
.PP
\fISearch and replace\fR
.IX Subsection "Search and replace"
.PP
Regular expressions also play a big role in \fIsearch and replace\fR
operations in Perl.  Search and replace is accomplished with the
\&\f(CW\*(C`s///\*(C'\fR operator.  The general form is
\&\f(CW\*(C`s/regexp/replacement/modifiers\*(C'\fR, with everything we know about
regexps and modifiers applying in this case as well.  The
\&\f(CW\*(C`replacement\*(C'\fR is a Perl double-quoted string that replaces in the
string whatever is matched with the \f(CW\*(C`regexp\*(C'\fR.  The operator \f(CW\*(C`=~\*(C'\fR is
also used here to associate a string with \f(CW\*(C`s///\*(C'\fR.  If matching
against \f(CW$_\fR, the \f(CW\*(C`$_\ =~\*(C'\fR can be dropped.  If there is a match,
\&\f(CW\*(C`s///\*(C'\fR returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:
.PP
.Vb 8
\&    $x = "Time to feed the cat!";
\&    $x =~ s/cat/hacker/;   # $x contains "Time to feed the hacker!"
\&    if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
\&        $more_insistent = 1;
\&    }
\&    $y = "\*(Aqquoted words\*(Aq";
\&    $y =~ s/^\*(Aq(.*)\*(Aq$/$1/;  # strip single quotes,
\&                           # $y contains "quoted words"
.Ve
.PP
In the last example, the whole string was matched, but only the part
inside the single quotes was grouped.  With the \f(CW\*(C`s///\*(C'\fR operator, the
matched variables \f(CW$1\fR, \f(CW$2\fR, etc. are immediately available for use
in the replacement expression, so we use \f(CW$1\fR to replace the quoted
string with just what was quoted.  With the global modifier, \f(CW\*(C`s///g\*(C'\fR
will search and replace all occurrences of the regexp in the string:
.PP
.Vb 6
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/;   # doesn\*(Aqt do it all:
\&                       # $x contains "I batted four for 4"
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/g;  # does it all:
\&                       # $x contains "I batted four for four"
.Ve
.PP
If you prefer 'regex' over 'regexp' in this tutorial, you could use
the following program to replace it:
.PP
.Vb 9
\&    % cat > simple_replace
\&    #!/usr/bin/perl
\&    $regexp = shift;
\&    $replacement = shift;
\&    while (<>) {
\&        s/$regexp/$replacement/g;
\&        print;
\&    }
\&    ^D
\&
\&    % simple_replace regexp regex perlretut.pod
.Ve
.PP
In \f(CW\*(C`simple_replace\*(C'\fR we used the \f(CW\*(C`s///g\*(C'\fR modifier to replace all
occurrences of the regexp on each line.  (Even though the regular
expression appears in a loop, Perl is smart enough to compile it
only once.)  As with \f(CW\*(C`simple_grep\*(C'\fR, both the
\&\f(CW\*(C`print\*(C'\fR and the \f(CW\*(C`s/$regexp/$replacement/g\*(C'\fR use \f(CW$_\fR implicitly.
.PP
If you don't want \f(CW\*(C`s///\*(C'\fR to change your original variable you can use
the non-destructive substitute modifier, \f(CW\*(C`s///r\*(C'\fR.  This changes the
behavior so that \f(CW\*(C`s///r\*(C'\fR returns the final substituted string
(instead of the number of substitutions):
.PP
.Vb 3
\&    $x = "I like dogs.";
\&    $y = $x =~ s/dogs/cats/r;
\&    print "$x $y\en";
.Ve
.PP
That example will print \*(L"I like dogs. I like cats\*(R". Notice the original
\&\f(CW$x\fR variable has not been affected. The overall
result of the substitution is instead stored in \f(CW$y\fR. If the
substitution doesn't affect anything then the original string is
returned:
.PP
.Vb 3
\&    $x = "I like dogs.";
\&    $y = $x =~ s/elephants/cougars/r;
\&    print "$x $y\en"; # prints "I like dogs. I like dogs."
.Ve
.PP
One other interesting thing that the \f(CW\*(C`s///r\*(C'\fR flag allows is chaining
substitutions:
.PP
.Vb 3
\&    $x = "Cats are great.";
\&    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, "\en";
\&    # prints "Hedgehogs are great."
.Ve
.PP
A modifier available specifically to search and replace is the
\&\f(CW\*(C`s///e\*(C'\fR evaluation modifier.  \f(CW\*(C`s///e\*(C'\fR treats the
replacement text as Perl code, rather than a double-quoted
string.  The value that the code returns is substituted for the
matched substring.  \f(CW\*(C`s///e\*(C'\fR is useful if you need to do a bit of
computation in the process of replacing text.  This example counts
character frequencies in a line:
.PP
.Vb 4
\&    $x = "Bill the cat";
\&    $x =~ s/(.)/$chars{$1}++;$1/eg;  # final $1 replaces char with itself
\&    print "frequency of \*(Aq$_\*(Aq is $chars{$_}\en"
\&        foreach (sort {$chars{$b} <=> $chars{$a}} keys %chars);
.Ve
.PP
This prints
.PP
.Vb 9
\&    frequency of \*(Aq \*(Aq is 2
\&    frequency of \*(Aqt\*(Aq is 2
\&    frequency of \*(Aql\*(Aq is 2
\&    frequency of \*(AqB\*(Aq is 1
\&    frequency of \*(Aqc\*(Aq is 1
\&    frequency of \*(Aqe\*(Aq is 1
\&    frequency of \*(Aqh\*(Aq is 1
\&    frequency of \*(Aqi\*(Aq is 1
\&    frequency of \*(Aqa\*(Aq is 1
.Ve
.PP
As with the match \f(CW\*(C`m//\*(C'\fR operator, \f(CW\*(C`s///\*(C'\fR can use other delimiters,
such as \f(CW\*(C`s!!!\*(C'\fR and \f(CW\*(C`s{}{}\*(C'\fR, and even \f(CW\*(C`s{}//\*(C'\fR.  If single quotes are
used \f(CW\*(C`s\*(Aq\*(Aq\*(Aq\*(C'\fR, then the regexp and replacement are
treated as single-quoted strings and there are no
variable substitutions.  \f(CW\*(C`s///\*(C'\fR in list context
returns the same thing as in scalar context, i.e., the number of
matches.
.PP
\fIThe split function\fR
.IX Subsection "The split function"
.PP
The \f(CW\*(C`split()\*(C'\fR function is another place where a regexp is used.
\&\f(CW\*(C`split /regexp/, string, limit\*(C'\fR separates the \f(CW\*(C`string\*(C'\fR operand into
a list of substrings and returns that list.  The regexp must be designed
to match whatever constitutes the separators for the desired substrings.
The \f(CW\*(C`limit\*(C'\fR, if present, constrains splitting into no more than \f(CW\*(C`limit\*(C'\fR
number of strings.  For example, to split a string into words, use
.PP
.Vb 4
\&    $x = "Calvin and Hobbes";
\&    @words = split /\es+/, $x;  # $word[0] = \*(AqCalvin\*(Aq
\&                               # $word[1] = \*(Aqand\*(Aq
\&                               # $word[2] = \*(AqHobbes\*(Aq
.Ve
.PP
If the empty regexp \f(CW\*(C`//\*(C'\fR is used, the regexp always matches and
the string is split into individual characters.  If the regexp has
groupings, then the resulting list contains the matched substrings from the
groupings as well.  For instance,
.PP
.Vb 12
\&    $x = "/usr/bin/perl";
\&    @dirs = split m!/!, $x;  # $dirs[0] = \*(Aq\*(Aq
\&                             # $dirs[1] = \*(Aqusr\*(Aq
\&                             # $dirs[2] = \*(Aqbin\*(Aq
\&                             # $dirs[3] = \*(Aqperl\*(Aq
\&    @parts = split m!(/)!, $x;  # $parts[0] = \*(Aq\*(Aq
\&                                # $parts[1] = \*(Aq/\*(Aq
\&                                # $parts[2] = \*(Aqusr\*(Aq
\&                                # $parts[3] = \*(Aq/\*(Aq
\&                                # $parts[4] = \*(Aqbin\*(Aq
\&                                # $parts[5] = \*(Aq/\*(Aq
\&                                # $parts[6] = \*(Aqperl\*(Aq
.Ve
.PP
Since the first character of \f(CW$x\fR matched the regexp, \f(CW\*(C`split\*(C'\fR prepended
an empty initial element to the list.
.PP
If you have read this far, congratulations! You now have all the basic
tools needed to use regular expressions to solve a wide range of text
processing problems.  If this is your first time through the tutorial,
why not stop here and play around with regexps a while....  Part\ 2
concerns the more esoteric aspects of regular expressions and those
concepts certainly aren't needed right at the start.
.SH "Part 2: Power tools"
.IX Header "Part 2: Power tools"
\&\s-1OK\s0, you know the basics of regexps and you want to know more.  If
matching regular expressions is analogous to a walk in the woods, then
the tools discussed in Part 1 are analogous to topo maps and a
compass, basic tools we use all the time.  Most of the tools in part 2
are analogous to flare guns and satellite phones.  They aren't used
too often on a hike, but when we are stuck, they can be invaluable.
.PP
What follows are the more advanced, less used, or sometimes esoteric
capabilities of Perl regexps.  In Part 2, we will assume you are
comfortable with the basics and concentrate on the advanced features.
.SS "More on characters, strings, and character classes"
.IX Subsection "More on characters, strings, and character classes"
There are a number of escape sequences and character classes that we
haven't covered yet.
.PP
There are several escape sequences that convert characters or strings
between upper and lower case, and they are also available within
patterns.  \f(CW\*(C`\el\*(C'\fR and \f(CW\*(C`\eu\*(C'\fR convert the next character to lower or
upper case, respectively:
.PP
.Vb 4
\&    $x = "perl";
\&    $string =~ /\eu$x/;  # matches \*(AqPerl\*(Aq in $string
\&    $x = "M(rs?|s)\e\e."; # note the double backslash
\&    $string =~ /\el$x/;  # matches \*(Aqmr.\*(Aq, \*(Aqmrs.\*(Aq, and \*(Aqms.\*(Aq,
.Ve
.PP
A \f(CW\*(C`\eL\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR indicates a lasting conversion of case, until
terminated by \f(CW\*(C`\eE\*(C'\fR or thrown over by another \f(CW\*(C`\eU\*(C'\fR or \f(CW\*(C`\eL\*(C'\fR:
.PP
.Vb 4
\&    $x = "This word is in lower case:\eL SHOUT\eE";
\&    $x =~ /shout/;       # matches
\&    $x = "I STILL KEYPUNCH CARDS FOR MY 360"
\&    $x =~ /\eUkeypunch/;  # matches punch card string
.Ve
.PP
If there is no \f(CW\*(C`\eE\*(C'\fR, case is converted until the end of the
string. The regexps \f(CW\*(C`\eL\eu$word\*(C'\fR or \f(CW\*(C`\eu\eL$word\*(C'\fR convert the first
character of \f(CW$word\fR to uppercase and the rest of the characters to
lowercase.
.PP
Control characters can be escaped with \f(CW\*(C`\ec\*(C'\fR, so that a control-Z
character would be matched with \f(CW\*(C`\ecZ\*(C'\fR.  The escape sequence
\&\f(CW\*(C`\eQ\*(C'\fR...\f(CW\*(C`\eE\*(C'\fR quotes, or protects most non-alphabetic characters.   For
instance,
.PP
.Vb 2
\&    $x = "\eQThat !^*&%~& cat!";
\&    $x =~ /\eQ!^*&%~&\eE/;  # check for rough language
.Ve
.PP
It does not protect \f(CW\*(C`$\*(C'\fR or \f(CW\*(C`@\*(C'\fR, so that variables can still be
substituted.
.PP
\&\f(CW\*(C`\eQ\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR and \f(CW\*(C`\eE\*(C'\fR are actually part of
double-quotish syntax, and not part of regexp syntax proper.  They will
work if they appear in a regular expression embedded directly in a
program, but not when contained in a string that is interpolated in a
pattern.
.PP
With the advent of 5.6.0, Perl regexps can handle more than just the
standard \s-1ASCII\s0 character set.  Perl now supports \fIUnicode\fR, a standard
for representing the alphabets from virtually all of the world's written
languages, and a host of symbols.  Perl's text strings are Unicode strings, so
they can contain characters with a value (codepoint or character number) higher
than 255.
.PP
What does this mean for regexps? Well, regexp users don't need to know
much about Perl's internal representation of strings.  But they do need
to know 1) how to represent Unicode characters in a regexp and 2) that
a matching operation will treat the string to be searched as a sequence
of characters, not bytes.  The answer to 1) is that Unicode characters
greater than \f(CW\*(C`chr(255)\*(C'\fR are represented using the \f(CW\*(C`\ex{hex}\*(C'\fR notation, because
\&\ex hex (without curly braces) doesn't go further than 255.  (Starting in Perl
5.14, if you're an octal fan, you can also use \f(CW\*(C`\eo{oct}\*(C'\fR.)
.PP
.Vb 1
\&    /\ex{263a}/;  # match a Unicode smiley face :)
.Ve
.PP
\&\fB\s-1NOTE\s0\fR: In Perl 5.6.0 it used to be that one needed to say \f(CW\*(C`use
utf8\*(C'\fR to use any Unicode features.  This is no more the case: for
almost all Unicode processing, the explicit \f(CW\*(C`utf8\*(C'\fR pragma is not
needed.  (The only case where it matters is if your Perl script is in
Unicode and encoded in \s-1UTF\-8\s0, then an explicit \f(CW\*(C`use utf8\*(C'\fR is needed.)
.PP
Figuring out the hexadecimal sequence of a Unicode character you want
or deciphering someone else's hexadecimal Unicode regexp is about as
much fun as programming in machine code.  So another way to specify
Unicode characters is to use the \fInamed character\fR escape
sequence \f(CW\*(C`\eN{\f(CIname\f(CW}\*(C'\fR.  \fIname\fR is a name for the Unicode character, as
specified in the Unicode standard.  For instance, if we wanted to
represent or match the astrological sign for the planet Mercury, we
could use
.PP
.Vb 2
\&    $x = "abc\eN{MERCURY}def";
\&    $x =~ /\eN{MERCURY}/;   # matches
.Ve
.PP
One can also use \*(L"short\*(R" names:
.PP
.Vb 2
\&    print "\eN{GREEK SMALL LETTER SIGMA} is called sigma.\en";
\&    print "\eN{greek:Sigma} is an upper\-case sigma.\en";
.Ve
.PP
You can also restrict names to a certain alphabet by specifying the
charnames pragma:
.PP
.Vb 2
\&    use charnames qw(greek);
\&    print "\eN{sigma} is Greek sigma\en";
.Ve
.PP
An index of character names is available on-line from the Unicode
Consortium, <http://www.unicode.org/charts/charindex.html>; explanatory
material with links to other resources at
<http://www.unicode.org/standard/where>.
.PP
The answer to requirement 2) is, as of 5.6.0, that a regexp (mostly)
uses Unicode characters.  (The \*(L"mostly\*(R" is for messy backward
compatibility reasons, but starting in Perl 5.14, any regex compiled in
the scope of a \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR (which is automatically
turned on within the scope of a \f(CW\*(C`use 5.012\*(C'\fR or higher) will turn that
\&\*(L"mostly\*(R" into \*(L"always\*(R".  If you want to handle Unicode properly, you
should ensure that \f(CW\*(Aqunicode_strings\*(Aq\fR is turned on.)
Internally, this is encoded to bytes using either \s-1UTF\-8\s0 or a native 8
bit encoding, depending on the history of the string, but conceptually
it is a sequence of characters, not bytes. See perlunitut for a
tutorial about that.
.PP
Let us now discuss Unicode character classes.  Just as with Unicode
characters, there are named Unicode character classes represented by the
\&\f(CW\*(C`\ep{name}\*(C'\fR escape sequence.  Closely associated is the \f(CW\*(C`\eP{name}\*(C'\fR
character class, which is the negation of the \f(CW\*(C`\ep{name}\*(C'\fR class.  For
example, to match lower and uppercase characters,
.PP
.Vb 5
\&    $x = "BOB";
\&    $x =~ /^\ep{IsUpper}/;   # matches, uppercase char class
\&    $x =~ /^\eP{IsUpper}/;   # doesn\*(Aqt match, char class sans uppercase
\&    $x =~ /^\ep{IsLower}/;   # doesn\*(Aqt match, lowercase char class
\&    $x =~ /^\eP{IsLower}/;   # matches, char class sans lowercase
.Ve
.PP
(The \*(L"Is\*(R" is optional.)
.PP
Here is the association between some Perl named classes and the
traditional Unicode classes:
.PP
.Vb 1
\&    Perl class name  Unicode class name or regular expression
\&
\&    IsAlpha          /^[LM]/
\&    IsAlnum          /^[LMN]/
\&    IsASCII          $code <= 127
\&    IsCntrl          /^C/
\&    IsBlank          $code =~ /^(0020|0009)$/ || /^Z[^lp]/
\&    IsDigit          Nd
\&    IsGraph          /^([LMNPS]|Co)/
\&    IsLower          Ll
\&    IsPrint          /^([LMNPS]|Co|Zs)/
\&    IsPunct          /^P/
\&    IsSpace          /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/
\&    IsSpacePerl      /^Z/ || ($code =~ /^(0009|000A|000C|000D|0085|2028|2029)$/
\&    IsUpper          /^L[ut]/
\&    IsWord           /^[LMN]/ || $code eq "005F"
\&    IsXDigit         $code =~ /^00(3[0\-9]|[46][1\-6])$/
.Ve
.PP
You can also use the official Unicode class names with \f(CW\*(C`\ep\*(C'\fR and
\&\f(CW\*(C`\eP\*(C'\fR, like \f(CW\*(C`\ep{L}\*(C'\fR for Unicode 'letters', \f(CW\*(C`\ep{Lu}\*(C'\fR for uppercase
letters, or \f(CW\*(C`\eP{Nd}\*(C'\fR for non-digits.  If a \f(CW\*(C`name\*(C'\fR is just one
letter, the braces can be dropped.  For instance, \f(CW\*(C`\epM\*(C'\fR is the
character class of Unicode 'marks', for example accent marks.
For the full list see perlunicode.
.PP
Unicode has also been separated into various sets of characters
which you can test with \f(CW\*(C`\ep{...}\*(C'\fR (in) and \f(CW\*(C`\eP{...}\*(C'\fR (not in).
To test whether a character is (or is not) an element of a script
you would use the script name, for example \f(CW\*(C`\ep{Latin}\*(C'\fR, \f(CW\*(C`\ep{Greek}\*(C'\fR,
or \f(CW\*(C`\eP{Katakana}\*(C'\fR.
.PP
What we have described so far is the single form of the \f(CW\*(C`\ep{...}\*(C'\fR character
classes.  There is also a compound form which you may run into.  These
look like \f(CW\*(C`\ep{name=value}\*(C'\fR or \f(CW\*(C`\ep{name:value}\*(C'\fR (the equals sign and colon
can be used interchangeably).  These are more general than the single form,
and in fact most of the single forms are just Perl-defined shortcuts for common
compound forms.  For example, the script examples in the previous paragraph
could be written equivalently as \f(CW\*(C`\ep{Script=Latin}\*(C'\fR, \f(CW\*(C`\ep{Script:Greek}\*(C'\fR, and
\&\f(CW\*(C`\eP{script=katakana}\*(C'\fR (case is irrelevant between the \f(CW\*(C`{}\*(C'\fR braces).  You may
never have to use the compound forms, but sometimes it is necessary, and their
use can make your code easier to understand.
.PP
\&\f(CW\*(C`\eX\*(C'\fR is an abbreviation for a character class that comprises
a Unicode \fIextended grapheme cluster\fR.  This represents a \*(L"logical character\*(R":
what appears to be a single character, but may be represented internally by more
than one.  As an example, using the Unicode full names, e.g., \f(CW\*(C`A\ +\ COMBINING\ RING\*(C'\fR is a grapheme cluster with base character \f(CW\*(C`A\*(C'\fR and combining character
\&\f(CW\*(C`COMBINING\ RING\*(C'\fR, which translates in Danish to A with the circle atop it,
as in the word Angstrom.
.PP
For the full and latest information about Unicode see the latest
Unicode standard, or the Unicode Consortium's website <http://www.unicode.org>
.PP
As if all those classes weren't enough, Perl also defines POSIX-style
character classes.  These have the form \f(CW\*(C`[:name:]\*(C'\fR, with \f(CW\*(C`name\*(C'\fR the
name of the \s-1POSIX\s0 class.  The \s-1POSIX\s0 classes are \f(CW\*(C`alpha\*(C'\fR, \f(CW\*(C`alnum\*(C'\fR,
\&\f(CW\*(C`ascii\*(C'\fR, \f(CW\*(C`cntrl\*(C'\fR, \f(CW\*(C`digit\*(C'\fR, \f(CW\*(C`graph\*(C'\fR, \f(CW\*(C`lower\*(C'\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`punct\*(C'\fR,
\&\f(CW\*(C`space\*(C'\fR, \f(CW\*(C`upper\*(C'\fR, and \f(CW\*(C`xdigit\*(C'\fR, and two extensions, \f(CW\*(C`word\*(C'\fR (a Perl
extension to match \f(CW\*(C`\ew\*(C'\fR), and \f(CW\*(C`blank\*(C'\fR (a \s-1GNU\s0 extension).  The \f(CW\*(C`//a\*(C'\fR
modifier restricts these to matching just in the \s-1ASCII\s0 range; otherwise
they can match the same as their corresponding Perl Unicode classes:
\&\f(CW\*(C`[:upper:]\*(C'\fR is the same as \f(CW\*(C`\ep{IsUpper}\*(C'\fR, etc.  (There are some
exceptions and gotchas with this; see perlrecharclass for a full
discussion.) The \f(CW\*(C`[:digit:]\*(C'\fR, \f(CW\*(C`[:word:]\*(C'\fR, and
\&\f(CW\*(C`[:space:]\*(C'\fR correspond to the familiar \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, and \f(CW\*(C`\es\*(C'\fR
character classes.  To negate a \s-1POSIX\s0 class, put a \f(CW\*(C`^\*(C'\fR in front of
the name, so that, e.g., \f(CW\*(C`[:^digit:]\*(C'\fR corresponds to \f(CW\*(C`\eD\*(C'\fR and, under
Unicode, \f(CW\*(C`\eP{IsDigit}\*(C'\fR.  The Unicode and \s-1POSIX\s0 character classes can
be used just like \f(CW\*(C`\ed\*(C'\fR, with the exception that \s-1POSIX\s0 character
classes can only be used inside of a character class:
.PP
.Vb 6
\&    /\es+[abc[:digit:]xyz]\es*/;  # match a,b,c,x,y,z, or a digit
\&    /^=item\es[[:digit:]]/;      # match \*(Aq=item\*(Aq,
\&                                # followed by a space and a digit
\&    /\es+[abc\ep{IsDigit}xyz]\es+/;  # match a,b,c,x,y,z, or a digit
\&    /^=item\es\ep{IsDigit}/;        # match \*(Aq=item\*(Aq,
\&                                  # followed by a space and a digit
.Ve
.PP
Whew! That is all the rest of the characters and character classes.
.SS "Compiling and saving regular expressions"
.IX Subsection "Compiling and saving regular expressions"
In Part 1 we mentioned that Perl compiles a regexp into a compact
sequence of opcodes.  Thus, a compiled regexp is a data structure
that can be stored once and used again and again.  The regexp quote
\&\f(CW\*(C`qr//\*(C'\fR does exactly that: \f(CW\*(C`qr/string/\*(C'\fR compiles the \f(CW\*(C`string\*(C'\fR as a
regexp and transforms the result into a form that can be assigned to a
variable:
.PP
.Vb 1
\&    $reg = qr/foo+bar?/;  # reg contains a compiled regexp
.Ve
.PP
Then \f(CW$reg\fR can be used as a regexp:
.PP
.Vb 3
\&    $x = "fooooba";
\&    $x =~ $reg;     # matches, just like /foo+bar?/
\&    $x =~ /$reg/;   # same thing, alternate form
.Ve
.PP
\&\f(CW$reg\fR can also be interpolated into a larger regexp:
.PP
.Vb 1
\&    $x =~ /(abc)?$reg/;  # still matches
.Ve
.PP
As with the matching operator, the regexp quote can use different
delimiters, e.g., \f(CW\*(C`qr!!\*(C'\fR, \f(CW\*(C`qr{}\*(C'\fR or \f(CW\*(C`qr~~\*(C'\fR.  Apostrophes
as delimiters (\f(CW\*(C`qr\*(Aq\*(Aq\*(C'\fR) inhibit any interpolation.
.PP
Pre-compiled regexps are useful for creating dynamic matches that
don't need to be recompiled each time they are encountered.  Using
pre-compiled regexps, we write a \f(CW\*(C`grep_step\*(C'\fR program which greps
for a sequence of patterns, advancing to the next pattern as soon
as one has been satisfied.
.PP
.Vb 4
\&    % cat > grep_step
\&    #!/usr/bin/perl
\&    # grep_step \- match <number> regexps, one after the other
\&    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...
\&
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
\&    @compiled = map qr/$_/, @regexp;
\&    while ($line = <>) {
\&        if ($line =~ /$compiled[0]/) {
\&            print $line;
\&            shift @compiled;
\&            last unless @compiled;
\&        }
\&    }
\&    ^D
\&
\&    % grep_step 3 shift print last grep_step
\&    $number = shift;
\&            print $line;
\&            last unless @compiled;
.Ve
.PP
Storing pre-compiled regexps in an array \f(CW@compiled\fR allows us to
simply loop through the regexps without any recompilation, thus gaining
flexibility without sacrificing speed.
.SS "Composing regular expressions at runtime"
.IX Subsection "Composing regular expressions at runtime"
Backtracking is more efficient than repeated tries with different regular
expressions.  If there are several regular expressions and a match with
any of them is acceptable, then it is possible to combine them into a set
of alternatives.  If the individual expressions are input data, this
can be done by programming a join operation.  We'll exploit this idea in
an improved version of the \f(CW\*(C`simple_grep\*(C'\fR program: a program that matches
multiple patterns:
.PP
.Vb 4
\&    % cat > multi_grep
\&    #!/usr/bin/perl
\&    # multi_grep \- match any of <number> regexps
\&    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...
\&
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
\&    $pattern = join \*(Aq|\*(Aq, @regexp;
\&
\&    while ($line = <>) {
\&        print $line if $line =~ /$pattern/;
\&    }
\&    ^D
\&
\&    % multi_grep 2 shift for multi_grep
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
.Ve
.PP
Sometimes it is advantageous to construct a pattern from the \fIinput\fR
that is to be analyzed and use the permissible values on the left
hand side of the matching operations.  As an example for this somewhat
paradoxical situation, let's assume that our input contains a command
verb which should match one out of a set of available command verbs,
with the additional twist that commands may be abbreviated as long as
the given string is unique. The program below demonstrates the basic
algorithm.
.PP
.Vb 10
\&    % cat > keymatch
\&    #!/usr/bin/perl
\&    $kwds = \*(Aqcopy compare list print\*(Aq;
\&    while( $command = <> ){
\&        $command =~ s/^\es+|\es+$//g;  # trim leading and trailing spaces
\&        if( ( @matches = $kwds =~ /\eb$command\ew*/g ) == 1 ){
\&            print "command: \*(Aq@matches\*(Aq\en";
\&        } elsif( @matches == 0 ){
\&            print "no such command: \*(Aq$command\*(Aq\en";
\&        } else {
\&            print "not unique: \*(Aq$command\*(Aq (could be one of: @matches)\en";
\&        }
\&    }
\&    ^D
\&
\&    % keymatch
\&    li
\&    command: \*(Aqlist\*(Aq
\&    co
\&    not unique: \*(Aqco\*(Aq (could be one of: copy compare)
\&    printer
\&    no such command: \*(Aqprinter\*(Aq
.Ve
.PP
Rather than trying to match the input against the keywords, we match the
combined set of keywords against the input.  The pattern matching
operation \f(CW\*(C`$kwds\ =~\ /\eb($command\ew*)/g\*(C'\fR does several things at the
same time. It makes sure that the given command begins where a keyword
begins (\f(CW\*(C`\eb\*(C'\fR). It tolerates abbreviations due to the added \f(CW\*(C`\ew*\*(C'\fR. It
tells us the number of matches (\f(CW\*(C`scalar @matches\*(C'\fR) and all the keywords
that were actually matched.  You could hardly ask for more.
.SS "Embedding comments and modifiers in a regular expression"
.IX Subsection "Embedding comments and modifiers in a regular expression"
Starting with this section, we will be discussing Perl's set of
\&\fIextended patterns\fR.  These are extensions to the traditional regular
expression syntax that provide powerful new tools for pattern
matching.  We have already seen extensions in the form of the minimal
matching constructs \f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{n,m}?\*(C'\fR, and \f(CW\*(C`{n,}?\*(C'\fR.  Most
of the extensions below have the form \f(CW\*(C`(?char...)\*(C'\fR, where the
\&\f(CW\*(C`char\*(C'\fR is a character that determines the type of extension.
.PP
The first extension is an embedded comment \f(CW\*(C`(?#text)\*(C'\fR.  This embeds a
comment into the regular expression without affecting its meaning.  The
comment should not have any closing parentheses in the text.  An
example is
.PP
.Vb 1
\&    /(?# Match an integer:)[+\-]?\ed+/;
.Ve
.PP
This style of commenting has been largely superseded by the raw,
freeform commenting that is allowed with the \f(CW\*(C`//x\*(C'\fR modifier.
.PP
Most modifiers, such as \f(CW\*(C`//i\*(C'\fR, \f(CW\*(C`//m\*(C'\fR, \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//x\*(C'\fR (or any
combination thereof) can also be embedded in
a regexp using \f(CW\*(C`(?i)\*(C'\fR, \f(CW\*(C`(?m)\*(C'\fR, \f(CW\*(C`(?s)\*(C'\fR, and \f(CW\*(C`(?x)\*(C'\fR.  For instance,
.PP
.Vb 7
\&    /(?i)yes/;  # match \*(Aqyes\*(Aq case insensitively
\&    /yes/i;     # same thing
\&    /(?x)(          # freeform version of an integer regexp
\&             [+\-]?  # match an optional sign
\&             \ed+    # match a sequence of digits
\&         )
\&    /x;
.Ve
.PP
Embedded modifiers can have two important advantages over the usual
modifiers.  Embedded modifiers allow a custom set of modifiers to
\&\fIeach\fR regexp pattern.  This is great for matching an array of regexps
that must have different modifiers:
.PP
.Vb 8
\&    $pattern[0] = \*(Aq(?i)doctor\*(Aq;
\&    $pattern[1] = \*(AqJohnson\*(Aq;
\&    ...
\&    while (<>) {
\&        foreach $patt (@pattern) {
\&            print if /$patt/;
\&        }
\&    }
.Ve
.PP
The second advantage is that embedded modifiers (except \f(CW\*(C`//p\*(C'\fR, which
modifies the entire regexp) only affect the regexp
inside the group the embedded modifier is contained in.  So grouping
can be used to localize the modifier's effects:
.PP
.Vb 1
\&    /Answer: ((?i)yes)/;  # matches \*(AqAnswer: yes\*(Aq, \*(AqAnswer: YES\*(Aq, etc.
.Ve
.PP
Embedded modifiers can also turn off any modifiers already present
by using, e.g., \f(CW\*(C`(?\-i)\*(C'\fR.  Modifiers can also be combined into
a single expression, e.g., \f(CW\*(C`(?s\-i)\*(C'\fR turns on single line mode and
turns off case insensitivity.
.PP
Embedded modifiers may also be added to a non-capturing grouping.
\&\f(CW\*(C`(?i\-m:regexp)\*(C'\fR is a non-capturing grouping that matches \f(CW\*(C`regexp\*(C'\fR
case insensitively and turns off multi-line mode.
.SS "Looking ahead and looking behind"
.IX Subsection "Looking ahead and looking behind"
This section concerns the lookahead and lookbehind assertions.  First,
a little background.
.PP
In Perl regular expressions, most regexp elements 'eat up' a certain
amount of string when they match.  For instance, the regexp element
\&\f(CW\*(C`[abc}]\*(C'\fR eats up one character of the string when it matches, in the
sense that Perl moves to the next character position in the string
after the match.  There are some elements, however, that don't eat up
characters (advance the character position) if they match.  The examples
we have seen so far are the anchors.  The anchor \f(CW\*(C`^\*(C'\fR matches the
beginning of the line, but doesn't eat any characters.  Similarly, the
word boundary anchor \f(CW\*(C`\eb\*(C'\fR matches wherever a character matching \f(CW\*(C`\ew\*(C'\fR
is next to a character that doesn't, but it doesn't eat up any
characters itself.  Anchors are examples of \fIzero-width assertions\fR:
zero-width, because they consume
no characters, and assertions, because they test some property of the
string.  In the context of our walk in the woods analogy to regexp
matching, most regexp elements move us along a trail, but anchors have
us stop a moment and check our surroundings.  If the local environment
checks out, we can proceed forward.  But if the local environment
doesn't satisfy us, we must backtrack.
.PP
Checking the environment entails either looking ahead on the trail,
looking behind, or both.  \f(CW\*(C`^\*(C'\fR looks behind, to see that there are no
characters before.  \f(CW\*(C`$\*(C'\fR looks ahead, to see that there are no
characters after.  \f(CW\*(C`\eb\*(C'\fR looks both ahead and behind, to see if the
characters on either side differ in their \*(L"word-ness\*(R".
.PP
The lookahead and lookbehind assertions are generalizations of the
anchor concept.  Lookahead and lookbehind are zero-width assertions
that let us specify which characters we want to test for.  The
lookahead assertion is denoted by \f(CW\*(C`(?=regexp)\*(C'\fR and the lookbehind
assertion is denoted by \f(CW\*(C`(?<=fixed\-regexp)\*(C'\fR.  Some examples are
.PP
.Vb 8
\&    $x = "I catch the housecat \*(AqTom\-cat\*(Aq with catnip";
\&    $x =~ /cat(?=\es)/;   # matches \*(Aqcat\*(Aq in \*(Aqhousecat\*(Aq
\&    @catwords = ($x =~ /(?<=\es)cat\ew+/g);  # matches,
\&                                           # $catwords[0] = \*(Aqcatch\*(Aq
\&                                           # $catwords[1] = \*(Aqcatnip\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq in \*(AqTom\-cat\*(Aq
\&    $x =~ /(?<=\es)cat(?=\es)/; # doesn\*(Aqt match; no isolated \*(Aqcat\*(Aq in
\&                              # middle of $x
.Ve
.PP
Note that the parentheses in \f(CW\*(C`(?=regexp)\*(C'\fR and \f(CW\*(C`(?<=regexp)\*(C'\fR are
non-capturing, since these are zero-width assertions.  Thus in the
second regexp, the substrings captured are those of the whole regexp
itself.  Lookahead \f(CW\*(C`(?=regexp)\*(C'\fR can match arbitrary regexps, but
lookbehind \f(CW\*(C`(?<=fixed\-regexp)\*(C'\fR only works for regexps of fixed
width, i.e., a fixed number of characters long.  Thus
\&\f(CW\*(C`(?<=(ab|bc))\*(C'\fR is fine, but \f(CW\*(C`(?<=(ab)*)\*(C'\fR is not.  The
negated versions of the lookahead and lookbehind assertions are
denoted by \f(CW\*(C`(?!regexp)\*(C'\fR and \f(CW\*(C`(?<!fixed\-regexp)\*(C'\fR respectively.
They evaluate true if the regexps do \fInot\fR match:
.PP
.Vb 4
\&    $x = "foobar";
\&    $x =~ /foo(?!bar)/;  # doesn\*(Aqt match, \*(Aqbar\*(Aq follows \*(Aqfoo\*(Aq
\&    $x =~ /foo(?!baz)/;  # matches, \*(Aqbaz\*(Aq doesn\*(Aqt follow \*(Aqfoo\*(Aq
\&    $x =~ /(?<!\es)foo/;  # matches, there is no \es before \*(Aqfoo\*(Aq
.Ve
.PP
The \f(CW\*(C`\eC\*(C'\fR is unsupported in lookbehind, because the already
treacherous definition of \f(CW\*(C`\eC\*(C'\fR would become even more so
when going backwards.
.PP
Here is an example where a string containing blank-separated words,
numbers and single dashes is to be split into its components.
Using \f(CW\*(C`/\es+/\*(C'\fR alone won't work, because spaces are not required between
dashes, or a word or a dash. Additional places for a split are established
by looking ahead and behind:
.PP
.Vb 5
\&    $str = "one two \- \-\-6\-8";
\&    @toks = split / \es+              # a run of spaces
\&                  | (?<=\eS) (?=\-)    # any non\-space followed by \*(Aq\-\*(Aq
\&                  | (?<=\-)  (?=\eS)   # a \*(Aq\-\*(Aq followed by any non\-space
\&                  /x, $str;          # @toks = qw(one two \- \- \- 6 \- 8)
.Ve
.SS "Using independent subexpressions to prevent backtracking"
.IX Subsection "Using independent subexpressions to prevent backtracking"
\&\fIIndependent subexpressions\fR are regular expressions, in the
context of a larger regular expression, that function independently of
the larger regular expression.  That is, they consume as much or as
little of the string as they wish without regard for the ability of
the larger regexp to match.  Independent subexpressions are represented
by \f(CW\*(C`(?>regexp)\*(C'\fR.  We can illustrate their behavior by first
considering an ordinary regexp:
.PP
.Vb 2
\&    $x = "ab";
\&    $x =~ /a*ab/;  # matches
.Ve
.PP
This obviously matches, but in the process of matching, the
subexpression \f(CW\*(C`a*\*(C'\fR first grabbed the \f(CW\*(C`a\*(C'\fR.  Doing so, however,
wouldn't allow the whole regexp to match, so after backtracking, \f(CW\*(C`a*\*(C'\fR
eventually gave back the \f(CW\*(C`a\*(C'\fR and matched the empty string.  Here, what
\&\f(CW\*(C`a*\*(C'\fR matched was \fIdependent\fR on what the rest of the regexp matched.
.PP
Contrast that with an independent subexpression:
.PP
.Vb 1
\&    $x =~ /(?>a*)ab/;  # doesn\*(Aqt match!
.Ve
.PP
The independent subexpression \f(CW\*(C`(?>a*)\*(C'\fR doesn't care about the rest
of the regexp, so it sees an \f(CW\*(C`a\*(C'\fR and grabs it.  Then the rest of the
regexp \f(CW\*(C`ab\*(C'\fR cannot match.  Because \f(CW\*(C`(?>a*)\*(C'\fR is independent, there
is no backtracking and the independent subexpression does not give
up its \f(CW\*(C`a\*(C'\fR.  Thus the match of the regexp as a whole fails.  A similar
behavior occurs with completely independent regexps:
.PP
.Vb 3
\&    $x = "ab";
\&    $x =~ /a*/g;   # matches, eats an \*(Aqa\*(Aq
\&    $x =~ /\eGab/g; # doesn\*(Aqt match, no \*(Aqa\*(Aq available
.Ve
.PP
Here \f(CW\*(C`//g\*(C'\fR and \f(CW\*(C`\eG\*(C'\fR create a 'tag team' handoff of the string from
one regexp to the other.  Regexps with an independent subexpression are
much like this, with a handoff of the string to the independent
subexpression, and a handoff of the string back to the enclosing
regexp.
.PP
The ability of an independent subexpression to prevent backtracking
can be quite useful.  Suppose we want to match a non-empty string
enclosed in parentheses up to two levels deep.  Then the following
regexp matches:
.PP
.Vb 2
\&    $x = "abc(de(fg)h";  # unbalanced parentheses
\&    $x =~ /\e( ( [^()]+ | \e([^()]*\e) )+ \e)/x;
.Ve
.PP
The regexp matches an open parenthesis, one or more copies of an
alternation, and a close parenthesis.  The alternation is two-way, with
the first alternative \f(CW\*(C`[^()]+\*(C'\fR matching a substring with no
parentheses and the second alternative \f(CW\*(C`\e([^()]*\e)\*(C'\fR  matching a
substring delimited by parentheses.  The problem with this regexp is
that it is pathological: it has nested indeterminate quantifiers
of the form \f(CW\*(C`(a+|b)+\*(C'\fR.  We discussed in Part 1 how nested quantifiers
like this could take an exponentially long time to execute if there
was no match possible.  To prevent the exponential blowup, we need to
prevent useless backtracking at some point.  This can be done by
enclosing the inner quantifier as an independent subexpression:
.PP
.Vb 1
\&    $x =~ /\e( ( (?>[^()]+) | \e([^()]*\e) )+ \e)/x;
.Ve
.PP
Here, \f(CW\*(C`(?>[^()]+)\*(C'\fR breaks the degeneracy of string partitioning
by gobbling up as much of the string as possible and keeping it.   Then
match failures fail much more quickly.
.SS "Conditional expressions"
.IX Subsection "Conditional expressions"
A \fIconditional expression\fR is a form of if-then-else statement
that allows one to choose which patterns are to be matched, based on
some condition.  There are two types of conditional expression:
\&\f(CW\*(C`(?(condition)yes\-regexp)\*(C'\fR and
\&\f(CW\*(C`(?(condition)yes\-regexp|no\-regexp)\*(C'\fR.  \f(CW\*(C`(?(condition)yes\-regexp)\*(C'\fR is
like an \f(CW\*(Aqif\ ()\ {}\*(Aq\fR statement in Perl.  If the \f(CW\*(C`condition\*(C'\fR is true,
the \f(CW\*(C`yes\-regexp\*(C'\fR will be matched.  If the \f(CW\*(C`condition\*(C'\fR is false, the
\&\f(CW\*(C`yes\-regexp\*(C'\fR will be skipped and Perl will move onto the next regexp
element.  The second form is like an \f(CW\*(Aqif\ ()\ {}\ else\ {}\*(Aq\fR statement
in Perl.  If the \f(CW\*(C`condition\*(C'\fR is true, the \f(CW\*(C`yes\-regexp\*(C'\fR will be
matched, otherwise the \f(CW\*(C`no\-regexp\*(C'\fR will be matched.
.PP
The \f(CW\*(C`condition\*(C'\fR can have several forms.  The first form is simply an
integer in parentheses \f(CW\*(C`(integer)\*(C'\fR.  It is true if the corresponding
backreference \f(CW\*(C`\einteger\*(C'\fR matched earlier in the regexp.  The same
thing can be done with a name associated with a capture group, written
as \f(CW\*(C`(<name>)\*(C'\fR or \f(CW\*(C`(\*(Aqname\*(Aq)\*(C'\fR.  The second form is a bare
zero-width assertion \f(CW\*(C`(?...)\*(C'\fR, either a lookahead, a lookbehind, or a
code assertion (discussed in the next section).  The third set of forms
provides tests that return true if the expression is executed within
a recursion (\f(CW\*(C`(R)\*(C'\fR) or is being called from some capturing group,
referenced either by number (\f(CW\*(C`(R1)\*(C'\fR, \f(CW\*(C`(R2)\*(C'\fR,...) or by name
(\f(CW\*(C`(R&name)\*(C'\fR).
.PP
The integer or name form of the \f(CW\*(C`condition\*(C'\fR allows us to choose,
with more flexibility, what to match based on what matched earlier in the
regexp. This searches for words of the form \f(CW"$x$x"\fR or \f(CW"$x$y$y$x"\fR:
.PP
.Vb 9
\&    % simple_grep \*(Aq^(\ew+)(\ew+)?(?(2)\eg2\eg1|\eg1)$\*(Aq /usr/dict/words
\&    beriberi
\&    coco
\&    couscous
\&    deed
\&    ...
\&    toot
\&    toto
\&    tutu
.Ve
.PP
The lookbehind \f(CW\*(C`condition\*(C'\fR allows, along with backreferences,
an earlier part of the match to influence a later part of the
match.  For instance,
.PP
.Vb 1
\&    /[ATGC]+(?(?<=AA)G|C)$/;
.Ve
.PP
matches a \s-1DNA\s0 sequence such that it either ends in \f(CW\*(C`AAG\*(C'\fR, or some
other base pair combination and \f(CW\*(C`C\*(C'\fR.  Note that the form is
\&\f(CW\*(C`(?(?<=AA)G|C)\*(C'\fR and not \f(CW\*(C`(?((?<=AA))G|C)\*(C'\fR; for the
lookahead, lookbehind or code assertions, the parentheses around the
conditional are not needed.
.SS "Defining named patterns"
.IX Subsection "Defining named patterns"
Some regular expressions use identical subpatterns in several places.
Starting with Perl 5.10, it is possible to define named subpatterns in
a section of the pattern so that they can be called up by name
anywhere in the pattern.  This syntactic pattern for this definition
group is \f(CW\*(C`(?(DEFINE)(?<name>pattern)...)\*(C'\fR.  An insertion
of a named pattern is written as \f(CW\*(C`(?&name)\*(C'\fR.
.PP
The example below illustrates this feature using the pattern for
floating point numbers that was presented earlier on.  The three
subpatterns that are used more than once are the optional sign, the
digit sequence for an integer and the decimal fraction.  The \s-1DEFINE\s0
group at the end of the pattern contains their definition.  Notice
that the decimal fraction pattern is the first place where we can
reuse the integer pattern.
.PP
.Vb 8
\&   /^ (?&osg)\e * ( (?&int)(?&dec)? | (?&dec) )
\&      (?: [eE](?&osg)(?&int) )?
\&    $
\&    (?(DEFINE)
\&      (?<osg>[\-+]?)         # optional sign
\&      (?<int>\ed++)          # integer
\&      (?<dec>\e.(?&int))     # decimal fraction
\&    )/x
.Ve
.SS "Recursive patterns"
.IX Subsection "Recursive patterns"
This feature (introduced in Perl 5.10) significantly extends the
power of Perl's pattern matching.  By referring to some other
capture group anywhere in the pattern with the construct
\&\f(CW\*(C`(?group\-ref)\*(C'\fR, the \fIpattern\fR within the referenced group is used
as an independent subpattern in place of the group reference itself.
Because the group reference may be contained \fIwithin\fR the group it
refers to, it is now possible to apply pattern matching to tasks that
hitherto required a recursive parser.
.PP
To illustrate this feature, we'll design a pattern that matches if
a string contains a palindrome. (This is a word or a sentence that,
while ignoring spaces, interpunctuation and case, reads the same backwards
as forwards. We begin by observing that the empty string or a string
containing just one word character is a palindrome. Otherwise it must
have a word character up front and the same at its end, with another
palindrome in between.
.PP
.Vb 1
\&    /(?: (\ew) (?...Here be a palindrome...) \eg{\-1} | \ew? )/x
.Ve
.PP
Adding \f(CW\*(C`\eW*\*(C'\fR at either end to eliminate what is to be ignored, we already
have the full pattern:
.PP
.Vb 4
\&    my $pp = qr/^(\eW* (?: (\ew) (?1) \eg{\-1} | \ew? ) \eW*)$/ix;
\&    for $s ( "saippuakauppias", "A man, a plan, a canal: Panama!" ){
\&        print "\*(Aq$s\*(Aq is a palindrome\en" if $s =~ /$pp/;
\&    }
.Ve
.PP
In \f(CW\*(C`(?...)\*(C'\fR both absolute and relative backreferences may be used.
The entire pattern can be reinserted with \f(CW\*(C`(?R)\*(C'\fR or \f(CW\*(C`(?0)\*(C'\fR.
If you prefer to name your groups, you can use \f(CW\*(C`(?&name)\*(C'\fR to
recurse into that group.
.SS "A bit of magic: executing Perl code in a regular expression"
.IX Subsection "A bit of magic: executing Perl code in a regular expression"
Normally, regexps are a part of Perl expressions.
\&\fICode evaluation\fR expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp.  A code evaluation
expression is denoted \f(CW\*(C`(?{code})\*(C'\fR, with \fIcode\fR a string of Perl
statements.
.PP
Be warned that this feature is considered experimental, and may be
changed without notice.
.PP
Code expressions are zero-width assertions, and the value they return
depends on their environment.  There are two possibilities: either the
code expression is used as a conditional in a conditional expression
\&\f(CW\*(C`(?(condition)...)\*(C'\fR, or it is not.  If the code expression is a
conditional, the code is evaluated and the result (i.e., the result of
the last statement) is used to determine truth or falsehood.  If the
code expression is not used as a conditional, the assertion always
evaluates true and the result is put into the special variable
\&\f(CW$^R\fR.  The variable \f(CW$^R\fR can then be used in code expressions later
in the regexp.  Here are some silly examples:
.PP
.Vb 5
\&    $x = "abcdef";
\&    $x =~ /abc(?{print "Hi Mom!";})def/; # matches,
\&                                         # prints \*(AqHi Mom!\*(Aq
\&    $x =~ /aaa(?{print "Hi Mom!";})def/; # doesn\*(Aqt match,
\&                                         # no \*(AqHi Mom!\*(Aq
.Ve
.PP
Pay careful attention to the next example:
.PP
.Vb 3
\&    $x =~ /abc(?{print "Hi Mom!";})ddd/; # doesn\*(Aqt match,
\&                                         # no \*(AqHi Mom!\*(Aq
\&                                         # but why not?
.Ve
.PP
At first glance, you'd think that it shouldn't print, because obviously
the \f(CW\*(C`ddd\*(C'\fR isn't going to match the target string. But look at this
example:
.PP
.Vb 2
\&    $x =~ /abc(?{print "Hi Mom!";})[dD]dd/; # doesn\*(Aqt match,
\&                                            # but _does_ print
.Ve
.PP
Hmm. What happened here? If you've been following along, you know that
the above pattern should be effectively (almost) the same as the last one;
enclosing the \f(CW\*(C`d\*(C'\fR in a character class isn't going to change what it
matches. So why does the first not print while the second one does?
.PP
The answer lies in the optimizations the regex engine makes. In the first
case, all the engine sees are plain old characters (aside from the
\&\f(CW\*(C`?{}\*(C'\fR construct). It's smart enough to realize that the string 'ddd'
doesn't occur in our target string before actually running the pattern
through. But in the second case, we've tricked it into thinking that our
pattern is more complicated. It takes a look, sees our
character class, and decides that it will have to actually run the
pattern to determine whether or not it matches, and in the process of
running it hits the print statement before it discovers that we don't
have a match.
.PP
To take a closer look at how the engine does optimizations, see the
section \*(L"Pragmas and debugging\*(R" below.
.PP
More fun with \f(CW\*(C`?{}\*(C'\fR:
.PP
.Vb 6
\&    $x =~ /(?{print "Hi Mom!";})/;       # matches,
\&                                         # prints \*(AqHi Mom!\*(Aq
\&    $x =~ /(?{$c = 1;})(?{print "$c";})/;  # matches,
\&                                           # prints \*(Aq1\*(Aq
\&    $x =~ /(?{$c = 1;})(?{print "$^R";})/; # matches,
\&                                           # prints \*(Aq1\*(Aq
.Ve
.PP
The bit of magic mentioned in the section title occurs when the regexp
backtracks in the process of searching for a match.  If the regexp
backtracks over a code expression and if the variables used within are
localized using \f(CW\*(C`local\*(C'\fR, the changes in the variables produced by the
code expression are undone! Thus, if we wanted to count how many times
a character got matched inside a group, we could use, e.g.,
.PP
.Vb 11
\&    $x = "aaaa";
\&    $count = 0;  # initialize \*(Aqa\*(Aq count
\&    $c = "bob";  # test if $c gets clobbered
\&    $x =~ /(?{local $c = 0;})         # initialize count
\&           ( a                        # match \*(Aqa\*(Aq
\&             (?{local $c = $c + 1;})  # increment count
\&           )*                         # do this any number of times,
\&           aa                         # but match \*(Aqaa\*(Aq at the end
\&           (?{$count = $c;})          # copy local $c var into $count
\&          /x;
\&    print "\*(Aqa\*(Aq count is $count, \e$c variable is \*(Aq$c\*(Aq\en";
.Ve
.PP
This prints
.PP
.Vb 1
\&    \*(Aqa\*(Aq count is 2, $c variable is \*(Aqbob\*(Aq
.Ve
.PP
If we replace the \f(CW\*(C`\ (?{local\ $c\ =\ $c\ +\ 1;})\*(C'\fR with
\&\f(CW\*(C`\ (?{$c\ =\ $c\ +\ 1;})\*(C'\fR, the variable changes are \fInot\fR undone
during backtracking, and we get
.PP
.Vb 1
\&    \*(Aqa\*(Aq count is 4, $c variable is \*(Aqbob\*(Aq
.Ve
.PP
Note that only localized variable changes are undone.  Other side
effects of code expression execution are permanent.  Thus
.PP
.Vb 2
\&    $x = "aaaa";
\&    $x =~ /(a(?{print "Yow\en";}))*aa/;
.Ve
.PP
produces
.PP
.Vb 4
\&   Yow
\&   Yow
\&   Yow
\&   Yow
.Ve
.PP
The result \f(CW$^R\fR is automatically localized, so that it will behave
properly in the presence of backtracking.
.PP
This example uses a code expression in a conditional to match a
definite article, either 'the' in English or 'der|die|das' in German:
.PP
.Vb 11
\&    $lang = \*(AqDE\*(Aq;  # use German
\&    ...
\&    $text = "das";
\&    print "matched\en"
\&        if $text =~ /(?(?{
\&                          $lang eq \*(AqEN\*(Aq; # is the language English?
\&                         })
\&                       the |             # if so, then match \*(Aqthe\*(Aq
\&                       (der|die|das)     # else, match \*(Aqder|die|das\*(Aq
\&                     )
\&                    /xi;
.Ve
.PP
Note that the syntax here is \f(CW\*(C`(?(?{...})yes\-regexp|no\-regexp)\*(C'\fR, not
\&\f(CW\*(C`(?((?{...}))yes\-regexp|no\-regexp)\*(C'\fR.  In other words, in the case of a
code expression, we don't need the extra parentheses around the
conditional.
.PP
If you try to use code expressions with interpolating variables, Perl
may surprise you:
.PP
.Vb 5
\&    $bar = 5;
\&    $pat = \*(Aq(?{ 1 })\*(Aq;
\&    /foo(?{ $bar })bar/; # compiles ok, $bar not interpolated
\&    /foo(?{ 1 })$bar/;   # compile error!
\&    /foo${pat}bar/;      # compile error!
\&
\&    $pat = qr/(?{ $foo = 1 })/;  # precompile code regexp
\&    /foo${pat}bar/;      # compiles ok
.Ve
.PP
If a regexp has (1) code expressions and interpolating variables, or
(2) a variable that interpolates a code expression, Perl treats the
regexp as an error. If the code expression is precompiled into a
variable, however, interpolating is ok. The question is, why is this
an error?
.PP
The reason is that variable interpolation and code expressions
together pose a security risk.  The combination is dangerous because
many programmers who write search engines often take user input and
plug it directly into a regexp:
.PP
.Vb 3
\&    $regexp = <>;       # read user\-supplied regexp
\&    $chomp $regexp;     # get rid of possible newline
\&    $text =~ /$regexp/; # search $text for the $regexp
.Ve
.PP
If the \f(CW$regexp\fR variable contains a code expression, the user could
then execute arbitrary Perl code.  For instance, some joker could
search for \f(CW\*(C`system(\*(Aqrm\ \-rf\ *\*(Aq);\*(C'\fR to erase your files.  In this
sense, the combination of interpolation and code expressions \fItaints\fR
your regexp.  So by default, using both interpolation and code
expressions in the same regexp is not allowed.  If you're not
concerned about malicious users, it is possible to bypass this
security check by invoking \f(CW\*(C`use\ re\ \*(Aqeval\*(Aq\*(C'\fR:
.PP
.Vb 5
\&    use re \*(Aqeval\*(Aq;       # throw caution out the door
\&    $bar = 5;
\&    $pat = \*(Aq(?{ 1 })\*(Aq;
\&    /foo(?{ 1 })$bar/;   # compiles ok
\&    /foo${pat}bar/;      # compiles ok
.Ve
.PP
Another form of code expression is the \fIpattern code expression\fR.
The pattern code expression is like a regular code expression, except
that the result of the code evaluation is treated as a regular
expression and matched immediately.  A simple example is
.PP
.Vb 4
\&    $length = 5;
\&    $char = \*(Aqa\*(Aq;
\&    $x = \*(Aqaaaaabb\*(Aq;
\&    $x =~ /(??{$char x $length})/x; # matches, there are 5 of \*(Aqa\*(Aq
.Ve
.PP
This final example contains both ordinary and pattern code
expressions.  It detects whether a binary string \f(CW1101010010001...\fR has a
Fibonacci spacing 0,1,1,2,3,5,...  of the \f(CW1\fR's:
.PP
.Vb 12
\&    $x = "1101010010001000001";
\&    $z0 = \*(Aq\*(Aq; $z1 = \*(Aq0\*(Aq;   # initial conditions
\&    print "It is a Fibonacci sequence\en"
\&        if $x =~ /^1         # match an initial \*(Aq1\*(Aq
\&                    (?:
\&                       ((??{ $z0 })) # match some \*(Aq0\*(Aq
\&                       1             # and then a \*(Aq1\*(Aq
\&                       (?{ $z0 = $z1; $z1 .= $^N; })
\&                    )+   # repeat as needed
\&                  $      # that is all there is
\&                 /x;
\&    printf "Largest sequence matched was %d\en", length($z1)\-length($z0);
.Ve
.PP
Remember that \f(CW$^N\fR is set to whatever was matched by the last
completed capture group. This prints
.PP
.Vb 2
\&    It is a Fibonacci sequence
\&    Largest sequence matched was 5
.Ve
.PP
Ha! Try that with your garden variety regexp package...
.PP
Note that the variables \f(CW$z0\fR and \f(CW$z1\fR are not substituted when the
regexp is compiled, as happens for ordinary variables outside a code
expression.  Rather, the code expressions are evaluated when Perl
encounters them during the search for a match.
.PP
The regexp without the \f(CW\*(C`//x\*(C'\fR modifier is
.PP
.Vb 1
\&    /^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N; }))+$/
.Ve
.PP
which shows that spaces are still possible in the code parts. Nevertheless,
when working with code and conditional expressions, the extended form of
regexps is almost necessary in creating and debugging regexps.
.SS "Backtracking control verbs"
.IX Subsection "Backtracking control verbs"
Perl 5.10 introduced a number of control verbs intended to provide
detailed control over the backtracking process, by directly influencing
the regexp engine and by providing monitoring techniques.  As all
the features in this group are experimental and subject to change or
removal in a future version of Perl, the interested reader is
referred to \*(L"Special Backtracking Control Verbs\*(R" in perlre for a
detailed description.
.PP
Below is just one example, illustrating the control verb \f(CW\*(C`(*FAIL)\*(C'\fR,
which may be abbreviated as \f(CW\*(C`(*F)\*(C'\fR. If this is inserted in a regexp
it will cause it to fail, just as it would at some
mismatch between the pattern and the string. Processing
of the regexp continues as it would after any \*(L"normal\*(R"
failure, so that, for instance, the next position in the string or another
alternative will be tried. As failing to match doesn't preserve capture
groups or produce results, it may be necessary to use this in
combination with embedded code.
.PP
.Vb 4
\&   %count = ();
\&   "supercalifragilisticexpialidocious" =~
\&       /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
\&   printf "%3d \*(Aq%s\*(Aq\en", $count{$_}, $_ for (sort keys %count);
.Ve
.PP
The pattern begins with a class matching a subset of letters.  Whenever
this matches, a statement like \f(CW\*(C`$count{\*(Aqa\*(Aq}++;\*(C'\fR is executed, incrementing
the letter's counter. Then \f(CW\*(C`(*FAIL)\*(C'\fR does what it says, and
the regexp engine proceeds according to the book: as long as the end of
the string hasn't been reached, the position is advanced before looking
for another vowel. Thus, match or no match makes no difference, and the
regexp engine proceeds until the entire string has been inspected.
(It's remarkable that an alternative solution using something like
.PP
.Vb 2
\&   $count{lc($_)}++ for split(\*(Aq\*(Aq, "supercalifragilisticexpialidocious");
\&   printf "%3d \*(Aq%s\*(Aq\en", $count2{$_}, $_ for ( qw{ a e i o u } );
.Ve
.PP
is considerably slower.)
.SS "Pragmas and debugging"
.IX Subsection "Pragmas and debugging"
Speaking of debugging, there are several pragmas available to control
and debug regexps in Perl.  We have already encountered one pragma in
the previous section, \f(CW\*(C`use\ re\ \*(Aqeval\*(Aq;\*(C'\fR, that allows variable
interpolation and code expressions to coexist in a regexp.  The other
pragmas are
.PP
.Vb 3
\&    use re \*(Aqtaint\*(Aq;
\&    $tainted = <>;
\&    @parts = ($tainted =~ /(\ew+)\es+(\ew+)/; # @parts is now tainted
.Ve
.PP
The \f(CW\*(C`taint\*(C'\fR pragma causes any substrings from a match with a tainted
variable to be tainted as well.  This is not normally the case, as
regexps are often used to extract the safe bits from a tainted
variable.  Use \f(CW\*(C`taint\*(C'\fR when you are not extracting safe bits, but are
performing some other processing.  Both \f(CW\*(C`taint\*(C'\fR and \f(CW\*(C`eval\*(C'\fR pragmas
are lexically scoped, which means they are in effect only until
the end of the block enclosing the pragmas.
.PP
.Vb 2
\&    use re \*(Aq/m\*(Aq;  # or any other flags
\&    $multiline_string =~ /^foo/; # /m is implied
.Ve
.PP
The \f(CW\*(C`re \*(Aq/flags\*(Aq\*(C'\fR pragma (introduced in Perl
5.14) turns on the given regular expression flags
until the end of the lexical scope.  See
\&\*(L"'/flags' mode\*(R" in re for more
detail.
.PP
.Vb 2
\&    use re \*(Aqdebug\*(Aq;
\&    /^(.*)$/s;       # output debugging info
\&
\&    use re \*(Aqdebugcolor\*(Aq;
\&    /^(.*)$/s;       # output debugging info in living color
.Ve
.PP
The global \f(CW\*(C`debug\*(C'\fR and \f(CW\*(C`debugcolor\*(C'\fR pragmas allow one to get
detailed debugging info about regexp compilation and
execution.  \f(CW\*(C`debugcolor\*(C'\fR is the same as debug, except the debugging
information is displayed in color on terminals that can display
termcap color sequences.  Here is example output:
.PP
.Vb 10
\&    % perl \-e \*(Aquse re "debug"; "abc" =~ /a*b+c/;\*(Aq
\&    Compiling REx \*(Aqa*b+c\*(Aq
\&    size 9 first at 1
\&       1: STAR(4)
\&       2:   EXACT <a>(0)
\&       4: PLUS(7)
\&       5:   EXACT <b>(0)
\&       7: EXACT <c>(9)
\&       9: END(0)
\&    floating \*(Aqbc\*(Aq at 0..2147483647 (checking floating) minlen 2
\&    Guessing start of match, REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq...
\&    Found floating substr \*(Aqbc\*(Aq at offset 1...
\&    Guessed: match at offset 0
\&    Matching REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq
\&      Setting an EVAL scope, savestack=3
\&       0 <> <abc>             |  1:  STAR
\&                               EXACT <a> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       1 <a> <bc>             |  4:    PLUS
\&                               EXACT <b> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       2 <ab> <c>             |  7:      EXACT <c>
\&       3 <abc> <>             |  9:      END
\&    Match successful!
\&    Freeing REx: \*(Aqa*b+c\*(Aq
.Ve
.PP
If you have gotten this far into the tutorial, you can probably guess
what the different parts of the debugging output tell you.  The first
part
.PP
.Vb 8
\&    Compiling REx \*(Aqa*b+c\*(Aq
\&    size 9 first at 1
\&       1: STAR(4)
\&       2:   EXACT <a>(0)
\&       4: PLUS(7)
\&       5:   EXACT <b>(0)
\&       7: EXACT <c>(9)
\&       9: END(0)
.Ve
.PP
describes the compilation stage.  \f(CWSTAR(4)\fR means that there is a
starred object, in this case \f(CW\*(Aqa\*(Aq\fR, and if it matches, goto line 4,
i.e., \f(CWPLUS(7)\fR.  The middle lines describe some heuristics and
optimizations performed before a match:
.PP
.Vb 4
\&    floating \*(Aqbc\*(Aq at 0..2147483647 (checking floating) minlen 2
\&    Guessing start of match, REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq...
\&    Found floating substr \*(Aqbc\*(Aq at offset 1...
\&    Guessed: match at offset 0
.Ve
.PP
Then the match is executed and the remaining lines describe the
process:
.PP
.Vb 12
\&    Matching REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq
\&      Setting an EVAL scope, savestack=3
\&       0 <> <abc>             |  1:  STAR
\&                               EXACT <a> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       1 <a> <bc>             |  4:    PLUS
\&                               EXACT <b> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       2 <ab> <c>             |  7:      EXACT <c>
\&       3 <abc> <>             |  9:      END
\&    Match successful!
\&    Freeing REx: \*(Aqa*b+c\*(Aq
.Ve
.PP
Each step is of the form \f(CW\*(C`n\ <x>\ <y>\*(C'\fR, with \f(CW\*(C`<x>\*(C'\fR the
part of the string matched and \f(CW\*(C`<y>\*(C'\fR the part not yet
matched.  The \f(CW\*(C`|\ \ 1:\ \ STAR\*(C'\fR says that Perl is at line number 1
in the compilation list above.  See
\&\*(L"Debugging Regular Expressions\*(R" in perldebguts for much more detail.
.PP
An alternative method of debugging regexps is to embed \f(CW\*(C`print\*(C'\fR
statements within the regexp.  This provides a blow-by-blow account of
the backtracking in an alternation:
.PP
.Vb 12
\&    "that this" =~ m@(?{print "Start at position ", pos, "\en";})
\&                     t(?{print "t1\en";})
\&                     h(?{print "h1\en";})
\&                     i(?{print "i1\en";})
\&                     s(?{print "s1\en";})
\&                         |
\&                     t(?{print "t2\en";})
\&                     h(?{print "h2\en";})
\&                     a(?{print "a2\en";})
\&                     t(?{print "t2\en";})
\&                     (?{print "Done at position ", pos, "\en";})
\&                    @x;
.Ve
.PP
prints
.PP
.Vb 8
\&    Start at position 0
\&    t1
\&    h1
\&    t2
\&    h2
\&    a2
\&    t2
\&    Done at position 4
.Ve
.SH "BUGS"
.IX Header "BUGS"
Code expressions, conditional expressions, and independent expressions
are \fIexperimental\fR.  Don't use them in production code.  Yet.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This is just a tutorial.  For the full story on Perl regular
expressions, see the perlre regular expressions reference page.
.PP
For more information on the matching \f(CW\*(C`m//\*(C'\fR and substitution \f(CW\*(C`s///\*(C'\fR
operators, see \*(L"Regexp Quote-Like Operators\*(R" in perlop.  For
information on the \f(CW\*(C`split\*(C'\fR operation, see \*(L"split\*(R" in perlfunc.
.PP
For an excellent all-around resource on the care and feeding of
regular expressions, see the book \fIMastering Regular Expressions\fR by
Jeffrey Friedl (published by O'Reilly, \s-1ISBN\s0 1556592\-257\-3).
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 2000 Mark Kvale
All rights reserved.
.PP
This document may be distributed under the same terms as Perl itself.
.SS "Acknowledgments"
.IX Subsection "Acknowledgments"
The inspiration for the stop codon \s-1DNA\s0 example came from the \s-1ZIP\s0
code example in chapter 7 of \fIMastering Regular Expressions\fR.
.PP
The author would like to thank Jeff Pinyan, Andrew Johnson, Peter
Haworth, Ronald J Kimball, and Joe Smith for all their helpful
comments.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlretut5.18.1                              0100644 0001750 0001750 00000427372 12566207444 023323  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRETUT 1"
.TH PERLRETUT 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlretut \- Perl regular expressions tutorial
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page provides a basic tutorial on understanding, creating and
using regular expressions in Perl.  It serves as a complement to the
reference page on regular expressions perlre.  Regular expressions
are an integral part of the \f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`qr//\*(C'\fR and \f(CW\*(C`split\*(C'\fR
operators and so this tutorial also overlaps with
\&\*(L"Regexp Quote-Like Operators\*(R" in perlop and \*(L"split\*(R" in perlfunc.
.PP
Perl is widely renowned for excellence in text processing, and regular
expressions are one of the big factors behind this fame.  Perl regular
expressions display an efficiency and flexibility unknown in most
other computer languages.  Mastering even the basics of regular
expressions will allow you to manipulate text with surprising ease.
.PP
What is a regular expression?  A regular expression is simply a string
that describes a pattern.  Patterns are in common use these days;
examples are the patterns typed into a search engine to find web pages
and the patterns used to list files in a directory, e.g., \f(CW\*(C`ls *.txt\*(C'\fR
or \f(CW\*(C`dir *.*\*(C'\fR.  In Perl, the patterns described by regular expressions
are used to search strings, extract desired parts of strings, and to
do search and replace operations.
.PP
Regular expressions have the undeserved reputation of being abstract
and difficult to understand.  Regular expressions are constructed using
simple concepts like conditionals and loops and are no more difficult
to understand than the corresponding \f(CW\*(C`if\*(C'\fR conditionals and \f(CW\*(C`while\*(C'\fR
loops in the Perl language itself.  In fact, the main challenge in
learning regular expressions is just getting used to the terse
notation used to express these concepts.
.PP
This tutorial flattens the learning curve by discussing regular
expression concepts, along with their notation, one at a time and with
many examples.  The first part of the tutorial will progress from the
simplest word searches to the basic regular expression concepts.  If
you master the first part, you will have all the tools needed to solve
about 98% of your needs.  The second part of the tutorial is for those
comfortable with the basics and hungry for more power tools.  It
discusses the more advanced regular expression operators and
introduces the latest cutting-edge innovations.
.PP
A note: to save time, 'regular expression' is often abbreviated as
regexp or regex.  Regexp is a more natural abbreviation than regex, but
is harder to pronounce.  The Perl pod documentation is evenly split on
regexp vs regex; in Perl, there is more than one way to abbreviate it.
We'll use regexp in this tutorial.
.SH "Part 1: The basics"
.IX Header "Part 1: The basics"
.SS "Simple word matching"
.IX Subsection "Simple word matching"
The simplest regexp is simply a word, or more generally, a string of
characters.  A regexp consisting of a word matches any string that
contains that word:
.PP
.Vb 1
\&    "Hello World" =~ /World/;  # matches
.Ve
.PP
What is this Perl statement all about? \f(CW"Hello World"\fR is a simple
double-quoted string.  \f(CW\*(C`World\*(C'\fR is the regular expression and the
\&\f(CW\*(C`//\*(C'\fR enclosing \f(CW\*(C`/World/\*(C'\fR tells Perl to search a string for a match.
The operator \f(CW\*(C`=~\*(C'\fR associates the string with the regexp match and
produces a true value if the regexp matched, or false if the regexp
did not match.  In our case, \f(CW\*(C`World\*(C'\fR matches the second word in
\&\f(CW"Hello World"\fR, so the expression is true.  Expressions like this
are useful in conditionals:
.PP
.Vb 6
\&    if ("Hello World" =~ /World/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It doesn\*(Aqt match\en";
\&    }
.Ve
.PP
There are useful variations on this theme.  The sense of the match can
be reversed by using the \f(CW\*(C`!~\*(C'\fR operator:
.PP
.Vb 6
\&    if ("Hello World" !~ /World/) {
\&        print "It doesn\*(Aqt match\en";
\&    }
\&    else {
\&        print "It matches\en";
\&    }
.Ve
.PP
The literal string in the regexp can be replaced by a variable:
.PP
.Vb 7
\&    $greeting = "World";
\&    if ("Hello World" =~ /$greeting/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It doesn\*(Aqt match\en";
\&    }
.Ve
.PP
If you're matching against the special default variable \f(CW$_\fR, the
\&\f(CW\*(C`$_ =~\*(C'\fR part can be omitted:
.PP
.Vb 7
\&    $_ = "Hello World";
\&    if (/World/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It doesn\*(Aqt match\en";
\&    }
.Ve
.PP
And finally, the \f(CW\*(C`//\*(C'\fR default delimiters for a match can be changed
to arbitrary delimiters by putting an \f(CW\*(Aqm\*(Aq\fR out front:
.PP
.Vb 4
\&    "Hello World" =~ m!World!;   # matches, delimited by \*(Aq!\*(Aq
\&    "Hello World" =~ m{World};   # matches, note the matching \*(Aq{}\*(Aq
\&    "/usr/bin/perl" =~ m"/perl"; # matches after \*(Aq/usr/bin\*(Aq,
\&                                 # \*(Aq/\*(Aq becomes an ordinary char
.Ve
.PP
\&\f(CW\*(C`/World/\*(C'\fR, \f(CW\*(C`m!World!\*(C'\fR, and \f(CW\*(C`m{World}\*(C'\fR all represent the
same thing.  When, e.g., the quote (\f(CW\*(C`"\*(C'\fR) is used as a delimiter, the forward
slash \f(CW\*(Aq/\*(Aq\fR becomes an ordinary character and can be used in this regexp
without trouble.
.PP
Let's consider how different regexps would match \f(CW"Hello World"\fR:
.PP
.Vb 4
\&    "Hello World" =~ /world/;  # doesn\*(Aqt match
\&    "Hello World" =~ /o W/;    # matches
\&    "Hello World" =~ /oW/;     # doesn\*(Aqt match
\&    "Hello World" =~ /World /; # doesn\*(Aqt match
.Ve
.PP
The first regexp \f(CW\*(C`world\*(C'\fR doesn't match because regexps are
case-sensitive.  The second regexp matches because the substring
\&\f(CW\*(Aqo\ W\*(Aq\fR occurs in the string \f(CW"Hello\ World"\fR.  The space
character ' ' is treated like any other character in a regexp and is
needed to match in this case.  The lack of a space character is the
reason the third regexp \f(CW\*(AqoW\*(Aq\fR doesn't match.  The fourth regexp
\&\f(CW\*(AqWorld \*(Aq\fR doesn't match because there is a space at the end of the
regexp, but not at the end of the string.  The lesson here is that
regexps must match a part of the string \fIexactly\fR in order for the
statement to be true.
.PP
If a regexp matches in more than one place in the string, Perl will
always match at the earliest possible point in the string:
.PP
.Vb 2
\&    "Hello World" =~ /o/;       # matches \*(Aqo\*(Aq in \*(AqHello\*(Aq
\&    "That hat is red" =~ /hat/; # matches \*(Aqhat\*(Aq in \*(AqThat\*(Aq
.Ve
.PP
With respect to character matching, there are a few more points you
need to know about.   First of all, not all characters can be used 'as
is' in a match.  Some characters, called \fImetacharacters\fR, are reserved
for use in regexp notation.  The metacharacters are
.PP
.Vb 1
\&    {}[]()^$.|*+?\e
.Ve
.PP
The significance of each of these will be explained
in the rest of the tutorial, but for now, it is important only to know
that a metacharacter can be matched by putting a backslash before it:
.PP
.Vb 5
\&    "2+2=4" =~ /2+2/;    # doesn\*(Aqt match, + is a metacharacter
\&    "2+2=4" =~ /2\e+2/;   # matches, \e+ is treated like an ordinary +
\&    "The interval is [0,1)." =~ /[0,1)./     # is a syntax error!
\&    "The interval is [0,1)." =~ /\e[0,1\e)\e./  # matches
\&    "#!/usr/bin/perl" =~ /#!\e/usr\e/bin\e/perl/;  # matches
.Ve
.PP
In the last regexp, the forward slash \f(CW\*(Aq/\*(Aq\fR is also backslashed,
because it is used to delimit the regexp.  This can lead to \s-1LTS
\&\s0(leaning toothpick syndrome), however, and it is often more readable
to change delimiters.
.PP
.Vb 1
\&    "#!/usr/bin/perl" =~ m!#\e!/usr/bin/perl!;  # easier to read
.Ve
.PP
The backslash character \f(CW\*(Aq\e\*(Aq\fR is a metacharacter itself and needs to
be backslashed:
.PP
.Vb 1
\&    \*(AqC:\eWIN32\*(Aq =~ /C:\e\eWIN/;   # matches
.Ve
.PP
In addition to the metacharacters, there are some \s-1ASCII\s0 characters
which don't have printable character equivalents and are instead
represented by \fIescape sequences\fR.  Common examples are \f(CW\*(C`\et\*(C'\fR for a
tab, \f(CW\*(C`\en\*(C'\fR for a newline, \f(CW\*(C`\er\*(C'\fR for a carriage return and \f(CW\*(C`\ea\*(C'\fR for a
bell (or alert).  If your string is better thought of as a sequence of arbitrary
bytes, the octal escape sequence, e.g., \f(CW\*(C`\e033\*(C'\fR, or hexadecimal escape
sequence, e.g., \f(CW\*(C`\ex1B\*(C'\fR may be a more natural representation for your
bytes.  Here are some examples of escapes:
.PP
.Vb 5
\&    "1000\et2000" =~ m(0\et2)   # matches
\&    "1000\en2000" =~ /0\en20/   # matches
\&    "1000\et2000" =~ /\e000\et2/ # doesn\*(Aqt match, "0" ne "\e000"
\&    "cat"   =~ /\eo{143}\ex61\ex74/ # matches in ASCII, but a weird way
\&                                 # to spell cat
.Ve
.PP
If you've been around Perl a while, all this talk of escape sequences
may seem familiar.  Similar escape sequences are used in double-quoted
strings and in fact the regexps in Perl are mostly treated as
double-quoted strings.  This means that variables can be used in
regexps as well.  Just like double-quoted strings, the values of the
variables in the regexp will be substituted in before the regexp is
evaluated for matching purposes.  So we have:
.PP
.Vb 4
\&    $foo = \*(Aqhouse\*(Aq;
\&    \*(Aqhousecat\*(Aq =~ /$foo/;      # matches
\&    \*(Aqcathouse\*(Aq =~ /cat$foo/;   # matches
\&    \*(Aqhousecat\*(Aq =~ /${foo}cat/; # matches
.Ve
.PP
So far, so good.  With the knowledge above you can already perform
searches with just about any literal string regexp you can dream up.
Here is a \fIvery simple\fR emulation of the Unix grep program:
.PP
.Vb 7
\&    % cat > simple_grep
\&    #!/usr/bin/perl
\&    $regexp = shift;
\&    while (<>) {
\&        print if /$regexp/;
\&    }
\&    ^D
\&
\&    % chmod +x simple_grep
\&
\&    % simple_grep abba /usr/dict/words
\&    Babbage
\&    cabbage
\&    cabbages
\&    sabbath
\&    Sabbathize
\&    Sabbathizes
\&    sabbatical
\&    scabbard
\&    scabbards
.Ve
.PP
This program is easy to understand.  \f(CW\*(C`#!/usr/bin/perl\*(C'\fR is the standard
way to invoke a perl program from the shell.
\&\f(CW\*(C`$regexp\ =\ shift;\*(C'\fR saves the first command line argument as the
regexp to be used, leaving the rest of the command line arguments to
be treated as files.  \f(CW\*(C`while\ (<>)\*(C'\fR loops over all the lines in
all the files.  For each line, \f(CW\*(C`print\ if\ /$regexp/;\*(C'\fR prints the
line if the regexp matches the line.  In this line, both \f(CW\*(C`print\*(C'\fR and
\&\f(CW\*(C`/$regexp/\*(C'\fR use the default variable \f(CW$_\fR implicitly.
.PP
With all of the regexps above, if the regexp matched anywhere in the
string, it was considered a match.  Sometimes, however, we'd like to
specify \fIwhere\fR in the string the regexp should try to match.  To do
this, we would use the \fIanchor\fR metacharacters \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR.  The
anchor \f(CW\*(C`^\*(C'\fR means match at the beginning of the string and the anchor
\&\f(CW\*(C`$\*(C'\fR means match at the end of the string, or before a newline at the
end of the string.  Here is how they are used:
.PP
.Vb 4
\&    "housekeeper" =~ /keeper/;    # matches
\&    "housekeeper" =~ /^keeper/;   # doesn\*(Aqt match
\&    "housekeeper" =~ /keeper$/;   # matches
\&    "housekeeper\en" =~ /keeper$/; # matches
.Ve
.PP
The second regexp doesn't match because \f(CW\*(C`^\*(C'\fR constrains \f(CW\*(C`keeper\*(C'\fR to
match only at the beginning of the string, but \f(CW"housekeeper"\fR has
keeper starting in the middle.  The third regexp does match, since the
\&\f(CW\*(C`$\*(C'\fR constrains \f(CW\*(C`keeper\*(C'\fR to match only at the end of the string.
.PP
When both \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR are used at the same time, the regexp has to
match both the beginning and the end of the string, i.e., the regexp
matches the whole string.  Consider
.PP
.Vb 3
\&    "keeper" =~ /^keep$/;      # doesn\*(Aqt match
\&    "keeper" =~ /^keeper$/;    # matches
\&    ""       =~ /^$/;          # ^$ matches an empty string
.Ve
.PP
The first regexp doesn't match because the string has more to it than
\&\f(CW\*(C`keep\*(C'\fR.  Since the second regexp is exactly the string, it
matches.  Using both \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR in a regexp forces the complete
string to match, so it gives you complete control over which strings
match and which don't.  Suppose you are looking for a fellow named
bert, off in a string by himself:
.PP
.Vb 1
\&    "dogbert" =~ /bert/;   # matches, but not what you want
\&
\&    "dilbert" =~ /^bert/;  # doesn\*(Aqt match, but ..
\&    "bertram" =~ /^bert/;  # matches, so still not good enough
\&
\&    "bertram" =~ /^bert$/; # doesn\*(Aqt match, good
\&    "dilbert" =~ /^bert$/; # doesn\*(Aqt match, good
\&    "bert"    =~ /^bert$/; # matches, perfect
.Ve
.PP
Of course, in the case of a literal string, one could just as easily
use the string comparison \f(CW\*(C`$string\ eq\ \*(Aqbert\*(Aq\*(C'\fR and it would be
more efficient.   The  \f(CW\*(C`^...$\*(C'\fR regexp really becomes useful when we
add in the more powerful regexp tools below.
.SS "Using character classes"
.IX Subsection "Using character classes"
Although one can already do quite a lot with the literal string
regexps above, we've only scratched the surface of regular expression
technology.  In this and subsequent sections we will introduce regexp
concepts (and associated metacharacter notations) that will allow a
regexp to represent not just a single character sequence, but a \fIwhole
class\fR of them.
.PP
One such concept is that of a \fIcharacter class\fR.  A character class
allows a set of possible characters, rather than just a single
character, to match at a particular point in a regexp.  Character
classes are denoted by brackets \f(CW\*(C`[...]\*(C'\fR, with the set of characters
to be possibly matched inside.  Here are some examples:
.PP
.Vb 4
\&    /cat/;       # matches \*(Aqcat\*(Aq
\&    /[bcr]at/;   # matches \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&    /item[0123456789]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    "abc" =~ /[cab]/;    # matches \*(Aqa\*(Aq
.Ve
.PP
In the last statement, even though \f(CW\*(Aqc\*(Aq\fR is the first character in
the class, \f(CW\*(Aqa\*(Aq\fR matches because the first character position in the
string is the earliest point at which the regexp can match.
.PP
.Vb 2
\&    /[yY][eE][sS]/;      # match \*(Aqyes\*(Aq in a case\-insensitive way
\&                         # \*(Aqyes\*(Aq, \*(AqYes\*(Aq, \*(AqYES\*(Aq, etc.
.Ve
.PP
This regexp displays a common task: perform a case-insensitive
match.  Perl provides a way of avoiding all those brackets by simply
appending an \f(CW\*(Aqi\*(Aq\fR to the end of the match.  Then \f(CW\*(C`/[yY][eE][sS]/;\*(C'\fR
can be rewritten as \f(CW\*(C`/yes/i;\*(C'\fR.  The \f(CW\*(Aqi\*(Aq\fR stands for
case-insensitive and is an example of a \fImodifier\fR of the matching
operation.  We will meet other modifiers later in the tutorial.
.PP
We saw in the section above that there were ordinary characters, which
represented themselves, and special characters, which needed a
backslash \f(CW\*(C`\e\*(C'\fR to represent themselves.  The same is true in a
character class, but the sets of ordinary and special characters
inside a character class are different than those outside a character
class.  The special characters for a character class are \f(CW\*(C`\-]\e^$\*(C'\fR (and
the pattern delimiter, whatever it is).
\&\f(CW\*(C`]\*(C'\fR is special because it denotes the end of a character class.  \f(CW\*(C`$\*(C'\fR is
special because it denotes a scalar variable.  \f(CW\*(C`\e\*(C'\fR is special because
it is used in escape sequences, just like above.  Here is how the
special characters \f(CW\*(C`]$\e\*(C'\fR are handled:
.PP
.Vb 5
\&   /[\e]c]def/; # matches \*(Aq]def\*(Aq or \*(Aqcdef\*(Aq
\&   $x = \*(Aqbcr\*(Aq;
\&   /[$x]at/;   # matches \*(Aqbat\*(Aq, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&   /[\e$x]at/;  # matches \*(Aq$at\*(Aq or \*(Aqxat\*(Aq
\&   /[\e\e$x]at/; # matches \*(Aq\eat\*(Aq, \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
.Ve
.PP
The last two are a little tricky.  In \f(CW\*(C`[\e$x]\*(C'\fR, the backslash protects
the dollar sign, so the character class has two members \f(CW\*(C`$\*(C'\fR and \f(CW\*(C`x\*(C'\fR.
In \f(CW\*(C`[\e\e$x]\*(C'\fR, the backslash is protected, so \f(CW$x\fR is treated as a
variable and substituted in double quote fashion.
.PP
The special character \f(CW\*(Aq\-\*(Aq\fR acts as a range operator within character
classes, so that a contiguous set of characters can be written as a
range.  With ranges, the unwieldy \f(CW\*(C`[0123456789]\*(C'\fR and \f(CW\*(C`[abc...xyz]\*(C'\fR
become the svelte \f(CW\*(C`[0\-9]\*(C'\fR and \f(CW\*(C`[a\-z]\*(C'\fR.  Some examples are
.PP
.Vb 6
\&    /item[0\-9]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    /[0\-9bx\-z]aa/;  # matches \*(Aq0aa\*(Aq, ..., \*(Aq9aa\*(Aq,
\&                    # \*(Aqbaa\*(Aq, \*(Aqxaa\*(Aq, \*(Aqyaa\*(Aq, or \*(Aqzaa\*(Aq
\&    /[0\-9a\-fA\-F]/;  # matches a hexadecimal digit
\&    /[0\-9a\-zA\-Z_]/; # matches a "word" character,
\&                    # like those in a Perl variable name
.Ve
.PP
If \f(CW\*(Aq\-\*(Aq\fR is the first or last character in a character class, it is
treated as an ordinary character; \f(CW\*(C`[\-ab]\*(C'\fR, \f(CW\*(C`[ab\-]\*(C'\fR and \f(CW\*(C`[a\e\-b]\*(C'\fR are
all equivalent.
.PP
The special character \f(CW\*(C`^\*(C'\fR in the first position of a character class
denotes a \fInegated character class\fR, which matches any character but
those in the brackets.  Both \f(CW\*(C`[...]\*(C'\fR and \f(CW\*(C`[^...]\*(C'\fR must match a
character, or the match fails.  Then
.PP
.Vb 4
\&    /[^a]at/;  # doesn\*(Aqt match \*(Aqaat\*(Aq or \*(Aqat\*(Aq, but matches
\&               # all other \*(Aqbat\*(Aq, \*(Aqcat, \*(Aq0at\*(Aq, \*(Aq%at\*(Aq, etc.
\&    /[^0\-9]/;  # matches a non\-numeric character
\&    /[a^]at/;  # matches \*(Aqaat\*(Aq or \*(Aq^at\*(Aq; here \*(Aq^\*(Aq is ordinary
.Ve
.PP
Now, even \f(CW\*(C`[0\-9]\*(C'\fR can be a bother to write multiple times, so in the
interest of saving keystrokes and making regexps more readable, Perl
has several abbreviations for common character classes, as shown below.
Since the introduction of Unicode, unless the \f(CW\*(C`//a\*(C'\fR modifier is in
effect, these character classes match more than just a few characters in
the \s-1ASCII\s0 range.
.IP "\(bu" 4
\&\ed matches a digit, not just [0\-9] but also digits from non-roman scripts
.IP "\(bu" 4
\&\es matches a whitespace character, the set [\e \et\er\en\ef] and others
.IP "\(bu" 4
\&\ew matches a word character (alphanumeric or _), not just [0\-9a\-zA\-Z_]
but also digits and characters from non-roman scripts
.IP "\(bu" 4
\&\eD is a negated \ed; it represents any other character than a digit, or [^\ed]
.IP "\(bu" 4
\&\eS is a negated \es; it represents any non-whitespace character [^\es]
.IP "\(bu" 4
\&\eW is a negated \ew; it represents any non-word character [^\ew]
.IP "\(bu" 4
The period '.' matches any character but \*(L"\en\*(R" (unless the modifier \f(CW\*(C`//s\*(C'\fR is
in effect, as explained below).
.IP "\(bu" 4
\&\eN, like the period, matches any character but \*(L"\en\*(R", but it does so
regardless of whether the modifier \f(CW\*(C`//s\*(C'\fR is in effect.
.PP
The \f(CW\*(C`//a\*(C'\fR modifier, available starting in Perl 5.14,  is used to
restrict the matches of \ed, \es, and \ew to just those in the \s-1ASCII\s0 range.
It is useful to keep your program from being needlessly exposed to full
Unicode (and its accompanying security considerations) when all you want
is to process English-like text.  (The \*(L"a\*(R" may be doubled, \f(CW\*(C`//aa\*(C'\fR, to
provide even more restrictions, preventing case-insensitive matching of
\&\s-1ASCII\s0 with non-ASCII characters; otherwise a Unicode \*(L"Kelvin Sign\*(R"
would caselessly match a \*(L"k\*(R" or \*(L"K\*(R".)
.PP
The \f(CW\*(C`\ed\es\ew\eD\eS\eW\*(C'\fR abbreviations can be used both inside and outside
of character classes.  Here are some in use:
.PP
.Vb 7
\&    /\ed\ed:\ed\ed:\ed\ed/; # matches a hh:mm:ss time format
\&    /[\ed\es]/;         # matches any digit or whitespace character
\&    /\ew\eW\ew/;         # matches a word char, followed by a
\&                      # non\-word char, followed by a word char
\&    /..rt/;           # matches any two chars, followed by \*(Aqrt\*(Aq
\&    /end\e./;          # matches \*(Aqend.\*(Aq
\&    /end[.]/;         # same thing, matches \*(Aqend.\*(Aq
.Ve
.PP
Because a period is a metacharacter, it needs to be escaped to match
as an ordinary period. Because, for example, \f(CW\*(C`\ed\*(C'\fR and \f(CW\*(C`\ew\*(C'\fR are sets
of characters, it is incorrect to think of \f(CW\*(C`[^\ed\ew]\*(C'\fR as \f(CW\*(C`[\eD\eW]\*(C'\fR; in
fact \f(CW\*(C`[^\ed\ew]\*(C'\fR is the same as \f(CW\*(C`[^\ew]\*(C'\fR, which is the same as
\&\f(CW\*(C`[\eW]\*(C'\fR. Think DeMorgan's laws.
.PP
An anchor useful in basic regexps is the \fIword anchor\fR
\&\f(CW\*(C`\eb\*(C'\fR.  This matches a boundary between a word character and a non-word
character \f(CW\*(C`\ew\eW\*(C'\fR or \f(CW\*(C`\eW\ew\*(C'\fR:
.PP
.Vb 5
\&    $x = "Housecat catenates house and cat";
\&    $x =~ /cat/;    # matches cat in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat/;  # matches cat in \*(Aqcatenates\*(Aq
\&    $x =~ /cat\eb/;  # matches cat in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq at end of string
.Ve
.PP
Note in the last example, the end of the string is considered a word
boundary.
.PP
You might wonder why \f(CW\*(Aq.\*(Aq\fR matches everything but \f(CW"\en"\fR \- why not
every character? The reason is that often one is matching against
lines and would like to ignore the newline characters.  For instance,
while the string \f(CW"\en"\fR represents one line, we would like to think
of it as empty.  Then
.PP
.Vb 2
\&    ""   =~ /^$/;    # matches
\&    "\en" =~ /^$/;    # matches, $ anchors before "\en"
\&
\&    ""   =~ /./;      # doesn\*(Aqt match; it needs a char
\&    ""   =~ /^.$/;    # doesn\*(Aqt match; it needs a char
\&    "\en" =~ /^.$/;    # doesn\*(Aqt match; it needs a char other than "\en"
\&    "a"  =~ /^.$/;    # matches
\&    "a\en"  =~ /^.$/;  # matches, $ anchors before "\en"
.Ve
.PP
This behavior is convenient, because we usually want to ignore
newlines when we count and match characters in a line.  Sometimes,
however, we want to keep track of newlines.  We might even want \f(CW\*(C`^\*(C'\fR
and \f(CW\*(C`$\*(C'\fR to anchor at the beginning and end of lines within the
string, rather than just the beginning and end of the string.  Perl
allows us to choose between ignoring and paying attention to newlines
by using the \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//m\*(C'\fR modifiers.  \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//m\*(C'\fR stand for
single line and multi-line and they determine whether a string is to
be treated as one continuous string, or as a set of lines.  The two
modifiers affect two aspects of how the regexp is interpreted: 1) how
the \f(CW\*(Aq.\*(Aq\fR character class is defined, and 2) where the anchors \f(CW\*(C`^\*(C'\fR
and \f(CW\*(C`$\*(C'\fR are able to match.  Here are the four possible combinations:
.IP "\(bu" 4
no modifiers (//): Default behavior.  \f(CW\*(Aq.\*(Aq\fR matches any character
except \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR matches only at the beginning of the string and
\&\f(CW\*(C`$\*(C'\fR matches only at the end or before a newline at the end.
.IP "\(bu" 4
s modifier (//s): Treat string as a single long line.  \f(CW\*(Aq.\*(Aq\fR matches
any character, even \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR matches only at the beginning of
the string and \f(CW\*(C`$\*(C'\fR matches only at the end or before a newline at the
end.
.IP "\(bu" 4
m modifier (//m): Treat string as a set of multiple lines.  \f(CW\*(Aq.\*(Aq\fR
matches any character except \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR are able to match
at the start or end of \fIany\fR line within the string.
.IP "\(bu" 4
both s and m modifiers (//sm): Treat string as a single long line, but
detect multiple lines.  \f(CW\*(Aq.\*(Aq\fR matches any character, even
\&\f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR, however, are able to match at the start or end
of \fIany\fR line within the string.
.PP
Here are examples of \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//m\*(C'\fR in action:
.PP
.Vb 1
\&    $x = "There once was a girl\enWho programmed in Perl\en";
\&
\&    $x =~ /^Who/;   # doesn\*(Aqt match, "Who" not at start of string
\&    $x =~ /^Who/s;  # doesn\*(Aqt match, "Who" not at start of string
\&    $x =~ /^Who/m;  # matches, "Who" at start of second line
\&    $x =~ /^Who/sm; # matches, "Who" at start of second line
\&
\&    $x =~ /girl.Who/;   # doesn\*(Aqt match, "." doesn\*(Aqt match "\en"
\&    $x =~ /girl.Who/s;  # matches, "." matches "\en"
\&    $x =~ /girl.Who/m;  # doesn\*(Aqt match, "." doesn\*(Aqt match "\en"
\&    $x =~ /girl.Who/sm; # matches, "." matches "\en"
.Ve
.PP
Most of the time, the default behavior is what is wanted, but \f(CW\*(C`//s\*(C'\fR and
\&\f(CW\*(C`//m\*(C'\fR are occasionally very useful.  If \f(CW\*(C`//m\*(C'\fR is being used, the start
of the string can still be matched with \f(CW\*(C`\eA\*(C'\fR and the end of the string
can still be matched with the anchors \f(CW\*(C`\eZ\*(C'\fR (matches both the end and
the newline before, like \f(CW\*(C`$\*(C'\fR), and \f(CW\*(C`\ez\*(C'\fR (matches only the end):
.PP
.Vb 2
\&    $x =~ /^Who/m;   # matches, "Who" at start of second line
\&    $x =~ /\eAWho/m;  # doesn\*(Aqt match, "Who" is not at start of string
\&
\&    $x =~ /girl$/m;  # matches, "girl" at end of first line
\&    $x =~ /girl\eZ/m; # doesn\*(Aqt match, "girl" is not at end of string
\&
\&    $x =~ /Perl\eZ/m; # matches, "Perl" is at newline before end
\&    $x =~ /Perl\ez/m; # doesn\*(Aqt match, "Perl" is not at end of string
.Ve
.PP
We now know how to create choices among classes of characters in a
regexp.  What about choices among words or character strings? Such
choices are described in the next section.
.SS "Matching this or that"
.IX Subsection "Matching this or that"
Sometimes we would like our regexp to be able to match different
possible words or character strings.  This is accomplished by using
the \fIalternation\fR metacharacter \f(CW\*(C`|\*(C'\fR.  To match \f(CW\*(C`dog\*(C'\fR or \f(CW\*(C`cat\*(C'\fR, we
form the regexp \f(CW\*(C`dog|cat\*(C'\fR.  As before, Perl will try to match the
regexp at the earliest possible point in the string.  At each
character position, Perl will first try to match the first
alternative, \f(CW\*(C`dog\*(C'\fR.  If \f(CW\*(C`dog\*(C'\fR doesn't match, Perl will then try the
next alternative, \f(CW\*(C`cat\*(C'\fR.  If \f(CW\*(C`cat\*(C'\fR doesn't match either, then the
match fails and Perl moves to the next position in the string.  Some
examples:
.PP
.Vb 2
\&    "cats and dogs" =~ /cat|dog|bird/;  # matches "cat"
\&    "cats and dogs" =~ /dog|cat|bird/;  # matches "cat"
.Ve
.PP
Even though \f(CW\*(C`dog\*(C'\fR is the first alternative in the second regexp,
\&\f(CW\*(C`cat\*(C'\fR is able to match earlier in the string.
.PP
.Vb 2
\&    "cats"          =~ /c|ca|cat|cats/; # matches "c"
\&    "cats"          =~ /cats|cat|ca|c/; # matches "cats"
.Ve
.PP
Here, all the alternatives match at the first string position, so the
first alternative is the one that matches.  If some of the
alternatives are truncations of the others, put the longest ones first
to give them a chance to match.
.PP
.Vb 2
\&    "cab" =~ /a|b|c/ # matches "c"
\&                     # /a|b|c/ == /[abc]/
.Ve
.PP
The last example points out that character classes are like
alternations of characters.  At a given character position, the first
alternative that allows the regexp match to succeed will be the one
that matches.
.SS "Grouping things and hierarchical matching"
.IX Subsection "Grouping things and hierarchical matching"
Alternation allows a regexp to choose among alternatives, but by
itself it is unsatisfying.  The reason is that each alternative is a whole
regexp, but sometime we want alternatives for just part of a
regexp.  For instance, suppose we want to search for housecats or
housekeepers.  The regexp \f(CW\*(C`housecat|housekeeper\*(C'\fR fits the bill, but is
inefficient because we had to type \f(CW\*(C`house\*(C'\fR twice.  It would be nice to
have parts of the regexp be constant, like \f(CW\*(C`house\*(C'\fR, and some
parts have alternatives, like \f(CW\*(C`cat|keeper\*(C'\fR.
.PP
The \fIgrouping\fR metacharacters \f(CW\*(C`()\*(C'\fR solve this problem.  Grouping
allows parts of a regexp to be treated as a single unit.  Parts of a
regexp are grouped by enclosing them in parentheses.  Thus we could solve
the \f(CW\*(C`housecat|housekeeper\*(C'\fR by forming the regexp as
\&\f(CW\*(C`house(cat|keeper)\*(C'\fR.  The regexp \f(CW\*(C`house(cat|keeper)\*(C'\fR means match
\&\f(CW\*(C`house\*(C'\fR followed by either \f(CW\*(C`cat\*(C'\fR or \f(CW\*(C`keeper\*(C'\fR.  Some more examples
are
.PP
.Vb 4
\&    /(a|b)b/;    # matches \*(Aqab\*(Aq or \*(Aqbb\*(Aq
\&    /(ac|b)b/;   # matches \*(Aqacb\*(Aq or \*(Aqbb\*(Aq
\&    /(^a|b)c/;   # matches \*(Aqac\*(Aq at start of string or \*(Aqbc\*(Aq anywhere
\&    /(a|[bc])d/; # matches \*(Aqad\*(Aq, \*(Aqbd\*(Aq, or \*(Aqcd\*(Aq
\&
\&    /house(cat|)/;  # matches either \*(Aqhousecat\*(Aq or \*(Aqhouse\*(Aq
\&    /house(cat(s|)|)/;  # matches either \*(Aqhousecats\*(Aq or \*(Aqhousecat\*(Aq or
\&                        # \*(Aqhouse\*(Aq.  Note groups can be nested.
\&
\&    /(19|20|)\ed\ed/;  # match years 19xx, 20xx, or the Y2K problem, xx
\&    "20" =~ /(19|20|)\ed\ed/;  # matches the null alternative \*(Aq()\ed\ed\*(Aq,
\&                             # because \*(Aq20\ed\ed\*(Aq can\*(Aqt match
.Ve
.PP
Alternations behave the same way in groups as out of them: at a given
string position, the leftmost alternative that allows the regexp to
match is taken.  So in the last example at the first string position,
\&\f(CW"20"\fR matches the second alternative, but there is nothing left over
to match the next two digits \f(CW\*(C`\ed\ed\*(C'\fR.  So Perl moves on to the next
alternative, which is the null alternative and that works, since
\&\f(CW"20"\fR is two digits.
.PP
The process of trying one alternative, seeing if it matches, and
moving on to the next alternative, while going back in the string
from where the previous alternative was tried, if it doesn't, is called
\&\fIbacktracking\fR.  The term 'backtracking' comes from the idea that
matching a regexp is like a walk in the woods.  Successfully matching
a regexp is like arriving at a destination.  There are many possible
trailheads, one for each string position, and each one is tried in
order, left to right.  From each trailhead there may be many paths,
some of which get you there, and some which are dead ends.  When you
walk along a trail and hit a dead end, you have to backtrack along the
trail to an earlier point to try another trail.  If you hit your
destination, you stop immediately and forget about trying all the
other trails.  You are persistent, and only if you have tried all the
trails from all the trailheads and not arrived at your destination, do
you declare failure.  To be concrete, here is a step-by-step analysis
of what Perl does when it tries to match the regexp
.PP
.Vb 1
\&    "abcde" =~ /(abd|abc)(df|d|de)/;
.Ve
.IP "0" 4
Start with the first letter in the string 'a'.
.IP "1" 4
.IX Item "1"
Try the first alternative in the first group 'abd'.
.IP "2" 4
.IX Item "2"
Match 'a' followed by 'b'. So far so good.
.IP "3" 4
.IX Item "3"
\&'d' in the regexp doesn't match 'c' in the string \- a dead
end.  So backtrack two characters and pick the second alternative in
the first group 'abc'.
.IP "4" 4
.IX Item "4"
Match 'a' followed by 'b' followed by 'c'.  We are on a roll
and have satisfied the first group. Set \f(CW$1\fR to 'abc'.
.IP "5" 4
.IX Item "5"
Move on to the second group and pick the first alternative
\&'df'.
.IP "6" 4
.IX Item "6"
Match the 'd'.
.IP "7" 4
.IX Item "7"
\&'f' in the regexp doesn't match 'e' in the string, so a dead
end.  Backtrack one character and pick the second alternative in the
second group 'd'.
.IP "8" 4
.IX Item "8"
\&'d' matches. The second grouping is satisfied, so set \f(CW$2\fR to
\&'d'.
.IP "9" 4
.IX Item "9"
We are at the end of the regexp, so we are done! We have
matched 'abcd' out of the string \*(L"abcde\*(R".
.PP
There are a couple of things to note about this analysis.  First, the
third alternative in the second group 'de' also allows a match, but we
stopped before we got to it \- at a given character position, leftmost
wins.  Second, we were able to get a match at the first character
position of the string 'a'.  If there were no matches at the first
position, Perl would move to the second character position 'b' and
attempt the match all over again.  Only when all possible paths at all
possible character positions have been exhausted does Perl give
up and declare \f(CW\*(C`$string\ =~\ /(abd|abc)(df|d|de)/;\*(C'\fR to be false.
.PP
Even with all this work, regexp matching happens remarkably fast.  To
speed things up, Perl compiles the regexp into a compact sequence of
opcodes that can often fit inside a processor cache.  When the code is
executed, these opcodes can then run at full throttle and search very
quickly.
.SS "Extracting matches"
.IX Subsection "Extracting matches"
The grouping metacharacters \f(CW\*(C`()\*(C'\fR also serve another completely
different function: they allow the extraction of the parts of a string
that matched.  This is very useful to find out what matched and for
text processing in general.  For each grouping, the part that matched
inside goes into the special variables \f(CW$1\fR, \f(CW$2\fR, etc.  They can be
used just as ordinary variables:
.PP
.Vb 6
\&    # extract hours, minutes, seconds
\&    if ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/) {    # match hh:mm:ss format
\&        $hours = $1;
\&        $minutes = $2;
\&        $seconds = $3;
\&    }
.Ve
.PP
Now, we know that in scalar context,
\&\f(CW\*(C`$time\ =~\ /(\ed\ed):(\ed\ed):(\ed\ed)/\*(C'\fR returns a true or false
value.  In list context, however, it returns the list of matched values
\&\f(CW\*(C`($1,$2,$3)\*(C'\fR.  So we could write the code more compactly as
.PP
.Vb 2
\&    # extract hours, minutes, seconds
\&    ($hours, $minutes, $second) = ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/);
.Ve
.PP
If the groupings in a regexp are nested, \f(CW$1\fR gets the group with the
leftmost opening parenthesis, \f(CW$2\fR the next opening parenthesis,
etc.  Here is a regexp with nested groups:
.PP
.Vb 2
\&    /(ab(cd|ef)((gi)|j))/;
\&     1  2      34
.Ve
.PP
If this regexp matches, \f(CW$1\fR contains a string starting with
\&\f(CW\*(Aqab\*(Aq\fR, \f(CW$2\fR is either set to \f(CW\*(Aqcd\*(Aq\fR or \f(CW\*(Aqef\*(Aq\fR, \f(CW$3\fR equals either
\&\f(CW\*(Aqgi\*(Aq\fR or \f(CW\*(Aqj\*(Aq\fR, and \f(CW$4\fR is either set to \f(CW\*(Aqgi\*(Aq\fR, just like \f(CW$3\fR,
or it remains undefined.
.PP
For convenience, Perl sets \f(CW$+\fR to the string held by the highest numbered
\&\f(CW$1\fR, \f(CW$2\fR,... that got assigned (and, somewhat related, \f(CW$^N\fR to the
value of the \f(CW$1\fR, \f(CW$2\fR,... most-recently assigned; i.e. the \f(CW$1\fR,
\&\f(CW$2\fR,... associated with the rightmost closing parenthesis used in the
match).
.SS "Backreferences"
.IX Subsection "Backreferences"
Closely associated with the matching variables \f(CW$1\fR, \f(CW$2\fR, ... are
the \fIbackreferences\fR \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR,...  Backreferences are simply
matching variables that can be used \fIinside\fR a regexp.  This is a
really nice feature; what matches later in a regexp is made to depend on
what matched earlier in the regexp.  Suppose we wanted to look
for doubled words in a text, like 'the the'.  The following regexp finds
all 3\-letter doubles with a space in between:
.PP
.Vb 1
\&    /\eb(\ew\ew\ew)\es\eg1\eb/;
.Ve
.PP
The grouping assigns a value to \eg1, so that the same 3\-letter sequence
is used for both parts.
.PP
A similar task is to find words consisting of two identical parts:
.PP
.Vb 7
\&    % simple_grep \*(Aq^(\ew\ew\ew\ew|\ew\ew\ew|\ew\ew|\ew)\eg1$\*(Aq /usr/dict/words
\&    beriberi
\&    booboo
\&    coco
\&    mama
\&    murmur
\&    papa
.Ve
.PP
The regexp has a single grouping which considers 4\-letter
combinations, then 3\-letter combinations, etc., and uses \f(CW\*(C`\eg1\*(C'\fR to look for
a repeat.  Although \f(CW$1\fR and \f(CW\*(C`\eg1\*(C'\fR represent the same thing, care should be
taken to use matched variables \f(CW$1\fR, \f(CW$2\fR,... only \fIoutside\fR a regexp
and backreferences \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR,... only \fIinside\fR a regexp; not doing
so may lead to surprising and unsatisfactory results.
.SS "Relative backreferences"
.IX Subsection "Relative backreferences"
Counting the opening parentheses to get the correct number for a
backreference is error-prone as soon as there is more than one
capturing group.  A more convenient technique became available
with Perl 5.10: relative backreferences. To refer to the immediately
preceding capture group one now may write \f(CW\*(C`\eg{\-1}\*(C'\fR, the next but
last is available via \f(CW\*(C`\eg{\-2}\*(C'\fR, and so on.
.PP
Another good reason in addition to readability and maintainability
for using relative backreferences is illustrated by the following example,
where a simple pattern for matching peculiar strings is used:
.PP
.Vb 1
\&    $a99a = \*(Aq([a\-z])(\ed)\eg2\eg1\*(Aq;   # matches a11a, g22g, x33x, etc.
.Ve
.PP
Now that we have this pattern stored as a handy string, we might feel
tempted to use it as a part of some other pattern:
.PP
.Vb 6
\&    $line = "code=e99e";
\&    if ($line =~ /^(\ew+)=$a99a$/){   # unexpected behavior!
\&        print "$1 is valid\en";
\&    } else {
\&        print "bad line: \*(Aq$line\*(Aq\en";
\&    }
.Ve
.PP
But this doesn't match, at least not the way one might expect. Only
after inserting the interpolated \f(CW$a99a\fR and looking at the resulting
full text of the regexp is it obvious that the backreferences have
backfired. The subexpression \f(CW\*(C`(\ew+)\*(C'\fR has snatched number 1 and
demoted the groups in \f(CW$a99a\fR by one rank. This can be avoided by
using relative backreferences:
.PP
.Vb 1
\&    $a99a = \*(Aq([a\-z])(\ed)\eg{\-1}\eg{\-2}\*(Aq;  # safe for being interpolated
.Ve
.SS "Named backreferences"
.IX Subsection "Named backreferences"
Perl 5.10 also introduced named capture groups and named backreferences.
To attach a name to a capturing group, you write either
\&\f(CW\*(C`(?<name>...)\*(C'\fR or \f(CW\*(C`(?\*(Aqname\*(Aq...)\*(C'\fR.  The backreference may
then be written as \f(CW\*(C`\eg{name}\*(C'\fR.  It is permissible to attach the
same name to more than one group, but then only the leftmost one of the
eponymous set can be referenced.  Outside of the pattern a named
capture group is accessible through the \f(CW\*(C`%+\*(C'\fR hash.
.PP
Assuming that we have to match calendar dates which may be given in one
of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write
three suitable patterns where we use 'd', 'm' and 'y' respectively as the
names of the groups capturing the pertaining components of a date. The
matching operation combines the three patterns as alternatives:
.PP
.Vb 8
\&    $fmt1 = \*(Aq(?<y>\ed\ed\ed\ed)\-(?<m>\ed\ed)\-(?<d>\ed\ed)\*(Aq;
\&    $fmt2 = \*(Aq(?<m>\ed\ed)/(?<d>\ed\ed)/(?<y>\ed\ed\ed\ed)\*(Aq;
\&    $fmt3 = \*(Aq(?<d>\ed\ed)\e.(?<m>\ed\ed)\e.(?<y>\ed\ed\ed\ed)\*(Aq;
\&    for my $d qw( 2006\-10\-21 15.01.2007 10/31/2005 ){
\&        if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
\&            print "day=$+{d} month=$+{m} year=$+{y}\en";
\&        }
\&    }
.Ve
.PP
If any of the alternatives matches, the hash \f(CW\*(C`%+\*(C'\fR is bound to contain the
three key-value pairs.
.SS "Alternative capture group numbering"
.IX Subsection "Alternative capture group numbering"
Yet another capturing group numbering technique (also as from Perl 5.10)
deals with the problem of referring to groups within a set of alternatives.
Consider a pattern for matching a time of the day, civil or military style:
.PP
.Vb 3
\&    if ( $time =~ /(\ed\ed|\ed):(\ed\ed)|(\ed\ed)(\ed\ed)/ ){
\&        # process hour and minute
\&    }
.Ve
.PP
Processing the results requires an additional if statement to determine
whether \f(CW$1\fR and \f(CW$2\fR or \f(CW$3\fR and \f(CW$4\fR contain the goodies. It would
be easier if we could use group numbers 1 and 2 in second alternative as
well, and this is exactly what the parenthesized construct \f(CW\*(C`(?|...)\*(C'\fR,
set around an alternative achieves. Here is an extended version of the
previous pattern:
.PP
.Vb 3
\&    if ( $time =~ /(?|(\ed\ed|\ed):(\ed\ed)|(\ed\ed)(\ed\ed))\es+([A\-Z][A\-Z][A\-Z])/ ){
\&        print "hour=$1 minute=$2 zone=$3\en";
\&    }
.Ve
.PP
Within the alternative numbering group, group numbers start at the same
position for each alternative. After the group, numbering continues
with one higher than the maximum reached across all the alternatives.
.SS "Position information"
.IX Subsection "Position information"
In addition to what was matched, Perl also provides the
positions of what was matched as contents of the \f(CW\*(C`@\-\*(C'\fR and \f(CW\*(C`@+\*(C'\fR
arrays. \f(CW\*(C`$\-[0]\*(C'\fR is the position of the start of the entire match and
\&\f(CW$+[0]\fR is the position of the end. Similarly, \f(CW\*(C`$\-[n]\*(C'\fR is the
position of the start of the \f(CW$n\fR match and \f(CW$+[n]\fR is the position
of the end. If \f(CW$n\fR is undefined, so are \f(CW\*(C`$\-[n]\*(C'\fR and \f(CW$+[n]\fR. Then
this code
.PP
.Vb 5
\&    $x = "Mmm...donut, thought Homer";
\&    $x =~ /^(Mmm|Yech)\e.\e.\e.(donut|peas)/; # matches
\&    foreach $expr (1..$#\-) {
\&        print "Match $expr: \*(Aq${$expr}\*(Aq at position ($\-[$expr],$+[$expr])\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 2
\&    Match 1: \*(AqMmm\*(Aq at position (0,3)
\&    Match 2: \*(Aqdonut\*(Aq at position (6,11)
.Ve
.PP
Even if there are no groupings in a regexp, it is still possible to
find out what exactly matched in a string.  If you use them, Perl
will set \f(CW\*(C`$\`\*(C'\fR to the part of the string before the match, will set \f(CW$&\fR
to the part of the string that matched, and will set \f(CW\*(C`$\*(Aq\*(C'\fR to the part
of the string after the match.  An example:
.PP
.Vb 3
\&    $x = "the cat caught the mouse";
\&    $x =~ /cat/;  # $\` = \*(Aqthe \*(Aq, $& = \*(Aqcat\*(Aq, $\*(Aq = \*(Aq caught the mouse\*(Aq
\&    $x =~ /the/;  # $\` = \*(Aq\*(Aq, $& = \*(Aqthe\*(Aq, $\*(Aq = \*(Aq cat caught the mouse\*(Aq
.Ve
.PP
In the second match, \f(CW\*(C`$\`\*(C'\fR equals \f(CW\*(Aq\*(Aq\fR because the regexp matched at the
first character position in the string and stopped; it never saw the
second 'the'.  It is important to note that using \f(CW\*(C`$\`\*(C'\fR and \f(CW\*(C`$\*(Aq\*(C'\fR
slows down regexp matching quite a bit, while \f(CW$&\fR slows it down to a
lesser extent, because if they are used in one regexp in a program,
they are generated for \fIall\fR regexps in the program.  So if raw
performance is a goal of your application, they should be avoided.
If you need to extract the corresponding substrings, use \f(CW\*(C`@\-\*(C'\fR and
\&\f(CW\*(C`@+\*(C'\fR instead:
.PP
.Vb 3
\&    $\` is the same as substr( $x, 0, $\-[0] )
\&    $& is the same as substr( $x, $\-[0], $+[0]\-$\-[0] )
\&    $\*(Aq is the same as substr( $x, $+[0] )
.Ve
.PP
As of Perl 5.10, the \f(CW\*(C`${^PREMATCH}\*(C'\fR, \f(CW\*(C`${^MATCH}\*(C'\fR and \f(CW\*(C`${^POSTMATCH}\*(C'\fR
variables may be used. These are only set if the \f(CW\*(C`/p\*(C'\fR modifier is present.
Consequently they do not penalize the rest of the program.
.SS "Non-capturing groupings"
.IX Subsection "Non-capturing groupings"
A group that is required to bundle a set of alternatives may or may not be
useful as a capturing group.  If it isn't, it just creates a superfluous
addition to the set of available capture group values, inside as well as
outside the regexp.  Non-capturing groupings, denoted by \f(CW\*(C`(?:regexp)\*(C'\fR,
still allow the regexp to be treated as a single unit, but don't establish
a capturing group at the same time.  Both capturing and non-capturing
groupings are allowed to co-exist in the same regexp.  Because there is
no extraction, non-capturing groupings are faster than capturing
groupings.  Non-capturing groupings are also handy for choosing exactly
which parts of a regexp are to be extracted to matching variables:
.PP
.Vb 2
\&    # match a number, $1\-$4 are set, but we only want $1
\&    /([+\-]?\e *(\ed+(\e.\ed*)?|\e.\ed+)([eE][+\-]?\ed+)?)/;
\&
\&    # match a number faster , only $1 is set
\&    /([+\-]?\e *(?:\ed+(?:\e.\ed*)?|\e.\ed+)(?:[eE][+\-]?\ed+)?)/;
\&
\&    # match a number, get $1 = whole number, $2 = exponent
\&    /([+\-]?\e *(?:\ed+(?:\e.\ed*)?|\e.\ed+)(?:[eE]([+\-]?\ed+))?)/;
.Ve
.PP
Non-capturing groupings are also useful for removing nuisance
elements gathered from a split operation where parentheses are
required for some reason:
.PP
.Vb 3
\&    $x = \*(Aq12aba34ba5\*(Aq;
\&    @num = split /(a|b)+/, $x;    # @num = (\*(Aq12\*(Aq,\*(Aqa\*(Aq,\*(Aq34\*(Aq,\*(Aqa\*(Aq,\*(Aq5\*(Aq)
\&    @num = split /(?:a|b)+/, $x;  # @num = (\*(Aq12\*(Aq,\*(Aq34\*(Aq,\*(Aq5\*(Aq)
.Ve
.SS "Matching repetitions"
.IX Subsection "Matching repetitions"
The examples in the previous section display an annoying weakness.  We
were only matching 3\-letter words, or chunks of words of 4 letters or
less.  We'd like to be able to match words or, more generally, strings
of any length, without writing out tedious alternatives like
\&\f(CW\*(C`\ew\ew\ew\ew|\ew\ew\ew|\ew\ew|\ew\*(C'\fR.
.PP
This is exactly the problem the \fIquantifier\fR metacharacters \f(CW\*(C`?\*(C'\fR,
\&\f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR, and \f(CW\*(C`{}\*(C'\fR were created for.  They allow us to delimit the
number of repeats for a portion of a regexp we consider to be a
match.  Quantifiers are put immediately after the character, character
class, or grouping that we want to specify.  They have the following
meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a?\*(C'\fR means: match 'a' 1 or 0 times
.IP "\(bu" 4
\&\f(CW\*(C`a*\*(C'\fR means: match 'a' 0 or more times, i.e., any number of times
.IP "\(bu" 4
\&\f(CW\*(C`a+\*(C'\fR means: match 'a' 1 or more times, i.e., at least once
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, but not more than \f(CW\*(C`m\*(C'\fR
times.
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR or more times
.IP "\(bu" 4
\&\f(CW\*(C`a{n}\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times
.PP
Here are some examples:
.PP
.Vb 10
\&    /[a\-z]+\es+\ed*/;  # match a lowercase word, at least one space, and
\&                     # any number of digits
\&    /(\ew+)\es+\eg1/;    # match doubled words of arbitrary length
\&    /y(es)?/i;       # matches \*(Aqy\*(Aq, \*(AqY\*(Aq, or a case\-insensitive \*(Aqyes\*(Aq
\&    $year =~ /^\ed{2,4}$/;  # make sure year is at least 2 but not more
\&                           # than 4 digits
\&    $year =~ /^\ed{4}$|^\ed{2}$/;    # better match; throw out 3\-digit dates
\&    $year =~ /^\ed{2}(\ed{2})?$/;  # same thing written differently. However,
\&                                 # this captures the last two digits in $1
\&                                 # and the other does not.
\&
\&    % simple_grep \*(Aq^(\ew+)\eg1$\*(Aq /usr/dict/words   # isn\*(Aqt this easier?
\&    beriberi
\&    booboo
\&    coco
\&    mama
\&    murmur
\&    papa
.Ve
.PP
For all of these quantifiers, Perl will try to match as much of the
string as possible, while still allowing the regexp to succeed.  Thus
with \f(CW\*(C`/a?.../\*(C'\fR, Perl will first try to match the regexp with the \f(CW\*(C`a\*(C'\fR
present; if that fails, Perl will try to match the regexp without the
\&\f(CW\*(C`a\*(C'\fR present.  For the quantifier \f(CW\*(C`*\*(C'\fR, we get the following:
.PP
.Vb 5
\&    $x = "the cat in the hat";
\&    $x =~ /^(.*)(cat)(.*)$/; # matches,
\&                             # $1 = \*(Aqthe \*(Aq
\&                             # $2 = \*(Aqcat\*(Aq
\&                             # $3 = \*(Aq in the hat\*(Aq
.Ve
.PP
Which is what we might expect, the match finds the only \f(CW\*(C`cat\*(C'\fR in the
string and locks onto it.  Consider, however, this regexp:
.PP
.Vb 4
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe cat in the h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 characters match)
.Ve
.PP
One might initially guess that Perl would find the \f(CW\*(C`at\*(C'\fR in \f(CW\*(C`cat\*(C'\fR and
stop there, but that wouldn't give the longest possible string to the
first quantifier \f(CW\*(C`.*\*(C'\fR.  Instead, the first quantifier \f(CW\*(C`.*\*(C'\fR grabs as
much of the string as possible while still having the regexp match.  In
this example, that means having the \f(CW\*(C`at\*(C'\fR sequence with the final \f(CW\*(C`at\*(C'\fR
in the string.  The other important principle illustrated here is that,
when there are two or more elements in a regexp, the \fIleftmost\fR
quantifier, if there is one, gets to grab as much of the string as
possible, leaving the rest of the regexp to fight over scraps.  Thus in
our example, the first quantifier \f(CW\*(C`.*\*(C'\fR grabs most of the string, while
the second quantifier \f(CW\*(C`.*\*(C'\fR gets the empty string.   Quantifiers that
grab as much of the string as possible are called \fImaximal match\fR or
\&\fIgreedy\fR quantifiers.
.PP
When a regexp can match a string in several different ways, we can use
the principles above to predict which way the regexp will match:
.IP "\(bu" 4
Principle 0: Taken as a whole, any regexp will be matched at the
earliest possible position in the string.
.IP "\(bu" 4
Principle 1: In an alternation \f(CW\*(C`a|b|c...\*(C'\fR, the leftmost alternative
that allows a match for the whole regexp will be the one used.
.IP "\(bu" 4
Principle 2: The maximal matching quantifiers \f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR and
\&\f(CW\*(C`{n,m}\*(C'\fR will in general match as much of the string as possible while
still allowing the whole regexp to match.
.IP "\(bu" 4
Principle 3: If there are two or more elements in a regexp, the
leftmost greedy quantifier, if any, will match as much of the string
as possible while still allowing the whole regexp to match.  The next
leftmost greedy quantifier, if any, will try to match as much of the
string remaining available to it as possible, while still allowing the
whole regexp to match.  And so on, until all the regexp elements are
satisfied.
.PP
As we have seen above, Principle 0 overrides the others. The regexp
will be matched as early as possible, with the other principles
determining how the regexp matches at that earliest character
position.
.PP
Here is an example of these principles in action:
.PP
.Vb 5
\&    $x = "The programming republic of Perl";
\&    $x =~ /^(.+)(e|r)(.*)$/;  # matches,
\&                              # $1 = \*(AqThe programming republic of Pe\*(Aq
\&                              # $2 = \*(Aqr\*(Aq
\&                              # $3 = \*(Aql\*(Aq
.Ve
.PP
This regexp matches at the earliest string position, \f(CW\*(AqT\*(Aq\fR.  One
might think that \f(CW\*(C`e\*(C'\fR, being leftmost in the alternation, would be
matched, but \f(CW\*(C`r\*(C'\fR produces the longest string in the first quantifier.
.PP
.Vb 3
\&    $x =~ /(m{1,2})(.*)$/;  # matches,
\&                            # $1 = \*(Aqmm\*(Aq
\&                            # $2 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Here, The earliest possible match is at the first \f(CW\*(Aqm\*(Aq\fR in
\&\f(CW\*(C`programming\*(C'\fR. \f(CW\*(C`m{1,2}\*(C'\fR is the first quantifier, so it gets to match
a maximal \f(CW\*(C`mm\*(C'\fR.
.PP
.Vb 3
\&    $x =~ /.*(m{1,2})(.*)$/;  # matches,
\&                              # $1 = \*(Aqm\*(Aq
\&                              # $2 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Here, the regexp matches at the start of the string. The first
quantifier \f(CW\*(C`.*\*(C'\fR grabs as much as possible, leaving just a single
\&\f(CW\*(Aqm\*(Aq\fR for the second quantifier \f(CW\*(C`m{1,2}\*(C'\fR.
.PP
.Vb 4
\&    $x =~ /(.?)(m{1,2})(.*)$/;  # matches,
\&                                # $1 = \*(Aqa\*(Aq
\&                                # $2 = \*(Aqmm\*(Aq
\&                                # $3 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Here, \f(CW\*(C`.?\*(C'\fR eats its maximal one character at the earliest possible
position in the string, \f(CW\*(Aqa\*(Aq\fR in \f(CW\*(C`programming\*(C'\fR, leaving \f(CW\*(C`m{1,2}\*(C'\fR
the opportunity to match both \f(CW\*(C`m\*(C'\fR's. Finally,
.PP
.Vb 1
\&    "aXXXb" =~ /(X*)/; # matches with $1 = \*(Aq\*(Aq
.Ve
.PP
because it can match zero copies of \f(CW\*(AqX\*(Aq\fR at the beginning of the
string.  If you definitely want to match at least one \f(CW\*(AqX\*(Aq\fR, use
\&\f(CW\*(C`X+\*(C'\fR, not \f(CW\*(C`X*\*(C'\fR.
.PP
Sometimes greed is not good.  At times, we would like quantifiers to
match a \fIminimal\fR piece of string, rather than a maximal piece.  For
this purpose, Larry Wall created the \fIminimal match\fR or
\&\fInon-greedy\fR quantifiers \f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, and \f(CW\*(C`{}?\*(C'\fR.  These are
the usual quantifiers with a \f(CW\*(C`?\*(C'\fR appended to them.  They have the
following meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a??\*(C'\fR means: match 'a' 0 or 1 times. Try 0 first, then 1.
.IP "\(bu" 4
\&\f(CW\*(C`a*?\*(C'\fR means: match 'a' 0 or more times, i.e., any number of times,
but as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a+?\*(C'\fR means: match 'a' 1 or more times, i.e., at least once, but
as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}?\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, not more than \f(CW\*(C`m\*(C'\fR
times, as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}?\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, but as few times as
possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n}?\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times.  Because we match exactly
\&\f(CW\*(C`n\*(C'\fR times, \f(CW\*(C`a{n}?\*(C'\fR is equivalent to \f(CW\*(C`a{n}\*(C'\fR and is just there for
notational consistency.
.PP
Let's look at the example above, but with minimal quantifiers:
.PP
.Vb 5
\&    $x = "The programming republic of Perl";
\&    $x =~ /^(.+?)(e|r)(.*)$/; # matches,
\&                              # $1 = \*(AqTh\*(Aq
\&                              # $2 = \*(Aqe\*(Aq
\&                              # $3 = \*(Aq programming republic of Perl\*(Aq
.Ve
.PP
The minimal string that will allow both the start of the string \f(CW\*(C`^\*(C'\fR
and the alternation to match is \f(CW\*(C`Th\*(C'\fR, with the alternation \f(CW\*(C`e|r\*(C'\fR
matching \f(CW\*(C`e\*(C'\fR.  The second quantifier \f(CW\*(C`.*\*(C'\fR is free to gobble up the
rest of the string.
.PP
.Vb 3
\&    $x =~ /(m{1,2}?)(.*?)$/;  # matches,
\&                              # $1 = \*(Aqm\*(Aq
\&                              # $2 = \*(Aqming republic of Perl\*(Aq
.Ve
.PP
The first string position that this regexp can match is at the first
\&\f(CW\*(Aqm\*(Aq\fR in \f(CW\*(C`programming\*(C'\fR. At this position, the minimal \f(CW\*(C`m{1,2}?\*(C'\fR
matches just one \f(CW\*(Aqm\*(Aq\fR.  Although the second quantifier \f(CW\*(C`.*?\*(C'\fR would
prefer to match no characters, it is constrained by the end-of-string
anchor \f(CW\*(C`$\*(C'\fR to match the rest of the string.
.PP
.Vb 4
\&    $x =~ /(.*?)(m{1,2}?)(.*)$/;  # matches,
\&                                  # $1 = \*(AqThe progra\*(Aq
\&                                  # $2 = \*(Aqm\*(Aq
\&                                  # $3 = \*(Aqming republic of Perl\*(Aq
.Ve
.PP
In this regexp, you might expect the first minimal quantifier \f(CW\*(C`.*?\*(C'\fR
to match the empty string, because it is not constrained by a \f(CW\*(C`^\*(C'\fR
anchor to match the beginning of the word.  Principle 0 applies here,
however.  Because it is possible for the whole regexp to match at the
start of the string, it \fIwill\fR match at the start of the string.  Thus
the first quantifier has to match everything up to the first \f(CW\*(C`m\*(C'\fR.  The
second minimal quantifier matches just one \f(CW\*(C`m\*(C'\fR and the third
quantifier matches the rest of the string.
.PP
.Vb 4
\&    $x =~ /(.??)(m{1,2})(.*)$/;  # matches,
\&                                 # $1 = \*(Aqa\*(Aq
\&                                 # $2 = \*(Aqmm\*(Aq
\&                                 # $3 = \*(Aqing republic of Perl\*(Aq
.Ve
.PP
Just as in the previous regexp, the first quantifier \f(CW\*(C`.??\*(C'\fR can match
earliest at position \f(CW\*(Aqa\*(Aq\fR, so it does.  The second quantifier is
greedy, so it matches \f(CW\*(C`mm\*(C'\fR, and the third matches the rest of the
string.
.PP
We can modify principle 3 above to take into account non-greedy
quantifiers:
.IP "\(bu" 4
Principle 3: If there are two or more elements in a regexp, the
leftmost greedy (non-greedy) quantifier, if any, will match as much
(little) of the string as possible while still allowing the whole
regexp to match.  The next leftmost greedy (non-greedy) quantifier, if
any, will try to match as much (little) of the string remaining
available to it as possible, while still allowing the whole regexp to
match.  And so on, until all the regexp elements are satisfied.
.PP
Just like alternation, quantifiers are also susceptible to
backtracking.  Here is a step-by-step analysis of the example
.PP
.Vb 5
\&    $x = "the cat in the hat";
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe cat in the h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 matches)
.Ve
.IP "0" 4
Start with the first letter in the string 't'.
.IP "1" 4
.IX Item "1"
The first quantifier '.*' starts out by matching the whole
string 'the cat in the hat'.
.IP "2" 4
.IX Item "2"
\&'a' in the regexp element 'at' doesn't match the end of the
string.  Backtrack one character.
.IP "3" 4
.IX Item "3"
\&'a' in the regexp element 'at' still doesn't match the last
letter of the string 't', so backtrack one more character.
.IP "4" 4
.IX Item "4"
Now we can match the 'a' and the 't'.
.IP "5" 4
.IX Item "5"
Move on to the third element '.*'.  Since we are at the end of
the string and '.*' can match 0 times, assign it the empty string.
.IP "6" 4
.IX Item "6"
We are done!
.PP
Most of the time, all this moving forward and backtracking happens
quickly and searching is fast. There are some pathological regexps,
however, whose execution time exponentially grows with the size of the
string.  A typical structure that blows up in your face is of the form
.PP
.Vb 1
\&    /(a|b+)*/;
.Ve
.PP
The problem is the nested indeterminate quantifiers.  There are many
different ways of partitioning a string of length n between the \f(CW\*(C`+\*(C'\fR
and \f(CW\*(C`*\*(C'\fR: one repetition with \f(CW\*(C`b+\*(C'\fR of length n, two repetitions with
the first \f(CW\*(C`b+\*(C'\fR length k and the second with length n\-k, m repetitions
whose bits add up to length n, etc.  In fact there are an exponential
number of ways to partition a string as a function of its length.  A
regexp may get lucky and match early in the process, but if there is
no match, Perl will try \fIevery\fR possibility before giving up.  So be
careful with nested \f(CW\*(C`*\*(C'\fR's, \f(CW\*(C`{n,m}\*(C'\fR's, and \f(CW\*(C`+\*(C'\fR's.  The book
\&\fIMastering Regular Expressions\fR by Jeffrey Friedl gives a wonderful
discussion of this and other efficiency issues.
.SS "Possessive quantifiers"
.IX Subsection "Possessive quantifiers"
Backtracking during the relentless search for a match may be a waste
of time, particularly when the match is bound to fail.  Consider
the simple pattern
.PP
.Vb 1
\&    /^\ew+\es+\ew+$/; # a word, spaces, a word
.Ve
.PP
Whenever this is applied to a string which doesn't quite meet the
pattern's expectations such as \f(CW"abc\ \ "\fR or \f(CW"abc\ \ def\ "\fR,
the regex engine will backtrack, approximately once for each character
in the string.  But we know that there is no way around taking \fIall\fR
of the initial word characters to match the first repetition, that \fIall\fR
spaces must be eaten by the middle part, and the same goes for the second
word.
.PP
With the introduction of the \fIpossessive quantifiers\fR in Perl 5.10, we
have a way of instructing the regex engine not to backtrack, with the
usual quantifiers with a \f(CW\*(C`+\*(C'\fR appended to them.  This makes them greedy as
well as stingy; once they succeed they won't give anything back to permit
another solution. They have the following meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}+\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, not more than \f(CW\*(C`m\*(C'\fR times,
as many times as possible, and don't give anything up. \f(CW\*(C`a?+\*(C'\fR is short
for \f(CW\*(C`a{0,1}+\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}+\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, but as many times as possible,
and don't give anything up. \f(CW\*(C`a*+\*(C'\fR is short for \f(CW\*(C`a{0,}+\*(C'\fR and \f(CW\*(C`a++\*(C'\fR is
short for \f(CW\*(C`a{1,}+\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`a{n}+\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times.  It is just there for
notational consistency.
.PP
These possessive quantifiers represent a special case of a more general
concept, the \fIindependent subexpression\fR, see below.
.PP
As an example where a possessive quantifier is suitable we consider
matching a quoted string, as it appears in several programming languages.
The backslash is used as an escape character that indicates that the
next character is to be taken literally, as another character for the
string.  Therefore, after the opening quote, we expect a (possibly
empty) sequence of alternatives: either some character except an
unescaped quote or backslash or an escaped character.
.PP
.Vb 1
\&    /"(?:[^"\e\e]++|\e\e.)*+"/;
.Ve
.SS "Building a regexp"
.IX Subsection "Building a regexp"
At this point, we have all the basic regexp concepts covered, so let's
give a more involved example of a regular expression.  We will build a
regexp that matches numbers.
.PP
The first task in building a regexp is to decide what we want to match
and what we want to exclude.  In our case, we want to match both
integers and floating point numbers and we want to reject any string
that isn't a number.
.PP
The next task is to break the problem down into smaller problems that
are easily converted into a regexp.
.PP
The simplest case is integers.  These consist of a sequence of digits,
with an optional sign in front.  The digits we can represent with
\&\f(CW\*(C`\ed+\*(C'\fR and the sign can be matched with \f(CW\*(C`[+\-]\*(C'\fR.  Thus the integer
regexp is
.PP
.Vb 1
\&    /[+\-]?\ed+/;  # matches integers
.Ve
.PP
A floating point number potentially has a sign, an integral part, a
decimal point, a fractional part, and an exponent.  One or more of these
parts is optional, so we need to check out the different
possibilities.  Floating point numbers which are in proper form include
123., 0.345, .34, \-1e6, and 25.4E\-72.  As with integers, the sign out
front is completely optional and can be matched by \f(CW\*(C`[+\-]?\*(C'\fR.  We can
see that if there is no exponent, floating point numbers must have a
decimal point, otherwise they are integers.  We might be tempted to
model these with \f(CW\*(C`\ed*\e.\ed*\*(C'\fR, but this would also match just a single
decimal point, which is not a number.  So the three cases of floating
point number without exponent are
.PP
.Vb 3
\&   /[+\-]?\ed+\e./;  # 1., 321., etc.
\&   /[+\-]?\e.\ed+/;  # .1, .234, etc.
\&   /[+\-]?\ed+\e.\ed+/;  # 1.0, 30.56, etc.
.Ve
.PP
These can be combined into a single regexp with a three-way alternation:
.PP
.Vb 1
\&   /[+\-]?(\ed+\e.\ed+|\ed+\e.|\e.\ed+)/;  # floating point, no exponent
.Ve
.PP
In this alternation, it is important to put \f(CW\*(Aq\ed+\e.\ed+\*(Aq\fR before
\&\f(CW\*(Aq\ed+\e.\*(Aq\fR.  If \f(CW\*(Aq\ed+\e.\*(Aq\fR were first, the regexp would happily match that
and ignore the fractional part of the number.
.PP
Now consider floating point numbers with exponents.  The key
observation here is that \fIboth\fR integers and numbers with decimal
points are allowed in front of an exponent.  Then exponents, like the
overall sign, are independent of whether we are matching numbers with
or without decimal points, and can be 'decoupled' from the
mantissa.  The overall form of the regexp now becomes clear:
.PP
.Vb 1
\&    /^(optional sign)(integer | f.p. mantissa)(optional exponent)$/;
.Ve
.PP
The exponent is an \f(CW\*(C`e\*(C'\fR or \f(CW\*(C`E\*(C'\fR, followed by an integer.  So the
exponent regexp is
.PP
.Vb 1
\&   /[eE][+\-]?\ed+/;  # exponent
.Ve
.PP
Putting all the parts together, we get a regexp that matches numbers:
.PP
.Vb 1
\&   /^[+\-]?(\ed+\e.\ed+|\ed+\e.|\e.\ed+|\ed+)([eE][+\-]?\ed+)?$/;  # Ta da!
.Ve
.PP
Long regexps like this may impress your friends, but can be hard to
decipher.  In complex situations like this, the \f(CW\*(C`//x\*(C'\fR modifier for a
match is invaluable.  It allows one to put nearly arbitrary whitespace
and comments into a regexp without affecting their meaning.  Using it,
we can rewrite our 'extended' regexp in the more pleasing form
.PP
.Vb 10
\&   /^
\&      [+\-]?         # first, match an optional sign
\&      (             # then match integers or f.p. mantissas:
\&          \ed+\e.\ed+  # mantissa of the form a.b
\&         |\ed+\e.     # mantissa of the form a.
\&         |\e.\ed+     # mantissa of the form .b
\&         |\ed+       # integer of the form a
\&      )
\&      ([eE][+\-]?\ed+)?  # finally, optionally match an exponent
\&   $/x;
.Ve
.PP
If whitespace is mostly irrelevant, how does one include space
characters in an extended regexp? The answer is to backslash it
\&\f(CW\*(Aq\e\ \*(Aq\fR or put it in a character class \f(CW\*(C`[\ ]\*(C'\fR.  The same thing
goes for pound signs: use \f(CW\*(C`\e#\*(C'\fR or \f(CW\*(C`[#]\*(C'\fR.  For instance, Perl allows
a space between the sign and the mantissa or integer, and we could add
this to our regexp as follows:
.PP
.Vb 10
\&   /^
\&      [+\-]?\e *      # first, match an optional sign *and space*
\&      (             # then match integers or f.p. mantissas:
\&          \ed+\e.\ed+  # mantissa of the form a.b
\&         |\ed+\e.     # mantissa of the form a.
\&         |\e.\ed+     # mantissa of the form .b
\&         |\ed+       # integer of the form a
\&      )
\&      ([eE][+\-]?\ed+)?  # finally, optionally match an exponent
\&   $/x;
.Ve
.PP
In this form, it is easier to see a way to simplify the
alternation.  Alternatives 1, 2, and 4 all start with \f(CW\*(C`\ed+\*(C'\fR, so it
could be factored out:
.PP
.Vb 11
\&   /^
\&      [+\-]?\e *      # first, match an optional sign
\&      (             # then match integers or f.p. mantissas:
\&          \ed+       # start out with a ...
\&          (
\&              \e.\ed* # mantissa of the form a.b or a.
\&          )?        # ? takes care of integers of the form a
\&         |\e.\ed+     # mantissa of the form .b
\&      )
\&      ([eE][+\-]?\ed+)?  # finally, optionally match an exponent
\&   $/x;
.Ve
.PP
or written in the compact form,
.PP
.Vb 1
\&    /^[+\-]?\e *(\ed+(\e.\ed*)?|\e.\ed+)([eE][+\-]?\ed+)?$/;
.Ve
.PP
This is our final regexp.  To recap, we built a regexp by
.IP "\(bu" 4
specifying the task in detail,
.IP "\(bu" 4
breaking down the problem into smaller parts,
.IP "\(bu" 4
translating the small parts into regexps,
.IP "\(bu" 4
combining the regexps,
.IP "\(bu" 4
and optimizing the final combined regexp.
.PP
These are also the typical steps involved in writing a computer
program.  This makes perfect sense, because regular expressions are
essentially programs written in a little computer language that specifies
patterns.
.SS "Using regular expressions in Perl"
.IX Subsection "Using regular expressions in Perl"
The last topic of Part 1 briefly covers how regexps are used in Perl
programs.  Where do they fit into Perl syntax?
.PP
We have already introduced the matching operator in its default
\&\f(CW\*(C`/regexp/\*(C'\fR and arbitrary delimiter \f(CW\*(C`m!regexp!\*(C'\fR forms.  We have used
the binding operator \f(CW\*(C`=~\*(C'\fR and its negation \f(CW\*(C`!~\*(C'\fR to test for string
matches.  Associated with the matching operator, we have discussed the
single line \f(CW\*(C`//s\*(C'\fR, multi-line \f(CW\*(C`//m\*(C'\fR, case-insensitive \f(CW\*(C`//i\*(C'\fR and
extended \f(CW\*(C`//x\*(C'\fR modifiers.  There are a few more things you might
want to know about matching operators.
.PP
\fIProhibiting substitution\fR
.IX Subsection "Prohibiting substitution"
.PP
If you change \f(CW$pattern\fR after the first substitution happens, Perl
will ignore it.  If you don't want any substitutions at all, use the
special delimiter \f(CW\*(C`m\*(Aq\*(Aq\*(C'\fR:
.PP
.Vb 4
\&    @pattern = (\*(AqSeuss\*(Aq);
\&    while (<>) {
\&        print if m\*(Aq@pattern\*(Aq;  # matches literal \*(Aq@pattern\*(Aq, not \*(AqSeuss\*(Aq
\&    }
.Ve
.PP
Similar to strings, \f(CW\*(C`m\*(Aq\*(Aq\*(C'\fR acts like apostrophes on a regexp; all other
\&\f(CW\*(C`m\*(C'\fR delimiters act like quotes.  If the regexp evaluates to the empty string,
the regexp in the \fIlast successful match\fR is used instead.  So we have
.PP
.Vb 2
\&    "dog" =~ /d/;  # \*(Aqd\*(Aq matches
\&    "dogbert =~ //;  # this matches the \*(Aqd\*(Aq regexp used before
.Ve
.PP
\fIGlobal matching\fR
.IX Subsection "Global matching"
.PP
The final two modifiers we will discuss here,
\&\f(CW\*(C`//g\*(C'\fR and \f(CW\*(C`//c\*(C'\fR, concern multiple matches.
The modifier \f(CW\*(C`//g\*(C'\fR stands for global matching and allows the
matching operator to match within a string as many times as possible.
In scalar context, successive invocations against a string will have
\&\f(CW\*(C`//g\*(C'\fR jump from match to match, keeping track of position in the
string as it goes along.  You can get or set the position with the
\&\f(CW\*(C`pos()\*(C'\fR function.
.PP
The use of \f(CW\*(C`//g\*(C'\fR is shown in the following example.  Suppose we have
a string that consists of words separated by spaces.  If we know how
many words there are in advance, we could extract the words using
groupings:
.PP
.Vb 5
\&    $x = "cat dog house"; # 3 words
\&    $x =~ /^\es*(\ew+)\es+(\ew+)\es+(\ew+)\es*$/; # matches,
\&                                           # $1 = \*(Aqcat\*(Aq
\&                                           # $2 = \*(Aqdog\*(Aq
\&                                           # $3 = \*(Aqhouse\*(Aq
.Ve
.PP
But what if we had an indeterminate number of words? This is the sort
of task \f(CW\*(C`//g\*(C'\fR was made for.  To extract all words, form the simple
regexp \f(CW\*(C`(\ew+)\*(C'\fR and loop over all matches with \f(CW\*(C`/(\ew+)/g\*(C'\fR:
.PP
.Vb 3
\&    while ($x =~ /(\ew+)/g) {
\&        print "Word is $1, ends at position ", pos $x, "\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 3
\&    Word is cat, ends at position 3
\&    Word is dog, ends at position 7
\&    Word is house, ends at position 13
.Ve
.PP
A failed match or changing the target string resets the position.  If
you don't want the position reset after failure to match, add the
\&\f(CW\*(C`//c\*(C'\fR, as in \f(CW\*(C`/regexp/gc\*(C'\fR.  The current position in the string is
associated with the string, not the regexp.  This means that different
strings have different positions and their respective positions can be
set or read independently.
.PP
In list context, \f(CW\*(C`//g\*(C'\fR returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole regexp.  So if
we wanted just the words, we could use
.PP
.Vb 4
\&    @words = ($x =~ /(\ew+)/g);  # matches,
\&                                # $words[0] = \*(Aqcat\*(Aq
\&                                # $words[1] = \*(Aqdog\*(Aq
\&                                # $words[2] = \*(Aqhouse\*(Aq
.Ve
.PP
Closely associated with the \f(CW\*(C`//g\*(C'\fR modifier is the \f(CW\*(C`\eG\*(C'\fR anchor.  The
\&\f(CW\*(C`\eG\*(C'\fR anchor matches at the point where the previous \f(CW\*(C`//g\*(C'\fR match left
off.  \f(CW\*(C`\eG\*(C'\fR allows us to easily do context-sensitive matching:
.PP
.Vb 12
\&    $metric = 1;  # use metric units
\&    ...
\&    $x = <FILE>;  # read in measurement
\&    $x =~ /^([+\-]?\ed+)\es*/g;  # get magnitude
\&    $weight = $1;
\&    if ($metric) { # error checking
\&        print "Units error!" unless $x =~ /\eGkg\e./g;
\&    }
\&    else {
\&        print "Units error!" unless $x =~ /\eGlbs\e./g;
\&    }
\&    $x =~ /\eG\es+(widget|sprocket)/g;  # continue processing
.Ve
.PP
The combination of \f(CW\*(C`//g\*(C'\fR and \f(CW\*(C`\eG\*(C'\fR allows us to process the string a
bit at a time and use arbitrary Perl logic to decide what to do next.
Currently, the \f(CW\*(C`\eG\*(C'\fR anchor is only fully supported when used to anchor
to the start of the pattern.
.PP
\&\f(CW\*(C`\eG\*(C'\fR is also invaluable in processing fixed-length records with
regexps.  Suppose we have a snippet of coding region \s-1DNA,\s0 encoded as
base pair letters \f(CW\*(C`ATCGTTGAAT...\*(C'\fR and we want to find all the stop
codons \f(CW\*(C`TGA\*(C'\fR.  In a coding region, codons are 3\-letter sequences, so
we can think of the \s-1DNA\s0 snippet as a sequence of 3\-letter records.  The
naive regexp
.PP
.Vb 3
\&    # expanded, this is "ATC GTT GAA TGC AAA TGA CAT GAC"
\&    $dna = "ATCGTTGAATGCAAATGACATGAC";
\&    $dna =~ /TGA/;
.Ve
.PP
doesn't work; it may match a \f(CW\*(C`TGA\*(C'\fR, but there is no guarantee that
the match is aligned with codon boundaries, e.g., the substring
\&\f(CW\*(C`GTT\ GAA\*(C'\fR gives a match.  A better solution is
.PP
.Vb 3
\&    while ($dna =~ /(\ew\ew\ew)*?TGA/g) {  # note the minimal *?
\&        print "Got a TGA stop codon at position ", pos $dna, "\en";
\&    }
.Ve
.PP
which prints
.PP
.Vb 2
\&    Got a TGA stop codon at position 18
\&    Got a TGA stop codon at position 23
.Ve
.PP
Position 18 is good, but position 23 is bogus.  What happened?
.PP
The answer is that our regexp works well until we get past the last
real match.  Then the regexp will fail to match a synchronized \f(CW\*(C`TGA\*(C'\fR
and start stepping ahead one character position at a time, not what we
want.  The solution is to use \f(CW\*(C`\eG\*(C'\fR to anchor the match to the codon
alignment:
.PP
.Vb 3
\&    while ($dna =~ /\eG(\ew\ew\ew)*?TGA/g) {
\&        print "Got a TGA stop codon at position ", pos $dna, "\en";
\&    }
.Ve
.PP
This prints
.PP
.Vb 1
\&    Got a TGA stop codon at position 18
.Ve
.PP
which is the correct answer.  This example illustrates that it is
important not only to match what is desired, but to reject what is not
desired.
.PP
(There are other regexp modifiers that are available, such as
\&\f(CW\*(C`//o\*(C'\fR, but their specialized uses are beyond the
scope of this introduction.  )
.PP
\fISearch and replace\fR
.IX Subsection "Search and replace"
.PP
Regular expressions also play a big role in \fIsearch and replace\fR
operations in Perl.  Search and replace is accomplished with the
\&\f(CW\*(C`s///\*(C'\fR operator.  The general form is
\&\f(CW\*(C`s/regexp/replacement/modifiers\*(C'\fR, with everything we know about
regexps and modifiers applying in this case as well.  The
\&\f(CW\*(C`replacement\*(C'\fR is a Perl double-quoted string that replaces in the
string whatever is matched with the \f(CW\*(C`regexp\*(C'\fR.  The operator \f(CW\*(C`=~\*(C'\fR is
also used here to associate a string with \f(CW\*(C`s///\*(C'\fR.  If matching
against \f(CW$_\fR, the \f(CW\*(C`$_\ =~\*(C'\fR can be dropped.  If there is a match,
\&\f(CW\*(C`s///\*(C'\fR returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:
.PP
.Vb 8
\&    $x = "Time to feed the cat!";
\&    $x =~ s/cat/hacker/;   # $x contains "Time to feed the hacker!"
\&    if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
\&        $more_insistent = 1;
\&    }
\&    $y = "\*(Aqquoted words\*(Aq";
\&    $y =~ s/^\*(Aq(.*)\*(Aq$/$1/;  # strip single quotes,
\&                           # $y contains "quoted words"
.Ve
.PP
In the last example, the whole string was matched, but only the part
inside the single quotes was grouped.  With the \f(CW\*(C`s///\*(C'\fR operator, the
matched variables \f(CW$1\fR, \f(CW$2\fR, etc. are immediately available for use
in the replacement expression, so we use \f(CW$1\fR to replace the quoted
string with just what was quoted.  With the global modifier, \f(CW\*(C`s///g\*(C'\fR
will search and replace all occurrences of the regexp in the string:
.PP
.Vb 6
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/;   # doesn\*(Aqt do it all:
\&                       # $x contains "I batted four for 4"
\&    $x = "I batted 4 for 4";
\&    $x =~ s/4/four/g;  # does it all:
\&                       # $x contains "I batted four for four"
.Ve
.PP
If you prefer 'regex' over 'regexp' in this tutorial, you could use
the following program to replace it:
.PP
.Vb 9
\&    % cat > simple_replace
\&    #!/usr/bin/perl
\&    $regexp = shift;
\&    $replacement = shift;
\&    while (<>) {
\&        s/$regexp/$replacement/g;
\&        print;
\&    }
\&    ^D
\&
\&    % simple_replace regexp regex perlretut.pod
.Ve
.PP
In \f(CW\*(C`simple_replace\*(C'\fR we used the \f(CW\*(C`s///g\*(C'\fR modifier to replace all
occurrences of the regexp on each line.  (Even though the regular
expression appears in a loop, Perl is smart enough to compile it
only once.)  As with \f(CW\*(C`simple_grep\*(C'\fR, both the
\&\f(CW\*(C`print\*(C'\fR and the \f(CW\*(C`s/$regexp/$replacement/g\*(C'\fR use \f(CW$_\fR implicitly.
.PP
If you don't want \f(CW\*(C`s///\*(C'\fR to change your original variable you can use
the non-destructive substitute modifier, \f(CW\*(C`s///r\*(C'\fR.  This changes the
behavior so that \f(CW\*(C`s///r\*(C'\fR returns the final substituted string
(instead of the number of substitutions):
.PP
.Vb 3
\&    $x = "I like dogs.";
\&    $y = $x =~ s/dogs/cats/r;
\&    print "$x $y\en";
.Ve
.PP
That example will print \*(L"I like dogs. I like cats\*(R". Notice the original
\&\f(CW$x\fR variable has not been affected. The overall
result of the substitution is instead stored in \f(CW$y\fR. If the
substitution doesn't affect anything then the original string is
returned:
.PP
.Vb 3
\&    $x = "I like dogs.";
\&    $y = $x =~ s/elephants/cougars/r;
\&    print "$x $y\en"; # prints "I like dogs. I like dogs."
.Ve
.PP
One other interesting thing that the \f(CW\*(C`s///r\*(C'\fR flag allows is chaining
substitutions:
.PP
.Vb 3
\&    $x = "Cats are great.";
\&    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, "\en";
\&    # prints "Hedgehogs are great."
.Ve
.PP
A modifier available specifically to search and replace is the
\&\f(CW\*(C`s///e\*(C'\fR evaluation modifier.  \f(CW\*(C`s///e\*(C'\fR treats the
replacement text as Perl code, rather than a double-quoted
string.  The value that the code returns is substituted for the
matched substring.  \f(CW\*(C`s///e\*(C'\fR is useful if you need to do a bit of
computation in the process of replacing text.  This example counts
character frequencies in a line:
.PP
.Vb 4
\&    $x = "Bill the cat";
\&    $x =~ s/(.)/$chars{$1}++;$1/eg;  # final $1 replaces char with itself
\&    print "frequency of \*(Aq$_\*(Aq is $chars{$_}\en"
\&        foreach (sort {$chars{$b} <=> $chars{$a}} keys %chars);
.Ve
.PP
This prints
.PP
.Vb 9
\&    frequency of \*(Aq \*(Aq is 2
\&    frequency of \*(Aqt\*(Aq is 2
\&    frequency of \*(Aql\*(Aq is 2
\&    frequency of \*(AqB\*(Aq is 1
\&    frequency of \*(Aqc\*(Aq is 1
\&    frequency of \*(Aqe\*(Aq is 1
\&    frequency of \*(Aqh\*(Aq is 1
\&    frequency of \*(Aqi\*(Aq is 1
\&    frequency of \*(Aqa\*(Aq is 1
.Ve
.PP
As with the match \f(CW\*(C`m//\*(C'\fR operator, \f(CW\*(C`s///\*(C'\fR can use other delimiters,
such as \f(CW\*(C`s!!!\*(C'\fR and \f(CW\*(C`s{}{}\*(C'\fR, and even \f(CW\*(C`s{}//\*(C'\fR.  If single quotes are
used \f(CW\*(C`s\*(Aq\*(Aq\*(Aq\*(C'\fR, then the regexp and replacement are
treated as single-quoted strings and there are no
variable substitutions.  \f(CW\*(C`s///\*(C'\fR in list context
returns the same thing as in scalar context, i.e., the number of
matches.
.PP
\fIThe split function\fR
.IX Subsection "The split function"
.PP
The \f(CW\*(C`split()\*(C'\fR function is another place where a regexp is used.
\&\f(CW\*(C`split /regexp/, string, limit\*(C'\fR separates the \f(CW\*(C`string\*(C'\fR operand into
a list of substrings and returns that list.  The regexp must be designed
to match whatever constitutes the separators for the desired substrings.
The \f(CW\*(C`limit\*(C'\fR, if present, constrains splitting into no more than \f(CW\*(C`limit\*(C'\fR
number of strings.  For example, to split a string into words, use
.PP
.Vb 4
\&    $x = "Calvin and Hobbes";
\&    @words = split /\es+/, $x;  # $word[0] = \*(AqCalvin\*(Aq
\&                               # $word[1] = \*(Aqand\*(Aq
\&                               # $word[2] = \*(AqHobbes\*(Aq
.Ve
.PP
If the empty regexp \f(CW\*(C`//\*(C'\fR is used, the regexp always matches and
the string is split into individual characters.  If the regexp has
groupings, then the resulting list contains the matched substrings from the
groupings as well.  For instance,
.PP
.Vb 12
\&    $x = "/usr/bin/perl";
\&    @dirs = split m!/!, $x;  # $dirs[0] = \*(Aq\*(Aq
\&                             # $dirs[1] = \*(Aqusr\*(Aq
\&                             # $dirs[2] = \*(Aqbin\*(Aq
\&                             # $dirs[3] = \*(Aqperl\*(Aq
\&    @parts = split m!(/)!, $x;  # $parts[0] = \*(Aq\*(Aq
\&                                # $parts[1] = \*(Aq/\*(Aq
\&                                # $parts[2] = \*(Aqusr\*(Aq
\&                                # $parts[3] = \*(Aq/\*(Aq
\&                                # $parts[4] = \*(Aqbin\*(Aq
\&                                # $parts[5] = \*(Aq/\*(Aq
\&                                # $parts[6] = \*(Aqperl\*(Aq
.Ve
.PP
Since the first character of \f(CW$x\fR matched the regexp, \f(CW\*(C`split\*(C'\fR prepended
an empty initial element to the list.
.PP
If you have read this far, congratulations! You now have all the basic
tools needed to use regular expressions to solve a wide range of text
processing problems.  If this is your first time through the tutorial,
why not stop here and play around with regexps a while....  Part\ 2
concerns the more esoteric aspects of regular expressions and those
concepts certainly aren't needed right at the start.
.SH "Part 2: Power tools"
.IX Header "Part 2: Power tools"
\&\s-1OK,\s0 you know the basics of regexps and you want to know more.  If
matching regular expressions is analogous to a walk in the woods, then
the tools discussed in Part 1 are analogous to topo maps and a
compass, basic tools we use all the time.  Most of the tools in part 2
are analogous to flare guns and satellite phones.  They aren't used
too often on a hike, but when we are stuck, they can be invaluable.
.PP
What follows are the more advanced, less used, or sometimes esoteric
capabilities of Perl regexps.  In Part 2, we will assume you are
comfortable with the basics and concentrate on the advanced features.
.SS "More on characters, strings, and character classes"
.IX Subsection "More on characters, strings, and character classes"
There are a number of escape sequences and character classes that we
haven't covered yet.
.PP
There are several escape sequences that convert characters or strings
between upper and lower case, and they are also available within
patterns.  \f(CW\*(C`\el\*(C'\fR and \f(CW\*(C`\eu\*(C'\fR convert the next character to lower or
upper case, respectively:
.PP
.Vb 4
\&    $x = "perl";
\&    $string =~ /\eu$x/;  # matches \*(AqPerl\*(Aq in $string
\&    $x = "M(rs?|s)\e\e."; # note the double backslash
\&    $string =~ /\el$x/;  # matches \*(Aqmr.\*(Aq, \*(Aqmrs.\*(Aq, and \*(Aqms.\*(Aq,
.Ve
.PP
A \f(CW\*(C`\eL\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR indicates a lasting conversion of case, until
terminated by \f(CW\*(C`\eE\*(C'\fR or thrown over by another \f(CW\*(C`\eU\*(C'\fR or \f(CW\*(C`\eL\*(C'\fR:
.PP
.Vb 4
\&    $x = "This word is in lower case:\eL SHOUT\eE";
\&    $x =~ /shout/;       # matches
\&    $x = "I STILL KEYPUNCH CARDS FOR MY 360"
\&    $x =~ /\eUkeypunch/;  # matches punch card string
.Ve
.PP
If there is no \f(CW\*(C`\eE\*(C'\fR, case is converted until the end of the
string. The regexps \f(CW\*(C`\eL\eu$word\*(C'\fR or \f(CW\*(C`\eu\eL$word\*(C'\fR convert the first
character of \f(CW$word\fR to uppercase and the rest of the characters to
lowercase.
.PP
Control characters can be escaped with \f(CW\*(C`\ec\*(C'\fR, so that a control-Z
character would be matched with \f(CW\*(C`\ecZ\*(C'\fR.  The escape sequence
\&\f(CW\*(C`\eQ\*(C'\fR...\f(CW\*(C`\eE\*(C'\fR quotes, or protects most non-alphabetic characters.   For
instance,
.PP
.Vb 2
\&    $x = "\eQThat !^*&%~& cat!";
\&    $x =~ /\eQ!^*&%~&\eE/;  # check for rough language
.Ve
.PP
It does not protect \f(CW\*(C`$\*(C'\fR or \f(CW\*(C`@\*(C'\fR, so that variables can still be
substituted.
.PP
\&\f(CW\*(C`\eQ\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR and \f(CW\*(C`\eE\*(C'\fR are actually part of
double-quotish syntax, and not part of regexp syntax proper.  They will
work if they appear in a regular expression embedded directly in a
program, but not when contained in a string that is interpolated in a
pattern.
.PP
Perl regexps can handle more than just the
standard \s-1ASCII\s0 character set.  Perl supports \fIUnicode\fR, a standard
for representing the alphabets from virtually all of the world's written
languages, and a host of symbols.  Perl's text strings are Unicode strings, so
they can contain characters with a value (codepoint or character number) higher
than 255.
.PP
What does this mean for regexps? Well, regexp users don't need to know
much about Perl's internal representation of strings.  But they do need
to know 1) how to represent Unicode characters in a regexp and 2) that
a matching operation will treat the string to be searched as a sequence
of characters, not bytes.  The answer to 1) is that Unicode characters
greater than \f(CW\*(C`chr(255)\*(C'\fR are represented using the \f(CW\*(C`\ex{hex}\*(C'\fR notation, because
\&\ex hex (without curly braces) doesn't go further than 255.  (Starting in Perl
5.14, if you're an octal fan, you can also use \f(CW\*(C`\eo{oct}\*(C'\fR.)
.PP
.Vb 1
\&    /\ex{263a}/;  # match a Unicode smiley face :)
.Ve
.PP
\&\fB\s-1NOTE\s0\fR: In Perl 5.6.0 it used to be that one needed to say \f(CW\*(C`use
utf8\*(C'\fR to use any Unicode features.  This is no more the case: for
almost all Unicode processing, the explicit \f(CW\*(C`utf8\*(C'\fR pragma is not
needed.  (The only case where it matters is if your Perl script is in
Unicode and encoded in \s-1UTF\-8,\s0 then an explicit \f(CW\*(C`use utf8\*(C'\fR is needed.)
.PP
Figuring out the hexadecimal sequence of a Unicode character you want
or deciphering someone else's hexadecimal Unicode regexp is about as
much fun as programming in machine code.  So another way to specify
Unicode characters is to use the \fInamed character\fR escape
sequence \f(CW\*(C`\eN{\f(CIname\f(CW}\*(C'\fR.  \fIname\fR is a name for the Unicode character, as
specified in the Unicode standard.  For instance, if we wanted to
represent or match the astrological sign for the planet Mercury, we
could use
.PP
.Vb 2
\&    $x = "abc\eN{MERCURY}def";
\&    $x =~ /\eN{MERCURY}/;   # matches
.Ve
.PP
One can also use \*(L"short\*(R" names:
.PP
.Vb 2
\&    print "\eN{GREEK SMALL LETTER SIGMA} is called sigma.\en";
\&    print "\eN{greek:Sigma} is an upper\-case sigma.\en";
.Ve
.PP
You can also restrict names to a certain alphabet by specifying the
charnames pragma:
.PP
.Vb 2
\&    use charnames qw(greek);
\&    print "\eN{sigma} is Greek sigma\en";
.Ve
.PP
An index of character names is available on-line from the Unicode
Consortium, <http://www.unicode.org/charts/charindex.html>; explanatory
material with links to other resources at
<http://www.unicode.org/standard/where>.
.PP
The answer to requirement 2) is that a regexp (mostly)
uses Unicode characters.  The \*(L"mostly\*(R" is for messy backward
compatibility reasons, but starting in Perl 5.14, any regex compiled in
the scope of a \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR (which is automatically
turned on within the scope of a \f(CW\*(C`use 5.012\*(C'\fR or higher) will turn that
\&\*(L"mostly\*(R" into \*(L"always\*(R".  If you want to handle Unicode properly, you
should ensure that \f(CW\*(Aqunicode_strings\*(Aq\fR is turned on.
Internally, this is encoded to bytes using either \s-1UTF\-8\s0 or a native 8
bit encoding, depending on the history of the string, but conceptually
it is a sequence of characters, not bytes. See perlunitut for a
tutorial about that.
.PP
Let us now discuss Unicode character classes.  Just as with Unicode
characters, there are named Unicode character classes represented by the
\&\f(CW\*(C`\ep{name}\*(C'\fR escape sequence.  Closely associated is the \f(CW\*(C`\eP{name}\*(C'\fR
character class, which is the negation of the \f(CW\*(C`\ep{name}\*(C'\fR class.  For
example, to match lower and uppercase characters,
.PP
.Vb 5
\&    $x = "BOB";
\&    $x =~ /^\ep{IsUpper}/;   # matches, uppercase char class
\&    $x =~ /^\eP{IsUpper}/;   # doesn\*(Aqt match, char class sans uppercase
\&    $x =~ /^\ep{IsLower}/;   # doesn\*(Aqt match, lowercase char class
\&    $x =~ /^\eP{IsLower}/;   # matches, char class sans lowercase
.Ve
.PP
(The \*(L"Is\*(R" is optional.)
.PP
Here is the association between some Perl named classes and the
traditional Unicode classes:
.PP
.Vb 1
\&    Perl class name  Unicode class name or regular expression
\&
\&    IsAlpha          /^[LM]/
\&    IsAlnum          /^[LMN]/
\&    IsASCII          $code <= 127
\&    IsCntrl          /^C/
\&    IsBlank          $code =~ /^(0020|0009)$/ || /^Z[^lp]/
\&    IsDigit          Nd
\&    IsGraph          /^([LMNPS]|Co)/
\&    IsLower          Ll
\&    IsPrint          /^([LMNPS]|Co|Zs)/
\&    IsPunct          /^P/
\&    IsSpace          /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/
\&    IsSpacePerl      /^Z/ || ($code =~ /^(0009|000A|000C|000D|0085|2028|2029)$/
\&    IsUpper          /^L[ut]/
\&    IsWord           /^[LMN]/ || $code eq "005F"
\&    IsXDigit         $code =~ /^00(3[0\-9]|[46][1\-6])$/
.Ve
.PP
You can also use the official Unicode class names with \f(CW\*(C`\ep\*(C'\fR and
\&\f(CW\*(C`\eP\*(C'\fR, like \f(CW\*(C`\ep{L}\*(C'\fR for Unicode 'letters', \f(CW\*(C`\ep{Lu}\*(C'\fR for uppercase
letters, or \f(CW\*(C`\eP{Nd}\*(C'\fR for non-digits.  If a \f(CW\*(C`name\*(C'\fR is just one
letter, the braces can be dropped.  For instance, \f(CW\*(C`\epM\*(C'\fR is the
character class of Unicode 'marks', for example accent marks.
For the full list see perlunicode.
.PP
Unicode has also been separated into various sets of characters
which you can test with \f(CW\*(C`\ep{...}\*(C'\fR (in) and \f(CW\*(C`\eP{...}\*(C'\fR (not in).
To test whether a character is (or is not) an element of a script
you would use the script name, for example \f(CW\*(C`\ep{Latin}\*(C'\fR, \f(CW\*(C`\ep{Greek}\*(C'\fR,
or \f(CW\*(C`\eP{Katakana}\*(C'\fR.
.PP
What we have described so far is the single form of the \f(CW\*(C`\ep{...}\*(C'\fR character
classes.  There is also a compound form which you may run into.  These
look like \f(CW\*(C`\ep{name=value}\*(C'\fR or \f(CW\*(C`\ep{name:value}\*(C'\fR (the equals sign and colon
can be used interchangeably).  These are more general than the single form,
and in fact most of the single forms are just Perl-defined shortcuts for common
compound forms.  For example, the script examples in the previous paragraph
could be written equivalently as \f(CW\*(C`\ep{Script=Latin}\*(C'\fR, \f(CW\*(C`\ep{Script:Greek}\*(C'\fR, and
\&\f(CW\*(C`\eP{script=katakana}\*(C'\fR (case is irrelevant between the \f(CW\*(C`{}\*(C'\fR braces).  You may
never have to use the compound forms, but sometimes it is necessary, and their
use can make your code easier to understand.
.PP
\&\f(CW\*(C`\eX\*(C'\fR is an abbreviation for a character class that comprises
a Unicode \fIextended grapheme cluster\fR.  This represents a \*(L"logical character\*(R":
what appears to be a single character, but may be represented internally by more
than one.  As an example, using the Unicode full names, e.g., \f(CW\*(C`A\ +\ COMBINING\ RING\*(C'\fR is a grapheme cluster with base character \f(CW\*(C`A\*(C'\fR and combining character
\&\f(CW\*(C`COMBINING\ RING\*(C'\fR, which translates in Danish to A with the circle atop it,
as in the word Angstrom.
.PP
For the full and latest information about Unicode see the latest
Unicode standard, or the Unicode Consortium's website <http://www.unicode.org>
.PP
As if all those classes weren't enough, Perl also defines POSIX-style
character classes.  These have the form \f(CW\*(C`[:name:]\*(C'\fR, with \f(CW\*(C`name\*(C'\fR the
name of the \s-1POSIX\s0 class.  The \s-1POSIX\s0 classes are \f(CW\*(C`alpha\*(C'\fR, \f(CW\*(C`alnum\*(C'\fR,
\&\f(CW\*(C`ascii\*(C'\fR, \f(CW\*(C`cntrl\*(C'\fR, \f(CW\*(C`digit\*(C'\fR, \f(CW\*(C`graph\*(C'\fR, \f(CW\*(C`lower\*(C'\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`punct\*(C'\fR,
\&\f(CW\*(C`space\*(C'\fR, \f(CW\*(C`upper\*(C'\fR, and \f(CW\*(C`xdigit\*(C'\fR, and two extensions, \f(CW\*(C`word\*(C'\fR (a Perl
extension to match \f(CW\*(C`\ew\*(C'\fR), and \f(CW\*(C`blank\*(C'\fR (a \s-1GNU\s0 extension).  The \f(CW\*(C`//a\*(C'\fR
modifier restricts these to matching just in the \s-1ASCII\s0 range; otherwise
they can match the same as their corresponding Perl Unicode classes:
\&\f(CW\*(C`[:upper:]\*(C'\fR is the same as \f(CW\*(C`\ep{IsUpper}\*(C'\fR, etc.  (There are some
exceptions and gotchas with this; see perlrecharclass for a full
discussion.) The \f(CW\*(C`[:digit:]\*(C'\fR, \f(CW\*(C`[:word:]\*(C'\fR, and
\&\f(CW\*(C`[:space:]\*(C'\fR correspond to the familiar \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, and \f(CW\*(C`\es\*(C'\fR
character classes.  To negate a \s-1POSIX\s0 class, put a \f(CW\*(C`^\*(C'\fR in front of
the name, so that, e.g., \f(CW\*(C`[:^digit:]\*(C'\fR corresponds to \f(CW\*(C`\eD\*(C'\fR and, under
Unicode, \f(CW\*(C`\eP{IsDigit}\*(C'\fR.  The Unicode and \s-1POSIX\s0 character classes can
be used just like \f(CW\*(C`\ed\*(C'\fR, with the exception that \s-1POSIX\s0 character
classes can only be used inside of a character class:
.PP
.Vb 6
\&    /\es+[abc[:digit:]xyz]\es*/;  # match a,b,c,x,y,z, or a digit
\&    /^=item\es[[:digit:]]/;      # match \*(Aq=item\*(Aq,
\&                                # followed by a space and a digit
\&    /\es+[abc\ep{IsDigit}xyz]\es+/;  # match a,b,c,x,y,z, or a digit
\&    /^=item\es\ep{IsDigit}/;        # match \*(Aq=item\*(Aq,
\&                                  # followed by a space and a digit
.Ve
.PP
Whew! That is all the rest of the characters and character classes.
.SS "Compiling and saving regular expressions"
.IX Subsection "Compiling and saving regular expressions"
In Part 1 we mentioned that Perl compiles a regexp into a compact
sequence of opcodes.  Thus, a compiled regexp is a data structure
that can be stored once and used again and again.  The regexp quote
\&\f(CW\*(C`qr//\*(C'\fR does exactly that: \f(CW\*(C`qr/string/\*(C'\fR compiles the \f(CW\*(C`string\*(C'\fR as a
regexp and transforms the result into a form that can be assigned to a
variable:
.PP
.Vb 1
\&    $reg = qr/foo+bar?/;  # reg contains a compiled regexp
.Ve
.PP
Then \f(CW$reg\fR can be used as a regexp:
.PP
.Vb 3
\&    $x = "fooooba";
\&    $x =~ $reg;     # matches, just like /foo+bar?/
\&    $x =~ /$reg/;   # same thing, alternate form
.Ve
.PP
\&\f(CW$reg\fR can also be interpolated into a larger regexp:
.PP
.Vb 1
\&    $x =~ /(abc)?$reg/;  # still matches
.Ve
.PP
As with the matching operator, the regexp quote can use different
delimiters, e.g., \f(CW\*(C`qr!!\*(C'\fR, \f(CW\*(C`qr{}\*(C'\fR or \f(CW\*(C`qr~~\*(C'\fR.  Apostrophes
as delimiters (\f(CW\*(C`qr\*(Aq\*(Aq\*(C'\fR) inhibit any interpolation.
.PP
Pre-compiled regexps are useful for creating dynamic matches that
don't need to be recompiled each time they are encountered.  Using
pre-compiled regexps, we write a \f(CW\*(C`grep_step\*(C'\fR program which greps
for a sequence of patterns, advancing to the next pattern as soon
as one has been satisfied.
.PP
.Vb 4
\&    % cat > grep_step
\&    #!/usr/bin/perl
\&    # grep_step \- match <number> regexps, one after the other
\&    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...
\&
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
\&    @compiled = map qr/$_/, @regexp;
\&    while ($line = <>) {
\&        if ($line =~ /$compiled[0]/) {
\&            print $line;
\&            shift @compiled;
\&            last unless @compiled;
\&        }
\&    }
\&    ^D
\&
\&    % grep_step 3 shift print last grep_step
\&    $number = shift;
\&            print $line;
\&            last unless @compiled;
.Ve
.PP
Storing pre-compiled regexps in an array \f(CW@compiled\fR allows us to
simply loop through the regexps without any recompilation, thus gaining
flexibility without sacrificing speed.
.SS "Composing regular expressions at runtime"
.IX Subsection "Composing regular expressions at runtime"
Backtracking is more efficient than repeated tries with different regular
expressions.  If there are several regular expressions and a match with
any of them is acceptable, then it is possible to combine them into a set
of alternatives.  If the individual expressions are input data, this
can be done by programming a join operation.  We'll exploit this idea in
an improved version of the \f(CW\*(C`simple_grep\*(C'\fR program: a program that matches
multiple patterns:
.PP
.Vb 4
\&    % cat > multi_grep
\&    #!/usr/bin/perl
\&    # multi_grep \- match any of <number> regexps
\&    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...
\&
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
\&    $pattern = join \*(Aq|\*(Aq, @regexp;
\&
\&    while ($line = <>) {
\&        print $line if $line =~ /$pattern/;
\&    }
\&    ^D
\&
\&    % multi_grep 2 shift for multi_grep
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
.Ve
.PP
Sometimes it is advantageous to construct a pattern from the \fIinput\fR
that is to be analyzed and use the permissible values on the left
hand side of the matching operations.  As an example for this somewhat
paradoxical situation, let's assume that our input contains a command
verb which should match one out of a set of available command verbs,
with the additional twist that commands may be abbreviated as long as
the given string is unique. The program below demonstrates the basic
algorithm.
.PP
.Vb 10
\&    % cat > keymatch
\&    #!/usr/bin/perl
\&    $kwds = \*(Aqcopy compare list print\*(Aq;
\&    while( $command = <> ){
\&        $command =~ s/^\es+|\es+$//g;  # trim leading and trailing spaces
\&        if( ( @matches = $kwds =~ /\eb$command\ew*/g ) == 1 ){
\&            print "command: \*(Aq@matches\*(Aq\en";
\&        } elsif( @matches == 0 ){
\&            print "no such command: \*(Aq$command\*(Aq\en";
\&        } else {
\&            print "not unique: \*(Aq$command\*(Aq (could be one of: @matches)\en";
\&        }
\&    }
\&    ^D
\&
\&    % keymatch
\&    li
\&    command: \*(Aqlist\*(Aq
\&    co
\&    not unique: \*(Aqco\*(Aq (could be one of: copy compare)
\&    printer
\&    no such command: \*(Aqprinter\*(Aq
.Ve
.PP
Rather than trying to match the input against the keywords, we match the
combined set of keywords against the input.  The pattern matching
operation \f(CW\*(C`$kwds\ =~\ /\eb($command\ew*)/g\*(C'\fR does several things at the
same time. It makes sure that the given command begins where a keyword
begins (\f(CW\*(C`\eb\*(C'\fR). It tolerates abbreviations due to the added \f(CW\*(C`\ew*\*(C'\fR. It
tells us the number of matches (\f(CW\*(C`scalar @matches\*(C'\fR) and all the keywords
that were actually matched.  You could hardly ask for more.
.SS "Embedding comments and modifiers in a regular expression"
.IX Subsection "Embedding comments and modifiers in a regular expression"
Starting with this section, we will be discussing Perl's set of
\&\fIextended patterns\fR.  These are extensions to the traditional regular
expression syntax that provide powerful new tools for pattern
matching.  We have already seen extensions in the form of the minimal
matching constructs \f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{n,m}?\*(C'\fR, and \f(CW\*(C`{n,}?\*(C'\fR.  Most
of the extensions below have the form \f(CW\*(C`(?char...)\*(C'\fR, where the
\&\f(CW\*(C`char\*(C'\fR is a character that determines the type of extension.
.PP
The first extension is an embedded comment \f(CW\*(C`(?#text)\*(C'\fR.  This embeds a
comment into the regular expression without affecting its meaning.  The
comment should not have any closing parentheses in the text.  An
example is
.PP
.Vb 1
\&    /(?# Match an integer:)[+\-]?\ed+/;
.Ve
.PP
This style of commenting has been largely superseded by the raw,
freeform commenting that is allowed with the \f(CW\*(C`//x\*(C'\fR modifier.
.PP
Most modifiers, such as \f(CW\*(C`//i\*(C'\fR, \f(CW\*(C`//m\*(C'\fR, \f(CW\*(C`//s\*(C'\fR and \f(CW\*(C`//x\*(C'\fR (or any
combination thereof) can also be embedded in
a regexp using \f(CW\*(C`(?i)\*(C'\fR, \f(CW\*(C`(?m)\*(C'\fR, \f(CW\*(C`(?s)\*(C'\fR, and \f(CW\*(C`(?x)\*(C'\fR.  For instance,
.PP
.Vb 7
\&    /(?i)yes/;  # match \*(Aqyes\*(Aq case insensitively
\&    /yes/i;     # same thing
\&    /(?x)(          # freeform version of an integer regexp
\&             [+\-]?  # match an optional sign
\&             \ed+    # match a sequence of digits
\&         )
\&    /x;
.Ve
.PP
Embedded modifiers can have two important advantages over the usual
modifiers.  Embedded modifiers allow a custom set of modifiers to
\&\fIeach\fR regexp pattern.  This is great for matching an array of regexps
that must have different modifiers:
.PP
.Vb 8
\&    $pattern[0] = \*(Aq(?i)doctor\*(Aq;
\&    $pattern[1] = \*(AqJohnson\*(Aq;
\&    ...
\&    while (<>) {
\&        foreach $patt (@pattern) {
\&            print if /$patt/;
\&        }
\&    }
.Ve
.PP
The second advantage is that embedded modifiers (except \f(CW\*(C`//p\*(C'\fR, which
modifies the entire regexp) only affect the regexp
inside the group the embedded modifier is contained in.  So grouping
can be used to localize the modifier's effects:
.PP
.Vb 1
\&    /Answer: ((?i)yes)/;  # matches \*(AqAnswer: yes\*(Aq, \*(AqAnswer: YES\*(Aq, etc.
.Ve
.PP
Embedded modifiers can also turn off any modifiers already present
by using, e.g., \f(CW\*(C`(?\-i)\*(C'\fR.  Modifiers can also be combined into
a single expression, e.g., \f(CW\*(C`(?s\-i)\*(C'\fR turns on single line mode and
turns off case insensitivity.
.PP
Embedded modifiers may also be added to a non-capturing grouping.
\&\f(CW\*(C`(?i\-m:regexp)\*(C'\fR is a non-capturing grouping that matches \f(CW\*(C`regexp\*(C'\fR
case insensitively and turns off multi-line mode.
.SS "Looking ahead and looking behind"
.IX Subsection "Looking ahead and looking behind"
This section concerns the lookahead and lookbehind assertions.  First,
a little background.
.PP
In Perl regular expressions, most regexp elements 'eat up' a certain
amount of string when they match.  For instance, the regexp element
\&\f(CW\*(C`[abc}]\*(C'\fR eats up one character of the string when it matches, in the
sense that Perl moves to the next character position in the string
after the match.  There are some elements, however, that don't eat up
characters (advance the character position) if they match.  The examples
we have seen so far are the anchors.  The anchor \f(CW\*(C`^\*(C'\fR matches the
beginning of the line, but doesn't eat any characters.  Similarly, the
word boundary anchor \f(CW\*(C`\eb\*(C'\fR matches wherever a character matching \f(CW\*(C`\ew\*(C'\fR
is next to a character that doesn't, but it doesn't eat up any
characters itself.  Anchors are examples of \fIzero-width assertions\fR:
zero-width, because they consume
no characters, and assertions, because they test some property of the
string.  In the context of our walk in the woods analogy to regexp
matching, most regexp elements move us along a trail, but anchors have
us stop a moment and check our surroundings.  If the local environment
checks out, we can proceed forward.  But if the local environment
doesn't satisfy us, we must backtrack.
.PP
Checking the environment entails either looking ahead on the trail,
looking behind, or both.  \f(CW\*(C`^\*(C'\fR looks behind, to see that there are no
characters before.  \f(CW\*(C`$\*(C'\fR looks ahead, to see that there are no
characters after.  \f(CW\*(C`\eb\*(C'\fR looks both ahead and behind, to see if the
characters on either side differ in their \*(L"word-ness\*(R".
.PP
The lookahead and lookbehind assertions are generalizations of the
anchor concept.  Lookahead and lookbehind are zero-width assertions
that let us specify which characters we want to test for.  The
lookahead assertion is denoted by \f(CW\*(C`(?=regexp)\*(C'\fR and the lookbehind
assertion is denoted by \f(CW\*(C`(?<=fixed\-regexp)\*(C'\fR.  Some examples are
.PP
.Vb 8
\&    $x = "I catch the housecat \*(AqTom\-cat\*(Aq with catnip";
\&    $x =~ /cat(?=\es)/;   # matches \*(Aqcat\*(Aq in \*(Aqhousecat\*(Aq
\&    @catwords = ($x =~ /(?<=\es)cat\ew+/g);  # matches,
\&                                           # $catwords[0] = \*(Aqcatch\*(Aq
\&                                           # $catwords[1] = \*(Aqcatnip\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq in \*(AqTom\-cat\*(Aq
\&    $x =~ /(?<=\es)cat(?=\es)/; # doesn\*(Aqt match; no isolated \*(Aqcat\*(Aq in
\&                              # middle of $x
.Ve
.PP
Note that the parentheses in \f(CW\*(C`(?=regexp)\*(C'\fR and \f(CW\*(C`(?<=regexp)\*(C'\fR are
non-capturing, since these are zero-width assertions.  Thus in the
second regexp, the substrings captured are those of the whole regexp
itself.  Lookahead \f(CW\*(C`(?=regexp)\*(C'\fR can match arbitrary regexps, but
lookbehind \f(CW\*(C`(?<=fixed\-regexp)\*(C'\fR only works for regexps of fixed
width, i.e., a fixed number of characters long.  Thus
\&\f(CW\*(C`(?<=(ab|bc))\*(C'\fR is fine, but \f(CW\*(C`(?<=(ab)*)\*(C'\fR is not.  The
negated versions of the lookahead and lookbehind assertions are
denoted by \f(CW\*(C`(?!regexp)\*(C'\fR and \f(CW\*(C`(?<!fixed\-regexp)\*(C'\fR respectively.
They evaluate true if the regexps do \fInot\fR match:
.PP
.Vb 4
\&    $x = "foobar";
\&    $x =~ /foo(?!bar)/;  # doesn\*(Aqt match, \*(Aqbar\*(Aq follows \*(Aqfoo\*(Aq
\&    $x =~ /foo(?!baz)/;  # matches, \*(Aqbaz\*(Aq doesn\*(Aqt follow \*(Aqfoo\*(Aq
\&    $x =~ /(?<!\es)foo/;  # matches, there is no \es before \*(Aqfoo\*(Aq
.Ve
.PP
The \f(CW\*(C`\eC\*(C'\fR is unsupported in lookbehind, because the already
treacherous definition of \f(CW\*(C`\eC\*(C'\fR would become even more so
when going backwards.
.PP
Here is an example where a string containing blank-separated words,
numbers and single dashes is to be split into its components.
Using \f(CW\*(C`/\es+/\*(C'\fR alone won't work, because spaces are not required between
dashes, or a word or a dash. Additional places for a split are established
by looking ahead and behind:
.PP
.Vb 5
\&    $str = "one two \- \-\-6\-8";
\&    @toks = split / \es+              # a run of spaces
\&                  | (?<=\eS) (?=\-)    # any non\-space followed by \*(Aq\-\*(Aq
\&                  | (?<=\-)  (?=\eS)   # a \*(Aq\-\*(Aq followed by any non\-space
\&                  /x, $str;          # @toks = qw(one two \- \- \- 6 \- 8)
.Ve
.SS "Using independent subexpressions to prevent backtracking"
.IX Subsection "Using independent subexpressions to prevent backtracking"
\&\fIIndependent subexpressions\fR are regular expressions, in the
context of a larger regular expression, that function independently of
the larger regular expression.  That is, they consume as much or as
little of the string as they wish without regard for the ability of
the larger regexp to match.  Independent subexpressions are represented
by \f(CW\*(C`(?>regexp)\*(C'\fR.  We can illustrate their behavior by first
considering an ordinary regexp:
.PP
.Vb 2
\&    $x = "ab";
\&    $x =~ /a*ab/;  # matches
.Ve
.PP
This obviously matches, but in the process of matching, the
subexpression \f(CW\*(C`a*\*(C'\fR first grabbed the \f(CW\*(C`a\*(C'\fR.  Doing so, however,
wouldn't allow the whole regexp to match, so after backtracking, \f(CW\*(C`a*\*(C'\fR
eventually gave back the \f(CW\*(C`a\*(C'\fR and matched the empty string.  Here, what
\&\f(CW\*(C`a*\*(C'\fR matched was \fIdependent\fR on what the rest of the regexp matched.
.PP
Contrast that with an independent subexpression:
.PP
.Vb 1
\&    $x =~ /(?>a*)ab/;  # doesn\*(Aqt match!
.Ve
.PP
The independent subexpression \f(CW\*(C`(?>a*)\*(C'\fR doesn't care about the rest
of the regexp, so it sees an \f(CW\*(C`a\*(C'\fR and grabs it.  Then the rest of the
regexp \f(CW\*(C`ab\*(C'\fR cannot match.  Because \f(CW\*(C`(?>a*)\*(C'\fR is independent, there
is no backtracking and the independent subexpression does not give
up its \f(CW\*(C`a\*(C'\fR.  Thus the match of the regexp as a whole fails.  A similar
behavior occurs with completely independent regexps:
.PP
.Vb 3
\&    $x = "ab";
\&    $x =~ /a*/g;   # matches, eats an \*(Aqa\*(Aq
\&    $x =~ /\eGab/g; # doesn\*(Aqt match, no \*(Aqa\*(Aq available
.Ve
.PP
Here \f(CW\*(C`//g\*(C'\fR and \f(CW\*(C`\eG\*(C'\fR create a 'tag team' handoff of the string from
one regexp to the other.  Regexps with an independent subexpression are
much like this, with a handoff of the string to the independent
subexpression, and a handoff of the string back to the enclosing
regexp.
.PP
The ability of an independent subexpression to prevent backtracking
can be quite useful.  Suppose we want to match a non-empty string
enclosed in parentheses up to two levels deep.  Then the following
regexp matches:
.PP
.Vb 2
\&    $x = "abc(de(fg)h";  # unbalanced parentheses
\&    $x =~ /\e( ( [^()]+ | \e([^()]*\e) )+ \e)/x;
.Ve
.PP
The regexp matches an open parenthesis, one or more copies of an
alternation, and a close parenthesis.  The alternation is two-way, with
the first alternative \f(CW\*(C`[^()]+\*(C'\fR matching a substring with no
parentheses and the second alternative \f(CW\*(C`\e([^()]*\e)\*(C'\fR  matching a
substring delimited by parentheses.  The problem with this regexp is
that it is pathological: it has nested indeterminate quantifiers
of the form \f(CW\*(C`(a+|b)+\*(C'\fR.  We discussed in Part 1 how nested quantifiers
like this could take an exponentially long time to execute if there
was no match possible.  To prevent the exponential blowup, we need to
prevent useless backtracking at some point.  This can be done by
enclosing the inner quantifier as an independent subexpression:
.PP
.Vb 1
\&    $x =~ /\e( ( (?>[^()]+) | \e([^()]*\e) )+ \e)/x;
.Ve
.PP
Here, \f(CW\*(C`(?>[^()]+)\*(C'\fR breaks the degeneracy of string partitioning
by gobbling up as much of the string as possible and keeping it.   Then
match failures fail much more quickly.
.SS "Conditional expressions"
.IX Subsection "Conditional expressions"
A \fIconditional expression\fR is a form of if-then-else statement
that allows one to choose which patterns are to be matched, based on
some condition.  There are two types of conditional expression:
\&\f(CW\*(C`(?(condition)yes\-regexp)\*(C'\fR and
\&\f(CW\*(C`(?(condition)yes\-regexp|no\-regexp)\*(C'\fR.  \f(CW\*(C`(?(condition)yes\-regexp)\*(C'\fR is
like an \f(CW\*(Aqif\ ()\ {}\*(Aq\fR statement in Perl.  If the \f(CW\*(C`condition\*(C'\fR is true,
the \f(CW\*(C`yes\-regexp\*(C'\fR will be matched.  If the \f(CW\*(C`condition\*(C'\fR is false, the
\&\f(CW\*(C`yes\-regexp\*(C'\fR will be skipped and Perl will move onto the next regexp
element.  The second form is like an \f(CW\*(Aqif\ ()\ {}\ else\ {}\*(Aq\fR statement
in Perl.  If the \f(CW\*(C`condition\*(C'\fR is true, the \f(CW\*(C`yes\-regexp\*(C'\fR will be
matched, otherwise the \f(CW\*(C`no\-regexp\*(C'\fR will be matched.
.PP
The \f(CW\*(C`condition\*(C'\fR can have several forms.  The first form is simply an
integer in parentheses \f(CW\*(C`(integer)\*(C'\fR.  It is true if the corresponding
backreference \f(CW\*(C`\einteger\*(C'\fR matched earlier in the regexp.  The same
thing can be done with a name associated with a capture group, written
as \f(CW\*(C`(<name>)\*(C'\fR or \f(CW\*(C`(\*(Aqname\*(Aq)\*(C'\fR.  The second form is a bare
zero-width assertion \f(CW\*(C`(?...)\*(C'\fR, either a lookahead, a lookbehind, or a
code assertion (discussed in the next section).  The third set of forms
provides tests that return true if the expression is executed within
a recursion (\f(CW\*(C`(R)\*(C'\fR) or is being called from some capturing group,
referenced either by number (\f(CW\*(C`(R1)\*(C'\fR, \f(CW\*(C`(R2)\*(C'\fR,...) or by name
(\f(CW\*(C`(R&name)\*(C'\fR).
.PP
The integer or name form of the \f(CW\*(C`condition\*(C'\fR allows us to choose,
with more flexibility, what to match based on what matched earlier in the
regexp. This searches for words of the form \f(CW"$x$x"\fR or \f(CW"$x$y$y$x"\fR:
.PP
.Vb 9
\&    % simple_grep \*(Aq^(\ew+)(\ew+)?(?(2)\eg2\eg1|\eg1)$\*(Aq /usr/dict/words
\&    beriberi
\&    coco
\&    couscous
\&    deed
\&    ...
\&    toot
\&    toto
\&    tutu
.Ve
.PP
The lookbehind \f(CW\*(C`condition\*(C'\fR allows, along with backreferences,
an earlier part of the match to influence a later part of the
match.  For instance,
.PP
.Vb 1
\&    /[ATGC]+(?(?<=AA)G|C)$/;
.Ve
.PP
matches a \s-1DNA\s0 sequence such that it either ends in \f(CW\*(C`AAG\*(C'\fR, or some
other base pair combination and \f(CW\*(C`C\*(C'\fR.  Note that the form is
\&\f(CW\*(C`(?(?<=AA)G|C)\*(C'\fR and not \f(CW\*(C`(?((?<=AA))G|C)\*(C'\fR; for the
lookahead, lookbehind or code assertions, the parentheses around the
conditional are not needed.
.SS "Defining named patterns"
.IX Subsection "Defining named patterns"
Some regular expressions use identical subpatterns in several places.
Starting with Perl 5.10, it is possible to define named subpatterns in
a section of the pattern so that they can be called up by name
anywhere in the pattern.  This syntactic pattern for this definition
group is \f(CW\*(C`(?(DEFINE)(?<name>pattern)...)\*(C'\fR.  An insertion
of a named pattern is written as \f(CW\*(C`(?&name)\*(C'\fR.
.PP
The example below illustrates this feature using the pattern for
floating point numbers that was presented earlier on.  The three
subpatterns that are used more than once are the optional sign, the
digit sequence for an integer and the decimal fraction.  The \s-1DEFINE\s0
group at the end of the pattern contains their definition.  Notice
that the decimal fraction pattern is the first place where we can
reuse the integer pattern.
.PP
.Vb 8
\&   /^ (?&osg)\e * ( (?&int)(?&dec)? | (?&dec) )
\&      (?: [eE](?&osg)(?&int) )?
\&    $
\&    (?(DEFINE)
\&      (?<osg>[\-+]?)         # optional sign
\&      (?<int>\ed++)          # integer
\&      (?<dec>\e.(?&int))     # decimal fraction
\&    )/x
.Ve
.SS "Recursive patterns"
.IX Subsection "Recursive patterns"
This feature (introduced in Perl 5.10) significantly extends the
power of Perl's pattern matching.  By referring to some other
capture group anywhere in the pattern with the construct
\&\f(CW\*(C`(?group\-ref)\*(C'\fR, the \fIpattern\fR within the referenced group is used
as an independent subpattern in place of the group reference itself.
Because the group reference may be contained \fIwithin\fR the group it
refers to, it is now possible to apply pattern matching to tasks that
hitherto required a recursive parser.
.PP
To illustrate this feature, we'll design a pattern that matches if
a string contains a palindrome. (This is a word or a sentence that,
while ignoring spaces, interpunctuation and case, reads the same backwards
as forwards. We begin by observing that the empty string or a string
containing just one word character is a palindrome. Otherwise it must
have a word character up front and the same at its end, with another
palindrome in between.
.PP
.Vb 1
\&    /(?: (\ew) (?...Here be a palindrome...) \eg{\-1} | \ew? )/x
.Ve
.PP
Adding \f(CW\*(C`\eW*\*(C'\fR at either end to eliminate what is to be ignored, we already
have the full pattern:
.PP
.Vb 4
\&    my $pp = qr/^(\eW* (?: (\ew) (?1) \eg{\-1} | \ew? ) \eW*)$/ix;
\&    for $s ( "saippuakauppias", "A man, a plan, a canal: Panama!" ){
\&        print "\*(Aq$s\*(Aq is a palindrome\en" if $s =~ /$pp/;
\&    }
.Ve
.PP
In \f(CW\*(C`(?...)\*(C'\fR both absolute and relative backreferences may be used.
The entire pattern can be reinserted with \f(CW\*(C`(?R)\*(C'\fR or \f(CW\*(C`(?0)\*(C'\fR.
If you prefer to name your groups, you can use \f(CW\*(C`(?&name)\*(C'\fR to
recurse into that group.
.SS "A bit of magic: executing Perl code in a regular expression"
.IX Subsection "A bit of magic: executing Perl code in a regular expression"
Normally, regexps are a part of Perl expressions.
\&\fICode evaluation\fR expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp.  A code evaluation
expression is denoted \f(CW\*(C`(?{code})\*(C'\fR, with \fIcode\fR a string of Perl
statements.
.PP
Be warned that this feature is considered experimental, and may be
changed without notice.
.PP
Code expressions are zero-width assertions, and the value they return
depends on their environment.  There are two possibilities: either the
code expression is used as a conditional in a conditional expression
\&\f(CW\*(C`(?(condition)...)\*(C'\fR, or it is not.  If the code expression is a
conditional, the code is evaluated and the result (i.e., the result of
the last statement) is used to determine truth or falsehood.  If the
code expression is not used as a conditional, the assertion always
evaluates true and the result is put into the special variable
\&\f(CW$^R\fR.  The variable \f(CW$^R\fR can then be used in code expressions later
in the regexp.  Here are some silly examples:
.PP
.Vb 5
\&    $x = "abcdef";
\&    $x =~ /abc(?{print "Hi Mom!";})def/; # matches,
\&                                         # prints \*(AqHi Mom!\*(Aq
\&    $x =~ /aaa(?{print "Hi Mom!";})def/; # doesn\*(Aqt match,
\&                                         # no \*(AqHi Mom!\*(Aq
.Ve
.PP
Pay careful attention to the next example:
.PP
.Vb 3
\&    $x =~ /abc(?{print "Hi Mom!";})ddd/; # doesn\*(Aqt match,
\&                                         # no \*(AqHi Mom!\*(Aq
\&                                         # but why not?
.Ve
.PP
At first glance, you'd think that it shouldn't print, because obviously
the \f(CW\*(C`ddd\*(C'\fR isn't going to match the target string. But look at this
example:
.PP
.Vb 2
\&    $x =~ /abc(?{print "Hi Mom!";})[dD]dd/; # doesn\*(Aqt match,
\&                                            # but _does_ print
.Ve
.PP
Hmm. What happened here? If you've been following along, you know that
the above pattern should be effectively (almost) the same as the last one;
enclosing the \f(CW\*(C`d\*(C'\fR in a character class isn't going to change what it
matches. So why does the first not print while the second one does?
.PP
The answer lies in the optimizations the regex engine makes. In the first
case, all the engine sees are plain old characters (aside from the
\&\f(CW\*(C`?{}\*(C'\fR construct). It's smart enough to realize that the string 'ddd'
doesn't occur in our target string before actually running the pattern
through. But in the second case, we've tricked it into thinking that our
pattern is more complicated. It takes a look, sees our
character class, and decides that it will have to actually run the
pattern to determine whether or not it matches, and in the process of
running it hits the print statement before it discovers that we don't
have a match.
.PP
To take a closer look at how the engine does optimizations, see the
section \*(L"Pragmas and debugging\*(R" below.
.PP
More fun with \f(CW\*(C`?{}\*(C'\fR:
.PP
.Vb 6
\&    $x =~ /(?{print "Hi Mom!";})/;       # matches,
\&                                         # prints \*(AqHi Mom!\*(Aq
\&    $x =~ /(?{$c = 1;})(?{print "$c";})/;  # matches,
\&                                           # prints \*(Aq1\*(Aq
\&    $x =~ /(?{$c = 1;})(?{print "$^R";})/; # matches,
\&                                           # prints \*(Aq1\*(Aq
.Ve
.PP
The bit of magic mentioned in the section title occurs when the regexp
backtracks in the process of searching for a match.  If the regexp
backtracks over a code expression and if the variables used within are
localized using \f(CW\*(C`local\*(C'\fR, the changes in the variables produced by the
code expression are undone! Thus, if we wanted to count how many times
a character got matched inside a group, we could use, e.g.,
.PP
.Vb 11
\&    $x = "aaaa";
\&    $count = 0;  # initialize \*(Aqa\*(Aq count
\&    $c = "bob";  # test if $c gets clobbered
\&    $x =~ /(?{local $c = 0;})         # initialize count
\&           ( a                        # match \*(Aqa\*(Aq
\&             (?{local $c = $c + 1;})  # increment count
\&           )*                         # do this any number of times,
\&           aa                         # but match \*(Aqaa\*(Aq at the end
\&           (?{$count = $c;})          # copy local $c var into $count
\&          /x;
\&    print "\*(Aqa\*(Aq count is $count, \e$c variable is \*(Aq$c\*(Aq\en";
.Ve
.PP
This prints
.PP
.Vb 1
\&    \*(Aqa\*(Aq count is 2, $c variable is \*(Aqbob\*(Aq
.Ve
.PP
If we replace the \f(CW\*(C`\ (?{local\ $c\ =\ $c\ +\ 1;})\*(C'\fR with
\&\f(CW\*(C`\ (?{$c\ =\ $c\ +\ 1;})\*(C'\fR, the variable changes are \fInot\fR undone
during backtracking, and we get
.PP
.Vb 1
\&    \*(Aqa\*(Aq count is 4, $c variable is \*(Aqbob\*(Aq
.Ve
.PP
Note that only localized variable changes are undone.  Other side
effects of code expression execution are permanent.  Thus
.PP
.Vb 2
\&    $x = "aaaa";
\&    $x =~ /(a(?{print "Yow\en";}))*aa/;
.Ve
.PP
produces
.PP
.Vb 4
\&   Yow
\&   Yow
\&   Yow
\&   Yow
.Ve
.PP
The result \f(CW$^R\fR is automatically localized, so that it will behave
properly in the presence of backtracking.
.PP
This example uses a code expression in a conditional to match a
definite article, either 'the' in English or 'der|die|das' in German:
.PP
.Vb 11
\&    $lang = \*(AqDE\*(Aq;  # use German
\&    ...
\&    $text = "das";
\&    print "matched\en"
\&        if $text =~ /(?(?{
\&                          $lang eq \*(AqEN\*(Aq; # is the language English?
\&                         })
\&                       the |             # if so, then match \*(Aqthe\*(Aq
\&                       (der|die|das)     # else, match \*(Aqder|die|das\*(Aq
\&                     )
\&                    /xi;
.Ve
.PP
Note that the syntax here is \f(CW\*(C`(?(?{...})yes\-regexp|no\-regexp)\*(C'\fR, not
\&\f(CW\*(C`(?((?{...}))yes\-regexp|no\-regexp)\*(C'\fR.  In other words, in the case of a
code expression, we don't need the extra parentheses around the
conditional.
.PP
If you try to use code expressions where the code text is contained within
an interpolated variable, rather than appearing literally in the pattern,
Perl may surprise you:
.PP
.Vb 5
\&    $bar = 5;
\&    $pat = \*(Aq(?{ 1 })\*(Aq;
\&    /foo(?{ $bar })bar/; # compiles ok, $bar not interpolated
\&    /foo(?{ 1 })$bar/;   # compiles ok, $bar interpolated
\&    /foo${pat}bar/;      # compile error!
\&
\&    $pat = qr/(?{ $foo = 1 })/;  # precompile code regexp
\&    /foo${pat}bar/;      # compiles ok
.Ve
.PP
If a regexp has a variable that interpolates a code expression, Perl
treats the regexp as an error. If the code expression is precompiled into
a variable, however, interpolating is ok. The question is, why is this an
error?
.PP
The reason is that variable interpolation and code expressions
together pose a security risk.  The combination is dangerous because
many programmers who write search engines often take user input and
plug it directly into a regexp:
.PP
.Vb 3
\&    $regexp = <>;       # read user\-supplied regexp
\&    $chomp $regexp;     # get rid of possible newline
\&    $text =~ /$regexp/; # search $text for the $regexp
.Ve
.PP
If the \f(CW$regexp\fR variable contains a code expression, the user could
then execute arbitrary Perl code.  For instance, some joker could
search for \f(CW\*(C`system(\*(Aqrm\ \-rf\ *\*(Aq);\*(C'\fR to erase your files.  In this
sense, the combination of interpolation and code expressions \fItaints\fR
your regexp.  So by default, using both interpolation and code
expressions in the same regexp is not allowed.  If you're not
concerned about malicious users, it is possible to bypass this
security check by invoking \f(CW\*(C`use\ re\ \*(Aqeval\*(Aq\*(C'\fR:
.PP
.Vb 4
\&    use re \*(Aqeval\*(Aq;       # throw caution out the door
\&    $bar = 5;
\&    $pat = \*(Aq(?{ 1 })\*(Aq;
\&    /foo${pat}bar/;      # compiles ok
.Ve
.PP
Another form of code expression is the \fIpattern code expression\fR.
The pattern code expression is like a regular code expression, except
that the result of the code evaluation is treated as a regular
expression and matched immediately.  A simple example is
.PP
.Vb 4
\&    $length = 5;
\&    $char = \*(Aqa\*(Aq;
\&    $x = \*(Aqaaaaabb\*(Aq;
\&    $x =~ /(??{$char x $length})/x; # matches, there are 5 of \*(Aqa\*(Aq
.Ve
.PP
This final example contains both ordinary and pattern code
expressions.  It detects whether a binary string \f(CW1101010010001...\fR has a
Fibonacci spacing 0,1,1,2,3,5,...  of the \f(CW1\fR's:
.PP
.Vb 12
\&    $x = "1101010010001000001";
\&    $z0 = \*(Aq\*(Aq; $z1 = \*(Aq0\*(Aq;   # initial conditions
\&    print "It is a Fibonacci sequence\en"
\&        if $x =~ /^1         # match an initial \*(Aq1\*(Aq
\&                    (?:
\&                       ((??{ $z0 })) # match some \*(Aq0\*(Aq
\&                       1             # and then a \*(Aq1\*(Aq
\&                       (?{ $z0 = $z1; $z1 .= $^N; })
\&                    )+   # repeat as needed
\&                  $      # that is all there is
\&                 /x;
\&    printf "Largest sequence matched was %d\en", length($z1)\-length($z0);
.Ve
.PP
Remember that \f(CW$^N\fR is set to whatever was matched by the last
completed capture group. This prints
.PP
.Vb 2
\&    It is a Fibonacci sequence
\&    Largest sequence matched was 5
.Ve
.PP
Ha! Try that with your garden variety regexp package...
.PP
Note that the variables \f(CW$z0\fR and \f(CW$z1\fR are not substituted when the
regexp is compiled, as happens for ordinary variables outside a code
expression.  Rather, the whole code block is parsed as perl code at the
same time as perl is compiling the code containing the literal regexp
pattern.
.PP
The regexp without the \f(CW\*(C`//x\*(C'\fR modifier is
.PP
.Vb 1
\&    /^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N; }))+$/
.Ve
.PP
which shows that spaces are still possible in the code parts. Nevertheless,
when working with code and conditional expressions, the extended form of
regexps is almost necessary in creating and debugging regexps.
.SS "Backtracking control verbs"
.IX Subsection "Backtracking control verbs"
Perl 5.10 introduced a number of control verbs intended to provide
detailed control over the backtracking process, by directly influencing
the regexp engine and by providing monitoring techniques.  As all
the features in this group are experimental and subject to change or
removal in a future version of Perl, the interested reader is
referred to \*(L"Special Backtracking Control Verbs\*(R" in perlre for a
detailed description.
.PP
Below is just one example, illustrating the control verb \f(CW\*(C`(*FAIL)\*(C'\fR,
which may be abbreviated as \f(CW\*(C`(*F)\*(C'\fR. If this is inserted in a regexp
it will cause it to fail, just as it would at some
mismatch between the pattern and the string. Processing
of the regexp continues as it would after any \*(L"normal\*(R"
failure, so that, for instance, the next position in the string or another
alternative will be tried. As failing to match doesn't preserve capture
groups or produce results, it may be necessary to use this in
combination with embedded code.
.PP
.Vb 4
\&   %count = ();
\&   "supercalifragilisticexpialidocious" =~
\&       /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
\&   printf "%3d \*(Aq%s\*(Aq\en", $count{$_}, $_ for (sort keys %count);
.Ve
.PP
The pattern begins with a class matching a subset of letters.  Whenever
this matches, a statement like \f(CW\*(C`$count{\*(Aqa\*(Aq}++;\*(C'\fR is executed, incrementing
the letter's counter. Then \f(CW\*(C`(*FAIL)\*(C'\fR does what it says, and
the regexp engine proceeds according to the book: as long as the end of
the string hasn't been reached, the position is advanced before looking
for another vowel. Thus, match or no match makes no difference, and the
regexp engine proceeds until the entire string has been inspected.
(It's remarkable that an alternative solution using something like
.PP
.Vb 2
\&   $count{lc($_)}++ for split(\*(Aq\*(Aq, "supercalifragilisticexpialidocious");
\&   printf "%3d \*(Aq%s\*(Aq\en", $count2{$_}, $_ for ( qw{ a e i o u } );
.Ve
.PP
is considerably slower.)
.SS "Pragmas and debugging"
.IX Subsection "Pragmas and debugging"
Speaking of debugging, there are several pragmas available to control
and debug regexps in Perl.  We have already encountered one pragma in
the previous section, \f(CW\*(C`use\ re\ \*(Aqeval\*(Aq;\*(C'\fR, that allows variable
interpolation and code expressions to coexist in a regexp.  The other
pragmas are
.PP
.Vb 3
\&    use re \*(Aqtaint\*(Aq;
\&    $tainted = <>;
\&    @parts = ($tainted =~ /(\ew+)\es+(\ew+)/; # @parts is now tainted
.Ve
.PP
The \f(CW\*(C`taint\*(C'\fR pragma causes any substrings from a match with a tainted
variable to be tainted as well.  This is not normally the case, as
regexps are often used to extract the safe bits from a tainted
variable.  Use \f(CW\*(C`taint\*(C'\fR when you are not extracting safe bits, but are
performing some other processing.  Both \f(CW\*(C`taint\*(C'\fR and \f(CW\*(C`eval\*(C'\fR pragmas
are lexically scoped, which means they are in effect only until
the end of the block enclosing the pragmas.
.PP
.Vb 2
\&    use re \*(Aq/m\*(Aq;  # or any other flags
\&    $multiline_string =~ /^foo/; # /m is implied
.Ve
.PP
The \f(CW\*(C`re \*(Aq/flags\*(Aq\*(C'\fR pragma (introduced in Perl
5.14) turns on the given regular expression flags
until the end of the lexical scope.  See
\&\*(L"'/flags' mode\*(R" in re for more
detail.
.PP
.Vb 2
\&    use re \*(Aqdebug\*(Aq;
\&    /^(.*)$/s;       # output debugging info
\&
\&    use re \*(Aqdebugcolor\*(Aq;
\&    /^(.*)$/s;       # output debugging info in living color
.Ve
.PP
The global \f(CW\*(C`debug\*(C'\fR and \f(CW\*(C`debugcolor\*(C'\fR pragmas allow one to get
detailed debugging info about regexp compilation and
execution.  \f(CW\*(C`debugcolor\*(C'\fR is the same as debug, except the debugging
information is displayed in color on terminals that can display
termcap color sequences.  Here is example output:
.PP
.Vb 10
\&    % perl \-e \*(Aquse re "debug"; "abc" =~ /a*b+c/;\*(Aq
\&    Compiling REx \*(Aqa*b+c\*(Aq
\&    size 9 first at 1
\&       1: STAR(4)
\&       2:   EXACT <a>(0)
\&       4: PLUS(7)
\&       5:   EXACT <b>(0)
\&       7: EXACT <c>(9)
\&       9: END(0)
\&    floating \*(Aqbc\*(Aq at 0..2147483647 (checking floating) minlen 2
\&    Guessing start of match, REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq...
\&    Found floating substr \*(Aqbc\*(Aq at offset 1...
\&    Guessed: match at offset 0
\&    Matching REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq
\&      Setting an EVAL scope, savestack=3
\&       0 <> <abc>             |  1:  STAR
\&                               EXACT <a> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       1 <a> <bc>             |  4:    PLUS
\&                               EXACT <b> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       2 <ab> <c>             |  7:      EXACT <c>
\&       3 <abc> <>             |  9:      END
\&    Match successful!
\&    Freeing REx: \*(Aqa*b+c\*(Aq
.Ve
.PP
If you have gotten this far into the tutorial, you can probably guess
what the different parts of the debugging output tell you.  The first
part
.PP
.Vb 8
\&    Compiling REx \*(Aqa*b+c\*(Aq
\&    size 9 first at 1
\&       1: STAR(4)
\&       2:   EXACT <a>(0)
\&       4: PLUS(7)
\&       5:   EXACT <b>(0)
\&       7: EXACT <c>(9)
\&       9: END(0)
.Ve
.PP
describes the compilation stage.  \f(CWSTAR(4)\fR means that there is a
starred object, in this case \f(CW\*(Aqa\*(Aq\fR, and if it matches, goto line 4,
i.e., \f(CWPLUS(7)\fR.  The middle lines describe some heuristics and
optimizations performed before a match:
.PP
.Vb 4
\&    floating \*(Aqbc\*(Aq at 0..2147483647 (checking floating) minlen 2
\&    Guessing start of match, REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq...
\&    Found floating substr \*(Aqbc\*(Aq at offset 1...
\&    Guessed: match at offset 0
.Ve
.PP
Then the match is executed and the remaining lines describe the
process:
.PP
.Vb 12
\&    Matching REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq
\&      Setting an EVAL scope, savestack=3
\&       0 <> <abc>             |  1:  STAR
\&                               EXACT <a> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       1 <a> <bc>             |  4:    PLUS
\&                               EXACT <b> can match 1 times out of 32767...
\&      Setting an EVAL scope, savestack=3
\&       2 <ab> <c>             |  7:      EXACT <c>
\&       3 <abc> <>             |  9:      END
\&    Match successful!
\&    Freeing REx: \*(Aqa*b+c\*(Aq
.Ve
.PP
Each step is of the form \f(CW\*(C`n\ <x>\ <y>\*(C'\fR, with \f(CW\*(C`<x>\*(C'\fR the
part of the string matched and \f(CW\*(C`<y>\*(C'\fR the part not yet
matched.  The \f(CW\*(C`|\ \ 1:\ \ STAR\*(C'\fR says that Perl is at line number 1
in the compilation list above.  See
\&\*(L"Debugging Regular Expressions\*(R" in perldebguts for much more detail.
.PP
An alternative method of debugging regexps is to embed \f(CW\*(C`print\*(C'\fR
statements within the regexp.  This provides a blow-by-blow account of
the backtracking in an alternation:
.PP
.Vb 12
\&    "that this" =~ m@(?{print "Start at position ", pos, "\en";})
\&                     t(?{print "t1\en";})
\&                     h(?{print "h1\en";})
\&                     i(?{print "i1\en";})
\&                     s(?{print "s1\en";})
\&                         |
\&                     t(?{print "t2\en";})
\&                     h(?{print "h2\en";})
\&                     a(?{print "a2\en";})
\&                     t(?{print "t2\en";})
\&                     (?{print "Done at position ", pos, "\en";})
\&                    @x;
.Ve
.PP
prints
.PP
.Vb 8
\&    Start at position 0
\&    t1
\&    h1
\&    t2
\&    h2
\&    a2
\&    t2
\&    Done at position 4
.Ve
.SH "BUGS"
.IX Header "BUGS"
Code expressions, conditional expressions, and independent expressions
are \fIexperimental\fR.  Don't use them in production code.  Yet.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This is just a tutorial.  For the full story on Perl regular
expressions, see the perlre regular expressions reference page.
.PP
For more information on the matching \f(CW\*(C`m//\*(C'\fR and substitution \f(CW\*(C`s///\*(C'\fR
operators, see \*(L"Regexp Quote-Like Operators\*(R" in perlop.  For
information on the \f(CW\*(C`split\*(C'\fR operation, see \*(L"split\*(R" in perlfunc.
.PP
For an excellent all-around resource on the care and feeding of
regular expressions, see the book \fIMastering Regular Expressions\fR by
Jeffrey Friedl (published by O'Reilly, \s-1ISBN 1556592\-257\-3\s0).
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 2000 Mark Kvale
All rights reserved.
.PP
This document may be distributed under the same terms as Perl itself.
.SS "Acknowledgments"
.IX Subsection "Acknowledgments"
The inspiration for the stop codon \s-1DNA\s0 example came from the \s-1ZIP\s0
code example in chapter 7 of \fIMastering Regular Expressions\fR.
.PP
The author would like to thank Jeff Pinyan, Andrew Johnson, Peter
Haworth, Ronald J Kimball, and Joe Smith for all their helpful
comments.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 643:" 4
.IX Item "Around line 643:"
Expected text after =item, not a number
.IP "Around line 647:" 4
.IX Item "Around line 647:"
Expected text after =item, not a number
.IP "Around line 651:" 4
.IX Item "Around line 651:"
Expected text after =item, not a number
.IP "Around line 657:" 4
.IX Item "Around line 657:"
Expected text after =item, not a number
.IP "Around line 662:" 4
.IX Item "Around line 662:"
Expected text after =item, not a number
.IP "Around line 667:" 4
.IX Item "Around line 667:"
Expected text after =item, not a number
.IP "Around line 671:" 4
.IX Item "Around line 671:"
Expected text after =item, not a number
.IP "Around line 677:" 4
.IX Item "Around line 677:"
Expected text after =item, not a number
.IP "Around line 682:" 4
.IX Item "Around line 682:"
Expected text after =item, not a number
.IP "Around line 1250:" 4
.IX Item "Around line 1250:"
Expected text after =item, not a number
.IP "Around line 1255:" 4
.IX Item "Around line 1255:"
Expected text after =item, not a number
.IP "Around line 1260:" 4
.IX Item "Around line 1260:"
Expected text after =item, not a number
.IP "Around line 1265:" 4
.IX Item "Around line 1265:"
Expected text after =item, not a number
.IP "Around line 1269:" 4
.IX Item "Around line 1269:"
Expected text after =item, not a number
.IP "Around line 1274:" 4
.IX Item "Around line 1274:"
Expected text after =item, not a number
                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlriscos.1                                 0100644 0001750 0001750 00000012514 12566207444 023132  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRISCOS 1"
.TH PERLRISCOS 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlriscos \- Perl version 5 for RISC OS
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document gives instructions for building Perl for \s-1RISC OS.\s0 It is
complicated by the need to cross compile. There is a binary version of
perl available from <http://www.cp15.org/perl/> which you may wish to
use instead of trying to compile it yourself.
.SH "BUILD"
.IX Header "BUILD"
You need an installed and working gccsdk cross compiler
<http://gccsdk.riscos.info/> and \s-1REXEN
\&\s0<http://www.cp15.org/programming/>
.PP
Firstly, copy the source and build a native copy of perl for your host
system.
Then, in the source to be cross compiled:
.IP "1." 4
.Vb 1
\&    $ ./Configure
.Ve
.IP "2." 4
Select the riscos hint file. The default answers for the rest of the
questions are usually sufficient.
.Sp
Note that, if you wish to run Configure non-interactively (see the \s-1INSTALL\s0
document for details), to have it select the correct hint file, you'll
need to provide the argument \-Dhintfile=riscos on the Configure
command-line.
.IP "3." 4
.Vb 1
\&    $ make miniperl
.Ve
.IP "4." 4
This should build miniperl and then fail when it tries to run it.
.IP "5." 4
Copy the miniperl executable from the native build done earlier to
replace the cross compiled miniperl.
.IP "6." 4
.Vb 1
\&    $ make
.Ve
.IP "7." 4
This will use miniperl to complete the rest of the build.
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex Waugh <alex@alexwaugh.com>
                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlriscos5.16.1                             0100644 0001750 0001750 00000012200 12566207423 023431  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRISCOS 1"
.TH PERLRISCOS 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlriscos \- Perl version 5 for RISC OS
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document gives instructions for building Perl for \s-1RISC\s0 \s-1OS\s0. It is
complicated by the need to cross compile. There is a binary version of
perl available from <http://www.cp15.org/perl/> which you may wish to
use instead of trying to compile it yourself.
.SH "BUILD"
.IX Header "BUILD"
You need an installed and working gccsdk cross compiler
<http://gccsdk.riscos.info/> and \s-1REXEN\s0
<http://www.cp15.org/programming/>
.PP
Firstly, copy the source and build a native copy of perl for your host
system.
Then, in the source to be cross compiled:
.IP "1." 4
.Vb 1
\&    $ ./Configure
.Ve
.IP "2." 4
Select the riscos hint file. The default answers for the rest of the
questions are usually sufficient.
.Sp
Note that, if you wish to run Configure non-interactively (see the \s-1INSTALL\s0
document for details), to have it select the correct hint file, you'll
need to provide the argument \-Dhintfile=riscos on the Configure
command-line.
.IP "3." 4
.Vb 1
\&    $ make miniperl
.Ve
.IP "4." 4
This should build miniperl and then fail when it tries to run it.
.IP "5." 4
Copy the miniperl executable from the native build done earlier to
replace the cross compiled miniperl.
.IP "6." 4
.Vb 1
\&    $ make
.Ve
.IP "7." 4
This will use miniperl to complete the rest of the build.
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex Waugh <alex@alexwaugh.com>
                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlriscos5.18.1                             0100644 0001750 0001750 00000012514 12566207444 023446  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R