          if value is not None and value is not noValue:
                return False
        return True


class NoValue(object):
    """Create a singleton instance of NoValue class.

    NoValue object can be used as an initializer on PyASN1 type class
    instantiation to represent ASN.1 type rather than ASN.1 data value.

    No operations other than type comparison can be performed on
    a PyASN1 type object.
    """
    skipMethods = ('__getattribute__', '__getattr__', '__setattr__', '__delattr__',
                   '__class__', '__init__', '__del__', '__new__', '__repr__', 
                   '__qualname__', '__objclass__', 'im_class', '__sizeof__')

    _instance = None

    def __new__(cls):
        if cls._instance is None:
            def getPlug(name):
                def plug(self, *args, **kw):
                    raise error.PyAsn1Error('Uninitialized ASN.1 value ("%s" attribute looked up)' % name)
                return plug

            op_names = [name
                        for typ in (str, int, list, dict)
                        for name in dir(typ)
                        if name not in cls.skipMethods and name.startswith('__') and name.endswith('__') and callable(getattr(typ, name))]

            for name in set(op_names):
                setattr(cls, name, getPlug(name))

            cls._instance = object.__new__(cls)

        return cls._instance

    def __getattr__(self, attr):
        if attr in self.skipMethods:
            raise AttributeError('attribute %s not present' % attr)
        raise error.PyAsn1Error('No value for "%s"' % attr)

    def __repr__(self):
        return '%s()' % self.__class__.__name__

noValue = NoValue()


# Base class for "simple" ASN.1 objects. These are immutable.
class AbstractSimpleAsn1Item(Asn1ItemBase):
    #: Default payload value
    defaultValue = noValue

    def __init__(self, value=noValue, tagSet=None, subtypeSpec=None):
        Asn1ItemBase.__init__(self, tagSet, subtypeSpec)
        if self.isNoValue(value):
            value = self.defaultValue
        if self.isNoValue(value):
            self.__hashedValue = value = noValue
        else:
            value = self.prettyIn(value)
            self._verifySubtypeSpec(value)
            self.__hashedValue = hash(value)
        self._value = value
        self._len = None

    def __repr__(self):
        r = []
        if self._value is not self.defaultValue:
            r.append(self.prettyOut(self._value))
        if self._tagSet is not self.tagSet:
            r.append('tagSet=%r' % (self._tagSet,))
        if self._subtypeSpec is not self.subtypeSpec:
            r.append('subtypeSpec=%r' % (self._subtypeSpec,))
        return '%s(%s)' % (self.__class__.__name__, ', '.join(r))

    def __str__(self):
        return str(self._value)

    def __eq__(self, other):
        return self is other and True or self._value == other

    def __ne__(self, other):
        return self._value != other

    def __lt__(self, other):
        return self._value < other

    def __le__(self, other):
        return self._value <= other

    def __gt__(self, other):
        return self._value > other

    def __ge__(self, other):
        return self._value >= other

    if sys.version_info[0] <= 2:
        def __nonzero__(self):
            return bool(self._value)
    else:
        def __bool__(self):
            return bool(self._value)

    def __hash__(self):
        return self.__hashedValue is noValue and hash(noValue) or self.__hashedValue

    def hasValue(self):
        """Indicate if |ASN.1| object represents ASN.1 value or ASN.1 type.

        The PyASN1 type objects can only participate in types comparison
        and serve as a blueprint for serialization codecs to resolve
        ambiguous types.

        The PyASN1 value objects can additionally participate to most
        of built-in Python operations.

        Returns
        -------
        : :class:`bool`
            :class:`True` if object is ASN.1 value,
            :class:`False` otherwise.

        """
        return self._value is not noValue

    def clone(self, value=noValue, tagSet=None, subtypeSpec=None):
        """Create a copy of a |ASN.1| type or object.

          Any parameters to the *clone()* method will replace corresponding
          properties of the |ASN.1| object.

          Parameters
          ----------
          value: :class:`tuple`, :class:`str` or |ASN.1| object
              Initialization value to pass to new ASN.1 object instead of
              inheriting one from the caller.

          tagSet: :py:class:`~pyasn1.type.tag.TagSet`
              Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

          subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
              Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

          Returns
          -------
          :
              new instance of |ASN.1| type/value
        """
        if self.isNoValue(value):
            if self.isNoValue(tagSet, subtypeSpec):
                return self
            value = self._value
        if tagSet is None:
            tagSet = self._tagSet
        if subtypeSpec is None:
            subtypeSpec = self._subtypeSpec
        return self.__class__(value, tagSet, subtypeSpec)

    def subtype(self, value=noValue, implicitTag=None, explicitTag=None,
                subtypeSpec=None):
        """Create a copy of a |ASN.1| type or object.

         Any parameters to the *subtype()* method will be added to the corresponding
         properties of the |ASN.1| object.

         Parameters
         ----------
         value: :class:`tuple`, :class:`str` or |ASN.1| object
             Initialization value to pass to new ASN.1 object instead of
             inheriting one from the caller.

         implicitTag: :py:class:`~pyasn1.type.tag.Tag`
             Implicitly apply given ASN.1 tag object to caller's
             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
             new object's ASN.1 tag(s).

         explicitTag: :py:class:`~pyasn1.type.tag.Tag`
             Explicitly apply given ASN.1 tag object to caller's
             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
             new object's ASN.1 tag(s).

         subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
             Add ASN.1 constraints object to one of the caller, then
             use the result as new object's ASN.1 constraints.

         Returns
         -------
         :
             new instance of |ASN.1| type/value
        """
        if self.isNoValue(value):
            value = self._value
        if implicitTag is not None:
            tagSet = self._tagSet.tagImplicitly(implicitTag)
        elif explicitTag is not None:
            tagSet = self._tagSet.tagExplicitly(explicitTag)
        else:
            tagSet = self._tagSet
        if subtypeSpec is None:
            subtypeSpec = self._subtypeSpec
        else:
            subtypeSpec = self._subtypeSpec + subtypeSpec
        return self.__class__(value, tagSet, subtypeSpec)

    def prettyIn(self, value):
        return value

    def prettyOut(self, value):
        return str(value)

    def prettyPrint(self, scope=0):
        """Provide human-friendly printable object representation.

        Returns
        -------
        : :class:`str`
            human-friendly type and/or value representation.
        """
        if self.hasValue():
            return self.prettyOut(self._value)
        else:
            return '<no value>'

    # XXX Compatibility stub
    def prettyPrinter(self, scope=0):
        return self.prettyPrint(scope)

    # noinspection PyUnusedLocal
    def prettyPrintType(self, scope=0):
        return '%s -> %s' % (self.getTagSet(), self.__class__.__name__)


#
# Constructed types:
# * There are five of them: Sequence, SequenceOf/SetOf, Set and Choice
# * ASN1 types and values are represened by Python class instances
# * Value initialization is made for defaulted components only
# * Primary method of component addressing is by-position. Data model for base
#   type is Python sequence. Additional type-specific addressing methods
#   may be implemented for particular types.
# * SequenceOf and SetOf types do not implement any additional methods
# * Sequence, Set and Choice types also implement by-identifier addressing
# * Sequence, Set and Choice types also implement by-asn1-type (tag) addressing
# * Sequence and Set types may include optional and defaulted
#   components
# * Constructed types hold a reference to component types used for value
#   verification and ordering.
# * Component type is a scalar type for SequenceOf/SetOf types and a list
#   of types for Sequence/Set/Choice.
#

def setupComponent():
    """Returns a sentinel value.

     Indicates to a constructed type to set up its inner component so that it
     can be referred to. This is useful in situation when you want to populate
     descendants of a constructed type what requires being able to refer to
     their parent types along the way.

     Example
     -------

     >>> constructed['record'] = setupComponent()
     >>> constructed['record']['scalar'] = 42
    """
    return noValue


class AbstractConstructedAsn1Item(Asn1ItemBase):

    #: If `True`, requires exact component type matching,
    #: otherwise subtype relation is only enforced
    strictConstraints = False

    def __init__(self, componentType=None, tagSet=None,
                 subtypeSpec=None, sizeSpec=None):
        Asn1ItemBase.__init__(self, tagSet, subtypeSpec)
        if componentType is None:
            self._componentType = self.componentType
        else:
            self._componentType = componentType
        if sizeSpec is None:
            self._sizeSpec = self.sizeSpec
        else:
            self._sizeSpec = sizeSpec
        self._componentValues = []
        self._componentValuesSet = 0

    def __repr__(self):
        r = []
        if self._componentType is not self.componentType:
            r.append('componentType=%r' % (self._componentType,))
        if self._tagSet is not self.tagSet:
            r.append('tagSet=%r' % (self._tagSet,))
        if self._subtypeSpec is not self.subtypeSpec:
            r.append('subtypeSpec=%r' % (self._subtypeSpec,))
        r = '%s(%s)' % (self.__class__.__name__, ', '.join(r))
        if self._componentValues:
            r += '.setComponents(%s)' % ', '.join([repr(x) for x in self._componentValues])
        return r

    def __eq__(self, other):
        return self is other and True or self._componentValues == other

    def __ne__(self, other):
        return self._componentValues != other

    def __lt__(self, other):
        return self._componentValues < other

    def __le__(self, other):
        return self._componentValues <= other

    def __gt__(self, other):
        return self._componentValues > other

    def __ge__(self, other):
        return self._componentValues >= other

    if sys.version_info[0] <= 2:
        def __nonzero__(self):
            return bool(self._componentValues)
    else:
        def __bool__(self):
            return bool(self._componentValues)

    def getComponentTagMap(self):
        raise error.PyAsn1Error('Method not implemented')

    def _cloneComponentValues(self, myClone, cloneValueFlag):
        pass

    def clone(self, tagSet=None, subtypeSpec=None, sizeSpec=None, cloneValueFlag=None):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing non-default ASN.1 tag(s)

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 subtype constraint(s)

        sizeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 size constraint(s)

        Returns
        -------
        :
            new instance of |ASN.1| type/value

        """
        if tagSet is None:
            tagSet = self._tagSet
        if subtypeSpec is None:
            subtypeSpec = self._subtypeSpec
        if sizeSpec is None:
            sizeSpec = self._sizeSpec
        r = self.__class__(self._componentType, tagSet, subtypeSpec, sizeSpec)
        if cloneValueFlag:
            self._cloneComponentValues(r, cloneValueFlag)
        return r

    def subtype(self, implicitTag=None, explicitTag=None, subtypeSpec=None,
                sizeSpec=None, cloneValueFlag=None):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing non-default ASN.1 tag(s)

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 subtype constraint(s)

        sizeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 size constraint(s)

        Returns
        -------
        :
            new instance of |ASN.1| type/value

        """
        if implicitTag is not None:
            tagSet = self._tagSet.tagImplicitly(implicitTag)
        elif explicitTag is not None:
            tagSet = self._tagSet.tagExplicitly(explicitTag)
        else:
            tagSet = self._tagSet
        if subtypeSpec is None:
            subtypeSpec = self._subtypeSpec
        else:
            subtypeSpec = self._subtypeSpec + subtypeSpec
        if sizeSpec is None:
            sizeSpec = self._sizeSpec
        else:
            sizeSpec = sizeSpec + self._sizeSpec
        r = self.__class__(self._componentType, tagSet, subtypeSpec, sizeSpec)
        if cloneValueFlag:
            self._cloneComponentValues(r, cloneValueFlag)
        return r

    def _verifyComponent(self, idx, value):
        pass

    def verifySizeSpec(self):
        self._sizeSpec(self)

    def getComponentByPosition(self, idx):
        raise error.PyAsn1Error('Method not implemented')

    def setComponentByPosition(self, idx, value, verifyConstraints=True):
        raise error.PyAsn1Error('Method not implemented')

    def setComponents(self, *args, **kwargs):
        for idx, value in enumerate(args):
            self[idx] = value
        for k in kwargs:
            self[k] = kwargs[k]
        return self

    def getComponentType(self):
        return self._componentType

    def setDefaultComponents(self):
        pass

    def __getitem__(self, idx):
        return self.getComponentByPosition(idx)

    def __setitem__(self, idx, value):
        self.setComponentByPosition(idx, value)

    def __len__(self):
        return len(self._componentValues)

    def clear(self):
        self._componentValues = []
        self._componentValuesSet = 0
                                                                                                                             usr/local/lib/python2.7/dist-packages/pyasn1/type/base.pyc                                          0100644 0000000 0000062 00000053216 13077704403 022054  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
 âˇXc           @   sŒ   d  d l  Z  d  d l m Z m Z m Z d  d l m Z d d d d g Z d e f d Ñ  É  YZ	 d e	 f d	 Ñ  É  YZ
 d
 e f d Ñ  É  YZ e É  Z d e
 f d Ñ  É  YZ d Ñ  Z d e
 f d Ñ  É  YZ d S(   iˇˇˇˇN(   t
   constraintt   tagmapt   tag(   t   errort   Asn1Itemt   Asn1ItemBaset   AbstractSimpleAsn1Itemt   AbstractConstructedAsn1Itemc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR      s   c           B   sí   e  Z e j É  Z e j É  Z d	 Z	 d	 d	 d  Ñ Z
 d	 d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e e d Ñ Z e e d Ñ Z e d Ñ  É Z RS(
   c         C   sL   | d  k r |  j |  _ n	 | |  _ | d  k r? |  j |  _ n	 | |  _ d  S(   N(   t   Nonet   tagSett   _tagSett   subtypeSpect   _subtypeSpec(   t   selfR   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __init__   s    	c         C   s`   y |  j  | | É WnE t j k
 r[ t j É  \ } } } | d | |  j j f É Ç n Xd  S(   Ns   %s at %s(   R   R   t   PyAsn1Errort   syst   exc_infot	   __class__R   (   R   t   valuet   idxt   ct   it   t(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   _verifySubtypeSpec(   s
    c         C   s   |  j  S(   N(   R   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   getSubtypeSpec/   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt	   getTagSet2   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   getEffectiveTagSet5   s    c         C   s   t  j i |  |  j 6É S(   N(   R   t   TagMapR   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt	   getTagMap8   s    c         C   sB   |  | k pA | s( |  j  | j É  k oA | pA |  j | j É  k S(   sS  Examine |ASN.1| type for equality with other ASN.1 type.

        ASN.1 tags (:py:mod:`~pyasn1.type.tag`) and constraints
        (:py:mod:`~pyasn1.type.constraint`) are examined when carrying
        out ASN.1 types comparison.

        No Python inheritance relationship between PyASN1 objects is considered.

        Parameters
        ----------
        other: a pyasn1 type object
            Class instance representing ASN.1 type.

        Returns
        -------
        : :class:`bool`
            :class:`True` if *other* is |ASN.1| type,
            :class:`False` otherwise.
        (   R   R   R   R   (   R   t   othert	   matchTagst   matchConstraints(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   isSameTypeWith;   s
    c         C   s<   | s |  j  j | j É  É o; | p; |  j j | j É  É S(   sä  Examine |ASN.1| type for subtype relationship with other ASN.1 type.
        
        ASN.1 tags (:py:mod:`~pyasn1.type.tag`) and constraints
        (:py:mod:`~pyasn1.type.constraint`) are examined when carrying
        out ASN.1 types comparison.

        No Python inheritance relationship between PyASN1 objects is considered.


        Parameters
        ----------
            other: a pyasn1 type object
                Class instance representing ASN.1 type. 

        Returns
        -------
            : :class:`bool`
                :class:`True` if *other* is a subtype of |ASN.1| type,
                :class:`False` otherwise.
        (   R   t   isSuperTagSetOfR   R   t   isSuperTypeOfR   (   R   R    R!   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR%   U   s    c          G   s1   x* |  D]" } | d  k	 r | t k	 r t Sq Wt S(   N(   R
   t   noValuet   Falset   True(   t   valuesR   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt	   isNoValueo   s    N(   R   R	   R   t   TagSetR   R    t   ConstraintsIntersectionR   R
   t   typeIdR   R   R   R   R   R   R(   R#   R%   t   staticmethodR*   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR      s   
				t   NoValuec           B   s5   e  Z d  Z d Z d Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s  Create a singleton instance of NoValue class.

    NoValue object can be used as an initializer on PyASN1 type class
    instantiation to represent ASN.1 type rather than ASN.1 data value.

    No operations other than type comparison can be performed on
    a PyASN1 type object.
    t   __getattribute__t   __getattr__t   __setattr__t   __delattr__R   R   t   __del__t   __new__t   __repr__t   __qualname__t   __objclass__t   im_classt
   __sizeof__c         C   s€   |  j  d  k r‘ d Ñ  } g  t t t t f D]a } t | É D]N } | |  j k r; | j d É r; | j	 d É r; t
 t | | É É r; | ^ q; q+ } x* t | É D] } t |  | | | É É qü Wt j |  É |  _  n  |  j  S(   Nc            s   á  f d Ü  } | S(   Nc            s   t  j d à  É Ç d  S(   Ns4   Uninitialized ASN.1 value ("%s" attribute looked up)(   R   R   (   R   t   argst   kw(   t   name(    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   plugâ   s    (    (   R=   R>   (    (   R=   s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   getPlugà   s    t   __(   t	   _instanceR
   t   strt   intt   listt   dictt   dirt   skipMethodst
   startswitht   endswitht   callablet   getattrt   sett   setattrt   objectR5   (   t   clsR?   t   typR=   t   op_names(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR5   Ü   s    	Qc         C   s9   | |  j  k r" t d | É Ç n  t j d | É Ç d  S(   Ns   attribute %s not presents   No value for "%s"(   RG   t   AttributeErrorR   R   (   R   t   attr(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR1   ô   s    c         C   s   d |  j  j S(   Ns   %s()(   R   R   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR6   û   s    (   s   __getattribute__s   __getattr__s   __setattr__s   __delattr__s	   __class__s   __init__s   __del__s   __new__s   __repr__R7   s   __objclass__s   im_classs
   __sizeof__N(	   R   R	   t   __doc__RG   R
   RA   R5   R1   R6   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR/   w   s     		c           B   sˇ   e  Z e Z e d d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z e j d	 d
 k rÖ d Ñ  Z n	 d Ñ  Z d Ñ  Z d Ñ  Z e d d d Ñ Z e d d d d Ñ Z d Ñ  Z d Ñ  Z d	 d Ñ Z d	 d Ñ Z d	 d Ñ Z RS(   c         C   sé   t  j |  | | É |  j | É r. |  j } n  |  j | É rM t |  _ } n+ |  j | É } |  j | É t | É |  _ | |  _	 d  |  _ d  S(   N(   R   R   R*   t   defaultValueR&   t$   _AbstractSimpleAsn1Item__hashedValuet   prettyInR   t   hasht   _valueR
   t   _len(   R   R   R   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR   ©   s    	c         C   s©   g  } |  j  |  j k	 r4 | j |  j |  j  É É n  |  j |  j k	 r` | j d |  j f É n  |  j |  j k	 rå | j d |  j f É n  d |  j j	 d j
 | É f S(   Ns	   tagSet=%rs   subtypeSpec=%rs   %s(%s)s   , (   RY   RU   t   appendt	   prettyOutR   R   R   R   R   R   t   join(   R   t   r(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR6   ∂   s    c         C   s   t  |  j É S(   N(   RB   RY   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __str__¿   s    c         C   s   |  | k r t  p |  j | k S(   N(   R(   RY   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __eq__√   s    c         C   s   |  j  | k S(   N(   RY   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __ne__∆   s    c         C   s   |  j  | k  S(   N(   RY   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __lt__…   s    c         C   s   |  j  | k S(   N(   RY   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __le__Ã   s    c         C   s   |  j  | k S(   N(   RY   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __gt__œ   s    c         C   s   |  j  | k S(   N(   RY   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __ge__“   s    i    i   c         C   s   t  |  j É S(   N(   t   boolRY   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __nonzero__÷   s    c         C   s   t  |  j É S(   N(   Rf   RY   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __bool__Ÿ   s    c         C   s"   |  j  t k r t t É p! |  j  S(   N(   RV   R&   RX   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __hash__‹   s    c         C   s   |  j  t k	 S(   sÛ  Indicate if |ASN.1| object represents ASN.1 value or ASN.1 type.

        The PyASN1 type objects can only participate in types comparison
        and serve as a blueprint for serialization codecs to resolve
        ambiguous types.

        The PyASN1 value objects can additionally participate to most
        of built-in Python operations.

        Returns
        -------
        : :class:`bool`
            :class:`True` if object is ASN.1 value,
            :class:`False` otherwise.

        (   RY   R&   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   hasValueﬂ   s    c         C   st   |  j  | É r1 |  j  | | É r% |  S|  j } n  | d k rI |  j } n  | d k ra |  j } n  |  j | | | É S(   s_  Create a copy of a |ASN.1| type or object.

          Any parameters to the *clone()* method will replace corresponding
          properties of the |ASN.1| object.

          Parameters
          ----------
          value: :class:`tuple`, :class:`str` or |ASN.1| object
              Initialization value to pass to new ASN.1 object instead of
              inheriting one from the caller.

          tagSet: :py:class:`~pyasn1.type.tag.TagSet`
              Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

          subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
              Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

          Returns
          -------
          :
              new instance of |ASN.1| type/value
        N(   R*   RY   R
   R   R   R   (   R   R   R   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   cloneÚ   s    c         C   sû   |  j  | É r |  j } n  | d k	 r< |  j j | É } n* | d k	 r] |  j j | É } n	 |  j } | d k r~ |  j } n |  j | } |  j | | | É S(   sõ  Create a copy of a |ASN.1| type or object.

         Any parameters to the *subtype()* method will be added to the corresponding
         properties of the |ASN.1| object.

         Parameters
         ----------
         value: :class:`tuple`, :class:`str` or |ASN.1| object
             Initialization value to pass to new ASN.1 object instead of
             inheriting one from the caller.

         implicitTag: :py:class:`~pyasn1.type.tag.Tag`
             Implicitly apply given ASN.1 tag object to caller's
             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
             new object's ASN.1 tag(s).

         explicitTag: :py:class:`~pyasn1.type.tag.Tag`
             Explicitly apply given ASN.1 tag object to caller's
             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
             new object's ASN.1 tag(s).

         subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
             Add ASN.1 constraints object to one of the caller, then
             use the result as new object's ASN.1 constraints.

         Returns
         -------
         :
             new instance of |ASN.1| type/value
        N(   R*   RY   R
   R   t   tagImplicitlyt   tagExplicitlyR   R   (   R   R   t   implicitTagt   explicitTagR   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   subtype  s     	c         C   s   | S(   N(    (   R   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyRW   A  s    c         C   s
   t  | É S(   N(   RB   (   R   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR\   D  s    c         C   s$   |  j  É  r |  j |  j É Sd Sd S(   sµ   Provide human-friendly printable object representation.

        Returns
        -------
        : :class:`str`
            human-friendly type and/or value representation.
        s
   <no value>N(   Rj   R\   RY   (   R   t   scope(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   prettyPrintG  s    c         C   s   |  j  | É S(   N(   Rr   (   R   Rq   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   prettyPrinterU  s    c         C   s   d |  j  É  |  j j f S(   Ns   %s -> %s(   R   R   R   (   R   Rq   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   prettyPrintTypeY  s    N(   R   R	   R&   RU   R
   R   R6   R_   R`   Ra   Rb   Rc   Rd   Re   R   t   version_infoRg   Rh   Ri   Rj   Rk   Rp   RW   R\   Rr   Rs   Rt   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR   •   s.   	
										!	-		c           C   s   t  S(   s´  Returns a sentinel value.

     Indicates to a constructed type to set up its inner component so that it
     can be referred to. This is useful in situation when you want to populate
     descendants of a constructed type what requires being able to refer to
     their parent types along the way.

     Example
     -------

     >>> constructed['record'] = setupComponent()
     >>> constructed['record']['scalar'] = 42
    (   R&   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   setupComponentp  s    c           B   s/  e  Z e Z d d d d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z e j d d	 k r d
 Ñ  Z n	 d Ñ  Z d Ñ  Z d Ñ  Z d d d d d Ñ Z d d d d d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  RS(   c         C   sq   t  j |  | | É | d  k r. |  j |  _ n	 | |  _ | d  k rR |  j |  _ n	 | |  _ g  |  _ d |  _ d  S(   Ni    (	   R   R   R
   t   componentTypet   _componentTypet   sizeSpect	   _sizeSpect   _componentValuest   _componentValuesSet(   R   Rw   R   R   Ry   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR   á  s    			c         C   sÏ   g  } |  j  |  j k	 r2 | j d |  j  f É n  |  j |  j k	 r^ | j d |  j f É n  |  j |  j k	 rä | j d |  j f É n  d |  j j d j	 | É f } |  j
 rË | d d j	 g  |  j
 D] } t | É ^ q» É 7} n  | S(   Ns   componentType=%rs	   tagSet=%rs   subtypeSpec=%rs   %s(%s)s   , s   .setComponents(%s)(   Rx   Rw   R[   R   R   R   R   R   R   R]   R{   t   repr(   R   R^   t   x(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR6   ï  s    	6c         C   s   |  | k r t  p |  j | k S(   N(   R(   R{   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR`   ¢  s    c         C   s   |  j  | k S(   N(   R{   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyRa   •  s    c         C   s   |  j  | k  S(   N(   R{   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyRb   ®  s    c         C   s   |  j  | k S(   N(   R{   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyRc   ´  s    c         C   s   |  j  | k S(   N(   R{   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyRd   Æ  s    c         C   s   |  j  | k S(   N(   R{   (   R   R    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyRe   ±  s    i    i   c         C   s   t  |  j É S(   N(   Rf   R{   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyRg   µ  s    c         C   s   t  |  j É S(   N(   Rf   R{   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyRh   ∏  s    c         C   s   t  j d É Ç d  S(   Ns   Method not implemented(   R   R   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   getComponentTagMapª  s    c         C   s   d  S(   N(    (   R   t   myClonet   cloneValueFlag(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   _cloneComponentValuesæ  s    c         C   sÄ   | d k r |  j } n  | d k r0 |  j } n  | d k rH |  j } n  |  j |  j | | | É } | r| |  j | | É n  | S(   s≈  Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing non-default ASN.1 tag(s)

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 subtype constraint(s)

        sizeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 size constraint(s)

        Returns
        -------
        :
            new instance of |ASN.1| type/value

        N(   R
   R   R   Rz   R   Rx   RÇ   (   R   R   R   Ry   RÅ   R^   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyRk   ¡  s    c         C   sÕ   | d k	 r! |  j j | É } n* | d k	 rB |  j j | É } n	 |  j } | d k rc |  j } n |  j | } | d k rà |  j } n | |  j } |  j |  j | | | É } | r… |  j | | É n  | S(   sœ  Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing non-default ASN.1 tag(s)

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 subtype constraint(s)

        sizeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 size constraint(s)

        Returns
        -------
        :
            new instance of |ASN.1| type/value

        N(	   R
   R   Rl   Rm   R   Rz   R   Rx   RÇ   (   R   Rn   Ro   R   Ry   RÅ   R   R^   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyRp   „  s    	c         C   s   d  S(   N(    (   R   R   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   _verifyComponent  s    c         C   s   |  j  |  É d  S(   N(   Rz   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   verifySizeSpec  s    c         C   s   t  j d É Ç d  S(   Ns   Method not implemented(   R   R   (   R   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   getComponentByPosition  s    c         C   s   t  j d É Ç d  S(   Ns   Method not implemented(   R   R   (   R   R   R   t   verifyConstraints(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   setComponentByPosition  s    c         O   sJ   x$ t  | É D] \ } } | |  | <q Wx | D] } | | |  | <q. W|  S(   N(   t	   enumerate(   R   R;   t   kwargsR   R   t   k(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   setComponents  s
    c         C   s   |  j  S(   N(   Rx   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   getComponentType!  s    c         C   s   d  S(   N(    (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   setDefaultComponents$  s    c         C   s   |  j  | É S(   N(   RÖ   (   R   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __getitem__'  s    c         C   s   |  j  | | É d  S(   N(   Rá   (   R   R   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __setitem__*  s    c         C   s   t  |  j É S(   N(   t   lenR{   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   __len__-  s    c         C   s   g  |  _  d |  _ d  S(   Ni    (   R{   R|   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   clear0  s    	N(!   R   R	   R'   t   strictConstraintsR
   R   R6   R`   Ra   Rb   Rc   Rd   Re   R   Ru   Rg   Rh   R   RÇ   Rk   Rp   RÉ   RÑ   RÖ   R(   Rá   Rã   Rå   Rç   Ré   Rè   Rë   Rí   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyR   Å  s:   										"	*									(   R   t   pyasn1.typeR    R   R   t   pyasn1R   t   __all__RN   R   R   R/   R&   R   Rv   R   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/base.pyt   <module>   s   e*	À	                                                                                                                                                                                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/pyasn1/type/char.py                                           0100644 0000000 0000062 00000026666 13077704400 021722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# This file is part of pyasn1 software.
#
# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>
# License: http://pyasn1.sf.net/license.html
#
import sys
from pyasn1.type import univ, tag
from pyasn1 import error


__all__ = ['NumericString', 'PrintableString', 'TeletexString', 'T61String', 'VideotexString',
           'IA5String', 'GraphicString', 'VisibleString', 'ISO646String',
           'GeneralString', 'UniversalString', 'BMPString', 'UTF8String']

NoValue = univ.NoValue
noValue = univ.noValue


class AbstractCharacterString(univ.OctetString):
    """Creates |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python 2 :class:`unicode` or Python 3 :class:`str`.
    When used in octet-stream context, |ASN.1| type assumes "|encoding|" encoding.

    Parameters
    ----------
    value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object
        unicode object (Python 2) or string (Python 3), alternatively string
        (Python 2) or bytes (Python 3) representing octet-stream of serialized
        unicode string (note `encoding` parameter) or |ASN.1| class instance.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    encoding: :py:class:`str`
        Unicode codec ID to encode/decode :class:`unicode` (Python 2) or
        :class:`str` (Python 3) the payload when |ASN.1| object is used
        in octet-stream context.

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    """

    if sys.version_info[0] <= 2:
        def __str__(self):
            try:
                return self._value.encode(self._encoding)
            except UnicodeEncodeError:
                raise error.PyAsn1Error(
                    'Can\'t encode string \'%s\' with \'%s\' codec' % (self._value, self._encoding)
                )

        def __unicode__(self):
            return unicode(self._value)

        def prettyIn(self, value):
            if isinstance(value, unicode):
                return value
            elif isinstance(value, str):
                try:
                    return value.decode(self._encoding)
                except (LookupError, UnicodeDecodeError):
                    raise error.PyAsn1Error(
                        'Can\'t decode string \'%s\' with \'%s\' codec' % (value, self._encoding)
                    )
            elif isinstance(value, (tuple, list)):
                try:
                    return self.prettyIn(''.join([chr(x) for x in value]))
                except ValueError:
                    raise error.PyAsn1Error(
                        'Bad %s initializer \'%s\'' % (self.__class__.__name__, value)
                    )
            else:
                try:
                    return unicode(value)
                except UnicodeDecodeError:
                    raise error.PyAsn1Error(
                        'Can\'t turn object \'%s\' into unicode' % (value,)
                    )

        def asOctets(self, padding=True):
            return str(self)

        def asNumbers(self, padding=True):
            return tuple([ord(x) for x in str(self)])

    else:
        def __str__(self):
            return str(self._value)

        def __bytes__(self):
            try:
                return self._value.encode(self._encoding)
            except UnicodeEncodeError:
                raise error.PyAsn1Error(
                    'Can\'t encode string \'%s\' with \'%s\' codec' % (self._value, self._encoding)
                )

        def prettyIn(self, value):
            if isinstance(value, str):
                return value
            elif isinstance(value, bytes):
                try:
                    return value.decode(self._encoding)
                except UnicodeDecodeError:
                    raise error.PyAsn1Error(
                        'Can\'t decode string \'%s\' with \'%s\' codec' % (value, self._encoding)
                    )
            elif isinstance(value, (tuple, list)):
                return self.prettyIn(bytes(value))
            else:
                try:
                    return str(value)
                except (UnicodeDecodeError, ValueError):
                    raise error.PyAsn1Error(
                        'Can\'t turn object \'%s\' into unicode' % (value,)
                    )

        def asOctets(self, padding=True):
            return bytes(self)

        def asNumbers(self, padding=True):
            return tuple(bytes(self))

    def prettyOut(self, value):
        return value

    def __reversed__(self):
        return reversed(self._value)

    def clone(self, value=noValue, tagSet=None, subtypeSpec=None,
              encoding=None, binValue=noValue, hexValue=noValue):
        """Creates a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object
            unicode object (Python 2) or string (Python 3), alternatively string
            (Python 2) or bytes (Python 3) representing octet-stream of serialized
            unicode string (note `encoding` parameter) or |ASN.1| class instance.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing non-default ASN.1 tag(s)

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 subtype constraint(s)

        encoding: :py:class:`str`
            Unicode codec ID to encode/decode :py:class:`unicode` (Python 2) or
            :py:class:`str` (Python 3) the payload when |ASN.1| object is used
            in octet-stream context.

        Returns
        -------
        :
            new instance of |ASN.1| type/value

        """
        return univ.OctetString.clone(self, value, tagSet, subtypeSpec, encoding, binValue, hexValue)

    def subtype(self, value=noValue, implicitTag=None, explicitTag=None,
                subtypeSpec=None, encoding=None, binValue=noValue, hexValue=noValue):
        """Creates a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object
            unicode object (Python 2) or string (Python 3), alternatively string
            (Python 2) or bytes (Python 3) representing octet-stream of serialized
            unicode string (note `encoding` parameter) or |ASN.1| class instance.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to caller's
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to caller's
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 subtype constraint(s)

        encoding: :py:class:`str`
            Unicode codec ID to encode/decode :py:class:`unicode` (Python 2) or
            :py:class:`str` (Python 3) the payload when |ASN.1| object is used
            in octet-stream context.

        Returns
        -------
        :
            new instance of |ASN.1| type/value

        """
        return univ.OctetString.subtype(self, value, implicitTag, explicitTag, subtypeSpec, encoding, binValue, hexValue)


class NumericString(AbstractCharacterString):
    __doc__ = AbstractCharacterString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = AbstractCharacterString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 18)
    )
    encoding = 'us-ascii'


class PrintableString(AbstractCharacterString):
    __doc__ = AbstractCharacterString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = AbstractCharacterString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 19)
    )
    encoding = 'us-ascii'


class TeletexString(AbstractCharacterString):
    __doc__ = AbstractCharacterString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = AbstractCharacterString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 20)
    )
    encoding = 'iso-8859-1'


class T61String(TeletexString):
    __doc__ = TeletexString.__doc__


class VideotexString(AbstractCharacterString):
    __doc__ = AbstractCharacterString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = AbstractCharacterString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 21)
    )
    encoding = 'iso-8859-1'


class IA5String(AbstractCharacterString):
    __doc__ = AbstractCharacterString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = AbstractCharacterString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 22)
    )
    encoding = 'us-ascii'


class GraphicString(AbstractCharacterString):
    __doc__ = AbstractCharacterString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = AbstractCharacterString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 25)
    )
    encoding = 'iso-8859-1'


class VisibleString(AbstractCharacterString):
    __doc__ = AbstractCharacterString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = AbstractCharacterString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 26)
    )
    encoding = 'us-ascii'


class ISO646String(VisibleString):
    __doc__ = VisibleString.__doc__


class GeneralString(AbstractCharacterString):
    __doc__ = AbstractCharacterString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = AbstractCharacterString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 27)
    )
    encoding = 'iso-8859-1'


class UniversalString(AbstractCharacterString):
    __doc__ = AbstractCharacterString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = AbstractCharacterString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 28)
    )
    encoding = "utf-32-be"


class BMPString(AbstractCharacterString):
    __doc__ = AbstractCharacterString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = AbstractCharacterString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 30)
    )
    encoding = "utf-16-be"


class UTF8String(AbstractCharacterString):
    __doc__ = AbstractCharacterString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = AbstractCharacterString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12)
    )
    encoding = "utf-8"
                                                                          usr/local/lib/python2.7/dist-packages/pyasn1/type/char.pyc                                          0100644 0000000 0000062 00000027623 13077704403 022062  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
 âˇXc           @   s¨  d  d l  Z  d  d l m Z m Z d  d l m Z d d d d d d	 d
 d d d d d d g Z e j Z e j Z d e j	 f d Ñ  É  YZ
 d e
 f d Ñ  É  YZ d e
 f d Ñ  É  YZ d e
 f d Ñ  É  YZ d e f d Ñ  É  YZ d e
 f d Ñ  É  YZ d	 e
 f d Ñ  É  YZ d
 e
 f d Ñ  É  YZ d e
 f d Ñ  É  YZ d e f d Ñ  É  YZ d e
 f d Ñ  É  YZ d e
 f d Ñ  É  YZ d e
 f d Ñ  É  YZ d e
 f d Ñ  É  YZ d S(    iˇˇˇˇN(   t   univt   tag(   t   errort   NumericStringt   PrintableStringt   TeletexStringt	   T61Stringt   VideotexStringt	   IA5Stringt   GraphicStringt   VisibleStringt   ISO646Stringt   GeneralStringt   UniversalStringt	   BMPStringt
   UTF8Stringt   AbstractCharacterStringc           B   s’   e  Z d  Z e j d d k rU d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ Z	 e d Ñ Z
 n3 d Ñ  Z d	 Ñ  Z d
 Ñ  Z e d Ñ Z	 e d Ñ Z
 d Ñ  Z d Ñ  Z e d d d e e d Ñ Z e d d d d e e d Ñ Z RS(   sp  Creates |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python 2 :class:`unicode` or Python 3 :class:`str`.
    When used in octet-stream context, |ASN.1| type assumes "|encoding|" encoding.

    Parameters
    ----------
    value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object
        unicode object (Python 2) or string (Python 3), alternatively string
        (Python 2) or bytes (Python 3) representing octet-stream of serialized
        unicode string (note `encoding` parameter) or |ASN.1| class instance.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    encoding: :py:class:`str`
        Unicode codec ID to encode/decode :class:`unicode` (Python 2) or
        :class:`str` (Python 3) the payload when |ASN.1| object is used
        in octet-stream context.

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    i    i   c         C   sN   y |  j  j |  j É SWn0 t k
 rI t j d |  j  |  j f É Ç n Xd  S(   Ns(   Can't encode string '%s' with '%s' codec(   t   _valuet   encodet	   _encodingt   UnicodeEncodeErrorR   t   PyAsn1Error(   t   self(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyt   __str__3   s
    c         C   s   t  |  j É S(   N(   t   unicodeR   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyt   __unicode__;   s    c         C   s)  t  | t É r | St  | t É ro y | j |  j É SWq%t t f k
 rk t j d | |  j f É Ç q%Xn∂ t  | t	 t
 f É rÌ y3 |  j d j g  | D] } t | É ^ qö É É SWq%t k
 rÈ t j d |  j j | f É Ç q%Xn8 y t | É SWn' t k
 r$t j d | f É Ç n Xd  S(   Ns(   Can't decode string '%s' with '%s' codect    s   Bad %s initializer '%s's#   Can't turn object '%s' into unicode(   t
   isinstanceR   t   strt   decodeR   t   LookupErrort   UnicodeDecodeErrorR   R   t   tuplet   listt   prettyInt   joint   chrt
   ValueErrort	   __class__t   __name__(   R   t   valuet   x(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR"   >   s&    3 c         C   s
   t  |  É S(   N(   R   (   R   t   padding(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyt   asOctetsW   s    c         C   s)   t  g  t |  É D] } t | É ^ q É S(   N(   R    R   t   ord(   R   R*   R)   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyt	   asNumbersZ   s    c         C   s   t  |  j É S(   N(   R   R   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR   ^   s    c         C   sN   y |  j  j |  j É SWn0 t k
 rI t j d |  j  |  j f É Ç n Xd  S(   Ns(   Can't encode string '%s' with '%s' codec(   R   R   R   R   R   R   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyt	   __bytes__a   s
    c         C   s”   t  | t É r | St  | t É ri y | j |  j É SWqœ t k
 re t j d | |  j f É Ç qœ Xnf t  | t t	 f É rë |  j
 t | É É Sy t | É SWn- t t f k
 rŒ t j d | f É Ç n Xd  S(   Ns(   Can't decode string '%s' with '%s' codecs#   Can't turn object '%s' into unicode(   R   R   t   bytesR   R   R   R   R   R    R!   R"   R%   (   R   R(   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR"   i   s    c         C   s
   t  |  É S(   N(   R/   (   R   R*   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR+   }   s    c         C   s   t  t |  É É S(   N(   R    R/   (   R   R*   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR-   Ä   s    c         C   s   | S(   N(    (   R   R(   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyt	   prettyOutÉ   s    c         C   s   t  |  j É S(   N(   t   reversedR   (   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyt   __reversed__Ü   s    c         C   s"   t  j j |  | | | | | | É S(   s`  Creates a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object
            unicode object (Python 2) or string (Python 3), alternatively string
            (Python 2) or bytes (Python 3) representing octet-stream of serialized
            unicode string (note `encoding` parameter) or |ASN.1| class instance.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing non-default ASN.1 tag(s)

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 subtype constraint(s)

        encoding: :py:class:`str`
            Unicode codec ID to encode/decode :py:class:`unicode` (Python 2) or
            :py:class:`str` (Python 3) the payload when |ASN.1| object is used
            in octet-stream context.

        Returns
        -------
        :
            new instance of |ASN.1| type/value

        (   R    t   OctetStringt   clone(   R   R(   t   tagSett   subtypeSpect   encodingt   binValuet   hexValue(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR4   â   s    c      	   C   s%   t  j j |  | | | | | | | É S(   s»  Creates a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object
            unicode object (Python 2) or string (Python 3), alternatively string
            (Python 2) or bytes (Python 3) representing octet-stream of serialized
            unicode string (note `encoding` parameter) or |ASN.1| class instance.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to caller's
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to caller's
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing non-default ASN.1 subtype constraint(s)

        encoding: :py:class:`str`
            Unicode codec ID to encode/decode :py:class:`unicode` (Python 2) or
            :py:class:`str` (Python 3) the payload when |ASN.1| object is used
            in octet-stream context.

        Returns
        -------
        :
            new instance of |ASN.1| type/value

        (   R    R3   t   subtype(   R   R(   t   implicitTagt   explicitTagR6   R7   R8   R9   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR:   ™   s    &N(   R'   t
   __module__t   __doc__t   syst   version_infoR   R   R"   t   TrueR+   R-   R.   R0   R2   t   noValuet   NoneR4   R:   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR      s$   									 	c           B   s>   e  Z e j Z e j j e j e j e j	 d  É É Z d Z
 RS(   i   s   us-ascii(   R'   R=   R   R>   R5   t   tagImplicitlyR   t   Tagt   tagClassUniversalt   tagFormatSimpleR7   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR   ”   s   		c           B   s>   e  Z e j Z e j j e j e j e j	 d  É É Z d Z
 RS(   i   s   us-ascii(   R'   R=   R   R>   R5   RD   R   RE   RF   RG   R7   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR   ›   s   		c           B   s>   e  Z e j Z e j j e j e j e j	 d  É É Z d Z
 RS(   i   s
   iso-8859-1(   R'   R=   R   R>   R5   RD   R   RE   RF   RG   R7   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR   Á   s   		c           B   s   e  Z e j Z RS(    (   R'   R=   R   R>   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR   Ò   s   c           B   s>   e  Z e j Z e j j e j e j e j	 d  É É Z d Z
 RS(   i   s
   iso-8859-1(   R'   R=   R   R>   R5   RD   R   RE   RF   RG   R7   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR   ı   s   		c           B   s>   e  Z e j Z e j j e j e j e j	 d  É É Z d Z
 RS(   i   s   us-ascii(   R'   R=   R   R>   R5   RD   R   RE   RF   RG   R7   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR   ˇ   s   		c           B   s>   e  Z e j Z e j j e j e j e j	 d  É É Z d Z
 RS(   i   s
   iso-8859-1(   R'   R=   R   R>   R5   RD   R   RE   RF   RG   R7   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR	   	  s   		c           B   s>   e  Z e j Z e j j e j e j e j	 d  É É Z d Z
 RS(   i   s   us-ascii(   R'   R=   R   R>   R5   RD   R   RE   RF   RG   R7   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR
     s   		c           B   s   e  Z e j Z RS(    (   R'   R=   R
   R>   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR     s   c           B   s>   e  Z e j Z e j j e j e j e j	 d  É É Z d Z
 RS(   i   s
   iso-8859-1(   R'   R=   R   R>   R5   RD   R   RE   RF   RG   R7   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR   !  s   		c           B   s>   e  Z e j Z e j j e j e j e j	 d  É É Z d Z
 RS(   i   s	   utf-32-be(   R'   R=   R   R>   R5   RD   R   RE   RF   RG   R7   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR   +  s   		c           B   s>   e  Z e j Z e j j e j e j e j	 d  É É Z d Z
 RS(   i   s	   utf-16-be(   R'   R=   R   R>   R5   RD   R   RE   RF   RG   R7   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR   5  s   		c           B   s>   e  Z e j Z e j j e j e j e j	 d  É É Z d Z
 RS(   i   s   utf-8(   R'   R=   R   R>   R5   RD   R   RE   RF   RG   R7   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyR   ?  s   		(   R?   t   pyasn1.typeR    R   t   pyasn1R   t   __all__t   NoValueRB   R3   R   R   R   R   R   R   R   R	   R
   R   R   R   R   R   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/char.pyt   <module>   s*   		ø









                                                                                                             usr/local/lib/python2.7/dist-packages/pyasn1/type/constraint.py                                     0100644 0000000 0000062 00000016402 13077704400 023154  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# This file is part of pyasn1 software.
#
# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>
# License: http://pyasn1.sf.net/license.html
#
# Original concept and code by Mike C. Fletcher.
#
import sys
from pyasn1.type import error

__all__ = ['SingleValueConstraint', 'ContainedSubtypeConstraint', 'ValueRangeConstraint',
           'ValueSizeConstraint', 'PermittedAlphabetConstraint', 'InnerTypeConstraint',
           'ConstraintsExclusion', 'ConstraintsIntersection', 'ConstraintsUnion']


class AbstractConstraint(object):
    """Abstract base-class for constraint objects

       Constraints should be stored in a simple sequence in the
       namespace of their client Asn1Item sub-classes in cases
       when ASN.1 constraint is define.
    """

    def __init__(self, *values):
        self._valueMap = {}
        self._setValues(values)
        self.__hashedValues = None

    def __call__(self, value, idx=None):
        try:
            self._testValue(value, idx)
        except error.ValueConstraintError:
            raise error.ValueConstraintError(
                '%s failed at: %r' % (self, sys.exc_info()[1])
            )

    def __repr__(self):
        return '%s(%s)' % (
            self.__class__.__name__,
            ', '.join([repr(x) for x in self._values])
        )

    def __eq__(self, other):
        return self is other and True or self._values == other

    def __ne__(self, other):
        return self._values != other

    def __lt__(self, other):
        return self._values < other

    def __le__(self, other):
        return self._values <= other

    def __gt__(self, other):
        return self._values > other

    def __ge__(self, other):
        return self._values >= other

    if sys.version_info[0] <= 2:
        def __nonzero__(self):
            return bool(self._values)
    else:
        def __bool__(self):
            return bool(self._values)

    def __hash__(self):
        if self.__hashedValues is None:
            self.__hashedValues = hash((self.__class__.__name__, self._values))
        return self.__hashedValues

    def _setValues(self, values):
        self._values = values

    def _testValue(self, value, idx):
        raise error.ValueConstraintError(value)

    # Constraints derivation logic
    def getValueMap(self):
        return self._valueMap

    def isSuperTypeOf(self, otherConstraint):
        return self in otherConstraint.getValueMap() or \
               otherConstraint is self or otherConstraint == self

    def isSubTypeOf(self, otherConstraint):
        return otherConstraint in self._valueMap or \
               otherConstraint is self or otherConstraint == self


class SingleValueConstraint(AbstractConstraint):
    """Value must be part of defined values constraint"""

    def _testValue(self, value, idx):
        # XXX index vals for performance?
        if value not in self._values:
            raise error.ValueConstraintError(value)


class ContainedSubtypeConstraint(AbstractConstraint):
    """Value must satisfy all of defined set of constraints"""

    def _testValue(self, value, idx):
        for c in self._values:
            c(value, idx)


class ValueRangeConstraint(AbstractConstraint):
    """Value must be within start and stop values (inclusive)"""

    def _testValue(self, value, idx):
        if value < self.start or value > self.stop:
            raise error.ValueConstraintError(value)

    def _setValues(self, values):
        if len(values) != 2:
            raise error.PyAsn1Error(
                '%s: bad constraint values' % (self.__class__.__name__,)
            )
        self.start, self.stop = values
        if self.start > self.stop:
            raise error.PyAsn1Error(
                '%s: screwed constraint values (start > stop): %s > %s' % (
                    self.__class__.__name__,
                    self.start, self.stop
                )
            )
        AbstractConstraint._setValues(self, values)


class ValueSizeConstraint(ValueRangeConstraint):
    """len(value) must be within start and stop values (inclusive)"""

    def _testValue(self, value, idx):
        l = len(value)
        if l < self.start or l > self.stop:
            raise error.ValueConstraintError(value)


class PermittedAlphabetConstraint(SingleValueConstraint):
    def _setValues(self, values):
        self._values = ()
        for v in values:
            self._values = self._values + tuple(v)

    def _testValue(self, value, idx):
        for v in value:
            if v not in self._values:
                raise error.ValueConstraintError(value)


# This is a bit kludgy, meaning two op modes within a single constraint
class InnerTypeConstraint(AbstractConstraint):
    """Value must satisfy type and presense constraints"""

    def _testValue(self, value, idx):
        if self.__singleTypeConstraint:
            self.__singleTypeConstraint(value)
        elif self.__multipleTypeConstraint:
            if idx not in self.__multipleTypeConstraint:
                raise error.ValueConstraintError(value)
            constraint, status = self.__multipleTypeConstraint[idx]
            if status == 'ABSENT':  # XXX presense is not checked!
                raise error.ValueConstraintError(value)
            constraint(value)

    def _setValues(self, values):
        self.__multipleTypeConstraint = {}
        self.__singleTypeConstraint = None
        for v in values:
            if isinstance(v, tuple):
                self.__multipleTypeConstraint[v[0]] = v[1], v[2]
            else:
                self.__singleTypeConstraint = v
        AbstractConstraint._setValues(self, values)


# Boolean ops on constraints

class ConstraintsExclusion(AbstractConstraint):
    """Value must not fit the single constraint"""

    def _testValue(self, value, idx):
        try:
            self._values[0](value, idx)
        except error.ValueConstraintError:
            return
        else:
            raise error.ValueConstraintError(value)

    def _setValues(self, values):
        if len(values) != 1:
            raise error.PyAsn1Error('Single constraint expected')
        AbstractConstraint._setValues(self, values)


class AbstractConstraintSet(AbstractConstraint):
    """Value must not satisfy the single constraint"""

    def __getitem__(self, idx): return self._values[idx]

    def __add__(self, value): return self.__class__(self, value)

    def __radd__(self, value): return self.__class__(value, self)

    def __len__(self): return len(self._values)

    # Constraints inclusion in sets

    def _setValues(self, values):
        self._values = values
        for v in values:
            self._valueMap[v] = 1
            self._valueMap.update(v.getValueMap())


class ConstraintsIntersection(AbstractConstraintSet):
    """Value must satisfy all constraints"""

    def _testValue(self, value, idx):
        for v in self._values:
            v(value, idx)


class ConstraintsUnion(AbstractConstraintSet):
    """Value must satisfy at least one constraint"""

    def _testValue(self, value, idx):
        for v in self._values:
            try:
                v(value, idx)
            except error.ValueConstraintError:
                pass
            else:
                return
        raise error.ValueConstraintError(
            'all of %s failed for \"%s\"' % (self._values, value)
        )

# XXX
# add tests for type check
                                                                                                                                                                                                                                                              usr/local/lib/python2.7/dist-packages/pyasn1/type/constraint.pyc                                    0100644 0000000 0000062 00000026271 13077704403 023327  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
 âˇXc        	   @   s3  d  d l  Z  d  d l m Z d d d d d d d	 d
 d g	 Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ	 d e f d Ñ  É  YZ
 d e f d Ñ  É  YZ d	 e f d Ñ  É  YZ d e f d Ñ  É  YZ d
 e f d Ñ  É  YZ d e f d Ñ  É  YZ d S(   iˇˇˇˇN(   t   errort   SingleValueConstraintt   ContainedSubtypeConstraintt   ValueRangeConstraintt   ValueSizeConstraintt   PermittedAlphabetConstraintt   InnerTypeConstraintt   ConstraintsExclusiont   ConstraintsIntersectiont   ConstraintsUniont   AbstractConstraintc           B   s¿   e  Z d  Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z e j d
 d k r d Ñ  Z n	 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s◊   Abstract base-class for constraint objects

       Constraints should be stored in a simple sequence in the
       namespace of their client Asn1Item sub-classes in cases
       when ASN.1 constraint is define.
    c         G   s#   i  |  _  |  j | É d  |  _ d  S(   N(   t	   _valueMapt
   _setValuest   Nonet!   _AbstractConstraint__hashedValues(   t   selft   values(    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __init__   s    	c         C   sR   y |  j  | | É Wn7 t j k
 rM t j d |  t j É  d f É Ç n Xd  S(   Ns   %s failed at: %ri   (   t
   _testValueR    t   ValueConstraintErrort   syst   exc_info(   R   t   valuet   idx(    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __call__   s
    c         C   s9   d |  j  j d j g  |  j D] } t | É ^ q É f S(   Ns   %s(%s)s   , (   t	   __class__t   __name__t   joint   _valuest   repr(   R   t   x(    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __repr__&   s    	c         C   s   |  | k r t  p |  j | k S(   N(   t   TrueR   (   R   t   other(    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __eq__,   s    c         C   s   |  j  | k S(   N(   R   (   R   R!   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __ne__/   s    c         C   s   |  j  | k  S(   N(   R   (   R   R!   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __lt__2   s    c         C   s   |  j  | k S(   N(   R   (   R   R!   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __le__5   s    c         C   s   |  j  | k S(   N(   R   (   R   R!   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __gt__8   s    c         C   s   |  j  | k S(   N(   R   (   R   R!   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __ge__;   s    i    i   c         C   s   t  |  j É S(   N(   t   boolR   (   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __nonzero__?   s    c         C   s   t  |  j É S(   N(   R(   R   (   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __bool__B   s    c         C   s7   |  j  d  k r0 t |  j j |  j f É |  _  n  |  j  S(   N(   R   R   t   hashR   R   R   (   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __hash__E   s    !c         C   s   | |  _  d  S(   N(   R   (   R   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   J   s    c         C   s   t  j | É Ç d  S(   N(   R    R   (   R   R   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   M   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   getValueMapQ   s    c         C   s(   |  | j  É  k p' | |  k p' | |  k S(   N(   R-   (   R   t   otherConstraint(    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   isSuperTypeOfT   s    c         C   s%   | |  j  k p$ | |  k p$ | |  k S(   N(   R   (   R   R.   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   isSubTypeOfX   s    N(   R   t
   __module__t   __doc__R   R   R   R   R"   R#   R$   R%   R&   R'   R   t   version_infoR)   R*   R,   R   R   R-   R/   R0   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR
      s&   														c           B   s   e  Z d  Z d Ñ  Z RS(   s/   Value must be part of defined values constraintc         C   s%   | |  j  k r! t j | É Ç n  d  S(   N(   R   R    R   (   R   R   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   `   s    (   R   R1   R2   R   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   ]   s   c           B   s   e  Z d  Z d Ñ  Z RS(   s4   Value must satisfy all of defined set of constraintsc         C   s%   x |  j  D] } | | | É q
 Wd  S(   N(   R   (   R   R   R   t   c(    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   i   s    (   R   R1   R2   R   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   f   s   c           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s6   Value must be within start and stop values (inclusive)c         C   s4   | |  j  k  s | |  j k r0 t j | É Ç n  d  S(   N(   t   startt   stopR    R   (   R   R   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   q   s    c         C   sî   t  | É d k r1 t j d |  j j f É Ç n  | \ |  _ |  _ |  j |  j k rÄ t j d |  j j |  j |  j f É Ç n  t j |  | É d  S(   Ni   s   %s: bad constraint valuess5   %s: screwed constraint values (start > stop): %s > %s(	   t   lenR    t   PyAsn1ErrorR   R   R5   R6   R
   R   (   R   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   u   s    	(   R   R1   R2   R   R   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   n   s   	c           B   s   e  Z d  Z d Ñ  Z RS(   s;   len(value) must be within start and stop values (inclusive)c         C   s@   t  | É } | |  j k  s* | |  j k r< t j | É Ç n  d  S(   N(   R7   R5   R6   R    R   (   R   R   R   t   l(    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   à   s    (   R   R1   R2   R   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   Ö   s   c           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s4   d |  _  x$ | D] } |  j  t | É |  _  q Wd  S(   N(    (   R   t   tuple(   R   R   t   v(    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   è   s    	c         C   s6   x/ | D]' } | |  j  k r t j | É Ç q q Wd  S(   N(   R   R    R   (   R   R   R   R;   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   î   s    (   R   R1   R   R   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   é   s   	c           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s0   Value must satisfy type and presense constraintsc         C   sÖ   |  j  r |  j  | É nh |  j rÅ | |  j k rC t j | É Ç n  |  j | \ } } | d k rt t j | É Ç n  | | É n  d  S(   Nt   ABSENT(   t*   _InnerTypeConstraint__singleTypeConstraintt,   _InnerTypeConstraint__multipleTypeConstraintR    R   (   R   R   R   t
   constraintt   status(    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   û   s    		c         C   sq   i  |  _  d  |  _ xH | D]@ } t | t É rP | d | d f |  j  | d <q | |  _ q Wt j |  | É d  S(   Ni   i   i    (   R>   R   R=   t
   isinstanceR:   R
   R   (   R   R   R;   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   ©   s    		"(   R   R1   R2   R   R   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   õ   s   	c           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s(   Value must not fit the single constraintc         C   sC   y |  j  d | | É Wn t j k
 r/ d  SXt j | É Ç d  S(   Ni    (   R   R    R   (   R   R   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   π   s
    c         C   s8   t  | É d k r$ t j d É Ç n  t j |  | É d  S(   Ni   s   Single constraint expected(   R7   R    R8   R
   R   (   R   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   ¡   s    (   R   R1   R2   R   R   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   ∂   s   	t   AbstractConstraintSetc           B   s;   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s,   Value must not satisfy the single constraintc         C   s   |  j  | S(   N(   R   (   R   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __getitem__    s    c         C   s   |  j  |  | É S(   N(   R   (   R   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __add__Ã   s    c         C   s   |  j  | |  É S(   N(   R   (   R   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __radd__Œ   s    c         C   s   t  |  j É S(   N(   R7   R   (   R   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   __len__–   s    c         C   sA   | |  _  x1 | D]) } d |  j | <|  j j | j É  É q Wd  S(   Ni   (   R   R   t   updateR-   (   R   R   R;   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   ‘   s    	(   R   R1   R2   RC   RD   RE   RF   R   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyRB   «   s   				c           B   s   e  Z d  Z d Ñ  Z RS(   s"   Value must satisfy all constraintsc         C   s%   x |  j  D] } | | | É q
 Wd  S(   N(   R   (   R   R   R   R;   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   ﬁ   s    (   R   R1   R2   R   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   €   s   c           B   s   e  Z d  Z d Ñ  Z RS(   s*   Value must satisfy at least one constraintc         C   s`   x= |  j  D]2 } y | | | É Wn t j k
 r7 q
 Xd  Sq
 Wt j d |  j  | f É Ç d  S(   Ns   all of %s failed for "%s"(   R   R    R   (   R   R   R   R;   (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR   Ê   s    (   R   R1   R2   R   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyR	   „   s   (   R   t   pyasn1.typeR    t   __all__t   objectR
   R   R   R   R   R   R   R   RB   R   R	   (    (    (    s6   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/constraint.pyt   <module>	   s   		L		                                                                                                                                                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/pyasn1/type/error.py                                          0100644 0000000 0000062 00000000360 13077704400 022115  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# This file is part of pyasn1 software.
#
# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>
# License: http://pyasn1.sf.net/license.html
#
from pyasn1.error import PyAsn1Error


class ValueConstraintError(PyAsn1Error):
    pass
                                                                                                                                                                                                                                                                                usr/local/lib/python2.7/dist-packages/pyasn1/type/error.pyc                                         0100644 0000000 0000062 00000000627 13077704403 022271  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
 âˇXc           @   s*   d  d l  m Z d e f d Ñ  É  YZ d S(   iˇˇˇˇ(   t   PyAsn1Errort   ValueConstraintErrorc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s1   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/error.pyR   
   s   N(   t   pyasn1.errorR    R   (    (    (    s1   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/error.pyt   <module>   s                                                                                                            usr/local/lib/python2.7/dist-packages/pyasn1/type/namedtype.py                                      0100644 0000000 0000062 00000015122 13077704400 022754  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# This file is part of pyasn1 software.
#
# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>
# License: http://pyasn1.sf.net/license.html
#
import sys
from pyasn1.type import tagmap
from pyasn1.compat import octets
from pyasn1 import error

__all__ = ['NamedType', 'OptionalNamedType', 'DefaultedNamedType', 'NamedTypes']


class NamedType(object):
    """Named type specification for constructed types
    """
    isOptional = 0
    isDefaulted = 0

    def __init__(self, name, t):
        self.__name = name
        self.__type = t

    def __repr__(self):
        return '%s(%r, %r)' % (
            self.__class__.__name__, self.__name, self.__type
        )

    def __eq__(self, other):
        return tuple(self) == tuple(other)

    def __ne__(self, other):
        return tuple(self) != tuple(other)

    def __lt__(self, other):
        return tuple(self) < tuple(other)

    def __le__(self, other):
        return tuple(self) <= tuple(other)

    def __gt__(self, other):
        return tuple(self) > tuple(other)

    def __ge__(self, other):
        return tuple(self) >= tuple(other)

    def __hash__(self):
        return hash(tuple(self))

    def getType(self):
        return self.__type

    def getName(self):
        return self.__name

    def __getitem__(self, idx):
        if idx == 0:
            return self.__name
        if idx == 1:
            return self.__type
        raise IndexError()


class OptionalNamedType(NamedType):
    isOptional = 1


class DefaultedNamedType(NamedType):
    isDefaulted = 1


class NamedTypes(object):
    def __init__(self, *namedTypes):
        self.__namedTypes = namedTypes
        self.__namedTypesLen = len(self.__namedTypes)
        self.__minTagSet = None
        self.__tagToPosIdx = {}
        self.__nameToPosIdx = {}
        self.__tagMap = {False: None, True: None}
        self.__ambigiousTypes = {}

    def __repr__(self):
        return '%s(%s)' % (
            self.__class__.__name__,
            ', '.join([repr(x) for x in self.__namedTypes])
        )

    def __eq__(self, other):
        return tuple(self) == tuple(other)

    def __ne__(self, other):
        return tuple(self) != tuple(other)

    def __lt__(self, other):
        return tuple(self) < tuple(other)

    def __le__(self, other):
        return tuple(self) <= tuple(other)

    def __gt__(self, other):
        return tuple(self) > tuple(other)

    def __ge__(self, other):
        return tuple(self) >= tuple(other)

    def __hash__(self):
        return hash(tuple(self))

    def __getitem__(self, idx):
        if octets.isStringType(idx):
            nameToPosIdx = self.__getNameToPosIdx()
            return self.__namedTypes[nameToPosIdx[idx]]
        else:
            return self.__namedTypes[idx]

    def __contains__(self, key):
        nameToPosIdx = self.__getNameToPosIdx()
        return key in nameToPosIdx

    def __iter__(self):
        return (x[0] for x in self.__namedTypes)

    if sys.version_info[0] <= 2:
        def __nonzero__(self):
            return bool(self.__namedTypesLen)
    else:
        def __bool__(self):
            return bool(self.__namedTypesLen)

    def __len__(self):
        return self.__namedTypesLen

    def clone(self):
        return self.__class__(*self.__namedTypes)

    def getTypeByPosition(self, idx):
        if idx < 0 or idx >= self.__namedTypesLen:
            raise error.PyAsn1Error('Type position out of range')
        else:
            return self.__namedTypes[idx].getType()

    def getPositionByType(self, tagSet):
        if not self.__tagToPosIdx:
            idx = self.__namedTypesLen
            while idx > 0:
                idx -= 1
                tagMap = self.__namedTypes[idx].getType().getTagMap() or tagmap.TagMap()
                for t in tagMap.getPosMap():
                    if t in self.__tagToPosIdx:
                        raise error.PyAsn1Error('Duplicate type %s' % (t,))
                    self.__tagToPosIdx[t] = idx
        try:
            return self.__tagToPosIdx[tagSet]
        except KeyError:
            raise error.PyAsn1Error('Type %s not found' % (tagSet,))

    def getNameByPosition(self, idx):
        try:
            return self.__namedTypes[idx].getName()
        except IndexError:
            raise error.PyAsn1Error('Type position out of range')

    def __getNameToPosIdx(self):
        if not self.__nameToPosIdx:
            idx = self.__namedTypesLen
            while idx > 0:
                idx -= 1
                n = self.__namedTypes[idx].getName()
                if n in self.__nameToPosIdx:
                    raise error.PyAsn1Error('Duplicate name %s' % (n,))
                self.__nameToPosIdx[n] = idx
        return self.__nameToPosIdx

    def getPositionByName(self, name):
        nameToPosIdx = self.__getNameToPosIdx()

        try:
            return nameToPosIdx[name]
        except KeyError:
            raise error.PyAsn1Error('Name %s not found' % (name,))

    def __buildAmbigiousTagMap(self):
        ambigiousTypes = ()
        idx = self.__namedTypesLen
        while idx > 0:
            idx -= 1
            t = self.__namedTypes[idx]
            if t.isOptional or t.isDefaulted:
                ambigiousTypes = (t,) + ambigiousTypes
            else:
                ambigiousTypes = (t,)
            self.__ambigiousTypes[idx] = NamedTypes(*ambigiousTypes)

    def getTagMapNearPosition(self, idx):
        if not self.__ambigiousTypes:
            self.__buildAmbigiousTagMap()
        try:
            return self.__ambigiousTypes[idx].getTagMap()
        except KeyError:
            raise error.PyAsn1Error('Type position out of range')

    def getPositionNearType(self, tagSet, idx):
        if not self.__ambigiousTypes:
            self.__buildAmbigiousTagMap()
        try:
            return idx + self.__ambigiousTypes[idx].getPositionByType(tagSet)
        except KeyError:
            raise error.PyAsn1Error('Type position out of range')

    def genMinTagSet(self):
        if self.__minTagSet is None:
            for t in self.__namedTypes:
                __type = t.getType()
                tagSet = getattr(__type, 'getMinTagSet', __type.getTagSet)()
                if self.__minTagSet is None or tagSet < self.__minTagSet:
                    self.__minTagSet = tagSet
        return self.__minTagSet

    def getTagMap(self, uniq=False):
        if self.__tagMap[uniq] is None:
            tagMap = tagmap.TagMap()
            for nt in self.__namedTypes:
                tagMap = tagMap.clone(
                    nt.getType(), nt.getType().getTagMap() or tagmap.TagMap(), uniq
                )
            self.__tagMap[uniq] = tagMap
        return self.__tagMap[uniq]
                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/local/lib/python2.7/dist-packages/pyasn1/type/namedtype.pyc                                     0100644 0000000 0000062 00000025071 13077704403 023126  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
 âˇXc           @   s™   d  d l  Z  d  d l m Z d  d l m Z d  d l m Z d d d d g Z d e f d	 Ñ  É  YZ	 d e	 f d
 Ñ  É  YZ
 d e	 f d Ñ  É  YZ d e f d Ñ  É  YZ d S(   iˇˇˇˇN(   t   tagmap(   t   octets(   t   errort	   NamedTypet   OptionalNamedTypet   DefaultedNamedTypet
   NamedTypesc           B   sÜ   e  Z d  Z d Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s3   Named type specification for constructed types
    i    c         C   s   | |  _  | |  _ d  S(   N(   t   _NamedType__namet   _NamedType__type(   t   selft   namet   t(    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __init__   s    	c         C   s   d |  j  j |  j |  j f S(   Ns
   %s(%r, %r)(   t	   __class__t   __name__R   R   (   R	   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __repr__   s    c         C   s   t  |  É t  | É k S(   N(   t   tuple(   R	   t   other(    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __eq__   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __ne__!   s    c         C   s   t  |  É t  | É k  S(   N(   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __lt__$   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __le__'   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __gt__*   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __ge__-   s    c         C   s   t  t |  É É S(   N(   t   hashR   (   R	   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __hash__0   s    c         C   s   |  j  S(   N(   R   (   R	   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   getType3   s    c         C   s   |  j  S(   N(   R   (   R	   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   getName6   s    c         C   s3   | d k r |  j  S| d k r& |  j St É  Ç d  S(   Ni    i   (   R   R   t
   IndexError(   R	   t   idx(    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __getitem__9   s
    (   R   t
   __module__t   __doc__t
   isOptionalt   isDefaultedR   R   R   R   R   R   R   R   R   R   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR      s   											c           B   s   e  Z d  Z RS(   i   (   R   R   R!   (    (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   A   s   c           B   s   e  Z d  Z RS(   i   (   R   R   R"   (    (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   E   s   c           B   s  e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z e j d d k rë d Ñ  Z n	 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ Z RS(   c         G   sZ   | |  _  t |  j  É |  _ d  |  _ i  |  _ i  |  _ i d  t 6d  t 6|  _	 i  |  _
 d  S(   N(   t   _NamedTypes__namedTypest   lent   _NamedTypes__namedTypesLent   Nonet   _NamedTypes__minTagSett   _NamedTypes__tagToPosIdxt   _NamedTypes__nameToPosIdxt   Falset   Truet   _NamedTypes__tagMapt   _NamedTypes__ambigiousTypes(   R	   t
   namedTypes(    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   J   s    				c         C   s9   d |  j  j d j g  |  j D] } t | É ^ q É f S(   Ns   %s(%s)s   , (   R   R   t   joinR#   t   repr(   R	   t   x(    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   S   s    	c         C   s   t  |  É t  | É k S(   N(   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   Y   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   \   s    c         C   s   t  |  É t  | É k  S(   N(   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   _   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   b   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   e   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   h   s    c         C   s   t  t |  É É S(   N(   R   R   (   R	   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   k   s    c         C   s9   t  j | É r* |  j É  } |  j | | S|  j | Sd  S(   N(   R   t   isStringTypet   _NamedTypes__getNameToPosIdxR#   (   R	   R   t   nameToPosIdx(    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   n   s    c         C   s   |  j  É  } | | k S(   N(   R3   (   R	   t   keyR4   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __contains__u   s    c         C   s   d Ñ  |  j  DÉ S(   Nc         s   s   |  ] } | d  Vq d S(   i    N(    (   t   .0R1   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pys	   <genexpr>z   s    (   R#   (   R	   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __iter__y   s    i    i   c         C   s   t  |  j É S(   N(   t   boolR%   (   R	   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __nonzero__}   s    c         C   s   t  |  j É S(   N(   R9   R%   (   R	   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __bool__Ä   s    c         C   s   |  j  S(   N(   R%   (   R	   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __len__É   s    c         C   s   |  j  |  j å  S(   N(   R   R#   (   R	   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   cloneÜ   s    c         C   sB   | d k  s | |  j  k r- t j d É Ç n |  j | j É  Sd  S(   Ni    s   Type position out of range(   R%   R   t   PyAsn1ErrorR#   R   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   getTypeByPositionâ   s    c         C   s‡   |  j  s£ |  j } xé | d k rü | d 8} |  j | j É  j É  pM t j É  } xI | j É  D]; } | |  j  k rã t j	 d | f É Ç n  | |  j  | <q] Wq Wn  y |  j  | SWn' t
 k
 r€ t j	 d | f É Ç n Xd  S(   Ni    i   s   Duplicate type %ss   Type %s not found(   R(   R%   R#   R   t	   getTagMapR    t   TagMapt	   getPosMapR   R>   t   KeyError(   R	   t   tagSetR   t   tagMapR   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   getPositionByTypeè   s    		
%c         C   s<   y |  j  | j É  SWn  t k
 r7 t j d É Ç n Xd  S(   Ns   Type position out of range(   R#   R   R   R   R>   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   getNameByPositionû   s    c         C   sÅ   |  j  sz |  j } xe | d k rv | d 8} |  j | j É  } | |  j  k rf t j d | f É Ç n  | |  j  | <q Wn  |  j  S(   Ni    i   s   Duplicate name %s(   R)   R%   R#   R   R   R>   (   R	   R   t   n(    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __getNameToPosIdx§   s    		
c         C   sF   |  j  É  } y | | SWn' t k
 rA t j d | f É Ç n Xd  S(   Ns   Name %s not found(   R3   RC   R   R>   (   R	   R
   R4   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   getPositionByNameØ   s
    c         C   s{   d } |  j  } xe | d k rv | d 8} |  j | } | j sG | j rW | f | } n	 | f } t | å  |  j | <q Wd  S(   Ni    i   (    (   R%   R#   R!   R"   R   R-   (   R	   t   ambigiousTypesR   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   __buildAmbigiousTagMap∑   s    	
	c         C   sR   |  j  s |  j É  n  y |  j  | j É  SWn  t k
 rM t j d É Ç n Xd  S(   Ns   Type position out of range(   R-   t!   _NamedTypes__buildAmbigiousTagMapR@   RC   R   R>   (   R	   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   getTagMapNearPosition√   s    	c         C   sY   |  j  s |  j É  n  y | |  j  | j | É SWn  t k
 rT t j d É Ç n Xd  S(   Ns   Type position out of range(   R-   RM   RF   RC   R   R>   (   R	   RD   R   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   getPositionNearTypeÀ   s    	c         C   s{   |  j  d  k rt xb |  j D]T } | j É  } t | d | j É É  } |  j  d  k sa | |  j  k  r | |  _  q q Wn  |  j  S(   Nt   getMinTagSet(   R'   R&   R#   R   t   getattrt	   getTagSet(   R	   R   t   _NamedTypes__typeRD   (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   genMinTagSet”   s    c         C   sÅ   |  j  | d  k rv t j É  } xD |  j D]9 } | j | j É  | j É  j É  pY t j É  | É } q) W| |  j  | <n  |  j  | S(   N(   R,   R&   R    RA   R#   R=   R   R@   (   R	   t   uniqRE   t   nt(    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR@   ‹   s    1(   R   R   R   R   R   R   R   R   R   R   R   R   R6   R8   t   syst   version_infoR:   R;   R<   R=   R?   RF   RG   R3   RJ   RM   RN   RO   RT   R*   R@   (    (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyR   I   s6   																										(   RW   t   pyasn1.typeR    t   pyasn1.compatR   t   pyasn1R   t   __all__t   objectR   R   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedtype.pyt   <module>   s   2                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/pyasn1/type/namedval.py                                       0100644 0000000 0000062 00000004514 13077704400 022560  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# This file is part of pyasn1 software.
#
# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>
# License: http://pyasn1.sf.net/license.html
#
# ASN.1 named integers
#
from pyasn1 import error

__all__ = ['NamedValues']


class NamedValues(object):
    def __init__(self, *namedValues):
        self.nameToValIdx = {}
        self.valToNameIdx = {}
        self.namedValues = ()
        automaticVal = 1
        for namedValue in namedValues:
            if isinstance(namedValue, tuple):
                name, val = namedValue
            else:
                name = namedValue
                val = automaticVal
            if name in self.nameToValIdx:
                raise error.PyAsn1Error('Duplicate name %s' % (name,))
            self.nameToValIdx[name] = val
            if val in self.valToNameIdx:
                raise error.PyAsn1Error('Duplicate value %s=%s' % (name, val))
            self.valToNameIdx[val] = name
            self.namedValues = self.namedValues + ((name, val),)
            automaticVal += 1

    def __repr__(self):
        return '%s(%s)' % (self.__class__.__name__, ', '.join([repr(x) for x in self.namedValues]))

    def __str__(self):
        return str(self.namedValues)

    def __eq__(self, other):
        return tuple(self) == tuple(other)

    def __ne__(self, other):
        return tuple(self) != tuple(other)

    def __lt__(self, other):
        return tuple(self) < tuple(other)

    def __le__(self, other):
        return tuple(self) <= tuple(other)

    def __gt__(self, other):
        return tuple(self) > tuple(other)

    def __ge__(self, other):
        return tuple(self) >= tuple(other)

    def __hash__(self):
        return hash(tuple(self))

    def getName(self, value):
        if value in self.valToNameIdx:
            return self.valToNameIdx[value]

    def getValue(self, name):
        if name in self.nameToValIdx:
            return self.nameToValIdx[name]

    def __getitem__(self, i):
        return self.namedValues[i]

    def __len__(self):
        return len(self.namedValues)

    def __add__(self, namedValues):
        return self.__class__(*self.namedValues + namedValues)

    def __radd__(self, namedValues):
        return self.__class__(*namedValues + tuple(self))

    def clone(self, *namedValues):
        return self.__class__(*tuple(self) + namedValues)

# XXX clone/subtype?
                                                                                                                                                                                    usr/local/lib/python2.7/dist-packages/pyasn1/type/namedval.pyc                                      0100644 0000000 0000062 00000007742 13077704403 022734  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
 âˇXc           @   s3   d  d l  m Z d g Z d e f d Ñ  É  YZ d S(   iˇˇˇˇ(   t   errort   NamedValuesc           B   s°   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         G   s   i  |  _  i  |  _ d |  _ d } x» | D]¿ } t | t É rL | \ } } n | } | } | |  j  k rÄ t j d | f É Ç n  | |  j  | <| |  j k r∏ t j d | | f É Ç n  | |  j | <|  j | | f f |  _ | d 7} q( Wd  S(   Ni   s   Duplicate name %ss   Duplicate value %s=%s(    (   t   nameToValIdxt   valToNameIdxt   namedValuest
   isinstancet   tupleR    t   PyAsn1Error(   t   selfR   t   automaticValt
   namedValuet   namet   val(    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __init__   s"    			c         C   s9   d |  j  j d j g  |  j D] } t | É ^ q É f S(   Ns   %s(%s)s   , (   t	   __class__t   __name__t   joinR   t   repr(   R   t   x(    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __repr__#   s    c         C   s   t  |  j É S(   N(   t   strR   (   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __str__&   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R   t   other(    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __eq__)   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __ne__,   s    c         C   s   t  |  É t  | É k  S(   N(   R   (   R   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __lt__/   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __le__2   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __gt__5   s    c         C   s   t  |  É t  | É k S(   N(   R   (   R   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __ge__8   s    c         C   s   t  t |  É É S(   N(   t   hashR   (   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __hash__;   s    c         C   s   | |  j  k r |  j  | Sd  S(   N(   R   (   R   t   value(    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   getName>   s    c         C   s   | |  j  k r |  j  | Sd  S(   N(   R   (   R   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   getValueB   s    c         C   s   |  j  | S(   N(   R   (   R   t   i(    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __getitem__F   s    c         C   s   t  |  j É S(   N(   t   lenR   (   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __len__I   s    c         C   s   |  j  |  j | å  S(   N(   R   R   (   R   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __add__L   s    c         C   s   |  j  | t |  É å  S(   N(   R   R   (   R   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   __radd__O   s    c         G   s   |  j  t |  É | å  S(   N(   R   R   (   R   R   (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   cloneR   s    (   R   t
   __module__R   R   R   R   R   R   R   R   R   R   R    R!   R#   R%   R&   R'   R(   (    (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyR      s"   																N(   t   pyasn1R    t   __all__t   objectR   (    (    (    s4   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/namedval.pyt   <module>	   s   	                              usr/local/lib/python2.7/dist-packages/pyasn1/type/tag.py                                            0100644 0000000 0000062 00000011730 13077704400 021542  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# This file is part of pyasn1 software.
#
# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>
# License: http://pyasn1.sf.net/license.html
#
from operator import getitem
from pyasn1 import error

__all__ = ['tagClassUniversal', 'tagClassApplication', 'tagClassContext',
           'tagClassPrivate', 'tagFormatSimple', 'tagFormatConstructed',
           'tagCategoryImplicit', 'tagCategoryExplicit', 'tagCategoryUntagged',
           'Tag', 'TagSet']

tagClassUniversal = 0x00
tagClassApplication = 0x40
tagClassContext = 0x80
tagClassPrivate = 0xC0

tagFormatSimple = 0x00
tagFormatConstructed = 0x20

tagCategoryImplicit = 0x01
tagCategoryExplicit = 0x02
tagCategoryUntagged = 0x04


class Tag(object):
    """ASN.1 types tags"""

    def __init__(self, tagClass, tagFormat, tagId):
        if tagId < 0:
            raise error.PyAsn1Error(
                'Negative tag ID (%s) not allowed' % (tagId,)
            )
        self.__tag = (tagClass, tagFormat, tagId)
        self.uniq = (tagClass, tagId)
        self.__hashedUniqTag = hash(self.uniq)

    def __str__(self):
        return '[%s:%s:%s]' % self.__tag

    def __repr__(self):
        return '%s(tagClass=%s, tagFormat=%s, tagId=%s)' % (
            (self.__class__.__name__,) + self.__tag
        )

    # These is really a hotspot -- expose public "uniq" attribute to save on
    # function calls
    def __eq__(self, other):
        return self.uniq == other.uniq

    def __ne__(self, other):
        return self.uniq != other.uniq

    def __lt__(self, other):
        return self.uniq < other.uniq

    def __le__(self, other):
        return self.uniq <= other.uniq

    def __gt__(self, other):
        return self.uniq > other.uniq

    def __ge__(self, other):
        return self.uniq >= other.uniq

    def __hash__(self):
        return self.__hashedUniqTag

    def __getitem__(self, idx):
        return self.__tag[idx]

    def __and__(self, otherTag):
        (tagClass, tagFormat, tagId) = otherTag
        return self.__class__(
            self.__tag & tagClass, self.__tag & tagFormat, self.__tag & tagId
        )

    def __or__(self, otherTag):
        (tagClass, tagFormat, tagId) = otherTag
        return self.__class__(
            self.__tag[0] | tagClass,
            self.__tag[1] | tagFormat,
            self.__tag[2] | tagId
        )

    def asTuple(self):
        return self.__tag  # __getitem__() is slow


class TagSet(object):
    def __init__(self, baseTag=(), *superTags):
        self.__baseTag = baseTag
        self.__superTags = superTags
        self.__hashedSuperTags = hash(superTags)
        _uniq = ()
        for t in superTags:
            _uniq = _uniq + t.uniq
        self.uniq = _uniq
        self.__lenOfSuperTags = len(superTags)

    def __str__(self):
        return self.__superTags and '+'.join([str(x) for x in self.__superTags]) or '[untagged]'

    def __repr__(self):
        return '%s(%s)' % (
            self.__class__.__name__,
            '(), ' + ', '.join([repr(x) for x in self.__superTags])
        )

    def __add__(self, superTag):
        return self.__class__(
            self.__baseTag, *self.__superTags + (superTag,)
        )

    def __radd__(self, superTag):
        return self.__class__(
            self.__baseTag, *(superTag,) + self.__superTags
        )

    def tagExplicitly(self, superTag):
        tagClass, tagFormat, tagId = superTag
        if tagClass == tagClassUniversal:
            raise error.PyAsn1Error(
                'Can\'t tag with UNIVERSAL-class tag'
            )
        if tagFormat != tagFormatConstructed:
            superTag = Tag(tagClass, tagFormatConstructed, tagId)
        return self + superTag

    def tagImplicitly(self, superTag):
        tagClass, tagFormat, tagId = superTag
        if self.__superTags:
            superTag = Tag(tagClass, self.__superTags[-1][1], tagId)
        return self[:-1] + superTag

    def getBaseTag(self):
        return self.__baseTag

    def __getitem__(self, idx):
        if isinstance(idx, slice):
            return self.__class__(
                self.__baseTag, *getitem(self.__superTags, idx)
            )
        return self.__superTags[idx]

    def __eq__(self, other):
        return self.uniq == other.uniq

    def __ne__(self, other):
        return self.uniq != other.uniq

    def __lt__(self, other):
        return self.uniq < other.uniq

    def __le__(self, other):
        return self.uniq <= other.uniq

    def __gt__(self, other):
        return self.uniq > other.uniq

    def __ge__(self, other):
        return self.uniq >= other.uniq

    def __hash__(self):
        return self.__hashedSuperTags

    def __len__(self):
        return self.__lenOfSuperTags

    def isSuperTagSetOf(self, tagSet):
        if len(tagSet) < self.__lenOfSuperTags:
            return False
        idx = self.__lenOfSuperTags - 1
        while idx >= 0:
            if self.__superTags[idx] != tagSet[idx]:
                return
            idx -= 1
        return True


def initTagSet(tag):
    return TagSet(tag, tag)
                                        usr/local/lib/python2.7/dist-packages/pyasn1/type/tag.pyc                                           0100644 0000000 0000062 00000017502 13077704403 021713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
 âˇXc           @   s∂   d  d l  m Z d  d l m Z d d d d d d d	 d
 d d d g Z d Z d Z d Z d Z d Z	 d Z
 d Z d Z d Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d Ñ  Z d S(   iˇˇˇˇ(   t   getitem(   t   errort   tagClassUniversalt   tagClassApplicationt   tagClassContextt   tagClassPrivatet   tagFormatSimplet   tagFormatConstructedt   tagCategoryImplicitt   tagCategoryExplicitt   tagCategoryUntaggedt   Tagt   TagSeti    i@   iÄ   i¿   i    i   i   i   c           B   så   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s   ASN.1 types tagsc         C   s\   | d k  r% t  j d | f É Ç n  | | | f |  _ | | f |  _ t |  j É |  _ d  S(   Ni    s    Negative tag ID (%s) not allowed(   R   t   PyAsn1Errort	   _Tag__tagt   uniqt   hasht   _Tag__hashedUniqTag(   t   selft   tagClasst	   tagFormatt   tagId(    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __init__   s    c         C   s   d |  j  S(   Ns
   [%s:%s:%s](   R   (   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __str__(   s    c         C   s   d |  j  j f |  j S(   Ns'   %s(tagClass=%s, tagFormat=%s, tagId=%s)(   t	   __class__t   __name__R   (   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __repr__+   s    c         C   s   |  j  | j  k S(   N(   R   (   R   t   other(    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __eq__2   s    c         C   s   |  j  | j  k S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __ne__5   s    c         C   s   |  j  | j  k  S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __lt__8   s    c         C   s   |  j  | j  k S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __le__;   s    c         C   s   |  j  | j  k S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __gt__>   s    c         C   s   |  j  | j  k S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __ge__A   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __hash__D   s    c         C   s   |  j  | S(   N(   R   (   R   t   idx(    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __getitem__G   s    c         C   s7   | \ } } } |  j  |  j | @|  j | @|  j | @É S(   N(   R   R   (   R   t   otherTagR   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __and__J   s    c         C   sC   | \ } } } |  j  |  j d | B|  j d | B|  j d | BÉ S(   Ni    i   i   (   R   R   (   R   R%   R   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __or__P   s
    c         C   s   |  j  S(   N(   R   (   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   asTupleX   s    (   R   t
   __module__t   __doc__R   R   R   R   R   R   R   R    R!   R"   R$   R&   R'   R(   (    (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR      s   														c           B   s≠   e  Z d d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         G   sa   | |  _  | |  _ t | É |  _ d } x | D] } | | j } q. W| |  _ t | É |  _ d  S(   N(    (   t   _TagSet__baseTagt   _TagSet__superTagsR   t   _TagSet__hashedSuperTagsR   t   lent   _TagSet__lenOfSuperTags(   R   t   baseTagt	   superTagst   _uniqt   t(    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR   ]   s    			c         C   s8   |  j  r4 d j g  |  j  D] } t | É ^ q É p7 d S(   Nt   +s
   [untagged](   R,   t   joint   str(   R   t   x(    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR   g   s    c         C   s=   d |  j  j d d j g  |  j D] } t | É ^ q É f S(   Ns   %s(%s)s   (), s   , (   R   R   R5   R,   t   repr(   R   R7   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR   j   s    	c         C   s   |  j  |  j |  j | f å S(   N(   R   R+   R,   (   R   t   superTag(    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __add__p   s    c         C   s   |  j  |  j | f |  j å S(   N(   R   R+   R,   (   R   R9   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __radd__u   s    c         C   sV   | \ } } } | t  k r- t j d É Ç n  | t k rN t | t | É } n  |  | S(   Ns"   Can't tag with UNIVERSAL-class tag(   R   R   R   R   R   (   R   R9   R   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   tagExplicitlyz   s    c         C   sD   | \ } } } |  j  r8 t | |  j  d d | É } n  |  d  | S(   Niˇˇˇˇi   (   R,   R   (   R   R9   R   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   tagImplicitlyÑ   s    	 c         C   s   |  j  S(   N(   R+   (   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt
   getBaseTagä   s    c         C   s9   t  | t É r. |  j |  j t |  j | É å S|  j | S(   N(   t
   isinstancet   sliceR   R+   R    R,   (   R   R#   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR$   ç   s    c         C   s   |  j  | j  k S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR   î   s    c         C   s   |  j  | j  k S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR   ó   s    c         C   s   |  j  | j  k  S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR   ö   s    c         C   s   |  j  | j  k S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR   ù   s    c         C   s   |  j  | j  k S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR    †   s    c         C   s   |  j  | j  k S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR!   £   s    c         C   s   |  j  S(   N(   R-   (   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR"   ¶   s    c         C   s   |  j  S(   N(   R/   (   R   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   __len__©   s    c         C   sb   t  | É |  j k  r t S|  j d } x5 | d k r] |  j | | | k rP d  S| d 8} q) Wt S(   Ni   i    (   R.   R/   t   FalseR,   t   True(   R   t   tagSetR#   (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   isSuperTagSetOf¨   s    (    (   R   R)   R   R   R   R:   R;   R<   R=   R>   R$   R   R   R   R   R    R!   R"   RA   RE   (    (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyR   \   s$   
					
											c         C   s   t  |  |  É S(   N(   R   (   t   tag(    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt
   initTagSet∑   s    N(   t   operatorR    t   pyasn1R   t   __all__R   R   R   R   R   R   R   R	   R
   t   objectR   R   RG   (    (    (    s/   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tag.pyt   <module>   s"   			@[                                                                                                                                                                                              usr/local/lib/python2.7/dist-packages/pyasn1/type/tagmap.py                                         0100644 0000000 0000062 00000005031 13077704400 022235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# This file is part of pyasn1 software.
#
# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>
# License: http://pyasn1.sf.net/license.html
#
from pyasn1 import error

__all__ = ['TagMap']


class TagMap(object):
    # noinspection PyDefaultArgument
    def __init__(self, posMap={}, negMap={}, defType=None):
        self.__posMap = posMap.copy()
        self.__negMap = negMap.copy()
        self.__defType = defType

    def __contains__(self, tagSet):
        return tagSet in self.__posMap or \
               self.__defType is not None and tagSet not in self.__negMap

    def __getitem__(self, tagSet):
        if tagSet in self.__posMap:
            return self.__posMap[tagSet]
        elif tagSet in self.__negMap:
            raise error.PyAsn1Error('Key in negative map')
        elif self.__defType is not None:
            return self.__defType
        else:
            raise KeyError()

    def __repr__(self):
        s = self.__class__.__name__ + '('
        if self.__posMap:
            s += 'posMap=%r, ' % (self.__posMap,)
        if self.__negMap:
            s += 'negMap=%r, ' % (self.__negMap,)
        if self.__defType is not None:
            s += 'defType=%r' % (self.__defType,)
        return s + ')'

    def __str__(self):
        s = self.__class__.__name__ + ':\n'
        if self.__posMap:
            s += 'posMap:\n%s, ' % ',\n '.join([x.prettyPrintType() for x in self.__posMap.values()])
        if self.__negMap:
            s += 'negMap:\n%s, ' % ',\n '.join([x.prettyPrintType() for x in self.__negMap.values()])
        if self.__defType is not None:
            s += 'defType:\n%s, ' % self.__defType.prettyPrintType()
        return s

    def clone(self, parentType, tagMap, uniq=False):
        if self.__defType is not None and tagMap.getDef() is not None:
            raise error.PyAsn1Error('Duplicate default value at %s' % (self,))
        if tagMap.getDef() is not None:
            defType = tagMap.getDef()
        else:
            defType = self.__defType

        posMap = self.__posMap.copy()
        for k in tagMap.getPosMap():
            if uniq and k in posMap:
                raise error.PyAsn1Error('Duplicate positive key %s' % (k,))
            posMap[k] = parentType

        negMap = self.__negMap.copy()
        negMap.update(tagMap.getNegMap())

        return self.__class__(
            posMap, negMap, defType,
        )

    def getPosMap(self):
        return self.__posMap.copy()

    def getNegMap(self):
        return self.__negMap.copy()

    def getDef(self):
        return self.__defType
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/pyasn1/type/tagmap.pyc                                        0100644 0000000 0000062 00000006371 13077704403 022413  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
 âˇXc           @   s3   d  d l  m Z d g Z d e f d Ñ  É  YZ d S(   iˇˇˇˇ(   t   errort   TagMapc           B   se   e  Z i  i  d	 d  Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z RS(
   c         C   s+   | j  É  |  _ | j  É  |  _ | |  _ d  S(   N(   t   copyt   _TagMap__posMapt   _TagMap__negMapt   _TagMap__defType(   t   selft   posMapt   negMapt   defType(    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tagmap.pyt   __init__   s    c         C   s+   | |  j  k p* |  j d  k	 o* | |  j k S(   N(   R   R   t   NoneR   (   R   t   tagSet(    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tagmap.pyt   __contains__   s    c         C   s^   | |  j  k r |  j  | S| |  j k r; t j d É Ç n |  j d  k	 rQ |  j St É  Ç d  S(   Ns   Key in negative map(   R   R   R    t   PyAsn1ErrorR   R   t   KeyError(   R   R   (    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tagmap.pyt   __getitem__   s    c         C   s~   |  j  j d } |  j r0 | d |  j f 7} n  |  j rP | d |  j f 7} n  |  j d  k	 rv | d |  j f 7} n  | d S(   Nt   (s   posMap=%r, s   negMap=%r, s
   defType=%rt   )(   t	   __class__t   __name__R   R   R   R   (   R   t   s(    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tagmap.pyt   __repr__!   s    		c         C   s«   |  j  j d } |  j rU | d d j g  |  j j É  D] } | j É  ^ q5 É 7} n  |  j rö | d d j g  |  j j É  D] } | j É  ^ qz É 7} n  |  j d  k	 r√ | d |  j j É  7} n  | S(   Ns   :
s   posMap:
%s, s   ,
 s   negMap:
%s, s   defType:
%s, (	   R   R   R   t   joint   valuest   prettyPrintTypeR   R   R   (   R   R   t   x(    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tagmap.pyt   __str__+   s    	<	<c         C   sÙ   |  j  d  k	 r: | j É  d  k	 r: t j d |  f É Ç n  | j É  d  k	 r[ | j É  } n	 |  j  } |  j j É  } xI | j É  D]; } | r± | | k r± t j d | f É Ç n  | | | <qÄ W|  j j É  } | j	 | j
 É  É |  j | | | É S(   Ns   Duplicate default value at %ss   Duplicate positive key %s(   R   R   t   getDefR    R   R   R   t	   getPosMapR   t   updatet	   getNegMapR   (   R   t
   parentTypet   tagMapt   uniqR	   R   t   kR   (    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tagmap.pyt   clone5   s    !	c         C   s   |  j  j É  S(   N(   R   R   (   R   (    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tagmap.pyR   J   s    c         C   s   |  j  j É  S(   N(   R   R   (   R   (    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tagmap.pyR   M   s    c         C   s   |  j  S(   N(   R   (   R   (    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tagmap.pyR   P   s    N(   R   t
   __module__R   R
   R   R   R   R   t   FalseR$   R   R   R   (    (    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tagmap.pyR      s   		
	
	
		N(   t   pyasn1R    t   __all__t   objectR   (    (    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/tagmap.pyt   <module>   s   	                                                                                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/pyasn1/type/univ.py                                           0100644 0000000 0000062 00000254630 13077704400 021760  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# This file is part of pyasn1 software.
#
# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>
# License: http://pyasn1.sf.net/license.html
#
import operator
import sys
import math
from pyasn1.type import base, tag, constraint, namedtype, namedval, tagmap
from pyasn1.codec.ber import eoo
from pyasn1.compat import octets, integer, binary
from pyasn1 import error

NoValue = base.NoValue
noValue = NoValue()

__all__ = ['Integer', 'Boolean', 'BitString', 'OctetString', 'Null',
           'ObjectIdentifier', 'Real', 'Enumerated', 'SequenceOfAndSetOfBase', 'SequenceOf',
           'SetOf', 'SequenceAndSetBase', 'Sequence', 'Set', 'Choice', 'Any',
           'NoValue', 'noValue']

# "Simple" ASN.1 types (yet incomplete)

class Integer(base.AbstractSimpleAsn1Item):
    """Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python :class:`int` objects.

    Parameters
    ----------
    value : :class:`int`, :class:`str` or |ASN.1| object
        Python integer or string literal or |ASN.1| class instance.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
        Object representing non-default symbolic aliases for numbers

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    """
    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x02)
    )
    baseTagSet = tagSet

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on initialization values.
    subtypeSpec = constraint.ConstraintsIntersection()

    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object
    #: representing symbolic aliases for numbers
    namedValues = namedval.NamedValues()

    def __init__(self, value=noValue, tagSet=None, subtypeSpec=None,
                 namedValues=None):
        if namedValues is None:
            self.__namedValues = self.namedValues
        else:
            self.__namedValues = namedValues
        base.AbstractSimpleAsn1Item.__init__(
            self, value, tagSet, subtypeSpec
        )

    def __repr__(self):
        if self.__namedValues is not self.namedValues:
            return '%s, %r)' % (base.AbstractSimpleAsn1Item.__repr__(self)[:-1], self.__namedValues)
        else:
            return base.AbstractSimpleAsn1Item.__repr__(self)

    def __and__(self, value):
        return self.clone(self._value & value)

    def __rand__(self, value):
        return self.clone(value & self._value)

    def __or__(self, value):
        return self.clone(self._value | value)

    def __ror__(self, value):
        return self.clone(value | self._value)

    def __xor__(self, value):
        return self.clone(self._value ^ value)

    def __rxor__(self, value):
        return self.clone(value ^ self._value)

    def __lshift__(self, value):
        return self.clone(self._value << value)

    def __rshift__(self, value):
        return self.clone(self._value >> value)

    def __add__(self, value):
        return self.clone(self._value + value)

    def __radd__(self, value):
        return self.clone(value + self._value)

    def __sub__(self, value):
        return self.clone(self._value - value)

    def __rsub__(self, value):
        return self.clone(value - self._value)

    def __mul__(self, value):
        return self.clone(self._value * value)

    def __rmul__(self, value):
        return self.clone(value * self._value)

    def __mod__(self, value):
        return self.clone(self._value % value)

    def __rmod__(self, value):
        return self.clone(value % self._value)

    def __pow__(self, value, modulo=None):
        return self.clone(pow(self._value, value, modulo))

    def __rpow__(self, value):
        return self.clone(pow(value, self._value))

    def __floordiv__(self, value):
        return self.clone(self._value // value)

    def __rfloordiv__(self, value):
        return self.clone(value // self._value)

    if sys.version_info[0] <= 2:
        def __div__(self, value):
            if isinstance(value, float):
                return Real(self._value / value)
            else:
                return self.clone(self._value / value)

        def __rdiv__(self, value):
            if isinstance(value, float):
                return Real(value / self._value)
            else:
                return self.clone(value / self._value)
    else:
        def __truediv__(self, value):
            return Real(self._value / value)

        def __rtruediv__(self, value):
            return Real(value / self._value)

        def __divmod__(self, value):
            return self.clone(divmod(self._value, value))

        def __rdivmod__(self, value):
            return self.clone(divmod(value, self._value))

        __hash__ = base.AbstractSimpleAsn1Item.__hash__

    def __int__(self):
        return int(self._value)

    if sys.version_info[0] <= 2:
        def __long__(self): return long(self._value)

    def __float__(self):
        return float(self._value)

    def __abs__(self):
        return self.clone(abs(self._value))

    def __index__(self):
        return int(self._value)

    def __pos__(self):
        return self.clone(+self._value)

    def __neg__(self):
        return self.clone(-self._value)

    def __invert__(self):
        return self.clone(~self._value)

    def __round__(self, n=0):
        r = round(self._value, n)
        if n:
            return self.clone(r)
        else:
            return r

    def __floor__(self):
        return math.floor(self._value)

    def __ceil__(self):
        return math.ceil(self._value)

    if sys.version_info[0:2] > (2, 5):
        def __trunc__(self): return self.clone(math.trunc(self._value))

    def __lt__(self, value):
        return self._value < value

    def __le__(self, value):
        return self._value <= value

    def __eq__(self, value):
        return self._value == value

    def __ne__(self, value):
        return self._value != value

    def __gt__(self, value):
        return self._value > value

    def __ge__(self, value):
        return self._value >= value

    def prettyIn(self, value):
        if not octets.isStringType(value):
            try:
                return int(value)
            except:
                raise error.PyAsn1Error(
                    'Can\'t coerce %r into integer: %s' % (value, sys.exc_info()[1])
                )
        r = self.__namedValues.getValue(value)
        if r is not None:
            return r
        try:
            return int(value)
        except:
            raise error.PyAsn1Error(
                'Can\'t coerce %r into integer: %s' % (value, sys.exc_info()[1])
            )

    def prettyOut(self, value):
        r = self.__namedValues.getName(value)
        return r is None and str(value) or repr(r)

    def getNamedValues(self):
        return self.__namedValues

    def clone(self, value=noValue, tagSet=None, subtypeSpec=None, namedValues=None):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`int`, :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

        namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
            Object representing symbolic aliases for numbers to use instead of inheriting from caller

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        """
        if self.isNoValue(value):
            if self.isNoValue(tagSet, subtypeSpec, namedValues):
                return self
            value = self._value
        if tagSet is None:
            tagSet = self._tagSet
        if subtypeSpec is None:
            subtypeSpec = self._subtypeSpec
        if namedValues is None:
            namedValues = self.__namedValues
        return self.__class__(value, tagSet, subtypeSpec, namedValues)

    def subtype(self, value=noValue, implicitTag=None, explicitTag=None,
                subtypeSpec=None, namedValues=None):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`int`, :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of 
            inheriting one from the caller.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Add ASN.1 constraints object to one of the caller, then
            use the result as new object's ASN.1 constraints.

        namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
            Add given object representing symbolic aliases for numbers
            to one of the caller, then use the result as new object's
            named numbers.

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        """
        if self.isNoValue(value):
            value = self._value
        if implicitTag is not None:
            tagSet = self._tagSet.tagImplicitly(implicitTag)
        elif explicitTag is not None:
            tagSet = self._tagSet.tagExplicitly(explicitTag)
        else:
            tagSet = self._tagSet
        if subtypeSpec is None:
            subtypeSpec = self._subtypeSpec
        else:
            subtypeSpec = self._subtypeSpec + subtypeSpec
        if namedValues is None:
            namedValues = self.__namedValues
        else:
            namedValues = namedValues + self.__namedValues
        return self.__class__(value, tagSet, subtypeSpec, namedValues)


class Boolean(Integer):
    __doc__ = Integer.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x01),
    )
    baseTagSet = tagSet

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on initialization values.
    subtypeSpec = Integer.subtypeSpec + constraint.SingleValueConstraint(0, 1)

    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object
    #: representing symbolic aliases for numbers
    namedValues = Integer.namedValues.clone(('False', 0), ('True', 1))


class BitString(base.AbstractSimpleAsn1Item):
    """Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type both Python :class:`tuple` (as a tuple
    of bits) and :class:`int` objects.

    Parameters
    ----------
    value : :class:`int`, :class:`str` or |ASN.1| object
        Python integer or string literal representing binary or hexadecimal
        number or sequence of integer bits or |ASN.1| object.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
        Object representing non-default symbolic aliases for numbers

    binValue: :py:class:`str`
        Binary string initializer to use instead of the *value*.
        Example: '10110011'.

    hexValue: :py:class:`str`
        Hexadecimal string initializer to use instead of the *value*.
        Example: 'DEADBEEF'.

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    """
    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x03)
    )
    baseTagSet = tagSet

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on initialization values.
    subtypeSpec = constraint.ConstraintsIntersection()

    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object
    #: representing symbolic aliases for numbers
    namedValues = namedval.NamedValues()

    defaultBinValue = defaultHexValue = noValue

    if sys.version_info[0] < 3:
        SizedIntegerBase = long
    else:
        SizedIntegerBase = int

    class SizedInteger(SizedIntegerBase):
        bitLength = leadingZeroBits = None

        def setBitLength(self, bitLength):
            self.bitLength = bitLength
            self.leadingZeroBits = max(bitLength - integer.bitLength(self), 0)
            return self

        def __len__(self):
            if self.bitLength is None:
                self.setBitLength(integer.bitLength(self))

            return self.bitLength

    def __init__(self, value=noValue, tagSet=None, subtypeSpec=None,
                 namedValues=None, binValue=noValue, hexValue=noValue):
        if namedValues is None:
            self.__namedValues = self.namedValues
        else:
            self.__namedValues = namedValues
        if not self.isNoValue(binValue):
            value = self.fromBinaryString(binValue)
        if not self.isNoValue(hexValue):
            value = self.fromHexString(hexValue)
        if self.isNoValue(value):
            if self.defaultBinValue is not noValue:
                value = self.fromBinaryString(self.defaultBinValue)
            elif self.defaultHexValue is not noValue:
                value = self.fromHexString(self.defaultHexValue)
        self.__asNumbersCache = {}
        base.AbstractSimpleAsn1Item.__init__(
            self, value, tagSet, subtypeSpec
        )

    def clone(self, value=noValue, tagSet=None, subtypeSpec=None,
              namedValues=None, binValue=noValue, hexValue=noValue):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value : :class:`int`, :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

        namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
            Class instance representing BitString type enumerations

        binValue: :py:class:`str`
            Binary string initializer to use instead of the *value*.
            Example: '10110011'.

        hexValue: :py:class:`str`
            Hexadecimal string initializer to use instead of the *value*.
            Example: 'DEADBEEF'.

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        """
        if self.isNoValue(value, binValue, hexValue):
            if self.isNoValue(tagSet, subtypeSpec, namedValues):
                return self
            value = self._value
        if tagSet is None:
            tagSet = self._tagSet
        if subtypeSpec is None:
            subtypeSpec = self._subtypeSpec
        if namedValues is None:
            namedValues = self.__namedValues
        return self.__class__(value, tagSet, subtypeSpec, namedValues, binValue, hexValue)

    def subtype(self, value=noValue, implicitTag=None, explicitTag=None,
                subtypeSpec=None, namedValues=None, binValue=noValue, hexValue=noValue):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value : :class:`int`, :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Add ASN.1 constraints object to one of the caller, then
            use the result as new object's ASN.1 constraints.

        namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
            Add given object representing symbolic aliases for numbers
            to one of the caller, then use the result as new object's
            named numbers.

        binValue: :py:class:`str`
            Binary string initializer to use instead of the *value*.
            Example: '10110011'.

        hexValue: :py:class:`str`
            Hexadecimal string initializer to use instead of the *value*.
            Example: 'DEADBEEF'.

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        """
        if self.isNoValue(value, binValue, hexValue):
            if self.isNoValue(implicitTag, explicitTag, subtypeSpec, namedValues):
                return self
            value = self._value
        if implicitTag is not None:
            tagSet = self._tagSet.tagImplicitly(implicitTag)
        elif explicitTag is not None:
            tagSet = self._tagSet.tagExplicitly(explicitTag)
        else:
            tagSet = self._tagSet
        if subtypeSpec is None:
            subtypeSpec = self._subtypeSpec
        else:
            subtypeSpec = self._subtypeSpec + subtypeSpec
        if namedValues is None:
            namedValues = self.__namedValues
        else:
            namedValues = namedValues + self.__namedValues
        return self.__class__(value, tagSet, subtypeSpec, namedValues, binValue, hexValue)

    def __str__(self):
        return self.asBinary()

    def __eq__(self, other):
        other = self.prettyIn(other)
        return self is other or self._value == other and len(self._value) == len(other)

    def __ne__(self, other):
        other = self.prettyIn(other)
        return self._value != other or len(self._value) != len(other)

    def __lt__(self, other):
        other = self.prettyIn(other)
        return len(self._value) < len(other) or len(self._value) == len(other) and self._value < other

    def __le__(self, other):
        other = self.prettyIn(other)
        return len(self._value) <= len(other) or len(self._value) == len(other) and self._value <= other

    def __gt__(self, other):
        other = self.prettyIn(other)
        return len(self._value) > len(other) or len(self._value) == len(other) and self._value > other

    def __ge__(self, other):
        other = self.prettyIn(other)
        return len(self._value) >= len(other) or len(self._value) == len(other) and self._value >= other

    # Immutable sequence object protocol

    def __len__(self):
        return len(self._value)

    def __getitem__(self, i):
        if isinstance(i, slice):
            return self.clone([self[x] for x in range(*i.indices(len(self)))])
        else:
            length = len(self._value) - 1
            if i > length or i < 0:
                raise IndexError('bit index out of range')
            return (self._value >> (length - i)) & 1

    def __iter__(self):
        length = len(self._value)
        while length:
            length -= 1
            yield (self._value >> length) & 1

    def __reversed__(self):
        return reversed(tuple(self))

    # arithmetic operators

    def __add__(self, value):
        value = self.prettyIn(value)
        return self.clone(self.SizedInteger(self._value << len(value) | value).setBitLength(len(self._value) + len(value)))

    def __radd__(self, value):
        value = self.prettyIn(value)
        return self.clone(self.SizedInteger(value << len(self._value) | self._value).setBitLength(len(self._value) + len(value)))

    def __mul__(self, value):
        bitString = self._value
        while value > 1:
            bitString <<= len(self._value)
            bitString |= self._value
            value -= 1
        return self.clone(bitString)

    def __rmul__(self, value):
        return self * value

    def __lshift__(self, count):
        return self.clone(self.SizedInteger(self._value << count).setBitLength(len(self._value) + count))

    def __rshift__(self, count):
        return self.clone(self.SizedInteger(self._value >> count).setBitLength(max(0, len(self._value) - count)))

    def __int__(self):
        return self._value

    def __float__(self):
        return float(self._value)

    if sys.version_info[0] < 3:
        def __long__(self):
            return self._value

    def asNumbers(self):
        """Get |ASN.1| value as a sequence of 8-bit integers.

        If |ASN.1| object length is not a multiple of 8, result
        will be left-padded with zeros.
        """
        return tuple(octets.octs2ints(self.asOctets()))

    def asOctets(self):
        """Get |ASN.1| value as a sequence of octets.

        If |ASN.1| object length is not a multiple of 8, result
        will be left-padded with zeros.
        """
        return integer.to_bytes(self._value, length=len(self))

    def asInteger(self):
        """Get |ASN.1| value as a single integer value.
        """
        return self._value

    def asBinary(self):
        """Get |ASN.1| value as a text string of bits.
        """
        binString = binary.bin(self._value)[2:]
        return '0'*(len(self._value) - len(binString)) + binString

    @classmethod
    def fromHexString(cls, value):
        try:
            return cls.SizedInteger(value, 16).setBitLength(len(value) * 4)

        except ValueError:
            raise error.PyAsn1Error('%s.fromHexString() error: %s' % (cls.__name__, sys.exc_info()[1]))

    @classmethod
    def fromBinaryString(cls, value):
        try:
            return cls.SizedInteger(value or '0', 2).setBitLength(len(value))

        except ValueError:
            raise error.PyAsn1Error('%s.fromBinaryString() error: %s' % (cls.__name__, sys.exc_info()[1]))

    @classmethod
    def fromOctetString(cls, value, padding=0):
        return cls(cls.SizedInteger(integer.from_bytes(value) >> padding).setBitLength(len(value) * 8 - padding))

    def prettyIn(self, value):
        if octets.isStringType(value):
            if not value:
                return self.SizedInteger(0).setBitLength(0)

            elif value[0] == '\'':  # "'1011'B" -- ASN.1 schema representation (deprecated)
                if value[-2:] == '\'B':
                    return self.fromBinaryString(value[1:-2])
                elif value[-2:] == '\'H':
                    return self.fromHexString(value[1:-2])
                else:
                    raise error.PyAsn1Error(
                        'Bad BIT STRING value notation %s' % (value,)
                    )

            elif self.__namedValues and not value.isdigit():  # named bits like 'Urgent, Active'
                number = 0
                highestBitPosition = 0
                for namedBit in value.split(','):
                    bitPosition = self.__namedValues.getValue(namedBit)
                    if bitPosition is None:
                        raise error.PyAsn1Error(
                            'Unknown bit identifier \'%s\'' % (namedBit,)
                        )

                    number |= (1 << bitPosition)

                    highestBitPosition = max(highestBitPosition, bitPosition)

                return self.SizedInteger(number).setBitLength(highestBitPosition + 1)

            elif value.startswith('0x'):
                return self.fromHexString(value[2:])

            elif value.startswith('0b'):
                return self.fromBinaryString(value[2:])

            else:  # assume plain binary string like '1011'
                return self.fromBinaryString(value)

        elif isinstance(value, (tuple, list)):
            return self.fromBinaryString(''.join([b and '1' or '0' for b in value]))

        elif isinstance(value, (self.SizedInteger, BitString)):
            return self.SizedInteger(value).setBitLength(len(value))

        elif isinstance(value, intTypes):
            return self.SizedInteger(value)

        else:
            raise error.PyAsn1Error(
                'Bad BitString initializer type \'%s\'' % (value,)
            )

    def prettyOut(self, value):
        return '\'%s\'' % str(self)


try:
    # noinspection PyStatementEffect
    all

except NameError:  # Python 2.4
    # noinspection PyShadowingBuiltins
    def all(iterable):
        for element in iterable:
            if not element:
                return False
        return True


class OctetString(base.AbstractSimpleAsn1Item):
    """Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python 2 :class:`str` or Python 3 :class:`bytes`.
    When used in Unicode context, |ASN.1| type assumes "|encoding|" serialization.

    Parameters
    ----------
    value : :class:`str`, :class:`bytes` or |ASN.1| object
        string (Python 2) or bytes (Python 3), alternatively unicode object
        (Python 2) or string (Python 3) representing character string to be
        serialized into octets (note `encoding` parameter) or |ASN.1| object.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    encoding: :py:class:`str`
        Unicode codec ID to encode/decode :class:`unicode` (Python 2) or
        :class:`str` (Python 3) the payload when |ASN.1| object is used
        in text string context.

    binValue: :py:class:`str`
        Binary string initializer to use instead of the *value*.
        Example: '10110011'.
        
    hexValue: :py:class:`str`
        Hexadecimal string initializer to use instead of the *value*.
        Example: 'DEADBEEF'.

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    """
    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x04)
    )
    baseTagSet = tagSet

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on initialization values.
    subtypeSpec = constraint.ConstraintsIntersection()

    defaultBinValue = defaultHexValue = noValue
    encoding = 'iso-8859-1'

    def __init__(self, value=noValue, tagSet=None, subtypeSpec=None,
                 encoding=None, binValue=noValue, hexValue=noValue):
        if encoding is None:
            self._encoding = self.encoding
        else:
            self._encoding = encoding
        if not self.isNoValue(binValue):
            value = self.fromBinaryString(binValue)
        if not self.isNoValue(hexValue):
            value = self.fromHexString(hexValue)
        if self.isNoValue(value):
            if self.defaultBinValue is not noValue:
                value = self.fromBinaryString(self.defaultBinValue)
            elif self.defaultHexValue is not noValue:
                value = self.fromHexString(self.defaultHexValue)
        self.__asNumbersCache = None
        base.AbstractSimpleAsn1Item.__init__(self, value, tagSet, subtypeSpec)

    def clone(self, value=noValue, tagSet=None, subtypeSpec=None,
              encoding=None, binValue=noValue, hexValue=noValue):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value : :class:`str`, :class:`bytes` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

        encoding: :py:class:`str`
            Unicode codec ID to encode/decode :class:`unicode` (Python 2)
            or :class:`str` (Python 3) the payload when |ASN.1|
            object is used in string context.

        binValue: :py:class:`str`
            Binary string initializer. Example: '10110011'.
        
        hexValue: :py:class:`str`
            Hexadecimal string initializer. Example: 'DEADBEEF'.

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        """
        if self.isNoValue(value, binValue, hexValue):
            if self.isNoValue(tagSet, subtypeSpec, encoding):
                return self
            value = self._value
        if tagSet is None:
            tagSet = self._tagSet
        if subtypeSpec is None:
            subtypeSpec = self._subtypeSpec
        if encoding is None:
            encoding = self._encoding
        return self.__class__(
            value, tagSet, subtypeSpec, encoding, binValue, hexValue
        )

    def subtype(self, value=noValue, implicitTag=None, explicitTag=None,
                subtypeSpec=None, encoding=None, binValue=noValue,
                hexValue=noValue):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value : :class:`str`, :class:`bytes` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to |ASN.1| object tag set
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to |ASN.1| object tag set
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Add ASN.1 constraints object to one of the caller, then
            use the result as new object's ASN.1 constraints.

        encoding: :py:class:`str`
            Unicode codec ID to encode/decode :class:`unicode` (Python 2)
            or :class:`str` (Python 3) the payload when *OctetString*
            object is used in string context.

        binValue: :py:class:`str`
            Binary string initializer. Example: '10110011'.
        
        hexValue: :py:class:`str`
            Hexadecimal string initializer. Example: 'DEADBEEF'.

        Returns
        -------
        :
             new instance of |ASN.1| type/value
        """
        if self.isNoValue(value, binValue, hexValue):
            if self.isNoValue(implicitTag, explicitTag, subtypeSpec, encoding):
                return self
            value = self._value
        if implicitTag is not None:
            tagSet = self._tagSet.tagImplicitly(implicitTag)
        elif explicitTag is not None:
            tagSet = self._tagSet.tagExplicitly(explicitTag)
        else:
            tagSet = self._tagSet
        if subtypeSpec is None:
            subtypeSpec = self._subtypeSpec
        else:
            subtypeSpec = self._subtypeSpec + subtypeSpec
        if encoding is None:
            encoding = self._encoding
        return self.__class__(
            value, tagSet, subtypeSpec, encoding, binValue, hexValue
        )

    if sys.version_info[0] <= 2:
        def prettyIn(self, value):
            if isinstance(value, str):
                return value
            elif isinstance(value, unicode):
                try:
                    return value.encode(self._encoding)
                except (LookupError, UnicodeEncodeError):
                    raise error.PyAsn1Error(
                        'Can\'t encode string \'%s\' with \'%s\' codec' % (value, self._encoding)
                    )
            elif isinstance(value, (tuple, list)):
                try:
                    return ''.join([chr(x) for x in value])
                except ValueError:
                    raise error.PyAsn1Error(
                        'Bad %s initializer \'%s\'' % (self.__class__.__name__, value)
                    )
            else:
                return str(value)

        def __str__(self):
            return str(self._value)

        def __unicode__(self):
            try:
                return self._value.decode(self._encoding)

            except UnicodeDecodeError:
                raise error.PyAsn1Error(
                    'Can\'t decode string \'%s\' with \'%s\' codec' % (self._value, self._encoding)
                )

        def asOctets(self):
            return str(self._value)

        def asNumbers(self):
            if self.__asNumbersCache is None:
                self.__asNumbersCache = tuple([ord(x) for x in self._value])
            return self.__asNumbersCache

    else:
        def prettyIn(self, value):
            if isinstance(value, bytes):
                return value
            elif isinstance(value, str):
                try:
                    return value.encode(self._encoding)
                except UnicodeEncodeError:
                    raise error.PyAsn1Error(
                        'Can\'t encode string \'%s\' with \'%s\' codec' % (value, self._encoding)
                    )
            elif isinstance(value, OctetString):  # a shortcut, bytes() would work the same way
                return value.asOctets()
            elif isinstance(value, base.AbstractSimpleAsn1Item):  # this mostly targets Integer objects
                return self.prettyIn(str(value))
            elif isinstance(value, (tuple, list)):
                return self.prettyIn(bytes(value))
            else:
                return bytes(value)

        def __str__(self):
            try:
                return self._value.decode(self._encoding)

            except UnicodeDecodeError:
                raise error.PyAsn1Error(
                    'Can\'t decode string \'%s\' with \'%s\' codec at \'%s\'' % (self._value, self._encoding, self.__class__.__name__)
                )

        def __bytes__(self):
            return bytes(self._value)

        def asOctets(self):
            return bytes(self._value)

        def asNumbers(self):
            if self.__asNumbersCache is None:
                self.__asNumbersCache = tuple(self._value)
            return self.__asNumbersCache

    def prettyOut(self, value):
        if sys.version_info[0] <= 2:
            numbers = tuple((ord(x) for x in value))
        else:
            numbers = tuple(value)
        for x in numbers:
            if x < 32 or x > 126:
                return '0x' + ''.join(('%.2x' % x for x in numbers))
        else:
            return octets.octs2str(value)

    @staticmethod
    def fromBinaryString(value):
        bitNo = 8
        byte = 0
        r = []
        for v in value:
            if bitNo:
                bitNo -= 1
            else:
                bitNo = 7
                r.append(byte)
                byte = 0
            if v in ('0', '1'):
                v = int(v)
            else:
                raise error.PyAsn1Error(
                    'Non-binary OCTET STRING initializer %s' % (v,)
                )
            byte |= v << bitNo

        r.append(byte)

        return octets.ints2octs(r)

    @staticmethod
    def fromHexString(value):
        r = []
        p = []
        for v in value:
            if p:
                r.append(int(p + v, 16))
                p = None
            else:
                p = v
        if p:
            r.append(int(p + '0', 16))

        return octets.ints2octs(r)

    def __repr__(self):
        r = []
        doHex = False
        if self._value is not self.defaultValue:
            for x in self.asNumbers():
                if x < 32 or x > 126:
                    doHex = True
                    break
            if not doHex:
                r.append('%r' % (self._value,))
        if self._tagSet is not self.tagSet:
            r.append('tagSet=%r' % (self._tagSet,))
        if self._subtypeSpec is not self.subtypeSpec:
            r.append('subtypeSpec=%r' % (self._subtypeSpec,))
        if self.encoding is not self._encoding:
            r.append('encoding=%r' % (self._encoding,))
        if doHex:
            r.append('hexValue=%r' % ''.join(['%.2x' % x for x in self.asNumbers()]))
        return '%s(%s)' % (self.__class__.__name__, ', '.join(r))

    # Immutable sequence object protocol

    def __len__(self):
        if self._len is None:
            self._len = len(self._value)
        return self._len

    def __getitem__(self, i):
        if isinstance(i, slice):
            return self.clone(operator.getitem(self._value, i))
        else:
            return self._value[i]

    def __iter__(self):
        return iter(self._value)

    def __contains__(self, value):
        return value in self._value

    def __add__(self, value):
        return self.clone(self._value + self.prettyIn(value))

    def __radd__(self, value):
        return self.clone(self.prettyIn(value) + self._value)

    def __mul__(self, value):
        return self.clone(self._value * value)

    def __rmul__(self, value):
        return self * value

    def __int__(self):
        return int(self._value)

    def __float__(self):
        return float(self._value)

    def __reversed__(self):
        return reversed(self._value)


class Null(OctetString):
    """Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python :class:`str` objects (always empty).

    Parameters
    ----------
    value : :class:`str` or :py:class:`~pyasn1.type.univ.Null` object
        Python empty string literal or *Null* class instance.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    """
    defaultValue = ''.encode()  # This is tightly constrained

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for ASN.1
    #: *Null* objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x05)
    )
    baseTagSet = tagSet
    subtypeSpec = OctetString.subtypeSpec + constraint.SingleValueConstraint(octets.str2octs(''))

    def clone(self, value=noValue, tagSet=None):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of 
            inheriting one from the caller.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

        Returns
        -------
        : :py:class:`~pyasn1.type.univ.Null`
            new instance of NULL type/value
        """
        return OctetString.clone(self, value, tagSet)

    def subtype(self, value=noValue, implicitTag=None, explicitTag=None):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`int`, :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        Returns
        -------
        : :py:class:`~pyasn1.type.univ.Null`
            new instance of NULL type/value
        """
        return OctetString.subtype(self, value, implicitTag, explicitTag)


if sys.version_info[0] <= 2:
    intTypes = (int, long)
else:
    intTypes = (int,)

numericTypes = intTypes + (float,)


class ObjectIdentifier(base.AbstractSimpleAsn1Item):
    """Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python :class:`tuple` objects (tuple of non-negative integers).

    Parameters
    ----------
    value: :class:`tuple`, :class:`str` or |ASN.1| object
        Python sequence of :class:`int` or string literal or |ASN.1| object.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    """
    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for ASN.1
    #: *ObjectIdentifier* objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x06)
    )
    baseTagSet = tagSet

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on initialization values.
    subtypeSpec = constraint.ConstraintsIntersection()

    def __add__(self, other):
        return self.clone(self._value + other)

    def __radd__(self, other):
        return self.clone(other + self._value)

    def asTuple(self):
        return self._value

    # Sequence object protocol

    def __len__(self):
        if self._len is None:
            self._len = len(self._value)
        return self._len

    def __getitem__(self, i):
        if isinstance(i, slice):
            return self.clone(
                operator.getitem(self._value, i)
            )
        else:
            return self._value[i]

    def __iter__(self):
        return iter(self._value)

    def __contains__(self, value):
        return value in self._value

    def __str__(self):
        return self.prettyPrint()

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.prettyPrint())

    def index(self, suboid):
        return self._value.index(suboid)

    def isPrefixOf(self, other):
        """Indicate if this |ASN.1| object is a prefix of other |ASN.1| object.

        Parameters
        ----------
        other: |ASN.1| object
            |ASN.1| object

        Returns
        -------
        : :class:`bool`
            :class:`True` if this |ASN.1| object is a parent (e.g. prefix) of the other |ASN.1| object
            or :class:`False` otherwise.
        """
        l = len(self)
        if l <= len(other):
            if self._value[:l] == other[:l]:
                return True
        return False

    def prettyIn(self, value):
        if isinstance(value, ObjectIdentifier):
            return tuple(value)
        elif octets.isStringType(value):
            if '-' in value:
                raise error.PyAsn1Error(
                    'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])
                )
            try:
                return tuple([int(subOid) for subOid in value.split('.') if subOid])
            except ValueError:
                raise error.PyAsn1Error(
                    'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])
                )

        try:
            tupleOfInts = tuple([int(subOid) for subOid in value if subOid >= 0])

        except (ValueError, TypeError):
            raise error.PyAsn1Error(
                'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])
            )

        if len(tupleOfInts) == len(value):
            return tupleOfInts

        raise error.PyAsn1Error('Malformed Object ID %s at %s' % (value, self.__class__.__name__))

    def prettyOut(self, value):
        return '.'.join([str(x) for x in value])


class Real(base.AbstractSimpleAsn1Item):
    """Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python :class:`float` objects.
    Additionally, |ASN.1| objects behave like a :class:`tuple` in which case its
    elements are mantissa, base and exponent.

    Parameters
    ----------
    value: :class:`tuple`, :class:`float` or |ASN.1| object
        Python sequence of :class:`int` (representing mantissa, base and
        exponent) or float instance or *Real* class instance.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.

    """
    binEncBase = None  # binEncBase = 16 is recommended for large numbers

    try:
        _plusInf = float('inf')
        _minusInf = float('-inf')
        _inf = (_plusInf, _minusInf)
    except ValueError:
        # Infinity support is platform and Python dependent
        _plusInf = _minusInf = None
        _inf = ()

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for ASN.1
    #: *Real* objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x09)
    )
    baseTagSet = tagSet

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on initialization values.
    subtypeSpec = constraint.ConstraintsIntersection()

    def clone(self, value=noValue, tagSet=None, subtypeSpec=None):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`tuple`, :class:`float` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        """
        return base.AbstractSimpleAsn1Item.clone(self, value, tagSet, subtypeSpec)

    def subtype(self, value=noValue, implicitTag=None, explicitTag=None,
                subtypeSpec=None):
        """Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`tuple`, :class:`float` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
             Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        """
        return base.AbstractSimpleAsn1Item.subtype(self, value, implicitTag, explicitTag)

    @staticmethod
    def __normalizeBase10(value):
        m, b, e = value
        while m and m % 10 == 0:
            m /= 10
            e += 1
        return m, b, e

    def prettyIn(self, value):
        if isinstance(value, tuple) and len(value) == 3:
            if not isinstance(value[0], numericTypes) or \
                    not isinstance(value[1], intTypes) or \
                    not isinstance(value[2], intTypes):
                raise error.PyAsn1Error('Lame Real value syntax: %s' % (value,))
            if isinstance(value[0], float) and \
                    self._inf and value[0] in self._inf:
                return value[0]
            if value[1] not in (2, 10):
                raise error.PyAsn1Error(
                    'Prohibited base for Real value: %s' % (value[1],)
                )
            if value[1] == 10:
                value = self.__normalizeBase10(value)
            return value
        elif isinstance(value, intTypes):
            return self.__normalizeBase10((value, 10, 0))
        elif isinstance(value, float) or octets.isStringType(value):
            if octets.isStringType(value):
                try:
                    value = float(value)
                except ValueError:
                    raise error.PyAsn1Error(
                        'Bad real value syntax: %s' % (value,)
                    )
            if self._inf and value in self._inf:
                return value
            else:
                e = 0
                while int(value) != value:
                    value *= 10
                    e -= 1
                return self.__normalizeBase10((int(value), 10, e))
        elif isinstance(value, Real):
            return tuple(value)
        raise error.PyAsn1Error(
            'Bad real value syntax: %s' % (value,)
        )

    def prettyOut(self, value):
        if value in self._inf:
            return '\'%s\'' % value
        else:
            return str(value)

    def prettyPrint(self, scope=0):
        if self.isInfinity():
            return self.prettyOut(self._value)
        else:
            return str(float(self))

    def isPlusInfinity(self):
        """Indicate PLUS-INFINITY object value

        Returns
        -------
        : :class:`bool`
            :class:`True` if calling object represents plus infinity
            or :class:`False` otherwise.

        """
        return self._value == self._plusInf

    def isMinusInfinity(self):
        """Indicate MINUS-INFINITY object value

        Returns
        -------
        : :class:`bool`
            :class:`True` if calling object represents minus infinity
            or :class:`False` otherwise.
        """
        return self._value == self._minusInf

    def isInfinity(self):
        return self._value in self._inf

    def __str__(self):
        return str(float(self))

    def __add__(self, value):
        return self.clone(float(self) + value)

    def __radd__(self, value):
        return self + value

    def __mul__(self, value):
        return self.clone(float(self) * value)

    def __rmul__(self, value):
        return self * value

    def __sub__(self, value):
        return self.clone(float(self) - value)

    def __rsub__(self, value):
        return self.clone(value - float(self))

    def __mod__(self, value):
        return self.clone(float(self) % value)

    def __rmod__(self, value):
        return self.clone(value % float(self))

    def __pow__(self, value, modulo=None):
        return self.clone(pow(float(self), value, modulo))

    def __rpow__(self, value):
        return self.clone(pow(value, float(self)))

    if sys.version_info[0] <= 2:
        def __div__(self, value):
            return self.clone(float(self) / value)

        def __rdiv__(self, value):
            return self.clone(value / float(self))
    else:
        def __truediv__(self, value):
            return self.clone(float(self) / value)

        def __rtruediv__(self, value):
            return self.clone(value / float(self))

        def __divmod__(self, value):
            return self.clone(float(self) // value)

        def __rdivmod__(self, value):
            return self.clone(value // float(self))

    def __int__(self):
        return int(float(self))

    if sys.version_info[0] <= 2:
        def __long__(self): return long(float(self))

    def __float__(self):
        if self._value in self._inf:
            return self._value
        else:
            return float(
                self._value[0] * pow(self._value[1], self._value[2])
            )

    def __abs__(self):
        return self.clone(abs(float(self)))

    def __pos__(self):
        return self.clone(+float(self))

    def __neg__(self):
        return self.clone(-float(self))

    def __round__(self, n=0):
        r = round(float(self), n)
        if n:
            return self.clone(r)
        else:
            return r

    def __floor__(self):
        return self.clone(math.floor(float(self)))

    def __ceil__(self):
        return self.clone(math.ceil(float(self)))

    if sys.version_info[0:2] > (2, 5):
        def __trunc__(self): return self.clone(math.trunc(float(self)))

    def __lt__(self, value):
        return float(self) < value

    def __le__(self, value):
        return float(self) <= value

    def __eq__(self, value):
        return float(self) == value

    def __ne__(self, value):
        return float(self) != value

    def __gt__(self, value):
        return float(self) > value

    def __ge__(self, value):
        return float(self) >= value

    if sys.version_info[0] <= 2:
        def __nonzero__(self):
            return bool(float(self))
    else:
        def __bool__(self):
            return bool(float(self))

        __hash__ = base.AbstractSimpleAsn1Item.__hash__

    def __getitem__(self, idx):
        if self._value in self._inf:
            raise error.PyAsn1Error('Invalid infinite value operation')
        else:
            return self._value[idx]


class Enumerated(Integer):
    __doc__ = Integer.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x0A)
    )
    baseTagSet = tagSet

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on initialization values.
    subtypeSpec = constraint.ConstraintsIntersection()

    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object
    #: representing symbolic aliases for numbers
    namedValues = namedval.NamedValues()

# "Structured" ASN.1 types

class SequenceOfAndSetOfBase(base.AbstractConstructedAsn1Item):
    """Create |ASN.1| type.

    |ASN.1| objects are mutable and duck-type Python :class:`list` objects.

    Parameters
    ----------
    componentType : :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
        A pyasn1 object representing ASN.1 type allowed within |ASN.1| type

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    sizeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing collection size constraint
     """

    # Python list protocol

    def clear(self):
        self._componentValues = []
        self._componentValuesSet = 0

    def append(self, value):
        self[len(self)] = value

    def count(self, value):
        return self._componentValues.count(value)

    def extend(self, values):
        for value in values:
            self.append(value)

    def index(self, value, start=0, stop=None):
        if stop is None:
            stop = len(self)
        return self._componentValues.index(value, start, stop)

    def reverse(self):
        self._componentValues.reverse()

    def sort(self, key=None, reverse=False):
        self._componentValues.sort(key=key, reverse=reverse)

    def __iter__(self):
        return iter(self._componentValues)

    def _cloneComponentValues(self, myClone, cloneValueFlag):
        for idx, componentValue in enumerate(self._componentValues):
            if componentValue is not None:
                if isinstance(componentValue, base.AbstractConstructedAsn1Item):
                    myClone.setComponentByPosition(
                        idx, componentValue.clone(cloneValueFlag=cloneValueFlag)
                    )
                else:
                    myClone.setComponentByPosition(idx, componentValue.clone())

    def getComponentByPosition(self, idx):
        """Return |ASN.1| type component value by position.

        Equivalent to Python sequence subscription operation (e.g. `[]`).

        Parameters
        ----------
        idx : :class:`int`
            component index (zero-based)

        Returns
        -------
        : :py:class:`~pyasn1.type.base.PyAsn1Item`
            a pyasn1 object
        """
        return self._componentValues[idx]

    def setComponentByPosition(self, idx, value=noValue,
                               verifyConstraints=True,
                               matchTags=True,
                               matchConstraints=True):
        """Assign |ASN.1| type component by position.

        Equivalent to Python sequence item assignment operation (e.g. `[]`).

        Parameters
        ----------
        idx : :class:`int`
            component index (zero-based)

        value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
            A Python or pyasn1 object to assign or :py:class:`~pyasn1.type.univ.noValue`
            object to instantiate component type.

        verifyConstraints : :class:`bool`
             If `False`, skip constraints validation

        matchTags: :class:`bool`
             If `False`, skip component tags matching

        matchConstraints: :class:`bool`
             If `False`, skip component constraints matching

        Returns
        -------
        self
        """
        componentType = self._componentType

        componentValuesLength = len(self._componentValues)

        if idx == componentValuesLength:
            self._componentValues.append(None)
        elif idx >= componentValuesLength:
            self._componentValues.extend([None for x in range((idx - componentValuesLength + 1))])

        if self.isNoValue(value):
            if self._componentValues[idx] is None:
                if componentType is None:
                    raise error.PyAsn1Error('Component type not defined')
                self._componentValues[idx] = componentType.clone()
                self._componentValuesSet += 1
            return self
        elif not isinstance(value, base.Asn1Item):
            if componentType is None:
                raise error.PyAsn1Error('Component type not defined')
            if isinstance(componentType, base.AbstractSimpleAsn1Item):
                value = componentType.clone(value=value)
            else:
                raise error.PyAsn1Error('%s instance value required' % componentType.__class__.__name__)
        elif componentType is not None:
            if self.strictConstraints:
                if not componentType.isSameTypeWith(value, matchTags, matchConstraints):
                    raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))
            else:
                if not componentType.isSuperTypeOf(value, matchTags, matchConstraints):
                    raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))

        if verifyConstraints:
            self._verifySubtypeSpec(value, idx)

        if self._componentValues[idx] is None:
            self._componentValuesSet += 1

        self._componentValues[idx] = value

        return self

    def getComponentTagMap(self):
        if self._componentType is not None:
            return self._componentType.getTagMap()

    def prettyPrint(self, scope=0):
        scope += 1
        r = self.__class__.__name__ + ':\n'
        for idx in range(len(self._componentValues)):
            r += ' ' * scope
            if self._componentValues[idx] is None:
                r += '<empty>'
            else:
                r = r + self._componentValues[idx].prettyPrint(scope)
        return r

    def prettyPrintType(self, scope=0):
        scope += 1
        r = '%s -> %s {\n' % (self.getTagSet(), self.__class__.__name__)
        if self._componentType is not None:
            r += ' ' * scope
            r = r + self._componentType.prettyPrintType(scope)
        return r + '\n' + ' ' * (scope - 1) + '}'


class SequenceOf(SequenceOfAndSetOfBase):
    __doc__ = SequenceOfAndSetOfBase.__doc__
    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x10)
    )
    baseTagSet = tagSet

    #: Default :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
    #: object representing ASN.1 type allowed within |ASN.1| type
    componentType = None

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on |ASN.1| objects
    subtypeSpec = constraint.ConstraintsIntersection()

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing size constraint on |ASN.1| objects
    sizeSpec = constraint.ConstraintsIntersection()

    typeId = 1


class SetOf(SequenceOfAndSetOfBase):
    __doc__ = SequenceOfAndSetOfBase.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x11)
    )
    baseTagSet = tagSet

    #: Default :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
    #: object representing ASN.1 type allowed within |ASN.1| type
    componentType = None

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on |ASN.1| objects
    subtypeSpec = constraint.ConstraintsIntersection()

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing size constraint on |ASN.1| objects
    sizeSpec = constraint.ConstraintsIntersection()

    typeId = 2


class SequenceAndSetBase(base.AbstractConstructedAsn1Item):
    """Create |ASN.1| type.

    |ASN.1| objects are mutable and duck-type Python :class:`dict` objects.

    Parameters
    ----------
    componentType : :py:class:`~pyasn1.type.namedtype.NamedType`
        Object holding named ASN.1 types allowed within this collection

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    sizeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing collection size constraint
    """
    #: Default :py:class:`~pyasn1.type.namedtype.NamedTypes`
    #: object representing named ASN.1 types allowed within |ASN.1| type
    componentType = namedtype.NamedTypes()

    def __init__(self, componentType=None, tagSet=None,
                 subtypeSpec=None, sizeSpec=None):
        if componentType is None:
            componentType = self.componentType
        base.AbstractConstructedAsn1Item.__init__(
            self, componentType, tagSet, subtypeSpec, sizeSpec
        )
        self._componentTypeLen = len(self._componentType)

    def __getitem__(self, idx):
        if octets.isStringType(idx):
            return self.getComponentByName(idx)
        else:
            return base.AbstractConstructedAsn1Item.__getitem__(self, idx)

    def __setitem__(self, idx, value):
        if octets.isStringType(idx):
            self.setComponentByName(idx, value)
        else:
            base.AbstractConstructedAsn1Item.__setitem__(self, idx, value)

    def __contains__(self, key):
        return key in self._componentType

    def __iter__(self):
        return iter(self._componentType)

    # Python dict protocol

    def values(self):
        for idx in range(self._componentTypeLen):
            yield self[idx]

    def keys(self):
        return iter(self._componentType)

    def items(self):
        for idx in range(self._componentTypeLen):
            yield self._componentType[idx].getName(), self[idx]

    def update(self, *iterValue, **mappingValue):
        for k, v in iterValue:
            self[k] = v
        for k in mappingValue:
            self[k] = mappingValue[k]

    def clear(self):
        self._componentValues = []
        self._componentValuesSet = 0

    def _cloneComponentValues(self, myClone, cloneValueFlag):
        for idx, componentValue in enumerate(self._componentValues):
            if componentValue is not None:
                if isinstance(componentValue, base.AbstractConstructedAsn1Item):
                    myClone.setComponentByPosition(
                        idx, componentValue.clone(cloneValueFlag=cloneValueFlag)
                    )
                else:
                    myClone.setComponentByPosition(idx, componentValue.clone())

    def getComponentByName(self, name):
        """Returns |ASN.1| type component by name.

        Equivalent to Python :class:`dict` subscription operation (e.g. `[]`).

        Parameters
        ----------
        name : :class:`str`
            |ASN.1| type component name

        Returns
        -------
        : :py:class:`~pyasn1.type.base.PyAsn1Item`
            a pyasn1 object
        """
        return self.getComponentByPosition(
            self._componentType.getPositionByName(name)
        )

    def setComponentByName(self, name, value=noValue,
                           verifyConstraints=True,
                           matchTags=True,
                           matchConstraints=True):
        """Assign |ASN.1| type component by name.

        Equivalent to Python :class:`dict` item assignment operation (e.g. `[]`).

        Parameters
        ----------
        name : :class:`str`
            |ASN.1| type component name

        value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
            A Python or pyasn1 object to assign

        verifyConstraints: :class:`bool`
             If `False`, skip constraints validation

        matchTags: :class:`bool`
             If `False`, skip component tags matching

        matchConstraints: :class:`bool`
             If `False`, skip component constraints matching

        Returns
        -------
        self
        """
        return self.setComponentByPosition(
            self._componentType.getPositionByName(name), value, verifyConstraints, matchTags, matchConstraints
        )

    def getComponentByPosition(self, idx):
        """Returns |ASN.1| type component by index.

        Equivalent to Python sequence subscription operation (e.g. `[]`).

        Parameters
        ----------
        idx : :class:`int`
            component index (zero-based)

        Returns
        -------
        : :py:class:`~pyasn1.type.base.PyAsn1Item`
            a PyASN1 object
        """
        try:
            return self._componentValues[idx]
        except IndexError:
            if idx < self._componentTypeLen:
                return
            raise

    def setComponentByPosition(self, idx, value=noValue,
                               verifyConstraints=True,
                               matchTags=True,
                               matchConstraints=True):
        """Assign |ASN.1| type component by position.

        Equivalent to Python sequence item assignment operation (e.g. `[]`).

        Parameters
        ----------
        idx : :class:`int`
            |ASN.1| type component index (zero-based)

        value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
            A Python or pyasn1 object to assign

        verifyConstraints : :class:`bool`
             If `False`, skip constraints validation

        matchTags: :class:`bool`
             If `False`, skip component tags matching

        matchConstraints: :class:`bool`
             If `False`, skip component constraints matching

        Returns
        -------
        self
        """
        if self._componentType:
            componentType = self._componentType.getTypeByPosition(idx)
        else:
            componentType = None

        componentValuesLength = len(self._componentValues)

        if idx == componentValuesLength:
            self._componentValues.append(None)
        elif idx > componentValuesLength:
            self._componentValues.extend([None for x in range(idx - componentValuesLength + 1)])

        if self.isNoValue(value):
            if self._componentValues[idx] is None:
                if componentType is None:
                    raise error.PyAsn1Error('%s instance value required' % componentType.__class__.__name__)
                self._componentValues[idx] = componentType.clone()
                self._componentValuesSet += 1
            return self
        elif not isinstance(value, base.Asn1Item):
            if componentType is None:
                raise error.PyAsn1Error('Component type not defined')
            if isinstance(componentType, base.AbstractSimpleAsn1Item):
                value = componentType.clone(value=value)
            else:
                raise error.PyAsn1Error('%s instance value required' % componentType.__class__.__name__)
        elif componentType is not None:
            if self.strictConstraints:
                if not componentType.isSameTypeWith(value, matchTags, matchConstraints):
                    raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))
            else:
                if not componentType.isSuperTypeOf(value, matchTags, matchConstraints):
                    raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))

        if verifyConstraints:
            self._verifySubtypeSpec(value, idx)

        if self._componentValues[idx] is None:
            self._componentValuesSet += 1

        self._componentValues[idx] = value

        return self

    def getNameByPosition(self, idx):
        if self._componentTypeLen:
            return self._componentType.getNameByPosition(idx)

    def getDefaultComponentByPosition(self, idx):
        if self._componentTypeLen and self._componentType[idx].isDefaulted:
            return self._componentType[idx].getType()

    def getComponentType(self):
        if self._componentTypeLen:
            return self._componentType

    def setDefaultComponents(self):
        """Assign default values to all defaulted |ASN.1| type components.

        Returns
        -------
        self
        """
        if self._componentTypeLen == self._componentValuesSet:
            return
        idx = self._componentTypeLen
        while idx:
            idx -= 1
            if self._componentType[idx].isDefaulted:
                if self.getComponentByPosition(idx) is None:
                    self.setComponentByPosition(idx)
            elif not self._componentType[idx].isOptional:
                if self.getComponentByPosition(idx) is None:
                    raise error.PyAsn1Error(
                        'Uninitialized component #%s at %r' % (idx, self)
                    )
        return self

    def prettyPrint(self, scope=0):
        """Return an object representation string.

        Returns
        -------
        : :class:`str`
            Human-friendly object representation.
        """
        scope += 1
        r = self.__class__.__name__ + ':\n'
        for idx in range(len(self._componentValues)):
            if self._componentValues[idx] is not None:
                r += ' ' * scope
                componentType = self.getComponentType()
                if componentType is None:
                    r += '<no-name>'
                else:
                    r = r + componentType.getNameByPosition(idx)
                r = '%s=%s\n' % (
                    r, self._componentValues[idx].prettyPrint(scope)
                )
        return r

    def prettyPrintType(self, scope=0):
        scope += 1
        r = '%s -> %s {\n' % (self.getTagSet(), self.__class__.__name__)
        for idx in range(len(self.componentType)):
            r += ' ' * scope
            r += '"%s"' % self.componentType.getNameByPosition(idx)
            r = '%s = %s\n' % (
                r, self._componentType.getTypeByPosition(idx).prettyPrintType(scope)
            )
        return r + '\n' + ' ' * (scope - 1) + '}'


class Sequence(SequenceAndSetBase):
    __doc__ = SequenceAndSetBase.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x10)
    )
    baseTagSet = tagSet

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on |ASN.1| objects
    subtypeSpec = constraint.ConstraintsIntersection()

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on |ASN.1| objects
    sizeSpec = constraint.ConstraintsIntersection()

    #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)
    #: object imposing size constraint on |ASN.1| objects
    componentType = namedtype.NamedTypes()

    typeId = 3

    def getComponentTagMapNearPosition(self, idx):
        if self._componentType:
            return self._componentType.getTagMapNearPosition(idx)

    def getComponentPositionNearType(self, tagSet, idx):
        if self._componentType:
            return self._componentType.getPositionNearType(tagSet, idx)
        else:
            return idx


class Set(SequenceAndSetBase):
    __doc__ = SequenceAndSetBase.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for ASN.1
    #: *Set* objects
    tagSet = tag.initTagSet(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x11)
    )
    baseTagSet = tagSet

    #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)
    #: object representing ASN.1 type allowed within |ASN.1| type
    componentType = namedtype.NamedTypes()

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on |ASN.1| objects
    subtypeSpec = constraint.ConstraintsIntersection()

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on |ASN.1| objects
    sizeSpec = constraint.ConstraintsIntersection()

    typeId = 4

    def getComponent(self, innerFlag=False):
        return self

    def getComponentByType(self, tagSet, innerFlag=False):
        """Returns |ASN.1| type component by ASN.1 tag.

        Parameters
        ----------
        tagSet : :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tags

        Returns
        -------
        : :py:class:`~pyasn1.type.base.PyAsn1Item`
            a pyasn1 object
        """
        component = self.getComponentByPosition(
            self._componentType.getPositionByType(tagSet)
        )
        if innerFlag and isinstance(component, Set):
            # get inner component by inner tagSet
            return component.getComponent(innerFlag=True)
        else:
            # get outer component by inner tagSet
            return component

    def setComponentByType(self, tagSet, value=noValue,
                           verifyConstraints=True,
                           matchTags=True,
                           matchConstraints=True,
                           innerFlag=False):
        """Assign |ASN.1| type component by ASN.1 tag.

        Parameters
        ----------
        tagSet : :py:class:`~pyasn1.type.tag.TagSet`
           Object representing ASN.1 tags

        value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
            A Python or pyasn1 object to assign

        verifyConstraints : :class:`bool`
            If `False`, skip constraints validation

        matchTags: :class:`bool`
            If `False`, skip component tags matching

        matchConstraints: :class:`bool`
            If `False`, skip component constraints matching

        innerFlag: :class:`bool`
            If `True`, search for matching *tagSet* recursively.

        Returns
        -------
        self
        """
        idx = self._componentType.getPositionByType(tagSet)

        componentType = self._componentType.getTypeByPosition(idx)

        if innerFlag:  # set inner component by inner tagSet
            if componentType.getTagSet():
                return self.setComponentByPosition(
                    idx, value, verifyConstraints, matchTags, matchConstraints
                )
            else:
                componentType = self.setComponentByPosition(idx).getComponentByPosition(idx)
                return componentType.setComponentByType(
                    tagSet, value, verifyConstraints, matchTags, matchConstraints, innerFlag=innerFlag
                )
        else:  # set outer component by inner tagSet
            return self.setComponentByPosition(
                idx, value, verifyConstraints, matchTags, matchConstraints
            )

    def getComponentTagMap(self):
        if self._componentType:
            return self._componentType.getTagMap(True)

    def getComponentPositionByType(self, tagSet):
        if self._componentType:
            return self._componentType.getPositionByType(tagSet)


class Choice(Set):
    __doc__ = Set.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects (untagged by default)
    tagSet = tag.TagSet()  # untagged
    baseTagSet = tagSet

    #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)
    #: object representing ASN.1 type allowed within |ASN.1| type
    componentType = namedtype.NamedTypes()

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing size constraint on |ASN.1| objects
    subtypeSpec = constraint.ConstraintsIntersection()

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing size constraint on |ASN.1| objects
    sizeSpec = constraint.ConstraintsIntersection(
        constraint.ValueSizeConstraint(1, 1)
    )

    typeId = 5

    _currentIdx = None

    def __eq__(self, other):
        if self._componentValues:
            return self._componentValues[self._currentIdx] == other
        return NotImplemented

    def __ne__(self, other):
        if self._componentValues:
            return self._componentValues[self._currentIdx] != other
        return NotImplemented

    def __lt__(self, other):
        if self._componentValues:
            return self._componentValues[self._currentIdx] < other
        return NotImplemented

    def __le__(self, other):
        if self._componentValues:
            return self._componentValues[self._currentIdx] <= other
        return NotImplemented

    def __gt__(self, other):
        if self._componentValues:
            return self._componentValues[self._currentIdx] > other
        return NotImplemented

    def __ge__(self, other):
        if self._componentValues:
            return self._componentValues[self._currentIdx] >= other
        return NotImplemented

    if sys.version_info[0] <= 2:
        def __nonzero__(self):
            return bool(self._componentValues)
    else:
        def __bool__(self):
            return bool(self._componentValues)

    def __len__(self):
        return self._currentIdx is not None and 1 or 0

    def __contains__(self, key):
        if self._currentIdx is None:
            return False
        return key == self._componentType[self._currentIdx].getName()

    def __iter__(self):
        if self._currentIdx is None:
            raise StopIteration
        yield self._componentType[self._currentIdx].getName()

    def verifySizeSpec(self):
        if self._currentIdx is None:
            raise error.PyAsn1Error('Component not chosen')

    def _cloneComponentValues(self, myClone, cloneValueFlag):
        try:
            c = self.getComponent()
        except error.PyAsn1Error:
            pass
        else:
            if isinstance(c, Choice):
                tagSet = c.getEffectiveTagSet()
            else:
                tagSet = c.getTagSet()
            if isinstance(c, base.AbstractConstructedAsn1Item):
                myClone.setComponentByType(
                    tagSet, c.clone(cloneValueFlag=cloneValueFlag)
                )
            else:
                myClone.setComponentByType(tagSet, c.clone())

    def setComponentByPosition(self, idx, value=noValue,
                               verifyConstraints=True,
                               matchTags=True,
                               matchConstraints=True):
        """Assign |ASN.1| type component by position.

        Equivalent to Python sequence item assignment operation (e.g. `[]`).

        Parameters
        ----------
        idx : :class:`int`
            component index (zero-based)

        value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
            A Python or pyasn1 object to assign

        verifyConstraints : :class:`bool`
            If `False`, skip constraints validation

        matchTags: :class:`bool`
            If `False`, skip component tags matching

        matchConstraints: :class:`bool`
            If `False`, skip component constraints matching

        Returns
        -------
        self
        """
        componentType = self._componentType.getTypeByPosition(idx)

        componentValuesLength = len(self._componentValues)

        if idx == componentValuesLength:
            self._componentValues.append(None)
        elif idx > componentValuesLength:
            self._componentValues.extend([None for x in range(idx - componentValuesLength + 1)])

        if self._currentIdx is not None:
            self._componentValues[self._currentIdx] = None

        if self.isNoValue(value):
            if self._componentValues[idx] is None:
                self._componentValues[idx] = self._componentType.getTypeByPosition(idx).clone()
                self._componentValuesSet = 1
                self._currentIdx = idx
            return self
        elif not isinstance(value, base.Asn1Item):
            value = self._componentType.getTypeByPosition(idx).clone(value=value)
        elif self.strictConstraints:
            if not componentType.isSameTypeWith(value, matchTags, matchConstraints):
                raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))
        else:
            if not componentType.isSuperTypeOf(value, matchTags, matchConstraints):
                raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))

        if verifyConstraints:
            self._verifySubtypeSpec(value, idx)

        self._componentValues[idx] = value
        self._currentIdx = idx
        self._componentValuesSet = 1

        return self

    def getMinTagSet(self):
        if self._tagSet:
            return self._tagSet
        else:
            return self._componentType.genMinTagSet()

    def getEffectiveTagSet(self):
        if self._tagSet:
            return self._tagSet
        else:
            c = self.getComponent()
            if isinstance(c, Choice):
                return c.getEffectiveTagSet()
            else:
                return c.getTagSet()

    def getTagMap(self):
        if self._tagSet:
            return Set.getTagMap(self)
        else:
            return Set.getComponentTagMap(self)

    def getComponent(self, innerFlag=0):
        """Return currently assigned component of the |ASN.1| object.

        Returns
        -------
        : :py:class:`~pyasn1.type.base.PyAsn1Item`
            a PyASN1 object
        """
        if self._currentIdx is None:
            raise error.PyAsn1Error('Component not chosen')
        else:
            c = self._componentValues[self._currentIdx]
            if innerFlag and isinstance(c, Choice):
                return c.getComponent(innerFlag)
            else:
                return c

    def getName(self, innerFlag=False):
        """Return the name of currently assigned component of the |ASN.1| object.

        Returns
        -------
        : :py:class:`str`
            |ASN.1| component name
        """
        if self._currentIdx is None:
            raise error.PyAsn1Error('Component not chosen')
        else:
            if innerFlag:
                c = self._componentValues[self._currentIdx]
                if isinstance(c, Choice):
                    return c.getName(innerFlag)
            return self._componentType.getNameByPosition(self._currentIdx)

    def setDefaultComponents(self):
        pass


class Any(OctetString):
    __doc__ = OctetString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects (untagged by default)
    tagSet = tag.TagSet()  # untagged
    baseTagSet = tagSet
    typeId = 6

    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
    #: object imposing constraints on initialization values.
    subtypeSpec = constraint.ConstraintsIntersection()

    def getTagMap(self):
        return tagmap.TagMap(
            {self.getTagSet(): self},
            {eoo.endOfOctets.getTagSet(): eoo.endOfOctets},
            self
        )

# XXX
# coercion rules?
                                                                                                        usr/local/lib/python2.7/dist-packages/pyasn1/type/univ.pyc                                          0100644 0000000 0000062 00000264312 13077704403 022124  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
 âˇXc           @   s≤  d  d l  Z  d  d l Z d  d l Z d  d l m Z m Z m Z m Z m Z m	 Z	 d  d l
 m Z d  d l m Z m Z m Z d  d l m Z e j Z e É  Z d d d d	 d
 d d d d d d d d d d d d d g Z d e j f d Ñ  É  YZ d e f d Ñ  É  YZ d e j f d Ñ  É  YZ y e Wn e k
 rHd Ñ  Z n Xd	 e j f d Ñ  É  YZ d
 e f d Ñ  É  YZ e j d d k röe e f Z  n	 e f Z  e  e! f Z" d e j f d  Ñ  É  YZ# d e j f d! Ñ  É  YZ$ d e f d" Ñ  É  YZ% d e j& f d# Ñ  É  YZ' d e' f d$ Ñ  É  YZ( d e' f d% Ñ  É  YZ) d e j& f d& Ñ  É  YZ* d e* f d' Ñ  É  YZ+ d e* f d( Ñ  É  YZ, d e, f d) Ñ  É  YZ- d e f d* Ñ  É  YZ. d S(+   iˇˇˇˇN(   t   baset   tagt
   constraintt	   namedtypet   namedvalt   tagmap(   t   eoo(   t   octetst   integert   binary(   t   errort   Integert   Booleant	   BitStringt   OctetStringt   Nullt   ObjectIdentifiert   Realt
   Enumeratedt   SequenceOfAndSetOfBaset
   SequenceOft   SetOft   SequenceAndSetBaset   Sequencet   Sett   Choicet   Anyt   NoValuet   noValuec           B   sô  e  Z d  Z e j e j e j e j d É É Z e Z	 e
 j É  Z e j É  Z e d7 d7 d7 d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d7 d Ñ Z$ d Ñ  Z% d Ñ  Z& d Ñ  Z' e( j) d d k rKd Ñ  Z* d Ñ  Z+ n0 d Ñ  Z, d Ñ  Z- d Ñ  Z. d Ñ  Z/ e0 j1 j2 Z2 d Ñ  Z3 e( j) d d k r£d  Ñ  Z4 n  d! Ñ  Z5 d" Ñ  Z6 d# Ñ  Z7 d$ Ñ  Z8 d% Ñ  Z9 d& Ñ  Z: d d' Ñ Z; d( Ñ  Z< d) Ñ  Z= e( j) d d !d8 k rd+ Ñ  Z> n  d, Ñ  Z? d- Ñ  Z@ d. Ñ  ZA d/ Ñ  ZB d0 Ñ  ZC d1 Ñ  ZD d2 Ñ  ZE d3 Ñ  ZF d4 Ñ  ZG e d7 d7 d7 d5 Ñ ZH e d7 d7 d7 d7 d6 Ñ ZI RS(9   s   Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python :class:`int` objects.

    Parameters
    ----------
    value : :class:`int`, :class:`str` or |ASN.1| object
        Python integer or string literal or |ASN.1| class instance.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
        Object representing non-default symbolic aliases for numbers

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    i   c         C   sA   | d  k r |  j |  _ n	 | |  _ t j j |  | | | É d  S(   N(   t   Nonet   namedValuest   _Integer__namedValuesR    t   AbstractSimpleAsn1Itemt   __init__(   t   selft   valuet   tagSett   subtypeSpecR   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR!   ?   s
    		c         C   sG   |  j  |  j k	 r3 d t j j |  É d  |  j  f St j j |  É Sd  S(   Ns   %s, %r)iˇˇˇˇ(   R   R   R    R    t   __repr__(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR&   I   s    !c         C   s   |  j  |  j | @É S(   N(   t   clonet   _value(   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __and__O   s    c         C   s   |  j  | |  j @É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __rand__R   s    c         C   s   |  j  |  j | BÉ S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __or__U   s    c         C   s   |  j  | |  j BÉ S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __ror__X   s    c         C   s   |  j  |  j | AÉ S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __xor__[   s    c         C   s   |  j  | |  j AÉ S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __rxor__^   s    c         C   s   |  j  |  j | >É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt
   __lshift__a   s    c         C   s   |  j  |  j | ?É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt
   __rshift__d   s    c         C   s   |  j  |  j | É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __add__g   s    c         C   s   |  j  | |  j É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __radd__j   s    c         C   s   |  j  |  j | É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __sub__m   s    c         C   s   |  j  | |  j É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __rsub__p   s    c         C   s   |  j  |  j | É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __mul__s   s    c         C   s   |  j  | |  j É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __rmul__v   s    c         C   s   |  j  |  j | É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __mod__y   s    c         C   s   |  j  | |  j É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __rmod__|   s    c         C   s   |  j  t |  j | | É É S(   N(   R'   t   powR(   (   R"   R#   t   modulo(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __pow__   s    c         C   s   |  j  t | |  j É É S(   N(   R'   R9   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __rpow__Ç   s    c         C   s   |  j  |  j | É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __floordiv__Ö   s    c         C   s   |  j  | |  j É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __rfloordiv__à   s    i    c         C   s8   t  | t É r  t |  j | É S|  j |  j | É Sd  S(   N(   t
   isinstancet   floatR   R(   R'   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __div__å   s    c         C   s8   t  | t É r  t | |  j É S|  j | |  j É Sd  S(   N(   R?   R@   R   R(   R'   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __rdiv__í   s    c         C   s   t  |  j | É S(   N(   R   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __truediv__ò   s    c         C   s   t  | |  j É S(   N(   R   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __rtruediv__õ   s    c         C   s   |  j  t |  j | É É S(   N(   R'   t   divmodR(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt
   __divmod__û   s    c         C   s   |  j  t | |  j É É S(   N(   R'   RE   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __rdivmod__°   s    c         C   s   t  |  j É S(   N(   t   intR(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __int__¶   s    c         C   s   t  |  j É S(   N(   t   longR(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __long__™   s    c         C   s   t  |  j É S(   N(   R@   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt	   __float__¨   s    c         C   s   |  j  t |  j É É S(   N(   R'   t   absR(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __abs__Ø   s    c         C   s   t  |  j É S(   N(   RH   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt	   __index__≤   s    c         C   s   |  j  |  j 
É S(   N(   R'   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __pos__µ   s    c         C   s   |  j  |  j É S(   N(   R'   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __neg__∏   s    c         C   s   |  j  |  j É S(   N(   R'   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt
   __invert__ª   s    c         C   s-   t  |  j | É } | r% |  j | É S| Sd  S(   N(   t   roundR(   R'   (   R"   t   nt   r(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt	   __round__æ   s    c         C   s   t  j |  j É S(   N(   t   matht   floorR(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt	   __floor__≈   s    c         C   s   t  j |  j É S(   N(   RW   t   ceilR(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __ceil__»   s    i   c         C   s   |  j  t j |  j É É S(   N(   R'   RW   t   truncR(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt	   __trunc__Ã   s    c         C   s   |  j  | k  S(   N(   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __lt__Œ   s    c         C   s   |  j  | k S(   N(   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __le__—   s    c         C   s   |  j  | k S(   N(   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __eq__‘   s    c         C   s   |  j  | k S(   N(   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __ne__◊   s    c         C   s   |  j  | k S(   N(   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __gt__⁄   s    c         C   s   |  j  | k S(   N(   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __ge__›   s    c         C   sÆ   t  j | É sM y t | É SWqM t j d | t j É  d f É Ç qM Xn  |  j j | É } | d  k	 ro | Sy t | É SWn* t j d | t j É  d f É Ç n Xd  S(   Ns    Can't coerce %r into integer: %si   (
   R   t   isStringTypeRH   R
   t   PyAsn1Errort   syst   exc_infoR   t   getValueR   (   R"   R#   RU   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   prettyIn‡   s    $c         C   s4   |  j  j | É } | d  k r* t | É p3 t | É S(   N(   R   t   getNameR   t   strt   repr(   R"   R#   RU   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt	   prettyOutÚ   s    c         C   s   |  j  S(   N(   R   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   getNamedValuesˆ   s    c         C   sí   |  j  | É r4 |  j  | | | É r( |  S|  j } n  | d k rL |  j } n  | d k rd |  j } n  | d k r| |  j } n  |  j | | | | É S(   sÈ  Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`int`, :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

        namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
            Object representing symbolic aliases for numbers to use instead of inheriting from caller

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        N(   t	   isNoValueR(   R   t   _tagSett   _subtypeSpecR   t	   __class__(   R"   R#   R$   R%   R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR'   ˘   s    c         C   s∆   |  j  | É r |  j } n  | d k	 r< |  j j | É } n* | d k	 r] |  j j | É } n	 |  j } | d k r~ |  j } n |  j | } | d k r£ |  j } n | |  j } |  j | | | | É S(   sr  Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`int`, :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of 
            inheriting one from the caller.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Add ASN.1 constraints object to one of the caller, then
            use the result as new object's ASN.1 constraints.

        namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
            Add given object representing symbolic aliases for numbers
            to one of the caller, then use the result as new object's
            named numbers.

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        N(	   Ro   R(   R   Rp   t   tagImplicitlyt   tagExplicitlyRq   R   Rr   (   R"   R#   t   implicitTagt   explicitTagR%   R   R$   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   subtype  s    %	N(   i   i   (J   t   __name__t
   __module__t   __doc__R   t
   initTagSett   Tagt   tagClassUniversalt   tagFormatSimpleR$   t
   baseTagSetR   t   ConstraintsIntersectionR%   R   t   NamedValuesR   R   R   R!   R&   R)   R*   R+   R,   R-   R.   R/   R0   R1   R2   R3   R4   R5   R6   R7   R8   R;   R<   R=   R>   Rf   t   version_infoRA   RB   RC   RD   RF   RG   R    R    t   __hash__RI   RK   RL   RN   RO   RP   RQ   RR   RV   RY   R[   R]   R^   R_   R`   Ra   Rb   Rc   Ri   Rm   Rn   R'   Rw   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR      s~   																																													&	c           B   si   e  Z e j Z e j e j e j e j d  É É Z	 e	 Z
 e j e j d d  É Z e j j d d É Z RS(   i   i    t   Falset   True(   s   Falsei    (   s   Truei   (   Rx   Ry   R   Rz   R   R{   R|   R}   R~   R$   R   R%   R   t   SingleValueConstraintR   R'   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   W  s   	c           B   s  e  Z d  Z e j e j e j e j d É É Z e Z	 e
 j É  Z e j É  Z e Z Z e j d d k  rt e Z n e Z d e f d Ñ  É  YZ e d% d% d% e e d Ñ Z e d% d% d% e e d Ñ Z e d% d% d% d% e e d Ñ Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d Ñ  Z& d Ñ  Z' d Ñ  Z( d Ñ  Z) d Ñ  Z* d Ñ  Z+ d Ñ  Z, d Ñ  Z- d Ñ  Z. d Ñ  Z/ e j d d k  rÆd Ñ  Z0 n  d Ñ  Z1 d Ñ  Z2 d Ñ  Z3 d Ñ  Z4 e5 d  Ñ  É Z6 e5 d! Ñ  É Z7 e5 d d" Ñ É Z8 d# Ñ  Z9 d$ Ñ  Z: RS(&   sv  Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type both Python :class:`tuple` (as a tuple
    of bits) and :class:`int` objects.

    Parameters
    ----------
    value : :class:`int`, :class:`str` or |ASN.1| object
        Python integer or string literal representing binary or hexadecimal
        number or sequence of integer bits or |ASN.1| object.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
        Object representing non-default symbolic aliases for numbers

    binValue: :py:class:`str`
        Binary string initializer to use instead of the *value*.
        Example: '10110011'.

    hexValue: :py:class:`str`
        Hexadecimal string initializer to use instead of the *value*.
        Example: 'DEADBEEF'.

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    i   i    t   SizedIntegerc           B   s$   e  Z d Z Z d  Ñ  Z d Ñ  Z RS(   c         C   s,   | |  _  t | t j  |  É d É |  _ |  S(   Ni    (   t	   bitLengtht   maxR   t   leadingZeroBits(   R"   Rà   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   setBitLength£  s    	c         C   s/   |  j  d  k r( |  j t j  |  É É n  |  j  S(   N(   Rà   R   Rã   R   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __len__®  s    N(   Rx   Ry   R   Rà   Rä   Rã   Rå   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRá   †  s   
	c         C   sÊ   | d  k r |  j |  _ n	 | |  _ |  j | É sE |  j | É } n  |  j | É sf |  j | É } n  |  j | É r¿ |  j t k	 rô |  j |  j É } q¿ |  j t k	 r¿ |  j |  j É } q¿ n  i  |  _	 t
 j j |  | | | É d  S(   N(   R   R   t   _BitString__namedValuesRo   t   fromBinaryStringt   fromHexStringt   defaultBinValueR   t   defaultHexValuet   _BitString__asNumbersCacheR    R    R!   (   R"   R#   R$   R%   R   t   binValuet   hexValue(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR!   Æ  s    			c         C   sû   |  j  | | | É r: |  j  | | | É r. |  S|  j } n  | d k rR |  j } n  | d k rj |  j } n  | d k rÇ |  j } n  |  j | | | | | | É S(   sﬂ  Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value : :class:`int`, :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

        namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
            Class instance representing BitString type enumerations

        binValue: :py:class:`str`
            Binary string initializer to use instead of the *value*.
            Example: '10110011'.

        hexValue: :py:class:`str`
            Hexadecimal string initializer to use instead of the *value*.
            Example: 'DEADBEEF'.

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        N(   Ro   R(   R   Rp   Rq   Rç   Rr   (   R"   R#   R$   R%   R   Rì   Rî   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR'   ¬  s    #c   	      C   sÓ   |  j  | | | É r= |  j  | | | | É r1 |  S|  j } n  | d k	 r^ |  j j | É } n* | d k	 r |  j j | É } n	 |  j } | d k r† |  j } n |  j | } | d k r≈ |  j } n | |  j } |  j | | | | | | É S(   sâ  Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value : :class:`int`, :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Add ASN.1 constraints object to one of the caller, then
            use the result as new object's ASN.1 constraints.

        namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`
            Add given object representing symbolic aliases for numbers
            to one of the caller, then use the result as new object's
            named numbers.

        binValue: :py:class:`str`
            Binary string initializer to use instead of the *value*.
            Example: '10110011'.

        hexValue: :py:class:`str`
            Hexadecimal string initializer to use instead of the *value*.
            Example: 'DEADBEEF'.

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        N(	   Ro   R(   R   Rp   Rs   Rt   Rq   Rç   Rr   (	   R"   R#   Ru   Rv   R%   R   Rì   Rî   R$   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRw   Ò  s     -	c         C   s
   |  j  É  S(   N(   t   asBinary(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __str__2  s    c         C   sC   |  j  | É } |  | k pB |  j | k oB t |  j É t | É k S(   N(   Ri   R(   t   len(   R"   t   other(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR`   5  s    c         C   s7   |  j  | É } |  j | k p6 t |  j É t | É k S(   N(   Ri   R(   Ró   (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRa   9  s    c         C   sR   |  j  | É } t |  j É t | É k  pQ t |  j É t | É k oQ |  j | k  S(   N(   Ri   Ró   R(   (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR^   =  s    c         C   sR   |  j  | É } t |  j É t | É k pQ t |  j É t | É k oQ |  j | k S(   N(   Ri   Ró   R(   (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR_   A  s    c         C   sR   |  j  | É } t |  j É t | É k pQ t |  j É t | É k oQ |  j | k S(   N(   Ri   Ró   R(   (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRb   E  s    c         C   sR   |  j  | É } t |  j É t | É k pQ t |  j É t | É k oQ |  j | k S(   N(   Ri   Ró   R(   (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRc   I  s    c         C   s   t  |  j É S(   N(   Ró   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRå   O  s    c         C   sô   t  | t É rH |  j g  t | j t |  É É å  D] } |  | ^ q1 É St |  j É d } | | k ss | d k  rÇ t d É Ç n  |  j | | ?d @Sd  S(   Ni   i    s   bit index out of range(   R?   t   sliceR'   t   ranget   indicesRó   R(   t
   IndexError(   R"   t   it   xt   length(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __getitem__R  s    9c         c   s:   t  |  j É } x$ | r5 | d 8} |  j | ?d @Vq Wd  S(   Ni   (   Ró   R(   (   R"   Rü   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __iter__[  s    	
c         C   s   t  t |  É É S(   N(   t   reversedt   tuple(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __reversed__a  s    c         C   sR   |  j  | É } |  j |  j |  j t | É >| BÉ j t |  j É t | É É É S(   N(   Ri   R'   Rá   R(   Ró   Rã   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR1   f  s    c         C   sU   |  j  | É } |  j |  j | t |  j É >|  j BÉ j t |  j É t | É É É S(   N(   Ri   R'   Rá   Ró   R(   Rã   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR2   j  s    c         C   sS   |  j  } x: | d k rE | t |  j  É K} | |  j  O} | d 8} q W|  j | É S(   Ni   (   R(   Ró   R'   (   R"   R#   t	   bitString(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR5   n  s    	c         C   s   |  | S(   N(    (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR6   v  s    c         C   s3   |  j  |  j |  j | >É j t |  j É | É É S(   N(   R'   Rá   R(   Rã   Ró   (   R"   t   count(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR/   y  s    c         C   s<   |  j  |  j |  j | ?É j t d t |  j É | É É É S(   Ni    (   R'   Rá   R(   Rã   Râ   Ró   (   R"   R¶   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR0   |  s    c         C   s   |  j  S(   N(   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRI     s    c         C   s   t  |  j É S(   N(   R@   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRL   Ç  s    c         C   s   |  j  S(   N(   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRK   Ü  s    c         C   s   t  t j |  j É  É É S(   s§   Get |ASN.1| value as a sequence of 8-bit integers.

        If |ASN.1| object length is not a multiple of 8, result
        will be left-padded with zeros.
        (   R£   R   t	   octs2intst   asOctets(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt	   asNumbersâ  s    c         C   s   t  j |  j d t |  É ÉS(   sú   Get |ASN.1| value as a sequence of octets.

        If |ASN.1| object length is not a multiple of 8, result
        will be left-padded with zeros.
        Rü   (   R   t   to_bytesR(   Ró   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR®   ë  s    c         C   s   |  j  S(   s5   Get |ASN.1| value as a single integer value.
        (   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt	   asIntegerô  s    c         C   s5   t  j |  j É d } d t |  j É t | É | S(   s4   Get |ASN.1| value as a text string of bits.
        i   t   0(   R	   t   binR(   Ró   (   R"   t	   binString(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRï   û  s    c         C   se   y' |  j  | d É j t | É d É SWn7 t k
 r` t j d |  j t j É  d f É Ç n Xd  S(   Ni   i   s   %s.fromHexString() error: %si   (	   Rá   Rã   Ró   t
   ValueErrorR
   Re   Rx   Rf   Rg   (   t   clsR#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRè   §  s    'c         C   sg   y) |  j  | p d d É j t | É É SWn7 t k
 rb t j d |  j t j É  d f É Ç n Xd  S(   NR¨   i   s   %s.fromBinaryString() error: %si   (	   Rá   Rã   Ró   RØ   R
   Re   Rx   Rf   Rg   (   R∞   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRé   ¨  s    )c         C   s7   |  |  j  t j | É | ?É j t | É d | É É S(   Ni   (   Rá   R   t
   from_bytesRã   Ró   (   R∞   R#   t   padding(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   fromOctetString¥  s    c         C   sJ  t  j | É rñ| s+ |  j d É j d É S| d d k rú | d d k r_ |  j | d d !É S| d d k rÉ |  j | d d !É St j d | f É Ç qF|  j rF| j	 É  rFd } d } xk | j
 d É D]Z } |  j j | É } | d  k rt j d	 | f É Ç n  | d | >O} t | | É } qŒ W|  j | É j | d É S| j d
 É rf|  j | d É S| j d É rÜ|  j | d É S|  j | É Sn∞ t | t t f É r‡|  j d j g  | D] } | r–d p”d ^ qæÉ É St | |  j t f É r|  j | É j t | É É St | t É r0|  j | É St j d | f É Ç d  S(   Ni    s   'i˛ˇˇˇs   'Bi   s   'Hs    Bad BIT STRING value notation %st   ,s   Unknown bit identifier '%s't   0xi   t   0bt    t   1R¨   s#   Bad BitString initializer type '%s'(   R   Rd   Rá   Rã   Ré   Rè   R
   Re   Rç   t   isdigitt   splitRh   R   Râ   t
   startswithR?   R£   t   listt   joinR   Ró   t   intTypes(   R"   R#   t   numbert   highestBitPositiont   namedBitt   bitPositiont   b(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRi   ∏  sD    5c         C   s   d t  |  É S(   Ns   '%s'(   Rk   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRm   Ó  s    N(;   Rx   Ry   Rz   R   R{   R|   R}   R~   R$   R   R   RÄ   R%   R   RÅ   R   R   Rê   Rë   Rf   RÇ   RJ   t   SizedIntegerBaseRH   Rá   R   R!   R'   Rw   Rñ   R`   Ra   R^   R_   Rb   Rc   Rå   R†   R°   R§   R1   R2   R5   R6   R/   R0   RI   RL   RK   R©   R®   R´   Rï   t   classmethodRè   Ré   R≥   Ri   Rm   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   i  s`   !
			.	@																									6c         C   s   x |  D] } | s t  Sq Wt S(   N(   RÑ   RÖ   (   t   iterablet   element(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   all¯  s    c           B   s´  e  Z d  Z e j e j e j e j d É É Z e Z	 e
 j É  Z e Z Z d Z e d! d! d! e e d Ñ Z e d! d! d! e e d Ñ Z e d! d! d! d! e e d Ñ Z e j d d k rÈ d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z n- d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ  É Z e d Ñ  É Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d Ñ  Z& d Ñ  Z' d Ñ  Z( d Ñ  Z) d Ñ  Z* d Ñ  Z+ d  Ñ  Z, RS("   s^  Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python 2 :class:`str` or Python 3 :class:`bytes`.
    When used in Unicode context, |ASN.1| type assumes "|encoding|" serialization.

    Parameters
    ----------
    value : :class:`str`, :class:`bytes` or |ASN.1| object
        string (Python 2) or bytes (Python 3), alternatively unicode object
        (Python 2) or string (Python 3) representing character string to be
        serialized into octets (note `encoding` parameter) or |ASN.1| object.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    encoding: :py:class:`str`
        Unicode codec ID to encode/decode :class:`unicode` (Python 2) or
        :class:`str` (Python 3) the payload when |ASN.1| object is used
        in text string context.

    binValue: :py:class:`str`
        Binary string initializer to use instead of the *value*.
        Example: '10110011'.
        
    hexValue: :py:class:`str`
        Hexadecimal string initializer to use instead of the *value*.
        Example: 'DEADBEEF'.

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    i   s
   iso-8859-1c         C   sÊ   | d  k r |  j |  _ n	 | |  _ |  j | É sE |  j | É } n  |  j | É sf |  j | É } n  |  j | É r¿ |  j t k	 rô |  j |  j É } q¿ |  j t k	 r¿ |  j |  j É } q¿ n  d  |  _	 t
 j j |  | | | É d  S(   N(   R   t   encodingt	   _encodingRo   Ré   Rè   Rê   R   Rë   t   _OctetString__asNumbersCacheR    R    R!   (   R"   R#   R$   R%   R…   Rì   Rî   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR!   1  s    		c         C   sû   |  j  | | | É r: |  j  | | | É r. |  S|  j } n  | d k rR |  j } n  | d k rj |  j } n  | d k rÇ |  j } n  |  j | | | | | | É S(   sË  Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value : :class:`str`, :class:`bytes` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

        encoding: :py:class:`str`
            Unicode codec ID to encode/decode :class:`unicode` (Python 2)
            or :class:`str` (Python 3) the payload when |ASN.1|
            object is used in string context.

        binValue: :py:class:`str`
            Binary string initializer. Example: '10110011'.
        
        hexValue: :py:class:`str`
            Hexadecimal string initializer. Example: 'DEADBEEF'.

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        N(   Ro   R(   R   Rp   Rq   R    Rr   (   R"   R#   R$   R%   R…   Rì   Rî   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR'   C  s    #c   	      C   s·   |  j  | | | É r= |  j  | | | | É r1 |  S|  j } n  | d k	 r^ |  j j | É } n* | d k	 r |  j j | É } n	 |  j } | d k r† |  j } n |  j | } | d k r≈ |  j } n  |  j | | | | | | É S(   sO  Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value : :class:`str`, :class:`bytes` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to |ASN.1| object tag set
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to |ASN.1| object tag set
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Add ASN.1 constraints object to one of the caller, then
            use the result as new object's ASN.1 constraints.

        encoding: :py:class:`str`
            Unicode codec ID to encode/decode :class:`unicode` (Python 2)
            or :class:`str` (Python 3) the payload when *OctetString*
            object is used in string context.

        binValue: :py:class:`str`
            Binary string initializer. Example: '10110011'.
        
        hexValue: :py:class:`str`
            Hexadecimal string initializer. Example: 'DEADBEEF'.

        Returns
        -------
        :
             new instance of |ASN.1| type/value
        N(	   Ro   R(   R   Rp   Rs   Rt   Rq   R    Rr   (	   R"   R#   Ru   Rv   R%   R…   Rì   Rî   R$   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRw   t  s     ,	i    i   c         C   sÚ   t  | t É r | St  | t É ro y | j |  j É SWqÓ t t f k
 rk t j d | |  j f É Ç qÓ Xn t  | t	 t
 f É r‰ y* d j g  | D] } t | É ^ qî É SWqÓ t k
 r‡ t j d |  j j | f É Ç qÓ Xn
 t | É Sd  S(   Ns(   Can't encode string '%s' with '%s' codecR∑   s   Bad %s initializer '%s'(   R?   Rk   t   unicodet   encodeR    t   LookupErrort   UnicodeEncodeErrorR
   Re   R£   Rº   RΩ   t   chrRØ   Rr   Rx   (   R"   R#   Rû   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRi   µ  s    * c         C   s   t  |  j É S(   N(   Rk   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRñ   …  s    c         C   sN   y |  j  j |  j É SWn0 t k
 rI t j d |  j  |  j f É Ç n Xd  S(   Ns(   Can't decode string '%s' with '%s' codec(   R(   t   decodeR    t   UnicodeDecodeErrorR
   Re   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __unicode__Ã  s
    c         C   s   t  |  j É S(   N(   Rk   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR®   ’  s    c         C   sD   |  j  d  k r= t g  |  j D] } t | É ^ q É |  _  n  |  j  S(   N(   RÀ   R   R£   R(   t   ord(   R"   Rû   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR©   ÿ  s    .c         C   s›   t  | t É r | St  | t É ri y | j |  j É SWqŸ t k
 re t j d | |  j f É Ç qŸ Xnp t  | t É rÇ | j	 É  St  | t
 j É rß |  j t | É É St  | t t f É rœ |  j t | É É St | É Sd  S(   Ns(   Can't encode string '%s' with '%s' codec(   R?   t   bytesRk   RÕ   R    Rœ   R
   Re   R   R®   R    R    Ri   R£   Rº   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRi   ﬁ  s    
c         C   sW   y |  j  j |  j É SWn9 t k
 rR t j d |  j  |  j |  j j f É Ç n Xd  S(   Ns0   Can't decode string '%s' with '%s' codec at '%s'(   R(   R—   R    R“   R
   Re   Rr   Rx   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRñ   Ò  s
    c         C   s   t  |  j É S(   N(   R’   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt	   __bytes__˙  s    c         C   s   t  |  j É S(   N(   R’   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR®   ˝  s    c         C   s+   |  j  d  k r$ t |  j É |  _  n  |  j  S(   N(   RÀ   R   R£   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR©      s    c         C   sç   t  j d d k r, t d Ñ  | DÉ É } n t | É } xN | D]9 } | d k  s] | d k r? d d j d Ñ  | DÉ É Sq? Wt j | É Sd  S(	   Ni    i   c         s   s   |  ] } t  | É Vq d  S(   N(   R‘   (   t   .0Rû   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pys	   <genexpr>  s    i    i~   Rµ   R∑   c         s   s   |  ] } d  | Vq d S(   s   %.2xN(    (   R◊   Rû   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pys	   <genexpr>  s    (   Rf   RÇ   R£   RΩ   R   t   octs2str(   R"   R#   t   numbersRû   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRm     s    c         C   s®   d } d } g  } xy |  D]q } | r2 | d 8} n d } | j  | É d } | d k rf t | É } n t j d | f É Ç | | | >O} q W| j  | É t j | É S(	   Ni   i    i   i   R¨   R∏   s&   Non-binary OCTET STRING initializer %s(   R¨   R∏   (   t   appendRH   R
   Re   R   t	   ints2octs(   R#   t   bitNot   byteRU   t   v(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRé     s     c         C   s|   g  } g  } x= |  D]5 } | rB | j  t | | d É É d  } q | } q W| ro | j  t | d d É É n  t j | É S(   Ni   R¨   (   R⁄   RH   R   R   R€   (   R#   RU   t   pRﬁ   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRè   (  s    	
c         C   s[  g  } t  } |  j |  j k	 rz x6 |  j É  D]( } | d k  sI | d k r+ t } Pq+ q+ W| sz | j d |  j f É qz n  |  j |  j k	 r¶ | j d |  j f É n  |  j |  j	 k	 r“ | j d |  j f É n  |  j
 |  j k	 r˛ | j d |  j f É n  | r>| j d d j g  |  j É  D] } d	 | ^ q É É n  d
 |  j j d j | É f S(   Ni    i~   s   %rs	   tagSet=%rs   subtypeSpec=%rs   encoding=%rs   hexValue=%rR∑   s   %.2xs   %s(%s)s   , (   RÑ   R(   t   defaultValueR©   RÖ   R⁄   Rp   R$   Rq   R%   R…   R    RΩ   Rr   Rx   (   R"   RU   t   doHexRû   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR&   7  s$    :c         C   s+   |  j  d  k r$ t |  j É |  _  n  |  j  S(   N(   t   _lenR   Ró   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRå   M  s    c         C   s:   t  | t É r+ |  j t j |  j | É É S|  j | Sd  S(   N(   R?   Rô   R'   t   operatort   getitemR(   (   R"   Rù   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR†   R  s    c         C   s   t  |  j É S(   N(   t   iterR(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR°   X  s    c         C   s   | |  j  k S(   N(   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __contains__[  s    c         C   s   |  j  |  j |  j | É É S(   N(   R'   R(   Ri   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR1   ^  s    c         C   s   |  j  |  j | É |  j É S(   N(   R'   Ri   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR2   a  s    c         C   s   |  j  |  j | É S(   N(   R'   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR5   d  s    c         C   s   |  | S(   N(    (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR6   g  s    c         C   s   t  |  j É S(   N(   RH   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRI   j  s    c         C   s   t  |  j É S(   N(   R@   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRL   m  s    c         C   s   t  |  j É S(   N(   R¢   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR§   p  s    N(-   Rx   Ry   Rz   R   R{   R|   R}   R~   R$   R   R   RÄ   R%   R   Rê   Rë   R…   R   R!   R'   Rw   Rf   RÇ   Ri   Rñ   R”   R®   R©   R÷   Rm   t   staticmethodRé   Rè   R&   Rå   R†   R°   RÊ   R1   R2   R5   R6   RI   RL   R§   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   ˇ  sP   $
		0		>																							c           B   sÑ   e  Z d  Z d j É  Z e j e j e j e j	 d É É Z
 e
 Z e j e j e j d É É Z e d d Ñ Z e d d d Ñ Z RS(   sˇ  Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python :class:`str` objects (always empty).

    Parameters
    ----------
    value : :class:`str` or :py:class:`~pyasn1.type.univ.Null` object
        Python empty string literal or *Null* class instance.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    R∑   i   c         C   s   t  j |  | | É S(   sâ  Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of 
            inheriting one from the caller.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

        Returns
        -------
        : :py:class:`~pyasn1.type.univ.Null`
            new instance of NULL type/value
        (   R   R'   (   R"   R#   R$   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR'   ê  s    c         C   s   t  j |  | | | É S(   s—  Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`int`, :class:`str` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        Returns
        -------
        : :py:class:`~pyasn1.type.univ.Null`
            new instance of NULL type/value
        (   R   Rw   (   R"   R#   Ru   Rv   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRw   ¶  s    N(   Rx   Ry   Rz   RÕ   R‡   R   R{   R|   R}   R~   R$   R   R   R%   R   RÜ   R   t   str2octsR   R   R'   Rw   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   t  s   i    i   c           B   sπ   e  Z d  Z e j e j e j e j d É É Z e Z	 e
 j É  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s®  Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python :class:`tuple` objects (tuple of non-negative integers).

    Parameters
    ----------
    value: :class:`tuple`, :class:`str` or |ASN.1| object
        Python sequence of :class:`int` or string literal or |ASN.1| object.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.
    i   c         C   s   |  j  |  j | É S(   N(   R'   R(   (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR1   Ï  s    c         C   s   |  j  | |  j É S(   N(   R'   R(   (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR2   Ô  s    c         C   s   |  j  S(   N(   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   asTupleÚ  s    c         C   s+   |  j  d  k r$ t |  j É |  _  n  |  j  S(   N(   R‚   R   Ró   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRå   ˜  s    c         C   s:   t  | t É r+ |  j t j |  j | É É S|  j | Sd  S(   N(   R?   Rô   R'   R„   R‰   R(   (   R"   Rù   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR†   ¸  s    c         C   s   t  |  j É S(   N(   RÂ   R(   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR°     s    c         C   s   | |  j  k S(   N(   R(   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRÊ     s    c         C   s
   |  j  É  S(   N(   t   prettyPrint(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRñ   
  s    c         C   s   d |  j  j |  j É  f S(   Ns   %s(%r)(   Rr   Rx   RÍ   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR&     s    c         C   s   |  j  j | É S(   N(   R(   t   index(   R"   t   suboid(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRÎ     s    c         C   s@   t  |  É } | t  | É k r< |  j |  | |  k r< t Sn  t S(   sv  Indicate if this |ASN.1| object is a prefix of other |ASN.1| object.

        Parameters
        ----------
        other: |ASN.1| object
            |ASN.1| object

        Returns
        -------
        : :class:`bool`
            :class:`True` if this |ASN.1| object is a parent (e.g. prefix) of the other |ASN.1| object
            or :class:`False` otherwise.
        (   Ró   R(   RÖ   RÑ   (   R"   Rò   t   l(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt
   isPrefixOf  s
    c         C   sñ  t  | t É r t | É St j | É r‹ d | k rc t j d | |  j j t	 j
 É  d f É Ç n  y6 t g  | j d É D] } | ry t | É ^ qy É SWq‹ t k
 rÿ t j d | |  j j t	 j
 É  d f É Ç q‹ Xn  y5 t g  | D] } | d k rÈ t | É ^ qÈ É } WnC t t f k
 rVt j d | |  j j t	 j
 É  d f É Ç n Xt | É t | É k rs| St j d | |  j j f É Ç d  S(   Nt   -s    Malformed Object ID %s at %s: %si   t   .i    s   Malformed Object ID %s at %s(   R?   R   R£   R   Rd   R
   Re   Rr   Rx   Rf   Rg   R∫   RH   RØ   t	   TypeErrorRó   (   R"   R#   t   subOidt   tupleOfInts(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRi   '  s&    
)6-5*c         C   s&   d j  g  | D] } t | É ^ q É S(   NR   (   RΩ   Rk   (   R"   R#   Rû   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRm   C  s    (   Rx   Ry   Rz   R   R{   R|   R}   R~   R$   R   R   RÄ   R%   R1   R2   RÈ   Rå   R†   R°   RÊ   Rñ   R&   RÎ   RÓ   Ri   Rm   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   Ã  s$   												c           B   s∂  e  Z d  Z d4 Z y( e d É Z e d É Z e e f Z Wn! e	 k
 r] d4 Z Z d5 Z n Xe
 j e
 j e
 j e
 j d É É Z e Z e j É  Z e d4 d4 d Ñ Z e d4 d4 d4 d Ñ Z e d Ñ  É Z d Ñ  Z d Ñ  Z d	 d
 Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d Ñ  Z& d Ñ  Z' d4 d Ñ Z( d Ñ  Z) e* j+ d	 d k rëd Ñ  Z, d Ñ  Z- n$ d Ñ  Z. d Ñ  Z/ d Ñ  Z0 d Ñ  Z1 d  Ñ  Z2 e* j+ d	 d k r›d! Ñ  Z3 n  d" Ñ  Z4 d# Ñ  Z5 d$ Ñ  Z6 d% Ñ  Z7 d	 d& Ñ Z8 d' Ñ  Z9 d( Ñ  Z: e* j+ d	 d !d6 k rAd* Ñ  Z; n  d+ Ñ  Z< d, Ñ  Z= d- Ñ  Z> d. Ñ  Z? d/ Ñ  Z@ d0 Ñ  ZA e* j+ d	 d k rñd1 Ñ  ZB n d2 Ñ  ZC eD jE jF ZF d3 Ñ  ZG RS(7   sC  Create |ASN.1| type or object.

    |ASN.1| objects are immutable and duck-type Python :class:`float` objects.
    Additionally, |ASN.1| objects behave like a :class:`tuple` in which case its
    elements are mantissa, base and exponent.

    Parameters
    ----------
    value: :class:`tuple`, :class:`float` or |ASN.1| object
        Python sequence of :class:`int` (representing mantissa, base and
        exponent) or float instance or *Real* class instance.

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    Raises
    ------
    : :py:class:`pyasn1.error.PyAsn1Error`
        On constraint violation or bad initializer.

    t   infs   -infi	   c         C   s   t  j j |  | | | É S(   sC  Create a copy of a |ASN.1| type or object.

        Any parameters to the *clone()* method will replace corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`tuple`, :class:`float` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        tagSet: :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
            Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        (   R    R    R'   (   R"   R#   R$   R%   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR'   v  s    c         C   s   t  j j |  | | | É S(   s  Create a copy of a |ASN.1| type or object.

        Any parameters to the *subtype()* method will be added to the corresponding
        properties of the |ASN.1| object.

        Parameters
        ----------
        value: :class:`tuple`, :class:`float` or |ASN.1| object
            Initialization value to pass to new ASN.1 object instead of
            inheriting one from the caller.

        implicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Implicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        explicitTag: :py:class:`~pyasn1.type.tag.Tag`
            Explicitly apply given ASN.1 tag object to caller's 
            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as
            new object's ASN.1 tag(s).

        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
             Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller

        Returns
        -------
        :
            new instance of |ASN.1| type/value
        (   R    R    Rw   (   R"   R#   Ru   Rv   R%   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRw   è  s    c         C   sM   |  \ } } } x. | r? | d d k r? | d :} | d 7} q W| | | f S(   Ni
   i    i   (    (   R#   t   mR√   t   e(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __normalizeBase10∞  s
    
c         C   s0  t  | t É r t | É d k r t  | d t É s] t  | d t É s] t  | d t É rv t j d | f É Ç n  t  | d t É r≠ |  j r≠ | d |  j k r≠ | d S| d d	 k r⁄ t j d | d f É Ç n  | d d k r¸ |  j	 | É } n  | St  | t É r%|  j	 | d d f É St  | t É sCt
 j | É r˝t
 j | É rèy t | É } Wqèt k
 rãt j d | f É Ç qèXn  |  j r´| |  j k r´| Sd } x* t | É | k r›| d 9} | d 8} q¥W|  j	 t | É d | f É Sn t  | t É rt | É St j d | f É Ç d  S(
   Ni   i    i   i   s   Lame Real value syntax: %si
   s"   Prohibited base for Real value: %ss   Bad real value syntax: %s(   i   i
   (   R?   R£   Ró   t   numericTypesRæ   R
   Re   R@   t   _inft   _Real__normalizeBase10R   Rd   RØ   RH   R   (   R"   R#   Rˆ   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRi   ∏  sD    !

c         C   s%   | |  j  k r d | St | É Sd  S(   Ns   '%s'(   R˘   Rk   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRm   ‡  s    i    c         C   s0   |  j  É  r |  j |  j É St t |  É É Sd  S(   N(   t
   isInfinityRm   R(   Rk   R@   (   R"   t   scope(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRÍ   Ê  s    c         C   s   |  j  |  j k S(   s‘   Indicate PLUS-INFINITY object value

        Returns
        -------
        : :class:`bool`
            :class:`True` if calling object represents plus infinity
            or :class:`False` otherwise.

        (   R(   t   _plusInf(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   isPlusInfinityÏ  s    
c         C   s   |  j  |  j k S(   s’   Indicate MINUS-INFINITY object value

        Returns
        -------
        : :class:`bool`
            :class:`True` if calling object represents minus infinity
            or :class:`False` otherwise.
        (   R(   t	   _minusInf(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   isMinusInfinity¯  s    	c         C   s   |  j  |  j k S(   N(   R(   R˘   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR˚     s    c         C   s   t  t |  É É S(   N(   Rk   R@   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRñ     s    c         C   s   |  j  t |  É | É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR1   	  s    c         C   s   |  | S(   N(    (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR2     s    c         C   s   |  j  t |  É | É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR5     s    c         C   s   |  | S(   N(    (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR6     s    c         C   s   |  j  t |  É | É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR3     s    c         C   s   |  j  | t |  É É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR4     s    c         C   s   |  j  t |  É | É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR7     s    c         C   s   |  j  | t |  É É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR8     s    c         C   s   |  j  t t |  É | | É É S(   N(   R'   R9   R@   (   R"   R#   R:   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR;   !  s    c         C   s   |  j  t | t |  É É É S(   N(   R'   R9   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR<   $  s    i   c         C   s   |  j  t |  É | É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRA   (  s    c         C   s   |  j  | t |  É É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRB   +  s    c         C   s   |  j  t |  É | É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRC   .  s    c         C   s   |  j  | t |  É É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRD   1  s    c         C   s   |  j  t |  É | É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRF   4  s    c         C   s   |  j  | t |  É É S(   N(   R'   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRG   7  s    c         C   s   t  t |  É É S(   N(   RH   R@   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRI   :  s    c         C   s   t  t |  É É S(   N(   RJ   R@   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRK   >  s    c         C   sI   |  j  |  j k r |  j  St |  j  d t |  j  d |  j  d É É Sd  S(   Ni    i   i   (   R(   R˘   R@   R9   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRL   @  s    c         C   s   |  j  t t |  É É É S(   N(   R'   RM   R@   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRN   H  s    c         C   s   |  j  t |  É 
É S(   N(   R'   R@   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRP   K  s    c         C   s   |  j  t |  É É S(   N(   R'   R@   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRQ   N  s    c         C   s0   t  t |  É | É } | r( |  j | É S| Sd  S(   N(   RS   R@   R'   (   R"   RT   RU   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRV   Q  s    c         C   s   |  j  t j t |  É É É S(   N(   R'   RW   RX   R@   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRY   X  s    c         C   s   |  j  t j t |  É É É S(   N(   R'   RW   RZ   R@   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR[   [  s    i   c         C   s   |  j  t j t |  É É É S(   N(   R'   RW   R\   R@   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR]   _  s    c         C   s   t  |  É | k  S(   N(   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR^   a  s    c         C   s   t  |  É | k S(   N(   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR_   d  s    c         C   s   t  |  É | k S(   N(   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR`   g  s    c         C   s   t  |  É | k S(   N(   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRa   j  s    c         C   s   t  |  É | k S(   N(   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRb   m  s    c         C   s   t  |  É | k S(   N(   R@   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRc   p  s    c         C   s   t  t |  É É S(   N(   t   boolR@   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __nonzero__t  s    c         C   s   t  t |  É É S(   N(   R  R@   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   __bool__w  s    c         C   s3   |  j  |  j k r$ t j d É Ç n |  j  | Sd  S(   Ns    Invalid infinite value operation(   R(   R˘   R
   Re   (   R"   t   idx(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR†   |  s    N(    (   i   i   (H   Rx   Ry   Rz   R   t
   binEncBaseR@   R˝   Rˇ   R˘   RØ   R   R{   R|   R}   R~   R$   R   R   RÄ   R%   R   R'   Rw   RÁ   R˙   Ri   Rm   RÍ   R˛   R   R˚   Rñ   R1   R2   R5   R6   R3   R4   R7   R8   R;   R<   Rf   RÇ   RA   RB   RC   RD   RF   RG   RI   RK   RL   RN   RP   RQ   RV   RY   R[   R]   R^   R_   R`   Ra   Rb   Rc   R  R  R    R    RÉ   R†   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   G  sÄ   

	 	(																																	c           B   sS   e  Z e j Z e j e j e j e j d  É É Z	 e	 Z
 e j É  Z e j É  Z RS(   i
   (   Rx   Ry   R   Rz   R   R{   R|   R}   R~   R$   R   R   RÄ   R%   R   RÅ   R   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   É  s   	c           B   s™   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d d Ñ Z d Ñ  Z	 d e
 d Ñ Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z e e e e d Ñ Z d Ñ  Z d d Ñ Z d d Ñ Z RS(   sî  Create |ASN.1| type.

    |ASN.1| objects are mutable and duck-type Python :class:`list` objects.

    Parameters
    ----------
    componentType : :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
        A pyasn1 object representing ASN.1 type allowed within |ASN.1| type

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    sizeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing collection size constraint
     c         C   s   g  |  _  d |  _ d  S(   Ni    (   t   _componentValuest   _componentValuesSet(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   clear¨  s    	c         C   s   | |  t  |  É <d  S(   N(   Ró   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR⁄   ∞  s    c         C   s   |  j  j | É S(   N(   R  R¶   (   R"   R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR¶   ≥  s    c         C   s"   x | D] } |  j  | É q Wd  S(   N(   R⁄   (   R"   t   valuesR#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   extend∂  s    i    c         C   s1   | d  k r t |  É } n  |  j j | | | É S(   N(   R   Ró   R  RÎ   (   R"   R#   t   startt   stop(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRÎ   ∫  s    c         C   s   |  j  j É  d  S(   N(   R  t   reverse(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR  ø  s    c         C   s   |  j  j d | d | É d  S(   Nt   keyR  (   R  t   sort(   R"   R  R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR  ¬  s    c         C   s   t  |  j É S(   N(   RÂ   R  (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR°   ≈  s    c         C   sz   xs t  |  j É D]b \ } } | d  k	 r t | t j É rY | j | | j d | É É qr | j | | j É  É q q Wd  S(   Nt   cloneValueFlag(   t	   enumerateR  R   R?   R    t   AbstractConstructedAsn1Itemt   setComponentByPositionR'   (   R"   t   myCloneR  R  t   componentValue(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   _cloneComponentValues»  s    c         C   s   |  j  | S(   s_  Return |ASN.1| type component value by position.

        Equivalent to Python sequence subscription operation (e.g. `[]`).

        Parameters
        ----------
        idx : :class:`int`
            component index (zero-based)

        Returns
        -------
        : :py:class:`~pyasn1.type.base.PyAsn1Item`
            a pyasn1 object
        (   R  (   R"   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   getComponentByPosition“  s    c   	      C   s  |  j  } t |  j É } | | k r7 |  j j d É n@ | | k rw |  j j g  t | | d É D] } d ^ qa É n  |  j | É r‡ |  j | d k r‹ | d k r∑ t j	 d É Ç n  | j
 É  |  j | <|  j d 7_ n  |  St | t j É sS| d k rt j	 d É Ç n  t | t j É r7| j
 d | É } q–t j	 d | j j É Ç n} | d k	 r–|  j rú| j | | | É sÕt j	 d | | f É Ç qÕq–| j | | | É s–t j	 d | | f É Ç q–n  | rÈ|  j | | É n  |  j | d k r|  j d 7_ n  | |  j | <|  S(   s  Assign |ASN.1| type component by position.

        Equivalent to Python sequence item assignment operation (e.g. `[]`).

        Parameters
        ----------
        idx : :class:`int`
            component index (zero-based)

        value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
            A Python or pyasn1 object to assign or :py:class:`~pyasn1.type.univ.noValue`
            object to instantiate component type.

        verifyConstraints : :class:`bool`
             If `False`, skip constraints validation

        matchTags: :class:`bool`
             If `False`, skip component tags matching

        matchConstraints: :class:`bool`
             If `False`, skip component constraints matching

        Returns
        -------
        self
        i   s   Component type not definedR#   s   %s instance value requireds-   Component value is tag-incompatible: %r vs %rN(   t   _componentTypeRó   R  R⁄   R   R
  Rö   Ro   R
   Re   R'   R  R?   R    t   Asn1ItemR    Rr   Rx   t   strictConstraintst   isSameTypeWitht   isSuperTypeOft   _verifySubtypeSpec(	   R"   R  R#   t   verifyConstraintst	   matchTagst   matchConstraintst   componentTypet   componentValuesLengthRû   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR  „  s>    	4	c         C   s    |  j  d  k	 r |  j  j É  Sd  S(   N(   R  R   t	   getTagMap(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   getComponentTagMap*  s    c         C   sÜ   | d 7} |  j  j d } xe t t |  j É É D]N } | d | 7} |  j | d  k rd | d 7} q0 | |  j | j | É } q0 W| S(   Ni   s   :
t    s   <empty>(   Rr   Rx   Rö   Ró   R  R   RÍ   (   R"   R¸   RU   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRÍ   .  s    
c         C   st   | d 7} d |  j  É  |  j j f } |  j d  k	 r\ | d | 7} | |  j j | É } n  | d d | d d S(   Ni   s   %s -> %s {
R%  s   
t   }(   t	   getTagSetRr   Rx   R  R   t   prettyPrintType(   R"   R¸   RU   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR(  9  s    
N(   Rx   Ry   Rz   R  R⁄   R¶   R
  R   RÎ   R  RÑ   R  R°   R  R  R   RÖ   R  R$  RÍ   R(  (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   ñ  s$   							
	D	c           B   s_   e  Z e j Z e j e j e j e j d  É É Z	 e	 Z
 d Z e j É  Z e j É  Z d Z RS(   i   i   N(   Rx   Ry   R   Rz   R   R{   R|   R}   t   tagFormatConstructedR$   R   R   R!  R   RÄ   R%   t   sizeSpect   typeId(    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   B  s   	c           B   s_   e  Z e j Z e j e j e j e j d  É É Z	 e	 Z
 d Z e j É  Z e j É  Z d Z RS(   i   i   N(   Rx   Ry   R   Rz   R   R{   R|   R}   R)  R$   R   R   R!  R   RÄ   R%   R*  R+  (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   Y  s   	c           B   s  e  Z d  Z e j É  Z d d d d d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z e e e e d Ñ Z d Ñ  Z e e e e d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z d d Ñ Z RS(   sà  Create |ASN.1| type.

    |ASN.1| objects are mutable and duck-type Python :class:`dict` objects.

    Parameters
    ----------
    componentType : :py:class:`~pyasn1.type.namedtype.NamedType`
        Object holding named ASN.1 types allowed within this collection

    tagSet: :py:class:`~pyasn1.type.tag.TagSet`
        Object representing non-default ASN.1 tag(s)

    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing non-default ASN.1 subtype constraint(s)

    sizeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`
        Object representing collection size constraint
    c         C   sJ   | d  k r |  j } n  t j j |  | | | | É t |  j É |  _ d  S(   N(   R   R!  R    R  R!   Ró   R  t   _componentTypeLen(   R"   R!  R$   R%   R*  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR!   à  s
    	c         C   s3   t  j | É r |  j | É St j j |  | É Sd  S(   N(   R   Rd   t   getComponentByNameR    R  R†   (   R"   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR†   ë  s    c         C   s<   t  j | É r" |  j | | É n t j j |  | | É d  S(   N(   R   Rd   t   setComponentByNameR    R  t   __setitem__(   R"   R  R#   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR/  ó  s    c         C   s   | |  j  k S(   N(   R  (   R"   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRÊ   ù  s    c         C   s   t  |  j É S(   N(   RÂ   R  (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR°   †  s    c         c   s'   x  t  |  j É D] } |  | Vq Wd  S(   N(   Rö   R,  (   R"   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR	  •  s    c         C   s   t  |  j É S(   N(   RÂ   R  (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   keys©  s    c         c   s:   x3 t  |  j É D]" } |  j | j É  |  | f Vq Wd  S(   N(   Rö   R,  R  Rj   (   R"   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   items¨  s    c         O   sD   x | D] \ } } | |  | <q Wx | D] } | | |  | <q( Wd  S(   N(    (   R"   t	   iterValuet   mappingValuet   kRﬁ   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   update∞  s    c         C   s   g  |  _  d |  _ d  S(   Ni    (   R  R  (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR  ∂  s    	c         C   sz   xs t  |  j É D]b \ } } | d  k	 r t | t j É rY | j | | j d | É É qr | j | | j É  É q q Wd  S(   NR  (   R  R  R   R?   R    R  R  R'   (   R"   R  R  R  R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR  ∫  s    c         C   s   |  j  |  j j | É É S(   s[  Returns |ASN.1| type component by name.

        Equivalent to Python :class:`dict` subscription operation (e.g. `[]`).

        Parameters
        ----------
        name : :class:`str`
            |ASN.1| type component name

        Returns
        -------
        : :py:class:`~pyasn1.type.base.PyAsn1Item`
            a pyasn1 object
        (   R  R  t   getPositionByName(   R"   t   name(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR-  ƒ  s    c         C   s%   |  j  |  j j | É | | | | É S(   s¿  Assign |ASN.1| type component by name.

        Equivalent to Python :class:`dict` item assignment operation (e.g. `[]`).

        Parameters
        ----------
        name : :class:`str`
            |ASN.1| type component name

        value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
            A Python or pyasn1 object to assign

        verifyConstraints: :class:`bool`
             If `False`, skip constraints validation

        matchTags: :class:`bool`
             If `False`, skip component tags matching

        matchConstraints: :class:`bool`
             If `False`, skip component constraints matching

        Returns
        -------
        self
        (   R  R  R6  (   R"   R7  R#   R  R  R   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR.  ◊  s    c         C   s=   y |  j  | SWn' t k
 r8 | |  j k  r2 d SÇ  n Xd S(   sW  Returns |ASN.1| type component by index.

        Equivalent to Python sequence subscription operation (e.g. `[]`).

        Parameters
        ----------
        idx : :class:`int`
            component index (zero-based)

        Returns
        -------
        : :py:class:`~pyasn1.type.base.PyAsn1Item`
            a PyASN1 object
        N(   R  Rú   R,  (   R"   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR  ¯  s    c   	      C   sD  |  j  r |  j  j | É } n d } t |  j É } | | k rR |  j j d É n@ | | k rí |  j j g  t | | d É D] } d ^ q| É n  |  j | É r|  j | d k r| d k r‹ t	 j
 d | j j É Ç n  | j É  |  j | <|  j d 7_ n  |  St | t j É sx| d k r5t	 j
 d É Ç n  t | t j É r\| j d | É } qıt	 j
 d | j j É Ç n} | d k	 rı|  j r¡| j | | | É sÚt	 j
 d | | f É Ç qÚqı| j | | | É sıt	 j
 d | | f É Ç qın  | r|  j | | É n  |  j | d k r3|  j d 7_ n  | |  j | <|  S(   sÕ  Assign |ASN.1| type component by position.

        Equivalent to Python sequence item assignment operation (e.g. `[]`).

        Parameters
        ----------
        idx : :class:`int`
            |ASN.1| type component index (zero-based)

        value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
            A Python or pyasn1 object to assign

        verifyConstraints : :class:`bool`
             If `False`, skip constraints validation

        matchTags: :class:`bool`
             If `False`, skip component tags matching

        matchConstraints: :class:`bool`
             If `False`, skip component constraints matching

        Returns
        -------
        self
        i   s   %s instance value requireds   Component type not definedR#   s-   Component value is tag-incompatible: %r vs %rN(   R  t   getTypeByPositionR   Ró   R  R⁄   R
  Rö   Ro   R
   Re   Rr   Rx   R'   R  R?   R    R  R    R  R  R  R  (	   R"   R  R#   R  R  R   R!  R"  Rû   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR    sB    	4	c         C   s   |  j  r |  j j | É Sd  S(   N(   R,  R  t   getNameByPosition(   R"   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR9  W  s    	c         C   s.   |  j  r* |  j | j r* |  j | j É  Sd  S(   N(   R,  R  t   isDefaultedt   getType(   R"   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   getDefaultComponentByPosition[  s    c         C   s   |  j  r |  j Sd  S(   N(   R,  R  (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   getComponentType_  s    	c         C   s∂   |  j  |  j k r d S|  j  } xê | r± | d 8} |  j | j rj |  j | É d k rÆ |  j | É qÆ q" |  j | j s" |  j | É d k rÆ t j	 d | |  f É Ç qÆ q" q" W|  S(   sv   Assign default values to all defaulted |ASN.1| type components.

        Returns
        -------
        self
        Ni   s!   Uninitialized component #%s at %r(
   R,  R  R  R:  R  R   R  t
   isOptionalR
   Re   (   R"   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   setDefaultComponentsc  s    		
i    c         C   s∫   | d 7} |  j  j d } xô t t |  j É É D]Ç } |  j | d k	 r0 | d | 7} |  j É  } | d k r| | d 7} n | | j | É } d | |  j | j | É f } q0 q0 W| S(   sö   Return an object representation string.

        Returns
        -------
        : :class:`str`
            Human-friendly object representation.
        i   s   :
R%  s	   <no-name>s   %s=%s
N(	   Rr   Rx   Rö   Ró   R  R   R=  R9  RÍ   (   R"   R¸   RU   R  R!  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRÍ   y  s    
$c         C   s´   | d 7} d |  j  É  |  j j f } xj t t |  j É É D]S } | d | 7} | d |  j j | É 7} d | |  j j | É j	 | É f } q< W| d d | d d S(   Ni   s   %s -> %s {
R%  s   "%s"s   %s = %s
s   
R&  (
   R'  Rr   Rx   Rö   Ró   R!  R9  R  R8  R(  (   R"   R¸   RU   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR(  ê  s    
&N(   Rx   Ry   Rz   R   t
   NamedTypesR!  R   R!   R†   R/  RÊ   R°   R	  R0  R1  R5  R  R  R-  R   RÖ   R.  R  R  R9  R<  R=  R?  RÍ   R(  (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   q  s<   										
		F				c           B   sw   e  Z e j Z e j e j e j e j d  É É Z	 e	 Z
 e j É  Z e j É  Z e j É  Z d Z d Ñ  Z d Ñ  Z RS(   i   i   c         C   s   |  j  r |  j  j | É Sd  S(   N(   R  t   getTagMapNearPosition(   R"   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   getComponentTagMapNearPosition≥  s    	c         C   s$   |  j  r |  j  j | | É S| Sd  S(   N(   R  t   getPositionNearType(   R"   R$   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   getComponentPositionNearType∑  s    	(   Rx   Ry   R   Rz   R   R{   R|   R}   R)  R$   R   R   RÄ   R%   R*  R   R@  R!  R+  RB  RD  (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   ú  s   		c           B   sß   e  Z e j Z e j e j e j e j d  É É Z	 e	 Z
 e j É  Z e j É  Z e j É  Z d Z e d Ñ Z e d Ñ Z e e e e e d Ñ Z d Ñ  Z d Ñ  Z RS(   i   i   c         C   s   |  S(   N(    (   R"   t	   innerFlag(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   getComponent÷  s    c         C   sH   |  j  |  j j | É É } | r@ t | t É r@ | j d t É S| Sd S(   s,  Returns |ASN.1| type component by ASN.1 tag.

        Parameters
        ----------
        tagSet : :py:class:`~pyasn1.type.tag.TagSet`
            Object representing ASN.1 tags

        Returns
        -------
        : :py:class:`~pyasn1.type.base.PyAsn1Item`
            a pyasn1 object
        RE  N(   R  R  t   getPositionByTypeR?   R   RF  RÖ   (   R"   R$   RE  t	   component(    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   getComponentByTypeŸ  s
    c   	      C   s¶   |  j  j | É } |  j  j | É } | râ | j É  rO |  j | | | | | É S|  j | É j | É } | j | | | | | d | ÉSn |  j | | | | | É Sd S(   sÓ  Assign |ASN.1| type component by ASN.1 tag.

        Parameters
        ----------
        tagSet : :py:class:`~pyasn1.type.tag.TagSet`
           Object representing ASN.1 tags

        value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
            A Python or pyasn1 object to assign

        verifyConstraints : :class:`bool`
            If `False`, skip constraints validation

        matchTags: :class:`bool`
            If `False`, skip component tags matching

        matchConstraints: :class:`bool`
            If `False`, skip component constraints matching

        innerFlag: :class:`bool`
            If `True`, search for matching *tagSet* recursively.

        Returns
        -------
        self
        RE  N(   R  RG  R8  R'  R  R  t   setComponentByType(	   R"   R$   R#   R  R  R   RE  R  R!  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRJ    s    c         C   s   |  j  r |  j  j t É Sd  S(   N(   R  R#  RÖ   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR$  "	  s    	c         C   s   |  j  r |  j  j | É Sd  S(   N(   R  RG  (   R"   R$   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   getComponentPositionByType&	  s    	(   Rx   Ry   R   Rz   R   R{   R|   R}   R)  R$   R   R   R@  R!  R   RÄ   R%   R*  R+  RÑ   RF  RI  R   RÖ   RJ  R$  RK  (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   æ  s"   	.	c           B   s>  e  Z e j Z e j É  Z e Z e j	 É  Z
 e j É  Z e j e j d  d  É É Z d Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e j d d	 k rµ d
 Ñ  Z n	 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! e" e# e# e# d Ñ Z$ d Ñ  Z% d Ñ  Z& d Ñ  Z' d d Ñ Z( e) d Ñ Z* d Ñ  Z+ RS(   i   i   c         C   s!   |  j  r |  j  |  j | k St S(   N(   R  t   _currentIdxt   NotImplemented(   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR`   D	  s    	c         C   s!   |  j  r |  j  |  j | k St S(   N(   R  RL  RM  (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRa   I	  s    	c         C   s!   |  j  r |  j  |  j | k  St S(   N(   R  RL  RM  (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR^   N	  s    	c         C   s!   |  j  r |  j  |  j | k St S(   N(   R  RL  RM  (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR_   S	  s    	c         C   s!   |  j  r |  j  |  j | k St S(   N(   R  RL  RM  (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRb   X	  s    	c         C   s!   |  j  r |  j  |  j | k St S(   N(   R  RL  RM  (   R"   Rò   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRc   ]	  s    	i    i   c         C   s   t  |  j É S(   N(   R  R  (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR  c	  s    c         C   s   t  |  j É S(   N(   R  R  (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR  f	  s    c         C   s   |  j  d  k	 r d p d S(   Ni   i    (   RL  R   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRå   i	  s    c         C   s-   |  j  d  k r t S| |  j |  j  j É  k S(   N(   RL  R   RÑ   R  Rj   (   R"   R  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRÊ   l	  s    c         c   s1   |  j  d  k r t Ç n  |  j |  j  j É  Vd  S(   N(   RL  R   t   StopIterationR  Rj   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR°   q	  s    	c         C   s%   |  j  d  k r! t j d É Ç n  d  S(   Ns   Component not chosen(   RL  R   R
   Re   (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   verifySizeSpecv	  s    c         C   sú   y |  j  É  } Wn t j k
 r& nr Xt | t É rE | j É  } n | j É  } t | t j É rÇ | j	 | | j
 d | É É n | j	 | | j
 É  É d  S(   NR  (   RF  R
   Re   R?   R   t   getEffectiveTagSetR'  R    R  RJ  R'   (   R"   R  R  t   cR$   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR  z	  s    c   	      C   sŸ  |  j  j | É } t |  j É } | | k r@ |  j j d É n@ | | k rÄ |  j j g  t | | d É D] } d ^ qj É n  |  j d k	 r¢ d |  j |  j <n  |  j	 | É r¸ |  j | d k r¯ |  j  j | É j
 É  |  j | <d |  _ | |  _ n  |  St | t j É s/|  j  j | É j
 d | É } nn |  j rl| j | | | É sùt j d | | f É Ç qùn1 | j | | | É sùt j d | | f É Ç n  | r∂|  j | | É n  | |  j | <| |  _ d |  _ |  S(   sΩ  Assign |ASN.1| type component by position.

        Equivalent to Python sequence item assignment operation (e.g. `[]`).

        Parameters
        ----------
        idx : :class:`int`
            component index (zero-based)

        value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative
            A Python or pyasn1 object to assign

        verifyConstraints : :class:`bool`
            If `False`, skip constraints validation

        matchTags: :class:`bool`
            If `False`, skip component tags matching

        matchConstraints: :class:`bool`
            If `False`, skip component constraints matching

        Returns
        -------
        self
        i   R#   s-   Component value is tag-incompatible: %r vs %rN(   R  R8  Ró   R  R⁄   R   R
  Rö   RL  Ro   R'   R  R?   R    R  R  R  R
   Re   R  R  (	   R"   R  R#   R  R  R   R!  R"  Rû   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR  ã	  s6    4	!			c         C   s!   |  j  r |  j  S|  j j É  Sd  S(   N(   Rp   R  t   genMinTagSet(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   getMinTagSetÃ	  s    	c         C   sC   |  j  r |  j  S|  j É  } t | t É r5 | j É  S| j É  Sd  S(   N(   Rp   RF  R?   R   RP  R'  (   R"   RQ  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRP  “	  s    	
c         C   s'   |  j  r t j |  É St j |  É Sd  S(   N(   Rp   R   R#  R$  (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR#  ‹	  s    	c         C   s[   |  j  d k r! t j d É Ç n6 |  j |  j  } | rS t | t É rS | j | É S| Sd S(   s≥   Return currently assigned component of the |ASN.1| object.

        Returns
        -------
        : :py:class:`~pyasn1.type.base.PyAsn1Item`
            a PyASN1 object
        s   Component not chosenN(   RL  R   R
   Re   R  R?   R   RF  (   R"   RE  RQ  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRF  ‚	  s    c         C   sm   |  j  d k r! t j d É Ç nH | rV |  j |  j  } t | t É rV | j | É Sn  |  j j	 |  j  É Sd S(   s≠   Return the name of currently assigned component of the |ASN.1| object.

        Returns
        -------
        : :py:class:`str`
            |ASN.1| component name
        s   Component not chosenN(
   RL  R   R
   Re   R  R?   R   Rj   R  R9  (   R"   RE  RQ  (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyRj   Û	  s    c         C   s   d  S(   N(    (   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR?  
  s    N(,   Rx   Ry   R   Rz   R   t   TagSetR$   R   R   R@  R!  R   RÄ   R%   t   ValueSizeConstraintR*  R+  R   RL  R`   Ra   R^   R_   Rb   Rc   Rf   RÇ   R  R  Rå   RÊ   R°   RO  R  R   RÖ   R  RS  RP  R#  RF  RÑ   Rj   R?  (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   +	  sB   													>		
	c           B   s>   e  Z e j Z e j É  Z e Z d  Z e	 j
 É  Z d Ñ  Z RS(   i   c         C   s3   t  j i |  |  j É  6i t j t j j É  6|  É S(   N(   R   t   TagMapR'  R   t   endOfOctets(   R"   (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR#  
  s    (   Rx   Ry   R   Rz   R   RT  R$   R   R+  R   RÄ   R%   R#  (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyR   
  s   	(/   R„   Rf   RW   t   pyasn1.typeR    R   R   R   R   R   t   pyasn1.codec.berR   t   pyasn1.compatR   R   R	   t   pyasn1R
   R   R   t   __all__R    R   R   R   R»   t	   NameErrorR   R   RÇ   RH   RJ   Ræ   R@   R¯   R   R   R   R  R   R   R   R   R   R   R   R   (    (    (    s0   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/univ.pyt   <module>   sR   .		ˇ ?ˇ äˇ vP	{ˇ =¨ˇ ,"m›                                                                                                                                                                                                                                                                                                                      usr/local/lib/python2.7/dist-packages/pyasn1/type/useful.py                                         0100644 0000000 0000062 00000002207 13077704400 022271  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# This file is part of pyasn1 software.
#
# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>
# License: http://pyasn1.sf.net/license.html
#
from pyasn1.type import univ, char, tag

__all__ = ['ObjectDescriptor', 'GeneralizedTime', 'UTCTime']

NoValue = univ.NoValue
noValue = univ.noValue


class ObjectDescriptor(char.GraphicString):
    __doc__ = char.GraphicString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = char.GraphicString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 7)
    )


class GeneralizedTime(char.VisibleString):
    __doc__ = char.GraphicString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = char.VisibleString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 24)
    )


class UTCTime(char.VisibleString):
    __doc__ = char.GraphicString.__doc__

    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects
    tagSet = char.VisibleString.tagSet.tagImplicitly(
        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 23)
    )
                                                                                                                                                                                                                                                                                                                                                                                         usr/local/lib/python2.7/dist-packages/pyasn1/type/useful.pyc                                        0100644 0000000 0000062 00000002441 13077704403 022437  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
 âˇXc           @   så   d  d l  m Z m Z m Z d d d g Z e j Z e j Z d e j f d Ñ  É  YZ d e j	 f d Ñ  É  YZ
 d e j	 f d Ñ  É  YZ d S(	   iˇˇˇˇ(   t   univt   chart   tagt   ObjectDescriptort   GeneralizedTimet   UTCTimec           B   s>   e  Z e j j Z e j j j e j e j	 e j
 d  É É Z RS(   i   (   t   __name__t
   __module__R   t   GraphicStringt   __doc__t   tagSett   tagImplicitlyR   t   Tagt   tagClassUniversalt   tagFormatSimple(    (    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/useful.pyR      s   c           B   s>   e  Z e j j Z e j j j e j	 e j
 e j d  É É Z RS(   i   (   R   R   R   R   R	   t   VisibleStringR
   R   R   R   R   R   (    (    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/useful.pyR      s   c           B   s>   e  Z e j j Z e j j j e j	 e j
 e j d  É É Z RS(   i   (   R   R   R   R   R	   R   R
   R   R   R   R   R   (    (    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/useful.pyR   !   s   N(   t   pyasn1.typeR    R   R   t   __all__t   NoValuet   noValueR   R   R   R   R   (    (    (    s2   /tmp/pip-build-awuatQ/pyasn1/pyasn1/type/useful.pyt   <module>   s   				                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/pyasn1-0.2.3.dist-info/                                       0042755 0000000 0000062 00000000000 13077704403 021773  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/pyasn1-0.2.3.dist-info/DESCRIPTION.rst                        0100644 0000000 0000062 00000000113 13077704400 024273  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Pure-Python implementation of ASN.1 types and DER/BER/CER codecs (X.208)


                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/local/lib/python2.7/dist-packages/pyasn1-0.2.3.dist-info/METADATA                               0100644 0000000 0000062 00000002646 13077704400 023076  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Metadata-Version: 2.0
Name: pyasn1
Version: 0.2.3
Summary: ASN.1 types and codecs
Home-page: https://github.com/etingof/pyasn1
Author: Ilya Etingof <etingof@gmail.com>
Author-email: etingof@gmail.com
License: BSD
Platform: any
Classifier: Development Status :: 5 - Production/Stable
Classifier: Environment :: Console
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Education
Classifier: Intended Audience :: Information Technology
Classifier: Intended Audience :: System Administrators
Classifier: Intended Audience :: Telecommunications Industry
Classifier: License :: OSI Approved :: BSD License
Classifier: Natural Language :: English
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 2.4
Classifier: Programming Language :: Python :: 2.5
Classifier: Programming Language :: Python :: 2.6
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.2
Classifier: Programming Language :: Python :: 3.3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Topic :: Communications
Classifier: Topic :: Software Development :: Libraries :: Python Modules

Pure-Python implementation of ASN.1 types and DER/BER/CER codecs (X.208)


                                                                                          usr/local/lib/python2.7/dist-packages/pyasn1-0.2.3.dist-info/RECORD                                 0100644 0000000 0000062 00000007774 13077704403 022706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        pyasn1/__init__.py,sha256=EYnLfIyoeyMfdhPIE03x_OugySp0KUqwsExpJ741KGw,175
pyasn1/debug.py,sha256=eoI4fMow2bcfQOsGo3wk0Y4uv07JFoFPIDwzacjDzsQ,3279
pyasn1/error.py,sha256=WWXwyoSjN3DBRXyuD0wwXgrWYJALzznOWHedahb-ijI,298
pyasn1/codec/__init__.py,sha256=EEDlJYS172EH39GUidN_8FbkNcWY9OVV8e30AV58pn0,59
pyasn1/codec/ber/__init__.py,sha256=EEDlJYS172EH39GUidN_8FbkNcWY9OVV8e30AV58pn0,59
pyasn1/codec/ber/decoder.py,sha256=wThkS_NPShYnFJXkSuwr-F18zhOFohlndHytPLvC0d8,40205
pyasn1/codec/ber/encoder.py,sha256=GBxFemfXQ8scpWGOgEqSR1buwdKGou4Rxuvuo43Wdoo,16695
pyasn1/codec/ber/eoo.py,sha256=URwHxdIgJbgoeRDuk-ozjB9JjHBinVuD7JWKMAx9S0s,387
pyasn1/codec/cer/__init__.py,sha256=EEDlJYS172EH39GUidN_8FbkNcWY9OVV8e30AV58pn0,59
pyasn1/codec/cer/decoder.py,sha256=4EL7-XVXvsWjLU3_c0OXmntaI18DxWFvb7QOl7KUsv0,2793
pyasn1/codec/cer/encoder.py,sha256=SPvxabbfOxMHh2VWra-zDjwOssOf8xFE8LBQFRxbHw0,5946
pyasn1/codec/der/__init__.py,sha256=EEDlJYS172EH39GUidN_8FbkNcWY9OVV8e30AV58pn0,59
pyasn1/codec/der/decoder.py,sha256=y5YMAinmR7Zd7Uv5bXrPMrpYwW79S0LrC39CE9JPJSk,1865
pyasn1/codec/der/encoder.py,sha256=PdDSFWa_viO9IppyXUl3duDm8ovNlIRbQK4wyCca1jU,2081
pyasn1/codec/native/__init__.py,sha256=EEDlJYS172EH39GUidN_8FbkNcWY9OVV8e30AV58pn0,59
pyasn1/codec/native/decoder.py,sha256=XjDelcyOLcGrronsp487N4PSyLgbRStE7J99IcfZTQM,6165
pyasn1/codec/native/encoder.py,sha256=cy2Cw59I5tmZ5GhGUpeCv1nO-eXO9ufejGG4YL96tSA,6759
pyasn1/compat/__init__.py,sha256=EEDlJYS172EH39GUidN_8FbkNcWY9OVV8e30AV58pn0,59
pyasn1/compat/binary.py,sha256=I58mp250ZKgFqPijWRNzvWzhtGUakyVajDqqwDlGtwo,518
pyasn1/compat/integer.py,sha256=JF7pMx8mHyXYnsk3CDJFfMuk0LcbK_pScrcwwZGYUw4,2714
pyasn1/compat/octets.py,sha256=R2YymZCvb8aFCTu1yu6gH55mD3tfZ2wQGuBmuo8f17w,1203
pyasn1/type/__init__.py,sha256=EEDlJYS172EH39GUidN_8FbkNcWY9OVV8e30AV58pn0,59
pyasn1/type/base.py,sha256=js7BoV_zSDCRCXDPU--_yswfLxBeYDu3E-xFhklSwos,18819
pyasn1/type/char.py,sha256=up4pZIfZIx8YV0Mow69DSAm0MWOLg0eCyaGEO0D28xE,11702
pyasn1/type/constraint.py,sha256=t5lIBIUgtkAiQa8NyL-gUIiX8ExrpOD4aXBlCBd5YR4,7426
pyasn1/type/error.py,sha256=d7HspaYLWRimy50U6zBaUnNhnaIaqkdccn1e_j-EfZk,240
pyasn1/type/namedtype.py,sha256=JpgHcferGrYIHnzJmyXEtoAjmezvRWTDZCc1f04Tjgk,6738
pyasn1/type/namedval.py,sha256=3ti898t7IINeJvyroThnUB8FJ_orlw0BCfyFdIqMo8Y,2380
pyasn1/type/tag.py,sha256=9ieVRuMAXoNW7Yp2rUgWdMfFGVsVFLxazrP7htEr4Qc,5080
pyasn1/type/tagmap.py,sha256=Z0urt_h8g6nwuOlJTBg3UkgUO81T9Alf2BQ51oHYsD4,2585
pyasn1/type/univ.py,sha256=QX2N-bHl0qopJSdQsMXPeMeBXgwY-_Z6iajHIRvXGxk,88472
pyasn1/type/useful.py,sha256=-BPMH5YiSRF963NMP4AWfsgv-ERXIzpt0IfxvEBOP38,1159
pyasn1-0.2.3.dist-info/DESCRIPTION.rst,sha256=2jbkK6fmEr45mOdVBxruBS_lcY2u6QKYcB8Cz6vgPHU,75
pyasn1-0.2.3.dist-info/METADATA,sha256=SbnEVYWgxisugbdIm4BZlmH52t1ohSmAOFSE9GLgZQE,1446
pyasn1-0.2.3.dist-info/RECORD,,
pyasn1-0.2.3.dist-info/WHEEL,sha256=o2k-Qa-RMNIJmUdIc7KU6VWR_ErNRbWNlxDIpl7lm34,110
pyasn1-0.2.3.dist-info/metadata.json,sha256=0X2yHT0p71C3PoeSQlA_Rnwb1yJeUMOZ0xflNQt5ztw,1390
pyasn1-0.2.3.dist-info/top_level.txt,sha256=dnNEQt3nIDIO5mSCCOB5obQHrjDOUsRycdBujc2vrWE,7
pyasn1-0.2.3.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
pyasn1/codec/ber/encoder.pyc,,
pyasn1/codec/native/decoder.pyc,,
pyasn1/type/namedval.pyc,,
pyasn1/codec/native/encoder.pyc,,
pyasn1/compat/integer.pyc,,
pyasn1/codec/der/decoder.pyc,,
pyasn1/codec/ber/__init__.pyc,,
pyasn1/codec/cer/decoder.pyc,,
pyasn1/compat/binary.pyc,,
pyasn1/type/base.pyc,,
pyasn1/__init__.pyc,,
pyasn1/codec/der/__init__.pyc,,
pyasn1/codec/ber/decoder.pyc,,
pyasn1/type/__init__.pyc,,
pyasn1/type/error.pyc,,
pyasn1/debug.pyc,,
pyasn1/type/constraint.pyc,,
pyasn1/compat/__init__.pyc,,
pyasn1/codec/cer/encoder.pyc,,
pyasn1/type/tag.pyc,,
pyasn1/type/useful.pyc,,
pyasn1/codec/__init__.pyc,,
pyasn1/codec/ber/eoo.pyc,,
pyasn1/codec/native/__init__.pyc,,
pyasn1/type/univ.pyc,,
pyasn1/type/char.pyc,,
pyasn1/error.pyc,,
pyasn1/type/namedtype.pyc,,
pyasn1/type/tagmap.pyc,,
pyasn1/codec/cer/__init__.pyc,,
pyasn1/codec/der/encoder.pyc,,
pyasn1/compat/octets.pyc,,
    usr/local/lib/python2.7/dist-packages/pyasn1-0.2.3.dist-info/WHEEL                                  0100644 0000000 0000062 00000000156 13077704400 022554  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Wheel-Version: 1.0
Generator: bdist_wheel (0.29.0)
Root-Is-Purelib: true
Tag: py2-none-any
Tag: py3-none-any

                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/pyasn1-0.2.3.dist-info/metadata.json                          0100644 0000000 0000062 00000002556 13077704400 024446  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {"classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: Education", "Intended Audience :: Information Technology", "Intended Audience :: System Administrators", "Intended Audience :: Telecommunications Industry", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.4", "Programming Language :: Python :: 2.5", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Communications", "Topic :: Software Development :: Libraries :: Python Modules"], "extensions": {"python.details": {"contacts": [{"email": "etingof@gmail.com", "name": "Ilya Etingof <etingof@gmail.com>", "role": "author"}], "document_names": {"description": "DESCRIPTION.rst"}, "project_urls": {"Home": "https://github.com/etingof/pyasn1"}}}, "generator": "bdist_wheel (0.29.0)", "license": "BSD", "metadata_version": "2.0", "name": "pyasn1", "platform": "any", "summary": "ASN.1 types and codecs", "version": "0.2.3"}                                                                                                                                                  usr/local/lib/python2.7/dist-packages/pyasn1-0.2.3.dist-info/top_level.txt                          0100644 0000000 0000062 00000000007 13077704400 024512  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        pyasn1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/local/lib/python2.7/dist-packages/pyasn1-0.2.3.dist-info/zip-safe                               0100644 0000000 0000062 00000000001 13077704400 023413  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/python_dateutil-2.6.0.dist-info/                              0042755 0000000 0000062 00000000000 13077704403 023777  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/python_dateutil-2.6.0.dist-info/DESCRIPTION.rst               0100644 0000000 0000062 00000000165 13077704377 026323  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
The dateutil module provides powerful extensions to the
datetime module available in the Python standard library.


                                                                                                                                                                                                                                                                                                                                                                                                           usr/local/lib/python2.7/dist-packages/python_dateutil-2.6.0.dist-info/METADATA                      0100644 0000000 0000062 00000002150 13077704377 025105  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Metadata-Version: 2.0
Name: python-dateutil
Version: 2.6.0
Summary: Extensions to the standard Python datetime module
Home-page: https://dateutil.readthedocs.io
Author: Paul Ganssle, Yaron de Leeuw
Author-email: dateutil@python.org
License: Simplified BSD
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: BSD License
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 2.6
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.2
Classifier: Programming Language :: Python :: 3.3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Topic :: Software Development :: Libraries
Requires: six
Requires-Dist: six (>=1.5)


The dateutil module provides powerful extensions to the
datetime module available in the Python standard library.


                                                                                                                                                                                                                                                                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/python_dateutil-2.6.0.dist-info/RECORD                        0100644 0000000 0000062 00000004063 13077704403 024676  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        dateutil/__init__.py,sha256=W02iiw8c30gWn96fDoH6q3r8RQC9hLqWt8G5ZdeUw9U,46
dateutil/_common.py,sha256=CplfXALOPPS2HFocG3xOBPK-cYL5ty8ESpQpjH6qorM,767
dateutil/easter.py,sha256=6WQORXKs5kdAfUT3ojvc4fKITj91O-fTycZvlb2l12E,2629
dateutil/parser.py,sha256=U-m1b5YDDvduoaHtM8enPt02Ys1D2OTCTuekQ-6mMQ8,50234
dateutil/relativedelta.py,sha256=yYf672y_NrfST_dvHfEKzu2swDt3VL0qRv_AwSlxAk8,21986
dateutil/rrule.py,sha256=eUQW9mQIFAPhlI6XIIxQA7ukuoUyXi-GM771qNOnEyI,61792
dateutil/tzwin.py,sha256=KAgNx5biLzq3qGU_nTkEWk-iEF1FzApOY438Nr2dkfA,58
dateutil/tz/__init__.py,sha256=XGupHGCnKti2YyoFfTAbNbAVsW56nOrFbR47Pc823FA,145
dateutil/tz/_common.py,sha256=nxrt5M0hFVQ4XXNtpU97qbg0nD-oeNzLtIsyLVJiOPI,11744
dateutil/tz/tz.py,sha256=gLEX5UmICizaVts5-aIl6T3xPGDPab2VHEn2blnyshw,48924
dateutil/tz/win.py,sha256=EAFtgfPG7irX2unjDtT27gOIDD1uRMVJH7OIvLne838,11466
dateutil/zoneinfo/__init__.py,sha256=q2KFmv03dY3x974DeImfCpASCm5ke9hifOgeWqeWki4,6810
dateutil/zoneinfo/dateutil-zoneinfo.tar.gz,sha256=hcCGQ4DVbbcf_he_Raqt4T6MbaByeyDW1QAS5kKE4NU,139671
dateutil/zoneinfo/rebuild.py,sha256=4WOHZuZabG6baUR1s13vYcWv_yMmdYEsyeWsgyb-aVs,1688
python_dateutil-2.6.0.dist-info/DESCRIPTION.rst,sha256=WzfQq_9HAZsBuKLe06cpD3Kt7lxqKtcoW7nJgXllcUU,117
python_dateutil-2.6.0.dist-info/METADATA,sha256=G4XkiGvhXvohvJEgIfQCg7JmsUCVwM5OGiSt3hZ0bSI,1128
python_dateutil-2.6.0.dist-info/RECORD,,
python_dateutil-2.6.0.dist-info/WHEEL,sha256=o2k-Qa-RMNIJmUdIc7KU6VWR_ErNRbWNlxDIpl7lm34,110
python_dateutil-2.6.0.dist-info/metadata.json,sha256=dbaFxA-wtImM0UwoSV5N0GP2WYPTuj3OE9rrZ5Cm3IE,1129
python_dateutil-2.6.0.dist-info/top_level.txt,sha256=4tjdWkhRZvF7LA_BYe_L9gB2w_p2a-z5y6ArjaRkot8,9
python_dateutil-2.6.0.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
dateutil/tz/__init__.pyc,,
dateutil/__init__.pyc,,
dateutil/_common.pyc,,
dateutil/easter.pyc,,
dateutil/zoneinfo/__init__.pyc,,
dateutil/relativedelta.pyc,,
dateutil/tzwin.pyc,,
dateutil/tz/tz.pyc,,
dateutil/tz/win.pyc,,
dateutil/parser.pyc,,
dateutil/rrule.pyc,,
dateutil/tz/_common.pyc,,
dateutil/zoneinfo/rebuild.pyc,,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/local/lib/python2.7/dist-packages/python_dateutil-2.6.0.dist-info/WHEEL                         0100644 0000000 0000062 00000000156 13077704377 024575  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Wheel-Version: 1.0
Generator: bdist_wheel (0.29.0)
Root-Is-Purelib: true
Tag: py2-none-any
Tag: py3-none-any

                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/python_dateutil-2.6.0.dist-info/metadata.json                 0100644 0000000 0000062 00000002151 13077704377 026456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {"classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Libraries"], "extensions": {"python.details": {"contacts": [{"email": "dateutil@python.org", "name": "Paul Ganssle, Yaron de Leeuw", "role": "author"}], "document_names": {"description": "DESCRIPTION.rst"}, "project_urls": {"Home": "https://dateutil.readthedocs.io"}}}, "extras": [], "generator": "bdist_wheel (0.29.0)", "license": "Simplified BSD", "metadata_version": "2.0", "name": "python-dateutil", "requires": "six", "run_requires": [{"requires": ["six (>=1.5)"]}], "summary": "Extensions to the standard Python datetime module", "version": "2.6.0"}                                                                                                                                                                                                                                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/python_dateutil-2.6.0.dist-info/top_level.txt                 0100644 0000000 0000062 00000000011 13077704377 026526  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        dateutil
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/python_dateutil-2.6.0.dist-info/zip-safe                      0100644 0000000 0000062 00000000001 13077704377 025434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/rsa/                                                          0042755 0000000 0000062 00000000000 13077704403 017014  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/rsa/__init__.py                                               0100644 0000000 0000062 00000003036 13077704374 021131  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""RSA module

Module for calculating large primes, and RSA encryption, decryption, signing
and verification. Includes generating public and private keys.

WARNING: this implementation does not use random padding, compression of the
cleartext input to prevent repetitions, or other common security improvements.
Use with care.

If you want to have a more secure implementation, use the functions from the
``rsa.pkcs1`` module.

"""

__author__ = "Sybren Stuvel, Barry Mead and Yesudeep Mangalapilly"
__date__ = "2016-01-13"
__version__ = '3.3'

from rsa.key import newkeys, PrivateKey, PublicKey
from rsa.pkcs1 import encrypt, decrypt, sign, verify, DecryptionError, \
    VerificationError

# Do doctest if we're run directly
if __name__ == "__main__":
    import doctest
    doctest.testmod()

__all__ = ["newkeys", "encrypt", "decrypt", "sign", "verify", 'PublicKey',
    'PrivateKey', 'DecryptionError', 'VerificationError']

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/rsa/__init__.pyc                                              0100644 0000000 0000062 00000002261 13077704403 021264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc        	   @   s¨   d  Z  d Z d Z d Z d d l m Z m Z m Z d d l m	 Z	 m
 Z
 m Z m Z m Z m Z e d k rá d d l Z e j É  n  d	 d
 d d d d d d d g	 Z d S(   s©  RSA module

Module for calculating large primes, and RSA encryption, decryption, signing
and verification. Includes generating public and private keys.

WARNING: this implementation does not use random padding, compression of the
cleartext input to prevent repetitions, or other common security improvements.
Use with care.

If you want to have a more secure implementation, use the functions from the
``rsa.pkcs1`` module.

s3   Sybren Stuvel, Barry Mead and Yesudeep Mangalapillys
   2016-01-13s   3.3iˇˇˇˇ(   t   newkeyst
   PrivateKeyt	   PublicKey(   t   encryptt   decryptt   signt   verifyt   DecryptionErrort   VerificationErrort   __main__NR    R   R   R   R   R   R   R   R   (   t   __doc__t
   __author__t   __date__t   __version__t   rsa.keyR    R   R   t	   rsa.pkcs1R   R   R   R   R   R   t   __name__t   doctestt   testmodt   __all__(    (    (    s)   /tmp/pip-build-awuatQ/rsa/rsa/__init__.pyt   <module>   s   .                                                                                                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/rsa/_compat.py                                                0100644 0000000 0000062 00000007733 13077704374 021024  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Python compatibility wrappers."""


from __future__ import absolute_import

import sys
from struct import pack

try:
    MAX_INT = sys.maxsize
except AttributeError:
    MAX_INT = sys.maxint

MAX_INT64 = (1 << 63) - 1
MAX_INT32 = (1 << 31) - 1
MAX_INT16 = (1 << 15) - 1

# Determine the word size of the processor.
if MAX_INT == MAX_INT64:
    # 64-bit processor.
    MACHINE_WORD_SIZE = 64
elif MAX_INT == MAX_INT32:
    # 32-bit processor.
    MACHINE_WORD_SIZE = 32
else:
    # Else we just assume 64-bit processor keeping up with modern times.
    MACHINE_WORD_SIZE = 64


try:
    # < Python3
    unicode_type = unicode
    have_python3 = False
except NameError:
    # Python3.
    unicode_type = str
    have_python3 = True

# Fake byte literals.
if str is unicode_type:
    def byte_literal(s):
        return s.encode('latin1')
else:
    def byte_literal(s):
        return s

# ``long`` is no more. Do type detection using this instead.
try:
    integer_types = (int, long)
except NameError:
    integer_types = (int,)

b = byte_literal

try:
    # Python 2.6 or higher.
    bytes_type = bytes
except NameError:
    # Python 2.5
    bytes_type = str


# To avoid calling b() multiple times in tight loops.
ZERO_BYTE = b('\x00')
EMPTY_BYTE = b('')


def is_bytes(obj):
    """
    Determines whether the given value is a byte string.

    :param obj:
        The value to test.
    :returns:
        ``True`` if ``value`` is a byte string; ``False`` otherwise.
    """
    return isinstance(obj, bytes_type)


def is_integer(obj):
    """
    Determines whether the given value is an integer.

    :param obj:
        The value to test.
    :returns:
        ``True`` if ``value`` is an integer; ``False`` otherwise.
    """
    return isinstance(obj, integer_types)


def byte(num):
    """
    Converts a number between 0 and 255 (both inclusive) to a base-256 (byte)
    representation.

    Use it as a replacement for ``chr`` where you are expecting a byte
    because this will work on all current versions of Python::

    :param num:
        An unsigned integer between 0 and 255 (both inclusive).
    :returns:
        A single byte.
    """
    return pack("B", num)


def get_word_alignment(num, force_arch=64,
                       _machine_word_size=MACHINE_WORD_SIZE):
    """
    Returns alignment details for the given number based on the platform
    Python is running on.

    :param num:
        Unsigned integral number.
    :param force_arch:
        If you don't want to use 64-bit unsigned chunks, set this to
        anything other than 64. 32-bit chunks will be preferred then.
        Default 64 will be used when on a 64-bit machine.
    :param _machine_word_size:
        (Internal) The machine word size used for alignment.
    :returns:
        4-tuple::

            (word_bits, word_bytes,
             max_uint, packing_format_type)
    """
    max_uint64 = 0xffffffffffffffff
    max_uint32 = 0xffffffff
    max_uint16 = 0xffff
    max_uint8 = 0xff

    if force_arch == 64 and _machine_word_size >= 64 and num > max_uint32:
        # 64-bit unsigned integer.
        return 64, 8, max_uint64, "Q"
    elif num > max_uint16:
        # 32-bit unsigned integer
        return 32, 4, max_uint32, "L"
    elif num > max_uint8:
        # 16-bit unsigned integer.
        return 16, 2, max_uint16, "H"
    else:
        # 8-bit unsigned integer.
        return 8, 1, max_uint8, "B"
                                     usr/local/lib/python2.7/dist-packages/rsa/_compat.pyc                                               0100644 0000000 0000062 00000007166 13077704403 021160  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @@  så  d  Z  d d l m Z d d l Z d d l m Z y e j Z Wn e k
 r[ e j	 Z n Xd Z
 d Z d Z e e
 k rÉ d	 Z n e e k rò d
 Z n d	 Z y e Z e Z Wn e k
 rÕ e Z e Z n Xe e k rÊ d Ñ  Z n	 d Ñ  Z y e e f Z Wn e k
 re f Z n Xe Z y
 e Z Wn e k
 rEe Z n Xe d É Z e d É Z d Ñ  Z d Ñ  Z d Ñ  Z  d	 e d Ñ Z! d S(   s   Python compatibility wrappers.i    (   t   absolute_importN(   t   packi   i?   i   i   i@   i    c         C@  s   |  j  d É S(   Nt   latin1(   t   encode(   t   s(    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/_compat.pyt   byte_literal9   s    c         C@  s   |  S(   N(    (   R   (    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/_compat.pyR   <   s    t    t    c         C@  s   t  |  t É S(   sΩ   
    Determines whether the given value is a byte string.

    :param obj:
        The value to test.
    :returns:
        ``True`` if ``value`` is a byte string; ``False`` otherwise.
    (   t
   isinstancet
   bytes_type(   t   obj(    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/_compat.pyt   is_bytesT   s    	c         C@  s   t  |  t É S(   s∑   
    Determines whether the given value is an integer.

    :param obj:
        The value to test.
    :returns:
        ``True`` if ``value`` is an integer; ``False`` otherwise.
    (   R   t   integer_types(   R
   (    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/_compat.pyt
   is_integer`   s    	c         C@  s   t  d |  É S(   sd  
    Converts a number between 0 and 255 (both inclusive) to a base-256 (byte)
    representation.

    Use it as a replacement for ``chr`` where you are expecting a byte
    because this will work on all current versions of Python::

    :param num:
        An unsigned integer between 0 and 255 (both inclusive).
    :returns:
        A single byte.
    t   B(   R   (   t   num(    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/_compat.pyt   bytel   s    c         C@  sò   d } d } d } d } | d k rL | d k rL |  | k rL d d | d f S|  | k rh d d	 | d
 f S|  | k rÑ d d | d f Sd d | d f Sd S(   sD  
    Returns alignment details for the given number based on the platform
    Python is running on.

    :param num:
        Unsigned integral number.
    :param force_arch:
        If you don't want to use 64-bit unsigned chunks, set this to
        anything other than 64. 32-bit chunks will be preferred then.
        Default 64 will be used when on a 64-bit machine.
    :param _machine_word_size:
        (Internal) The machine word size used for alignment.
    :returns:
        4-tuple::

            (word_bits, word_bytes,
             max_uint, packing_format_type)
    l   ˇˇˇˇ Iˇˇˇˇ    iˇˇ  iˇ   i@   i   t   Qi    i   t   Li   i   t   Hi   R   N(    (   R   t
   force_archt   _machine_word_sizet
   max_uint64t
   max_uint32t
   max_uint16t	   max_uint8(    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/_compat.pyt   get_word_alignment|   s    $l            l   ˇˇˇˇ I   Ä    iˇˇˇi Ä  iˇ  ("   t   __doc__t
   __future__R    t   syst   structR   t   maxsizet   MAX_INTt   AttributeErrort   maxintt	   MAX_INT64t	   MAX_INT32t	   MAX_INT16t   MACHINE_WORD_SIZEt   unicodet   unicode_typet   Falset   have_python3t	   NameErrort   strt   TrueR   t   intt   longR   t   bt   bytesR	   t	   ZERO_BYTEt
   EMPTY_BYTER   R   R   R   (    (    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/_compat.pyt   <module>   sP   		

	

			                                                                                                                                                                                                                                                                                                                                                                                                          usr/local/lib/python2.7/dist-packages/rsa/_version133.py                                            0100644 0000000 0000062 00000027207 13077704374 021453  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""RSA module
pri = k[1]                               	//Private part of keys d,p,q

Module for calculating large primes, and RSA encryption, decryption,
signing and verification. Includes generating public and private keys.

WARNING: this code implements the mathematics of RSA. It is not suitable for
real-world secure cryptography purposes. It has not been reviewed by a security
expert. It does not include padding of data. There are many ways in which the
output of this module, when used without any modification, can be sucessfully
attacked.
"""

__author__ = "Sybren Stuvel, Marloes de Boer and Ivo Tamboer"
__date__ = "2010-02-05"
__version__ = '1.3.3'

# NOTE: Python's modulo can return negative numbers. We compensate for
# this behaviour using the abs() function

from cPickle import dumps, loads
import base64
import math
import os
import random
import sys
import types
import zlib

from rsa._compat import byte

# Display a warning that this insecure version is imported.
import warnings
warnings.warn('Insecure version of the RSA module is imported as %s, be careful'
        % __name__)

def gcd(p, q):
    """Returns the greatest common divisor of p and q


    >>> gcd(42, 6)
    6
    """
    if p<q: return gcd(q, p)
    if q == 0: return p
    return gcd(q, abs(p%q))

def bytes2int(bytes):
    """Converts a list of bytes or a string to an integer

    >>> (128*256 + 64)*256 + + 15
    8405007
    >>> l = [128, 64, 15]
    >>> bytes2int(l)
    8405007
    """

    if not (type(bytes) is types.ListType or type(bytes) is types.StringType):
        raise TypeError("You must pass a string or a list")

    # Convert byte stream to integer
    integer = 0
    for byte in bytes:
        integer *= 256
        if type(byte) is types.StringType: byte = ord(byte)
        integer += byte

    return integer

def int2bytes(number):
    """Converts a number to a string of bytes
    
    >>> bytes2int(int2bytes(123456789))
    123456789
    """

    if not (type(number) is types.LongType or type(number) is types.IntType):
        raise TypeError("You must pass a long or an int")

    string = ""

    while number > 0:
        string = "%s%s" % (byte(number & 0xFF), string)
        number /= 256
    
    return string

def fast_exponentiation(a, p, n):
    """Calculates r = a^p mod n
    """
    result = a % n
    remainders = []
    while p != 1:
        remainders.append(p & 1)
        p = p >> 1
    while remainders:
        rem = remainders.pop()
        result = ((a ** rem) * result ** 2) % n
    return result

def read_random_int(nbits):
    """Reads a random integer of approximately nbits bits rounded up
    to whole bytes"""

    nbytes = ceil(nbits/8.)
    randomdata = os.urandom(nbytes)
    return bytes2int(randomdata)

def ceil(x):
    """ceil(x) -> int(math.ceil(x))"""

    return int(math.ceil(x))
    
def randint(minvalue, maxvalue):
    """Returns a random integer x with minvalue <= x <= maxvalue"""

    # Safety - get a lot of random data even if the range is fairly
    # small
    min_nbits = 32

    # The range of the random numbers we need to generate
    range = maxvalue - minvalue

    # Which is this number of bytes
    rangebytes = ceil(math.log(range, 2) / 8.)

    # Convert to bits, but make sure it's always at least min_nbits*2
    rangebits = max(rangebytes * 8, min_nbits * 2)
    
    # Take a random number of bits between min_nbits and rangebits
    nbits = random.randint(min_nbits, rangebits)
    
    return (read_random_int(nbits) % range) + minvalue

def fermat_little_theorem(p):
    """Returns 1 if p may be prime, and something else if p definitely
    is not prime"""

    a = randint(1, p-1)
    return fast_exponentiation(a, p-1, p)

def jacobi(a, b):
    """Calculates the value of the Jacobi symbol (a/b)
    """

    if a % b == 0:
        return 0
    result = 1
    while a > 1:
        if a & 1:
            if ((a-1)*(b-1) >> 2) & 1:
                result = -result
            b, a = a, b % a
        else:
            if ((b ** 2 - 1) >> 3) & 1:
                result = -result
            a = a >> 1
    return result

def jacobi_witness(x, n):
    """Returns False if n is an Euler pseudo-prime with base x, and
    True otherwise.
    """

    j = jacobi(x, n) % n
    f = fast_exponentiation(x, (n-1)/2, n)

    if j == f: return False
    return True

def randomized_primality_testing(n, k):
    """Calculates whether n is composite (which is always correct) or
    prime (which is incorrect with error probability 2**-k)

    Returns False if the number if composite, and True if it's
    probably prime.
    """

    q = 0.5     # Property of the jacobi_witness function

    # t = int(math.ceil(k / math.log(1/q, 2)))
    t = ceil(k / math.log(1/q, 2))
    for i in range(t+1):
        x = randint(1, n-1)
        if jacobi_witness(x, n): return False
    
    return True

def is_prime(number):
    """Returns True if the number is prime, and False otherwise.

    >>> is_prime(42)
    0
    >>> is_prime(41)
    1
    """

    """
    if not fermat_little_theorem(number) == 1:
        # Not prime, according to Fermat's little theorem
        return False
    """

    if randomized_primality_testing(number, 5):
        # Prime, according to Jacobi
        return True
    
    # Not prime
    return False

    
def getprime(nbits):
    """Returns a prime number of max. 'math.ceil(nbits/8)*8' bits. In
    other words: nbits is rounded up to whole bytes.

    >>> p = getprime(8)
    >>> is_prime(p-1)
    0
    >>> is_prime(p)
    1
    >>> is_prime(p+1)
    0
    """

    nbytes = int(math.ceil(nbits/8.))

    while True:
        integer = read_random_int(nbits)

        # Make sure it's odd
        integer |= 1

        # Test for primeness
        if is_prime(integer): break

        # Retry if not prime

    return integer

def are_relatively_prime(a, b):
    """Returns True if a and b are relatively prime, and False if they
    are not.

    >>> are_relatively_prime(2, 3)
    1
    >>> are_relatively_prime(2, 4)
    0
    """

    d = gcd(a, b)
    return (d == 1)

def find_p_q(nbits):
    """Returns a tuple of two different primes of nbits bits"""

    p = getprime(nbits)
    while True:
        q = getprime(nbits)
        if not q == p: break
    
    return (p, q)

def extended_euclid_gcd(a, b):
    """Returns a tuple (d, i, j) such that d = gcd(a, b) = ia + jb
    """

    if b == 0:
        return (a, 1, 0)

    q = abs(a % b)
    r = long(a / b)
    (d, k, l) = extended_euclid_gcd(b, q)

    return (d, l, k - l*r)

# Main function: calculate encryption and decryption keys
def calculate_keys(p, q, nbits):
    """Calculates an encryption and a decryption key for p and q, and
    returns them as a tuple (e, d)"""

    n = p * q
    phi_n = (p-1) * (q-1)

    while True:
        # Make sure e has enough bits so we ensure "wrapping" through
        # modulo n
        e = getprime(max(8, nbits/2))
        if are_relatively_prime(e, n) and are_relatively_prime(e, phi_n): break

    (d, i, j) = extended_euclid_gcd(e, phi_n)

    if not d == 1:
        raise Exception("e (%d) and phi_n (%d) are not relatively prime" % (e, phi_n))

    if not (e * i) % phi_n == 1:
        raise Exception("e (%d) and i (%d) are not mult. inv. modulo phi_n (%d)" % (e, i, phi_n))

    return (e, i)


def gen_keys(nbits):
    """Generate RSA keys of nbits bits. Returns (p, q, e, d).

    Note: this can take a long time, depending on the key size.
    """

    while True:
        (p, q) = find_p_q(nbits)
        (e, d) = calculate_keys(p, q, nbits)

        # For some reason, d is sometimes negative. We don't know how
        # to fix it (yet), so we keep trying until everything is shiny
        if d > 0: break

    return (p, q, e, d)

def gen_pubpriv_keys(nbits):
    """Generates public and private keys, and returns them as (pub,
    priv).

    The public key consists of a dict {e: ..., , n: ....). The private
    key consists of a dict {d: ...., p: ...., q: ....).
    """
    
    (p, q, e, d) = gen_keys(nbits)

    return ( {'e': e, 'n': p*q}, {'d': d, 'p': p, 'q': q} )

def encrypt_int(message, ekey, n):
    """Encrypts a message using encryption key 'ekey', working modulo
    n"""

    if type(message) is types.IntType:
        return encrypt_int(long(message), ekey, n)

    if not type(message) is types.LongType:
        raise TypeError("You must pass a long or an int")

    if message > 0 and \
            math.floor(math.log(message, 2)) > math.floor(math.log(n, 2)):
        raise OverflowError("The message is too long")

    return fast_exponentiation(message, ekey, n)

def decrypt_int(cyphertext, dkey, n):
    """Decrypts a cypher text using the decryption key 'dkey', working
    modulo n"""

    return encrypt_int(cyphertext, dkey, n)

def sign_int(message, dkey, n):
    """Signs 'message' using key 'dkey', working modulo n"""

    return decrypt_int(message, dkey, n)

def verify_int(signed, ekey, n):
    """verifies 'signed' using key 'ekey', working modulo n"""

    return encrypt_int(signed, ekey, n)

def picklechops(chops):
    """Pickles and base64encodes it's argument chops"""

    value = zlib.compress(dumps(chops))
    encoded = base64.encodestring(value)
    return encoded.strip()

def unpicklechops(string):
    """base64decodes and unpickes it's argument string into chops"""

    return loads(zlib.decompress(base64.decodestring(string)))

def chopstring(message, key, n, funcref):
    """Splits 'message' into chops that are at most as long as n,
    converts these into integers, and calls funcref(integer, key, n)
    for each chop.

    Used by 'encrypt' and 'sign'.
    """

    msglen = len(message)
    mbits = msglen * 8
    nbits = int(math.floor(math.log(n, 2)))
    nbytes = nbits / 8
    blocks = msglen / nbytes

    if msglen % nbytes > 0:
        blocks += 1

    cypher = []
    
    for bindex in range(blocks):
        offset = bindex * nbytes
        block = message[offset:offset+nbytes]
        value = bytes2int(block)
        cypher.append(funcref(value, key, n))

    return picklechops(cypher)

def gluechops(chops, key, n, funcref):
    """Glues chops back together into a string.  calls
    funcref(integer, key, n) for each chop.

    Used by 'decrypt' and 'verify'.
    """
    message = ""

    chops = unpicklechops(chops)
    
    for cpart in chops:
        mpart = funcref(cpart, key, n)
        message += int2bytes(mpart)
    
    return message

def encrypt(message, key):
    """Encrypts a string 'message' with the public key 'key'"""
    
    return chopstring(message, key['e'], key['n'], encrypt_int)

def sign(message, key):
    """Signs a string 'message' with the private key 'key'"""
    
    return chopstring(message, key['d'], key['p']*key['q'], decrypt_int)

def decrypt(cypher, key):
    """Decrypts a cypher with the private key 'key'"""

    return gluechops(cypher, key['d'], key['p']*key['q'], decrypt_int)

def verify(cypher, key):
    """Verifies a cypher with the public key 'key'"""

    return gluechops(cypher, key['e'], key['n'], encrypt_int)

# Do doctest if we're not imported
if __name__ == "__main__":
    import doctest
    doctest.testmod()

__all__ = ["gen_pubpriv_keys", "encrypt", "decrypt", "sign", "verify"]

                                                                                                                                                                                                                                                                                                                                                                                         usr/local/lib/python2.7/dist-packages/rsa/_version133.pyc                                           0100644 0000000 0000062 00000032226 13077704403 021604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   s  d  Z  d Z d Z d Z d d l m Z m Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l m Z d d l Z e j d e É d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d Ñ  Z& d Ñ  Z' d Ñ  Z( d Ñ  Z) d  Ñ  Z* d! Ñ  Z+ d" Ñ  Z, d# Ñ  Z- d$ Ñ  Z. d% Ñ  Z/ d& Ñ  Z0 d' Ñ  Z1 e d( k rÎd d l2 Z2 e2 j3 É  n  d) d* d+ d, d- g Z4 d S(.   s#  RSA module
pri = k[1]                               	//Private part of keys d,p,q

Module for calculating large primes, and RSA encryption, decryption,
signing and verification. Includes generating public and private keys.

WARNING: this code implements the mathematics of RSA. It is not suitable for
real-world secure cryptography purposes. It has not been reviewed by a security
expert. It does not include padding of data. There are many ways in which the
output of this module, when used without any modification, can be sucessfully
attacked.
s.   Sybren Stuvel, Marloes de Boer and Ivo Tamboers
   2010-02-05s   1.3.3iˇˇˇˇ(   t   dumpst   loadsN(   t   bytes@   Insecure version of the RSA module is imported as %s, be carefulc         C   s@   |  | k  r t  | |  É S| d k r) |  St  | t |  | É É S(   sN   Returns the greatest common divisor of p and q


    >>> gcd(42, 6)
    6
    i    (   t   gcdt   abs(   t   pt   q(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyR   5   s
      c         C   så   t  |  É t j k p' t  |  É t j k s9 t d É Ç n  d } xF |  D]> } | d 9} t  | É t j k rz t | É } n  | | 7} qF W| S(   s°   Converts a list of bytes or a string to an integer

    >>> (128*256 + 64)*256 + + 15
    8405007
    >>> l = [128, 64, 15]
    >>> bytes2int(l)
    8405007
    s    You must pass a string or a listi    i   (   t   typet   typest   ListTypet
   StringTypet	   TypeErrort   ord(   t   bytest   integerR   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt	   bytes2int@   s    
*
 c         C   sz   t  |  É t j k p' t  |  É t j k s9 t d É Ç n  d } x4 |  d k ru d t |  d @É | f } |  d :}  qB W| S(   sf   Converts a number to a string of bytes
    
    >>> bytes2int(int2bytes(123456789))
    123456789
    s   You must pass a long or an intt    i    s   %s%siˇ   i   (   R   R   t   LongTypet   IntTypeR   R   (   t   numbert   string(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt	   int2bytesV   s    *c         C   sq   |  | } g  } x+ | d k r= | j  | d @É | d ?} q Wx, | rl | j É  } |  | | d | } qA W| S(   s   Calculates r = a^p mod n
    i   i   (   t   appendt   pop(   t   aR   t   nt   resultt
   remainderst   rem(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   fast_exponentiationh   s    
	c         C   s)   t  |  d É } t j | É } t | É S(   sP   Reads a random integer of approximately nbits bits rounded up
    to whole bytesg       @(   t   ceilt   ost   urandomR   (   t   nbitst   nbytest
   randomdata(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   read_random_intu   s    c         C   s   t  t j |  É É S(   s   ceil(x) -> int(math.ceil(x))(   t   intt   mathR   (   t   x(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyR   }   s    c         C   sg   d } | |  } t  t j | d É d É } t | d | d É } t j | | É } t | É | |  S(   s9   Returns a random integer x with minvalue <= x <= maxvaluei    i   g       @i   (   R   R&   t   logt   maxt   randomt   randintR$   (   t   minvaluet   maxvaluet	   min_nbitst   ranget
   rangebytest	   rangebitsR!   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyR+   Ç   s    
c         C   s'   t  d |  d É } t | |  d |  É S(   sP   Returns 1 if p may be prime, and something else if p definitely
    is not primei   (   R+   R   (   R   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   fermat_little_theoremó   s    c         C   sù   |  | d k r d Sd } x| |  d k rò |  d @rk |  d | d d ?d @rW | } n  |  | |  } }  q | d d d ?d @rã | } n  |  d ?}  q W| S(   s4   Calculates the value of the Jacobi symbol (a/b)
    i    i   i   i   (    (   R   t   bR   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   jacobiû   s    


c         C   sA   t  |  | É | } t |  | d d | É } | | k r= t St S(   sU   Returns False if n is an Euler pseudo-prime with base x, and
    True otherwise.
    i   i   (   R4   R   t   Falset   True(   R'   R   t   jt   f(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   jacobi_witness∞   s
     c         C   sk   d } t  | t j d | d É É } x> t | d É D], } t d |  d É } t | |  É r7 t Sq7 Wt S(   s”   Calculates whether n is composite (which is always correct) or
    prime (which is incorrect with error probability 2**-k)

    Returns False if the number if composite, and True if it's
    probably prime.
    g      ‡?i   i   (   R   R&   R(   R/   R+   R9   R5   R6   (   R   t   kR   t   tt   iR'   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   randomized_primality_testingª   s      c         C   s   t  |  d É r t St S(   su   Returns True if the number is prime, and False otherwise.

    >>> is_prime(42)
    0
    >>> is_prime(41)
    1
    i   (   R=   R6   R5   (   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   is_primeÕ   s    c         C   sP   t  t j |  d É É } x0 t rK t |  É } | d O} t | É r Pq q W| S(   s„   Returns a prime number of max. 'math.ceil(nbits/8)*8' bits. In
    other words: nbits is rounded up to whole bytes.

    >>> p = getprime(8)
    >>> is_prime(p-1)
    0
    >>> is_prime(p)
    1
    >>> is_prime(p+1)
    0
    g       @i   (   R%   R&   R   R6   R$   R>   (   R!   R"   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   getprime‰   s    	
 c         C   s   t  |  | É } | d k S(   s§   Returns True if a and b are relatively prime, and False if they
    are not.

    >>> are_relatively_prime(2, 3)
    1
    >>> are_relatively_prime(2, 4)
    0
    i   (   R   (   R   R3   t   d(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   are_relatively_prime   s    
c         C   s?   t  |  É } x& t r4 t  |  É } | | k s Pq q W| | f S(   s5   Returns a tuple of two different primes of nbits bits(   R?   R6   (   R!   R   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   find_p_q  s    	 c         C   sf   | d k r |  d d f St  |  | É } t |  | É } t | | É \ } } } | | | | | f S(   s@   Returns a tuple (d, i, j) such that d = gcd(a, b) = ia + jb
    i    i   (   R   t   longt   extended_euclid_gcd(   R   R3   R   t   rR@   R:   t   l(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyRD     s    c   	      C   s€   |  | } |  d | d } xE t  rc t t d | d É É } t | | É r t | | É r Pq q Wt | | É \ } } } | d k s° t d | | f É Ç n  | | | d k s— t d | | | f É Ç n  | | f S(   sa   Calculates an encryption and a decryption key for p and q, and
    returns them as a tuple (e, d)i   i   i   s.   e (%d) and phi_n (%d) are not relatively primes6   e (%d) and i (%d) are not mult. inv. modulo phi_n (%d)(   R6   R?   R)   RA   RD   t	   Exception(	   R   R   R!   R   t   phi_nt   eR@   R<   R7   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   calculate_keys%  s    
	 c         C   sW   xD t  rF t |  É \ } } t | | |  É \ } } | d k r Pq q W| | | | f S(   s|   Generate RSA keys of nbits bits. Returns (p, q, e, d).

    Note: this can take a long time, depending on the key size.
    i    (   R6   RB   RJ   (   R!   R   R   RI   R@   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   gen_keys=  s    	 c         C   sI   t  |  É \ } } } } i | d 6| | d 6i | d 6| d 6| d 6f S(   sÃ   Generates public and private keys, and returns them as (pub,
    priv).

    The public key consists of a dict {e: ..., , n: ....). The private
    key consists of a dict {d: ...., p: ...., q: ....).
    RI   R   R@   R   R   (   RK   (   R!   R   R   RI   R@   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   gen_pubpriv_keysM  s    c         C   s∞   t  |  É t j k r+ t t |  É | | É St  |  É t j k	 rO t d É Ç n  |  d k r† t j t j	 |  d É É t j t j	 | d É É k r† t
 d É Ç n  t |  | | É S(   sD   Encrypts a message using encryption key 'ekey', working modulo
    ns   You must pass a long or an inti    i   s   The message is too long(   R   R   R   t   encrypt_intRC   R   R   R&   t   floorR(   t   OverflowErrorR   (   t   messaget   ekeyR   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyRM   Y  s    6c         C   s   t  |  | | É S(   sL   Decrypts a cypher text using the decryption key 'dkey', working
    modulo n(   RM   (   t
   cyphertextt   dkeyR   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   decrypt_inti  s    c         C   s   t  |  | | É S(   s2   Signs 'message' using key 'dkey', working modulo n(   RT   (   RP   RS   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   sign_into  s    c         C   s   t  |  | | É S(   s4   verifies 'signed' using key 'ekey', working modulo n(   RM   (   t   signedRQ   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt
   verify_intt  s    c         C   s.   t  j t |  É É } t j | É } | j É  S(   s-   Pickles and base64encodes it's argument chops(   t   zlibt   compressR    t   base64t   encodestringt   strip(   t   chopst   valuet   encoded(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   picklechopsy  s    c         C   s   t  t j t j |  É É É S(   s:   base64decodes and unpickes it's argument string into chops(   R   RX   t
   decompressRZ   t   decodestring(   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   unpicklechopsÄ  s    c         C   sœ   t  |  É } | d } t t j t j | d É É É } | d } | | } | | d k rh | d 7} n  g  }	 xT t | É D]F }
 |
 | } |  | | | !} t | É } |	 j | | | | É É q{ Wt |	 É S(   s∫   Splits 'message' into chops that are at most as long as n,
    converts these into integers, and calls funcref(integer, key, n)
    for each chop.

    Used by 'encrypt' and 'sign'.
    i   i   i    i   (	   t   lenR%   R&   RN   R(   R/   R   R   R`   (   RP   t   keyR   t   funcreft   msglent   mbitsR!   R"   t   blockst   cyphert   bindext   offsett   blockR^   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt
   chopstringÖ  s    
!


c         C   sI   d } t  |  É }  x0 |  D]( } | | | | É } | t | É 7} q W| S(   sÖ   Glues chops back together into a string.  calls
    funcref(integer, key, n) for each chop.

    Used by 'decrypt' and 'verify'.
    R   (   Rc   R   (   R]   Re   R   Rf   RP   t   cpartt   mpart(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt	   gluechops†  s    c         C   s   t  |  | d | d t É S(   s5   Encrypts a string 'message' with the public key 'key'RI   R   (   Rn   RM   (   RP   Re   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   encrypt∞  s    c         C   s#   t  |  | d | d | d t É S(   s3   Signs a string 'message' with the private key 'key'R@   R   R   (   Rn   RT   (   RP   Re   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   signµ  s    c         C   s#   t  |  | d | d | d t É S(   s,   Decrypts a cypher with the private key 'key'R@   R   R   (   Rq   RT   (   Rj   Re   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   decrypt∫  s    c         C   s   t  |  | d | d t É S(   s+   Verifies a cypher with the public key 'key'RI   R   (   Rq   RM   (   Rj   Re   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   verifyø  s    t   __main__RL   Rr   Rt   Rs   Ru   (5   t   __doc__t
   __author__t   __date__t   __version__t   cPickleR    R   RZ   R&   R   R*   t   sysR   RX   t   rsa._compatR   t   warningst   warnt   __name__R   R   R   R   R$   R   R+   R2   R4   R9   R=   R>   R?   RA   RB   RD   RJ   RK   RL   RM   RT   RU   RW   R`   Rc   Rn   Rq   Rr   Rs   Rt   Ru   t   doctestt   testmodt   __all__(    (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version133.pyt   <module>   sd   																
																                                                                                                                                                                                                                                                                                                                                                                          usr/local/lib/python2.7/dist-packages/rsa/_version200.py                                            0100644 0000000 0000062 00000036434 13077704374 021450  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""RSA module

Module for calculating large primes, and RSA encryption, decryption,
signing and verification. Includes generating public and private keys.

WARNING: this implementation does not use random padding, compression of the
cleartext input to prevent repetitions, or other common security improvements.
Use with care.

"""

__author__ = "Sybren Stuvel, Marloes de Boer, Ivo Tamboer, and Barry Mead"
__date__ = "2010-02-08"
__version__ = '2.0'

import math
import os
import random
import sys
import types
from rsa._compat import byte

# Display a warning that this insecure version is imported.
import warnings
warnings.warn('Insecure version of the RSA module is imported as %s' % __name__)


def bit_size(number):
    """Returns the number of bits required to hold a specific long number"""

    return int(math.ceil(math.log(number,2)))

def gcd(p, q):
    """Returns the greatest common divisor of p and q
    >>> gcd(48, 180)
    12
    """
    # Iterateive Version is faster and uses much less stack space
    while q != 0:
        if p < q: (p,q) = (q,p)
        (p,q) = (q, p % q)
    return p
    

def bytes2int(bytes):
    """Converts a list of bytes or a string to an integer

    >>> (((128 * 256) + 64) * 256) + 15
    8405007
    >>> l = [128, 64, 15]
    >>> bytes2int(l)              #same as bytes2int('\x80@\x0f')
    8405007
    """

    if not (type(bytes) is types.ListType or type(bytes) is types.StringType):
        raise TypeError("You must pass a string or a list")

    # Convert byte stream to integer
    integer = 0
    for byte in bytes:
        integer *= 256
        if type(byte) is types.StringType: byte = ord(byte)
        integer += byte

    return integer

def int2bytes(number):
    """
    Converts a number to a string of bytes
    """

    if not (type(number) is types.LongType or type(number) is types.IntType):
        raise TypeError("You must pass a long or an int")

    string = ""

    while number > 0:
        string = "%s%s" % (byte(number & 0xFF), string)
        number /= 256
    
    return string

def to64(number):
    """Converts a number in the range of 0 to 63 into base 64 digit
    character in the range of '0'-'9', 'A'-'Z', 'a'-'z','-','_'.
    
    >>> to64(10)
    'A'
    """

    if not (type(number) is types.LongType or type(number) is types.IntType):
        raise TypeError("You must pass a long or an int")

    if 0 <= number <= 9:            #00-09 translates to '0' - '9'
        return byte(number + 48)

    if 10 <= number <= 35:
        return byte(number + 55)     #10-35 translates to 'A' - 'Z'

    if 36 <= number <= 61:
        return byte(number + 61)     #36-61 translates to 'a' - 'z'

    if number == 62:                # 62   translates to '-' (minus)
        return byte(45)

    if number == 63:                # 63   translates to '_' (underscore)
        return byte(95)

    raise ValueError('Invalid Base64 value: %i' % number)


def from64(number):
    """Converts an ordinal character value in the range of
    0-9,A-Z,a-z,-,_ to a number in the range of 0-63.
    
    >>> from64(49)
    1
    """

    if not (type(number) is types.LongType or type(number) is types.IntType):
        raise TypeError("You must pass a long or an int")

    if 48 <= number <= 57:         #ord('0') - ord('9') translates to 0-9
        return(number - 48)

    if 65 <= number <= 90:         #ord('A') - ord('Z') translates to 10-35
        return(number - 55)

    if 97 <= number <= 122:        #ord('a') - ord('z') translates to 36-61
        return(number - 61)

    if number == 45:               #ord('-') translates to 62
        return(62)

    if number == 95:               #ord('_') translates to 63
        return(63)

    raise ValueError('Invalid Base64 value: %i' % number)


def int2str64(number):
    """Converts a number to a string of base64 encoded characters in
    the range of '0'-'9','A'-'Z,'a'-'z','-','_'.
    
    >>> int2str64(123456789)
    '7MyqL'
    """

    if not (type(number) is types.LongType or type(number) is types.IntType):
        raise TypeError("You must pass a long or an int")

    string = ""

    while number > 0:
        string = "%s%s" % (to64(number & 0x3F), string)
        number /= 64

    return string


def str642int(string):
    """Converts a base64 encoded string into an integer.
    The chars of this string in in the range '0'-'9','A'-'Z','a'-'z','-','_'
    
    >>> str642int('7MyqL')
    123456789
    """

    if not (type(string) is types.ListType or type(string) is types.StringType):
        raise TypeError("You must pass a string or a list")

    integer = 0
    for byte in string:
        integer *= 64
        if type(byte) is types.StringType: byte = ord(byte)
        integer += from64(byte)

    return integer

def read_random_int(nbits):
    """Reads a random integer of approximately nbits bits rounded up
    to whole bytes"""

    nbytes = int(math.ceil(nbits/8.))
    randomdata = os.urandom(nbytes)
    return bytes2int(randomdata)

def randint(minvalue, maxvalue):
    """Returns a random integer x with minvalue <= x <= maxvalue"""

    # Safety - get a lot of random data even if the range is fairly
    # small
    min_nbits = 32

    # The range of the random numbers we need to generate
    range = (maxvalue - minvalue) + 1

    # Which is this number of bytes
    rangebytes = ((bit_size(range) + 7) / 8)

    # Convert to bits, but make sure it's always at least min_nbits*2
    rangebits = max(rangebytes * 8, min_nbits * 2)
    
    # Take a random number of bits between min_nbits and rangebits
    nbits = random.randint(min_nbits, rangebits)
    
    return (read_random_int(nbits) % range) + minvalue

def jacobi(a, b):
    """Calculates the value of the Jacobi symbol (a/b)
    where both a and b are positive integers, and b is odd
    """

    if a == 0: return 0
    result = 1
    while a > 1:
        if a & 1:
            if ((a-1)*(b-1) >> 2) & 1:
                result = -result
            a, b = b % a, a
        else:
            if (((b * b) - 1) >> 3) & 1:
                result = -result
            a >>= 1
    if a == 0: return 0
    return result

def jacobi_witness(x, n):
    """Returns False if n is an Euler pseudo-prime with base x, and
    True otherwise.
    """

    j = jacobi(x, n) % n
    f = pow(x, (n-1)/2, n)

    if j == f: return False
    return True

def randomized_primality_testing(n, k):
    """Calculates whether n is composite (which is always correct) or
    prime (which is incorrect with error probability 2**-k)

    Returns False if the number is composite, and True if it's
    probably prime.
    """

    # 50% of Jacobi-witnesses can report compositness of non-prime numbers

    for i in range(k):
        x = randint(1, n-1)
        if jacobi_witness(x, n): return False
    
    return True

def is_prime(number):
    """Returns True if the number is prime, and False otherwise.

    >>> is_prime(42)
    0
    >>> is_prime(41)
    1
    """

    if randomized_primality_testing(number, 6):
        # Prime, according to Jacobi
        return True
    
    # Not prime
    return False

    
def getprime(nbits):
    """Returns a prime number of max. 'math.ceil(nbits/8)*8' bits. In
    other words: nbits is rounded up to whole bytes.

    >>> p = getprime(8)
    >>> is_prime(p-1)
    0
    >>> is_prime(p)
    1
    >>> is_prime(p+1)
    0
    """

    while True:
        integer = read_random_int(nbits)

        # Make sure it's odd
        integer |= 1

        # Test for primeness
        if is_prime(integer): break

        # Retry if not prime

    return integer

def are_relatively_prime(a, b):
    """Returns True if a and b are relatively prime, and False if they
    are not.

    >>> are_relatively_prime(2, 3)
    1
    >>> are_relatively_prime(2, 4)
    0
    """

    d = gcd(a, b)
    return (d == 1)

def find_p_q(nbits):
    """Returns a tuple of two different primes of nbits bits"""
    pbits = nbits + (nbits/16)  #Make sure that p and q aren't too close
    qbits = nbits - (nbits/16)  #or the factoring programs can factor n
    p = getprime(pbits)
    while True:
        q = getprime(qbits)
        #Make sure p and q are different.
        if not q == p: break
    return (p, q)

def extended_gcd(a, b):
    """Returns a tuple (r, i, j) such that r = gcd(a, b) = ia + jb
    """
    # r = gcd(a,b) i = multiplicitive inverse of a mod b
    #      or      j = multiplicitive inverse of b mod a
    # Neg return values for i or j are made positive mod b or a respectively
    # Iterateive Version is faster and uses much less stack space
    x = 0
    y = 1
    lx = 1
    ly = 0
    oa = a                             #Remember original a/b to remove 
    ob = b                             #negative values from return results
    while b != 0:
        q = long(a/b)
        (a, b)  = (b, a % b)
        (x, lx) = ((lx - (q * x)),x)
        (y, ly) = ((ly - (q * y)),y)
    if (lx < 0): lx += ob              #If neg wrap modulo orignal b
    if (ly < 0): ly += oa              #If neg wrap modulo orignal a
    return (a, lx, ly)                 #Return only positive values

# Main function: calculate encryption and decryption keys
def calculate_keys(p, q, nbits):
    """Calculates an encryption and a decryption key for p and q, and
    returns them as a tuple (e, d)"""

    n = p * q
    phi_n = (p-1) * (q-1)

    while True:
        # Make sure e has enough bits so we ensure "wrapping" through
        # modulo n
        e = max(65537,getprime(nbits/4))
        if are_relatively_prime(e, n) and are_relatively_prime(e, phi_n): break

    (d, i, j) = extended_gcd(e, phi_n)

    if not d == 1:
        raise Exception("e (%d) and phi_n (%d) are not relatively prime" % (e, phi_n))
    if (i < 0):
        raise Exception("New extended_gcd shouldn't return negative values")
    if not (e * i) % phi_n == 1:
        raise Exception("e (%d) and i (%d) are not mult. inv. modulo phi_n (%d)" % (e, i, phi_n))

    return (e, i)


def gen_keys(nbits):
    """Generate RSA keys of nbits bits. Returns (p, q, e, d).

    Note: this can take a long time, depending on the key size.
    """

    (p, q) = find_p_q(nbits)
    (e, d) = calculate_keys(p, q, nbits)

    return (p, q, e, d)

def newkeys(nbits):
    """Generates public and private keys, and returns them as (pub,
    priv).

    The public key consists of a dict {e: ..., , n: ....). The private
    key consists of a dict {d: ...., p: ...., q: ....).
    """
    nbits = max(9,nbits)           # Don't let nbits go below 9 bits
    (p, q, e, d) = gen_keys(nbits)

    return ( {'e': e, 'n': p*q}, {'d': d, 'p': p, 'q': q} )

def encrypt_int(message, ekey, n):
    """Encrypts a message using encryption key 'ekey', working modulo n"""

    if type(message) is types.IntType:
        message = long(message)

    if not type(message) is types.LongType:
        raise TypeError("You must pass a long or int")

    if message < 0 or message > n:
        raise OverflowError("The message is too long")

    #Note: Bit exponents start at zero (bit counts start at 1) this is correct
    safebit = bit_size(n) - 2                   #compute safe bit (MSB - 1)
    message += (1 << safebit)                   #add safebit to ensure folding

    return pow(message, ekey, n)

def decrypt_int(cyphertext, dkey, n):
    """Decrypts a cypher text using the decryption key 'dkey', working
    modulo n"""

    message = pow(cyphertext, dkey, n)

    safebit = bit_size(n) - 2                   #compute safe bit (MSB - 1)
    message -= (1 << safebit)                   #remove safebit before decode

    return message

def encode64chops(chops):
    """base64encodes chops and combines them into a ',' delimited string"""

    chips = []                              #chips are character chops

    for value in chops:
        chips.append(int2str64(value))

    #delimit chops with comma
    encoded = ','.join(chips)

    return encoded

def decode64chops(string):
    """base64decodes and makes a ',' delimited string into chops"""

    chips = string.split(',')               #split chops at commas

    chops = []

    for string in chips:                    #make char chops (chips) into chops
        chops.append(str642int(string))

    return chops

def chopstring(message, key, n, funcref):
    """Chops the 'message' into integers that fit into n,
    leaving room for a safebit to be added to ensure that all
    messages fold during exponentiation.  The MSB of the number n
    is not independant modulo n (setting it could cause overflow), so
    use the next lower bit for the safebit.  Therefore reserve 2-bits
    in the number n for non-data bits.  Calls specified encryption
    function for each chop.

    Used by 'encrypt' and 'sign'.
    """

    msglen = len(message)
    mbits = msglen * 8
    #Set aside 2-bits so setting of safebit won't overflow modulo n.
    nbits = bit_size(n) - 2             # leave room for safebit
    nbytes = nbits / 8
    blocks = msglen / nbytes

    if msglen % nbytes > 0:
        blocks += 1

    cypher = []
    
    for bindex in range(blocks):
        offset = bindex * nbytes
        block = message[offset:offset+nbytes]
        value = bytes2int(block)
        cypher.append(funcref(value, key, n))

    return encode64chops(cypher)   #Encode encrypted ints to base64 strings

def gluechops(string, key, n, funcref):
    """Glues chops back together into a string.  calls
    funcref(integer, key, n) for each chop.

    Used by 'decrypt' and 'verify'.
    """
    message = ""

    chops = decode64chops(string)  #Decode base64 strings into integer chops
    
    for cpart in chops:
        mpart = funcref(cpart, key, n) #Decrypt each chop
        message += int2bytes(mpart)    #Combine decrypted strings into a msg
    
    return message

def encrypt(message, key):
    """Encrypts a string 'message' with the public key 'key'"""
    if 'n' not in key:
        raise Exception("You must use the public key with encrypt")

    return chopstring(message, key['e'], key['n'], encrypt_int)

def sign(message, key):
    """Signs a string 'message' with the private key 'key'"""
    if 'p' not in key:
        raise Exception("You must use the private key with sign")

    return chopstring(message, key['d'], key['p']*key['q'], encrypt_int)

def decrypt(cypher, key):
    """Decrypts a string 'cypher' with the private key 'key'"""
    if 'p' not in key:
        raise Exception("You must use the private key with decrypt")

    return gluechops(cypher, key['d'], key['p']*key['q'], decrypt_int)

def verify(cypher, key):
    """Verifies a string 'cypher' with the public key 'key'"""
    if 'n' not in key:
        raise Exception("You must use the public key with verify")

    return gluechops(cypher, key['e'], key['n'], decrypt_int)

# Do doctest if we're not imported
if __name__ == "__main__":
    import doctest
    doctest.testmod()

__all__ = ["newkeys", "encrypt", "decrypt", "sign", "verify"]

                                                                                                                                                                                                                                    usr/local/lib/python2.7/dist-packages/rsa/_version200.pyc                                           0100644 0000000 0000062 00000036065 13077704403 021604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   s÷  d  Z  d Z d Z d Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 m
 Z
 d d l Z e j d e É d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d Ñ  Z$ d Ñ  Z% d  Ñ  Z& d! Ñ  Z' d" Ñ  Z( d# Ñ  Z) d$ Ñ  Z* d% Ñ  Z+ d& Ñ  Z, e d' k rΩd d l- Z- e- j. É  n  d( d) d* d+ d, g Z/ d S(-   sE  RSA module

Module for calculating large primes, and RSA encryption, decryption,
signing and verification. Includes generating public and private keys.

WARNING: this implementation does not use random padding, compression of the
cleartext input to prevent repetitions, or other common security improvements.
Use with care.

s;   Sybren Stuvel, Marloes de Boer, Ivo Tamboer, and Barry Meads
   2010-02-08s   2.0iˇˇˇˇN(   t   bytes4   Insecure version of the RSA module is imported as %sc         C   s   t  t j t j |  d É É É S(   sB   Returns the number of bits required to hold a specific long numberi   (   t   intt   matht   ceilt   log(   t   number(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   bit_size,   s    c         C   sD   x= | d k r? |  | k  r+ | |  }  } n  | |  | }  } q W|  S(   sO   Returns the greatest common divisor of p and q
    >>> gcd(48, 180)
    12
    i    (    (   t   pt   q(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   gcd1   s
     c         C   så   t  |  É t j k p' t  |  É t j k s9 t d É Ç n  d } xF |  D]> } | d 9} t  | É t j k rz t | É } n  | | 7} qF W| S(   sŒ   Converts a list of bytes or a string to an integer

    >>> (((128 * 256) + 64) * 256) + 15
    8405007
    >>> l = [128, 64, 15]
    >>> bytes2int(l)              #same as bytes2int('Ä@')
    8405007
    s    You must pass a string or a listi    i   (   t   typet   typest   ListTypet
   StringTypet	   TypeErrort   ord(   t   bytest   integerR    (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt	   bytes2int=   s    
*
 c         C   sz   t  |  É t j k p' t  |  É t j k s9 t d É Ç n  d } x4 |  d k ru d t |  d @É | f } |  d :}  qB W| S(   s0   
    Converts a number to a string of bytes
    s   You must pass a long or an intt    i    s   %s%siˇ   i   (   R
   R   t   LongTypet   IntTypeR   R    (   R   t   string(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt	   int2bytesS   s    *c         C   s˜   t  |  É t j k p' t  |  É t j k s9 t d É Ç n  d |  k oP d k n rc t |  d É Sd |  k oz d k n rç t |  d É Sd |  k o§ d	 k n r∑ t |  d	 É S|  d
 k rÕ t d É S|  d k r„ t d É St d |  É Ç d S(   s†   Converts a number in the range of 0 to 63 into base 64 digit
    character in the range of '0'-'9', 'A'-'Z', 'a'-'z','-','_'.
    
    >>> to64(10)
    'A'
    s   You must pass a long or an inti    i	   i0   i
   i#   i7   i$   i=   i>   i-   i?   i_   s   Invalid Base64 value: %iN(   R
   R   R   R   R   R    t
   ValueError(   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   to64c   s    *

c         C   sŸ   t  |  É t j k p' t  |  É t j k s9 t d É Ç n  d |  k oP d k n r] |  d Sd |  k ot d k n rÅ |  d Sd |  k oò d k n r• |  d	 S|  d
 k rµ d S|  d k r≈ d St d |  É Ç d S(   så   Converts an ordinal character value in the range of
    0-9,A-Z,a-z,-,_ to a number in the range of 0-63.
    
    >>> from64(49)
    1
    s   You must pass a long or an inti0   i9   iA   iZ   i7   ia   iz   i=   i-   i>   i_   i?   s   Invalid Base64 value: %iN(   R
   R   R   R   R   R   (   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   from64Ä   s    *c         C   sz   t  |  É t j k p' t  |  É t j k s9 t d É Ç n  d } x4 |  d k ru d t |  d @É | f } |  d :}  qB W| S(   s°   Converts a number to a string of base64 encoded characters in
    the range of '0'-'9','A'-'Z,'a'-'z','-','_'.
    
    >>> int2str64(123456789)
    '7MyqL'
    s   You must pass a long or an intR   i    s   %s%si?   i@   (   R
   R   R   R   R   R   (   R   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt	   int2str64ù   s    *c         C   sí   t  |  É t j k p' t  |  É t j k s9 t d É Ç n  d } xL |  D]D } | d 9} t  | É t j k rz t | É } n  | t | É 7} qF W| S(   s±   Converts a base64 encoded string into an integer.
    The chars of this string in in the range '0'-'9','A'-'Z','a'-'z','-','_'
    
    >>> str642int('7MyqL')
    123456789
    s    You must pass a string or a listi    i@   (   R
   R   R   R   R   R   R   (   R   R   R    (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt	   str642int±   s    *
 c         C   s2   t  t j |  d É É } t j | É } t | É S(   sP   Reads a random integer of approximately nbits bits rounded up
    to whole bytesg       @(   R   R   R   t   ost   urandomR   (   t   nbitst   nbytest
   randomdata(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   read_random_intƒ   s    c         C   sc   d } | |  d } t  | É d d } t | d | d É } t j | | É } t | É | |  S(   s9   Returns a random integer x with minvalue <= x <= maxvaluei    i   i   i   i   (   R   t   maxt   randomt   randintR"   (   t   minvaluet   maxvaluet	   min_nbitst   ranget
   rangebytest	   rangebitsR   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyR%   Ã   s    c         C   s©   |  d k r d Sd } x| |  d k rî |  d @rg |  d | d d ?d @rS | } n  | |  |  }  } q | | d d ?d @rá | } n  |  d L}  q W|  d k r• d S| S(   so   Calculates the value of the Jacobi symbol (a/b)
    where both a and b are positive integers, and b is odd
    i    i   i   i   (    (   t   at   bt   result(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   jacobi·   s     


 c         C   sA   t  |  | É | } t |  | d d | É } | | k r= t St S(   sU   Returns False if n is an Euler pseudo-prime with base x, and
    True otherwise.
    i   i   (   R/   t   powt   Falset   True(   t   xt   nt   jt   f(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   jacobi_witnessÙ   s
     c         C   sA   x: t  | É D], } t d |  d É } t | |  É r t Sq Wt S(   s”   Calculates whether n is composite (which is always correct) or
    prime (which is incorrect with error probability 2**-k)

    Returns False if the number is composite, and True if it's
    probably prime.
    i   (   R)   R%   R7   R1   R2   (   R4   t   kt   iR3   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   randomized_primality_testingˇ   s
    
 c         C   s   t  |  d É r t St S(   su   Returns True if the number is prime, and False otherwise.

    >>> is_prime(42)
    0
    >>> is_prime(41)
    1
    i   (   R:   R2   R1   (   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   is_prime  s    	c         C   s7   x0 t  r2 t |  É } | d O} t | É r Pq q W| S(   s„   Returns a prime number of max. 'math.ceil(nbits/8)*8' bits. In
    other words: nbits is rounded up to whole bytes.

    >>> p = getprime(8)
    >>> is_prime(p-1)
    0
    >>> is_prime(p)
    1
    >>> is_prime(p+1)
    0
    i   (   R2   R"   R;   (   R   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   getprime   s    	
 c         C   s   t  |  | É } | d k S(   s§   Returns True if a and b are relatively prime, and False if they
    are not.

    >>> are_relatively_prime(2, 3)
    1
    >>> are_relatively_prime(2, 4)
    0
    i   (   R	   (   R,   R-   t   d(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   are_relatively_prime:  s    
c         C   s[   |  |  d } |  |  d } t  | É } x& t rP t  | É } | | k s+ Pq+ q+ W| | f S(   s5   Returns a tuple of two different primes of nbits bitsi   (   R<   R2   (   R   t   pbitst   qbitsR   R   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   find_p_qG  s    	 c   	      C   s¡   d } d } d } d } |  } | } x[ | d k rÅ t  |  | É } | |  | }  } | | | | } } | | | | } } q' W| d k  rõ | | 7} n  | d k  r¥ | | 7} n  |  | | f S(   s@   Returns a tuple (r, i, j) such that r = gcd(a, b) = ia + jb
    i    i   (   t   long(	   R,   R-   R3   t   yt   lxt   lyt   oat   obR   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   extended_gcdR  s       c   	      C   sˆ   |  | } |  d | d } xE t  rc t d t | d É É } t | | É r t | | É r Pq q Wt | | É \ } } } | d k s° t d | | f É Ç n  | d k  rº t d É Ç n  | | | d k sÏ t d | | | f É Ç n  | | f S(   sa   Calculates an encryption and a decryption key for p and q, and
    returns them as a tuple (e, d)i   i  i   s.   e (%d) and phi_n (%d) are not relatively primei    s1   New extended_gcd shouldn't return negative valuess6   e (%d) and i (%d) are not mult. inv. modulo phi_n (%d)(   R2   R#   R<   R>   RH   t	   Exception(	   R   R   R   R4   t   phi_nt   eR=   R9   R5   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   calculate_keysi  s    
	 c         C   s:   t  |  É \ } } t | | |  É \ } } | | | | f S(   s|   Generate RSA keys of nbits bits. Returns (p, q, e, d).

    Note: this can take a long time, depending on the key size.
    (   RA   RL   (   R   R   R   RK   R=   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   gen_keysÇ  s    c         C   sX   t  d |  É }  t |  É \ } } } } i | d 6| | d 6i | d 6| d 6| d 6f S(   sÃ   Generates public and private keys, and returns them as (pub,
    priv).

    The public key consists of a dict {e: ..., , n: ....). The private
    key consists of a dict {d: ...., p: ...., q: ....).
    i	   RK   R4   R=   R   R   (   R#   RM   (   R   R   R   RK   R=   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   newkeysç  s    c         C   sù   t  |  É t j k r$ t |  É }  n  t  |  É t j k	 rH t d É Ç n  |  d k  s` |  | k ro t d É Ç n  t | É d } |  d | >7}  t |  | | É S(   s@   Encrypts a message using encryption key 'ekey', working modulo ns   You must pass a long or inti    s   The message is too longi   i   (	   R
   R   R   RB   R   R   t   OverflowErrorR   R0   (   t   messaget   ekeyR4   t   safebit(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   encrypt_intô  s    c         C   s4   t  |  | | É } t | É d } | d | >8} | S(   sL   Decrypts a cypher text using the decryption key 'dkey', working
    modulo ni   i   (   R0   R   (   t
   cyphertextt   dkeyR4   RP   RR   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   decrypt_int´  s    c         C   s=   g  } x! |  D] } | j  t | É É q Wd j | É } | S(   sA   base64encodes chops and combines them into a ',' delimited stringt   ,(   t   appendR   t   join(   t   chopst   chipst   valuet   encoded(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   encode64chops∂  s
    c         C   s=   |  j  d É } g  } x! | D] }  | j t |  É É q W| S(   s9   base64decodes and makes a ',' delimited string into chopsRW   (   t   splitRX   R   (   R   R[   RZ   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   decode64chops√  s
    c         C   sæ   t  |  É } | d } t | É d } | d } | | } | | d k rW | d 7} n  g  }	 xT t | É D]F }
 |
 | } |  | | | !} t | É } |	 j | | | | É É qj Wt |	 É S(   s≈  Chops the 'message' into integers that fit into n,
    leaving room for a safebit to be added to ensure that all
    messages fold during exponentiation.  The MSB of the number n
    is not independant modulo n (setting it could cause overflow), so
    use the next lower bit for the safebit.  Therefore reserve 2-bits
    in the number n for non-data bits.  Calls specified encryption
    function for each chop.

    Used by 'encrypt' and 'sign'.
    i   i   i    i   (   t   lenR   R)   R   RX   R^   (   RP   t   keyR4   t   funcreft   msglent   mbitsR   R    t   blockst   cyphert   bindext   offsett   blockR\   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt
   chopstringœ  s    



c         C   sI   d } t  |  É } x0 | D]( } | | | | É } | t | É 7} q W| S(   sÖ   Glues chops back together into a string.  calls
    funcref(integer, key, n) for each chop.

    Used by 'decrypt' and 'verify'.
    R   (   R`   R   (   R   Rb   R4   Rc   RP   RZ   t   cpartt   mpart(    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt	   gluechopsÔ  s    c         C   s6   d | k r t  d É Ç n  t |  | d | d t É S(   s5   Encrypts a string 'message' with the public key 'key'R4   s(   You must use the public key with encryptRK   (   RI   Rk   RS   (   RP   Rb   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   encryptˇ  s    c         C   s>   d | k r t  d É Ç n  t |  | d | d | d t É S(   s3   Signs a string 'message' with the private key 'key'R   s&   You must use the private key with signR=   R   (   RI   Rk   RS   (   RP   Rb   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   sign  s    c         C   s>   d | k r t  d É Ç n  t |  | d | d | d t É S(   s5   Decrypts a string 'cypher' with the private key 'key'R   s)   You must use the private key with decryptR=   R   (   RI   Rn   RV   (   Rg   Rb   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   decrypt  s    c         C   s6   d | k r t  d É Ç n  t |  | d | d t É S(   s4   Verifies a string 'cypher' with the public key 'key'R4   s'   You must use the public key with verifyRK   (   RI   Rn   RV   (   Rg   Rb   (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   verify  s    t   __main__RN   Ro   Rq   Rp   Rr   (0   t   __doc__t
   __author__t   __date__t   __version__R   R   R$   t   sysR   t   rsa._compatR    t   warningst   warnt   __name__R   R	   R   R   R   R   R   R   R"   R%   R/   R7   R:   R;   R<   R>   RA   RH   RL   RM   RN   RS   RV   R^   R`   Rk   Rn   Ro   Rp   Rq   Rr   t   doctestt   testmodt   __all__(    (    (    s,   /tmp/pip-build-awuatQ/rsa/rsa/_version200.pyt   <module>   s\   																										 					                                                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/local/lib/python2.7/dist-packages/rsa/asn1.py                                                   0100644 0000000 0000062 00000003370 13077704374 020235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''ASN.1 definitions.

Not all ASN.1-handling code use these definitions, but when it does, they should be here.
'''

from pyasn1.type import univ, namedtype, tag

class PubKeyHeader(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('oid', univ.ObjectIdentifier()),
        namedtype.NamedType('parameters', univ.Null()),
    )

class OpenSSLPubKey(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('header', PubKeyHeader()),
        
        # This little hack (the implicit tag) allows us to get a Bit String as Octet String
        namedtype.NamedType('key', univ.OctetString().subtype(
                                          implicitTag=tag.Tag(tagClass=0, tagFormat=0, tagId=3))),
    )


class AsnPubKey(univ.Sequence):
    '''ASN.1 contents of DER encoded public key:
    
    RSAPublicKey ::= SEQUENCE {
         modulus           INTEGER,  -- n
         publicExponent    INTEGER,  -- e
    '''

    componentType = namedtype.NamedTypes(
        namedtype.NamedType('modulus', univ.Integer()),
        namedtype.NamedType('publicExponent', univ.Integer()),
    )
                                                                                                                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/rsa/asn1.pyc                                                  0100644 0000000 0000062 00000003135 13077704403 020370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   sq   d  Z  d d l m Z m Z m Z d e j f d Ñ  É  YZ d e j f d Ñ  É  YZ d e j f d Ñ  É  YZ d	 S(
   sn   ASN.1 definitions.

Not all ASN.1-handling code use these definitions, but when it does, they should be here.
iˇˇˇˇ(   t   univt	   namedtypet   tagt   PubKeyHeaderc           B   s>   e  Z e j e j d  e j É  É e j d e j É  É É Z RS(   t   oidt
   parameters(	   t   __name__t
   __module__R   t
   NamedTypest	   NamedTypeR    t   ObjectIdentifiert   Nullt   componentType(    (    (    s%   /tmp/pip-build-awuatQ/rsa/rsa/asn1.pyR      s   t   OpenSSLPubKeyc           B   s_   e  Z e j e j d  e É  É e j d e j É  j d e	 j
 d d d d d d É É É É Z RS(   t   headert   keyt   implicitTagt   tagClassi    t	   tagFormatt   tagIdi   (   R   R   R   R   R	   R   R    t   OctetStringt   subtypeR   t   TagR   (    (    (    s%   /tmp/pip-build-awuatQ/rsa/rsa/asn1.pyR      s   t	   AsnPubKeyc           B   sD   e  Z d  Z e j e j d e j É  É e j d e j É  É É Z RS(   sß   ASN.1 contents of DER encoded public key:
    
    RSAPublicKey ::= SEQUENCE {
         modulus           INTEGER,  -- n
         publicExponent    INTEGER,  -- e
    t   modulust   publicExponent(	   R   R   t   __doc__R   R   R	   R    t   IntegerR   (    (    (    s%   /tmp/pip-build-awuatQ/rsa/rsa/asn1.pyR   (   s   N(	   R   t   pyasn1.typeR    R   R   t   SequenceR   R   R   (    (    (    s%   /tmp/pip-build-awuatQ/rsa/rsa/asn1.pyt   <module>   s   
                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/lib/python2.7/dist-packages/rsa/bigfile.py                                                0100644 0000000 0000062 00000006035 13077704374 020775  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''Large file support

    - break a file into smaller blocks, and encrypt them, and store the
      encrypted blocks in another file.

    - take such an encrypted files, decrypt its blocks, and reconstruct the
      original file.

The encrypted file format is as follows, where || denotes byte concatenation:

    FILE := VERSION || BLOCK || BLOCK ...

    BLOCK := LENGTH || DATA

    LENGTH := varint-encoded length of the subsequent data. Varint comes from
    Google Protobuf, and encodes an integer into a variable number of bytes.
    Each byte uses the 7 lowest bits to encode the value. The highest bit set
    to 1 indicates the next byte is also part of the varint. The last byte will
    have this bit set to 0.

This file format is called the VARBLOCK format, in line with the varint format
used to denote the block sizes.

'''

from rsa import key, common, pkcs1, varblock
from rsa._compat import byte

def encrypt_bigfile(infile, outfile, pub_key):
    '''Encrypts a file, writing it to 'outfile' in VARBLOCK format.
    
    :param infile: file-like object to read the cleartext from
    :param outfile: file-like object to write the crypto in VARBLOCK format to
    :param pub_key: :py:class:`rsa.PublicKey` to encrypt with

    '''

    if not isinstance(pub_key, key.PublicKey):
        raise TypeError('Public key required, but got %r' % pub_key)

    key_bytes = common.bit_size(pub_key.n) // 8
    blocksize = key_bytes - 11 # keep space for PKCS#1 padding

    # Write the version number to the VARBLOCK file
    outfile.write(byte(varblock.VARBLOCK_VERSION))

    # Encrypt and write each block
    for block in varblock.yield_fixedblocks(infile, blocksize):
        crypto = pkcs1.encrypt(block, pub_key)

        varblock.write_varint(outfile, len(crypto))
        outfile.write(crypto)

def decrypt_bigfile(infile, outfile, priv_key):
    '''Decrypts an encrypted VARBLOCK file, writing it to 'outfile'
    
    :param infile: file-like object to read the crypto in VARBLOCK format from
    :param outfile: file-like object to write the cleartext to
    :param priv_key: :py:class:`rsa.PrivateKey` to decrypt with

    '''

    if not isinstance(priv_key, key.PrivateKey):
        raise TypeError('Private key required, but got %r' % priv_key)
    
    for block in varblock.yield_varblocks(infile):
        cleartext = pkcs1.decrypt(block, priv_key)
        outfile.write(cleartext)

__all__ = ['encrypt_bigfile', 'decrypt_bigfile']

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/lib/python2.7/dist-packages/rsa/bigfile.pyc                                               0100644 0000000 0000062 00000005353 13077704403 021133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   sZ   d  Z  d d l m Z m Z m Z m Z d d l m Z d Ñ  Z d Ñ  Z	 d d g Z
 d S(	   sD  Large file support

    - break a file into smaller blocks, and encrypt them, and store the
      encrypted blocks in another file.

    - take such an encrypted files, decrypt its blocks, and reconstruct the
      original file.

The encrypted file format is as follows, where || denotes byte concatenation:

    FILE := VERSION || BLOCK || BLOCK ...

    BLOCK := LENGTH || DATA

    LENGTH := varint-encoded length of the subsequent data. Varint comes from
    Google Protobuf, and encodes an integer into a variable number of bytes.
    Each byte uses the 7 lowest bits to encode the value. The highest bit set
    to 1 indicates the next byte is also part of the varint. The last byte will
    have this bit set to 0.

This file format is called the VARBLOCK format, in line with the varint format
used to denote the block sizes.

iˇˇˇˇ(   t   keyt   commont   pkcs1t   varblock(   t   bytec         C   s±   t  | t j É s% t d | É Ç n  t j | j É d } | d } | j t t	 j
 É É xO t	 j |  | É D]; } t j | | É } t	 j | t | É É | j | É qn Wd S(   s  Encrypts a file, writing it to 'outfile' in VARBLOCK format.
    
    :param infile: file-like object to read the cleartext from
    :param outfile: file-like object to write the crypto in VARBLOCK format to
    :param pub_key: :py:class:`rsa.PublicKey` to encrypt with

    s   Public key required, but got %ri   i   N(   t
   isinstanceR    t	   PublicKeyt	   TypeErrorR   t   bit_sizet   nt   writeR   R   t   VARBLOCK_VERSIONt   yield_fixedblocksR   t   encryptt   write_varintt   len(   t   infilet   outfilet   pub_keyt	   key_bytest	   blocksizet   blockt   crypto(    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/bigfile.pyt   encrypt_bigfile-   s    	
c         C   sb   t  | t j É s% t d | É Ç n  x6 t j |  É D]% } t j | | É } | j | É q5 Wd S(   s  Decrypts an encrypted VARBLOCK file, writing it to 'outfile'
    
    :param infile: file-like object to read the crypto in VARBLOCK format from
    :param outfile: file-like object to write the cleartext to
    :param priv_key: :py:class:`rsa.PrivateKey` to decrypt with

    s    Private key required, but got %rN(	   R   R    t
   PrivateKeyR   R   t   yield_varblocksR   t   decryptR
   (   R   R   t   priv_keyR   t	   cleartext(    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/bigfile.pyt   decrypt_bigfileF   s
    	R   R   N(   t   __doc__t   rsaR    R   R   R   t   rsa._compatR   R   R   t   __all__(    (    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/bigfile.pyt   <module>(   s
   "		                                                                                                                                                                                                                                                                                     usr/local/lib/python2.7/dist-packages/rsa/cli.py                                                    0100644 0000000 0000062 00000027360 13077704374 020147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''Commandline scripts.

These scripts are called by the executables defined in setup.py.
'''

from __future__ import with_statement, print_function

import abc
import sys
from optparse import OptionParser

import rsa
import rsa.bigfile
import rsa.pkcs1

HASH_METHODS = sorted(rsa.pkcs1.HASH_METHODS.keys())

def keygen():
    '''Key generator.'''

    # Parse the CLI options
    parser = OptionParser(usage='usage: %prog [options] keysize',
            description='Generates a new RSA keypair of "keysize" bits.')
    
    parser.add_option('--pubout', type='string',
            help='Output filename for the public key. The public key is '
            'not saved if this option is not present. You can use '
            'pyrsa-priv2pub to create the public key file later.')
    
    parser.add_option('-o', '--out', type='string',
            help='Output filename for the private key. The key is '
            'written to stdout if this option is not present.')

    parser.add_option('--form',
            help='key format of the private and public keys - default PEM',
            choices=('PEM', 'DER'), default='PEM')

    (cli, cli_args) = parser.parse_args(sys.argv[1:])

    if len(cli_args) != 1:
        parser.print_help()
        raise SystemExit(1)
    
    try:
        keysize = int(cli_args[0])
    except ValueError:
        parser.print_help()
        print('Not a valid number: %s' % cli_args[0], file=sys.stderr)
        raise SystemExit(1)

    print('Generating %i-bit key' % keysize, file=sys.stderr)
    (pub_key, priv_key) = rsa.newkeys(keysize)


    # Save public key
    if cli.pubout:
        print('Writing public key to %s' % cli.pubout, file=sys.stderr)
        data = pub_key.save_pkcs1(format=cli.form)
        with open(cli.pubout, 'wb') as outfile:
            outfile.write(data)

    # Save private key
    data = priv_key.save_pkcs1(format=cli.form)
    
    if cli.out:
        print('Writing private key to %s' % cli.out, file=sys.stderr)
        with open(cli.out, 'wb') as outfile:
            outfile.write(data)
    else:
        print('Writing private key to stdout', file=sys.stderr)
        sys.stdout.write(data)


class CryptoOperation(object):
    '''CLI callable that operates with input, output, and a key.'''

    __metaclass__ = abc.ABCMeta

    keyname = 'public' # or 'private'
    usage = 'usage: %%prog [options] %(keyname)s_key'
    description = None
    operation = 'decrypt'
    operation_past = 'decrypted'
    operation_progressive = 'decrypting'
    input_help = 'Name of the file to %(operation)s. Reads from stdin if ' \
            'not specified.'
    output_help = 'Name of the file to write the %(operation_past)s file ' \
            'to. Written to stdout if this option is not present.'
    expected_cli_args = 1
    has_output = True

    key_class = rsa.PublicKey

    def __init__(self):
        self.usage = self.usage % self.__class__.__dict__
        self.input_help = self.input_help % self.__class__.__dict__
        self.output_help = self.output_help % self.__class__.__dict__

    @abc.abstractmethod
    def perform_operation(self, indata, key, cli_args=None):
        '''Performs the program's operation.

        Implement in a subclass.

        :returns: the data to write to the output.
        '''

    def __call__(self):
        '''Runs the program.'''

        (cli, cli_args) = self.parse_cli()

        key = self.read_key(cli_args[0], cli.keyform)

        indata = self.read_infile(cli.input)

        print(self.operation_progressive.title(), file=sys.stderr)
        outdata = self.perform_operation(indata, key, cli_args)

        if self.has_output:
            self.write_outfile(outdata, cli.output)

    def parse_cli(self):
        '''Parse the CLI options
        
        :returns: (cli_opts, cli_args)
        '''

        parser = OptionParser(usage=self.usage, description=self.description)
        
        parser.add_option('-i', '--input', type='string', help=self.input_help)

        if self.has_output:
            parser.add_option('-o', '--output', type='string', help=self.output_help)

        parser.add_option('--keyform',
                help='Key format of the %s key - default PEM' % self.keyname,
                choices=('PEM', 'DER'), default='PEM')

        (cli, cli_args) = parser.parse_args(sys.argv[1:])

        if len(cli_args) != self.expected_cli_args:
            parser.print_help()
            raise SystemExit(1)

        return (cli, cli_args)

    def read_key(self, filename, keyform):
        '''Reads a public or private key.'''

        print('Reading %s key from %s' % (self.keyname, filename), file=sys.stderr)
        with open(filename, 'rb') as keyfile:
            keydata = keyfile.read()

        return self.key_class.load_pkcs1(keydata, keyform)
    
    def read_infile(self, inname):
        '''Read the input file'''

        if inname:
            print('Reading input from %s' % inname, file=sys.stderr)
            with open(inname, 'rb') as infile:
                return infile.read()

        print('Reading input from stdin', file=sys.stderr)
        return sys.stdin.read()

    def write_outfile(self, outdata, outname):
        '''Write the output file'''

        if outname:
            print('Writing output to %s' % outname, file=sys.stderr)
            with open(outname, 'wb') as outfile:
                outfile.write(outdata)
        else:
            print('Writing output to stdout', file=sys.stderr)
            sys.stdout.write(outdata)

class EncryptOperation(CryptoOperation):
    '''Encrypts a file.'''

    keyname = 'public'
    description = ('Encrypts a file. The file must be shorter than the key '
            'length in order to be encrypted. For larger files, use the '
            'pyrsa-encrypt-bigfile command.')
    operation = 'encrypt'
    operation_past = 'encrypted'
    operation_progressive = 'encrypting'


    def perform_operation(self, indata, pub_key, cli_args=None):
        '''Encrypts files.'''

        return rsa.encrypt(indata, pub_key)

class DecryptOperation(CryptoOperation):
    '''Decrypts a file.'''

    keyname = 'private'
    description = ('Decrypts a file. The original file must be shorter than '
            'the key length in order to have been encrypted. For larger '
            'files, use the pyrsa-decrypt-bigfile command.')
    operation = 'decrypt'
    operation_past = 'decrypted'
    operation_progressive = 'decrypting'
    key_class = rsa.PrivateKey

    def perform_operation(self, indata, priv_key, cli_args=None):
        '''Decrypts files.'''

        return rsa.decrypt(indata, priv_key)

class SignOperation(CryptoOperation):
    '''Signs a file.'''

    keyname = 'private'
    usage = 'usage: %%prog [options] private_key hash_method'
    description = ('Signs a file, outputs the signature. Choose the hash '
            'method from %s' % ', '.join(HASH_METHODS))
    operation = 'sign'
    operation_past = 'signature'
    operation_progressive = 'Signing'
    key_class = rsa.PrivateKey
    expected_cli_args = 2

    output_help = ('Name of the file to write the signature to. Written '
            'to stdout if this option is not present.')

    def perform_operation(self, indata, priv_key, cli_args):
        '''Decrypts files.'''

        hash_method = cli_args[1]
        if hash_method not in HASH_METHODS:
            raise SystemExit('Invalid hash method, choose one of %s' % 
                    ', '.join(HASH_METHODS))

        return rsa.sign(indata, priv_key, hash_method)

class VerifyOperation(CryptoOperation):
    '''Verify a signature.'''

    keyname = 'public'
    usage = 'usage: %%prog [options] public_key signature_file'
    description = ('Verifies a signature, exits with status 0 upon success, '
        'prints an error message and exits with status 1 upon error.')
    operation = 'verify'
    operation_past = 'verified'
    operation_progressive = 'Verifying'
    key_class = rsa.PublicKey
    expected_cli_args = 2
    has_output = False

    def perform_operation(self, indata, pub_key, cli_args):
        '''Decrypts files.'''

        signature_file = cli_args[1]
        
        with open(signature_file, 'rb') as sigfile:
            signature = sigfile.read()

        try:
            rsa.verify(indata, signature, pub_key)
        except rsa.VerificationError:
            raise SystemExit('Verification failed.')

        print('Verification OK', file=sys.stderr)


class BigfileOperation(CryptoOperation):
    '''CryptoOperation that doesn't read the entire file into memory.'''

    def __init__(self):
        CryptoOperation.__init__(self)

        self.file_objects = []

    def __del__(self):
        '''Closes any open file handles.'''

        for fobj in self.file_objects:
            fobj.close()

    def __call__(self):
        '''Runs the program.'''

        (cli, cli_args) = self.parse_cli()

        key = self.read_key(cli_args[0], cli.keyform)

        # Get the file handles
        infile = self.get_infile(cli.input)
        outfile = self.get_outfile(cli.output)

        # Call the operation
        print(self.operation_progressive.title(), file=sys.stderr)
        self.perform_operation(infile, outfile, key, cli_args)

    def get_infile(self, inname):
        '''Returns the input file object'''

        if inname:
            print('Reading input from %s' % inname, file=sys.stderr)
            fobj = open(inname, 'rb')
            self.file_objects.append(fobj)
        else:
            print('Reading input from stdin', file=sys.stderr)
            fobj = sys.stdin

        return fobj

    def get_outfile(self, outname):
        '''Returns the output file object'''

        if outname:
            print('Will write output to %s' % outname, file=sys.stderr)
            fobj = open(outname, 'wb')
            self.file_objects.append(fobj)
        else:
            print('Will write output to stdout', file=sys.stderr)
            fobj = sys.stdout

        return fobj

class EncryptBigfileOperation(BigfileOperation):
    '''Encrypts a file to VARBLOCK format.'''

    keyname = 'public'
    description = ('Encrypts a file to an encrypted VARBLOCK file. The file '
            'can be larger than the key length, but the output file is only '
            'compatible with Python-RSA.')
    operation = 'encrypt'
    operation_past = 'encrypted'
    operation_progressive = 'encrypting'

    def perform_operation(self, infile, outfile, pub_key, cli_args=None):
        '''Encrypts files to VARBLOCK.'''

        return rsa.bigfile.encrypt_bigfile(infile, outfile, pub_key)

class DecryptBigfileOperation(BigfileOperation):
    '''Decrypts a file in VARBLOCK format.'''

    keyname = 'private'
    description = ('Decrypts an encrypted VARBLOCK file that was encrypted '
            'with pyrsa-encrypt-bigfile')
    operation = 'decrypt'
    operation_past = 'decrypted'
    operation_progressive = 'decrypting'
    key_class = rsa.PrivateKey

    def perform_operation(self, infile, outfile, priv_key, cli_args=None):
        '''Decrypts a VARBLOCK file.'''

        return rsa.bigfile.decrypt_bigfile(infile, outfile, priv_key)


encrypt = EncryptOperation()
decrypt = DecryptOperation()
sign = SignOperation()
verify = VerifyOperation()
encrypt_bigfile = EncryptBigfileOperation()
decrypt_bigfile = DecryptBigfileOperation()

                                                                                                                                                                                                                                                                                usr/local/lib/python2.7/dist-packages/rsa/cli.pyc                                                   0100644 0000000 0000062 00000031121 13077704403 020271  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @Ä ss  d  Z  d d l m Z m Z d d l Z d d l Z d d l m Z d d l Z d d l	 Z d d l
 Z e e j j j É  É Z d Ñ  Z d e f d Ñ  É  YZ d e f d	 Ñ  É  YZ d
 e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ e É  Z e É  Z e É  Z e É  Z e É  Z e É  Z d S(   sW   Commandline scripts.

These scripts are called by the executables defined in setup.py.
iˇˇˇˇ(   t   with_statementt   print_functionN(   t   OptionParserc          CÄ s"  t  d d d d É }  |  j d d d d d	 É|  j d
 d d d d d É|  j d d d d d d d É|  j t j d É \ } } t | É d k r∞ |  j É  t d É Ç n  y t | d É } WnB t	 k
 r|  j É  t
 d | d d t j Ét d É Ç n Xt
 d | d t j Ét j | É \ } } | j ròt
 d | j d t j É| j d | j É } t | j d É è } | j | É Wd QXn  | j d | j É } | j r˚t
 d | j d t j Ét | j d É è } | j | É Wd QXn# t
 d d t j Ét j j | É d S(   s   Key generator.t   usages   usage: %prog [options] keysizet   descriptions.   Generates a new RSA keypair of "keysize" bits.s   --puboutt   typet   stringt   helpsû   Output filename for the public key. The public key is not saved if this option is not present. You can use pyrsa-priv2pub to create the public key file later.s   -os   --outs`   Output filename for the private key. The key is written to stdout if this option is not present.s   --forms7   key format of the private and public keys - default PEMt   choicest   PEMt   DERt   defaulti   i    s   Not a valid number: %st   files   Generating %i-bit keys   Writing public key to %st   formatt   wbNs   Writing private key to %ss   Writing private key to stdout(   R	   R
   (   R   t
   add_optiont
   parse_argst   syst   argvt   lent
   print_helpt
   SystemExitt   intt
   ValueErrort   printt   stderrt   rsat   newkeyst   puboutt
   save_pkcs1t   formt   opent   writet   outt   stdout(   t   parsert   clit   cli_argst   keysizet   pub_keyt   priv_keyt   datat   outfile(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyt   keygen"   sB    	

		t   CryptoOperationc           BÄ sß   e  Z d  Z e j Z d Z d Z d Z	 d Z
 d Z d Z d Z d Z d Z e Z e j Z d	 Ñ  Z e j d d
 Ñ É Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s9   CLI callable that operates with input, output, and a key.t   publics'   usage: %%prog [options] %(keyname)s_keyt   decryptt	   decryptedt
   decryptingsE   Name of the file to %(operation)s. Reads from stdin if not specified.sj   Name of the file to write the %(operation_past)s file to. Written to stdout if this option is not present.i   c         CÄ sF   |  j  |  j j |  _  |  j |  j j |  _ |  j |  j j |  _ d  S(   N(   R   t	   __class__t   __dict__t
   input_helpt   output_help(   t   self(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyt   __init__n   s    c         CÄ s   d S(   sÄ   Performs the program's operation.

        Implement in a subclass.

        :returns: the data to write to the output.
        N(    (   R5   t   indatat   keyR%   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyt   perform_operations   s    c         CÄ së   |  j  É  \ } } |  j | d | j É } |  j | j É } t |  j j É  d t j	 É|  j
 | | | É } |  j rç |  j | | j É n  d S(   s   Runs the program.i    R   N(   t	   parse_clit   read_keyt   keyformt   read_infilet   inputR   t   operation_progressivet   titleR   R   R9   t
   has_outputt   write_outfilet   output(   R5   R$   R%   R8   R7   t   outdata(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyt   __call__|   s    	c         CÄ sﬂ   t  d |  j d |  j É } | j d d d d d |  j É|  j re | j d d	 d d d |  j Én  | j d
 d d |  j d d d d É| j t	 j
 d É \ } } t | É |  j k r’ | j É  t d É Ç n  | | f S(   sN   Parse the CLI options
        
        :returns: (cli_opts, cli_args)
        R   R   s   -is   --inputR   R   R   s   -os   --outputs	   --keyforms&   Key format of the %s key - default PEMR   R	   R
   R   i   (   s   PEMs   DER(   R   R   R   R   R3   RA   R4   t   keynameR   R   R   R   t   expected_cli_argsR   R   (   R5   R#   R$   R%   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR:   ã   s    	"
c         CÄ sW   t  d |  j | f d t j Ét | d É è } | j É  } Wd QX|  j j | | É S(   s   Reads a public or private key.s   Reading %s key from %sR   t   rbN(   R   RF   R   R   R   t   readt	   key_classt
   load_pkcs1(   R5   t   filenameR<   t   keyfilet   keydata(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR;   §   s     c         CÄ sb   | rB t  d | d t j Ét | d É è } | j É  SWd QXn  t  d d t j Ét j j É  S(   s   Read the input files   Reading input from %sR   RH   Ns   Reading input from stdin(   R   R   R   R   RI   t   stdin(   R5   t   innamet   infile(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR=   ≠   s    c         CÄ sl   | rE t  d | d t j Ét | d É è } | j | É Wd QXn# t  d d t j Ét j j | É d S(   s   Write the output files   Writing output to %sR   R   Ns   Writing output to stdout(   R   R   R   R   R    R"   (   R5   RD   t   outnameR*   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyRB   ∏   s    N(   t   __name__t
   __module__t   __doc__t   abct   ABCMetat   __metaclass__RF   R   t   NoneR   t	   operationt   operation_pastR?   R3   R4   RG   t   TrueRA   R   t	   PublicKeyRJ   R6   t   abstractmethodR9   RE   R:   R;   R=   RB   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR,   Z   s*   								t   EncryptOperationc           BÄ s8   e  Z d  Z d Z d Z d Z d Z d Z d d Ñ Z	 RS(   s   Encrypts a file.R-   sê   Encrypts a file. The file must be shorter than the key length in order to be encrypted. For larger files, use the pyrsa-encrypt-bigfile command.t   encryptt	   encryptedt
   encryptingc         CÄ s   t  j | | É S(   s   Encrypts files.(   R   R`   (   R5   R7   R'   R%   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR9   œ   s    N(
   RS   RT   RU   RF   R   RZ   R[   R?   RY   R9   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR_   √   s   t   DecryptOperationc           BÄ sA   e  Z d  Z d Z d Z d Z d Z d Z e j	 Z
 d d Ñ Z RS(   s   Decrypts a file.t   privates†   Decrypts a file. The original file must be shorter than the key length in order to have been encrypted. For larger files, use the pyrsa-decrypt-bigfile command.R.   R/   R0   c         CÄ s   t  j | | É S(   s   Decrypts files.(   R   R.   (   R5   R7   R(   R%   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR9   ‡   s    N(   RS   RT   RU   RF   R   RZ   R[   R?   R   t
   PrivateKeyRJ   RY   R9   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyRc   ‘   s   	t   SignOperationc           BÄ s]   e  Z d  Z d Z d Z d d j e É Z d Z d Z	 d Z
 e j Z d Z d	 Z d
 Ñ  Z RS(   s   Signs a file.Rd   s/   usage: %%prog [options] private_key hash_methodsC   Signs a file, outputs the signature. Choose the hash method from %ss   , t   signt	   signaturet   Signingi   s\   Name of the file to write the signature to. Written to stdout if this option is not present.c         CÄ sE   | d } | t  k r2 t d d j t  É É Ç n  t j | | | É S(   s   Decrypts files.i   s%   Invalid hash method, choose one of %ss   , (   t   HASH_METHODSR   t   joinR   Rg   (   R5   R7   R(   R%   t   hash_method(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR9   ı   s
    
(   RS   RT   RU   RF   R   Rk   Rj   R   RZ   R[   R?   R   Re   RJ   RG   R4   R9   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyRf   Â   s   	t   VerifyOperationc           BÄ sP   e  Z d  Z d Z d Z d Z d Z d Z d Z e	 j
 Z d Z e Z d Ñ  Z RS(	   s   Verify a signature.R-   s1   usage: %%prog [options] public_key signature_filess   Verifies a signature, exits with status 0 upon success, prints an error message and exits with status 1 upon error.t   verifyt   verifiedt	   Verifyingi   c         CÄ s   | d } t  | d É è } | j É  } Wd QXy t j | | | É Wn  t j k
 rg t d É Ç n Xt d d t j Éd S(   s   Decrypts files.i   RH   Ns   Verification failed.s   Verification OKR   (	   R   RI   R   Rn   t   VerificationErrorR   R   R   R   (   R5   R7   R'   R%   t   signature_filet   sigfileRh   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR9     s    
(   RS   RT   RU   RF   R   R   RZ   R[   R?   R   R]   RJ   RG   t   FalseRA   R9   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyRm   ˇ   s   	t   BigfileOperationc           BÄ s;   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s>   CryptoOperation that doesn't read the entire file into memory.c         CÄ s   t  j |  É g  |  _ d  S(   N(   R,   R6   t   file_objects(   R5   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR6      s    c         CÄ s"   x |  j  D] } | j É  q
 Wd S(   s   Closes any open file handles.N(   Rv   t   close(   R5   t   fobj(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyt   __del__%  s    c         CÄ sÖ   |  j  É  \ } } |  j | d | j É } |  j | j É } |  j | j É } t |  j j	 É  d t
 j É|  j | | | | É d S(   s   Runs the program.i    R   N(   R:   R;   R<   t
   get_infileR>   t   get_outfileRC   R   R?   R@   R   R   R9   (   R5   R$   R%   R8   RQ   R*   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyRE   +  s    c         CÄ s_   | r? t  d | d t j Ét | d É } |  j j | É n t  d d t j Ét j } | S(   s   Returns the input file objects   Reading input from %sR   RH   s   Reading input from stdin(   R   R   R   R   Rv   t   appendRO   (   R5   RP   Rx   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyRz   :  s    	c         CÄ s_   | r? t  d | d t j Ét | d É } |  j j | É n t  d d t j Ét j } | S(   s   Returns the output file objects   Will write output to %sR   R   s   Will write output to stdout(   R   R   R   R   Rv   R|   R"   (   R5   RR   Rx   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR{   G  s    	(   RS   RT   RU   R6   Ry   RE   Rz   R{   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyRu     s   				t   EncryptBigfileOperationc           BÄ s8   e  Z d  Z d Z d Z d Z d Z d Z d d Ñ Z	 RS(   s#   Encrypts a file to VARBLOCK format.R-   sí   Encrypts a file to an encrypted VARBLOCK file. The file can be larger than the key length, but the output file is only compatible with Python-RSA.R`   Ra   Rb   c         CÄ s   t  j j | | | É S(   s   Encrypts files to VARBLOCK.(   R   t   bigfilet   encrypt_bigfile(   R5   RQ   R*   R'   R%   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR9   _  s    N(
   RS   RT   RU   RF   R   RZ   R[   R?   RY   R9   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR}   T  s   t   DecryptBigfileOperationc           BÄ sA   e  Z d  Z d Z d Z d Z d Z d Z e j	 Z
 d d Ñ Z RS(   s#   Decrypts a file in VARBLOCK format.Rd   sQ   Decrypts an encrypted VARBLOCK file that was encrypted with pyrsa-encrypt-bigfileR.   R/   R0   c         CÄ s   t  j j | | | É S(   s   Decrypts a VARBLOCK file.(   R   R~   t   decrypt_bigfile(   R5   RQ   R*   R(   R%   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyR9   o  s    N(   RS   RT   RU   RF   R   RZ   R[   R?   R   Re   RJ   RY   R9   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyRÄ   d  s   	(   RU   t
   __future__R    R   RV   R   t   optparseR   R   t   rsa.bigfilet	   rsa.pkcs1t   sortedt   pkcs1Rj   t   keysR+   t   objectR,   R_   Rc   Rf   Rm   Ru   R}   RÄ   R`   R.   Rg   Rn   R   RÅ   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/cli.pyt   <module>   s.   	8i7					                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/rsa/common.py                                                 0100644 0000000 0000062 00000011154 13077704374 020662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''Common functionality shared by several modules.'''


def bit_size(num):
    '''
    Number of bits needed to represent a integer excluding any prefix
    0 bits.

    As per definition from http://wiki.python.org/moin/BitManipulation and
    to match the behavior of the Python 3 API.

    Usage::
    
        >>> bit_size(1023)
        10
        >>> bit_size(1024)
        11
        >>> bit_size(1025)
        11

    :param num:
        Integer value. If num is 0, returns 0. Only the absolute value of the
        number is considered. Therefore, signed integers will be abs(num)
        before the number's bit length is determined.
    :returns:
        Returns the number of bits in the integer.
    '''
    if num == 0:
        return 0
    if num < 0:
        num = -num

    # Make sure this is an int and not a float.
    num & 1

    hex_num = "%x" % num
    return ((len(hex_num) - 1) * 4) + {
        '0':0, '1':1, '2':2, '3':2,
        '4':3, '5':3, '6':3, '7':3,
        '8':4, '9':4, 'a':4, 'b':4,
        'c':4, 'd':4, 'e':4, 'f':4,
     }[hex_num[0]]


def _bit_size(number):
    '''
    Returns the number of bits required to hold a specific long number.
    '''
    if number < 0:
        raise ValueError('Only nonnegative numbers possible: %s' % number)

    if number == 0:
        return 0
    
    # This works, even with very large numbers. When using math.log(number, 2),
    # you'll get rounding errors and it'll fail.
    bits = 0
    while number:
        bits += 1
        number >>= 1

    return bits


def byte_size(number):
    '''
    Returns the number of bytes required to hold a specific long number.
    
    The number of bytes is rounded up.

    Usage::

        >>> byte_size(1 << 1023)
        128
        >>> byte_size((1 << 1024) - 1)
        128
        >>> byte_size(1 << 1024)
        129

    :param number:
        An unsigned integer
    :returns:
        The number of bytes required to hold a specific long number.
    '''
    quanta, mod = divmod(bit_size(number), 8)
    if mod or number == 0:
        quanta += 1
    return quanta
    #return int(math.ceil(bit_size(number) / 8.0))


def extended_gcd(a, b):
    '''Returns a tuple (r, i, j) such that r = gcd(a, b) = ia + jb
    '''
    # r = gcd(a,b) i = multiplicitive inverse of a mod b
    #      or      j = multiplicitive inverse of b mod a
    # Neg return values for i or j are made positive mod b or a respectively
    # Iterateive Version is faster and uses much less stack space
    x = 0
    y = 1
    lx = 1
    ly = 0
    oa = a                             #Remember original a/b to remove 
    ob = b                             #negative values from return results
    while b != 0:
        q = a // b
        (a, b)  = (b, a % b)
        (x, lx) = ((lx - (q * x)),x)
        (y, ly) = ((ly - (q * y)),y)
    if (lx < 0): lx += ob              #If neg wrap modulo orignal b
    if (ly < 0): ly += oa              #If neg wrap modulo orignal a
    return (a, lx, ly)                 #Return only positive values


def inverse(x, n):
    '''Returns x^-1 (mod n)

    >>> inverse(7, 4)
    3
    >>> (inverse(143, 4) * 143) % 4
    1
    '''

    (divider, inv, _) = extended_gcd(x, n)

    if divider != 1:
        raise ValueError("x (%d) and n (%d) are not relatively prime" % (x, n))

    return inv


def crt(a_values, modulo_values):
    '''Chinese Remainder Theorem.

    Calculates x such that x = a[i] (mod m[i]) for each i.

    :param a_values: the a-values of the above equation
    :param modulo_values: the m-values of the above equation
    :returns: x such that x = a[i] (mod m[i]) for each i
    

    >>> crt([2, 3], [3, 5])
    8

    >>> crt([2, 3, 2], [3, 5, 7])
    23

    >>> crt([2, 3, 0], [7, 11, 15])
    135
    '''

    m = 1
    x = 0 

    for modulo in modulo_values:
        m *= modulo

    for (m_i, a_i) in zip(modulo_values, a_values):
        M_i = m // m_i
        inv = inverse(M_i, m_i)

        x = (x + a_i * M_i * inv) % m

    return x

if __name__ == '__main__':
    import doctest
    doctest.testmod()

                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/lib/python2.7/dist-packages/rsa/common.pyc                                                0100644 0000000 0000062 00000010106 13077704403 021012  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   se   d  Z  d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e d k ra d d	 l Z e j	 É  n  d	 S(
   s/   Common functionality shared by several modules.c         C   s∆   |  d k r d S|  d k  r& |  }  n  |  d @d |  } t  | É d d i d d 6d d 6d d 6d d	 6d
 d 6d
 d 6d
 d 6d
 d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6| d S(   sv  
    Number of bits needed to represent a integer excluding any prefix
    0 bits.

    As per definition from http://wiki.python.org/moin/BitManipulation and
    to match the behavior of the Python 3 API.

    Usage::
    
        >>> bit_size(1023)
        10
        >>> bit_size(1024)
        11
        >>> bit_size(1025)
        11

    :param num:
        Integer value. If num is 0, returns 0. Only the absolute value of the
        number is considered. Therefore, signed integers will be abs(num)
        before the number's bit length is determined.
    :returns:
        Returns the number of bits in the integer.
    i    i   s   %xi   t   0t   1i   t   2t   3i   t   4t   5t   6t   7t   8t   9t   at   bt   ct   dt   et   f(   t   len(   t   numt   hex_num(    (    s'   /tmp/pip-build-awuatQ/rsa/rsa/common.pyt   bit_size   s    

c         C   sZ   |  d k  r t  d |  É Ç n  |  d k r/ d Sd } x |  rU | d 7} |  d L}  q8 W| S(   sM   
    Returns the number of bits required to hold a specific long number.
    i    s%   Only nonnegative numbers possible: %si   (   t
   ValueError(   t   numbert   bits(    (    s'   /tmp/pip-build-awuatQ/rsa/rsa/common.pyt	   _bit_size=   s    	
c         C   s>   t  t |  É d É \ } } | s- |  d k r: | d 7} n  | S(   sò  
    Returns the number of bytes required to hold a specific long number.
    
    The number of bytes is rounded up.

    Usage::

        >>> byte_size(1 << 1023)
        128
        >>> byte_size((1 << 1024) - 1)
        128
        >>> byte_size(1 << 1024)
        129

    :param number:
        An unsigned integer
    :returns:
        The number of bytes required to hold a specific long number.
    i   i    i   (   t   divmodR   (   R   t   quantat   mod(    (    s'   /tmp/pip-build-awuatQ/rsa/rsa/common.pyt	   byte_sizeQ   s    c   	      C   sª   d } d } d } d } |  } | } xU | d k r{ |  | } | |  | }  } | | | | } } | | | | } } q' W| d k  rï | | 7} n  | d k  rÆ | | 7} n  |  | | f S(   s@   Returns a tuple (r, i, j) such that r = gcd(a, b) = ia + jb
    i    i   (    (	   R
   R   t   xt   yt   lxt   lyt   oat   obt   q(    (    s'   /tmp/pip-build-awuatQ/rsa/rsa/common.pyt   extended_gcdl   s     
  c         C   sA   t  |  | É \ } } } | d k r= t d |  | f É Ç n  | S(   s`   Returns x^-1 (mod n)

    >>> inverse(7, 4)
    3
    >>> (inverse(143, 4) * 143) % 4
    1
    i   s*   x (%d) and n (%d) are not relatively prime(   R#   R   (   R   t   nt   dividert   invt   _(    (    s'   /tmp/pip-build-awuatQ/rsa/rsa/common.pyt   inverseÉ   s    	c   	      C   sz   d } d } x | D] } | | 9} q WxL t  | |  É D]; \ } } | | } t | | É } | | | | | } q7 W| S(   sâ  Chinese Remainder Theorem.

    Calculates x such that x = a[i] (mod m[i]) for each i.

    :param a_values: the a-values of the above equation
    :param modulo_values: the m-values of the above equation
    :returns: x such that x = a[i] (mod m[i]) for each i
    

    >>> crt([2, 3], [3, 5])
    8

    >>> crt([2, 3, 2], [3, 5, 7])
    23

    >>> crt([2, 3, 0], [7, 11, 15])
    135
    i   i    (   t   zipR(   (	   t   a_valuest   modulo_valuest   mR   t   modulot   m_it   a_it   M_iR&   (    (    s'   /tmp/pip-build-awuatQ/rsa/rsa/common.pyt   crtî   s    
t   __main__iˇˇˇˇN(
   t   __doc__R   R   R   R#   R(   R1   t   __name__t   doctestt   testmod(    (    (    s'   /tmp/pip-build-awuatQ/rsa/rsa/common.pyt   <module>   s   	)					"                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/local/lib/python2.7/dist-packages/rsa/core.py                                                   0100644 0000000 0000062 00000003204 13077704374 020317  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''Core mathematical operations.

This is the actual core RSA implementation, which is only defined
mathematically on integers.
'''


from rsa._compat import is_integer

def assert_int(var, name):

    if is_integer(var):
        return

    raise TypeError('%s should be an integer, not %s' % (name, var.__class__))

def encrypt_int(message, ekey, n):
    '''Encrypts a message using encryption key 'ekey', working modulo n'''

    assert_int(message, 'message')
    assert_int(ekey, 'ekey')
    assert_int(n, 'n')

    if message < 0:
        raise ValueError('Only non-negative numbers are supported')
         
    if message > n:
        raise OverflowError("The message %i is too long for n=%i" % (message, n))

    return pow(message, ekey, n)

def decrypt_int(cyphertext, dkey, n):
    '''Decrypts a cypher text using the decryption key 'dkey', working
    modulo n'''

    assert_int(cyphertext, 'cyphertext')
    assert_int(dkey, 'dkey')
    assert_int(n, 'n')

    message = pow(cyphertext, dkey, n)
    return message

                                                                                                                                                                                                                                                                                                                                                                                            usr/local/lib/python2.7/dist-packages/rsa/core.pyc                                                  0100644 0000000 0000062 00000002657 13077704403 020466  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   s5   d  Z  d d l m Z d Ñ  Z d Ñ  Z d Ñ  Z d S(   s}   Core mathematical operations.

This is the actual core RSA implementation, which is only defined
mathematically on integers.
iˇˇˇˇ(   t
   is_integerc         C   s-   t  |  É r d  St d | |  j f É Ç d  S(   Ns   %s should be an integer, not %s(   R    t	   TypeErrort	   __class__(   t   vart   name(    (    s%   /tmp/pip-build-awuatQ/rsa/rsa/core.pyt
   assert_int   s    c         C   sw   t  |  d É t  | d É t  | d É |  d k  rB t d É Ç n  |  | k rg t d |  | f É Ç n  t |  | | É S(   s@   Encrypts a message using encryption key 'ekey', working modulo nt   messaget   ekeyt   ni    s'   Only non-negative numbers are supporteds#   The message %i is too long for n=%i(   R   t
   ValueErrort   OverflowErrort   pow(   R   R   R   (    (    s%   /tmp/pip-build-awuatQ/rsa/rsa/core.pyt   encrypt_int!   s    c         C   s=   t  |  d É t  | d É t  | d É t |  | | É } | S(   sL   Decrypts a cypher text using the decryption key 'dkey', working
    modulo nt
   cyphertextt   dkeyR   (   R   R   (   R   R   R   R   (    (    s%   /tmp/pip-build-awuatQ/rsa/rsa/core.pyt   decrypt_int0   s
    N(   t   __doc__t   rsa._compatR    R   R   R   (    (    (    s%   /tmp/pip-build-awuatQ/rsa/rsa/core.pyt   <module>   s   		                                                                                 usr/local/lib/python2.7/dist-packages/rsa/key.py                                                    0100644 0000000 0000062 00000043401 13077704374 020162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''RSA key generation code.

Create new keys with the newkeys() function. It will give you a PublicKey and a
PrivateKey object.

Loading and saving keys requires the pyasn1 module. This module is imported as
late as possible, such that other functionality will remain working in absence
of pyasn1.

'''

import logging
from rsa._compat import b, bytes_type

import rsa.prime
import rsa.pem
import rsa.common

log = logging.getLogger(__name__)



class AbstractKey(object):
    '''Abstract superclass for private and public keys.'''

    @classmethod
    def load_pkcs1(cls, keyfile, format='PEM'):
        r'''Loads a key in PKCS#1 DER or PEM format.

        :param keyfile: contents of a DER- or PEM-encoded file that contains
            the public key.
        :param format: the format of the file to load; 'PEM' or 'DER'

        :return: a PublicKey object

        '''

        methods = {
            'PEM': cls._load_pkcs1_pem,
            'DER': cls._load_pkcs1_der,
        }

        if format not in methods:
            formats = ', '.join(sorted(methods.keys()))
            raise ValueError('Unsupported format: %r, try one of %s' % (format,
                formats))

        method = methods[format]
        return method(keyfile)

    def save_pkcs1(self, format='PEM'):
        '''Saves the public key in PKCS#1 DER or PEM format.

        :param format: the format to save; 'PEM' or 'DER'
        :returns: the DER- or PEM-encoded public key.

        '''

        methods = {
            'PEM': self._save_pkcs1_pem,
            'DER': self._save_pkcs1_der,
        }

        if format not in methods:
            formats = ', '.join(sorted(methods.keys()))
            raise ValueError('Unsupported format: %r, try one of %s' % (format,
                formats))

        method = methods[format]
        return method()

class PublicKey(AbstractKey):
    '''Represents a public RSA key.

    This key is also known as the 'encryption key'. It contains the 'n' and 'e'
    values.

    Supports attributes as well as dictionary-like access. Attribute accesss is
    faster, though.

    >>> PublicKey(5, 3)
    PublicKey(5, 3)

    >>> key = PublicKey(5, 3)
    >>> key.n
    5
    >>> key['n']
    5
    >>> key.e
    3
    >>> key['e']
    3

    '''

    __slots__ = ('n', 'e')

    def __init__(self, n, e):
        self.n = n
        self.e = e

    def __getitem__(self, key):
        return getattr(self, key)

    def __repr__(self):
        return 'PublicKey(%i, %i)' % (self.n, self.e)

    def __eq__(self, other):
        if other is None:
            return False

        if not isinstance(other, PublicKey):
            return False

        return self.n == other.n and self.e == other.e

    def __ne__(self, other):
        return not (self == other)

    @classmethod
    def _load_pkcs1_der(cls, keyfile):
        r'''Loads a key in PKCS#1 DER format.

        @param keyfile: contents of a DER-encoded file that contains the public
            key.
        @return: a PublicKey object

        First let's construct a DER encoded key:

        >>> import base64
        >>> b64der = 'MAwCBQCNGmYtAgMBAAE='
        >>> der = base64.decodestring(b64der)

        This loads the file:

        >>> PublicKey._load_pkcs1_der(der)
        PublicKey(2367317549, 65537)

        '''

        from pyasn1.codec.der import decoder
        from rsa.asn1 import AsnPubKey
        
        (priv, _) = decoder.decode(keyfile, asn1Spec=AsnPubKey())
        return cls(n=int(priv['modulus']), e=int(priv['publicExponent']))

    def _save_pkcs1_der(self):
        '''Saves the public key in PKCS#1 DER format.

        @returns: the DER-encoded public key.
        '''

        from pyasn1.codec.der import encoder
        from rsa.asn1 import AsnPubKey

        # Create the ASN object
        asn_key = AsnPubKey()
        asn_key.setComponentByName('modulus', self.n)
        asn_key.setComponentByName('publicExponent', self.e)

        return encoder.encode(asn_key)

    @classmethod
    def _load_pkcs1_pem(cls, keyfile):
        '''Loads a PKCS#1 PEM-encoded public key file.

        The contents of the file before the "-----BEGIN RSA PUBLIC KEY-----" and
        after the "-----END RSA PUBLIC KEY-----" lines is ignored.

        @param keyfile: contents of a PEM-encoded file that contains the public
            key.
        @return: a PublicKey object
        '''

        der = rsa.pem.load_pem(keyfile, 'RSA PUBLIC KEY')
        return cls._load_pkcs1_der(der)

    def _save_pkcs1_pem(self):
        '''Saves a PKCS#1 PEM-encoded public key file.

        @return: contents of a PEM-encoded file that contains the public key.
        '''

        der = self._save_pkcs1_der()
        return rsa.pem.save_pem(der, 'RSA PUBLIC KEY')

    @classmethod
    def load_pkcs1_openssl_pem(cls, keyfile):
        '''Loads a PKCS#1.5 PEM-encoded public key file from OpenSSL.
        
        These files can be recognised in that they start with BEGIN PUBLIC KEY
        rather than BEGIN RSA PUBLIC KEY.
        
        The contents of the file before the "-----BEGIN PUBLIC KEY-----" and
        after the "-----END PUBLIC KEY-----" lines is ignored.

        @param keyfile: contents of a PEM-encoded file that contains the public
            key, from OpenSSL.
        @return: a PublicKey object
        '''

        der = rsa.pem.load_pem(keyfile, 'PUBLIC KEY')
        return cls.load_pkcs1_openssl_der(der)

    @classmethod
    def load_pkcs1_openssl_der(cls, keyfile):
        '''Loads a PKCS#1 DER-encoded public key file from OpenSSL.

        @param keyfile: contents of a DER-encoded file that contains the public
            key, from OpenSSL.
        @return: a PublicKey object
        '''
    
        from rsa.asn1 import OpenSSLPubKey
        from pyasn1.codec.der import decoder
        from pyasn1.type import univ
        
        (keyinfo, _) = decoder.decode(keyfile, asn1Spec=OpenSSLPubKey())
        
        if keyinfo['header']['oid'] != univ.ObjectIdentifier('1.2.840.113549.1.1.1'):
            raise TypeError("This is not a DER-encoded OpenSSL-compatible public key")
                
        return cls._load_pkcs1_der(keyinfo['key'][1:])
        
        


class PrivateKey(AbstractKey):
    '''Represents a private RSA key.

    This key is also known as the 'decryption key'. It contains the 'n', 'e',
    'd', 'p', 'q' and other values.

    Supports attributes as well as dictionary-like access. Attribute accesss is
    faster, though.

    >>> PrivateKey(3247, 65537, 833, 191, 17)
    PrivateKey(3247, 65537, 833, 191, 17)

    exp1, exp2 and coef don't have to be given, they will be calculated:

    >>> pk = PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)
    >>> pk.exp1
    55063
    >>> pk.exp2
    10095
    >>> pk.coef
    50797

    If you give exp1, exp2 or coef, they will be used as-is:

    >>> pk = PrivateKey(1, 2, 3, 4, 5, 6, 7, 8)
    >>> pk.exp1
    6
    >>> pk.exp2
    7
    >>> pk.coef
    8

    '''

    __slots__ = ('n', 'e', 'd', 'p', 'q', 'exp1', 'exp2', 'coef')

    def __init__(self, n, e, d, p, q, exp1=None, exp2=None, coef=None):
        self.n = n
        self.e = e
        self.d = d
        self.p = p
        self.q = q

        # Calculate the other values if they aren't supplied
        if exp1 is None:
            self.exp1 = int(d % (p - 1))
        else:
            self.exp1 = exp1

        if exp1 is None:
            self.exp2 = int(d % (q - 1))
        else:
            self.exp2 = exp2

        if coef is None:
            self.coef = rsa.common.inverse(q, p)
        else:
            self.coef = coef

    def __getitem__(self, key):
        return getattr(self, key)

    def __repr__(self):
        return 'PrivateKey(%(n)i, %(e)i, %(d)i, %(p)i, %(q)i)' % self

    def __eq__(self, other):
        if other is None:
            return False

        if not isinstance(other, PrivateKey):
            return False

        return (self.n == other.n and
            self.e == other.e and
            self.d == other.d and
            self.p == other.p and
            self.q == other.q and
            self.exp1 == other.exp1 and
            self.exp2 == other.exp2 and
            self.coef == other.coef)

    def __ne__(self, other):
        return not (self == other)

    @classmethod
    def _load_pkcs1_der(cls, keyfile):
        r'''Loads a key in PKCS#1 DER format.

        @param keyfile: contents of a DER-encoded file that contains the private
            key.
        @return: a PrivateKey object

        First let's construct a DER encoded key:

        >>> import base64
        >>> b64der = 'MC4CAQACBQDeKYlRAgMBAAECBQDHn4npAgMA/icCAwDfxwIDANcXAgInbwIDAMZt'
        >>> der = base64.decodestring(b64der)

        This loads the file:

        >>> PrivateKey._load_pkcs1_der(der)
        PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)

        '''

        from pyasn1.codec.der import decoder
        (priv, _) = decoder.decode(keyfile)

        # ASN.1 contents of DER encoded private key:
        #
        # RSAPrivateKey ::= SEQUENCE {
        #     version           Version, 
        #     modulus           INTEGER,  -- n
        #     publicExponent    INTEGER,  -- e
        #     privateExponent   INTEGER,  -- d
        #     prime1            INTEGER,  -- p
        #     prime2            INTEGER,  -- q
        #     exponent1         INTEGER,  -- d mod (p-1)
        #     exponent2         INTEGER,  -- d mod (q-1) 
        #     coefficient       INTEGER,  -- (inverse of q) mod p
        #     otherPrimeInfos   OtherPrimeInfos OPTIONAL 
        # }

        if priv[0] != 0:
            raise ValueError('Unable to read this file, version %s != 0' % priv[0])

        as_ints = tuple(int(x) for x in priv[1:9])
        return cls(*as_ints)

    def _save_pkcs1_der(self):
        '''Saves the private key in PKCS#1 DER format.

        @returns: the DER-encoded private key.
        '''

        from pyasn1.type import univ, namedtype
        from pyasn1.codec.der import encoder

        class AsnPrivKey(univ.Sequence):
            componentType = namedtype.NamedTypes(
                namedtype.NamedType('version', univ.Integer()),
                namedtype.NamedType('modulus', univ.Integer()),
                namedtype.NamedType('publicExponent', univ.Integer()),
                namedtype.NamedType('privateExponent', univ.Integer()),
                namedtype.NamedType('prime1', univ.Integer()),
                namedtype.NamedType('prime2', univ.Integer()),
                namedtype.NamedType('exponent1', univ.Integer()),
                namedtype.NamedType('exponent2', univ.Integer()),
                namedtype.NamedType('coefficient', univ.Integer()),
            )

        # Create the ASN object
        asn_key = AsnPrivKey()
        asn_key.setComponentByName('version', 0)
        asn_key.setComponentByName('modulus', self.n)
        asn_key.setComponentByName('publicExponent', self.e)
        asn_key.setComponentByName('privateExponent', self.d)
        asn_key.setComponentByName('prime1', self.p)
        asn_key.setComponentByName('prime2', self.q)
        asn_key.setComponentByName('exponent1', self.exp1)
        asn_key.setComponentByName('exponent2', self.exp2)
        asn_key.setComponentByName('coefficient', self.coef)

        return encoder.encode(asn_key)

    @classmethod
    def _load_pkcs1_pem(cls, keyfile):
        '''Loads a PKCS#1 PEM-encoded private key file.

        The contents of the file before the "-----BEGIN RSA PRIVATE KEY-----" and
        after the "-----END RSA PRIVATE KEY-----" lines is ignored.

        @param keyfile: contents of a PEM-encoded file that contains the private
            key.
        @return: a PrivateKey object
        '''

        der = rsa.pem.load_pem(keyfile, b('RSA PRIVATE KEY'))
        return cls._load_pkcs1_der(der)

    def _save_pkcs1_pem(self):
        '''Saves a PKCS#1 PEM-encoded private key file.

        @return: contents of a PEM-encoded file that contains the private key.
        '''

        der = self._save_pkcs1_der()
        return rsa.pem.save_pem(der, b('RSA PRIVATE KEY'))

def find_p_q(nbits, getprime_func=rsa.prime.getprime, accurate=True):
    ''''Returns a tuple of two different primes of nbits bits each.
    
    The resulting p * q has exacty 2 * nbits bits, and the returned p and q
    will not be equal.

    :param nbits: the number of bits in each of p and q.
    :param getprime_func: the getprime function, defaults to
        :py:func:`rsa.prime.getprime`.

        *Introduced in Python-RSA 3.1*

    :param accurate: whether to enable accurate mode or not.
    :returns: (p, q), where p > q

    >>> (p, q) = find_p_q(128)
    >>> from rsa import common
    >>> common.bit_size(p * q)
    256

    When not in accurate mode, the number of bits can be slightly less

    >>> (p, q) = find_p_q(128, accurate=False)
    >>> from rsa import common
    >>> common.bit_size(p * q) <= 256
    True
    >>> common.bit_size(p * q) > 240
    True
    
    '''
    
    total_bits = nbits * 2

    # Make sure that p and q aren't too close or the factoring programs can
    # factor n.
    shift = nbits // 16
    pbits = nbits + shift
    qbits = nbits - shift
    
    # Choose the two initial primes
    log.debug('find_p_q(%i): Finding p', nbits)
    p = getprime_func(pbits)
    log.debug('find_p_q(%i): Finding q', nbits)
    q = getprime_func(qbits)

    def is_acceptable(p, q):
        '''Returns True iff p and q are acceptable:
            
            - p and q differ
            - (p * q) has the right nr of bits (when accurate=True)
        '''

        if p == q:
            return False

        if not accurate:
            return True

        # Make sure we have just the right amount of bits
        found_size = rsa.common.bit_size(p * q)
        return total_bits == found_size

    # Keep choosing other primes until they match our requirements.
    change_p = False
    while not is_acceptable(p, q):
        # Change p on one iteration and q on the other
        if change_p:
            p = getprime_func(pbits)
        else:
            q = getprime_func(qbits)

        change_p = not change_p

    # We want p > q as described on
    # http://www.di-mgt.com.au/rsa_alg.html#crt
    return (max(p, q), min(p, q))

def calculate_keys(p, q, nbits):
    '''Calculates an encryption and a decryption key given p and q, and
    returns them as a tuple (e, d)

    '''

    phi_n = (p - 1) * (q - 1)

    # A very common choice for e is 65537
    e = 65537

    try:
        d = rsa.common.inverse(e, phi_n)
    except ValueError:
        raise ValueError("e (%d) and phi_n (%d) are not relatively prime" %
                (e, phi_n))

    if (e * d) % phi_n != 1:
        raise ValueError("e (%d) and d (%d) are not mult. inv. modulo "
                "phi_n (%d)" % (e, d, phi_n))

    return (e, d)

def gen_keys(nbits, getprime_func, accurate=True):
    '''Generate RSA keys of nbits bits. Returns (p, q, e, d).

    Note: this can take a long time, depending on the key size.
    
    :param nbits: the total number of bits in ``p`` and ``q``. Both ``p`` and
        ``q`` will use ``nbits/2`` bits.
    :param getprime_func: either :py:func:`rsa.prime.getprime` or a function
        with similar signature.
    '''

    (p, q) = find_p_q(nbits // 2, getprime_func, accurate)
    (e, d) = calculate_keys(p, q, nbits // 2)

    return (p, q, e, d)

def newkeys(nbits, accurate=True, poolsize=1):
    '''Generates public and private keys, and returns them as (pub, priv).

    The public key is also known as the 'encryption key', and is a
    :py:class:`rsa.PublicKey` object. The private key is also known as the
    'decryption key' and is a :py:class:`rsa.PrivateKey` object.

    :param nbits: the number of bits required to store ``n = p*q``.
    :param accurate: when True, ``n`` will have exactly the number of bits you
        asked for. However, this makes key generation much slower. When False,
        `n`` may have slightly less bits.
    :param poolsize: the number of processes to use to generate the prime
        numbers. If set to a number > 1, a parallel algorithm will be used.
        This requires Python 2.6 or newer.

    :returns: a tuple (:py:class:`rsa.PublicKey`, :py:class:`rsa.PrivateKey`)

    The ``poolsize`` parameter was added in *Python-RSA 3.1* and requires
    Python 2.6 or newer.
    
    '''

    if nbits < 16:
        raise ValueError('Key too small')

    if poolsize < 1:
        raise ValueError('Pool size (%i) should be >= 1' % poolsize)

    # Determine which getprime function to use
    if poolsize > 1:
        from rsa import parallel
        import functools

        getprime_func = functools.partial(parallel.getprime, poolsize=poolsize)
    else: getprime_func = rsa.prime.getprime

    # Generate the key components
    (p, q, e, d) = gen_keys(nbits, getprime_func)
    
    # Create the key objects
    n = p * q

    return (
        PublicKey(n, e),
        PrivateKey(n, e, d, p, q)
    )

__all__ = ['PublicKey', 'PrivateKey', 'newkeys']

if __name__ == '__main__':
    import doctest
    
    try:
        for count in range(100):
            (failures, tests) = doctest.testmod()
            if failures:
                break

            if (count and count % 10 == 0) or count == 1:
                print('%i times' % count)
    except KeyboardInterrupt:
        print('Aborted')
    else:
        print('Doctests done')
                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/rsa/key.pyc                                                   0100644 0000000 0000062 00000043622 13077704403 020323  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   sá  d  Z  d d l Z d d l m Z m Z d d l Z d d l Z d d l Z e j	 e
 É Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d	 Ñ  É  YZ e j j e d
 Ñ Z d Ñ  Z e d Ñ Z e d d Ñ Z d d d g Z e
 d k rÉd d l Z ye x^ e d É D]P Z e j É  \ Z Z e r/Pn  e rEe d d k sQe d k rd e GHqqWWn e k
 rzd GHqÉXd GHn  d S(   s(  RSA key generation code.

Create new keys with the newkeys() function. It will give you a PublicKey and a
PrivateKey object.

Loading and saving keys requires the pyasn1 module. This module is imported as
late as possible, such that other functionality will remain working in absence
of pyasn1.

iˇˇˇˇN(   t   bt
   bytes_typet   AbstractKeyc           B   s,   e  Z d  Z e d d Ñ É Z d d Ñ Z RS(   s0   Abstract superclass for private and public keys.t   PEMc         C   sn   i |  j  d 6|  j d 6} | | k rZ d j t | j É  É É } t d | | f É Ç n  | | } | | É S(   s  Loads a key in PKCS#1 DER or PEM format.

        :param keyfile: contents of a DER- or PEM-encoded file that contains
            the public key.
        :param format: the format of the file to load; 'PEM' or 'DER'

        :return: a PublicKey object

        R   t   DERs   , s%   Unsupported format: %r, try one of %s(   t   _load_pkcs1_pemt   _load_pkcs1_dert   joint   sortedt   keyst
   ValueError(   t   clst   keyfilet   formatt   methodst   formatst   method(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt
   load_pkcs1*   s    
	
c         C   sk   i |  j  d 6|  j d 6} | | k rZ d j t | j É  É É } t d | | f É Ç n  | | } | É  S(   s¨   Saves the public key in PKCS#1 DER or PEM format.

        :param format: the format to save; 'PEM' or 'DER'
        :returns: the DER- or PEM-encoded public key.

        R   R   s   , s%   Unsupported format: %r, try one of %s(   t   _save_pkcs1_pemt   _save_pkcs1_derR   R   R	   R
   (   t   selfR   R   R   R   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt
   save_pkcs1C   s    
	
(   t   __name__t
   __module__t   __doc__t   classmethodR   R   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR   '   s   t	   PublicKeyc           B   sè   e  Z d  Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z e	 d Ñ  É Z
 d	 Ñ  Z e	 d
 Ñ  É Z d Ñ  Z e	 d Ñ  É Z e	 d Ñ  É Z RS(   sÜ  Represents a public RSA key.

    This key is also known as the 'encryption key'. It contains the 'n' and 'e'
    values.

    Supports attributes as well as dictionary-like access. Attribute accesss is
    faster, though.

    >>> PublicKey(5, 3)
    PublicKey(5, 3)

    >>> key = PublicKey(5, 3)
    >>> key.n
    5
    >>> key['n']
    5
    >>> key.e
    3
    >>> key['e']
    3

    t   nt   ec         C   s   | |  _  | |  _ d  S(   N(   R   R   (   R   R   R   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   __init__r   s    	c         C   s   t  |  | É S(   N(   t   getattr(   R   t   key(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   __getitem__v   s    c         C   s   d |  j  |  j f S(   Ns   PublicKey(%i, %i)(   R   R   (   R   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   __repr__y   s    c         C   sE   | d  k r t St | t É s# t S|  j | j k oD |  j | j k S(   N(   t   Nonet   Falset
   isinstanceR   R   R   (   R   t   other(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   __eq__|   s
    c         C   s   |  | k S(   N(    (   R   R%   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   __ne__Ö   s    c         C   se   d d l  m } d d l m } | j | d | É  É\ } } |  d t | d É d t | d É É S(	   s«  Loads a key in PKCS#1 DER format.

        @param keyfile: contents of a DER-encoded file that contains the public
            key.
        @return: a PublicKey object

        First let's construct a DER encoded key:

        >>> import base64
        >>> b64der = 'MAwCBQCNGmYtAgMBAAE='
        >>> der = base64.decodestring(b64der)

        This loads the file:

        >>> PublicKey._load_pkcs1_der(der)
        PublicKey(2367317549, 65537)

        iˇˇˇˇ(   t   decoder(   t	   AsnPubKeyt   asn1SpecR   t   modulusR   t   publicExponent(   t   pyasn1.codec.derR(   t   rsa.asn1R)   t   decodet   int(   R   R   R(   R)   t   privt   _(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR   à   s    c         C   s\   d d l  m } d d l m } | É  } | j d |  j É | j d |  j É | j | É S(   sb   Saves the public key in PKCS#1 DER format.

        @returns: the DER-encoded public key.
        iˇˇˇˇ(   t   encoder(   R)   R+   R,   (   R-   R3   R.   R)   t   setComponentByNameR   R   t   encode(   R   R3   R)   t   asn_key(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR   £   s    	c         C   s"   t  j j | d É } |  j | É S(   sO  Loads a PKCS#1 PEM-encoded public key file.

        The contents of the file before the "-----BEGIN RSA PUBLIC KEY-----" and
        after the "-----END RSA PUBLIC KEY-----" lines is ignored.

        @param keyfile: contents of a PEM-encoded file that contains the public
            key.
        @return: a PublicKey object
        s   RSA PUBLIC KEY(   t   rsat   pemt   load_pemR   (   R   R   t   der(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR   ≥   s    c         C   s   |  j  É  } t j j | d É S(   sÉ   Saves a PKCS#1 PEM-encoded public key file.

        @return: contents of a PEM-encoded file that contains the public key.
        s   RSA PUBLIC KEY(   R   R7   R8   t   save_pem(   R   R:   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR   ¬   s    c         C   s"   t  j j | d É } |  j | É S(   sÓ  Loads a PKCS#1.5 PEM-encoded public key file from OpenSSL.
        
        These files can be recognised in that they start with BEGIN PUBLIC KEY
        rather than BEGIN RSA PUBLIC KEY.
        
        The contents of the file before the "-----BEGIN PUBLIC KEY-----" and
        after the "-----END PUBLIC KEY-----" lines is ignored.

        @param keyfile: contents of a PEM-encoded file that contains the public
            key, from OpenSSL.
        @return: a PublicKey object
        s
   PUBLIC KEY(   R7   R8   R9   t   load_pkcs1_openssl_der(   R   R   R:   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   load_pkcs1_openssl_pemÀ   s    c         C   sè   d d l  m } d d l m } d d l m } | j | d | É  É\ } } | d d | j d É k rz t d	 É Ç n  |  j	 | d
 d É S(   s’   Loads a PKCS#1 DER-encoded public key file from OpenSSL.

        @param keyfile: contents of a DER-encoded file that contains the public
            key, from OpenSSL.
        @return: a PublicKey object
        iˇˇˇˇ(   t   OpenSSLPubKey(   R(   (   t   univR*   t   headert   oids   1.2.840.113549.1.1.1s7   This is not a DER-encoded OpenSSL-compatible public keyR   i   (
   R.   R>   R-   R(   t   pyasn1.typeR?   R/   t   ObjectIdentifiert	   TypeErrorR   (   R   R   R>   R(   R?   t   keyinfoR2   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR<   ›   s    	(   R   R   (   R   R   R   t	   __slots__R   R    R!   R&   R'   R   R   R   R   R   R=   R<   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR   X   s   									t
   PrivateKeyc           B   sz   e  Z d  Z d Z d d d d	 Ñ Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 e
 d Ñ  É Z d Ñ  Z e
 d Ñ  É Z d Ñ  Z RS(   s„  Represents a private RSA key.

    This key is also known as the 'decryption key'. It contains the 'n', 'e',
    'd', 'p', 'q' and other values.

    Supports attributes as well as dictionary-like access. Attribute accesss is
    faster, though.

    >>> PrivateKey(3247, 65537, 833, 191, 17)
    PrivateKey(3247, 65537, 833, 191, 17)

    exp1, exp2 and coef don't have to be given, they will be calculated:

    >>> pk = PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)
    >>> pk.exp1
    55063
    >>> pk.exp2
    10095
    >>> pk.coef
    50797

    If you give exp1, exp2 or coef, they will be used as-is:

    >>> pk = PrivateKey(1, 2, 3, 4, 5, 6, 7, 8)
    >>> pk.exp1
    6
    >>> pk.exp2
    7
    >>> pk.coef
    8

    R   R   t   dt   pt   qt   exp1t   exp2t   coefc	   	      C   sø   | |  _  | |  _ | |  _ | |  _ | |  _ | d  k rS t | | d É |  _ n	 | |  _ | d  k rÇ t | | d É |  _ n	 | |  _ | d  k r≤ t	 j
 j | | É |  _ n	 | |  _ d  S(   Ni   (   R   R   RH   RI   RJ   R"   R0   RK   RL   R7   t   commont   inverseRM   (	   R   R   R   RH   RI   RJ   RK   RL   RM   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR     s    							c         C   s   t  |  | É S(   N(   R   (   R   R   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR    /  s    c         C   s   d |  S(   Ns-   PrivateKey(%(n)i, %(e)i, %(d)i, %(p)i, %(q)i)(    (   R   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR!   2  s    c         C   s±   | d  k r t St | t É s# t S|  j | j k o∞ |  j | j k o∞ |  j | j k o∞ |  j | j k o∞ |  j | j k o∞ |  j	 | j	 k o∞ |  j
 | j
 k o∞ |  j | j k S(   N(   R"   R#   R$   RG   R   R   RH   RI   RJ   RK   RL   RM   (   R   R%   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR&   5  s    c         C   s   |  | k S(   N(    (   R   R%   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR'   E  s    c         C   ss   d d l  m } | j | É \ } } | d d k rL t d | d É Ç n  t d Ñ  | d d !DÉ É } |  | å  S(   s  Loads a key in PKCS#1 DER format.

        @param keyfile: contents of a DER-encoded file that contains the private
            key.
        @return: a PrivateKey object

        First let's construct a DER encoded key:

        >>> import base64
        >>> b64der = 'MC4CAQACBQDeKYlRAgMBAAECBQDHn4npAgMA/icCAwDfxwIDANcXAgInbwIDAMZt'
        >>> der = base64.decodestring(b64der)

        This loads the file:

        >>> PrivateKey._load_pkcs1_der(der)
        PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)

        iˇˇˇˇ(   R(   i    s)   Unable to read this file, version %s != 0c         s   s   |  ] } t  | É Vq d  S(   N(   R0   (   t   .0t   x(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pys	   <genexpr>r  s    i   i	   (   R-   R(   R/   R
   t   tuple(   R   R   R(   R1   R2   t   as_ints(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR   H  s    c            s  d d l  m â m â  d d l m } d à j f á  á f d Ü  É  Y} | É  } | j d d É | j d |  j É | j d	 |  j É | j d
 |  j	 É | j d |  j
 É | j d |  j É | j d |  j É | j d |  j É | j d |  j É | j | É S(   sd   Saves the private key in PKCS#1 DER format.

        @returns: the DER-encoded private key.
        iˇˇˇˇ(   R?   t	   namedtype(   R3   t
   AsnPrivKeyc              s—   e  Z à  j à  j d  à j É  É à  j d à j É  É à  j d à j É  É à  j d à j É  É à  j d à j É  É à  j d à j É  É à  j d à j É  É à  j d à j É  É à  j d à j É  É É	 Z RS(	   t   versionR+   R,   t   privateExponentt   prime1t   prime2t	   exponent1t	   exponent2t   coefficient(   R   R   t
   NamedTypest	   NamedTypet   Integert   componentType(    (   RT   R?   (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyRU   ~  s   RV   i    R+   R,   RW   RX   RY   RZ   R[   R\   (   RB   R?   RT   R-   R3   t   SequenceR4   R   R   RH   RI   RJ   RK   RL   RM   R5   (   R   R3   RU   R6   (    (   RT   R?   s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR   u  s    "	c         C   s(   t  j j | t d É É } |  j | É S(   sT  Loads a PKCS#1 PEM-encoded private key file.

        The contents of the file before the "-----BEGIN RSA PRIVATE KEY-----" and
        after the "-----END RSA PRIVATE KEY-----" lines is ignored.

        @param keyfile: contents of a PEM-encoded file that contains the private
            key.
        @return: a PrivateKey object
        s   RSA PRIVATE KEY(   R7   R8   R9   R    R   (   R   R   R:   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR   ô  s    c         C   s%   |  j  É  } t j j | t d É É S(   sÖ   Saves a PKCS#1 PEM-encoded private key file.

        @return: contents of a PEM-encoded file that contains the private key.
        s   RSA PRIVATE KEY(   R   R7   R8   R;   R    (   R   R:   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyR   ®  s    (   R   R   RH   RI   RJ   s   exp1s   exp2s   coefN(   R   R   R   RF   R"   R   R    R!   R&   R'   R   R   R   R   R   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyRG   Ù   s    				-	$c   
         s“   |  d â |  d } |  | } |  | } t  j d |  É | | É } t  j d |  É | | É } á  á f d Ü  } t }	 x; | | | É sµ |	 rü | | É } n | | É } |	 }	 q{ Wt | | É t | | É f S(   s.  'Returns a tuple of two different primes of nbits bits each.
    
    The resulting p * q has exacty 2 * nbits bits, and the returned p and q
    will not be equal.

    :param nbits: the number of bits in each of p and q.
    :param getprime_func: the getprime function, defaults to
        :py:func:`rsa.prime.getprime`.

        *Introduced in Python-RSA 3.1*

    :param accurate: whether to enable accurate mode or not.
    :returns: (p, q), where p > q

    >>> (p, q) = find_p_q(128)
    >>> from rsa import common
    >>> common.bit_size(p * q)
    256

    When not in accurate mode, the number of bits can be slightly less

    >>> (p, q) = find_p_q(128, accurate=False)
    >>> from rsa import common
    >>> common.bit_size(p * q) <= 256
    True
    >>> common.bit_size(p * q) > 240
    True
    
    i   i   s   find_p_q(%i): Finding ps   find_p_q(%i): Finding qc            s:   |  | k r t  Sà  s t St j j |  | É } à | k S(   sü   Returns True iff p and q are acceptable:
            
            - p and q differ
            - (p * q) has the right nr of bits (when accurate=True)
        (   R#   t   TrueR7   RN   t   bit_size(   RI   RJ   t
   found_size(   t   accuratet
   total_bits(    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   is_acceptableﬁ  s    (   t   logt   debugR#   t   maxt   min(
   t   nbitst   getprime_funcRe   t   shiftt   pbitst   qbitsRI   RJ   Rg   t   change_p(    (   Re   Rf   s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   find_p_q±  s     



c         C   sï   |  d | d } d } y t  j j | | É } Wn' t k
 rZ t d | | f É Ç n X| | | d k rã t d | | | f É Ç n  | | f S(   si   Calculates an encryption and a decryption key given p and q, and
    returns them as a tuple (e, d)

    i   i  s.   e (%d) and phi_n (%d) are not relatively primes6   e (%d) and d (%d) are not mult. inv. modulo phi_n (%d)(   R7   RN   RO   R
   (   RI   RJ   Rl   t   phi_nR   RH   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   calculate_keys˛  s    c         C   sH   t  |  d | | É \ } } t | | |  d É \ } } | | | | f S(   se  Generate RSA keys of nbits bits. Returns (p, q, e, d).

    Note: this can take a long time, depending on the key size.
    
    :param nbits: the total number of bits in ``p`` and ``q``. Both ``p`` and
        ``q`` will use ``nbits/2`` bits.
    :param getprime_func: either :py:func:`rsa.prime.getprime` or a function
        with similar signature.
    i   (   Rr   Rt   (   Rl   Rm   Re   RI   RJ   R   RH   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   gen_keys  s    i   c         C   s”   |  d k  r t  d É Ç n  | d k  r: t  d | É Ç n  | d k r} d d l m } d d l } | j | j d | É} n t j j } t |  | É \ } } } }	 | | }
 t |
 | É t	 |
 | |	 | | É f S(	   sû  Generates public and private keys, and returns them as (pub, priv).

    The public key is also known as the 'encryption key', and is a
    :py:class:`rsa.PublicKey` object. The private key is also known as the
    'decryption key' and is a :py:class:`rsa.PrivateKey` object.

    :param nbits: the number of bits required to store ``n = p*q``.
    :param accurate: when True, ``n`` will have exactly the number of bits you
        asked for. However, this makes key generation much slower. When False,
        `n`` may have slightly less bits.
    :param poolsize: the number of processes to use to generate the prime
        numbers. If set to a number > 1, a parallel algorithm will be used.
        This requires Python 2.6 or newer.

    :returns: a tuple (:py:class:`rsa.PublicKey`, :py:class:`rsa.PrivateKey`)

    The ``poolsize`` parameter was added in *Python-RSA 3.1* and requires
    Python 2.6 or newer.
    
    i   s   Key too smalli   s   Pool size (%i) should be >= 1iˇˇˇˇ(   t   parallelNt   poolsize(
   R
   R7   Rv   t	   functoolst   partialt   getprimet   primeRu   R   RG   (   Rl   Re   Rw   Rv   Rx   Rm   RI   RJ   R   RH   R   (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   newkeys%  s    
R|   t   __main__id   i
   i    s   %i timest   Aborteds   Doctests done(   R   t   loggingt   rsa._compatR    R   t	   rsa.primeR7   t   rsa.pemt
   rsa.commont	   getLoggerR   Rh   t   objectR   R   RG   R{   Rz   Rb   Rr   Rt   Ru   R|   t   __all__t   doctestt   ranget   countt   testmodt   failurest   testst   KeyboardInterrupt(    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/key.pyt   <module>   s4   1úΩM	/"	                                                                                                              usr/local/lib/python2.7/dist-packages/rsa/parallel.py                                               0100644 0000000 0000062 00000004244 13077704374 021170  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''Functions for parallel computation on multiple cores.

Introduced in Python-RSA 3.1.

.. note::

    Requires Python 2.6 or newer.

'''

from __future__ import print_function

import multiprocessing as mp

import rsa.prime
import rsa.randnum

def _find_prime(nbits, pipe):
    while True:
        integer = rsa.randnum.read_random_int(nbits)

        # Make sure it's odd
        integer |= 1

        # Test for primeness
        if rsa.prime.is_prime(integer):
            pipe.send(integer)
            return

def getprime(nbits, poolsize):
    '''Returns a prime number that can be stored in 'nbits' bits.

    Works in multiple threads at the same time.

    >>> p = getprime(128, 3)
    >>> rsa.prime.is_prime(p-1)
    False
    >>> rsa.prime.is_prime(p)
    True
    >>> rsa.prime.is_prime(p+1)
    False
    
    >>> from rsa import common
    >>> common.bit_size(p) == 128
    True
    
    '''

    (pipe_recv, pipe_send) = mp.Pipe(duplex=False)

    # Create processes
    procs = [mp.Process(target=_find_prime, args=(nbits, pipe_send))
             for _ in range(poolsize)]
    [p.start() for p in procs]

    result = pipe_recv.recv()

    [p.terminate() for p in procs]

    return result

__all__ = ['getprime']

    
if __name__ == '__main__':
    print('Running doctests 1000x or until failure')
    import doctest
    
    for count in range(100):
        (failures, tests) = doctest.testmod()
        if failures:
            break
        
        if count and count % 10 == 0:
            print('%i times' % count)
    
    print('Doctests done')

                                                                                                                                                                                                                                                                                                                                                            usr/local/lib/python2.7/dist-packages/rsa/parallel.pyc                                              0100644 0000000 0000062 00000003741 13077704403 021325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @  s‚   d  Z  d d l m Z d d l Z d d l Z d d l Z d Ñ  Z d Ñ  Z	 d g Z
 e d k rﬁ e d É d d l Z xW e d	 É D]I Z e j É  \ Z Z e r¶ Pn  e rÑ e d
 d k rÑ e d e É qÑ qÑ We d É n  d S(   sÑ   Functions for parallel computation on multiple cores.

Introduced in Python-RSA 3.1.

.. note::

    Requires Python 2.6 or newer.

iˇˇˇˇ(   t   print_functionNc         C  sP   xI t  rK t j j |  É } | d O} t j j | É r | j | É d  Sq Wd  S(   Ni   (   t   Truet   rsat   randnumt   read_random_intt   primet   is_primet   send(   t   nbitst   pipet   integer(    (    s)   /tmp/pip-build-awuatQ/rsa/rsa/parallel.pyt   _find_prime"   s    	
c         C  sô   t  j d t É \ } } g  t | É D]$ } t  j d t d |  | f É ^ q% } g  | D] } | j É  ^ qV | j É  } g  | D] } | j É  ^ q | S(   s]  Returns a prime number that can be stored in 'nbits' bits.

    Works in multiple threads at the same time.

    >>> p = getprime(128, 3)
    >>> rsa.prime.is_prime(p-1)
    False
    >>> rsa.prime.is_prime(p)
    True
    >>> rsa.prime.is_prime(p+1)
    False
    
    >>> from rsa import common
    >>> common.bit_size(p) == 128
    True
    
    t   duplext   targett   args(	   t   mpt   Pipet   Falset   ranget   ProcessR   t   startt   recvt	   terminate(   R   t   poolsizet	   pipe_recvt	   pipe_sendt   _t   procst   pt   result(    (    s)   /tmp/pip-build-awuatQ/rsa/rsa/parallel.pyt   getprime.   s    4R   t   __main__s'   Running doctests 1000x or until failureid   i
   i    s   %i timess   Doctests done(   t   __doc__t
   __future__R    t   multiprocessingR   t	   rsa.primeR   t   rsa.randnumR   R   t   __all__t   __name__t   printt   doctestR   t   countt   testmodt   failurest   tests(    (    (    s)   /tmp/pip-build-awuatQ/rsa/rsa/parallel.pyt   <module>   s"   		 	
                               usr/local/lib/python2.7/dist-packages/rsa/pem.py                                                    0100644 0000000 0000062 00000006454 13077704374 020162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''Functions that load and write PEM-encoded files.'''

import base64
from rsa._compat import b, is_bytes

def _markers(pem_marker):
    '''
    Returns the start and end PEM markers
    '''

    if is_bytes(pem_marker):
        pem_marker = pem_marker.decode('utf-8')

    return (b('-----BEGIN %s-----' % pem_marker),
            b('-----END %s-----' % pem_marker))

def load_pem(contents, pem_marker):
    '''Loads a PEM file.

    @param contents: the contents of the file to interpret
    @param pem_marker: the marker of the PEM content, such as 'RSA PRIVATE KEY'
        when your file has '-----BEGIN RSA PRIVATE KEY-----' and
        '-----END RSA PRIVATE KEY-----' markers.

    @return the base64-decoded content between the start and end markers.

    @raise ValueError: when the content is invalid, for example when the start
        marker cannot be found.

    '''

    (pem_start, pem_end) = _markers(pem_marker)

    pem_lines = []
    in_pem_part = False

    for line in contents.splitlines():
        line = line.strip()

        # Skip empty lines
        if not line:
            continue

        # Handle start marker
        if line == pem_start:
            if in_pem_part:
                raise ValueError('Seen start marker "%s" twice' % pem_start)

            in_pem_part = True
            continue

        # Skip stuff before first marker
        if not in_pem_part:
            continue

        # Handle end marker
        if in_pem_part and line == pem_end:
            in_pem_part = False
            break

        # Load fields
        if b(':') in line:
            continue

        pem_lines.append(line)

    # Do some sanity checks
    if not pem_lines:
        raise ValueError('No PEM start marker "%s" found' % pem_start)

    if in_pem_part:
        raise ValueError('No PEM end marker "%s" found' % pem_end)

    # Base64-decode the contents
    pem = b('').join(pem_lines)
    return base64.decodestring(pem)


def save_pem(contents, pem_marker):
    '''Saves a PEM file.

    @param contents: the contents to encode in PEM format
    @param pem_marker: the marker of the PEM content, such as 'RSA PRIVATE KEY'
        when your file has '-----BEGIN RSA PRIVATE KEY-----' and
        '-----END RSA PRIVATE KEY-----' markers.

    @return the base64-encoded content between the start and end markers.

    '''

    (pem_start, pem_end) = _markers(pem_marker)

    b64 = base64.encodestring(contents).replace(b('\n'), b(''))
    pem_lines = [pem_start]
    
    for block_start in range(0, len(b64), 64):
        block = b64[block_start:block_start + 64]
        pem_lines.append(block)

    pem_lines.append(pem_end)
    pem_lines.append(b(''))

    return b('\n').join(pem_lines)
    
                                                                                                                                                                                                                    usr/local/lib/python2.7/dist-packages/rsa/pem.pyc                                                   0100644 0000000 0000062 00000005234 13077704403 020311  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   sG   d  Z  d d l Z d d l m Z m Z d Ñ  Z d Ñ  Z d Ñ  Z d S(   s0   Functions that load and write PEM-encoded files.iˇˇˇˇN(   t   bt   is_bytesc         C   s<   t  |  É r |  j d É }  n  t d |  É t d |  É f S(   s/   
    Returns the start and end PEM markers
    s   utf-8s   -----BEGIN %s-----s   -----END %s-----(   R   t   decodeR    (   t
   pem_marker(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/pem.pyt   _markers   s    c         C   s  t  | É \ } } g  } t } x™ |  j É  D]ú } | j É  } | sI q+ n  | | k rz | rn t d | É Ç n  t } q+ n  | sÜ q+ n  | r¢ | | k r¢ t } Pn  t d É | k r∫ q+ n  | j | É q+ W| s‰ t d | É Ç n  | r˝ t d | É Ç n  t d É j | É } t	 j
 | É S(   s–  Loads a PEM file.

    @param contents: the contents of the file to interpret
    @param pem_marker: the marker of the PEM content, such as 'RSA PRIVATE KEY'
        when your file has '-----BEGIN RSA PRIVATE KEY-----' and
        '-----END RSA PRIVATE KEY-----' markers.

    @return the base64-decoded content between the start and end markers.

    @raise ValueError: when the content is invalid, for example when the start
        marker cannot be found.

    s   Seen start marker "%s" twicet   :s   No PEM start marker "%s" founds   No PEM end marker "%s" foundt    (   R   t   Falset
   splitlinest   stript
   ValueErrort   TrueR    t   appendt   joint   base64t   decodestring(   t   contentsR   t	   pem_startt   pem_endt	   pem_linest   in_pem_partt   linet   pem(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/pem.pyt   load_pem!   s4    c         C   s∂   t  | É \ } } t j |  É j t d É t d É É } | g } x> t d t | É d É D]$ } | | | d !} | j | É q[ W| j | É | j t d É É t d É j | É S(   s_  Saves a PEM file.

    @param contents: the contents to encode in PEM format
    @param pem_marker: the marker of the PEM content, such as 'RSA PRIVATE KEY'
        when your file has '-----BEGIN RSA PRIVATE KEY-----' and
        '-----END RSA PRIVATE KEY-----' markers.

    @return the base64-encoded content between the start and end markers.

    s   
R   i    i@   (	   R   R   t   encodestringt   replaceR    t   ranget   lenR   R   (   R   R   R   R   t   b64R   t   block_startt   block(    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/pem.pyt   save_pem_   s    '	(   t   __doc__R   t   rsa._compatR    R   R   R   R   (    (    (    s$   /tmp/pip-build-awuatQ/rsa/rsa/pem.pyt   <module>   s
   		>                                                                                                                                                                                                                                                                                                                                                                    usr/local/lib/python2.7/dist-packages/rsa/pkcs1.py                                                  0100644 0000000 0000062 00000030035 13077704374 020412  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''Functions for PKCS#1 version 1.5 encryption and signing

This module implements certain functionality from PKCS#1 version 1.5. For a
very clear example, read http://www.di-mgt.com.au/rsa_alg.html#pkcs1schemes

At least 8 bytes of random padding is used when encrypting a message. This makes
these methods much more secure than the ones in the ``rsa`` module.

WARNING: this module leaks information when decryption fails. The exceptions
that are raised contain the Python traceback information, which can be used to
deduce where in the process the failure occurred. DO NOT PASS SUCH INFORMATION
to your users.
'''

import hashlib
import os

from rsa._compat import b
from rsa import common, transform, core, varblock

# ASN.1 codes that describe the hash algorithm used.
HASH_ASN1 = {
    'MD5': b('\x30\x20\x30\x0c\x06\x08\x2a\x86\x48\x86\xf7\x0d\x02\x05\x05\x00\x04\x10'),
    'SHA-1': b('\x30\x21\x30\x09\x06\x05\x2b\x0e\x03\x02\x1a\x05\x00\x04\x14'),
    'SHA-256': b('\x30\x31\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x01\x05\x00\x04\x20'),
    'SHA-384': b('\x30\x41\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x02\x05\x00\x04\x30'),
    'SHA-512': b('\x30\x51\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x03\x05\x00\x04\x40'),
}

HASH_METHODS = {
    'MD5': hashlib.md5,
    'SHA-1': hashlib.sha1,
    'SHA-256': hashlib.sha256,
    'SHA-384': hashlib.sha384,
    'SHA-512': hashlib.sha512,
}

class CryptoError(Exception):
    '''Base class for all exceptions in this module.'''

class DecryptionError(CryptoError):
    '''Raised when decryption fails.'''

class VerificationError(CryptoError):
    '''Raised when verification fails.'''
 
def _pad_for_encryption(message, target_length):
    r'''Pads the message for encryption, returning the padded message.
    
    :return: 00 02 RANDOM_DATA 00 MESSAGE
    
    >>> block = _pad_for_encryption('hello', 16)
    >>> len(block)
    16
    >>> block[0:2]
    '\x00\x02'
    >>> block[-6:]
    '\x00hello'

    '''

    max_msglength = target_length - 11
    msglength = len(message)
    
    if msglength > max_msglength:
        raise OverflowError('%i bytes needed for message, but there is only'
            ' space for %i' % (msglength, max_msglength))
    
    # Get random padding
    padding = b('')
    padding_length = target_length - msglength - 3
    
    # We remove 0-bytes, so we'll end up with less padding than we've asked for,
    # so keep adding data until we're at the correct length.
    while len(padding) < padding_length:
        needed_bytes = padding_length - len(padding)
        
        # Always read at least 8 bytes more than we need, and trim off the rest
        # after removing the 0-bytes. This increases the chance of getting
        # enough bytes, especially when needed_bytes is small
        new_padding = os.urandom(needed_bytes + 5)
        new_padding = new_padding.replace(b('\x00'), b(''))
        padding = padding + new_padding[:needed_bytes]
    
    assert len(padding) == padding_length
    
    return b('').join([b('\x00\x02'),
                    padding,
                    b('\x00'),
                    message])
    

def _pad_for_signing(message, target_length):
    r'''Pads the message for signing, returning the padded message.
    
    The padding is always a repetition of FF bytes.
    
    :return: 00 01 PADDING 00 MESSAGE
    
    >>> block = _pad_for_signing('hello', 16)
    >>> len(block)
    16
    >>> block[0:2]
    '\x00\x01'
    >>> block[-6:]
    '\x00hello'
    >>> block[2:-6]
    '\xff\xff\xff\xff\xff\xff\xff\xff'
    
    '''

    max_msglength = target_length - 11
    msglength = len(message)
    
    if msglength > max_msglength:
        raise OverflowError('%i bytes needed for message, but there is only'
            ' space for %i' % (msglength, max_msglength))
    
    padding_length = target_length - msglength - 3
    
    return b('').join([b('\x00\x01'),
                    padding_length * b('\xff'),
                    b('\x00'),
                    message])
    
    
def encrypt(message, pub_key):
    '''Encrypts the given message using PKCS#1 v1.5
    
    :param message: the message to encrypt. Must be a byte string no longer than
        ``k-11`` bytes, where ``k`` is the number of bytes needed to encode
        the ``n`` component of the public key.
    :param pub_key: the :py:class:`rsa.PublicKey` to encrypt with.
    :raise OverflowError: when the message is too large to fit in the padded
        block.
        
    >>> from rsa import key, common
    >>> (pub_key, priv_key) = key.newkeys(256)
    >>> message = 'hello'
    >>> crypto = encrypt(message, pub_key)
    
    The crypto text should be just as long as the public key 'n' component:

    >>> len(crypto) == common.byte_size(pub_key.n)
    True
    
    '''
    
    keylength = common.byte_size(pub_key.n)
    padded = _pad_for_encryption(message, keylength)
    
    payload = transform.bytes2int(padded)
    encrypted = core.encrypt_int(payload, pub_key.e, pub_key.n)
    block = transform.int2bytes(encrypted, keylength)
    
    return block

def decrypt(crypto, priv_key):
    r'''Decrypts the given message using PKCS#1 v1.5
    
    The decryption is considered 'failed' when the resulting cleartext doesn't
    start with the bytes 00 02, or when the 00 byte between the padding and
    the message cannot be found.
    
    :param crypto: the crypto text as returned by :py:func:`rsa.encrypt`
    :param priv_key: the :py:class:`rsa.PrivateKey` to decrypt with.
    :raise DecryptionError: when the decryption fails. No details are given as
        to why the code thinks the decryption fails, as this would leak
        information about the private key.


    >>> import rsa
    >>> (pub_key, priv_key) = rsa.newkeys(256)

    It works with strings:

    >>> crypto = encrypt('hello', pub_key)
    >>> decrypt(crypto, priv_key)
    'hello'
    
    And with binary data:

    >>> crypto = encrypt('\x00\x00\x00\x00\x01', pub_key)
    >>> decrypt(crypto, priv_key)
    '\x00\x00\x00\x00\x01'

    Altering the encrypted information will *likely* cause a
    :py:class:`rsa.pkcs1.DecryptionError`. If you want to be *sure*, use
    :py:func:`rsa.sign`.


    .. warning::

        Never display the stack trace of a
        :py:class:`rsa.pkcs1.DecryptionError` exception. It shows where in the
        code the exception occurred, and thus leaks information about the key.
        It's only a tiny bit of information, but every bit makes cracking the
        keys easier.

    >>> crypto = encrypt('hello', pub_key)
    >>> crypto = crypto[0:5] + 'X' + crypto[6:] # change a byte
    >>> decrypt(crypto, priv_key)
    Traceback (most recent call last):
    ...
    DecryptionError: Decryption failed

    '''
    
    blocksize = common.byte_size(priv_key.n)
    encrypted = transform.bytes2int(crypto)
    decrypted = core.decrypt_int(encrypted, priv_key.d, priv_key.n)
    cleartext = transform.int2bytes(decrypted, blocksize)

    # If we can't find the cleartext marker, decryption failed.
    if cleartext[0:2] != b('\x00\x02'):
        raise DecryptionError('Decryption failed')
    
    # Find the 00 separator between the padding and the message
    try:
        sep_idx = cleartext.index(b('\x00'), 2)
    except ValueError:
        raise DecryptionError('Decryption failed')
    
    return cleartext[sep_idx+1:]
    
def sign(message, priv_key, hash):
    '''Signs the message with the private key.

    Hashes the message, then signs the hash with the given key. This is known
    as a "detached signature", because the message itself isn't altered.
    
    :param message: the message to sign. Can be an 8-bit string or a file-like
        object. If ``message`` has a ``read()`` method, it is assumed to be a
        file-like object.
    :param priv_key: the :py:class:`rsa.PrivateKey` to sign with
    :param hash: the hash method used on the message. Use 'MD5', 'SHA-1',
        'SHA-256', 'SHA-384' or 'SHA-512'.
    :return: a message signature block.
    :raise OverflowError: if the private key is too small to contain the
        requested hash.

    '''

    # Get the ASN1 code for this hash method
    if hash not in HASH_ASN1:
        raise ValueError('Invalid hash method: %s' % hash)
    asn1code = HASH_ASN1[hash]
    
    # Calculate the hash
    hash = _hash(message, hash)

    # Encrypt the hash with the private key
    cleartext = asn1code + hash
    keylength = common.byte_size(priv_key.n)
    padded = _pad_for_signing(cleartext, keylength)
    
    payload = transform.bytes2int(padded)
    encrypted = core.encrypt_int(payload, priv_key.d, priv_key.n)
    block = transform.int2bytes(encrypted, keylength)
    
    return block

def verify(message, signature, pub_key):
    '''Verifies that the signature matches the message.
    
    The hash method is detected automatically from the signature.
    
    :param message: the signed message. Can be an 8-bit string or a file-like
        object. If ``message`` has a ``read()`` method, it is assumed to be a
        file-like object.
    :param signature: the signature block, as created with :py:func:`rsa.sign`.
    :param pub_key: the :py:class:`rsa.PublicKey` of the person signing the message.
    :raise VerificationError: when the signature doesn't match the message.

    '''
    
    keylength = common.byte_size(pub_key.n)
    encrypted = transform.bytes2int(signature)
    decrypted = core.decrypt_int(encrypted, pub_key.e, pub_key.n)
    clearsig = transform.int2bytes(decrypted, keylength)
    
    # Get the hash method
    method_name = _find_method_hash(clearsig)
    message_hash = _hash(message, method_name)

    # Reconstruct the expected padded hash
    cleartext = HASH_ASN1[method_name] + message_hash
    expected = _pad_for_signing(cleartext, keylength)

    # Compare with the signed one
    if expected != clearsig:
        raise VerificationError('Verification failed')

    return True

def _hash(message, method_name):
    '''Returns the message digest.
    
    :param message: the signed message. Can be an 8-bit string or a file-like
        object. If ``message`` has a ``read()`` method, it is assumed to be a
        file-like object.
    :param method_name: the hash method, must be a key of
        :py:const:`HASH_METHODS`.
    
    '''

    if method_name not in HASH_METHODS:
        raise ValueError('Invalid hash method: %s' % method_name)
    
    method = HASH_METHODS[method_name]
    hasher = method()

    if hasattr(message, 'read') and hasattr(message.read, '__call__'):
        # read as 1K blocks
        for block in varblock.yield_fixedblocks(message, 1024):
            hasher.update(block)
    else:
        # hash the message object itself.
        hasher.update(message)

    return hasher.digest()


def _find_method_hash(clearsig):
    '''Finds the hash method.
    
    :param clearsig: full padded ASN1 and hash.
    
    :return: the used hash method.
    
    :raise VerificationFailed: when the hash method cannot be found

    '''

    for (hashname, asn1code) in HASH_ASN1.items():
        if asn1code in clearsig:
            return hashname
    
    raise VerificationError('Verification failed')


__all__ = ['encrypt', 'decrypt', 'sign', 'verify',
           'DecryptionError', 'VerificationError', 'CryptoError']

if __name__ == '__main__':
    print('Running doctests 1000x or until failure')
    import doctest
    
    for count in range(1000):
        (failures, tests) = doctest.testmod()
        if failures:
            break
        
        if count and count % 100 == 0:
            print('%i times' % count)
    
    print('Doctests done')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/lib/python2.7/dist-packages/rsa/pkcs1.pyc                                                 0100644 0000000 0000062 00000025542 13077704403 020555  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   sÚ  d  Z  d d l Z d d l Z d d l m Z d d l m Z m Z m Z m	 Z	 i e d É d 6e d É d 6e d	 É d
 6e d É d 6e d É d 6Z
 i e j d 6e j d 6e j d
 6e j d 6e j d 6Z d e f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d d d  d d d g Z e d! k rÓd" GHd d l Z xR e  d# É D]D Z! e j" É  \ Z# Z$ e# r¿Pn  e! rûe! d$ d% k rûd& e! GHqûqûWd' GHn  d S((   sb  Functions for PKCS#1 version 1.5 encryption and signing

This module implements certain functionality from PKCS#1 version 1.5. For a
very clear example, read http://www.di-mgt.com.au/rsa_alg.html#pkcs1schemes

At least 8 bytes of random padding is used when encrypting a message. This makes
these methods much more secure than the ones in the ``rsa`` module.

WARNING: this module leaks information when decryption fails. The exceptions
that are raised contain the Python traceback information, which can be used to
deduce where in the process the failure occurred. DO NOT PASS SUCH INFORMATION
to your users.
iˇˇˇˇN(   t   b(   t   commont	   transformt   coret   varblocks   0 0*ÜHÜ˜ t   MD5s   0!0	+ s   SHA-1s   010	`ÜHe  s   SHA-256s   0A0	`ÜHe 0s   SHA-384s   0Q0	`ÜHe @s   SHA-512t   CryptoErrorc           B   s   e  Z d  Z RS(   s-   Base class for all exceptions in this module.(   t   __name__t
   __module__t   __doc__(    (    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyR   6   s   t   DecryptionErrorc           B   s   e  Z d  Z RS(   s   Raised when decryption fails.(   R   R   R	   (    (    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyR
   9   s   t   VerificationErrorc           B   s   e  Z d  Z RS(   s   Raised when verification fails.(   R   R   R	   (    (    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyR   <   s   c         C   s   | d } t  |  É } | | k r; t d | | f É Ç n  t d É } | | d } xe t  | É | k  rº | t  | É } t j | d É } | j t d É t d É É } | | |  } qX Wt  | É | k s’ t Ç t d É j t d É | t d É |  g É S(   s  Pads the message for encryption, returning the padded message.
    
    :return: 00 02 RANDOM_DATA 00 MESSAGE
    
    >>> block = _pad_for_encryption('hello', 16)
    >>> len(block)
    16
    >>> block[0:2]
    '\x00\x02'
    >>> block[-6:]
    '\x00hello'

    i   s;   %i bytes needed for message, but there is only space for %it    i   i   t    t    (   t   lent   OverflowErrorR    t   ost   urandomt   replacet   AssertionErrort   join(   t   messaget   target_lengtht   max_msglengtht	   msglengtht   paddingt   padding_lengtht   needed_bytest   new_padding(    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyt   _pad_for_encryption?   s"    
	c         C   s~   | d } t  |  É } | | k r; t d | | f É Ç n  | | d } t d É j t d É | t d É t d É |  g É S(   sv  Pads the message for signing, returning the padded message.
    
    The padding is always a repetition of FF bytes.
    
    :return: 00 01 PADDING 00 MESSAGE
    
    >>> block = _pad_for_signing('hello', 16)
    >>> len(block)
    16
    >>> block[0:2]
    '\x00\x01'
    >>> block[-6:]
    '\x00hello'
    >>> block[2:-6]
    '\xff\xff\xff\xff\xff\xff\xff\xff'
    
    i   s;   %i bytes needed for message, but there is only space for %ii   R   t    s   ˇR   (   R   R   R    R   (   R   R   R   R   R   (    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyt   _pad_for_signingm   s    
	c         C   sa   t  j | j É } t |  | É } t j | É } t j | | j | j É } t j	 | | É } | S(   s’  Encrypts the given message using PKCS#1 v1.5
    
    :param message: the message to encrypt. Must be a byte string no longer than
        ``k-11`` bytes, where ``k`` is the number of bytes needed to encode
        the ``n`` component of the public key.
    :param pub_key: the :py:class:`rsa.PublicKey` to encrypt with.
    :raise OverflowError: when the message is too large to fit in the padded
        block.
        
    >>> from rsa import key, common
    >>> (pub_key, priv_key) = key.newkeys(256)
    >>> message = 'hello'
    >>> crypto = encrypt(message, pub_key)
    
    The crypto text should be just as long as the public key 'n' component:

    >>> len(crypto) == common.byte_size(pub_key.n)
    True
    
    (
   R   t	   byte_sizet   nR   R   t	   bytes2intR   t   encrypt_intt   et	   int2bytes(   R   t   pub_keyt	   keylengtht   paddedt   payloadt	   encryptedt   block(    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyt   encryptè   s    c         C   sæ   t  j | j É } t j |  É } t j | | j | j É } t j | | É } | d d !t	 d É k rv t
 d É Ç n  y | j t	 d É d É } Wn t k
 r± t
 d É Ç n X| | d S(   s]  Decrypts the given message using PKCS#1 v1.5
    
    The decryption is considered 'failed' when the resulting cleartext doesn't
    start with the bytes 00 02, or when the 00 byte between the padding and
    the message cannot be found.
    
    :param crypto: the crypto text as returned by :py:func:`rsa.encrypt`
    :param priv_key: the :py:class:`rsa.PrivateKey` to decrypt with.
    :raise DecryptionError: when the decryption fails. No details are given as
        to why the code thinks the decryption fails, as this would leak
        information about the private key.


    >>> import rsa
    >>> (pub_key, priv_key) = rsa.newkeys(256)

    It works with strings:

    >>> crypto = encrypt('hello', pub_key)
    >>> decrypt(crypto, priv_key)
    'hello'
    
    And with binary data:

    >>> crypto = encrypt('\x00\x00\x00\x00\x01', pub_key)
    >>> decrypt(crypto, priv_key)
    '\x00\x00\x00\x00\x01'

    Altering the encrypted information will *likely* cause a
    :py:class:`rsa.pkcs1.DecryptionError`. If you want to be *sure*, use
    :py:func:`rsa.sign`.


    .. warning::

        Never display the stack trace of a
        :py:class:`rsa.pkcs1.DecryptionError` exception. It shows where in the
        code the exception occurred, and thus leaks information about the key.
        It's only a tiny bit of information, but every bit makes cracking the
        keys easier.

    >>> crypto = encrypt('hello', pub_key)
    >>> crypto = crypto[0:5] + 'X' + crypto[6:] # change a byte
    >>> decrypt(crypto, priv_key)
    Traceback (most recent call last):
    ...
    DecryptionError: Decryption failed

    i    i   R   s   Decryption failedR   i   (   R   R!   R"   R   R#   R   t   decrypt_intt   dR&   R    R
   t   indext
   ValueError(   t   cryptot   priv_keyt	   blocksizeR+   t	   decryptedt	   cleartextt   sep_idx(    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyt   decryptÆ   s    3c   
      C   s£   | t  k r t d | É Ç n  t  | } t |  | É } | | } t j | j É } t | | É } t j | É } t	 j
 | | j | j É } t j | | É }	 |	 S(   s¿  Signs the message with the private key.

    Hashes the message, then signs the hash with the given key. This is known
    as a "detached signature", because the message itself isn't altered.
    
    :param message: the message to sign. Can be an 8-bit string or a file-like
        object. If ``message`` has a ``read()`` method, it is assumed to be a
        file-like object.
    :param priv_key: the :py:class:`rsa.PrivateKey` to sign with
    :param hash: the hash method used on the message. Use 'MD5', 'SHA-1',
        'SHA-256', 'SHA-384' or 'SHA-512'.
    :return: a message signature block.
    :raise OverflowError: if the private key is too small to contain the
        requested hash.

    s   Invalid hash method: %s(   t	   HASH_ASN1R1   t   _hashR   R!   R"   R    R   R#   R   R$   R/   R&   (
   R   R3   t   hasht   asn1codeR6   R(   R)   R*   R+   R,   (    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyt   signÚ   s    

c         C   s•   t  j | j É } t j | É } t j | | j | j É } t j | | É } t	 | É } t
 |  | É } t | | }	 t |	 | É }
 |
 | k r° t d É Ç n  t S(   s)  Verifies that the signature matches the message.
    
    The hash method is detected automatically from the signature.
    
    :param message: the signed message. Can be an 8-bit string or a file-like
        object. If ``message`` has a ``read()`` method, it is assumed to be a
        file-like object.
    :param signature: the signature block, as created with :py:func:`rsa.sign`.
    :param pub_key: the :py:class:`rsa.PublicKey` of the person signing the message.
    :raise VerificationError: when the signature doesn't match the message.

    s   Verification failed(   R   R!   R"   R   R#   R   R.   R%   R&   t   _find_method_hashR:   R9   R    R   t   True(   R   t	   signatureR'   R(   R+   R5   t   clearsigt   method_namet   message_hashR6   t   expected(    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyt   verify  s    c         C   só   | t  k r t d | É Ç n  t  | } | É  } t |  d É rÄ t |  j d É rÄ x7 t j |  d É D] } | j | É qf Wn | j |  É | j É  S(   s<  Returns the message digest.
    
    :param message: the signed message. Can be an 8-bit string or a file-like
        object. If ``message`` has a ``read()`` method, it is assumed to be a
        file-like object.
    :param method_name: the hash method, must be a key of
        :py:const:`HASH_METHODS`.
    
    s   Invalid hash method: %st   readt   __call__i   (   t   HASH_METHODSR1   t   hasattrRF   R   t   yield_fixedblockst   updatet   digest(   R   RB   t   methodt   hasherR,   (    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyR:   8  s    
	!c         C   s=   x* t  j É  D] \ } } | |  k r | Sq Wt d É Ç d S(   s¬   Finds the hash method.
    
    :param clearsig: full padded ASN1 and hash.
    
    :return: the used hash method.
    
    :raise VerificationFailed: when the hash method cannot be found

    s   Verification failedN(   R9   t   itemsR   (   RA   t   hashnameR<   (    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyR>   T  s    R-   R8   R=   RE   t   __main__s'   Running doctests 1000x or until failureiË  id   i    s   %i timess   Doctests done(%   R	   t   hashlibR   t   rsa._compatR    t   rsaR   R   R   R   R9   t   md5t   sha1t   sha256t   sha384t   sha512RH   t	   ExceptionR   R
   R   R   R    R-   R8   R=   RE   R:   R>   t   __all__R   t   doctestt   ranget   countt   testmodt   failurest   tests(    (    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/pkcs1.pyt   <module>   sN   "



	.	"		D	%	!		                                                                                                                                                              usr/local/lib/python2.7/dist-packages/rsa/prime.py                                                  0100644 0000000 0000062 00000007501 13077704374 020507  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''Numerical functions related to primes.

Implementation based on the book Algorithm Design by Michael T. Goodrich and
Roberto Tamassia, 2002.
'''

__all__ = [ 'getprime', 'are_relatively_prime']

import rsa.randnum

def gcd(p, q):
    '''Returns the greatest common divisor of p and q

    >>> gcd(48, 180)
    12
    '''

    while q != 0:
        if p < q: (p,q) = (q,p)
        (p,q) = (q, p % q)
    return p
    

def jacobi(a, b):
    '''Calculates the value of the Jacobi symbol (a/b) where both a and b are
    positive integers, and b is odd

    :returns: -1, 0 or 1
    '''

    assert a > 0
    assert b > 0

    if a == 0: return 0
    result = 1
    while a > 1:
        if a & 1:
            if ((a-1)*(b-1) >> 2) & 1:
                result = -result
            a, b = b % a, a
        else:
            if (((b * b) - 1) >> 3) & 1:
                result = -result
            a >>= 1
    if a == 0: return 0
    return result

def jacobi_witness(x, n):
    '''Returns False if n is an Euler pseudo-prime with base x, and
    True otherwise.
    '''

    j = jacobi(x, n) % n

    f = pow(x, n >> 1, n)

    if j == f: return False
    return True

def randomized_primality_testing(n, k):
    '''Calculates whether n is composite (which is always correct) or
    prime (which is incorrect with error probability 2**-k)

    Returns False if the number is composite, and True if it's
    probably prime.
    '''

    # 50% of Jacobi-witnesses can report compositness of non-prime numbers

    # The implemented algorithm using the Jacobi witness function has error
    # probability q <= 0.5, according to Goodrich et. al
    #
    # q = 0.5
    # t = int(math.ceil(k / log(1 / q, 2)))
    # So t = k / log(2, 2) = k / 1 = k
    # this means we can use range(k) rather than range(t)

    for _ in range(k):
        x = rsa.randnum.randint(n-1)
        if jacobi_witness(x, n): return False
    
    return True

def is_prime(number):
    '''Returns True if the number is prime, and False otherwise.

    >>> is_prime(42)
    False
    >>> is_prime(41)
    True
    '''

    return randomized_primality_testing(number, 6)

def getprime(nbits):
    '''Returns a prime number that can be stored in 'nbits' bits.

    >>> p = getprime(128)
    >>> is_prime(p-1)
    False
    >>> is_prime(p)
    True
    >>> is_prime(p+1)
    False
    
    >>> from rsa import common
    >>> common.bit_size(p) == 128
    True
    
    '''

    while True:
        integer = rsa.randnum.read_random_int(nbits)

        # Make sure it's odd
        integer |= 1

        # Test for primeness
        if is_prime(integer):
            return integer

        # Retry if not prime


def are_relatively_prime(a, b):
    '''Returns True if a and b are relatively prime, and False if they
    are not.

    >>> are_relatively_prime(2, 3)
    1
    >>> are_relatively_prime(2, 4)
    0
    '''

    d = gcd(a, b)
    return (d == 1)
    
if __name__ == '__main__':
    print('Running doctests 1000x or until failure')
    import doctest
    
    for count in range(1000):
        (failures, tests) = doctest.testmod()
        if failures:
            break
        
        if count and count % 100 == 0:
            print('%i times' % count)
    
    print('Doctests done')
                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/rsa/prime.pyc                                                 0100644 0000000 0000062 00000007061 13077704403 020644  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   s€   d  Z  d d g Z d d l Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z	 d Ñ  Z
 e d k r◊ d GHd d l Z xR e d É D]D Z e j É  \ Z Z e r© Pn  e rá e d d k rá d e GHqá qá Wd GHn  d S(   sç   Numerical functions related to primes.

Implementation based on the book Algorithm Design by Michael T. Goodrich and
Roberto Tamassia, 2002.
t   getprimet   are_relatively_primeiˇˇˇˇNc         C   sD   x= | d k r? |  | k  r+ | |  }  } n  | |  | }  } q W|  S(   sP   Returns the greatest common divisor of p and q

    >>> gcd(48, 180)
    12
    i    (    (   t   pt   q(    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/prime.pyt   gcd   s
     c         C   sÕ   |  d k s t  Ç | d k s$ t  Ç |  d k r4 d Sd } x| |  d k r∏ |  d @rã |  d | d d ?d @rw | } n  | |  |  }  } q= | | d d ?d @r´ | } n  |  d L}  q= W|  d k r… d S| S(   sâ   Calculates the value of the Jacobi symbol (a/b) where both a and b are
    positive integers, and b is odd

    :returns: -1, 0 or 1
    i    i   i   i   (   t   AssertionError(   t   at   bt   result(    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/prime.pyt   jacobi(   s      


 c         C   s=   t  |  | É | } t |  | d ?| É } | | k r9 t St S(   sU   Returns False if n is an Euler pseudo-prime with base x, and
    True otherwise.
    i   (   R	   t   powt   Falset   True(   t   xt   nt   jt   f(    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/prime.pyt   jacobi_witness@   s
     c         C   sD   x= t  | É D]/ } t j j |  d É } t | |  É r t Sq Wt S(   s”   Calculates whether n is composite (which is always correct) or
    prime (which is incorrect with error probability 2**-k)

    Returns False if the number is composite, and True if it's
    probably prime.
    i   (   t   ranget   rsat   randnumt   randintR   R   R   (   R   t   kt   _R   (    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/prime.pyt   randomized_primality_testingL   s
     c         C   s   t  |  d É S(   s|   Returns True if the number is prime, and False otherwise.

    >>> is_prime(42)
    False
    >>> is_prime(41)
    True
    i   (   R   (   t   number(    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/prime.pyt   is_primed   s    	c         C   s=   x6 t  r8 t j j |  É } | d O} t | É r | Sq Wd S(   s  Returns a prime number that can be stored in 'nbits' bits.

    >>> p = getprime(128)
    >>> is_prime(p-1)
    False
    >>> is_prime(p)
    True
    >>> is_prime(p+1)
    False
    
    >>> from rsa import common
    >>> common.bit_size(p) == 128
    True
    
    i   N(   R   R   R   t   read_random_intR   (   t   nbitst   integer(    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/prime.pyR    o   s
    	
c         C   s   t  |  | É } | d k S(   s§   Returns True if a and b are relatively prime, and False if they
    are not.

    >>> are_relatively_prime(2, 3)
    1
    >>> are_relatively_prime(2, 4)
    0
    i   (   R   (   R   R   t   d(    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/prime.pyR   ç   s    
t   __main__s'   Running doctests 1000x or until failureiË  id   i    s   %i timess   Doctests done(   t   __doc__t   __all__t   rsa.randnumR   R   R	   R   R   R   R    R   t   __name__t   doctestR   t   countt   testmodt   failurest   tests(    (    (    s&   /tmp/pip-build-awuatQ/rsa/rsa/prime.pyt   <module>   s&   							                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/rsa/randnum.py                                                0100644 0000000 0000062 00000004556 13077704374 021046  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''Functions for generating random numbers.'''

# Source inspired by code by Yesudeep Mangalapilly <yesudeep@gmail.com>

import os

from rsa import common, transform
from rsa._compat import byte

def read_random_bits(nbits):
    '''Reads 'nbits' random bits.

    If nbits isn't a whole number of bytes, an extra byte will be appended with
    only the lower bits set.
    '''

    nbytes, rbits = divmod(nbits, 8)

    # Get the random bytes
    randomdata = os.urandom(nbytes)

    # Add the remaining random bits
    if rbits > 0:
        randomvalue = ord(os.urandom(1))
        randomvalue >>= (8 - rbits)
        randomdata = byte(randomvalue) + randomdata

    return randomdata


def read_random_int(nbits):
    '''Reads a random integer of approximately nbits bits.
    '''

    randomdata = read_random_bits(nbits)
    value = transform.bytes2int(randomdata)

    # Ensure that the number is large enough to just fill out the required
    # number of bits.
    value |= 1 << (nbits - 1)

    return value

def randint(maxvalue):
    '''Returns a random integer x with 1 <= x <= maxvalue
    
    May take a very long time in specific situations. If maxvalue needs N bits
    to store, the closer maxvalue is to (2 ** N) - 1, the faster this function
    is.
    '''

    bit_size = common.bit_size(maxvalue)

    tries = 0
    while True:
        value = read_random_int(bit_size)
        if value <= maxvalue:
            break

        if tries and tries % 10 == 0:
            # After a lot of tries to get the right number of bits but still
            # smaller than maxvalue, decrease the number of bits by 1. That'll
            # dramatically increase the chances to get a large enough number.
            bit_size -= 1
        tries += 1

    return value


                                                                                                                                                  usr/local/lib/python2.7/dist-packages/rsa/randnum.pyc                                               0100644 0000000 0000062 00000003312 13077704403 021167  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   sW   d  Z  d d l Z d d l m Z m Z d d l m Z d Ñ  Z d Ñ  Z d Ñ  Z	 d S(   s(   Functions for generating random numbers.iˇˇˇˇN(   t   commont	   transform(   t   bytec         C   sj   t  |  d É \ } } t j | É } | d k rf t t j d É É } | d | L} t | É | } n  | S(   sç   Reads 'nbits' random bits.

    If nbits isn't a whole number of bytes, an extra byte will be appended with
    only the lower bits set.
    i   i    i   (   t   divmodt   ost   urandomt   ordR   (   t   nbitst   nbytest   rbitst
   randomdatat   randomvalue(    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/randnum.pyt   read_random_bits   s    c         C   s1   t  |  É } t j | É } | d |  d >O} | S(   s8   Reads a random integer of approximately nbits bits.
    i   (   R   R   t	   bytes2int(   R   R
   t   value(    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/randnum.pyt   read_random_int/   s    c         C   so   t  j |  É } d } xS t rj t | É } | |  k r: Pn  | r] | d d k r] | d 8} n  | d 7} q W| S(   s‚   Returns a random integer x with 1 <= x <= maxvalue
    
    May take a very long time in specific situations. If maxvalue needs N bits
    to store, the closer maxvalue is to (2 ** N) - 1, the faster this function
    is.
    i    i
   i   (   R    t   bit_sizet   TrueR   (   t   maxvalueR   t   triesR   (    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/randnum.pyt   randint<   s    	(
   t   __doc__R   t   rsaR    R   t   rsa._compatR   R   R   R   (    (    (    s(   /tmp/pip-build-awuatQ/rsa/rsa/randnum.pyt   <module>   s   		                                                                                                                                                                                                                                                                                                                      usr/local/lib/python2.7/dist-packages/rsa/transform.py                                              0100644 0000000 0000062 00000015300 13077704374 021402  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''Data transformation functions.

From bytes to a number, number to bytes, etc.
'''

from __future__ import absolute_import

try:
    # We'll use psyco if available on 32-bit architectures to speed up code.
    # Using psyco (if available) cuts down the execution time on Python 2.5
    # at least by half.
    import psyco
    psyco.full()
except ImportError:
    pass

import binascii
from struct import pack
from rsa import common
from rsa._compat import is_integer, b, byte, get_word_alignment, ZERO_BYTE, EMPTY_BYTE


def bytes2int(raw_bytes):
    r'''Converts a list of bytes or an 8-bit string to an integer.

    When using unicode strings, encode it to some encoding like UTF8 first.

    >>> (((128 * 256) + 64) * 256) + 15
    8405007
    >>> bytes2int('\x80@\x0f')
    8405007

    '''

    return int(binascii.hexlify(raw_bytes), 16)


def _int2bytes(number, block_size=None):
    r'''Converts a number to a string of bytes.

    Usage::

        >>> _int2bytes(123456789)
        '\x07[\xcd\x15'
        >>> bytes2int(_int2bytes(123456789))
        123456789

        >>> _int2bytes(123456789, 6)
        '\x00\x00\x07[\xcd\x15'
        >>> bytes2int(_int2bytes(123456789, 128))
        123456789

        >>> _int2bytes(123456789, 3)
        Traceback (most recent call last):
        ...
        OverflowError: Needed 4 bytes for number, but block size is 3

    @param number: the number to convert
    @param block_size: the number of bytes to output. If the number encoded to
        bytes is less than this, the block will be zero-padded. When not given,
        the returned block is not padded.

    @throws OverflowError when block_size is given and the number takes up more
        bytes than fit into the block.
    '''
    # Type checking
    if not is_integer(number):
        raise TypeError("You must pass an integer for 'number', not %s" %
            number.__class__)

    if number < 0:
        raise ValueError('Negative numbers cannot be used: %i' % number)

    # Do some bounds checking
    if number == 0:
        needed_bytes = 1
        raw_bytes = [ZERO_BYTE]
    else:
        needed_bytes = common.byte_size(number)
        raw_bytes = []

    # You cannot compare None > 0 in Python 3x. It will fail with a TypeError.
    if block_size and block_size > 0:
        if needed_bytes > block_size:
            raise OverflowError('Needed %i bytes for number, but block size '
                'is %i' % (needed_bytes, block_size))

    # Convert the number to bytes.
    while number > 0:
        raw_bytes.insert(0, byte(number & 0xFF))
        number >>= 8

    # Pad with zeroes to fill the block
    if block_size and block_size > 0:
        padding = (block_size - needed_bytes) * ZERO_BYTE
    else:
        padding = EMPTY_BYTE

    return padding + EMPTY_BYTE.join(raw_bytes)


def bytes_leading(raw_bytes, needle=ZERO_BYTE):
    '''
    Finds the number of prefixed byte occurrences in the haystack.

    Useful when you want to deal with padding.

    :param raw_bytes:
        Raw bytes.
    :param needle:
        The byte to count. Default \000.
    :returns:
        The number of leading needle bytes.
    '''
    leading = 0
    # Indexing keeps compatibility between Python 2.x and Python 3.x
    _byte = needle[0]
    for x in raw_bytes:
        if x == _byte:
            leading += 1
        else:
            break
    return leading


def int2bytes(number, fill_size=None, chunk_size=None, overflow=False):
    '''
    Convert an unsigned integer to bytes (base-256 representation)::

    Does not preserve leading zeros if you don't specify a chunk size or
    fill size.

    .. NOTE:
        You must not specify both fill_size and chunk_size. Only one
        of them is allowed.

    :param number:
        Integer value
    :param fill_size:
        If the optional fill size is given the length of the resulting
        byte string is expected to be the fill size and will be padded
        with prefix zero bytes to satisfy that length.
    :param chunk_size:
        If optional chunk size is given and greater than zero, pad the front of
        the byte string with binary zeros so that the length is a multiple of
        ``chunk_size``.
    :param overflow:
        ``False`` (default). If this is ``True``, no ``OverflowError``
        will be raised when the fill_size is shorter than the length
        of the generated byte sequence. Instead the byte sequence will
        be returned as is.
    :returns:
        Raw bytes (base-256 representation).
    :raises:
        ``OverflowError`` when fill_size is given and the number takes up more
        bytes than fit into the block. This requires the ``overflow``
        argument to this function to be set to ``False`` otherwise, no
        error will be raised.
    '''
    if number < 0:
        raise ValueError("Number must be an unsigned integer: %d" % number)

    if fill_size and chunk_size:
        raise ValueError("You can either fill or pad chunks, but not both")

    # Ensure these are integers.
    number & 1

    raw_bytes = b('')

    # Pack the integer one machine word at a time into bytes.
    num = number
    word_bits, _, max_uint, pack_type = get_word_alignment(num)
    pack_format = ">%s" % pack_type
    while num > 0:
        raw_bytes = pack(pack_format, num & max_uint) + raw_bytes
        num >>= word_bits
    # Obtain the index of the first non-zero byte.
    zero_leading = bytes_leading(raw_bytes)
    if number == 0:
        raw_bytes = ZERO_BYTE
    # De-padding.
    raw_bytes = raw_bytes[zero_leading:]

    length = len(raw_bytes)
    if fill_size and fill_size > 0:
        if not overflow and length > fill_size:
            raise OverflowError(
                "Need %d bytes for number, but fill size is %d" %
                (length, fill_size)
            )
        raw_bytes = raw_bytes.rjust(fill_size, ZERO_BYTE)
    elif chunk_size and chunk_size > 0:
        remainder = length % chunk_size
        if remainder:
            padding_size = chunk_size - remainder
            raw_bytes = raw_bytes.rjust(length + padding_size, ZERO_BYTE)
    return raw_bytes


if __name__ == '__main__':
    import doctest
    doctest.testmod()

                                                                                                                                                                                                                                                                                                                                usr/local/lib/python2.7/dist-packages/rsa/transform.pyc                                             0100644 0000000 0000062 00000013212 13077704403 021536  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @@  s˙   d  Z  d d l m Z y d d l Z e j É  Wn e k
 rC n Xd d l Z d d l m Z d d l	 m
 Z
 d d l m Z m Z m Z m Z m Z m Z d Ñ  Z d d Ñ Z e d	 Ñ Z d d e d
 Ñ Z e d k rˆ d d l Z e j É  n  d S(   sN   Data transformation functions.

From bytes to a number, number to bytes, etc.
i    (   t   absolute_importN(   t   pack(   t   common(   t
   is_integert   bt   bytet   get_word_alignmentt	   ZERO_BYTEt
   EMPTY_BYTEc         C@  s   t  t j |  É d É S(   sÌ   Converts a list of bytes or an 8-bit string to an integer.

    When using unicode strings, encode it to some encoding like UTF8 first.

    >>> (((128 * 256) + 64) * 256) + 15
    8405007
    >>> bytes2int('\x80@\x0f')
    8405007

    i   (   t   intt   binasciit   hexlify(   t	   raw_bytes(    (    s*   /tmp/pip-build-awuatQ/rsa/rsa/transform.pyt	   bytes2int'   s    c         C@  s  t  |  É s" t d |  j É Ç n  |  d k  rA t d |  É Ç n  |  d k r_ d } t g } n t j |  É } g  } | rÆ | d k rÆ | | k rÆ t d | | f É Ç qÆ n  x4 |  d k r‰ | j d t	 |  d @É É |  d L}  q± W| r| d k r| | t } n t
 } | t
 j | É S(   sK  Converts a number to a string of bytes.

    Usage::

        >>> _int2bytes(123456789)
        '\x07[\xcd\x15'
        >>> bytes2int(_int2bytes(123456789))
        123456789

        >>> _int2bytes(123456789, 6)
        '\x00\x00\x07[\xcd\x15'
        >>> bytes2int(_int2bytes(123456789, 128))
        123456789

        >>> _int2bytes(123456789, 3)
        Traceback (most recent call last):
        ...
        OverflowError: Needed 4 bytes for number, but block size is 3

    @param number: the number to convert
    @param block_size: the number of bytes to output. If the number encoded to
        bytes is less than this, the block will be zero-padded. When not given,
        the returned block is not padded.

    @throws OverflowError when block_size is given and the number takes up more
        bytes than fit into the block.
    s-   You must pass an integer for 'number', not %si    s#   Negative numbers cannot be used: %ii   s0   Needed %i bytes for number, but block size is %iiˇ   i   (   R   t	   TypeErrort	   __class__t
   ValueErrorR   R   t	   byte_sizet   OverflowErrort   insertR   R   t   join(   t   numbert
   block_sizet   needed_bytesR   t   padding(    (    s*   /tmp/pip-build-awuatQ/rsa/rsa/transform.pyt
   _int2bytes6   s*    c         C@  s?   d } | d } x( |  D]  } | | k r6 | d 7} q Pq W| S(   s  
    Finds the number of prefixed byte occurrences in the haystack.

    Useful when you want to deal with padding.

    :param raw_bytes:
        Raw bytes.
    :param needle:
        The byte to count. Default  .
    :returns:
        The number of leading needle bytes.
    i    i   (    (   R   t   needlet   leadingt   _bytet   x(    (    s*   /tmp/pip-build-awuatQ/rsa/rsa/transform.pyt   bytes_leadingv   s    
c         C@  sÄ  |  d k  r t  d |  É Ç n  | r: | r: t  d É Ç n  |  d @t d É } |  } t | É \ } } } }	 d |	 }
 x1 | d k r© t |
 | | @É | } | | L} qy Wt | É } |  d k rÀ t } n  | | } t | É } | r4| d k r4| r| | k rt d | | f É Ç n  | j | t É } nH | r|| d k r|| | } | r|| | } | j | | t É } q|n  | S(   s)  
    Convert an unsigned integer to bytes (base-256 representation)::

    Does not preserve leading zeros if you don't specify a chunk size or
    fill size.

    .. NOTE:
        You must not specify both fill_size and chunk_size. Only one
        of them is allowed.

    :param number:
        Integer value
    :param fill_size:
        If the optional fill size is given the length of the resulting
        byte string is expected to be the fill size and will be padded
        with prefix zero bytes to satisfy that length.
    :param chunk_size:
        If optional chunk size is given and greater than zero, pad the front of
        the byte string with binary zeros so that the length is a multiple of
        ``chunk_size``.
    :param overflow:
        ``False`` (default). If this is ``True``, no ``OverflowError``
        will be raised when the fill_size is shorter than the length
        of the generated byte sequence. Instead the byte sequence will
        be returned as is.
    :returns:
        Raw bytes (base-256 representation).
    :raises:
        ``OverflowError`` when fill_size is given and the number takes up more
        bytes than fit into the block. This requires the ``overflow``
        argument to this function to be set to ``False`` otherwise, no
        error will be raised.
    i    s&   Number must be an unsigned integer: %ds/   You can either fill or pad chunks, but not bothi   t    s   >%ss-   Need %d bytes for number, but fill size is %d(	   R   R   R   R   R   R   t   lenR   t   rjust(   R   t	   fill_sizet
   chunk_sizet   overflowR   t   numt	   word_bitst   _t   max_uintt	   pack_typet   pack_formatt   zero_leadingt   lengtht	   remaindert   padding_size(    (    s*   /tmp/pip-build-awuatQ/rsa/rsa/transform.pyt	   int2bytesé   s:    "
	


t   __main__(   t   __doc__t
   __future__R    t   psycot   fullt   ImportErrorR
   t   structR   t   rsaR   t   rsa._compatR   R   R   R   R   R   R   t   NoneR   R   t   FalseR/   t   __name__t   doctestt   testmod(    (    (    s*   /tmp/pip-build-awuatQ/rsa/rsa/transform.pyt   <module>   s"   .	@K                                                                                                                                                                                                                                                                                                                                                                                      usr/local/lib/python2.7/dist-packages/rsa/util.py                                                   0100644 0000000 0000062 00000005572 13077704374 020356  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''Utility functions.'''

from __future__ import with_statement, print_function

import sys
from optparse import OptionParser

import rsa.key

def private_to_public():
    '''Reads a private key and outputs the corresponding public key.'''

    # Parse the CLI options
    parser = OptionParser(usage='usage: %prog [options]',
            description='Reads a private key and outputs the '
            'corresponding public key. Both private and public keys use '
            'the format described in PKCS#1 v1.5')

    parser.add_option('-i', '--input', dest='infilename', type='string',
            help='Input filename. Reads from stdin if not specified')
    parser.add_option('-o', '--output', dest='outfilename', type='string',
            help='Output filename. Writes to stdout of not specified')

    parser.add_option('--inform', dest='inform',
            help='key format of input - default PEM',
            choices=('PEM', 'DER'), default='PEM')

    parser.add_option('--outform', dest='outform',
            help='key format of output - default PEM',
            choices=('PEM', 'DER'), default='PEM')

    (cli, cli_args) = parser.parse_args(sys.argv)

    # Read the input data
    if cli.infilename:
        print('Reading private key from %s in %s format' % \
            (cli.infilename, cli.inform), file=sys.stderr)
        with open(cli.infilename, 'rb') as infile:
            in_data = infile.read()
    else:
        print('Reading private key from stdin in %s format' % cli.inform,
              file=sys.stderr)
        in_data = sys.stdin.read().encode('ascii')

    assert type(in_data) == bytes, type(in_data)


    # Take the public fields and create a public key
    priv_key = rsa.key.PrivateKey.load_pkcs1(in_data, cli.inform)
    pub_key = rsa.key.PublicKey(priv_key.n, priv_key.e)

    # Save to the output file
    out_data = pub_key.save_pkcs1(cli.outform)

    if cli.outfilename:
        print('Writing public key to %s in %s format' % \
            (cli.outfilename, cli.outform), file=sys.stderr)
        with open(cli.outfilename, 'wb') as outfile:
            outfile.write(out_data)
    else:
        print('Writing public key to stdout in %s format' % cli.outform,
              file=sys.stderr)
        sys.stdout.write(out_data.decode('ascii'))

    
                                                                                                                                      usr/local/lib/python2.7/dist-packages/rsa/util.pyc                                                  0100644 0000000 0000062 00000004562 13077704403 020510  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @Ä sQ   d  Z  d d l m Z m Z d d l Z d d l m Z d d l Z d Ñ  Z	 d S(   s   Utility functions.iˇˇˇˇ(   t   with_statementt   print_functionN(   t   OptionParserc    	   
   CÄ s=  t  d d d d É }  |  j d d d d d	 d
 d d É|  j d d d d d	 d
 d d É|  j d d d d d d d$ d d É|  j d d d d d d d% d d É|  j t j É \ } } | j rt d | j | j f d t j Ét	 | j d É è } | j
 É  } Wd QXn2 t d | j d t j Ét j j
 É  j d  É } t | É t k sgt t | É É Ç t j j j | | j É } t j j | j | j É } | j | j É } | j rt d! | j | j f d t j Ét	 | j d" É è } | j | É Wd QXn3 t d# | j d t j Ét j j | j d  É É d S(&   s=   Reads a private key and outputs the corresponding public key.t   usages   usage: %prog [options]t   descriptionsÇ   Reads a private key and outputs the corresponding public key. Both private and public keys use the format described in PKCS#1 v1.5s   -is   --inputt   destt
   infilenamet   typet   stringt   helps1   Input filename. Reads from stdin if not specifieds   -os   --outputt   outfilenames2   Output filename. Writes to stdout of not specifieds   --informt   informs!   key format of input - default PEMt   choicest   PEMt   DERt   defaults	   --outformt   outforms"   key format of output - default PEMs(   Reading private key from %s in %s formatt   filet   rbNs+   Reading private key from stdin in %s formatt   asciis%   Writing public key to %s in %s formatt   wbs)   Writing public key to stdout in %s format(   R   R   (   R   R   (   R   t
   add_optiont
   parse_argst   syst   argvR   t   printR   t   stderrt   opent   readt   stdint   encodeR   t   bytest   AssertionErrort   rsat   keyt
   PrivateKeyt
   load_pkcs1t	   PublicKeyt   nt   et
   save_pkcs1R   R
   t   writet   stdoutt   decode(	   t   parsert   clit   cli_argst   infilet   in_datat   priv_keyt   pub_keyt   out_datat   outfile(    (    s%   /tmp/pip-build-awuatQ/rsa/rsa/util.pyt   private_to_public   sB    		
$	
(
   t   __doc__t
   __future__R    R   R   t   optparseR   t   rsa.keyR!   R5   (    (    (    s%   /tmp/pip-build-awuatQ/rsa/rsa/util.pyt   <module>   s
                                                                                                                                                 usr/local/lib/python2.7/dist-packages/rsa/varblock.py                                               0100644 0000000 0000062 00000010410 13077704374 021167  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- coding: utf-8 -*-
#
#  Copyright 2011 Sybren A. St√ºvel <sybren@stuvel.eu>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''VARBLOCK file support

The VARBLOCK file format is as follows, where || denotes byte concatenation:

    FILE := VERSION || BLOCK || BLOCK ...

    BLOCK := LENGTH || DATA

    LENGTH := varint-encoded length of the subsequent data. Varint comes from
    Google Protobuf, and encodes an integer into a variable number of bytes.
    Each byte uses the 7 lowest bits to encode the value. The highest bit set
    to 1 indicates the next byte is also part of the varint. The last byte will
    have this bit set to 0.

This file format is called the VARBLOCK format, in line with the varint format
used to denote the block sizes.

'''

from rsa._compat import byte, b


ZERO_BYTE = b('\x00')
VARBLOCK_VERSION = 1

def read_varint(infile):
    '''Reads a varint from the file.

    When the first byte to be read indicates EOF, (0, 0) is returned. When an
    EOF occurs when at least one byte has been read, an EOFError exception is
    raised.

    @param infile: the file-like object to read from. It should have a read()
        method.
    @returns (varint, length), the read varint and the number of read bytes.
    '''

    varint = 0
    read_bytes = 0

    while True:
        char = infile.read(1)
        if len(char) == 0:
            if read_bytes == 0:
                return (0, 0)
            raise EOFError('EOF while reading varint, value is %i so far' %
                           varint)

        byte = ord(char)
        varint += (byte & 0x7F) << (7 * read_bytes)

        read_bytes += 1

        if not byte & 0x80:
            return (varint, read_bytes)


def write_varint(outfile, value):
    '''Writes a varint to a file.

    @param outfile: the file-like object to write to. It should have a write()
        method.
    @returns the number of written bytes.
    '''

    # there is a big difference between 'write the value 0' (this case) and
    # 'there is nothing left to write' (the false-case of the while loop)

    if value == 0:
        outfile.write(ZERO_BYTE)
        return 1

    written_bytes = 0
    while value > 0:
        to_write = value & 0x7f
        value = value >> 7

        if value > 0:
            to_write |= 0x80

        outfile.write(byte(to_write))
        written_bytes += 1

    return written_bytes


def yield_varblocks(infile):
    '''Generator, yields each block in the input file.

    @param infile: file to read, is expected to have the VARBLOCK format as
        described in the module's docstring.
    @yields the contents of each block.
    '''

    # Check the version number
    first_char = infile.read(1)
    if len(first_char) == 0:
        raise EOFError('Unable to read VARBLOCK version number')

    version = ord(first_char)
    if version != VARBLOCK_VERSION:
        raise ValueError('VARBLOCK version %i not supported' % version)

    while True:
        (block_size, read_bytes) = read_varint(infile)

        # EOF at block boundary, that's fine.
        if read_bytes == 0 and block_size == 0:
            break

        block = infile.read(block_size)

        read_size = len(block)
        if read_size != block_size:
            raise EOFError('Block size is %i, but could read only %i bytes' %
                           (block_size, read_size))

        yield block


def yield_fixedblocks(infile, blocksize):
    '''Generator, yields each block of ``blocksize`` bytes in the input file.

    :param infile: file to read and separate in blocks.
    :returns: a generator that yields the contents of each block
    '''

    while True:
        block = infile.read(blocksize)

        read_bytes = len(block)
        if read_bytes == 0:
            break

        yield block

        if read_bytes < blocksize:
            break

                                                                                                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/rsa/varblock.pyc                                              0100644 0000000 0000062 00000007241 13077704403 021333  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
¸àˇXc           @   sV   d  Z  d d l m Z m Z e d É Z d Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 d	 S(
   ss  VARBLOCK file support

The VARBLOCK file format is as follows, where || denotes byte concatenation:

    FILE := VERSION || BLOCK || BLOCK ...

    BLOCK := LENGTH || DATA

    LENGTH := varint-encoded length of the subsequent data. Varint comes from
    Google Protobuf, and encodes an integer into a variable number of bytes.
    Each byte uses the 7 lowest bits to encode the value. The highest bit set
    to 1 indicates the next byte is also part of the varint. The last byte will
    have this bit set to 0.

This file format is called the VARBLOCK format, in line with the varint format
used to denote the block sizes.

iˇˇˇˇ(   t   bytet   bt    i   c         C   s°   d } d } xé t  rú |  j d É } t | É d k rY | d k rF d St d | É Ç n  t | É } | | d @d | >7} | d 7} | d @s | | f Sq Wd S(	   sw  Reads a varint from the file.

    When the first byte to be read indicates EOF, (0, 0) is returned. When an
    EOF occurs when at least one byte has been read, an EOFError exception is
    raised.

    @param infile: the file-like object to read from. It should have a read()
        method.
    @returns (varint, length), the read varint and the number of read bytes.
    i    i   s,   EOF while reading varint, value is %i so fari   i   iÄ   N(   i    i    (   t   Truet   readt   lent   EOFErrort   ord(   t   infilet   varintt
   read_bytest   charR    (    (    s)   /tmp/pip-build-awuatQ/rsa/rsa/varblock.pyt   read_varint*   s    	

c         C   sÑ   | d k r |  j  t É d Sd } xZ | d k r | d @} | d ?} | d k r_ | d O} n  |  j  t | É É | d 7} q& W| S(   s©   Writes a varint to a file.

    @param outfile: the file-like object to write to. It should have a write()
        method.
    @returns the number of written bytes.
    i    i   i   i   iÄ   (   t   writet	   ZERO_BYTER    (   t   outfilet   valuet   written_bytest   to_write(    (    s)   /tmp/pip-build-awuatQ/rsa/rsa/varblock.pyt   write_varintJ   s    

c         c   sﬂ   |  j  d É } t | É d k r0 t d É Ç n  t | É } | t k r[ t d | É Ç n  x} t r⁄ t |  É \ } } | d k rí | d k rí Pn  |  j  | É } t | É } | | k r“ t d | | f É Ç n  | Vq^ Wd S(   s÷   Generator, yields each block in the input file.

    @param infile: file to read, is expected to have the VARBLOCK format as
        described in the module's docstring.
    @yields the contents of each block.
    i   i    s&   Unable to read VARBLOCK version numbers!   VARBLOCK version %i not supporteds.   Block size is %i, but could read only %i bytesN(   R   R   R   R   t   VARBLOCK_VERSIONt
   ValueErrorR   R   (   R   t
   first_chart   versiont
   block_sizeR
   t   blockt	   read_size(    (    s)   /tmp/pip-build-awuatQ/rsa/rsa/varblock.pyt   yield_varblocksg   s     		c         c   sQ   xJ t  rL |  j | É } t | É } | d k r4 Pn  | V| | k  r Pq q Wd S(   s≈   Generator, yields each block of ``blocksize`` bytes in the input file.

    :param infile: file to read and separate in blocks.
    :returns: a generator that yields the contents of each block
    i    N(   R   R   R   (   R   t	   blocksizeR   R
   (    (    s)   /tmp/pip-build-awuatQ/rsa/rsa/varblock.pyt   yield_fixedblocksâ   s    	N(
   t   __doc__t   rsa._compatR    R   R   R   R   R   R   R   (    (    (    s)   /tmp/pip-build-awuatQ/rsa/rsa/varblock.pyt   <module>"   s   	 		"                                                                                                                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/rsa-3.3.dist-info/                                            0042755 0000000 0000062 00000000000 13077704403 021210  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/rsa-3.3.dist-info/DESCRIPTION.rst                             0100644 0000000 0000062 00000000012 13077704374 023520  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        UNKNOWN


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/lib/python2.7/dist-packages/rsa-3.3.dist-info/METADATA                                    0100644 0000000 0000062 00000001267 13077704374 022323  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Metadata-Version: 2.0
Name: rsa
Version: 3.3
Summary: Pure-Python RSA implementation
Home-page: http://stuvel.eu/rsa
Author: Sybren A. Stuvel
Author-email: sybren@stuvel.eu
License: ASL 2
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Education
Classifier: Intended Audience :: Information Technology
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Topic :: Security :: Cryptography
Requires-Dist: pyasn1 (>=0.1.3)

UNKNOWN


                                                                                                                                                                                                                                                                                                                                         usr/local/lib/python2.7/dist-packages/rsa-3.3.dist-info/RECORD                                      0100644 0000000 0000062 00000005447 13077704403 022116  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        rsa/core.py,sha256=n4Va7dWijditR5b8H9LLd0Pb0QEmgf2xsLNlHYuRinM,1668
rsa/prime.py,sha256=EIU6XFqlc1dnBg_dso48OA9I9b0kRPBBrrF2U7CgqtE,3905
rsa/key.py,sha256=Nv_mFx7JHe7caF8pBq4FqixtWTvTuHwjYNk9BZNl3dE,18177
rsa/pem.py,sha256=rEe5WzwnPqbPCaMWl2mGXpURDszMHNgx2ECdLXYFCw8,3372
rsa/asn1.py,sha256=NOQ1Po7Ln6qnc7GKgrvbVdk6t44YEYnizYMD_JBu_GU,1784
rsa/common.py,sha256=P84IC-aohmx5u6EDljJUVQdfSAoUbHnJtL7T3VxsXtM,4716
rsa/util.py,sha256=McDCUdIitqoClG0Vi1gYqdKzfeHXHoFdBY2yfL4RTJE,2938
rsa/_compat.py,sha256=a7wbeF_OmNrwPXOaJCpzYpnk968b_0i1CeXjiLEKFvc,4059
rsa/cli.py,sha256=1hPLfJIYtzu9wQTy89f_eO8NWJ-TWP1vTVUNGKHgxV4,12016
rsa/transform.py,sha256=dBRef_m_IC_X3Q-NjBFV8WaT-ijTe-emLgJC5sQs1Sw,6848
rsa/varblock.py,sha256=0Rc7knd6-EJ08uSIJ5oCwVI53wyx5JEZuatW8xmm9y8,4360
rsa/__init__.py,sha256=-i85rxQP4r35dX7Je_ByyG2hX1Ybx-9VPIsLpMdoDWE,1566
rsa/bigfile.py,sha256=1FnJKCZldAwS8THdyub8vVfCJxmRt86jHVs11o_a2LI,3101
rsa/parallel.py,sha256=1942q40fWW2lJLGEx7JdvXkLWxh6BWqcS3X6x_UfPcA,2212
rsa/_version133.py,sha256=EpOOhY1yfiaw_MOE_X8WDGALcDVOSKbt-ng8HUF_XAg,11911
rsa/randnum.py,sha256=wpUhZEXOelkJm-EbDMQykOmovjddCyVo1wN7OU8EjsY,2414
rsa/_version200.py,sha256=i3Ubnfa10yvO5bOnCoaYGvYLelFfk4qbmU0y3u5hiSA,15644
rsa/pkcs1.py,sha256=id0X5qYVUH0JVpCFn_a0_P07ZaTXIeEyj9NIfWQUmus,12317
rsa-3.3.dist-info/metadata.json,sha256=aMkGAevWkBAFr5eEJVCONU4twTvTqHSUvmY6iR5RNYU,1567
rsa-3.3.dist-info/WHEEL,sha256=AvR0WeTpDaxT645bl5FQxUK6NPsTls2ttpcGJg3j1Xg,110
rsa-3.3.dist-info/DESCRIPTION.rst,sha256=OCTuuN6LcWulhHS3d5rfjdsQtW22n7HENFRh6jC6ego,10
rsa-3.3.dist-info/entry_points.txt,sha256=V0KlSf6VhiqQVRRoMvxaL8jlxgvm65BmWy-a58e85pM,309
rsa-3.3.dist-info/RECORD,,
rsa-3.3.dist-info/METADATA,sha256=JhdAVWyPWCtGpIpbxoVZl_4FDYhgUMaXE7t9ZJ0HcdE,695
rsa-3.3.dist-info/top_level.txt,sha256=fAq1Bm-GX3Blvuu7bvG87v7ye2ZJoIL7oVz1F9FdxjI,4
/usr/local/bin/pyrsa-encrypt-bigfile,sha256=ttfIHuKPlTHu9xJUzPpoYB1bm6-bHkrHtHpOgU7ehWY,230
/usr/local/bin/pyrsa-encrypt,sha256=vVhJnsNfIpOyOd85-SL-ocfQ-sl7VFeHCOcM4fl_IPM,214
/usr/local/bin/pyrsa-verify,sha256=bVVSh8ljxeeHRIEPmJyOOzSwfPWgmtMZF7VavtJtoQ0,212
/usr/local/bin/pyrsa-sign,sha256=6E4QM99xqYzOoW6UqQvXkEdmapQlnK9WX4o5zrfgLm8,208
/usr/local/bin/pyrsa-priv2pub,sha256=JbFzBIEZgG5zWZjcxpqKYR6cJlHB3V9jk29R7MZnGjM,235
/usr/local/bin/pyrsa-decrypt,sha256=g2CEzz8_-NRvnZ7fqe_lJWKeQFTphBoSlXHL6aJZzs4,214
/usr/local/bin/pyrsa-decrypt-bigfile,sha256=8gemCE_s0rI0eLGoBlPljlObLN5BROJetauF_HzEVGg,230
/usr/local/bin/pyrsa-keygen,sha256=-Puohc6lXSZLJGV2Dq99QyjBvCwLvz6b-AJ_KBU4Ggc,212
rsa/cli.pyc,,
rsa/_version133.pyc,,
rsa/common.pyc,,
rsa/_compat.pyc,,
rsa/pem.pyc,,
rsa/varblock.pyc,,
rsa/_version200.pyc,,
rsa/asn1.pyc,,
rsa/util.pyc,,
rsa/__init__.pyc,,
rsa/randnum.pyc,,
rsa/core.pyc,,
rsa/key.pyc,,
rsa/parallel.pyc,,
rsa/prime.pyc,,
rsa/transform.pyc,,
rsa/pkcs1.pyc,,
rsa/bigfile.pyc,,
                                                                                                                                                                                                                         usr/local/lib/python2.7/dist-packages/rsa-3.3.dist-info/WHEEL                                       0100644 0000000 0000062 00000000156 13077704374 022003  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Wheel-Version: 1.0
Generator: bdist_wheel (0.24.0)
Root-Is-Purelib: true
Tag: py2-none-any
Tag: py3-none-any

                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/rsa-3.3.dist-info/entry_points.txt                            0100644 0000000 0000062 00000000465 13077704374 024515  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        [console_scripts]
pyrsa-decrypt = rsa.cli:decrypt
pyrsa-decrypt-bigfile = rsa.cli:decrypt_bigfile
pyrsa-encrypt = rsa.cli:encrypt
pyrsa-encrypt-bigfile = rsa.cli:encrypt_bigfile
pyrsa-keygen = rsa.cli:keygen
pyrsa-priv2pub = rsa.util:private_to_public
pyrsa-sign = rsa.cli:sign
pyrsa-verify = rsa.cli:verify

                                                                                                                                                                                                           usr/local/lib/python2.7/dist-packages/rsa-3.3.dist-info/metadata.json                               0100644 0000000 0000062 00000003037 13077704374 023670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {"version": "3.3", "run_requires": [{"requires": ["pyasn1 (>=0.1.3)"]}], "metadata_version": "2.0", "name": "rsa", "generator": "bdist_wheel (0.24.0)", "summary": "Pure-Python RSA implementation", "license": "ASL 2", "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "Intended Audience :: Education", "Intended Audience :: Information Technology", "License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Topic :: Security :: Cryptography"], "extras": [], "extensions": {"python.exports": {"console_scripts": {"pyrsa-decrypt-bigfile": "rsa.cli:decrypt_bigfile", "pyrsa-keygen": "rsa.cli:keygen", "pyrsa-encrypt-bigfile": "rsa.cli:encrypt_bigfile", "pyrsa-sign": "rsa.cli:sign", "pyrsa-priv2pub": "rsa.util:private_to_public", "pyrsa-encrypt": "rsa.cli:encrypt", "pyrsa-decrypt": "rsa.cli:decrypt", "pyrsa-verify": "rsa.cli:verify"}}, "python.details": {"contacts": [{"email": "sybren@stuvel.eu", "name": "Sybren A. Stuvel", "role": "author"}], "project_urls": {"Home": "http://stuvel.eu/rsa"}, "document_names": {"description": "DESCRIPTION.rst"}}, "python.commands": {"wrap_console": {"pyrsa-decrypt-bigfile": "rsa.cli:decrypt_bigfile", "pyrsa-keygen": "rsa.cli:keygen", "pyrsa-encrypt-bigfile": "rsa.cli:encrypt_bigfile", "pyrsa-sign": "rsa.cli:sign", "pyrsa-priv2pub": "rsa.util:private_to_public", "pyrsa-encrypt": "rsa.cli:encrypt", "pyrsa-decrypt": "rsa.cli:decrypt", "pyrsa-verify": "rsa.cli:verify"}}}}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/local/lib/python2.7/dist-packages/rsa-3.3.dist-info/top_level.txt                               0100644 0000000 0000062 00000000004 13077704374 023736  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        rsa
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/local/lib/python2.7/dist-packages/s3transfer/                                                   0042755 0000000 0000062 00000000000 13077704403 020321  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/s3transfer/__init__.py                                        0100644 0000000 0000062 00000066550 13077704375 022451  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
"""Abstractions over S3's upload/download operations.

This module provides high level abstractions for efficient
uploads/downloads.  It handles several things for the user:

* Automatically switching to multipart transfers when
  a file is over a specific size threshold
* Uploading/downloading a file in parallel
* Throttling based on max bandwidth
* Progress callbacks to monitor transfers
* Retries.  While botocore handles retries for streaming uploads,
  it is not possible for it to handle retries for streaming
  downloads.  This module handles retries for both cases so
  you don't need to implement any retry logic yourself.

This module has a reasonable set of defaults.  It also allows you
to configure many aspects of the transfer process including:

* Multipart threshold size
* Max parallel downloads
* Max bandwidth
* Socket timeouts
* Retry amounts

There is no support for s3->s3 multipart copies at this
time.


.. _ref_s3transfer_usage:

Usage
=====

The simplest way to use this module is:

.. code-block:: python

    client = boto3.client('s3', 'us-west-2')
    transfer = S3Transfer(client)
    # Upload /tmp/myfile to s3://bucket/key
    transfer.upload_file('/tmp/myfile', 'bucket', 'key')

    # Download s3://bucket/key to /tmp/myfile
    transfer.download_file('bucket', 'key', '/tmp/myfile')

The ``upload_file`` and ``download_file`` methods also accept
``**kwargs``, which will be forwarded through to the corresponding
client operation.  Here are a few examples using ``upload_file``::

    # Making the object public
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         extra_args={'ACL': 'public-read'})

    # Setting metadata
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         extra_args={'Metadata': {'a': 'b', 'c': 'd'}})

    # Setting content type
    transfer.upload_file('/tmp/myfile.json', 'bucket', 'key',
                         extra_args={'ContentType': "application/json"})


The ``S3Transfer`` clas also supports progress callbacks so you can
provide transfer progress to users.  Both the ``upload_file`` and
``download_file`` methods take an optional ``callback`` parameter.
Here's an example of how to print a simple progress percentage
to the user:

.. code-block:: python

    class ProgressPercentage(object):
        def __init__(self, filename):
            self._filename = filename
            self._size = float(os.path.getsize(filename))
            self._seen_so_far = 0
            self._lock = threading.Lock()

        def __call__(self, bytes_amount):
            # To simplify we'll assume this is hooked up
            # to a single filename.
            with self._lock:
                self._seen_so_far += bytes_amount
                percentage = (self._seen_so_far / self._size) * 100
                sys.stdout.write(
                    "\r%s  %s / %s  (%.2f%%)" % (self._filename, self._seen_so_far,
                                                 self._size, percentage))
                sys.stdout.flush()


    transfer = S3Transfer(boto3.client('s3', 'us-west-2'))
    # Upload /tmp/myfile to s3://bucket/key and print upload progress.
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         callback=ProgressPercentage('/tmp/myfile'))



You can also provide a TransferConfig object to the S3Transfer
object that gives you more fine grained control over the
transfer.  For example:

.. code-block:: python

    client = boto3.client('s3', 'us-west-2')
    config = TransferConfig(
        multipart_threshold=8 * 1024 * 1024,
        max_concurrency=10,
        num_download_attempts=10,
    )
    transfer = S3Transfer(client, config)
    transfer.upload_file('/tmp/foo', 'bucket', 'key')


"""
import os
import math
import functools
import logging
import socket
import threading
import random
import string
from concurrent import futures

from botocore.compat import six
from botocore.vendored.requests.packages.urllib3.exceptions import \
    ReadTimeoutError
from botocore.exceptions import IncompleteReadError

import s3transfer.compat
from s3transfer.exceptions import RetriesExceededError, S3UploadFailedError


__author__ = 'Amazon Web Services'
__version__ = '0.0.1'

logger = logging.getLogger(__name__)
queue = six.moves.queue

MB = 1024 * 1024
SHUTDOWN_SENTINEL = object()


def random_file_extension(num_digits=8):
    return ''.join(random.choice(string.hexdigits) for _ in range(num_digits))


def disable_upload_callbacks(request, operation_name, **kwargs):
    if operation_name in ['PutObject', 'UploadPart'] and \
            hasattr(request.body, 'disable_callback'):
        request.body.disable_callback()


def enable_upload_callbacks(request, operation_name, **kwargs):
    if operation_name in ['PutObject', 'UploadPart'] and \
            hasattr(request.body, 'enable_callback'):
        request.body.enable_callback()


class QueueShutdownError(Exception):
    pass


class ReadFileChunk(object):
    def __init__(self, fileobj, start_byte, chunk_size, full_file_size,
                 callback=None, enable_callback=True):
        """

        Given a file object shown below:

            |___________________________________________________|
            0          |                 |                 full_file_size
                       |----chunk_size---|
                 start_byte

        :type fileobj: file
        :param fileobj: File like object

        :type start_byte: int
        :param start_byte: The first byte from which to start reading.

        :type chunk_size: int
        :param chunk_size: The max chunk size to read.  Trying to read
            pass the end of the chunk size will behave like you've
            reached the end of the file.

        :type full_file_size: int
        :param full_file_size: The entire content length associated
            with ``fileobj``.

        :type callback: function(amount_read)
        :param callback: Called whenever data is read from this object.

        """
        self._fileobj = fileobj
        self._start_byte = start_byte
        self._size = self._calculate_file_size(
            self._fileobj, requested_size=chunk_size,
            start_byte=start_byte, actual_file_size=full_file_size)
        self._fileobj.seek(self._start_byte)
        self._amount_read = 0
        self._callback = callback
        self._callback_enabled = enable_callback

    @classmethod
    def from_filename(cls, filename, start_byte, chunk_size, callback=None,
                      enable_callback=True):
        """Convenience factory function to create from a filename.

        :type start_byte: int
        :param start_byte: The first byte from which to start reading.

        :type chunk_size: int
        :param chunk_size: The max chunk size to read.  Trying to read
            pass the end of the chunk size will behave like you've
            reached the end of the file.

        :type full_file_size: int
        :param full_file_size: The entire content length associated
            with ``fileobj``.

        :type callback: function(amount_read)
        :param callback: Called whenever data is read from this object.

        :type enable_callback: bool
        :param enable_callback: Indicate whether to invoke callback
            during read() calls.

        :rtype: ``ReadFileChunk``
        :return: A new instance of ``ReadFileChunk``

        """
        f = open(filename, 'rb')
        file_size = os.fstat(f.fileno()).st_size
        return cls(f, start_byte, chunk_size, file_size, callback,
                   enable_callback)

    def _calculate_file_size(self, fileobj, requested_size, start_byte,
                             actual_file_size):
        max_chunk_size = actual_file_size - start_byte
        return min(max_chunk_size, requested_size)

    def read(self, amount=None):
        if amount is None:
            amount_to_read = self._size - self._amount_read
        else:
            amount_to_read = min(self._size - self._amount_read, amount)
        data = self._fileobj.read(amount_to_read)
        self._amount_read += len(data)
        if self._callback is not None and self._callback_enabled:
            self._callback(len(data))
        return data

    def enable_callback(self):
        self._callback_enabled = True

    def disable_callback(self):
        self._callback_enabled = False

    def seek(self, where):
        self._fileobj.seek(self._start_byte + where)
        if self._callback is not None and self._callback_enabled:
            # To also rewind the callback() for an accurate progress report
            self._callback(where - self._amount_read)
        self._amount_read = where

    def close(self):
        self._fileobj.close()

    def tell(self):
        return self._amount_read

    def __len__(self):
        # __len__ is defined because requests will try to determine the length
        # of the stream to set a content length.  In the normal case
        # of the file it will just stat the file, but we need to change that
        # behavior.  By providing a __len__, requests will use that instead
        # of stat'ing the file.
        return self._size

    def __enter__(self):
        return self

    def __exit__(self, *args, **kwargs):
        self.close()

    def __iter__(self):
        # This is a workaround for http://bugs.python.org/issue17575
        # Basically httplib will try to iterate over the contents, even
        # if its a file like object.  This wasn't noticed because we've
        # already exhausted the stream so iterating over the file immediately
        # stops, which is what we're simulating here.
        return iter([])


class StreamReaderProgress(object):
    """Wrapper for a read only stream that adds progress callbacks."""
    def __init__(self, stream, callback=None):
        self._stream = stream
        self._callback = callback

    def read(self, *args, **kwargs):
        value = self._stream.read(*args, **kwargs)
        if self._callback is not None:
            self._callback(len(value))
        return value


class OSUtils(object):
    def get_file_size(self, filename):
        return os.path.getsize(filename)

    def open_file_chunk_reader(self, filename, start_byte, size, callback):
        return ReadFileChunk.from_filename(filename, start_byte,
                                           size, callback,
                                           enable_callback=False)

    def open(self, filename, mode):
        return open(filename, mode)

    def remove_file(self, filename):
        """Remove a file, noop if file does not exist."""
        # Unlike os.remove, if the file does not exist,
        # then this method does nothing.
        try:
            os.remove(filename)
        except OSError:
            pass

    def rename_file(self, current_filename, new_filename):
        s3transfer.compat.rename_file(current_filename, new_filename)


class MultipartUploader(object):
    # These are the extra_args that need to be forwarded onto
    # subsequent upload_parts.
    UPLOAD_PART_ARGS = [
        'SSECustomerKey',
        'SSECustomerAlgorithm',
        'SSECustomerKeyMD5',
        'RequestPayer',
    ]

    def __init__(self, client, config, osutil,
                 executor_cls=futures.ThreadPoolExecutor):
        self._client = client
        self._config = config
        self._os = osutil
        self._executor_cls = executor_cls

    def _extra_upload_part_args(self, extra_args):
        # Only the args in UPLOAD_PART_ARGS actually need to be passed
        # onto the upload_part calls.
        upload_parts_args = {}
        for key, value in extra_args.items():
            if key in self.UPLOAD_PART_ARGS:
                upload_parts_args[key] = value
        return upload_parts_args

    def upload_file(self, filename, bucket, key, callback, extra_args):
        response = self._client.create_multipart_upload(Bucket=bucket,
                                                        Key=key, **extra_args)
        upload_id = response['UploadId']
        try:
            parts = self._upload_parts(upload_id, filename, bucket, key,
                                       callback, extra_args)
        except Exception as e:
            logger.debug("Exception raised while uploading parts, "
                         "aborting multipart upload.", exc_info=True)
            self._client.abort_multipart_upload(
                Bucket=bucket, Key=key, UploadId=upload_id)
            raise S3UploadFailedError(
                "Failed to upload %s to %s: %s" % (
                    filename, '/'.join([bucket, key]), e))
        self._client.complete_multipart_upload(
            Bucket=bucket, Key=key, UploadId=upload_id,
            MultipartUpload={'Parts': parts})

    def _upload_parts(self, upload_id, filename, bucket, key, callback,
                      extra_args):
        upload_parts_extra_args = self._extra_upload_part_args(extra_args)
        parts = []
        part_size = self._config.multipart_chunksize
        num_parts = int(
            math.ceil(self._os.get_file_size(filename) / float(part_size)))
        max_workers = self._config.max_concurrency
        with self._executor_cls(max_workers=max_workers) as executor:
            upload_partial = functools.partial(
                self._upload_one_part, filename, bucket, key, upload_id,
                part_size, upload_parts_extra_args, callback)
            for part in executor.map(upload_partial, range(1, num_parts + 1)):
                parts.append(part)
        return parts

    def _upload_one_part(self, filename, bucket, key,
                         upload_id, part_size, extra_args,
                         callback, part_number):
        open_chunk_reader = self._os.open_file_chunk_reader
        with open_chunk_reader(filename, part_size * (part_number - 1),
                               part_size, callback) as body:
            response = self._client.upload_part(
                Bucket=bucket, Key=key,
                UploadId=upload_id, PartNumber=part_number, Body=body,
                **extra_args)
            etag = response['ETag']
            return {'ETag': etag, 'PartNumber': part_number}


class ShutdownQueue(queue.Queue):
    """A queue implementation that can be shutdown.

    Shutting down a queue means that this class adds a
    trigger_shutdown method that will trigger all subsequent
    calls to put() to fail with a ``QueueShutdownError``.

    It purposefully deviates from queue.Queue, and is *not* meant
    to be a drop in replacement for ``queue.Queue``.

    """
    def _init(self, maxsize):
        self._shutdown = False
        self._shutdown_lock = threading.Lock()
        # queue.Queue is an old style class so we don't use super().
        return queue.Queue._init(self, maxsize)

    def trigger_shutdown(self):
        with self._shutdown_lock:
            self._shutdown = True
            logger.debug("The IO queue is now shutdown.")

    def put(self, item):
        # Note: this is not sufficient, it's still possible to deadlock!
        # Need to hook into the condition vars used by this class.
        with self._shutdown_lock:
            if self._shutdown:
                raise QueueShutdownError("Cannot put item to queue when "
                                         "queue has been shutdown.")
        return queue.Queue.put(self, item)


class MultipartDownloader(object):
    def __init__(self, client, config, osutil,
                 executor_cls=futures.ThreadPoolExecutor):
        self._client = client
        self._config = config
        self._os = osutil
        self._executor_cls = executor_cls
        self._ioqueue = ShutdownQueue(self._config.max_io_queue)

    def download_file(self, bucket, key, filename, object_size,
                      extra_args, callback=None):
        with self._executor_cls(max_workers=2) as controller:
            # 1 thread for the future that manages the uploading of files
            # 1 thread for the future that manages IO writes.
            download_parts_handler = functools.partial(
                self._download_file_as_future,
                bucket, key, filename, object_size, callback)
            parts_future = controller.submit(download_parts_handler)

            io_writes_handler = functools.partial(
                self._perform_io_writes, filename)
            io_future = controller.submit(io_writes_handler)
            results = futures.wait([parts_future, io_future],
                                   return_when=futures.FIRST_EXCEPTION)
            self._process_future_results(results)

    def _process_future_results(self, futures):
        finished, unfinished = futures
        for future in finished:
            future.result()

    def _download_file_as_future(self, bucket, key, filename, object_size,
                                 callback):
        part_size = self._config.multipart_chunksize
        num_parts = int(math.ceil(object_size / float(part_size)))
        max_workers = self._config.max_concurrency
        download_partial = functools.partial(
            self._download_range, bucket, key, filename,
            part_size, num_parts, callback)
        try:
            with self._executor_cls(max_workers=max_workers) as executor:
                list(executor.map(download_partial, range(num_parts)))
        finally:
            self._ioqueue.put(SHUTDOWN_SENTINEL)

    def _calculate_range_param(self, part_size, part_index, num_parts):
        start_range = part_index * part_size
        if part_index == num_parts - 1:
            end_range = ''
        else:
            end_range = start_range + part_size - 1
        range_param = 'bytes=%s-%s' % (start_range, end_range)
        return range_param

    def _download_range(self, bucket, key, filename,
                        part_size, num_parts, callback, part_index):
        try:
            range_param = self._calculate_range_param(
                part_size, part_index, num_parts)

            max_attempts = self._config.num_download_attempts
            last_exception = None
            for i in range(max_attempts):
                try:
                    logger.debug("Making get_object call.")
                    response = self._client.get_object(
                        Bucket=bucket, Key=key, Range=range_param)
                    streaming_body = StreamReaderProgress(
                        response['Body'], callback)
                    buffer_size = 1024 * 16
                    current_index = part_size * part_index
                    for chunk in iter(lambda: streaming_body.read(buffer_size),
                                      b''):
                        self._ioqueue.put((current_index, chunk))
                        current_index += len(chunk)
                    return
                except (socket.timeout, socket.error,
                        ReadTimeoutError, IncompleteReadError) as e:
                    logger.debug("Retrying exception caught (%s), "
                                 "retrying request, (attempt %s / %s)", e, i,
                                 max_attempts, exc_info=True)
                    last_exception = e
                    continue
            raise RetriesExceededError(last_exception)
        finally:
            logger.debug("EXITING _download_range for part: %s", part_index)

    def _perform_io_writes(self, filename):
        with self._os.open(filename, 'wb') as f:
            while True:
                task = self._ioqueue.get()
                if task is SHUTDOWN_SENTINEL:
                    logger.debug("Shutdown sentinel received in IO handler, "
                                 "shutting down IO handler.")
                    return
                else:
                    try:
                        offset, data = task
                        f.seek(offset)
                        f.write(data)
                    except Exception as e:
                        logger.debug("Caught exception in IO thread: %s",
                                     e, exc_info=True)
                        self._ioqueue.trigger_shutdown()
                        raise


class TransferConfig(object):
    def __init__(self,
                 multipart_threshold=8 * MB,
                 max_concurrency=10,
                 multipart_chunksize=8 * MB,
                 num_download_attempts=5,
                 max_io_queue=100):
        self.multipart_threshold = multipart_threshold
        self.max_concurrency = max_concurrency
        self.multipart_chunksize = multipart_chunksize
        self.num_download_attempts = num_download_attempts
        self.max_io_queue = max_io_queue


class S3Transfer(object):

    ALLOWED_DOWNLOAD_ARGS = [
        'VersionId',
        'SSECustomerAlgorithm',
        'SSECustomerKey',
        'SSECustomerKeyMD5',
        'RequestPayer',
    ]

    ALLOWED_UPLOAD_ARGS = [
        'ACL',
        'CacheControl',
        'ContentDisposition',
        'ContentEncoding',
        'ContentLanguage',
        'ContentType',
        'Expires',
        'GrantFullControl',
        'GrantRead',
        'GrantReadACP',
        'GrantWriteACL',
        'Metadata',
        'RequestPayer',
        'ServerSideEncryption',
        'StorageClass',
        'SSECustomerAlgorithm',
        'SSECustomerKey',
        'SSECustomerKeyMD5',
        'SSEKMSKeyId',
    ]

    def __init__(self, client, config=None, osutil=None):
        self._client = client
        if config is None:
            config = TransferConfig()
        self._config = config
        if osutil is None:
            osutil = OSUtils()
        self._osutil = osutil

    def upload_file(self, filename, bucket, key,
                    callback=None, extra_args=None):
        """Upload a file to an S3 object.

        Variants have also been injected into S3 client, Bucket and Object.
        You don't have to use S3Transfer.upload_file() directly.
        """
        if extra_args is None:
            extra_args = {}
        self._validate_all_known_args(extra_args, self.ALLOWED_UPLOAD_ARGS)
        events = self._client.meta.events
        events.register_first('request-created.s3',
                              disable_upload_callbacks,
                              unique_id='s3upload-callback-disable')
        events.register_last('request-created.s3',
                             enable_upload_callbacks,
                             unique_id='s3upload-callback-enable')
        if self._osutil.get_file_size(filename) >= \
                self._config.multipart_threshold:
            self._multipart_upload(filename, bucket, key, callback, extra_args)
        else:
            self._put_object(filename, bucket, key, callback, extra_args)

    def _put_object(self, filename, bucket, key, callback, extra_args):
        # We're using open_file_chunk_reader so we can take advantage of the
        # progress callback functionality.
        open_chunk_reader = self._osutil.open_file_chunk_reader
        with open_chunk_reader(filename, 0,
                               self._osutil.get_file_size(filename),
                               callback=callback) as body:
            self._client.put_object(Bucket=bucket, Key=key, Body=body,
                                    **extra_args)

    def download_file(self, bucket, key, filename, extra_args=None,
                      callback=None):
        """Download an S3 object to a file.

        Variants have also been injected into S3 client, Bucket and Object.
        You don't have to use S3Transfer.download_file() directly.
        """
        # This method will issue a ``head_object`` request to determine
        # the size of the S3 object.  This is used to determine if the
        # object is downloaded in parallel.
        if extra_args is None:
            extra_args = {}
        self._validate_all_known_args(extra_args, self.ALLOWED_DOWNLOAD_ARGS)
        object_size = self._object_size(bucket, key, extra_args)
        temp_filename = filename + os.extsep + random_file_extension()
        try:
            self._download_file(bucket, key, temp_filename, object_size,
                                extra_args, callback)
        except Exception:
            logger.debug("Exception caught in download_file, removing partial "
                         "file: %s", temp_filename, exc_info=True)
            self._osutil.remove_file(temp_filename)
            raise
        else:
            self._osutil.rename_file(temp_filename, filename)

    def _download_file(self, bucket, key, filename, object_size,
                       extra_args, callback):
        if object_size >= self._config.multipart_threshold:
            self._ranged_download(bucket, key, filename, object_size,
                                  extra_args, callback)
        else:
            self._get_object(bucket, key, filename, extra_args, callback)

    def _validate_all_known_args(self, actual, allowed):
        for kwarg in actual:
            if kwarg not in allowed:
                raise ValueError(
                    "Invalid extra_args key '%s', "
                    "must be one of: %s" % (
                        kwarg, ', '.join(allowed)))

    def _ranged_download(self, bucket, key, filename, object_size,
                         extra_args, callback):
        downloader = MultipartDownloader(self._client, self._config,
                                         self._osutil)
        downloader.download_file(bucket, key, filename, object_size,
                                 extra_args, callback)

    def _get_object(self, bucket, key, filename, extra_args, callback):
        # precondition: num_download_attempts > 0
        max_attempts = self._config.num_download_attempts
        last_exception = None
        for i in range(max_attempts):
            try:
                return self._do_get_object(bucket, key, filename,
                                           extra_args, callback)
            except (socket.timeout, socket.error,
                    ReadTimeoutError, IncompleteReadError) as e:
                # TODO: we need a way to reset the callback if the
                # download failed.
                logger.debug("Retrying exception caught (%s), "
                             "retrying request, (attempt %s / %s)", e, i,
                             max_attempts, exc_info=True)
                last_exception = e
                continue
        raise RetriesExceededError(last_exception)

    def _do_get_object(self, bucket, key, filename, extra_args, callback):
        response = self._client.get_object(Bucket=bucket, Key=key,
                                           **extra_args)
        streaming_body = StreamReaderProgress(
            response['Body'], callback)
        with self._osutil.open(filename, 'wb') as f:
            for chunk in iter(lambda: streaming_body.read(8192), b''):
                f.write(chunk)

    def _object_size(self, bucket, key, extra_args):
        return self._client.head_object(
            Bucket=bucket, Key=key, **extra_args)['ContentLength']

    def _multipart_upload(self, filename, bucket, key, callback, extra_args):
        uploader = MultipartUploader(self._client, self._config, self._osutil)
        uploader.upload_file(filename, bucket, key, callback, extra_args)
                                                                                                                                                        usr/local/lib/python2.7/dist-packages/s3transfer/__init__.pyc                                       0100644 0000000 0000062 00000066117 13077704403 022603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
˝àˇXc           @   sÈ  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 m
 Z
 d d l m Z d d l m Z d d l m Z d d l Z d d l m Z m Z d Z d	 Z e j e É Z e j j Z d! Z e É  Z d d Ñ Z  d Ñ  Z! d Ñ  Z" d e# f d Ñ  É  YZ$ d e f d Ñ  É  YZ% d e f d Ñ  É  YZ& d e f d Ñ  É  YZ' d e f d Ñ  É  YZ( d e j) f d Ñ  É  YZ* d e f d Ñ  É  YZ+ d e f d Ñ  É  YZ, d e f d  Ñ  É  YZ- d S("   s≠  Abstractions over S3's upload/download operations.

This module provides high level abstractions for efficient
uploads/downloads.  It handles several things for the user:

* Automatically switching to multipart transfers when
  a file is over a specific size threshold
* Uploading/downloading a file in parallel
* Throttling based on max bandwidth
* Progress callbacks to monitor transfers
* Retries.  While botocore handles retries for streaming uploads,
  it is not possible for it to handle retries for streaming
  downloads.  This module handles retries for both cases so
  you don't need to implement any retry logic yourself.

This module has a reasonable set of defaults.  It also allows you
to configure many aspects of the transfer process including:

* Multipart threshold size
* Max parallel downloads
* Max bandwidth
* Socket timeouts
* Retry amounts

There is no support for s3->s3 multipart copies at this
time.


.. _ref_s3transfer_usage:

Usage
=====

The simplest way to use this module is:

.. code-block:: python

    client = boto3.client('s3', 'us-west-2')
    transfer = S3Transfer(client)
    # Upload /tmp/myfile to s3://bucket/key
    transfer.upload_file('/tmp/myfile', 'bucket', 'key')

    # Download s3://bucket/key to /tmp/myfile
    transfer.download_file('bucket', 'key', '/tmp/myfile')

The ``upload_file`` and ``download_file`` methods also accept
``**kwargs``, which will be forwarded through to the corresponding
client operation.  Here are a few examples using ``upload_file``::

    # Making the object public
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         extra_args={'ACL': 'public-read'})

    # Setting metadata
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         extra_args={'Metadata': {'a': 'b', 'c': 'd'}})

    # Setting content type
    transfer.upload_file('/tmp/myfile.json', 'bucket', 'key',
                         extra_args={'ContentType': "application/json"})


The ``S3Transfer`` clas also supports progress callbacks so you can
provide transfer progress to users.  Both the ``upload_file`` and
``download_file`` methods take an optional ``callback`` parameter.
Here's an example of how to print a simple progress percentage
to the user:

.. code-block:: python

    class ProgressPercentage(object):
        def __init__(self, filename):
            self._filename = filename
            self._size = float(os.path.getsize(filename))
            self._seen_so_far = 0
            self._lock = threading.Lock()

        def __call__(self, bytes_amount):
            # To simplify we'll assume this is hooked up
            # to a single filename.
            with self._lock:
                self._seen_so_far += bytes_amount
                percentage = (self._seen_so_far / self._size) * 100
                sys.stdout.write(
                    "%s  %s / %s  (%.2f%%)" % (self._filename, self._seen_so_far,
                                                 self._size, percentage))
                sys.stdout.flush()


    transfer = S3Transfer(boto3.client('s3', 'us-west-2'))
    # Upload /tmp/myfile to s3://bucket/key and print upload progress.
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         callback=ProgressPercentage('/tmp/myfile'))



You can also provide a TransferConfig object to the S3Transfer
object that gives you more fine grained control over the
transfer.  For example:

.. code-block:: python

    client = boto3.client('s3', 'us-west-2')
    config = TransferConfig(
        multipart_threshold=8 * 1024 * 1024,
        max_concurrency=10,
        num_download_attempts=10,
    )
    transfer = S3Transfer(client, config)
    transfer.upload_file('/tmp/foo', 'bucket', 'key')


iˇˇˇˇN(   t   futures(   t   six(   t   ReadTimeoutError(   t   IncompleteReadError(   t   RetriesExceededErrort   S3UploadFailedErrors   Amazon Web Servicess   0.0.1i   i   c         C   s   d j  d Ñ  t |  É DÉ É S(   Nt    c         s   s!   |  ] } t  j t j É Vq d  S(   N(   t   randomt   choicet   stringt	   hexdigits(   t   .0t   _(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pys	   <genexpr>ú   s    (   t   joint   range(   t
   num_digits(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   random_file_extensionõ   s    c         K   s2   | d k r. t  |  j d É r. |  j j É  n  d  S(   Nt	   PutObjectt
   UploadPartt   disable_callback(   R   R   (   t   hasattrt   bodyR   (   t   requestt   operation_namet   kwargs(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   disable_upload_callbacksü   s    c         K   s2   | d k r. t  |  j d É r. |  j j É  n  d  S(   NR   R   t   enable_callback(   s	   PutObjects
   UploadPart(   R   R   R   (   R   R   R   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   enable_upload_callbacks•   s    t   QueueShutdownErrorc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR   ´   s   t   ReadFileChunkc           B   sí   e  Z d e d  Ñ Z e d e d Ñ É Z d Ñ  Z d d Ñ Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sk   | |  _  | |  _ |  j |  j  d | d | d | É|  _ |  j  j |  j É d |  _ | |  _ | |  _ d S(   sÇ  

        Given a file object shown below:

            |___________________________________________________|
            0          |                 |                 full_file_size
                       |----chunk_size---|
                 start_byte

        :type fileobj: file
        :param fileobj: File like object

        :type start_byte: int
        :param start_byte: The first byte from which to start reading.

        :type chunk_size: int
        :param chunk_size: The max chunk size to read.  Trying to read
            pass the end of the chunk size will behave like you've
            reached the end of the file.

        :type full_file_size: int
        :param full_file_size: The entire content length associated
            with ``fileobj``.

        :type callback: function(amount_read)
        :param callback: Called whenever data is read from this object.

        t   requested_sizet
   start_bytet   actual_file_sizei    N(   t   _fileobjt   _start_bytet   _calculate_file_sizet   _sizet   seekt   _amount_readt	   _callbackt   _callback_enabled(   t   selft   fileobjR!   t
   chunk_sizet   full_file_sizet   callbackR   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   __init__∞   s    				c         C   s@   t  | d É } t j | j É  É j } |  | | | | | | É S(   sW  Convenience factory function to create from a filename.

        :type start_byte: int
        :param start_byte: The first byte from which to start reading.

        :type chunk_size: int
        :param chunk_size: The max chunk size to read.  Trying to read
            pass the end of the chunk size will behave like you've
            reached the end of the file.

        :type full_file_size: int
        :param full_file_size: The entire content length associated
            with ``fileobj``.

        :type callback: function(amount_read)
        :param callback: Called whenever data is read from this object.

        :type enable_callback: bool
        :param enable_callback: Indicate whether to invoke callback
            during read() calls.

        :rtype: ``ReadFileChunk``
        :return: A new instance of ``ReadFileChunk``

        t   rb(   t   opent   ost   fstatt   filenot   st_size(   t   clst   filenameR!   R-   R/   R   t   ft	   file_size(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   from_filenameÿ   s    c         C   s   | | } t  | | É S(   N(   t   min(   R+   R,   R    R!   R"   t   max_chunk_size(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR%   ˘   s    
c         C   së   | d  k r |  j |  j } n t |  j |  j | É } |  j j | É } |  j t | É 7_ |  j d  k	 rç |  j rç |  j t | É É n  | S(   N(	   t   NoneR&   R(   R<   R#   t   readt   lenR)   R*   (   R+   t   amountt   amount_to_readt   data(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR?   ˛   s    c         C   s   t  |  _ d  S(   N(   t   TrueR*   (   R+   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR   	  s    c         C   s   t  |  _ d  S(   N(   t   FalseR*   (   R+   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR     s    c         C   sS   |  j  j |  j | É |  j d  k	 rF |  j rF |  j | |  j É n  | |  _ d  S(   N(   R#   R'   R$   R)   R>   R*   R(   (   R+   t   where(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR'     s    c         C   s   |  j  j É  d  S(   N(   R#   t   close(   R+   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyRG     s    c         C   s   |  j  S(   N(   R(   (   R+   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   tell  s    c         C   s   |  j  S(   N(   R&   (   R+   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   __len__  s    c         C   s   |  S(   N(    (   R+   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt	   __enter__$  s    c         O   s   |  j  É  d  S(   N(   RG   (   R+   t   argsR   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   __exit__'  s    c         C   s
   t  g  É S(   N(   t   iter(   R+   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   __iter__*  s    N(   R   R   R>   RD   R0   t   classmethodR;   R%   R?   R   R   R'   RG   RH   RI   RJ   RL   RN   (    (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR   Ø   s   '									t   StreamReaderProgressc           B   s#   e  Z d  Z d d Ñ Z d Ñ  Z RS(   s<   Wrapper for a read only stream that adds progress callbacks.c         C   s   | |  _  | |  _ d  S(   N(   t   _streamR)   (   R+   t   streamR/   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR0   5  s    	c         O   s>   |  j  j | | é  } |  j d  k	 r: |  j t | É É n  | S(   N(   RQ   R?   R)   R>   R@   (   R+   RK   R   t   value(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR?   9  s    N(   R   R   t   __doc__R>   R0   R?   (    (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyRP   3  s   t   OSUtilsc           B   s5   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   t  j j | É S(   N(   R3   t   patht   getsize(   R+   R8   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   get_file_sizeA  s    c         C   s   t  j | | | | d t ÉS(   NR   (   R   R;   RE   (   R+   R8   R!   t   sizeR/   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   open_file_chunk_readerD  s    	c         C   s   t  | | É S(   N(   R2   (   R+   R8   t   mode(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR2   I  s    c         C   s)   y t  j | É Wn t k
 r$ n Xd S(   s+   Remove a file, noop if file does not exist.N(   R3   t   removet   OSError(   R+   R8   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   remove_fileL  s    c         C   s   t  j j | | É d  S(   N(   t
   s3transfert   compatt   rename_file(   R+   t   current_filenamet   new_filename(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyRa   U  s    (   R   R   RX   RZ   R2   R^   Ra   (    (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyRU   @  s
   					t   MultipartUploaderc           B   sM   e  Z d  d d d g Z e j d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(	   t   SSECustomerKeyt   SSECustomerAlgorithmt   SSECustomerKeyMD5t   RequestPayerc         C   s(   | |  _  | |  _ | |  _ | |  _ d  S(   N(   t   _clientt   _configt   _ost   _executor_cls(   R+   t   clientt   configt   osutilt   executor_cls(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR0   c  s    			c         C   sC   i  } x6 | j  É  D]( \ } } | |  j k r | | | <q q W| S(   N(   t   itemst   UPLOAD_PART_ARGS(   R+   t
   extra_argst   upload_parts_argst   keyRS   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   _extra_upload_part_argsj  s
    c   
      C   sÍ   |  j  j d | d | | ç } | d } y" |  j | | | | | | É } Wnm t k
 rπ }	 t j d d t É|  j  j d | d | d | É t d | d j	 | | g É |	 f É Ç n X|  j  j
 d | d | d | d i | d	 6É d  S(
   Nt   Buckett   Keyt   UploadIdsB   Exception raised while uploading parts, aborting multipart upload.t   exc_infos   Failed to upload %s to %s: %st   /t   MultipartUploadt   Parts(   Ri   t   create_multipart_uploadt   _upload_partst	   Exceptiont   loggert   debugRD   t   abort_multipart_uploadR   R   t   complete_multipart_upload(
   R+   R8   t   bucketRu   R/   Rs   t   responset	   upload_idt   partst   e(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   upload_files  s"    
&c         C   s’   |  j  | É } g  } |  j j }	 t t j |  j j | É t |	 É É É }
 |  j j	 } |  j
 d | É èe } t j |  j | | | | |	 | | É } x4 | j | t d |
 d É É D] } | j | É q¥ WWd  QX| S(   Nt   max_workersi   (   Rv   Rj   t   multipart_chunksizet   intt   matht   ceilRk   RX   t   floatt   max_concurrencyRl   t	   functoolst   partialt   _upload_one_partt   mapR   t   append(   R+   Rá   R8   RÖ   Ru   R/   Rs   t   upload_parts_extra_argsRà   t	   part_sizet	   num_partsRã   t   executort   upload_partialt   part(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR   Ü  s    (&c	         C   sÇ   |  j  j }	 |	 | | | d | | É èS }
 |  j j d | d | d | d | d |
 | ç } | d } i | d 6| d 6SWd  QXd  S(   Ni   Rw   Rx   Ry   t
   PartNumbert   Bodyt   ETag(   Rk   RZ   Ri   t   upload_part(   R+   R8   RÖ   Ru   Rá   Rò   Rs   R/   t   part_numbert   open_chunk_readerR   RÜ   t   etag(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyRî   ñ  s    	
(
   R   R   Rr   R    t   ThreadPoolExecutorR0   Rv   Rä   R   Rî   (    (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyRd   Y  s   					t   ShutdownQueuec           B   s)   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sY  A queue implementation that can be shutdown.

    Shutting down a queue means that this class adds a
    trigger_shutdown method that will trigger all subsequent
    calls to put() to fail with a ``QueueShutdownError``.

    It purposefully deviates from queue.Queue, and is *not* meant
    to be a drop in replacement for ``queue.Queue``.

    c         C   s+   t  |  _ t j É  |  _ t j j |  | É S(   N(   RE   t	   _shutdownt	   threadingt   Lockt   _shutdown_lockt   queuet   Queuet   _init(   R+   t   maxsize(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR¨   Ø  s    	c         C   s*   |  j  è t |  _ t j d É Wd  QXd  S(   Ns   The IO queue is now shutdown.(   R©   RD   R¶   RÅ   RÇ   (   R+   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   trigger_shutdownµ  s    
	c         C   s;   |  j  è |  j r" t d É Ç n  Wd  QXt j j |  | É S(   Ns6   Cannot put item to queue when queue has been shutdown.(   R©   R¶   R   R™   R´   t   put(   R+   t   item(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyRØ   ∫  s    
	(   R   R   RT   R¨   RÆ   RØ   (    (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR•   §  s   
		t   MultipartDownloaderc           B   sP   e  Z e j d  Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z RS(   c         C   s=   | |  _  | |  _ | |  _ | |  _ t |  j j É |  _ d  S(   N(   Ri   Rj   Rk   Rl   R•   t   max_io_queuet   _ioqueue(   R+   Rm   Rn   Ro   Rp   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR0   ≈  s
    				c         C   sû   |  j  d d É èÜ } t j |  j | | | | | É } | j | É }	 t j |  j | É }
 | j |
 É } t j |	 | g d t j É} |  j	 | É Wd  QXd  S(   NRã   i   t   return_when(
   Rl   Rí   Rì   t   _download_file_as_futuret   submitt   _perform_io_writesR    t   waitt   FIRST_EXCEPTIONt   _process_future_results(   R+   RÖ   Ru   R8   t   object_sizeRs   R/   t
   controllert   download_parts_handlert   parts_futuret   io_writes_handlert	   io_futuret   results(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   download_fileÕ  s    c         C   s+   | \ } } x | D] } | j  É  q Wd  S(   N(   t   result(   R+   R    t   finishedt
   unfinishedt   future(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR∫   ﬁ  s    c      	   C   sÆ   |  j  j } t t j | t | É É É } |  j  j } t j |  j	 | | | | | | É }	 z; |  j
 d | É è# }
 t |
 j |	 t | É É É Wd  QXWd  |  j j t É Xd  S(   NRã   (   Rj   Rå   Rç   Ré   Rè   Rê   Rë   Rí   Rì   t   _download_rangeRl   t   listRï   R   R≥   RØ   t   SHUTDOWN_SENTINEL(   R+   RÖ   Ru   R8   Rª   R/   Rò   Rô   Rã   t   download_partialRö   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyRµ   „  s    &c         C   sE   | | } | | d k r# d } n | | d } d | | f } | S(   Ni   R   s   bytes=%s-%s(    (   R+   Rò   t
   part_indexRô   t   start_ranget	   end_ranget   range_param(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   _calculate_range_paramÒ  s    
	c      	      sX  z@|  j  | | | É } |  j j }	 d  }
 xt |	 É D]¯ } y• t j d É |  j j d | d | d | É } t	 | d | É â d â  | | } xI t
 á  á f d Ü  d	 É D], } |  j j | | f É | t | É 7} q≠ Wd  SWq7 t j t j t t f k
 r.} t j d
 | | |	 d t É| }
 q7 q7 Xq7 Wt |
 É Ç Wd  t j d | É Xd  S(   Ns   Making get_object call.Rw   Rx   t   RangeRû   i   i   c              s   à j  à  É S(   N(   R?   (    (   t   buffer_sizet   streaming_body(    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   <lambda>  s    R   sC   Retrying exception caught (%s), retrying request, (attempt %s / %s)Rz   s$   EXITING _download_range for part: %si @  (   Rœ   Rj   t   num_download_attemptsR>   R   RÅ   RÇ   Ri   t
   get_objectRP   RM   R≥   RØ   R@   t   sockett   timeoutt   errorR   R   RD   R   (   R+   RÖ   Ru   R8   Rò   Rô   R/   RÀ   RŒ   t   max_attemptst   last_exceptiont   iRÜ   t   current_indext   chunkRâ   (    (   R—   R“   s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR«   ˙  s8    
	c      	   C   s¡   |  j  j | d É è¶ } xú t r∂ |  j j É  } | t k rM t j d É d  Sy* | \ } } | j | É | j	 | É Wq t
 k
 r≤ } t j d | d t É|  j j É  Ç  q Xq WWd  QXd  S(   Nt   wbsC   Shutdown sentinel received in IO handler, shutting down IO handler.s!   Caught exception in IO thread: %sRz   (   Rk   R2   RD   R≥   t   getR…   RÅ   RÇ   R'   t   writeRÄ   RÆ   (   R+   R8   R9   t   taskt   offsetRC   Râ   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR∑     s    		N(   R   R   R    R§   R0   R>   R¬   R∫   Rµ   Rœ   R«   R∑   (    (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR±   ƒ  s   					!t   TransferConfigc           B   s(   e  Z d  e d d  e d d d Ñ Z RS(   i   i
   i   id   c         C   s1   | |  _  | |  _ | |  _ | |  _ | |  _ d  S(   N(   t   multipart_thresholdRë   Rå   R‘   R≤   (   R+   R‰   Rë   Rå   R‘   R≤   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR0   0  s
    				(   R   R   t   MBR0   (    (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR„   /  s
   t
   S3Transferc           B   s—   e  Z d  d d d d g Z d d d d d	 d
 d d d d d d d d d d d d d g Z d d d Ñ Z d d d Ñ Z d Ñ  Z d d d Ñ Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(    t	   VersionIdRf   Re   Rg   Rh   t   ACLt   CacheControlt   ContentDispositiont   ContentEncodingt   ContentLanguaget   ContentTypet   Expirest   GrantFullControlt	   GrantReadt   GrantReadACPt   GrantWriteACLt   Metadatat   ServerSideEncryptiont   StorageClasst   SSEKMSKeyIdc         C   sO   | |  _  | d  k r! t É  } n  | |  _ | d  k rB t É  } n  | |  _ d  S(   N(   Ri   R>   R„   Rj   RU   t   _osutil(   R+   Rm   Rn   Ro   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR0   ]  s    		c         C   s∫   | d k r i  } n  |  j | |  j É |  j j j } | j d t d d É| j d t	 d d É|  j
 j | É |  j j k rù |  j | | | | | É n |  j | | | | | É d S(   sµ   Upload a file to an S3 object.

        Variants have also been injected into S3 client, Bucket and Object.
        You don't have to use S3Transfer.upload_file() directly.
        s   request-created.s3t	   unique_ids   s3upload-callback-disables   s3upload-callback-enableN(   R>   t   _validate_all_known_argst   ALLOWED_UPLOAD_ARGSRi   t   metat   eventst   register_firstR   t   register_lastR   R˜   RX   Rj   R‰   t   _multipart_uploadt   _put_object(   R+   R8   RÖ   Ru   R/   Rs   R¸   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyRä   f  s    			c         C   s_   |  j  j } | | d |  j  j | É d | Éè) } |  j j d | d | d | | ç Wd  QXd  S(   Ni    R/   Rw   Rx   Rû   (   R˜   RZ   RX   Ri   t
   put_object(   R+   R8   RÖ   Ru   R/   Rs   R¢   R   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR   }  s    	c         C   s≈   | d k r i  } n  |  j | |  j É |  j | | | É } | t j t É  } y  |  j | | | | | | É Wn: t k
 r≠ t	 j
 d | d t É|  j j | É Ç  n X|  j j | | É d S(   sπ   Download an S3 object to a file.

        Variants have also been injected into S3 client, Bucket and Object.
        You don't have to use S3Transfer.download_file() directly.
        s<   Exception caught in download_file, removing partial file: %sRz   N(   R>   R˘   t   ALLOWED_DOWNLOAD_ARGSt   _object_sizeR3   t   extsepR   t   _download_fileRÄ   RÅ   RÇ   RD   R˜   R^   Ra   (   R+   RÖ   Ru   R8   Rs   R/   Rª   t   temp_filename(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR¬   á  s    
		c         C   sN   | |  j  j k r1 |  j | | | | | | É n |  j | | | | | É d  S(   N(   Rj   R‰   t   _ranged_downloadt   _get_object(   R+   RÖ   Ru   R8   Rª   Rs   R/   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR  °  s    c         C   sC   x< | D]4 } | | k r t  d | d j | É f É Ç q q Wd  S(   Ns/   Invalid extra_args key '%s', must be one of: %ss   , (   t
   ValueErrorR   (   R+   t   actualt   allowedt   kwarg(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR˘   ©  s
    c         C   s;   t  |  j |  j |  j É } | j | | | | | | É d  S(   N(   R±   Ri   Rj   R˜   R¬   (   R+   RÖ   Ru   R8   Rª   Rs   R/   t
   downloader(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR  ±  s    c   
   	   C   s£   |  j  j } d  } x~ t | É D]p } y |  j | | | | | É SWq t j t j t t	 f k
 ré }	 t
 j d |	 | | d t É|	 } q q Xq Wt | É Ç d  S(   NsC   Retrying exception caught (%s), retrying request, (attempt %s / %s)Rz   (   Rj   R‘   R>   R   t   _do_get_objectR÷   R◊   Rÿ   R   R   RÅ   RÇ   RD   R   (
   R+   RÖ   Ru   R8   Rs   R/   RŸ   R⁄   R€   Râ   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR  ∏  s    	c   	         sÉ   |  j  j d | d | | ç } t | d | É â  |  j j | d É è7 } x- t á  f d Ü  d É D] } | j | É qb WWd  QXd  S(   NRw   Rx   Rû   Rﬁ   c              s   à  j  d É S(   Ni    (   R?   (    (   R“   (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR”   —  s    R   (   Ri   R’   RP   R˜   R2   RM   R‡   (	   R+   RÖ   Ru   R8   Rs   R/   RÜ   R9   R›   (    (   R“   s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR  À  s    	c         C   s    |  j  j d | d | | ç d S(   NRw   Rx   t   ContentLength(   Ri   t   head_object(   R+   RÖ   Ru   Rs   (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyR  ‘  s    c         C   s8   t  |  j |  j |  j É } | j | | | | | É d  S(   N(   Rd   Ri   Rj   R˜   Rä   (   R+   R8   RÖ   Ru   R/   Rs   t   uploader(    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyRˇ   ÿ  s    N(   R   R   R  R˙   R>   R0   Rä   R   R¬   R  R˘   R  R  R  R  Rˇ   (    (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyRÊ   =  sH   		
	
							i   (.   RT   R3   Ré   Rí   t   loggingR÷   Rß   R   R	   t
   concurrentR    t   botocore.compatR   t6   botocore.vendored.requests.packages.urllib3.exceptionsR   t   botocore.exceptionsR   t   s3transfer.compatR_   t   s3transfer.exceptionsR   R   t
   __author__t   __version__t	   getLoggerR   RÅ   t   movesR™   RÂ   t   objectR…   R   R   R   RÄ   R   R   RP   RU   Rd   R´   R•   R±   R„   RÊ   (    (    (    s7   /tmp/pip-build-awuatQ/s3transfer/s3transfer/__init__.pyt   <module>}   s@   			ÑK k                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/local/lib/python2.7/dist-packages/s3transfer/compat.py                                          0100644 0000000 0000062 00000002152 13077704375 022161  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import sys
import os
import errno


if sys.platform.startswith('win'):
    def rename_file(current_filename, new_filename):
        try:
            os.remove(new_filename)
        except OSError as e:
            if not e.errno == errno.ENOENT:
                # We only want to a ignore trying to remove
                # a file that does not exist.  If it fails
                # for any other reason we should be propagating
                # that exception.
                raise
        os.rename(current_filename, new_filename)
else:
    rename_file = os.rename
                                                                                                                                                                                                                                                                                                                                                                                                                      usr/local/lib/python2.7/dist-packages/s3transfer/compat.pyc                                         0100644 0000000 0000062 00000001162 13077704403 022314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
˝àˇXc           @   sO   d  d l  Z  d  d l Z d  d l Z e  j j d É rB d Ñ  Z n	 e j Z d S(   iˇˇˇˇNt   winc         C   sS   y t  j | É Wn+ t k
 r> } | j t j k s? Ç  q? n Xt  j |  | É d  S(   N(   t   ost   removet   OSErrort   errnot   ENOENTt   rename(   t   current_filenamet   new_filenamet   e(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/compat.pyt   rename_file   s    
(   t   sysR   R   t   platformt
   startswithR
   R   (    (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/compat.pyt   <module>   s
                                                                                                                                                                                                                                                                                                                                                                                                                 usr/local/lib/python2.7/dist-packages/s3transfer/exceptions.py                                      0100644 0000000 0000062 00000001462 13077704375 023062  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
class RetriesExceededError(Exception):
    def __init__(self, last_exception, msg='Max Retries Exceeded'):
        super(RetriesExceededError, self).__init__(msg)
        self.last_exception = last_exception


class S3UploadFailedError(Exception):
    pass
                                                                                                                                                                                                              usr/local/lib/python2.7/dist-packages/s3transfer/exceptions.pyc                                     0100644 0000000 0000062 00000001511 13077704403 023210  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
˝àˇXc           @   s0   d  e  f d Ñ  É  YZ d e  f d Ñ  É  YZ d S(   t   RetriesExceededErrorc           B   s   e  Z d  d Ñ Z RS(   s   Max Retries Exceededc         C   s#   t  t |  É j | É | |  _ d  S(   N(   t   superR    t   __init__t   last_exception(   t   selfR   t   msg(    (    s9   /tmp/pip-build-awuatQ/s3transfer/s3transfer/exceptions.pyR      s    (   t   __name__t
   __module__R   (    (    (    s9   /tmp/pip-build-awuatQ/s3transfer/s3transfer/exceptions.pyR       s   t   S3UploadFailedErrorc           B   s   e  Z RS(    (   R   R   (    (    (    s9   /tmp/pip-build-awuatQ/s3transfer/s3transfer/exceptions.pyR      s   N(   t	   ExceptionR    R   (    (    (    s9   /tmp/pip-build-awuatQ/s3transfer/s3transfer/exceptions.pyt   <module>   s                                                                                                                                                                                          usr/local/lib/python2.7/dist-packages/s3transfer/legacy.py                                          0100644 0000000 0000062 00000066456 13077704375 022163  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
"""Abstractions over S3's upload/download operations.

This module provides high level abstractions for efficient
uploads/downloads.  It handles several things for the user:

* Automatically switching to multipart transfers when
  a file is over a specific size threshold
* Uploading/downloading a file in parallel
* Throttling based on max bandwidth
* Progress callbacks to monitor transfers
* Retries.  While botocore handles retries for streaming uploads,
  it is not possible for it to handle retries for streaming
  downloads.  This module handles retries for both cases so
  you don't need to implement any retry logic yourself.

This module has a reasonable set of defaults.  It also allows you
to configure many aspects of the transfer process including:

* Multipart threshold size
* Max parallel downloads
* Max bandwidth
* Socket timeouts
* Retry amounts

There is no support for s3->s3 multipart copies at this
time.


.. _ref_s3transfer_usage:

Usage
=====

The simplest way to use this module is:

.. code-block:: python

    client = boto3.client('s3', 'us-west-2')
    transfer = S3Transfer(client)
    # Upload /tmp/myfile to s3://bucket/key
    transfer.upload_file('/tmp/myfile', 'bucket', 'key')

    # Download s3://bucket/key to /tmp/myfile
    transfer.download_file('bucket', 'key', '/tmp/myfile')

The ``upload_file`` and ``download_file`` methods also accept
``**kwargs``, which will be forwarded through to the corresponding
client operation.  Here are a few examples using ``upload_file``::

    # Making the object public
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         extra_args={'ACL': 'public-read'})

    # Setting metadata
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         extra_args={'Metadata': {'a': 'b', 'c': 'd'}})

    # Setting content type
    transfer.upload_file('/tmp/myfile.json', 'bucket', 'key',
                         extra_args={'ContentType': "application/json"})


The ``S3Transfer`` clas also supports progress callbacks so you can
provide transfer progress to users.  Both the ``upload_file`` and
``download_file`` methods take an optional ``callback`` parameter.
Here's an example of how to print a simple progress percentage
to the user:

.. code-block:: python

    class ProgressPercentage(object):
        def __init__(self, filename):
            self._filename = filename
            self._size = float(os.path.getsize(filename))
            self._seen_so_far = 0
            self._lock = threading.Lock()

        def __call__(self, bytes_amount):
            # To simplify we'll assume this is hooked up
            # to a single filename.
            with self._lock:
                self._seen_so_far += bytes_amount
                percentage = (self._seen_so_far / self._size) * 100
                sys.stdout.write(
                    "\r%s  %s / %s  (%.2f%%)" % (self._filename, self._seen_so_far,
                                                 self._size, percentage))
                sys.stdout.flush()


    transfer = S3Transfer(boto3.client('s3', 'us-west-2'))
    # Upload /tmp/myfile to s3://bucket/key and print upload progress.
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         callback=ProgressPercentage('/tmp/myfile'))



You can also provide a TransferConfig object to the S3Transfer
object that gives you more fine grained control over the
transfer.  For example:

.. code-block:: python

    client = boto3.client('s3', 'us-west-2')
    config = TransferConfig(
        multipart_threshold=8 * 1024 * 1024,
        max_concurrency=10,
        num_download_attempts=10,
    )
    transfer = S3Transfer(client, config)
    transfer.upload_file('/tmp/foo', 'bucket', 'key')


"""
import os
import math
import functools
import logging
import socket
import threading
import random
import string
from concurrent import futures

from botocore.compat import six
from botocore.vendored.requests.packages.urllib3.exceptions import \
    ReadTimeoutError
from botocore.exceptions import IncompleteReadError

import s3transfer.compat
from s3transfer.exceptions import RetriesExceededError, S3UploadFailedError


logger = logging.getLogger(__name__)
queue = six.moves.queue

MB = 1024 * 1024
SHUTDOWN_SENTINEL = object()


def random_file_extension(num_digits=8):
    return ''.join(random.choice(string.hexdigits) for _ in range(num_digits))


def disable_upload_callbacks(request, operation_name, **kwargs):
    if operation_name in ['PutObject', 'UploadPart'] and \
            hasattr(request.body, 'disable_callback'):
        request.body.disable_callback()


def enable_upload_callbacks(request, operation_name, **kwargs):
    if operation_name in ['PutObject', 'UploadPart'] and \
            hasattr(request.body, 'enable_callback'):
        request.body.enable_callback()


class QueueShutdownError(Exception):
    pass


class ReadFileChunk(object):
    def __init__(self, fileobj, start_byte, chunk_size, full_file_size,
                 callback=None, enable_callback=True):
        """

        Given a file object shown below:

            |___________________________________________________|
            0          |                 |                 full_file_size
                       |----chunk_size---|
                 start_byte

        :type fileobj: file
        :param fileobj: File like object

        :type start_byte: int
        :param start_byte: The first byte from which to start reading.

        :type chunk_size: int
        :param chunk_size: The max chunk size to read.  Trying to read
            pass the end of the chunk size will behave like you've
            reached the end of the file.

        :type full_file_size: int
        :param full_file_size: The entire content length associated
            with ``fileobj``.

        :type callback: function(amount_read)
        :param callback: Called whenever data is read from this object.

        """
        self._fileobj = fileobj
        self._start_byte = start_byte
        self._size = self._calculate_file_size(
            self._fileobj, requested_size=chunk_size,
            start_byte=start_byte, actual_file_size=full_file_size)
        self._fileobj.seek(self._start_byte)
        self._amount_read = 0
        self._callback = callback
        self._callback_enabled = enable_callback

    @classmethod
    def from_filename(cls, filename, start_byte, chunk_size, callback=None,
                      enable_callback=True):
        """Convenience factory function to create from a filename.

        :type start_byte: int
        :param start_byte: The first byte from which to start reading.

        :type chunk_size: int
        :param chunk_size: The max chunk size to read.  Trying to read
            pass the end of the chunk size will behave like you've
            reached the end of the file.

        :type full_file_size: int
        :param full_file_size: The entire content length associated
            with ``fileobj``.

        :type callback: function(amount_read)
        :param callback: Called whenever data is read from this object.

        :type enable_callback: bool
        :param enable_callback: Indicate whether to invoke callback
            during read() calls.

        :rtype: ``ReadFileChunk``
        :return: A new instance of ``ReadFileChunk``

        """
        f = open(filename, 'rb')
        file_size = os.fstat(f.fileno()).st_size
        return cls(f, start_byte, chunk_size, file_size, callback,
                   enable_callback)

    def _calculate_file_size(self, fileobj, requested_size, start_byte,
                             actual_file_size):
        max_chunk_size = actual_file_size - start_byte
        return min(max_chunk_size, requested_size)

    def read(self, amount=None):
        if amount is None:
            amount_to_read = self._size - self._amount_read
        else:
            amount_to_read = min(self._size - self._amount_read, amount)
        data = self._fileobj.read(amount_to_read)
        self._amount_read += len(data)
        if self._callback is not None and self._callback_enabled:
            self._callback(len(data))
        return data

    def enable_callback(self):
        self._callback_enabled = True

    def disable_callback(self):
        self._callback_enabled = False

    def seek(self, where):
        self._fileobj.seek(self._start_byte + where)
        if self._callback is not None and self._callback_enabled:
            # To also rewind the callback() for an accurate progress report
            self._callback(where - self._amount_read)
        self._amount_read = where

    def close(self):
        self._fileobj.close()

    def tell(self):
        return self._amount_read

    def __len__(self):
        # __len__ is defined because requests will try to determine the length
        # of the stream to set a content length.  In the normal case
        # of the file it will just stat the file, but we need to change that
        # behavior.  By providing a __len__, requests will use that instead
        # of stat'ing the file.
        return self._size

    def __enter__(self):
        return self

    def __exit__(self, *args, **kwargs):
        self.close()

    def __iter__(self):
        # This is a workaround for http://bugs.python.org/issue17575
        # Basically httplib will try to iterate over the contents, even
        # if its a file like object.  This wasn't noticed because we've
        # already exhausted the stream so iterating over the file immediately
        # stops, which is what we're simulating here.
        return iter([])


class StreamReaderProgress(object):
    """Wrapper for a read only stream that adds progress callbacks."""
    def __init__(self, stream, callback=None):
        self._stream = stream
        self._callback = callback

    def read(self, *args, **kwargs):
        value = self._stream.read(*args, **kwargs)
        if self._callback is not None:
            self._callback(len(value))
        return value


class OSUtils(object):
    def get_file_size(self, filename):
        return os.path.getsize(filename)

    def open_file_chunk_reader(self, filename, start_byte, size, callback):
        return ReadFileChunk.from_filename(filename, start_byte,
                                           size, callback,
                                           enable_callback=False)

    def open(self, filename, mode):
        return open(filename, mode)

    def remove_file(self, filename):
        """Remove a file, noop if file does not exist."""
        # Unlike os.remove, if the file does not exist,
        # then this method does nothing.
        try:
            os.remove(filename)
        except OSError:
            pass

    def rename_file(self, current_filename, new_filename):
        s3transfer.compat.rename_file(current_filename, new_filename)


class MultipartUploader(object):
    # These are the extra_args that need to be forwarded onto
    # subsequent upload_parts.
    UPLOAD_PART_ARGS = [
        'SSECustomerKey',
        'SSECustomerAlgorithm',
        'SSECustomerKeyMD5',
        'RequestPayer',
    ]

    def __init__(self, client, config, osutil,
                 executor_cls=futures.ThreadPoolExecutor):
        self._client = client
        self._config = config
        self._os = osutil
        self._executor_cls = executor_cls

    def _extra_upload_part_args(self, extra_args):
        # Only the args in UPLOAD_PART_ARGS actually need to be passed
        # onto the upload_part calls.
        upload_parts_args = {}
        for key, value in extra_args.items():
            if key in self.UPLOAD_PART_ARGS:
                upload_parts_args[key] = value
        return upload_parts_args

    def upload_file(self, filename, bucket, key, callback, extra_args):
        response = self._client.create_multipart_upload(Bucket=bucket,
                                                        Key=key, **extra_args)
        upload_id = response['UploadId']
        try:
            parts = self._upload_parts(upload_id, filename, bucket, key,
                                       callback, extra_args)
        except Exception as e:
            logger.debug("Exception raised while uploading parts, "
                         "aborting multipart upload.", exc_info=True)
            self._client.abort_multipart_upload(
                Bucket=bucket, Key=key, UploadId=upload_id)
            raise S3UploadFailedError(
                "Failed to upload %s to %s: %s" % (
                    filename, '/'.join([bucket, key]), e))
        self._client.complete_multipart_upload(
            Bucket=bucket, Key=key, UploadId=upload_id,
            MultipartUpload={'Parts': parts})

    def _upload_parts(self, upload_id, filename, bucket, key, callback,
                      extra_args):
        upload_parts_extra_args = self._extra_upload_part_args(extra_args)
        parts = []
        part_size = self._config.multipart_chunksize
        num_parts = int(
            math.ceil(self._os.get_file_size(filename) / float(part_size)))
        max_workers = self._config.max_concurrency
        with self._executor_cls(max_workers=max_workers) as executor:
            upload_partial = functools.partial(
                self._upload_one_part, filename, bucket, key, upload_id,
                part_size, upload_parts_extra_args, callback)
            for part in executor.map(upload_partial, range(1, num_parts + 1)):
                parts.append(part)
        return parts

    def _upload_one_part(self, filename, bucket, key,
                         upload_id, part_size, extra_args,
                         callback, part_number):
        open_chunk_reader = self._os.open_file_chunk_reader
        with open_chunk_reader(filename, part_size * (part_number - 1),
                               part_size, callback) as body:
            response = self._client.upload_part(
                Bucket=bucket, Key=key,
                UploadId=upload_id, PartNumber=part_number, Body=body,
                **extra_args)
            etag = response['ETag']
            return {'ETag': etag, 'PartNumber': part_number}


class ShutdownQueue(queue.Queue):
    """A queue implementation that can be shutdown.

    Shutting down a queue means that this class adds a
    trigger_shutdown method that will trigger all subsequent
    calls to put() to fail with a ``QueueShutdownError``.

    It purposefully deviates from queue.Queue, and is *not* meant
    to be a drop in replacement for ``queue.Queue``.

    """
    def _init(self, maxsize):
        self._shutdown = False
        self._shutdown_lock = threading.Lock()
        # queue.Queue is an old style class so we don't use super().
        return queue.Queue._init(self, maxsize)

    def trigger_shutdown(self):
        with self._shutdown_lock:
            self._shutdown = True
            logger.debug("The IO queue is now shutdown.")

    def put(self, item):
        # Note: this is not sufficient, it's still possible to deadlock!
        # Need to hook into the condition vars used by this class.
        with self._shutdown_lock:
            if self._shutdown:
                raise QueueShutdownError("Cannot put item to queue when "
                                         "queue has been shutdown.")
        return queue.Queue.put(self, item)


class MultipartDownloader(object):
    def __init__(self, client, config, osutil,
                 executor_cls=futures.ThreadPoolExecutor):
        self._client = client
        self._config = config
        self._os = osutil
        self._executor_cls = executor_cls
        self._ioqueue = ShutdownQueue(self._config.max_io_queue)

    def download_file(self, bucket, key, filename, object_size,
                      extra_args, callback=None):
        with self._executor_cls(max_workers=2) as controller:
            # 1 thread for the future that manages the uploading of files
            # 1 thread for the future that manages IO writes.
            download_parts_handler = functools.partial(
                self._download_file_as_future,
                bucket, key, filename, object_size, callback)
            parts_future = controller.submit(download_parts_handler)

            io_writes_handler = functools.partial(
                self._perform_io_writes, filename)
            io_future = controller.submit(io_writes_handler)
            results = futures.wait([parts_future, io_future],
                                   return_when=futures.FIRST_EXCEPTION)
            self._process_future_results(results)

    def _process_future_results(self, futures):
        finished, unfinished = futures
        for future in finished:
            future.result()

    def _download_file_as_future(self, bucket, key, filename, object_size,
                                 callback):
        part_size = self._config.multipart_chunksize
        num_parts = int(math.ceil(object_size / float(part_size)))
        max_workers = self._config.max_concurrency
        download_partial = functools.partial(
            self._download_range, bucket, key, filename,
            part_size, num_parts, callback)
        try:
            with self._executor_cls(max_workers=max_workers) as executor:
                list(executor.map(download_partial, range(num_parts)))
        finally:
            self._ioqueue.put(SHUTDOWN_SENTINEL)

    def _calculate_range_param(self, part_size, part_index, num_parts):
        start_range = part_index * part_size
        if part_index == num_parts - 1:
            end_range = ''
        else:
            end_range = start_range + part_size - 1
        range_param = 'bytes=%s-%s' % (start_range, end_range)
        return range_param

    def _download_range(self, bucket, key, filename,
                        part_size, num_parts, callback, part_index):
        try:
            range_param = self._calculate_range_param(
                part_size, part_index, num_parts)

            max_attempts = self._config.num_download_attempts
            last_exception = None
            for i in range(max_attempts):
                try:
                    logger.debug("Making get_object call.")
                    response = self._client.get_object(
                        Bucket=bucket, Key=key, Range=range_param)
                    streaming_body = StreamReaderProgress(
                        response['Body'], callback)
                    buffer_size = 1024 * 16
                    current_index = part_size * part_index
                    for chunk in iter(lambda: streaming_body.read(buffer_size),
                                      b''):
                        self._ioqueue.put((current_index, chunk))
                        current_index += len(chunk)
                    return
                except (socket.timeout, socket.error,
                        ReadTimeoutError, IncompleteReadError) as e:
                    logger.debug("Retrying exception caught (%s), "
                                 "retrying request, (attempt %s / %s)", e, i,
                                 max_attempts, exc_info=True)
                    last_exception = e
                    continue
            raise RetriesExceededError(last_exception)
        finally:
            logger.debug("EXITING _download_range for part: %s", part_index)

    def _perform_io_writes(self, filename):
        with self._os.open(filename, 'wb') as f:
            while True:
                task = self._ioqueue.get()
                if task is SHUTDOWN_SENTINEL:
                    logger.debug("Shutdown sentinel received in IO handler, "
                                 "shutting down IO handler.")
                    return
                else:
                    try:
                        offset, data = task
                        f.seek(offset)
                        f.write(data)
                    except Exception as e:
                        logger.debug("Caught exception in IO thread: %s",
                                     e, exc_info=True)
                        self._ioqueue.trigger_shutdown()
                        raise


class TransferConfig(object):
    def __init__(self,
                 multipart_threshold=8 * MB,
                 max_concurrency=10,
                 multipart_chunksize=8 * MB,
                 num_download_attempts=5,
                 max_io_queue=100):
        self.multipart_threshold = multipart_threshold
        self.max_concurrency = max_concurrency
        self.multipart_chunksize = multipart_chunksize
        self.num_download_attempts = num_download_attempts
        self.max_io_queue = max_io_queue


class S3Transfer(object):

    ALLOWED_DOWNLOAD_ARGS = [
        'VersionId',
        'SSECustomerAlgorithm',
        'SSECustomerKey',
        'SSECustomerKeyMD5',
        'RequestPayer',
    ]

    ALLOWED_UPLOAD_ARGS = [
        'ACL',
        'CacheControl',
        'ContentDisposition',
        'ContentEncoding',
        'ContentLanguage',
        'ContentType',
        'Expires',
        'GrantFullControl',
        'GrantRead',
        'GrantReadACP',
        'GrantWriteACL',
        'Metadata',
        'RequestPayer',
        'ServerSideEncryption',
        'StorageClass',
        'SSECustomerAlgorithm',
        'SSECustomerKey',
        'SSECustomerKeyMD5',
        'SSEKMSKeyId',
    ]

    def __init__(self, client, config=None, osutil=None):
        self._client = client
        if config is None:
            config = TransferConfig()
        self._config = config
        if osutil is None:
            osutil = OSUtils()
        self._osutil = osutil

    def upload_file(self, filename, bucket, key,
                    callback=None, extra_args=None):
        """Upload a file to an S3 object.

        Variants have also been injected into S3 client, Bucket and Object.
        You don't have to use S3Transfer.upload_file() directly.
        """
        if extra_args is None:
            extra_args = {}
        self._validate_all_known_args(extra_args, self.ALLOWED_UPLOAD_ARGS)
        events = self._client.meta.events
        events.register_first('request-created.s3',
                              disable_upload_callbacks,
                              unique_id='s3upload-callback-disable')
        events.register_last('request-created.s3',
                             enable_upload_callbacks,
                             unique_id='s3upload-callback-enable')
        if self._osutil.get_file_size(filename) >= \
                self._config.multipart_threshold:
            self._multipart_upload(filename, bucket, key, callback, extra_args)
        else:
            self._put_object(filename, bucket, key, callback, extra_args)

    def _put_object(self, filename, bucket, key, callback, extra_args):
        # We're using open_file_chunk_reader so we can take advantage of the
        # progress callback functionality.
        open_chunk_reader = self._osutil.open_file_chunk_reader
        with open_chunk_reader(filename, 0,
                               self._osutil.get_file_size(filename),
                               callback=callback) as body:
            self._client.put_object(Bucket=bucket, Key=key, Body=body,
                                    **extra_args)

    def download_file(self, bucket, key, filename, extra_args=None,
                      callback=None):
        """Download an S3 object to a file.

        Variants have also been injected into S3 client, Bucket and Object.
        You don't have to use S3Transfer.download_file() directly.
        """
        # This method will issue a ``head_object`` request to determine
        # the size of the S3 object.  This is used to determine if the
        # object is downloaded in parallel.
        if extra_args is None:
            extra_args = {}
        self._validate_all_known_args(extra_args, self.ALLOWED_DOWNLOAD_ARGS)
        object_size = self._object_size(bucket, key, extra_args)
        temp_filename = filename + os.extsep + random_file_extension()
        try:
            self._download_file(bucket, key, temp_filename, object_size,
                                extra_args, callback)
        except Exception:
            logger.debug("Exception caught in download_file, removing partial "
                         "file: %s", temp_filename, exc_info=True)
            self._osutil.remove_file(temp_filename)
            raise
        else:
            self._osutil.rename_file(temp_filename, filename)

    def _download_file(self, bucket, key, filename, object_size,
                       extra_args, callback):
        if object_size >= self._config.multipart_threshold:
            self._ranged_download(bucket, key, filename, object_size,
                                  extra_args, callback)
        else:
            self._get_object(bucket, key, filename, extra_args, callback)

    def _validate_all_known_args(self, actual, allowed):
        for kwarg in actual:
            if kwarg not in allowed:
                raise ValueError(
                    "Invalid extra_args key '%s', "
                    "must be one of: %s" % (
                        kwarg, ', '.join(allowed)))

    def _ranged_download(self, bucket, key, filename, object_size,
                         extra_args, callback):
        downloader = MultipartDownloader(self._client, self._config,
                                         self._osutil)
        downloader.download_file(bucket, key, filename, object_size,
                                 extra_args, callback)

    def _get_object(self, bucket, key, filename, extra_args, callback):
        # precondition: num_download_attempts > 0
        max_attempts = self._config.num_download_attempts
        last_exception = None
        for i in range(max_attempts):
            try:
                return self._do_get_object(bucket, key, filename,
                                           extra_args, callback)
            except (socket.timeout, socket.error,
                    ReadTimeoutError, IncompleteReadError) as e:
                # TODO: we need a way to reset the callback if the
                # download failed.
                logger.debug("Retrying exception caught (%s), "
                             "retrying request, (attempt %s / %s)", e, i,
                             max_attempts, exc_info=True)
                last_exception = e
                continue
        raise RetriesExceededError(last_exception)

    def _do_get_object(self, bucket, key, filename, extra_args, callback):
        response = self._client.get_object(Bucket=bucket, Key=key,
                                           **extra_args)
        streaming_body = StreamReaderProgress(
            response['Body'], callback)
        with self._osutil.open(filename, 'wb') as f:
            for chunk in iter(lambda: streaming_body.read(8192), b''):
                f.write(chunk)

    def _object_size(self, bucket, key, extra_args):
        return self._client.head_object(
            Bucket=bucket, Key=key, **extra_args)['ContentLength']

    def _multipart_upload(self, filename, bucket, key, callback, extra_args):
        uploader = MultipartUploader(self._client, self._config, self._osutil)
        uploader.upload_file(filename, bucket, key, callback, extra_args)
                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/s3transfer/legacy.pyc                                         0100644 0000000 0000062 00000065600 13077704403 022304  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
˝àˇXc           @   s›  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 m
 Z
 d d l m Z d d l m Z d d l m Z d d l Z d d l m Z m Z e j e É Z e j j Z d Z e É  Z d	 d
 Ñ Z d Ñ  Z d Ñ  Z  d e! f d Ñ  É  YZ" d e f d Ñ  É  YZ# d e f d Ñ  É  YZ$ d e f d Ñ  É  YZ% d e f d Ñ  É  YZ& d e j' f d Ñ  É  YZ( d e f d Ñ  É  YZ) d e f d Ñ  É  YZ* d e f d Ñ  É  YZ+ d S(    s≠  Abstractions over S3's upload/download operations.

This module provides high level abstractions for efficient
uploads/downloads.  It handles several things for the user:

* Automatically switching to multipart transfers when
  a file is over a specific size threshold
* Uploading/downloading a file in parallel
* Throttling based on max bandwidth
* Progress callbacks to monitor transfers
* Retries.  While botocore handles retries for streaming uploads,
  it is not possible for it to handle retries for streaming
  downloads.  This module handles retries for both cases so
  you don't need to implement any retry logic yourself.

This module has a reasonable set of defaults.  It also allows you
to configure many aspects of the transfer process including:

* Multipart threshold size
* Max parallel downloads
* Max bandwidth
* Socket timeouts
* Retry amounts

There is no support for s3->s3 multipart copies at this
time.


.. _ref_s3transfer_usage:

Usage
=====

The simplest way to use this module is:

.. code-block:: python

    client = boto3.client('s3', 'us-west-2')
    transfer = S3Transfer(client)
    # Upload /tmp/myfile to s3://bucket/key
    transfer.upload_file('/tmp/myfile', 'bucket', 'key')

    # Download s3://bucket/key to /tmp/myfile
    transfer.download_file('bucket', 'key', '/tmp/myfile')

The ``upload_file`` and ``download_file`` methods also accept
``**kwargs``, which will be forwarded through to the corresponding
client operation.  Here are a few examples using ``upload_file``::

    # Making the object public
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         extra_args={'ACL': 'public-read'})

    # Setting metadata
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         extra_args={'Metadata': {'a': 'b', 'c': 'd'}})

    # Setting content type
    transfer.upload_file('/tmp/myfile.json', 'bucket', 'key',
                         extra_args={'ContentType': "application/json"})


The ``S3Transfer`` clas also supports progress callbacks so you can
provide transfer progress to users.  Both the ``upload_file`` and
``download_file`` methods take an optional ``callback`` parameter.
Here's an example of how to print a simple progress percentage
to the user:

.. code-block:: python

    class ProgressPercentage(object):
        def __init__(self, filename):
            self._filename = filename
            self._size = float(os.path.getsize(filename))
            self._seen_so_far = 0
            self._lock = threading.Lock()

        def __call__(self, bytes_amount):
            # To simplify we'll assume this is hooked up
            # to a single filename.
            with self._lock:
                self._seen_so_far += bytes_amount
                percentage = (self._seen_so_far / self._size) * 100
                sys.stdout.write(
                    "%s  %s / %s  (%.2f%%)" % (self._filename, self._seen_so_far,
                                                 self._size, percentage))
                sys.stdout.flush()


    transfer = S3Transfer(boto3.client('s3', 'us-west-2'))
    # Upload /tmp/myfile to s3://bucket/key and print upload progress.
    transfer.upload_file('/tmp/myfile', 'bucket', 'key',
                         callback=ProgressPercentage('/tmp/myfile'))



You can also provide a TransferConfig object to the S3Transfer
object that gives you more fine grained control over the
transfer.  For example:

.. code-block:: python

    client = boto3.client('s3', 'us-west-2')
    config = TransferConfig(
        multipart_threshold=8 * 1024 * 1024,
        max_concurrency=10,
        num_download_attempts=10,
    )
    transfer = S3Transfer(client, config)
    transfer.upload_file('/tmp/foo', 'bucket', 'key')


iˇˇˇˇN(   t   futures(   t   six(   t   ReadTimeoutError(   t   IncompleteReadError(   t   RetriesExceededErrort   S3UploadFailedErrori   i   c         C   s   d j  d Ñ  t |  É DÉ É S(   Nt    c         s   s!   |  ] } t  j t j É Vq d  S(   N(   t   randomt   choicet   stringt	   hexdigits(   t   .0t   _(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pys	   <genexpr>ô   s    (   t   joint   range(   t
   num_digits(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   random_file_extensionò   s    c         K   s2   | d k r. t  |  j d É r. |  j j É  n  d  S(   Nt	   PutObjectt
   UploadPartt   disable_callback(   R   R   (   t   hasattrt   bodyR   (   t   requestt   operation_namet   kwargs(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   disable_upload_callbacksú   s    c         K   s2   | d k r. t  |  j d É r. |  j j É  n  d  S(   NR   R   t   enable_callback(   s	   PutObjects
   UploadPart(   R   R   R   (   R   R   R   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   enable_upload_callbacks¢   s    t   QueueShutdownErrorc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR   ®   s   t   ReadFileChunkc           B   sí   e  Z d e d  Ñ Z e d e d Ñ É Z d Ñ  Z d d Ñ Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   sk   | |  _  | |  _ |  j |  j  d | d | d | É|  _ |  j  j |  j É d |  _ | |  _ | |  _ d S(   sÇ  

        Given a file object shown below:

            |___________________________________________________|
            0          |                 |                 full_file_size
                       |----chunk_size---|
                 start_byte

        :type fileobj: file
        :param fileobj: File like object

        :type start_byte: int
        :param start_byte: The first byte from which to start reading.

        :type chunk_size: int
        :param chunk_size: The max chunk size to read.  Trying to read
            pass the end of the chunk size will behave like you've
            reached the end of the file.

        :type full_file_size: int
        :param full_file_size: The entire content length associated
            with ``fileobj``.

        :type callback: function(amount_read)
        :param callback: Called whenever data is read from this object.

        t   requested_sizet
   start_bytet   actual_file_sizei    N(   t   _fileobjt   _start_bytet   _calculate_file_sizet   _sizet   seekt   _amount_readt	   _callbackt   _callback_enabled(   t   selft   fileobjR!   t
   chunk_sizet   full_file_sizet   callbackR   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   __init__≠   s    				c         C   s@   t  | d É } t j | j É  É j } |  | | | | | | É S(   sW  Convenience factory function to create from a filename.

        :type start_byte: int
        :param start_byte: The first byte from which to start reading.

        :type chunk_size: int
        :param chunk_size: The max chunk size to read.  Trying to read
            pass the end of the chunk size will behave like you've
            reached the end of the file.

        :type full_file_size: int
        :param full_file_size: The entire content length associated
            with ``fileobj``.

        :type callback: function(amount_read)
        :param callback: Called whenever data is read from this object.

        :type enable_callback: bool
        :param enable_callback: Indicate whether to invoke callback
            during read() calls.

        :rtype: ``ReadFileChunk``
        :return: A new instance of ``ReadFileChunk``

        t   rb(   t   opent   ost   fstatt   filenot   st_size(   t   clst   filenameR!   R-   R/   R   t   ft	   file_size(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   from_filename’   s    c         C   s   | | } t  | | É S(   N(   t   min(   R+   R,   R    R!   R"   t   max_chunk_size(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR%   ˆ   s    
c         C   së   | d  k r |  j |  j } n t |  j |  j | É } |  j j | É } |  j t | É 7_ |  j d  k	 rç |  j rç |  j t | É É n  | S(   N(	   t   NoneR&   R(   R<   R#   t   readt   lenR)   R*   (   R+   t   amountt   amount_to_readt   data(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR?   ˚   s    c         C   s   t  |  _ d  S(   N(   t   TrueR*   (   R+   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR     s    c         C   s   t  |  _ d  S(   N(   t   FalseR*   (   R+   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR   	  s    c         C   sS   |  j  j |  j | É |  j d  k	 rF |  j rF |  j | |  j É n  | |  _ d  S(   N(   R#   R'   R$   R)   R>   R*   R(   (   R+   t   where(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR'     s    c         C   s   |  j  j É  d  S(   N(   R#   t   close(   R+   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyRG     s    c         C   s   |  j  S(   N(   R(   (   R+   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   tell  s    c         C   s   |  j  S(   N(   R&   (   R+   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   __len__  s    c         C   s   |  S(   N(    (   R+   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt	   __enter__!  s    c         O   s   |  j  É  d  S(   N(   RG   (   R+   t   argsR   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   __exit__$  s    c         C   s
   t  g  É S(   N(   t   iter(   R+   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   __iter__'  s    N(   R   R   R>   RD   R0   t   classmethodR;   R%   R?   R   R   R'   RG   RH   RI   RJ   RL   RN   (    (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR   ¨   s   '									t   StreamReaderProgressc           B   s#   e  Z d  Z d d Ñ Z d Ñ  Z RS(   s<   Wrapper for a read only stream that adds progress callbacks.c         C   s   | |  _  | |  _ d  S(   N(   t   _streamR)   (   R+   t   streamR/   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR0   2  s    	c         O   s>   |  j  j | | é  } |  j d  k	 r: |  j t | É É n  | S(   N(   RQ   R?   R)   R>   R@   (   R+   RK   R   t   value(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR?   6  s    N(   R   R   t   __doc__R>   R0   R?   (    (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyRP   0  s   t   OSUtilsc           B   s5   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   t  j j | É S(   N(   R3   t   patht   getsize(   R+   R8   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   get_file_size>  s    c         C   s   t  j | | | | d t ÉS(   NR   (   R   R;   RE   (   R+   R8   R!   t   sizeR/   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   open_file_chunk_readerA  s    	c         C   s   t  | | É S(   N(   R2   (   R+   R8   t   mode(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR2   F  s    c         C   s)   y t  j | É Wn t k
 r$ n Xd S(   s+   Remove a file, noop if file does not exist.N(   R3   t   removet   OSError(   R+   R8   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   remove_fileI  s    c         C   s   t  j j | | É d  S(   N(   t
   s3transfert   compatt   rename_file(   R+   t   current_filenamet   new_filename(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyRa   R  s    (   R   R   RX   RZ   R2   R^   Ra   (    (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyRU   =  s
   					t   MultipartUploaderc           B   sM   e  Z d  d d d g Z e j d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z	 RS(	   t   SSECustomerKeyt   SSECustomerAlgorithmt   SSECustomerKeyMD5t   RequestPayerc         C   s(   | |  _  | |  _ | |  _ | |  _ d  S(   N(   t   _clientt   _configt   _ost   _executor_cls(   R+   t   clientt   configt   osutilt   executor_cls(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR0   `  s    			c         C   sC   i  } x6 | j  É  D]( \ } } | |  j k r | | | <q q W| S(   N(   t   itemst   UPLOAD_PART_ARGS(   R+   t
   extra_argst   upload_parts_argst   keyRS   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   _extra_upload_part_argsg  s
    c   
      C   sÍ   |  j  j d | d | | ç } | d } y" |  j | | | | | | É } Wnm t k
 rπ }	 t j d d t É|  j  j d | d | d | É t d | d j	 | | g É |	 f É Ç n X|  j  j
 d | d | d | d i | d	 6É d  S(
   Nt   Buckett   Keyt   UploadIdsB   Exception raised while uploading parts, aborting multipart upload.t   exc_infos   Failed to upload %s to %s: %st   /t   MultipartUploadt   Parts(   Ri   t   create_multipart_uploadt   _upload_partst	   Exceptiont   loggert   debugRD   t   abort_multipart_uploadR   R   t   complete_multipart_upload(
   R+   R8   t   bucketRu   R/   Rs   t   responset	   upload_idt   partst   e(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   upload_filep  s"    
&c         C   s’   |  j  | É } g  } |  j j }	 t t j |  j j | É t |	 É É É }
 |  j j	 } |  j
 d | É èe } t j |  j | | | | |	 | | É } x4 | j | t d |
 d É É D] } | j | É q¥ WWd  QX| S(   Nt   max_workersi   (   Rv   Rj   t   multipart_chunksizet   intt   matht   ceilRk   RX   t   floatt   max_concurrencyRl   t	   functoolst   partialt   _upload_one_partt   mapR   t   append(   R+   Rá   R8   RÖ   Ru   R/   Rs   t   upload_parts_extra_argsRà   t	   part_sizet	   num_partsRã   t   executort   upload_partialt   part(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR   É  s    (&c	         C   sÇ   |  j  j }	 |	 | | | d | | É èS }
 |  j j d | d | d | d | d |
 | ç } | d } i | d 6| d 6SWd  QXd  S(   Ni   Rw   Rx   Ry   t
   PartNumbert   Bodyt   ETag(   Rk   RZ   Ri   t   upload_part(   R+   R8   RÖ   Ru   Rá   Rò   Rs   R/   t   part_numbert   open_chunk_readerR   RÜ   t   etag(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyRî   ì  s    	
(
   R   R   Rr   R    t   ThreadPoolExecutorR0   Rv   Rä   R   Rî   (    (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyRd   V  s   					t   ShutdownQueuec           B   s)   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   sY  A queue implementation that can be shutdown.

    Shutting down a queue means that this class adds a
    trigger_shutdown method that will trigger all subsequent
    calls to put() to fail with a ``QueueShutdownError``.

    It purposefully deviates from queue.Queue, and is *not* meant
    to be a drop in replacement for ``queue.Queue``.

    c         C   s+   t  |  _ t j É  |  _ t j j |  | É S(   N(   RE   t	   _shutdownt	   threadingt   Lockt   _shutdown_lockt   queuet   Queuet   _init(   R+   t   maxsize(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR¨   ¨  s    	c         C   s*   |  j  è t |  _ t j d É Wd  QXd  S(   Ns   The IO queue is now shutdown.(   R©   RD   R¶   RÅ   RÇ   (   R+   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   trigger_shutdown≤  s    
	c         C   s;   |  j  è |  j r" t d É Ç n  Wd  QXt j j |  | É S(   Ns6   Cannot put item to queue when queue has been shutdown.(   R©   R¶   R   R™   R´   t   put(   R+   t   item(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyRØ   ∑  s    
	(   R   R   RT   R¨   RÆ   RØ   (    (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR•   °  s   
		t   MultipartDownloaderc           B   sP   e  Z e j d  Ñ Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z RS(   c         C   s=   | |  _  | |  _ | |  _ | |  _ t |  j j É |  _ d  S(   N(   Ri   Rj   Rk   Rl   R•   t   max_io_queuet   _ioqueue(   R+   Rm   Rn   Ro   Rp   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR0   ¬  s
    				c         C   sû   |  j  d d É èÜ } t j |  j | | | | | É } | j | É }	 t j |  j | É }
 | j |
 É } t j |	 | g d t j É} |  j	 | É Wd  QXd  S(   NRã   i   t   return_when(
   Rl   Rí   Rì   t   _download_file_as_futuret   submitt   _perform_io_writesR    t   waitt   FIRST_EXCEPTIONt   _process_future_results(   R+   RÖ   Ru   R8   t   object_sizeRs   R/   t
   controllert   download_parts_handlert   parts_futuret   io_writes_handlert	   io_futuret   results(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   download_file   s    c         C   s+   | \ } } x | D] } | j  É  q Wd  S(   N(   t   result(   R+   R    t   finishedt
   unfinishedt   future(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR∫   €  s    c      	   C   sÆ   |  j  j } t t j | t | É É É } |  j  j } t j |  j	 | | | | | | É }	 z; |  j
 d | É è# }
 t |
 j |	 t | É É É Wd  QXWd  |  j j t É Xd  S(   NRã   (   Rj   Rå   Rç   Ré   Rè   Rê   Rë   Rí   Rì   t   _download_rangeRl   t   listRï   R   R≥   RØ   t   SHUTDOWN_SENTINEL(   R+   RÖ   Ru   R8   Rª   R/   Rò   Rô   Rã   t   download_partialRö   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyRµ   ‡  s    &c         C   sE   | | } | | d k r# d } n | | d } d | | f } | S(   Ni   R   s   bytes=%s-%s(    (   R+   Rò   t
   part_indexRô   t   start_ranget	   end_ranget   range_param(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   _calculate_range_paramÓ  s    
	c      	      sX  z@|  j  | | | É } |  j j }	 d  }
 xt |	 É D]¯ } y• t j d É |  j j d | d | d | É } t	 | d | É â d â  | | } xI t
 á  á f d Ü  d	 É D], } |  j j | | f É | t | É 7} q≠ Wd  SWq7 t j t j t t f k
 r.} t j d
 | | |	 d t É| }
 q7 q7 Xq7 Wt |
 É Ç Wd  t j d | É Xd  S(   Ns   Making get_object call.Rw   Rx   t   RangeRû   i   i   c              s   à j  à  É S(   N(   R?   (    (   t   buffer_sizet   streaming_body(    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   <lambda>  s    R   sC   Retrying exception caught (%s), retrying request, (attempt %s / %s)Rz   s$   EXITING _download_range for part: %si @  (   Rœ   Rj   t   num_download_attemptsR>   R   RÅ   RÇ   Ri   t
   get_objectRP   RM   R≥   RØ   R@   t   sockett   timeoutt   errorR   R   RD   R   (   R+   RÖ   Ru   R8   Rò   Rô   R/   RÀ   RŒ   t   max_attemptst   last_exceptiont   iRÜ   t   current_indext   chunkRâ   (    (   R—   R“   s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR«   ˜  s8    
	c      	   C   s¡   |  j  j | d É è¶ } xú t r∂ |  j j É  } | t k rM t j d É d  Sy* | \ } } | j | É | j	 | É Wq t
 k
 r≤ } t j d | d t É|  j j É  Ç  q Xq WWd  QXd  S(   Nt   wbsC   Shutdown sentinel received in IO handler, shutting down IO handler.s!   Caught exception in IO thread: %sRz   (   Rk   R2   RD   R≥   t   getR…   RÅ   RÇ   R'   t   writeRÄ   RÆ   (   R+   R8   R9   t   taskt   offsetRC   Râ   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR∑     s    		N(   R   R   R    R§   R0   R>   R¬   R∫   Rµ   Rœ   R«   R∑   (    (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR±   ¡  s   					!t   TransferConfigc           B   s(   e  Z d  e d d  e d d d Ñ Z RS(   i   i
   i   id   c         C   s1   | |  _  | |  _ | |  _ | |  _ | |  _ d  S(   N(   t   multipart_thresholdRë   Rå   R‘   R≤   (   R+   R‰   Rë   Rå   R‘   R≤   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR0   -  s
    				(   R   R   t   MBR0   (    (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR„   ,  s
   t
   S3Transferc           B   s—   e  Z d  d d d d g Z d d d d d	 d
 d d d d d d d d d d d d d g Z d d d Ñ Z d d d Ñ Z d Ñ  Z d d d Ñ Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(    t	   VersionIdRf   Re   Rg   Rh   t   ACLt   CacheControlt   ContentDispositiont   ContentEncodingt   ContentLanguaget   ContentTypet   Expirest   GrantFullControlt	   GrantReadt   GrantReadACPt   GrantWriteACLt   Metadatat   ServerSideEncryptiont   StorageClasst   SSEKMSKeyIdc         C   sO   | |  _  | d  k r! t É  } n  | |  _ | d  k rB t É  } n  | |  _ d  S(   N(   Ri   R>   R„   Rj   RU   t   _osutil(   R+   Rm   Rn   Ro   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR0   Z  s    		c         C   s∫   | d k r i  } n  |  j | |  j É |  j j j } | j d t d d É| j d t	 d d É|  j
 j | É |  j j k rù |  j | | | | | É n |  j | | | | | É d S(   sµ   Upload a file to an S3 object.

        Variants have also been injected into S3 client, Bucket and Object.
        You don't have to use S3Transfer.upload_file() directly.
        s   request-created.s3t	   unique_ids   s3upload-callback-disables   s3upload-callback-enableN(   R>   t   _validate_all_known_argst   ALLOWED_UPLOAD_ARGSRi   t   metat   eventst   register_firstR   t   register_lastR   R˜   RX   Rj   R‰   t   _multipart_uploadt   _put_object(   R+   R8   RÖ   Ru   R/   Rs   R¸   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyRä   c  s    			c         C   s_   |  j  j } | | d |  j  j | É d | Éè) } |  j j d | d | d | | ç Wd  QXd  S(   Ni    R/   Rw   Rx   Rû   (   R˜   RZ   RX   Ri   t
   put_object(   R+   R8   RÖ   Ru   R/   Rs   R¢   R   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR   z  s    	c         C   s≈   | d k r i  } n  |  j | |  j É |  j | | | É } | t j t É  } y  |  j | | | | | | É Wn: t k
 r≠ t	 j
 d | d t É|  j j | É Ç  n X|  j j | | É d S(   sπ   Download an S3 object to a file.

        Variants have also been injected into S3 client, Bucket and Object.
        You don't have to use S3Transfer.download_file() directly.
        s<   Exception caught in download_file, removing partial file: %sRz   N(   R>   R˘   t   ALLOWED_DOWNLOAD_ARGSt   _object_sizeR3   t   extsepR   t   _download_fileRÄ   RÅ   RÇ   RD   R˜   R^   Ra   (   R+   RÖ   Ru   R8   Rs   R/   Rª   t   temp_filename(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR¬   Ñ  s    
		c         C   sN   | |  j  j k r1 |  j | | | | | | É n |  j | | | | | É d  S(   N(   Rj   R‰   t   _ranged_downloadt   _get_object(   R+   RÖ   Ru   R8   Rª   Rs   R/   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR  û  s    c         C   sC   x< | D]4 } | | k r t  d | d j | É f É Ç q q Wd  S(   Ns/   Invalid extra_args key '%s', must be one of: %ss   , (   t
   ValueErrorR   (   R+   t   actualt   allowedt   kwarg(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR˘   ¶  s
    c         C   s;   t  |  j |  j |  j É } | j | | | | | | É d  S(   N(   R±   Ri   Rj   R˜   R¬   (   R+   RÖ   Ru   R8   Rª   Rs   R/   t
   downloader(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR  Æ  s    c   
   	   C   s£   |  j  j } d  } x~ t | É D]p } y |  j | | | | | É SWq t j t j t t	 f k
 ré }	 t
 j d |	 | | d t É|	 } q q Xq Wt | É Ç d  S(   NsC   Retrying exception caught (%s), retrying request, (attempt %s / %s)Rz   (   Rj   R‘   R>   R   t   _do_get_objectR÷   R◊   Rÿ   R   R   RÅ   RÇ   RD   R   (
   R+   RÖ   Ru   R8   Rs   R/   RŸ   R⁄   R€   Râ   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR  µ  s    	c   	         sÉ   |  j  j d | d | | ç } t | d | É â  |  j j | d É è7 } x- t á  f d Ü  d É D] } | j | É qb WWd  QXd  S(   NRw   Rx   Rû   Rﬁ   c              s   à  j  d É S(   Ni    (   R?   (    (   R“   (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR”   Œ  s    R   (   Ri   R’   RP   R˜   R2   RM   R‡   (	   R+   RÖ   Ru   R8   Rs   R/   RÜ   R9   R›   (    (   R“   s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR  »  s    	c         C   s    |  j  j d | d | | ç d S(   NRw   Rx   t   ContentLength(   Ri   t   head_object(   R+   RÖ   Ru   Rs   (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyR  —  s    c         C   s8   t  |  j |  j |  j É } | j | | | | | É d  S(   N(   Rd   Ri   Rj   R˜   Rä   (   R+   R8   RÖ   Ru   R/   Rs   t   uploader(    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyRˇ   ’  s    N(   R   R   R  R˙   R>   R0   Rä   R   R¬   R  R˘   R  R  R  R  Rˇ   (    (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyRÊ   :  sH   		
	
							i   (,   RT   R3   Ré   Rí   t   loggingR÷   Rß   R   R	   t
   concurrentR    t   botocore.compatR   t6   botocore.vendored.requests.packages.urllib3.exceptionsR   t   botocore.exceptionsR   t   s3transfer.compatR_   t   s3transfer.exceptionsR   R   t	   getLoggerR   RÅ   t   movesR™   RÂ   t   objectR…   R   R   R   RÄ   R   R   RP   RU   Rd   R´   R•   R±   R„   RÊ   (    (    (    s5   /tmp/pip-build-awuatQ/s3transfer/s3transfer/legacy.pyt   <module>}   s<   			ÑK k                                                                                                                                usr/local/lib/python2.7/dist-packages/s3transfer-0.0.1.dist-info/                                   0042755 0000000 0000062 00000000000 13077704403 022646  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/s3transfer-0.0.1.dist-info/DESCRIPTION.rst                    0100644 0000000 0000062 00000000606 13077704375 025170  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =====================================================
s3transfer - An Amazon S3 Transfer Manager for Python
=====================================================

.. warning::

  This project is currently a work in progress. Please do not rely on
  this functionality in production as the interfaces may change over time.

S3transfer is a Python library for managing Amazon S3 transfers.


                                                                                                                          usr/local/lib/python2.7/dist-packages/s3transfer-0.0.1.dist-info/METADATA                           0100644 0000000 0000062 00000002417 13077704375 023760  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Metadata-Version: 2.0
Name: s3transfer
Version: 0.0.1
Summary: An Amazon S3 Transfer Manager
Home-page: https://github.com/boto/s3transfer
Author: Amazon Web Services
Author-email: kyknapp1@gmail.com
License: Apache License 2.0
Platform: UNKNOWN
Classifier: Development Status :: 1 - Planning
Classifier: Intended Audience :: Developers
Classifier: Natural Language :: English
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 2.6
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Requires-Dist: botocore>=1.3.0,<2.0.0
Requires-Dist: futures>=2.2.0,<4.0.0; python_version=="2.6" or python_version=="2.7"

=====================================================
s3transfer - An Amazon S3 Transfer Manager for Python
=====================================================

.. warning::

  This project is currently a work in progress. Please do not rely on
  this functionality in production as the interfaces may change over time.

S3transfer is a Python library for managing Amazon S3 transfers.


                                                                                                                                                                                                                                                 usr/local/lib/python2.7/dist-packages/s3transfer-0.0.1.dist-info/RECORD                             0100644 0000000 0000062 00000001651 13077704403 023545  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        s3transfer/__init__.py,sha256=tAZ-JDKwPkS-xbYiBbg4N7bauOv1UJximScJv4u07e0,28008
s3transfer/compat.py,sha256=zwkoVbfq1fT2y48tNbdE-E-DBx5DL5qQT90NurtBGgg,1130
s3transfer/exceptions.py,sha256=bVcAorGBZxnPmuhm_89932AGD8vlziDXdPgtR5lMw1s,818
s3transfer/legacy.py,sha256=nLnoZFNCZJrFWX-cS9-WcJh-S0CAlyLj8bi6h5nH8q4,27950
s3transfer-0.0.1.dist-info/DESCRIPTION.rst,sha256=ToIG0wVtFldWuXRjOncELWo-iBmOAtA3s9zKKFlD0MU,390
s3transfer-0.0.1.dist-info/METADATA,sha256=Pv3I4sRPOgXJMdNfZGnU80tmY_hRWwGszGjRgIFLSk8,1295
s3transfer-0.0.1.dist-info/metadata.json,sha256=vjuVihiluIAegdySiK_BO9IZ0SVV7-8pHBtMnkWY1wI,1070
s3transfer-0.0.1.dist-info/RECORD,,
s3transfer-0.0.1.dist-info/top_level.txt,sha256=cT7JDso1VWzQGJXAXImnyI6JUK_Fw7zjNFsigiwIsNk,11
s3transfer-0.0.1.dist-info/WHEEL,sha256=AvR0WeTpDaxT645bl5FQxUK6NPsTls2ttpcGJg3j1Xg,110
s3transfer/__init__.pyc,,
s3transfer/exceptions.pyc,,
s3transfer/legacy.pyc,,
s3transfer/compat.pyc,,
                                                                                       usr/local/lib/python2.7/dist-packages/s3transfer-0.0.1.dist-info/WHEEL                              0100644 0000000 0000062 00000000156 13077704375 023442  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Wheel-Version: 1.0
Generator: bdist_wheel (0.24.0)
Root-Is-Purelib: true
Tag: py2-none-any
Tag: py3-none-any

                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/s3transfer-0.0.1.dist-info/metadata.json                      0100644 0000000 0000062 00000002056 13077704375 025327  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {"license": "Apache License 2.0", "name": "s3transfer", "metadata_version": "2.0", "generator": "bdist_wheel (0.24.0)", "summary": "An Amazon S3 Transfer Manager", "run_requires": [{"requires": ["botocore>=1.3.0,<2.0.0"]}, {"environment": "python_version==\"2.6\" or python_version==\"2.7\"", "requires": ["futures>=2.2.0,<4.0.0"]}], "version": "0.0.1", "extensions": {"python.details": {"project_urls": {"Home": "https://github.com/boto/s3transfer"}, "document_names": {"description": "DESCRIPTION.rst"}, "contacts": [{"role": "author", "email": "kyknapp1@gmail.com", "name": "Amazon Web Services"}]}}, "classifiers": ["Development Status :: 1 - Planning", "Intended Audience :: Developers", "Natural Language :: English", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5"], "extras": []}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/s3transfer-0.0.1.dist-info/top_level.txt                      0100644 0000000 0000062 00000000013 13077704375 025375  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        s3transfer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/local/lib/python2.7/site-packages/                                                              0042775 0000000 0000062 00000000000 13077704275 016241  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python3.4/                                                                            0042775 0000000 0000062 00000000000 13077704332 013511  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python3.4/dist-packages/                                                              0042775 0000000 0000062 00000000000 13077704332 016230  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/share/                                                                                    0042775 0000000 0000062 00000000000 13077704333 012300  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/share/ca-certificates/                                                                    0042775 0000000 0000062 00000000000 13077704333 015326  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/sbin/                                                                                           0040755 0000000 0000000 00000000000 13077704310 011016  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/sbin/aa-exec                                                                                    0100755 0000000 0000000 00000005140 12442566606 012255  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/perl
# ------------------------------------------------------------------
#
#    Copyright (C) 2011-2013 Canonical Ltd.
#
#    This program is free software; you can redistribute it and/or
#    modify it under the terms of version 2 of the GNU General Public
#    License published by the Free Software Foundation.
#
# ------------------------------------------------------------------

use strict;
use warnings;
use Errno;

require LibAppArmor;
require POSIX;

my $opt_d = '';
my $opt_h = '';
my $opt_p = '';
my $opt_n = '';
my $opt_i = '';
my $opt_v = '';
my $opt_f = '';

sub _warn {
    my $msg = $_[0];
    print STDERR "aa-exec: WARN: $msg\n";
}
sub _error {
    my $msg = $_[0];
    print STDERR "aa-exec: ERROR: $msg\n";
    exit 1
}

sub _debug {
    $opt_d or return;
    my $msg = $_[0];
    print STDERR "aa-exec: DEBUG: $msg\n";
}

sub _verbose {
    $opt_v or return;
    my $msg = $_[0];
    print STDERR "$msg\n";
}

sub usage() {
    my $s = <<'EOF';
USAGE: aa-exec [OPTIONS] <prog> <args>

Confine <prog> with the specified PROFILE.

OPTIONS:
  -p PROFILE, --profile=PROFILE		PROFILE to confine <prog> with
  -n NAMESPACE, --namespace=NAMESPACE	NAMESPACE to confine <prog> in
  -f FILE, --file FILE		profile file to load
  -i, --immediate		change profile immediately instead of at exec
  -v, --verbose			show messages with stats
  -h, --help			display this help

EOF
    print $s;
}

use Getopt::Long;

GetOptions(
    'debug|d'        => \$opt_d,
    'help|h'         => \$opt_h,
    'profile|p=s'    => \$opt_p,
    'namespace|n=s'  => \$opt_n,
    'file|f=s'       => \$opt_f,
    'immediate|i'    => \$opt_i,
    'verbose|v'      => \$opt_v,
);

if ($opt_h) {
    usage();
    exit(0);
}

if ($opt_n || $opt_p) {
   my $test;
   my $prof;

   if ($opt_n) {
      $prof = ":$opt_n:";
   }

   $prof .= $opt_p;

   if ($opt_f) {
       system("apparmor_parser", "-r", "$opt_f") == 0
	   or _error("\'aborting could not load $opt_f\'");
   }

   if ($opt_i) {
       _verbose("aa_change_profile(\"$prof\")");
       $test = LibAppArmor::aa_change_profile($prof);
       _debug("$test = aa_change_profile(\"$prof\"); $!");
   } else {
       _verbose("aa_change_onexec(\"$prof\")");
       $test = LibAppArmor::aa_change_onexec($prof);
       _debug("$test = aa_change_onexec(\"$prof\"); $!");
   }

   if ($test != 0) {
       if ($!{ENOENT} || $!{EACCESS}) {
	   my $pre = ($opt_p) ? "profile" : "namespace";
	   _error("$pre \'$prof\' does not exist\n");
       } elsif ($!{EINVAL}) {
	   _error("AppArmor interface not available\n");
       } else {
	   _error("$!\n");
       }
   }
}

_verbose("exec @ARGV");
exec @ARGV;
                                                                                                                                                                                                                                                                                                                                                                                                                                usr/sbin/aa-status                                                                                  0100755 0000000 0000000 00000014660 12442566606 012663  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python3
# ------------------------------------------------------------------
#
#    Copyright (C) 2005-2006 Novell/SUSE
#    Copyright (C) 2011 Canonical Ltd.
#
#    This program is free software; you can redistribute it and/or
#    modify it under the terms of version 2 of the GNU General Public
#    License published by the Free Software Foundation.
#
# ------------------------------------------------------------------

import re, os, sys

def cmd_enabled():
    '''Returns error code if AppArmor is not enabled'''
    if get_profiles() == {}:
        sys.exit(2)

def cmd_profiled():
    '''Prints the number of loaded profiles'''
    profiles = get_profiles()
    sys.stdout.write("%d\n" % len(profiles))
    if profiles == {}:
        sys.exit(2)

def cmd_enforced():
    '''Prints the number of loaded enforcing profiles'''
    profiles = get_profiles()
    sys.stdout.write("%d\n" % len(filter_profiles(profiles, 'enforce')))
    if profiles == {}:
        sys.exit(2)

def cmd_complaining():
    '''Prints the number of loaded non-enforcing profiles'''
    profiles = get_profiles()
    sys.stdout.write("%d\n" % len(filter_profiles(profiles, 'complain')))
    if profiles == {}:
        sys.exit(2)

def cmd_verbose():
    '''Displays multiple data points about loaded profile set'''
    global verbose
    verbose = True
    profiles = get_profiles()
    processes = get_processes(profiles)

    stdmsg("%d profiles are loaded." % len(profiles))
    for status in ('enforce', 'complain'):
        filtered_profiles = filter_profiles(profiles, status)
        stdmsg("%d profiles are in %s mode." % (len(filtered_profiles), status))
        for item in filtered_profiles:
                stdmsg("   %s" % item)

    stdmsg("%d processes have profiles defined." % len(processes))
    for status in ('enforce', 'complain', 'unconfined'):
        filtered_processes = filter_processes(processes, status)
        if status == 'unconfined':
            stdmsg("%d processes are unconfined but have a profile defined." % len(filtered_processes))
        else:
            stdmsg("%d processes are in %s mode." % (len(filtered_processes), status))
        # Sort by name, and then by pid
        filtered_processes.sort(key=lambda x: int(x[0]))
        filtered_processes.sort(key=lambda x: x[1])
        for (pid, process) in filtered_processes:
            stdmsg("   %s (%s) " % (process, pid))

    if profiles == {}:
        sys.exit(2)

def get_profiles():
    '''Fetch loaded profiles'''

    profiles = {}

    if os.path.exists("/sys/module/apparmor"):
        stdmsg("apparmor module is loaded.")
    else:
        errormsg("apparmor module is not loaded.")
        sys.exit(1)

    apparmorfs = find_apparmorfs()
    if not apparmorfs:
        errormsg("apparmor filesystem is not mounted.")
        sys.exit(3)

    apparmor_profiles = os.path.join(apparmorfs, "profiles")
    if not os.access(apparmor_profiles, os.R_OK):
        errormsg("You do not have enough privilege to read the profile set.")
        sys.exit(4)

    for p in open(apparmor_profiles).readlines():
        match = re.search("^([^\(]+)\s+\((\w+)\)$", p)
        profiles[match.group(1)] = match.group(2)

    return profiles

def get_processes(profiles):
    '''Fetch process list'''
    processes = {}
    contents = os.listdir("/proc")
    for filename in contents:
        if filename.isdigit():
            try:
                for p in open("/proc/%s/attr/current" % filename).readlines():
                    match = re.search("^([^\(]+)\s+\((\w+)\)$", p)
                    if match:
                        processes[filename] = { 'profile' : match.group(1), \
                                                'mode' : match.group(2) }
                    elif os.path.realpath("/proc/%s/exe" % filename) in profiles:
                        # keep only unconfined processes that have a profile defined
                        processes[filename] = { 'profile' : os.path.realpath("/proc/%s/exe" % filename), \
                                                'mode' : 'unconfined' }
            except:
                pass
    return processes

def filter_profiles(profiles, status):
    '''Return a list of profiles that have a particular status'''
    filtered = []
    for key, value in list(profiles.items()):
        if value == status:
            filtered.append(key)
    filtered.sort()
    return filtered

def filter_processes(processes, status):
    '''Return a list of processes that have a particular status'''
    filtered = []
    for key, value in list(processes.items()):
        if value['mode'] == status:
            filtered.append([key, value['profile']])
    return filtered

def find_apparmorfs():
    '''Finds AppArmor mount point'''
    for p in open("/proc/mounts").readlines():
        if p.split()[2] == "securityfs" and \
           os.path.exists(os.path.join(p.split()[1], "apparmor")):
            return os.path.join(p.split()[1], "apparmor")
    return False

def errormsg(message):
    '''Prints to stderr if verbose mode is on'''
    global verbose
    if verbose:
        sys.stderr.write(message + "\n")

def stdmsg(message):
    '''Prints to stdout if verbose mode is on'''
    global verbose
    if verbose:
        sys.stdout.write(message + "\n")

def print_usage():
    '''Print usage information'''
    sys.stdout.write('''Usage: %s [OPTIONS]
Displays various information about the currently loaded AppArmor policy.
OPTIONS (one only):
  --enabled       returns error code if AppArmor not enabled
  --profiled      prints the number of loaded policies
  --enforced      prints the number of loaded enforcing policies
  --complaining   prints the number of loaded non-enforcing policies
  --verbose       (default) displays multiple data points about loaded policy set
  --help          this message
''' % sys.argv[0])

# Main
global verbose
verbose = False

if len(sys.argv) > 2:
    sys.stderr.write("Error: Too many options.\n")
    print_usage()
    sys.exit(1)
elif len(sys.argv) == 2:
    cmd = sys.argv.pop(1)
else:
    cmd = '--verbose'

# Command dispatch:
commands = {
    '--enabled'      : cmd_enabled,
    '--profiled'     : cmd_profiled,
    '--enforced'     : cmd_enforced,
    '--complaining'  : cmd_complaining,
    '--verbose'      : cmd_verbose,
    '-v'             : cmd_verbose,
    '--help'         : print_usage,
    '-h'             : print_usage
}

if cmd in commands:
    commands[cmd]()
    sys.exit(0)
else:
    sys.stderr.write("Error: Invalid command.\n")
    print_usage()
    sys.exit(1)

                                                                                usr/sbin/apparmor_status                                                                            0120777 0000000 0000000 00000000000 12442566612 016014  2aa-status                                                                                           ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/sbin/arp                                                                                        0100755 0000000 0000000 00000154610 12427456104 011535  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF          >    ·!@     @       »“          @ 8 	 @         @       @ @     @ @     ¯      ¯                   8      8@     8@                                          @       @     ∞      ∞                    æ      æ`     æ`     »      Ë                     (æ      (æ`     (æ`     –      –                   T      T@     T@     D       D              PÂtd   Ùô      Ùô@     Ùô@     ,      ,             QÂtd                                                  RÂtd   æ      æ`     æ`                        /lib64/ld-linux-x86-64.so.2          GNU                        GNU j˜±˜ÛÌwFd√49 L«Ω5Ü   E                 E   F   9Úã2ƒ˜≥¢˜                                              o                     ã                      ≈                     ≤                     ß                     ∂                      $                                           ï                      <                     d                     Å                      j                     `                     –                      Ò                      •                      ‡                     ù                      ˘                     û                     \                      O                     ]                     ±                     Ï                     k                                          ‘                     Q                      W                     d                      (                     å                                          ‰                      Í                      |                     ∑                     ∑                      ›                      c                     ∆                      @                      y                     4                     ú                     Ä                     t                      æ                                           0                                            :                      m                      q                     U                     I                                           Ú                     ;                     ¯                      É                     é                     !                     .                                           ™    “`            J      “`            £    “`             libc.so.6 socket __printf_chk exit endprotoent setlocale fopen inet_aton optind setservent strrchr __strdup perror getnetbyaddr inet_ntoa inet_ntop strncpy gettext __stack_chk_fail putchar realloc inet_pton getnetbyname strtol fgets calloc strlen getaddrinfo __errno_location memcmp getnameinfo setprotoent herror __fprintf_chk gethostbyaddr fputc fputs memcpy fclose strtoul malloc __strncpy_chk __ctype_b_loc sscanf optarg stderr ioctl gethostbyname __snprintf_chk getprotoent getopt_long index fwrite strchr __ctype_toupper_loc __strcpy_chk freeaddrinfo __sprintf_chk __h_errno_location uname endservent bindtextdomain __strcat_chk strcmp strerror __libc_start_main snprintf getservent free __gmon_start__ GLIBC_2.14 GLIBC_2.4 GLIBC_2.2.5 GLIBC_2.3.4 GLIBC_2.3                                                                                          îëñ   ∆     ii   —     ui	   €     ti	   Á     ii   Û      ¯ø`        )            “`        F           “`        G           “`        E           ¿`                    ¿`                   (¿`                   0¿`                   8¿`                   @¿`                   H¿`                   P¿`                   X¿`        	           `¿`        
           h¿`                   p¿`                   x¿`                   Ä¿`                   à¿`                   ê¿`                   ò¿`                   †¿`                   ®¿`                   ∞¿`                   ∏¿`                   ¿¿`                   »¿`                   –¿`                   ÿ¿`                   ‡¿`                   Ë¿`                   ¿`                   ¯¿`                    ¡`                   ¡`                   ¡`                    ¡`        !            ¡`        "           (¡`        #           0¡`        $           8¡`        %           @¡`        &           H¡`        '           P¡`        (           X¡`        )           `¡`        *           h¡`        +           p¡`        ,           x¡`        -           Ä¡`        .           à¡`        /           ê¡`        0           ò¡`        1           †¡`        2           ®¡`        3           ∞¡`        4           ∏¡`        5           ¿¡`        6           »¡`        7           –¡`        8           ÿ¡`        9           ‡¡`        :           Ë¡`        ;           ¡`        <           ¯¡`        =            ¬`        >           ¬`        ?           ¬`        @           ¬`        A            ¬`        B           (¬`        C           0¬`        D           HÉÏHãµ´  HÖ¿tË£  HÉƒ√              ˇ5¢´  ˇ%§´  @ ˇ%¢´  h    È‡ˇˇˇˇ%ö´  h   È–ˇˇˇˇ%í´  h   È¿ˇˇˇˇ%ä´  h   È∞ˇˇˇˇ%Ç´  h   È†ˇˇˇˇ%z´  h   Èêˇˇˇˇ%r´  h   ÈÄˇˇˇˇ%j´  h   Èpˇˇˇˇ%b´  h   È`ˇˇˇˇ%Z´  h	   ÈPˇˇˇˇ%R´  h
   È@ˇˇˇˇ%J´  h   È0ˇˇˇˇ%B´  h   È ˇˇˇˇ%:´  h   Èˇˇˇˇ%2´  h   È ˇˇˇˇ%*´  h   È˛ˇˇˇ%"´  h   È‡˛ˇˇˇ%´  h   È–˛ˇˇˇ%´  h   È¿˛ˇˇˇ%
´  h   È∞˛ˇˇˇ%´  h   È†˛ˇˇˇ%˙™  h   Èê˛ˇˇˇ%Ú™  h   ÈÄ˛ˇˇˇ%Í™  h   Èp˛ˇˇˇ%‚™  h   È`˛ˇˇˇ%⁄™  h   ÈP˛ˇˇˇ%“™  h   È@˛ˇˇˇ% ™  h   È0˛ˇˇˇ%¬™  h   È ˛ˇˇˇ%∫™  h   È˛ˇˇˇ%≤™  h   È ˛ˇˇˇ%™™  h   È˝ˇˇˇ%¢™  h    È‡˝ˇˇˇ%ö™  h!   È–˝ˇˇˇ%í™  h"   È¿˝ˇˇˇ%ä™  h#   È∞˝ˇˇˇ%Ç™  h$   È†˝ˇˇˇ%z™  h%   Èê˝ˇˇˇ%r™  h&   ÈÄ˝ˇˇˇ%j™  h'   Èp˝ˇˇˇ%b™  h(   È`˝ˇˇˇ%Z™  h)   ÈP˝ˇˇˇ%R™  h*   È@˝ˇˇˇ%J™  h+   È0˝ˇˇˇ%B™  h,   È ˝ˇˇˇ%:™  h-   È˝ˇˇˇ%2™  h.   È ˝ˇˇˇ%*™  h/   È¸ˇˇˇ%"™  h0   È‡¸ˇˇˇ%™  h1   È–¸ˇˇˇ%™  h2   È¿¸ˇˇˇ%
™  h3   È∞¸ˇˇˇ%™  h4   È†¸ˇˇˇ%˙©  h5   Èê¸ˇˇˇ%Ú©  h6   ÈÄ¸ˇˇˇ%Í©  h7   Èp¸ˇˇˇ%‚©  h8   È`¸ˇˇˇ%⁄©  h9   ÈP¸ˇˇˇ%“©  h:   È@¸ˇˇˇ% ©  h;   È0¸ˇˇˇ%¬©  h<   È ¸ˇˇˇ%∫©  h=   È¸ˇˇˇ%≤©  h>   È ¸ˇˇˇ%™©  h?   È˚ˇˇˇ%¢©  h@   È‡˚ˇˇˇ%ö©  hA   È–˚ˇˇˇ%í©  hB   È¿˚ˇˇˇ%ä©  hC   È∞˚ˇˇPHã5Xπ  øó@ Ë.˝ˇˇø   ËTˇˇˇ@ AWAVπ8   AUATAâ˝USIâÙæ¿ä@ HÅÏ8  Hç¨$`  dHã%(   HâÑ$(  1¿HâÔÛH•æ â@ ø   Ëè˛ˇˇæ6â@ øHâ@ Ë ¸ˇˇøHâ@ ËÊ˚ˇˇø¨á@ ËL(  HÖ¿Hâr≈  Ñ  øRâ@ E1ˆË  HÖ¿Hâ]≈  Ñ  Ä    LçD$HâÈ∫}â@ LâÊDâÔË ¸ˇˇÉ¯ˇâ√ÑP  ÉÎAÉ˚5á?  ˇ$›Äå@ Aæ   Î¬«å∏     Î∂Hã5?∏  ∫   ø “` ËW  ÎûAæ   Îñ«P∏     ÎäAæ   ÎÇ«8∏     Aæ   ÈmˇˇˇHã=˛∑  Lã7®  Aπ Ü@ Hã2®  ∫sâ@ æ   1¿Ë	˛ˇˇø   Ëﬂ˝ˇˇøWâ@ «¯∑      ËK˚ˇˇHã=¥∑  Hâ¬æ   1¿Ë’˝ˇˇÈˇˇˇHã=ë∑  Ë'  HÖ¿Hâ:ƒ  ÑG  «ö∑     È›˛ˇˇ«õ∑     ÈŒ˛ˇˇHã=W∑  Ë∫  HÖ¿Hâƒ  Ö≤˛ˇˇHã;∑  ø∞Ö@ È≤  «c∑     Èí˛ˇˇËı  Hã÷√  ÉxÖF  É=-∑   t>Hã¥√  Éx ék  1“æ   ø   Ëy˝ˇˇÖ¿â∑  à:  AÉ˛w´Bˇ$ı0é@ ø¨á@ ËC&  HÖ¿Hâi√  u¨ø`Ö@ Ë=˙ˇˇπ¨á@ Hã=°∂  Hâ¬æ   1¿Ë¬¸ˇˇÉ»ˇHãî$(  dH3%(   Öh  HÅƒ8  []A\A]A^A_√HcO∂  Lç|$π   LâˇIç,ƒ1¿Û´Hãu HÖˆÑÿ  Lç¥$   ∫Ä   Lâ˜Ë¯T  HãŸ¬  1ˇHçT$`LâˆˇP(Ö¿àí  HãD$`É= ∂   HâD$HãD$hHâD$tHãò¬  ã@fâD$ «D$0   HÉ≈E1ÌêHã] HÖ€Ñò  ãÒµ  Ö¿Ö†  D∂#AÉ¸pÖt  Ä{uÖj  Ä{bÖ`  Ä{ ÖV  AÉÕHÉ≈ÎØHchµ  æ∞á@ Lç¥$   Mã$ƒ∏*â@ MÖ‰LD‡1€LâÁË˚ˇˇHÖ¿Hâ≈Ñ:  HâÍæ   Lâ˜Ë’˘ˇˇHÖ¿ÑÚ  É√É=Vµ  Ñ¬  æ
   Lâ˜ËØ¯ˇˇHÖ¿t∆  ∂¥$   @Ñˆtµ@Ä˛#tØHçt$`Lâ˜Ë˜   ÉËéÏ  Lãl$`æ:   LâÔËl¯ˇˇHÖ¿tHãD$hLâl$hHâD$`Hç|$`ËÓ  Ö¿Ñaˇˇˇøxá@ Ë,¯ˇˇHã=ï¥  Hâ¬Mâ‡âŸæ   1¿Ë±˙ˇˇÈ7ˇˇˇHce¥  «ó¥     Iã<ƒËR  â«Ëk˙ˇˇHcD¥  Iç<ƒËã  â«ÎÁHc0¥  Iã<ƒË'  â«Î”æ‡à@ HâﬂËÊ¯ˇˇÖ¿u1AÉÕHÉ≈ÈE˛ˇˇHã=¥  HâŸ∫°â@ æ   1¿Ë*˙ˇˇHã] È<˛ˇˇæ€à@ HâﬂË§¯ˇˇÖ¿uÉd$0˚HÉ≈È˛ˇˇæÂà@ HâﬂËÖ¯ˇˇÖ¿uÉL$0HÉ≈È„˝ˇˇæÎà@ HâﬂËf¯ˇˇÖ¿u"ÉL$0@HÉ≈Èƒ˝ˇˇøàÖ@ Ë˜ˇˇπRâ@ Èÿ¸ˇˇæÛà@ HâﬂË3¯ˇˇÖ¿Ö’   ÅL$0Ä   HÉ≈Èä˝ˇˇHã=S≥  LâÒ∫õâ@ æ   1¿Ëo˘ˇˇÈ˛ˇˇHâÔËbˆˇˇ1ˇÈÀ˛ˇˇEÖÌIç4∫   æ “` ÑÀ   Ëü¯ˇˇAˆ≈Ö«   AÄÂt+ÉL$0É='≥   Öa  ã=≥  1¿Lâ˙æSâ  Ë»ˆˇˇÖ¿x1ˇÈm˛ˇˇË®ıˇˇã É‡˚É¯Öò  ø¬â@ Ë@ˆˇˇø   Hâ∆LâÚ1¿ËN¯ˇˇÉœˇÈ6˛ˇˇAÉ¸dÖ§   Ä{eÖö   Ä{vÖê   Ä{ ÖÜ   HãuHÖˆÑ7˚ˇˇ∫   ø “` HÉ≈ËQ  Èy¸ˇˇAΩ   ËŒ˜ˇˇÉ=k≤   ÖÖ   ã=O≤  1¿Lâ˙æSâ  ËˆˇˇÖ¿â@ˇˇˇËÔÙˇˇã É‡˚É¯Ö!  AÄÂÖ¯˛ˇˇÈ8ˇˇˇøHá@ ÈG˝ˇˇæ¯à@ HâﬂËõˆˇˇÖ¿Ö©˙ˇˇHã]HÖ€Ñú˙ˇˇæ â@ HâﬂËyˆˇˇÖ¿uIHÉ≈È‹˚ˇˇHã•±  ∫   æ   ø™â@ Ë±˜ˇˇÈ[ˇˇˇHãÖ±  ∫   æ   øÈâ@ Ëë˜ˇˇÈ˛ˇˇ∫Ä   HâﬁLâ˜ËÏˆˇˇHãæ  1ˇHçT$`LâˆˇP(Ö¿à∆   HãD$`ÉL$0 HâD$4HãD$hHâD$<Èmˇˇˇø˝â@ ËËˆˇˇÉœˇÈ∞¸ˇˇË{Ùˇˇø á@ ËëÙˇˇLâ·Hã=˜∞  Hâ¬æ   1¿Ë˜ˇˇÉœˇÈÄ¸ˇˇø◊â@ Ë¶ˆˇˇÉœˇÈn¸ˇˇHã(ø»Ü@ ËQÙˇˇHã=∫∞  Hâ¬æ   HâÈ1¿ËÿˆˇˇâﬂË±ˆˇˇøîâ@ ËgˆˇˇÉœˇËüˆˇˇHãøÜ@ ËÙˇˇHâŸÈ|ˇˇˇHã+Ω  Lâ˜ˇP0ÉœˇÈ¸ˇˇøåà@ ËÎÛˇˇHã=T∞  Hâ¬æ   1¿ËuˆˇˇÉœˇÈ›˚ˇˇHã.∞  øÿÖ@ Î®1ÌIâ—^Hâ‚HÉ‰PTI«¿P@ H«¡‡~@ H««–@ ËÜÙˇˇÙD  ∏ﬂ—` UH-ÿ—` HÉ¯HâÂv∏    HÖ¿t]øÿ—` ˇ‡fÑ     ]√fffff.Ñ     æÿ—` UHÅÓÿ—` H¡˛HâÂHâH¡Ë?H∆H—˛t∏    HÖ¿t]øÿ—` ˇ‡ ]√fD  Ä=ÅØ   uUHâÂËnˇˇˇ]∆nØ  Û√@ ø æ` HÉ? uÎì ∏    HÖ¿tÒUHâÂˇ–]Èzˇˇˇf.Ñ     HÉÏøà@ Ë≤ÚˇˇHã=Ø  Hâ¬æ   1¿Ë<ıˇˇø‡@ ËíÚˇˇHã=˚Æ  Hâ¬æ   1¿Ëıˇˇø8Ä@ ËrÚˇˇHã=€Æ  Hâ¬æ   1¿Ë¸ÙˇˇøêÄ@ ËRÚˇˇHã=ªÆ  Hâ¬æ   1¿Ë‹ÙˇˇøËÄ@ Ë2ÚˇˇHã=õÆ  Hâ¬æ   1¿ËºÙˇˇø@Å@ ËÚˇˇHã={Æ  Hâ¬æ   1¿ËúÙˇˇøòÅ@ ËÚÒˇˇHã=[Æ  Hâ¬æ   1¿Ë|Ùˇˇø–Å@ Ë“ÒˇˇHã=;Æ  Hâ¬æ   1¿Ë\ÙˇˇøÇ@ Ë≤ÒˇˇHã=Æ  Hâ¬æ   1¿Ë<Ùˇˇø@Ç@ ËíÒˇˇHã=˚≠  Hâ¬æ   1¿ËÙˇˇøxÇ@ ËrÒˇˇHã=€≠  Hâ¬æ   1¿Ë¸Ûˇˇø¿Ç@ ËRÒˇˇHã=ª≠  Hâ¬æ   1¿Ë‹ÛˇˇøÉ@ Ë2ÒˇˇHã=õ≠  Hâ¬æ   1¿ËºÛˇˇøHÉ@ ËÒˇˇHã={≠  Hâ¬æ   1¿ËúÛˇˇø†É@ ËÚˇˇHã=[≠  π¨á@ Hâ¬æ   1¿ËwÛˇˇøËÉ@ ËÕˇˇHã=6≠  Hâ¬æ   1¿ËWÛˇˇø   Ëm  ø   Ë#Ûˇˇ AWAVAUATUSHÅÏÿ  dHã%(   Hâú$»  1€HÖˇHâ|$(∆Ñ$–    t_Hâ˛Hçº$–   ∫d   ËïK  Hãvπ  1ˇHçT$@Hç¥$–   ˇP(Ö¿à≤  HãUπ  æ   Hç|$@ˇP Hçº$–   ∫d   Hâ∆ËKK  æ∞á@ ø¥á@ Ë,ÚˇˇHÖ¿Hâ$Ñá  Hã$Hçº$   æ»   ËÈˇˇHÖ¿Ñ∂  ª-   Ω-   Lç¥$@  fâú$   fâ¨$ê  E1ˇ«D$     Hã$Hçº$   æ»   ËöˇˇHÖ¿Ñ!  Hç¨$ê  1¿LâÚæ Ñ@ UHçú$(  SLçå$¿  LçD$LHçL$HHçº$  ËÒˇˇÉ¯AZA[éŸ  Dã¬´  AÉ«EÖ¿tHãB∏  ãL$89HÖuˇˇˇÄº$–    tHç¥$–   Lâ˜Ë+ˇˇÖ¿ÖSˇˇˇÄ=l´   tæ “` HâÔËˇˇÖ¿Ö5ˇˇˇã={´  ÉD$ÖˇÑ2  Aº≤á@ ã5R´  Dãl$<ÖˆÑq  AÄ<$?ã|$8MDÊLâd$Ë‚  HÖ¿HâD$ Ñ‹  ã.´  çPÖ¿â#´  ÑÖ  DâËÉ‡âD$Ö–  Lç§$¿   ∆Ñ$¿    Aˆ≈Öü  DâËÉ‡âD$Ö  Aˆ≈ÄÖ·  Aˆ≈@Ö¿  Aˆ≈Öü  HãT$AÉÂ ∏ â@ HDÿæ∆á@ 1¿ø   ËˇˇãL$Ö…Ö  ãT$Ö“Ñ   ø—á@ Ë–Ìˇˇ∫‚á@ Hâ¡æ‰á@ ø   1¿Ë◊ÔˇˇIâËHâŸLâ‚æ à@ ø   1¿ËΩÔˇˇÈ¯˝ˇˇÑ     Hã±∂  1ˇHçT$@LâˆˇP(Ö¿à≤˛ˇˇã5™  Hãè∂  Hç|$@ÅŒ Ä  ˇP LâˆHâ«IâƒË{ÓˇˇÖ¿∏≤á@ LD‡È˛ˇˇ ã|$8Ë  HÖ¿Iâ¿Ñè  øà@ LâD$ËÌˇˇLâÒHâ∆Lâ‚1¿ø   ËÔˇˇAˆ≈LãD$Ö¸  Aˆ≈Ö  ø1à@ Ë‹Ïˇˇø   Hâ∆1¿ËÌÓˇˇAˆ≈ ÖÆ  Aˆ≈Öé  Aˆ≈Ön  Aˆ≈ÄÖN  Aˆ≈@Ö.  AÉÂtæià@ ø   1¿Ë§Óˇˇøpà@ ËzÏˇˇHâÍHâ∆ø   1¿ËàÓˇˇÈ√¸ˇˇ Dã˝®  EÖ…Öõ  ãD$Ö¿Ñ6  Hã<$Ë€Îˇˇ1¿Hãú$»  dH3%(   ÖÃ  HÅƒÿ  []A\A]A^A_√øÛá@ ËÏˇˇ∫ â@ Hâ¡æ‰á@ ø   1¿ËÓˇˇÈ1˛ˇˇø@Ñ@ ËﬁÎˇˇø   Hâ∆1¿ËÔÌˇˇÈ]˝ˇˇHãD$ Hçå$∞  æ‰á@ ø   Hã1¿Ë…ÌˇˇÈÌ˝ˇˇ∫
   æïé@ LâÁËrÍˇˇÈJ˝ˇˇLç§$¿   f«Ñ$¿   C È)˝ˇˇ∫
   æ„ï@ LâÁËDÍˇˇÈJ˝ˇˇ∫
   æƒá@ LâÁË-ÍˇˇÈ)˝ˇˇ∫
   æ¬á@ LâÁËÍˇˇÈ˝ˇˇ∫
   æë@ LâÁËˇÈˇˇÈÁ¸ˇˇÉ=∑ß   uQE1ˇÄº$–    t|É=ïß   Ñ$  ø¿Ñ@ ËÌÍˇˇDâ˙Hâ∆ø   1¿Ë˚ÏˇˇÈí˛ˇˇæà@ ø   1¿ËÂÏˇˇÈÛ˝ˇˇ«D$    E1ˇøòÑ@ Ë´Íˇˇã\$Dâ˘Hâ∆Dâ˙ø   1¿)ŸAâÿË≠ÏˇˇÈ8˛ˇˇÉ=ß   uàÄ=¯¶   Ñ.˛ˇˇÈvˇˇˇæ`à@ ø   1¿Ë|ÏˇˇÈº˝ˇˇæZà@ ø   1¿ËfÏˇˇÈú˝ˇˇædà@ ø   1¿ËPÏˇˇÈ|˝ˇˇæTà@ ø   1¿Ë:ÏˇˇÈ\˝ˇˇøHà@ ËÍˇˇHâ⁄Hâ∆ø   1¿ËÏˇˇÈ1˝ˇˇIãHçî$∞  æ?à@ ø   1¿Ë¯ÎˇˇÈ˝ˇˇøwà@ Ë…ÈˇˇHãT$(Hçå$–   Hâ∆ø   1¿ËÕÎˇˇÈd˝ˇˇø¨á@ Ëé  HâD$ È˚ˇˇø¨á@ Ëz  Iâ¿È_¸ˇˇHã£≤  Hçº$–   ˇP0É»ˇÈ/˝ˇˇø¥á@ ËûÎˇˇÉ»ˇÈ˝ˇˇË1ÈˇˇêAWAVπ   AUATUSHâ˚HÅÏò  Hã3Lçd$0dHã%(   HâÑ$à  1¿LâÁHÖˆÛH´«    ÑQ  Hçº$   ∫Ä   Ë5D  Hã≤  1ˇHçî$Ä   Hç¥$   ˇP(Ö¿àC  HãÑ$Ä   HãkHâD$0HãÑ$à   HÖÌHâD$8Ñ˛  ã5D•  ÖˆÑÃ  ã&•  Ö…Ö  ∫   HâÓHâÁËﬁÁˇˇã=•  1¿Hâ‚æ'â  HÉ√∆D$ IâÂËΩËˇˇÖ¿àÌ  HãD$ãÓ§  HâD$@HãD$Ö“HâD$HÖ≥  Ω   AΩ   Ñ     HãHÖ¿t"ø€à@ Hâ∆LâÈÛ¶Ö  HÉ√HãÉÂ˚HÖ¿uﬁIç|$4∫   æ “` âl$PËﬁÈˇˇã|§  Ö¿Ö0  ã=^§  1¿Lâ‚æUâ  ËËˇˇÖ¿à  1¿Hãú$à  dH3%(   Ö-  HÅƒò  []A\A]A^A_√∫   HâÓHâÁLã5ñ∞  HÉ√IâÂË Êˇˇã=¯£  1¿Hâ‚æ'â  ∆D$ Ë∞ÁˇˇÖ¿à‡  MÖˆÑÍ˛ˇˇ∑D$øΩà@ A;FÑ÷˛ˇˇË&ÁˇˇHã=è£  Hâ¬æ   1¿Ë∞Èˇˇ∏ˇˇˇˇÈUˇˇˇfD  ∂É˙pu(Äxuu"ÄxbuÄx uÉÕHÉ√È∫˛ˇˇf.Ñ     ø‡à@ Hâ∆LâÈÛ¶uÉÂ˜HÉ√Èï˛ˇˇD  øÂà@ π   Hâ∆Û¶uÉÕHÉ√Ès˛ˇˇ øÎà@ π   Hâ∆Û¶uÉÕ@HÉ√ÈS˛ˇˇ øÛà@ Hâ∆LâÈÛ¶u@ÄÕÄHÉ√È4˛ˇˇ@ É˙du;Äxeu5Äxvu/Äx u)HãsHÖˆÑ∫  ∫   ø “` HÉ√ËYA  ÈÙ˝ˇˇ@ ø¯à@ π   Hâ∆Û¶Öâ  HãCHÖ¿Ñ|  ø â@ π   Hâ∆Û¶Ö∂   HÉ√È∞˝ˇˇHãÈÆ  HÉ√Içt$HâÔˇP Ö¿â˝ˇˇø@Ö@ È}˛ˇˇÑ     Hã	¢  ∫   æ   øâ@ ËËˇˇÈ∞˝ˇˇ∑|$Ë∆  HÖ¿Iâ∆Ñû   Hã@HÖ¿Ñë   Iç}ˇ–Mã.øÖ@ Iâ«ËGÂˇˇHã=∞°  Hâ¬Mâ˘MâËHâÈæ   1¿Ë»ÁˇˇÈ¸ˇˇHçº$   ∫Ä   Hâ∆ËÁˇˇHã/Æ  1ˇHçî$Ä   Hç¥$   ˇP(Ö¿x`HãÑ$Ä   ÉÕ HâD$THãÑ$à   HâD$\ÈÛ˛ˇˇøˇˇˇˇË  Iâ∆Hã@ÈYˇˇˇøåà@ ÈÅ˝ˇˇø°à@ Èw˝ˇˇø!â@ ËÿÊˇˇ∏ˇˇˇˇÈ›¸ˇˇHãØ≠  Hçº$   ˇP0∏ˇˇˇˇÈ¡¸ˇˇË≠ÒˇˇËH‰ˇˇË≥„ˇˇã8ËÁˇˇøËÑ@ Hâ√ËO‰ˇˇHã=∏†  Hâ¬IâÿHâÈæ   1¿Ë”ÊˇˇÈ˝ˇˇf.Ñ     @ HÉÏøXé@ Ë‰ˇˇø_é@ Hâ.ú  Ë‰ˇˇøké@ Hâùú  Ë„ˇˇøzé@ HâLñ  Ëﬂ„ˇˇøé@ Hâªñ  ËŒ„ˇˇøäé@ Hâjì  ËΩ„ˇˇøóé@ HâYò  Ë¨„ˇˇø¢é@ Hâó  Ëõ„ˇˇø∞é@ Hâ˜ì  Ëä„ˇˇø∑é@ Hâfî  Ëy„ˇˇø¬é@ Hâïú  Ëh„ˇˇøÃé@ Hâô  ËW„ˇˇHâ8í  ∏   fâ(°  HÉƒ√ffffff.Ñ     fÉ=°   ATIâ¸UStHã¯è  HÖ€t3ΩÄ¬` Î@ HÉ≈Hã] HÖ€tHã;LâÊË ‰ˇˇÖ¿u‰Hâÿ[]A\√@ æ,   LâÁ1€ËA„ˇˇHÖ¿t‡øè@ Ë¬‚ˇˇHã=+ü  Hâ¬æ   1¿ËLÂˇˇHâÿ[]A\√@ 1¿Ëy˛ˇˇÈuˇˇˇ@ HÉÏfÉ=h†   tBHã[è  HÖ¿t'9xt"∫Ä¬` Îf.Ñ     9xtHÉ¬HãHÖ¿uÔHÉƒ√f.Ñ     1¿â|$Ë˛ˇˇã|$Î≠ffffff.Ñ     HÉÏfÉ=¯ü   tRHãÎé  ∏ˇˇˇˇHÖ“t'9zt,∏Ä¬` Î
D  9ztHÉ¿HãHÖ“uÔ∏ˇˇˇˇHÉƒ√D  ãBPHÉƒ√Ñ     1¿â|$Ëï˝ˇˇã|$Îùffffff.Ñ     AVAUHâ˛ATU∫   SHÅÏ  HâÁIâÂdHã%(   HâÑ$  1¿Ë´<  Lã5ƒé  @ æ,   LâÔË√·ˇˇHÖ¿Ñ:  Lç`∆  MÖˆt"Lâˆª √` LâÔË^‚ˇˇÖ¿â≈t`HÉ√Hã3HÖˆuÊø“é@ Ω   Ë·ˇˇHã=vù  Hâ¬LâÈæ   1¿Ëî„ˇˇHãú$  dH3%(   âËÖ¯   HÅƒ  []A\A]A^√ LãkLâÔËå‡ˇˇπÄ“` ã1HÉ¡çñˇ˛˛˛˜÷!ÚÅ‚ÄÄÄÄtËâ÷¡Ó˜¬ÄÄ  D÷HçqHDŒ “HÉŸHÅÈÄ“` HçDH=ˇ   wgHãCHÖ¿tÉ Ä=<ù   u*∫   LâÓøÄ“` Ë(ﬂˇˇMÖ‰ÑKˇˇˇMâÂÈ◊˛ˇˇÄ    ∫   æ–é@ øÄ“` Ë¸ﬁˇˇÎ¿f.Ñ     E1‰È≈˛ˇˇøPè@ Ë˛ﬂˇˇHã=gú  Hâ¬æ   1¿Ëà‚ˇˇÈÔ˛ˇˇËæﬂˇˇfffff.Ñ     AUATIâ¸USøÄ“` HâÛHâ÷∫   HÉÏËÆ·ˇˇHâﬂæ/   Ë—ﬂˇˇHçPHÖ¿HE⁄HâﬂË^‡ˇˇHÖ¿Hâ≈Ñä   LâÁËJﬂˇˇHâﬂIâ≈Ë?ﬂˇˇI9≈sBL)ËLâÊHç\ HâﬂËá‡ˇˇÖ¿u+∆ æ_   HâÔËSﬂˇˇHÖ¿t∆  HâÔ∆ú   Ëå˝ˇˇÖ¿uHÉƒHâÔ[]A\A]È&ﬁˇˇfD  ∫   HâÓøÄ“` Ë˛‡ˇˇÎ‘@ HÉƒ[]A\A]√ffff.Ñ     AUATAâ¸USHÉÏfÉ=Øú   Ñ≈   ªÄ¬` 1ÌAΩVUUUÎxfD  ãFÖ¿tgâËA˜ÌâË¡¯)¬çR9≈u&Hã=ˇö  ÖÌ∏é@ ∫Òé@ æ   HE–1¿Ë·ˇˇHã3HãLãF∏ˆé@ Hã=Õö  ∫˘é@ æ   HÖ…HD»1¿É≈Ë‚‡ˇˇHÉ√Hã3HÖˆtAÉ¸uÄHÉ~8 ÖuˇˇˇÎ· Hã5âö  HÉƒø
   []A\A]È≈ﬁˇˇD  1¿ËŸ˘ˇˇÈ/ˇˇˇ@ ATUIâÙSHçnHÉÏdHã%(   HâD$1¿ãç  HÖˇfâÑœ   1€∫   HâÊËﬂˇˇHòçS∂Ä∞è@ àD Hã<$∂Ñ¿t<:u1â”HÉ«É˚?wHÖˇuƒêÉ˙?â–wâ¬É¿É¯?∆D …vÒ1¿ÎVfD  øtè@ ËV›ˇˇHã=øô  Hâ¬æ   1¿Ë‡ﬂˇˇH∏……………………IâD$HâEHâEHâEHâE HâE(HâE0HâE8∏ˇˇˇˇHãL$dH3%(   uHÉƒ[]A\√Ä    1¿ÈpˇˇˇËƒ‹ˇˇ@ ATUSHÉÏ∆1õ  [D∂AÄ¯ˇtoAÄ¯…tiHç_ø‘` Hâ|$Aâ¸∫   1¿πäè@ æ   HçoHÉ√ËÇﬂˇˇD∂CˇHâÔAÄ¯ˇï¬AÄ¯…ï¿Ñ¬t
âËD)‡É¯@uæ∆E ]∆E HÉƒ[∏ ‘` ]A\√Ω‘` Î„êfÉ?t∫@   æéè@ ø¿”` Èv7  fD  HÉ«ÈGˇˇˇÄ    AWAVAUATIâıUSHçZHÉÏãµã  fâ∂.@Ä˝-Ñ9  @ÑÌÑ0  Ë∑ﬁˇˇHâ«IçEMâÏHâ$Lã7Læ˝IÉƒC∑~â—ÄÊtHâ|$Ëà⁄ˇˇHã Hã|$Jæ∏A∑FHâ≈ÄÂ	tNÌHÉ√Dâ‚@àkˇA∂,$D)Í@Ä˝-ts@ÑÌtnL;$$uü@ÑÌÖΩ   Ä    ∆ 1¿HÉƒ[]A\A]A^A_√@ ø¿è@ ËF€ˇˇ∫Ä   Hâ∆ø ’` Ët6  Ë⁄ˇˇ«    HÉƒ∏ˇˇˇˇ[]A\A]A^A_√D  É˙ÑÜ   É˙çBÄ    É¿HÉ√∆Cˇ@çPˇÉ˙~ÌA∂$<-ÖpˇˇˇIç|$∫
   1ˆË'‹ˇˇ¿à1¿ÈYˇˇˇMâÏ∏   Î∫ø—è@ Ë®⁄ˇˇ∫Ä   Hâ∆ø ’` Ëñ‹ˇˇË·Ÿˇˇ«    ∏ˇˇˇˇÈˇˇˇ@Ä˝-t£È˛˛ˇˇfD  SHâÚHâÛHâ˛1ˇË?˛ˇˇÖ¿x∏   fâ1¿[√Ä    ∏ˇˇˇˇ[√ê1“1…@ ∂–Ë< D¡HÉ¬àÇø‘` HÉ˙uÂS∆;ô   D∂GAÉ‡Dâ√—˚t,ø¿‘` ËÀŸˇˇHç∏¿‘` Aâÿπ„è@ H«¬ˇˇˇˇæ   1¿Ë…‹ˇˇ∏¿‘` [√fêHÖˇt+Hâ˘Hã=1ñ  A∏ ’` ∫Áè@ æ   1¿ÈJ‹ˇˇf.Ñ     Hã=	ñ  π ’` ∫yâ@ æ   1¿È#‹ˇˇ ∑ÉËfÉ¯˝wHÉ«È+ˇˇˇ HÉÏøéè@ ËZŸˇˇ∫@   Hâ∆øÄ‘` HÉƒÈÑ4  @ HÉÏD∂OD∑Gπ˛è@ ∫@   æ   fA¡»øÄ’` E∑¿1¿Ë˛€ˇˇ∏Ä’` HÉƒ√@ fÉ?t*HÉÏøéè@ ËÏÿˇˇ∫@   Hâ∆ø¿’` HÉƒÈ4  fD  HÉ«Îäf.Ñ     USHâÛHâ’æ2ó@ HâﬂHÉÏdHã%(   HâD$1¿HçL$Hâ‚ËO⁄ˇˇÉ¯tBÉ¯t%∏ˇˇˇˇHã|$dH3<%(   uWHÉƒ[]√fÑ     ãD$àEã$àE1¿ÎœÄ    HçT$1¿æ‰è@ HâﬂËÙŸˇˇâ¬∏ˇˇˇˇÉ˙u®ãD$∆E àE1¿ÎôËÙ◊ˇˇ@ HÉÏD∂D∂Gπ2ó@ ∫@   æ   ø ÷` 1¿Ëÿ⁄ˇˇ∏ ÷` HÉƒ√fffff.Ñ     fÉ?t
øéè@ È¿◊ˇˇHÉÏD∂OD∂Gπ2ó@ ∫@   æ   ø ÷` 1¿Ëá⁄ˇˇ∏ ÷` HÉƒ√f.Ñ      UHâÂAUATSIâ¸IâıHÉÏË8◊ˇˇçPLâÊHc“HÉ¬HÉ‚H)‘HçPHâÁHâ„Ëµÿˇˇ∂$1ˇâ¯Ñ“Ñ§   D  HÉˇÑ-  Ä˙	uêHÉ√∂Ä˙	tÙÄ˙ tÔÄ˙'Mâd˝ Ñ±   Ä˙"Ñ®   ∂ˆ¬ﬂÑ˝   Ä˙	Lâ‡uÈ   Ä    Ä˙	tHÉ¿HÉ√àPˇ∂ˆ¬ﬂuËÑ“Lç`∆  uÎ HÉ√∂Ä˙	tÙÄ˙ tÔHÉ«Ñ“â¯Öaˇˇˇπ   Hc)¡IçTı HçLIçLÕ Ñ     H«    HÉ¬H9 uHçeË[A\A]]√D  ∂CHçKÑ¿uÎ2fêIÉƒHÉ¡AàD$ˇ∂Ñ¿t8¬uËÄyˇ\t‚Lâ‡HçY∂QÈRˇˇˇfêA∆$ HâÀIÉƒ1“HÉ«È^ˇˇˇ∏   È^ˇˇˇLâ‡È'ˇˇˇÄ    HÉÏø-ê@ Ë“’ˇˇøXé@ HâŒâ  Ë¡’ˇˇø?ê@ Hâ˝â  Ë∞’ˇˇø<ê@ Hâ,ç  Ëü’ˇˇøQê@ Hâ€å  Ëé’ˇˇøNê@ Hâäå  Ë}’ˇˇøfê@ Hâ9å  Ël’ˇˇø~ê@ HâËã  Ë[’ˇˇøÃé@ Hâóè  ËJ’ˇˇø(ë@ HâÜÑ  Ë9’ˇˇøáê@ Hâıè  Ë(’ˇˇøé@ Hâ$ë  Ë’ˇˇø¬é@ HâÖ  Ë’ˇˇøäé@ Hâã  Ëı‘ˇˇøçê@ HâÒâ  Ë‰‘ˇˇøöê@ Hâ`é  Ë”‘ˇˇø¶ê@ Hâèå  Ë¬‘ˇˇøæê@ Hâ˛â  Ë±‘ˇˇøÀê@ Hâmê  Ë†‘ˇˇø–ê@ Hâê  Ëè‘ˇˇø◊ê@ HâKé  Ë~‘ˇˇøËê@ Hâ∫è  Ëm‘ˇˇøë@ Hâiè  Ë\‘ˇˇøë@ Hâòä  ËK‘ˇˇø∞é@ Hâà  Ë:‘ˇˇøë@ Hâ6é  Ë)‘ˇˇHâ™é  ∏   fâ∂î  HÉƒ√êfÉ=®î   ATIâ¸USt?HãXÖ  HÖ€t'Ω «` Î@ HÉ≈Hã] HÖ€tHã;LâÊË ’ˇˇÖ¿u‰Hâÿ[]A\√@ 1¿ËŸ˝ˇˇÎ∏Ä    HÉÏfÉ=Dî   tBHã˚Ñ  HÖ¿t'9xt"∫ «` Îf.Ñ     9xtHÉ¬HãHÖ¿uÔHÉƒ√f.Ñ     1¿â|$Ëu˝ˇˇã|$Î≠ffffff.Ñ     AUATAâ¸USHÉÏfÉ=Àì   Ñ≈   ª «` 1ÌAΩVUUUÎwfD  É~ˇtgâËA˜ÌâË¡¯)¬çR9≈u&Hã=`è  ÖÌ∏é@ ∫Òé@ æ   HE–1¿Ët’ˇˇHã3HãLãF∏ˆé@ Hã=.è  ∫˘é@ æ   HÖ…HD»1¿É≈ËC’ˇˇHÉ√Hã3HÖˆtAÉ¸uÅãFÖ¿tÁÈuˇˇˇD  Hã5Èé  HÉƒø
   []A\A]È%”ˇˇD  1¿Ëy¸ˇˇÈ/ˇˇˇ@ ãGÖ¿tÄ> u$ÉËHÎ@ HÉ∆Ä> uH9∆uÚ∏   √@ 1¿√f.Ñ      ã?Èô—ˇˇfÑ     ATUHâ’SHâÛæ/   HÉÏdHã%(   HâD$1¿ËË—ˇˇHâ¡1¿HÖ…t^Hçy1“∆ HâÊË‘ˇˇIâƒHã$Ä8 uaHÖÌtEâ‡π ê@ H«¬ˇˇˇˇæ   HâÔ1¿Ë~‘ˇˇ∫ˇˇˇˇDâ·∏   ”Ífâ∏   ˜“ âSHã\$dH3%(   uHÉƒ[]A\√Ä    ∏ˇˇˇˇÎŸË$—ˇˇ@ ÈÎ“ˇˇff.Ñ     AVAUATUSHâÛHÉÏdHã%(   HâD$1¿fÉ>Ö  DãFHâ˝Aâ‘EÖ¿DâD$Ñ   AÅ‰ˇ  u˜—DÖ¡u	ÄÊ@Ñˆ   Hã/ì  ∏   HÖ“uÈâ   HãR HÖ“twD;BuÒ9BuÏHãrHâÔ∫Ä   Ë€+   Hãt$dH34%(   Dâ‡Öó  HÉƒ[]A\A]A^√@ AÅ‰ˇ  tgã{E1‰ËÏœˇˇ∫Ä   Hâ∆HâÔËå+  Î≤f.Ñ     Dâ«Ö¿œtwHç|$∫   æ   Ëì“ˇˇHÖ¿ÑÒ   Hã0∫Ä   HâÔAæ   ËD+  ÎhfêÄÊÄ∫Ä   Ñ∫   æIë@ Ë(+  ÈKˇˇˇ Hã9í  1¿HÖ“ÖˇˇˇDâ«œfÑ     æ   Ëñ—ˇˇHÖ¿Ñß   Hã0∫Ä   HâÔE1ˆË⁄*  ø(   Ë0—ˇˇIâ≈HãHãSHâÔEâuIâE Hã‘ë  IâUIâE Ë7œˇˇHçXHâﬂË˚–ˇˇHâ⁄HâÓHâ«IâEËπ–ˇˇLâ-¢ë  È•˛ˇˇD  æ‚á@ Ën*  Èë˛ˇˇAæ   ã{Ë´Œˇˇ∫Ä   Hâ∆HâÔËK*  ÈlˇˇˇE1ˆÎﬁêËKŒˇˇAºˇˇˇˇ« a   ÈR˛ˇˇË≈ŒˇˇD  HÉÏ∑ÉËfÉ¯˝w0âÚπ ˇˇˇHâ˛ø ◊` Ëå˝ˇˇ∫    Ö¿∏ ◊` HE¬HÉƒ√Ä    øéè@ ËñŒˇˇ∫Ä   Hâ∆ø ◊` HÉƒÈ¿)  ATUHâ’SHâÛHÉÏdHã%(   HâD$1¿ÉˇÑ±   Åˇ   tQ∏   øIë@ π   fâ1“fâUÛ¶ÖQ  «E    Aº   Hã\$dH3%(   Dâ‡Ö¿  HÉƒ[]A\√@ 1ˆπ   øIë@ fâ
fârπ   HâﬁÛ¶t∞HçrHâﬂËeœˇˇÖ¿AâƒÖ  HâﬂËœˇˇHÖ¿Ñ  Hã@Hã ã âEÎá ø   E1¿«D$    fâ:fDâBË[ÃˇˇHçt$Hç{IâÿIæHããäçQøAàÄ˙wZÉÈ7
àMæHHãæ…¡·àBãäDçJøAàPAÄ˘wIÉÍ7	—àIÉ¿HÉ∆I9¯uÆãD$EâƒA)‹»âEÈı˛ˇˇfÑ     ÉÈ0Ä˘	á¨   
àÎõfD  ÉÍ0Ä˙	áî   	—àÎ¨fD  HçuHâﬂËdŒˇˇÖ¿AâƒuHâﬂËÖÃˇˇHÖ¿t@ã@A¥»âEÈå˛ˇˇE1‰ÈÑ˛ˇˇÑ     HâﬂËXÃˇˇHÖ¿t$ã@Aº   »âEÈ\˛ˇˇHâﬂË∏ÕˇˇHÖ¿Ö∂˛ˇˇË∫ÀˇˇHâ√Ë“Àˇˇã âfD  AºˇˇˇˇÈ)˛ˇˇË(ÃˇˇÑ     HÉÏ∑ÉËfÉ¯˝w0â—âÚHâ˛øÄ◊` ËÔ˙ˇˇ∫    Ö¿∏Ä◊` HE¬HÉƒ√f.Ñ     øéè@ ËˆÀˇˇ∫Ä   Hâ∆øÄ◊` HÉƒÈ '  AUAT∏‚á@ USâ˚HÉÏÖˇÑó   Ö“ÖØ   Ä=òå   IâıÑ'  ∆»å   A∂E É¯tÖ    AÄ}cÖ   AÄ}puxAÄ} uqHãÚç  HÖ¿uÎc Hã@HÖ¿tW;uÛLã@πûâ@ 1¿∫@   æ   ø¿÷` Ë4Œˇˇ∂]å  Ñ¿t)∏¿÷` @ HÉƒ[]A\A]√D  AÄ}dÑµ  D  Aâÿπ‰è@ ∫@   fA¡»æ   E∑¿ø¿÷` 1¿ËŸÕˇˇHÉƒ∏¿÷` []A\A]√fÑ     É¯ut´É¯ru∂AÄ}auØAÄ}wu®AÄ} u°Hãç  HÖ¿uÎì Hã@HÖ¿tá;uÛÈ+ˇˇˇfD  ø   Ë.ÀˇˇfD  Ëì…ˇˇHÖ¿Iâƒtvø   ËÃˇˇHÖ¿Hâ≈Ñµ  Iã<$ËÀˇˇHâEAãD$âE IãD$∂É˙tÖ«   Äxcu±Äxpu´Äx u•Hãéå  HÖ¿ÑU  HâEHâ-zå  Ë…ˇˇHÖ¿IâƒuäËPÃˇˇø   Ë∆ ˇˇËÅ ˇˇHÖ¿Iâƒt[ø   ËoÀˇˇHÖ¿Hâ≈Ñ3  Iã<$Ëä ˇˇHâEA∑D$f¡»∑¿âE Hãå  HÖ¿Ñ∆   HâEHâ-Ûã  Ë& ˇˇHÖ¿Iâƒu•Ëπ»ˇˇ∆Rä  Èæ˝ˇˇD  É˙utKÉ˙rÖ‚˛ˇˇÄxaÖÿ˛ˇˇÄxwÖŒ˛ˇˇÄx Öƒ˛ˇˇHãùã  HÖ¿Ñ4  HâEHâ-âã  È§˛ˇˇ@ ÄxdÖñ˛ˇˇÄxpÖå˛ˇˇÄx ÖÇ˛ˇˇHãcã  HÖ¿Ñ⁄   HâEHâ-Oã  Èb˛ˇˇf.Ñ     Hâ-1ã  H«E    È÷˛ˇˇ@ Hâ-)ã  H«E    È,˛ˇˇ@ øQë@ Ë÷ ˇˇÈ<˛ˇˇêøQë@ Ë∆ ˇˇIã<$ËM…ˇˇHâ%   A∑D$È∫˛ˇˇf.Ñ     AÄ}pÖE˝ˇˇAÄ} Ö:˝ˇˇHã≥ä  HÖ¿uÈ)˝ˇˇfÑ     Hã@HÖ¿Ñ˝ˇˇ;uÔÈ∑¸ˇˇf.Ñ     Hâ-yä  H«E    ÈÑ˝ˇˇ@ Hâ-Yä  H«E    Èl˝ˇˇ@ Èã…ˇˇff.Ñ     USHâ˝HÉÏãÖ“uãFÖ¿u
Å~  ˇˇtêHÉƒHâË[]√fD  æ.   Hâ˚Ë£«ˇˇHÖ¿tﬁH9√rÎ/Ä    HÉËH9ÿtÄ8:uÚHÉ¿HEÿHÉƒHâ›HâË[]√D  Ä8:t·Hâ›HÉƒHâË[]√fD  ATUHâıSHâ”HÉÏPdHã%(   HâD$H1¿Éˇt}HçT$1¿π   1ˆHâ◊ÛH´HçL$HâÔ«D$
   Ë§…ˇˇÖ¿Ö¨   Hã|$HãGHãHâHãPHâSHãPHâSã@âC1€Ë†…ˇˇHãt$HdH34%(   âÿÖú   HÉƒP[]A\√ê∏
   HÉ√@∑
fâ1“«C    fâS˙«C¸    Hâ⁄Ëı«ˇˇÖ¿~YHâﬁHâÔª   Ëë˛ˇˇH9≈IâƒtôHâ«Ë!∆ˇˇHçPLâÊHâÔË≤«ˇˇÎÄHã=©Ç  Aâ¿HâÈ∫Yë@ æ   1¿ªˇˇˇˇËΩ»ˇˇÈXˇˇˇªˇˇˇˇÈNˇˇˇËÈ≈ˇˇfÑ     S∑Hâ˚øéè@ çPˇfÉ˙˝w{fÉ¯
ue˜∆ˇ  Öâ   DãSEÖ“uDãKEÖ…Ñ£   HÉÏE1…E1¿j πˇ   ∫¿ÿ` æ   HâﬂË0∆ˇˇÖ¿ZYÖ·   HÉ√ø¿ÿ` Hâﬁ[È¥˝ˇˇ@ ËÀƒˇˇ« a   øÇë@ Ëk≈ˇˇ[∫Ä   Hâ∆ø¿ÿ` Èò   Ñ     HÉ√ø
   πP   Hâﬁ∫¿ÿ` Ë%ƒˇˇHâﬁø¿ÿ` [ÈW˝ˇˇÄ    DãCEÖ¿ÖPˇˇˇã{ÖˇÖEˇˇˇÅÊ Ä  t(HÉ√H∏default ø¿ÿ` HâﬁHâà  [È˝ˇˇD  HÉ√ø¿ÿ` «Âá  [::]Hâﬁ∆ﬂá   [ÈÂ¸ˇˇHãÅ  ∫   æ   ønë@ Ë*«ˇˇÈ ˇˇˇD  SHâ˛Hâ˚πP   ø
   ∫@ÿ` Ëe√ˇˇHâﬁø@ÿ` [Èó¸ˇˇÄ    AWAVAâ˜AUATæ∞á@ USøüë@ HÅÏ8  dHã%(   HâÑ$(  1¿ËZ∆ˇˇHÖ¿Iâ∆ÑÖ  AÅÁ   Dâ|$Öú  øœë@ Hçú$–   Lçl$Ëı√ˇˇø   Hâ∆1¿Ë∆ˇˇLçc#øêí@ Ëÿ√ˇˇø   Hâ∆1¿ËÈ≈ˇˇfÑ     Hçº$   LâÚæˇ  ËªƒˇˇHÖ¿Ñ⁄  HÉÏMâÈæ‡í@ Hç¨$  HçL$}UHçD$(PHçD$<PHçD$@PHçD$DPHçCATPHçCPHçCPHçCPHçC
PHçCPSHçÑ$ú   PHçÑ$  Hçî$;  RHçPRHçPRHçPRHçPRHçP
RHçPRPHçÑ$‡   PHçÑ$S  PHçÑ$V  PHçÑ$Y  PHçÑ$\  P1¿LçÑ$Z  Hçî$P  Hçº$   ËäƒˇˇHÅƒ‡   ˆD$ÑX  ãL$Ö…ÑÏ˛ˇˇHÉÏA∏Íë@ πÄ   HçÑ$õ   ∫   æÄ   PHçÑ$û   PHçÑ$°   PHçÑ$§   PAUHçÑ$™   PHçÑ$≠   P1¿Lçå$∞   Hçº$`  ËD¡ˇˇHÉƒ@ø   HçT$0Hç¥$   ˇ0u  Dã|$(Hç|$0æ   ˇu  HÉÏIâ¡A∏í@ AWπÄ   ∫   æÄ   1¿Hçº$0  ËÊ¿ˇˇHçCLâ$$IâŸA∏Íë@ πÄ   ∫   PHçCæÄ   PHçCPHçCPHçC
PHçCP1¿Hçº$‡  Ëù¿ˇˇHÉƒ@ø   HçT$PHç¥$†  ˇât  æ   Hç|$Pˇqt  Hçº$†  Hâ¡∫ûâ@ 1¿æÄ   Ëu¡ˇˇDã|$∆Ñ$   Aˆ«Ö^  A˜«   Ö©  Aˆ«Ö¿  Aˆ«Ö◊  A˜«   ÖÓ  A˜«   Ö  A˜«   ÖN  A˜«   Ö!  A˜«  @ ÖÙ   Aˆ« Ö    A˜«    Öù   AÅÁ   utHÉÏæPì@ ø   UãD$4PãD$8PDãL$<1¿LçÑ$0  Hçå$¿  Hçî$@  Ëü¬ˇˇHÉƒ È∂¸ˇˇfD  ø¥ë@ È_¸ˇˇfD  ãT$Ö“Öî¸ˇˇÈ£˝ˇˇÄ    Hçº$  ∫   æí@ ËøˇˇÈpˇˇˇ@ Hçº$  ∫   æœè@ ËÒæˇˇÈGˇˇˇ@ Hçº$  ∫   æè@ Ë—æˇˇÈˇˇˇ@ Hçº$  ∫   æ ë@ Ë±æˇˇÈ˛ˇˇ@ Hçº$  ∫   æJñ@ ËëæˇˇÈ√˛ˇˇ@ Hçº$  ∫   æ]é@ ËqæˇˇÈñ˛ˇˇ@ Hçº$  ∫   æƒá@ ËQæˇˇAˆ«Ñ@˛ˇˇHçº$  ∫   æí@ Ë0æˇˇAˆ«Ñ)˛ˇˇHçº$  ∫   æ
í@ ËæˇˇA˜«   Ñ˛ˇˇHçº$  ∫   æí@ ËÎΩˇˇA˜«   Ñ˚˝ˇˇHçº$  ∫   æ¬á@ Ë«ΩˇˇÈﬂ˝ˇˇfê∏U   fâÑ$  Èê˝ˇˇfD  Lâ˜Ë`æˇˇ1¿Hãå$(  dH3%(   u<HÅƒ8  []A\A]A^A_√øüë@ Ëœ¿ˇˇø`í@ ËÖæˇˇø   Hâ∆1¿Ëñ¿ˇˇ∏   Î±ËJæˇˇf.Ñ     AWAVAUATUSHÅÏ¯  â|$Hât$Løí@ æ∞á@ dHã%(   HâÑ$Ë  1¿ËU¿ˇˇHÖ¿HâD$@Ñß  ø í@ Ëæˇˇø   Hâ∆1¿Ë¿ˇˇÉ|$Høxì@ tø–ì@ ËËΩˇˇø   Hâ∆1¿Ë˘øˇˇLç§$ê   HçÑ$ﬂ   HâD$IçD$HâD$ È  D  AÉ˘Ñ  é‡  AÉ˘Ñf  AÉ˘Ö,  A∫E   Hç¨$@  «Ñ$@  STALfDâî$D  f.Ñ     UãD$dæ∏î@ ø   P1¿Lçå$   LçÑ$  Hçå$0  Hçî$p  ËIøˇˇZYÉ|$hÑÃ  HãD$p1…HcT$lHâ”H)√H9¬∏    HNÿÉ|$HtLHâ»HΩ◊£p=
◊£æKí@ H˜Ìø   1¿H H¡˘?H¡˙H) ËËæˇˇãD$\Ö¿Ñî  æSí@ ø   1¿ËÀæˇˇø
   Ë—ªˇˇHãT$@Hçº$‡  æˇ  ËöΩˇˇHÖ¿ÑŸ  HÉÏIç\$	Mçl$HçÑ$‚   Hç¨$›   ˇt$(Hâ¡IçD$Iâ»HâD$PHâ\$(SIç\$AUSATHç¥$8  VæPî@ HçÑ$¿   PHçÑ$§   PHçÑ$º   PHçÑ$‡   PHçÑ$–   PHçÑ$‡   PHçÑ$ÿ   PHçÑ$–   PHçÑ$‡   PHçÑ$Ï   P1¿Lçú$É  ASLçî$Ü  Lâú$–   ARLçº$â  Lâî$–   AWLç¥$å  AVLãå$»   Hçî$Ä  Hçº$ê  Hâå$ÿ   HâÈË4ΩˇˇHÅƒ®   Lã\$@A∏Íë@ πÄ   ∫   æÄ   1¿ASLãT$@ARAWAVˇt$@ˇt$XULçå$  Hçº$†  Ë&∫ˇˇHÉƒ@ø   Hçî$∞   Hç¥$`  ˇn  ãl$`ãt$LHçº$∞   ˇÒm  HÉÏIâ¡A∏í@ UπÄ   ∫   æÄ   1¿Hçº$p  Ë≈πˇˇA^ˇt$(ˇt$1¿ˇt$(AUMâ·SA∏ë@ π   ∫   æ   Hçº$P  ËçπˇˇHã¨$∞   ∆Ñ$@   HÉƒ0@ˆ≈ÄÖ  @ˆ≈ÖΩ   @ˆ≈Ö‘   ÉÂu^DãL$hAÉ˘tuéï¸ˇˇAÉ˘ Ñ;  é=  AÉ˘@Ñ[  AÅ˘Ä   Öæ  Hç¨$@  «Ñ$@  PERM∆Ñ$D   Èû¸ˇˇfD  Hçº$  ∫   æë@ Ë¡∏ˇˇDãL$hAÉ˘uãAπY   Hç¨$@  «Ñ$@  DELAfDâå$D  ÈO¸ˇˇÄ    Hçº$  ∫   æåè@ Ëq∏ˇˇ@ˆ≈Ñ,ˇˇˇHçº$  ∫   æŒé@ ËP∏ˇˇÈˇˇˇ AΩR   fDâ¨$  ÈÂ˛ˇˇ@ Hãî$à   HãD$pHâ—H)¡H9¬∫    HN È¸ˇˇ@ HâÿæWí@ ø   H˜Ì1¿H⁄H¡˚?H¡˙H)⁄Ë#ªˇˇÈS¸ˇˇfD  AÉ˘Öé   A∏E   Hç¨$@  «Ñ$@  PROBfDâÑ$D  Èg˚ˇˇÄ    EÖ…u[Hç¨$@  «Ñ$@  NONE∆Ñ$D   È;˚ˇˇ H∏INCOMPLEªTE  Hç¨$@  HâÑ$@  fâú$H  ∆Ñ$J   È˚ˇˇ@ Hç¨$@  A∏=í@ π   ∫   æ   1¿HâÔË9∑ˇˇÈ‘˙ˇˇ@ H∏REACHABLAªE   Hç¨$@  HâÑ$@  fDâú$H  È¢˙ˇˇfêøED  Hç¨$@  «Ñ$@  FAILfâº$D  ∆Ñ$F   Ès˙ˇˇ æP   Hç¨$@  «Ñ$@  NOARfâ¥$D  ÈK˙ˇˇ Hã|$@Ë>∑ˇˇ1¿Hãå$Ë  dH3%(   u.HÅƒ¯  []A\A]A^A_√Ä    ãt$Lã|$HÅŒ   Ë˝ÚˇˇÎøË6∑ˇˇfD  ATAâ¸Uâ˝AÉ‰$SÉÂ@ˆ«Äâ˚∏   uÉ„@u&[]A\√fÑ     DâÊâÔË∂ÚˇˇÖ¿u‰É„@tﬂD  [DâÊâÔ]A\Èö¯ˇˇf.Ñ     HÉÏø‡î@ Ë‚∂ˇˇHã=Ks  Hâ¬æ   1¿Ëlπˇˇøï@ Ë¬∂ˇˇHã=+s  Hâ¬æ   1¿ËLπˇˇøPï@ Ë¢∂ˇˇHã=s  Hâ¬æ   1¿Ë,πˇˇ∏   HÉƒ√fêAWAVAâˇAUATIâıUSE1ˆπ   HÅÏ»  Hã6dHã%(   HâÑ$∏  1¿Hçº$8  H«Ñ$0  NONEHÖˆÛH´Ñ#  Hç¨$∞   ∫Ä   Iç]HâÔËrµˇˇ∆Ñ$/   øIë@ π   HâÓÛ¶Ñ%  æ/   HâÔË¯µˇˇHÖ¿IâƒÑÃ  Hçx1ˆ∫
   Ë,∑ˇˇ=Ä   Iâ∆á~  A∆$ HçT$HâÓø   ˇÆh  Ö¿àn  Lçd$`1¿π
   HãT$ AÅ˛Ä   LâÁÛH´HãD$HâT$h«Ñ$®      HâD$`DâÑç  IãU«Ñ$ò      Ω   fâÑ$î   H«D$    AΩ   HÖ“t]ø∂ï@ Hâ÷HâÈÛ¶ÖJ  LãsMÖˆÑ  Ëÿ∑ˇˇIæHã ˆDPÑÓ   ∫
   1ˆLâ˜ËG∂ˇˇHãSHÉ√âÑ$ò   HÖ“u¶ æ   ø
   Ë¡∑ˇˇÖ¿â√â˜g  à  HãD$HÖ¿Ñ  Hç|$0∫   Hâ∆H«D$0    H«D$8    H«D$@    H«D$H    H«D$P    Ëƒ≥ˇˇHçT$01¿æ3â  âﬂ∆D$? Ë¨¥ˇˇÖ¿à˜  ãD$@âÑ$¨   AÉˇLâ‚Ñ™  1¿æâ  âﬂË~¥ˇˇÖ¿à›  âﬂËè¥ˇˇ1¿Î Ë˝ˇˇHãú$∏  dH3%(   Ö“  HÅƒ»  []A\A]A^A_√f.Ñ     ∂É¯gÖî   ÄzwÖJ  Äz Ö@  HãsHÖˆtüˆÑ$®   uïHçº$0  ∫Ä   ËÎ≤ˇˇ∆Ñ$Ø   HçT$Hç¥$0  ø   ˇsf  Ö¿à  HãT$ HãD$HÉ√Éå$®   Hâî$à   HâÑ$Ä   HãÈ˛ˇˇD  øΩï@ Hâ÷LâÈÛ¶ÑmˇˇˇÉ¯mÑ\  É¯dÖÆ   ÄzyÖ  ÄznÖ˜  Äz ÖÌ  HãSÉå$®   HÉ√È¶˝ˇˇÑ     Lçd$`Lâπ
   H«D$    H«D$     LâÁHãT$ H«D$    ÛH´HãD$«D$(    HâT$h«Ñ$®      HâD$`1¿È˝ˇˇ@ øΩï@ Hâ÷LâÈÛ¶Ñ≠˛ˇˇHâ◊æQä@ HâT$Ë{≥ˇˇÖ¿HãT$Ñ¡   fD  HÉ{ Ö%˛ˇˇHâT$Hâÿ1“HçXÈË¸ˇˇf.Ñ     HçT$HâÓø   ˇe  Ö¿à5  Lçd$`1¿π   HãT$ LâÁÛ´HãD$HâT$hHâD$`«Ñ$®      ∏Ä   È^¸ˇˇ Äzou"ÄzduÄz uHãSÉå$®    HÉ√È_¸ˇˇêøQä@ Hâ÷HâÈÛ¶ÖEˇˇˇLãsHçCMÖˆÑd˝ˇˇHãSLât$È;ˇˇˇfD  Hçº$0  ˇZd  ∏   È=˝ˇˇËK˙ˇˇÈx˚ˇˇfD  1ˇHçT$HâÓˇ(d  Ö¿âz˚ˇˇHâÔˇd  ∏   È˝ˇˇD  øQä@ Hâ÷HâÈÛ¶ÑpˇˇˇÄzeÖ´˛ˇˇÄzvÖ°˛ˇˇÄz ÑRˇˇˇÈí˛ˇˇf.Ñ     1ˇHçT$HâÓˇ∏c  Ö¿â≥˛ˇˇÎéøîâ@ Ë‹≤ˇˇ∏   Èè¸ˇˇ«Ñ$¨       ÈI¸ˇˇ1¿æâ  âﬂË‘∞ˇˇÖ¿âV¸ˇˇø—ï@ Ë¢≤ˇˇã=úc  Ë◊∞ˇˇ∏   ÈJ¸ˇˇø≈ï@ ËÉ≤ˇˇ∏   È6¸ˇˇø€ï@ Ëo≤ˇˇã=ic  Ë§∞ˇˇ∏   È¸ˇˇËıØˇˇD  Éˇt#ÉˇtHÉ: tHâ÷Èx˘ˇˇÑ     È˚¯ˇˇ HÉÏøàï@ Ë⁄ØˇˇHã=Cl  Hâ¬æ   1¿Ëd≤ˇˇHÉƒÈÀ¯ˇˇf.Ñ     êAUATUSHâ”HÉÏdHã%(   HâD$1¿HÖ“Ñ*  Aâ˝1…∫   AÉÂAâ¸HâıAÉ˝fâ«C    ∆C ∆C ∆C ∆C
 ∆C	 ∆C fâKéˆ   1¿HÉ√fâC˙ËÆˇˇHâ⁄Hç}Î>fD  ÉÈ7

à
æ…¡·à
HæuHãã±çqøàM@Ä˛w:HÉ≈ÉÈ7
HÉ¬H9Ôt?Hæu Hãã±çqøàM @Ä˛v±ÉÈ0Ä˘	wq

à
Î™ ÉÈ0Ä˘	w`HÉ≈
HÉ¬H9Ôu¡∫   æÂï@ HâﬂËüØˇˇÖ¿t;∫   æÓï@ HâﬂËâØˇˇÖ¿î¿∂¿˜ÿHã|$dH3<%(   u_HÉƒ[]A\A]√@ ∏ˇˇˇˇÎ⁄fÑ     ∫   HâÊHâÔËê∞ˇˇHÖ¿t€∫ˇˇˇˇH9–t—AÉ‰u»AÉ˝âCuHã$Ä8¿˜–É‡˛ÎëËÎ≠ˇˇEÖÌÖº˛ˇˇHã,$∏˝ˇˇˇÄ} :ÖpˇˇˇHÉ≈È†˛ˇˇfD  HçGHçWHÉÏÄ8 u/HÉËH9–uÚDãOA…EÖ…Ö∆   ∆Oq   ∏@Ÿ` HÉƒ√D  DãOA…EÖ…uQ∂GHÉÏA∏˚ï@ π@   ∫   æ@   P∂G
P∂G	P∂GP∂GPD∂O1¿ø@Ÿ` ËQ¨ˇˇHÉƒ0∏@Ÿ` HÉƒ√∂GEâ…A∏(ñ@ π@   ∫   æ@   P∂G
P∂G	P∂GP∂GP∂Gø@Ÿ` P1¿Ë¨ˇˇHÉƒ0∏@Ÿ` HÉƒ√ Eâ…A∏ıï@ π@   ∫   æ@   ø@Ÿ` 1¿ËÃ´ˇˇÈˇˇˇÄ    fÉ?t*HÉÏøéè@ Ë¨¨ˇˇ∫@   Hâ∆øÄŸ` HÉƒÈ÷  fD  HÉ«Èß˛ˇˇÄ    HÉÏ∂A∏Oô@ π   ∫   æ   P∂GP∂GPD∂O1¿ø¿Ÿ` ËH´ˇˇ∏¿Ÿ` HÉƒ(√f.Ñ     @ ATLçgUΩ ⁄` SHâ˚HÉ√D∂CˇHâÔ1¿πLñ@ H«¬ˇˇˇˇæ   ËÏÆˇˇHòH≈L9„u“∫ ⁄` ã
HÉ¬çÅˇ˛˛˛˜—!»%ÄÄÄÄtÈâ¡¡È©ÄÄ  D¡HçJ[HD— ¿∏ ⁄` HÉ⁄HÅÍ ⁄` ]∆ÇˇŸ`  A\√ AWAVAUATIâıUSHçZHÉÏã5`  fâ∂.@Ä˝-Ñ.  @ÑÌÑ%  Ë7ÆˇˇHâ«IçEMâÏHâ$Lã7Læ˝IÉƒC∑~â—ÄÊtHâ|$Ë™ˇˇHã Hã|$Jæ∏A∑FHâ≈ÄÂ	tNÌHÉ√Dâ‡@àkˇA∂,$D)Ë@Ä˝-ts@ÑÌtnL;$$uü@ÑÌÖ≤   Ä    ∆ 1¿HÉƒ[]A\A]A^A_√@ ø¿è@ Ë∆™ˇˇ∫Ä   Hâ∆øÄ⁄` ËÙ  Ëˇ©ˇˇ«    HÉƒ∏ˇˇˇˇ[]A\A]A^A_√D  É¯tÉ¯çPw HÉ√É˙∆Cˇ@çRvA∂$<-Ö{ˇˇˇIç|$∫
   1ˆË≤´ˇˇ¿à1¿ÈdˇˇˇMâÏ∫   ÎΩø—è@ Ë3™ˇˇ∫Ä   Hâ∆øÄ⁄` Ëa  Ël©ˇˇ«    ∏ˇˇˇˇÈ)ˇˇˇ@Ä˝-t£È	ˇˇˇêSHâÚHâÛHâ˛1ˇËO˛ˇˇÖ¿x1¿fâ1¿[√fê∏ˇˇˇˇ[√fÑ     1“1…@ ∂–Ë< D¡HÉ¬àÇ?⁄` HÉ˙uÂS∆Kn   D∂GAÉ‡Dâ√—˚t,ø@⁄` Ë[©ˇˇHç∏@⁄` Aâÿπ„è@ H«¬ˇˇˇˇæ   1¿ËY¨ˇˇ∏@⁄` [√fêHÖˇt+Hâ˘Hã=¡e  A∏Ä⁄` ∫Áè@ æ   1¿È⁄´ˇˇf.Ñ     Hã=ôe  πÄ⁄` ∫yâ@ æ   1¿È≥´ˇˇ HÉÏXdHã%(   HâD$H1¿∑ÉËfÉ¯˝w HÉ«ËˇˇˇHãL$HdH3%(   u#HÉƒX√fêøéè@ Ë∆®ˇˇ∫@   Hâ∆HâÁËˆ  ÎÕËè®ˇˇf.Ñ     D  HÉÏøpñ@ Ëí®ˇˇHã=˚d  Hâ¬æ   1¿Ë´ˇˇ∏ˇˇˇˇHÉƒ√fêHÉÏ∂GA∏ùñ@ π   ∫   æ   P∂GP∂GP∂GPD∂1¿ø €` Ë3ßˇˇ∆ñm   ∏ €` HÉƒ(√fêHÖˇt+Hâ˘Hã=Åd  A∏@€` ∫Áè@ æ   1¿Èö™ˇˇf.Ñ     Hã=Yd  π@€` ∫yâ@ æ   1¿Ès™ˇˇ ∑ÉËfÉ¯˝wHÉ«ÈKˇˇˇ øéè@ ÈÆßˇˇfffff.Ñ     USHâ˜HâÛHçjHÉÏã:]  fâËRßˇˇ1…HÉ¯
u*∂tKæKDçF–¡‡D	¿àD HÉ¡HÉ˘uﬂ1¿HÉƒ[]√ø»ñ@ ËFßˇˇ∫Ä   Hâ∆ø@€` Ë4©ˇˇË¶ˇˇ«    ∏ˇˇˇˇÎÀfêSHâÚHâÛHâ˛1ˇËoˇˇˇÖ¿x∏  fâ1¿[√Ä    ∏ˇˇˇˇ[√ê∏ â@ √f.Ñ     ∏ˇˇˇˇ√f.Ñ     Hâ¯√fff.Ñ     ATLçgUΩ¿€` SHâ˚HÉ√D∂CˇHâÔ1¿πLñ@ H«¬ˇˇˇˇæ   Ë|©ˇˇHòH≈L9„u“∫¿€` ã
HÉ¬çÅˇ˛˛˛˜—!»%ÄÄÄÄtÈâ¡¡È©ÄÄ  D¡HçJ[HD— ¿∏¿€` HÉ⁄HÅÍ¿€` ]∆Çø€`  A\√ ∑ÉËfÉ¯˝wHçG√Ä    HÉÏøéè@ Ë
¶ˇˇ∫@   Hâ∆ø@‹` HÉƒÈ4  @ ∑ÉËfÉ¯˝wHÉ«Èˇˇˇ HÉÏøéè@ Ë •ˇˇ∫@   Hâ∆ø ‹` HÉƒÈÙ   @ HÉÏæ   Ë¬¶ˇˇHÖ¿tHÉƒ√Ë£®ˇˇ HÉÏËwßˇˇHÖ¿tHÉƒ√Ëà®ˇˇÑ     HÅÏ®  Hç|$«D$    «D$    dHã%(   HâÑ$ò  1¿«D$    Ët•ˇˇÖ¿x`Hçº$í   LçD$HçL$HçT$1¿æ/ó@ ËÕ¶ˇˇÉ¯~8iT$'  iD$Ë  –D$Hã¥$ò  dH34%(   uHÅƒ®  √Ä    ∏ˇˇˇˇÎ◊Ë§§ˇˇ@ Hâ–HçRˇ∆Dˇ È§ˇˇf.Ñ     D  AUATHâ˜USHâıLçjHÉÏã∂]  fâËN§ˇˇHÉ¯Hâ√á©   æ/   HâÔËt§ˇˇHÖ¿IâƒtHçx∆  ∫
   1ˆË©•ˇˇâ√Ä}  t9HâÔË	§ˇˇHÉ¯w+â⁄H9–r$çSHâÓLâÔπ   ËÈ•ˇˇHÉƒâÿ[]A\A]√@ A∆$/øló@ Ë˘£ˇˇ∫Ä   Hâ∆ø¿‹` ËÁ•ˇˇË2£ˇˇ«    HÉƒ∏ˇˇˇˇ[]A\A]√@ ø8ó@ Î√êSHâÚHâÛHâ˛1ˇËˇˇˇÖ¿x∏  fâ1¿[√Ä    ∏ˇˇˇˇ[√êHÉÏHâ˛∫   øÄ‹` Ë⁄¢ˇˇ∆cj   ∏Ä‹` HÉƒ√fÑ     HÖˇt+Hâ˘Hã=¡_  A∏¿‹` ∫Áè@ æ   1¿È⁄•ˇˇf.Ñ     Hã=ô_  π¿‹` ∫yâ@ æ   1¿È≥•ˇˇ ∑ÉËfÉ¯˝w,HçwHÉÏ∫   øÄ‹` ËM¢ˇˇ∆÷i   ∏Ä‹` HÉƒ√@ øéè@ ÈŒ¢ˇˇf.Ñ     @ ATUæ∞á@ Søäó@ HÅÏ  dHã%(   HâÑ$  1¿Ë√§ˇˇHÖ¿Hâ√Ñ'  øüó@ Lçd$Hçl$Ës¢ˇˇø   Hâ∆1¿ËÑ§ˇˇø∫ó@ ËZ¢ˇˇø   Hâ∆1¿Ëk§ˇˇHâ⁄æ   HâÁËK£ˇˇ Hâ⁄æ   HâÁË8£ˇˇHÖ¿Ñè   æ
   HâÁË"¢ˇˇHÖ¿t∆  1ˆ∫
   LâÁ∆D$ ∆D$# ËQ£ˇˇÉ¯Hâ¡w)Aâ¿Ö…Hò∆ Öò   HâÍæ÷ó@ ø   1¿Ë‰£ˇˇÎäfê∆D$ π˛ˇˇˇA∏   IâÈHâ‚æÒó@ ø   1¿Ëπ£ˇˇÈ\ˇˇˇ@ HâﬂË(°ˇˇ1¿Hãú$  dH3%(   u8HÅƒ  []A\√Ä    ø ò@ ËV°ˇˇø   Hâ∆1¿Ëg£ˇˇ∏   Î∫ÉÈÎãË°ˇˇfD  HÉÏHãï]  ∫1   æ   ø(ò@ Ë°£ˇˇHãz]  ∫1   æ   ø`ò@ ËÜ£ˇˇ∏   HÉƒ√fff.Ñ     AWAVAUATUSHâÛHÅÏ®  Hã6dHã%(   HâÑ$ò  1¿â|$HÖˆÑ˘   Hçº$  Lçd$0∫Ä   LçsËé¢ˇˇ1¿π   LâÁÛH´HçT$Hç¥$  «    1ˇˇÆY  LcËEÖÌà{  LãCHãD$ªQä@ HãT$Dâl$@Içl$MÖ¿HâD$0HâT$8uUÈ©   fÑ     AÄxeuUAÄxvuNAÄx uG IÉ~ Mç~tMÄ|$D uFIã7∫»   HâÔMçwË‚°ˇˇMãGMÖ¿tYπ   Lâ∆HâﬂÛ¶t¬AÄ8dt§IÉ~ uÄ|$D Mâ˜tΩ Ë{˛ˇˇHãú$ò  dH3%(   Öx  HÅƒ®  []A\A]A^A_√fêÄ|$D t…AÉ˝Lâ‚dã
HÉ¬çÅˇ˛˛˛˜—!»%ÄÄÄÄtÈâ¡¡È©ÄÄ  D¡HçJHD— ¿HÉ⁄L)‚I9’voøòò@ Ë,üˇˇHã=ï[  Hâ¬æ   1¿Ë∂°ˇˇ∏   Èaˇˇˇø%ô@ ËüˇˇHã=k[  Hâ¬DâÈæ   1¿Ëâ°ˇˇ∏   È4ˇˇˇHçº$  ˇ!X  ∏   Èˇˇˇ1“æ   ø	   Ë∂°ˇˇÖ¿â√âdX  x*É|$Lâ‚t4â«æâ  1¿ËÚûˇˇÖ¿xSâﬂËüˇˇ1¿È’˛ˇˇøîâ@ Ë∂†ˇˇ∏   È¡˛ˇˇâ«æâ  1¿ËæûˇˇÖ¿yÃø—ï@ Ëê†ˇˇã=X  Ë≈ûˇˇ∏   Èê˛ˇˇø€ï@ Ëq†ˇˇã=„W  Ë¶ûˇˇ∏   Èq˛ˇˇË˜ùˇˇÄ    HÉÏÉˇtWÉÊ@u*ÉˇtHÉ: tHâ÷HÉƒÈ˝ˇˇ HÉƒÈØ¸ˇˇÄ    HãAZ  ∫,   æ   ø¯ò@ ËM†ˇˇHÉƒÈÑ¸ˇˇ@ HãZ  ∫+   æ   ø»ò@ Ë%†ˇˇHÉƒÈ\¸ˇˇf.Ñ     fêãJW  ATUSfâæÑ€t|HâıIâ¸Ë1†ˇˇHãHæ√ˆDBuCçCü<vLçCø<w]ÉÎ7IæL$¡„ˆDJHâ»u'çQüÄ˙v/çQøÄ˙w7ÉË7	√à]1¿[]A\√ÉÎ0Î… ÉË0	√ÎÁêÉÎWÎπ ÉËW	√Î◊ê1¿Î◊@ Ë3úˇˇ«    ∏ˇˇˇˇÎ¡fD  HÉÏD∂A∏Øô@ π@   ∫   æ@   ø@›` 1¿Ëßõˇˇ∏@›` HÉƒ√f.Ñ      AUATIâ¸USHçnHÉÏã…V  IâÌfâæDâË)ËÉ¯tfÑ€tbË-üˇˇHãHæ√ˆDBt_ÉÎ0IæL$¡„ˆDJHâ»tYæ—ÉÍ0	”Ñ¿uZIÉƒIÉ≈Aà]ˇAæ$Ä˚:ußDâËAæ\$IÉƒ)ËÉ¯uù 1¿HÉƒ[]A\A]√ çCü<w!ÉÎWÎò@ çQüÄ˙w(ÉËW	√IÉƒÎ§D  çCø<w:ÉÎ7ÈmˇˇˇfÑ     çQøÄ˙wæ—ÉÍ7	”Èjˇˇˇ Ñ…tÄ˘:u¡ÎÈVˇˇˇË“öˇˇ«    ∏ˇˇˇˇÈtˇˇˇfêHÉÏ∂GA∏Eô@ π@   ∫   æ@   P∂GP∂GP∂GP∂GPD∂1¿øÄ›` Ë.öˇˇ∏Ä›` HÉƒ8√@ AUATIâ¸USHçnHÉÏãôU  IâÌfâæDâË)ËÉ¯tfÑ€tbËΩùˇˇHãHæ√ˆDBt_ÉÎ0IæL$¡„ˆDJHâ»tYæ—ÉÍ0	”Ñ¿uZIÉƒIÉ≈Aà]ˇAæ$Ä˚:ußDâËAæ\$IÉƒ)ËÉ¯uù 1¿HÉƒ[]A\A]√ çCü<w!ÉÎWÎò@ çQüÄ˙w(ÉËW	√IÉƒÎ§D  çCø<w:ÉÎ7ÈmˇˇˇfÑ     çQøÄ˙wæ—ÉÍ7	”Èjˇˇˇ Ñ…tÄ˘:u¡ÎÈVˇˇˇËbôˇˇ«    ∏ˇˇˇˇÈtˇˇˇfêHÉÏ∂GA∏hô@ π@   ∫   æ@   P∂GP∂GP∂GP∂GP∂GP∂GPD∂1¿ø¿›` Ë¥òˇˇ∏¿›` HÉƒH√f.Ñ     AUATIâ¸USHçnHÉÏãYT  IâÌfâæDâË)ËÉ¯tSÑ€tOË=úˇˇHãHæ√ˆDBtOÉÎ0IæL$¡„ˆDJHâ»tIÉË0	√IÉ≈Aà]ˇAæ\$Ä˚:tADâËIÉƒ)ËÉ¯u≠1¿HÉƒ[]A\A]√fD  çCü<w)ÉÎWÎ®@ çQüÄ˙w(ÉËW	√Î≠êAæ\$IÉƒÈaˇˇˇêçCø<w!ÉÎ7ÈuˇˇˇêçQøÄ˙wÉË7	√ÈzˇˇˇfD  Ëòˇˇ«    ∏ˇˇˇˇÎÖfD  HÉÏ∂GA∏ñô@ π@   ∫   æ@   P∂GP∂GP∂GP∂GPD∂1¿ø ﬁ` Ë^óˇˇ∏ ﬁ` HÉƒ8√@ HÉÏDøA∏πô@ π   ∫   æ   ø@ﬁ` 1¿Ë'óˇˇ∏@ﬁ` HÉƒ√f.Ñ      AUATIâ¸USHçnHÉÏã	T  IâÌfâæDâË)ËÉ¯tSÑ€tOË≠öˇˇHãHæ√ˆDBtOÉÎ0IæL$¡„ˆDJHâ»tIÉË0	√IÉ≈Aà]ˇAæ\$Ä˚:tADâËIÉƒ)ËÉ¯u≠1¿HÉƒ[]A\A]√fD  çCü<w)ÉÎWÎ®@ çQüÄ˙w(ÉËW	√Î≠êAæ\$IÉƒÈaˇˇˇêçCø<w!ÉÎ7ÈuˇˇˇêçQøÄ˙wÉË7	√ÈzˇˇˇfD  Ësñˇˇ«    ∏ˇˇˇˇÎÖfD  HÉÏ∂Gπ–ô@ ∫@   æ   P∂GP∂GP∂GPD∂O1¿D∂øÄﬁ` Ëƒôˇˇ∏Äﬁ` HÉƒ(√f.Ñ     AWAâˇAVIâˆAUIâ’ATLç%?  UHç-?  SL)Â1€H¡˝HÉÏË%ïˇˇHÖÌtÑ     LâÍLâˆDâˇAˇ‹HÉ√H9ÎuÍHÉƒ[]A\A]A^A_√ff.Ñ     Û√  HÉÏHÉƒ√                                         Usage:
  arp [-vn]  [<HW>] [-i <if>] [-a] [<hostname>]             <-Display ARP cache
   arp [-v]          [-i <if>] -d  <host> [pub]               <-Delete ARP entry
          arp [-vnD] [<HW>] [-i <if>] -f  [<filename>]            <-Add entry from file
          arp [-v]   [<HW>] [-i <if>] -s  <host> <hwaddr> [temp]            <-Add entry
          arp [-v]   [<HW>] [-i <if>] -Ds <host> <if> [netmask <nm>] pub          <-''-

               -a                       display (all) hosts in alternative (BSD) style
                -s, --set                set a new ARP entry
           -d, --delete             delete a specified entry
              -v, --verbose            be verbose
            -n, --numeric            don't resolve names
           -i, --device             specify network interface (e.g. eth0)
         -D, --use-device         read <hwaddr> from given device
               -A, -p, --protocol       specify protocol family
               -f, --file               read new entries from file or from /etc/ethers

         <HW>=Use '-H <hw>' to specify hardware address type. Default: %s
       List of possible hardware types (which support ARP):
 %s 0x%x 0x%x %100s %100s %100s
 Address                  HWtype  HWaddress           Flags Mask            Iface
       Entries: %d	Skipped: %d	Found: %d
      arp: in %d entries no match found.
     arp: cant get HW-Address for `%s': %s.
 arp: device `%s' has HW address %s `%s'.
       arp: invalid hardware address
  %s: hardware type not supported!
       %s: address family not supported!
      arp: %s: unknown address family.
       arp: %s: unknown hardware type.
        +I18N
AF: (inet) +UNIX +INET +INET6 +IPX +AX25 +NETROM +X25 +ATALK +ECONET +ROSE 
HW: (ether) +ETHER +ARC +SLIP +PPP +TUNNEL -TR +AX25 +NETROM +X25 +FR +ROSE +ASH +SIT +FDDI +HIPPI +HDLC/LAPB +EUI64  arp: %s: kernel only supports 'inet'.
  arp: %s: hardware type without ARP support.
    arp: cannot open etherfile %s !
        arp: format error on line %u of etherfile %s !
 arp: cannot set entry on line %u of etherfile %s !
 ether ? /proc/net/arp A ! %-23.23s   <from_interface> * %-8.8s%-20.20s (incomplete) %-6.6s%-15.15s %s
 %s (%s) at  <from_interface>  <incomplete>  %s [%s]  netmask %s  PERM  AUTO  DONTPUB  TRAIL  on %s
 %s (%s) -- no entry
 arp: need host name
 arp: need hardware address
 arp: protocol type mismatch.
 temp priv trail dontpub auto netmask 255.255.255.255 arp: SIOCSARP()
 SIOCSARP /etc/ethers /usr/share/locale net-tools inet arp: -N not yet supported.
 %s
%s
%s
 A:H:adfp:nsei:t:vh?DNV socket >> %s args=%s
 arp: SIOCDARP(dontpub)
 No ARP entry for %s
 SIOCDARP(dontpub) arp: SIOCDARP(pub)
 SIOCDARP(pub) verbose version all delete file numeric set protocol hw-type help use-device symbolic arp 1.88 (2001-04-04) net-tools 1.60                                                           ä@                     v       ä@                     V       ä@                     a       ä@                     d       &ä@                     f       +ä@                     n       3ä@                     s       7ä@                    A       @ä@                    H       Qä@                    i       Hä@                     h       Mä@                     D       Xä@                     N                                       ™@     Ê@     Ê@     õ@     Ê@     Ê@     Ê@     p@     Ê@     Ê@     Ê@     Ê@     Ê@     A@     Ê@     Ê@     Ê@     Ê@     Ê@     Ê@     Ê@     @     Ê@     Ê@     Ê@     Ê@     Ê@     Ê@     Ê@     Ê@     Ê@     Ê@     ˆ@     Ê@     Ê@     Ó@     ‚@     ⁄@     Ê@     Ê@     ¬@     Ê@     Ê@     Ê@     Ê@     ∂@     Ê@     ™@     Ê@     Ê@     Æ@     p@     Ê@     ◊@     î@     …@     ë@     ™@     µ@     UNSPEC UNIX Domain DARPA Internet IPv6 AMPR AX.25 AMPR NET/ROM Novell IPX Appletalk DDP Econet CCITT X.25 AMPR ROSE Ash , Unknown address family `%s'.
 
     .. %s (%s)  ddp netrom tcpip      Please don't supply more than one address family.
      Too much address family arguments.
 Malformed Ash address %1x [NONE SET] /proc/sys/net/ash      I^ds8/–«åõ°∂˝ÍInvalid callsign Callsign too long -%d %s: %s
 /proc/net/ax25 %d/%d /proc/net/appletalk /proc/sys/net/econet Local Loopback VJ Serial Line IP VJ 6-bit Serial Line IP Adaptive Serial Line IP Ethernet HIPPI generic X.25 IPIP Tunnel Point-to-Point Protocol (Cisco)-HDLC LAPB ARCnet Frame Relay DLCI Frame Relay Access Device IPv6-in-IPv4 IrLAP Generic EUI-64     Fiber Distributed Data Interface default netstat getaddrinfo: %s: %d
 getnameinfo failed
 [UNKNOWN] /proc/net/if_inet6 /proc/net/ipv6_route Kernel IPv6 routing cache
 Kernel IPv6 routing table
 %s:%s:%s:%s:%s:%s:%s:%s %s/%d G H D f /proc/net/ndisc Kernel IPv6 Neighbour Cache
 UNKNOWN(%02x)  %-9ld   *   %-7ld   INET6 (IPv6) not configured in this system.
    Destination                    Next Hop                   Flag Met Ref Use If
  %4s%4s%4s%4s%4s%4s%4s%4s %02x %4s%4s%4s%4s%4s%4s%4s%4s %02x %4s%4s%4s%4s%4s%4s%4s%4s %08x %08x %08x %08x %s
    %-30s %-26s %-4s %-3d %-1d%6d %s
       Neighbour                                   HW Address        Iface    Flags Ref State
 Neighbour                                   HW Address        Iface    Flags Ref State            Stale(sec) Delete(sec)
       %4s%4s%4s%4s%4s%4s%4s%4s %02x %02x %02x %02x %08lx %08lx %08lx %04x %04x %04lx %8s %2s%2s%2s%2s%2s%2s
  %-43s %-17s %-8s %-5s %-3d %-16s        Usage: inet6_route [-vF] del Target
           inet6_route [-vF] add Target [gw Gw] [metric M] [[dev] If]
             inet6_route [-FC] flush      NOT supported
      Flushing `inet6' routing table not supported
 metric gateway SIOGIFINDEX SIOCDELRT SIOCADDRT          ˇˇˇˇˇˇ %08lX %02X%02X%02X%02X%02X%02X /proc/net/ipx       %08lX:%02X%02X%02X%02X%02X%02X irda %02X- loop unspec /proc/net/nr      You cannot start PPP with this program.
 ppp %02x%02x%02x%02x%02x /proc/net/rose        Node address must be ten digits sit adaptive cslip6 cslip tunnel /proc/net/unix out of virtual memory
 %d.%d.%d Address can't exceed eighteen digits with sigdigits Invalid address /proc/net/x25 /proc/net/x25_routes Kernel X.25 routing table
 Destination          Iface
 *                    %-5s
 %s/%*d   %-5s
 X.25 not configured in this system.
    Usage: x25_route [-v] del Target[/mask] [dev] If
              x25_route [-v] add Target[/mask] [dev] If
       route: netmask doesn't match route address
     Flushing `x25' routing table not supported
     Modifying `x25' routing cache not supported
 route: bogus netmask %d
 arcnet %02x:%02x:%02x:%02x:%02x:%02x      %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X eui64 %02X-%02X-%02X-%02X-%02X-%02X fddi %i frad dlci lapb hdlc %02X:%02X:%02X:%02X:%02X:%02X hippi ;(  d   lzˇˇt  º~ˇˇî  ‹~ˇˇd  ÌáˇˇD  Ïàˇˇú  ãˇˇ¥  \íˇˇ  åóˇˇ¥  |òˇˇÃ  ôˇˇ  åôˇˇ$  öˇˇL  ‹õˇˇî  Ãúˇˇ‰  ºùˇˇ$  Ãûˇˇ\  \üˇˇî  åüˇˇ¨  <°ˇˇ  l°ˇˇ4  ‹°ˇˇT  ,¢ˇˇl  l¢ˇˇÑ  ¨¢ˇˇú  Ï¢ˇˇ¥  ú£ˇˇ‰  ‹£ˇˇ¸  ,§ˇˇ  Ã•ˇˇD  úßˇˇd  ¸ßˇˇî  l®ˇˇ¥  \©ˇˇÙ  ú©ˇˇ	  ¨©ˇˇ$	  l™ˇˇ\	  |™ˇˇt	  Ã¨ˇˇº	  ,≠ˇˇ‹	  lØˇˇ
  ÃØˇˇ4
  Ã≥ˇˇÑ
  ‹≥ˇˇú
  l¥ˇˇ‹
  ¨µˇˇ  ∑ˇˇ\  L∑ˇˇ|  LΩˇˇú  \ƒˇˇú  ºƒˇˇ‘  ,≈ˇˇÏ  úÀˇˇ<  ¸ÀˇˇT  ÃÕˇˇî  ÏŒˇˇ‰  ,œˇˇ¸  |œˇˇ  –ˇˇL  ¨—ˇˇ¥  ‹—ˇˇ‘  L“ˇˇÙ  ú“ˇˇ  ”ˇˇ,  <”ˇˇD  å”ˇˇl  ‹”ˇˇÑ  ‘ˇˇú  å‘ˇˇÃ  º‘ˇˇÏ  Ã‘ˇˇ  ‹‘ˇˇ  Ï‘ˇˇ4  |’ˇˇd  º’ˇˇ|  ¸’ˇˇ¨  ÷ˇˇÃ  <÷ˇˇÏ  Ï÷ˇˇ  ◊ˇˇ$  Ï◊ˇˇt  ÿˇˇî  Lÿˇˇ¨  úÿˇˇƒ  Ïÿˇˇ‹  |⁄ˇˇ  Ã⁄ˇˇ,  ú›ˇˇ|  ,ﬁˇˇ¨  ‹ﬁˇˇ‹  ﬂˇˇÙ  <‡ˇˇ4  å‡ˇˇ\  ¨·ˇˇú  ‚ˇˇÃ  „ˇˇ  \„ˇˇ4  ú„ˇˇL  ú‰ˇˇå  Ï‰ˇˇ¥  \Âˇˇ¸         zR xê      °Ñˇˇ*                  zR xê  $      vˇˇP   FJwÄ ?;*3$"       D   HÖˇˇ   D    \   \   PáˇˇO   BèBéB çB(åA0ÜA8ÉGê!òI†dòBê$
8A0A(B BBBA L   º   @éˇˇ"   BèBéG çB(åA0ÜA8ÉJ–§
8A0A(B BBBA   L     pzˇˇ	   BèBéG çB(åD0ÜA8ÉOÆ
8A0A(B BBBA      \  –íˇˇ·    D‹4   t  ®ìˇˇú    JåDÜA Éy
ABEx
ABE   ¨  îˇˇa    D A
K     $   Ã  `îˇˇq    D F
FG
I       D   Ù  ∏îˇˇ¬   BéBçE åA(ÜF0ÉG¿µ
0A(A BBBD    L   <  @ñˇˇ„    BçBåD ÜA(ÉT0è
(D ABBK\(A ABB      <   å  ‡ñˇˇÏ    BçBåD ÜA(ÉD0æ
(F ABBJ     4   Ã  êóˇˇ   BåAÜD ÉH0Â
 AABH     4     hòˇˇè    BåAÜA ÉD0v
 AFBA        <  ¿òˇˇ)           d   T  ÿòˇˇ™   BèBéB çB(åD0ÜA8ÉHP¨
8A0A(B BBBEk
8F0A(B BBBF        º   öˇˇ/    AÉ_
HF    ‹  0öˇˇn    dÉI√        ¸  ÄöˇˇM                ∏öˇˇ<    \[    ,  ‡öˇˇ<    Dw    D  õˇˇ6    J[ ,   \  0õˇˇ¨    AÜAÉR0@
AAJ        å  ∞õˇˇ2    Dm    §  ÿõˇˇC    Tn ,   º  úˇˇô   AÜCEçåÉ!
F          Ï  Äùˇˇœ   D        ,     0üˇˇY    JåDÜA Éy
ABE       <  `üˇˇa    D A
K     <   \  ∞üˇˇÏ    BçBåD ÜA(ÉD0æ
(F ABBJ        ú  `†ˇˇ3              ¥  à†ˇˇ           4   Ã  Ä†ˇˇº    BåAÜD ÉL0ë
 AABH          °ˇˇ           D      °ˇˇK   BéBçB åA(ÜA0ÉG@§
0A(A BBBE        d  £ˇˇ`    Dt
H[   4   Ñ  H£ˇˇ8   BåAÜD ÉG0i
 AABE        º  P•ˇˇ`    Dq
K[   L   ‹  ê•ˇˇ¸   BçBåF ÜA(ÉF0£
(A ABBF{
(F ABBJ      ,  @©ˇˇ           <   D  8©ˇˇä    AÜAÉG [
DAGz
GAFLDA 4   Ñ  à©ˇˇ7   BåAÜD ÉGpå
 AABB     D   º  ê™ˇˇk   AÉ@H ZAS
IV
Zd
L~
J^
E            ∏´ˇˇ)    AÉc         $  »´ˇˇˆ   BèBéE çB(åF0ÜA8ÉL$§¯$VÄ%Fà%Fê%Fò%F†%F®%A∞%E∏%E¿%E»%E–%Eÿ%A‡%IË%Q%E¯%EÄ&Eà&Eê&Eò&E†&A®&I∞&I∏&I¿&I»&I–&f$[¯$^Ä%Ià%Iê%Iò%B†%I®%I∞%[$q¯$KÄ%zà%Jê%Eò%E†%E®%E∞%S$·¯$KÄ%Eà%Eê%h$◊
8A0A(B BBBA ¸   D	  ®∞ˇˇ
   BèBéB çB(åA0ÜA8ÉG∞$∏$O¿$h∏$A∞$™∏$^¿$Q»$F–$Gÿ$A‡$BË$I$N¯$IÄ%Ià%Iê%Iò%I†%I®%I∞%I∏%I¿%L»%R–%Rÿ%J‡%o∏$^¿$G»$B–$Bÿ$D‡$DË$A$Y∞$u∏$J¿$`∏$D¿$D»$F–$Bÿ$D‡$v∞$˜
8A0A(B BBBH 4   D
  ∏∂ˇˇV    BåDÜG ÉV
ABJYFB      |
  ‡∂ˇˇn    DiL   î
  8∑ˇˇk   BèBéE çB(åD0ÜA8ÉOÄ|
8A0A(B BBBK      ‰
  XΩˇˇU    ld <   ¸
  †Ωˇˇ    BçBåA ÜA(ÉG@8
(A ABBE    L   <  0øˇˇ   Ln
FTV E(E0E8E@UI
A]E E(E0E8J@KI
D   å   ¿ˇˇ9    J[    §  (¿ˇˇB    DY E(E0Z,   ƒ  X¿ˇˇç    BåEÜF É_WI      d   Ù  ∏¿ˇˇü   BèBéB çB(åD0ÜA8ÉHP¨
8A0A(B BBBEk
8F0A(B BBBF        \  ¡ˇˇ'    AÉ\
CF    |   ¬ˇˇn    dÉI√        ú  P¬ˇˇM              ¥  à¬ˇˇa    D`y
C         ‘  ÿ¬ˇˇ.    Di $   Ï  ¬ˇˇN    DZE E(E0`          √ˇˇM              ,  P√ˇˇ"           ,   D  h√ˇˇ~    AÜAÉN }
AAA         t  ∏√ˇˇ/    AÉ_
HF    î  »√ˇˇ              ¨  ¿√ˇˇ              ƒ  ∏√ˇˇ           ,   ‹  ∞√ˇˇç    BåEÜF É_WI           ƒˇˇ<    \[    $  8ƒˇˇ<    \[    <   mˇˇ    A       T  Hƒˇˇ    DS
A         t  Hƒˇˇ    DN
A         î  Hƒˇˇ¨    G∞ë
H       ¥  ÿƒˇˇ           L   Ã  ‡ƒˇˇﬂ    BçBåD ÜA(ÉK0w
(C ABBEp
(F ABBE        p≈ˇˇ/    AÉ_
HF    <  Ä≈ˇˇ'    Db    T  ò≈ˇˇM              l  –≈ˇˇB    T_ 4   Ñ  ∆ˇˇä   BåAÜF ÉL∞?
 AABH      º  `«ˇˇD    D L   ‘  ò«ˇˇ…   BèBéB çB(åA0ÜA8ÉJ‡?
8A0A(B BBBC   ,   $   ˇˇÑ    D\
HD
L_
I_       ,   T  x ˇˇ™    HåAÜA Éb
ABA      Ñ  ¯ ˇˇ3    Dn <   ú   Àˇˇ   BçBåD ÜA(ÉH0Ö
(A ABBD     $   ‹   ÃˇˇL    DZ E(E0E8E@Y  <     (Ãˇˇ   BçBåD ÜA(ÉH0Ö
(A ABBD     ,   D  ÕˇˇV    DZ E(E0E8E@EHEPY    <   t  8Õˇˇ˙    BçBåD ÜA(ÉH0r
(A ABBG     $   ¥  ¯ÕˇˇL    DZ E(E0E8E@Y     ‹   Œˇˇ3    Dn <   Ù  HŒˇˇ˙    BçBåD ÜA(ÉH0r
(A ABBG     $   4  œˇˇF    DTE E(E0^     D   \  0œˇˇe    BèEéE çE(åH0ÜH8ÉM@l8A0A(B BBB    §  Xœˇˇ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ∞"@     ê"@                                  8@            T@            æ`                          æ`                   ı˛ˇo    ò@            à	@            »@     
       ˝                                           ¿`            `                           ÿ@            x@            `       	              ˛ˇˇo    @     ˇˇˇo           ˇˇo    Ü@                                                                                                             (æ`                     v@     Ü@     ñ@     ¶@     ∂@     ∆@     ÷@     Ê@     ˆ@     @     @     &@     6@     F@     V@     f@     v@     Ü@     ñ@     ¶@     ∂@     ∆@     ÷@     Ê@     ˆ@     @     @     &@     6@     F@     V@     f@     v@     Ü@     ñ@     ¶@     ∂@     ∆@     ÷@     Ê@     ˆ@     @     @     &@     6@     F@     V@     f@     v@     Ü@     ñ@     ¶@     ∂@     ∆@     ÷@     Ê@     ˆ@     @     @     &@     6@     F@     V@     f@     v@     Ü@     ñ@     ¶@                             aä@     wä@                                     @Œ`      »`     Ä»`     @≈`     @ `     @À`      …`      ∆`     Ä∆`     Äƒ`     ¿Œ`     ¿Õ`                                     ˘è@     ˘è@     ﬁ`     ˇñ@     Râ@     ‰ﬁ`     ¯ñ@     ôë@     ‡ﬁ`     ñ@     ñ@     ÿﬁ`     ê@     è@     ‹ﬁ`     è@     è@     Ëﬁ`     Râ@     Râ@     ‰ﬁ`     ôë@     ôë@     ‡ﬁ`     è@     è@     ‹ﬁ`     ó@     ó@     Ïﬁ`     è@     Râ@     ‰ﬁ`     &ê@     [ñ@     –ﬁ`     Üó@     Üó@     Ä”`     ßè@     ßè@     ‘ﬁ`                                                     ßè@                    ¿8@     P9@                                             ˇˇˇˇ    ôè@     ßè@               @   ¿8@     ∞7@                                                            ˘è@                   `;@      <@     Ä9@     –;@                             ˇˇˇˇ    Ôè@     ˘è@                   `;@     0;@                                                             è@                    `<@     †<@                                             ˇˇˇˇ    ê@                                     [ñ@                    ê=@     –=@     ‡<@                                     ˇˇˇˇ    ê@                                     †…`      Õ`     ‡Ã`     †Ã`     `Ã`      Ã`     ‡ƒ`     ‡œ`     †≈`     † `     †À`     `Õ`     ‡ `     `—`      —`     `œ`     ‡–`     †–`     ‡À`     `–`     †—`     `…`     †œ`      œ`      –`     ‡…`                                                     Râ@                   êC@     ¿F@      G@     `D@                     †C@     ˇˇˇˇ                                            ôë@             
      Q@     †O@     `N@     ¿M@     P^@     êe@             ˇˇˇˇ    åë@     ˇˇˇˇ                            ñ@                    ¿g@     ‡h@     e@                                     ˇˇˇˇ    ñ@     Gñ@                   i@                                     Rñ@                                                           Wñ@             ˇˇˇˇ    pi@                                                                     è@                   –k@     êl@      j@     @l@                             ˇˇˇˇ    ^ñ@     è@                    –k@     †k@                             ôñ@                                     m@                                                     ºñ@                
   0m@     –m@      n@     Äm@                             ˇˇˇˇ    ≤ñ@     ºñ@               
   0m@     Än@                             Ëñ@                                                           Ïñ@                                                           ıñ@                                                           ˆñ@                                                           ¸ñ@                                                           ˝ñ@                                                            ó@                    ∞n@     ¿n@                                                             Wñ@                     ‡n@     ∞o@                                                                                             ó@                    –n@     po@                                             ˇˇˇˇ    	ó@                                     Üó@             	      r@     êr@      q@     @r@     ‡r@     êw@             ˇˇˇˇ    |ó@     Üó@                  r@     ‡q@                     ˇˇˇˇ    >ô@                   –x@      x@                             [ñ@                                                           ¨á@                   0z@     y@                             êô@                   †{@     Äz@                             ¥ô@                   }@      |@                             ºô@                                                           ¡ô@                   P}@                                     ∆ô@                                                           Àô@                                                           Óô@                  ê~@     ê}@                      .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss                                                                               8@     8                                                 T@     T                                     !             t@     t      $                              4   ˆˇˇo       ò@     ò      0                             >             »@     »      ¿                          F             à	@     à	      ˝                             N   ˇˇˇo       Ü@     Ü      ê                            [   ˛ˇˇo       @           `                            j             x@     x      `                            t      B       ÿ@     ÿ      `                          ~             8@     8                                    y             `@     `      P                            Ñ             ∞@     ∞      ¢f                             ä             T@     T      	                              ê             Ä@     Ä      t              @               ò             Ùô@     Ùô      ,                             ¶              ù@      ù      Ï                             ∞             æ`     æ                                    º             æ`     æ                                    »              æ`      æ                                    Õ             (æ`     (æ      –                           ÷             ¯ø`     ¯ø                                   €              ¿`      ¿      8                            ‰             @¬`     @¬      ò              @               Í              “`     ÿ—      ¯              @                                     ÿ—      Ô                                                                                                                                                      usr/sbin/dkms                                                                                       0100755 0000000 0000000 00000372576 12414033245 011717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/bash
#
#  Dynamic Kernel Module Support (DKMS) <dkms-devel@dell.com>
#  Copyright (C) 2003-2008 Dell, Inc.
#  by Gary Lerhaupt, Matt Domsch, & Mario Limonciello
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

shopt -s extglob

# All of the variables we will accept from dkms.conf.
# Does not include directives
readonly dkms_conf_variables="CLEAN REMAKE_INITRD remake_initrd PACKAGE_NAME
       PACKAGE_VERSION POST_ADD POST_INSTALL POST_REMOVE PRE_BUILD
       PRE_INSTALL BUILD_EXCLUSIVE_KERNEL BUILD_EXCLUSIVE_ARCH
       build_exclude OBSOLETE_BY MAKE MAKE_MATCH MODULES_CONF
       modules_conf_array PATCH PATCH_MATCH patch_array BUILT_MODULE_NAME
       built_module_name BUILT_MODULE_LOCATION built_module_location
       DEST_MODULE_NAME dest_module_name MODULES_CONF_OBSOLETES
       DEST_MODULE_LOCATION dest_module_location
       modules_conf_obsoletes MODULES_CONF_ALIAS_TYPE
       modules_conf_alias_type STRIP strip MODULES_CONF_OBSOLETE_ONLY
       modules_conf_obsolete_only AUTOINSTALL"

# Some important regular expressions.  Requires bash 3 or above.
# Any poor souls still running bash 2 or older really need an upgrade.
readonly y_re='^(Y|y)'
readonly mv_re='^([^/]*)/(.*)$'
readonly rh_kernels='(debug|summit|smp|enterprise|bigmem|hugemem|BOOT|vmnix)'

#Areas that will vary between Linux and other OS's
_get_kernel_dir() {
    KVER=$1
    case ${current_os} in
       Linux)          DIR="/lib/modules/$KVER/build" ;;
       GNU/kFreeBSD)   DIR="/usr/src/kfreebsd-headers-$KVER/sys" ;;
    esac
    echo $DIR
}

_check_kernel_dir() {
    DIR=$(_get_kernel_dir $1)
    case ${current_os} in
       Linux)          test -e $DIR/include ;;
       GNU/kFreeBSD)   test -e $DIR/kern && test -e $DIR/conf/kmod.mk ;;
       *)              return 1 ;;
    esac
    return $?
}

# Run a command that we may or may not want to be detailed about.
invoke_command()
{
    # $1 = command to be executed using eval.
    # $2 = Description of command to run
    # $3 = 'background' if you want to run the command asynchronously.
    local exitval=0
    [[ $verbose ]] && echo -e "$1" || echo -en "$2..."
    if [[ $3 = background && ! $verbose ]]; then
	local exitval_file=$(mktemp_or_die $tmp_location/dkms.XXXXXX)
	(eval "$1" >/dev/null 2>&1; echo "exitval=$?" >> "$exitval_file") &
	while [[ -e $exitval_file && ! -s $exitval_file ]]; do
	    sleep 3
	    echo -en "."
	done
	. "$exitval_file"
	rm -f "$exitval_file"
    else
	eval "$1"; exitval=$?
    fi
    (($exitval > 0)) && echo -en "(bad exit status: $exitval)"
    echo -en "\n"
    return $exitval
}

error() (
    exec >&2
    echo -n $"Error! "
    for s in "$@"; do echo "$s"; done 
)

warn() (
    exec >&2
    echo -n "$Warning: "
    for s in "$@"; do echo "$s"; done
)

# Print an error message and die with the passed error code.
die() {
    # $1 = error code to return with
    # rest = strings to print before we exit.
    ret=$1
    shift
    error "$@"
    [[ $die_is_fatal = yes ]] && exit $ret || return $ret
}

mktemp_or_die() {
    local t
    t=$(mktemp "$@") && echo "$t" && return
    [[ $* = *-d* ]] && die 1 $"Unable to make temporary directory"
    die 1 "Unable to make temporary file."
}

show_usage()
{
    echo $"Usage: $0 [action] [options]"
    echo $"  [action]  = { add | remove | build | install | uninstall | match | autoinstall"
    echo $"               | mkdriverdisk | mktarball | ldtarball | mkrpm | mkkmp | mkdeb | status }"
    echo $"  [options] = [-m module] [-v module-version] [-k kernel-version] [-a arch]"
    echo $"              [-d distro] [-c dkms.conf-location] [-q] [--force] [--all]"
    echo $"              [--templatekernel=kernel] [--directive='cli-directive=cli-value']"
    echo $"              [--config=kernel-.config-location] [--archive=tarball-location]"
    echo $"              [--kernelsourcedir=source-location] [--no-prepare-kernel] [--no-initrd]"
    echo $"              [--binaries-only] [--source-only] [-r release (SuSE)] [--verbose]"
    echo $"              [--size] [--spec=specfile] [--media=floppy|iso|tar] [--legacy-postinst=0|1]"
}

VER()
{
    # $1 = kernel version string

    # Pad all numbers in $1 so that they have at least three digits, e.g.,
    #   2.6.9-1cvs200409091247 => 002.006.009-001cvs200409091247
    # The result should compare correctly as a string.

    echo $1 | sed -e 's:\([^0-9]\)\([0-9]\):\1 \2:g' \
		  -e 's:\([0-9]\)\([^0-9]\):\1 \2:g' \
		  -e 's:\(.*\): \1 :' \
		  -e 's: \([0-9]\) : 00\1 :g' \
		  -e 's: \([0-9][0-9]\) : 0\1 :g' \
		  -e 's: ::g'
}

# Figure out the correct module suffix for the kernel we are currently
# dealing with, which may or may not be the currently installed kernel.
set_module_suffix()
{
    # $1 = the kernel to base the module_suffix on
    kernel_test="${1-:$(uname -r)}"
    module_suffix=".ko"
    [[ $(VER $kernel_test) < $(VER 2.5) ]] && module_suffix=".o"
}

set_kernel_source_dir()
{
    # $1 = the kernel to base the directory on
    kernel_source_dir="$(_get_kernel_dir "$1")"
}

# A little test function for DKMS commands that only work on one kernel.
have_one_kernel() {
    if (( ${#kernelver[@]} != 1 )); then
        die 4 $"The action $1 does not support multiple kernel version" \
        $"parameters on the command line."
    fi
    if [[ $all ]]; then
        die 5 $"The action $1 does not support the --all" \
        $"parameter."
    fi
}

# Set up the kernelver and arch arrays.  You must have a 1:1 correspondence --
# if there is an entry in kernelver[$i], there must also be an entry in arch[$i]
# Note the special casing for the status action -- the status functions just
# report on what we already have, and will break with the preprocessing that
# this function provides.
setup_kernels_arches()
{
    # If all is set, use dkms status to fill the arrays
    if [[ $all && $1 != status ]]; then
	local i=0
	while read line; do
	    line=${line#*/}; line=${line#*/};
	    # (I would leave out the delimiters in the status output
	    #  in the first place.)
	    kernelver[$i]=${line%/*}
	    arch[$i]=${line#*/}
	    i=$(($i + 1))
	done < <(module_status_built "$module" "$module_version")
    fi

    # Set default kernel version and arch, if none set (but only --all isn't set)
    if [[ $1 != status ]]; then
	if [[ ! $kernelver && ! $all ]]; then
	    kernelver[0]=$(uname -r)
	    kernels_arches_default="yes"
	fi
	if [[ ! $arch ]]; then
	    kernelver_rpm=$(rpm -qf "/lib/modules/$kernelver" 2>/dev/null | \
		grep -v "not owned by any package" | grep kernel | head -n 1)
	    if ! arch[0]=$(rpm -q --queryformat "%{ARCH}" "$kernelver_rpm" 2>/dev/null); then
		arch[0]=$(uname -m)
		if [[ $arch = x86_64 ]] && \
		    grep -q Intel /proc/cpuinfo && \
		    ls $install_tree/$kernelver/build/configs \
		    2>/dev/null | grep -q "ia32e"; then
		    arch[0]="ia32e"
		fi
	    fi
	fi
    fi

    # If only one arch is specified, make it so for all the kernels
    if ((${#arch[@]} == 1 && ${#kernelver[@]} > 1)); then
	while ((${#arch[@]} < ${#kernelver[@]})); do
	    arch[${#arch[@]}]=$arch
	done
    fi

    # Set global multi_arch
    multi_arch=""
    local i=0
    for ((i=0; $i < ${#arch[@]}; i++)); do
	[[ $arch != ${arch[$i]} ]] && {
	    multi_arch="true"
	    break
	}
    done
}

do_depmod()
{
    # $1 = kernel version
    if [ "${current_os}" != "Linux" ] ; then
        return
    fi
    if [[ -f /boot/System.map-$1 ]]; then
	/sbin/depmod -a "$1" -F "/boot/System.map-$1"
    else
	/sbin/depmod -a "$1"
    fi
}

# This function is a little hairy -- every distro has slightly different tools
# and naming conventions for creating initial ramdisks.  It should probably
# be split out into one function per distro, with make_initrd left as a stub.
make_initrd()
{
    # $1 = kernel version
    # $2 = arch
    [[ $no_initrd ]] && return
    local mkinitrd kernel_file initrd_dir="/boot"
    for mkinitrd in dracut update-initramfs mkinitrd ''; do
	[[ $mkinitrd ]] && which "$mkinitrd" >/dev/null 2>&1 && break
    done

    # no mkinitrd? Just return.
    [[ $mkinitrd ]] || return 0

    # back up our current initrd
    echo $""
    [[ $2 = ia64 && -d /boot/efi/efi/redhat ]] && initrd_dir="/boot/efi/efi/redhat"
    # find out what the proper filename will be
    for initrd in "initrd-$1.img" "initramfs-$1.img" "initrd.img-$1" "initrd-$1" ''; do
	[[ $initrd && -f $initrd_dir/$initrd ]] && break
    done
    if ! [[ $initrd ]]; then
	# Return if we cannot find an initrd.
	warn $"Unable to find an initial ram disk that I know how to handle." \
	    $"Will not try to make an initrd."
	return 0
    fi
    echo $"Backing up $initrd to $initrd_dir/$initrd.old-dkms"
    cp -f "$initrd_dir/$initrd" "$initrd_dir/$initrd.old-dkms"
    echo $"Making new $initrd"
    echo $"(If next boot fails, revert to $initrd.old-dkms image)"

    if [[ $mkinitrd = dracut ]]; then
	invoke_command "$mkinitrd $1" "$mkinitrd" background
    elif [[ $mkinitrd = update-initramfs ]]; then
	invoke_command "$mkinitrd -u" "$mkinitrd" background
    elif $mkinitrd --version >/dev/null 2>&1; then
	invoke_command "$mkinitrd -f $initrd_dir/$initrd $1" "$mkinitrd" background
    elif [[ -e /etc/SuSE-release || -d /etc/SuSEconfig ]]; then
	for kernel_file in vmlinuz vmlinux ''; do
	    [[ $kernel_file && -f $initrd_dir/$kernel_file ]] && break
	done
	if [[ ! $kernel_file ]]; then
	    error $"Unable to find valid kernel file under " \
		$"$initrd_dir for kernel version $1" 
	    return 1;
	fi
	invoke_command "$mkinitrd -k $kernel_file-$1 -i $initrd" "$mkinitrd" background
    elif [[ -e /etc/debian_version ]]; then
	invoke_command "$mkinitrd -o $initrd_dir/$initrd $1" "$mkinitrd" background
    else
	echo $""
	echo $"Calling $mkinitrd (bad exit status 9 may occur)"
	invoke_command "$mkinitrd" "$mkinitrd" background
    fi
    return
}

# Grab our distro information from RPM-based distros.
distro_version_rpm()
{
    which rpm > /dev/null 2>&1 || { echo unknown; return; }
    local r wp ver dist

    for r in redhat-release sles-release suse-release ovs-release; do
	wp=$(rpm -q --whatprovides "$r") || continue
	ver=$(rpm -q --qf "%{version}\n" ${wp})
	case $r in
	    sles*) echo sles${ver};;
	    suse*) echo suse${ver};;
	    ovs*)  echo ovm${ver};;
	    redhat*)
		case $wp in
		    redhat*|sl*)
			ver=$(echo $ver | \
			sed -e 's/^\([[:digit:]]*\).*/\1/g')
			echo el${ver};;
		    centos*|enterprise*) echo el${ver};;
		    fedora*) echo fc${ver};;
		    *) echo unknown ;;
		esac
	       ;;
	    *) echo unknown;;
	esac
	return
    done
    echo unknown
}

# Grab distro information from LSB compliant distros.
# Falls back to distro_version_rpm if needed.
distro_version()
{
    # What distribution are we running?
    local LSB_DESCRIPTION DISTRIB_ID DISTRIB_RELEASE ver

    # try the LSB-provided strings first
    if [ -r /etc/lsb-release ]; then
	. /etc/lsb-release
    elif type lsb_release >/dev/null 2>&1; then
	DISTRIB_ID=$(lsb_release -i -s)
	DISTRIB_RELEASE=$(lsb_release -r -s)
    fi

    case ${DISTRIB_ID} in
	Fedora)     echo fc${DISTRIB_RELEASE} ;;
	RedHatEnterprise*|CentOS|ScientificSL)  # OEL also reports as such
	# format is 4.7, 5.3
	    ver=$(echo "${DISTRIB_RELEASE}" | \
		sed -e 's/^\([[:digit:]]*\).*/\1/g')
	    echo el${ver}
	    ;;
	SUSE*)
	    if [[ $(lsb_release -d -s) =~ Enterprise ]]; then
		echo sles${DISTRIB_RELEASE}
	    else
		echo suse${DISTRIB_RELEASE}
	    fi
	    ;;
	*)
	    if [[ ${DISTRIB_ID} && ${DISTRIB_RELEASE} ]]; then
		echo "${DISTRIB_ID}${DISTRIB_RELEASE}"
	    else
		distro_version_rpm
	    fi
	    ;;
    esac
}

override_dest_module_location()
{
    local orig_location="$1"
    [[ ${addon_modules_dir} ]] && echo "/${addon_modules_dir}" && return

    if [ "$current_os" = "GNU/kFreeBSD" ] ; then
	# Does not support subdirs, regardless of distribution
	echo "" && return
    fi

    case "$running_distribution" in
	fc[12345]) ;;
	el[1234]) ;;
	sles[123456789]) ;;
	suse[123456789]) ;;
	suse10\.[01]) ;;
	fc*) echo "/extra" && return ;;
	el*) echo "/extra" && return ;;
	ovm*) echo "/extra" && return ;;
	sles*) echo "/updates" && return ;;
	suse*) echo "/updates" && return ;;
	Ubuntu*) echo "/updates/dkms" && return ;;
	Debian*) echo "/updates/dkms" && return ;;
	*) ;;
    esac
    echo "$orig_location"
}

# Source a file safely.
# We want to ensure that the .conf file we source does not stomp all over
# parts of the environment we don't want them to.  This makes it so that
# it is harder to accidentally corrupt our environment.  conf files can
# still deliberatly trash the environment by abusing dkms_directive env
# variables or by crafting special values that will make eval do evil things.
safe_source() {
    # $1 = file to source
    # $@ = environment variables to echo out
    local to_source_file="$1"; shift
    declare -a -r export_envs=("$@")
    local tmpfile=$(mktemp_or_die)
    ( exec >"$tmpfile"
	. "$to_source_file" >/dev/null
	# This is really ugly, but a neat hack
	# Remember, in bash 2.0 and greater all variables are really arrays.
	for _export_env in "${export_envs[@]}"; do
	    for _i in $(eval echo \${!$_export_env[@]}); do
		eval echo '$_export_env[$_i]=\"${'$_export_env'[$_i]}\"'
	    done
	done

	# handle DKMS_DIRECTIVE stuff specially.
	for directive in $(set | grep ^DKMS_DIRECTIVE | cut -d = -f 2-3); do
	    directive_name=${directive%%=*}
	    directive_value=${directive#*=}
	    echo "$directive_name=\"$directive_value\""
	done
    )
    . "$tmpfile"
    rm "$tmpfile"
}

# Source a dkms.conf file and perform appropriate postprocessing on it.
# Do our best to not repeatedly source the same .conf file -- this can happen
# when chaining module installtion functions or autoinstalling.
read_conf()
{
    # $1 kernel version (required)
    # $2 arch (required)
    # $3 dkms.conf location (optional)

    local return_value=0
    local read_conf_file="$dkms_tree/$module/$module_version/source/dkms.conf"

    # Set variables supported in dkms.conf files (eg. $kernelver)
    local kernelver="$1"
    local arch="$2"
    set_kernel_source_dir "$1"


    # Find which conf file to check
    [[ $conf ]] && read_conf_file="$conf"
    [[ $3 ]] && read_conf_file="$3"

    [[ -r $read_conf_file ]] || die 4 $"Could not locate dkms.conf file." \
	$"File: $conf does not exist."

    [[ $last_mvka = $module/$module_version/$1/$2 && \
	$last_mvka_conf = $(readlink -f $read_conf_file) ]] && return


    # Clear variables and arrays
    for var in $dkms_conf_variables; do
	unset $var
    done

    # Source in the dkms.conf.
    # Allow for user-specified overrides in order of specificity.
    local _conf_file
    for _conf_file in "$read_conf_file" "/etc/dkms/$module.conf" \
        "/etc/dkms/$module-$module_version.conf" "/etc/dkms/$module-$module_version-$1.conf" \
        "/etc/dkms/$module-$module_version-$1-$2.conf"; do
        [ -e "$_conf_file" ] && safe_source "$_conf_file" $dkms_conf_variables
    done

    # Source in the directive_array
    for directive in "${directive_array[@]}"; do
	directive_name=${directive%%=*}
	directive_value=${directive#*=}
	export $directive_name="$directive_value"
	echo $"DIRECTIVE: $directive_name=\"$directive_value\""
    done

    # Set variables
    clean="$CLEAN"
    package_name="$PACKAGE_NAME"
    package_version="$PACKAGE_VERSION"
    post_add="$POST_ADD"
    post_build="$POST_BUILD"
    post_install="$POST_INSTALL"
    post_remove="$POST_REMOVE"
    pre_build="$PRE_BUILD"
    pre_install="$PRE_INSTALL"
    obsolete_by="$OBSOLETE_BY"

    # Set module naming/location arrays
    local index array_size=0 s
    for s in ${#BUILT_MODULE_NAME[@]} \
	${#BUILT_MODULE_LOCATION[@]} \
	${#DEST_MODULE_NAME[@]} \
	${#DEST_MODULE_LOCATION[@]}; do
	((s > array_size)) && array_size=$s
    done
    for ((index=0; index < array_size; index++)); do
	# Set values
	built_module_name[$index]=${BUILT_MODULE_NAME[$index]}
	built_module_location[$index]=${BUILT_MODULE_LOCATION[$index]}
	dest_module_name[$index]=${DEST_MODULE_NAME[$index]}
	dest_module_location[$index]=${DEST_MODULE_LOCATION[$index]}
	modules_conf_obsoletes[$index]=${MODULES_CONF_OBSOLETES[$index]}
	modules_conf_alias_type[$index]=${MODULES_CONF_ALIAS_TYPE[$index]}
	case ${MODULES_CONF_OBSOLETE_ONLY[$index]} in
	    [yY]*) modules_conf_obsolete_only[$index]="yes";;
	esac
	case ${STRIP[$index]} in
	    [nN]*) strip[$index]="no";;
	    *)     strip[$index]="yes";;
	esac

	# If unset, set by defaults
	[[ ! ${built_module_name[$index]} ]] && \
	    ((${#DEST_MODULE_LOCATION[@]} == 1)) && \
	    built_module_name[$index]=$module
	[[ ! ${dest_module_name[$index]} ]] && \
	    dest_module_name[$index]=${built_module_name[$index]}
	[[ ${built_module_location[$index]} && \
	    ${built_module_location[$index]:(-1)} != / ]] && \
	    built_module_location[$index]="${built_module_location[$index]}/"

	# FAIL if no built_module_name
	if [[ ! ${built_module_name[$index]} ]]; then
	    echo $"dkms.conf: Error! No 'BUILT_MODULE_NAME' directive specified for record #$index." >&2
	    return_value=1
	fi

	# FAIL if built_module_name ends in .o or .ko
	case ${built_module_name[$index]} in
	*.o|*.ko)
	    echo $"dkms.conf: Error! 'BUILT_MODULE_NAME' directive ends in '.o' or '.ko' in record #$index." >&2
	    return_value=1
	    ;;
	esac

	# FAIL if dest_module_name ends in .o or .ko
	case ${dest_module_name[$index]} in
	*.o|*.ko)
	    echo $"dkms.conf: Error! 'DEST_MODULE_NAME' directive ends in '.o' or '.ko' in record #$index." >&2
	    return_value=1
	    ;;
	esac

	# Override location for specific kernels
	dest_module_location[$index]="$(override_dest_module_location ${dest_module_location[$index]})"

	# Fail if no DEST_MODULE_LOCATION
	if [[ ! ${DEST_MODULE_LOCATION[$index]} ]]; then
	    echo $"dkms.conf: Error! No 'DEST_MODULE_LOCATION' directive specified for record #$index.">&2
	    return_value=1
	fi
	    # Fail if bad DEST_MODULE_LOCATION
	case ${DEST_MODULE_LOCATION[$index]} in
	    /kernel*) ;;
	    /updates*) ;;
	    /extra*) ;;
	    *)
		echo $"dkms.conf: Error! Directive 'DEST_MODULE_LOCATION' does not begin with">&2
		echo $"'/kernel', '/updates', or '/extra' in record #$index.">&2
		return_value=1
		;;
	esac
    done

    # Get the correct make command
    [[ ${MAKE_MATCH[0]} ]] || make_command="${MAKE[0]}"
    for ((index=0; index < ${#MAKE[@]}; index++)); do
	[[ ${MAKE[$index]} && ${MAKE_MATCH[$index]} && \
	    $1 =~ ${MAKE_MATCH[$index]} ]] && \
	    make_command="${MAKE[$index]}"
    done

    # Use the generic make and make clean commands if not specified
    if [[ $(VER $1) < $(VER 2.6.6) ]]; then
	[[ ! $make_command ]] && \
	    make_command="make -C $kernel_source_dir SUBDIRS=$dkms_tree/$module/$module_version/build modules"
	[[ ! $clean ]] && \
	    clean="make -C $kernel_source_dir SUBDIRS=$dkms_tree/$module/$module_version/build clean"
    else
	[[ ! $make_command ]] && \
	    make_command="make -C $kernel_source_dir M=$dkms_tree/$module/$module_version/build"
	 [[ ! $clean ]] && \
	     clean="make -C $kernel_source_dir M=$dkms_tree/$module/$module_version/build clean"
    fi

    # Set modules_conf_array
    for ((index=0; index < ${#MODULES_CONF[@]}; index++)); do
	[[ ${MODULES_CONF[$index]} ]] && modules_conf_array[$index]="${MODULES_CONF[$index]}"
    done

    # Set patch_array (including kernel specific patches)
    count=0
    for ((index=0; index < ${#PATCH[@]}; index++)); do
	if [[ ${PATCH[$index]} && (! ${PATCH_MATCH[$index]} || \
		$1 =~ ${PATCH_MATCH[$index]}) ]]; then
	    patch_array[$count]="${PATCH[$index]}"
	    count=$(($count+1))
	fi
    done

    # Set remake_initrd
    [[ $REMAKE_INITRD =~ $y_re ]] && remake_initrd="yes"

    # Set build_exclude
    [[ $BUILD_EXCLUSIVE_KERNEL && ! $1 =~ $BUILD_EXCLUSIVE_KERNEL ]] && \
       build_exclude="yes"
    [[ $BUILD_EXCLUSIVE_ARCH && ! $2 =~ $BUILD_EXCLUSIVE_ARCH ]] && \
	build_exclude="yes"

    # Fail if absolutely no DEST_MODULE_LOCATION
    if ((${#dest_module_location[@]} == 0)); then
	echo $"dkms.conf: Error! No 'DEST_MODULE_LOCATION' directive specified." >&2
	return_value=1
    fi

    # Fail if no PACKAGE_NAME
    if [[ ! $package_name ]]; then
	echo $"dkms.conf: Error! No 'PACKAGE_NAME' directive specified.">&2
	return_value=1
    fi

    # Fail if no PACKAGE_VERSION
    if [[ ! $package_version ]]; then
	echo $"dkms.conf: Error! No 'PACKAGE_VERSION' directive specified.">&2
	return_value=1
    fi

    # Set clean
    [[ $clean ]] || clean="make clean"

    ((return_value == 0)) && last_mvka="$module/$module_version/$1/$2" && \
	last_mvka_conf="$(readlink -f "$read_conf_file")"
    return $return_value
}

# Little helper function for parsing the output of modinfo.
get_module_verinfo(){
    local vals=
    while read -a vals; do
	case ${vals[0]} in
	    version:) res[0]=${vals[1]}; res[2]=${vals[2]};;
	    srcversion:) res[1]=${vals[1]};;
	esac
    done < <(modinfo $1)
}

# Perform some module version sanity checking whenever we are installing
# or removing modules.
check_version_sanity()
{
    # $1 = kernel_version
    # $2 = arch
    # $3 = obs by kernel version
    # $4 = dest_module_name

    local lib_tree="$install_tree/$1" res=
    echo $"Running module version sanity check."
    local i=0
    local -a kernels_info dkms_info
    set_module_suffix
    read -a kernels_module < <(find $lib_tree -name ${4}$module_suffix)
    [[ $kernels_module ]] || return 0
    if [[ ${kernels_module[1]} ]]; then
	warn $"Warning! Cannot do version sanity checking because multiple ${4}$module_suffix" \
	    $"modules were found in kernel $1."
	return 0
    fi
    local dkms_module="$dkms_tree/$module/$module_version/$1/$2/module/${4}$module_suffix"
    get_module_verinfo $kernels_module; kernels_info=("${res[@]}")
    get_module_verinfo $dkms_module; dkms_info=("${res[@]}")
    if [[ ! ${dkms_info[1]} && ${kernels_info[1]} ]]; then
	# use obsolete checksum info
	dkms_info[1]=${dkms_info[2]}
	kernels_info[1]=${kernels_info[2]}
    fi

    if [[ ${kernels_info[1]} && ${dkms_info[1]} && \
	${kernels_info[1]} = ${dkms_info[1]} && ! $force ]]; then
	echo $"" >&2
	echo $"Good news! Module version $dkms_info for ${4}$module_suffix" >&2
	echo $"exactly matches what is already found in kernel $1." >&2
	echo $"DKMS will not replace this module." >&2
	echo $"You may override by specifying --force." >&2
	return 1
    fi

    if [[ $kernels_info && $dkms_info && \
	! ( $(VER $dkms_info) > $(VER $kernels_info) ) && ! $force ]]; then
	error $"Module version $dkms_info for ${4}$module_suffix" \
	    $"is not newer than what is already found in kernel $1 ($kernels_info)." \
	    $"You may override by specifying --force."
	return 1
    fi

    # magic split into array syntax saves trivial awk and cut calls.
    local -a obs=(${3//-/ })
    local -a my=(${1//-/ })
    local obsolete=0
    if [[ ${obs} && ${my} ]]; then
	if [[ $(VER ${obs}) == $(VER ${my}) && ! $force ]]; then
	    #they get obsoleted possibly in this kernel release
	    if [[ ! ${obs[1]} ]]; then
		#they were obsoleted in this upstream kernel
		obsolete=1
	    elif [[ $(VER ${my[1]}) > $(VER ${obs[1]}) ]]; then
		#they were obsoleted in an earlier ABI bump of the kernel
		obsolete=1
	    elif [[ $(VER ${my[1]}) = $(VER ${obs[1]}) ]]; then
		#they were obsoleted in this ABI bump of the kernel
		obsolete=1
	    fi
	elif [[ $(VER ${my}) > $(VER ${obs}) && ! $force ]]; then
	    #they were obsoleted in an earlier kernel release
	    obsolete=1
	fi
    fi

    if ((obsolete == 1)); then
	echo $"" >&2
	echo $"Module has been obsoleted due to being included" >&2
	echo $"in kernel $3.  We will avoid installing" >&2
	echo $"for future kernels above $3." >&2
	echo $"You may override by specifying --force." >&2
	return 1
    fi
    return 0
}

moduleconfig_update_obsoletes()
{
    # $@ = files to process
    # do nothing if we have no obsoletes
    [[ ${modules_conf_obsoletes[@]} ]] || return 0
    # generate sed args to remove obsolete modules
    local mod_diff
    for ((index=0; index < ${#dest_module_name[@]}; index++)); do
	[[ ${modules_conf_obsoletes[$index]} ]] || continue
	for obsolete_module in ${modules_conf_obsoletes[$index]//,/ }; do
	    # for module.conf style syntax
	    sa_mc_o[${#sa_mc_o[@]}]="-e"
	    sa_mc_o[${#sa_mc_o[@]}]="s/\(alias ${modules_conf_alias_type[$index]}[0-9]*\) $obsolete_module$/\1 ${dest_module_name[$index]}/g"

	    # for /etc/sysconfig/kernel style syntax
	    sa_sck_o[${#sa_sck_o[@]}]="-e"
	    sa_sck_o[${#sa_sck_o[@]}]="s/\(INITRD_MODULES.*\)$obsolete_module\b\(.*\)/\1${dest_module_name[$index]}\2/"
	done
    done

    # do all the changes at once, record the diffs for posterity
    for file in "$@"; do
	[[ $file && -w $file ]] || continue
	_tmpf="$temp_dir_name/${file##*/}.new"
	if [[ $file = /etc/sysconfig/kernel ]]; then
	    [ -z "${sa_sck_o[@]}" ] || sed "${sa_sck_o[@]}" "$file" > "$_tmpf"
	else
	    [ -z "${sa_mc_o[@]}" ] || sed "${sa_mc_o[@]}" "$file" > "$_tmpf"
	fi
	if [ -f "$_tmpf" ] && ! mod_diff=$(diff -u "$_tmpf" "$file"); then
	    echo $"$file updated to replace obsoleted module references:"
	    echo "$mod_diff"
	    cp -fp "$_tmpf" "$file"
	    rm -f "$_tmpf"
	fi
    done
}

moduleconfig_add()
{
    # $1 = kernel version

    local temp_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
    local -a sa_mc_o=() sa_sck_o=()
    modconfig_files="/etc/modprobe.d/dkms.conf
		     /etc/modprobe.d/dkms
		     /etc/modules.conf
		     /etc/modprobe.conf
		     /etc/modprobe.d/$package_name.conf
		     /etc/sysconfig/kernel"

    moduleconfig_update_obsoletes $modconfig_files

    for moduleconfig in $modconfig_files; do
	[[ -e $moduleconfig ]] || continue
	for ((index=0; index < ${#dest_module_name[@]}; index++)); do

	    # Only add it if it can't be found already in config file
	    if [[ ${modules_conf_alias_type[$index]} ]] && \
	       ! grep -qs "alias ${modules_conf_alias_type[$index]}[0-9]* ${dest_module_name[$index]}\b" $moduleconfig && \
	       [[ ${modules_conf_obsolete_only[$index]} != yes ]]; then
		if [[ $modconfig_files = /etc/modprobe.d/$package_name.conf ]] && \
		    [[ ! -e /etc/modprobe.d/$package_name.conf ]]; then
		    touch /etc/modprobe.d/$package_name.conf
		    echo $"created /etc/modprobe.d/$package_name.conf.">&2
		fi
		aliases=$(awk "/^alias ${modules_conf_alias_type[$index]}/ {print \$2}" $moduleconfig)
		if [[ $aliases ]]; then
		    alias_number=$(($(echo "$aliases" | sed "s/${modules_conf_alias_type[$index]}//" | sort -n | tail -n 1) + 1))
		else
		    alias_number=0
		fi
		echo -e "alias ${modules_conf_alias_type[$index]}${alias_number} ${dest_module_name[$index]}" >> $moduleconfig
		echo $"$moduleconfig: added alias reference for '${dest_module_name[$index]}'"
	    fi
	done

	# Add anything else
	for ((index=0; index < ${#modules_conf_array[@]}; index++)); do
	    if [ -n "${modules_conf_array[$index]}" ] && \
	    ! grep -q "${modules_conf_array[$index]}" "$moduleconfig"; then
	    echo -e $"$moduleconfig: added '${modules_conf_array[$index]}'"
	    echo -e "${modules_conf_array[$index]}" >> $moduleconfig
	    fi
	done
    done

    # Delete the temp dir
    rm -rf $temp_dir_name
}

moduleconfig_remove()
{
    # $1 = kernel version

    local temp_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
    modconfig_files=""
    [ -e /etc/modprobe.d/dkms.conf ] && modconfig_files="/etc/modprobe.d/dkms.conf"
    [ -e /etc/modprobe.d/dkms ] && modconfig_files="/etc/modprobe.d/dkms"
    [ -e /etc/modules.conf ] && modconfig_files="$modconfig_files /etc/modules.conf"
    [ -e /etc/modprobe.conf ] && modconfig_files="$modconfig_files /etc/modprobe.conf"
    [ -e /etc/modprobe.d/$package_name.conf ] && modconfig_files="/etc/modprobe.d/$package_name.conf"

    for moduleconfig in $modconfig_files; do
	for ((index=0; index < ${#dest_module_name[@]}; index++)); do
	    # Remove/Replace aliases (maybe)
	    [[ ${modules_conf_alias_type[$index]} ]] || continue
	    find "$install_tree/$1/" -name "${dest_module_name[$index]}.*" -quit 2>/dev/null && continue

	    local conf_replacement=""
	    for obsolete_module in ${modules_conf_obsoletes[$index]//,/ }; do
		find $install_tree/$1/ -name "$obsolete_module.*" -quit 2>/dev/null || continue
		conf_replacement=$obsolete_module
		break
	    done

	    if [[ ! $conf_replacement ]]; then
		grep -v "alias ${modules_conf_alias_type[$index]}[0-9]* ${dest_module_name[$index]}" $moduleconfig > $temp_dir_name/moduleconfig.new
		mv -f $temp_dir_name/moduleconfig.new $moduleconfig
		echo $"$moduleconfig: removed alias for '${dest_module_name[$index]}'"
		if [[ $modconfig_files = /etc/modprobe.d/$package_name.conf ]]; then
		    rm -f /etc/modprobe.d/$package_name.conf
		    echo $"$moduleconfig: deleted /etc/modprobe.d/$package_name.conf file"
		fi
	    elif grep -q "alias ${modules_conf_alias_type[$index]}[0-9]* ${dest_module_name[$index]}$" $moduleconfig; then
		sed "s/\(alias ${modules_conf_alias_type[$index]}[0-9]*\) ${dest_module_name[$index]}$/\1 $conf_replacement/g" $moduleconfig > $temp_dir_name/moduleconfig.new
		mv -f $temp_dir_name/moduleconfig.new $moduleconfig
		echo $"$moduleconfig: alias for '${dest_module_name[$index]}' changed back to '$conf_replacement'"
	    fi
	done

	# Remove static conf entries
	for ((index=0; index < ${#modules_conf_array[@]}; index++)); do
	    [[ ${modules_conf_array[$index]} ]] || continue
	    grep -v "${modules_conf_array[$index]}" "$moduleconfig" > $temp_dir_name/moduleconfig.new
	    echo $"$moduleconfig: removed '${modules_conf_array[$index]}'"
	    mv -f $temp_dir_name/moduleconfig.new $moduleconfig
	done
    done

    # Delete the temp dir
    rm -rf $temp_dir_name
}

etc_sysconfig_kernel_modify()
(
    [[ -e /etc/sysconfig/kernel && $remake_initrd ]] || return 0

    # Make a temp directory to store files
    local temp_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
    if [[ $1 = add ]]; then
	. /etc/sysconfig/kernel
	for m in "${dest_module_name[@]}"; do
	    for l in "${INITRD_MODULES}"; do
		[[ $m = $l ]] && continue 2
	    done
	    sed -e "s/INITRD_MODULES=\"\(.*\)\"/INITRD_MODULES=\"\1 $m\"/" /etc/sysconfig/kernel > $temp_dir_name/kernel.new
	    mv $temp_dir_name/kernel.new /etc/sysconfig/kernel
	done
    # Remove /etc/sysconfig/kernel entries
    elif [[ $1 = delete ]]; then
	for m in "${dest_module_name[@]}"; do
	    sed -e "s/\(INITRD_MODULES.*\)$m\b\(.*\)/\1\2/" /etc/sysconfig/kernel > $temp_dir_name/kernel.new
	    mv $temp_dir_name/kernel.new /etc/sysconfig/kernel
	done
    fi
    # Delete the temp dir
    rm -rf $temp_dir_name
)

check_module_args() {
    [[ $module && $module_version ]] && return
    die 1 $"Invalid number of arguments passed." \
        $"Usage: $1 <module>/<module-version> or" \
        $"       $1 -m <module>/<module-version> or" \
	$"       $1 -m <module> -v <module-version>"
}

read_conf_or_die() {
    read_conf "$@" && return
    die 8 $"Bad conf file." $"File: $conf" \
	$"does not represent a valid dkms.conf file."
}

run_build_script() {
    # $1 = script type
    # $2 = script to run
    local script_type run
    [[ $2 ]] || return 0
    case "$1" in
        pre_build|post_build) script_type='build';;
        *) script_type='source'
    esac
    run="$dkms_tree/$module/$module_version/$script_type/$2"
    if [[ -x ${run%% *} ]]; then
        echo $""
        echo $"Running the $1 script:"
        (
            cd "$dkms_tree/$module/$module_version/$script_type/"
            exec $run
        )
    else
        echo $""
        warn $"The $1 script is not executable."
    fi
}

# Register a DKMS-ified source tree with DKMS.
# This function is smart enough to register the module if we
# passed a source tree or a tarball instead of relying on the source tree
# being unpacked into /usr/src/$module-$module_version.
add_module()
{
    # if $archive is set and $module and $module_version are not,
    # try loading the tarball passed first.
    if [[ $archive_location && ! $module && ! $module_version ]]; then
	load_tarball
    elif [[ $try_source_tree && ! $module && ! $module_version ]]; then
	add_source_tree "$try_source_tree"
    fi

    # Check that we have all the arguments
    check_module_args add

    # Check that this module-version hasn't already been added
    if is_module_added "$module" "$module_version"; then
	die 3 $"DKMS tree already contains: $module-$module_version" \
	    $"You cannot add the same module/version combo more than once."
    fi

    [[ $conf ]] || conf="$source_tree/$module-$module_version/dkms.conf"

    # Check that /usr/src/$module-$module_version exists
    if ! [[ -d $source_tree/$module-$module_version ]]; then
	die 2 $"Could not find module source directory." \
	    $"Directory: $source_tree/$module-$module_version does not exist."
    fi

    # Do stuff for --rpm_safe_upgrade
    if [[ $rpm_safe_upgrade ]]; then
	local pppid=$(awk '/PPid:/ {print $2}' /proc/$PPID/status)
	local lock_name=$(mktemp_or_die $tmp_location/dkms_rpm_safe_upgrade_lock.$pppid.XXXXXX)
	echo "$module-$module_version" >> $lock_name
	ps -o lstart --no-headers -p $pppid 2>/dev/null >> $lock_name
    fi

    # Check the conf file for sanity
    read_conf_or_die "$kernelver" "$arch" "$conf"

    # Create the necessary dkms tree structure
    echo $""
    echo $"Creating symlink $dkms_tree/$module/$module_version/source ->"
    echo $"                 $source_tree/$module-$module_version"
    mkdir -p "$dkms_tree/$module/$module_version/build"
    ln -s "$source_tree/$module-$module_version" "$dkms_tree/$module/$module_version/source"

    # Run the post_add script
    run_build_script post_add "$post_add"

    echo $""
    echo $"DKMS: add completed."
}

# Prepare a kernel source or include tree for compiling a module.
# Most modern-ish distros do not require this function at all,
# so it will be removed in a future release.
prepare_kernel()
{
    # $1 = kernel version to prepare
    # $2 = arch to prepare

    set_kernel_source_dir "$1"

    # Check that kernel-source exists
    _check_kernel_dir "$1" || {
	case "$running_distribution" in
	    Debian* | Ubuntu* )
		die 1 $"Your kernel headers for kernel $1 cannot be found." \
		    $"Please install the linux-headers-$1 package," \
		    $"or use the --kernelsourcedir option to tell DKMS where it's located";;
	    * ) die 1 echo $"Your kernel headers for kernel $1 cannot be found at" \
		$"/lib/modules/$1/build or /lib/modules/$1/source."
		$"You can use the --kernelsourcedir option to tell DKMS where it's located."
	esac
    }

    [[ $no_prepare_kernel ]] && return

    if [[ (! ( $(VER $1) < $(VER 2.6.5) ) || -d /etc/SuSEconfig) && \
       -d "$kernel_source_dir" && \
       -z "$ksourcedir_fromcli" ]]; then
	echo $""
	echo $"Kernel preparation unnecessary for this kernel.  Skipping..."
	no_clean_kernel="no-clean-kernel"
	return 1
    fi

    # Prepare kernel for module build
    echo $""
    echo $"Preparing kernel $1 for module build:"
    echo $"(This is not compiling a kernel, just preparing kernel symbols)"
    cd $kernel_source_dir
    [[ -r .config ]] && {
	config_contents=$(cat .config)
	echo $"Storing current .config to be restored when complete"
    }

    # Set kernel_config
    if [[ -e /etc/redhat-release || -e /etc/fedora-release ]]; then
	# Note this also applies to VMware 3.x
	if [[ -z $kernel_config && -d $kernel_source_dir/configs ]]; then
	    local kernel_trunc=${1%%-*}
	    # Try a .config specific to whatever kernel we are running
	    if [[ $1 =~ $rh_kernels && \
		-e $kernel_source_dir/configs/kernel-$kernel_trunc-$2-${BASH_REMATCH[1]}.config ]]; then
		kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$2-${BASH_REMATCH[1]}.config"
	    elif [[ -e $kernel_source_dir/configs/kernel-$kernel_trunc-$2.config ]]; then
		# If that one does not exist, try a generic one.
		kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$2.config"
	    else
		# If that does not exist, fall back to no config file
		kernel_config=""
	    fi
	fi
    elif [[ (-e /etc/SuSE-release || -d /etc/SuSEconfig) && \
	-z $kernel_config && -d $kernel_source_dir/arch ]]; then
	    local kernel_trunc=${1%%-*}
	    case $2 in
		i586|i686) config_arch="i386";;
		*) config_arch=$2;;
	    esac
	    for config_type in default smp bigsmp; do
		[[ $1 =~ $config_type ]] && kernel_config="$kernel_source_dir/arch/$config_arch/defconfig.$config_type"
		[[ -e $kernel_config ]] || kernel_config=""
	    done
	    [[ $kernel_config ]] || kernel_config="$kernel_source_dir/arch/$config_arch/defconfig.default"
	    [[ -e $kernel_config ]] || kernel_config=""
    fi

    # Do preparation
    if [ -e /boot/vmlinuz.version.h ]; then
	echo $"Running UnitedLinux preparation routine"
	local kernel_config="/boot/vmlinuz.config"
	invoke_command "make mrproper" "make mrproper" background
	[[ $config_contents ]] && echo "$config_contents" > .config
	invoke_command "cp /boot/vmlinuz.version.h include/linux/version.h" "using /boot/vmlinux.version.h"
	invoke_command "cp -f $kernel_config .config" "using $kernel_config"
	invoke_command "make KERNELRELEASE=$1 cloneconfig" "make cloneconfig" background
	invoke_command "make CONFIG_MODVERSIONS=1 KERNELRELEASE=$1 dep" "make CONFIG_MODVERSIONS=1 dep" background
    elif grep -q rhconfig.h $kernel_source_dir/include/linux/{modversions,version}.h 2>/dev/null; then
	echo $"Running Red Hat style preparation routine"
	invoke_command "make clean" "make clean" background
	[[ $config_contents ]] && echo "$config_contents" > .config

	if [[ $kernel_config ]]; then
	    echo $"using $kernel_config"
	    cp -f "$kernel_config" .config
	elif [[ -e .config ]]; then
	    warn $"Using $kernel_source_dir/.config" \
		$"(I hope this is the correct config for this kernel)"
	else
	    warn $"Cannot find a .config file to prepare your kernel with." \
		$"Try using the --config option to specify where one can be found." \
		$"Your build will likely fail because of this."
	fi

	# Hack to workaround broken tmp_include_depends for Red Hat
	if grep -q "/usr/src/build" $kernel_source_dir/tmp_include_depends 2>/dev/null; then
	    sed 's/\/usr\/src\/build\/.*\/install//g' $kernel_source_dir/tmp_include_depends > $kernel_source_dir/tmp_include_depends.new
	    mv -f $kernel_source_dir/tmp_include_depends.new $kernel_source_dir/tmp_include_depends
	fi

	invoke_command "make KERNELRELEASE=$1 oldconfig" "make oldconfig" background
	kerneldoth_contents=$(cat /boot/kernel.h 2>/dev/null)
	invoke_command "/usr/lib/dkms/mkkerneldoth --kernelver $1 --targetarch $2 --output /boot/kernel.h" "running mkkerneldoth" background
    else
	echo $"Running Generic preparation routine"
	invoke_command "make mrproper" "make mrproper" background
	[[ $config_contents ]] && echo "$config_contents" > .config

	if [[ $kernel_config ]]; then
	    echo $"using $kernel_config"
	    cp -f "$kernel_config" .config
	elif [[ -e .config ]]; then
	    warn $"using $kernel_source_dir/.config" \
		$"(I hope this is the correct config for this kernel)"
	else
	    warn $"Warning! Cannot find a .config file to prepare your kernel with." \
		$"Try using the --config option to specify where one can be found." \
		$"Your build will likely fail because of this."
	fi

	invoke_command "make KERNELRELEASE=$1 oldconfig" "make oldconfig" background
	if [[ $(VER $1) < $(VER 2.5) ]]; then
	    invoke_command "make KERNELRELEASE=$1 dep" "make dep" background
	else
	    invoke_command "make KERNELRELEASE=$1 prepare-all scripts" "make prepare-all" background
	fi
    fi
    cd - >/dev/null
}

# Get ready to build a module that has been registered with DKMS.
prepare_build()
{
    # If the module has not been added, try to add it.
    is_module_added "$module" "$module_version" || add_module

    set_kernel_source_dir "$kernelver"
    local base_dir="$dkms_tree/$module/$module_version/$kernelver/$arch"

    # Check that the right arguments were passed
    check_module_args build

    # Check that the module has not already been built for this kernel
    [[ -d $base_dir ]] && die 3 \
	$"This module/version has already been built on: $kernelver" \
	$"Directory: $base_dir" \
	$"already exists.  Use the dkms remove function before trying to build again."

    # Read the conf file
    set_module_suffix "$kernelver"
    read_conf_or_die "$kernelver" "$arch"

    # Error out if build_exclude is set
    [[ $build_exclude ]] && die 9 \
	$" The dkms.conf for this module includes a BUILD_EXCLUSIVE directive which" \
	$"does not match this kernel/arch.  This indicates that it should not be built."

    # Error out if source_tree is basically empty (binary-only dkms tarball w/ --force check)
    (($(ls $dkms_tree/$module/$module_version/source | wc -l | awk {'print $1'}) < 2)) && die 8 \
	$"The directory $dkms_tree/$module/$module_version/source/" \
	$"does not appear to have module source located within it.  Build halted."

    prepare_kernel "$kernelver" "$arch"

    # Set up temporary build directory for build
    rm -rf "$dkms_tree/$module/$module_version/build"
    cp -rf "$dkms_tree/$module/$module_version/source/" "$dkms_tree/$module/$module_version/build"

    cd "$dkms_tree/$module/$module_version/build"

    # Apply any patches
    for p in "${patch_array[@]}"; do
	[[ ! -e $dkms_tree/$module/$module_version/build/patches/$p ]] && \
	    report_build_problem 5 \
	    $" Patch $p as specified in dkms.conf cannot be" \
	    $"found in $dkms_tree/$module/$module_version/build/patches/."
	invoke_command "patch -p1 < ./patches/$p" "applying patch $p" || \
	    report_build_problem 6 $"Application of patch $p failed." \
	    $"Check $dkms_tree/$module/$module_version/build/ for more information."
    done

    # Run the pre_build script
    run_build_script pre_build "$pre_build"
}

# Build our previously prepared source tree.  prepare_build must be called
# before calling this function.
do_build()
{
    local base_dir="$dkms_tree/$module/$module_version/$kernelver/$arch"
    echo $""
    echo $"Building module:"

    invoke_command "$clean" "cleaning build area" background
    echo $"DKMS make.log for $module-$module_version for kernel $kernelver ($arch)" >> "$dkms_tree/$module/$module_version/build/make.log"
    date >> "$dkms_tree/$module/$module_version/build/make.log"
    local the_make_command="${make_command/#make/make KERNELRELEASE=$kernelver}"

    invoke_command "{ $the_make_command; } >> $dkms_tree/$module/$module_version/build/make.log 2>&1" "$the_make_command" background || \
	report_build_problem 10 $"Bad return status for module build on kernel: $kernelver ($arch)" \
	$"Consult $dkms_tree/$module/$module_version/build/make.log for more information."

    # Make sure all the modules built successfully
    for ((count=0; count < ${#built_module_name[@]}; count++)); do
	[[ -e ${built_module_location[$count]}${built_module_name[$count]}$module_suffix ]] && continue
	report_build_problem 7 \
	    $" Build of ${built_module_name[$count]}$module_suffix failed for: $kernelver ($arch)" \
	    $"Consult the make.log in the build directory" \
	    $"$dkms_tree/$module/$module_version/build/ for more information."
    done
    cd - >/dev/null

    # Build success, so create DKMS structure for a built module
    mkdir -p "$base_dir/log"
    [[ $kernel_config ]] && cp -f "$kernel_config" "$base_dir/log/"
    mv -f "$dkms_tree/$module/$module_version/build/make.log" "$base_dir/log/make.log" 2>/dev/null

    # Save a copy of the new module
    mkdir "$base_dir/module" >/dev/null
    for ((count=0; count < ${#built_module_name[@]}; count++)); do
	[[ ${strip[$count]} != no ]] && strip -g "$dkms_tree/$module/$module_version/build/${built_module_location[$count]}${built_module_name[$count]}$module_suffix"
	cp -f "$dkms_tree/$module/$module_version/build/${built_module_location[$count]}${built_module_name[$count]}$module_suffix" "$base_dir/module/${dest_module_name[$count]}$module_suffix" >/dev/null
    done

    # Run the post_build script
    run_build_script post_build "$post_build"
}

# Clean up after a build.
clean_build()
{
    # Run the clean commands
    cd "$dkms_tree/$module/$module_version/build"
    invoke_command "$clean" "cleaning build area" background
    cd - >/dev/null

    if [[ ! ( $(VER $kernelver) < $(VER 2.6.6) ) && \
       -d $kernel_source_dir && \
       ! -h $kernel_source_dir && \
       ! $ksourcedir_fromcli ]]; then
	echo $"Kernel cleanup unnecessary for this kernel.  Skipping..."
    elif [[ ! $no_clean_kernel ]]; then
	cd "$kernel_source_dir"
	[[ $kerneldoth_contents ]] || invoke_command "make mrproper" "cleaning kernel tree (make mrproper)" background
	[[ $config_contents ]] || echo "$config_contents" > .config
	[[ $kerneldoth_contents ]] && echo "$kerneldoth_contents" > /boot/kernel.h
	cd - >/dev/null
    fi

    # Clean the build directory
    rm -rf "$dkms_tree/$module/$module_version/build/*"
}

build_module()
{
    prepare_build
    do_build
    clean_build
    echo $""
    echo $"DKMS: build completed."
}

# Install a previously built module
# There are huge swaths of code here that special-case for various distros.
# They should be split into their own functions.
install_module()
{
    # If the module has not been built, try to build it first.
    is_module_built "$module" "$module_version" "$kernelver" "$arch" || build_module
    local base_dir="$dkms_tree/$module/$module_version/$kernelver/$arch"
    check_module_args install

    # Make sure that kernel exists to install into
    [[ -e $install_tree/$kernelver ]] || die 6 \
	$"The directory $install_tree/$kernelver doesn't exist." \
	$"You cannot install a module onto a non-existant kernel."

    # Read the conf file
    read_conf_or_die "$kernelver" "$arch"

    # Check that its not already installed (kernel symlink)
    is_module_installed "$module" "$module_version" "$kernelver" "$arch" && die 5 \
	$"This module/version combo is already installed" \
	$"for kernel: $kernelver ($arch)"

    # if upgrading using rpm_safe_upgrade, go ahead and force the install
    # else we can wind up with the first half of an upgrade failing to install anything,
    # while the second half of the upgrade, the removal, then succeeds, leaving us with
    # nothing installed.
    [[ $rpm_safe_upgrade ]] && force="true"

    # Save the original_module if one exists, none have been saved before, and this is the first module for this kernel
    local lib_tree="$install_tree/$kernelver"
    local count
    for ((count=0; count < ${#built_module_name[@]}; count++)); do
	echo $""
	echo $"${dest_module_name[$count]}$module_suffix:"
	# Check this version against what is already in the kernel
	check_version_sanity "$kernelver" "$arch" \
	    "$obsolete_by" "${dest_module_name[$count]}" || continue

	if ((count == 0)) && ! run_build_script pre_install "$pre_install" && \
	    ! [[ $force ]]; then
	    die 101 $"pre_install failed, aborting install." \
		$"You may override by specifying --force."
	fi
	local module_count=$(find $lib_tree -name ${dest_module_name[$count]}$module_suffix -type f | wc -l | awk {'print $1'})
	echo $" - Original module"
	if [[ -L $dkms_tree/$module/kernel-$kernelver-$arch && \
	    -e $dkms_tree/$module/original_module/$kernelver/$arch/${dest_module_name[$count]}$module_suffix ]]; then
	    echo $"   - An original module was already stored during a previous install"
	elif ! [[ -L $dkms_tree/$module/kernel-$kernelver-$arch ]]; then
	    local archive_pref1="$lib_tree/extra/${dest_module_name[$count]}$module_suffix"
	    local archive_pref2="$lib_tree/updates/${dest_module_name[$count]}$module_suffix"
	    local archive_pref3="$lib_tree${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"
	    local archive_pref4=""
	    ((module_count == 1)) && archive_pref4=$(find $lib_tree -name ${dest_module_name[$count]}$module_suffix -type f)
	    local original_module=""
	    local found_orginal=""
	    for original_module in $archive_pref1 $archive_pref2 $archive_pref3 $archive_pref4; do
		[[ -f $original_module ]] || continue
		case "$running_distribution" in
		    Debian* | Ubuntu* ) ;;
		    *)
			echo $"   - Found $original_module"
			echo $"   - Storing in $dkms_tree/$module/original_module/$kernelver/$arch/"
			echo $"   - Archiving for uninstallation purposes"
			mkdir -p "$dkms_tree/$module/original_module/$kernelver/$arch"
			mv -f "$original_module" "$dkms_tree/$module/original_module/$kernelver/$arch/"
			;;
		esac
		found_original="yes"
		break
	    done
	    if [[ ! $found_original ]] && ((module_count > 1)); then
		echo $"   - Multiple original modules exist but DKMS does not know which to pick"
		echo $"   - Due to the confusion, none will be considered during a later uninstall"
	    elif [[ ! $found_original ]]; then
		echo $"   - No original module exists within this kernel"
	    fi
	else
	    echo $"   - This kernel never originally had a module by this name"
	fi

	if ((module_count > 1)); then
	    echo $" - Multiple same named modules!"
	    echo $"   - $module_count named ${dest_module_name[$count]}$module_suffix in $lib_tree/"
	    case "$running_distribution" in
		Debian* | Ubuntu* ) ;;
		*)
		    echo $"   - All instances of this module will now be stored for reference purposes ONLY"
		    echo $"   - Storing in $dkms_tree/$module/original_module/$kernelver/$arch/collisions/"
		    ;;
	    esac
	    for module_dup in $(find $lib_tree -name ${dest_module_name[$count]}$module_suffix -type f); do
		dup_tree="${module_dup#$lib_tree}";
		dup_tree="${dup_tree/${dest_module_name[$count]}$module_suffix}"
		case "$running_distribution" in
		Debian* | Ubuntu* ) ;;
		*)
		   echo $"     - Stored $module_dup"
		   mkdir -p "$dkms_tree/$module/original_module/$kernelver/$arch/collisions/$dup_tree"
		   mv -f $module_dup "$dkms_tree/$module/original_module/$kernelver/$arch/collisions/$dup_tree"
		   ;;
		esac
	    done
	fi

	# Copy module to its location
	echo $" - Installation"
	echo $"   - Installing to $install_tree/$kernelver${dest_module_location[$count]}/"
	mkdir -p $install_tree/$kernelver${dest_module_location[$count]}
	cp -f "$base_dir/module/${dest_module_name[$count]}$module_suffix" "$install_tree/$kernelver${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"

    done

    # Create the kernel-<kernelver> symlink to designate this version as active
    rm -f "$dkms_tree/$module/kernel-$kernelver-$arch" 2>/dev/null
    ln -s "$module_version/$kernelver/$arch" "$dkms_tree/$module/kernel-$kernelver-$arch" 2>/dev/null

    # add to kabi-tracking
    if [[ ${weak_modules} ]]; then
	echo $"Adding any weak-modules"
	list_each_installed_module "$module" "$kernelver" "$arch" | ${weak_modules} --add-modules
    fi

    # Run the post_install script
    run_build_script post_install "$post_install"

    # Make modules.conf changes as necessary
    echo $""
    moduleconfig_add "$kernelver"
    etc_sysconfig_kernel_modify "add"

    invoke_command "do_depmod $kernelver" "depmod" background || {
	do_uninstall "$kernelver" "$arch"
	die 6 $"Problems with depmod detected.  Automatically uninstalling this module." \
	    $"DKMS: Install Failed (depmod problems).  Module rolled back to built state."
	    exit 6
    }

    # Do remake_initrd things (save old initrd)
    [[ $remake_initrd ]] && ! make_initrd "$kernelver" "$arch" && {
	do_uninstall "$kernelver" "$arch"
	die 7 $"Problems with mkinitrd detected.  Automatically uninstalling this module." \
	    $"DKMS: Install Failed (mkinitrd problems).  Module rolled back to built state."
    }
    echo $""
    echo $"DKMS: install completed."
}

# List each kernel object that has been installed for a particular module.
list_each_installed_module()
{
    # $1 = module
    # $2 = kernel version
    # $3 = arch
    local count
    local real_dest_module_location
    for ((count=0; count < ${#built_module_name[@]}; count++)); do
	real_dest_module_location="$(find_actual_dest_module_location $1 $count $2 $3)"
	echo "$install_tree/$2${real_dest_module_location}/${dest_module_name[$count]}$module_suffix"
    done
}

is_module_added() {
    [[ $1 && $2 ]] || return 1
    [[ -d $dkms_tree/$1/$2 ]] || return 2
    [[ -L $dkms_tree/$1/$2/source || -d $dkms_tree/$1/$2/source ]];
}

is_module_built() {
    [[ $1 && $2 && $3 && $4 ]] || return 1
    local d="$dkms_tree/$1/$2/$3/$4" m=''
    [[ -d $d/module ]] || return 1
    read_conf_or_die "$3" "$4" "$dkms_tree/$1/$2/source/dkms.conf"
    for m in "${dest_module_name[@]}"; do
	[[ -f $d/module/$m.ko || -f $d/module/$m.o ]] || return 1
    done
}

# This assumes we have already checked to see if the module has been built.
_is_module_installed() {
    [[ $1 && $2 && $3 && $4 ]] || return 1
    local d="$dkms_tree/$1/$2/$3/$4"
    local k="$dkms_tree/$1/kernel-$3-$4"
    [[ -L $k && $(readlink -f $k) = $d ]]
}

# This does not.
is_module_installed() { is_module_built "$@" && _is_module_installed "$@"; }

maybe_add_module() (
    is_module_added "$1" "$2" && {
	echo $"Module $1/$2 already added."
	return 0
    }
    module="$1" module_version="$2" add_module
)

maybe_build_module() (
    is_module_built "$1" "$2" "$3" "$4" && {
	echo $"Module $1/$2 already built for kernel $3/4"
	return 0
    }
    module="$1" module_version="$2" kernelver="$3" arch="$4" build_module
)

maybe_install_module() (
    is_module_installed "$1" "$2" "$3" "$4" && {
	echo $"Module $1/$2 already installed on kernel $3/$4"
	return 0
    }
    module="$1" module_version="$2" kernelver="$3" arch="$4" install_module
)

build_modules() {
    local i=0
    for ((i=0; i < ${#kernelver[@]}; i++)); do
	maybe_build_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}"
    done
}

install_modules() {
    local i=0
    for ((i=0; i < ${#kernelver[@]}; i++)); do
	maybe_install_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}"
    done
}

check_module_exists() {
    is_module_added "$module" "$module_version" && return
    die 2 $"DKMS tree does not contain: $module-$module_version" \
	$"Build cannot continue without the proper tree."
}

possible_dest_module_locations()
{
    # $1 = count
    # There are two places an installed module may really be:
    # 1) "$install_tree/$kernelver/${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"
    # 2) "$install_tree/$kernelver/${DEST_MODULE_LOCATION[$count]}/${dest_module_name[$count]}$module_suffix"
    # override_dest_module_location() is what controls whether or not they're the same.

    local location
    location[0]="${dest_module_location[$count]}"
    [[ ${DEST_MODULE_LOCATION[$count]} != ${dest_module_location[$count]} ]] && \
    location[1]="${DEST_MODULE_LOCATION[$count]}"

    echo "${location[@]}"
}

find_actual_dest_module_location()
{
    local module="$1"
    local count="$2"
    local kernelver="$3"
    local arch="$4"
    local locations="$(possible_dest_module_locations $count)"
    local l
    local dkms_owned
    local installed
    dkms_owned="${dkms_tree}/${module}/kernel-${kernelver}-${arch}/module/${dest_module_name[$count]}${module_suffix}"

    for l in $locations; do
	installed="${install_tree}/${kernelver}${l}/${dest_module_name[${count}]}${module_suffix}"
	if [[ -f ${installed} ]] && diff "${dkms_owned}" "${installed}" > /dev/null 2>&1; then
	    echo "${l}"
	    return 0
	fi
    done

}

# Remove compiled DKMS modules from any kernels they are installed in.
do_uninstall()
{
    # $1 = kernel version
    # $2 = arch

    echo $""
    echo $"-------- Uninstall Beginning --------"
    echo $"Module:  $module"
    echo $"Version: $module_version"
    echo $"Kernel:  $1 ($2)"
    echo $"-------------------------------------"

    set_module_suffix "$1"

    # If kernel-<kernelver> symlink points to this module, check for original_module and put it back
    local was_active=""
    local kernel_symlink=$(readlink -f "$dkms_tree/$module/kernel-$1-$2")
    local real_dest_module_location
    if [[ $kernel_symlink = $dkms_tree/$module/$module_version/$1/$2 ]]; then
	was_active="true"
	echo $""
	echo $"Status: Before uninstall, this module version was ACTIVE on this kernel."
	# remove kabi-tracking if last instance removed
	if [[ ${weak_modules} ]] && \
	    (module_status_built $module $module_version |grep -q "installed"); then
	    echo $"Removing any linked weak-modules"
	    list_each_installed_module "$module" "$1" "$2" | ${weak_modules} --remove-modules
	fi

	for ((count=0; count < ${#built_module_name[@]}; count++)); do
	    real_dest_module_location="$(find_actual_dest_module_location $module $count $1 $2)"
	    echo $""
	    echo $"${dest_module_name[$count]}$module_suffix:"
	    echo $" - Uninstallation"
	    echo $"   - Deleting from: $install_tree/$1${real_dest_module_location}/"
	    rm -f "$install_tree/$1${real_dest_module_location}/${dest_module_name[$count]}$module_suffix"
	    dir_to_remove="${real_dest_module_location#/}"
	    while [ "${dir_to_remove}" != "${dir_to_remove#/}" ]; do dir_to_remove="${dir_to_remove#/}" ; done
	    (cd "$install_tree/$1" && rmdir --parents --ignore-fail-on-non-empty "${dir_to_remove}" || true)
	    echo $" - Original module"
	    if [[ -e $dkms_tree/$module/original_module/$1/$2/${dest_module_name[$count]}$module_suffix ]]; then
		case "$running_distribution" in
		Debian* | Ubuntu* ) ;;
		*)
		    echo $"   - Archived original module found in the DKMS tree"
		    echo $"   - Moving it to: $install_tree/$1${DEST_MODULE_LOCATION[$count]}/"
		    mkdir -p "$install_tree/$1${DEST_MODULE_LOCATION[$count]}/"
		    mv -f "$dkms_tree/$module/original_module/$1/$2/${dest_module_name[$count]}$module_suffix" \
			"$install_tree/$1${DEST_MODULE_LOCATION[$count]}/" 2>/dev/null
		    ;;
		esac
	    else
		echo $"   - No original module was found for this module on this kernel."
		echo $"   - Use the dkms install command to reinstall any previous module version."

		# Remove modules_conf entries from /etc/modules.conf if remake_initrd is set or if this is last instance removed
		if [[ $remake_initrd ]] || \
		    (do_status $module $module_version | grep -q "installed"); then
		    echo $""
		    moduleconfig_remove "$1"
		fi
	    fi
	done
	rm -f "$dkms_tree/$module/kernel-$1-$2"
    else
	echo $""
	echo $"Status: This module version was INACTIVE for this kernel."
    fi

    # Run the post_remove script
    run_build_script post_remove "$post_remove"

    # Run depmod because we changed /lib/modules
    invoke_command "do_depmod $1" "depmod" background

    # Do remake_initrd things (remake initrd)
    if [[ $remake_initrd && $was_active ]] && ! make_initrd "$1" "$2"; then
	warn $"There was a problem remaking your initrd.  You must manually remake it" \
	    $"before booting into this kernel."
    fi

    # Delete the original_module if nothing for this kernel is installed anymore
    if [[ $was_active && -d $dkms_tree/$module/original_module/$1/$2 && \
	! -d $dkms_tree/$module/original_module/$1/$2/collisions ]]; then
	echo $""
	echo $"Removing original_module from DKMS tree for kernel $1 ($2)"
	rm -rf "$dkms_tree/$module/original_module/$1/$2" 2>/dev/null
	[[ $(find $dkms_tree/$module/original_module/$1/* -maxdepth 0 -type d 2>/dev/null) ]] || rm -rf "$dkms_tree/$module/original_module/$1"
    elif [[ $was_active && -d $dkms_tree/$module/original_module/$1/$2/collisions ]]; then
	echo $""
	echo $"Keeping directory $dkms_tree/$module/original_module/$1/$2/collisions/"
	echo $"for your reference purposes.  Your kernel originally contained multiple"
	echo $"same-named modules and this directory is now where these are located."
    fi
    [[ $(find $dkms_tree/$module/original_module/* -maxdepth 0 -type d 2>/dev/null) ]] || rm -rf "$dkms_tree/$module/original_module"

    # Re-add entries to modules.conf if this module/version is still installed on another kernel
    # But only do this if it was just ACTIVE on the kernel we just uninstalled from
    [[ $was_active && $remake_initrd ]] && do_status $module $module_version | grep -q "installed" && moduleconfig_add "$1"

    echo $""
    echo $"DKMS: uninstall completed."
}

# Check our preconditions, and then let do_install do all the hard work.
uninstall_module()
{
    # Check that the right arguments were passed
    check_module_args uninstall

    # Check that $module is in the dkms tree
    [[ -d $dkms_tree/$module ]] || die 2 \
	$"There are no instances of module: $module" \
	$"located in the DKMS tree."

    # Make sure that its installed in the first place
    [[ -d $dkms_tree/$module/$module_version ]] || die 3 \
	$"The module/version combo: $module-$module_version" \
	$"is not located in the DKMS tree."

    # Read the conf file
    read_conf_or_die "$kernelver" "$arch"

    # Only do stuff if module/module version is currently installed
    local kernel_symlink=$(readlink -f "$dkms_tree/$module/kernel-$kernelver-$arch")
    [[ $kernel_symlink = $dkms_tree/$module/$module_version/$kernelver/$arch ]] || die 5 \
	    $"The module $module $module_version is not currently installed." \
	    $"This module is not currently ACTIVE for kernel $kernelver ($arch)."
    do_uninstall "$kernelver" "$arch"
}

# Unregister a DKMS module.  This uninstalls any installed modules along the way.
remove_module()
{
    # Check that the right arguments were passed
    if [[ ! ($module && $module_version) || $kernels_arches_default  ]]; then
	die 1 $"Invalid number of parameters passed." \
	    $"Usage: remove <module>/<module-version> --all" \
	    $"   or: remove <module>/<module-version> -k <kernel-version>"
    fi

    # Check that $module is in the dkms tree
    if ! [[ -d $dkms_tree/$module/$module_version ]]; then
	die 3 $"There are no instances of module: $module" \
	    $"$module_version located in the DKMS tree."
    fi

    local i
    for ((i=0; i < ${#kernelver[@]}; i++)); do
	# make sure its there first before removing
	if ! [[ -d $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]} ]]; then
	    die 4 $"There is no instance of $module $module_version" \
		$"for kernel ${kernelver[$i]} (${arch[$i]}) located in the DKMS tree."
	fi

	# Do --rpm_safe_upgrade check (exit out and don't do remove if inter-release RPM upgrade scenario occurs)
	if [[ $rpm_safe_upgrade ]]; then
	    local pppid=$(awk '/PPid:/ {print $2}' /proc/$PPID/status)
	    local time_stamp=$(ps -o lstart --no-headers -p $pppid 2>/dev/null)
	    for lock_file in $tmp_location/dkms_rpm_safe_upgrade_lock.$pppid.*; do
		[[ -f $lock_file ]] || continue
		lock_head=$(head -n 1 $lock_file 2>/dev/null)
		lock_tail=$(tail -n 1 $lock_file 2>/dev/null)
		[[ $lock_head = $module-$module_version && $time_stamp && $lock_tail = $time_stamp ]] || continue
		rm -f $lock_file
		die 0 $"DKMS: Remove cancelled because --rpm_safe_upgrade scenario detected."
	    done
	fi

	# Read the conf file
	read_conf_or_die "${kernelver[$i]}" "${arch[$i]}"

	do_uninstall "${kernelver[$i]}" "${arch[$i]}"

	# Delete the $kernel_version/$arch_used part of the tree
	rm -rf "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}"
	[[ $(find $dkms_tree/$module/$module_version/${kernelver[$i]}/* \
	    -maxdepth 0 -type d 2>/dev/null) ]] || \
	    rm -rf "$dkms_tree/$module/$module_version/${kernelver[$i]}"
    done

    # Delete the $module_version part of the tree if no other $module_version/$kernel_version dirs exist
    if ! find $dkms_tree/$module/$module_version/* -maxdepth 0 -type d 2>/dev/null | egrep -qv "(build|tarball|driver_disk|rpm|deb|source)$"; then
	echo $""
	echo $"------------------------------"
	echo $"Deleting module version: $module_version"
	echo $"completely from the DKMS tree."
	echo $"------------------------------"
	rm -rf "$dkms_tree/$module/$module_version"
	echo $"Done."
    fi

    # Get rid of any remnant directories if necessary
    if (($(ls "$dkms_tree/$module" | wc -w | awk '{print $1}') == 0)); then
	rm -rf "$dkms_tree/$module" 2>/dev/null

	# Its now safe to completely remove references in /etc/sysconfig/kernel for SuSE
	etc_sysconfig_kernel_modify "delete"
    fi
}

# Given a kernel object, figure out which DKMS module it is from.
find_module_from_ko()
{
    local ko="$1"
    local basename_ko="${ko##*/}"
    local module
    local kernellink

    for kernellink in "$dkms_tree"/*/kernel-*; do
	[[ -L $kernellink ]] || continue
	module=${kernellink#$dkms_tree/}
	module=${module%/kernel-*}
	diff "$kernellink/module/${basename_ko}" "${ko}" >/dev/null 2>&1 || continue
	rest=$(readlink $kernellink)
	echo "$module/$rest"
	return 0
    done
    return 1
}

# Check to see if modules meeting the passed parameters are weak-installed.
# This function's calling convention is different from the usual DKMS status
# checking functions -- the kernel version we usually have is the one we are currently
# running on, not necessarily the one we compiled the module for.
module_status_weak() {
    # $1 = module, $2 = module version, $3 = kernel version weak installed to,
    # $4 = kernel arch, $5 = kernel version built for
    [[ $weak_modules ]] || return 1
    local weak_ko mod installed_ko f ret=1 oifs=$IFS
    local -a already_found
    for weak_ko in "$install_tree/"*/weak-updates/*; do
	[[ -e $weak_ko ]] || continue
	[[ -L $weak_ko ]] && installed_ko="$(readlink -f "$weak_ko")" || continue
	IFS=/ read m v k a < <(IFS=$oifs find_module_from_ko "$weak_ko") || continue
	kern=${weak_ko#$install_tree/}
	kern=${kern%/weak-updates/*}
	[[ $m = ${1:-*} && $v = ${2:-*} && $k = ${5:-*} && \
	    $a = ${4:-*} && $kern = ${3:-*} ]] || \
	    continue
	ret=0
	for f in "${already_found[@]}"; do
	    [[ $f = $m/$v/$kern/$a/$k ]] && continue 2
	done
	already_found[${#already_found[@]}]="$m/$v/$kern/$a/$k"
	echo "installed-weak $m/$v/$kern/$a/$k"
    done
    return $ret
}

# Print the requested status lines for weak-installed modules.
do_status_weak()
{
    local mvka m v k a kern status
    while read status mvka; do
	IFS=/ read m v k a kern <<< "$mvka"
	echo "$m, $v, $k, $a: installed-weak from $kern"
    done < <(module_status_weak "$@")
}

# Spit out all the extra status information that people running DKMS are
# interested in, but that the DKMS internals do not usually care about.
module_status_built_extra() (
    set_module_suffix "$3"
    read_conf "$3" "$4" "$dkms_tree/$1/$2/source/dkms.conf"
    [[ -d $dkms_tree/$1/original_module/$3/$4 ]] && echo -n " (original_module exists)"
    for ((count=0; count < ${#dest_module_name[@]}; count++)); do
	tree_mod="$dkms_tree/$1/$2/$3/$4/module/${dest_module_name[$count]}$module_suffix"
	if ! [[ -e $tree_mod ]]; then
	    echo -n " (WARNING! Missing some built modules!)"
	elif _is_module_installed "$@"; then
	    real_dest="$(find_actual_dest_module_location "$1" $count "$3" "$4")"
	    if ! diff -q "$tree_mod" "$install_tree/$3${real_dest}/${dest_module_name[$count]}$module_suffix" >/dev/null 2>&1; then
		echo -n " (WARNING! Diff between built and installed module!)"
	    fi
	fi
    done
)

# Return a list of all the modules that are either built or installed.
# This and module_status do some juggling of $IFS to ensure that
# we do not get word splitting where it would be inconvienent.
module_status_built() {
    local ret=1 directory ka k a state oifs="$IFS" IFS=''
    for directory in "$dkms_tree/$1/$2/"${3:-+([0-9]).*}/${4:-*}; do
	IFS="$oifs"
	ka="${directory#$dkms_tree/$1/$2/}"
	k="${ka%/*}"
	a="${ka#*/}"
	is_module_built "$1" "$2" "$k" "$a" || continue
	ret=0
	state="built"
	_is_module_installed "$1" "$2" "$k" "$a" && \
	    state="installed"
	echo "$state $1/$2/$k/$a"
	IFS=''
    done
    IFS="$oifs"
    return $ret
}

# Return the status of all modules that have been added, built, or installed.
module_status() {
    local oifs="$IFS" IFS='' mv m v directory ret=1
    for directory in "$dkms_tree/"${1:-*}/${2:-*}; do
	IFS="$oifs"
	mv="${directory#$dkms_tree/}"
	m="${mv%/*}"
	v="${mv#*/}"
	is_module_added "$m" "$v" || continue
	ret=0
	module_status_built "$m" "$v" "$3" "$4" || echo "added $m/$v"
	IFS=''
    done
    IFS="$oifs"
    return $ret
}

# Print out the status in the format that people who call DKMS expect.
# Internal callers should use the module_status functions, as their output
# is easier to parse.
do_status() {
    local status mvka m v k a
    while read status mvka; do
	IFS=/ read m v k a <<< "$mvka"
	case $status in
	    added) echo "$m, $v: $status";;
	    built|installed) echo -n "$m, $v, $k, $a: $status"
		module_status_built_extra "$m" "$v" "$k" "$a"
		echo;;
	esac
    done < <(module_status "$@")
}

# Show all our status in the format that external callers expect, even
# though it is slightly harder to parse.
show_status()
{
    local j state_array
    if ((${#kernelver[@]} == 0)); then
	do_status "$module" "$module_version" "$kernelver" "$arch"
	do_status_weak "$module" "$module_version" "$kernelver" "$arch"
    else
	for ((j=0; j < ${#kernelver[@]}; j++)); do
	    do_status "$module" "$module_version" "${kernelver[$j]}" "${arch[$j]}"
	    do_status_weak "$module" "$module_version" "${kernelver[$j]}" "${arch[$j]}"
	done
    fi
}

create_temporary_trees()
{
    [[ $module || $module_version || ! -r dkms.conf ]] && return 0

    . dkms.conf
    module="$PACKAGE_NAME"
    module_version="$PACKAGE_VERSION"

    source_tree=$(mktemp_or_die -d)
    dkms_tree=$(mktemp_or_die -d)

    local source_tree_dir="$source_tree/$PACKAGE_NAME-$PACKAGE_VERSION"
    mkdir -p "$source_tree_dir"
    cp -a * "$source_tree_dir" # intentionally skip .git or .hg
    add_module
    temporary_trees_del_command="rm -rf $source_tree $dkms_tree"
}

delete_temporary_trees()
{
    [[ $temporary_trees_del_command ]] || return 0
    $temporary_trees_del_command
    module=
    module_version=
    source_tree=
    dkms_tree=
    temporary_trees_del_command=
}

in_temporary_trees() { [[ $temporary_trees_del_command ]] ;}

media_valid()
{
    local mrx='^(floppy|iso|tar)$'
    [[ $media =~ $mrx ]]
}

make_driver_disk_floppy()
{
    local image_name="$1"
    local source_dir="$2"
    local file
    local fs='ext2'
    [[ $distro = redhat* ]] && fs='vfat'

    rm -f "$image_name"
    invoke_command "dd if=/dev/zero of=$image_name bs=$(($size/20))k count=20" "making a blank floppy image" background
    case $fs in
	vfat) invoke_command "mkdosfs $image_name" "mkdosfs" background;;
	ext2) invoke_command "mke2fs -F $image_name" "mke2fs" background;;
    esac

    local mntdir=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
    invoke_command "mount -o loop -t $fs $image_name $mntdir >/dev/null 2>&1" "loopback mounting disk image"
    [[ -d $mntdir/lost+found ]] && rmdir "$mntdir/lost+found"
    invoke_command "cp -r $source_dir/* $mntdir/" "  copying files to floppy disk image"
    invoke_command "umount $mntdir" "unmounting disk image"
    rm -rf "$mntdir"
}

make_driver_disk_isotar()
{
    local type="$1"
    local image_name="$2"
    local source_dir="$3"
    local file
    case $type in
	iso) invoke_command "mkisofs -v -r -J -pad -V $module -o $image_name ." "mkisofs" background;;
	tar) invoke_command "tar cvf $image_name ." "tar" background;;
    esac
}

make_driver_disk_media()
{
    echo "Copying files $2"

    case $media in
	floppy*) make_driver_disk_floppy "$1" "$2";;
	iso*) make_driver_disk_isotar "iso" "$1" "$2";;
	tar*) make_driver_disk_isotar "tar" "$1" "$2";;
    esac
}

driver_disk_suffix()
{
    case $media in
	floppy*) echo "img";;
	iso*) echo "iso";;
	tar*) echo "tar";;
    esac
}

make_redhat_driver_disk()
{
    local i count
    # kludge to allow redhat1 driver disks with BOOT kernel modules (arch i386)
    if [[ $distro = redhat1 && $multi_arch = true ]]; then
	local redhat1_okay="true"
	local other_arch=""
	for ((i=0; i < ${#kernelver[@]}; i++)); do
	    if [[ ${arch[$i]} != i386 && $other_arch != ${arch[$i]} && $other_arch ]]; then
		die 3 $"You have specified a Red Hat version 1 driver disk, but have also" \
		    $"specified multiple architectures.  Version 1 does not support this." \
		    $"Use 'redhat2' instead (only OSes >= RHEL3, FC1 support version 2)."
	    elif [[ ${arch[$i]} != i386 && $other_arch != ${arch[$i]} && ! $other_arch ]]; then
		other_arch="${arch[$i]}"
	    fi
	done
    fi
    if [ "$distro" == "redhat2" ]  && [ -z "$redhat1_okay" ]; then
	echo $"Creating Red Hat v2 driver disk (arch support)."
	echo $""
	local rhdd_filename="rhdd"
    elif [ "$distro" == "redhat3" ] && [ -z "$redhat1_okay" ]; then
        echo $"Creating Red Hat v3 driver disk."
	echo $""
	make_redhat3_driver_disk
	return
    else
	echo $"Creating Red Hat v1 driver disk."
	echo $""
	local rhdd_filename="rhdd-6.1"
    fi

    cpioarchive_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)

    for ((i=0; i < ${#kernelver[@]}; i++)); do
	set_module_suffix "${kernelver[$i]}"

	local dd_prefix="${kernelver[$i]}"
	[[ $distro = redhat2 ]] && dd_prefix="${kernelver[$i]}/${arch[$i]}"
	[[ $multi_arch = true && -z $redhat1_okay ]] && dd_prefix="${kernelver[$i]}/${arch[$i]}"
	maybe_build_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}" || {
	    rm -rf "$cpioarchive_dir_name"
	    die 5 $"Cannot build $module/$module_version for redhat driver disk."
	}
	
	# FIXME: add check for KMP binary RPMs to include in the driver disk
	if [[ ! $kernel_version_list ]]; then
	    kernel_version_list="kernel${kernelver[$i]}-${arch[$i]}"
	else
	    kernel_version_list="$kernel_version_list-kernel${kernelver[$i]}-${arch[$i]}"
	fi
	mkdir -p $cpioarchive_dir_name/$dd_prefix
	for f in "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/"*"$module_suffix"; do
	    [[ -f $f ]] || continue
	    echo "Marking ${f#$dkms_tree/$module/$module_version/}..."
	    cp "$f" "$cpioarchive_dir_name/$dd_prefix/"
	    modules_cgz_list="$dd_prefix/${f##*/} ${modules_cgz_list}"
	done

    done

    # Create directory and necessary files
    driver_disk_dir=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)

    # Copy files for the driver disk (or warn if not present)
    local files_for_driverdisk="modinfo disk-info modules.dep pcitable modules.pcimap pci.ids"
    # Fedora Core 5 and higher, RHEL5 and higher, strictly require: rhdd, modules.cgz, modinfo, modules.alias, modules.dep
    # which is in effect ignoring disk-info, pcitable, modules.pcimap and pci.ids
    # and adding modules.alias, which will be generated.

    local files_into_driverdisk="modules.cgz $rhdd_filename modules.alias"
    for file in $files_for_driverdisk; do
	if [[ -e $dkms_tree/$module/$module_version/source/redhat_driver_disk/$file ]]; then
	    files_into_driverdisk="$file $files_into_driverdisk"
	    cp -f "$dkms_tree/$module/$module_version/source/redhat_driver_disk/$file" "$driver_disk_dir/" 2>/dev/null
	else
	    warn $"File: $file not found in $dkms_tree/$module/$module_version/source/redhat_driver_disk/"
	fi
    done
    echo "$module-$module_version driver disk" > "$driver_disk_dir/$rhdd_filename"

    # Make sure the kernel_version_list is not too long
    if (( $(echo $kernel_version_list | wc -m | awk {'print $1'}) > 200 )); then
	kernel_version_list="manykernels"
    fi

    local suffix="$(driver_disk_suffix)"
    local image_dir="$dkms_tree/$module/$module_version/driver_disk"
    local image_name="$module-$module_version-$kernel_version_list-dd.$suffix"
    echo $""
    echo $"Creating driver disk on $media media:"
    cd "$cpioarchive_dir_name"
    invoke_command "echo '$modules_cgz_list' | cpio -oH crc 2>/dev/null | gzip -9 > ./modules.cgz" "compressing modules.cgz" background
    cp -f ./modules.cgz "$driver_disk_dir/"

    # generate modules.alias file
    # On 2.4 kernels and kernels with no aliases. this won't yield anything.
    touch ./modules.alias
    for f in ${modules_cgz_list}; do
	module_wo_suffix=$(basename ${f} ${module_suffix})
	tmp_alias="./modules.alias.${module_wo_suffix}"
	f="./${f}"
	depmod -n ${f} 2>/dev/null | grep ^alias > ${tmp_alias}
	if [[ -s ${tmp_alias} ]]; then
	    cat "${tmp_alias}" >> ./modules.alias
	fi
    done
    [[ -e ./modules.alias ]] && cp -f ./modules.alias "$driver_disk_dir/"
    # FIXME: add rpms/ directory, copy in KMP RPMs, run createrepo --pretty

    cd - >/dev/null
    rm -rf "$cpioarchive_dir_name"

    mkdir -p "$image_dir"
    rm -f "$image_dir/$image_name"

    cd "$driver_disk_dir"
    make_driver_disk_media "$image_dir/$image_name" "$driver_disk_dir"
    cd - >/dev/null
    rm -rf "$driver_disk_dir"

    echo $""
    echo $"Disk image location: $image_dir/$image_name"
    echo $""
    echo $"DKMS: mkdriverdisk completed."
}

make_driver_disk()
{
    # Check that the right arguments were passed
    if ! [[ $module && $module_version && $distro && $kernelver ]]; then
	die 1 $"Invalid number of parameters passed." \
	$"Usage: mkdriverdisk <module>/<module-version> -d <distro> -k <kernelver> [--media floppy|iso|tar]"
    fi

    # default to floppy media
    [[ $media ]] || media="floppy"
    if ! media_valid; then
	die 1 $"Media $media is invalid." \
	    $"Usage: mkdriverdisk <module>/<module-version> -d <distro> -k <kernelver> [--media floppy|iso|tar]"
    fi

    # Check that source symlink works
    check_module_exists

    # Confirm that distro is supported
    case $distro in
	redhat | redhat[123] | suse | UnitedLinux | ubuntu) ;;
	*) die 3 $"Invalid distro argument. Currently, the distros" \
		$"supported are: redhat, redhat1, redhat2, redhat3, suse, UnitedLinux" \
		$"               ubuntu";;
    esac

    # Read the conf file
    read_conf_or_die "$kernelver" "$arch"

    case $distro in
	redhat*) make_redhat_driver_disk;;
	ubuntu) make_ubuntu_driver_disk;;
	*) make_suse_driver_disk;;
    esac
}

find_external_dependencies()
{
    local mod count i
    local -a deps

    # find all module dependencies
    for ((count=0; count < ${#dest_module_name[@]}; count++)); do
	for ((i=0; i < ${#kernelver[@]}; i++)); do
	    set_module_suffix "${kernelver[$i]}"
	    mod="$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix"
	    deps=(${deps[@]} $(modinfo "$mod" | sed -n 's/,/ /g; s/^depends: *//p'))
	done
    done

    # prune internally satisfied dependencies

    for ((i=0; i < ${#deps[@]}; i++)); do
	for mod in ${dest_module_name[@]}; do
	    [[ ${deps[i]} = $mod ]] && deps[i]=
	done
    done

    for dep in "${deps[@]}"; do
	echo $dep
    done | sort -u
}

make_suse_driver_disk()
{
    [[ $release ]] || die 3 \
	$"Invalid number of parameters passed for suse/UnitedLinux driver disk." \
	$"Usage: mkdriverdisk <module>/<module-version> -d <distro> -k <kernelver>" \
	$"                    -r <release-number>"

    local driver_disk_dir=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
    local suffix="$(driver_disk_suffix)"
    local image_dir="$dkms_tree/$module/$module_version/driver_disk"
    local image_name="$module-$module_version-$distro-$release-dd.$suffix"

    echo $""
    echo $"Creating driver disk:"

    local deps="$(find_external_dependencies)"

    local offset=0
    # reserve a place for dependencies
    [[ ${deps[@]} ]] && offset=1
    
    local count
    for ((count=0; count < ${#dest_module_name[@]}; count++)); do
	local i
	local topdir=$(printf "%02d" $(($count+1+offset)))
	for ((i=0; i < ${#kernelver[@]}; i++)); do
	    set_module_suffix "${kernelver[$i]}"

	    if ! [[ -e $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix ]]; then
		rm -rf $temp_dir_name
		die 5 \
		    $"Cannot find module ${dest_module_name[$count]}$module_suffix for kernel ${kernelver[$i]} (${arch[$i]})." \
		    $"Module/version must be in built state before making a driver disk."
	    fi
	    # FIXME: add check for KMP binary RPMs to include in the driver disk
	    suse_arch=${arch[$i]}
	    case $suse_arch in
		i?86) suse_arch=i386;;
	    esac

	    echo "Marking ${kernelver[$i]}/${arch[$i]}/modules/${dest_module_name[$count]}$module_suffix..."
	    mkdir -p "$driver_disk_dir/$topdir/$suse_arch-$release/install/lib/modules/${kernelver[$i]}${dest_module_location[$count]}"
	    cp "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix" "$driver_disk_dir/$topdir/$suse_arch-$release/install/lib/modules/${kernelver[$i]}${dest_module_location[$count]}/"

	    case ${kernelver[$i]} in
		*-default)
		    mkdir -p "$driver_disk_dir/$topdir/$suse_arch-$release/modules/"
		    cp "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix" "$driver_disk_dir/$topdir/$suse_arch-$release/modules/"
		    ;;
	    esac

	    # create directory for dependency information
	    [[ ${deps[@]} ]] && mkdir -p "$driver_disk_dir/01/linux/$distro/$suse_arch-$release/modules"

	done

	# ---
	for arch_release in $(find $driver_disk_dir/$topdir -maxdepth 1 -mindepth 1 -type d | sed "s#$driver_disk_dir\/$topdir\/##"); do
	    cd "$driver_disk_dir/$topdir/$arch_release/install/"
	    invoke_command "tar cvzf update.tar.gz lib/" "making update.tar.gz for $arch_release" background
	    cd - >/dev/null

	    mkdir -p "$driver_disk_dir/$topdir/linux/$distro/$arch_release/install"
	    mkdir -p "$driver_disk_dir/$topdir/linux/$distro/$arch_release/modules"

	    echo $"  copying update.tar.gz for $arch_release to disk image..."
	    cp -f "$driver_disk_dir/$topdir/$arch_release/install/update.tar.gz" "$driver_disk_dir/$topdir/linux/$distro/$arch_release/install/"

	    postkernels=
	    archtest=${arch_release/-*}
	    for ((i=0; i<${#kernelver[@]}; i++)); do
		[[ ${arch[$i]} = ${archtest} ]] && \
		    postkernels="${postkernels} ${kernelver[$i]}"
	    done

	    if [[ ${postkernels} ]]; then
		dstfile="$driver_disk_dir/$topdir/linux/$distro/$arch_release/install/update.post"
		echo $"  creating update.post for $arch_release..."
		(cat << EOF
#!/bin/sh

kernlist="${postkernels}"

for kernel in \${kernlist}; do
    if [ -e /boot/System.map-\${kernel} ]; then
	depmod -a -F /boot/System.map-\${kernel} \${kernel}
    fi
done

EOF
		) > ${dstfile}
		chmod a+x ${dstfile}
	    fi

	    if [[ -d $driver_disk_dir/$topdir/$arch_release/modules/ ]]; then
		echo $"  copying kernel modules for installation kernel to disk image..."
		cp -f $driver_disk_dir/$topdir/$arch_release/modules/* $driver_disk_dir/$topdir/linux/$distro/$arch_release/modules/ 2>/dev/null
	    else
		warn $"No kernel modules found for -default kernel."
	    fi

	    rm -fr "$driver_disk_dir/$topdir/$arch_release"
	done
    done

    local dir
    if [[ ${deps[@]} ]]; then
	for dir in "$driver_disk_dir/01/linux/$distro/"*"/modules"; do
	    for dep in "${deps[@]}"; do
		echo $dep >> "$dir/module.order"
	    done
	done
    fi

    # FIXME: add suse-equivalent rpms/ directory, copy in KMP RPMs, run createrepo --pretty

    mkdir -p "$image_dir"
    rm -f "$image_dir/$image_name"
    cd "$driver_disk_dir"
    make_driver_disk_media "$image_dir/$image_name" "$driver_disk_dir"
    cd - >/dev/null
    rm -rf "$driver_disk_dir"

    echo $""
    echo $"Disk image location: $dkms_tree/$module/$module_version/driver_disk/$image_name"
    echo $""
    echo $"DKMS: mkdriverdisk completed."
}

make_ubuntu_driver_disk()
{
    local suffix="$(driver_disk_suffix)"
    local image_dir="$dkms_tree/$module/$module_version/driver_disk"
    local image_name="$module-$module_version-$distro-dd.$suffix"

    local tempdir=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)

   # Check that the dh_make command is present
   if ! which dpkg-deb >/dev/null 2>&1 ; then
	die 1 $"dpkg-deb not present." \
	    $"Install the dpkg-dev package."
   fi

   local i
   for ((i=0; i < ${#kernelver[@]}; i++)); do
      set_module_suffix "${kernelver[$i]}"
      # Driver disks only recognize i386 as package arch
      local karch=${arch[$i]/i?86/i386}
      local kvers=${kernelver[$i]/-/_}; kvers=${kvers%%_*}
       # ubuntu-drivers/<kver>/*_<debarch>.deb
      local dd_prefix="ubuntu-drivers/$kvers"
      local dd_suffix="_${karch}.deb"
      maybe_build_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}" || {
	  rm -rf "$tempdir"
	  die 5 $"Unable to build $module/$module_version for Ubuntu driver disk."
      }
      mkdir -p "$tempdir/$dd_prefix"
      local deb_dir="$tempdir/$dd_prefix/debian"
      local deb_lib_dir="$deb_dir/lib/modules/${kernelver[$i]}/updates/dkms"
      mkdir -p "$deb_lib_dir"
      cp "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/"*"$module_suffix" "$deb_lib_dir"
      pushd "$deb_dir" > /dev/null 2>&1
      mkdir DEBIAN
      cat > DEBIAN/control <<EOF
Package: ${module}-modules-${kernelver[$i]}
Version: ${module_version}-1
Section: misc
Priority: optional
Architecture: $karch
Depends:
Maintainer: DKMS <dkms-devel@dell.com>
Description: DKMS packaged binary driver update
 DKMS automagically generated debian package for
 driver update disks, used with Ubuntu installation
 programs (such as Ubiquity).
EOF

       # Generate the DEBIAN/preinst file.
       # This is tricky as we need some parts evaluated now
       # and some parts evaluated at runtime
cat >DEBIAN/preinst <<EOF
#!/bin/bash
[[ \$(uname -r) = ${kernelver[$i]} ]] || exit 1
exit 0
EOF
       chmod 0775 DEBIAN/preinst
       cd "$tempdir/$dd_prefix"
       dpkg-deb --build debian
       mv debian.deb "${module}_${module_version}-${kernelver[$i]}${dd_suffix}"
       rm -rf debian
       popd > /dev/null 2>&1
   done

   echo "Copying source..."
   mkdir -p "$tempdir/ubuntu"
   cp -ar "$source_tree/$module-$module_version" "$tempdir/ubuntu/"

   mkdir -p "$image_dir"
   rm -f "$image_dir/$image_name"
   cd "$tempdir"
   make_driver_disk_media "$image_dir/$image_name" "$tempdir"
   cd - >/dev/null
   rm -rf "$tempdir"
   echo $""
   echo $"Disk image location: $dkms_tree/$module/$module_version/driver_disk/$image_name"
   echo $""
   echo $"DKMS: mkdriverdisk completed."
}

make_tarball()
{
    make_common_test "mktarball"

    # Check for dkms_dbversion
    if ! [[ -e $dkms_tree/dkms_dbversion ]]; then
	echo $"" >&2
	echo $"Could not find the file $dkms_tree/dkms_dbversion." >&2
	echo $"Creating w/ default contents." >&2
	echo "2.0.0" > $dkms_tree/dkms_dbversion
    fi

    # Read the conf file
    read_conf_or_die "$kernelver" "$arch"

    temp_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
    mkdir -p $temp_dir_name/dkms_main_tree

    if [[ $source_only ]]; then
	kernel_version_list="source-only"
    else
	local i
	for ((i=0; i<${#kernelver[@]}; i++)); do
	    if ! [[ -d $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]} ]]; then
		rm -rf "$temp_dir_name" 2>/dev/null
		die 6  $"No modules built for ${kernelver[$i]} (${arch[$i]})." \
		    $"Modules must already be in the built state before using mktarball."
	    fi

	    set_module_suffix "${kernelver[$i]}"

	    echo "Marking modules for ${kernelver[$i]} (${arch[$i]}) for archiving..."
	    if [[ ! $kernel_version_list ]]; then
		kernel_version_list="kernel${kernelver[$i]}-${arch[$i]}"
	    else
		kernel_version_list="${kernel_version_list}-kernel${kernelver[$i]}-${arch[$i]}"
	    fi
	    mkdir -p "$temp_dir_name/dkms_main_tree/${kernelver[$i]}/${arch[$i]}"
	    cp -rf "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}" "$temp_dir_name/dkms_main_tree/${kernelver[$i]}"
    done
    fi

    # Store the dkms_dbversion in the tarball
    cp -f "$dkms_tree/dkms_dbversion" "$temp_dir_name/dkms_main_tree/"

    # Copy the source_tree or make special binaries-only structure
    if [[ $binaries_only ]]; then
	echo $""
	echo $"Creating tarball structure to specifically accomodate binaries."
	mkdir $temp_dir_name/dkms_binaries_only
	echo "$module" > $temp_dir_name/dkms_binaries_only/PACKAGE_NAME
	echo "$module_version" > $temp_dir_name/dkms_binaries_only/PACKAGE_VERSION
	[[ ! $conf ]] && conf="$dkms_tree/$module/$module_version/source/dkms.conf"
	cp -f $conf $temp_dir_name/dkms_binaries_only/ 2>/dev/null
    else
	echo $""
	echo $"Marking $dkms_tree/$module/$module_version/source for archiving..."
	mkdir -p $temp_dir_name/dkms_source_tree
	cp -rf $dkms_tree/$module/$module_version/source/* $temp_dir_name/dkms_source_tree
    fi

    if (( $(echo $kernel_version_list | wc -m | awk {'print $1'}) > 200 )); then
	kernel_version_list="manykernels"
    fi

    local tarball_name="$module-$module_version-$kernel_version_list.dkms.tar.gz"
    local tarball_dest="$dkms_tree/$module/$module_version/tarball/"

    # Die if we will not be able to create the tarball due to permissions.
    if [[ $archive_location ]]; then
	tarball_name="${archive_location##*/}"
        if [[ ${archive_location%/*} != $archive_location && \
            -d ${archive_location%/*} && -w ${archive_location%/*} ]]; then
            tarball_dest="${archive_location%/*}"
        elif [[ ${archive_location%/*} != $archive_location ]] && ! mkdir -p $tarball_dest; then
	    die 9 $"Will not be able to create $archive_location due to a permissions problem."
	fi
    fi
    if [ ! -d $tarball_dest ]; then
	mkdir -p "$dkms_tree/$module/$module_version/tarball/"
    fi

    echo $""
    echo $"Tarball location: $tarball_dest/$tarball_name"

    local tarball_ext=${tarball_name##*.}
    [[ $tarball_ext = tar ]] || tarball_name=${tarball_name%.$tarball_ext}

    # Make the tarball
    cd $temp_dir_name
    if tar -cf $temp_dir_name/$tarball_name ./* 2>/dev/null; then
	cd - >/dev/null
	echo $""
	mv -f "$temp_dir_name/$tarball_name" "$tarball_dest/$tarball_name"
	rm -rf $temp_dir_name
    else
	cd - >/dev/null
	rm -rf $temp_dir_name
	die 6 $"Failed to make tarball."
    fi
    case $tarball_ext in
	gz) gzip -9 "$tarball_dest/$tarball_name";;
	bz2) bzip2 -9 "$tarball_dest/$tarball_name";;
	xz) xz -9 "$tarball_dest/$tarball_name";;
    esac
    echo $""
    echo $"DKMS: mktarball completed."
}

# A tiny helper function to make sure dkms.conf describes a valid package.
get_pkginfo_from_conf() {
    [[ -f $1 && $1 = *dkms.conf ]] || return
    read_conf_or_die "$kernelver" "$arch" "$1"
    [[ $PACKAGE_NAME && $PACKAGE_VERSION ]]
}

# Unpack a DKMS tarball from a few different supported formats.
# We expect $archive_location to have been passed either as a raw argument or
# with --archive.
load_tarball()
{
    # Error out if $archive_location does not exist
    if [[ ! -e $archive_location ]]; then
	die 2 $"$archive_location does not exist."
    fi

    # If it is an .rpm file. install it with rpm, run an autoinstall, and then exit.
    if [[ $archive_location = *.rpm ]]; then
       if rpm -Uvh "$archive_location"; then
           autoinstall
           exit $?
       else
           die 9 $"Unable to install $archive_location using rpm." \
               $"Check to ensure that your system can install .rpm files."
       fi
    fi

    # Figure out what kind of archive it is (tar.gz, tar, tar.bz, etc)
    # Note that this does not depend on the extensions being correct.
    local tar_options=""
    for xpand in gzip bzip xz; do
	$xpand -t $archive_location 2>/dev/null || continue
	case $xpand in
	    gzip) tar_options=z;;
	    bzip2) tar_options=j;;
	    xz) tar_options=J;;
	esac
	break
    done

    # Untar it into $tmp_location
    local temp_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
    trap 'rm -rf $temp_dir_name' EXIT
    tar -${tar_options}xf $archive_location -C $temp_dir_name

    if [[ ! $temp_dir_name/dkms_main_tree ]]; then
	# Tarball was not generated from mktarball.
	# Just find the dkms.conf file and load the source.
	conf=$(find $temp_dir_name/ -name dkms.conf 2>/dev/null | head -n 1)
	if [[ ! $conf ]]; then
	    rm -rf $temp_dir_name
	    die 3 $"Tarball does not appear to be a correctly formed" \
		$"DKMS archive. No dkms.conf found within it."
	fi
	add_source_tree "${conf%dkms.conf}"
	return
    fi

    # Check that dkms_dbversion is not a future version
    # As far as I can tell, the only reason we bother with this is for detecting
    # whether we have arch support or not, which we can also determine by examining
    # the structure of the tarball.
    db_from_tarball=$(cat $temp_dir_name/dkms_main_tree/dkms_dbversion 2>/dev/null)
    db_from_dkms=$(cat $dkms_tree/dkms_dbversion 2>/dev/null)
    if [[ $db_from_tarball && $db_from_dkms && \
	$(VER "$db_from_tarball") > $(VER "$db_from_dkms") ]]; then
	die 9 \
	    $"The tarball you are trying to load indicates it is database version" \
	    $"$db_from_tarball.  This version of DKMS only supports $db_from_dkms or lower."
    fi

    # Make sure its a sane tarball. Sane ones will have one of the two
    # directories we test for.
    for loc in dkms_source_tree dkms_binaries_only ''; do
	if [[ ! $loc ]]; then
	    die 7 $"No valid dkms.conf in dkms_source_tree or dkms_binaries_only." \
		$"$archive_location is not a valid DKMS tarball."
	fi
	local conf="$temp_dir_name/$loc/dkms.conf"
	[[ -f $conf ]] || continue
	if ! get_pkginfo_from_conf "$conf"; then
	    echo >&2
	    echo $"Malformed dkms.conf, refusing to load." >&2
	    continue
	fi
	if is_module_added "$PACKAGE_NAME" "$PACKAGE_VERSION" && \
	    [[ ! $force ]]; then
	    die 8  $"$PACKAGE_NAME-$PACKAGE_VERSION is already added!" \
		$"Aborting."
	fi
	module="$PACKAGE_NAME"; module_version="$PACKAGE_VERSION"
	echo $""
	echo $"Loading tarball for $module-$module_version"
	case $loc in
	    dkms_source_tree)
		add_source_tree "$temp_dir_name/dkms_source_tree";;
	    dkms_binaries_only)
		#if there is a source tree on the system already, don't build a binaries stub
		if [[ ! -d $source_tree/$module-$module_version ]]; then
			echo $"Creating $dkms_tree/$module/$module_version/source"
			mkdir -p "$dkms_tree/$module/$module_version/source"
			echo $"Copying dkms.conf to $dkms_tree/$module/$module_version/source..."
			cp -rf "$temp_dir_name/dkms_binaries_only/dkms.conf" "$dkms_tree/$module/$module_version/source"
		fi;;
	    *)  die 8 $"$FUNCNAME:$LINENO: Cannot happen." \
		$"Report this error to dkms-devel@dell.com";;
	esac
	break
    done

    # at this point, the source has been copied to the appropriate location
    # and registered with dkms, or a binary-only config has been noted.
    # Now, add any included precompiled modules.

    # Is tarball from before DKMS 2.0 (prior to arch support)
    if [[ ! -e $temp_dir_name/dkms_main_tree/dkms_dbversion ]]; then
	[[ $loc = dkms_binaries_only ]] && rm -rf "$dkms_tree/$module/$module_version/source"
	die 10 $" This tarball was created with dkms < 2.0 and contains" \
	    $"no arch info. DKMS is refusing to install precompiled modules."
    fi

    # Load precompiled modules.
    for directory in "$temp_dir_name/dkms_main_tree"/*/*; do
	[[ -d $directory ]] || continue
	kernel_arch_to_load=${directory/*dkms_main_tree\/}
	dkms_dir_location="$dkms_tree/$module/$module_version/$kernel_arch_to_load"
	if [[ -d $dkms_dir_location && ! $force ]]; then
	    warn $"$dkms_dir_location already exists.  Skipping..."
	else
	    echo $"Loading $dkms_dir_location..."
	    rm -rf $dkms_dir_location
	    mkdir -p $dkms_dir_location
	    cp -rf $directory/* $dkms_dir_location/
	fi
    done

    echo $""
    echo $"DKMS: ldtarball completed."
    [[ $loc != dkms_binaries_only ]] || [[ -d $source_tree/$module-$module_version ]]
}

run_match()
{
    set_kernel_source_dir "$kernelver"

    # Error if $template_kernel is unset
    if [[ ! $template_kernel ]]; then
	die 1 $"Invalid number of parameters passed." \
	    $"Usage: match --templatekernel=<kernel-version> -k <kernel-version>" \
	    $"   or: match --templatekernel=<kernel-version> -k <kernel-version> <module>"
    fi

    # Error out if $template_kernel = $kernel_version
    if [[ $template_kernel = $kernelver ]]; then
	die 2 $"The templatekernel and the specified kernel version are the same."
    fi

    # Read in the status of template_kernel
    local template_kernel_status=$(do_status '' '' $template_kernel $arch | grep ": installed")

    # If $module is set, grep the status only for that module
    if [[ $module ]]; then
	# Make sure that its installed in the first place
	if ! [[ -d $dkms_tree/$module/ ]]; then
	    die 3 $"The module: $module is not located in the DKMS tree."
	fi
	template_kernel_status=$(echo "$template_kernel_status" | grep "^$module,")
    fi

    echo $""
    echo $"Matching modules in kernel: $kernelver ($arch)"
    echo $"to the configuration of kernel: $template_kernel ($arch)"

    # Prepare the kernel just once but only if there is actual work to do
    if [[ ! $template_kernel_status ]]; then
	echo $""
	echo $"There is nothing to be done for this match."
    else
	prepare_kernel "$kernelver" "$arch"

	# Iterate over the kernel_status and match kernel to the template_kernel
	while read template_line; do
	    template_module=`echo "$template_line" | awk {'print $1'} | sed 's/,$//'`
	    template_version=`echo "$template_line" | awk {'print $2'} | sed 's/,$//'`

	    # Print out a match header
	    echo $""
	    echo $"---- Match Beginning ----"
	    echo $"Module:  $template_module"
	    echo $"Version: $template_version"
	    echo $"-------------------------"

	    # Figure out what to do from here
	    if show_status "$template_module" "$template_version" "$kernelver" "$arch" 2>/dev/null | grep -q ": installed"; then
		echo $""
		echo $"This module/version combo is already installed.  Nothing to be done."
	    elif show_status "$template_module" "$template_version" "$kernelver" "$arch" 2>/dev/null | grep -q ": built"; then
		echo $""
		echo $"This module/version combo is built.  Installing it:"
		module="$template_module"
		module_version="$template_version"
		install_module
	    else
		echo $""
		echo $"Building & Installing this module/version:"
		module="$template_module"
		module_version="$template_version"
		build_module
		install_module
	    fi
	done < <(echo "$template_kernel_status")

	# Clean up the kernel tree
	if [[ ! ( $(VER $kernelver) < $(VER 2.6.6) ) && \
	    -d "$kernel_source_dir" && \
	    ! -h "$kernel_source_dir" && \
	    -z "$ksourcedir_fromcli" ]]; then
	    echo $"Kernel cleanup unnecessary for this kernel.  Skipping..."
	elif [[ ! $no_clean_kernel ]]; then
	    cd "$kernel_source_dir"
	    [[ $kerneldoth_contents ]] || invoke_command "make mrproper" "cleaning kernel tree (make mrproper)" background
	    [[ $config_contents ]] && echo "$config_contents" > .config
	    [[ $kerneldoth_contents ]] && echo "$kerneldoth_contents" > /boot/kernel.h
	    cd - >/dev/null
	fi
    fi

    # Done
    echo $""
    echo $"DKMS: match completed."
}

make_rpm()
{
    make_common_test "mkrpm"

    # Check that the rpmbuild command is present
    if ! which rpmbuild >/dev/null 2>&1 ; then
	die 1 $"rpmbuild not present." \
	    $"Install the rpm-build package."
    fi

    # Read the conf file
    read_conf_or_die "$kernelver" "$arch"

    local rpm_basedir="$dkms_tree/$module/$module_version/rpm"

    echo $""
    local sp
    for sp in "$dkms_tree/$module/$module_version/source/$module-dkms-mkrpm.spec" \
	"/etc/dkms/template-dkms-mkrpm.spec"; do
	[[ -e $sp ]] || continue
	SPECFILE="$sp"
	break
    done
    if [[ ! $SPECFILE ]]; then
	die 5 $"Cannot find $sp which is needed by" \
	    $"DKMS in order use mkrpm."
    fi

    # Run a dkms mktarball for use in the rpm
    local mktarball_line
    if [[ ! $source_only || $binaries_only ]]; then
	mktarball_line="--binaries-only"
	local i
	echo $""
	for ((i=0; i<${#kernelver[@]}; i++)); do
	    if ! [[ -d $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]} ]]; then
	    die 5 $"You do not seem to have $module $module_version built for" \
		$"${kernelver[$i]} (${arch[$i]}).  All modules must be in" \
		$"the built state before you can use mkrpm."
	    fi
	    echo $"Marking ${kernelver[$i]} (${arch[$i]}) for RPM..."
	    mktarball_line="-k ${kernelver[$i]} -a ${arch[$i]} $mktarball_line"
	done
    else
	mktarball_line="none"
    fi

    local temp_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
    trap 'rm -rf $temp_dir_name' EXIT HUP TERM
    mkdir -p ${temp_dir_name}/{BUILD,RPMS,SRPMS,SPECS,SOURCES}
    cp ${SPECFILE} ${temp_dir_name}/SPECS/dkms_mkrpm.spec

    #if using legacy mode, install common postinst
    if ((legacy_postinst != 0)); then
	invoke_command "cp '$PREFIX/usr/lib/dkms/common.postinst' '${temp_dir_name}/SOURCES'" "copying legacy postinstall template"
    fi

    #Copy in the source tree
    if [[ ! $binaries_only ]]; then
	invoke_command "cp -Lpr '$dkms_tree/$module/$module_version/source' '${temp_dir_name}/SOURCES/$module-$module_version'" "Copying source tree"
    fi

    if invoke_command "LC_ALL=C rpmbuild --define \"_topdir ${temp_dir_name}\" --define \"version $module_version\" --define \"module_name $module\" --define \"kernel_versions ${kernelver[*]}\" --define \"mktarball_line $mktarball_line\" --define \"__find_provides  /usr/lib/dkms/find-provides\" --define \"_use_internal_dependency_generator 0\" -ba ${temp_dir_name}/SPECS/dkms_mkrpm.spec > ${temp_dir_name}/rpmbuild.log 2>&1" "rpmbuild"; then
	mkdir -p ${rpm_basedir}
	cp -a ${temp_dir_name}/SRPMS/* ${temp_dir_name}/RPMS/*/* ${rpm_basedir}/
	echo $""
	cat ${temp_dir_name}/rpmbuild.log | grep ^Wrote | sed -e "s:${temp_dir_name}/:${rpm_basedir}/:" -e 's:SRPMS/::' -e 's:RPMS/.*/::'
	echo $""
	echo $"DKMS: mkrpm completed."
    else
	cat ${temp_dir_name}/rpmbuild.log >&2
	die 7 $"There was a problem creating your rpm."
    fi
    rm -rf $temp_dir_name
    trap > /dev/null 2>&1
}

preproc_file()
{
    local date_str="$(date -R)"
    echo "modifying $1..."
    sed -e "s/DEBIAN_PACKAGE/$debian_package/g" \
	-e "s/MODULE_NAME/$module/g" \
	-e "s/MODULE_VERSION/$module_version/g" \
	-e "s/DATE_STAMP/$date_str/" "$1" > "$1.dkms-pp"
    mv "$1.dkms-pp" "$1"
}

# Install a package on a debian system.
debian_install()
{
    local getroot  tmpfile i
    local -a packages=("$@")
    for ((i=0; i < ${#packages[@]}; i++)); do
	dpkg-query -s "${packages[$i]}"| egrep -q '^Status:.* installed$' || continue
	unset package[$i]
    done
    # if they are already installed, we are OK.
    [[ ${package[@]} ]] || return
    if ((UID != 0)); then
	# figure out how to get root
	for getroot in su-to-root gksudo kdesu sudo; do
	    which $getroot >/dev/null 2>&1 || continue
	    case $getroot in
		su-to-root) getroot="$getroot -c";;
		gksudo) [[ $DISPLAY ]] || continue
		    getroot="$getroot --description 'DKMS Debian package builder' ";;
		kdesu) [[ $DISPLAY ]] || continue;;
	    esac
	    break
	done
    fi
    if [[ -x /usr/sbin/synaptic && $DISPLAY ]] && tmpfile=$(mktemp_or_die); then
	# Pretty GUI install.
	trap 'rm -f "$tmpfile"' EXIT
	for ((i=0; i=${#packages[@]}; i++)); do
	    [[ ${packages[$i]} ]] && echo "install ${packages[$i]}" >>$tmpfile
	done
	$getroot "sh -c '/usr/sbin/synaptic --set-selections --non-interactive --hide-main-window < $tmpfile'"
    else
	$getroot apt-get -y install "${packages[@]}"
    fi
    if (( $? != 0)); then
	die 4 $"Missing ${packages[@]}" \
	    $"and unable to install.  Please ask an admin to install for you."
    fi
}

make_debian()
{
    create_type="$1"

    create_temporary_trees
    trap "delete_temporary_trees" EXIT HUP TERM

    make_common_test "mk${create_type}"

    debian_package=${module//_/-}

    # Read the conf file
    read_conf_or_die "$kernelver" "$arch"
    debian_install fakeroot dpkg-dev debhelper

    #skeleton to load templates from
    local system_mk="$dkms_tree/$module/$module_version/source/$module-dkms-mk${create_type}"
    local local_mk="/etc/dkms/template-dkms-mk${create_type}"
    if [[ -e ${system_mk} ]]; then
	echo $"Using ${system_mk}"
	DEBDIR=${system_mk}
    elif [[ -e ${local_mk} ]]; then
	echo $"Using ${local_mk}"
	DEBDIR=${local_mk}
    else
	die 5 $"Cannot find ${local_mk} which is needed by" \
	    $"DKMS in order to use mk${create_type}."
    fi

    #prepare build directory and copy template
    local temp_dir=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
    trap "rm -rf $temp_dir; delete_temporary_trees" EXIT HUP TERM
    local temp_dir_debian="$temp_dir/$debian_package-dkms-$module_version"
    invoke_command "cp -ar '$DEBDIR/' '$temp_dir_debian'" "copying template"
    pushd "$temp_dir_debian" > /dev/null 2>&1
    for file in debian/*; do
	preproc_file "$file"
	chmod 755 "$file"
    done
    popd > /dev/null 2>&1

     #if using legacy mode, install common postinst
    if ((legacy_postinst != 0)); then
	invoke_command "cp '$PREFIX/usr/lib/dkms/common.postinst' '$temp_dir_debian'" "copying legacy postinstall template"
    fi

    #Copy in the source tree
    if [[ ! $binaries_only ]]; then
	invoke_command "cp -Lpr '$dkms_tree/$module/$module_version/source' '$temp_dir_debian/$module-$module_version'" "Copying source tree"
    fi

    #Only if we are shipping binary modules, make a .tgz for the deb
    local archive_location="$dkms_tree/$module/$module_version/tarball/$module-$module_version.dkms.tar.gz"
    if [[ ! $source_only ]]; then
	binaries_only="binaries-only"
	invoke_command "make_tarball" "Gathering binaries"
	if [[ -f $archive_location ]]; then
	    invoke_command "cp '$archive_location' '$temp_dir_debian'" "Copying DKMS tarball into DKMS tree"
	else
	    die 12 $"Unable to find created tarball."
	fi
    fi

    #calculate destination directory
    deb_basedir=$dkms_tree/$module/$module_version/${create_type}
    mkdir -p ${deb_basedir} >/dev/null 2>&1

    #create deb
    pushd "$temp_dir_debian" > /dev/null 2>&1
    case "$create_type" in
	dsc)
	    invoke_command "dpkg-buildpackage -S -us -uc 1>/dev/null" "Building source package" || \
		die 7 $"There was a problem creating your ${create_type}."
	    echo $""
	    echo $"DKMS: mk${create_type} completed."
	    invoke_command "mv '$temp_dir/${debian_package}-dkms_${module_version}_source.changes' '$temp_dir/${debian_package}-dkms_${module_version}.dsc' '$temp_dir/${debian_package}-dkms_${module_version}.tar.gz' '$deb_basedir'" "Moving built files to $deb_basedir"
	    ;;
	deb)
	    invoke_command "dpkg-buildpackage -rfakeroot -d -b -us -uc 1>/dev/null" "Building binary package" || \
		die 7 $"There was a problem creating your ${create_type}."
	    echo $""
	    echo $"DKMS: mk${create_type} completed."
	    invoke_command "mv '$temp_dir/${debian_package}-dkms_${module_version}_all.deb' '$deb_basedir'" "Moving built files to $deb_basedir"
	    ;;
    esac
    popd > /dev/null 2>&1

    if in_temporary_trees; then
	echo "Copying built files to "`pwd`"/.." >&2
	cp "${deb_basedir}/"* ..
    fi

    #cleanup
    invoke_command "rm $temp_dir -fr" "Cleaning up temporary files"
    delete_temporary_trees || \
	die 7 $"There was a problem cleaning up temporary files."
}

make_common_test()
{
    local create_type=$1
    # Error if $module_version is set but $module is not
    check_module_args $create_type

    # Check that source symlink works
    check_module_exists

    # Make sure that its installed in the first place
    [[ -d $dkms_tree/$module/$module_version ]] ||
	die 3 $"The module/version combo: $module-$module_version" \
	    $"is not located in the DKMS tree."
}

make_kmp_srpm()
{
    local temp_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
    trap 'rm -rf $temp_dir_name' EXIT HUP TERM
    mkdir -p $temp_dir_name/{BUILD,RPMS,SRPMS,SPECS,SOURCES}
    pushd "$dkms_tree/$module/$module_version" > /dev/null 2>&1
    # want to change name of the top-level of the tarball
    # from build to $module-$module_version
    cp -lr build ${module}-${module_version}
    tar cvjf $temp_dir_name/SOURCES/${module}-${module_version}.tar.bz2 ${module}-${module_version} > /dev/null 2>&1
    rm -rf ${module}-${module_version}
    popd > /dev/null 2>&1
    pushd "$temp_dir_name" > /dev/null 2>&1
    invoke_command "rpmbuild --define \"_topdir ${temp_dir_name}\" --target=$arch -bs ${SPECFILE} > ${temp_dir_name}/rpmbuild.log 2>&1" "rpmbuild"
    grep ^Wrote $temp_dir_name/rpmbuild.log > /dev/null 2>&1
    local RC="$?"
    if ((RC == 0)); then
	local kmp_basedir="$dkms_tree/$module/$module_version/rpm"
	mkdir -p $kmp_basedir
	RPMS=$(LANG=C cp -va ${temp_dir_name}/SRPMS/* $kmp_basedir | awk '{print $NF}')
    else
	echo $"rpmbuild error log:"
	cat $temp_dir_name/rpmbuild.log
    fi
    popd > /dev/null 2>&1
    rm -rf $temp_dir_name
    trap > /dev/null 2>&1
    return ${RC}
}

report_build_problem()
{
    #If apport is on the system, files a build problem
    if [ -x /usr/share/apport/apport ] && which python>/dev/null; then
	python /usr/share/apport/package-hooks/dkms_packages.py -m $module -v $module_version -k ${kernelver[0]}
    fi
    die "$@"
}

# Little helper function for reading args from the commandline.
# it automatically handles -a b and -a=b variants, and returns 1 if
# we need to shift $3.
read_arg() {
    # $1 = arg name
    # $2 = arg value
    # $3 = arg parameter
    local rematch='^[^=]*=(.*)$'
    if [[ $2 =~ $rematch ]]; then
	read "$1" <<< "${BASH_REMATCH[1]}"
    else
	read "$1" <<< "$3"
	# There is no way to shift our callers args, so
	# return 1 to indicate they should do it instead.
	return 1
    fi
}

# A couple of helper functions for parsing out our most common arguments.
# This one allows you to pass -k kernel.version-extra/arch instead of
# -k kernel-version.extra -a arch.
# This makes it harder to pass mismatching numbers of kernel/arch pairs, because
# they are all passed at the same time.
parse_kernelarch(){
    if [[ $1 =~ $mv_re ]]; then
	kernelver[${#kernelver[@]}]="${BASH_REMATCH[1]}"
	arch[${#arch[@]}]="${BASH_REMATCH[2]}"
    else
	kernelver[${#kernelver[@]}]="$1"
    fi
}

# This allows you to pass module and module_version information on the commandline
# in a more convienent form.  Instead of the mostly mandatory and annoying
# -m module -v module_version, you can use either -m module/module_version, 
# or just a raw module/module_version with no -m parameter.  
# This vastly improves readability and discoverability of
# commands on the commandline.
parse_moduleversion(){
    if [[ $1 =~ $mv_re ]]; then
	module="${BASH_REMATCH[1]}"
	module_version="${BASH_REMATCH[2]}"
    else
	module="$1"
    fi
}

check_root() {
    ((UID == 0)) && return
    die 1 $"You must be root to use this command."
}

# Add a passed source tree to the default source location.
# We will check the dkms.conf file to make sure it is valid
# beforehand.
add_source_tree() {
    local from=$(readlink -f $1)
    if ! [[ $from && -f $from/dkms.conf ]]; then
	die 9 $"$1 must contain a dkms.conf file!"
    fi
    check_root
    setup_kernels_arches
    if ! get_pkginfo_from_conf "$from/dkms.conf" ; then
	die 10 $"Malformed dkms.conf file. Cannot load source tree."
    fi
    module="$PACKAGE_NAME"
    module_version="$PACKAGE_VERSION"
    if [[ $force && -d $source_tree/$module-$module_version ]]; then
	echo >&2
	echo $"Forcing install of $module-$module_version"
	rm -rf "$source_tree/$module-$module_version"
    fi

    # We are already installed, just return.
    case $from in
	"$source_tree/$module-$module_version") return;;
	"$dkms_tree/$module/$version/source") return;;
	"$dkms_tree/$module/$version/build") return;;
    esac
    mkdir -p "$source_tree/$module-$module_version"
    cp -fr "$from"/* "$source_tree/$module-$module_version"
}

make_kmp()
{
    make_common_test "mkkmp"

    # Read the conf file
    read_conf_or_die "$kernelver" "$arch"

    echo $""
    if [[ $specfile && -e $dkms_tree/$module/$module_version/source/$specfile ]]; then
	echo $"Using $dkms_tree/$module/$module_version/source/$specfile"
	SPECFILE="$dkms_tree/$module/$module_version/source/$specfile"
    elif [[ -e $dkms_tree/$module/$module_version/source/$module-kmp.spec ]]; then
	echo $"Using $dkms_tree/$module/$module_version/source/$module-kmp.spec"
	SPECFILE="$dkms_tree/$module/$module_version/source/$module-kmp.spec"
    else
	die 5 $"Cannot find a suitable spec file which is needed by" \
	    $"DKMS in order use mkkmp.  Please specify --spec=specfile."
    fi

    prepare_build
    make_kmp_srpm
    RC=$?
    clean_build

    if ((RC == 0)); then
	echo $""
	echo $"KMP SRPM location: $RPMS"
	echo $""
	echo $"DKMS: mkkmp completed."
    else
	die 7 $"There was a problem creating your KMP source rpm."
    fi
    # FIXME: hand SRPM to mock or build system to build
}

# This code used to be in dkms_autoinstaller.
# Moving it into the main dkms script gets rid of a fair amount of duplicate
# functionality, and makes it much easier to reinstall DKMS kernel modules
# by hand if dkms_autoinstaller is not used.
autoinstall() {
    local status mv mvka m v k a last_v last_m tenative
    local -a to_install=()
    # Walk through our list of installed and built modules, and create
    # a list of modules that need to be reinstalled.
    while read status mvka; do
        IFS='/' read m v k a <<< "$mvka"
        [[ ! $last_m ]] && last_m="$m"
        # If the module is already installed or weak-installed, skip it.
        _is_module_installed "$m" "$v" "$kernelver" "$arch" && continue
        module_status_weak "$m" "$v" "$kernelver" "$arch" >/dev/null && continue
        # if the module does not want to be autoinstalled, skip it.
        read_conf_or_die "$k" "$a" "$dkms_tree/$m/$v/source/dkms.conf"
        if [[ ! $AUTOINSTALL ]]; then
            continue
        # otherwise, only autoinstall the latest version we have hanging around.
        elif [[ $last_m != $m ]]; then
            last_m="$m"
            last_v='0'
            [[ $tenative ]] && to_install[${#to_install[@]}]="$tenative"
            tenative=''
        fi
        if [[ ($(VER $v) > $(VER $last_v)) ]]; then
            last_v="$v"
            tenative="$m/$v"
        fi
    done < <(module_status)
    # We may have exited the loop with $tenative set.  If it is,
    # it contains something that should be updated.
    [[ $tenative ]] && to_install[${#to_install[@]}]="$tenative"
    [[ $to_install ]] || return 0
    # Install modules that need to be updated in parallel.
    for mv in "${to_install[@]}"; do
        IFS=/ read m v <<< "$mv"
        (module="$m"; module_version="$v"; install_module) &
    done
    wait
}

function make_redhat3_driver_disk ()
{
    # Check that the rpmbuild command is present
    if ! which rpmbuild >/dev/null 2>&1 ; then
        echo $"" >&2
        echo $"Error! rpmbuild not present." >&2
        echo $"Install the rpm-build package." >&2
        exit 1
    fi

    local kmodtool=$(rpm -ql redhat-rpm-config | grep kmodtool)
    #Check that the kmodtool is present
    if [ -z "$kmodtool" ]; then
        echo $"Error! kmodtool not present." >&2
        echo $"Install redhat-rpm-config package." >&2
        exit 1
    fi

    # Check that the createrepo command is present
    if ! which createrepo >/dev/null 2>&1 ; then
        echo $"" >&2
        echo $"Error! createrepo not present." >&2
        echo $"Install the createrepo package." >&2
        exit 1
    fi

    echo $""
    if [ -n "$specfile" -a -e "$dkms_tree/$module/$module_version/source/$specfile" ]; then
        echo $"Using $dkms_tree/$module/$module_version/source/$specfile"
        SPECFILE="$dkms_tree/$module/$module_version/source/$specfile"
    elif [ -e "/etc/dkms/template-dkms-redhat-kmod.spec" ]; then
        echo $"Using /etc/dkms/template-dkms-redhat-kmod.spec"
        SPECFILE="/etc/dkms/template-dkms-redhat-kmod.spec"
    else
        echo $"" >&2
        echo $"Cannot find /etc/dkms/template-dkms-redhat-kmod.spec which is needed by" >&2
        echo $"DKMS in order to make Redhat driver disk v3." >&2
        exit 5
    fi
    # Set up temporary build directory for build
    rm -rf "$dkms_tree/$module/$module_version/build"
    cp -rf "$dkms_tree/$module/$module_version/source/" "$dkms_tree/$module/$module_version/build"

    cd "$dkms_tree/$module/$module_version/build"

    # Run the pre_build script
    if [ -n "$pre_build" ] && [ -x `echo "$dkms_tree/$module/$module_version/source/$pre_build" | sed 's/ .*//'` ]; then
        echo $""
        echo $"Running the pre_build script:"
        $dkms_tree/$module/$module_version/build/$pre_build
    fi

    # Apply any patches
    local index=0
    while [ $index -lt ${#patch_array[@]} ]; do
        if ! [ -e "$dkms_tree/$module/$module_version/build/patches/${patch_array[$index]}" ]; then
            echo $"" >&2
            echo $"Error!  Patch ${patch_array[$index]} as specified in dkms.conf cannot be" >&2
            echo $"found in $dkms_tree/$module/$module_version/build/patches/." >&2
            exit 5
        fi
        invoke_command "patch -p1 < ./patches/${patch_array[$index]}" "applying patch ${patch_array[$index]}"
        if [ "$?" -ne 0 ]; then
            echo $"" >&2
            echo $"Error! Application of patch ${patch_array[$index]} failed." >&2
            echo $"Check $dkms_tree/$module/$module_version/build/ for more information." >&2
                report_build_problem
            exit 6
        fi
        index=$(($index+1))
    done
    # Create temp dirs and copy files for build
    local temp_dir_name=`mktemp -d $tmp_location/dkms.XXXXXX`
    trap 'rm -rf $temp_dir_name' EXIT HUP TERM
    mkdir -p ${temp_dir_name}/{disk,BUILD,RPMS,SRPMS,SPECS,SOURCES}
    cp ${SPECFILE} ${temp_dir_name}/SPECS/$module.spec
    cp -rax $dkms_tree/$module/$module_version/build/ $temp_dir_name/SOURCES/$module-$module_version/
    # Clean the build directory
    rm -rf "$dkms_tree/$module/$module_version/build/*"
    cd $temp_dir_name/SOURCES
    invoke_command "tar -jcvf $temp_dir_name/SOURCES/$module-$module_version.tar.bz2 $module-$module_version/" "creating source tarball"
    local i=0
    #Build RPMS
    while [ $i -lt ${#kernelver[@]} ]; do
        invoke_command "LC_ALL=C rpmbuild --define \"_topdir ${temp_dir_name}\" --define \"version $module_version\" --define \"module_name $module\" --define \"kernel_version ${kernelver[$i]}\" -bb --target ${arch[$i]} ${temp_dir_name}/SPECS/$module.spec > ${temp_dir_name}/rpmbuild.log 2>&1" "rpmbuild"
        if [ "$?" -ne 0 ]; then
            echo $"" >&2
            echo $"Error! There was a problem creating your kmod." >&2
            cat ${temp_dir_name}/rpmbuild.log >&2
            exit 7
        fi
        local kabi_whitelist=`rpm -ql kabi-whitelists | grep ${arch[$i]}`
        if [ $kabi_whitelist ]; then
            local module_file=`rpm -qlp ${temp_dir_name}/RPMS/${arch[$i]}/kmod-${module}-${module_version}* | grep ${module}.ko`
            cd ${temp_dir_name}/
            rpm2cpio ${temp_dir_name}/RPMS/${arch[$i]}/kmod-${module}-${module_version}* | cpio -id --quiet .${module_file}
            cd - > /dev/null
            local mod_symbols=( $(modprobe --dump-modversions ${temp_dir_name}/${module_file} | cut -f2) )
            local miss_sym_count=0
            local missing_symbols
            for ((i=0; i < "${#mod_symbols[@]}"; i++))
            do
               if [ -z "`grep -o ${mod_symbols[${i}]} ${kabi_whitelist}`" ]; then
                   missing_symbols[$miss_sym_count]="${mod_symbols[${i}]}"
                   miss_sym_count=$(($miss_sym_count+1))
               fi
            done
            if [ $miss_sym_count -ne 0 ]; then
                echo $"" >&2
                echo $"WARNING: ${module}-${module_version} is using following kernel symbols that are not in the ABI whitelist:"
                echo $"----------------------------------"
                for missing_symbol in ${missing_symbols[*]}
                do
                    echo "$missing_symbol"
                done
                echo $"----------------------------------"
                echo $"" >&2
            else
                echo $"NOTICE: ${module}-${module_version} module seems to use only official Red Hat ABI."
            fi
        else
            echo $"WARNING:${module}-${module_version} module is not checked against Red Hat ABI whitelist."
            echo $"Install 'kabi-whitelists' package and build driver disk again to run the ABI compliance test."
        fi    
        i=$(($i + 1))
    done

    i=0
    while [ $i -lt ${#arch[@]} ]; do
        invoke_command "createrepo --pretty ${temp_dir_name}/RPMS/${arch[$i]}" "creating repo"
        if [ "$?" -ne 0 ]; then
            echo $"" >&2
            echo $"Error! There was a problem creating repository." >&2
            exit 7
        fi
        i=$(($i + 1))
    done

    echo "$module-$module_version driver disk" > "${temp_dir_name}/disk/rhdd3"
    mkdir ${temp_dir_name}/disk/rpms
    cp -rax ${temp_dir_name}/RPMS/* ${temp_dir_name}/disk/rpms/

    local suffix="$(driver_disk_suffix)"
    local image_dir="$dkms_tree/$module/$module_version/driver_disk"
    local image_name="$module-$module_version-dd.$suffix"
    echo $""
    echo $"Creating driver disk on $media media:"
    cd "${temp_dir_name}/disk"
    mkdir -p "$image_dir"
    rm -f "$image_dir/$image_name"
    make_driver_disk_media "$image_dir/$image_name" "${temp_dir_name}/disk"
    rm -rf $temp_dir_name

    echo $""
    echo $"Disk image location: $image_dir/$image_name"
    echo $""
    echo $"DKMS: mkdriverdisk completed."
    
    trap > /dev/null 2>&1
}

#############################
####                     ####
#### Program Starts Here ####
####                     ####
#############################

# Set a standard path
PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/lib/dkms"

# Ensure files and directories we create are readable to anyone,
# since we aim to build as a non-root user
umask 022

# Unset environment variables that may interfere with the build
unset CC CXX CFLAGS CXXFLAGS LDFLAGS

# Set important variables
current_kernel=$(uname -r)
current_os=$(uname -s)
dkms_tree="/var/lib/dkms"
source_tree="/usr/src"
install_tree="/lib/modules"
tmp_location=${TMPDIR:-/tmp}
verbose=""
dkms_frameworkconf="/etc/dkms/framework.conf"

# these can come from the environment or the config file
[[ ! ${ADDON_MODULES_DIR} && -e /etc/sysconfig/module-init-tools ]] && . /etc/sysconfig/module-init-tools
addon_modules_dir="${ADDON_MODULES_DIR}"
[[ ! ${addon_modules_dir} ]] && running_distribution="$(distro_version)"
weak_modules="${WEAK_MODULES_BIN}"

# Source in /etc/dkms_framework.conf
[ -e $dkms_frameworkconf ] && . $dkms_frameworkconf 2>/dev/null

# Clear out command line argument variables
module=""
module_version=""
template_kernel=""
distro=""
media=""
release=""
conf=""
kernel_config=""
archive_location=""
kernel_source_dir=""
ksourcedir_fromcli=""
action=""
force=""
no_prepare_kernel=""
no_clean_kernel=""
binaries_only=""
source_only=""
all=""
module_suffix=""
rpm_safe_upgrade=""
size="1440";
specfile=""
legacy_postinst="1"
declare -a directive_array=() kernelver=() arch=()
weak_modules=''
last_mvka=''
last_mvka_conf=''
try_source_tree=''
die_is_fatal="yes"
[ -x /sbin/weak-modules ] && weak_modules='/sbin/weak-modules'
[ -x /usr/lib/module-init-tools/weak-modules ] && weak_modules='/usr/lib/module-init-tools/weak-modules'

action_re='^(remove|(auto|un)?install|match|mk(driverdisk|tarball|rpm|deb|dsc|kmp)|build|add|status|ldtarball)$'

# Parse command line arguments
while (($# > 0)); do
    case $1 in
	--dkmsframework*)    read_arg dkms_frameworkconf "$1" "$2" || shift
			     #immediately load this config
			     . $dkms_frameworkconf 2> /dev/null;;
	--module*|-m)        read_arg _mv "$1" "$2" || shift
			     parse_moduleversion "$_mv";;
	-v)                  read_arg module_version "$1" "$2" || shift;;
	--kernelver*|-k)     read_arg _ka "$1" "$2" || shift
			     parse_kernelarch "$_ka";;
	--distro*|-d)        read_arg distro "$1" "$2" || shift;;
	--media*)            read_arg media "$1" "$2" ||shift;;
	--release*|-r)       read_arg release "$1" "$2" || shift;;
	--templatekernel*)   read_arg template_kernel "$1" "$2" || shift;;
	-c)                  read_arg conf "$1" "$2" || shift;;
	--quiet|-q)          exec >/dev/null 2>&1;;
	--version|-V)        echo $"dkms: 2.2.0.3"
			     exit 0;;
	--no-prepare-kernel) no_prepare_kernel="no-prepare-kernel";;
	--no-clean-kernel)   no_clean_kernel="no-clean-kernel";;
	--no-initrd)         no_initrd="no-initrd";;
	--binaries-only)     binaries_only="binaries-only";;
	--source-only)       source_only="source-only";;
	--force)             force="true";;
	--all)               all="true";;
	--verbose)           verbose="true";;
	--rpm_safe_upgrade)  rpm_safe_upgrade="true";;
	--dkmstree*)         read_arg dkms_tree "$1" "$2" || shift;;
	--sourcetree*)       read_arg source_tree "$1" "$2" || shift;;
	--installtree*)      read_arg install_tree "$1" "$2" || shift;;
	--config*)           read_arg kernel_config "$1" "$2" || shift;;
	--archive*)          read_arg archive_location "$1" "$2" || shift;;
	--legacy-postinst*)  read_arg legacy_postinst "$1" "$2" || shift;;
	--arch*|-a)          read_arg _aa "$1" "$2" || shift
			     arch[${#arch[@]}]="$_aa";;
	--size*)             read_arg size "$1" "$2" || shift;;
	--kernelsourcedir*)  read_arg kernel_source_dir "$1" "$2" || shift
			     ksourcedir_fromcli="true";;
	--directive*)        read_arg _da "$1" "$2" || shift
			     directive_array[${#directive_array[@]}]="$_da";;
	--spec*)             read_arg specfile "$1" "$2" || shift;;
	--debug)
	    export PS4='${BASH_SOURCE}@${LINENO}(${FUNCNAME[0]}): '
	    set -x;;
	-*|--*)              error $" Unknown option: $1"
			     show_usage
			     exit 2;;
	*) if [[ $1 =~ $action_re ]]; then
	    action="$action $1" # Add actions to the action list
	    elif [[ -f $1 && $1 = *dkms.conf ]]; then
	    try_source_tree="${1%dkms.conf}./" # Flag as a source tree
	    elif [[ -d $1 && -f $1/dkms.conf ]]; then
	    try_source_tree="$1" # ditto
	    elif [[ -f $1 ]]; then
	    archive_location="$1" # It is a file, assume it is an archive.
	    elif [[ ! $module ]]; then
	    parse_moduleversion "$1" # Assume it is a module/version pair.
	    else
	    warn $"I do not know how to handle $1."
	    fi;;
    esac
    shift
done

# Sanity checking

# Error out if binaries-only is set and source-only is set
if [[ $binaries_only && $source_only ]]; then
    die 8 $" You have specified both --binaries-only and --source-only." \
	$"You cannot do this."
fi

# Error if # of arches doesn't match # of kernels
if (( ${#kernelver[@]} != ${#arch[@]} && \
    ${#arch[@]} > 1 )); then
    die 1 $" If more than one arch is specified on the command line, then there" \
	$"must be an equal number of kernel versions also specified (1:1 relationship)."
fi

# Check that kernel version and all aren't both set simultaneously
if [[ $kernelver && $all ]]; then
    die 2 $" You cannot specify a kernel version and also specify" \
	$"--all on the command line."
fi

# Check that arch and all aren't both set simultaneously
if [[ $arch && $all ]]; then
    die 3 $" You cannot specify an arch and also specify" \
	$"--all on the command line."
fi

# Run the specified action
for action_to_run in $action; do
    setup_kernels_arches "$action_to_run"
    case "$action_to_run" in
	remove)       check_root && remove_module;;
	install)      check_root && install_modules;;
	autoinstall)  check_root && autoinstall;;
	match)        check_root && have_one_kernel && run_match;;
	uninstall)    check_root && have_one_kernel && uninstall_module;;
	mkdriverdisk) check_root && make_driver_disk;;
	build)        build_modules;;
	add)          add_module;;
	mktarball)    make_tarball;;
	mkrpm)        make_rpm;;
	mkdeb)        make_debian "deb";;
	mkdsc)        make_debian "dsc";;
	mkkmp)        have_one_kernel && make_kmp;;
	status)       show_status;;
	ldtarball) # Make sure they're root if we're using --force
	    if ((UID != 0)) && [[ $force = true ]]; then
		die 1 $"You must be root to use this command with the --force option."
	    fi
	    load_tarball && add_module;;
	'') error $"No action was specified."
	    show_usage;;
	*)  error $"Unknown action specified: $action_to_run"
	    show_usage;;
    esac
done
                                                                                                                                  usr/sbin/ip6tables-apply                                                                            0120777 0000000 0000000 00000000000 12427446353 016632  2iptables-apply                                                                                      ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/sbin/iptables-apply                                                                             0100755 0000000 0000000 00000015550 12427446263 013705  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/bash
# iptables-apply -- a safer way to update iptables remotely
#
# Usage:
#   iptables-apply [-hV] [-t timeout] [-w savefile] {[rulesfile]|-c [runcmd]}
#
# Versions:
#   * 1.0 Copyright 2006 Martin F. Krafft <madduck@madduck.net>
#         Original version
#   * 1.1 Copyright 2010 GW <gw.2010@tnode.com or http://gw.tnode.com/>
#         Added parameter -c (run command)
#         Added parameter -w (save successfully applied rules to file)
#         Major code cleanup
#
# Released under the terms of the Artistic Licence 2.0
#
set -eu

PROGNAME="${0##*/}"
VERSION=1.1


### Default settings

DEF_TIMEOUT=10

MODE=0  # apply rulesfile mode
# MODE=1  # run command mode

case "$PROGNAME" in
	(*6*)
		SAVE=ip6tables-save
		RESTORE=ip6tables-restore
		DEF_RULESFILE="/etc/network/ip6tables.up.rules"
		DEF_SAVEFILE="$DEF_RULESFILE"
		DEF_RUNCMD="/etc/network/ip6tables.up.run"
		;;
	(*)
		SAVE=iptables-save
		RESTORE=iptables-restore
		DEF_RULESFILE="/etc/network/iptables.up.rules"
		DEF_SAVEFILE="$DEF_RULESFILE"
		DEF_RUNCMD="/etc/network/iptables.up.run"
		;;
esac


### Functions

function blurb() {
	cat <<-__EOF__
	$PROGNAME $VERSION -- a safer way to update iptables remotely
	__EOF__
}

function copyright() {
	cat <<-__EOF__
	$PROGNAME has been published under the terms of the Artistic Licence 2.0.

	Original version - Copyright 2006 Martin F. Krafft <madduck@madduck.net>.
	Version 1.1 - Copyright 2010 GW <gw.2010@tnode.com or http://gw.tnode.com/>.
	__EOF__
}

function about() {
	blurb
	echo
	copyright
}

function usage() {
	blurb
	echo
	cat <<-__EOF__
	Usage:
	  $PROGNAME [-hV] [-t timeout] [-w savefile] {[rulesfile]|-c [runcmd]}

	The script will try to apply a new rulesfile (as output by iptables-save,
	read by iptables-restore) or run a command to configure iptables and then
	prompt the user whether the changes are okay. If the new iptables rules cut
	the existing connection, the user will not be able to answer affirmatively.
	In this case, the script rolls back to the previous working iptables rules
	after the timeout expires.

	Successfully applied rules can also be written to savefile and later used
	to roll back to this state. This can be used to implement a store last good
	configuration mechanism when experimenting with an iptables setup script:
	  $PROGNAME -w $DEF_SAVEFILE -c $DEF_RUNCMD

	When called as ip6tables-apply, the script will use ip6tables-save/-restore
	and IPv6 default values instead. Default value for rulesfile is
	'$DEF_RULESFILE'.

	Options:

	-t seconds, --timeout seconds
	  Specify the timeout in seconds (default: $DEF_TIMEOUT).
	-w savefile, --write savefile
	  Specify the savefile where successfully applied rules will be written to
	  (default if empty string is given: $DEF_SAVEFILE).
	-c runcmd, --command runcmd
	  Run command runcmd to configure iptables instead of applying a rulesfile
	  (default: $DEF_RUNCMD).
	-h, --help
	  Display this help text.
	-V, --version
	  Display version information.

	__EOF__
}

function checkcommands() {
	for cmd in "${COMMANDS[@]}"; do
		if ! command -v "$cmd" >/dev/null; then
			echo "Error: needed command not found: $cmd" >&2
			exit 127
		fi
	done
}

function revertrules() {
	echo -n "Reverting to old iptables rules... "
	"$RESTORE" <"$TMPFILE"
	echo "done."
}


### Parsing and checking parameters

TIMEOUT="$DEF_TIMEOUT"
SAVEFILE=""

SHORTOPTS="t:w:chV";
LONGOPTS="timeout:,write:,command,help,version";

OPTS=$(getopt -s bash -o "$SHORTOPTS" -l "$LONGOPTS" -n "$PROGNAME" -- "$@") || exit $?
for opt in $OPTS; do
	case "$opt" in
		(-*)
			unset OPT_STATE
			;;
		(*)
			case "${OPT_STATE:-}" in
				(SET_TIMEOUT) eval TIMEOUT=$opt;;
				(SET_SAVEFILE)
					eval SAVEFILE=$opt
					[ -z "$SAVEFILE" ] && SAVEFILE="$DEF_SAVEFILE"
					;;
			esac
			;;
	esac

	case "$opt" in
		(-t|--timeout) OPT_STATE="SET_TIMEOUT";;
		(-w|--write) OPT_STATE="SET_SAVEFILE";;
		(-c|--command) MODE=1;;
		(-h|--help) usage >&2; exit 0;;
		(-V|--version) about >&2; exit 0;;
		(--) break;;
	esac
	shift
done

# Validate parameters
if [ "$TIMEOUT" -ge 0 ] 2>/dev/null; then
	TIMEOUT=$(($TIMEOUT))
else
	echo "Error: timeout must be a positive number" >&2
	exit 1
fi

if [ -n "$SAVEFILE" -a -e "$SAVEFILE" -a ! -w "$SAVEFILE" ]; then
	echo "Error: savefile not writable: $SAVEFILE" >&2
	exit 8
fi

case "$MODE" in
	(1)
		# Treat parameter as runcmd (run command mode)
		RUNCMD="${1:-$DEF_RUNCMD}"
		if [ ! -x "$RUNCMD" ]; then
			echo "Error: runcmd not executable: $RUNCMD" >&2
			exit 6
		fi

		# Needed commands
		COMMANDS=(mktemp "$SAVE" "$RESTORE" "$RUNCMD")
		checkcommands
		;;
	(*)
		# Treat parameter as rulesfile (apply rulesfile mode)
		RULESFILE="${1:-$DEF_RULESFILE}";
		if [ ! -r "$RULESFILE" ]; then
			echo "Error: rulesfile not readable: $RULESFILE" >&2
			exit 2
		fi

		# Needed commands
		COMMANDS=(mktemp "$SAVE" "$RESTORE")
		checkcommands
		;;
esac


### Begin work

# Store old iptables rules to temporary file
TMPFILE=`mktemp /tmp/$PROGNAME-XXXXXXXX`
trap "rm -f $TMPFILE" EXIT 1 2 3 4 5 6 7 8 10 11 12 13 14 15

if ! "$SAVE" >"$TMPFILE"; then
	# An error occured
	if ! grep -q ipt /proc/modules 2>/dev/null; then
		echo "Error: iptables support lacking from the kernel" >&2
		exit 3
	else
		echo "Error: unknown error saving old iptables rules: $TMPFILE" >&2
		exit 4
	fi
fi

# Legacy to stop the fail2ban daemon if present
[ -x /etc/init.d/fail2ban ] && /etc/init.d/fail2ban stop

# Configure iptables
case "$MODE" in
	(1)
		# Run command in background and kill it if it times out
		echo -n "Running command '$RUNCMD'... "
		"$RUNCMD" &
		CMD_PID=$!
		( sleep "$TIMEOUT"; kill "$CMD_PID" 2>/dev/null; exit 0 ) &
		CMDTIMEOUT_PID=$!
		if ! wait "$CMD_PID"; then
			echo "failed."
			echo "Error: unknown error running command: $RUNCMD" >&2
			revertrules
			exit 7
		else
			echo "done."
		fi
		;;
	(*)
		# Apply iptables rulesfile
		echo -n "Applying new iptables rules from '$RULESFILE'... "
		if ! "$RESTORE" <"$RULESFILE"; then
			echo "failed."
			echo "Error: unknown error applying new iptables rules: $RULESFILE" >&2
			revertrules
			exit 5
		else
			echo "done."
		fi
		;;
esac

# Prompt user for confirmation
echo -n "Can you establish NEW connections to the machine? (y/N) "

read -n1 -t "$TIMEOUT" ret 2>&1 || :
case "${ret:-}" in
	(y*|Y*)
		# Success
		echo

		if [ ! -z "$SAVEFILE" ]; then
			# Write successfully applied rules to the savefile
			echo "Writing successfully applied rules to '$SAVEFILE'..."
			if ! "$SAVE" >"$SAVEFILE"; then
				echo "Error: unknown error writing successfully applied rules: $SAVEFILE" >&2
				exit 9
			fi
		fi

		echo "... then my job is done. See you next time."
		;;
	(*)
		# Failed
		echo
		if [ -z "${ret:-}" ]; then
			echo "Timeout! Something happened (or did not). Better play it safe..."
		else
			echo "No affirmative response! Better play it safe..."
		fi
		revertrules
		exit 255
		;;
esac

# Legacy to start the fail2ban daemon again
[ -x /etc/init.d/fail2ban ] && /etc/init.d/fail2ban start

exit 0

# vim:noet:sw=8
                                                                                                                                                        usr/sbin/mkinitramfs                                                                                0100755 0000000 0000000 00000022576 12704740230 013276  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh

umask 0022
export PATH='/usr/bin:/sbin:/bin'

# Defaults
keep="n"
CONFDIR="/etc/initramfs-tools"
verbose="n"
test -e /bin/busybox && BUSYBOXDIR=/bin
test -e /usr/lib/initramfs-tools/bin/busybox && BUSYBOXDIR=/usr/lib/initramfs-tools/bin
export BUSYBOXDIR

OPTIONS=`getopt -o c:d:ko:r:v -n "$0" -- "$@"`

# Check for non-GNU getopt
if [ $? != 0 ] ; then echo "W: non-GNU getopt" >&2 ; exit 1 ; fi

eval set -- "$OPTIONS"

while true; do
	case "$1" in
	-c)
		compress="$2"
		shift 2
		;;
	-d)
		CONFDIR="$2"
		shift 2
		if [ ! -d "${CONFDIR}" ]; then
			echo "${0}: ${CONFDIR}: Not a directory" >&2
			exit 1
		fi
		;;
	-o)
		outfile="$2"
		shift 2
		;;
	-k)
		keep="y"
		shift
		;;
	-r)
		ROOT="$2"
		shift 2
		;;
	-v)
		verbose="y"
		shift
		;;
	--)
		shift
		break
		;;
	*)
		echo "Internal error!" >&2
		exit 1
		;;
	esac
done

# For dependency ordered mkinitramfs hook scripts.
. /usr/share/initramfs-tools/scripts/functions
. /usr/share/initramfs-tools/hook-functions

. "${CONFDIR}/initramfs.conf"
EXTRA_CONF=''
for i in /usr/share/initramfs-tools/conf.d/* ${CONFDIR}/conf.d/*; do
	[ -e $i ] && EXTRA_CONF="${EXTRA_CONF} $(basename $i \
		| grep '^[[:alnum:]][[:alnum:]\._-]*$' | grep -v '\.dpkg-.*$')";
done
# FIXME: deprecated those settings on mkinitramfs run
# 	 these conf dirs are for boot scripts and land on initramfs
for i in ${EXTRA_CONF}; do
	if [ -d  ${CONFDIR}/conf.d/${i} ]; then
		echo "Warning: ${CONFDIR}/conf.d/${i} is a directory instead of file, ignoring."
	elif [ -e  ${CONFDIR}/conf.d/${i} ]; then
		. ${CONFDIR}/conf.d/${i}
	elif [ -e  /usr/share/initramfs-tools/conf.d/${i} ]; then
		. /usr/share/initramfs-tools/conf.d/${i}
	fi
done

# source package confs
for i in /usr/share/initramfs-tools/conf-hooks.d/*; do
	if [ -d "${i}" ]; then
		echo "Warning: ${i} is a directory instead of file, ignoring."
	elif [ -e "${i}" ]; then
		. "${i}"
	fi
done

if [ -n "${UMASK:-}" ]; then
	umask "${UMASK}"
fi

if [ -z "${outfile}" ]; then
	usage
fi

touch "$outfile"
outfile="$(readlink -f "$outfile")"

# And by "version" we really mean path to kernel modules
# This is braindead, and exists to preserve the interface with mkinitrd
if [ ${#} -ne 1 ]; then
	version="$(uname -r)"
else
	version="${1}"
fi

case "${version}" in
/lib/modules/*/[!/]*)
	;;
/lib/modules/[!/]*)
	version="${version#/lib/modules/}"
	version="${version%%/*}"
	;;
esac

case "${version}" in
*/*)
	echo "$PROG: ${version} is not a valid kernel version" >&2
	exit 1
	;;
esac

# Check userspace and kernel support for compressed initramfs images
if [ -z "${compress:-}" ]; then
	compress=${COMPRESS}
else
	COMPRESS=${compress}
fi

if ! command -v "${compress}" >/dev/null 2>&1; then
	compress=gzip
	[ "${verbose}" = y ] && \
		echo "No ${COMPRESS} in ${PATH}, using gzip"
	COMPRESS=gzip
fi

if dpkg --compare-versions "${version}" lt "2.6.38" 2>/dev/null; then
	compress=gzip
	[ "${verbose}" = y ] && \
		echo "linux-2.6 likely misses ${COMPRESS} support, using gzip"
fi

[ "${compress}" = lzop ] && compress="lzop -9"
[ "${compress}" = xz ] && compress="xz --check=crc32"

if [ -d "${outfile}" ]; then
	echo "${outfile} is a directory" >&2
	exit 1
fi

MODULESDIR="/lib/modules/${version}"

if [ ! -e "${MODULESDIR}" ]; then
	echo "WARNING: missing ${MODULESDIR}"
	echo "Ensure all necessary drivers are built into the linux image!"
fi
if [ ! -e "${MODULESDIR}/modules.dep" ]; then
	depmod ${version}
fi

[ -n "${TMPDIR}" ] && [ ! -w "${TMPDIR}" ] && unset TMPDIR
DESTDIR="$(mktemp -d ${TMPDIR:-/var/tmp}/mkinitramfs_XXXXXX)" || exit 1
chmod 755 "${DESTDIR}"

__TMPCPIOGZ="$(mktemp ${TMPDIR:-/var/tmp}/mkinitramfs-OL_XXXXXX)" || exit 1
__TMPEARLYCPIO="$(mktemp ${TMPDIR:-/var/tmp}/mkinitramfs-FW_XXXXXX)" || exit 1

DPKG_ARCH=`dpkg --print-architecture`

# Export environment for hook scripts.
#
export MODULESDIR
export version
export CONFDIR
export DESTDIR
export DPKG_ARCH
export verbose
export KEYMAP
export MODULES
export BUSYBOX

# Private, used by 'catenate_cpiogz'.
export __TMPCPIOGZ

# Private, used by 'prepend_earlyinitramfs'.
export __TMPEARLYCPIO

for d in bin conf/conf.d etc lib/modules run sbin scripts ${MODULESDIR}; do
	mkdir -p "${DESTDIR}/${d}"
done

# Copy in modules.builtin and modules.order (not generated by depmod)
for x in modules.builtin modules.order; do
	if [ -f "${MODULESDIR}/${x}" ]; then
		cp -p "${MODULESDIR}/${x}" "${DESTDIR}${MODULESDIR}/${x}"
	fi
done

# MODULES=list case.  Always honour.
for x in "${CONFDIR}/modules" /usr/share/initramfs-tools/modules.d/*; do
	if [ -f "${x}" ]; then
		add_modules_from_file "${x}"
	fi
done

# MODULES=most is default
case "${MODULES}" in
dep)
	dep_add_modules
	;;
most)
	auto_add_modules
	;;
netboot)
	auto_add_modules base
	auto_add_modules net
	;;
list)
	# nothing to add
	;;
*)
	echo "W: mkinitramfs: unsupported MODULES setting: ${MODULES}."
	echo "W: mkinitramfs: Falling back to MODULES=most."
	auto_add_modules
	;;
esac

# Resolve hidden dependencies
hidden_dep_add_modules

# First file executed by linux
cp -p /usr/share/initramfs-tools/init ${DESTDIR}/init

# add existant boot scripts
for b in $(cd /usr/share/initramfs-tools/scripts/ && find . \
	-regextype posix-extended -regex '.*/[[:alnum:]\._-]+$' -type f); do
	[ -d "${DESTDIR}/scripts/$(dirname "${b}")" ] \
		|| mkdir -p "${DESTDIR}/scripts/$(dirname "${b}")"
	cp -p "/usr/share/initramfs-tools/scripts/${b}" \
		"${DESTDIR}/scripts/$(dirname "${b}")/"
done
for b in $(cd "${CONFDIR}/scripts" && find . \
	-regextype posix-extended -regex '.*/[[:alnum:]\._-]+$' -type f); do
	[ -d "${DESTDIR}/scripts/$(dirname "${b}")" ] \
		|| mkdir -p "${DESTDIR}/scripts/$(dirname "${b}")"
	cp -p "${CONFDIR}/scripts/${b}" "${DESTDIR}/scripts/$(dirname "${b}")/"
done

echo "DPKG_ARCH=${DPKG_ARCH}" > ${DESTDIR}/conf/arch.conf
cp -p "${CONFDIR}/initramfs.conf" ${DESTDIR}/conf
for i in ${EXTRA_CONF}; do
	if [ -e "${CONFDIR}/conf.d/${i}" ]; then
		copy_exec "${CONFDIR}/conf.d/${i}" /conf/conf.d
	elif [ -e "/usr/share/initramfs-tools/conf.d/${i}" ]; then
		copy_exec "/usr/share/initramfs-tools/conf.d/${i}" /conf/conf.d
	fi
done

# ROOT hardcoding
if [ -n "${ROOT:-}" ]; then
	echo "ROOT=${ROOT}" > ${DESTDIR}/conf/conf.d/root
fi

if ! command -v ldd >/dev/null 2>&1 ; then
	echo "WARNING: no ldd around - install libc-bin" >&2
	exit 1
fi

# fstab and mtab
touch "${DESTDIR}/etc/fstab"
ln -s /proc/mounts "${DESTDIR}/etc/mtab"

# module-init-tools
copy_exec /sbin/modprobe /sbin
copy_exec /sbin/rmmod /sbin
mkdir -p "${DESTDIR}/etc/modprobe.d"
cp -a /etc/modprobe.d/* "${DESTDIR}/etc/modprobe.d/"

# workaround: libgcc always needed on old-abi arm
if [ "$DPKG_ARCH" = arm ] || [ "$DPKG_ARCH" = armeb ]; then
	cp -a /lib/libgcc_s.so.1 "${DESTDIR}/lib/"
fi

run_scripts /usr/share/initramfs-tools/hooks
run_scripts "${CONFDIR}"/hooks

# cache boot run order
for b in $(cd "${DESTDIR}/scripts" && find . -mindepth 1 -type d); do
	cache_run_scripts "${DESTDIR}" "/scripts/${b#./}"
done

# generate module deps
depmod -a -b "${DESTDIR}" ${version}
rm -f "${DESTDIR}/lib/modules/${version}"/modules.*map

# make sure that library search path is up to date
cp -ar /etc/ld.so.conf* "$DESTDIR"/etc/
if ! ldconfig -r "$DESTDIR" ; then
	[ $(id -u) != "0" ] \
	&& echo "ldconfig might need uid=0 (root) for chroot()" >&2
fi

# Apply DSDT to initramfs
if [ -e "${CONFDIR}/DSDT.aml" ]; then
	copy_exec "${CONFDIR}/DSDT.aml" /
fi

# Make sure there is a final sh in initramfs
if [ ! -e "${DESTDIR}/bin/sh" ]; then
	copy_exec /bin/sh "${DESTDIR}/bin/"
fi

# Remove any looping or broken symbolic links, since they break cpio.
[ "${verbose}" = y ] && xargs_verbose="-t"
(cd "${DESTDIR}" && find . -type l -printf '%p %Y\n' | sed -n 's/ [LN]$//p' \
	| xargs ${xargs_verbose:-} -rL1 rm -f)

# dirty hack for armhf's double-linker situation; if we have one of
# the two known eglibc linkers, nuke both and re-create sanity
if [ "$DPKG_ARCH" = armhf ]; then
	if [ -e "${DESTDIR}/lib/arm-linux-gnueabihf/ld-linux.so.3" ] || \
	   [ -e "${DESTDIR}/lib/ld-linux-armhf.so.3" ]; then
		rm -f "${DESTDIR}/lib/arm-linux-gnueabihf/ld-linux.so.3"
		rm -f "${DESTDIR}/lib/ld-linux-armhf.so.3"
		cp -aL /lib/ld-linux-armhf.so.3 "${DESTDIR}/lib/"
		ln -sf /lib/ld-linux-armhf.so.3 "${DESTDIR}/lib/arm-linux-gnueabihf/ld-linux.so.3"
	fi
fi

[ "${verbose}" = y ] && echo "Building cpio ${outfile} initramfs"

if [ -s "${__TMPEARLYCPIO}" ]; then
	cat "${__TMPEARLYCPIO}" >"${outfile}" || exit 1
else
	# truncate
	> "${outfile}"
fi

(
# preserve permissions if root builds the image, see #633582
[ "$(id -ru)" != 0 ] && cpio_owner_root="-R 0:0"

# work around lack of "set -o pipefail" for the following pipe:
# cd "${DESTDIR}" && find . | cpio --quiet $cpio_owner_root -o -H newc | gzip >>"${outfile}" || exit 1
exec 3>&1
eval `
	# http://cfaj.freeshell.org/shell/cus-faq-2.html
	exec 4>&1 >&3 3>&-
	cd  "${DESTDIR}"
	{
		find . 4>&-; echo "ec1=$?;" >&4
	} | {
		cpio --quiet $cpio_owner_root -o -H newc 4>&-; echo "ec2=$?;" >&4
	} | ${compress} >>"${outfile}"
	echo "ec3=$?;" >&4
`
if [ "$ec1" -ne 0 ]; then
	echo "E: mkinitramfs failure find $ec1 cpio $ec2 $compress $ec3"
	exit "$ec1"
fi
if [ "$ec2" -ne 0 ]; then
	echo "E: mkinitramfs failure cpio $ec2 $compress $ec3"
	exit "$ec2"
fi
if [ "$ec3" -ne 0 ]; then
	echo "E: mkinitramfs failure $compress $ec3"
	exit "$ec3"
fi
) || exit 1

if [ -s "${__TMPCPIOGZ}" ]; then
	cat "${__TMPCPIOGZ}" >>"${outfile}" || exit 1
fi

if [ "${keep}" = "y" ]; then
	echo "Working files in ${DESTDIR}, early initramfs in ${__TMPEARLYCPIO} and overlay in ${__TMPCPIOGZ}"
else
	rm -rf "${DESTDIR}"
	rm -rf "${__TMPCPIOGZ}"
	rm -rf "${__TMPEARLYCPIO}"
fi

exit 0
                                                                                                                                  usr/sbin/nfnl_osf                                                                                   0100755 0000000 0000000 00000034270 12427446356 012566  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF          >    ∑@     @       ¯1          @ 8 	 @         @       @ @     @ @     ¯      ¯                   8      8@     8@                                          @       @     ú!      ú!                     .       .`      .`           H                    .      .`     .`     ‡      ‡                   T      T@     T@     D       D              PÂtd   D      D@     D@     T       T              QÂtd                                                  RÂtd    .       .`      .`                          /lib64/ld-linux-x86-64.so.2          GNU                        GNU ÿf=†èöﬁ„}•O%µhK-4≥            àE  
       "   (åBE’Ïª„í|ÿqX9Úã≥¢˜                                                 *                     Y                      Ø                      ù                      H                      6                      (                      ‹                      É                      #                     d                                          R                     ©                                            9                     Ö                      A                     |                      î                      h                      ¿                      „                                            «                      I                     Î                      ’     1`            m    1`             Ä    H1`             t    1`                   1`            ˘     1`             libnfnetlink.so.0 nfnl_talk nfnl_close nfnl_fill_hdr nfnl_subsys_close nfnl_subsys_open nfnl_addattr_l nfnl_open libc.so.6 fflush __stack_chk_fail strftime localtime_r fgets __errno_location getopt __fprintf_chk stdout fclose strtoul __ctype_b_loc optarg stderr __snprintf_chk gettimeofday strchr __vfprintf_chk syscall fopen64 strerror __libc_start_main snprintf _edata __bss_start _end __gmon_start__ GLIBC_2.3 GLIBC_2.4 GLIBC_2.2.5 GLIBC_2.3.4                                                 r          ii   î     ii   û     ui	   ®     ti	   ¥      ¯/`                   1`                   1`        "            1`        !           0`                    0`                   (0`                   00`                   80`                   @0`                   H0`                   P0`                   X0`        	           `0`        
           h0`                   p0`                   x0`                   Ä0`                   à0`                   ê0`                   ò0`                   †0`                   ®0`                   ∞0`                   ∏0`                   ¿0`                   »0`                   –0`                   ÿ0`                   ‡0`                   Ë0`                   0`                   HÉÏHãu$  HÖ¿tË3  HÉƒ√              ˇ5b$  ˇ%d$  @ ˇ%b$  h    È‡ˇˇˇˇ%Z$  h   È–ˇˇˇˇ%R$  h   È¿ˇˇˇˇ%J$  h   È∞ˇˇˇˇ%B$  h   È†ˇˇˇˇ%:$  h   Èêˇˇˇˇ%2$  h   ÈÄˇˇˇˇ%*$  h   Èpˇˇˇˇ%"$  h   È`ˇˇˇˇ%$  h	   ÈPˇˇˇˇ%$  h
   È@ˇˇˇˇ%
$  h   È0ˇˇˇˇ%$  h   È ˇˇˇˇ%˙#  h   Èˇˇˇˇ%Ú#  h   È ˇˇˇˇ%Í#  h   È˛ˇˇˇ%‚#  h   È‡˛ˇˇˇ%⁄#  h   È–˛ˇˇˇ%“#  h   È¿˛ˇˇˇ% #  h   È∞˛ˇˇˇ%¬#  h   È†˛ˇˇˇ%∫#  h   Èê˛ˇˇˇ%≤#  h   ÈÄ˛ˇˇˇ%™#  h   Èp˛ˇˇˇ%¢#  h   È`˛ˇˇˇ%ö#  h   ÈP˛ˇˇˇ%í#  h   È@˛ˇˇˇ%ä#  h   È0˛ˇˇAUATE1ÌUSâ˝HâÛE1‰HÉÏ∫1@ HâﬁâÔË|ˇˇˇÉ¯ˇtRÉ¯dtÉ¯fuLã%n#  ÎŸ@ AΩ   ÎÕÑ     HãHã=V#  ∫†@ æ   1¿Ëeˇˇˇ∏ˇˇˇˇHÉƒ[]A\A]√MÖ‰∞˛tÓË	ˇˇˇHÖ¿Hâ?#  te1…∫   æ   Hâ«ËÈ˝ˇˇHÖ¿Hâ#  tnLâÁDâÓËR  Ö¿â√Hã=ˇ"  tË–˝ˇˇHã=˘"  ËT˛ˇˇâÿÎêËª˝ˇˇHã=‰"  Ë?˛ˇˇ1¿ÈxˇˇˇËs˝ˇˇãâﬂË⁄˛ˇˇâ⁄Hâ∆ø–@ 1¿Ë9  ∏ÍˇˇˇÈOˇˇˇËJ˝ˇˇãâﬂË±˛ˇˇâ⁄Hâ∆ø @ 1¿ªÍˇˇˇË  Îâ1ÌIâ—^Hâ‚HÉ‰PTI«¿‡@ H«¡p@ H««p@ Ë†˝ˇˇÙf.Ñ     D  ∏1` UH-1` HÉ¯HâÂv∏    HÖ¿t]ø1` ˇ‡fÑ     ]√fffff.Ñ     æ1` UHÅÓ1` H¡˛HâÂHâH¡Ë?H∆H—˛t∏    HÖ¿t]ø1` ˇ‡ ]√fD  Ä=±!   uUHâÂËnˇˇˇ]∆û!  Û√@ ø.` HÉ? uÎì ∏    HÖ¿tÒUHâÂˇ–]Èzˇˇˇf.Ñ     HÅÏÿ   Ñ¿Hât$(HâT$0HâL$8LâD$@LâL$Ht7)D$P)L$`)T$p)ú$Ä   )§$ê   )¨$†   )¥$∞   )º$¿   Hâ˙dHã%(   HâD$1¿Hã=˚   HÖˇtWHçÑ$‡   Hâ·æ   «$   «D$0   HâD$HçD$ HâD$ËS˚ˇˇHã=º   Ëg¸ˇˇHãD$dH3%(   uHÅƒÿ   √Hã=x   Hâ=ë   ÎôËö˚ˇˇf.Ñ     USHÅÏx  Ñ¿Hâ¥$»   Hâî$–   Hâå$ÿ   LâÑ$‡   Lâå$Ë   t@)Ñ$   )å$   )î$  )ú$   )§$0  )¨$@  )¥$P  )º$`  dHã%(   HâÑ$∏   1¿Hâ˝HãÓ  HÖ€ÑÕ   1ˆHâÁË˚ˇˇHçt$0HâÁËé˙ˇˇHçL$0Hç|$p∫@ æ@   Ëu˚ˇˇø∫   1¿Ë)˚ˇˇLãD$HçL$pIâ¡∫@ æ   Hâﬂ1¿Ëò˚ˇˇHçÑ$ê  Hã=y  HçL$HâÍæ   «D$   HâD$ HçÑ$¿   «D$0   HâD$(Ë’˘ˇˇHã=>  ËÈ˙ˇˇHãÑ$∏   dH3%(   u!HÅƒx  []√@ HãÒ  Hâ
  È ˇˇˇË˙ˇˇS@æˆË˙ˇˇHÖ¿t4Hâ√∆  HÉ√t(Ë˚ˇˇHãÎ HâÿHÉ¿tHâ√HæHçCˇˆDQ uÂ[√ Hâÿ[√ AWAVAUATUSHâ˚HÅÏx	  ât$æ@ dHã%(   HâÑ$h	  1¿Ë˙ˇˇHÖ¿HâD$Ñy  HçÑ$ê   Hç¨$`  Hçú$p  HâD$HãT$æ   HâÔËû˘ˇˇHÖ¿Ñ]  ∂î$`  Ä˙
î¡Ä˙#î¿	»Ä˙î¬–u≈IâËAãIÉ¿çÇˇ˛˛˛˜“!–%ÄÄÄÄtËâ¬¡Í©ÄÄ  D¬IçPLD¬ ¿IÉÿI)ËAÉËEÖ¿~ÉIc¿Hç|$ πJ   ∆Ñ`   1¿HâÓÛH´ø@ DâD$Ë'˝ˇˇDãD$HâË1…1“ ∂0@Ñˆt@Ä˛:@î∆É¡HÉ¿@∂ˆÚA9»ﬁÉ˙Ö`  1¿π   HâﬂÛH´æ:   HâÔËS˛ˇˇHÖ¿Iâ∆Ñ  ∆  D∂º$`  AÄˇSÑÒ  AÄˇTÑ¡  AÄˇ%Ñ  ËH˘ˇˇHã Iæ◊ˆDPÖŸ  IÉ∆æ:   Lâ˜Ëı˝ˇˇHÖ¿Iâ«tLâ˜∆  ∫
   1ˆMçwË«¯ˇˇàD$(æ:   Lâ˜Ë∆˝ˇˇHÖ¿Iâ«tLâ˜∆  ∫
   1ˆMçwËò¯ˇˇàD$)æ:   Lâ˜Ëó˝ˇˇHÖ¿Iâ«tLâ˜∆  ∫
   1ˆMçwËi¯ˇˇfâD$*æ:   Lâ˜Ëg˝ˇˇHÖ¿Iâ«t)MâÒMçw∆  A∏*@ πÄ   ∫   æÄ   Hâﬂ1¿Ë∂ˆˇˇæ:   Lâ˜Ë)˝ˇˇHÖ¿Iâ«t4∆  A∂<*ÑÚ  <@ÑÍ  Hç|$0LâÒ∫.@ æ    1¿Ë!˜ˇˇMçwæ:   Lâ˜Ë‡¸ˇˇHÖ¿Iâ«t LâÒHç|$PMçw∆  ∫.@ æ    1¿ËËˆˇˇæ:   Lâ˜Ë´¸ˇˇHÖ¿tHç|$p∆  LâÒ∫.@ æ    1¿Ë∫ˆˇˇIâﬁE1ˇ@ AÄ> Ñ˚   McÔæ,   Nç$+A∂$LâÁÉËE<áÁ  ∂¿ˇ$≈@@ D  ËC¸ˇˇHÖ¿Iâ∆ÑG  Jç|+∂<SÑó  <TÑœ  <%Ñ∑  A∆ ∫
   1ˆË˜ˆˇˇIÉ∆E1“LâÚL)‚A◊AÉˇ@û∆MÖˆï¬!÷∫   fê∑|$.HçRHãL$D∑ï @ ∑ï@ Hç<fDâåºê   ∑|$.Hç<fâîºí   ∑|$.Hâ˙Hç<É¬Hç<πDâWâGfâT$.@ÑˆÖ˚˛ˇˇHçº$  1¿πM   ÛH´ã|$ÖˇÑ%  HÉÏAπ   jHã=R  Hç¥$   E1¿1…1“Ë&ıˇˇXZA∏P  ∫   æh  HçL$ Hçº$  Ë≤ÙˇˇHÉÏHã=  1…j 1“E1…E1¿Hç¥$   ËÓıˇˇÖ¿â¬Y^Ö  πÄ   1¿HâÔÛH´ÈÄ˚ˇˇËÀ˙ˇˇHÖ¿Iâ∆Ñˇ  IÉ∆∆  ∫   LâL)‡A«AÉˇ@û∆MÖˆï¿E1“!∆1¿È∞˛ˇˇËã˙ˇˇHÖ¿Iâ∆Ñ◊  IÉ∆∆  ∫   LâL)‡A«AÉˇ@û∆MÖˆï¿E1“!∆1¿Èp˛ˇˇËK˙ˇˇHÖ¿Iâ∆ÑØ  IÉ∆∆  ∫   LâL)‡A«AÉˇ@û∆MÖˆï¿E1“!∆1¿È0˛ˇˇË˙ˇˇHÖ¿Iâ∆Ñ'  Jç|+Ä?%ÑÒ   ∆  ∫
   1ˆË“ÙˇˇIÉ∆E1“LâÚL)‚A◊AÉˇ@û∆MÖˆï¬!÷∫   Èÿ˝ˇˇÑ     Ë´˘ˇˇHÖ¿Iâ∆Ñ'  IÉ∆∆  LâL)‡A«AÉˇ@û∆MÖˆï¿E1“1“!∆1¿Èì˝ˇˇ Ëk˘ˇˇHÖ¿Iâ∆Ñ‰˝ˇˇIÉ∆LâL)‡A«AÉˇ@û∆MÖˆï¿!∆Èπ˝ˇˇD  HÉÏE1…h  È÷˝ˇˇÄ    IçNHç|$0∫.@ æ    1¿Ë6ÛˇˇÈ¸ˇˇêJç|+∆  ∫
   1ˆIÉ∆ËÿÛˇˇA∫   ÈˇˇˇD  1“Hã|$âT$Ë»ÚˇˇãT$â–Hãú$h	  dH3%(   Ö·  HÅƒx	  []A\A]A^A_√fÑ     A∫   Jç|+A∆ ∫
   1ˆDâT$IÉ∆Ë\ÛˇˇDãT$Èb¸ˇˇfêA∫   ÎŒÑ     A∫   ÎæÑ     ∂Ñ$a  «D$    <%Ñ⁄   <*u«D$$    È˙ˇˇ«D$    Hç}∫
   1ˆËÔÚˇˇâD$$È˘ˇˇfD  AÉ«1ˆ1¿E1“∫   È˚˚ˇˇ AÉ«1ˆ1¿E1“∫   È„˚ˇˇ AÉ«1ˆ1¿E1“∫   ÈÀ˚ˇˇ AÉ«1ˆ1¿E1“∫   È≥˚ˇˇ AÉ«1ˆ1¿E1“∫   Èõ˚ˇˇ AÉ«1ˆ1¿E1“1“ÈÜ˚ˇˇ∂Ñ$a  «D$    <%Ö&ˇˇˇHç}∫
   1ˆË.ÚˇˇâD$$È/˘ˇˇIâÓÈ+˘ˇˇ∫
   1ˆHâÔ«D$     ËÚˇˇâD$$È˘ˇˇHâÓø`@ 1¿Ë~ıˇˇ∫ÍˇˇˇÈ˛ˇˇËüˇˇã(âÔËÚˇˇâÈHâ¬Hâﬁ1¿ø8@ ËbÙˇˇÉ»ˇÈ˛ˇˇË’ˇˇD  AWAâˇAVIâˆAUIâ’ATLç%x  UHç-x  SL)Â1€H¡˝HÉÏË’ÔˇˇHÖÌtÑ     LâÍLâˆDâˇAˇ‹HÉ√H9ÎuÍHÉƒ[]A\A]A^A_√ff.Ñ     Û√  HÉÏHÉƒ√                     %F %R:%S %s.%lu %ld  r Loading '%s'.
 %s, %s f:dh   Failed to open file '%s': %s [%d].
     Wrong input line '%s': cnt: %d, must be 8, i: %d, must be %d.
  Usage: %s -f fingerprints -d <del rules> -h
    Failed to create nfnl handler: %s [%d].
        Faied to create nfnl subsystem: %s [%d].
                       Ä@     ¿@     ¿@     ¿@     ¿@     ¿@     ¿@     ¿@      @     ‡@     ¿@     ¿@     ¿@     ¿@     †@     `@     ¿@     ¿@     Ë@                                                                                                                               
         	          
                                                                                                                                                                          ;P   	   \Ïˇˇú   ,Óˇˇ¥  sÔˇˇl   |ˇˇƒ   lÒˇˇ‰   ÏÚˇˇ  <Ûˇˇ4  ,¸ˇˇÙ  ú¸ˇˇ<         zR xê      ˇÓˇˇ*                  zR xê  $      ∏Îˇˇ–   FJwÄ ?;*3$"       D   ∞ÔˇˇÊ    G‡…
A    ,   d   ÄˇˇÄ   AÜAÉGêX
AAE      î   –ÒˇˇM    AÉC
DD|   ¥    ÚˇˇÎ   BèBéB çB(åA0ÜA8ÉJ∞C∏H¿\∏A∞f∏K¿Z∏A∞¥
∏H¿L|
8A0A(B BBBJ     <   4  pÏˇˇG   BçBåD ÜA(ÉL0_
(A ABBA     D   t  0˙ˇˇe    BèEéE çE(åH0ÜH8ÉM@l8A0A(B BBB    º  X˙ˇˇ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ê@     p@                                  r              x@            ‰@             .`                          .`                   ı˛ˇo    ò@             @            ÿ@     
       ¿                                           0`            †                           ÿ@            x@            `       	              ˛ˇˇo    (@     ˇˇˇo           ˇˇo    ‡@                                                                                                             .`                     ∂@     ∆@     ÷@     Ê@     ˆ@     @     @     &@     6@     F@     V@     f@     v@     Ü@     ñ@     ¶@     ∂@     ∆@     ÷@     Ê@     ˆ@     @     @     &@     6@     F@     V@     f@                      .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss                                                                               8@     8                                                 T@     T                                     !             t@     t      $                              4   ˆˇˇo       ò@     ò      <                             >             ÿ@     ÿ      H                          F              @            ¿                             N   ˇˇˇo       ‡@     ‡      F                            [   ˛ˇˇo       (@     (      P                            j             x@     x      `                            t      B       ÿ@     ÿ      †                          ~             x@     x                                    y             †@     †      –                            Ñ             p@     p      r                             ä             ‰@     ‰      	                              ê              @            D              @               ò             D@     D      T                              ¶             ò@     ò                                   ∞              .`      .                                    º             .`     .                                    »             .`     .                                    Õ             .`     .      ‡                           ÷             ¯/`     ¯/                                   €              0`      0      ¯                             ‰             ¯0`     ¯0                                    Í             1`     1      8                                                    1      Ô                                                                                                                                                                                                                                                                                                                                                                      usr/sbin/splat                                                                                      0100755 0000000 0000000 00000054220 13045367427 012100  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF          >    @     @       –Q          @ 8 	 @         @       @ @     @ @     ¯      ¯                   8      8@     8@                                          @       @     $E      $E                    N      N`     N`     –      ò                    (N      (N`     (N`     –      –                   T      T@     T@     D       D              PÂtd    =       =@      =@     T      T             QÂtd                                                  RÂtd   N      N`     N`                        /lib64/ld-linux-x86-64.so.2          GNU                       GNU ŒZÂ0àºÆ›bMm~}◊â                        )å9Úã3ƒ˜                        ‹                      =                                            ê                      ∫                      n                      !                      h                      6                      ä                      Ø                      N                                             ·                       /                      |                      ú                                            µ                      t                      ®                      S                      ¡                      a     ‡P`            É     Q`                  Q`             libc.so.6 fflush strncmp optind __assert_fail strtol memset __errno_location read __fprintf_chk stdout fputs lseek strtoul malloc stderr ioctl getopt_long strncasecmp fwrite close open strchr strerror __libc_start_main free __gmon_start__ GLIBC_2.3.4 GLIBC_2.2.5                                            ti	         ui	   ¸       ¯O`                   ‡P`                    Q`                   Q`                   P`                    P`                   (P`                   0P`                   8P`                   @P`                   HP`                   PP`                   XP`        	           `P`        
           hP`                   pP`                   xP`                   ÄP`                   àP`                   êP`                   òP`                   †P`                   ®P`                   ∞P`                   ∏P`                   ¿P`                   »P`                   HÉÏHã•F  HÖ¿tËÛ   HÉƒ√              ˇ5íF  ˇ%îF  @ ˇ%íF  h    È‡ˇˇˇˇ%äF  h   È–ˇˇˇˇ%ÇF  h   È¿ˇˇˇˇ%zF  h   È∞ˇˇˇˇ%rF  h   È†ˇˇˇˇ%jF  h   Èêˇˇˇˇ%bF  h   ÈÄˇˇˇˇ%ZF  h   Èpˇˇˇˇ%RF  h   È`ˇˇˇˇ%JF  h	   ÈPˇˇˇˇ%BF  h
   È@ˇˇˇˇ%:F  h   È0ˇˇˇˇ%2F  h   È ˇˇˇˇ%*F  h   Èˇˇˇˇ%"F  h   È ˇˇˇˇ%F  h   È˛ˇˇˇ%F  h   È‡˛ˇˇˇ%
F  h   È–˛ˇˇˇ%F  h   È¿˛ˇˇˇ%˙E  h   È∞˛ˇˇˇ%ÚE  h   È†˛ˇˇˇ%ÍE  h   Èê˛ˇˇˇ%‚E  h   ÈÄ˛ˇˇHçˇ1  PHç5J/  Hç=J/  ∫#  Ë–˛ˇˇAWAVAUATAâ¸ø`@ UHâıSHÉÏhËR  HÖ¿HâPF  Ñ√   1ˆ1¿ø+6@ ËTˇˇˇÉ¯ˇAâ¿â(F  Ñø  ∫@Q` 1¿π   Hâ◊æ@Q` ∫?   Û´Dâ«ËØ˛ˇˇÉ¯ˇtvËu  Ö¿Aâ≈ÑG  ã=‰E  ÉˇˇtËz˛ˇˇÉ¿Ñ4  EÖÌt^Hã=mE  HÖˇtËª˝ˇˇã=µE  ÉˇˇtËK˛ˇˇÉ¿Ñ’  Hã=£E  ËÊ  DâËHÉƒh[]A\A]A^A_√Aâ≈Îï∏   ÎÂHã|$0Ë>   AÉ¸Ñ5  ø    ËJ˛ˇˇHÖ¿Hâ√Ñ≠  1¿π   HâﬂÛ´«C   øê@ Ë1  HÖ¿HâCÑ6  LçkE1¿π@9@ ∫@:@ HâÓDâÁË8˝ˇˇÉ¯ˇÑÏ  ÉË?É¯9ág  ˇ$≈@7@ «C   Î√ÉÎæÉ{ ÖÈ  HcMD  æ:   Lã|≈¯LâˇË˚¸ˇˇHÖ¿Ñ  Lçp1“1ˆLâˇ∆  Ë˝ˇˇ1“1ˆLâ˜HâD$(Ën˝ˇˇHÉ…ˇHâD$8Lâˇ1¿æo6@ ÚÆLâˇH˜—HçQˇËj˝ˇˇÖ¿«D$0   Öˇ  1¿HÉ…ˇLâ˜ÚÆæo6@ Lâ˜H˜—HçQˇË;˝ˇˇÖ¿ÖR  Hã=4D  Ë◊  É|$0 HâD$(Ñ  Hã|$(Ë˝  HÖ¿Ñö  HãxXË´  HâD$0ÎHâ∆LâÔË˘  Ö¿ÖÆ   Hã|$0Ë«  HÖ¿uﬁHã|$0Ëò  ÎØ«C   Èö˛ˇˇ«C   Èé˛ˇˇË)  HâﬂË·  AÉÕˇÈÃ˝ˇˇ«C    Èl˛ˇˇHcC  Hã=C  ∫s6@ æ   HãL≈¯1¿Ë∏¸ˇˇÈC˛ˇˇËn˚ˇˇHã=ﬂB  Dã Hâ√π+6@ ∫∞3@ æ   1¿Ëã¸ˇˇDã+ÈI˝ˇˇHã|$0âD$8Ëı  ãD$8Hã|$(âD$0Ë„  ãD$0Hã=êB  MâLâ˘∫®4@ æ   Aâ¡1¿Ë>¸ˇˇHâﬂË&  È@ˇˇˇÉ|$8ˇÑ£˛ˇˇHã=◊B  Ëz  É|$0 HâD$(Ñ¥  «D$0    ÎLâˆHâ«Ë5  HÖ¿Öi  Hã|$(ËÇ  HÖ¿u›É|$0 uHã=B  MâLâ˘∫X4@ æ   Ë∫˚ˇˇHã|$(Ë0  È;˝ˇˇ1¿É|$(ˇî¿âD$0ÈÓ˝ˇˇIãxXËÔ  HâD$0ÎHâ∆LâÔË=  Ö¿ÖÚ˛ˇˇHã|$0Ë  HÖ¿uﬁHã|$0Ë‹  Hã|$(ËÚ  HÖ¿Iâ¿tê1¿HÉ…ˇLâˇÚÆLâ∆LâˇLâD$0H˜—HçQˇËÿ˙ˇˇÖ¿LãD$0u√ÎÖËÿ˘ˇˇHã=IA  Dã π+6@ ∫W6@ æ   1¿Ë¯˙ˇˇÈ¸ˇˇHçT$@π   æef¿Hâ◊Û´ã=âA  «D$@H7&«D$D   Ë˙ˇˇLcËEÖÌÖé  Lcl$LEÖÌàp˚ˇˇLâÔDâ-@  Ë;˙ˇˇHÖ¿HâÈ@  Ñê  1ˆLâÍHâ«ËÆ˘ˇˇø   Ë˙ˇˇHÖ¿Hâ√Ñm  1¿π   HâﬂÛ´Dã5A  «H7&Hâ⁄«C  æef¿Dâ˜Ëx˘ˇˇÖ¿Aâ≈Ö=  DãkHâﬂË—¯ˇˇAk›TÉ√Hc€HâﬂËØ˘ˇˇHÖ¿HâD$0Ñ  Hâ⁄1ˆHâ√Hâ«Ë!˘ˇˇDâk1¿«H7&«C  Hâ⁄æef¿Dâ˜Ë˘ˇˇÖ¿Aâ≈Ö®  HãD$0E1ÌãXLçpâ\$(ÎTø`   LâÛËA˘ˇˇHÖ¿Iâ«Ñ*  Hâ«Lâˆπ   Û•øê@ MçvTË*  HÖ¿IâGXÑ¯  Hã=@  Lâ˛AÉ≈ËJ  D9l$(•Hã|$0Ë˘˜ˇˇHã=˙?  Ëù  HâD$0Hã|$0ËŒ  HÖ¿Iâ«ÑZ˙ˇˇø   Ë∏¯ˇˇHÖ¿Iâ∆Ñ´  Hâ«π   1¿Û´ã™?  A«H7&LâÚA«F  æef¿AãGPâﬂAâF1¿Ë¯ˇˇÖ¿Aâ≈Ö  EãnLâ˜Ëk˜ˇˇMcıMkˆTIÉ∆Lâ˜ËH¯ˇˇHÖ¿HâD$8Ñ9  LâÚ1ˆIâ∆Hâ«Ë∫˜ˇˇA«H7&A«F  LâÚAãGPæef¿EânâﬂAâF1¿Ëû˜ˇˇÖ¿Aâ≈Öô  HãD$8E1ÌãXâ\$(HçXÎ;ø`   IâﬁHÉ√TËÕ˜ˇˇHÖ¿Ñû  LâxXHâ«Lâˆπ   AÉ≈Û•Hâ∆IãXËÛ  D9l$(æHã|$8Ë¢ˆˇˇÈµ˛ˇˇË®ˆˇˇHã=>  Dã π+6@ ∫W6@ æ   1¿Ë»˜ˇˇÈ¢¯ˇˇË~ˆˇˇHã=Ô=  Dãπef¿EãF∫Â5@ æ   1¿Ëö˜ˇˇLâ˜ËBˆˇˇHã|$0Ë  ÈI¯ˇˇHâ∆LâÔË8	  Ö¿Öˇ˙ˇˇ«D$0   Èw˚ˇˇÉ; tHã5g=  ø@Q` ËmˆˇˇÉ{ Ö¨  É{ tjHã=Ó=  LçcËç  Iâ∆Lâ˜Ë¬  HÖ¿tBHãxXËt  Hâ≈ÎÄ    Hâ∆LâÁËΩ  Ö¿Aâ≈ÖF  HâÔËä  HÖ¿u›HâÔË]  Î±Lâ˜ËS  Hã‹<  ∫R   æ   ø(5@ Ë®ˆˇˇHã{Ë  Iâ∆@ Lâ˜Ë@  HÖ¿IâƒÑÿ  Mãl$XË∫  ø   Ë ˆˇˇHÖ¿Hâ≈Ñ„  H«     H«@    MâË« ¿øÆùAãEPAπ   Hã=[<  π   ∫∏6@ æ   âEAãD$P«E    âE1¿Lâ$$ËˆˇˇHã=(<  Ë”ıˇˇã=Ω<  1¿HâÍæff¿Ë>ıˇˇAâ≈ãCÖ¿Ñ√   EÖÌÖ˘   A∏á6@ π6@ Hã=Â;  ∫¬6@ æ   1¿ËƒıˇˇHã=Õ;  ËxıˇˇHâÔË`ÙˇˇÉ;Ñè   ~PãÔ;  Hã5;  ã=B<  çPˇHc“ËÁÙˇˇÖ¿Iâ≈xvHã=â;  Hã ;  ∫Â6@ æ   1¿ËaıˇˇHã=j;  ËıˇˇEÖÌÑ§˛ˇˇÉ{ Ñö˛ˇˇLâ˜Ë∫  HâﬂË"  ÈˆˇˇEÖÌuSA∏á6@ π&6@ È<ˇˇˇEÖÌÖjˇˇˇÈb˛ˇˇHã=;  â¡∫ 6@ æ   1¿ËÙˇˇÎ¢Ë©Ûˇˇã8ËÚÙˇˇπ6@ Iâ¿È˘˛ˇˇËêÛˇˇã8ËŸÙˇˇπ!6@ Iâ¿È‡˛ˇˇLâ˜E1ÌË1  ÈrˇˇˇHâÔË$  Lâ˜Ë  È]ˇˇˇHã-H;  Hãô:  ∫T   æ   ø–4@ ËeÙˇˇHâÔËÕ  IâƒLâÁË  HÖ¿Hâ≈Ñµ   HçEHâl$«D$   Hã=N:  Aπ   A∏á6@ HâD$ãEP1…∫à6@ æ   â$1¿ËÙˇˇHã}XËk  Hâ≈ÎKfD  HçHHâD$«D$   Hã=¯9  Aπ   A∏á6@ HâL$ãPPπ   æ   1¿â$∫•6@ ËªÛˇˇHâÔËS  HÖ¿uÆHâÔË&  È7ˇˇˇLâÁE1ÌË  ÈW˛ˇˇAΩÙˇˇˇÈ:˛ˇˇHã=∑9  LâÒ∫Í6@ æ   1¿ËkÛˇˇHã|$8ËÚˇˇAΩÙˇˇˇÈƒ˚ˇˇLâˆLâˇËã  HÖ¿Ñg  Hâ∆LâÔË˜  Ö¿ÖæˆˇˇÈp˜ˇˇËÂÒˇˇDãD$DDãπef¿Hã=I9  ∫Â5@ æ   1¿Ë ÛˇˇÈH¯ˇˇAΩÙˇˇˇÈ∂ÛˇˇË´ÒˇˇDãCDãπef¿∫96@ Hã=9  æ   1¿Ë«ÚˇˇHâﬂËoÒˇˇÈÄÛˇˇËuÒˇˇHã\$8Dãπef¿Hã=Ÿ8  ∫Â5@ æ   1¿DãCËåÚˇˇHâﬂË4ÒˇˇÈÌ˙ˇˇË™  ÈÑıˇˇLâˇfêËÒˇˇHã=ú8  HâŸ∫Ä5@ æ   1¿AΩÙˇˇˇËJÚˇˇHã|$0ËˇˇÈÛˇˇHãl8  ∫8   æ   øË3@ ËÚˇˇÈ›ıˇˇË÷ˇˇHã\$0Dãπef¿∫Â5@ DãCÈ!ˇˇˇHã,8  ∫*   æ   ø(4@ Ë–ÒˇˇÈùıˇˇHã=8  MâLâ˘∫Ä4@ æ   1¿ËΩÒˇˇÈzıˇˇ1ÌIâ—^Hâ‚HÉ‰PTI«¿`1@ H«¡0@ H««@ ËˇˇˇÙf.Ñ     @ ∏ÁP` UH-‡P` HÉ¯HâÂw]√∏    HÖ¿tÙ]ø‡P` ˇ‡Ä    ∏‡P` UH-‡P` H¡¯HâÂHâ¬H¡Í?H–H—¯u]√∫    HÖ“tÙ]Hâ∆ø‡P` ˇ‚Ä    Ä=I7   uUHâÂË~ˇˇˇ]∆67  Û√@ HÉ=84   t∏    HÖ¿tUø N` HâÂˇ–]È{ˇˇˇ Èsˇˇˇ AW1“AVIâ˛AUATUHâı1ˆSHÉÏËÉˇˇ1“1ˆHâÔâD$ËsˇˇHã=D7  AâƒË‰  Iâ≈LâÔË  HÖ¿Hâ√Ñá   ∫   LâˆHâﬂË-ÔˇˇÖ¿t	ãD$9CPuœHã{XËß  Hâ√Îfê∫   HâÓLâˇË ÔˇˇÖ¿t$E9gPtHâﬂËæ  HÖ¿Iâ«u÷HâﬂËé  Îã@ HâﬂËÄ  LâÔËx  Lâ¯HÉƒ[]A\A]A^A_√LâÔË^  1¿ÎÂf.Ñ     HÉÏHã˝5  ∫-   æ   øà1@ Ë°ÔˇˇHã‚5  ∫Ö  æ   ø∏1@ ËÜÔˇˇHã«5  ∫h   æ   ø@3@ ËkÔˇˇ1¿HÉƒ√@ HÖˇtÈÓˇˇPπ$9@ ∫m   æ¢5@ ø™5@ Ë\Óˇˇfff.Ñ     HÖˇtÈÊÌˇˇPπ9@ ∫›   æ¢5@ øΩ5@ Ë,Óˇˇfff.Ñ     HÖˇSHâ˚tHãHÖˇtË˘  Hâﬂ[È†Ìˇˇπ9@ ∫B  æ¢5@ ø—5@ ËÁÌˇˇÄ    U1¿æef¿SHÉÏ(ã-m5  Hâ‚H«D$    «D$    «$H7&«D$   âÔË”ÌˇˇÖ¿â√âÔt0ËFÌˇˇHã=∑4  Dãπef¿DãD$∫Â5@ æ   1¿ËaÓˇˇã=5  1“1ˆËRÌˇˇHÉƒ(âÿ[]√fÑ     ATUHâ˝ø`   SHâÛLãfXË»ÌˇˇHâ∆∏ÙˇˇˇHÖˆtcLâfXHãHâHãCHâFHãCHâFHãCHâFHãC HâF HãC(HâF(HãC0HâF0HãC8HâF8HãC@HâF@HãCHHâFHãCPâFPHã} Ë™  1¿[]A\√ HÉÏø`@ ËR  HÉ¯HâO4  ¿HÉƒÉ‡√ffff.Ñ     Hã=14  Èt  @ HÉÏHÖˇÑ3  Å$Ôæ≠ﬁÖ  HÖˆÑ<  LãMÖ¿Ñ∞   IãPIã HÖ“HâÑî   HãWÉo HÖ“tqÅz Ôæ≠ﬁÖá   MçHÎ3fD  HãzL9œt?Hã?H9˘t
H;OÖ   HãRHÖ“t4Åz Ôæ≠ﬁuNHãJL9¡u IãHHâ˜HârHâJÎ¬êHârHâ˜Î∏Ä    Hãq3  IâLâg3  HÉƒ√HâwÈcˇˇˇ1¿ÎÓHç&  Hç5¯  Hç=C  ∫¿  Ë~ÎˇˇHç  Hç5Ÿ  Hç=—  ∫≈  Ë_ÎˇˇHçË  Hç5∫  Hç=‹  ∫∂  Ë@ÎˇˇHç…  Hç5õ  Hç=¨  ∫µ  Ë!ÎˇˇHç™  Hç5|  Hç=µ  ∫∏  ËÎˇˇfêATUHcÔSHÉÏÉ˝éñ   HÖˆÑ¨   HãHÖ€tHãHâHÉƒHâÿ[]A\√fÑ     AâÏHât$A¡‰Ic¸Ë<ÎˇˇHãt$HÖ¿Hât2A)ÏHâÈIc‘H˜ŸH¬H9–s HËH9¬HâwÙH«    HãHÖ¿uUËÍˇˇ«    HÉƒHâÿ[]A\√HçÄ  Hç5±  Hç=  ∫  Ë7ÍˇˇHça  Hç5í  Hç=  ∫  ËÍˇˇHâ√È5ˇˇˇATHÖˇUHâ˝SÑt  Å$Ôæ≠ﬁÖ)  HÖˆHâÛÑ˛   HÖ“Iâ‘Ñ0  Hç5å1  ø   Ë ˛ˇˇHÖ¿Ññ   Lâ HãHÖ“HâPtzHâHãMÉE HÖ…tbÅy Ôæ≠ﬁurHçpÎ- HãyH;xt6Mã L9«tI;xupHãIHÖ…t/Åy Ôæ≠ﬁu?LãAI9ÿuÕIâHâqHãyÎ HâAHâ«Î¡Ä    Lâ‡[]A\√HçPHâUÈyˇˇˇ1¿ÎÍHç   Hç5Ç  Hç=Õ  ∫ù  ËÈˇˇHç·  Hç5c  Hç=[  ∫¢  ËÈËˇˇHç¬  Hç5D  Hç=}  ∫ì  Ë ËˇˇHç£  Hç5%  Hç=G  ∫ë  Ë´ËˇˇHçÑ  Hç5  Hç=  ∫î  ËåËˇˇHçe  Hç5Á  Hç=¯  ∫ê  ËmËˇˇffff.Ñ     SHç50  Hâ˚ø(   ËK˝ˇˇHÖ¿t%H«     Hâ@H«@    HâX«@     «@$Ôæ≠ﬁ[√ffffff.Ñ     ATHÖˇIâ¸USÑˇ   Å$Ôæ≠ﬁÖ”   HãGHÖ¿tGÅx Ôæ≠ﬁÖû   HãÜ/  Î@ Åz Ôæ≠ﬁÖÑ   Hâ¡Hâ–HãPHâ«@ AR!HâX/  HÖ“u”Iã$HÖ€uÎ9Ñ     HâÎHã;HãkHÖˇtIãT$HÖ“tˇ“Hã&/  HÖÌHâHâ/  uœHã/  A«D$$AR![]Iâ$Lâ%/  A\√Hç\  Hç5ö  Hç=Â  ∫Ô   Ë ÁˇˇHç=  Hç5{  Hç=ù  ∫Ï   ËÁˇˇHç  Hç5\  Hç=m  ∫Í   Ë‚ÊˇˇfêHÉÏHÖˇtÅ$Ôæ≠ﬁu.ãW 1¿Ö“î¿HÉƒ√Hç¿  Hç5  Hç=+  ∫
  Ë†ÊˇˇHç°  Hç5˚  Hç=  ∫  ËÅÊˇˇêHÉÏHÖˇtÅ$Ôæ≠ﬁu'ãG HÉƒ√Hç\  Hç5¡  Hç=“  ∫  ËGÊˇˇHç=  Hç5¢  Hç=ƒ  ∫  Ë(ÊˇˇÑ     HÉÏHÖˇtHÖˆtWÅ$Ôæ≠ﬁu/HâÚHãwHÉƒÈÈ˚ˇˇHç„  Hç5T  Hç=e  ∫&  Ë⁄ÂˇˇHçƒ  Hç55  Hç=W  ∫)  ËªÂˇˇHç•  Hç5  Hç=  ∫'  ËúÂˇˇfff.Ñ     HÉÏHÖˇtHÖˆtVÅ$Ôæ≠ﬁu.HâÚHÉƒHâ˛ÈZ˚ˇˇHç3  Hç5≈  Hç=÷  ∫5  ËKÂˇˇHç  Hç5¶  Hç=»  ∫8  Ë,ÂˇˇHçı  Hç5á  Hç=á  ∫6  ËÂˇˇffff.Ñ     ATHÖˇUSÑà   HÖˆHâıtaÅ$Ôæ≠ﬁu9HãIâ‘HÖ€uÎ%D  Hã[HÖ€tLâÊHã;ˇ’Ö¿tÎHã[]A\√ []1¿A\√Hçb  Hç5  Hç=&  ∫H  Ëä‰ˇˇHçC  Hç5Â  Hç=|  ∫F  Ëk‰ˇˇHç$  Hç5∆  Hç=◊  ∫E  ËL‰ˇˇfff.Ñ     AVHÖˇAUIâ˝ATUSttHÖˆHâıÑ¶   Å$Ôæ≠ﬁu~Iâ‘Hâ˚E1ˆHãHÖ…tLâÊHã9ˇ’Ö¿uHãHÉ√HãHÖ…uÂ[]A\A]DâA^√ HâﬁLâÔËU˜ˇˇHÖ¿tæIãUHÖ“tHâ«ˇ“AÉ∆Î™Hçe  Hç5  Hç=(  ∫[  Ëù„ˇˇHçF  Hç5¯  Hç=  ∫^  Ë~„ˇˇHç'  Hç5Ÿ  Hç=p  ∫\  Ë_„ˇˇffffff.Ñ     AUATUSHÉÏHÖˇÑè   HÖˆIâÙthÅ$Ôæ≠ﬁu@HãHÖ€t4Iâ’1ÌÎD  Hã[HÖ€tÉ≈LâÓHã;Aˇ‘Ö¿yÁ˜›HÉƒâË[]A\A]√1ÌÎÔHç[  Hç5G  Hç=i  ∫z  ËÕ‚ˇˇHç<  Hç5(  Hç=ø  ∫x  ËÆ‚ˇˇHç  Hç5	  Hç=  ∫w  Ëè‚ˇˇffffff.Ñ     AVHÖˇIâ˛AUATUSÑ  HÖˆIâÙÑ8  Å$Ôæ≠ﬁÖ  É ~mHãIâ˝HçhHã@HÖ¿t(IãU Hã8LâÛHã2Aˇ‘Ö¿x]HãU IâÌHãBHçjHÖ¿uÿIãFIânHÖ¿t%D  Åx Ôæ≠ﬁurHãHã
HâPHâHHã@HÖ¿u‡[]A\A]A^√Ä    HãHÉ√HãHãE Hã2Hã8Aˇ‘Ö¿yÂHãU HãI9›HãBHâJHãU HâHâE ÖSˇˇˇMãm IÉ≈ÈFˇˇˇHçÍ  Hç5‡  Hç=+  ∫™  Ëf·ˇˇHçÀ  Hç5¡  Hç=“  ∫è  ËG·ˇˇHç¨  Hç5¢  Hç=ƒ  ∫í  Ë(·ˇˇHçç  Hç5É  Hç=  ∫ê  Ë	·ˇˇfÑ     HÉÏHÖˇtHÖˆtVÅ$Ôæ≠ﬁu.HâÚHÉƒHâ˛È ˆˇˇHç5  Hç55  Hç=F  ∫π  Ëª‡ˇˇHç  Hç5  Hç=8  ∫º  Ëú‡ˇˇHç˜  Hç5˜  Hç=˜  ∫∫  Ë}‡ˇˇffff.Ñ     HÉÏHÖˇtÅ$Ôæ≠ﬁu+Hâ˛HÉƒÈ“ÛˇˇHç§  Hç5≠  Hç=æ  ∫»  Ë3‡ˇˇHçÖ  Hç5é  Hç=∞  ∫   Ë‡ˇˇ@ HÉÏHÖˇtBÅ$Ôæ≠ﬁuHãHÖ¿tHã HÉƒ√fD  1¿ÎÒHç,  Hç5?  Hç=a  ∫ÿ  Ë≈ﬂˇˇHç  Hç5   Hç=1  ∫÷  Ë¶ﬂˇˇfD  HÉÏHÖˇtHÖˆtWÅ$Ôæ≠ﬁu/HâÚHãwHÉƒÈiıˇˇHç¥  Hç5‘  Hç=Â  ∫‰  ËZﬂˇˇHçï  Hç5µ  Hç=◊  ∫Á  Ë;ﬂˇˇHçv  Hç5ñ  Hç=ñ  ∫Â  Ëﬂˇˇfff.Ñ     HÉÏHÖˇtÅ$Ôæ≠ﬁu+Hâ˛HÉƒÈrÚˇˇHç   Hç5M  Hç=^  ∫Û  Ë”ﬁˇˇHç  Hç5.  Hç=P  ∫ı  Ë¥ﬁˇˇ@ HÖˇSHâ˚tBHç5P&  ø(   ËñÛˇˇHÖ¿t*HâÅ{$Ôæ≠ﬁu?HãHâXHâPHãSHâPHâC«@ Ôæ≠ﬁ[√Hç~  Hç5¿  Hç=—  ∫  ËFﬁˇˇHç_  Hç5°  Hç=√  ∫  Ë'ﬁˇˇÄ    HÉÏHÖˇt%Å Ôæ≠ﬁuZHãÅx$Ôæ≠ﬁu/HãHâGHâWHÉƒ√HçÎ  Hç5M  Hç=ı  ∫  Ë”›ˇˇHçÃ  Hç5.  Hç=Á  ∫  Ë¥›ˇˇHç≠  Hç5  Hç=Z  ∫  Ëï›ˇˇD  HÉÏHÖˇÑÊ   Å Ôæ≠ﬁÖ∫   HãÅx$Ôæ≠ﬁÖã   HãPHÖ“t/Åz Ôæ≠ﬁuZH9◊uÎJD  Åx Ôæ≠ﬁuEH9«t*Hâ¬HãBHÖ¿uÊHã◊$  «G AR!HâHâ=∆$  HÉƒ√êHÉ¬HãHHâ
Î’HçPHâ¯ÎÓHç”  Hç5U  Hç=+  ∫)  Ë€‹ˇˇHç¥  Hç56  Hç=Ô  ∫'  Ëº‹ˇˇHçï  Hç5  Hç=b  ∫%  Ëù‹ˇˇHçv  Hç5¯  Hç=†  ∫$  Ë~‹ˇˇfffff.Ñ     HÉÏHÖˇÑç   Å Ôæ≠ﬁueHãÅx$Ôæ≠ﬁu:HãGHÖ¿tHãPHâWHãWHãH9¬tHÉ¬HâWHÖ¿tHã HÉƒ√@ 1¿ÎÛHç€  Hç5o  Hç=(  ∫>  Ëı€ˇˇHçº  Hç5P  Hç=õ  ∫<  Ë÷€ˇˇHçù  Hç51  Hç=Ÿ  ∫;  Ë∑€ˇˇÄ    HÉÏHÖˇHâ¯t*HÖˆHâÚtÅ Ôæ≠ﬁuWHã?Å$Ôæ≠ﬁu,HãpHÉƒÈjÒˇˇHç5  Hç5’  Hç=}  ∫M  Ë[€ˇˇHç  Hç5∂  Hç=o  ∫Q  Ë<€ˇˇHç˜  Hç5ó  Hç=‚  ∫O  Ë€ˇˇHçÿ  Hç5x  Hç=x  f∫NËˇ⁄ˇˇffffff.Ñ     AUATUHâ˝SHÉÏHÖˇtIHÖˆIâÙtÅ Ôæ≠ﬁIâ’tÎRÑ     LâÓHâ«Aˇ‘Ö¿uHâÔË;˛ˇˇHÖ¿Hâ√u„HÉƒHâÿ[]A\A]√HçF  Hç5
  Hç=ò  ∫]  Ëv⁄ˇˇHç'  Hç5—
  Hç=  ∫_  ËW⁄ˇˇHç  Hç5≤
  Hç=I  ∫^  Ë8⁄ˇˇÑ     HÉÏHÖˇHâ¯tyÅ Ôæ≠ﬁuQHã?Å$Ôæ≠ﬁu&HãpHã@H9tHÉƒÈyÌˇˇfÑ     1¿HÉƒ√Hçé  Hç5D
  Hç=˝
  ∫m  Ë ŸˇˇHço  Hç5%
  Hç=p
  ∫k  Ë´ŸˇˇHçP  Hç5
  Hç=Æ
  ∫j  ËåŸˇˇfff.Ñ     HÖˇSHâ˚t=Å Ôæ≠ﬁuSË9ˇˇˇHÖ¿Hâ«t!Hãª   HãPHÖ“tˇ“âÿ[√f.Ñ     1€âÿ[√Hç”
  Hç5ï	  Hç==
  ∫z  ËŸˇˇHç¥
  Hç5v	  Hç=¡	  ∫{  Ë¸ÿˇˇf.Ñ     fêAWAâˇAVIâˆAUIâ’ATLç%  UHç-  SL)Â1€H¡˝HÉÏË%ÿˇˇHÖÌtÑ     LâÍLâˆDâˇAˇ‹HÉ√H9ÎuÍHÉƒ[]A\A]A^A_√ff.Ñ     Û√  HÉÏHÉƒ√                         usage: splat [hvla] [-t <subsystem:<tests>>]
     --help      -h               This help
  --verbose   -v               Increase verbosity
  --list      -l               List all tests in all subsystems
  --all       -a               Run all tests in all subsystems
  --test      -t <sub:test>    Run 'test' in subsystem 'sub'
  --exit      -x               Exit on first test error
  --nocolor   -c               Do not colorize output
   
Examples:
  splat -t kmem:all     # Runs all kmem tests
  splat -t taskq:0x201  # Run taskq test 0x201
        Unable to open %s: %d
Is the splat module loaded?
      Option -t <subsystem:test> is useless when used with -a
        Test must be of the form <subsystem:test>
      No tests '%s:%s' could be found
        Test '%s:%s' could not be found
        Test '%s:%s' not added to run list: %d
 ------------------------------ Available SPLAT Tests ------------------------------
    ------------------------------ Running SPLAT Tests ------------------------------
      Error initializing subsystem: %s
 splat.c sub != ((void *)0) test != ((void *)0) args != ((void *)0) Ioctl() error %lu / %d: %d
 [0;31mFail[0m [0;32mPass[0m Fail Pass /dev/splatctl Ioctl() error 0x%lx / %d: %d
 Unable to close %s: %d
 all Unknown option '%s'
 %*s0x%0*x %-*s ---- %s ----
 %*s0x%0*x %-*s %s
 %*s:%-*s  %s  %s
 Error reading results: %d
 
%s
 Error initializing test: %s
 help verbose list test exit nocolor                      “@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     ∆@     Ù@     Ë@     Ù@     Ù@     Ù@     Ù@     “@     Ù@     Ù@     Ù@     ∫@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     Ù@     ¢@     Ù@     ù@     Ù@     î@     args_fini test_fini subsystem_fini              7@                     h       7@                     v       7@                     l       o6@                     a       7@                    t       7@                     x       #7@                     c                                       hvlat:xc list.c x != ((void *)0) l != ((void *)0) l->magic == 0xDEADBEEF pp != ((void *)0) i->magic == 0xDEADBEEF size >= (int)sizeof(void *) pfreelist != ((void *)0) f != ((void *)0) i != ((void *)0) i->list->magic == 0xDEADBEEF (*pi)->magic == 0xDEADBEEF        (i->pos == *i->prev) || (i->pos == (*i->prev)->next)    list_delete list_remove list_find list_insert list_next         list_iterator_destroy           list_iterator_reset             list_iterator_create list_dequeue list_enqueue list_peek list_pop list_push list_sort list_for_each             list_node_destroy               list_delete_all list_find_first list_prepend    list_node_create list_append list_count list_is_empty list_free_aux list_destroy list_alloc_aux ;T  )   PÃˇˇ†  –ÕˇˇX  Õˇˇ  ¯€ˇˇp  ‹ˇˇ»  ‡›ˇˇ  @ﬁˇˇ0  pﬁˇˇH  †ﬁˇˇ`  ‡ﬁˇˇÄ  pﬂˇˇ®   ‡ˇˇÿ  0‡ˇˇ  @‡ˇˇp  ¿·ˇˇê  ∞‚ˇˇÿ  `‰ˇˇ  ∞‰ˇˇ(  ‡ÂˇˇX  @Êˇˇx  †Êˇˇò  0Áˇˇ∏  ¿Áˇˇÿ  ÄËˇˇ  pÈˇˇX  @Íˇˇò  ¿Îˇˇÿ  PÏˇˇ¯  ∞Ïˇˇ   Ìˇˇ8  ∞ÌˇˇX  Óˇˇx  †Óˇˇò  0Ôˇˇ∏  Pˇˇÿ  Òˇˇ¯  –Òˇˇ  êÚˇˇX  @Ûˇˇx  –Ûˇˇ†  @ÙˇˇË             zR xê      Ä⁄ˇˇ*                  zR xê  $      ® ˇˇÄ   FJwÄ ?;*3$"    L   D    €ˇˇÊ    BèDéE çB(åA0ÜF8ÉDP∑
8A0A(B BBBA        î   ¿€ˇˇ\    DW   ¨   ‹ˇˇ$    K       ƒ    ‹ˇˇ$    K       ‹   8‹ˇˇ9    DÉW
E    $   ¸   X‹ˇˇá    AÜHÉD@uCA,   $  ¿‹ˇˇç    BåAÜI É}AB         T   ›ˇˇ#    D[    l  8›ˇˇ           L   Ñ  ‡ ˇˇ   BèBéB çB(åI0ÜD8ÉD†»
8A0A(B BBBA       ‘  p ˇˇ     H       Ï  »‹ˇˇ~   D—
A     D     (ﬁˇˇ    BåAÜD ÉD0d
 DABJb
 DABA      ,   T  –ﬁˇˇ£   BåDÜD É 
ABA      Ñ  P‡ˇˇA    AÉ       ,   §  Ä‡ˇˇ.   BåGÜA É∏
AMA      ‘  Ä·ˇˇ_    D\
A         Ù  ¿·ˇˇX    DU
A            ‚ˇˇÑ    D^
E         4  p‚ˇˇÉ    DZ
H      <   T  ‡‚ˇˇ¥    BåDÜA ÉB
ABDA
ADA       <   î  `„ˇˇ·    BéEçE åA(ÜA0ÉD
(A BBED   <   ‘  ‰ˇˇ¡    BçBåA ÜA(ÉD0M
(C ABBA     <     †‰ˇˇw   BéHçB åA(ÜA0Éì
(A BBBH      T  ‡ÂˇˇÉ    DZ
H         t  PÊˇˇ\    DU
E         î  êÊˇˇj    D]
G         ¥  ‡ÊˇˇÑ    D^
E         ‘  PÁˇˇ\    DU
E         Ù  êÁˇˇâ    DÉF
A         Ëˇˇã    Di
A         4  pËˇˇ   Dz
B        T  pÈˇˇπ    DO
E        t  Íˇˇ±    Dm
E      <   î  ∞Íˇˇ∏    BçBåA ÜD(ÉD0D
(D ABBA        ‘  0Îˇˇ§    Dn
NF
A$   Ù  ¿ÎˇˇÑ    DÉq
KE
A      D     (Ïˇˇe    BèEéE çE(åH0ÜH8ÉM@l8A0A(B BBB    d  PÏˇˇ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ‡@     ¿@                                  H	@            d1@            N`                          N`                   ı˛ˇo    ò@            P@            »@     
                                                  P`            (                            @            ¿@            `       	              ˛ˇˇo    ê@     ˇˇˇo           ˇˇo    X@                                                                                                             (N`                     Ü	@     ñ	@     ¶	@     ∂	@     ∆	@     ÷	@     Ê	@     ˆ	@     
@     
@     &
@     6
@     F
@     V
@     f
@     v
@     Ü
@     ñ
@     ¶
@     ∂
@     ∆
@     ÷
@     Ê
@                      .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss                                                                               8@     8                                                 T@     T                                     !             t@     t      $                              4   ˆˇˇo       ò@     ò      0                             >             »@     »      à                          F             P@     P                                   N   ˇˇˇo       X@     X      6                            [   ˛ˇˇo       ê@     ê      0                            j             ¿@     ¿      `                            t              @            (                          ~             H	@     H	                                    y             p	@     p	      Ä                            Ñ             
@     
      r&                             ä             d1@     d1      	                              ê             Ä1@     Ä1      †                              ò              =@      =      T                             ¶             x>@     x>      ¨                             ∞             N`     N                                    º             N`     N                                    »              N`      N                                    Õ             (N`     (N      –                           ÷             ¯O`     ¯O                                   €              P`      P      –                             ‰             –P`     –P                                    Í             ‡P`     ‡P      »                                                     ‡P      Ô                                                                                                                                                                                                                                                                                                                                                                                                              usr/sbin/update-ca-certificates                                                                     0100755 0000000 0000000 00000010264 13017551713 015253  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh -e
#
# update-ca-certificates
#
# Copyright (c) 2003 Fumitoshi UKAI <ukai@debian.or.jp>
# Copyright (c) 2009 Philipp Kern <pkern@debian.org>
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02111-1301,
# USA.
#

verbose=0
fresh=0
while [ $# -gt 0 ];
do
  case $1 in
    --verbose|-v)
      verbose=1;;
    --fresh|-f)
      fresh=1;;
    --help|-h|*)
      echo "$0: [--verbose] [--fresh]"
      exit;;
  esac
  shift
done

CERTSCONF=/etc/ca-certificates.conf
CERTSDIR=/usr/share/ca-certificates
LOCALCERTSDIR=/usr/local/share/ca-certificates
CERTBUNDLE=ca-certificates.crt
ETCCERTSDIR=/etc/ssl/certs

cleanup() {
  rm -f "$TEMPBUNDLE"
  rm -f "$ADDED"
  rm -f "$REMOVED"
}
trap cleanup 0

# Helper files.  (Some of them are not simple arrays because we spawn
# subshells later on.)
TEMPBUNDLE="$(mktemp -t "${CERTBUNDLE}.tmp.XXXXXX")"
ADDED="$(mktemp -t "ca-certificates.tmp.XXXXXX")"
REMOVED="$(mktemp -t "ca-certificates.tmp.XXXXXX")"

# Adds a certificate to the list of trusted ones.  This includes a symlink
# in /etc/ssl/certs to the certificate file and its inclusion into the
# bundle.
add() {
  CERT="$1"
  PEM="$ETCCERTSDIR/$(basename "$CERT" .crt | sed -e 's/ /_/g' \
                                                  -e 's/[()]/=/g' \
                                                  -e 's/,/_/g').pem"
  if ! test -e "$PEM" || [ "$(readlink "$PEM")" != "$CERT" ]
  then
    ln -sf "$CERT" "$PEM"
    echo +$PEM >> "$ADDED"
  fi
  # Add trailing newline to certificate, if it is missing (#635570)
  sed -e '$a\' "$CERT" >> "$TEMPBUNDLE"
}

remove() {
  CERT="$1"
  PEM="$ETCCERTSDIR/$(basename "$CERT" .crt).pem"
  if test -L "$PEM"
  then
    rm -f "$PEM"
    echo -$PEM >> "$REMOVED"
  fi
}

cd $ETCCERTSDIR
if [ "$fresh" = 1 ]; then
  echo -n "Clearing symlinks in $ETCCERTSDIR..."
  find . -type l -print | while read symlink
  do
    case $(readlink $symlink) in
      $CERTSDIR*) rm -f $symlink;;
    esac
  done
  find . -type l -print | while read symlink
  do
    test -f $symlink || rm -f $symlink
  done
  echo "done."
fi

echo -n "Updating certificates in $ETCCERTSDIR... "

# Handle certificates that should be removed.  This is an explicit act
# by prefixing lines in the configuration files with exclamation marks (!).
sed -n -e '/^$/d' -e 's/^!//p' $CERTSCONF | while read crt
do
  remove "$CERTSDIR/$crt"
done

sed -e '/^$/d' -e '/^#/d' -e '/^!/d' $CERTSCONF | while read crt
do
  if ! test -f "$CERTSDIR/$crt"
  then
    echo "W: $CERTSDIR/$crt not found, but listed in $CERTSCONF." >&2
    continue
  fi
  add "$CERTSDIR/$crt"
done

# Now process certificate authorities installed by the local system
# administrator.
if [ -d "$LOCALCERTSDIR" ]
then
  find -L "$LOCALCERTSDIR" -type f -name '*.crt' | sort | while read crt
  do
    add "$crt"
  done
fi

rm -f "$CERTBUNDLE"

ADDED_CNT=$(wc -l < "$ADDED")
REMOVED_CNT=$(wc -l < "$REMOVED")

if [ "$ADDED_CNT" -gt 0 ] || [ "$REMOVED_CNT" -gt 0 ]
then
  # only run if set of files has changed
  if [ "$verbose" = 0 ]
  then
    c_rehash . > /dev/null
  else
    c_rehash .
  fi
fi

chmod 0644 "$TEMPBUNDLE"
mv -f "$TEMPBUNDLE" "$CERTBUNDLE"
# Restore proper SELinux label after moving the file
[ -x /sbin/restorecon ] && /sbin/restorecon "$CERTBUNDLE" >/dev/null 2>&1

echo "$ADDED_CNT added, $REMOVED_CNT removed; done."

HOOKSDIR=/etc/ca-certificates/update.d
echo -n "Running hooks in $HOOKSDIR...."
VERBOSE_ARG=
[ "$verbose" = 0 ] || VERBOSE_ARG=--verbose
eval run-parts $VERBOSE_ARG --test -- $HOOKSDIR | while read hook
do
  ( cat $ADDED
    cat $REMOVED ) | $hook || echo E: $hook exited with code $?.
done
echo "done."

# vim:set et sw=2:

                                                                                                                                                                                                                                                                                                                                            usr/sbin/update-initramfs                                                                           0100755 0000000 0000000 00000021416 12704740230 014216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh

STATEDIR=/var/lib/initramfs-tools
BOOTDIR=/boot
CONF=/etc/initramfs-tools/update-initramfs.conf
USETRIGGERS=true
mode=""
version=""
update_initramfs=yes
backup_initramfs=no

set -e

[ -r ${CONF} ] && . ${CONF}

case "$DPKG_MAINTSCRIPT_PACKAGE" in
linux-image-*)
	if [ -z "$INITRAMFS_TOOLS_KERNEL_HOOK" ]; then
		# kernel maintainer script called us directly; ignore
		# it and let the hook script handle it instead
		echo "update-initramfs: deferring update (hook will be called later)"
		exit 0
	fi
	;;
?*)
	if	   $USETRIGGERS						\
		&& [ $# = 1 ]						\
		&& [ x"$1" = x-u ]					\
		&& dpkg-trigger --check-supported 2>/dev/null
	then
		if dpkg-trigger --no-await update-initramfs; then
			echo "update-initramfs: deferring update (trigger activated)"
			exit 0
		fi
	fi
	;;
esac

usage()
{
	if [ -n "${1:-}" ]; then
		printf "${*}\n\n" >&2
	fi
	cat >&2 << EOF
Usage: ${0} [OPTION]...

Options:
 -k version	Specify kernel version or 'all'
 -c		Create a new initramfs
 -u		Update an existing initramfs
 -d		Remove an existing initramfs
 -t		Take over a custom initramfs with this one
 -b directory	Set alternate boot directory
 -v		Be verbose
 -h		This message

EOF
	exit 1
}

# chroot check
chrooted()
{
	# borrowed from udev's postinst
	if [ "$(stat -c %d/%i /)" = "$(stat -Lc %d/%i /proc/1/root 2>/dev/null)" ]; then
		# the devicenumber/inode pair of / is the same as that of
		# /sbin/init's root, so we're *not* in a chroot and hence
		# return false.
		return 1
	fi
return 0
}

mild_panic()
{
	if [ -n "${1:-}" ]; then
		printf "${*}\n" >&2
	fi
	exit 0
}

panic()
{
	if [ -n "${1:-}" ]; then
		printf "${*}\n" >&2
	fi
	exit 1
}

verbose()
{
	if [ "${verbose}" = 1 ]; then
		printf "${*}\n"
	fi
}

version_exists()
{
	[ -e "${STATEDIR}/${1}" ] && [ -e "${initramfs}" ]
	return $?
}

set_initramfs()
{
	initramfs="${BOOTDIR}/initrd.img-${version}"
}


# backup initramfs while running
backup_initramfs()
{
	[ ! -r "${initramfs}" ] && return 0
	initramfs_bak="${initramfs}.dpkg-bak"
	[ -r "${initramfs_bak}" ] && rm -f "${initramfs_bak}"
	ln -f "${initramfs}" "${initramfs_bak}" \
		|| cp -a "${initramfs}" "${initramfs_bak}"
	verbose "Keeping ${initramfs_bak}"
}

# keep booted initramfs
backup_booted_initramfs()
{
	initramfs_bak="${initramfs}.dpkg-bak"

	# first time run thus no backup
	[ ! -r "${initramfs_bak}" ] && return 0

	# chroot with no /proc
	[ ! -r /proc/uptime ] && rm -f "${initramfs_bak}" && return 0

	# no kept backup wanted
	[ "${backup_initramfs}" = "no" ] && rm -f "${initramfs_bak}" && return 0

	# no backup yet
	if [ ! -r "${initramfs}.bak" ]; then
		mv -f ${initramfs_bak} "${initramfs}.bak"
		verbose "Backup ${initramfs}.bak"
		return 0
	fi

	# keep booted initramfs
	boot_initramfs=
	uptime_days=$(awk '{printf "%d", $1 / 3600 / 24}' /proc/uptime)
	if [ -n "$uptime_days" ]; then
		boot_initramfs=$(find "${initramfs}.bak" -mtime +${uptime_days})
	fi
	if [ -n "${boot_initramfs}" ]; then
		mv -f "${initramfs_bak}" "${initramfs}.bak"
		verbose "Backup ${initramfs}.bak"
		return 0
	fi
	verbose "Removing current backup ${initramfs_bak}"
	rm -f ${initramfs_bak}
}

# nuke generated copy
remove_initramfs_bak()
{
	[ -z "${initramfs_bak:-}" ] && return 0
	rm -f "${initramfs_bak}"
	verbose "Removing ${initramfs_bak}"
}


generate_initramfs()
{
	echo "update-initramfs: Generating ${initramfs}"
	OPTS="-o"
	if [ "${verbose}" = 1 ]; then
		OPTS="-v ${OPTS}"
	fi
	if mkinitramfs ${OPTS} "${initramfs}.new" "${version}"; then
		mv -f "${initramfs}.new" "${initramfs}"
		set_sha1
		# Guard against an unclean shutdown
		sync
	else
		mkinitramfs_return="$?"
		remove_initramfs_bak
		rm -f "${initramfs}.new"
		echo "update-initramfs: failed for ${initramfs} with $mkinitramfs_return." >&2
		exit $mkinitramfs_return
	fi
}

# Invoke bootloader
run_bootloader()
{
	# invoke policy conformant bootloader hooks
	if [ -d /etc/initramfs/post-update.d/ ]; then
		run-parts --arg=${version} --arg=${initramfs} \
			/etc/initramfs/post-update.d/
		return 0
	fi
}

compare_sha1()
{
	sha1sum "${initramfs}" | diff "${STATEDIR}/${version}" - >/dev/null 2>&1
	return $?
}

# Note that this must overwrite so that updates work.
set_sha1()
{
	sha1sum "${initramfs}" > "${STATEDIR}/${version}"
}

delete_sha1()
{
	rm -f "${STATEDIR}/${version}"
}

# ro /boot is not modified
ro_boot_check()
{
	# check irrelevant inside of a chroot
	if [ ! -r /proc/mounts ] || chrooted; then
		return 0
	fi

	boot_opts=$(awk '/boot/{if ((match($4, /^ro/) || match($4, /,ro/)) \
		&& $2 == "/boot") print "ro"}' /proc/mounts)
	if [ -n "${boot_opts}" ]; then
		echo "WARNING: /boot is ro mounted."
		echo "update-initramfs: Not updating ${initramfs}"
		exit 0
	fi
}

get_sorted_versions()
{
	version_list=""

	for gsv_x in "${STATEDIR}"/*; do
		gsv_x="$(basename "${gsv_x}")"
		if [ "${gsv_x}" = '*' ]; then
			return 0
		fi
		worklist=""
		for gsv_i in $version_list; do
			if dpkg --compare-versions "${gsv_x}" '>' "${gsv_i}" 2>/dev/null; then
				worklist="${worklist} ${gsv_x} ${gsv_i}"
				gsv_x=""
			else
				worklist="${worklist} ${gsv_i}"
			fi
		done
		if [ "${gsv_x}" != "" ]; then
			worklist="${worklist} ${gsv_x}"
		fi
		version_list="${worklist}"
	done

	verbose "Available versions: ${version_list}"
}

set_current_version()
{
	if [ -f /boot/initrd.img-`uname -r` ]; then
		version=`uname -r`
	fi
}

set_linked_version()
{
	linktarget=
	if [ -e /initrd.img ] && [ -L /initrd.img ]; then
		linktarget="$(basename "$(readlink /initrd.img)")"
	fi

	if [ -e /boot/initrd.img ] && [ -L /boot/initrd.img ]; then
		linktarget="$(basename "$(readlink /boot/initrd.img)")"
	fi

	if [ -z "${linktarget}" ]; then
		return
	fi

	version="${linktarget##initrd.img-}"
}

set_highest_version()
{
	get_sorted_versions
	if [ -z "${version_list}" ]; then
		version=
		return
	fi
	set -- ${version_list}
	version=${1}
}

create()
{
	if [ -z "${version}" ]; then
		usage "Create mode requires a version argument"
	fi

	set_initramfs

	if [ "${takeover}" = 0 ]; then
		if version_exists "${version}"; then
			panic "Cannot create version ${version}: already exists"
		fi

		if [ -e "${initramfs}" ]; then
			panic "${initramfs} already exists, cannot create."
		fi
	fi

	generate_initramfs

	run_bootloader
}

update()
{
	if [ "${update_initramfs}" = "no" ]; then
		echo "update-initramfs: Not updating initramfs."
		exit 0
	fi

	if [ -z "${version}" ]; then
		set_highest_version
	fi

	if [ -z "${version}" ]; then
		set_linked_version
	fi

	if [ -z "${version}" ]; then
		set_current_version
	fi

	if [ -z "${version}" ]; then
		verbose "Nothing to do, exiting."
		exit 0
	fi

	set_initramfs

	ro_boot_check

	altered_check

	backup_initramfs

	generate_initramfs

	run_bootloader

	backup_booted_initramfs
}

delete()
{
	if [ -z "${version}" ]; then
		usage "Delete mode requires a version argument"
	fi

	set_initramfs

	if [ "${takeover}" = 0 ]; then
		if [ ! -e "${initramfs}" ]; then
			panic "Cannot delete ${initramfs}, doesn't exist."
		fi

		if ! version_exists "${version}"; then
			panic "Cannot delete version ${version}: Not created by this utility."
		fi
	fi

	altered_check

	echo "update-initramfs: Deleting ${initramfs}"

	delete_sha1

	rm -f "${initramfs}" "${initramfs}.bak"
}

# Check for update mode on existing and modified initramfs
altered_check()
{
	# No check on takeover
	[ "${takeover}" = 1 ] && return 0
	if [ ! -e "${initramfs}" ]; then
		mild_panic "${initramfs} does not exist. Cannot update."
	fi
	if ! compare_sha1; then
		echo "update-initramfs: ${initramfs} has been altered." >&2
		mild_panic "update-initramfs: Cannot update. Override with -t option."
	fi
}

# Defaults
verbose=0
yes=0
# We default to takeover=1 in Ubuntu, but not Debian
takeover=0

##

while getopts "k:cudyvtb:h?" flag; do
	case "${flag}" in
	k)
		version="${OPTARG}"
		;;
	c)
		mode="c"
		;;
	d)
		mode="d"
		;;
	u)
		mode="u"
		;;
	v)
		verbose="1"
		;;
	y)
		yes="1"
		;;
	t)
		takeover="1"
		;;
	b)
		BOOTDIR="${OPTARG}"
		if [ ! -d "${BOOTDIR}" ]; then
			echo "Error: ${BOOTDIR} is not a directory." >&2
			exit 1
		fi
		;;
	h|?)
		usage
		;;
	esac
done

shift $((${OPTIND} - 1))

if [ $# -ne 0 ]; then
	printf "Extra argument '%s'\n\n" "$1" >&2
	usage
fi

# Validate arguments
if [ -z "${mode}" ]; then
	usage "You must specify at least one of -c, -u, or -d."
fi

if [ "${version}" = "all" ] \
	|| ( [ "${update_initramfs}" = "all" ] && [ -z "${version}" ] ); then
	: FIXME check for --yes, and if not ask are you sure
	get_sorted_versions
	if [ -z "${version_list}" ]; then
		verbose "Nothing to do, exiting."
		exit 0
	fi

	OPTS="-b ${BOOTDIR}"
	if [ "${verbose}" = "1" ]; then
		OPTS="${OPTS} -v"
	fi
	if [ "${takeover}" = "1" ]; then
		OPTS="${OPTS} -t"
	fi
	if [ "${yes}" = "1" ]; then
		OPTS="${OPTS} -y"
	fi
	for u_version in ${version_list}; do
		verbose "Execute: ${0} -${mode} -k \"${u_version}\" ${OPTS}"
		"${0}" -${mode} -k "${u_version}" ${OPTS}
	done
	exit 0
fi


case "${mode}" in
	c)
		create
		;;
	d)
		delete
		;;
	u)
		update
		;;
esac
                                                                                                                                                                                                                                                  usr/sbin/update-mime                                                                                0100755 0000000 0000000 00000021535 12447720176 013166  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/perl
###############################################################################
#
#  Update-MIME:  Install programs into "/etc/mailcap", resolve conflicts,
#                auto-uninstall, make dinner, and wash dishes.
#
#  Written by Brian White <bcwhite@pobox.com>.
#
#  This program has been placed in the public domain (the only true "free").
#  Do whatever you wish with it, though I'd appreciate it if my name stayed
#  on it as the original author.
#
###############################################################################

umask(022);



#
# Program Constants
#
$debug		= 0;
$conffile	= "/etc/update-mime.conf";
$mailcap	= "/etc/mailcap";
$mailcapdef	= "/usr/lib/mime/mailcap";
$mimedir	= "/usr/lib/mime/packages";
$appsdir	= "/usr/share/applications";
$orderfile	= "/etc/mailcap.order";
$defpriority    = 5;
$localgen	= 0;


# If the call comes from dpkg, only accept it if --triggered is passed
# This is so that we don't get useless calls from packages' postinsts
# that call update-mime due to dh_installmime adding that call for
# when there was no triggers support.
#
# When this 'hack' is removed, mime-support's postinst should be updated
# to not pass --triggered anymore in 'triggered'.
if ($ENV{"DPKG_RUNNING_VERSION"} ne "" && $ARGV[0] ne "--triggered") {
    exit (0);
}


# Allow local run
if ($ARGV[0] eq "--local") {
    $conffile	= "$ENV{HOME}/.update-mime.conf";
    $mailcap	= "$ENV{HOME}/.mailcap";
    $orderfile	= "$ENV{HOME}/.mailcap.order";
    $localgen	= 1;
}


#
# Allow local customizations
#
do $conffile if -f $conffile;


#
# Global Variables
#
%entries;
%packages;
%priorities;
@order;
$counter=1;


sub ReadEntries
{
	my($pkg,$priority);

#	foreach $file (glob "$mimedir/*") {
	foreach $file (map { glob $_.'/*' } split ':',$mimedir) {
		next if ($file =~ m!(^|/)(\.|\#)|(\~)$!);
		($pkg) = ($file =~ m|/([^/]*)$|);
		print STDERR "$pkg:\n" if $debug;

		if (!defined $packages{$pkg}) {
			$packages{$pkg} = [];
		}

		if (open(FILE,"<$file")) {
			while (<FILE>) {
				chomp;
				next if m/^\s*$|^\s*\#/;
				if (! m(^[a-zA-Z0-9*][a-zA-Z0-9!#\$&^_.+-]*/[a-zA-Z0-9*][a-zA-Z0-9!#\$&^_.+-]*;) ) {
					print STDERR "Warning: mailcap line not starting with a media type in $pkg\n";
					print STDERR "Problematic line: $_\n";
				}
				if (m/priority\s*=\s*(\d+)\s*($|;)/i) {
					$priority=$1;
				} else {
					$priority=$defpriority;
				}
				if ($priority < 0 || $priority > 9) {
					print STDERR "Error: priority of $priority is out of range (0 <= pri <= 9)\n";
					print STDERR "       $_\n";
					$priority=$defpriority;
				}
				$entries{$counter} = $_;
				push @{$packages{$pkg}},$counter;
				push @{$priorities{$priority}},$counter;
				print STDERR "$counter: $_\n" if $debug;
				$counter++;
			}
			close(FILE);
		} else {
			print STDERR "Warning: could not open file '$file' -- $!\n";
		}
	}
}

sub RecurseIntoDirectories
{
	my @files;
	foreach my $dir (@_) {
		next if ($dir =~ m!(^|/)(\.|\#)|(\~)$!);
		my @entries = glob "$dir/*";
		push @files, RecurseIntoDirectories(grep { -d $_ } @entries);
		push @files, grep { -f $_ } @entries;
	}
	return @files;
}

sub ReadDesktopEntries
{
	my($pkg,$priority);

	foreach $file (RecurseIntoDirectories(split ':',$appsdir)) {
		next if ($file =~ m!(^|/)(\.|\#)|(\~)$!);
		next unless ($file =~ m/\.desktop$/);
		($pkg) = ($file =~ m|/([^/]*)\.desktop$|);
		print STDERR "$pkg:\n" if $debug;

		next if (defined $packages{$pkg});
		$packages{$pkg} = [];

		if (open(FILE,"<$file")) {
			my($terminal, $name, $icon, $exec, @types) = ("test=test -n \"\$DISPLAY\"", $pkg);
			while (<FILE>) {
				chomp;
				next if (m/^\s*$|^\s*\#/);
				if (m/^Terminal=(\w+)/i) {
					$terminal = "needsterminal" if ($1 eq "true");
				}
				elsif (m/^Name=(.+)/i) {
					$name = $1;
				}
				elsif (m/^Icon=(.+)/i) {
					$icon = $1;
				}
				elsif (m/Exec=(.*)$/i) {
					$exec = $1;
					$exec =~ s/%[fFuU]/%s/g;
					$exec .= " %s" if ($exec !~ m/%s/);
				}
				elsif (m/MimeType=(.*)/i) {
					push @types, split(/;/, $1);
				}
			}
			if (!defined($exec) || !scalar(@types)) {
				close(FILE);
				next;
			}
			$exec =~ s/%c/$name/g;
			$exec =~ s/%i/--icon $icon/g;
			foreach $type (@types) {
				my $entry = "$type; $exec; $terminal";
				$priority=$defpriority;
				$entries{$counter} = $entry;
				push @{$packages{$pkg}},$counter;
				push @{$priorities{$priority}},$counter;
				print STDERR "$counter: $entry\n" if $debug;
				$counter++;
			}
			close(FILE);
		} else {
			print STDERR "Warning: could not open file '$file' -- $!\n";
		}
	}
}


sub ReadOrder
{
	if (-e $orderfile) {
		if (open(FILE,"<$orderfile")) {
			while (<FILE>) {
				chomp;
				s/\s*\#.*$//;
				next if m/^\s*$/;
				push @order,$_;
				/(.*):/;
				my $pkg = $1;
				unless( grep {/^$pkg$/} keys(%packages)) {
					print STDERR "Warning: package $pkg listed in /etc/mailcap.order does not have mailcap entries.\n";
				}
			}
			close(FILE);
		} else {
			print STDERR "Warning: could not open file '$orderfile' -- $!\n";
		}
	}
}



sub OrderEntries
{
	my(@entrylist,@orderlist,@templist,$priority,$entrycode,$ordercode);

	foreach $priority (sort {$b <=> $a} keys %priorities) {
		print STDERR " - Priority $priority:" if $debug;
		@templist = @{$priorities{$priority}};
		@templist = sort {
			$ae  = $entries{$a};
			$ac  = 0;
			$ac += 1 if $ae =~ m!^\S+/\*!;
			$ac += 2 if $ae =~ m!^\*/!;
			$be  = $entries{$b};
			$bc  = 0;
			$bc += 1 if $be =~ m!^\S+/\*!;
			$bc += 2 if $be =~ m!^\*/!;
			$ac <=> $bc;
		} @templist;
		foreach $entry (@templist) {
			print STDERR " $entry" if $debug;
			push @entrylist,$entry;
		}
		print STDERR "\n" if $debug;
	}

	print STDERR "entrylist: @entrylist\n" if $debug;
	foreach $ordercode (@order) {
		my($pkg,$typ);
		if ($ordercode =~ m/:/) {
			($pkg,$typ) = ($ordercode =~ m/^(.*):(\S*)/);
		} else {
			$pkg = $ordercode;
			$typ = "*/*";
		}
		$typ = "*/*" unless $typ;
		print STDERR " - Ordering '$ordercode'...  (package=$pkg, type=$typ, orderlist=@orderlist)\n" if $debug;
		$typ =~ s/\*/\.\*/g;
		foreach $entrycode (@entrylist) {
			next if grep(/^\Q$entrycode\E$/,@orderlist);
			print STDERR "    - Checking entrycode '$entrycode' against (@{$packages{$pkg}})...\n" if $debug;
			if (grep(/^\Q$entrycode\E$/,@{$packages{$pkg}})) {
				$entry = $entries{$entrycode};
				my($etype) = ($entry =~ m/^(.*?)(;|\s)/);
				print STDERR "       - entry found, type=$etype, checking against '$typ'\n" if $debug;
				if ($etype =~ m!^$typ$!) {
#					print STDERR "       - matched!\n" if $debug;
#					my($oaction) = ($ordercode =~ m/action=([^\s;]*)/i);
#					my($eaction) = ($entry     =~ m/action=([^\s;]*)/i);
#					$eaction="view" unless $eaction;
#					print STDERR "       - checking entry action '$eaction' against '$oaction'\n" if $debug;
#					if (!$oaction || $eaction =~ m/^($oaction)$/) {
						push @orderlist,$entrycode;
						print STDERR "       - matched!  (orderlist=@orderlist)\n" if $debug;
#					}
				}
			}
		}
	}

	foreach $entrycode (@entrylist) {
		next if grep(/^\Q$entrycode\E$/,@orderlist);
		push @orderlist,$entrycode;
	}

	print STDERR "orderlist: @orderlist\n" if $debug;
	return @orderlist;
}



#
# Generate new mailcap file
#
sub UpdateMailcap
{
	my(@entrylist) = @_;
	my(@above,@user,@below,$state,$entrycode);
	$state = 0;
	if (!open(PATH,"<$mailcap")) {
		if (!open(PATH,"<$mailcapdef")) {
#			print STDERR "Warning: could not read '$mailcap' (update stopped) -- $!\n";
#			print STDERR "         restore from backup or delete and re-install mime-support package";
			return;
		}
	}

	while (<PATH>) {
		s/install-mime/update-mime/g;
		if ($state == 0) {
			push @above,$_;
		}
		$state=2 if ($state == 1 && /^\# ----- .* Ends /);
		if ($state == 1) {
			push @user,$_;
		}
		$state=1 if ($state == 0 && /^\# ----- .* Begins /);
		if ($state == 2) {
			push @below,$_;
		}
		$state=3 if ($state == 2);
	}

	close PATH;

	if ($state == 3) {
		my $newfile = join('',@above,@user,@below);
		$newfile .= "\n###############################################################################\n\n";
		foreach $entrycode (@entrylist) {
			my $entry = $entries{$entrycode};
			$entry =~ s/\s*priority\s*=\s*\d+\s*($|;)//;
			$entry =~ s/\s*;\s*$//;
			$newfile .= $entry."\n";
		}

		if (!open(PATH,">$mailcap.new")) {
			print STDERR "Error: could not write '$mailcap.new' -- $!\n";
			exit(1) unless ($debug);
			open(PATH,">-");
		}
		print PATH $newfile;
		close PATH;
		if (!open(PATH,"<$mailcap.new")) {
			die "Error: could not read generated '$mailcap.new' -- $!\n";
		}
		my $savfile = "";
		$savfile .= $_ while (<PATH>);
		if ($savfile ne $newfile) {
			die "Error: contents of '$mailcap.new' do not match what was written -- abort\n";
		}
		rename "$mailcap.new","$mailcap";
	} else {
		print STDERR "Error: '$mailcap' is not in required format -- not updated\n";
		print STDERR "       Restore from backup or delete and re-install mime-support package";
	}
}



ReadEntries();
ReadDesktopEntries();
ReadOrder();
@list = OrderEntries();
UpdateMailcap(@list);
                                                                                                                                                                   usr/sbin/update-python-modules                                                                      0100755 0000000 0000000 00000046522 11572765505 015234  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python
#
# copyright (c) 2006 Josselin Mouette <joss@debian.org>
# Licensed under the GNU Lesser General Public License, version 2.1
# See COPYING for details

# Everything prefixed by old_ is compatibility code with older versions
# Modules used to lie in /usr/{lib,share}/python-support/$package
# They now lie in /usr/{lib,share}/pyshared

import sys,os,shutil
from optparse import OptionParser
from subprocess import call
from py_compile import compile, PyCompileError
sys.path.append("/usr/share/python-support/private/")
import pysupport
from pysupport import py_supported,py_installed,py_oldversions

basepath='/usr/lib/pymodules'
sourcepath='/usr/share/python-support'
old_extensionpath='/usr/lib/python-support'
shared_path='/usr/share/pyshared'
shared_extensionpath='/usr/lib/pyshared'

parser = OptionParser(usage="usage: %prog [-v] [-c] package_directory [...]\n"+
                            "       %prog [-v] [-c] package.dirs [...]\n"+
                            "       %prog [-v] [-a|-f|-p]")
parser.add_option("-v", "--verbose", action="store_true", dest="verbose",
                  help="verbose output", default=False)
parser.add_option("-c", "--clean", action="store_true", dest="clean_mode",
                  help="clean modules instead of compiling them",
                  default=False)
parser.add_option("-a", "--rebuild-all", action="store_true",
                  dest="rebuild_all", default=False,
                  help="rebuild all private modules for a new default python version")
parser.add_option("-f", "--force-rebuild-all", action="store_true",
                  dest="rebuild_everything", default=False,
                  help="rebuild all modules, including public modules for all python versions")
parser.add_option("-p", "--post-install", action="store_true", dest="post_install",
                  help="run post-installation operations, common to many packages",
                  default=False)
parser.add_option("-b", "--bytecompile", action="store_true", dest="force_private",
                  help="[deprecated] byte-compilation mode: only handle private modules",
                  default=False)
parser.add_option("-i", "--install", action="store_true", dest="force_public",
                  help="[deprecated] installation mode: only handle public modules",
                  default=False)
(options, args) = parser.parse_args()

def debug(x):
    if(options.verbose):
        print x

def warning(x):
    sys.stderr.write("WARNING: %s\n"%x)

def isect(l1,l2):
    return [i for i in l1 if i in l2]

def concat(l1,l2):
    return l1 + [i for i in l2 if i not in l1]


# Abstract class implementing the methods related to public modules
class _PublicList (list):
    pyversions = py_supported
    def install (self, versions):
        versions = isect (self.pyversions, versions)
        for filename in self:
            version = None
            rng = versions
            try:
                if filename.startswith (shared_path+"/"):
                    # New layout, module
                    relname = filename[len(shared_path)+1:]
                elif filename.startswith (shared_extensionpath+"/python"):
                    # New layout, extension
                    [ version, relname ] = filename[len(shared_extensionpath)+1:].split("/", 1)
                elif filename.startswith (sourcepath+"/"):
                    [ package, relname ] = filename[len(sourcepath)+1:].split("/",1)
                elif filename.startswith (old_extensionpath+"/"):
                    [ package, version, relname ] = filename[len(old_extensionpath)+1:].split("/",2)
                else:
                    raise ValueError
            except ValueError:
                warning ("%s contains an invalid filename (%s)"%(self.name, filename))
                continue
            if version:
                if version not in versions:
                    continue
                rng = [version]
            for pyversion in rng:
                destpath = os.path.join (basepath, pyversion, relname)
                try:
                    os.makedirs(os.path.dirname(destpath))
                except OSError:
                    pass
                if filename[-4:] not in ['.pyc', '.pyo']:
                    debug("link "+destpath)
                    # os.path.exists returns False for broken symbolic links
                    if os.path.exists(destpath) or os.path.islink(destpath):
                        if file!="__init__.py" or (os.path.exists(destpath) and os.path.getsize(destpath)):
                            # The file is already here, probably from the previous version. 
                            # No need to check for conflicts, dpkg catches them earlier now
                            debug("overwrite "+destpath)
                        else:
                            debug("overwrite namespace "+destpath)
                        if os.path.isdir(destpath):
                            shutil.rmtree(destpath)
                        else:
                            os.remove(destpath)
                    os.symlink(filename,destpath)


# Abstract class implementing the methods related to private modules
class _PrivateList (list):
    pyversion = None
    def bytecompile (self):
        if self.pyversion:
            debug("Byte-compilation of whole %s with python%s..."%(self.name,self.pyversion))
            call(['/usr/bin/python'+self.pyversion, 
                  os.path.join('/usr/lib','python'+self.pyversion,'py_compile.py')]
                 + self)
        else:
            for filename in self:
                debug("compile "+filename+'c')
                try:
                    # Note that compile doesn't raise PyCompileError by default
                    compile(filename, doraise=True)
                except IOError, (errno, strerror):
                    warning("I/O error while trying to byte-compile %s (%s): %s" % (filename, errno, strerror))
                except PyCompileError, inst:
                    warning("compile error while trying to byte-compile %s: %s" % (filename, inst.msg))
                except:
                    warning("unexpected error while trying to byte-compile %s: %s" % (filename, sys.exc_info()[0]))
    def clean(self):
        for filename in self:
            for ext in ['c', 'o']:
                fullpath=filename+ext
                if os.path.exists(fullpath):
                    debug("remove "+fullpath)
                    os.remove(fullpath)


# Abstract class for PrivateFileList and SharedFileList
class _FileList(list):
    def __init__ (self, path):
        self.name = path
        for line in file(path):
            line = line.strip()
            if (not line) or line.startswith('#'):
                continue
            if line.startswith('/'):
                self.append(line)
                continue
            line = [x.strip() for x in line.split('=',1)]
            if len(line) != 2:
                warning("Parse error in %s"%path)
                continue
            self.parse_option(*line)

# This class represents a file list as provided in the /usr/share/python-support/$package.public
# Useful for public modules and extensions
class SharedFileList(_FileList, _PublicList):
    def parse_option (self, arg, value):
        if arg=='pyversions':
            self.pyversions = pysupport.version_list(value)
        # Ignore unknown arguments for extensivity

# This class represents a file list as provided in the /usr/share/python-support/$package.private
# Useful for private modules
class PrivateFileList(_FileList, _PrivateList):
    def parse_option (self, arg, value):
        if arg=='pyversion':
            self.pyversion = value

# This is a helper generator that goes through files of interest in a given directory
def allfiles(path, onlypy=False):
    for root, dirs, files in os.walk(path):
        for f in files:
            if (onlypy and not f.endswith(".py")) or f== ".version":
                continue
            yield os.path.join(root,f)
        if not onlypy:
            for d in dirs:
                d = os.path.join(root, d)
                if os.path.islink(d):
                    yield d

# This class emulates the file listing as provided by /usr/share/python-support/$package.public
# with the deprecated layout /usr/{lib,share}/python-support/$package/
class SharedDirList(_PublicList):
    def __init__ (self, path):
        self.name = path
        # Add all files to the file listing
        self.extend(allfiles(path))
        verfile=os.path.join(path,'.version')
        extdir=path.replace(sourcepath,old_extensionpath,1)
        if os.path.isfile(verfile):
            # If we have a .version, use it
            self.pyversions = pysupport.version_list(file(verfile).readline())
        elif os.path.isdir(extdir):
            # Try to obtain the list of supported versions
            # from the extensions in /usr/lib
            self.pyversions = isect(py_supported,os.listdir(extdir))
        else:
            # Otherwise, support all versions
            pass

        if os.path.isdir(extdir):
            # Add the extensions to the file listing
            for version in self.pyversions:
                self.extend(allfiles(os.path.join(extdir,version)))

# This class emulates the file listing as provided by /usr/share/python-support/$package.private
# with the deprecated layout /usr/share/python-support/$package.dirs
class PrivateDirList(_PrivateList):
    def __init__ (self, path):
        self.name = path
        self.extend(allfiles(path, onlypy=True))
        versionfile = os.path.join(path, ".pyversion")
        if os.path.isfile(versionfile):
            self.pyversion = file(versionfile).readline().strip()


class CachedFileList(dict):
    def __getitem__ (self, name):
        if name in self and dict.__getitem__(self, name) == None:
            if name.startswith("/"):
                # The case of old-style private directories
                self[name] = PrivateDirList (name)
            else:
                path = os.path.join (sourcepath, name)
                if name.endswith(".public"):
                    self[name] = SharedFileList (path)
                elif name.endswith(".private"):
                    self[name] = PrivateFileList (path)
                elif os.path.isdir(path):
                    self[name] = SharedDirList (path)
                else:
                    raise Exception("[Internal Error] I don't know what to do with this path: %s"%path)
        return dict.__getitem__(self, name)


def bytecompile_all(py,path=None):
    if not path:
        path=os.path.join(basepath,py)
    if not os.path.isdir(path):
        return
    debug("Byte-compilation of whole %s..."%path)
    os.spawnl(os.P_WAIT, '/usr/bin/'+py, py,
              os.path.join('/usr/lib/',py,'compileall.py'), '-q', path)

# A function to create the ".path" at the root of the installed directory
# Returns the list of affected directories
def create_dotpath(py):
  path=os.path.join(basepath,py)
  if not os.path.isdir(path):
    return
  pathfile=os.path.join(path,".path")
  debug("Generation of %s..."%pathfile)
  pathlist=[path]
  ret=[]
  for f in os.listdir(path):
    f=os.path.join(path,f)
    if f.endswith(".pth") and os.path.isfile(f):
      for l in file(f):
        l=l.rstrip('\n')
        if l.startswith('import'):
          # Do not ship lines starting with "import", they are executed! (complete WTF)
          continue
        pathlist.append(l)
        l2=os.path.join(path,l)
        pathlist.append(l2)
        ret.append(l2)
  fd=file(pathfile,"w")
  fd.writelines([l+'\n' for l in pathlist])
  fd.close()
  return ret

def post_change_stuff(py):
  # All the changes that need to be done after anything has changed
  # in a /usr/lib/pymodules/pythonX.Y directory
  # * Cleanup of all dangling symlinks that are left out after a package
  #   is upgraded/removed.
  # * The namespace packages are here because python doesn't consider a
  #   directory to be able to contain packages if there is no __init__.py
  #   file (yes, this is completely stupid).
  # * The .path file must be created by concatenating all those .pth
  #   files that extend sys.path (this also badly sucks).
  # * Byte-compilation of all .py files that haven't already been
  path=os.path.join(basepath,py)
  if not os.path.isdir(path):
    return
  # First, remove any dangling symlinks.
  # In the same loop, we find which directories may need a namespace package
  dirhash={}
  for dir, dirs, files in os.walk(path):
    dirhash[dir]=False
    files.sort() # We need the .py to appear before the .pyc
    for f in files+dirs:
      # We also examine dirs as some symlinks are dirs
      abspath=os.path.join(dir,f)
      islink=os.path.islink(abspath)
      if islink:
        if not os.path.exists(abspath):
          # We refer to a file that was removed
          debug("remove "+abspath)
          os.remove(abspath)
          continue
        srcfile = os.readlink (abspath)
        # Remove links left here after a change in the supported python versions for a package
        removed = False
        for package in public_packages:
          if srcfile in public_packages[package]:
            if py not in public_packages[package].pyversions:
              debug("remove "+abspath)
              os.remove(abspath)
              removed = True
            break
        else:
          # Remove files provided by packages that do not use python-support anymore
          debug("remove "+abspath)
          os.remove(abspath)
          removed = True
        if removed:
          # Do not go further, the file was removed
          continue
      if f[-4:] in ['.pyc', '.pyo']:
        if not os.path.exists(abspath[:-1]):
          debug("remove "+abspath)
          os.remove(abspath)
          continue
      elif f[-3:] in ['.py', '.so']:
        if islink or f!='__init__.py':
          # List the directory as maybe needing a namespace packages
          d=dir
          while dirhash.has_key(d) and not dirhash[d]:
            dirhash[d]=True
            d=os.path.dirname(d)
    # Remove the directory if it is empty after our crazy removals
    try:
      os.removedirs(dir)
    except OSError:
      pass
  dirhash[path]=False
  # Then, find which directories belong in a .pth file
  # These directories don't need a namespace package, so we
  # set them to False in dirhash
  for p in create_dotpath (py):
    dirhash[p] = False
  # Finally, create/remove namespace packages
  for dir in dirhash:
    initfile=os.path.join(dir,"__init__.py")
    noinitfile=os.path.join(dir,".noinit")
    if dirhash[dir] and not os.path.exists(noinitfile):
      if not os.path.exists(initfile):
        debug("create namespace "+initfile)
        file(initfile,"w").close()
    else:
      for e in ['','c','o']:
        if os.path.exists(initfile+e):
          debug('remove namespace '+initfile+e)
          os.remove(initfile+e)
      try:
        os.removedirs(dir)
      except OSError:
        pass
  bytecompile_all(py)


# A helper function for older $package.dirs files
def dirlist_file(f):
    return [ l.rstrip('\n') for l in file(f) if len(l)>1 ]

# End of function definitions - Start of the script itself

# Ensure that the umask is sane
os.umask(022)

# Read all modules listing
public_packages = CachedFileList()
private_packages = CachedFileList()
dirlisting = os.listdir(sourcepath)
for name in dirlisting:
    path=os.path.join(sourcepath,name)
    if name == "private":
        continue
    ext = name.split(".")[-1]
    if os.path.isdir(path):
        if ext in ["public", "private", "dirs"]:
            # Presumably a bogus directory, see #528130
            warning("%s is a directory"%name)
        else:
            public_packages[name] = None
        continue
    if not os.path.isfile(path):
        # Ignore whatever is not a file, like dangling symlinks
        continue
    if ext == "public":
        public_packages[name] = None
    elif ext == "private":
        private_packages[name] = None
    elif ext == "dirs":
        for dirname in dirlist_file (path):
            private_packages[dirname] = None
    # Just ignore all other files

# Parse arguments
do_public=[]
do_private=[]
for arg in args:
    if arg.startswith(sourcepath):
        arg = arg[len(sourcepath):].lstrip("/")
    if arg.endswith(".dirs") and arg in dirlisting:
        for dirname in dirlist_file(os.path.join(sourcepath, arg)):
            do_private.append(private_packages[dirname])
    elif arg in public_packages:
        do_public.append(public_packages[arg])
    elif arg in private_packages:
        do_private.append(private_packages[arg])
    else:
        if options.clean_mode:
            warning("%s does not exist.\n         Some bytecompiled files may be left behind."%arg)
        else:
            parser.error("%s is not a recognized python-support module."%arg)

# Check consistency options (although these ones should not exist anymore)
if do_private and options.force_public:
    parser.error("Option -i cannot be used with a .private module file.")
if do_public and options.force_private:
    parser.error("Option -b cannot be used with a .public module file.")

if options.rebuild_everything:
    options.rebuild_all = True
    for pyver in py_supported:
        dir = os.path.join(basepath,pyver)
        if os.path.isdir(dir):
            shutil.rmtree(dir)

# Check for changes in installed python versions
need_postinstall = []
for pyver in py_oldversions+py_supported:
    dir = os.path.join(basepath,pyver)
    # Check for ".path" because sometimes the directory already exists 
    # while the python version isn't installed, because of some .so's.
    if pyver not in py_installed and os.path.isdir(dir):
        debug("Removing obsolete directory %s..."%(dir))
        shutil.rmtree(dir)
    if pyver in py_installed and not os.path.isfile(os.path.join(dir,".path")):
        need_postinstall.append(pyver)
if need_postinstall:
    debug("Building all modules for %s..."%(" ".join(need_postinstall)))
    for package in public_packages:
        public_packages[package].install(need_postinstall)
    for pyver in need_postinstall:
        # Here we need to launch create_dotpath because otherwise we could
        # end up without the .path file that is checked 6 lines earlier
        create_dotpath(pyver)

if options.rebuild_all:
    for package in private_packages:
        private_packages[package].bytecompile()


# Now for the processing of what was handed on the command line
for package in do_private:
    if not options.clean_mode:
        package.bytecompile()
    else:
        package.clean()

need_dotpath = False
for package in do_public:
    need_postinstall = concat (need_postinstall, isect(package.pyversions,py_installed))
    if options.clean_mode:
        continue
    package.install(py_installed)
    for f in package:
        if f.endswith(".pth"):
            need_dotpath = True

# Only do the funny and time-consuming things when the -p option is
# given, e.g when python-support is triggered.
if need_postinstall and 'DPKG_RUNNING_VERSION' in os.environ and not options.post_install:
    ret = os.spawnlp(os.P_WAIT, 'dpkg-trigger', 'dpkg-trigger', '--no-await', 'pysupport')
    if ret:
        sys.stderr.write("ERROR: dpkg-trigger failed\n")
        sys.exit(1)
    if need_dotpath:
        for py in need_postinstall:
            create_dotpath (py)
    need_postinstall = []

if options.post_install:
    # The trigger has been activated; do it for all installed versions
    need_postinstall = py_installed
if need_postinstall:
    need_dotpath = False
    for py in need_postinstall:
        post_change_stuff(py)

                                                                                                                                                                              usr/sbin/xfs_admin                                                                                  0100755 0000000 0000000 00000002544 12363160775 012726  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh -f
#
# Copyright (c) 2000-2001 Silicon Graphics, Inc.  All Rights Reserved.
#

status=0
DB_OPTS=""
REPAIR_OPTS=""
USAGE="Usage: xfs_admin [-efjlpuV] [-c 0|1] [-L label] [-U uuid] device"

while getopts "efjlpuc:L:U:V" c
do
	case $c in
	c)	REPAIR_OPTS=$REPAIR_OPTS" -c lazycount="$OPTARG;;
	e)	DB_OPTS=$DB_OPTS" -c 'version extflg'";;
	f)	DB_OPTS=$DB_OPTS" -f";;
	j)	DB_OPTS=$DB_OPTS" -c 'version log2'";;
	l)	DB_OPTS=$DB_OPTS" -r -c label";;
	L)	DB_OPTS=$DB_OPTS" -c 'label "$OPTARG"'";;
	p)	DB_OPTS=$DB_OPTS" -c 'version projid32bit'";;
	u)	DB_OPTS=$DB_OPTS" -r -c uuid";;
	U)	DB_OPTS=$DB_OPTS" -c 'uuid "$OPTARG"'";;
	V)	xfs_db -p xfs_admin -V
		status=$?
		exit $status
		;;
	\?)	echo $USAGE 1>&2
		exit 2
		;;
	esac
done
set -- extra $@
shift $OPTIND
case $# in
	1)	if [ -n "$DB_OPTS" ]
		then
			eval xfs_db -x -p xfs_admin $DB_OPTS $1
			status=$?
		fi
		if [ -n "$REPAIR_OPTS" ]
		then
			# Hide normal repair output which is sent to stderr
			# assuming the filesystem is fine when a user is
			# running xfs_admin.
			# Ideally, we need to improve the output behaviour
			# of repair for this purpose (say a "quiet" mode).
			eval xfs_repair $REPAIR_OPTS $1 2> /dev/null
			status=`expr $? + $status`
			if [ $status -ne 0 ]
			then
				echo "Conversion failed, is the filesystem unmounted?"
			fi
		fi
		;;
	*)	echo $USAGE 1>&2
		exit 2
		;;
esac
exit $status
                                                                                                                                                            usr/sbin/xfs_bmap                                                                                   0100755 0000000 0000000 00000001176 12363161000 012533  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh -f
#
# Copyright (c) 2003 Silicon Graphics, Inc.  All Rights Reserved.
#

OPTS=""
VERSION=false
USAGE="Usage: xfs_bmap [-adlpvV] [-n nx] file..."
DIRNAME=`dirname $0`

while getopts "adln:pvV" c
do
	case $c in
	a)	OPTS=$OPTS" -a";;
	d)	OPTS=$OPTS" -d";;
	l)	OPTS=$OPTS" -l";;
	n)	OPTS=$OPTS" -n "$OPTARG;;
	p)	OPTS=$OPTS" -p";;
	v)	OPTS=$OPTS" -v";;
	V)	VERSION=true;;
	\?)	echo $USAGE 1>&2
		exit 2
		;;
	esac
done
$VERSION && $DIRNAME/xfs_io -p xfs_bmap -V

shift `expr $OPTIND - 1`

while [ "$1" != "" ]
do
	$DIRNAME/xfs_io -r -p xfs_bmap -c "bmap $OPTS" "$1"
	status=$?
	[ $status -ne 0 ] && exit $status
	shift
done
exit 0
                                                                                                                                                                                                                                                                                                                                                                                                  usr/sbin/xfs_copy                                                                                   0100755 0000000 0000000 00001076760 12363161040 012606  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF          >    4@     @       0w         @ 8  @         @       @ @     @ @     ¿      ¿                           @      @                                          @       @     N     N                    P      Pd      Pd     @&      »)                    P     Pd     Pd                                      @     @     D       D              PÂtd   ‡Ø     ‡ØC     ‡ØC     t      t             QÂtd                                                  /lib64/ld-linux-x86-64.so.2          GNU                        GNU ÙLHpú8d˘çç˜ç√buÁ   V            V   W   X   )å9Úã2ƒ˜≥¢˜                            r                     Ú                     0                     Ï                     ‚                                          ˆ                      Î                                            ù                     §                     h                     ˝                     *                     ≈                                          Ö                     #                     ô                     ∑                                          ≈                     '                     @                     Z                     ú                      À                     g                      g                                           ±                     Ω                     H                     a                     π                      F                     -                     ÿ                                          O                     €                     Y                     a                     *                       m                     C                     ?                     ‚                     N                     „                      ~                     ñ                     t                                          ~                      ˙                     ˆ             