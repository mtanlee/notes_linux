.mak,
	    src/testdir/Make_ming.mak, src/testdir/Make_os2.mak,
	    src/testdir/Make_vms.mms, src/testdir/Makefile

Patch 7.3.817
Problem:    Test 89 fails with tiny and small features.
Solution:   Add sourcing small.vim.
Files:	    src/testdir/test89.in

Patch 7.3.818
Problem:    When test 40 fails because of a bad build it may leave files
	    behind that cause it to fail later.
Solution:   Let the file names start with "X".
Files:	    src/testdir/test40.in

Patch 7.3.819
Problem:    Compiling without +eval and with Python isn't working.
Solution:   Add the eval feature when building with Python.
Files:	    src/if_py_both.h, src/feature.h, src/eval.c, src/ex_docmd.c,
	    src/normal.c, src/ex_docmd.c, src/gui_gtk_x11.c

Patch 7.3.820
Problem:    Build errors and warnings when building with small features and
	    Lua, Perl or Ruby.
Solution:   Add #ifdefs and UNUSED.
Files:	    src/if_perl.xs, src/if_lua.c, src/if_ruby.c

Patch 7.3.821
Problem:    Build with OLE and Cygwin is broken. (Steve Hall)
Solution:   Select static or shared stdc library. (Ken Takata)
Files:	    src/Make_cyg.mak

Patch 7.3.822 (after 7.3.799)
Problem:    Crash when accessing freed buffer.
Solution:   Get 'textwidth' in caller of enter_buffer(). (Christian Brabandt)
Files:	    src/buffer.c

Patch 7.3.823 (after 7.3.821)
Problem:    Building with Cygwin: '-lsupc++' is not needed.
Solution:   Remove it. (Ken Takata)
Files:	    src/Make_cyg.mak

Patch 7.3.824
Problem:    Can redefine builtin functions.  (ZyX)
Solution:   Disallow adding a function to g:.
Files:	    src/eval.c

Patch 7.3.825
Problem:    With Python errors are not always clear.
Solution:   Print the stack trace, unless :silent is used. (ZyX)
Files:	    src/if_python3.c, src/if_python.c

Patch 7.3.826
Problem:    List of features in :version output is hard to read.
Solution:   Make columns. (Nazri Ramliy)
Files:	    src/version.c

Patch 7.3.827 (after 7.3.825)
Problem:    Python tests fail.
Solution:   Adjust the output for the stack trace.
Files:	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.ok

Patch 7.3.828
Problem:    Mappings are not aware of wildmenu mode.
Solution:   Add wildmenumode(). (Christian Brabandt)
Files:	    src/eval.c, runtime/doc/eval.txt

Patch 7.3.829
Problem:    When compiled with the +rightleft feature 'showmatch' also shows a
	    match for the opening paren.  When 'revins' is set the screen may
	    scroll.
Solution:   Only check the opening paren when the +rightleft feature was
	    enabled.  Do not show a match that is not visible. (partly by
	    Christian Brabandt)
Files:	    src/search.c

Patch 7.3.830
Problem:    :mksession confuses bytes, columns and characters when positioning
	    the cursor.
Solution:   Use w_virtcol with "|" instead of w_cursor.col with "l".
Files:	    src/ex_docmd.c

Patch 7.3.831
Problem:    Clumsy to handle the situation that a variable does not exist.
Solution:   Add default value to getbufvar() et al. (Shougo Matsushita,
	    Hirohito Higashi)
Files:	    runtime/doc/eval.txt, src/eval.c src/testdir/test91.in,
	    src/testdir/test91.ok, src/testdir/Make_amiga.mak,
	    src/testdir/Make_dos.mak, src/testdir/Make_ming.mak,
	    src/testdir/Make_os2.mak, src/testdir/Make_vms.mms,
	    src/testdir/Makefile

Patch 7.3.832
Problem:    Compiler warning.
Solution:   Add type cast. (Mike Williams)
Files:	    src/version.c

Patch 7.3.833
Problem:    In the terminal the scroll wheel always scrolls the active window.
Solution:   Scroll the window under the mouse pointer, like in the GUI.
	    (Bradie Rao)
Files:	    src/edit.c, src/normal.c

Patch 7.3.834
Problem:    Ruby 2.0 has a few API changes.
Solution:   Add handling of Ruby 2.0. (Yasuhiro Matsumoto)
Files:	    src/if_ruby.c

Patch 7.3.835
Problem:    "xxd -i" fails on an empty file.
Solution:   Do output the closing } for an empty file. (partly by Lawrence
	    Woodman)
Files:	    src/xxd/xxd.c

Patch 7.3.836
Problem:    Clipboard does not work on Win32 when compiled with Cygwin.
Solution:   Move the Win32 clipboard code to a separate file and use it when
	    building with os_unix.c. (Frodak Baksik, Ken Takata)
Files:	    src/Make_bc5.mak, src/Make_cyg.mak, src/Make_ivc.mak,
	    src/Make_ming.mak, src/Make_mvc.mak, src/Make_w16.mak,
	    src/Makefile, src/config.h.in, src/configure.in,
	    src/auto/configure, src/feature.h, src/globals.h, src/mbyte.c,
	    src/os_mswin.c, src/os_unix.c, src/os_win32.c, src/proto.h,
	    src/proto/os_mswin.pro, src/proto/winclip.pro, src/term.c,
	    src/vim.h, src/winclip.c

Patch 7.3.837 (after 7.3.826)
Problem:    Empty lines in :version output when 'columns' is 320.
Solution:   Simplify the logic of making columns. (Nazri Ramliy, Roland
	    Eggner)
Files:	    src/version.c

Patch 7.3.838 (after 7.3.830)
Problem:    Insufficient testing for mksession.
Solution:   Add tests. (mostly by Roland Eggner)
Files:	    src/testdir/Make_amiga.mak, src/testdir/Make_dos.mak,
	    src/testdir/Make_ming.mak, src/testdir/Make_os2.mak,
	    src/testdir/Make_vms.mms, src/testdir/Makefile,
	    src/testdir/test92.in, src/testdir/test92.ok,
	    src/testdir/test93.in, src/testdir/test93.ok,
	    src/ex_docmd.c

Patch 7.3.839
Problem:    Some files missing in the list of distributed files.
Solution:   Add lines for new files.
Files:	    Filelist

Patch 7.3.840
Problem:    "\@<!" in regexp does not work correctly with multi-byte
	    characters, especially cp932.
Solution:   Move column to start of multi-byte character. (Yasuhiro Matsumoto)
Files:	    src/regexp.c

Patch 7.3.841
Problem:    When a "cond ? one : two" expression has a subscript it is not
	    parsed correctly. (Andy Wokula)
Solution:   Handle a subscript also when the type is unknown. (Christian
	    Brabandt)
Files:	    src/eval.c

Patch 7.3.842
Problem:    Compiler warning for signed/unsigned pointer.
Solution:   Add type cast. (Christian Brabandt)
Files:	    src/eval.c

Patch 7.3.843 (after 7.3.841)
Problem:    Missing test file changes.
Solution:   Change the tests.
Files:	    src/testdir/test49.vim, src/testdir/test49.ok

Patch 7.3.844
Problem:    Enum is not indented correctly with "public" etc.
Solution:   Skip "public", "private" and "protected". (Hong Xu)
Files:	    src/misc1.c

Patch 7.3.845 (after 7.3.844)
Problem:    Enum indenting is not tested.
Solution:   Add tests. (Hong Xu)
Files:	    src/testdir/test3.in, src/testdir/test3.ok

Patch 7.3.846
Problem:    Missing proto files.
Solution:   Add the files.
Files:	    Filelist, src/proto/os_beos.pro

Patch 7.3.847
Problem:    Test 55 fails when messages are translated.
Solution:   Set language to C. (Ken Takata)
Files:	    src/testdir/test55.in

Patch 7.3.848
Problem:    Can't build with Ruby 2.0 when using MinGW x64 or MSVC10.
Solution:   Fix it. Also detect RUBY_PLATFORM and RUBY_INSTALL_NAME for x64.
	    (Ken Takata)
Files:	    src/Make_cyg.mak, src/Make_ming.mak, src/if_ruby.c

Patch 7.3.849
Problem:    ":g//" gives "Pattern not found error" with E486.  Should not use
	    the error number, it's not a regular error message.
Solution:   Use a normal message. (David Bürgin)
Files:	    src/ex_cmds.c

Patch 7.3.850
Problem:    ":vimgrep //" matches everywhere.
Solution:   Make it use the previous search pattern. (David Bürgin)
Files:	    runtime/doc/quickfix.txt, src/quickfix.c

Patch 7.3.851
Problem:    Using an empty pattern with :sort silently continues when there is
	    no previous search pattern.
Solution:   Give an error message. (David Bürgin)
Files:	    src/ex_cmds.c

Patch 7.3.852
Problem:    system() breaks clipboard text. (Yukihiro Nakadaira)
Solution:   Use Xutf8TextPropertyToTextList(). (Christian Brabandt)
	    Also do not put the text in the clip buffer if conversion fails.
Files:	    src/ui.c, src/ops.c

Patch 7.3.853
Problem:    Using "ra" in multiple lines on multi-byte characters leaves a few
	    characters not replaced.
Solution:   Adjust the end column only in the last line. (Yasuhiro Matsumoto)
Files:	    src/testdir/test69.in, src/testdir/test69.ok, src/ops.c

Patch 7.3.854
Problem:    After using backspace in insert mode completion, CTRL-N and CTRL-P
	    do not highlight the right entry. (Olivier Teuliere)
Solution:   Set the current item to the shown item after using backspace.
Files:	    src/edit.c

Patch 7.3.855
Problem:    Compiler warnings.
Solution:   Add type casts. (Mike Williams)
Files:	    src/misc1.c

Patch 7.3.856
Problem:    When calling system() multi-byte clipboard contents is garbled.
Solution:   Save and restore the clipboard contents.  (Yukihiro Nakadaira)
Files:	    src/gui_gtk_x11.c, src/proto/gui_gtk_x11.pro, src/ops.c,
	    src/proto/ops.pro, src/os_unix.c, src/proto/ui.pro, src/ui.c

Patch 7.3.857
Problem:    The QuitPre autocommand event does not trigger for :qa and :wq.
Solution:   Trigger the event. (Tatsuro Fujii)
Files:	    src/ex_docmd.c

Patch 7.3.858
Problem:    "gv" selects the wrong area after some operators.
Solution:   Save and restore the type of selection. (Christian Brabandt)
Files:	    src/testdir/test66.in, src/testdir/test66.ok, src/normal.c

Patch 7.3.859
Problem:    'ambiwidth' must be set by the user.
Solution:   Detects East Asian ambiguous width (UAX #11) state of the terminal
	    at the start-up time and 'ambiwidth' accordingly.  (Hayaki Saito)
Files:	    src/main.c, src/option.c, src/term.c, src/term.h,
	    src/proto/term.pro

Patch 7.3.860
Problem:    When using --remote-expr try/catch does not work. (Andrey Radev)
Solution:   Set emsg_silent instead of emsg_skip.
Files:	    src/main.c

Patch 7.3.861
Problem:    ":setlocal number" clears global value of 'relativenumber'.
Solution:   Do it properly. (Markus Heidelberg)
Files:	    src/testdir/test89.in, src/testdir/test89.ok, src/option.c

Patch 7.3.862
Problem:    Dragging the status line can be slow.
Solution:   Look ahead and drop the drag event if there is a next one.
Files:	    src/eval.c, src/misc1.c, src/proto/misc1.pro, src/normal.c

Patch 7.3.863 (after 7.3.859)
Problem:    Problem with 'ambiwidth' detection for ANSI terminal.
Solution:   Work around not recognizing a term response. (Hayaki Saito)
Files:	    src/term.c

Patch 7.3.864 (after 7.3.862)
Problem:    Can't build without the mouse feature.
Solution:   Add an #ifdef. (Ike Devolder)
Files:	    src/misc1.c

Patch 7.3.865 (after 7.3.862)
Problem:    Mouse position may be wrong.
Solution:   Let vungetc() restore the mouse position.
Files:	    src/getchar.c

Patch 7.3.866
Problem:    Not serving the X selection during system() isn't nice.
Solution:   When using fork() do not loose the selection, keep serving it.
	    Add a loop similar to handling I/O. (Yukihiro Nakadaira)
Files:	    src/os_unix.c

Patch 7.3.867
Problem:    Matchparen does not update match when using auto-indenting.
	    (Marc Aldorasi)
Solution:   Add the TextChanged and TextChangedI autocommand events.
Files:	    runtime/plugin/matchparen.vim, src/main.c, src/edit.c,
	    src/globals.h, src/vim.h, src/fileio.c, src/proto/fileio.pro,
	    runtime/doc/autocmd.txt

Patch 7.3.868
Problem:    When at the hit-return prompt and using "k" while no text has
	    scrolled off screen, then using "j", an empty line is displayed.
Solution:   Only act on "k" when text scrolled off screen.  Also accept
	    page-up and page-down.  (cptstubing)
Files:	    src/message.c

Patch 7.3.869
Problem:    bufwinnr() matches buffers in other tabs.
Solution:   For bufwinnr() and ? only match buffers in the current tab.
	    (Alexey Radkov)
Files:	    src/buffer.c, src/diff.c, src/eval.c, src/ex_docmd.c,
	    src/if_perl.xs, src/proto/buffer.pro

Patch 7.3.870
Problem:    Compiler warnings when using MingW 4.5.3.
Solution:   Do not use MAKEINTRESOURCE. Adjust #if. (Ken Takata)
Files:	    src/gui_w32.c, src/gui_w48.c, src/os_mswin.c, src/os_win32.c,
	    src/os_win32.h

Patch 7.3.871
Problem:    search('^$', 'c') does not use the empty match under the cursor.
Solution:   Special handling of the 'c' flag. (Christian Brabandt)
	    Add tests.
Files:	    src/search.c, src/testdir/test14.in, src/testdir/test14.ok

Patch 7.3.872
Problem:    On some systems case of file names is always ignored, on others
	    never.
Solution:   Add the 'fileignorecase' option to control this at runtime.
	    Implies 'wildignorecase'.
Files:	    src/buffer.c, src/edit.c, src/ex_cmds2.c, src/ex_getln.c,
	    src/fileio.c, src/misc1.c, src/misc2.c, src/option.c,
	    src/option.h, src/vim.h, runtime/doc/options.txt

Patch 7.3.873
Problem:    Cannot easily use :s to make title case.
Solution:   Have "\L\u" result in title case. (James McCoy)
Files:	    src/regexp.c, src/testdir/test79.in, src/testdir/test79.ok,
	    src/testdir/test80.in, src/testdir/test80.ok

Patch 7.3.874
Problem:    Comparing file names does not handle multi-byte characters
	    properly.
Solution:   Implement multi-byte handling.
Files:	    src/misc1.c, src/misc2.c

Patch 7.3.875 (after 7.3.866)
Problem:    Build problem with some combination of features.
Solution:   Use FEAT_XCLIPBOARD instead of FEAT_CLIPBOARD.
Files:	    src/os_unix.c

Patch 7.3.876
Problem:    #if indents are off.
Solution:   Insert a space where appropriate. (Taro Muraoka)
Files:	    src/gui.c

Patch 7.3.877 (after 7.3.871)
Problem:    Forward searching with search() is broken.
Solution:   Fix it and add tests. (Sung Pae)
Files:	    src/search.c, src/testdir/test14.in, src/testdir/test14.ok

Patch 7.3.878
Problem:    'fileignorecase' is missing in options window and quickref.
Solution:   Add the option.
Files:	    runtime/optwin.vim, runtime/doc/quickref.txt

Patch 7.3.879
Problem:    When using an ex command in operator pending mode, using Esc to
	    abort the command still executes the operator. (David Bürgin)
Solution:   Clear the operator when the ex command fails. (Christian Brabandt)
Files:	    src/normal.c

Patch 7.3.880
Problem:    When writing viminfo, old history lines may replace lines written
	    more recently by another Vim instance.
Solution:   Mark history entries that were read from viminfo and overwrite
	    them when merging with the current viminfo.
Files:	    src/ex_getln.c

Patch 7.3.881
Problem:    Python list does not work correctly.
Solution:   Fix it and add a test. (Yukihiro Nakadaira)
Files:	    src/testdir/test86.in, src/testdir/test86.ok, src/if_py_both.h

Patch 7.3.882
Problem:    CursorHold may trigger after receiving the termresponse.
Solution:   Set the did_cursorhold flag. (Hayaki Saito)
Files:	    src/term.c

Patch 7.3.883 (after 7.3.880)
Problem:    Can't build with some combination of features.
Solution:   Adjust #ifdefs.
Files:	    src/ex_getln.c

Patch 7.3.884
Problem:    Compiler warning for variable shadowing another. (John Little)
Solution:   Rename the variable. (Christian Brabandt)
Files:	    src/term.c

Patch 7.3.885
Problem:    Double free for list and dict in Lua. (Shougo Matsu)
Solution:   Do not unref list and dict. (Yasuhiro Matsumoto)
Files:	    src/if_lua.c

Patch 7.3.886
Problem:    Can't build with multi-byte on Solaris 10.
Solution:   Add #ifdef X_HAVE_UTF8_STRING. (Laurent Blume)
Files:	    src/ui.c

Patch 7.3.887
Problem:    No tests for Visual mode operators, what 7.3.879 fixes.
Solution:   Add a new test file. (David Bürgin)
Files:	    src/testdir/test94.in, src/testdir/test94.ok,
	    src/testdir/Make_amiga.mak, src/testdir/Make_dos.mak,
	    src/testdir/Make_ming.mak, src/testdir/Make_os2.mak,
	    src/testdir/Make_vms.mms, src/testdir/Makefile

Patch 7.3.888
Problem:    Filename completion with 'fileignorecase' does not work for
	    multi-byte characters.
Solution:   Make 'fileignorecase' work properly. (Hirohito Higashi)
Files:	    src/misc2.c

Patch 7.3.889
Problem:    Can't build with Ruby 2.0 on a 64 bit system.
Solution:   Define rb_fix2int and rb_num2int. (Kohei Suzuki)
Files:	    src/if_ruby.c

Patch 7.3.890
Problem:    Test 79 fails on Windows. (Michael Soyka)
Solution:   Add comment below line causing an error.
Files:	    src/testdir/test79.in

Patch 7.3.891
Problem:    Merging viminfo history doesn't work well.
Solution:   Don't stop when one type of history is empty. Don't merge history
	    when writing viminfo.
Files:	    src/ex_getln.c

Patch 7.3.892 (after 7.3.891)
Problem:    Still merging problems for viminfo history.
Solution:   Do not merge lines when writing, don't write old viminfo lines.
Files:	    src/ex_getln.c, src/ex_cmds.c, src/proto/ex_getln.pro

Patch 7.3.893
Problem:    Crash when using b:, w: or t: after closing the buffer, window or
	    tabpage.
Solution:   Allocate the dictionary instead of having it part of the
	    buffer/window/tabpage struct. (Yukihiro Nakadaira)
Files:	    src/buffer.c, src/eval.c, src/fileio.c, src/structs.h,
	    src/window.c, src/proto/eval.pro

Patch 7.3.894
Problem:    Using wrong RUBY_VER causing Ruby build to break.
Solution:   Correct the RUBY_VER value. (Yongwei Wu)
Files:	    src/bigvim.bat

Patch 7.3.895
Problem:    Valgrind error in test 91. (Issue 128)
Solution:   Pass scope name to find_var_in_ht().
Files:	    src/eval.c

Patch 7.3.896
Problem:    Memory leaks in Lua interface.
Solution:   Fix the leaks, add tests. (Yukihiro Nakadaira)
Files:	    src/testdir/test85.in, src/testdir/test85.ok, src/if_lua.c

Patch 7.3.897
Problem:    Configure doesn't always find the shared library.
Solution:   Change the configure script. (Ken Takata)
Files:	    src/configure.in, src/auto/configure

Patch 7.3.898
Problem:    Memory leak reported by valgrind in test 91.
Solution:   Only use default argument when needed.
Files:	    src/eval.c, src/testdir/test91.in, src/testdir/test91.ok

Patch 7.3.899
Problem:    #if indents are off.
Solution:   Fix the indents.
Files:	    src/os_unix.c

Patch 7.3.900
Problem:    Not obvious that some mouse features are mutual-exclusive.
Solution:   Add a comment.
Files:	    src/feature.h

Patch 7.3.901
Problem:    Outdated comment, ugly condition.
Solution:   Update a few comments, break line.
Files:	    src/getchar.c, src/misc1.c, src/undo.c

Patch 7.3.902
Problem:    When deleting last buffer in other tab the tabline is not updated.
Solution:   Set the redraw_tabline flag. (Yukihiro Nakadaira)
Files:	    src/window.c

Patch 7.3.903 (after 7.3.892)
Problem:    Crash on exit writing viminfo. (Ron Aaron)
Solution:   Check for the history to be empty.
Files:	    src/ex_getln.c

Patch 7.3.904 (after 7.3.893)
Problem:    Using memory freed by the garbage collector.
Solution:   Mark items in aucmd_win as used.
Files:	    src/eval.c

Patch 7.3.905 (after 7.3.903)
Problem:    Crash when writing viminfo. (Ron Aaron)
Solution:   Prevent freed history info to be used.
Files:	    src/ex_getln.c

Patch 7.3.906
Problem:    The "sleep .2" for running tests does not work on Solaris.
Solution:   Fall back to using "sleep 1". (Laurent Blume)
Files:	    src/testdir/Makefile

Patch 7.3.907
Problem:    Python uses IndexError when a dict key is not found.
Solution:   Use KeyError instead. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c,
	    src/testdir/test86.ok, src/testdir/test87.ok

Patch 7.3.908
Problem:    Possible crash when using a list in Python.
Solution:   Return early if the list is NULL. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.909
Problem:    Duplicate Python code.
Solution:   Move more items to if_py_both.h. (ZyX)  Also avoid compiler
	    warnings for missing initializers.
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c

Patch 7.3.910
Problem:    Python code in #ifdef branches with only minor differences.
Solution:   Merge the #ifdef branches. (ZyX)
Files:	    src/if_py_both.h, src/if_python.c

Patch 7.3.911
Problem:    Python: Access to Vim variables is not so easy.
Solution:   Define vim.vars and vim.vvars. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/eval.c, src/globals.h,
	    src/if_py_both.h, src/if_python3.c, src/if_python.c,
	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.912
Problem:    Typing a ":" command at the hit-enter dialog does not work if the
	    "file changed" dialog happens next.
Solution:   Check for changed files before giving the hit-enter dialog.
Files:	    src/message.c

Patch 7.3.913 (after 7.3.905)
Problem:    Still a crash when writing viminfo.
Solution:   Add checks for NULL pointers. (Ron Aaron)
Files:	    src/ex_getln.c

Patch 7.3.914
Problem:    ~/.viminfo is messed up when running tests.
Solution:   Set the viminfo filename.
Files:	    src/testdir/test89.in, src/testdir/test94.in

Patch 7.3.915
Problem:    When reading a file with encoding conversion fails at the end the
	    next encoding in 'fencs' is not used.
Solution:   Retry with another encoding when possible. (Taro Muraoka)
Files:	    src/fileio.c

Patch 7.3.916
Problem:    Using freed memory when pasting with the mouse (Issue 130).
Solution:   Get the byte value early. (hint by Dominique Pelle)
Files:	    src/buffer.c

Patch 7.3.917
Problem:    When a path ends in a backslash appending a comma has the wrong
	    effect.
Solution:   Replace a trailing backslash with a slash. (Nazri Ramliy)
Files:	    src/misc1.c, src/testdir/test73.in, src/testdir/test73.ok

Patch 7.3.918
Problem:    Repeating an Ex command after using a Visual motion does not work.
Solution:   Check for an Ex command being used. (David Bürgin)
Files:	    src/normal.c

Patch 7.3.919 (after 7.3.788)
Problem:    An empty nl.po file does not work with an old msgfmt.
Solution:   Put a single # in the file. (Laurent Blume)
Files:	    src/po/Makefile

Patch 7.3.920
Problem:    Compiler warning for size_t to int.
Solution:   Add a type cast. (Mike Williams)
Files:	    src/misc1.c

Patch 7.3.921 (after 7.3.697)
Problem:    Trying to create a fontset handle when 'guifontset' is not set.
Solution:   Add curly braces around the code block. (Max Kirillov)
Files:	    src/syntax.c

Patch 7.3.922
Problem:    No test for what 7.3.918 fixes.
Solution:   Add a test. (David Bürgin)
Files:	    src/testdir/test94.in, src/testdir/test94.ok

Patch 7.3.923
Problem:    Check for X11 header files fails on Solaris.
Solution:   Only use -Werror for gcc. (Laurent Blume)
Files:	    src/configure.in, src/auto/configure

Patch 7.3.924
Problem:    Python interface can't easily access options.
Solution:   Add vim.options, vim.window.options and vim.buffer.options. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/eval.c, src/if_py_both.h,
	    src/if_python.c, src/if_python3.c, src/option.c,
	    src/proto/eval.pro, src/proto/option.pro, src/testdir/test86.in,
	    src/testdir/test86.ok, src/testdir/test87.in,
	    src/testdir/test87.ok, src/vim.h

Patch 7.3.925
Problem:    Typos in source files.
Solution:   Fix the typos. (Ken Takata)
Files:	    runtime/plugin/matchparen.vim, runtime/tools/vim_vs_net.cmd,
	    src/GvimExt/gvimext.cpp, src/INSTALLvms.txt, src/Make_cyg.mak,
	    src/Make_mvc.mak, src/Make_sas.mak, src/Make_vms.mms,
	    src/Make_w16.mak, src/Makefile, src/VisVim/OleAut.cpp,
	    src/VisVim/README_VisVim.txt, src/auto/configure, src/buffer.c,
	    src/configure.in, src/diff.c, src/dosinst.c, src/edit.c,
	    src/eval.c, src/ex_cmds2.c, src/ex_docmd.c, src/ex_eval.c,
	    src/farsi.c, src/feature.h, src/fileio.c, src/glbl_ime.cpp,
	    src/gui.c, src/gui_athena.c, src/gui_beval.c, src/gui_gtk_x11.c,
	    src/gui_mac.c, src/gui_motif.c, src/gui_photon.c, src/gui_w16.c,
	    src/gui_w32.c, src/gui_w48.c, src/gui_xmebw.c, src/gui_xmebwp.h,
	    src/hardcopy.c, src/if_cscope.c, src/if_mzsch.c, src/if_ole.cpp,
	    src/if_perl.xs, src/if_py_both.h, src/if_python.c,
	    src/if_python3.c, src/if_ruby.c, src/main.aap, src/mbyte.c,
	    src/memfile.c, src/memline.c, src/misc1.c, src/misc2.c,
	    src/nbdebug.c, src/normal.c, src/ops.c, src/os_amiga.c,
	    src/os_mac.h, src/os_msdos.c, src/os_mswin.c, src/os_win16.h,
	    src/os_win32.c, src/os_win32.h, src/quickfix.c, src/screen.c,
	    src/search.c, src/spell.c, src/structs.h, src/syntax.c,
	    src/window.c, vimtutor.com


Patch 7.3.926
Problem:    Autocommands are triggered by setwinvar() et al. Missing BufEnter
	    on :tabclose. Duplicate WinEnter on :tabclose. Wrong order of
	    events for :tablose and :tabnew.
Solution:   Fix these autocommand events. (ZyX)
Files:	    runtime/doc/eval.txt, src/buffer.c, src/eval.c, src/ex_cmds2.c,
	    src/fileio.c, src/proto/window.pro, src/testdir/test62.in,
	    src/testdir/test62.ok, src/window.c

Patch 7.3.927
Problem:    Missing combining characters when putting text in a register.
Solution:   Include combining characters. (David Bürgin)
Files:	    src/getchar.c, src/testdir/test44.in, src/testdir/test44.ok

Patch 7.3.928 (after 7.3.924)
Problem:    Can't build with strict C compiler.
Solution:   Move declaration to start of block. (Taro Muraoka)
Files:	    src/if_py_both.h

Patch 7.3.929 (after 7.3.924)
Problem:    Compiler warning for unused variable. Not freeing unused string.
Solution:   Remove the variable. Clear the options.
Files:	    src/option.c

Patch 7.3.930
Problem:    MSVC 2012 update is not recognized.
Solution:   Update the version in the makefile. (Raymond Ko)
Files:	    src/Make_mvc.mak

Patch 7.3.931
Problem:    No completion for :xmap and :smap. (Yukihiro Nakadaira)
Solution:   Add the case statements. (Christian Brabandt)
Files:	    src/ex_docmd.c

Patch 7.3.932
Problem:    Compiler warning for uninitialized variable. (Tony Mechelynck)
Solution:   Initialize the variable.
Files:	    src/option.c

Patch 7.3.933
Problem:    Ruby on Mac crashes due to GC failure.
Solution:   Init the stack from main(). (Hiroshi Shirosaki)
Files:	    src/main.c, src/if_ruby.c, src/proto/if_ruby.pro

Patch 7.3.934
Problem:    E381 and E380 make the user think nothing happened.
Solution:   Display the message indicating what error list is now active.
	    (Christian Brabandt)
Files:	    src/quickfix.c

Patch 7.3.935 (after 7.3.933)
Problem:    Ruby: Init stack works differently on 64 bit systems.
Solution:   Handle 64 bit systems and also static library. (Yukihiro
	    Nakadaira)
Files:	    src/if_ruby.c

Patch 7.3.936 (after 7.3.935)
Problem:    Ruby 1.8: Missing piece for static linking on 64 bit systems.
Solution:   Define ruby_init_stack() (Hiroshi Shirosaki)
	    Also fix preprocessor indents.
Files:	    src/if_ruby.c

Patch 7.3.937
Problem:    More can be shared between Python 2 and 3.
Solution:   Move code to if_py_both.h. (ZyX)
Files:	    src/if_python.c, src/if_python3.c, src/if_py_both.h

Patch 7.3.938
Problem:    Python: not easy to get to window number.
Solution:   Add vim.window.number. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/if_py_both.h, src/proto/window.pro,
	    src/window.c

Patch 7.3.939
Problem:    Using Py_BuildValue is inefficient sometimes.
Solution:   Use PyLong_FromLong(). (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.940
Problem:    Python: Can't get position of window.
Solution:   Add window.row and window.col. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/if_py_both.h

Patch 7.3.941
Problem:    Stuff in if_py_both.h is ordered badly.
Solution:   Reorder by type. (ZyX)
Files:	    src/if_py_both.h, src/if_python.c

Patch 7.3.942
Problem:    Python: SEGV in Buffer functions.
Solution:   Call CheckBuffer() at the right time. (ZyX)
Files:	    src/if_py_both.h, src/if_python.c, src/if_python3.c

Patch 7.3.943
Problem:    Python: Negative indices were failing.
Solution:   Fix negative indices. Add tests. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/testdir/test86.in,
	    src/testdir/test86.ok, src/testdir/test87.in,
	    src/testdir/test87.ok

Patch 7.3.944
Problem:    External program receives the termresponse.
Solution:   Insert a delay and discard input. (Hayaki Saito)
Files:	    src/term.c

Patch 7.3.945
Problem:    Python: List of buffers is not very useful.
Solution:   Make vim.buffers a map. No iterator yet. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/if_py_both.h, src/if_python3.c,
	    src/if_python.c, src/testdir/test86.ok, src/testdir/test87.ok

Patch 7.3.946
Problem:    Sometimes get stuck in waiting for cursor position report,
	    resulting in keys starting with <Esc>[ not working.
Solution:   Only wait for more characters after <Esc>[ if followed by '?', '>'
	    or a digit.
Files:	    src/term.c

Patch 7.3.947
Problem:    Python: No iterator for vim.list and vim.bufferlist.
Solution:   Add the iterators. Also fix name of FunctionType. Add tests for
	    vim.buffers.  (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/eval.c, src/if_py_both.h,
	    src/if_python3.c, src/if_python.c, src/proto/eval.pro,
	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.948
Problem:    Cannot build with Python 2.2
Solution:   Make Python interface work with Python 2.2
	    Make 2.2 the first supported version. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c,
	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.ok, src/configure.in, src/auto/configure

Patch 7.3.949
Problem:    Python: no easy access to tabpages.
Solution:   Add vim.tabpages and vim.current.tabpage. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/if_py_both.h, src/if_python3.c,
	    src/if_python.c, src/proto/if_python3.pro,
	    src/proto/if_python.pro, src/proto/window.pro, src/structs.h,
	    src/window.c

Patch 7.3.950
Problem:    Python: Stack trace printer can't handle messages.
Solution:   Make KeyErrors use PyErr_SetObject. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c

Patch 7.3.951
Problem:    Python exceptions have problems.
Solution:   Change some IndexErrors to TypeErrors. Make “line number out of
	    range” an IndexError.  Make “unable to get option value” a
	    RuntimeError. Make all PyErr_SetString messages start with
	    lowercase letter and use _(). (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c,
	    src/testdir/test86.ok, src/testdir/test87.ok

Patch 7.3.952
Problem:    Python: It's not easy to change window/buffer/tabpage.
Solution:   Add ability to assign to vim.current.{tabpage,buffer,window}.
	    (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/if_py_both.h

Patch 7.3.953
Problem:    Python: string exceptions are deprecated.
Solution:   Make vim.error an Exception subclass. (ZyX)
Files:	    src/if_python.c, src/if_python3.c

Patch 7.3.954
Problem:    No check if PyObject_IsTrue fails.
Solution:   Add a check for -1 value. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.955
Problem:    Python: Not enough tests.
Solution:   Add tests for vim.{current,window*,tabpage*}. (ZyX)
Files:	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.956
Problem:    Python vim.bindeval() causes SIGABRT.
Solution:   Make pygilstate a local variable. (Yukihiro Nakadaira)
Files:	    src/if_py_both.h, src/if_python.c, src/if_python3.c

Patch 7.3.957
Problem:    Python does not have a "do" command like Perl or Lua.
Solution:   Add the ":py3do" command. (Lilydjwg)
Files:	    runtime/doc/if_pyth.txt, src/ex_cmds.h, src/ex_docmd.c,
	    src/if_python3.c, src/proto/if_python3.pro

Patch 7.3.958
Problem:    Python: Iteration destructor not set.
Solution:   Put IterDestructor to use. (ZyX)
Files:	    src/if_py_both.c

Patch 7.3.959 (after 7.3.957)
Problem:    Missing error number.
Solution:   Assign an error number.
Files:	    src/if_python3.c

Patch 7.3.960
Problem:    Compiler warning for unused variable.
Solution:   Put declaration in #ifdef.
Files:	    src/window.c

Patch 7.3.961
Problem:    Tests 86 and 87 fail when using another language than English.
Solution:   Set the language to C in the test. (Dominique Pelle)
Files:	    src/testdir/test86.in, src/testdir/test87.in,
	    src/testdir/test87.ok

Patch 7.3.962
Problem:    Python tests are not portable.
Solution:   Use shiftwidth instead of iminsert. (ZyX)
Files:	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.963
Problem:    Setting curbuf without curwin causes trouble.
Solution:   Add switch_buffer() and restore_buffer().  Block autocommands to
	    avoid trouble.
Files:	    src/eval.c, src/proto/eval.pro, src/proto/window.pro,
	    src/if_py_both.h, src/window.c, src/testdir/test86.ok

Patch 7.3.964
Problem:    Python: not so easy to access tab pages.
Solution:   Add window.tabpage, make window.number work with non-current tab
	    pages. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/if_py_both.h, src/if_python3.c,
	    src/if_python.c, src/testdir/test86.ok, src/testdir/test87.ok

Patch 7.3.965
Problem:    Python garbage collection not working properly.
Solution:   Add support for garbage collection. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.966
Problem:    There is ":py3do" but no ":pydo".
Solution:   Add the ":pydo" command. (Lilydjwg)
Files:	    runtime/doc/if_pyth.txt, src/ex_cmds.h, src/ex_docmd.c,
	    src/if_py_both.h, src/if_python.c, src/if_python3.c,
	    src/proto/if_python.pro

Patch 7.3.967 (after 7.3.965)
Problem:    Build fails on Mac OSX. (Greg Novack)
Solution:   Undefine clear().
Files:	    src/if_py_both.h

Patch 7.3.968
Problem:    Multi-byte support is only available when compiled with "big"
	    features.
Solution:   Include multi-byte by default, with "normal" features.
Files:	    src/feature.h

Patch 7.3.969
Problem:    Can't build with Python 3 and without Python 2.
Solution:   Adjust #ifdef. (Xavier de Gaye)
Files:	    src/window.c

Patch 7.3.970
Problem:    Syntax highlighting can be slow.
Solution:   Include the NFA regexp engine.  Add the 'regexpengine' option to
	    select which one is used. (various authors, including Ken Takata,
	    Andrei Aiordachioaie, Russ Cox, Xiaozhou Liua, Ian Young)
Files:	    src/Make_cyg.mak, src/Make_ming.mak, src/Make_mvc.mak,
	    src/Makefile, src/regexp.c, src/regexp.h, src/regexp_nfa.c,
	    src/structs.h, src/testdir/Makefile, src/testdir/test64.in,
	    src/testdir/test64.ok, Filelist, runtime/doc/pattern.txt,
	    runtime/doc/option.txt, src/option.c, src/option.h,
	    src/testdir/test95.in, src/testdir/test95.ok,
	    src/testdir/Make_amiga.mak, src/testdir/Make_dos.mak,
	    src/testdir/Make_ming.mak, src/testdir/Make_os2.mak,
	    src/testdir/Make_vms.mms, src/testdir/Makefile

Patch 7.3.971
Problem:    No support for VS2012 static code analysis.
Solution:   Add the ANALYZE option. (Mike Williams)
Files:	    src/Make_mvc.mak

Patch 7.3.972
Problem:    Cursor not restored after InsertEnter autocommand if it moved to
	    another line.
Solution:   Also restore if the saved line number is still valid.  Allow
	    setting v:char to skip restoring.
Files:	    src/edit.c, runtime/doc/autocmd.txt

Patch 7.3.973
Problem:    Compiler warnings. Crash on startup. (Tony Mechelynck)
Solution:   Change EMSG2 to EMSGN. Make array one character longer.
Files:	    src/regexp_nfa.c

Patch 7.3.974
Problem:    Can't build with ruby 1.8.5.
Solution:   Only use ruby_init_stack() when RUBY_INIT_STACK is defined.
	    (Yukihiro Nakadaira)
Files:	    src/if_ruby.c

Patch 7.3.975
Problem:    Crash in regexp parsing.
Solution:   Correctly compute the end of allocated memory.
Files:	    src/regexp_nfa.c

Patch 7.3.976
Problem:    Can't build on HP-UX.
Solution:   Remove modern initialization. (John Marriott)
Files:	    src/regexp_nfa.c

Patch 7.3.977
Problem:    Compiler warnings on 64 bit Windows.
Solution:   Add type casts. (Mike Williams)  Also fix some white space and
	    uncomment what was commented-out for testing.
Files:	    src/regexp_nfa.c

Patch 7.3.978
Problem:    Regexp debug logs don't have a good name.
Solution:   Use clear names and make it possible to write logs for the old and
	    new engines separately. (Taro Muraoka)
Files:	    src/regexp.c, src/regexp_nfa.c

Patch 7.3.979
Problem:    Complex NFA regexp doesn't work.
Solution:   Set actual state stack end instead of using an arbitrary number.
	    (Yasuhiro Matsumoto)
Files:	    src/regexp_nfa.c

Patch 7.3.980
Problem:    Regexp logs may contain garbage. Character classes don't work
	    correctly for multi-byte characters.
Solution:   Check for end of post list.  Only use "is" functions for
	    characters up to 255. (Ken Takata)
Files:	    src/regexp_nfa.c

Patch 7.3.981
Problem:    In the old regexp engine \i, \I, \f and \F don't work on
	    multi-byte characters.
Solution:   Dereference pointer properly.
Files:	    src/regexp.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.982
Problem:    In the new regexp engine \p does not work on multi-byte
	    characters.
Solution:   Don't point to an integer but the characters.
Files:	    src/regexp_nfa.c, src/testdir/test95.in, src/testdir/test95.ok

Patch 7.3.983
Problem:    Unnecessary temp variable.
Solution:   Remove the variable.
Files:	    src/regexp_nfa.c

Patch 7.3.984
Problem:    A Visual mapping that uses CTRL-G works differently when started
	    from Insert mode. (Ein Brown)
Solution:   Reset old_mapped_len when handling typed text in Select mode.
Files:	    src/normal.c

Patch 7.3.985
Problem:    GTK vim not started as gvim doesn't set WM_CLASS property to a
	    useful value.
Solution:   Call g_set_prgname() on startup. (James McCoy)
Files:	    src/gui_gtk_x11.c

Patch 7.3.986
Problem:    Test 95 doesn't pass when 'encoding' isn't utf-8. (Yasuhiro
	    Matsumoto)
Solution:   Force 'encoding' to be utf-8.
Files:	    src/testdir/test95.in

Patch 7.3.987
Problem:    No easy to run an individual test.  Tests 64 fails when
	    'encoding' is not utf-8.
Solution:   Add individual test targets to the Makefile.  Move some lines from
	    test 64 to 95.
Files:	    src/Makefile, src/testdir/test64.in, src/testdir/test64.ok,
	    src/testdir/test95.in, src/testdir/test95.ok

Patch 7.3.988
Problem:    New regexp engine is slow.
Solution:   Break out of the loop when the state list is empty.
Files:	    src/regexp_nfa.c

Patch 7.3.989
Problem:    New regexp engine compares negative numbers to character.
Solution:   Add missing case statements.
Files:	    src/regexp_nfa.c

Patch 7.3.990
Problem:    Memory leak in new regexp engine.
Solution:   Jump to end of function to free memory. (Dominique Pelle)
Files:	    src/regexp_nfa.c

Patch 7.3.991
Problem:    More can be shared by Python 2 and 3.
Solution:   Move more stuff to if_py_both. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c,
	    src/testdir/test87.ok

Patch 7.3.992
Problem:    Python: Too many type casts.
Solution:   Change argument types. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c

Patch 7.3.993
Problem:    Python: Later patch does things slightly differently.
Solution:   Adjusted argument type changes. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c

Patch 7.3.994
Problem:    Python: using magic constants.
Solution:   Use descriptive values for ml_flags. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c

Patch 7.3.995
Problem:    Python: Module initialization is duplicated.
Solution:   Move to shared file. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c

Patch 7.3.996
Problem:    Python: Can't check types of what is returned by bindeval().
Solution:   Add vim.List, vim.Dictionary and vim.Function types. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/if_py_both.h, src/testdir/test86.in,
	    src/testdir/test86.ok, src/testdir/test87.in,
	    src/testdir/test87.ok

Patch 7.3.997
Problem:    Vim and Python exceptions are different.
Solution:   Make Vim exceptions be Python exceptions. (ZyX)
Files:	    src/if_py_both.h, src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.998
Problem:    Python: garbage collection issues.
Solution:   Fix the GC issues: Use proper DESTRUCTOR_FINISH: avoids negative
	    refcounts, use PyObject_GC_* for objects with tp_traverse and
	    tp_clear, add RangeTraverse and RangeClear, use Py_XDECREF in some
	    places. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c

Patch 7.3.999
Problem:    New regexp engine sets curbuf temporarily.
Solution:   Use reg_buf instead, like the old engine.
Files:	    src/regexp_nfa.c

Patch 7.3.1000 (whoa!)
Problem:    Typo in char value causes out of bounds access.
Solution:   Fix character value.  (Klemens Baum)
Files:	    src/regexp.c

Patch 7.3.1001
Problem:    Duplicate condition in if.
Solution:   Remove one condition.
Files:	    src/regexp_nfa.c

Patch 7.3.1002
Problem:    Valgrind errors for Python interface.
Solution:   Fix memory leaks when running tests. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1003
Problem:    Python interface does not compile with Python 2.2
Solution:   Fix thread issues and True/False. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c,
	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1004
Problem:    No error when option could not be set.
Solution:   Report an error. (ZyX)
Files:	    src/if_py_both.h, src/option.c, src/proto/option.pro,
	    src/testdir/test86.ok, src/testdir/test87.ok

Patch 7.3.1005
Problem:    Get stuck on regexp "\n*" and on "%s/^\n\+/\r".
Solution:   Fix handling of matching a line break. (idea by Hirohito Higashi)
Files:	    src/regexp_nfa.c

Patch 7.3.1006
Problem:    NFA engine not used for "\_[0-9]".
Solution:   Enable this, fixed in patch 1005.
Files:	    src/regexp_nfa.c

Patch 7.3.1007
Problem:    Can't build on Minix 3.2.1.
Solution:   Add a condition to an #ifdef. (Gautam Tirumala)
Files:	    src/memfile.c

Patch 7.3.1008
Problem:    Test 95 fails on MS-Windows.
Solution:   Set 'nomore'. Change \i to \f.  Change multi-byte character to
	    something that is not matching \i. (Ken Takata)
Files:	    src/testdir/test95.in, src/testdir/test95.ok

Patch 7.3.1009
Problem:    Compiler warning for ambiguous else.
Solution:   Add curly braces.
Files:	    src/if_py_both.h

Patch 7.3.1010
Problem:    New regexp: adding \Z makes every character match.
Solution:   Only apply ireg_icombine for composing characters.
	    Also add missing change from patch 1008. (Ken Takata)
Files:	    src/regexp_nfa.c, src/testdir/test95.in, src/testdir/test95.ok

Patch 7.3.1011
Problem:    New regexp engine is inefficient with multi-byte characters.
Solution:   Handle a character at a time instead of a byte at a time.  Also
	    make \Z partly work.
Files:	    src/regexp_nfa.c, src/testdir/test95.in, src/testdir/test95.ok

Patch 7.3.1012
Problem:    \Z does not work properly with the new regexp engine.
Solution:   Make \Z work.  Add tests.
Files:	    src/regexp_nfa.c, src/testdir/test95.in, src/testdir/test95.ok

Patch 7.3.1013
Problem:    New regexp logging is a bit messy.
Solution:   Consistently use #defines, add explanatory comment. (Taro Muraoka)
Files:	    src/regexp_nfa.c

Patch 7.3.1014
Problem:    New regexp state dump is hard to read.
Solution:   Make the state dump more pretty. (Taro Muraoka)
Files:	    src/regexp_nfa.c

Patch 7.3.1015
Problem:    New regexp engine: Matching composing characters is wrong.
Solution:   Fix matching composing characters.
Files:	    src/regexp_nfa.c, src/testdir/test95.in, src/testdir/test95.ok

Patch 7.3.1016
Problem:    Unused field in nfa_state.
Solution:   Remove lastthread.
Files:	    src/regexp.h, src/regexp_nfa.c

Patch 7.3.1017
Problem:    Zero width match changes length of match.
Solution:   For a zero width match put new states in the current position in
	    the state list.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok,
	    src/regexp.h

Patch 7.3.1018
Problem:    New regexp engine wastes memory.
Solution:   Allocate prog with actual number of states, not estimated maximum
	    number of sates.
Files:	    src/regexp_nfa.c

Patch 7.3.1019
Problem:    These do not work with the new regexp engine: \%o123, \%x123,
	    \%d123, \%u123 and \%U123.
Solution:   Implement these items.
Files:	    src/regexp_nfa.c

Patch 7.3.1020
Problem:    Not all patterns are tested with auto / old / new engine.
Solution:   Test patterns with three values of 'regexpengine'.
Files:	    src/testdir/test64.in, src/testdir/test64.ok,
	    src/testdir/test95.in, src/testdir/test95.ok

Patch 7.3.1021
Problem:    New regexp engine does not ignore order of composing chars.
Solution:   Ignore composing chars order.
Files:	    src/regexp_nfa.c, src/testdir/test95.in, src/testdir/test95.ok

Patch 7.3.1022
Problem:    Compiler warning for shadowed variable. (John Little)
Solution:   Move declaration, rename variables.
Files:	    src/regexp_nfa.c

Patch 7.3.1023
Problem:    Searching for composing char only and using \Z has different
	    results.
Solution:   Make it match the composing char, matching everything is not
	    useful.
Files:	    src/regexp_nfa.c, src/testdir/test95.in, src/testdir/test95.ok

Patch 7.3.1024
Problem:    New regexp: End of matching pattern not set correctly. (Cesar
	    Romani)
Solution:   Quit the loop after finding the match.  Store nfa_has_zend in the
	    program.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok,
	    src/regexp.h

Patch 7.3.1025
Problem:    New regexp: not matching newline in string. (Marc Weber)
Solution:   Check for "\n" character.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1026
Problem:    New regexp: pattern that includes a new-line matches too early.
	    (john McGowan)
Solution:   Do not start searching in the second line.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1027
Problem:    New regexp performance: Calling no_Magic() very often.
Solution:   Remove magicness inline.
Files:	    src/regexp_nfa.c

Patch 7.3.1028
Problem:    New regexp performance: Copying a lot of position state.
Solution:   Only copy the sub-expressions that are being used.
Files:	    src/regexp_nfa.c, src/regexp.h

Patch 7.3.1029
Problem:    New regexp performance: Unused position state being copied.
Solution:   Keep track of which positions are actually valid.
Files:	    src/regexp_nfa.c

Patch 7.3.1030 (after 7.3.1028)
Problem:    Can't build for debugging.
Solution:   Fix struct member names.
Files:	    src/regexp_nfa.c

Patch 7.3.1031
Problem:    Compiler warnings for shadowed variable. (John Little)
Solution:   Move the variable declarations to the scope where they are used.
Files:	    src/regexp_nfa.c

Patch 7.3.1032
Problem:    "\ze" is not supported by the new regexp engine.
Solution:   Make "\ze" work.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1033
Problem:    "\1" .. "\9" are not supported in the new regexp engine.
Solution:   Implement them.  Add a few more tests.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok,
	    src/regexp.h

Patch 7.3.1034
Problem:    New regexp code using strange multi-byte code.
Solution:   Use the normal code to advance and backup pointers.
Files:	    src/regexp_nfa.c

Patch 7.3.1035
Problem:    Compiler warning on 64 bit windows.
Solution:   Add type cast. (Mike Williams)
Files:	    src/if_py_both.h

Patch 7.3.1036
Problem:    Can't build on HP-UX.
Solution:   Give the union a name. (John Marriott)
Files:	    src/regexp_nfa.c

Patch 7.3.1037
Problem:    Look-behind matching is very slow on long lines.
Solution:   Add a byte limit to how far back an attempt is made.
Files:	    src/regexp.c, src/regexp_nfa.c, src/testdir/test64.in,
	    src/testdir/test64.ok

Patch 7.3.1038
Problem:    Crash when using Cscope.
Solution:   Avoid negative argument to vim_strncpy(). (Narendran
	    Gopalakrishnan)
Files:	    src/if_cscope.c

Patch 7.3.1039
Problem:    New regexp engine does not support \%23c, \%<23c and the like. 
Solution:   Implement them. (partly by Yasuhiro Matsumoto)
Files:	    src/regexp.h, src/regexp_nfa.c, src/testdir/test64.in,
	    src/testdir/test64.ok

Patch 7.3.1040
Problem:    Python: Problems with debugging dynamic build.
Solution:   Python patch 1. (ZyX)
Files:	    src/if_python.c, src/if_python3.c

Patch 7.3.1041
Problem:    Python: Invalid read valgrind errors.
Solution:   Python patch 2: defer DICTKEY_UNREF until key is no longer needed.
	    (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1042
Problem:    Python: can't assign to vim.Buffer.name.
Solution:   Python patch 3. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/ex_cmds.c, src/if_py_both.h,
	    src/if_python3.c, src/if_python.c, src/proto/ex_cmds.pro,
	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1043
Problem:    Python: Dynamic compilation with 2.3 fails.
Solution:   Python patch 4. (ZyX)
Files:	    src/if_python.c

Patch 7.3.1044
Problem:    Python: No {Buffer,TabPage,Window}.valid attributes.
Solution:   Python patch 5: add .valid (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c,
	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1045
Problem:    Python: No error handling for VimToPython function.
Solution:   Python patch 6. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1046
Problem:    Python: Using Py_BuildValue for building strings.
Solution:   Python patch 7 and 7.5: Replace Py_BuildValue with
	    PyString_FromString. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1047
Problem:    Python: dir() does not work properly.
Solution:   Python patch 8.  Add __dir__ method to all objects with custom
	    tp_getattr supplemented by __members__ attribute for at least
	    python-2* versions.  __members__ is not mentioned in python-3*
	    dir() output even if it is accessible. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c,
	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1048
Problem:    Python: no consistent naming.
Solution:   Python patch 9: Rename d to dict and lookupDict to lookup_dict.
	    (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1049
Problem:    Python: no consistent naming
Solution:   Python patch 10: Rename DICTKEY_GET_NOTEMPTY to DICTKEY_GET. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1050
Problem:    Python: Typo in pyiter_to_tv.
Solution:   Python patch 11. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1051
Problem:    Python: possible memory leaks.
Solution:   Python patch 12: fix the leaks (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1052
Problem:    Python: possible SEGV and negative refcount.
Solution:   Python patch 13: Fix IterIter function. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1053
Problem:    Python: no flag for types with tp_traverse+tp_clear.
Solution:   Python patch 14: Add Py_TPFLAGS_HAVE_GC. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1054 (after 7.3.1042)
Problem:    Can't build without the +autocmd feature. (Elimar Riesebieter)
Solution:   Fix use of buf and curbuf.
Files:	    src/ex_cmds.c, src/testdir/test86.ok, src/testdir/test87.ok

Patch 7.3.1055
Problem:    Negated collection does not match newline.
Solution:   Handle newline differently. (Hiroshi Shirosaki)
Files:	    src/regexp_nfa.c, src/testdir/test64.ok, src/testdir/test64.in

Patch 7.3.1056
Problem:    Python: possible memory leaks.
Solution:   Python patch 15. (ZyX) Fix will follow later.
Files:	    src/eval.c, src/if_py_both.h, src/proto/eval.pro

Patch 7.3.1057
Problem:    Python: not enough compatibility.
Solution:   Python patch 16: Make OutputWritelines support any sequence object
	    (ZyX) Note: tests fail
Files:	    src/if_py_both.h, src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1058
Problem:    Call of funcref does not succeed in other script.
Solution:   Python patch 17: add get_expanded_name(). (ZyX)
Files:	    src/eval.c, src/proto/eval.pro

Patch 7.3.1059
Problem:    Python: Using fixed size buffers.
Solution:   Python patch 18: Use python's own formatter. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c

Patch 7.3.1060
Problem:    Python: can't repr() a function.
Solution:   Python patch 19: add FunctionRepr(). (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1061
Problem:    Python: Dictionary is not standard.
Solution:   Python patch 20: Add standard methods and fields. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/eval.c, src/if_py_both.h,
	    src/if_python3.c, src/if_python.c, src/proto/eval.pro,
	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1062
Problem:    Python: List is not standard.
Solution:   Python patch 21: Add standard methods and fields. (ZyX)
Files:	    src/if_py_both.h, src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1063
Problem:    Python: Function is not standard.
Solution:   Python patch 22: make Function subclassable. (ZyX)
Files:	    src/eval.c, src/if_py_both.h, src/proto/eval.pro,
	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1064
Problem:    Python: insufficient error checking.
Solution:   Python patch 23. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1065
Problem:    Python: key mapping is not standard.
Solution:   Python patch 24: use PyMapping_Keys. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c

Patch 7.3.1066
Problem:    Python: Insufficient exception and error testing.
Solution:   Python patch 25. (ZyX)
Files:	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1067
Problem:    Python: documentation lags behind.
Solution:   Python patch 26. (ZyX)
Files:	    runtime/doc/if_pyth.txt

Patch 7.3.1068
Problem:    Python: Script is auto-loaded on function creation.
Solution:   Python patch 27. (ZyX)
Files:	    src/eval.c, src/if_py_both.h, src/proto/eval.pro,
	    src/testdir/test86.ok, src/testdir/test87.ok, src/vim.h

Patch 7.3.1069
Problem:    Python: memory leaks.
Solution:   Python patch 28: Purge out DICTKEY_CHECK_EMPTY macros. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1070
Problem:    Vim crashes in Python tests. Compiler warning for unused function.
Solution:   Disable the tests for now. Move the function.
Files:	    src/if_py_both.h, src/if_python.c, src/testdir/test86.in,
	    src/testdir/test87.in

Patch 7.3.1071
Problem:    New regexp engine: backreferences don't work correctly.
Solution:   Add every possible start/end position on the state stack.
Files:	    src/regexp_nfa.c, src/regexp.h, src/testdir/test64.in,
	    src/testdir/test64.ok

Patch 7.3.1072
Problem:    Compiler warning for uninitialized variable.
Solution:   Initialize it.
Files:	    src/regexp_nfa.c

Patch 7.3.1073
Problem:    New regexp engine may run out of states.
Solution:   Allocate states dynamically.  Also make the test report errors.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok,
	    src/testdir/test95.in

Patch 7.3.1074
Problem:    Compiler warning for printf format. (Manuel Ortega)
Solution:   Add type casts.
Files:	    src/if_py_both.h

Patch 7.3.1075
Problem:    Compiler warning for storing a long_u in an int.
Solution:   Declare the number as an int. (Mike Williams)
Files:	    src/regexp_nfa.c

Patch 7.3.1076
Problem:    New regexp engine: \@= and \& don't work.
Solution:   Make these items work.  Add column info to logging.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1077
Problem:    Python: Allocating dict the wrong way, causing a crash.
Solution:   Use py_dict_alloc(). Fix some exception problems. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1078
Problem:    New regexp engine: \@! doesn't work.
Solution:   Implement the negated version of \@=.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1079
Problem:    Test 87 fails.
Solution:   Fix the test for Python 3.3. (ZyX)  Make it pass on 32 bit systems.
Files:	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1080
Problem:    Test 86 fails.
Solution:   Comment out the parts that don't work.  Make it pass on 32 bit
	    systems.
Files:	    src/testdir/test86.in, src/testdir/test86.ok

Patch 7.3.1081
Problem:    Compiler warnings on 64-bit Windows.
Solution:   Change variable types. (Mike Williams)
Files:	    src/if_py_both.h, src/regexp_nfa.c

Patch 7.3.1082
Problem:    New regexp engine: Problem with \@= matching.
Solution:   Save and restore nfa_match.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1083
Problem:    New regexp engine: Does not support \%^ and \%$.
Solution:   Support matching start and end of file.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1084
Problem:    New regexp engine: only accepts up to \{,10}.
Solution:   Remove upper limit.  Remove dead code with NFA_PLUS.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1085
Problem:    New regexp engine: Non-greedy multi doesn't work.
Solution:   Implement \{-}.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1086
Problem:    Old regexp engine accepts illegal range, new one doesn't.
Solution:   Also accept the illegal range with the new engine.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1087
Problem:    A leading star is not seen as a normal char when \{} follows.
Solution:   Save and restore the parse state properly.
Files:	    src/regexp.c, src/regexp_nfa.c, src/testdir/test64.in,
	    src/testdir/test64.ok

Patch 7.3.1088
Problem:    New regexp engine: \@<= and \@<! are not implemented.
Solution:   Implement look-behind matching.  Fix off-by-one error in old
	    regexp engine.
Files:	    src/regexp.c, src/regexp_nfa.c, src/testdir/test64.in,
	    src/testdir/test64.ok

Patch 7.3.1089
Problem:    Tests 86 and 87 fail on MS-Windows. (Ken Takata)
Solution:   Fix platform-specific stuff. (ZyX)
Files:	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1090
Problem:    New regexp engine does not support \z1 .. \z9 and \z(.
Solution:   Implement the syntax submatches.
Files:	    src/regexp.h, src/regexp_nfa.c

Patch 7.3.1091
Problem:    New regexp engine: no error when using \z1 or \z( where it does
	    not work.
Solution:   Give an error message.
Files:	    src/regexp.c, src/regexp_nfa.c

Patch 7.3.1092
Problem:    Can't build with regexp debugging.  NFA debug output shows wrong
	    pattern.
Solution:   Fix debugging code for recent changes.  Add the pattern to the
	    program.
Files:	    src/regexp_nfa.c, src/regexp.h

Patch 7.3.1093
Problem:    New regexp engine: When a sub expression is empty \1 skips a
	    character.
Solution:   Make \1 try the current position when the match is empty.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1094
Problem:    New regexp engine: Attempts to match "^" at every character.
Solution:   Only try "^" at the start of a line.
Files:	    src/regexp_nfa.c

Patch 7.3.1095
Problem:    Compiler warnings for shadowed variables. (Christian Brabandt)
Solution:   Rename new_state() to alloc_state().  Remove unnecessary
	    declaration.
Files:	    src/regexp_nfa.c

Patch 7.3.1096
Problem:    Python: popitem() was not defined in a standard way.
Solution:   Remove the argument from popitem(). (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/if_py_both.h, src/testdir/test86.in,
	    src/testdir/test86.ok, src/testdir/test87.in,
	    src/testdir/test87.ok

Patch 7.3.1097
Problem:    Python: a few recently added items are not documented.
Solution:   Update the documentation. (ZyX)
Files:	    runtime/doc/if_pyth.txt

Patch 7.3.1098
Problem:    Python: Possible memory leaks
Solution:   Add Py_XDECREF() calls. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1099
Problem:    Python: Changing directory with os.chdir() causes problems for
	    Vim's notion of directories.
Solution:   Add vim.chdir() and vim.fchdir(). (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/ex_docmd.c, src/if_py_both.h,
	    src/if_python3.c, src/if_python.c, src/proto/ex_docmd.pro,
	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1100
Problem:    Python: a few more memory problems.
Solution:   Add and remove Py_XDECREF(). (ZyX)
Files:	    src/if_py_both.h, src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1101
Problem:    Configure doesn't find Python 3 on Ubuntu 13.04.
Solution:   First try distutils.sysconfig. Also fix some indents.  (Ken
	    Takata)
Files:	    src/configure.in, src/auto/configure

Patch 7.3.1102
Problem:    Completion of ":py3do" and ":py3file" does not work after ":py3".
Solution:   Make completion work. (Taro Muraoka)
Files:	    src/ex_docmd.c

Patch 7.3.1103
Problem:    New regexp engine: overhead in saving and restoring.
Solution:   Make saving and restoring list IDs faster.  Don't copy or check \z
	    subexpressions when they are not used.
Files:	    src/regexp_nfa.c

Patch 7.3.1104
Problem:    New regexp engine does not handle "~".
Solution:   Add support for "~".
Files:	    src/regexp_nfa.c, src/testdir/test24.in, src/testdir/test24.ok

Patch 7.3.1105
Problem:    New regexp engine: too much code in one function.  Dead code.
Solution:   Move the recursive nfa_regmatch call to a separate function.
	    Remove the dead code.
Files:	    src/regexp_nfa.c

Patch 7.3.1106
Problem:    New regexp engine: saving and restoring lastlist in the states
	    takes a lot of time.
Solution:   Use a second lastlist value for the first recursive call.
Files:	    src/regexp.h, src/regexp_nfa.c

Patch 7.3.1107
Problem:    Compiler warnings for unused variables.
Solution:   Put the variables inside #ifdef.
Files:	    src/regexp.c, src/regexp_nfa.c

Patch 7.3.1108
Problem:    Error message for os.fchdir() (Charles Peacech)
Solution:   Clear the error. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1109
Problem:    Building on MS-Windows doesn't see changes in if_py_both.h.
Solution:   Add a dependency. (Ken Takata)
Files:	    src/Make_bc5.mak, src/Make_cyg.mak, src/Make_ming.mak,
	    src/Make_mvc.mak

Patch 7.3.1110
Problem:    New regexp matching: Using \@= and the like can be slow.
Solution:   Decide whether to first try matching the zero-width part or what
	    follows, whatever is more likely to fail.
Files:	    src/regexp_nfa.c

Patch 7.3.1111
Problem:    nfa_recognize_char_class() implementation is inefficient.
Solution:   Use bits in an int instead of chars in a string. (Dominique Pelle)
Files:	    src/regexp_nfa.c, src/testdir/test36.in, src/testdir/test36.ok

Patch 7.3.1112
Problem:    New regexp engine: \%V not supported.
Solution:   Implement \%V.  Add tests.
Files:	    src/regexp.c, src/regexp_nfa.c, src/testdir/test64.in,
	    src/testdir/test64.ok

Patch 7.3.1113
Problem:    New regexp engine: \%'m not supported.
Solution:   Implement \%'m.  Add tests.
Files:	    src/regexp.c, src/regexp_nfa.c, src/testdir/test64.in,
	    src/testdir/test64.ok

Patch 7.3.1114 (after 7.3.1110)
Problem:    Can't build without the syntax feature.
Solution:   Add #ifdefs. (Erik Falor)
Files:	    src/regexp_nfa.c

Patch 7.3.1115
Problem:    Many users don't like the cursor line number when 'relativenumber'
	    is set.
Solution:   Have four combinations with 'number' and 'relativenumber'.
	    (Christian Brabandt)
Files:	    runtime/doc/options.txt, src/option.c, src/screen.c,
	    src/testdir/test89.in, src/testdir/test89.ok

Patch 7.3.1116
Problem:    Can't build without Visual mode.
Solution:   Add #ifdefs.
Files:	    src/regexp_nfa.c

Patch 7.3.1117
Problem:    New regexp engine: \%[abc] not supported.
Solution:   Implement \%[abc].  Add tests.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1118
Problem:    Match failure rate is not very specific.
Solution:   Tune the failure rate for match items.
Files:	    src/regexp_nfa.c

Patch 7.3.1119
Problem:    Flags in 'cpo' are search for several times.
Solution:   Store the result and re-use the flags.
Files:	    src/regexp.c, src/regexp_nfa.c

Patch 7.3.1120
Problem:    Crash when regexp logging is enabled.
Solution:   Avoid using NULL pointers. Advance over count argument.
Files:	    src/regexp.c, src/regexp_nfa.c

Patch 7.3.1121
Problem:    New regexp engine: adding states that are not used.
Solution:   Don't add the states.
Files:	    src/regexp_nfa.c

Patch 7.3.1122
Problem:    New regexp engine: \@> not supported.
Solution:   Implement \%>.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1123
Problem:    Can't build tiny Vim on MS-Windows.
Solution:   Adjust #ifdef around using modif_fname(). (Mike Williams)
Files:	    src/misc1.c

Patch 7.3.1124
Problem:    Python: Crash on MS-Windows when os.fchdir() is not available.
Solution:   Check for _chdir to be NULL. (Ken Takata)
Files:	    src/if_py_both.h

Patch 7.3.1125
Problem:    Error for using \%V in a pattern in tiny Vim.
Solution:   Allow using \%V but never match. (Dominique Pelle)
Files:	    src/regexp_nfa.c

Patch 7.3.1126
Problem:    Compiler warning for uninitialized variable. (Tony Mechelynck)
Solution:   Assign something to the variable.
Files:	    src/regexp_nfa.c

Patch 7.3.1127
Problem:    No error for using empty \%[].
Solution:   Give error message.
Files:	    src/regexp.c, src/regexp_nfa.c

Patch 7.3.1128
Problem:    Now that the NFA engine handles everything every failure is a
	    syntax error.
Solution:   Remove the syntax_error flag.
Files:	    src/regexp.c, src/regexp_nfa.c

Patch 7.3.1129
Problem:    Can't see what pattern in syntax highlighting is slow.
Solution:   Add the ":syntime" command.
Files:	    src/structs.h, src/syntax.c, src/ex_cmds.h, src/ex_docmd.c,
	    src/proto/syntax.pro, src/ex_cmds2.c, src/proto/ex_cmds2.pro,
	    runtime/doc/syntax.txt

Patch 7.3.1130 (after 7.3.1129)
Problem:    Can't build with anything but huge features.
Solution:   Check for FEAT_PROFILE. (Yasuhiro Matsumoto)
Files:	    src/ex_docmd.c, src/structs.h, src/syntax.c

Patch 7.3.1131
Problem:    New regexp engine is a bit slow.
Solution:   Do not clear the state list.  Don't copy syntax submatches when
	    not used.
Files:	    src/regexp_nfa.c

Patch 7.3.1132
Problem:    Crash when debugging regexp.
Solution:   Do not try to dump subexpr that were not set.  Skip over count of
	    \% items.
Files:	    src/regexp.c, src/regexp_nfa.c

Patch 7.3.1133
Problem:    New regexp engine is a bit slow.
Solution:   Skip ahead to a character that must match.  Don't try matching a
	    "^" patter past the start of line.
Files:	    src/regexp_nfa.c, src/regexp.h

Patch 7.3.1134
Problem:    Running test 49 takes a long time.
Solution:   Don't have it grep all files.
Files:	    src/testdir/test49.vim

Patch 7.3.1135
Problem:    Compiler warning for unused argument.
Solution:   Add UNUSED.
Files:	    src/syntax.c

Patch 7.3.1136
Problem:    ":func Foo" does not show attributes.
Solution:   Add "abort", "dict" and "range". (Yasuhiro Matsumoto)
Files:	    src/eval.c

Patch 7.3.1137
Problem:    New regexp engine: collections are slow.
Solution:   Handle all characters in one go.
Files:	    src/regexp_nfa.c

Patch 7.3.1138
Problem:    New regexp engine: neglist no longer used.
Solution:   Remove the now unused neglist.
Files:	    src/regexp_nfa.c

Patch 7.3.1139
Problem:    New regexp engine: negated flag is hardly used.
Solution:   Add separate _NEG states, remove negated flag.
Files:	    src/regexp_nfa.c, src/regexp.h

Patch 7.3.1140
Problem:    New regexp engine: trying expensive match while the result is not
	    going to be used.
Solution:   Check for output state already being in the state list.
Files:	    src/regexp_nfa.c

Patch 7.3.1141
Problem:    Win32: Check for available memory is not reliable and adds
	    overhead.
Solution:   Remove mch_avail_mem(). (Mike Williams)
Files:	    src/os_win32.c, src/os_win32.h

Patch 7.3.1142
Problem:    Memory leak in ":syntime report".
Solution:   Clear the grow array. (Dominique Pelle)
Files:	    src/syntax.c

Patch 7.3.1143
Problem:    When mapping NUL it is displayed as an X.
Solution:   Check for KS_ZERO instead of K_ZERO. (Yasuhiro Matsumoto)
Files:	    src/message.c

Patch 7.3.1144
Problem:    "RO" is not translated everywhere.
Solution:   Put inside _(). (Sergey Alyoshin)
Files:	    src/buffer.c, src/screen.c

Patch 7.3.1145
Problem:    New regexp engine: addstate() is called very often.
Solution:   Optimize adding the start state.
Files:	    src/regexp_nfa.c

Patch 7.3.1146
Problem:    New regexp engine: look-behind match not checked when followed by
	    zero-width match.
Solution:   Do the look-behind match before adding the zero-width state.
Files:	    src/regexp_nfa.c

Patch 7.3.1147
Problem:    New regexp engine: regstart is only used to find the first match.
Solution:   Use regstart whenever adding the start state.
Files:	    src/regexp_nfa.c

Patch 7.3.1148
Problem:    No command line completion for ":syntime".
Solution:   Implement the completion. (Dominique Pelle)
Files:	    runtime/doc/map.txt, src/ex_cmds.h, src/ex_docmd.c,
	    src/ex_getln.c, src/proto/syntax.pro, src/syntax.c, src/vim.h

Patch 7.3.1149
Problem:    New regexp engine: Matching plain text could be faster.
Solution:   Detect a plain text match and handle it specifically.  Add
	    vim_regfree().
Files:	    src/regexp.c, src/regexp.h, src/regexp_nfa.c,
	    src/proto/regexp.pro, src/buffer.c, src/edit.c, src/eval.c,
	    src/ex_cmds.c, src/ex_cmds2.c, src/ex_docmd.c, src/ex_eval.c,
	    src/ex_getln.c, src/fileio.c, src/gui.c, src/misc1.c, src/misc2.c,
	    src/option.c, src/syntax.c, src/quickfix.c, src/search.c,
	    src/spell.c, src/tag.c, src/window.c, src/screen.c, src/macros.h,
	    src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1150
Problem:    New regexp engine: Slow when a look-behind match does not have a
	    width specified.
Solution:   Try to compute the maximum width.
Files:	    src/regexp_nfa.c

Patch 7.3.1151
Problem:    New regexp engine: Slow when a look-behind match is followed by a
	    zero-width match.
Solution:   Postpone the look-behind match more often.
Files:	    src/regexp_nfa.c

Patch 7.3.1152
Problem:    In tiny build ireg_icombine is undefined. (Tony Mechelynck)
Solution:   Add #ifdef.
Files:	    src/regexp_nfa.c

Patch 7.3.1153
Problem:    New regexp engine: Some look-behind matches are very expensive.
Solution:   Postpone invisible matches further, until a match is almost found.
Files:	    src/regexp_nfa.c

Patch 7.3.1154
Problem:    New regexp_nfa engine: Unnecessary code.
Solution:   Remove unnecessary code.
Files:	    src/regexp_nfa.c

Patch 7.3.1155
Problem:    MS-DOS: "make test" uses external rmdir command.
Solution:   Rename "rmdir" to "rd". (Taro Muraoka)
Files:	    src/testdir/Make_dos.mak

Patch 7.3.1156
Problem:    Compiler warnings. (dv1445)
Solution:   Initialize variables, even when the value isn't really used.
Files:	    src/regexp_nfa.c, src/eval.c

Patch 7.3.1157
Problem:    New regexp engine fails on "\(\<command\)\@<=.*"
Solution:   Fix rule for postponing match.  Further tune estimating whether
	    postponing works better.  Add test.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1158
Problem:    Crash when running test 86. (Jun Takimoto)
Solution:   Define PY_SSIZE_T_CLEAN early. (Elimar Riesebieter)
Files:	    src/if_python.c, src/if_python3.c

Patch 7.3.1159
Problem:    The round() function is not always available. (Christ van
	    Willegen)
Solution:   Use the solution from f_round().
Files:	    src/ex_cmds2.c, src/eval.c, src/proto/eval.pro

Patch 7.3.1160
Problem:    Mixing long and pointer doesn't always work.
Solution:   Avoid cast to pointer.
Files:	    src/undo.c

Patch 7.3.1161
Problem:    Python: PyList_SetItem() is inefficient.
Solution:   Use PyList_SET_ITEM() (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1162
Problem:    Python: Memory leaks
Solution:   Add more Py_DECREF(). (ZyX)
Files:	    src/if_py_both.h, src/if_python.c

Patch 7.3.1163
Problem:    Not easy to load Python modules.
Solution:   Search "python2", "python3" and "pythonx" directories in
	    'runtimepath' for Python modules. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/configure.in, src/ex_cmds2.c,
	    src/if_py_both.h, src/if_python.c, src/if_python3.c,
	    src/testdir/test86.in, src/testdir/test87.in, src/auto/configure

Patch 7.3.1164
Problem:    Can't test what is actually displayed on screen.
Solution:   Add the screenchar() and screenattr() functions.
Files:	    src/eval.c, runtime/doc/eval.txt

Patch 7.3.1165
Problem:    HP-UX compiler can't handle zero size array. (Charles Cooper)
Solution:   Make the array one item big.
Files:	    src/regexp.h, src/regexp_nfa.c

Patch 7.3.1166
Problem:    Loading Python modules is not tested.
Solution:   Enable commented-out tests, add missing files. (ZyX)
Files:	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok,
	    src/testdir/python2/module.py, src/testdir/python3/module.py,
	    src/testdir/pythonx/module.py, src/testdir/pythonx/modulex.py,
	    Filelist

Patch 7.3.1167
Problem:    Python configure check doesn't reject Python 2 when requesting
	    Python 3.  Some systems need -pthreads instead of -pthread.
Solution:   Adjust configure accordingly. (Andrei Olsen)
Files:	    src/configure.in, src/auto/configure

Patch 7.3.1168
Problem:    Python "sane" configure checks give a warning message.
Solution:   Use single quotes instead of escaped double quotes. (Ben Fritz)
Files:	    src/configure.in, src/auto/configure

Patch 7.3.1169
Problem:    New regexp engine: some work is done while executing a pattern,
	    even though the result is predictable.
Solution:   Do the work while compiling the pattern.
Files:	    src/regexp_nfa.c

Patch 7.3.1170
Problem:    Patch 7.3.1058 breaks backwards compatibility, not possible to use
	    a function reference as a string. (lilydjwg)
Solution:   Instead of translating the function name only translate "s:".
Files:	    src/eval.c

Patch 7.3.1171
Problem:    Check for digits and ascii letters can be faster.
Solution:   Use a trick with one comparison. (Dominique Pelle)
Files:	    src/macros.h

Patch 7.3.1172
Problem:    Python 2: loading modules doesn't work well.
Solution:   Fix the code. Add more tests. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/if_py_both.h, src/if_python.c,
	    src/testdir/python2/module.py, src/testdir/python3/module.py,
	    src/testdir/python_after/after.py,
	    src/testdir/python_before/before.py, src/testdir/test86.in,
	    src/testdir/test86.ok, src/testdir/test87.in,
	    src/testdir/test87.ok, Filelist

Patch 7.3.1173
Problem:    Python 2 tests don't have the same output everywhere.
Solution:   Make the Python 2 tests more portable. (ZyX)
Files:	    src/testdir/test86.in, src/testdir/test86.ok

Patch 7.3.1174
Problem:    Python 2 and 3 use different ways to load modules.
Solution:   Use the same method. (ZyX)
Files:	    runtime/doc/if_pyth.txt, src/if_py_both.h, src/if_python3.c,
	    src/if_python.c

Patch 7.3.1175
Problem:    Using isalpha() and isalnum() can be slow.
Solution:   Use range checks. (Mike Williams)
Files:	    src/ex_docmd.c, src/macros.h

Patch 7.3.1176
Problem:    Compiler warnings on 64 bit system.
Solution:   Add type casts. (Mike Williams)
Files:	    src/eval.c, src/if_py_both.h

Patch 7.3.1177
Problem:    Wasting memory on padding.
Solution:   Reorder struct fields. (Dominique Pelle)
Files:	    src/structs.h, src/fileio.c

Patch 7.3.1178
Problem:    Can't put all Vim config files together in one directory.
Solution:   Load ~/.vim/vimrc if ~/.vimrc does not exist. (Lech Lorens)
Files:	    runtime/doc/gui.txt, runtime/doc/starting.txt, src/gui.c,
	    src/main.c, src/os_amiga.h, src/os_dos.h, src/os_unix.h

Patch 7.3.1179
Problem:    When a global mapping starts with the same characters as a
	    buffer-local mapping Vim waits for a character to be typed to find
	    out whether the global mapping is to be used. (Andy Wokula)
Solution:   Use the local mapping without waiting. (Michael Henry)
Files:	    runtime/doc/map.txt, src/getchar.c

Patch 7.3.1180
Problem:    When current directory changes, path from cscope may no longer be
	    valid. (AS Budden)
Solution:   Always store the absolute path. (Christian Brabandt)
Files:	    src/if_cscope.c

Patch 7.3.1181
Problem:    Wrong error message for 1.0[0].
Solution:   Check for funcref and float separately. (Yasuhiro Matsumoto)
Files:	    src/eval.c

Patch 7.3.1182
Problem:    'backupcopy' default on MS-Windows does not work for hard and soft
	    links.
Solution:   Check for links. (David Pope, Ken Takata)
Files:	    src/fileio.c, src/os_win32.c, src/proto/os_win32.pro

Patch 7.3.1183
Problem:    Python tests 86 and 87 fail.
Solution:   Add "empty" files. (ZyX)
Files:	    src/testdir/python_before/before_1.py,
	    src/testdir/python_before/before_2.py

Patch 7.3.1184
Problem:    Highlighting is sometimes wrong. (Axel Bender)
Solution:   Fetch regline again when returning from recursive regmatch.
Files:	    src/regexp_nfa.c

Patch 7.3.1185
Problem:    New regexp engine: no match with ^ after \n. (SungHyun Nam)
Solution:   Fix it, add a test.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1186
Problem:    Python 3: test 87 may crash.
Solution:   Use _PyArg_Parse_SizeT instead of PyArg_Parse. (Jun Takimoto)
Files:	    src/if_python3.c

Patch 7.3.1187 (after 7.3.1170)
Problem:    "s:" is recognized but "<SID>" is not. (ZyX)
Solution:   Translate "<SID>" like "s:".
Files:	    src/eval.c

Patch 7.3.1188
Problem:    Newline characters messing up error message.
Solution:   Remove the newlines. (Kazunobu Kuriyama)
Files:	    src/gui_x11.c

Patch 7.3.1189 (after 7.3.1185)
Problem:    Highlighting is still wrong sometimes. (Dominique Pelle)
Solution:   Also restore reginput properly.
Files:	    src/regexp_nfa.c

Patch 7.3.1190
Problem:    Compiler warning for parentheses. (Christian Wellenbrock)
Solution:   Change #ifdef.
Files:	    src/ex_docmd.c

Patch 7.3.1191
Problem:    Backreference to previous line doesn't work. (Lech Lorens)
Solution:   Implement looking in another line.
Files:	    src/regexp.c, src/regexp_nfa.c, src/testdir/test64.in,
	    src/testdir/test64.ok

Patch 7.3.1192
Problem:    Valgrind reports errors when using backreferences. (Dominique
	    Pelle)
Solution:   Do not check the end of submatches.
Files:	    src/regexp_nfa.c

Patch 7.3.1193
Problem:    fail_if_missing not used for Python 3.
Solution:   Give an error when Python 3 can't be configured. (Andrei Olsen)
Files:	    src/configure.in, src/auto/configure

Patch 7.3.1194
Problem:    Yaml highlighting is slow.
Solution:   Tune the estimation of pattern failure chance.
Files:	    src/regexp_nfa.c

Patch 7.3.1195
Problem:    Compiler warning for uninitialized variable. (Tony Mechelynck)
Solution:   Set the length to the matching backref.
Files:	    src/regexp.c

Patch 7.3.1196
Problem:    Old regexp engine does not match pattern with backref correctly.
	    (Dominique Pelle)
Solution:   Fix setting status.  Test multi-line patterns better.
Files:	    src/regexp.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1197
Problem:    ":wviminfo!" does not write history previously read from a viminfo
	    file.  (Roland Eggner)
Solution:   When not merging history write all entries.
Files:	    src/ex_cmds.c, src/ex_getln.c, src/proto/ex_getln.pro

Patch 7.3.1198
Problem:    Build error when using Perl 5.18.0 and dynamic loading.
Solution:   Change #ifdefs for Perl_croak_xs_usage. (Ike Devolder)
Files:	    src/if_perl.xs

Patch 7.3.1199
Problem:    When evaluating 'foldexpr' causes an error this is silently
	    ignored and evaluation is retried every time.
Solution:   Set emsg_silent instead of emsg_off. Stop evaluating 'foldexpr' is
	    it is causing errors.  (Christian Brabandt)
Files:	    src/fold.c

Patch 7.3.1200
Problem:    When calling setline() from Insert mode, using CTRL-R =, undo does
	    not work properly. (Israel Chauca)
Solution:   Sync undo after evaluating the expression. (Christian Brabandt)
Files:	    src/edit.c, src/testdir/test61.in, src/testdir/test61.ok

Patch 7.3.1201
Problem:    When a startup script creates a preview window, it probably
	    becomes the current window.
Solution:   Make another window the current one. (Christian Brabandt)
Files:	    src/main.c

Patch 7.3.1202 (after 7.3.660)
Problem:    Tags are not found in case-folded tags file. (Darren cole, Issue
	    90)
Solution:   Take into account that when case folding was used for the tags
	    file "!rm" sorts before the "!_TAG" header lines.
Files:	    src/tag.c

Patch 7.3.1203
Problem:    Matches from matchadd() might be highlighted incorrectly when they
	    are at a fixed position and inserting lines. (John Szakmeister)
Solution:   Redraw all lines below a change if there are highlighted matches.
	    (idea by Christian Brabandt)
Files:	    src/screen.c

Patch 7.3.1204
Problem:    Calling gettabwinvar() in 'tabline' cancels Visual mode. (Hirohito
	    Higashi)
Solution:   Don't always use goto_tabpage_tp().
Files:	    src/window.c, src/proto/window.pro, src/eval.c, src/if_py_both.h

Patch 7.3.1205
Problem:    logtalk.dict is not removed on uninstall.
Solution:   Remove the file. (Kazunobu Kuriyama)
Files:	    src/Makefile

Patch 7.3.1206
Problem:    Inconsistent function argument declarations.
Solution:   Use ANSI style.
Files:	    src/if_py_both.h

Patch 7.3.1207
Problem:    New regexp engine: no match found on "#if FOO". (Lech Lorens)
Solution:   When adding a state gets skipped don't adjust the index.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1208
Problem:    Compiler warnings on MS-Windows.
Solution:   Add type cast.  Move variable declaration. (Mike Williams)
Files:	    src/option.c, src/os_mswin.c

Patch 7.3.1209
Problem:    No completion for ":tabdo".
Solution:   Add tabdo to the list of modifiers. (Dominique Pelle)
Files:	    src/ex_docmd.c

Patch 7.3.1210 (after 7.3.1182)
Problem:    'backupcopy' default on MS-Windows is wrong when 'encoding' equals
	    the current codepage.
Solution:   Change the #else block. (Ken Takata)
Files:	    src/os_win32.c

Patch 7.3.1211
Problem:    MS-Windows: When 'encoding' differs from the current codepage
	    ":hardcopy" does not work properly.
Solution:   Use TextOutW() and SetDlgItemTextW(). (Ken Takata)
Files:	    src/os_mswin.c, src/vim.rc

Patch 7.3.1212
Problem:    "make test" on MS-Windows does not report failure like Unix does.
Solution:   Make it work like on Unix. (Taro Muraoka)
Files:	    src/testdir/Make_dos.mak

Patch 7.3.1213
Problem:    Can't build with small features and Python.
Solution:   Adjust #ifdefs.
Files:	    src/eval.c, src/buffer.c, src/eval.c, src/window.c

Patch 7.3.1214
Problem:    Missing declaration for init_users() and realloc_post_list().
	    (Salman Halim)
Solution:   Add the declarations.
Files:	    src/misc1.c, src/regexp_nfa.c

Patch 7.3.1215
Problem:    Compiler warning for function not defined.
Solution:   Add #ifdef.
Files:	    src/misc1.c

Patch 7.3.1216
Problem:    Configure can't find Motif on Ubuntu.
Solution:   Search for libXm in /usr/lib/*-linux-gnu.
Files:	    src/configure.in, src/auto/configure

Patch 7.3.1217
Problem:    New regexp engine: Can't handle \%[[ao]]. (Yukihiro Nakadaira)
Solution:   Support nested atoms inside \%[].
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1218
Problem:    "make test" on MS-Windows does not clean all temporary files and
	    gives some unnecessary message.
Solution:   Clean the right files.  Create .failed files. (Ken Takata)
Files:	    src/testdir/Make_dos.mak

Patch 7.3.1219
Problem:    No test for using []] inside \%[].
Solution:   Add a test.
Files:	    src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1220
Problem:    MS-Windows: When using wide font italic and bold are not included.
Solution:   Support wide-bold, wide-italic and wide-bold-italic. (Ken Takata,
	    Taro Muraoka)
Files:	    src/gui.c, src/gui.h, src/gui_w48.c

Patch 7.3.1221
Problem:    When build flags change "make distclean" run into a configure
	    error.
Solution:   When CFLAGS changes delete auto/config.cache.  Also avoid adding
	    duplicate text to flags. (Ken Takata)
Files:	    src/Makefile, src/configure.in, src/auto/configure

Patch 7.3.1222
Problem:    Cannot execute some tests from the src directly.
Solution:   Add missing targets.
Files:	    src/Makefile

Patch 7.3.1223
Problem:    Tests fail on MS-Windows.
Solution:   Avoid depending on OS version. Use DOS commands instead of Unix
	    commands. (Taro Muraoka, Ken Takata)
Files:	    src/testdir/test17.in, src/testdir/test50.in,
	    src/testdir/test71.in, src/testdir/test77.in

Patch 7.3.1224
Problem:    Clang gives warnings on xxd.
Solution:   Change how to use part of a string. (Dominique Pelle) Also avoid
	    warning for return not reached.
Files:	    src/xxd/xxd.c, src/regexp_nfa.c

Patch 7.3.1225
Problem:    Compiler warnings when building with Motif.
Solution:   Change set_label() argument. (Kazunobu Kuriyama)
Files:	    src/gui_motif.c

Patch 7.3.1226
Problem:    Python: duplicate code.
Solution:   Share code between OutputWrite() and OutputWritelines(). (ZyX)
Files:	    src/if_py_both.h, src/testdir/test86.ok, src/testdir/test87.ok

Patch 7.3.1227
Problem:    Inconsistent string conversion.
Solution:   Use 'encoding' instead of utf-8. Use METH_O in place of
	    METH_VARARGS where appropriate. (ZyX)
Files:	    src/if_py_both.h, src/testdir/test86.ok, src/testdir/test87.ok

Patch 7.3.1228
Problem:    Python: various inconsistencies and problems.
Solution:   StringToLine now supports both bytes() and unicode() objects.
	    Make function names consistent.  Fix memory leak fixed in
	    StringToLine. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c

Patch 7.3.1229
Problem:    Python: not so easy to delete/restore translating.
Solution:   Make macros do translation of exception messages. (ZyX)
	    Note: this breaks translations!
Files:	    src/if_py_both.h, src/if_python3.c

Patch 7.3.1230
Problem:    Python: Exception messages are not clear.
Solution:   Make exception messages more verbose. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c,
	    src/testdir/test86.ok, src/testdir/test87.ok

Patch 7.3.1231
Problem:    Python: use of numbers not consistent.
Solution:   Add support for Number protocol. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c,
	    src/testdir/test86.ok, src/testdir/test87.ok

Patch 7.3.1232
Problem:    Python: inconsistencies in variable names.
Solution:   Rename variables. (ZyX)
Files:	    src/eval.c, src/if_py_both.h

Patch 7.3.1233
Problem:    Various Python problems.
Solution:   Fix VimTryEnd. Crash with debug build and PYTHONDUMPREFS=1. Memory
	    leaks in StringToLine(), BufferMark() and convert_dl. (ZyX)
Files:	    src/if_py_both.h, src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok

Patch 7.3.1234 (after 7.3.1229)
Problem:    Python: Strings are not marked for translation.
Solution:   Add N_() where appropriate. (ZyX)
Files:	    src/if_py_both.h

Patch 7.3.1235
Problem:    In insert mode CTRL-] is not inserted, on the command-line it is.
Solution:   Don't insert CTRL-] on the command line. (Yukihiro Nakadaira)
Files:	    src/ex_getln.c

Patch 7.3.1236
Problem:    Python: WindowSetattr() missing support for NUMBER_UNSIGNED.
Solution:   Add NUMBER_UNSIGNED, add more tests. Various fixes. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c,
	    src/testdir/pythonx/failing.py,
	    src/testdir/pythonx/failing_import.py, src/testdir/test86.in,
	    src/testdir/test86.ok, src/testdir/test87.in,
	    src/testdir/test87.ok, src/testdir/pythonx/topmodule/__init__.py,
	    src/testdir/pythonx/topmodule/submodule/__init__.py,
	    src/testdir/pythonx/topmodule/submodule/subsubmodule/__init__.py,
	    src/testdir/pythonx/topmodule/submodule/subsubmodule/subsubsubmodule.py

Patch 7.3.1237
Problem:    Python: non-import errors not handled correctly.
Solution:   Let non-ImportError exceptions pass the finder. (ZyX)
Files:	    src/if_py_both.h, src/testdir/test86.ok, src/testdir/test87.ok

Patch 7.3.1238
Problem:    Crash in Python interface on 64 bit machines.
Solution:   Change argument type of PyString_AsStringAndSize. (Taro Muraoka,
	    Jun Takimoto)
Files:	    src/if_python.c

Patch 7.3.1239
Problem:    Can't build with Python and MSVC10.
Solution:   Move #if outside of macro. (Taro Muraoka)
Files:	    src/if_py_both.h

Patch 7.3.1240
Problem:    Memory leak in findfile().
Solution:   Free the memory. (Christian Brabandt)
Files:	    src/eval.c

Patch 7.3.1241 (after 7.3.1236)
Problem:    Some test files missing from the distribution.
Solution:   Update the list of files.
Files:	    Filelist

Patch 7.3.1242
Problem:    No failure when trying to use a number as a string.
Solution:   Give an error when StringToLine() is called with an instance of
	    the wrong type. (Jun Takimoto)
Files:	    src/if_py_both.h

Patch 7.3.1243
Problem:    New regexp engine: back references in look-behind match don't
	    work. (Lech Lorens)
Solution:   Copy the submatches before a recursive match. Also fix function
	    prototypes.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1244
Problem:    MS-Windows: confirm() dialog text may not fit.
Solution:   Use GetTextWidthEnc() instead of GetTextWidth(). (Yasuhiro
	    Matsumoto)
Files:	    src/gui_w32.c

Patch 7.3.1245
Problem:    MS-Windows: confirm() dialog text may still not fit.
Solution:   Use GetTextWidthEnc() instead of GetTextWidth() in two more
	    places. (Yasuhiro Matsumoto)
Files:	    src/gui_w32.c

Patch 7.3.1246
Problem:    When setting 'winfixheight' and resizing the window causes the
	    window layout to be wrong.
Solution:   Add frame_check_height() and frame_check_width() (Yukihiro
	    Nakadaira)
Files:	    src/window.c

Patch 7.3.1247
Problem:    New regexp engine: '[ ]\@!\p\%([ ]\@!\p\)*:' does not always match.
Solution:   When there is a PIM add a duplicate state that starts at another
	    position.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1248
Problem:    Still have old hacking code for Input Method.
Solution:   Add 'imactivatefunc' and 'imstatusfunc' as a generic solution to
	    Input Method activation. (Yukihiro Nakadaira)
Files:	    runtime/doc/options.txt, src/fileio.c, src/mbyte.c, src/option.c,
	    src/option.h, src/proto/fileio.pro

Patch 7.3.1249
Problem:    Modeline not recognized when using "Vim" instead of "vim".
Solution:   Also accept "Vim".
Files:	    src/buffer.c

Patch 7.3.1250
Problem:    Python tests fail on MS-Windows.
Solution:   Change backslashes to slashes. (Taro Muraoka)
Files:	    src/testdir/test86.in, src/testdir/test87.in

Patch 7.3.1251
Problem:    Test 61 messes up viminfo.
Solution:   Specify a separate viminfo file.
Files:	    src/testdir/test61.in

Patch 7.3.1252
Problem:    Gvim does not find the toolbar bitmap files in ~/vimfiles/bitmaps
	    if the corresponding menu command contains additional characters
	    like the shortcut marker '&' or if you use a non-english locale.  
Solution:   Use menu->en_dname or menu->dname. (Martin Gieseking)
Files:	    src/gui_w32.c

Patch 7.3.1253 (after 7.3.1200)
Problem:    Still undo problem after using CTRL-R = setline(). (Hirohito
	    Higashi)
Solution:   Set the ins_need_undo flag.
Files:	    src/edit.c

Patch 7.3.1254 (after 7.3.1252)
Problem:    Can't build without the multi-lang feature. (John Marriott)
Solution:   Add #ifdef.
Files:	    src/gui_w32.c

Patch 7.3.1255
Problem:    Clang warnings when building with Athena.
Solution:   Add type casts. (Dominique Pelle)
Files:	    src/gui_at_fs.c

Patch 7.3.1256
Problem:    Can't build without eval or autocmd feature.
Solution:   Add #ifdefs.
Files:	    src/mbyte.c, src/window.c

Patch 7.3.1257
Problem:    With GNU gettext() ":lang de_DE.utf8" does not always result in
	    German messages.
Solution:   Clear the $LANGUAGE environment variable.
Files:	    src/ex_cmds2.c

Patch 7.3.1258
Problem:    Using submatch() may crash Vim. (Ingo Karkat)
Solution:   Restore the number of subexpressions used.
Files:	    src/regexp_nfa.c

Patch 7.3.1259
Problem:    No test for patch 7.3.1258
Solution:   Add a test entry.
Files:	    src/testdir/test64.in, src/testdir/test64.ok

Patch 7.3.1260
Problem:    User completion does not get the whole command line in the command
	    line window.
Solution:   Pass on the whole command line. (Daniel Thau)
Files:	    src/ex_getln.c, src/structs.h

Patch 7.3.1261 (after patch 7.3.1179)
Problem:    A buffer-local language mapping from a keymap stops a global
	    insert mode mapping from working. (Ron Aaron)
Solution:   Do not wait for more characters to be typed only when the mapping
	    was defined with <nowait>.
Files:	    runtime/doc/map.txt, src/eval.c, src/getchar.c,
	    src/testdir/test75.in, src/testdir/test75.ok

Patch 7.3.1262
Problem:    Crash and compilation warnings with Cygwin.
Solution:   Check return value of XmbTextListToTextProperty(). Add type casts.
	    Adjust #ifdefs. (Lech Lorens)
Files:	    src/main.c, src/os_unix.c, src/ui.c

Patch 7.3.1263
Problem:    Typo in short option name.
Solution:   Change "imse" to "imsf".
Files:	    src/option.c

Patch 7.3.1264 (after 7.3.1261)
Problem:    Missing m_nowait.
Solution:   Include missing part of the patch.
Files:	    src/structs.h

Patch 7.3.1265 (after 7.3.1249)
Problem:    Accepting "Vim:" for a modeline causes errors too often.
Solution:   Require "Vim:" to be followed by "set".
Files:	    src/buffer.c

Patch 7.3.1266
Problem:    QNX: GUI fails to start.
Solution:   Remove the QNX-specific #ifdef. (Sean Boudreau)
Files:	    src/gui.c

Patch 7.3.1267
Problem:    MS-Windows ACL support doesn't work well.
Solution:   Implement more ACL support. (Ken Takata)
Files:	    src/os_win32.c

Patch 7.3.1268
Problem:    ACL support doesn't work when compiled with MingW.
Solution:   Support ACL on MingW. (Ken Takata)
Files:	    src/os_win32.c, src/os_win32.h

Patch 7.3.1269
Problem:    Insert completion keeps entry selected even though the list has
	    changed. (Olivier Teuliere)
Solution:   Reset compl_shown_match and compl_curr_match. (Christian Brabandt)
Files:	    src/edit.c

Patch 7.3.1270
Problem:    Using "Vp" in an empty buffer can't be undone. (Hauke Petersen)
Solution:   Save one line in an empty buffer. (Christian Brabandt)
Files:	    src/ops.c

Patch 7.3.1271 (after 7.3.1260)
Problem:    Command line completion does not work.
Solution:   Move setting xp_line down. (Daniel Thau)
Files:	    src/ex_getln.c

Patch 7.3.1272
Problem:    Crash when editing Ruby file. (Aliaksandr Rahalevich)
Solution:   Reallocate the state list when necessary.
Files:	    src/regexp_nfa.c

Patch 7.3.1273
Problem:    When copying a location list the index might be wrong.
Solution:   Set the index to one when using the first entry. (Lech Lorens)
Files:	    src/quickfix.c

Patch 7.3.1274
Problem:    When selecting an entry from a location list it may pick an
	    arbitrary window or open a new one.
Solution:   Prefer using a window related to the location list. (Lech Lorens)
Files:	    src/quickfix.c

Patch 7.3.1275
Problem:    "gn" does not work when the match is a single character.
Solution:   Fix it, add a test. (Christian Brabandt)
Files:	    src/search.c, src/testdir/test53.in, src/testdir/test53.ok

Patch 7.3.1276
Problem:    When using a cscope connection resizing the window may send
	    SIGWINCH to cscope and it quits.
Solution:   Call setpgid(0, 0) in the child process. (Narendran Gopalakrishnan)
Files:	    src/if_cscope.c

Patch 7.3.1277
Problem:    In diff mode 'cursorline' also draws in the non-active window.
	    When 'nu' and 'sbr' are set the 'sbr' string is not underlined.
Solution:   Only draw the cursor line in the current window. Combine the
	    'cursorline' and other highlighting attributes. (Christian
	    Brabandt)
Files:	    src/screen.c

Patch 7.3.1278
Problem:    When someone sets the screen size to a huge value with "stty" Vim
	    runs out of memory before reducing the size.
Solution:   Limit Rows and Columns in more places.
Files:	    src/gui.c, src/gui_gtk_x11.c, src/option.c, src/os_unix.c,
	    src/proto/term.pro, src/term.c

Patch 7.3.1279
Problem:    Compiler warning for variable uninitialized. (Tony Mechelynck)
Solution:   Add an init.
Files:	    src/ex_getln.c

Patch 7.3.1280
Problem:    Reading memory already freed since patch 7.3.1247. (Simon
	    Ruderich, Dominique Pelle)
Solution:   Copy submatches before reallocating the state list.
Files:	    src/regexp_nfa.c

Patch 7.3.1281
Problem:    When 'ttymouse' is set to "xterm2" clicking in column 123 moves
	    the cursor to column 96. (Kevin Goodsell)
Solution:   Decode KE_CSI.
Files:	    src/term.c

Patch 7.3.1282 (after 7.3.1277)
Problem:    'cursorline' not drawn in any other window. (Charles Campbell)
Solution:   Do draw the cursor line in other windows.
Files:	    src/screen.c

Patch 7.3.1283
Problem:    Test 71 fails on MS-Windows.
Solution:   Put the binary data in a separate file. (Ken Takata)
Files:	    src/testdir/test71.in, src/testdir/test71a.in

Patch 7.3.1284
Problem:    Compiler warnings in MS-Windows clipboard handling.
Solution:   Add type casts. (Ken Takata)
Files:	    src/winclip.c

Patch 7.3.1285
Problem:    No tests for picking a window when selecting an entry in a
	    location list.  Not picking the right window sometimes.
Solution:   Add test 96. Set usable_win appropriately. (Lech Lorens)
Files:	    src/quickfix.c, src/testdir/Makefile, src/testdir/test96.in,
	    src/testdir/test96.ok, src/testdir/Make_amiga.mak,
	    src/testdir/Make_dos.mak, src/testdir/Make_ming.mak,
	    src/testdir/Make_os2.mak, src/testdir/Make_vms.mms

Patch 7.3.1286
Problem:    Check for screen size missing for Athena and Motif.
Solution:   Add call to limit_screen_size().
Files:	    src/gui_x11.c

Patch 7.3.1287
Problem:    Python SystemExit exception is not handled properly.
Solution:   Catch the exception and give an error. (Yasuhiro Matsumoto, Ken
	    Takata)
Files:	    runtime/doc/if_pyth.txt, src/if_py_both.h, src/if_python.c,
	    src/if_python3.c

Patch 7.3.1288
Problem:    The first ":echo 'hello'" command output doesn't show.  Mapping
	    for <S-F3> gets triggered during startup.
Solution:   Add debugging code for the termresponse.  When receiving the "Co"
	    entry and when setting 'ambiwidth' redraw right away if possible.
	    Add redraw_asap().  Don't set 'ambiwidth' if it already had the
	    right value.  Do the 'ambiwidth' check in the second row to avoid
	    confusion with <S-F3>.
Files:	    src/term.c, src/screen.c, src/proto/screen.pro

Patch 7.3.1289
Problem:    Get GLIB warning when removing a menu item.
Solution:   Reference menu-id and also call gtk_container_remove().  (Ivan
	    Krasilnikov)
Files:	    src/gui_gtk.c

Patch 7.3.1290 (after 7.3.1253)
Problem:    CTRL-R = in Insert mode changes the start of the insert position.
	    (Ingo Karkat)
Solution:   Only break undo, don't start a new insert.
Files:	    src/edit.c

Patch 7.3.1291 (after 7.3.1288)
Problem:    Compiler warnings for uninitialized variables. (Tony Mechelynck)
Solution:   Initialize the variables.
Files:	    src/screen.c

Patch 7.3.1292
Problem:    Possibly using invalid pointer when searching for window. (Raichoo)
Solution:   Use "firstwin" instead of "tp_firstwin" for current tab.
Files:	    src/window.c

Patch 7.3.1293
Problem:    Put in empty buffer cannot be undone.
Solution:   Save one more line for undo. (Ozaki)
Files:	    src/ops.c

Patch 7.3.1294
Problem:    ":diffoff" resets options.
Solution:   Save and restore option values. (Christian Brabandt)
Files:	    src/diff.c, src/structs.h, src/option.c

Patch 7.3.1295
Problem:    glob() and globpath() do not handle escaped special characters
	    properly.
Solution:   Handle escaped characters differently. (Adnan Zafar)
Files:	    src/testdir/Makefile, src/testdir/test97.in,
	    src/testdir/test97.ok, src/testdir/Make_amiga.mak,
	    src/testdir/Make_dos.mak, src/testdir/Make_ming.mak,
	    src/testdir/Make_os2.mak, src/testdir/Make_vms.mms, src/fileio.c,
	    src/misc1.c

Patch 7.3.1296
Problem:    Only MS-Windows limits the GUI window size to what fits on the
	    monitor.
Solution:   Limit the size for all systems. (Daniel Harding)
Files:	    src/ui.c

Patch 7.3.1297
Problem:    findfile() directory matching does not work when a star follows
	    text. (Markus Braun)
Solution:   Make a wildcard work properly. (Christian Brabandt)
Files:	    src/misc2.c, src/testdir/test89.in, src/testdir/test89.ok

Patch 7.3.1298 (after 7.3.1297)
Problem:    Crash.
Solution:   Use STRCPY() instead of STRCAT() and allocate one more byte.
Files:	    src/misc2.c

Patch 7.3.1299
Problem:    Errors when doing "make proto".  Didn't do "make depend" for a
	    while.
Solution:   Add #ifdefs.  Update dependencies.  Update proto files.
Files:	    src/if_python3.c, src/os_win32.c, src/Makefile,
	    src/proto/ex_docmd.pro, src/proto/if_python.pro,
	    src/proto/if_python3.pro, src/proto/gui_w16.pro,
	    src/proto/gui_w32.pro, src/proto/os_win32.pro

Patch 7.3.1300
Problem:    Mac: tiny and small build fails.
Solution:   Don't include os_macosx.m in tiny build. Include mouse support in
	    small build. (Kazunobu Kuriyama)
Files:	    src/configure.in, src/auto/configure, src/vim.h

Patch 7.3.1301
Problem:    Some tests fail on MS-Windows.
Solution:   Fix path separators in test 89 and 96.  Omit test 97, escaping
	    works differently.  Make findfile() work on MS-Windows.
Files:	    src/testdir/Make_dos.mak, src/testdir/Make_ming.mak,
	    src/testdir/Make_os2.mak, src/testdir/test89.in,
	    src/testdir/test96.in, src/misc2.c

Patch 7.3.1302
Problem:    Test 17 fails on MS-Windows.  Includes line break in file name
	    everywhere.
Solution:   Fix 'fileformat'. Omit CR-LF from a line read from an included
	    file.
Files:	    src/search.c, src/testdir/test17.in, src/testdir/test17.ok

Patch 7.3.1303 (after 7.3.1290)
Problem:    Undo is synced whenever CTRL-R = is called, breaking some plugins.
Solution:   Only break undo when calling setline() or append().
Files:	    src/globals.h, src/eval.c, src/edit.c, src/testdir/test61.in,
	    src/testdir/test61.ok

Patch 7.3.1304
Problem:    Test 89 still fails on MS-Windows.
Solution:   Set 'shellslash'. (Taro Muraoka)
Files:	    src/testdir/test89.in

Patch 7.3.1305
Problem:    Warnings from 64 bit compiler.
Solution:   Add type casts.
Files:	    src/misc2.c

Patch 7.3.1306
Problem:    When redrawing the screen during startup the intro message may be
	    cleared.
Solution:   Redisplay the intro message when appropriate.
Files:	    src/screen.c, src/version.c, src/proto/version.pro

Patch 7.3.1307
Problem:    MS-Windows build instructions are outdated.
Solution:   Adjust for building on Windows 7.  Drop Windows 95/98/ME support.
Files:	    Makefile, nsis/gvim.nsi

Patch 7.3.1308
Problem:    Typos in MS-Windows build settings and README.
Solution:   Minor changes to MS-Windows files.
Files:	    src/msvc2008.bat, src/msvc2010.bat, src/VisVim/README_VisVim.txt

Patch 7.3.1309
Problem:    When a script defines a function the flag to wait for the user to
	    hit enter is reset.
Solution:   Restore the flag. (Yasuhiro Matsumoto)  Except when the user was
	    typing the function.
Files:	    src/eval.c

Patch 7.3.1310
Problem:    Typos in nsis script. Can use better compression.
Solution:   Fix typos.  Use lzma compression. (Ken Takata)
Files:	    nsis/gvim.nsi

Patch 7.3.1311
Problem:    Compiler warnings on Cygwin.
Solution:   Add type casts. Add windows include files. (Ken Takata)
Files:	    src/mbyte.c, src/ui.c

Patch 7.3.1312 (after 7.3.1287)
Problem:    Not giving correct error messages for SystemExit().
Solution:   Move E858 into an else. (Ken Takata)
Files:	    src/if_py_both.h

Patch 7.3.1313
Problem:    :py and :py3 don't work when compiled with Cygwin or MingW with 64
	    bit.
Solution:   Add -DMS_WIN64 to the build command. (Ken Takata)
Files:	    src/Make_cyg.mak, src/Make_ming.mak

Patch 7.3.1314
Problem:    Test 87 fails with Python 3.3.
Solution:   Filter the error messages. (Taro Muraoka)
Files:	    src/testdir/test87.in

Patch 7.4a.001
Problem:    Script to update syntax menu is outdated.
Solution:   Add the missing items.
Files:	    runtime/makemenu.vim

Patch 7.4a.002
Problem:    Valgrind errors in test 89. (Simon Ruderich)
Solution:   Allocate one more byte. (Dominique Pelle)
Files:	    src/misc2.c

Patch 7.4a.003
Problem:    Copyright year is outdated.
Solution:   Only use the first year.
Files:	    src/vim.rc, src/vim16.rc

Patch 7.4a.004
Problem:    MSVC 2012 Update 3 is not recognized.
Solution:   Add the version number. (Raymond Ko)
Files:	    src/Make_mvc.mak

Patch 7.4a.005
Problem:    Scroll binding causes unexpected scroll.
Solution:   Store the topline after updating scroll binding.  Add a test.
	    (Lech Lorens)
Files:	    src/testdir/test98.in, src/testdir/test98a.in,
	    src/testdir/test98.ok, src/option.c, src/testdir/Make_amiga.mak,
	    src/testdir/Make_dos.mak, src/testdir/Make_ming.mak,
	    src/testdir/Make_os2.mak, src/testdir/Make_vms.mms,
	    src/testdir/Makefile

Patch 7.4a.006
Problem:    Failure in po file check goes unnoticed.
Solution:   Fail "make test" if the po file check fails.
Files:	    src/Makefile

Patch 7.4a.007
Problem:    After "g$" with 'virtualedit' set, "k" moves to a different
	    column.  (Dimitar Dimitrov)
Solution:   Set w_curswant. (Christian Brabandt)
Files:	    src/normal.c

Patch 7.4a.008
Problem:    Python 3 doesn't handle multibyte characters properly when
	    'encoding' is not utf-8.
Solution:   Use PyUnicode_Decode() instead of PyUnicode_FromString(). (Ken
	    Takata)
Files:	    src/if_python3.c

Patch 7.4a.009
Problem:    Compiler warnings for function prototypes.
Solution:   Add "void".  Move list_features() prototype. (Ken Takata)
Files:	    src/gui_w48.c, src/if_py_both.h, src/version.c

Patch 7.4a.010
Problem:    Test 86 and 87 fail when building with Python or Python 3 and
	    using a static library.
Solution:   Add configure check to add -fPIE compiler flag.
Files:	    src/configure.in, src/auto/configure

Patch 7.4a.011
Problem:    Configure check for Python 3 config name isn't right.
Solution:   Always include vi_cv_var_python3_version. (Tim Harder)
Files:	    src/configure.in, src/auto/configure

Patch 7.4a.012
Problem:    "make test" fails when using a shadow directory.
Solution:   Create links for files in src/po. (James McCoy)
Files:	    src/Makefile

Patch 7.4a.013
Problem:    Setting/resetting 'lbr' in the main help file changes alignment
	    after a Tab. (Dimitar Dimitrov)
Solution:   Also use the code for conceal mode where n_extra is computed for
	    'lbr'.
Files:	    src/screen.c, src/testdir/test88.in, src/testdir/test88.ok

Patch 7.4a.014
Problem:    Test 86 and 89 have a problem with using a shadow dir.
Solution:   Adjust for the different directory structure. (James McCoy)
Files:	    src/testdir/test89.in, src/testdir/test86.in, src/Makefile

Patch 7.4a.015
Problem:    No Japanese man pages.
Solution:   Add Japanese translations of man pages. (Ken Takata, Yukihiro
	    Nakadaira, et al.)
Files:	    Filelist, src/Makefile, runtime/doc/evim-ja.UTF-8.1,
	    runtime/doc/vim-ja.UTF-8.1, runtime/doc/vimdiff-ja.UTF-8.1,
	    runtime/doc/vimtutor-ja.UTF-8.1, runtime/doc/xxd-ja.UTF-8.1

Patch 7.4a.016 (after 7.4a.014)
Problem:    Features enabled in Makefile.
Solution:   Undo accidental changes.
Files:	    src/Makefile

Patch 7.4a.017
Problem:    When 'foldmethod' is "indent", using ">>" on a line just above a
	    fold makes the cursor line folded. (Evan Laforge)
Solution:   Call foldOpenCursor(). (Christian Brabandt)
Files:	    src/ops.c

Patch 7.4a.018
Problem:    Compiler warning for code unreachable. (Charles Campbell)
Solution:   Use "while" instead of endless loop.  Change break to continue.
Files:	    src/regexp_nfa.c, src/ui.c

Patch 7.4a.019
Problem:    Invalid closing parenthesis in test 62. Command truncated at
	    double quote.
Solution:   Remove the parenthesis. Change double quote to ''. (ZyX)
Files:	    src/testdir/test62.in, src/testdir/test62.ok

Patch 7.4a.020
Problem:    Superfluous mb_ptr_adv().
Solution:   Remove the call. (Dominique Pelle)
Files:	    src/regexp_nfa.c

Patch 7.4a.021
Problem:    Using feedkeys() doesn't always work.
Solution:   Omit feedkeys(). (Ken Takata)
Files:	    src/testdir/test98a.in

Patch 7.4a.022
Problem:    Using "d2g$" does not delete the last character. (ZyX)
Solution:   Set the "inclusive" flag properly.
Files:	    src/normal.c

Patch 7.4a.023 (after 7.4a.019)
Problem:    Still another superfluous parenthesis. (ZyX)
Solution:   Remove it.
Files:	    src/testdir/test62.in

Patch 7.4a.024
Problem:    X11 GUI: Checking icon height twice.
Solution:   Check height and width. (Dominique Pelle)
Files:	    src/gui_x11.c

Patch 7.4a.025
Problem:    Get the press-Enter prompt even after using :redraw.
Solution:   Clear need_wait_return when executing :redraw.
Files:	    src/ex_docmd.c

Patch 7.4a.026
Problem:    ":diffoff" does not remove folds. (Ramel)
Solution:   Do not restore 'foldenable' when 'foldmethod' is "manual".
Files:	    src/diff.c

Patch 7.4a.027
Problem:    When Python adds lines to another buffer the cursor position is
	    wrong, it might be below the last line causing ml_get errors.
	    (Vlad Irnov)
Solution:   Temporarily change the current window, so that marks are corrected
	    properly.
Files:	    src/if_py_both.h, src/window.c, src/proto/buffer.pro

Patch 7.4a.028
Problem:    Crash when spell checking in new buffer.
Solution:   Set the b_p_key field.  (Mike Williams)
Files:	    src/spell.c, src/testdir/test58.in

Patch 7.4a.029
Problem:    Can't build with MzScheme on Ubuntu 13.04.
Solution:   Add configure check for the "ffi" library.
Files:	    src/configure.in, src/auto/configure

Patch 7.4a.030 (after 7.4.027)
Problem:    Missing find_win_for_buf(). (toothpik)
Solution:   Add missing changes.
Files:	    src/buffer.c

Patch 7.4a.031
Problem:    Compiler warnings. (Charles Campbell)
Solution:   Initialize variables even when not needed.
Files:	    src/regexp_nfa.c, src/search.c

Patch 7.4a.032
Problem:    New regexp engine: Does not match shorter alternative. (Ingo
	    Karkat)
Solution:   Do not drop a new state when the PIM info is different.
Files:	    src/regexp_nfa.c

Patch 7.4a.033
Problem:    Test 98 always passes.
Solution:   Include test98a.in in test98.in, execute the crucial command in
	    one line. (Yukihiro Nakadaira)
Files:	    src/testdir/test98.in, src/testdir/test98a.in

Patch 7.4a.034
Problem:    The tabline may flicker when opening a new tab after 7.3.759 on
	    Win32.
Solution:   Move call to TabCtrl_SetCurSel(). (Ken Takata)
Files:	    src/gui_w48.c

Patch 7.4a.035
Problem:    Fix in patch 7.4a.032 is not tested.
Solution:   Add test.
Files:	    src/testdir/test64.in, src/testdir/test64.ok

Patch 7.4a.036
Problem:    "\p" in a regexp does not match double-width characters.
	    (Yukihiro Nakadaira)
Solution:   Don't count display cells, use vim_isprintc().
Files:	    src/regexp.c, src/regexp_nfa.c, src/testdir/test64.in,
	    src/testdir/test64.ok, src/testdir/test95.in,
	    src/testdir/test95.ok

Patch 7.4a.037
Problem:    Win32: When mouse is hidden and in the toolbar, moving it won't
	    make it appear. (Sami Salonen)
Solution:   Add tabline_wndproc() and toolbar_wndproc(). (Ken Takata)
Files:	    src/gui_w32.c, src/gui_w48.c

Patch 7.4a.038
Problem:    When using MSVC 2012 there are various issues, including GUI size
	    computations.
Solution:   Use SM_CXPADDEDBORDER. (Mike Williams)
Files:	    src/gui_w32.c, src/gui_w48.c, src/os_win32.h

Patch 7.4a.039
Problem:    New regexp engine doesn't match pattern. (Ingo Karkat)
Solution:   When adding a state also check for different PIM if the list of
	    states has any state with a PIM.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.4a.040
Problem:    Win32: using uninitialized variable.
Solution:   (Yukihiro Nakadaira)
Files:	    src/os_win32.c

Patch 7.4a.041
Problem:    When using ":new ++ff=unix" and "dos" is first in 'fileformats'
	    then 'ff' is set to "dos" instead of "unix". (Ingo Karkat)
Solution:   Create set_file_options() and invoke it from do_ecmd().
Files:	    src/fileio.c, src/proto/fileio.pro, src/ex_cmds.c,
	    src/testdir/test91.in, src/testdir/test91.ok

Patch 7.4a.042
Problem:    Crash when BufUnload autocommands close all buffers. (Andrew
	    Pimlott)
Solution:   Set curwin->w_buffer to curbuf to avoid NULL.
Files:	    src/window.c, src/testdir/test8.in, src/testdir/test8.ok

Patch 7.4a.043
Problem:    More ml_get errors when adding or deleting lines from Python.
	    (Vlad Irnov)
Solution:   Switch to a window with the buffer when possible.
Files:	    src/if_py_both.h

Patch 7.4a.044
Problem:    Test 96 sometimes fails.
Solution:   Clear window from b_wininfo in win_free().  (Suggestion by
	    Yukihiro Nakadaira)
Files:	    src/window.c

Patch 7.4a.045
Problem:    Configure does not always find the right library for Lua.  Missing
	    support for LuaJit. 
Solution:   Improve the configure detection of Lua. (Hiroshi Shirosaki)
Files:	    src/Makefile, src/configure.in, src/auto/configure

Patch 7.4a.046
Problem:    Can't build without mbyte feature.
Solution:   Add #ifdefs.
Files:	    src/ex_cmds.c

Patch 7.4a.047
Problem:    Some comments are not so nice.
Solution:   Change the comments.
Files:	    src/ex_docmd.c, src/message.c, src/ops.c, src/option.c

Patch 7.4b.001
Problem:    Win32: dialog may extend off-screen.
Solution:   Reduce the size, use correct borders. (Andrei Olsen)
Files:	    src/gui_w32.c

Patch 7.4b.002
Problem:    Crash searching for \%(\%(\|\d\|-\|\.\)*\|\*\). (Marcin
	    Szamotulski)  Also for \(\)*.
Solution:   Do add a state for opening parenthesis, so that we can check if it
	    was added before at the same position.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.4b.003
Problem:    Regexp code is not nicely aligned.
Solution:   Adjust white space. (Ken Takata)
Files:	    src/regexp_nfa.c

Patch 7.4b.004
Problem:    Regexp crash on pattern "@\%[\w\-]*". (Axel Kielhorn)
Solution:   Add \%(\) around \%[] internally.
Files:	    src/regexp_nfa.c, src/testdir/test64.in, src/testdir/test64.ok

Patch 7.4b.005
Problem:    Finding %s in shellpipe and shellredir does not ignore %%s.
Solution:   Skip over %%. (lcd 47)
Files:	    src/ex_cmds.c

Patch 7.4b.006 (after 7.3.1295)
Problem:    Using \{n,m} in an autocommand pattern no longer works.
	    Specifically, mutt temp files are not recognized. (Gary Johnson)
Solution:   Make \\\{n,m\} work.
Files:	    runtime/doc/autocmd.txt, src/fileio.c

Patch 7.4b.007
Problem:    On 32 bit MS-Windows :perldo does not work.
Solution:   Make sure time_t uses 32 bits. (Ken Takata)
Files:	    src/if_perl.xs, src/vim.h

Patch 7.4b.008
Problem:    'autochdir' causes setbufvar() to change the current directory.
	    (Ben Fritz)
Solution:   When disabling autocommands also reset 'acd' temporarily.
	    (Christian Brabandt)
Files:	    src/fileio.c

Patch 7.4b.009
Problem:    When setting the Visual area manually and 'selection' is
	    exclusive, a yank includes one character too much. (Ingo Karkat)
Solution:   Default the Visual operation to "v". (Christian Brabandt)
Files:	    src/mark.c

Patch 7.4b.010
Problem:    Win32: Tcl library load does not use standard mechanism.
Solution:   Call vimLoadLib() instead of LoadLibraryEx(). (Ken Takata)
Files:	    src/if_perl.xs, src/if_tcl.c

Patch 7.4b.011
Problem:    ":he \%(\)" does not work. (ZyX)
Solution:   Add an exception to the list.
Files:	    src/ex_cmds.c

Patch 7.4b.012
Problem:    Output from a shell command is truncated at a NUL. (lcd 47)
Solution:   Change every NUL into an SOH.
Files:	    src/misc1.c

Patch 7.4b.013
Problem:    Install dir for JP man pages is wrong.
Solution:   Remove ".UTF-8" from the directory name. (Ken Takata)
Files:	    src/Makefile

Patch 7.4b.014 (after 7.4b.012)
Problem:    Stupid mistake.
Solution:   Changle "len" to "i".
Files:	    src/misc1.c

Patch 7.4b.015 (after 7.4b.008)
Problem:    Can't compile without the 'acd' feature.
Solution:   Add #ifdefs. (Kazunobu Kuriyama)
Files:	    src/fileio.c

Patch 7.4b.016
Problem:    Ruby detection fails on Fedora 19.
Solution:   Use one way to get the Ruby version. (Michael Henry)
Files:	    src/configure.in, src/auto/configure

Patch 7.4b.017
Problem:    ":he \^x" gives a strange error message. (glts)
Solution:   Do not translate \^x to \_CTRL-x.
Files:	    src/ex_cmds.c

Patch 7.4b.018 (after 7.4b.001)
Problem:    Win32: Dialog can still be too big.
Solution:   Move the check for height further down. (Andrei Olsen)
Files:	    src/gui_w32.c

Patch 7.4b.019 (after 7.4a.034)
Problem:    Tabline is not updated properly when closing a tab on Win32.
Solution:   Only reduce flickering when adding a tab. (Ken Takata)
Files:	    src/gui_w48.c

Patch 7.4b.020
Problem:    "g~ap" changes first character of next paragraph. (Manuel Ortega)
Solution:   Avoid subtracting (0 - 1) from todo.  (Mike Williams)
Files:	    src/ops.c, src/testdir/test82.in, src/testdir/test82.ok

Patch 7.4b.021
Problem:    Pressing "u" after an external command results in multiple
	    press-enter messages. (glts)
Solution:   Don't call hit_return_msg() when we have K_IGNORE. (Christian
	    Brabandt)
Files:	    src/message.c

Patch 7.4b.022
Problem:    Not waiting for a character when the tick count overflows.
Solution:   Subtract the unsigned numbers and cast to int. (Ken Takata)
Files:	    src/os_win32.c


 vim:tw=78:ts=8:ft=help:norl:
           usr/share/vim/vim74/doc/vi_diff.txt                                                                 0100644 0000000 0000000 00000122271 13050207306 015636  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *vi_diff.txt*   For Vim version 7.4.  Last change: 2013 Aug 22


		  VIM REFERENCE MANUAL    by Bram Moolenaar


Differences between Vim and Vi				*vi-differences*

Throughout the help files differences between Vim and Vi/Ex are given in
curly braces, like "{not in Vi}".  This file only lists what has not been
mentioned in other files and gives an overview.

Vim is mostly POSIX 1003.2-1 compliant.  The only command known to be missing
is ":open".  There are probably a lot of small differences (either because Vim
is missing something or because Posix is beside the mark).

1. Simulated command			|simulated-command|
2. Missing options			|missing-options|
3. Limits				|limits|
4. The most interesting additions	|vim-additions|
5. Other vim features			|other-features|
6. Command-line arguments		|cmdline-arguments|
7. POSIX compliance			|posix-compliance|

==============================================================================
1. Simulated command					*simulated-command*

This command is in Vi, but Vim only simulates it:

							*:o* *:op* *:open*
:[range]o[pen]			Works like |:visual|: end Ex mode.
				{Vi: start editing in open mode}

:[range]o[pen] /pattern/	As above, additionally move the cursor to the
				column where "pattern" matches in the cursor
				line.

Vim does not support open mode, since it's not really useful.  For those
situations where ":open" would start open mode Vim will leave Ex mode, which
allows executing the same commands, but updates the whole screen instead of
only one line.

==============================================================================
2. Missing options					*missing-options*

These options are in the Unix Vi, but not in Vim.  If you try to set one of
them you won't get an error message, but the value is not used and cannot be
printed.

autoprint (ap)		boolean	(default on)		*'autoprint'* *'ap'*
beautify (bf)		boolean	(default off)		*'beautify'* *'bf'*
flash (fl)		boolean	(default ??)		*'flash'* *'fl'*
graphic (gr)		boolean	(default off)		*'graphic'* *'gr'*
hardtabs (ht)		number	(default 8)		*'hardtabs'* *'ht'*
	number of spaces that a <Tab> moves on the display
mesg			boolean	(default on)		*'mesg'*
novice			boolean	(default off)		*'novice'*
open			boolean	(default on)		*'open'*
optimize (op)		boolean	(default off)		*'optimize'* *'op'*
redraw			boolean	(default off)		*'redraw'*
slowopen (slow)		boolean	(default off)		*'slowopen'* *'slow'*
sourceany		boolean	(default off)		*'sourceany'*
w300			number	(default 23)		*'w300'*
w1200			number	(default 23)		*'w1200'*
w9600			number	(default 23)		*'w9600'*

==============================================================================
3. Limits						*limits*

Vim has only a few limits for the files that can be edited {Vi: can not handle
<Nul> characters and characters above 128, has limited line length, many other
limits}.
							*E340*
Maximum line length	   On machines with 16-bit ints (Amiga and MS-DOS real
			   mode): 32767, otherwise 2147483647 characters.
			   Longer lines are split.
Maximum number of lines	   2147483647 lines.
Maximum file size	   2147483647 bytes (2 Gbyte) when a long integer is
			   32 bits.  Much more for 64 bit longs.  Also limited
			   by available disk space for the |swap-file|.
							*E75*
Length of a file path	   Unix and Win32: 1024 characters, otherwise 256
			   characters (or as much as the system supports).
Length of an expanded string option
			   Unix and Win32: 1024 characters, otherwise 256
			   characters
Maximum display width	   Unix and Win32: 1024 characters, otherwise 255
			   characters
Maximum lhs of a mapping   50 characters.
Number of different highlighting types: over 30000
Range of a Number variable:  -2147483648 to 2147483647 (might be more on 64
			   bit systems)
Maximum length of a line in a tags file: 512 bytes.

Information for undo and text in registers is kept in memory, thus when making
(big) changes the amount of (virtual) memory available limits the number of
undo levels and the text that can be kept in registers.  Other things are also
kept in memory:  Command-line history, error messages for Quickfix mode, etc.

Memory usage limits
-------------------

The option 'maxmem' ('mm') is used to set the maximum memory used for one
buffer (in kilobytes).  'maxmemtot' is used to set the maximum memory used for
all buffers (in kilobytes).  The defaults depend on the system used.  For the
Amiga and MS-DOS, 'maxmemtot' is set depending on the amount of memory
available.
These are not hard limits, but tell Vim when to move text into a swap file.
If you don't like Vim to swap to a file, set 'maxmem' and 'maxmemtot' to a
very large value.  The swap file will then only be used for recovery.  If you
don't want a swap file at all, set 'updatecount' to 0, or use the "-n"
argument when starting Vim.

==============================================================================
4. The most interesting additions			*vim-additions*

Vi compatibility.					|'compatible'|
	Although Vim is 99% Vi compatible, some things in Vi can be
	considered to be a bug, or at least need improvement.  But still, Vim
	starts in a mode which behaves like the "real" Vi as much as possible.
	To make Vim behave a little bit better, try resetting the 'compatible'
	option:
		:set nocompatible
	Or start Vim with the "-N" argument:
		vim -N
	Vim starts with 'nocompatible' automatically if you have a .vimrc
	file.  See |startup|.
	The 'cpoptions' option can be used to set Vi compatibility on/off for
	a number of specific items.

Support for different systems.
	Vim can be used on:
	- All Unix systems (it works on all systems it was tested on, although
	  the GUI and Perl interface may not work everywhere).
	- Amiga (500, 1000, 1200, 2000, 3000, 4000, ...).
	- MS-DOS in real-mode (no additional drivers required).
	- In protected mode on Windows 3.1 and MS-DOS (DPMI driver required).
	- Windows 95 and Windows NT, with support for long file names.
	- OS/2 (needs emx.dll)
	- Atari MiNT
	- VMS
	- BeOS
	- Macintosh
	- Risc OS
	- IBM OS/390
	Note that on some systems features need to be disabled to reduce
	resource usage, esp. on MS-DOS.  For some outdated systems you need to
	use an older Vim version.

Multi level undo.					|undo|
	'u' goes backward in time, 'CTRL-R' goes forward again.  Set option
	'undolevels' to the number of changes to be remembered (default 1000).
	Set 'undolevels' to 0 for a Vi-compatible one level undo.  Set it to
	-1 for no undo at all.
	When all changes in a buffer have been undone, the buffer is not
	considered changed anymore.  You can exit it with :q, without <!>.
	When undoing a few changes and then making a new change Vim will
	create a branch in the undo tree.  This means you can go back to any
	state of the text, there is no risk of a change causing text to be
	lost forever. |undo-tree|

Graphical User Interface (GUI).				|gui|
	Included support for GUI: menu's, mouse, scrollbars, etc.  You can
	define your own menus.  Better support for CTRL/SHIFT/ALT keys in
	combination with special keys and mouse.  Supported for various
	platforms, such as X11 (with Motif and Athena interfaces), GTK, Win32
	(Windows 95 and later), BeOS, Amiga and Macintosh.

Multiple windows and buffers.				|windows.txt|
	Vim can split the screen into several windows, each editing a
	different buffer or the same buffer at a different location.  Buffers
	can still be loaded (and changed) but not displayed in a window.  This
	is called a hidden buffer.  Many commands and options have been added
	for this facility.
	Vim can also use multiple tab pages, each with one or more windows.  A
	line with tab labels can be used to quickly switch between these pages.
	|tab-page|

Syntax highlighting.					|:syntax|
	Vim can highlight keywords, patterns and other things.  This is
	defined by a number of |:syntax| commands, and can be made to
	highlight most languages and file types.  A number of files are
	included for highlighting the most common languages, like C, C++,
	Java, Pascal, Makefiles, shell scripts, etc.  The colors used for
	highlighting can be defined for ordinary terminals, color terminals
	and the GUI with the |:highlight| command.  A convenient way to do
	this is using a |:colorscheme| command.
	The highlighted text can be exported as HTML. |convert-to-HTML|
	Other items that can be highlighted are matches with the search string
	|'hlsearch'|, matching parens |matchparen| and the cursor line and
	column |'cursorline'| |'cursorcolumn'|.

Spell checking.						|spell|
	When the 'spell' option is set Vim will highlight spelling mistakes.
	About 50 languages are currently supported, selected with the
	'spelllang' option.  In source code only comments and strings are
	checked for spelling.

Folding.						|folding|
	A range of lines can be shown as one "folded" line.  This allows
	overviewing a file and moving blocks of text around quickly.
	Folds can be created manually, from the syntax of the file, by indent,
	etc.

Diff mode.						|diff|
	Vim can show two versions of a file with the differences highlighted.
	Parts of the text that are equal are folded away.  Commands can be
	used to move text from one version to the other.

Plugins.						|add-plugin|
	The functionality can be extended by dropping a plugin file in the
	right directory.  That's an easy way to start using Vim scripts
	written by others.  Plugins can be for all kind of files, or
	specifically for a filetype.

Repeat a series of commands.				|q|
	"q{c}" starts recording typed characters into named register {c}.
	A subsequent "q" stops recording.  The register can then be executed
	with the "@{c}" command.  This is very useful to repeat a complex
	action.

Flexible insert mode.					|ins-special-special|
	The arrow keys can be used in insert mode to move around in the file.
	This breaks the insert in two parts as far as undo and redo is
	concerned.

	CTRL-O can be used to execute a single Normal mode command.  This is
	almost the same as hitting <Esc>, typing the command and doing |a|.

Visual mode.						|Visual-mode|
	Visual mode can be used to first highlight a piece of text and then
	give a command to do something with it.  This is an (easy to use)
	alternative to first giving the operator and then moving to the end of
	the text to be operated upon.
	|v| and |V| are used to start Visual mode.  |v| works on characters
	and |V| on lines.  Move the cursor to extend the Visual area.  It is
	shown highlighted on the screen.  By typing "o" the other end of the
	Visual area can be moved.  The Visual area can be affected by an
	operator:
		d	delete
		c	change
		y	yank
		> or <	insert or delete indent
		!	filter through external program
		=	filter through indent
		:	start |:| command for the Visual lines.
		gq	format text to 'textwidth' columns
		J	join lines
		~	swap case
		u	make lowercase
		U	make uppercase

Block operators.					|visual-block|
	With Visual mode a rectangular block of text can be selected.  Start
	Visual mode with CTRL-V.  The block can be deleted ("d"), yanked ("y")
	or its case can be changed ("~", "u" and "U").  A deleted or yanked
	block can be put into the text with the "p" and "P" commands.

Help system.						|:help|
	Help is displayed in a window.  The usual commands can be used to
	move around, search for a string, etc.  Tags can be used to jump
	around in the help files, just like hypertext links.  The |:help|
	command takes an argument to quickly jump to the info on a subject.
	<F1> is the quick access to the help system.  The name of the help
	index file can be set with the 'helpfile' option.

Command-line editing and history.			|cmdline-editing|
	You can insert or delete at any place in the command-line using the
	cursor keys.  The right/left cursor keys can be used to move
	forward/backward one character.  The shifted right/left cursor keys
	can be used to move forward/backward one word.  CTRL-B/CTRL-E can be
	used to go to the begin/end of the command-line.
							|cmdline-history|
	The command-lines are remembered.  The up/down cursor keys can be used
	to recall previous command-lines.  The 'history' option can be set to
	the number of lines that will be remembered.  There is a separate
	history for commands and for search patterns.

Command-line completion.				|cmdline-completion|
	While entering a command-line (on the bottom line of the screen)
	<Tab> can be typed to complete
	   what		example		~
	- command	:e<Tab>
	- tag		:ta scr<Tab>
	- option	:set sc<Tab>
	- option value  :set hf=<Tab>
	- file name	:e ve<Tab>
	- etc.

	If there are multiple matches, CTRL-N (next) and CTRL-P (previous)
	will walk through the matches.  <Tab> works like CTRL-N, but wraps
	around to the first match.

	The 'wildchar' option can be set to the character for command-line
	completion, <Tab> is the default.  CTRL-D can be typed after an
	(incomplete) wildcard; all matches will be listed.  CTRL-A will insert
	all matches.  CTRL-L will insert the longest common part of the
	matches.

Insert-mode completion.					|ins-completion|
	In Insert mode the CTRL-N and CTRL-P keys can be used to complete a
	word that appears elsewhere.	|i_CTRL-N|
	With CTRL-X another mode is entered, through which completion can be
	done for:
	|i_CTRL-X_CTRL-F|	file names
	|i_CTRL-X_CTRL-K|	words from 'dictionary' files
	|i_CTRL-X_CTRL-T|	words from 'thesaurus' files
	|i_CTRL-X_CTRL-I|	words from included files
	|i_CTRL-X_CTRL-L|	whole lines
	|i_CTRL-X_CTRL-]|	words from the tags file
	|i_CTRL-X_CTRL-D|	definitions or macros
	|i_CTRL-X_CTRL-O|	Omni completion: clever completion
				specifically for a file type
	etc.

Long line support.					|'wrap'| |'linebreak'|
	If the 'wrap' option is off, long lines will not wrap and only part
	of them will be shown.  When the cursor is moved to a part that is not
	shown, the screen will scroll horizontally.  The minimum number of
	columns to scroll can be set with the 'sidescroll' option.  The |zh|
	and |zl| commands can be used to scroll sideways.
	Alternatively, long lines are broken in between words when the
	'linebreak' option is set.  This allows editing a single-line
	paragraph conveniently (e.g. when the text is later read into a DTP
	program).  Move the cursor up/down with the |gk| and |gj| commands.

Text formatting.					|formatting|
	The 'textwidth' option can be used to automatically limit the line
	length.  This supplements the 'wrapmargin' option of Vi, which was not
	very useful.  The |gq| operator can be used to format a piece of text
	(for example, |gqap| formats the current paragraph).  Commands for
	text alignment: |:center|, |:left| and |:right|.

Extended search patterns.				|pattern|
	There are many extra items to match various text items.  Examples:
	A "\n" can be used in a search pattern to match a line break.
	"x\{2,4}" matches "x" 2 to 4 times.
	"\s" matches a white space character.

Directory, remote and archive browsing.			|netrw|
	Vim can browse the file system.  Simply edit a directory.  Move around
	in the list with the usual commands and press <Enter> to go to the
	directory or file under the cursor.
	This also works for remote files over ftp, http, ssh, etc.
	Zip and tar archives can also be browsed. |tar| |zip|

Edit-compile-edit speedup.				|quickfix|
	The |:make| command can be used to run the compilation and jump to the
	first error.  A file with compiler error messages is interpreted.  Vim
	jumps to the first error.

	Each line in the error file is scanned for the name of a file, line
	number and error message.  The 'errorformat' option can be set to a
	list of scanf-like strings to handle output from many compilers.

	The |:cn| command can be used to jump to the next error.
	|:cl| lists all the error messages.  Other commands are available.
	The 'makeef' option has the name of the file with error messages.
	The 'makeprg' option contains the name of the program to be executed
	with the |:make| command.
	The 'shellpipe' option contains the string to be used to put the
	output of the compiler into the errorfile.

Finding matches in files.				|:vimgrep|
	Vim can search for a pattern in multiple files.  This uses the
	advanced Vim regexp pattern, works on all systems and also works to
	search in compressed files.

Improved indenting for programs.			|'cindent'|
	When the 'cindent' option is on the indent of each line is
	automatically adjusted.  C syntax is mostly recognized.  The indent
	for various styles can be set with 'cinoptions'.  The keys to trigger
	indenting can be set with 'cinkeys'.

	Comments can be automatically formatted.  The 'comments' option can be
	set to the characters that start and end a comment.  This works best
	for C code, but also works for e-mail (">" at start of the line) and
	other types of text.  The |=| operator can be used to re-indent
	lines.

	For many other languages an indent plugin is present to support
	automatic indenting. |30.3|

Searching for words in included files.			|include-search|
	The |[i| command can be used to search for a match of the word under
	the cursor in the current and included files.  The 'include' option
	can be set to a pattern that describes a command to include a file
	(the default is for C programs).
	The |[I| command lists all matches, the |[_CTRL-I| command jumps to
	a match.
	The |[d|, |[D| and |[_CTRL-D| commands do the same, but only for
	lines where the pattern given with the 'define' option matches.

Automatic commands.					|autocommand|
	Commands can be automatically executed when reading a file, writing a
	file, jumping to another buffer, etc., depending on the file name.
	This is useful to set options and mappings for C programs,
	documentation, plain text, e-mail, etc.  This also makes it possible
	to edit compressed files.

Scripts and Expressions.				|expression|
	Commands have been added to form up a powerful script language.
	|:if|		Conditional execution, which can be used for example
			to set options depending on the value of $TERM.
	|:while|	Repeat a number of commands.
	|:for|		Loop over a list.
	|:echo|		Print the result of an expression.
	|:let|		Assign a value to an internal variable, option, etc.
			Variable types are Number, String, List and Dictionary.
	|:execute|	Execute a command formed by an expression.
	|:try|		Catch exceptions.
	etc., etc.  See |eval|.
	Debugging and profiling are supported. |debug-scripts| |profile|
	If this is not enough, an interface is provided to |Python|, |Ruby|,
	|Tcl|, |Lua|, |Perl| and |MzScheme|.

Viminfo.						|viminfo-file|
	The command-line history, marks and registers can be stored in a file
	that is read on startup.  This can be used to repeat a search command
	or command-line command after exiting and restarting Vim.  It is also
	possible to jump right back to where the last edit stopped with |'0|.
	The 'viminfo' option can be set to select which items to store in the
	.viminfo file.  This is off by default.

Printing.						|printing|
	The |:hardcopy| command sends text to the printer.  This can include
	syntax highlighting.

Mouse support.						|mouse-using|
	The mouse is supported in the GUI version, in an xterm for Unix, for
	BSDs with sysmouse, for Linux with gpm, for MS-DOS, and Win32.  It
	can be used to position the cursor, select the visual area, paste a
	register, etc.

Usage of key names.					|<>| |key-notation|
	Special keys now all have a name like <Up>, <End>, etc.
	This name can be used in mappings, to make it easy to edit them.

Editing binary files.					|edit-binary|
	Vim can edit binary files.  You can change a few characters in an
	executable file, without corrupting it.  Vim doesn't remove NUL
	characters (they are represented as <NL> internally).
	|-b|		command-line argument to start editing a binary file
	|'binary'|	Option set by |-b|.  Prevents adding an <EOL> for the
			last line in the file.

Multi-language support.					|multi-lang|
	Files in double-byte or multi-byte encodings can be edited.  There is
	UTF-8 support to be able to edit various languages at the same time,
	without switching fonts. |UTF-8|
	Messages and menus are available in different languages.

Move cursor beyond lines.
	When the 'virtualedit' option is set the cursor can move all over the
	screen, also where there is no text.  This is useful to edit tables
	and figures easily.

==============================================================================
5. Other vim features					*other-features*

A random collection of nice extra features.


When Vim is started with "-s scriptfile", the characters read from
"scriptfile" are treated as if you typed them.  If end of file is reached
before the editor exits, further characters are read from the console.

The "-w" option can be used to record all typed characters in a script file.
This file can then be used to redo the editing, possibly on another file or
after changing some commands in the script file.

The "-o" option opens a window for each argument.  "-o4" opens four windows.

Vi requires several termcap entries to be able to work full-screen.  Vim only
requires the "cm" entry (cursor motion).


In command mode:

When the 'showcmd' option is set, the command characters are shown in the last
line of the screen.  They are removed when the command is finished.

If the 'ruler' option is set, the current cursor position is shown in the
last line of the screen.

"U" still works after having moved off the last changed line and after "u".

Characters with the 8th bit set are displayed.  The characters between '~' and
0xa0 are displayed as "~?", "~@", "~A", etc., unless they are included in the
'isprint' option.

"][" goes to the next ending of a C function ('}' in column 1).
"[]" goes to the previous ending of a C function ('}' in column 1).

"]f", "[f" and "gf" start editing the file whose name is under the cursor.
CTRL-W f splits the window and starts editing the file whose name is under
the cursor.

"*" searches forward for the identifier under the cursor, "#" backward.
"K" runs the program defined by the 'keywordprg' option, with the identifier
under the cursor as argument.

"%" can be preceded with a count.  The cursor jumps to the line that
percentage down in the file.  The normal "%" function to jump to the matching
brace skips braces inside quotes.

With the CTRL-] command, the cursor may be in the middle of the identifier.

The used tags are remembered.  Commands that can be used with the tag stack
are CTRL-T, ":pop" and ":tag".  ":tags" lists the tag stack.

The 'tags' option can be set to a list of tag file names.  Thus multiple
tag files can be used.  For file names that start with "./", the "./" is
replaced with the path of the current file.  This makes it possible to use a
tags file in the same directory as the file being edited.

Previously used file names are remembered in the alternate file name list.
CTRL-^ accepts a count, which is an index in this list.
":files" command shows the list of alternate file names.
"#<N>" is replaced with the <N>th alternate file name in the list.
"#<" is replaced with the current file name without extension.

Search patterns have more features.  The <NL> character is seen as part of the
search pattern and the substitute string of ":s".  Vi sees it as the end of
the command.

Searches can put the cursor on the end of a match and may include a character
offset.

Count added to "~", ":next", ":Next", "n" and "N".

The command ":next!" with 'autowrite' set does not write the file.  In vi the
file was written, but this is considered to be a bug, because one does not
expect it and the file is not written with ":rewind!".

In Vi when entering a <CR> in replace mode deletes a character only when 'ai'
is set (but does not show it until you hit <Esc>).  Vim always deletes a
character (and shows it immediately).

Added :wnext command.  Same as ":write" followed by ":next".

The ":w!" command always writes, also when the file is write protected.  In Vi
you would have to do ":!chmod +w %:S" and ":set noro".

When 'tildeop' has been set, "~" is an operator (must be followed by a
movement command).

With the "J" (join) command you can reset the 'joinspaces' option to have only
one space after a period (Vi inserts two spaces).

"cw" can be used to change white space formed by several characters (Vi is
confusing: "cw" only changes one space, while "dw" deletes all white space).

"o" and "O" accept a count for repeating the insert (Vi clears a part of
display).

Flags after Ex commands not supported (no plans to include it).

On non-UNIX systems ":cd" command shows current directory instead of going to
the home directory (there isn't one).  ":pwd" prints the current directory on
all systems.

After a ":cd" command the file names (in the argument list, opened files)
still point to the same files.  In Vi ":cd" is not allowed in a changed file;
otherwise the meaning of file names change.

":source!" command reads Vi commands from a file.

":mkexrc" command writes current modified options and mappings to a ".exrc"
file.  ":mkvimrc" writes to a ".vimrc" file.

No check for "tail recursion" with mappings.  This allows things like
":map! foo ^]foo".

When a mapping starts with number, vi loses the count typed before it (e.g.
when using the mapping ":map g 4G" the command "7g" goes to line 4).  This is
considered a vi bug.  Vim concatenates the counts (in the example it becomes
"74G"), as most people would expect.

The :put! command inserts the contents of a register above the current line.

The "p" and "P" commands of vi cannot be repeated with "." when the putted
text is less than a line.  In Vim they can always be repeated.

":noremap" command can be used to enter a mapping that will not be remapped.
This is useful to exchange the meaning of two keys.  ":cmap", ":cunmap" and
":cnoremap" can be used for mapping in command-line editing only.  ":imap",
":iunmap" and ":inoremap" can be used for mapping in insert mode only.
Similar commands exist for abbreviations: ":noreabbrev", ":iabbrev"
":cabbrev", ":iunabbrev", ":cunabbrev", ":inoreabbrev", ":cnoreabbrev".

In Vi the command ":map foo bar" would remove a previous mapping
":map bug foo".  This is considered a bug, so it is not included in Vim.
":unmap! foo" does remove ":map! bug foo", because unmapping would be very
difficult otherwise (this is vi compatible).

The ':' register contains the last command-line.
The '%' register contains the current file name.
The '.' register contains the last inserted text.

":dis" command shows the contents of the yank registers.

CTRL-O/CTRL-I can be used to jump to older/newer positions.  These are the
same positions as used with the '' command, but may be in another file.  The
":jumps" command lists the older positions.

If the 'shiftround' option is set, an indent is rounded to a multiple of
'shiftwidth' with ">" and "<" commands.

The 'scrolljump' option can be set to the minimum number of lines to scroll
when the cursor gets off the screen.  Use this when scrolling is slow.

The 'scrolloff' option can be set to the minimum number of lines to keep
above and below the cursor.  This gives some context to where you are
editing.  When set to a large number the cursor line is always in the middle
of the window.

Uppercase marks can be used to jump between files.  The ":marks" command lists
all currently set marks.  The commands "']" and "`]" jump to the end of the
previous operator or end of the text inserted with the put command.  "'[" and
"`[" do jump to the start.

The 'shelltype' option can be set to reflect the type of shell used on the
Amiga.

The 'highlight' option can be set for the highlight mode to be used for
several commands.

The CTRL-A (add) and CTRL-X (subtract) commands are new.  The count to the
command (default 1) is added to/subtracted from the number at or after the
cursor.  That number may be decimal, octal (starts with a '0') or hexadecimal
(starts with '0x').  Very useful in macros.

With the :set command the prefix "inv" can be used to invert boolean options.

In both Vi and Vim you can create a line break with the ":substitute" command
by using a CTRL-M.  For Vi this means you cannot insert a real CTRL-M in the
text.  With Vim you can put a real CTRL-M in the text by preceding it with a
CTRL-V.


In Insert mode:

If the 'revins' option is set, insert happens backwards.  This is for typing
Hebrew.  When inserting normal characters the cursor will not be shifted and
the text moves rightwards.  Backspace, CTRL-W and CTRL-U will also work in
the opposite direction.  CTRL-B toggles the 'revins' option.  In replace mode
'revins' has no effect.  Only when enabled at compile time.

The backspace key can be used just like CTRL-D to remove auto-indents.

You can backspace, CTRL-U and CTRL-W over line breaks if the 'backspace' (bs)
option includes "eol".  You can backspace over the start of insert if the
'backspace' option includes "start".

When the 'paste' option is set, a few options are reset and mapping in insert
mode and abbreviation are disabled.  This allows for pasting text in windowing
systems without unexpected results.  When the 'paste' option is reset, the old
option values are restored.

CTRL-T/CTRL-D always insert/delete an indent in the current line, no matter
what column the cursor is in.

CTRL-@ (insert previously inserted text) works always (Vi: only when typed as
first character).

CTRL-A works like CTRL-@ but does not leave insert mode.

CTRL-R {0-9a-z..} can be used to insert the contents of a register.

When the 'smartindent' option is set, C programs will be better auto-indented.
With 'cindent' even more.

CTRL-Y and CTRL-E can be used to copy a character from above/below the
current cursor position.

After CTRL-V you can enter a three digit decimal number.  This byte value is
inserted in the text as a single character.  Useful for international
characters that are not on your keyboard.

When the 'expandtab' (et) option is set, a <Tab> is expanded to the
appropriate number of spaces.

The window always reflects the contents of the buffer (Vi does not do this
when changing text and in some other cases).

If Vim is compiled with DIGRAPHS defined, digraphs are supported.  A set of
normal digraphs is included.  They are shown with the ":digraph" command.
More can be added with ":digraph {char1}{char2} {number}".  A digraph is
entered with "CTRL-K {char1} {char2}" or "{char1} BS {char2}" (only when
'digraph' option is set).

When repeating an insert, e.g. "10atest <Esc>" vi would only handle wrapmargin
for the first insert.  Vim does it for all.

A count to the "i" or "a" command is used for all the text.  Vi uses the count
only for one line.  "3iabc<NL>def<Esc>" would insert "abcabcabc<NL>def" in Vi
but "abc<NL>defabc<NL>defabc<NL>def" in Vim.


In Command-line mode:

<Esc> terminates the command-line without executing it.  In vi the command
line would be executed, which is not what most people expect (hitting <Esc>
should always get you back to command mode).  To avoid problems with some
obscure macros, an <Esc> in a macro will execute the command.  If you want a
typed <Esc> to execute the command like vi does you can fix this with
	":cmap ^V<Esc> ^V<CR>"

General:

The 'ttimeout' option is like 'timeout', but only works for cursor and
function keys, not for ordinary mapped characters.  The 'timeoutlen' option
gives the number of milliseconds that is waited for.  If the 'esckeys' option
is not set, cursor and function keys that start with <Esc> are not recognized
in insert mode.

There is an option for each terminal string.  Can be used when termcap is not
supported or to change individual strings.

The 'fileformat' option can be set to select the <EOL>: "dos" <CR><NL>, "unix"
<NL> or "mac" <CR>.
When the 'fileformats' option is not empty, Vim tries to detect the type of
<EOL> automatically.  The 'fileformat' option is set accordingly.

On systems that have no job control (older Unix systems and non-Unix systems)
the CTRL-Z, ":stop" or ":suspend" command starts a new shell.

If Vim is started on the Amiga without an interactive window for output, a
window is opened (and :sh still works).  You can give a device to use for
editing with the |-d| argument, e.g. "-d con:20/20/600/150".

The 'columns' and 'lines' options are used to set or get the width and height
of the display.

Option settings are read from the first and last few lines of the file.
Option 'modelines' determines how many lines are tried (default is 5).  Note
that this is different from the Vi versions that can execute any Ex command
in a modeline (a major security problem).  |trojan-horse|

If the 'insertmode' option is set (e.g. in .exrc), Vim starts in insert mode.
And it comes back there, when pressing <Esc>.

Undo information is kept in memory.  Available memory limits the number and
size of change that can be undone.  This may be a problem with MS-DOS, is
hardly a problem on the Amiga and almost never with Unix and Win32.

If the 'backup' or 'writebackup' option is set: Before a file is overwritten,
a backup file (.bak) is made.  If the "backup" option is set it is left
behind.

Vim creates a file ending in ".swp" to store parts of the file that have been
changed or that do not fit in memory.  This file can be used to recover from
an aborted editing session with "vim -r file".  Using the swap file can be
switched off by setting the 'updatecount' option to 0 or starting Vim with
the "-n" option.  Use the 'directory' option for placing the .swp file
somewhere else.

Vim is able to work correctly on filesystems with 8.3 file names, also when
using messydos or crossdos filesystems on the Amiga, or any 8.3 mounted
filesystem under Unix.  See |'shortname'|.

Error messages are shown at least one second (Vi overwrites error messages).

If Vim gives the |hit-enter| prompt, you can hit any key.  Characters other
than <CR>, <NL> and <Space> are interpreted as the (start of) a command.  (Vi
only accepts a command starting with ':').

The contents of the numbered and unnamed registers is remembered when
changing files.

The "No lines in buffer" message is a normal message instead of an error
message, since that may cause a mapping to be aborted.

The AUX: device of the Amiga is supported.

==============================================================================
6. Command-line arguments				*cmdline-arguments*

Different versions of Vi have different command-line arguments.  This can be
confusing.  To help you, this section gives an overview of the differences.

Five variants of Vi will be considered here:
	Elvis	Elvis version 2.1b
	Nvi	Nvi version 1.79
	Posix	Posix 1003.2
	Vi	Vi version 3.7 (for Sun 4.1.x)
	Vile	Vile version 7.4 (incomplete)
	Vim	Vim version 5.2

Only Vim is able to accept options in between and after the file names.

+{command}	Elvis, Nvi, Posix, Vi, Vim: Same as "-c {command}".

-		Nvi, Posix, Vi: Run Ex in batch mode.
		Vim: Read file from stdin (use -s for batch mode).

--		Vim: End of options, only file names are following.

--cmd {command}	Vim: execute {command} before sourcing vimrc files.

--echo-wid	Vim: GTK+ echoes the Window ID on stdout

--help		Vim: show help message and exit.

--literal	Vim: take file names literally, don't expand wildcards.

--nofork	Vim: same as |-f|

--noplugin[s]	Vim: Skip loading plugins.

--remote	Vim: edit the files in another Vim server

--remote-expr {expr}	Vim: evaluate {expr} in another Vim server

--remote-send {keys}	Vim: send {keys} to a Vim server and exit

--remote-silent {file}	Vim: edit the files in another Vim server if possible

--remote-wait	Vim: edit the files in another Vim server and wait for it

--remote-wait-silent	Vim: like --remote-wait, no complaints if not possible

--role {role}	Vim: GTK+ 2: set role of main window

--serverlist	Vim: Output a list of Vim servers and exit

--servername {name}	Vim: Specify Vim server name

--socketid {id}		Vim: GTK window socket to run Vim in

--windowid {id}		Vim: Win32 window ID to run Vim in

--version	Vim: show version message and exit.

-?		Vile: print usage summary and exit.

-a		Elvis: Load all specified file names into a window (use -o for
		Vim).

-A		Vim: Start in Arabic mode (when compiled with Arabic).

-b {blksize}	Elvis: Use {blksize} blocksize for the session file.
-b		Vim: set 'binary' mode.

-C		Vim: Compatible mode.

-c {command}	Elvis, Nvi, Posix, Vim: run {command} as an Ex command after
		loading the edit buffer.
		Vim: allow up to 10 "-c" arguments

-d {device}	Vim: Use {device} for I/O (Amiga only). {only when compiled
		without the |+diff| feature}
-d		Vim: start with 'diff' set. |vimdiff|

-dev {device}	Vim: Use {device} for I/O (Amiga only).

-D		Vim: debug mode.

-e		Elvis, Nvi, Vim: Start in Ex mode, as if the executable is
		called "ex".

-E		Vim: Start in improved Ex mode |gQ|, like "exim".

-f		Vim: Run GUI in foreground (Amiga: don't open new window).
-f {session}	Elvis: Use {session} as the session file.

-F		Vim: Start in Farsi mode (when compiled with Farsi).
		Nvi: Fast start, don't read the entire file when editing
		starts.

-G {gui}	Elvis: Use the {gui} as user interface.

-g		Vim: Start GUI.
-g N		Vile: start editing at line N

-h		Vim: Give help message.
		Vile: edit the help file

-H		Vim: start Hebrew mode (when compiled with it).

-i		Elvis: Start each window in Insert mode.
-i {viminfo}	Vim: Use {viminfo} for viminfo file.

-L		Vim: Same as "-r" (also in some versions of Vi).

-l		Nvi, Vi, Vim: Set 'lisp' and 'showmatch' options.

-m		Vim: Modifications not allowed to be written, resets 'write'
		option.

-M		Vim: Modifications not allowed, resets 'modifiable' and the
		'write' option.

-N		Vim: No-compatible mode.

-n		Vim: No swap file used.

-nb[args]	Vim: open a NetBeans interface connection

-O[N]		Vim: Like -o, but use vertically split windows.

-o[N]		Vim: Open [N] windows, or one for each file.

-p[N]		Vim: Open [N] tab pages, or one for each file.

-P {parent-title} Win32 Vim: open Vim inside a parent application window

-q {name}	Vim: Use {name} for quickfix error file.
-q{name}	Vim: Idem.

-R		Elvis, Nvi, Posix, Vile, Vim: Set the 'readonly' option.

-r		Elvis, Nvi, Posix, Vi, Vim: Recovery mode.

-S		Nvi: Set 'secure' option.
-S {script}	Vim: source script after starting up.

-s		Nvi, Posix, Vim: Same as "-" (silent mode), when in Ex mode.
		Elvis: Sets the 'safer' option.
-s {scriptin}	Vim: Read from script file {scriptin}; only when not in Ex
		mode.
-s {pattern}	Vile: search for {pattern}

-t {tag}	Elvis, Nvi, Posix, Vi, Vim: Edit the file containing {tag}.
-t{tag}		Vim: Idem.

-T {term}	Vim: Set terminal name to {term}.

-u {vimrc}	Vim: Read initializations from {vimrc} file.

-U {gvimrc}	Vim: Read GUI initializations from {gvimrc} file.

-v		Nvi, Posix, Vi, Vim: Begin in Normal mode (visual mode, in Vi
		terms).
		Vile: View mode, no changes possible.

-V		Elvis, Vim: Verbose mode.
-V{nr}		Vim: Verbose mode with specified level.

-w {size}	Elvis, Posix, Nvi, Vi, Vim: Set value of 'window' to {size}.
-w{size}	Nvi, Vi: Same as "-w {size}".
-w {name}	Vim: Write to script file {name} (must start with non-digit).

-W {name}	Vim: Append to script file {name}.

-x		Vi, Vim: Ask for encryption key.  See |encryption|.

-X		Vim: Don't connect to the X server.

-y		Vim: Start in easy mode, like |evim|.

-Z		Vim: restricted mode

@{cmdfile}	Vile: use {cmdfile} as startup file.

==============================================================================
7. POSIX compliance				*posix* *posix-compliance*

In 2005 the POSIX test suite was run to check the compatibility of Vim.  Most
of the test was executed properly.  There are the few things where Vim
is not POSIX compliant, even when run in Vi compatibility mode.

Set the $VIM_POSIX environment variable to have 'cpoptions' include the POSIX
flags when Vim starts up.  This makes Vim run as POSIX as it can.  That's
a bit different from being Vi compatible.

This is where Vim does not behave as POSIX specifies and why:

							*posix-screen-size*
	The $COLUMNS and $LINES environment variables are ignored by Vim if
	the size can be obtained from the terminal in a more reliable way.
	Add the '|' flag to 'cpoptions' to have $COLUMNS and $LINES overrule
	sizes obtained in another way.

	The "{" and "}" commands don't stop at a "{" in the original Vi, but
	POSIX specifies it does.  Add the '{' flag to 'cpoptions' if you want
	it the POSIX way.

	The "D", "o" and "O" commands accept a count.  Also when repeated.
	Add the '#' flag to 'cpoptions' if you want to ignore the count.

	The ":cd" command fails if the current buffer is modified when the '.'
	flag is present in 'cpoptions'.

	There is no ATTENTION message, the "A" flag is added to 'shortmess'.

These are remarks about running the POSIX test suite:
- vi test 33 sometimes fails for unknown reasons
- vi test 250 fails; behavior will be changed in a new revision
    http://www.opengroup.org/austin/mailarchives/ag-review/msg01710.html
    (link no longer works, perhaps it's now:
    https://www.opengroup.org/sophocles/show_mail.tpl?CALLER=show_archive.tpl&source=L&listname=austin-review-l&id=1711)
- vi test 310 fails; exit code non-zero when any error occurred?
- ex test 24 fails because test is wrong.  Changed between SUSv2 and SUSv3.
- ex tests 47, 48, 49, 72, 73 fail because .exrc file isn't read in silent
  mode and $EXINIT isn't used.
- ex tests 76, 78 fail because echo is used instead of printf. (fixed)
    Also: problem with \s not changed to space.
- ex test 355 fails because 'window' isn't used for "30z".
- ex test 368 fails because shell command isn't echoed in silent mode.
- ex test 394 fails because "=" command output isn't visible in silent mode.
- ex test 411 fails because test file is wrong, contains stray ':'.
- ex test 475 and 476 fail because reprint output isn't visible in silent mode.
- ex test 480 and 481 fail because the tags file has spaces instead of a tab.
- ex test 502 fails because .exrc isn't read in silent mode.
- ex test 509 fails because .exrc isn't read in silent mode. and exit code is
  1 instead of 2.
- ex test 534 fails because .exrc isn't read in silent mode.


 vim:tw=78:ts=8:ft=help:norl:
                                                                                                                                                                                                                                                                                                                                       usr/share/vim/vim74/doc/vim2html.pl                                                                 0100755 0000000 0000000 00000010645 13050207306 015572  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/env perl

# converts vim documentation to simple html
# Sirtaj Singh Kang (taj@kde.org)

# Sun Feb 24 14:49:17 CET 2002

use strict;
use vars qw/%url $date/;

%url = ();
$date = `date`;
chop $date;

sub maplink
{
	my $tag = shift;
	if( exists $url{ $tag } ){
		return $url{ $tag };
	} else {
		#warn "Unknown hyperlink target: $tag\n";
		$tag =~ s/\.txt//;
		$tag =~ s/</&lt;/g;
		$tag =~ s/>/&gt;/g;
		return "<code class=\"badlink\">$tag</code>";
	}
}

sub readTagFile
{
	my($tagfile) = @_;
	my( $tag, $file, $name );

	open(TAGS,"$tagfile") || die "can't read tags\n";

	while( <TAGS> ) {
		next unless /^(\S+)\s+(\S+)\s+/;

		$tag = $1;
		my $label = $tag;
		($file= $2) =~ s/.txt$/.html/g;
		$label =~ s/\.txt//;

		$url{ $tag } = "<a href=\"$file#".escurl($tag)."\">".esctext($label)."</a>";
	}
	close( TAGS );
}

sub esctext
{
	my $text = shift;
	$text =~ s/&/&amp;/g;
	$text =~ s/</&lt;/g;
	$text =~ s/>/&gt;/g;
	return $text;
}

sub escurl
{
	my $url = shift;
	$url =~ s/"/%22/g;
	$url =~ s/~/%7E/g;
	$url =~ s/</%3C/g;
	$url =~ s/>/%3E/g;
	$url =~ s/=/%20/g;
	$url =~ s/#/%23/g;
	$url =~ s/\//%2F/g;

	return $url;
}

sub vim2html
{
	my( $infile ) = @_;
	my( $outfile );

	open(IN, "$infile" ) || die "Couldn't read from $infile: $!.\n";

	($outfile = $infile) =~ s:.*/::g;
	$outfile =~ s/\.txt$//g;

	open( OUT, ">$outfile.html" )
			|| die "Couldn't write to $outfile.html: $!.\n";
	my $head = uc( $outfile );

	print OUT<<EOF;
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>VIM: $outfile</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>$head</h2>
<pre>
EOF

	my $inexample = 0;
	while( <IN> ) {
		chop;
		if ( /^\s*[-=]+\s*$/ ) {
			print OUT "</pre><hr><pre>";
			next;
		}

		# examples
		elsif( /^>$/ || /\s>$/ ) {
			$inexample = 1;
			chop;
		}
		elsif ( $inexample && /^([<\S])/ ) {
			$inexample = 0;
			$_ = $' if $1 eq "<";
		}

		s/\s+$//g;

		# Various vim highlights. note that < and > have already been escaped
		# so that HTML doesn't get screwed up.

		my @out = ();
		#		print "Text: $_\n";
		LOOP:
		foreach my $token ( split /((?:\|[^\|]+\|)|(?:\*[^\*]+\*))/ ) {
			if ( $token =~ /^\|([^\|]+)\|/ ) {
				# link
				push( @out, "|".maplink( $1 )."|" );
				next LOOP;
			}
			elsif ( $token =~ /^\*([^\*]+)\*/ ) {
				# target
				push( @out,
					"<b class=\"vimtag\">\*<a name=\"".escurl($1)."\">".esctext($1)."<\/a>\*<\/b>");
				next LOOP;
			}

			$_ = esctext($token);
			s/CTRL-(\w+)/<code class="keystroke">CTRL-$1<\/code>/g;
			# parameter <...>
			s/&lt;(.*?)&gt;/<code class="special">&lt;$1&gt;<\/code>/g;

			# parameter {...}
			s/\{([^}]*)\}/<code class="special">{$1}<\/code>/g;

			# parameter [...]
			s/\[(range|line|count|offset|cmd|[-+]?num)\]/<code class="special">\[$1\]<\/code>/g;
			# note
			s/(Note:?)/<code class="note">$1<\/code>/gi;

			# local heading
			s/^(.*)\~$/<code class="section">$1<\/code>/g;
			push( @out, $_ );
		}

		$_ = join( "", @out );

		if( $inexample == 2 ) {
			print OUT "<code class=\"example\">$_</code>\n";
		} else {
			print OUT $_,"\n";
		}

		$inexample = 2 if $inexample == 1;
	}
	print OUT<<EOF;
</pre>
<p><i>Generated by vim2html on $date</i></p>
</body>
</html>
EOF

}

sub usage
{
die<<EOF;
vim2html.pl: converts vim documentation to HTML.
usage:

	vim2html.pl <tag file> <text files>
EOF
}


sub writeCSS
{
	open( CSS, ">vim-stylesheet.css"  ) || die "Couldn't write stylesheet: $!\n";
	print CSS<<EOF;
body { background-color: white; color: black;}
:link { color: rgb(0,137,139); }
:visited { color: rgb(0,100,100);
           background-color: white; /* should be inherit */ }
:active { color: rgb(0,200,200);
          background-color: white; /* should be inherit */ }

B.vimtag { color : rgb(250,0,250); }

h1, h2 { color: rgb(82,80,82); text-align: center; }
h3, h4, h5, h6 { color: rgb(82,80,82); }
.headline { color: rgb(0,137,139); }
.header { color: rgb(164, 32, 246); }
.section { color: rgb(164, 32, 246); }
.keystroke { color: rgb(106, 89, 205); }
.vim { }
.example { color: rgb(0, 0, 255); }
.option { }
.notvi { }
.special { color: rgb(106, 89, 205); }
.note { color: blue; background-color: yellow; }
.sub {}
.badlink { color: rgb(0,37,39); }
EOF

}

# main
usage() if $#ARGV < 1;

print "Processing tags...\n";
readTagFile( $ARGV[ 0 ] );

foreach my $file ( 1..$#ARGV ) {
	print "Processing ".$ARGV[ $file ]."...\n";
	vim2html( $ARGV[ $file ] );
}
print "Writing stylesheet...\n";
writeCSS();
print "done.\n"
                                                                                           usr/share/vim/vim74/doc/visual.txt                                                                  0100644 0000000 0000000 00000052337 13050207306 015540  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *visual.txt*    For Vim version 7.4.  Last change: 2014 Mar 23


		  VIM REFERENCE MANUAL    by Bram Moolenaar


Visual mode				*Visual* *Visual-mode* *visual-mode*

Visual mode is a flexible and easy way to select a piece of text for an
operator.  It is the only way to select a block of text.

This is introduced in section |04.4| of the user manual.

1. Using Visual mode			|visual-use|
2. Starting and stopping Visual mode	|visual-start|
3. Changing the Visual area		|visual-change|
4. Operating on the Visual area		|visual-operators|
5. Blockwise operators			|blockwise-operators|
6. Repeating				|visual-repeat|
7. Examples				|visual-examples|
8. Select mode				|Select-mode|

{Vi has no Visual mode, the name "visual" is used for Normal mode, to
distinguish it from Ex mode}
{Since Vim 7.4.200 the |+visual| feature is always included}

==============================================================================
1. Using Visual mode					*visual-use*

Using Visual mode consists of three parts:
1. Mark the start of the text with "v", "V" or CTRL-V.
   The character under the cursor will be used as the start.
2. Move to the end of the text.
   The text from the start of the Visual mode up to and including the
   character under the cursor is highlighted.
3. Type an operator command.
   The highlighted characters will be operated upon.

The 'highlight' option can be used to set the display mode to use for
highlighting in Visual mode.
The 'virtualedit' option can be used to allow positioning the cursor to
positions where there is no actual character.

The highlighted text normally includes the character under the cursor.
However, when the 'selection' option is set to "exclusive" and the cursor is
after the Visual area, the character under the cursor is not included.

With "v" the text before the start position and after the end position will
not be highlighted.  However, all uppercase and non-alpha operators, except
"~" and "U", will work on whole lines anyway.  See the list of operators
below.

							*visual-block*
With CTRL-V (blockwise Visual mode) the highlighted text will be a rectangle
between start position and the cursor.  However, some operators work on whole
lines anyway (see the list below).  The change and substitute operators will
delete the highlighted text and then start insertion at the top left
position.

==============================================================================
2. Starting and stopping Visual mode			*visual-start*

						*v* *characterwise-visual*
[count]v		Start Visual mode per character.
			With [count] select the same number of characters or
			lines as used for the last Visual operation, but at
			the current cursor position, multiplied by [count].
			When the previous Visual operation was on a block both
			the width and height of the block are multiplied by
			[count].
			When there was no previous Visual operation [count]
			characters are selected.  This is like moving the
			cursor right N * [count] characters.  One less when
			'selection' is not "exclusive".

						*V* *linewise-visual*
[count]V		Start Visual mode linewise.
			With [count] select the same number of lines as used
			for the last Visual operation, but at the current
			cursor position, multiplied by [count].  When there
			was no previous Visual operation [count] lines are
			selected.

						*CTRL-V* *blockwise-visual*
[count]CTRL-V		Start Visual mode blockwise.  Note: Under Windows
			CTRL-V could be mapped to paste text, it doesn't work
			to start Visual mode then, see |CTRL-V-alternative|.
			[count] is used as with `v` above.

If you use <Esc>, click the left mouse button or use any command that
does a jump to another buffer while in Visual mode, the highlighting stops
and no text is affected.  Also when you hit "v" in characterwise Visual mode,
"CTRL-V" in blockwise Visual mode or "V" in linewise Visual mode.  If you hit
CTRL-Z the highlighting stops and the editor is suspended or a new shell is
started |CTRL-Z|.

	      new mode after typing:		*v_v* *v_CTRL-V* *v_V*
old mode	     "v"	      "CTRL-V"		     "V"	~

Normal		    Visual	   blockwise Visual	  linewise Visual
Visual		    Normal	   blockwise Visual	  linewise Visual
blockwise Visual    Visual	   Normal		  linewise Visual
linewise Visual     Visual	   blockwise Visual	  Normal

						*gv* *v_gv* *reselect-Visual*
gv			Start Visual mode with the same area as the previous
			area and the same mode.
			In Visual mode the current and the previous Visual
			area are exchanged.
			After using "p" or "P" in Visual mode the text that
			was put will be selected.

								*gn* *v_gn*
gn			Search forward for the last used search pattern, like
			with `n`, and start Visual mode to select the match.
			If the cursor is on the match, visually selects it.
			If an operator is pending, operates on the match.
			E.g., "dgn" deletes the text of the next match.
			If Visual mode is active, extends the selection
			until the end of the next match.

								*gN* *v_gN*
gN			Like |gn| but searches backward, like with `N`.

							*<LeftMouse>*
<LeftMouse>		Set the current cursor position.  If Visual mode is
			active it is stopped.  Only when 'mouse' option is
			contains 'n' or 'a'.  If the position is within 'so'
			lines from the last line on the screen the text is
			scrolled up.  If the position is within 'so' lines from
			the first line on the screen the text is scrolled
			down.

							*<RightMouse>*
<RightMouse>		Start Visual mode if it is not active.  The text from
			the cursor position to the position of the click is
			highlighted.  If Visual mode was already active move
			the start or end of the highlighted text, which ever
			is closest, to the position of the click.  Only when
			'mouse' option contains 'n' or 'a'.

			Note: when 'mousemodel' is set to "popup",
			<S-LeftMouse> has to be used instead of <RightMouse>.

							*<LeftRelease>*
<LeftRelease>		This works like a <LeftMouse>, if it is not at
			the same position as <LeftMouse>.  In an older version
			of xterm you won't see the selected area until the
			button is released, unless there is access to the
			display where the xterm is running (via the DISPLAY
			environment variable or the -display argument).  Only
			when 'mouse' option contains 'n' or 'a'.

If Visual mode is not active and the "v", "V" or CTRL-V is preceded with a
count, the size of the previously highlighted area is used for a start.  You
can then move the end of the highlighted area and give an operator.  The type
of the old area is used (character, line or blockwise).
- Linewise Visual mode: The number of lines is multiplied with the count.
- Blockwise Visual mode: The number of lines and columns is multiplied with
  the count.
- Normal Visual mode within one line: The number of characters is multiplied
  with the count.
- Normal Visual mode with several lines: The number of lines is multiplied
  with the count, in the last line the same number of characters is used as
  in the last line in the previously highlighted area.
The start of the text is the Cursor position.  If the "$" command was used as
one of the last commands to extend the highlighted text, the area will be
extended to the rightmost column of the longest line.

If you want to highlight exactly the same area as the last time, you can use
"gv" |gv| |v_gv|.

							*v_<Esc>*
<Esc>			In Visual mode: Stop Visual mode.

							*v_CTRL-C*
CTRL-C			In Visual mode: Stop Visual mode.  When insert mode is
			pending (the mode message shows
			"-- (insert) VISUAL --"), it is also stopped.

==============================================================================
3. Changing the Visual area				*visual-change*

							*v_o*
o			Go to Other end of highlighted text: The current
			cursor position becomes the start of the highlighted
			text and the cursor is moved to the other end of the
			highlighted text.  The highlighted area remains the
			same.

							*v_O*
O			Go to Other end of highlighted text.  This is like
			"o", but in Visual block mode the cursor moves to the
			other corner in the same line.  When the corner is at
			a character that occupies more than one position on
			the screen (e.g., a <Tab>), the highlighted text may
			change.

							*v_$*
When the "$" command is used with blockwise Visual mode, the right end of the
highlighted text will be determined by the longest highlighted line.  This
stops when a motion command is used that does not move straight up or down.

For moving the end of the block many commands can be used, but you cannot
use Ex commands, commands that make changes or abandon the file.  Commands
(starting with) ".", "&", CTRL-^, "Z", CTRL-], CTRL-T, CTRL-R, CTRL-I
and CTRL-O cause a beep and Visual mode continues.

When switching to another window on the same buffer, the cursor position in
that window is adjusted, so that the same Visual area is still selected.  This
is especially useful to view the start of the Visual area in one window, and
the end in another.  You can then use <RightMouse> (or <S-LeftMouse> when
'mousemodel' is "popup") to drag either end of the Visual area.

==============================================================================
4. Operating on the Visual area				*visual-operators*

The operators that can be used are:
	~	switch case					|v_~|
	d	delete						|v_d|
	c	change (4)					|v_c|
	y	yank						|v_y|
	>	shift right (4)					|v_>|
	<	shift left (4)					|v_<|
	!	filter through external command (1)		|v_!|
	=	filter through 'equalprg' option command (1)	|v_=|
	gq	format lines to 'textwidth' length (1)		|v_gq|

The objects that can be used are:
	aw	a word (with white space)			|v_aw|
	iw	inner word					|v_iw|
	aW	a WORD (with white space)			|v_aW|
	iW	inner WORD					|v_iW|
	as	a sentence (with white space)			|v_as|
	is	inner sentence					|v_is|
	ap	a paragraph (with white space)			|v_ap|
	ip	inner paragraph					|v_ip|
	ab	a () block (with parenthesis)			|v_ab|
	ib	inner () block					|v_ib|
	aB	a {} block (with braces)			|v_aB|
	iB	inner {} block					|v_iB|
	at	a <tag> </tag> block (with tags)		|v_at|
	it	inner <tag> </tag> block			|v_it|
	a<	a <> block (with <>)				|v_a<|
	i<	inner <> block					|v_i<|
	a[	a [] block (with [])				|v_a[|
	i[	inner [] block					|v_i[|
	a"	a double quoted string (with quotes)		|v_aquote|
	i"	inner double quoted string			|v_iquote|
	a'	a single quoted string (with quotes)		|v_a'|
	i'	inner simple quoted string			|v_i'|
	a`	a string in backticks (with backticks)		|v_a`|
	i`	inner string in backticks			|v_i`|

Additionally the following commands can be used:
	:	start Ex command for highlighted lines (1)	|v_:|
	r	change (4)					|v_r|
	s	change						|v_s|
	C	change (2)(4)					|v_C|
	S	change (2)					|v_S|
	R	change (2)					|v_R|
	x	delete						|v_x|
	D	delete (3)					|v_D|
	X	delete (2)					|v_X|
	Y	yank (2)					|v_Y|
	p	put						|v_p|
	J	join (1)					|v_J|
	U	make uppercase					|v_U|
	u	make lowercase					|v_u|
	^]	find tag					|v_CTRL-]|
	I	block insert					|v_b_I|
	A	block append					|v_b_A|

(1): Always whole lines, see |:visual_example|.
(2): Whole lines when not using CTRL-V.
(3): Whole lines when not using CTRL-V, delete until the end of the line when
     using CTRL-V.
(4): When using CTRL-V operates on the block only.

Note that the ":vmap" command can be used to specifically map keys in Visual
mode.  For example, if you would like the "/" command not to extend the Visual
area, but instead take the highlighted text and search for that: >
	:vmap / y/<C-R>"<CR>
(In the <> notation |<>|, when typing it you should type it literally; you
need to remove the 'B' and '<' flags from 'cpoptions'.)

If you want to give a register name using the """ command, do this just before
typing the operator character: "v{move-around}"xd".

If you want to give a count to the command, do this just before typing the
operator character: "v{move-around}3>" (move lines 3 indents to the right).

							*{move-around}*
The {move-around} is any sequence of movement commands.  Note the difference
with {motion}, which is only ONE movement command.

Another way to operate on the Visual area is using the |/\%V| item in a
pattern.  For example, to replace all '(' in the Visual area with '#': >

	:'<,'>s/\%V(/#/g

Note that the "'<,'>" will appear automatically when you press ":" in Visual
mode.

==============================================================================
5. Blockwise operators					*blockwise-operators*

{not available when compiled without the |+visualextra| feature}

Reminder: Use 'virtualedit' to be able to select blocks that start or end
after the end of a line or halfway a tab.

Visual-block Insert						*v_b_I*
With a blockwise selection, I{string}<ESC> will insert {string} at the start
of block on every line of the block, provided that the line extends into the
block.  Thus lines that are short will remain unmodified.  TABs are split to
retain visual columns.
See |v_b_I_example|.

Visual-block Append						*v_b_A*
With a blockwise selection, A{string}<ESC> will append {string} to the end of
block on every line of the block.  There is some differing behavior where the
block RHS is not straight, due to different line lengths:

1. Block was created with <C-v>$
    In this case the string is appended to the end of each line.
2. Block was created with <C-v>{move-around}
    In this case the string is appended to the end of the block on each line,
    and whitespace is inserted to pad to the end-of-block column.
See |v_b_A_example|.
Note: "I" and "A" behave differently for lines that don't extend into the
selected block.  This was done intentionally, so that you can do it the way
you want.

Visual-block change						*v_b_c*
All selected text in the block will be replaced by the same text string.  When
using "c" the selected text is deleted and Insert mode started.  You can then
enter text (without a line break).  When you hit <Esc>, the same string is
inserted in all previously selected lines.

Visual-block Change						*v_b_C*
Like using "c", but the selection is extended until the end of the line for
all lines.

								*v_b_<*
Visual-block Shift						*v_b_>*
The block is shifted by 'shiftwidth'.  The RHS of the block is irrelevant.  The
LHS of the block determines the point from which to apply a right shift, and
padding includes TABs optimally according to 'ts' and 'et'.  The LHS of the
block determines the point upto which to shift left.
See |v_b_>_example|.
See |v_b_<_example|.

Visual-block Replace						*v_b_r*
Every screen char in the highlighted region is replaced with the same char, ie
TABs are split and the virtual whitespace is replaced, maintaining screen
layout.
See |v_b_r_example|.


==============================================================================
6. Repeating						*visual-repeat*

When repeating a Visual mode operator, the operator will be applied to the
same amount of text as the last time:
- Linewise Visual mode: The same number of lines.
- Blockwise Visual mode: The same number of lines and columns.
- Normal Visual mode within one line: The same number of characters.
- Normal Visual mode with several lines: The same number of lines, in the
  last line the same number of characters as in the last line the last time.
The start of the text is the Cursor position.  If the "$" command was used as
one of the last commands to extend the highlighted text, the repeating will
be applied up to the rightmost column of the longest line.


==============================================================================
7. Examples						*visual-examples*

							*:visual_example*
Currently the ":" command works on whole lines only.  When you select part of
a line, doing something like ":!date" will replace the whole line.  If you
want only part of the line to be replaced you will have to make a mapping for
it.  In a future release ":" may work on partial lines.

Here is an example, to replace the selected text with the output of "date": >
	:vmap _a <Esc>`>a<CR><Esc>`<i<CR><Esc>!!date<CR>kJJ

(In the <> notation |<>|, when typing it you should type it literally; you
need to remove the 'B' and '<' flags from 'cpoptions')

What this does is:
<Esc>		stop Visual mode
`>		go to the end of the Visual area
a<CR><Esc>	break the line after the Visual area
`<		jump to the start of the Visual area
i<CR><Esc>	break the line before the Visual area
!!date<CR>	filter the Visual text through date
kJJ		Join the lines back together

							*visual-search*
Here is an idea for a mapping that makes it possible to do a search for the
selected text: >
	:vmap X y/<C-R>"<CR>

(In the <> notation |<>|, when typing it you should type it literally; you
need to remove the 'B' and '<' flags from 'cpoptions')

Note that special characters (like '.' and '*') will cause problems.

Visual-block Examples					*blockwise-examples*
With the following text, I will indicate the commands to produce the block and
the results below.  In all cases, the cursor begins on the 'a' in the first
line of the test text.
The following modeline settings are assumed ":ts=8:sw=4:".

It will be helpful to
:set hls
/<TAB>
where <TAB> is a real TAB.  This helps visualise the operations.

The test text is:

abcdefghijklmnopqrstuvwxyz
abc		defghijklmnopqrstuvwxyz
abcdef  ghi		jklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz

1. fo<C-v>3jISTRING<ESC>					*v_b_I_example*

abcdefghijklmnSTRINGopqrstuvwxyz
abc	      STRING  defghijklmnopqrstuvwxyz
abcdef  ghi   STRING	jklmnopqrstuvwxyz
abcdefghijklmnSTRINGopqrstuvwxyz

2. fo<C-v>3j$ASTRING<ESC>					*v_b_A_example*

abcdefghijklmnopqrstuvwxyzSTRING
abc		defghijklmnopqrstuvwxyzSTRING
abcdef  ghi		jklmnopqrstuvwxyzSTRING
abcdefghijklmnopqrstuvwxyzSTRING

3. fo<C-v>3j3l<..						*v_b_<_example*

abcdefghijklmnopqrstuvwxyz
abc	      defghijklmnopqrstuvwxyz
abcdef  ghi   jklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz

4. fo<C-v>3j>..							*v_b_>_example*

abcdefghijklmn		  opqrstuvwxyz
abc			    defghijklmnopqrstuvwxyz
abcdef  ghi			    jklmnopqrstuvwxyz
abcdefghijklmn		  opqrstuvwxyz

5. fo<C-v>5l3jrX						*v_b_r_example*

abcdefghijklmnXXXXXXuvwxyz
abc	      XXXXXXhijklmnopqrstuvwxyz
abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz
abcdefghijklmnXXXXXXuvwxyz

==============================================================================
8. Select mode						*Select* *Select-mode*

Select mode looks like Visual mode, but the commands accepted are quite
different.  This resembles the selection mode in Microsoft Windows.
When the 'showmode' option is set, "-- SELECT --" is shown in the last line.

Entering Select mode:
- Using the mouse to select an area, and 'selectmode' contains "mouse".
  'mouse' must also contain a flag for the current mode.
- Using a non-printable movement command, with the Shift key pressed, and
  'selectmode' contains "key".  For example: <S-Left> and <S-End>.  'keymodel'
  must also contain "startsel".
- Using "v", "V" or CTRL-V command, and 'selectmode' contains "cmd".
- Using "gh", "gH" or "g_CTRL-H" command in Normal mode.
- From Visual mode, press CTRL-G.			*v_CTRL-G*

Commands in Select mode:
- Printable characters, <NL> and <CR> cause the selection to be deleted, and
  Vim enters Insert mode.  The typed character is inserted.
- Non-printable movement commands, with the Shift key pressed, extend the
  selection.  'keymodel' must include "startsel".
- Non-printable movement commands, with the Shift key NOT pressed, stop Select
  mode.  'keymodel' must include "stopsel".
- ESC stops Select mode.
- CTRL-O switches to Visual mode for the duration of one command. *v_CTRL-O*
- CTRL-G switches to Visual mode.

Otherwise, typed characters are handled as in Visual mode.

When using an operator in Select mode, and the selection is linewise, the
selected lines are operated upon, but like in characterwise selection.  For
example, when a whole line is deleted, it can later be pasted halfway a line.


Mappings and menus in Select mode.			*Select-mode-mapping*

When mappings and menus are defined with the |:vmap| or |:vmenu| command they
work both in Visual mode and in Select mode.  When these are used in Select
mode Vim automatically switches to Visual mode, so that the same behavior as
in Visual mode is effective.  If you don't want this use |:xmap| or |:smap|.

Users will expect printable characters to replace the selected area.
Therefore avoid mapping printable characters in Select mode.  Or use
|:sunmap|  after |:map| and |:vmap| to remove it for Select mode.

After the mapping or menu finishes, the selection is enabled again and Select
mode entered, unless the selected area was deleted, another buffer became
the current one or the window layout was changed.

When a character was typed that causes the selection to be deleted and Insert
mode started, Insert mode mappings are applied to this character.  This may
cause some confusion, because it means Insert mode mappings apply to a
character typed in Select mode.  Language mappings apply as well.

							*gV* *v_gV*
gV			Avoid the automatic reselection of the Visual area
			after a Select mode mapping or menu has finished.
			Put this just before the end of the mapping or menu.
			At least it should be after any operations on the
			selection.

							*gh*
gh			Start Select mode, characterwise.  This is like "v",
			but starts Select mode instead of Visual mode.
			Mnemonic: "get highlighted".

							*gH*
gH			Start Select mode, linewise.  This is like "V",
			but starts Select mode instead of Visual mode.
			Mnemonic: "get Highlighted".

							*g_CTRL-H*
g CTRL-H		Start Select mode, blockwise.  This is like CTRL-V,
			but starts Select mode instead of Visual mode.
			Mnemonic: "get Highlighted".

 vim:tw=78:ts=8:ft=help:norl:
                                                                                                                                                                                                                                                                                                 usr/share/vim/vim74/doc/windows.txt                                                                 0100644 0000000 0000000 00000141405 13050207306 015722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *windows.txt*   For Vim version 7.4.  Last change: 2014 Sep 23


		  VIM REFERENCE MANUAL    by Bram Moolenaar


Editing with multiple windows and buffers.		*windows* *buffers*

The commands which have been added to use multiple windows and buffers are
explained here.  Additionally, there are explanations for commands that work
differently when used in combination with more than one window.

The basics are explained in chapter 7 and 8 of the user manual |usr_07.txt|
|usr_08.txt|.

1.  Introduction				|windows-intro|
2.  Starting Vim				|windows-starting|
3.  Opening and closing a window		|opening-window|
4.  Moving cursor to other windows		|window-move-cursor|
5.  Moving windows around			|window-moving|
6.  Window resizing				|window-resize|
7.  Argument and buffer list commands		|buffer-list|
8.  Do a command in all buffers or windows	|list-repeat|
9.  Tag or file name under the cursor		|window-tag|
10. The preview window				|preview-window|
11. Using hidden buffers			|buffer-hidden|
12. Special kinds of buffers			|special-buffers|

{Vi does not have any of these commands}
{not able to use multiple windows when the |+windows| feature was disabled at
compile time}
{not able to use vertically split windows when the |+vertsplit| feature was
disabled at compile time}

==============================================================================
1. Introduction					*windows-intro* *window*

Summary:
   A buffer is the in-memory text of a file.
   A window is a viewport on a buffer.
   A tab page is a collection of windows.

A window is a viewport onto a buffer.  You can use multiple windows on one
buffer, or several windows on different buffers.

A buffer is a file loaded into memory for editing.  The original file remains
unchanged until you write the buffer to the file.

A buffer can be in one of three states:

							*active-buffer*
active:   The buffer is displayed in a window.  If there is a file for this
	  buffer, it has been read into the buffer.  The buffer may have been
	  modified since then and thus be different from the file.
							*hidden-buffer*
hidden:   The buffer is not displayed.  If there is a file for this buffer, it
	  has been read into the buffer.  Otherwise it's the same as an active
	  buffer, you just can't see it.
							*inactive-buffer*
inactive: The buffer is not displayed and does not contain anything.  Options
	  for the buffer are remembered if the file was once loaded.  It can
	  contain marks from the |viminfo| file.  But the buffer doesn't
	  contain text.

In a table:

state		displayed	loaded		":buffers"  ~
		in window			shows	    ~
active		  yes		 yes		  'a'
hidden		  no		 yes		  'h'
inactive	  no		 no		  ' '

Note: All CTRL-W commands can also be executed with |:wincmd|, for those
places where a Normal mode command can't be used or is inconvenient.

The main Vim window can hold several split windows.  There are also tab pages
|tab-page|, each of which can hold multiple windows.

==============================================================================
2. Starting Vim						*windows-starting*

By default, Vim starts with one window, just like Vi.

The "-o" and "-O" arguments to Vim can be used to open a window for each file
in the argument list.  The "-o" argument will split the windows horizontally;
the "-O" argument will split the windows vertically.  If both "-o" and "-O"
are given, the last one encountered will be used to determine the split
orientation.  For example, this will open three windows, split horizontally: >
	vim -o file1 file2 file3

"-oN", where N is a decimal number, opens N windows split horizontally.  If
there are more file names than windows, only N windows are opened and some
files do not get a window.  If there are more windows than file names, the
last few windows will be editing empty buffers.  Similarly, "-ON" opens N
windows split vertically, with the same restrictions.

If there are many file names, the windows will become very small.  You might
want to set the 'winheight' and/or 'winwidth' options to create a workable
situation.

Buf/Win Enter/Leave |autocommand|s are not executed when opening the new
windows and reading the files, that's only done when they are really entered.

							*status-line*
A status line will be used to separate windows.  The 'laststatus' option tells
when the last window also has a status line:
	'laststatus' = 0	never a status line
	'laststatus' = 1	status line if there is more than one window
	'laststatus' = 2	always a status line

You can change the contents of the status line with the 'statusline' option.
This option can be local to the window, so that you can have a different
status line in each window.

Normally, inversion is used to display the status line.  This can be changed
with the 's' character in the 'highlight' option.  For example, "sb" sets it to
bold characters.  If no highlighting is used for the status line ("sn"), the
'^' character is used for the current window, and '=' for other windows.  If
the mouse is supported and enabled with the 'mouse' option, a status line can
be dragged to resize windows.

Note: If you expect your status line to be in reverse video and it isn't,
check if the 'highlight' option contains "si".  In version 3.0, this meant to
invert the status line.  Now it should be "sr", reverse the status line, as
"si" now stands for italic!  If italic is not available on your terminal, the
status line is inverted anyway; you will only see this problem on terminals
that have termcap codes for italics.

==============================================================================
3. Opening and closing a window				*opening-window* *E36*

CTRL-W s						*CTRL-W_s*
CTRL-W S						*CTRL-W_S*
CTRL-W CTRL-S						*CTRL-W_CTRL-S*
:[N]sp[lit] [++opt] [+cmd] [file]			*:sp* *:split*
		Split current window in two.  The result is two viewports on
		the same file.
		
		Make the new window N high (default is to use half the height
		of the current window).  Reduces the current window height to
		create room (and others, if the 'equalalways' option is set,
		'eadirection' isn't "hor", and one of them is higher than the
		current or the new window).

		If [file] is given it will be edited in the new window.  If it
		is not loaded in any buffer, it will be read.  Else the new
		window will use the already loaded buffer.

		Note: CTRL-S does not work on all terminals and might block
		further input, use CTRL-Q to get going again.
		Also see |++opt| and |+cmd|.

CTRL-W CTRL-V						*CTRL-W_CTRL-V*
CTRL-W v						*CTRL-W_v*
:[N]vs[plit] [++opt] [+cmd] [file]			*:vs* *:vsplit*
		Like |:split|, but split vertically.  The windows will be
		spread out horizontally if
		1. a width was not specified,
		2. 'equalalways' is set,
		3. 'eadirection' isn't "ver", and
		4. one of the other windows is wider than the current or new
		   window.
		Note: In other places CTRL-Q does the same as CTRL-V, but here
		it doesn't!

CTRL-W n						*CTRL-W_n*
CTRL-W CTRL_N						*CTRL-W_CTRL-N*
:[N]new [++opt] [+cmd]					*:new*
		Create a new window and start editing an empty file in it.
		Make new window N high (default is to use half the existing
		height).  Reduces the current window height to create room (and
		others, if the 'equalalways' option is set and 'eadirection'
		isn't "hor").
		Also see |++opt| and |+cmd|.
		If 'fileformats' is not empty, the first format given will be
		used for the new buffer.  If 'fileformats' is empty, the
		'fileformat' of the current buffer is used.  This can be
		overridden with the |++opt| argument.
		Autocommands are executed in this order:
		1. WinLeave for the current window
		2. WinEnter for the new window
		3. BufLeave for the current buffer
		4. BufEnter for the new buffer
		This behaves like a ":split" first, and then an ":enew"
		command.

:[N]vne[w] [++opt] [+cmd] [file]			*:vne* *:vnew*
		Like |:new|, but split vertically.  If 'equalalways' is set
		and 'eadirection' isn't "ver" the windows will be spread out
		horizontally, unless a width was specified.

:[N]new [++opt] [+cmd] {file}
:[N]sp[lit] [++opt] [+cmd] {file}			*:split_f*
		Create a new window and start editing file {file} in it.  This
		behaves like a ":split" first, and then an ":e" command.
		If [+cmd] is given, execute the command when the file has been
		loaded |+cmd|.
		Also see |++opt|.
		Make new window N high (default is to use half the existing
		height).  Reduces the current window height to create room
		(and others, if the 'equalalways' option is set).

:[N]sv[iew] [++opt] [+cmd] {file}		*:sv* *:sview* *splitview*
		Same as ":split", but set 'readonly' option for this buffer.

:[N]sf[ind] [++opt] [+cmd] {file}		*:sf* *:sfind* *splitfind*
		Same as ":split", but search for {file} in 'path' like in
		|:find|.  Doesn't split if {file} is not found.

CTRL-W CTRL-^					*CTRL-W_CTRL-^* *CTRL-W_^*
CTRL-W ^	Does ":split #", split window in two and edit alternate file.
		When a count is given, it becomes ":split #N", split window
		and edit buffer N.

Note that the 'splitbelow' and 'splitright' options influence where a new
window will appear.

						*:vert* *:vertical*
:vert[ical] {cmd}
		Execute {cmd}.  If it contains a command that splits a window,
		it will be split vertically.
		Doesn't work for |:execute| and |:normal|.

:lefta[bove] {cmd}				*:lefta* *:leftabove*
:abo[veleft] {cmd}				*:abo* *:aboveleft*
		Execute {cmd}.  If it contains a command that splits a window,
		it will be opened left (vertical split) or above (horizontal
		split) the current window.  Overrules 'splitbelow' and
		'splitright'.
		Doesn't work for |:execute| and |:normal|.

:rightb[elow] {cmd}				*:rightb* *:rightbelow*
:bel[owright] {cmd}				*:bel* *:belowright*
		Execute {cmd}.  If it contains a command that splits a window,
		it will be opened right (vertical split) or below (horizontal
		split) the current window.  Overrules 'splitbelow' and
		'splitright'.
		Doesn't work for |:execute| and |:normal|.

						*:topleft* *E442*
:to[pleft] {cmd}
		Execute {cmd}.  If it contains a command that splits a window,
		it will appear at the top and occupy the full width of the Vim
		window.  When the split is vertical the window appears at the
		far left and occupies the full height of the Vim window.
		Doesn't work for |:execute| and |:normal|.

						*:botright*
:bo[tright] {cmd}
		Execute {cmd}.  If it contains a command that splits a window,
		it will appear at the bottom and occupy the full width of the
		Vim window.  When the split is vertical the window appears at
		the far right and occupies the full height of the Vim window.
		Doesn't work for |:execute| and |:normal|.

These command modifiers can be combined to make a vertically split window
occupy the full height.  Example: >
	:vertical topleft split tags
Opens a vertically split, full-height window on the "tags" file at the far
left of the Vim window.


Closing a window
----------------

CTRL-W q						*CTRL-W_q*
CTRL-W CTRL-Q						*CTRL-W_CTRL-Q*
:q[uit]		Quit current window.  When quitting the last window (not
		counting a help window), exit Vim.
		When 'hidden' is set, and there is only one window for the
		current buffer, it becomes hidden.
		When 'hidden' is not set, and there is only one window for the
		current buffer, and the buffer was changed, the command fails.
		(Note: CTRL-Q does not work on all terminals)

:q[uit]!	Quit current window.  If this was the last window for a buffer,
		any changes to that buffer are lost.  When quitting the last
		window (not counting help windows), exit Vim.  The contents of
		the buffer are lost, even when 'hidden' is set.

CTRL-W c					*CTRL-W_c* *:clo* *:close*
:clo[se][!]	Close current window.  When the 'hidden' option is set, or
		when the buffer was changed and the [!] is used, the buffer
		becomes hidden (unless there is another window editing it).
		When there is only one window in the current tab page and
		there is another tab page, this closes the current tab page.
		|tab-page|.
		This command fails when:			*E444*
		- There is only one window on the screen.
		- When 'hidden' is not set, [!] is not used, the buffer has
		  changes, and there is no other window on this buffer.
		Changes to the buffer are not written and won't get lost, so
		this is a "safe" command.

CTRL-W CTRL-C						*CTRL-W_CTRL-C*
		You might have expected that CTRL-W CTRL-C closes the current
		window, but that does not work, because the CTRL-C cancels the
		command.

							*:hide*
:hid[e]		Quit current window, unless it is the last window on the
		screen.  The buffer becomes hidden (unless there is another
		window editing it or 'bufhidden' is "unload" or "delete").
		If the window is the last one in the current tab page the tab
		page is closed. |tab-page|
		The value of 'hidden' is irrelevant for this command.
		Changes to the buffer are not written and won't get lost, so
		this is a "safe" command.

:hid[e] {cmd}	Execute {cmd} with 'hidden' is set.  The previous value of
		'hidden' is restored after {cmd} has been executed.
		Example: >
		    :hide edit Makefile
<		This will edit "Makefile", and hide the current buffer if it
		has any changes.

CTRL-W o						*CTRL-W_o* *E445*
CTRL-W CTRL-O					*CTRL-W_CTRL-O* *:on* *:only*
:on[ly][!]	Make the current window the only one on the screen.  All other
		windows are closed.
		When the 'hidden' option is set, all buffers in closed windows
		become hidden.
		When 'hidden' is not set, and the 'autowrite' option is set,
		modified buffers are written.  Otherwise, windows that have
		buffers that are modified are not removed, unless the [!] is
		given, then they become hidden.  But modified buffers are
		never abandoned, so changes cannot get lost.

==============================================================================
4. Moving cursor to other windows			*window-move-cursor*

CTRL-W <Down>					*CTRL-W_<Down>*
CTRL-W CTRL-J					*CTRL-W_CTRL-J* *CTRL-W_j*
CTRL-W j	Move cursor to Nth window below current one.  Uses the cursor
		position to select between alternatives.

CTRL-W <Up>					*CTRL-W_<Up>*
CTRL-W CTRL-K					*CTRL-W_CTRL-K* *CTRL-W_k*
CTRL-W k	Move cursor to Nth window above current one.  Uses the cursor
		position to select between alternatives.

CTRL-W <Left>					*CTRL-W_<Left>*
CTRL-W CTRL-H					*CTRL-W_CTRL-H*
CTRL-W <BS>					*CTRL-W_<BS>* *CTRL-W_h*
CTRL-W h	Move cursor to Nth window left of current one.  Uses the
		cursor position to select between alternatives.

CTRL-W <Right>					*CTRL-W_<Right>*
CTRL-W CTRL-L					*CTRL-W_CTRL-L* *CTRL-W_l*
CTRL-W l	Move cursor to Nth window right of current one.  Uses the
		cursor position to select between alternatives.

CTRL-W w					*CTRL-W_w* *CTRL-W_CTRL-W*
CTRL-W CTRL-W	Without count: move cursor to window below/right of the
		current one.  If there is no window below or right, go to
		top-left window.
		With count: go to Nth window (windows are numbered from
		top-left to bottom-right).  To obtain the window number see
		|bufwinnr()| and |winnr()|.  When N is larger than the number
		of windows go to the last window.

						*CTRL-W_W*
CTRL-W W	Without count: move cursor to window above/left of current
		one.  If there is no window above or left, go to bottom-right
		window.  With count: go to Nth window, like with CTRL-W w.

CTRL-W t					*CTRL-W_t* *CTRL-W_CTRL-T*
CTRL-W CTRL-T	Move cursor to top-left window.

CTRL-W b					*CTRL-W_b* *CTRL-W_CTRL-B*
CTRL-W CTRL-B	Move cursor to bottom-right window.

CTRL-W p					*CTRL-W_p* *CTRL-W_CTRL-P*
CTRL-W CTRL-P	Go to previous (last accessed) window.

						*CTRL-W_P* *E441*
CTRL-W P	Go to preview window.  When there is no preview window this is
		an error.
		{not available when compiled without the |+quickfix| feature}

If Visual mode is active and the new window is not for the same buffer, the
Visual mode is ended.  If the window is on the same buffer, the cursor
position is set to keep the same Visual area selected.

						*:winc* *:wincmd*
These commands can also be executed with ":wincmd":

:[count]winc[md] {arg}
		Like executing CTRL-W [count] {arg}.  Example: >
			:wincmd j
<		Moves to the window below the current one.
		This command is useful when a Normal mode cannot be used (for
		the |CursorHold| autocommand event).  Or when a Normal mode
		command is inconvenient.
		The count can also be a window number.  Example: >
			:exe nr . "wincmd w"
<		This goes to window "nr".

==============================================================================
5. Moving windows around				*window-moving*

CTRL-W r				*CTRL-W_r* *CTRL-W_CTRL-R* *E443*
CTRL-W CTRL-R	Rotate windows downwards/rightwards.  The first window becomes
		the second one, the second one becomes the third one, etc.
		The last window becomes the first window.  The cursor remains
		in the same window.
		This only works within the row or column of windows that the
		current window is in.

						*CTRL-W_R*
CTRL-W R	Rotate windows upwards/leftwards.  The second window becomes
		the first one, the third one becomes the second one, etc.  The
		first window becomes the last window.  The cursor remains in
		the same window.
		This only works within the row or column of windows that the
		current window is in.

CTRL-W x					*CTRL-W_x* *CTRL-W_CTRL-X*
CTRL-W CTRL-X	Without count: Exchange current window with next one.  If there
		is no next window, exchange with previous window.
		With count: Exchange current window with Nth window (first
		window is 1).  The cursor is put in the other window.
		When vertical and horizontal window splits are mixed, the
		exchange is only done in the row or column of windows that the
		current window is in.

The following commands can be used to change the window layout.  For example,
when there are two vertically split windows, CTRL-W K will change that in
horizontally split windows.  CTRL-W H does it the other way around.

						*CTRL-W_K*
CTRL-W K	Move the current window to be at the very top, using the full
		width of the screen.  This works like closing the current
		window and then creating another one with ":topleft split",
		except that the current window contents is used for the new
		window.

						*CTRL-W_J*
CTRL-W J	Move the current window to be at the very bottom, using the
		full width of the screen.  This works like closing the current
		window and then creating another one with ":botright split",
		except that the current window contents is used for the new
		window.

						*CTRL-W_H*
CTRL-W H	Move the current window to be at the far left, using the
		full height of the screen.  This works like closing the
		current window and then creating another one with
		":vert topleft split", except that the current window contents
		is used for the new window.
		{not available when compiled without the |+vertsplit| feature}

						*CTRL-W_L*
CTRL-W L	Move the current window to be at the far right, using the full
		height of the screen.  This works like closing the
		current window and then creating another one with
		":vert botright split", except that the current window
		contents is used for the new window.
		{not available when compiled without the |+vertsplit| feature}

						*CTRL-W_T*
CTRL-W T	Move the current window to a new tab page.  This fails if
		there is only one window in the current tab page.
		When a count is specified the new tab page will be opened
		before the tab page with this index.  Otherwise it comes after
		the current tab page.

==============================================================================
6. Window resizing					*window-resize*

						*CTRL-W_=*
CTRL-W =	Make all windows (almost) equally high and wide, but use
		'winheight' and 'winwidth' for the current window.
		Windows with 'winfixheight' set keep their height and windows
		with 'winfixwidth' set keep their width.

:res[ize] -N					*:res* *:resize* *CTRL-W_-*
CTRL-W -	Decrease current window height by N (default 1).
		If used after |:vertical|: decrease width by N.

:res[ize] +N					*CTRL-W_+*
CTRL-W +	Increase current window height by N (default 1).
		If used after |:vertical|: increase width by N.

:res[ize] [N]
CTRL-W CTRL-_					*CTRL-W_CTRL-_* *CTRL-W__*
CTRL-W _	Set current window height to N (default: highest possible).

z{nr}<CR>	Set current window height to {nr}.

						*CTRL-W_<*
CTRL-W <	Decrease current window width by N (default 1).

						*CTRL-W_>*
CTRL-W >	Increase current window width by N (default 1).

:vertical res[ize] [N]			*:vertical-resize* *CTRL-W_bar*
CTRL-W |	Set current window width to N (default: widest possible).

You can also resize a window by dragging a status line up or down with the
mouse.  Or by dragging a vertical separator line left or right.  This only
works if the version of Vim that is being used supports the mouse and the
'mouse' option has been set to enable it.

The option 'winheight' ('wh') is used to set the minimal window height of the
current window.  This option is used each time another window becomes the
current window.  If the option is '0', it is disabled.  Set 'winheight' to a
very large value, e.g., '9999', to make the current window always fill all
available space.  Set it to a reasonable value, e.g., '10', to make editing in
the current window comfortable.

The equivalent 'winwidth' ('wiw') option is used to set the minimal width of
the current window.

When the option 'equalalways' ('ea') is set, all the windows are automatically
made the same size after splitting or closing a window.  If you don't set this
option, splitting a window will reduce the size of the current window and
leave the other windows the same.  When closing a window, the extra lines are
given to the window above it.

The 'eadirection' option limits the direction in which the 'equalalways'
option is applied.  The default "both" resizes in both directions.  When the
value is "ver" only the heights of windows are equalized.  Use this when you
have manually resized a vertically split window and want to keep this width.
Likewise, "hor" causes only the widths of windows to be equalized.

The option 'cmdheight' ('ch') is used to set the height of the command-line.
If you are annoyed by the |hit-enter| prompt for long messages, set this
option to 2 or 3.

If there is only one window, resizing that window will also change the command
line height.  If there are several windows, resizing the current window will
also change the height of the window below it (and sometimes the window above
it).

The minimal height and width of a window is set with 'winminheight' and
'winminwidth'.  These are hard values, a window will never become smaller.

==============================================================================
7. Argument and buffer list commands			*buffer-list*

      args list		       buffer list	   meaning ~
1. :[N]argument [N]	11. :[N]buffer [N]	to arg/buf N
2. :[N]next [file ..]	12. :[N]bnext [N]	to Nth next arg/buf
3. :[N]Next [N]		13. :[N]bNext [N]	to Nth previous arg/buf
4. :[N]previous	[N]	14. :[N]bprevious [N]	to Nth previous arg/buf
5. :rewind / :first	15. :brewind / :bfirst	to first arg/buf
6. :last		16. :blast		to last arg/buf
7. :all			17. :ball		edit all args/buffers
			18. :unhide		edit all loaded buffers
			19. :[N]bmod [N]	to Nth modified buf

  split & args list	  split & buffer list	   meaning ~
21. :[N]sargument [N]   31. :[N]sbuffer [N]	split + to arg/buf N
22. :[N]snext [file ..] 32. :[N]sbnext [N]      split + to Nth next arg/buf
23. :[N]sNext [N]       33. :[N]sbNext [N]      split + to Nth previous arg/buf
24. :[N]sprevious [N]   34. :[N]sbprevious [N]  split + to Nth previous arg/buf
25. :srewind / :sfirst	35. :sbrewind / :sbfirst split + to first arg/buf
26. :slast		36. :sblast		split + to last arg/buf
27. :sall		37. :sball		edit all args/buffers
			38. :sunhide		edit all loaded buffers
			39. :[N]sbmod [N]	split + to Nth modified buf

40. :args		list of arguments
41. :buffers		list of buffers

The meaning of [N] depends on the command:
 [N] is number of buffers to go forward/backward on ?2, ?3, and ?4
 [N] is an argument number, defaulting to current argument, for 1 and 21
 [N] is a buffer number, defaulting to current buffer, for 11 and 31
 [N] is a count for 19 and 39

Note: ":next" is an exception, because it must accept a list of file names
for compatibility with Vi.


The argument list and multiple windows
--------------------------------------

The current position in the argument list can be different for each window.
Remember that when doing ":e file", the position in the argument list stays
the same, but you are not editing the file at that position.  To indicate
this, the file message (and the title, if you have one) shows
"(file (N) of M)", where "(N)" is the current position in the file list, and
"M" the number of files in the file list.

All the entries in the argument list are added to the buffer list.  Thus, you
can also get to them with the buffer list commands, like ":bnext".

:[N]al[l][!] [N]				*:al* *:all* *:sal* *:sall*
:[N]sal[l][!] [N]
		Rearrange the screen to open one window for each argument.
		All other windows are closed.  When a count is given, this is
		the maximum number of windows to open.
		With the |:tab| modifier open a tab page for each argument.
		When there are more arguments than 'tabpagemax' further ones
		become split windows in the last tab page.
		When the 'hidden' option is set, all buffers in closed windows
		become hidden.
		When 'hidden' is not set, and the 'autowrite' option is set,
		modified buffers are written.  Otherwise, windows that have
		buffers that are modified are not removed, unless the [!] is
		given, then they become hidden.  But modified buffers are
		never abandoned, so changes cannot get lost.
		[N] is the maximum number of windows to open.  'winheight'
		also limits the number of windows opened ('winwidth' if
		|:vertical| was prepended).
		Buf/Win Enter/Leave autocommands are not executed for the new
		windows here, that's only done when they are really entered.

:[N]sa[rgument][!] [++opt] [+cmd] [N]			*:sa* *:sargument*
		Short for ":split | argument [N]": split window and go to Nth
		argument.  But when there is no such argument, the window is
		not split.  Also see |++opt| and |+cmd|.

:[N]sn[ext][!] [++opt] [+cmd] [file ..]			*:sn* *:snext*
		Short for ":split | [N]next": split window and go to Nth next
		argument.  But when there is no next file, the window is not
		split.  Also see |++opt| and |+cmd|.

:[N]spr[evious][!] [++opt] [+cmd] [N]			*:spr* *:sprevious*
:[N]sN[ext][!] [++opt] [+cmd] [N]			*:sN* *:sNext*
		Short for ":split | [N]Next": split window and go to Nth
		previous argument.  But when there is no previous file, the
		window is not split.  Also see |++opt| and |+cmd|.

						*:sre* *:srewind*
:sre[wind][!] [++opt] [+cmd]
		Short for ":split | rewind": split window and go to first
		argument.  But when there is no argument list, the window is
		not split.  Also see |++opt| and |+cmd|.

						*:sfir* *:sfirst*
:sfir[st] [++opt] [+cmd]
		Same as ":srewind".

						*:sla* *:slast*
:sla[st][!] [++opt] [+cmd]
		Short for ":split | last": split window and go to last
		argument.  But when there is no argument list, the window is
		not split.  Also see |++opt| and |+cmd|.

						*:dr* *:drop*
:dr[op] [++opt] [+cmd] {file} ..
		Edit the first {file} in a window.
		- If the file is already open in a window change to that
		  window.
		- If the file is not open in a window edit the file in the
		  current window.  If the current buffer can't be |abandon|ed,
		  the window is split first.
		The |argument-list| is set, like with the |:next| command.
		The purpose of this command is that it can be used from a
		program that wants Vim to edit another file, e.g., a debugger.
		When using the |:tab| modifier each argument is opened in a
		tab page.  The last window is used if it's empty.
		Also see |++opt| and |+cmd|.
		{only available when compiled with a GUI}

==============================================================================
8. Do a command in all buffers or windows			*list-repeat*

							*:windo*
:windo {cmd}		Execute {cmd} in each window.
			It works like doing this: >
				CTRL-W t
				:{cmd}
				CTRL-W w
				:{cmd}
				etc.
<			This only operates in the current tab page.
			When an error is detected on one window, further
			windows will not be visited.
			The last window (or where an error occurred) becomes
			the current window.
			{cmd} can contain '|' to concatenate several commands.
			{cmd} must not open or close windows or reorder them.
			{not in Vi} {not available when compiled without the
			|+listcmds| feature}
			Also see |:tabdo|, |:argdo| and |:bufdo|.

							*:bufdo*
:bufdo[!] {cmd}		Execute {cmd} in each buffer in the buffer list.
			It works like doing this: >
				:bfirst
				:{cmd}
				:bnext
				:{cmd}
				etc.
<			When the current file can't be |abandon|ed and the [!]
			is not present, the command fails.
			When an error is detected on one buffer, further
			buffers will not be visited.
			Unlisted buffers are skipped.
			The last buffer (or where an error occurred) becomes
			the current buffer.
			{cmd} can contain '|' to concatenate several commands.
			{cmd} must not delete buffers or add buffers to the
			buffer list.
			Note: While this command is executing, the Syntax
			autocommand event is disabled by adding it to
			'eventignore'.  This considerably speeds up editing
			each buffer.
			{not in Vi} {not available when compiled without the
			|+listcmds| feature}
			Also see |:tabdo|, |:argdo| and |:windo|.

Examples: >

	:windo set nolist nofoldcolumn | normal zn

This resets the 'list' option and disables folding in all windows. >

	:bufdo set fileencoding= | update

This resets the 'fileencoding' in each buffer and writes it if this changed
the buffer.  The result is that all buffers will use the 'encoding' encoding
(if conversion works properly).

==============================================================================
9. Tag or file name under the cursor			*window-tag*

							*:sta* *:stag*
:sta[g][!] [tagname]
		Does ":tag[!] [tagname]" and splits the window for the found
		tag.  See also |:tag|.

CTRL-W ]					*CTRL-W_]* *CTRL-W_CTRL-]*
CTRL-W CTRL-]	Split current window in two.  Use identifier under cursor as a
		tag and jump to it in the new upper window.
		In Visual mode uses the Visually selected text as a tag.
		Make new window N high.

							*CTRL-W_g]*
CTRL-W g ]	Split current window in two.  Use identifier under cursor as a
		tag and perform ":tselect" on it in the new upper window.
		In Visual mode uses the Visually selected text as a tag.
		Make new window N high.

							*CTRL-W_g_CTRL-]*
CTRL-W g CTRL-]	Split current window in two.  Use identifier under cursor as a
		tag and perform ":tjump" on it in the new upper window.
		In Visual mode uses the Visually selected text as a tag.
		Make new window N high.

CTRL-W f					*CTRL-W_f* *CTRL-W_CTRL-F*
CTRL-W CTRL-F	Split current window in two.  Edit file name under cursor.
		Like ":split gf", but window isn't split if the file does not
		exist.
		Uses the 'path' variable as a list of directory names where to
		look for the file.  Also the path for current file is
		used to search for the file name.
		If the name is a hypertext link that looks like
		"type://machine/path", only "/path" is used.
		If a count is given, the count'th matching file is edited.
		{not available when the |+file_in_path| feature was disabled
		at compile time}

CTRL-W F						*CTRL-W_F*
		Split current window in two.  Edit file name under cursor and
		jump to the line number following the file name. See |gF| for
		details on how the line number is obtained.
		{not available when the |+file_in_path| feature was disabled
		at compile time}

CTRL-W gf						*CTRL-W_gf*
		Open a new tab page and edit the file name under the cursor.
		Like "tab split" and "gf", but the new tab page isn't created
		if the file does not exist.
		{not available when the |+file_in_path| feature was disabled
		at compile time}

CTRL-W gF						*CTRL-W_gF*
		Open a new tab page and edit the file name under the cursor
		and jump to the line number following the file name.  Like
		"tab split" and "gF", but the new tab page isn't created if
		the file does not exist.
		{not available when the |+file_in_path| feature was disabled
		at compile time}

Also see |CTRL-W_CTRL-I|: open window for an included file that includes
the keyword under the cursor.

==============================================================================
10. The preview window				*preview-window*

The preview window is a special window to show (preview) another file.  It is
normally a small window used to show an include file or definition of a
function.
{not available when compiled without the |+quickfix| feature}

There can be only one preview window (per tab page).  It is created with one
of the commands below.  The 'previewheight' option can be set to specify the
height of the preview window when it's opened.  The 'previewwindow' option is
set in the preview window to be able to recognize it.  The 'winfixheight'
option is set to have it keep the same height when opening/closing other
windows.

						*:pta* *:ptag*
:pta[g][!] [tagname]
		Does ":tag[!] [tagname]" and shows the found tag in a
		"Preview" window without changing the current buffer or cursor
		position.  If a "Preview" window already exists, it is re-used
		(like a help window is).  If a new one is opened,
		'previewheight' is used for the height of the window.   See
		also |:tag|.
		See below for an example. |CursorHold-example|
		Small difference from |:tag|: When [tagname] is equal to the
		already displayed tag, the position in the matching tag list
		is not reset.  This makes the CursorHold example work after a
		|:ptnext|.

CTRL-W z					*CTRL-W_z*
CTRL-W CTRL-Z					*CTRL-W_CTRL-Z* *:pc* *:pclose*
:pc[lose][!]	Close any "Preview" window currently open.  When the 'hidden'
		option is set, or when the buffer was changed and the [!] is
		used, the buffer becomes hidden (unless there is another
		window editing it).  The command fails if any "Preview" buffer
		cannot be closed.  See also |:close|.

							*:pp* *:ppop*
:[count]pp[op][!]
		Does ":[count]pop[!]" in the preview window.  See |:pop| and
		|:ptag|.  {not in Vi}

CTRL-W }						*CTRL-W_}*
		Use identifier under cursor as a tag and perform a :ptag on
		it.  Make the new Preview window (if required) N high.  If N is
		not given, 'previewheight' is used.

CTRL-W g }						*CTRL-W_g}*
		Use identifier under cursor as a tag and perform a :ptjump on
		it.  Make the new Preview window (if required) N high.  If N is
		not given, 'previewheight' is used.

							*:ped* *:pedit*
:ped[it][!] [++opt] [+cmd] {file}
		Edit {file} in the preview window.  The preview window is
		opened like with |:ptag|.  The current window and cursor
		position isn't changed.  Useful example: >
			:pedit +/fputc /usr/include/stdio.h
<
							*:ps* *:psearch*
:[range]ps[earch][!] [count] [/]pattern[/]
		Works like |:ijump| but shows the found match in the preview
		window.  The preview window is opened like with |:ptag|.  The
		current window and cursor position isn't changed.  Useful
		example: >
			:psearch popen
<		Like with the |:ptag| command, you can use this to
		automatically show information about the word under the
		cursor.  This is less clever than using |:ptag|, but you don't
		need a tags file and it will also find matches in system
		include files.  Example: >
  :au! CursorHold *.[ch] nested exe "silent! psearch " . expand("<cword>")
<		Warning: This can be slow.

Example						*CursorHold-example*  >

  :au! CursorHold *.[ch] nested exe "silent! ptag " . expand("<cword>")

This will cause a ":ptag" to be executed for the keyword under the cursor,
when the cursor hasn't moved for the time set with 'updatetime'.  The "nested"
makes other autocommands be executed, so that syntax highlighting works in the
preview window.  The "silent!" avoids an error message when the tag could not
be found.  Also see |CursorHold|.  To disable this again: >

  :au! CursorHold

A nice addition is to highlight the found tag, avoid the ":ptag" when there
is no word under the cursor, and a few other things: >

  :au! CursorHold *.[ch] nested call PreviewWord()
  :func PreviewWord()
  :  if &previewwindow			" don't do this in the preview window
  :    return
  :  endif
  :  let w = expand("<cword>")		" get the word under cursor
  :  if w =~ '\a'			" if the word contains a letter
  :
  :    " Delete any existing highlight before showing another tag
  :    silent! wincmd P			" jump to preview window
  :    if &previewwindow			" if we really get there...
  :      match none			" delete existing highlight
  :      wincmd p			" back to old window
  :    endif
  :
  :    " Try displaying a matching tag for the word under the cursor
  :    try
  :       exe "ptag " . w
  :    catch
  :      return
  :    endtry
  :
  :    silent! wincmd P			" jump to preview window
  :    if &previewwindow		" if we really get there...
  :	 if has("folding")
  :	   silent! .foldopen		" don't want a closed fold
  :	 endif
  :	 call search("$", "b")		" to end of previous line
  :	 let w = substitute(w, '\\', '\\\\', "")
  :	 call search('\<\V' . w . '\>')	" position cursor on match
  :	 " Add a match highlight to the word at this position
  :      hi previewWord term=bold ctermbg=green guibg=green
  :	 exe 'match previewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
  :      wincmd p			" back to old window
  :    endif
  :  endif
  :endfun

==============================================================================
11. Using hidden buffers				*buffer-hidden*

A hidden buffer is not displayed in a window, but is still loaded into memory.
This makes it possible to jump from file to file, without the need to read or
write the file every time you get another buffer in a window.
{not available when compiled without the |+listcmds| feature}

							*:buffer-!*
If the option 'hidden' ('hid') is set, abandoned buffers are kept for all
commands that start editing another file: ":edit", ":next", ":tag", etc.  The
commands that move through the buffer list sometimes make the current buffer
hidden although the 'hidden' option is not set.  This happens when a buffer is
modified, but is forced (with '!') to be removed from a window, and
'autowrite' is off or the buffer can't be written.

You can make a hidden buffer not hidden by starting to edit it with any
command.  Or by deleting it with the ":bdelete" command.

The 'hidden' is global, it is used for all buffers.  The 'bufhidden' option
can be used to make an exception for a specific buffer.  It can take these
values:
	<empty>		Use the value of 'hidden'.
	hide		Hide this buffer, also when 'hidden' is not set.
	unload		Don't hide but unload this buffer, also when 'hidden'
			is set.
	delete		Delete the buffer.

							*hidden-quit*
When you try to quit Vim while there is a hidden, modified buffer, you will
get an error message and Vim will make that buffer the current buffer.  You
can then decide to write this buffer (":wq") or quit without writing (":q!").
Be careful: there may be more hidden, modified buffers!

A buffer can also be unlisted.  This means it exists, but it is not in the
list of buffers. |unlisted-buffer|


:files[!]					*:files*
:buffers[!]					*:buffers* *:ls*
:ls[!]		Show all buffers.  Example:

			1 #h   "/test/text"		line 1 ~
			2u     "asdf"			line 0 ~
			3 %a + "version.c"		line 1 ~

		When the [!] is included the list will show unlisted buffers
		(the term "unlisted" is a bit confusing then...).

		Each buffer has a unique number.  That number will not change,
		so you can always go to a specific buffer with ":buffer N" or
		"N CTRL-^", where N is the buffer number.

		Indicators (chars in the same column are mutually exclusive):
		u	an unlisted buffer (only displayed when [!] is used)
			   |unlisted-buffer|
		 %	the buffer in the current window
		 #	the alternate buffer for ":e #" and CTRL-^
		  a	an active buffer: it is loaded and visible
		  h	a hidden buffer: It is loaded, but currently not
			   displayed in a window |hidden-buffer|
		   -	a buffer with 'modifiable' off
		   =	a readonly buffer
		    +	a modified buffer
		    x   a buffer with read errors

						*:bad* *:badd*
:bad[d]	[+lnum] {fname}
		Add file name {fname} to the buffer list, without loading it.
		If "lnum" is specified, the cursor will be positioned at that
		line when the buffer is first entered.  Note that other
		commands after the + will be ignored.

:[N]bd[elete][!]			*:bd* *:bdel* *:bdelete* *E516*
:bd[elete][!] [N]
		Unload buffer [N] (default: current buffer) and delete it from
		the buffer list.  If the buffer was changed, this fails,
		unless when [!] is specified, in which case changes are lost.
		The file remains unaffected.  Any windows for this buffer are
		closed.  If buffer [N] is the current buffer, another buffer
		will be displayed instead.  This is the most recent entry in
		the jump list that points into a loaded buffer.
		Actually, the buffer isn't completely deleted, it is removed
		from the buffer list |unlisted-buffer| and option values,
		variables and mappings/abbreviations for the buffer are
		cleared.

:bdelete[!] {bufname}						*E93* *E94*
		Like ":bdelete[!] [N]", but buffer given by name.  Note that a
		buffer whose name is a number cannot be referenced by that
		name; use the buffer number instead.  Insert a backslash
		before a space in a buffer name.

:bdelete[!] N1 N2 ...
		Do ":bdelete[!]" for buffer N1, N2, etc.  The arguments can be
		buffer numbers or buffer names (but not buffer names that are
		a number).  Insert a backslash before a space in a buffer
		name.

:N,Mbdelete[!]	Do ":bdelete[!]" for all buffers in the range N to M
		|inclusive|.

:[N]bw[ipeout][!]			*:bw* *:bwipe* *:bwipeout* *E517*
:bw[ipeout][!] {bufname}
:N,Mbw[ipeout][!]
:bw[ipeout][!] N1 N2 ...
		Like |:bdelete|, but really delete the buffer.  Everything
		related to the buffer is lost.  All marks in this buffer
		become invalid, option settings are lost, etc.  Don't use this
		unless you know what you are doing.

:[N]bun[load][!]				*:bun* *:bunload* *E515*
:bun[load][!] [N]
		Unload buffer [N] (default: current buffer).  The memory
		allocated for this buffer will be freed.  The buffer remains
		in the buffer list.
		If the buffer was changed, this fails, unless when [!] is
		specified, in which case the changes are lost.
		Any windows for this buffer are closed.  If buffer [N] is the
		current buffer, another buffer will be displayed instead.
		This is the most recent entry in the jump list that points
		into a loaded buffer.

:bunload[!] {bufname}
		Like ":bunload[!] [N]", but buffer given by name.  Note that a
		buffer whose name is a number cannot be referenced by that
		name; use the buffer number instead.  Insert a backslash
		before a space in a buffer name.

:N,Mbunload[!]	Do ":bunload[!]" for all buffers in the range N to M
		|inclusive|.

:bunload[!] N1 N2 ...
		Do ":bunload[!]" for buffer N1, N2, etc.  The arguments can be
		buffer numbers or buffer names (but not buffer names that are
		a number).  Insert a backslash before a space in a buffer
		name.

:[N]b[uffer][!] [+cmd] [N]		*:b* *:bu* *:buf* *:buffer* *E86*
		Edit buffer [N] from the buffer list.  If [N] is not given,
		the current buffer remains being edited.  See |:buffer-!| for
		[!].  This will also edit a buffer that is not in the buffer
		list, without setting the 'buflisted' flag.
		Also see ||+cmd|.

:[N]b[uffer][!] [+cmd] {bufname}
		Edit buffer for {bufname} from the buffer list.  See
		|:buffer-!| for [!].  This will also edit a buffer that is not
		in the buffer list, without setting the 'buflisted' flag.
		Also see ||+cmd|.

:[N]sb[uffer] [+cmd] [N]				*:sb* *:sbuffer*
		Split window and edit buffer [N] from the buffer list.  If [N]
		is not given, the current buffer is edited.  Respects the
		"useopen" setting of 'switchbuf' when splitting.  This will
		also edit a buffer that is not in the buffer list, without
		setting the 'buflisted' flag.
		Also see ||+cmd|.

:[N]sb[uffer] [+cmd] {bufname}
		Split window and edit buffer for {bufname} from the buffer
		list.  This will also edit a buffer that is not in the buffer
		list, without setting the 'buflisted' flag.
		Note: If what you want to do is split the buffer, make a copy
		under another name, you can do it this way: >
			:w foobar | sp #
<		Also see ||+cmd|.

:[N]bn[ext][!] [+cmd] [N]				*:bn* *:bnext* *E87*
		Go to [N]th next buffer in buffer list.  [N] defaults to one.
		Wraps around the end of the buffer list.
		See |:buffer-!| for [!].
		Also see ||+cmd|.
		If you are in a help buffer, this takes you to the next help
		buffer (if there is one).  Similarly, if you are in a normal
		(non-help) buffer, this takes you to the next normal buffer.
		This is so that if you have invoked help, it doesn't get in
		the way when you're browsing code/text buffers.  The next three
		commands also work like this.


							*:sbn* *:sbnext*
:[N]sbn[ext] [+cmd] [N]
		Split window and go to [N]th next buffer in buffer list.
		Wraps around the end of the buffer list.  Uses 'switchbuf'
		Also see ||+cmd|.

:[N]bN[ext][!] [+cmd] [N]		*:bN* *:bNext* *:bp* *:bprevious* *E88*
:[N]bp[revious][!] [+cmd] [N]
		Go to [N]th previous buffer in buffer list.  [N] defaults to
		one.  Wraps around the start of the buffer list.
		See |:buffer-!| for [!] and 'switchbuf'.
		Also see ||+cmd|.

:[N]sbN[ext] [+cmd] [N]			*:sbN* *:sbNext* *:sbp* *:sbprevious*
:[N]sbp[revious] [+cmd] [N]
		Split window and go to [N]th previous buffer in buffer list.
		Wraps around the start of the buffer list.
		Uses 'switchbuf'.
		Also see ||+cmd|.

:br[ewind][!] [+cmd]					*:br* *:brewind*
		Go to first buffer in buffer list.  If the buffer list is
		empty, go to the first unlisted buffer.
		See |:buffer-!| for [!].

:bf[irst] [+cmd]					*:bf* *:bfirst*
		Same as |:brewind|.
		Also see |+cmd|.

:sbr[ewind] [+cmd]					*:sbr* *:sbrewind*
		Split window and go to first buffer in buffer list.  If the
		buffer list is empty, go to the first unlisted buffer.
		Respects the 'switchbuf' option.
		Also see |+cmd|.

:sbf[irst] [+cmd]					*:sbf* *:sbfirst*
		Same as ":sbrewind".

:bl[ast][!] [+cmd]					*:bl* *:blast*
		Go to last buffer in buffer list.  If the buffer list is
		empty, go to the last unlisted buffer.
		See |:buffer-!| for [!].

:sbl[ast] [+cmd]					*:sbl* *:sblast*
		Split window and go to last buffer in buffer list.  If the
		buffer list is empty, go to the last unlisted buffer.
		Respects 'switchbuf' option.

:[N]bm[odified][!] [+cmd] [N]			*:bm* *:bmodified* *E84*
		Go to [N]th next modified buffer.  Note: this command also
		finds unlisted buffers.  If there is no modified buffer the
		command fails.

:[N]sbm[odified] [+cmd] [N]				*:sbm* *:sbmodified*
		Split window and go to [N]th next modified buffer.
		Respects 'switchbuf' option.
		Note: this command also finds buffers not in the buffer list.

:[N]unh[ide] [N]			*:unh* *:unhide* *:sun* *:sunhide*
:[N]sun[hide] [N]
		Rearrange the screen to open one window for each loaded buffer
		in the buffer list.  When a count is given, this is the
		maximum number of windows to open.

:[N]ba[ll] [N]					*:ba* *:ball* *:sba* *:sball*
:[N]sba[ll] [N]	Rearrange the screen to open one window for each buffer in
		the buffer list.  When a count is given, this is the maximum
		number of windows to open.  'winheight' also limits the number
		of windows opened ('winwidth' if |:vertical| was prepended).
		Buf/Win Enter/Leave autocommands are not executed for the new
		windows here, that's only done when they are really entered.
		When the |:tab| modifier is used new windows are opened in a
		new tab, up to 'tabpagemax'.

Note: All the commands above that start editing another buffer, keep the
'readonly' flag as it was.  This differs from the ":edit" command, which sets
the 'readonly' flag each time the file is read.

==============================================================================
12. Special kinds of buffers			*special-buffers*

Instead of containing the text of a file, buffers can also be used for other
purposes.  A few options can be set to change the behavior of a buffer:
	'bufhidden'	what happens when the buffer is no longer displayed
			in a window.
	'buftype'	what kind of a buffer this is
	'swapfile'	whether the buffer will have a swap file
	'buflisted'	buffer shows up in the buffer list

A few useful kinds of a buffer:

quickfix	Used to contain the error list or the location list.  See
		|:cwindow| and |:lwindow|.  This command sets the 'buftype'
		option to "quickfix".  You are not supposed to change this!
		'swapfile' is off.

help		Contains a help file.  Will only be created with the |:help|
		command.  The flag that indicates a help buffer is internal
		and can't be changed.  The 'buflisted' option will be reset
		for a help buffer.

directory	Displays directory contents.  Can be used by a file explorer
		plugin.  The buffer is created with these settings: >
			:setlocal buftype=nowrite
			:setlocal bufhidden=delete
			:setlocal noswapfile
<		The buffer name is the name of the directory and is adjusted
		when using the |:cd| command.

scratch		Contains text that can be discarded at any time.  It is kept
		when closing the window, it must be deleted explicitly.
		Settings: >
			:setlocal buftype=nofile
			:setlocal bufhidden=hide
			:setlocal noswapfile
<		The buffer name can be used to identify the buffer, if you
		give it a meaningful name.

						*unlisted-buffer*
unlisted	The buffer is not in the buffer list.  It is not used for
		normal editing, but to show a help file, remember a file name
		or marks.  The ":bdelete" command will also set this option,
		thus it doesn't completely delete the buffer.  Settings: >
			:setlocal nobuflisted
<

 vim:tw=78:ts=8:ft=help:norl:
                                                                                                                                                                                                                                                           usr/share/vim/vim74/doc/workshop.txt                                                                0100644 0000000 0000000 00000011027 13050207306 016100  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *workshop.txt*  For Vim version 7.4.  Last change: 2013 Jul 06


		  VIM REFERENCE MANUAL    by Gordon Prieur


Sun Visual WorkShop Features			*workshop* *workshop-support*

1. Introduction						|workshop-intro|
2. Commands						|workshop-commands|
3. Compiling vim/gvim for WorkShop			|workshop-compiling|
4. Configuring gvim for a WorkShop release tree		|workshop-configure|
5. Obtaining the latest version of the XPM library	|workshop-xpm|

{Vi does not have any of these features}
{only available when compiled with the |+sun_workshop| feature}

==============================================================================
1. Introduction						*workshop-intro*

Sun Visual WorkShop has an "Editor of Choice" feature designed to let users
debug using their favorite editors.  For the 6.0 release we have added support
for gvim.  A workshop debug session will have a debugging window and an editor
window (possibly others as well).  The user can do many debugging operations
from the editor window, minimizing the need to switch from window to window.

The version of vim shipped with Sun Visual WorkShop 6 (also called Forte
Developer 6) is vim 5.3.  The features in this release are much more reliable
than the vim/gvim shipped with Visual WorkShop.  VWS users wishing to use vim
as their editor should compile these sources and install them in their
workshop release tree.

==============================================================================
2. Commands						*workshop-commands*

						*:ws* *:wsverb*
:ws[verb] verb			Pass the verb to the verb executor

Pass the verb to a workshop function which gathers some arguments and
sends the verb and data to workshop over an IPC connection.

==============================================================================
3. Compiling vim/gvim for WorkShop			*workshop-compiling*

Compiling vim with FEAT_SUN_WORKSHOP turns on all compile time flags necessary
for building a vim to work with Visual WorkShop.  The features required for VWS
have been built and tested using the Sun compilers from the VWS release.  They
have not been built or tested using Gnu compilers.  This does not mean the
features won't build and run if compiled with gcc, just that nothing is
guaranteed with gcc!

==============================================================================
4. Configuring gvim for a WorkShop release tree		*workshop-configure*

There are several assumptions which must be met in order to compile a gvim for
use with Sun Visual WorkShop 6.

    o You should use the compiler in VWS rather than gcc.  We have neither
      built nor tested with gcc and cannot guarantee it will build properly.

    o You must supply your own XPM library.  See |workshop-xpm| below for
      details on obtaining the latest version of XPM.

    o Edit the Makefile in the src directory and uncomment the lines for Sun
      Visual WorkShop.  You can easily find these by searching for the string
      FEAT_SUN_WORKSHOP

    o We also suggest you use Motif for your gui.  This will provide gvim with
      the same look-and-feel as the rest of Sun Visual WorkShop.

The following configuration line can be used to configure vim to build for use
with Sun Visual WorkShop:

    $ CC=cc configure --enable-workshop --enable-gui=motif \
	-prefix=<VWS-install-dir>/contrib/contrib6/<vim-version>

The VWS-install-dir should be the base directory where your Sun Visual WorkShop
was installed.  By default this is /opt/SUNWspro.  It will normally require
root permissions to install the vim release.  You will also need to change the
symlink <VWS-install-dir>/bin/gvim to point to the vim in your newly installed
directory.  The <vim-version> should be a unique version string.  I use "vim"
concatenated with the equivalent of version.h's VIM_VERSION_SHORT.

==============================================================================
5. Obtaining the latest version of the XPM library	*workshop-xpm*

The XPM library is required to show images within Vim with Motif or Athena.
Without it the toolbar and signs will be disabled.

The XPM library is provided by Arnaud Le Hors of the French National Institute
for Research in Computer Science and Control.  It can be downloaded from
http://cgit.freedesktop.org/xorg/lib/libXpm.  The current release, as of this
writing, is xpm-3.4k-solaris.tgz, which is a gzip'ed tar file.  If you create
the directory /usr/local/xpm and untar the file there you can use the
uncommented lines in the Makefile without changing them.  If you use another
xpm directory you will need to change the XPM_DIR in src/Makefile.

 vim:tw=78:ts=8:ft=help:norl:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/share/vim/vim74/evim.vim                                                                        0100644 0000000 0000000 00000003655 13050207306 014403  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim script for Evim key bindings
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2006 Mar 29

" Don't use Vi-compatible mode.
set nocompatible

" Use the mswin.vim script for most mappings
source <sfile>:p:h/mswin.vim

" Vim is in Insert mode by default
set insertmode

" Make a buffer hidden when editing another one
set hidden

" Make cursor keys ignore wrapping
inoremap <silent> <Down> <C-R>=pumvisible() ? "\<lt>Down>" : "\<lt>C-O>gj"<CR>
inoremap <silent> <Up> <C-R>=pumvisible() ? "\<lt>Up>" : "\<lt>C-O>gk"<CR>

" CTRL-F does Find dialog instead of page forward
noremap <silent> <C-F> :promptfind<CR>
vnoremap <silent> <C-F> y:promptfind <C-R>"<CR>
onoremap <silent> <C-F> <C-C>:promptfind<CR>
inoremap <silent> <C-F> <C-O>:promptfind<CR>
cnoremap <silent> <C-F> <C-C>:promptfind<CR>


set backspace=2		" allow backspacing over everything in insert mode
set autoindent		" always set autoindenting on
if has("vms")
  set nobackup		" do not keep a backup file, use versions instead
else
  set backup		" keep a backup file
endif
set history=50		" keep 50 lines of command line history
set ruler		" show the cursor position all the time
set incsearch		" do incremental searching
set mouse=a		" always use the mouse

" Don't use Ex mode, use Q for formatting
map Q gq

" Switch syntax highlighting on, when the terminal has colors
" Highlight the last used search pattern on the next search command.
if &t_Co > 2 || has("gui_running")
  syntax on
  set hlsearch
  nohlsearch
endif

" Only do this part when compiled with support for autocommands.
if has("autocmd")

  " Enable file type detection.
  " Use the default filetype settings, so that mail gets 'tw' set to 72,
  " 'cindent' is on in C files, etc.
  " Also load indent files, to automatically do language-dependent indenting.
  filetype plugin indent on

  " For all text files set 'textwidth' to 78 characters.
  au FileType text setlocal tw=78

endif " has("autocmd")

" vim: set sw=2 :
                                                                                   usr/share/vim/vim74/filetype.vim                                                                    0100644 0000000 0000000 00000210402 13050207306 015252  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim support file to detect file types
"
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2014 Oct 09

" Listen very carefully, I will say this only once
if exists("did_load_filetypes")
  finish
endif
let did_load_filetypes = 1

" Line continuation is used here, remove 'C' from 'cpoptions'
let s:cpo_save = &cpo
set cpo&vim

augroup filetypedetect

" Ignored extensions
if exists("*fnameescape")
au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew
	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
au BufNewFile,BufRead *~
	\ let s:name = expand("<afile>") |
	\ let s:short = substitute(s:name, '\~$', '', '') |
	\ if s:name != s:short && s:short != "" |
	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
	\ endif |
	\ unlet! s:name s:short
au BufNewFile,BufRead ?\+.in
	\ if expand("<afile>:t") != "configure.in" |
	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
	\ endif
elseif &verbose > 0
  echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
endif

" Pattern used to match file names which should not be inspected.
" Currently finds compressed files.
if !exists("g:ft_ignore_pat")
  let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
endif

" Function used for patterns that end in a star: don't set the filetype if the
" file name matches ft_ignore_pat.
func! s:StarSetf(ft)
  if expand("<amatch>") !~ g:ft_ignore_pat
    exe 'setf ' . a:ft
  endif
endfunc

" Abaqus or Trasys
au BufNewFile,BufRead *.inp			call s:Check_inp()

func! s:Check_inp()
  if getline(1) =~ '^\*'
    setf abaqus
  else
    let n = 1
    if line("$") > 500
      let nmax = 500
    else
      let nmax = line("$")
    endif
    while n <= nmax
      if getline(n) =~? "^header surface data"
	setf trasys
	break
      endif
      let n = n + 1
    endwhile
  endif
endfunc

" A-A-P recipe
au BufNewFile,BufRead *.aap			setf aap

" A2ps printing utility
au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps

" ABAB/4
au BufNewFile,BufRead *.abap			setf abap

" ABC music notation
au BufNewFile,BufRead *.abc			setf abc

" ABEL
au BufNewFile,BufRead *.abl			setf abel

" AceDB
au BufNewFile,BufRead *.wrm			setf acedb

" Ada (83, 9X, 95)
au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
if has("vms")
  au BufNewFile,BufRead *.gpr,*.ada_m,*.adc	setf ada
else
  au BufNewFile,BufRead *.gpr			setf ada
endif

" AHDL
au BufNewFile,BufRead *.tdf			setf ahdl

" AMPL
au BufNewFile,BufRead *.run			setf ampl

" Ant
au BufNewFile,BufRead build.xml			setf ant

" Arduino
au BufNewFile,BufRead *.ino,*.pde		setf arduino

" Apache style config file
au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')

" Apache config file
au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache

" XA65 MOS6510 cross assembler
au BufNewFile,BufRead *.a65			setf a65

" Applescript
au BufNewFile,BufRead *.scpt			setf applescript

" Applix ELF
au BufNewFile,BufRead *.am
	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif

" ALSA configuration
au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf

" Arc Macro Language
au BufNewFile,BufRead *.aml			setf aml

" APT config file
au BufNewFile,BufRead apt.conf		       setf aptconf
au BufNewFile,BufRead */.aptitude/config       setf aptconf
au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf

" Arch Inventory file
au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch

" ART*Enterprise (formerly ART-IM)
au BufNewFile,BufRead *.art			setf art

" AsciiDoc
au BufNewFile,BufRead *.asciidoc		setf asciidoc

" ASN.1
au BufNewFile,BufRead *.asn,*.asn1		setf asn

" Active Server Pages (with Visual Basic Script)
au BufNewFile,BufRead *.asa
	\ if exists("g:filetype_asa") |
	\   exe "setf " . g:filetype_asa |
	\ else |
	\   setf aspvbs |
	\ endif

" Active Server Pages (with Perl or Visual Basic Script)
au BufNewFile,BufRead *.asp
	\ if exists("g:filetype_asp") |
	\   exe "setf " . g:filetype_asp |
	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
	\   setf aspperl |
	\ else |
	\   setf aspvbs |
	\ endif

" Grub (must be before catch *.lst)
au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub

" Assembly (all kinds)
" *.lst is not pure assembly, it has two extra columns (address, byte codes)
au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call s:FTasm()

" This function checks for the kind of assembly that is wanted by the user, or
" can be detected from the first five lines of the file.
func! s:FTasm()
  " make sure b:asmsyntax exists
  if !exists("b:asmsyntax")
    let b:asmsyntax = ""
  endif

  if b:asmsyntax == ""
    call s:FTasmsyntax()
  endif

  " if b:asmsyntax still isn't set, default to asmsyntax or GNU
  if b:asmsyntax == ""
    if exists("g:asmsyntax")
      let b:asmsyntax = g:asmsyntax
    else
      let b:asmsyntax = "asm"
    endif
  endif

  exe "setf " . fnameescape(b:asmsyntax)
endfunc

func! s:FTasmsyntax()
  " see if file contains any asmsyntax=foo overrides. If so, change
  " b:asmsyntax appropriately
  let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
	\" ".getline(5)." "
  let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
  if match != ''
    let b:asmsyntax = match
  elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
    let b:asmsyntax = "vmasm"
  endif
endfunc

" Macro (VAX)
au BufNewFile,BufRead *.mar			setf vmasm

" Atlas
au BufNewFile,BufRead *.atl,*.as		setf atlas

" Autoit v3
au BufNewFile,BufRead *.au3			setf autoit

" Autohotkey
au BufNewFile,BufRead *.ahk			setf autohotkey

" Automake
au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake

" Autotest .at files are actually m4
au BufNewFile,BufRead *.at			setf m4

" Avenue
au BufNewFile,BufRead *.ave			setf ave

" Awk
au BufNewFile,BufRead *.awk			setf awk

" B
au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b

" BASIC or Visual Basic
au BufNewFile,BufRead *.bas			call s:FTVB("basic")

" Check if one of the first five lines contains "VB_Name".  In that case it is
" probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
func! s:FTVB(alt)
  if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
    setf vb
  else
    exe "setf " . a:alt
  endif
endfunc

" Visual Basic Script (close to Visual Basic) or Visual Basic .NET
au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb

" IBasic file (similar to QBasic)
au BufNewFile,BufRead *.iba,*.ibi		setf ibasic

" FreeBasic file (similar to QBasic)
au BufNewFile,BufRead *.fb,*.bi			setf freebasic

" Batch file for MSDOS.
au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
" *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
au BufNewFile,BufRead *.cmd
	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif

" Batch file for 4DOS
au BufNewFile,BufRead *.btm			call s:FTbtm()
func! s:FTbtm()
  if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
    setf dosbatch
  else
    setf btm
  endif
endfunc

" BC calculator
au BufNewFile,BufRead *.bc			setf bc

" BDF font
au BufNewFile,BufRead *.bdf			setf bdf

" BibTeX bibliography database file
au BufNewFile,BufRead *.bib			setf bib

" BibTeX Bibliography Style
au BufNewFile,BufRead *.bst			setf bst

" BIND configuration
au BufNewFile,BufRead named.conf,rndc.conf	setf named

" BIND zone
au BufNewFile,BufRead named.root		setf bindzone
au BufNewFile,BufRead *.db			call s:BindzoneCheck('')

func! s:BindzoneCheck(default)
  if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
    setf bindzone
  elseif a:default != ''
    exe 'setf ' . a:default
  endif
endfunc

" Blank
au BufNewFile,BufRead *.bl			setf blank

" Blkid cache file
au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml

" C or lpc
au BufNewFile,BufRead *.c			call s:FTlpc()

func! s:FTlpc()
  if exists("g:lpc_syntax_for_c")
    let lnum = 1
    while lnum <= 12
      if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
	setf lpc
	return
      endif
      let lnum = lnum + 1
    endwhile
  endif
  setf c
endfunc

" Calendar
au BufNewFile,BufRead calendar			setf calendar

" C#
au BufNewFile,BufRead *.cs			setf cs

" CSDL
au BufNewFile,BufRead *.csdl			setf csdl

" Cabal
au BufNewFile,BufRead *.cabal			setf cabal

" Cdrdao TOC
au BufNewFile,BufRead *.toc			setf cdrtoc

" Cdrdao config
au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf

" Cfengine
au BufNewFile,BufRead cfengine.conf		setf cfengine

" ChaiScript
au BufRead,BufNewFile *.chai			setf chaiscript

" Comshare Dimension Definition Language
au BufNewFile,BufRead *.cdl			setf cdl

" Conary Recipe
au BufNewFile,BufRead *.recipe			setf conaryrecipe

" Controllable Regex Mutilator
au BufNewFile,BufRead *.crm			setf crm

" Cyn++
au BufNewFile,BufRead *.cyn			setf cynpp

" Cynlib
" .cc and .cpp files can be C++ or Cynlib.
au BufNewFile,BufRead *.cc
	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
au BufNewFile,BufRead *.cpp
	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif

" C++
au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
if has("fname_case")
  au BufNewFile,BufRead *.C,*.H setf cpp
endif

" .h files can be C, Ch C++, ObjC or ObjC++.
" Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
" detected automatically.
au BufNewFile,BufRead *.h			call s:FTheader()

func! s:FTheader()
  if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
    if exists("g:c_syntax_for_h")
      setf objc
    else
      setf objcpp
    endif
  elseif exists("g:c_syntax_for_h")
    setf c
  elseif exists("g:ch_syntax_for_h")
    setf ch
  else
    setf cpp
  endif
endfunc

" Ch (CHscript)
au BufNewFile,BufRead *.chf			setf ch

" TLH files are C++ headers generated by Visual C++'s #import from typelibs
au BufNewFile,BufRead *.tlh			setf cpp

" Cascading Style Sheets
au BufNewFile,BufRead *.css			setf css

" Century Term Command Scripts (*.cmd too)
au BufNewFile,BufRead *.con			setf cterm

" Changelog
au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
					\	setf debchangelog

au BufNewFile,BufRead [cC]hange[lL]og
	\  if getline(1) =~ '; urgency='
	\|   setf debchangelog
	\| else
	\|   setf changelog
	\| endif

au BufNewFile,BufRead NEWS
	\  if getline(1) =~ '; urgency='
	\|   setf debchangelog
	\| endif

" CHILL
au BufNewFile,BufRead *..ch			setf chill

" Changes for WEB and CWEB or CHILL
au BufNewFile,BufRead *.ch			call s:FTchange()

" This function checks if one of the first ten lines start with a '@'.  In
" that case it is probably a change file.
" If the first line starts with # or ! it's probably a ch file.
" If a line has "main", "include", "//" ir "/*" it's probably ch.
" Otherwise CHILL is assumed.
func! s:FTchange()
  let lnum = 1
  while lnum <= 10
    if getline(lnum)[0] == '@'
      setf change
      return
    endif
    if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
      setf ch
      return
    endif
    if getline(lnum) =~ "MODULE"
      setf chill
      return
    endif
    if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
      setf ch
      return
    endif
    let lnum = lnum + 1
  endwhile
  setf chill
endfunc

" ChordPro
au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro

" Clean
au BufNewFile,BufRead *.dcl,*.icl		setf clean

" Clever
au BufNewFile,BufRead *.eni			setf cl

" Clever or dtd
au BufNewFile,BufRead *.ent			call s:FTent()

func! s:FTent()
  " This function checks for valid cl syntax in the first five lines.
  " Look for either an opening comment, '#', or a block start, '{".
  " If not found, assume SGML.
  let lnum = 1
  while lnum < 6
    let line = getline(lnum)
    if line =~ '^\s*[#{]'
      setf cl
      return
    elseif line !~ '^\s*$'
      " Not a blank line, not a comment, and not a block start,
      " so doesn't look like valid cl code.
      break
    endif
    let lnum = lnum + 1
  endw
  setf dtd
endfunc

" Clipper (or FoxPro; could also be eviews)
au BufNewFile,BufRead *.prg
	\ if exists("g:filetype_prg") |
	\   exe "setf " . g:filetype_prg |
	\ else |
	\   setf clipper |
	\ endif

" Clojure
au BufNewFile,BufRead *.clj,*.cljs		setf clojure

" Cmake
au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake

" Cmusrc
au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc

" Cobol
au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
"   cobol or zope form controller python script? (heuristic)
au BufNewFile,BufRead *.cpy
	\ if getline(1) =~ '^##' |
	\   setf python |
	\ else |
	\   setf cobol |
	\ endif

" Coco/R
au BufNewFile,BufRead *.atg			setf coco

" Cold Fusion
au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf

" Configure scripts
au BufNewFile,BufRead configure.in,configure.ac setf config

" CUDA  Cumpute Unified Device Architecture
au BufNewFile,BufRead *.cu			setf cuda

" Dockerfile
au BufNewFile,BufRead Dockerfile		setf dockerfile

" WildPackets EtherPeek Decoder
au BufNewFile,BufRead *.dcd			setf dcd

" Enlightenment configuration files
au BufNewFile,BufRead *enlightenment/*.cfg	setf c

" Eterm
au BufNewFile,BufRead *Eterm/*.cfg		setf eterm

" Euphoria 3 or 4
au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
if has("fname_case")
   au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
endif

func! s:EuphoriaCheck()
  if exists('g:filetype_euphoria')
    exe 'setf ' . g:filetype_euphoria
  else
    setf euphoria3
  endif
endfunc

" Lynx config files
au BufNewFile,BufRead lynx.cfg			setf lynx

" Quake
au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake

" Quake C
au BufNewFile,BufRead *.qc			setf c

" Configure files
au BufNewFile,BufRead *.cfg			setf cfg

" Cucumber
au BufNewFile,BufRead *.feature			setf cucumber

" Communicating Sequential Processes
au BufNewFile,BufRead *.csp,*.fdr		setf csp

" CUPL logic description and simulation
au BufNewFile,BufRead *.pld			setf cupl
au BufNewFile,BufRead *.si			setf cuplsim

" Debian Control
au BufNewFile,BufRead */debian/control		setf debcontrol
au BufNewFile,BufRead control
	\  if getline(1) =~ '^Source:'
	\|   setf debcontrol
	\| endif

" Debian Sources.list
au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources

" Deny hosts
au BufNewFile,BufRead denyhosts.conf		setf denyhosts

" dnsmasq(8) configuration files
au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq

" ROCKLinux package description
au BufNewFile,BufRead *.desc			setf desc

" the D language or dtrace
au BufNewFile,BufRead *.d			call s:DtraceCheck()

func! s:DtraceCheck()
  let lines = getline(1, min([line("$"), 100]))
  if match(lines, '^module\>\|^import\>') > -1
    " D files often start with a module and/or import statement.
    setf d
  elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
    setf dtrace
  else
    setf d
  endif
endfunc

" Desktop files
au BufNewFile,BufRead *.desktop,.directory	setf desktop

" Dict config
au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf

" Dictd config
au BufNewFile,BufRead dictd.conf		setf dictdconf

" Diff files
au BufNewFile,BufRead *.diff,*.rej,*.patch	setf diff

" Dircolors
au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors

" Diva (with Skill) or InstallShield
au BufNewFile,BufRead *.rul
	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
	\   setf ishd |
	\ else |
	\   setf diva |
	\ endif

" DCL (Digital Command Language - vms) or DNS zone file
au BufNewFile,BufRead *.com			call s:BindzoneCheck('dcl')

" DOT
au BufNewFile,BufRead *.dot			setf dot

" Dylan - lid files
au BufNewFile,BufRead *.lid			setf dylanlid

" Dylan - intr files (melange)
au BufNewFile,BufRead *.intr			setf dylanintr

" Dylan
au BufNewFile,BufRead *.dylan			setf dylan

" Microsoft Module Definition
au BufNewFile,BufRead *.def			setf def

" Dracula
au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula

" Datascript
au BufNewFile,BufRead *.ds			setf datascript

" dsl
au BufNewFile,BufRead *.dsl			setf dsl

" DTD (Document Type Definition for XML)
au BufNewFile,BufRead *.dtd			setf dtd

" DTS/DSTI (device tree files)
au BufNewFile,BufRead *.dts,*.dtsi		setf dts

" EDIF (*.edf,*.edif,*.edn,*.edo)
au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)	setf edif

" Embedix Component Description
au BufNewFile,BufRead *.ecd			setf ecd

" Eiffel or Specman or Euphoria
au BufNewFile,BufRead *.e,*.E			call s:FTe()

" Elinks configuration
au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks

func! s:FTe()
  if exists('g:filetype_euphoria')
    exe 'setf ' . g:filetype_euphoria
  else
    let n = 1
    while n < 100 && n < line("$")
      if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
        setf specman
        return
      endif
      let n = n + 1
    endwhile
    setf eiffel
  endif
endfunc

" ERicsson LANGuage; Yaws is erlang too
au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang

" Elm Filter Rules file
au BufNewFile,BufRead filter-rules		setf elmfilt

" ESMTP rc file
au BufNewFile,BufRead *esmtprc			setf esmtprc

" ESQL-C
au BufNewFile,BufRead *.ec,*.EC			setf esqlc

" Esterel
au BufNewFile,BufRead *.strl			setf esterel

" Essbase script
au BufNewFile,BufRead *.csc			setf csc

" Exim
au BufNewFile,BufRead exim.conf			setf exim

" Expect
au BufNewFile,BufRead *.exp			setf expect

" Exports
au BufNewFile,BufRead exports			setf exports

" Falcon
au BufNewFile,BufRead *.fal			setf falcon

" Fantom
au BufNewFile,BufRead *.fan,*.fwt		setf fan

" Factor
au BufNewFile,BufRead *.factor			setf factor

" Fetchmail RC file
au BufNewFile,BufRead .fetchmailrc		setf fetchmail

" FlexWiki - disabled, because it has side effects when a .wiki file
" is not actually FlexWiki
"au BufNewFile,BufRead *.wiki			setf flexwiki

" Focus Executable
au BufNewFile,BufRead *.fex,*.focexec		setf focexec

" Focus Master file (but not for auto.master)
au BufNewFile,BufRead auto.master		setf conf
au BufNewFile,BufRead *.mas,*.master		setf master

" Forth
au BufNewFile,BufRead *.fs,*.ft			setf forth

" Reva Forth
au BufNewFile,BufRead *.frt			setf reva

" Fortran
if has("fname_case")
  au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
endif
au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran

" Framescript
au BufNewFile,BufRead *.fsl			setf framescript

" FStab
au BufNewFile,BufRead fstab,mtab		setf fstab

" GDB command files
au BufNewFile,BufRead .gdbinit			setf gdb

" GDMO
au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo

" Gedcom
au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom

" Git
au BufNewFile,BufRead *.git/COMMIT_EDITMSG	setf gitcommit
au BufNewFile,BufRead *.git/MERGE_MSG		setf gitcommit
au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
au BufNewFile,BufRead *.git/modules/*/COMMIT_EDITMSG setf gitcommit
au BufNewFile,BufRead *.git/modules/*/config	setf gitconfig
au BufNewFile,BufRead */.config/git/config	setf gitconfig
au BufNewFile,BufRead git-rebase-todo		setf gitrebase
au BufNewFile,BufRead .msg.[0-9]*
      \ if getline(1) =~ '^From.*# This line is ignored.$' |
      \   setf gitsendemail |
      \ endif
au BufNewFile,BufRead *.git/*
      \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
      \   setf git |
      \ endif

" Gkrellmrc
au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc

" GP scripts (2.0 and onward)
au BufNewFile,BufRead *.gp,.gprc		setf gp

" GPG
au BufNewFile,BufRead */.gnupg/options		setf gpg
au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg

" gnash(1) configuration files
au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash

" Gitolite
au BufNewFile,BufRead gitolite.conf		setf gitolite
au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl

" Gnuplot scripts
au BufNewFile,BufRead *.gpi			setf gnuplot

" Go (Google)
au BufNewFile,BufRead *.go			setf go

" GrADS scripts
au BufNewFile,BufRead *.gs			setf grads

" Gretl
au BufNewFile,BufRead *.gretl			setf gretl

" Groovy
au BufNewFile,BufRead *.groovy			setf groovy

" GNU Server Pages
au BufNewFile,BufRead *.gsp			setf gsp

" Group file
au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group

" GTK RC
au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc

" Haml
au BufNewFile,BufRead *.haml			setf haml

" Hamster Classic | Playground files
au BufNewFile,BufRead *.hsc,*.hsm		setf hamster

" Haskell
au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
au BufNewFile,BufRead *.lhs			setf lhaskell
au BufNewFile,BufRead *.chs			setf chaskell

" Haste
au BufNewFile,BufRead *.ht			setf haste
au BufNewFile,BufRead *.htpp			setf hastepreproc

" Hercules
au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum	setf hercules

" HEX (Intel)
au BufNewFile,BufRead *.hex,*.h32		setf hex

" Tilde (must be before HTML)
au BufNewFile,BufRead *.t.html			setf tilde

" HTML (.shtml and .stm for server side)
au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()

" Distinguish between HTML, XHTML and Django
func! s:FThtml()
  let n = 1
  while n < 10 && n < line("$")
    if getline(n) =~ '\<DTD\s\+XHTML\s'
      setf xhtml
      return
    endif
    if getline(n) =~ '{%\s*\(extends\|block\|load\)\>'
      setf htmldjango
      return
    endif
    let n = n + 1
  endwhile
  setf html
endfunc

" HTML with Ruby - eRuby
au BufNewFile,BufRead *.erb,*.rhtml		setf eruby

" HTML with M4
au BufNewFile,BufRead *.html.m4			setf htmlm4

" HTML Cheetah template
au BufNewFile,BufRead *.tmpl			setf htmlcheetah

" Host config
au BufNewFile,BufRead */etc/host.conf		setf hostconf

" Hosts access
au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess

" Hyper Builder
au BufNewFile,BufRead *.hb			setf hb

" Httest
au BufNewFile,BufRead *.htt,*.htb		setf httest

" Icon
au BufNewFile,BufRead *.icn			setf icon

" IDL (Interface Description Language)
au BufNewFile,BufRead *.idl			call s:FTidl()

" Distinguish between standard IDL and MS-IDL
func! s:FTidl()
  let n = 1
  while n < 50 && n < line("$")
    if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
      setf msidl
      return
    endif
    let n = n + 1
  endwhile
  setf idl
endfunc

" Microsoft IDL (Interface Description Language)  Also *.idl
" MOF = WMI (Windows Management Instrumentation) Managed Object Format
au BufNewFile,BufRead *.odl,*.mof		setf msidl

" Icewm menu
au BufNewFile,BufRead */.icewm/menu		setf icemenu

" Indent profile (must come before IDL *.pro!)
au BufNewFile,BufRead .indent.pro		setf indent
au BufNewFile,BufRead indent.pro		call s:ProtoCheck('indent')

" IDL (Interactive Data Language)
au BufNewFile,BufRead *.pro			call s:ProtoCheck('idlang')

" Distinguish between "default" and Cproto prototype file. */
func! s:ProtoCheck(default)
  " Cproto files have a comment in the first line and a function prototype in
  " the second line, it always ends in ";".  Indent files may also have
  " comments, thus we can't match comments to see the difference.
  " IDL files can have a single ';' in the second line, require at least one
  " chacter before the ';'.
  if getline(2) =~ '.;$'
    setf cpp
  else
    exe 'setf ' . a:default
  endif
endfunc


" Indent RC
au BufNewFile,BufRead indentrc			setf indent

" Inform
au BufNewFile,BufRead *.inf,*.INF		setf inform

" Initng
au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng

" Innovation Data Processing
au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c 	setf upstreamdat
au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c 	setf upstreamlog
au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c 	setf usserverlog
au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c 	setf usw2kagtlog

" Ipfilter
au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter

" Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl

" .INI file for MSDOS
au BufNewFile,BufRead *.ini			setf dosini

" SysV Inittab
au BufNewFile,BufRead inittab			setf inittab

" Inno Setup
au BufNewFile,BufRead *.iss			setf iss

" J
au BufNewFile,BufRead *.ijs			setf j

" JAL
au BufNewFile,BufRead *.jal,*.JAL		setf jal

" Jam
au BufNewFile,BufRead *.jpl,*.jpr		setf jam

" Java
au BufNewFile,BufRead *.java,*.jav		setf java

" JavaCC
au BufNewFile,BufRead *.jj,*.jjt		setf javacc

" JavaScript, ECMAScript
au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript

" Java Server Pages
au BufNewFile,BufRead *.jsp			setf jsp

" Java Properties resource file (note: doesn't catch font.properties.pl)
au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')

" Jess
au BufNewFile,BufRead *.clp			setf jess

" Jgraph
au BufNewFile,BufRead *.jgr			setf jgraph

" Jovial
au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial

" JSON
au BufNewFile,BufRead *.json,*.jsonp		setf json

" Kixtart
au BufNewFile,BufRead *.kix			setf kix

" Kimwitu[++]
au BufNewFile,BufRead *.k			setf kwt

" Kivy
au BufNewFile,BufRead *.kv			setf kivy

" KDE script
au BufNewFile,BufRead *.ks			setf kscript

" Kconfig
au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig

" Lace (ISE)
au BufNewFile,BufRead *.ace,*.ACE		setf lace

" Latte
au BufNewFile,BufRead *.latte,*.lte		setf latte

" Limits
au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits

" LambdaProlog (*.mod too, see Modsim)
au BufNewFile,BufRead *.sig			setf lprolog

" LDAP LDIF
au BufNewFile,BufRead *.ldif			setf ldif

" Ld loader
au BufNewFile,BufRead *.ld			setf ld

" Lex
au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex

" Libao
au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao

" Libsensors
au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors

" LFTP
au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp

" Lifelines (or Lex for C++!)
au BufNewFile,BufRead *.ll			setf lifelines

" Lilo: Linux loader
au BufNewFile,BufRead lilo.conf			setf lilo

" Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
if has("fname_case")
  au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
else
  au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
endif

" SBCL implementation of Common Lisp
au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp

" Liquid
au BufNewFile,BufRead *.liquid			setf liquid

" Lite
au BufNewFile,BufRead *.lite,*.lt		setf lite

" LiteStep RC files
au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep

" Login access
au BufNewFile,BufRead */etc/login.access	setf loginaccess

" Login defs
au BufNewFile,BufRead */etc/login.defs		setf logindefs

" Logtalk
au BufNewFile,BufRead *.lgt			setf logtalk

" LOTOS
au BufNewFile,BufRead *.lot,*.lotos		setf lotos

" Lout (also: *.lt)
au BufNewFile,BufRead *.lou,*.lout		setf lout

" Lua
au BufNewFile,BufRead *.lua			setf lua

" Luarocks
au BufNewFile,BufRead *.rockspec		setf lua

" Linden Scripting Language (Second Life)
au BufNewFile,BufRead *.lsl			setf lsl

" Lynx style file (or LotusScript!)
au BufNewFile,BufRead *.lss			setf lss

" M4
au BufNewFile,BufRead *.m4
	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif

" MaGic Point
au BufNewFile,BufRead *.mgp			setf mgp

" Mail (for Elm, trn, mutt, muttng, rn, slrn)
au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail

" Mail aliases
au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases

" Mailcap configuration file
au BufNewFile,BufRead .mailcap,mailcap		setf mailcap

" Makefile
au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make

" MakeIndex
au BufNewFile,BufRead *.ist,*.mst		setf ist

" Mallard
au BufNewFile,BufRead *.page			setf mallard

" Manpage
au BufNewFile,BufRead *.man			setf man

" Man config
au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf

" Maple V
au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple

" Map (UMN mapserver config file)
au BufNewFile,BufRead *.map			setf map

" Markdown
au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown

" Mason
au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason

" Matlab or Objective C
au BufNewFile,BufRead *.m			call s:FTm()

func! s:FTm()
  let n = 1
  while n < 10
    let line = getline(n)
    if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\|//\)'
      setf objc
      return
    endif
    if line =~ '^\s*%'
      setf matlab
      return
    endif
    if line =~ '^\s*(\*'
      setf mma
      return
    endif
    let n = n + 1
  endwhile
  if exists("g:filetype_m")
    exe "setf " . g:filetype_m
  else
    setf matlab
  endif
endfunc

" Mathematica notebook
au BufNewFile,BufRead *.nb			setf mma

" Maya Extension Language
au BufNewFile,BufRead *.mel			setf mel

" Mercurial (hg) commit file
au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit

" Mercurial config (looks like generic config file)
au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg

" Messages (logs mostly)
au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages

" Metafont
au BufNewFile,BufRead *.mf			setf mf

" MetaPost
au BufNewFile,BufRead *.mp			setf mp

" MGL
au BufNewFile,BufRead *.mgl			setf mgl

" MIX - Knuth assembly
au BufNewFile,BufRead *.mix,*.mixal		setf mix

" MMIX or VMS makefile
au BufNewFile,BufRead *.mms			call s:FTmms()

" Symbian meta-makefile definition (MMP)
au BufNewFile,BufRead *.mmp			setf mmp

func! s:FTmms()
  let n = 1
  while n < 10
    let line = getline(n)
    if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
      setf mmix
      return
    endif
    if line =~ '^\s*#'
      setf make
      return
    endif
    let n = n + 1
  endwhile
  setf mmix
endfunc


" Modsim III (or LambdaProlog)
au BufNewFile,BufRead *.mod
	\ if getline(1) =~ '\<module\>' |
	\   setf lprolog |
	\ else |
	\   setf modsim3 |
	\ endif

" Modula 2  (.md removed in favor of Markdown)
au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi	setf modula2

" Modula 3 (.m3, .i3, .mg, .ig)
au BufNewFile,BufRead *.[mi][3g]		setf modula3

" Monk
au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk

" MOO
au BufNewFile,BufRead *.moo			setf moo

" Modconf
au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf

" Mplayer config
au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf

" Moterola S record
au BufNewFile,BufRead *.s19,*.s28,*.s37		setf srec

" Mrxvtrc
au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc

" Msql
au BufNewFile,BufRead *.msql			setf msql

" Mysql
au BufNewFile,BufRead *.mysql			setf mysql

" Mutt setup files (must be before catch *.rc)
au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')

" M$ Resource files
au BufNewFile,BufRead *.rc,*.rch		setf rc

" MuPAD source
au BufRead,BufNewFile *.mu			setf mupad

" Mush
au BufNewFile,BufRead *.mush			setf mush

" Mutt setup file (also for Muttng)
au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc

" Nano
au BufNewFile,BufRead */etc/nanorc,.nanorc	setf nanorc

" Nastran input/DMAP
"au BufNewFile,BufRead *.dat			setf nastran

" Natural
au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural

" Netrc
au BufNewFile,BufRead .netrc			setf netrc

" Ninja file
au BufNewFile,BufRead *.ninja			setf ninja

" Novell netware batch files
au BufNewFile,BufRead *.ncf			setf ncf

" Nroff/Troff (*.ms and *.t are checked below)
au BufNewFile,BufRead *.me
	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
	\   setf nroff |
	\ endif
au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
au BufNewFile,BufRead *.[1-9]			call s:FTnroff()

" This function checks if one of the first five lines start with a dot.  In
" that case it is probably an nroff file: 'filetype' is set and 1 is returned.
func! s:FTnroff()
  if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
    setf nroff
    return 1
  endif
  return 0
endfunc

" Nroff or Objective C++
au BufNewFile,BufRead *.mm			call s:FTmm()

func! s:FTmm()
  let n = 1
  while n < 10
    let line = getline(n)
    if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\)'
      setf objcpp
      return
    endif
    let n = n + 1
  endwhile
  setf nroff
endfunc

" Not Quite C
au BufNewFile,BufRead *.nqc			setf nqc

" NSIS
au BufNewFile,BufRead *.nsi,*.nsh		setf nsis

" OCAML
au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml

" Occam
au BufNewFile,BufRead *.occ			setf occam

" Omnimark
au BufNewFile,BufRead *.xom,*.xin		setf omnimark

" OpenROAD
au BufNewFile,BufRead *.or			setf openroad

" OPL
au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl

" Oracle config file
au BufNewFile,BufRead *.ora			setf ora

" Packet filter conf
au BufNewFile,BufRead pf.conf			setf pf

" Pam conf
au BufNewFile,BufRead */etc/pam.conf		setf pamconf

" PApp
au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp

" Password file
au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd

" Pascal (also *.p)
au BufNewFile,BufRead *.pas			setf pascal

" Delphi project file
au BufNewFile,BufRead *.dpr			setf pascal

" PDF
au BufNewFile,BufRead *.pdf			setf pdf

" Perl
if has("fname_case")
  au BufNewFile,BufRead *.pl,*.PL		call s:FTpl()
else
  au BufNewFile,BufRead *.pl			call s:FTpl()
endif
au BufNewFile,BufRead *.plx,*.al		setf perl
au BufNewFile,BufRead *.p6,*.pm6		setf perl6

func! s:FTpl()
  if exists("g:filetype_pl")
    exe "setf " . g:filetype_pl
  else
    " recognize Prolog by specific text in the first non-empty line
    " require a blank after the '%' because Perl uses "%list" and "%translate"
    let l = getline(nextnonblank(1))
    if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
      setf prolog
    else
      setf perl
    endif
  endif
endfunc

" Perl, XPM or XPM2
au BufNewFile,BufRead *.pm
	\ if getline(1) =~ "XPM2" |
	\   setf xpm2 |
	\ elseif getline(1) =~ "XPM" |
	\   setf xpm |
	\ else |
	\   setf perl |
	\ endif

" Perl POD
au BufNewFile,BufRead *.pod			setf pod

" Php, php3, php4, etc.
" Also Phtml (was used for PHP 2 in the past)
" Also .ctp for Cake template file
au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php

" Pike
au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike

" Pinfo config
au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo

" Palm Resource compiler
au BufNewFile,BufRead *.rcp			setf pilrc

" Pine config
au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine

" PL/1, PL/I
au BufNewFile,BufRead *.pli,*.pl1		setf pli

" PL/M (also: *.inp)
au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm

" PL/SQL
au BufNewFile,BufRead *.pls,*.plsql		setf plsql

" PLP
au BufNewFile,BufRead *.plp			setf plp

" PO and PO template (GNU gettext)
au BufNewFile,BufRead *.po,*.pot		setf po

" Postfix main config
au BufNewFile,BufRead main.cf			setf pfmain

" PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr

" PostScript Printer Description
au BufNewFile,BufRead *.ppd			setf ppd

" Povray
au BufNewFile,BufRead *.pov			setf pov

" Povray configuration
au BufNewFile,BufRead .povrayrc			setf povini

" Povray, PHP or assembly
au BufNewFile,BufRead *.inc			call s:FTinc()

func! s:FTinc()
  if exists("g:filetype_inc")
    exe "setf " . g:filetype_inc
  else
    let lines = getline(1).getline(2).getline(3)
    if lines =~? "perlscript"
      setf aspperl
    elseif lines =~ "<%"
      setf aspvbs
    elseif lines =~ "<?"
      setf php
    else
      call s:FTasmsyntax()
      if exists("b:asmsyntax")
	exe "setf " . fnameescape(b:asmsyntax)
      else
	setf pov
      endif
    endif
  endif
endfunc

" Printcap and Termcap
au BufNewFile,BufRead *printcap
	\ let b:ptcap_type = "print" | setf ptcap
au BufNewFile,BufRead *termcap
	\ let b:ptcap_type = "term" | setf ptcap

" PCCTS / ANTRL
"au BufNewFile,BufRead *.g			setf antrl
au BufNewFile,BufRead *.g			setf pccts

" PPWizard
au BufNewFile,BufRead *.it,*.ih			setf ppwiz

" Obj 3D file format
" TODO: is there a way to avoid MS-Windows Object files?
au BufNewFile,BufRead *.obj			setf obj

" Oracle Pro*C/C++
au BufNewFile,BufRead *.pc			setf proc

" Privoxy actions file
au BufNewFile,BufRead *.action			setf privoxy

" Procmail
au BufNewFile,BufRead .procmail,.procmailrc	setf procmail

" Progress or CWEB
au BufNewFile,BufRead *.w			call s:FTprogress_cweb()

func! s:FTprogress_cweb()
  if exists("g:filetype_w")
    exe "setf " . g:filetype_w
    return
  endif
  if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
    setf progress
  else
    setf cweb
  endif
endfunc

" Progress or assembly
au BufNewFile,BufRead *.i			call s:FTprogress_asm()

func! s:FTprogress_asm()
  if exists("g:filetype_i")
    exe "setf " . g:filetype_i
    return
  endif
  " This function checks for an assembly comment the first ten lines.
  " If not found, assume Progress.
  let lnum = 1
  while lnum <= 10 && lnum < line('$')
    let line = getline(lnum)
    if line =~ '^\s*;' || line =~ '^\*'
      call s:FTasm()
      return
    elseif line !~ '^\s*$' || line =~ '^/\*'
      " Not an empty line: Doesn't look like valid assembly code.
      " Or it looks like a Progress /* comment
      break
    endif
    let lnum = lnum + 1
  endw
  setf progress
endfunc

" Progress or Pascal
au BufNewFile,BufRead *.p			call s:FTprogress_pascal()

func! s:FTprogress_pascal()
  if exists("g:filetype_p")
    exe "setf " . g:filetype_p
    return
  endif
  " This function checks for valid Pascal syntax in the first ten lines.
  " Look for either an opening comment or a program start.
  " If not found, assume Progress.
  let lnum = 1
  while lnum <= 10 && lnum < line('$')
    let line = getline(lnum)
    if line =~ '^\s*\(program\|unit\|procedure\|function\|const\|type\|var\)\>'
	\ || line =~ '^\s*{' || line =~ '^\s*(\*'
      setf pascal
      return
    elseif line !~ '^\s*$' || line =~ '^/\*'
      " Not an empty line: Doesn't look like valid Pascal code.
      " Or it looks like a Progress /* comment
      break
    endif
    let lnum = lnum + 1
  endw
  setf progress
endfunc


" Software Distributor Product Specification File (POSIX 1387.2-1995)
au BufNewFile,BufRead *.psf			setf psf
au BufNewFile,BufRead INDEX,INFO
	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
	\   setf psf |
	\ endif

" Prolog
au BufNewFile,BufRead *.pdb			setf prolog

" Promela
au BufNewFile,BufRead *.pml			setf promela

" Google protocol buffers
au BufNewFile,BufRead *.proto			setf proto

" Protocols
au BufNewFile,BufRead */etc/protocols		setf protocols

" Pyrex
au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex

" Python
au BufNewFile,BufRead *.py,*.pyw		setf python

" Quixote (Python-based web framework)
au BufNewFile,BufRead *.ptl			setf python

" Radiance
au BufNewFile,BufRead *.rad,*.mat		setf radiance

" Ratpoison config/command files
au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison

" RCS file
au BufNewFile,BufRead *\,v			setf rcs

" Readline
au BufNewFile,BufRead .inputrc,inputrc		setf readline

" Registry for MS-Windows
au BufNewFile,BufRead *.reg
	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif

" Renderman Interface Bytestream
au BufNewFile,BufRead *.rib			setf rib

" Rexx
au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx

" R (Splus)
if has("fname_case")
  au BufNewFile,BufRead *.s,*.S			setf r
else
  au BufNewFile,BufRead *.s			setf r
endif

" R Help file
if has("fname_case")
  au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
else
  au BufNewFile,BufRead *.rd			setf rhelp
endif

" R noweb file
if has("fname_case")
  au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
else
  au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
endif

" R Markdown file
if has("fname_case")
  au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
else
  au BufNewFile,BufRead *.rmd,*.smd			setf rmd
endif

" R reStructuredText file
if has("fname_case")
  au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
else
  au BufNewFile,BufRead *.rrst,*.srst			setf rrst
endif

" Rexx, Rebol or R
au BufNewFile,BufRead *.r,*.R			call s:FTr()

func! s:FTr()
  let max = line("$") > 50 ? 50 : line("$")

  for n in range(1, max)
    " Rebol is easy to recognize, check for that first
    if getline(n) =~? '\<REBOL\>'
      setf rebol
      return
    endif
  endfor

  for n in range(1, max)
    " R has # comments
    if getline(n) =~ '^\s*#'
      setf r
      return
    endif
    " Rexx has /* comments */
    if getline(n) =~ '^\s*/\*'
      setf rexx
      return
    endif
  endfor

  " Nothing recognized, use user default or assume Rexx
  if exists("g:filetype_r")
    exe "setf " . g:filetype_r
  else
    " Rexx used to be the default, but R appears to be much more popular.
    setf r
  endif
endfunc

" Remind
au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind

" Resolv.conf
au BufNewFile,BufRead resolv.conf		setf resolv

" Relax NG Compact
au BufNewFile,BufRead *.rnc			setf rnc

" Relax NG XML
au BufNewFile,BufRead *.rng			setf rng

" RPL/2
au BufNewFile,BufRead *.rpl			setf rpl

" Robots.txt
au BufNewFile,BufRead robots.txt		setf robots

" Rpcgen
au BufNewFile,BufRead *.x			setf rpcgen

" reStructuredText Documentation Format
au BufNewFile,BufRead *.rst			setf rst

" RTF
au BufNewFile,BufRead *.rtf			setf rtf

" Interactive Ruby shell
au BufNewFile,BufRead .irbrc,irbrc		setf ruby

" Ruby
au BufNewFile,BufRead *.rb,*.rbw		setf ruby

" RubyGems
au BufNewFile,BufRead *.gemspec			setf ruby

" Rackup
au BufNewFile,BufRead *.ru			setf ruby

" Bundler
au BufNewFile,BufRead Gemfile			setf ruby

" Ruby on Rails
au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby

" Rantfile and Rakefile is like Ruby
au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby

" S-lang (or shader language, or SmallLisp)
au BufNewFile,BufRead *.sl			setf slang

" Samba config
au BufNewFile,BufRead smb.conf			setf samba

" SAS script
au BufNewFile,BufRead *.sas			setf sas

" Sass
au BufNewFile,BufRead *.sass			setf sass

" Sather
au BufNewFile,BufRead *.sa			setf sather

" Scilab
au BufNewFile,BufRead *.sci,*.sce		setf scilab

" SCSS
au BufNewFile,BufRead *.scss			setf scss

" SD: Streaming Descriptors
au BufNewFile,BufRead *.sd			setf sd

" SDL
au BufNewFile,BufRead *.sdl,*.pr		setf sdl

" sed
au BufNewFile,BufRead *.sed			setf sed

" Sieve (RFC 3028)
au BufNewFile,BufRead *.siv			setf sieve

" Sendmail
au BufNewFile,BufRead sendmail.cf		setf sm

" Sendmail .mc files are actually m4.  Could also be MS Message text file.
au BufNewFile,BufRead *.mc			call s:McSetf()

func! s:McSetf()
  " Rely on the file to start with a comment.
  " MS message text files use ';', Sendmail files use '#' or 'dnl'
  for lnum in range(1, min([line("$"), 20]))
    let line = getline(lnum)
    if line =~ '^\s*\(#\|dnl\)'
      setf m4  " Sendmail .mc file
      return
    elseif line =~ '^\s*;'
      setf msmessages  " MS Message text file
      return
    endif
  endfor
  setf m4  " Default: Sendmail .mc file
endfunc

" Services
au BufNewFile,BufRead */etc/services		setf services

" Service Location config
au BufNewFile,BufRead */etc/slp.conf		setf slpconf

" Service Location registration
au BufNewFile,BufRead */etc/slp.reg		setf slpreg

" Service Location SPI
au BufNewFile,BufRead */etc/slp.spi		setf slpspi

" Setserial config
au BufNewFile,BufRead */etc/serial.conf		setf setserial

" SGML
au BufNewFile,BufRead *.sgm,*.sgml
	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
	\   setf sgmllnx |
	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
	\   let b:docbk_type = "sgml" |
	\   let b:docbk_ver = 4 |
	\   setf docbk |
	\ else |
	\   setf sgml |
	\ endif

" SGMLDECL
au BufNewFile,BufRead *.decl,*.dcl,*.dec
	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
	\    setf sgmldecl |
	\ endif

" SGML catalog file
au BufNewFile,BufRead catalog			setf catalog
au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')

" Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
" Gentoo ebuilds are actually bash scripts
au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH("bash")
au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))

" Also called from scripts.vim.
func! SetFileTypeSH(name)
  if expand("<amatch>") =~ g:ft_ignore_pat
    return
  endif
  if a:name =~ '\<csh\>'
    " Some .sh scripts contain #!/bin/csh.
    call SetFileTypeShell("csh")
    return
  elseif a:name =~ '\<tcsh\>'
    " Some .sh scripts contain #!/bin/tcsh.
    call SetFileTypeShell("tcsh")
    return
  elseif a:name =~ '\<zsh\>'
    " Some .sh scripts contain #!/bin/zsh.
    call SetFileTypeShell("zsh")
    return
  elseif a:name =~ '\<ksh\>'
    let b:is_kornshell = 1
    if exists("b:is_bash")
      unlet b:is_bash
    endif
    if exists("b:is_sh")
      unlet b:is_sh
    endif
  elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
    let b:is_bash = 1
    if exists("b:is_kornshell")
      unlet b:is_kornshell
    endif
    if exists("b:is_sh")
      unlet b:is_sh
    endif
  elseif a:name =~ '\<sh\>'
    let b:is_sh = 1
    if exists("b:is_kornshell")
      unlet b:is_kornshell
    endif
    if exists("b:is_bash")
      unlet b:is_bash
    endif
  endif
  call SetFileTypeShell("sh")
endfunc

" For shell-like file types, check for an "exec" command hidden in a comment,
" as used for Tcl.
" Also called from scripts.vim, thus can't be local to this script.
func! SetFileTypeShell(name)
  if expand("<amatch>") =~ g:ft_ignore_pat
    return
  endif
  let l = 2
  while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
    " Skip empty and comment lines.
    let l = l + 1
  endwhile
  if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
    " Found an "exec" line after a comment with continuation
    let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
    if n =~ '\<tclsh\|\<wish'
      setf tcl
      return
    endif
  endif
  exe "setf " . a:name
endfunc

" tcsh scripts
au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call SetFileTypeShell("tcsh")

" csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()

func! s:CSH()
  if exists("g:filetype_csh")
    call SetFileTypeShell(g:filetype_csh)
  elseif &shell =~ "tcsh"
    call SetFileTypeShell("tcsh")
  else
    call SetFileTypeShell("csh")
  endif
endfunc

" Z-Shell script
au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
au BufNewFile,BufRead *.zsh			setf zsh

" Scheme
au BufNewFile,BufRead *.scm,*.ss,*.rkt		setf scheme

" Screen RC
au BufNewFile,BufRead .screenrc,screenrc	setf screen

" Simula
au BufNewFile,BufRead *.sim			setf simula

" SINDA
au BufNewFile,BufRead *.sin,*.s85		setf sinda

" SiSU
au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu

" SKILL
au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill

" SLRN
au BufNewFile,BufRead .slrnrc			setf slrnrc
au BufNewFile,BufRead *.score			setf slrnsc

" Smalltalk (and TeX)
au BufNewFile,BufRead *.st			setf st
au BufNewFile,BufRead *.cls
	\ if getline(1) =~ '^%' |
	\  setf tex |
	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
	\  setf rexx |
	\ else |
	\  setf st |
	\ endif

" Smarty templates
au BufNewFile,BufRead *.tpl			setf smarty

" SMIL or XML
au BufNewFile,BufRead *.smil
	\ if getline(1) =~ '<?\s*xml.*?>' |
	\   setf xml |
	\ else |
	\   setf smil |
	\ endif

" SMIL or SNMP MIB file
au BufNewFile,BufRead *.smi
	\ if getline(1) =~ '\<smil\>' |
	\   setf smil |
	\ else |
	\   setf mib |
	\ endif

" SMITH
au BufNewFile,BufRead *.smt,*.smith		setf smith

" Snobol4 and spitbol
au BufNewFile,BufRead *.sno,*.spt		setf snobol4

" SNMP MIB files
au BufNewFile,BufRead *.mib,*.my		setf mib

" Snort Configuration
au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
au BufNewFile,BufRead *.rules			call s:FTRules()

let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
func! s:FTRules()
  let path = expand('<amatch>:p')
  if path =~ '^/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
    setf udevrules
    return
  endif
  if path =~ '^/etc/ufw/'
    setf conf  " Better than hog
    return
  endif
  try
    let config_lines = readfile('/etc/udev/udev.conf')
  catch /^Vim\%((\a\+)\)\=:E484/
    setf hog
    return
  endtry
  let dir = expand('<amatch>:p:h')
  for line in config_lines
    if line =~ s:ft_rules_udev_rules_pattern
      let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
      if dir == udev_rules
        setf udevrules
      endif
      break
    endif
  endfor
  setf hog
endfunc


" Spec (Linux RPM)
au BufNewFile,BufRead *.spec			setf spec

" Speedup (AspenTech plant simulator)
au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup

" Slice
au BufNewFile,BufRead *.ice			setf slice

" Spice
au BufNewFile,BufRead *.sp,*.spice		setf spice

" Spyce
au BufNewFile,BufRead *.spy,*.spi		setf spyce

" Squid
au BufNewFile,BufRead squid.conf		setf squid

" SQL for Oracle Designer
au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql

" SQL
au BufNewFile,BufRead *.sql			call s:SQL()

func! s:SQL()
  if exists("g:filetype_sql")
    exe "setf " . g:filetype_sql
  else
    setf sql
  endif
endfunc

" SQLJ
au BufNewFile,BufRead *.sqlj			setf sqlj

" SQR
au BufNewFile,BufRead *.sqr,*.sqi		setf sqr

" OpenSSH configuration
au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig

" OpenSSH server configuration
au BufNewFile,BufRead sshd_config		setf sshdconfig

" Stata
au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata

" SMCL
au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl

" Stored Procedures
au BufNewFile,BufRead *.stp			setf stp

" Standard ML
au BufNewFile,BufRead *.sml			setf sml

" Sratus VOS command macro
au BufNewFile,BufRead *.cm			setf voscm

" Sysctl
au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl

" Synopsys Design Constraints
au BufNewFile,BufRead *.sdc			setf sdc

" Sudoers
au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers

" SVG (Scalable Vector Graphics)
au BufNewFile,BufRead *.svg			setf svg

" If the file has an extension of 't' and is in a directory 't' or 'xt' then
" it is almost certainly a Perl test file.
" If the first line starts with '#' and contains 'perl' it's probably a Perl
" file.
" (Slow test) If a file contains a 'use' statement then it is almost certainly
" a Perl file.
func! s:FTperl()
  let dirname = expand("%:p:h:t")
  if expand("%:e") == 't' && (dirname == 't' || dirname == 'xt')
    setf perl
    return 1
  endif
  if getline(1)[0] == '#' && getline(1) =~ 'perl'
    setf perl
    return 1
  endif
  if search('^use\s\s*\k', 'nc', 30)
    setf perl
    return 1
  endif
  return 0
endfunc

" Tads (or Nroff or Perl test file)
au BufNewFile,BufRead *.t
	\ if !s:FTnroff() && !s:FTperl() | setf tads | endif

" Tags
au BufNewFile,BufRead tags			setf tags

" TAK
au BufNewFile,BufRead *.tak			setf tak

" Task
au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
au BufRead,BufNewFile *.task			setf taskedit

" Tcl (JACL too)
au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl

" TealInfo
au BufNewFile,BufRead *.tli			setf tli

" Telix Salt
au BufNewFile,BufRead *.slt			setf tsalt

" Terminfo
au BufNewFile,BufRead *.ti			setf terminfo

" TeX
au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
au BufNewFile,BufRead *.tex			call s:FTtex()

" Choose context, plaintex, or tex (LaTeX) based on these rules:
" 1. Check the first line of the file for "%&<format>".
" 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
" 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
func! s:FTtex()
  let firstline = getline(1)
  if firstline =~ '^%&\s*\a\+'
    let format = tolower(matchstr(firstline, '\a\+'))
    let format = substitute(format, 'pdf', '', '')
    if format == 'tex'
      let format = 'plain'
    endif
  else
    " Default value, may be changed later:
    let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
    " Save position, go to the top of the file, find first non-comment line.
    let save_cursor = getpos('.')
    call cursor(1,1)
    let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
    if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
      let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>\|part\>\|chapter\>\|section\>\|subsection\>\|subsubsection\>\|paragraph\>\|subparagraph\>\|subsubparagraph'
      let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
      let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
			      \ 'cnp', firstNC + 1000)
      if kwline == 1	" lpat matched
	let format = 'latex'
      elseif kwline == 2	" cpat matched
	let format = 'context'
      endif		" If neither matched, keep default set above.
      " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
      " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
      " if cline > 0
      "   let format = 'context'
      " endif
      " if lline > 0 && (cline == 0 || cline > lline)
      "   let format = 'tex'
      " endif
    endif " firstNC
    call setpos('.', save_cursor)
  endif " firstline =~ '^%&\s*\a\+'

  " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
  if format == 'plain'
    setf plaintex
  elseif format == 'context'
    setf context
  else " probably LaTeX
    setf tex
  endif
  return
endfunc

" ConTeXt
au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context

" Texinfo
au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo

" TeX configuration
au BufNewFile,BufRead texmf.cnf			setf texmf

" Tidy config
au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy

" TF mud client
au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf

" TPP - Text Presentation Program
au BufNewFile,BufReadPost *.tpp			setf tpp

" Treetop
au BufRead,BufNewFile *.treetop			setf treetop

" Trustees
au BufNewFile,BufRead trustees.conf		setf trustees

" TSS - Geometry
au BufNewFile,BufReadPost *.tssgm		setf tssgm

" TSS - Optics
au BufNewFile,BufReadPost *.tssop		setf tssop

" TSS - Command Line (temporary)
au BufNewFile,BufReadPost *.tsscl		setf tsscl

" TWIG files
au BufNewFile,BufReadPost *.twig		setf twig

" Motif UIT/UIL files
au BufNewFile,BufRead *.uit,*.uil		setf uil

" Udev conf
au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf

" Udev permissions
au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
"
" Udev symlinks config
au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh

" UnrealScript
au BufNewFile,BufRead *.uc			setf uc

" Updatedb
au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb

" Upstart (init(8)) config files
au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart

" Vera
au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera

" Verilog HDL
au BufNewFile,BufRead *.v			setf verilog

" Verilog-AMS HDL
au BufNewFile,BufRead *.va,*.vams		setf verilogams

" SystemVerilog
au BufNewFile,BufRead *.sv,*.svh		setf systemverilog

" VHDL
au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')

" Vim script
au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim

" Viminfo file
au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo

" Virata Config Script File or Drupal module
au BufRead,BufNewFile *.hw,*.module,*.pkg
	\ if getline(1) =~ '<?php' |
	\   setf php |
	\ else |
	\   setf virata |
	\ endif

" Visual Basic (also uses *.bas) or FORM
au BufNewFile,BufRead *.frm			call s:FTVB("form")

" SaxBasic is close to Visual Basic
au BufNewFile,BufRead *.sba			setf vb

" Vgrindefs file
au BufNewFile,BufRead vgrindefs			setf vgrindefs

" VRML V1.0c
au BufNewFile,BufRead *.wrl			setf vrml

" Vroom (vim testing and executable documentation)
au BufNewFile,BufRead *.vroom			setf vroom

" Webmacro
au BufNewFile,BufRead *.wm			setf webmacro

" Wget config
au BufNewFile,BufRead .wgetrc,wgetrc		setf wget

" Website MetaLanguage
au BufNewFile,BufRead *.wml			setf wml

" Winbatch
au BufNewFile,BufRead *.wbt			setf winbatch

" WSML
au BufNewFile,BufRead *.wsml			setf wsml

" WvDial
au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial

" CVS RC file
au BufNewFile,BufRead .cvsrc			setf cvsrc

" CVS commit file
au BufNewFile,BufRead cvs\d\+			setf cvs

" WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
" lines in a WEB file).
au BufNewFile,BufRead *.web
	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
	\   setf web |
	\ else |
	\   setf winbatch |
	\ endif

" Windows Scripting Host and Windows Script Component
au BufNewFile,BufRead *.ws[fc]			setf wsh

" XHTML
au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml

" X Pixmap (dynamically sets colors, use BufEnter to make it work better)
au BufEnter *.xpm
	\ if getline(1) =~ "XPM2" |
	\   setf xpm2 |
	\ else |
	\   setf xpm |
	\ endif
au BufEnter *.xpm2				setf xpm2

" XFree86 config
au BufNewFile,BufRead XF86Config
	\ if getline(1) =~ '\<XConfigurator\>' |
	\   let b:xf86conf_xfree86_version = 3 |
	\ endif |
	\ setf xf86conf
au BufNewFile,BufRead */xorg.conf.d/*.conf
	\ let b:xf86conf_xfree86_version = 4 |
	\ setf xf86conf

" Xorg config
au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf

" Xinetd conf
au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd

" XS Perl extension interface language
au BufNewFile,BufRead *.xs			setf xs

" X resources file
au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults

" Xmath
au BufNewFile,BufRead *.msc,*.msf		setf xmath
au BufNewFile,BufRead *.ms
	\ if !s:FTnroff() | setf xmath | endif

" XML  specific variants: docbk and xbl
au BufNewFile,BufRead *.xml			call s:FTxml()

func! s:FTxml()
  let n = 1
  while n < 100 && n < line("$")
    let line = getline(n)
    " DocBook 4 or DocBook 5.
    let is_docbook4 = line =~ '<!DOCTYPE.*DocBook'
    let is_docbook5 = line =~ ' xmlns="http://docbook.org/ns/docbook"'
    if is_docbook4 || is_docbook5
      let b:docbk_type = "xml"
      if is_docbook5
	let b:docbk_ver = 5
      else
	let b:docbk_ver = 4
      endif
      setf docbk
      return
    endif
    if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
      setf xbl
      return
    endif
    let n += 1
  endwhile
  setf xml
endfunc

" XMI (holding UML models) is also XML
au BufNewFile,BufRead *.xmi			setf xml

" CSPROJ files are Visual Studio.NET's XML-based project config files
au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml

" Qt Linguist translation source and Qt User Interface Files are XML
au BufNewFile,BufRead *.ts,*.ui			setf xml

" TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
au BufNewFile,BufRead *.tpm			setf xml

" Xdg menus
au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml

" ATI graphics driver configuration
au BufNewFile,BufRead fglrxrc			setf xml

" XLIFF (XML Localisation Interchange File Format) is also XML
au BufNewFile,BufRead *.xlf			setf xml
au BufNewFile,BufRead *.xliff			setf xml

" XML User Interface Language
au BufNewFile,BufRead *.xul			setf xml

" X11 xmodmap (also see below)
au BufNewFile,BufRead *Xmodmap			setf xmodmap

" Xquery
au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery

" XSD
au BufNewFile,BufRead *.xsd			setf xsd

" Xslt
au BufNewFile,BufRead *.xsl,*.xslt		setf xslt

" Yacc
au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc

" Yacc or racc
au BufNewFile,BufRead *.y			call s:FTy()

func! s:FTy()
  let n = 1
  while n < 100 && n < line("$")
    let line = getline(n)
    if line =~ '^\s*%'
      setf yacc
      return
    endif
    if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
      setf racc
      return
    endif
    let n = n + 1
  endwhile
  setf yacc
endfunc


" Yaml
au BufNewFile,BufRead *.yaml,*.yml		setf yaml

" yum conf (close enough to dosini)
au BufNewFile,BufRead */etc/yum.conf		setf dosini

" Zimbu
au BufNewFile,BufRead *.zu			setf zimbu

" Zope
"   dtml (zope dynamic template markup language), pt (zope page template),
"   cpt (zope form controller page template)
au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call s:FThtml()
"   zsql (zope sql method)
au BufNewFile,BufRead *.zsql			call s:SQL()

" Z80 assembler asz80
au BufNewFile,BufRead *.z8a			setf z8a

augroup END


" Source the user-specified filetype file, for backwards compatibility with
" Vim 5.x.
if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
  execute "source " . myfiletypefile
endif


" Check for "*" after loading myfiletypefile, so that scripts.vim is only used
" when there are no matching file name extensions.
" Don't do this for compressed files.
augroup filetypedetect
au BufNewFile,BufRead *
	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
	\ | runtime! scripts.vim | endif
au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif


" Extra checks for when no filetype has been detected now.  Mostly used for
" patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
" script file.
" Most of these should call s:StarSetf() to avoid names ending in .gz and the
" like are used.

" More Apache config files
au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')

" Asterisk config file
au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')

" Bazaar version control
au BufNewFile,BufRead bzr_log.*			setf bzr

" BIND zone
au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')

" Calendar
au BufNewFile,BufRead */.calendar/*,
	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
	\					call s:StarSetf('calendar')

" Changelog
au BufNewFile,BufRead [cC]hange[lL]og*
	\ if getline(1) =~ '; urgency='
	\|  call s:StarSetf('debchangelog')
	\|else
	\|  call s:StarSetf('changelog')
	\|endif

" Crontab
au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')

" dnsmasq(8) configuration
au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')

" Dracula
au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')

" Fvwm
au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
au BufNewFile,BufRead *fvwm2rc*
	\ if expand("<afile>:e") == "m4"
	\|  call s:StarSetf('fvwm2m4')
	\|else
	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
	\|endif

" Gedcom
au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')

" GTK RC
au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')

" Jam
au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')

" Jargon
au! BufNewFile,BufRead *jarg*
	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
	\|  call s:StarSetf('jargon')
	\|endif

" Kconfig
au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')

" Lilo: Linux loader
au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')

" Logcheck
au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')

" Makefile
au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')

" Ruby Makefile
au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')

" Mail (also matches muttrc.vim, so this is below the other checks)
au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}	setf mail

" Modconf
au BufNewFile,BufRead */etc/modutils/*
	\ if executable(expand("<afile>")) != 1
	\|  call s:StarSetf('modconf')
	\|endif
au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')

" Mutt setup file
au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')

" Nroff macros
au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')

" Pam conf
au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')

" Printcap and Termcap
au BufNewFile,BufRead *printcap*
	\ if !did_filetype()
	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
	\|endif
au BufNewFile,BufRead *termcap*
	\ if !did_filetype()
	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
	\|endif

" ReDIF
" Only used when the .rdf file was not detected to be XML.
au BufRead,BufNewFile *.rdf			call s:Redif()
func! s:Redif()
  let lnum = 1
  while lnum <= 5 && lnum < line('$')
    if getline(lnum) =~ "^\ctemplate-type:"
      setf redif
      return
    endif
    let lnum = lnum + 1
  endwhile
endfunc

" Remind
au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')

" Vim script
au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')

" Subversion commit file
au BufNewFile,BufRead svn-commit*.tmp		setf svn

" X resources file
au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')

" XFree86 config
au BufNewFile,BufRead XF86Config-4*
	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
au BufNewFile,BufRead XF86Config*
	\ if getline(1) =~ '\<XConfigurator\>'
	\|  let b:xf86conf_xfree86_version = 3
	\|endif
	\|call s:StarSetf('xf86conf')

" X11 xmodmap
au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')

" Xinetd conf
au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')

" yum conf (close enough to dosini)
au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')

" Z-Shell script
au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')


" Plain text files, needs to be far down to not override others.  This avoids
" the "conf" type being used if there is a line starting with '#'.
au BufNewFile,BufRead *.txt,*.text,README	setf text


" Use the filetype detect plugins.  They may overrule any of the previously
" detected filetypes.
runtime! ftdetect/*.vim

" NOTE: The above command could have ended the filetypedetect autocmd group
" and started another one. Let's make sure it has ended to get to a consistent
" state.
augroup END

" Generic configuration file (check this last, it's just guessing!)
au filetypedetect BufNewFile,BufRead,StdinReadPost *
	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
	\   setf conf |
	\ endif


" If the GUI is already running, may still need to install the Syntax menu.
" Don't do it when the 'M' flag is included in 'guioptions'.
if has("menu") && has("gui_running")
      \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
  source <sfile>:p:h/menu.vim
endif

" Function called for testing all functions defined here.  These are
" script-local, thus need to be executed here.
" Returns a string with error messages (hopefully empty).
func! TestFiletypeFuncs(testlist)
  let output = ''
  for f in a:testlist
    try
      exe f
    catch
      let output = output . "\n" . f . ": " . v:exception
    endtry
  endfor
  return output
endfunc

" Restore 'cpoptions'
let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                              usr/share/vim/vim74/ftoff.vim                                                                       0100644 0000000 0000000 00000000430 13050207306 014533  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim support file to switch off detection of file types
"
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last change:	2001 Jun 11

if exists("did_load_filetypes")
  unlet did_load_filetypes
endif

" Remove all autocommands in the filetypedetect group
silent! au! filetypedetect *
                                                                                                                                                                                                                                        usr/share/vim/vim74/ftplugin/                                                                       0040755 0000000 0000000 00000000000 13101201173 014541  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim74/ftplugin/README.txt                                                             0100644 0000000 0000000 00000001545 13050207306 016250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        The ftplugin directory is for Vim plugin scripts that are only used for a
specific filetype.

All files ending in .vim in this directory and subdirectories will be sourced
by Vim when it detects the filetype that matches the name of the file or
subdirectory.
For example, these are all loaded for the "c" filetype:

	c.vim
	c_extra.vim
	c/settings.vim

Note that the "_" in "c_extra.vim" is required to separate the filetype name
from the following arbitrary name.

The filetype plugins are only loaded when the ":filetype plugin" command has
been used.

The default filetype plugin files contain settings that 95% of the users will
want to use.  They do not contain personal preferences, like the value of
'shiftwidth'.

If you want to do additional settings, or overrule the default filetype
plugin, you can create your own plugin file.  See ":help ftplugin" in Vim.
                                                                                                                                                           usr/share/vim/vim74/ftplugin/a2ps.vim                                                               0100644 0000000 0000000 00000000712 13050207306 016127  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         a2ps(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s include=^\\s*Include:
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                      usr/share/vim/vim74/ftplugin/aap.vim                                                                0100644 0000000 0000000 00000001314 13050207306 016022  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Aap recipe
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2013 Apr 05

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Reset 'formatoptions', 'comments' and 'expandtab' to undo this plugin.
let b:undo_ftplugin = "setl fo< com< et<"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set 'comments' to format dashed lists in comments.
setlocal comments=s:#\ -,m:#\ \ ,e:#,n:#,fb:-

" Expand tabs to spaces to avoid trouble.
setlocal expandtab
                                                                                                                                                                                                                                                                                                                    usr/share/vim/vim74/ftplugin/abap.vim                                                               0100644 0000000 0000000 00000001440 13050207306 016164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	ABAP
" Author:	Steven Oliver <oliver.steven@gmail.com>
" Copyright:	Copyright (c) 2013 Steven Oliver
" License:	You may redistribute this under the same terms as Vim itself
" --------------------------------------------------------------------------

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal softtabstop=2 shiftwidth=2
setlocal suffixesadd=.abap

" Windows allows you to filter the open file dialog
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "ABAP Source Files (*.abap)\t*.abap\n" .
                     \ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: set sw=4 sts=4 et tw=80 :
                                                                                                                                                                                                                                usr/share/vim/vim74/ftplugin/abaqus.vim                                                             0100644 0000000 0000000 00000006477 13050207306 016554  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:     Abaqus finite element input file (www.abaqus.com)
" Maintainer:   Carl Osterwisch <osterwischc@asme.org>
" Last Change:  2012 Apr 30

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin") | finish | endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Save the compatibility options and temporarily switch to vim defaults
let s:cpo_save = &cpoptions
set cpoptions&vim

" Set the format of the include file specification for Abaqus
" Used in :check gf ^wf [i and other commands
setlocal include=\\<\\cINPUT\\s*=

" Remove characters up to the first = when evaluating filenames
setlocal includeexpr=substitute(v:fname,'.\\{-}=','','')

" Remove comma from valid filename characters since it is used to
" separate keyword parameters
setlocal isfname-=,

" Define format of comment lines (see 'formatoptions' for uses)
setlocal comments=:**
setlocal commentstring=**%s

" Definitions start with a * and assign a NAME, NSET, or ELSET
" Used in [d ^wd and other commands
setlocal define=^\\*\\a.*\\c\\(NAME\\\|NSET\\\|ELSET\\)\\s*=

" Abaqus keywords and identifiers may include a - character
setlocal iskeyword+=-

let b:undo_ftplugin = "setlocal include< includeexpr< isfname<"
    \ . " comments< commentstring< define< iskeyword<"

if has("folding")
    " Fold all lines that do not begin with *
    setlocal foldexpr=getline(v:lnum)[0]!=\"\*\"
    setlocal foldmethod=expr
    let b:undo_ftplugin .= " foldexpr< foldmethod<"
endif

" Set the file browse filter (currently only supported under Win32 gui)
if has("gui_win32") && !exists("b:browsefilter")
    let b:browsefilter = "Abaqus Input Files (*.inp *.inc)\t*.inp;*.inc\n" .
    \ "Abaqus Results (*.dat)\t*.dat\n" .
    \ "Abaqus Messages (*.pre *.msg *.sta)\t*.pre;*.msg;*.sta\n" .
    \ "All Files (*.*)\t*.*\n"
    let b:undo_ftplugin .= "|unlet! b:browsefilter"
endif

" Define patterns for the matchit plugin
if exists("loaded_matchit") && !exists("b:match_words")
    let b:match_ignorecase = 1
    let b:match_words = 
    \ '\*part:\*end\s*part,' .
    \ '\*assembly:\*end\s*assembly,' .
    \ '\*instance:\*end\s*instance,' .
    \ '\*step:\*end\s*step'
    let b:undo_ftplugin .= "|unlet! b:match_ignorecase b:match_words"
endif

" Define keys used to move [count] keywords backward or forward.
noremap <silent><buffer> [[ ?^\*\a<CR>:nohlsearch<CR>
noremap <silent><buffer> ]] /^\*\a<CR>:nohlsearch<CR>

" Define key to toggle commenting of the current line or range
noremap <silent><buffer> <LocalLeader><LocalLeader> 
    \ :call <SID>Abaqus_ToggleComment()<CR>j
function! <SID>Abaqus_ToggleComment() range
    if strpart(getline(a:firstline), 0, 2) == "**"
        " Un-comment all lines in range
        silent execute a:firstline . ',' . a:lastline . 's/^\*\*//'
    else
        " Comment all lines in range
        silent execute a:firstline . ',' . a:lastline . 's/^/**/'
    endif
endfunction

let b:undo_ftplugin .= "|unmap <buffer> [[|unmap <buffer> ]]"
    \ . "|unmap <buffer> <LocalLeader><LocalLeader>"

" Undo must be done in nocompatible mode for <LocalLeader>.
let b:undo_ftplugin = "let s:cpo_save = &cpoptions|"
    \ . "set cpoptions&vim|"
    \ . b:undo_ftplugin
    \ . "|let &cpoptions = s:cpo_save"
    \ . "|unlet s:cpo_save"

" Restore saved compatibility options
let &cpoptions = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                 usr/share/vim/vim74/ftplugin/ada.vim                                                                0100644 0000000 0000000 00000014410 13050207306 016007  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        "------------------------------------------------------------------------------
"  Description: Perform Ada specific completion & tagging.
"     Language: Ada (2005)
"	   $Id: ada.vim 887 2008-07-08 14:29:01Z krischik $
"   Maintainer: Martin Krischik <krischik@users.sourceforge.net>
"		Taylor Venable <taylor@metasyntax.net>
"		Neil Bird <neil@fnxweb.com>
"      $Author: krischik $
"	 $Date: 2008-07-08 16:29:01 +0200 (Di, 08 Jul 2008) $
"      Version: 4.6 with patch from David Bürgin
"    $Revision: 887 $
"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/ftplugin/ada.vim $
"      History: 24.05.2006 MK Unified Headers
"		26.05.2006 MK ' should not be in iskeyword.
"		16.07.2006 MK Ada-Mode as vim-ball
"		02.10.2006 MK Better folding.
"		15.10.2006 MK Bram's suggestion for runtime integration
"               05.11.2006 MK Bram suggested not to use include protection for
"                             autoload
"		05.11.2006 MK Bram suggested to save on spaces
"		08.07.2007 TV fix default compiler problems.
"    Help Page: ft-ada-plugin
"------------------------------------------------------------------------------
" Provides mapping overrides for tag jumping that figure out the current
" Ada object and tag jump to that, not the 'simple' vim word.
" Similarly allows <Ctrl-N> matching of full-length ada entities from tags.
"------------------------------------------------------------------------------

" Only do this when not done yet for this buffer
if exists ("b:did_ftplugin") || version < 700
   finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 45

"
" Temporarily set cpoptions to ensure the script loads OK
"
let s:cpoptions = &cpoptions
set cpoptions-=C

" Section: Comments  {{{1
"
setlocal comments=O:--,:--\ \ 
setlocal commentstring=--\ \ %s
setlocal complete=.,w,b,u,t,i

" Section: case	     {{{1
"
setlocal nosmartcase
setlocal ignorecase

" Section: formatoptions {{{1
"
setlocal formatoptions+=ron

" Section: Tagging {{{1
"
if exists ("g:ada_extended_tagging")
   " Make local tag mappings for this buffer (if not already set)
   if g:ada_extended_tagging == 'jump'
      if mapcheck('<C-]>','n') == ''
	 nnoremap <unique> <buffer> <C-]>    :call ada#Jump_Tag ('', 'tjump')<cr>
      endif
      if mapcheck('g<C-]>','n') == ''
	 nnoremap <unique> <buffer> g<C-]>   :call ada#Jump_Tag ('','stjump')<cr>
      endif
   elseif g:ada_extended_tagging == 'list'
      if mapcheck('<C-]>','n') == ''
	 nnoremap <unique> <buffer> <C-]>    :call ada#List_Tag ()<cr>
      endif
      if mapcheck('g<C-]>','n') == ''
	 nnoremap <unique> <buffer> g<C-]>   :call ada#List_Tag ()<cr>
      endif
   endif
endif

" Section: Completion {{{1
"
setlocal completefunc=ada#User_Complete
setlocal omnifunc=adacomplete#Complete

if exists ("g:ada_extended_completion")
   if mapcheck ('<C-N>','i') == ''
      inoremap <unique> <buffer> <C-N> <C-R>=ada#Completion("\<lt>C-N>")<cr>
   endif
   if mapcheck ('<C-P>','i') == ''
      inoremap <unique> <buffer> <C-P> <C-R>=ada#Completion("\<lt>C-P>")<cr>
   endif
   if mapcheck ('<C-X><C-]>','i') == ''
      inoremap <unique> <buffer> <C-X><C-]> <C-R>=<SID>ada#Completion("\<lt>C-X>\<lt>C-]>")<cr>
   endif
   if mapcheck ('<bs>','i') == ''
      inoremap <silent> <unique> <buffer> <bs> <C-R>=ada#Insert_Backspace ()<cr>
   endif
endif

" Section: Matchit {{{1
"
" Only do this when not done yet for this buffer & matchit is used
"
if !exists ("b:match_words")  &&
  \ exists ("loaded_matchit")
   "
   " The following lines enable the macros/matchit.vim plugin for
   " Ada-specific extended matching with the % key.
   "
   let s:notend      = '\%(\<end\s\+\)\@<!'
   let b:match_words =
      \ s:notend . '\<if\>:\<elsif\>:\<else\>:\<end\>\s\+\<if\>,' .
      \ s:notend . '\<case\>:\<when\>:\<end\>\s\+\<case\>,' .
      \ '\%(\<while\>.*\|\<for\>.*\|'.s:notend.'\)\<loop\>:\<end\>\s\+\<loop\>,' .
      \ '\%(\<do\>\|\<begin\>\):\<exception\>:\<end\>\s*\%($\|[;A-Z]\),' .
      \ s:notend . '\<record\>:\<end\>\s\+\<record\>'
endif


" Section: Compiler {{{1
"
if ! exists("g:ada_default_compiler")
   if has("vms")
      let g:ada_default_compiler = 'decada'
   else
      let g:ada_default_compiler = 'gnat'
   endif
endif

if ! exists("current_compiler")			||
   \ current_compiler != g:ada_default_compiler
   execute "compiler " . g:ada_default_compiler
endif

" Section: Folding {{{1
"
if exists("g:ada_folding")
   if g:ada_folding[0] == 'i'
      setlocal foldmethod=indent
      setlocal foldignore=--
      setlocal foldnestmax=5
   elseif g:ada_folding[0] == 'g'
      setlocal foldmethod=expr
      setlocal foldexpr=ada#Pretty_Print_Folding(v:lnum)
   elseif g:ada_folding[0] == 's'
      setlocal foldmethod=syntax
   endif
   setlocal tabstop=8
   setlocal softtabstop=3
   setlocal shiftwidth=3
endif

" Section: Abbrev {{{1
"
if exists("g:ada_abbrev")
   iabbrev ret	return
   iabbrev proc procedure
   iabbrev pack package
   iabbrev func function
endif

" Section: Commands, Mapping, Menus {{{1
"
call ada#Map_Popup (
   \ 'Tag.List',
   \  'l',
   \ 'call ada#List_Tag ()')
call ada#Map_Popup (
   \'Tag.Jump',
   \'j',
   \'call ada#Jump_Tag ()')
call ada#Map_Menu (
   \'Tag.Create File',
   \':AdaTagFile',
   \'call ada#Create_Tags (''file'')')
call ada#Map_Menu (
   \'Tag.Create Dir',
   \':AdaTagDir',
   \'call ada#Create_Tags (''dir'')')

call ada#Map_Menu (
   \'Highlight.Toggle Space Errors',
   \ ':AdaSpaces',
   \'call ada#Switch_Syntax_Option (''space_errors'')')
call ada#Map_Menu (
   \'Highlight.Toggle Lines Errors',
   \ ':AdaLines',
   \'call ada#Switch_Syntax_Option (''line_errors'')')
call ada#Map_Menu (
   \'Highlight.Toggle Rainbow Color',
   \ ':AdaRainbow',
   \'call ada#Switch_Syntax_Option (''rainbow_color'')')
call ada#Map_Menu (
   \'Highlight.Toggle Standard Types',
   \ ':AdaTypes',
   \'call ada#Switch_Syntax_Option (''standard_types'')')

" 1}}}
" Reset cpoptions
let &cpoptions = s:cpoptions
unlet s:cpoptions

finish " 1}}}

"------------------------------------------------------------------------------
"   Copyright (C) 2006	Martin Krischik
"
"   Vim is Charityware - see ":help license" or uganda.txt for licence details.
"------------------------------------------------------------------------------
" vim: textwidth=78 nowrap tabstop=8 shiftwidth=3 softtabstop=3 noexpandtab
" vim: foldmethod=marker
                                                                                                                                                                                                                                                        usr/share/vim/vim74/ftplugin/alsaconf.vim                                                           0100644 0000000 0000000 00000000652 13050207306 017053  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         alsaconf(8) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                      usr/share/vim/vim74/ftplugin/ant.vim                                                                0100644 0000000 0000000 00000002475 13050207306 016054  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	ant
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "XML Files (*.xml)\t*.xml\n" .
	    \	     "All Files (*.*)\t*.*\n"

runtime! ftplugin/xml.vim ftplugin/xml_*.vim ftplugin/xml/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif

" Change the :browse e filter to primarily show Ant-related files.
if has("gui_win32")
    let b:browsefilter = "Build Files (build.xml)\tbuild.xml\n" .
		\	 "Java Files (*.java)\t*.java\n" .
		\	 "Properties Files (*.prop*)\t*.prop*\n" .
		\	 "Manifest Files (*.mf)\t*.mf\n" .
		\	 s:browsefilter
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:browsefilter | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                   usr/share/vim/vim74/ftplugin/arch.vim                                                               0100644 0000000 0000000 00000000643 13050207306 016202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         GNU Arch inventory file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                             usr/share/vim/vim74/ftplugin/art.vim                                                                0100644 0000000 0000000 00000000632 13050207306 016051  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:      ART-IM and ART*Enterprise
" Maintainer:    Dorai Sitaram <ds26@gte.com>
" URL:		 http://www.ccs.neu.edu/~dorai/vimplugins/vimplugins.html
" Last Change:   Apr 2, 2003

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

run ftplugin/lisp.vim

setl lw-=if
setl lw+=def-art-fun,deffacts,defglobal,defrule,defschema,for,schema,while
                                                                                                      usr/share/vim/vim74/ftplugin/aspvbs.vim                                                             0100644 0000000 0000000 00000003574 13050207306 016571  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	aspvbs
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "HTML Files (*.html, *.htm)\t*.htm*\n" .
	    \	     "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words
endif

" ASP:  Active Server Pages (with Visual Basic Script)
" thanks to Gontran BAERTS
if exists("loaded_matchit")
  let s:notend = '\%(\<end\s\+\)\@<!'
  let b:match_ignorecase = 1
  let b:match_words =
  \ s:notend . '\<if\>\%(.\{-}then\s\+\w\)\@!:\<elseif\>:^\s*\<else\>:\<end\s\+\<if\>,' .
  \ s:notend . '\<select\s\+case\>:\<case\>:\<case\s\+else\>:\<end\s\+select\>,' .
  \ '^\s*\<sub\>:\<end\s\+sub\>,' .
  \ '^\s*\<function\>:\<end\s\+function\>,' .
  \ '\<class\>:\<end\s\+class\>,' .
  \ '^\s*\<do\>:\<loop\>,' .
  \ '^\s*\<for\>:\<next\>,' .
  \ '\<while\>:\<wend\>,' .
  \ s:match_words
endif

" Change the :browse e filter to primarily show ASP-related files.
if has("gui_win32")
    let  b:browsefilter="ASP Files (*.asp)\t*.asp\n" . s:browsefilter
endif

let b:undo_ftplugin = "unlet! b:match_words b:match_ignorecase b:browsefilter | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                    usr/share/vim/vim74/ftplugin/automake.vim                                                           0100644 0000000 0000000 00000000505 13050207306 017070  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Automake
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

runtime! ftplugin/make.vim ftplugin/make_*.vim ftplugin/make/*.vim

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                           usr/share/vim/vim74/ftplugin/bdf.vim                                                                0100644 0000000 0000000 00000000665 13050207306 016024  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         BDF font definition
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=b:COMMENT commentstring=COMMENT\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                           usr/share/vim/vim74/ftplugin/bst.vim                                                                0100644 0000000 0000000 00000000515 13050207306 016053  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	bst
" Author:	Tim Pope <vimNOSPAM@tpope.info>
" $Id: bst.vim,v 1.1 2007/05/05 17:37:57 vimboss Exp $

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

setlocal commentstring=%\ %s
setlocal comments=:%
setlocal fo-=t fo+=croql

let b:undo_ftplugin = "setlocal com< cms< fo<"
                                                                                                                                                                                   usr/share/vim/vim74/ftplugin/btm.vim                                                                0100644 0000000 0000000 00000000474 13050207306 016051  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	BTM
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2004 Jul 06

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Behaves just like dosbatch
runtime! ftplugin/dosbatch.vim ftplugin/dosbatch_*.vim ftplugin/dosbatch/*.vim
                                                                                                                                                                                                    usr/share/vim/vim74/ftplugin/c.vim                                                                  0100644 0000000 0000000 00000003654 13050207306 015514  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	C
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2012 Jul 10

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Using line continuation here.
let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = "setl fo< com< ofu< | if has('vms') | setl isk< | endif"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set completion with CTRL-X CTRL-O to autoloaded function.
if exists('&ofu')
  setlocal ofu=ccomplete#Complete
endif

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

" In VMS C keywords contain '$' characters.
if has("vms")
  setlocal iskeyword+=$
endif

" When the matchit plugin is loaded, this makes the % command skip parens and
" braces in comments.
let b:match_words = &matchpairs . ',^\s*#\s*if\(\|def\|ndef\)\>:^\s*#\s*elif\>:^\s*#\s*else\>:^\s*#\s*endif\>'
let b:match_skip = 's:comment\|string\|character'

" Win32 can filter files in the browse dialog
if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  if &ft == "cpp"
    let b:browsefilter = "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
	  \ "C Header Files (*.h)\t*.h\n" .
	  \ "C Source Files (*.c)\t*.c\n" .
	  \ "All Files (*.*)\t*.*\n"
  elseif &ft == "ch"
    let b:browsefilter = "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
	  \ "C Header Files (*.h)\t*.h\n" .
	  \ "C Source Files (*.c)\t*.c\n" .
	  \ "All Files (*.*)\t*.*\n"
  else
    let b:browsefilter = "C Source Files (*.c)\t*.c\n" .
	  \ "C Header Files (*.h)\t*.h\n" .
	  \ "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
	  \ "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
	  \ "All Files (*.*)\t*.*\n"
  endif
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                    usr/share/vim/vim74/ftplugin/calendar.vim                                                           0100644 0000000 0000000 00000000702 13050207306 017032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         calendar(1) input file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=s1:/*,mb:*,ex:*/ commentstring& include&
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                              usr/share/vim/vim74/ftplugin/cdrdaoconf.vim                                                         0100644 0000000 0000000 00000000567 13050207306 017374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2007-12-04

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                         usr/share/vim/vim74/ftplugin/ch.vim                                                                 0100644 0000000 0000000 00000000730 13050207306 015654  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:     Ch
" Maintainer:   SoftIntegration, Inc. <info@softintegration.com>
" URL:		http://www.softintegration.com/download/vim/ftplugin/ch.vim
" Last change:	2004 May 16
"		Created based on cpp.vim
"
" Ch is a C/C++ interpreter with many high level extensions
"

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Behaves just like C
runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim
                                        usr/share/vim/vim74/ftplugin/changelog.vim                                                          0100644 0000000 0000000 00000021041 13050207306 017207  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         generic Changelog file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2014-01-10
" Variables:
"   g:changelog_timeformat (deprecated: use g:changelog_dateformat instead) -
"       description: the timeformat used in ChangeLog entries.
"       default: "%Y-%m-%d".
"   g:changelog_dateformat -
"       description: the format sent to strftime() to generate a date string.
"       default: "%Y-%m-%d".
"   g:changelog_username -
"       description: the username to use in ChangeLog entries
"       default: try to deduce it from environment variables and system files.
" Local Mappings:
"   <Leader>o -
"       adds a new changelog entry for the current user for the current date.
" Global Mappings:
"   <Leader>o -
"       switches to the ChangeLog buffer opened for the current directory, or
"       opens it in a new buffer if it exists in the current directory.  Then
"       it does the same as the local <Leader>o described above.
" Notes:
"   run 'runtime ftplugin/changelog.vim' to enable the global mapping for
"   changelog files.
" TODO:
"  should we perhaps open the ChangeLog file even if it doesn't exist already?
"  Problem is that you might end up with ChangeLog files all over the place.

" If 'filetype' isn't "changelog", we must have been to add ChangeLog opener
if &filetype == 'changelog'
  if exists('b:did_ftplugin')
    finish
  endif
  let b:did_ftplugin = 1

  let s:cpo_save = &cpo
  set cpo&vim

  " Set up the format used for dates.
  if !exists('g:changelog_dateformat')
    if exists('g:changelog_timeformat')
      let g:changelog_dateformat = g:changelog_timeformat
    else
      let g:changelog_dateformat = "%Y-%m-%d"
    endif
  endif

  function! s:username()
    if exists('g:changelog_username')
      return g:changelog_username
    elseif $EMAIL != ""
      return $EMAIL
    elseif $EMAIL_ADDRESS != ""
      return $EMAIL_ADDRESS
    endif
    
    let login = s:login()
    return printf('%s <%s@%s>', s:name(login), login, s:hostname())
  endfunction

  function! s:login()
    return s:trimmed_system_with_default('whoami', 'unknown')
  endfunction

  function! s:trimmed_system_with_default(command, default)
    return s:first_line(s:system_with_default(a:command, a:default))
  endfunction

  function! s:system_with_default(command, default)
    let output = system(a:command)
    if v:shell_error
      return default
    endif
    return output
  endfunction

  function! s:first_line(string)
    return substitute(a:string, '\n.*$', "", "")
  endfunction

  function! s:name(login)
    for name in [s:gecos_name(a:login), $NAME, s:capitalize(a:login)]
      if name != ""
        return name
      endif
    endfor
  endfunction

  function! s:gecos_name(login)
    for line in s:try_reading_file('/etc/passwd')
      if line =~ '^' . a:login . ':'
        return substitute(s:passwd_field(line, 5), '&', s:capitalize(a:login), "")
      endif
    endfor
    return ""
  endfunction

  function! s:try_reading_file(path)
    try
      return readfile(a:path)
    catch
      return []
    endtry
  endfunction

  function! s:passwd_field(line, field)
    let fields = split(a:line, ':', 1)
    if len(fields) < a:field
      return ""
    endif
    return fields[a:field - 1]
  endfunction

  function! s:capitalize(word)
    return toupper(a:word[0]) . strpart(a:word, 1)
  endfunction

  function! s:hostname()
    return s:trimmed_system_with_default('hostname', 'localhost')
  endfunction

  " Format used for new date entries.
  if !exists('g:changelog_new_date_format')
    let g:changelog_new_date_format = "%d  %u\n\n\t* %p%c\n\n"
  endif

  " Format used for new entries to current date entry.
  if !exists('g:changelog_new_entry_format')
    let g:changelog_new_entry_format = "\t* %p%c"
  endif

  " Regular expression used to find a given date entry.
  if !exists('g:changelog_date_entry_search')
    let g:changelog_date_entry_search = '^\s*%d\_s*%u'
  endif

  " Regular expression used to find the end of a date entry
  if !exists('g:changelog_date_end_entry_search')
    let g:changelog_date_end_entry_search = '^\s*$'
  endif


  " Substitutes specific items in new date-entry formats and search strings.
  " Can be done with substitute of course, but unclean, and need \@! then.
  function! s:substitute_items(str, date, user, prefix)
    let str = a:str
    let middles = {'%': '%', 'd': a:date, 'u': a:user, 'p': a:prefix, 'c': '{cursor}'}
    let i = stridx(str, '%')
    while i != -1
      let inc = 0
      if has_key(middles, str[i + 1])
        let mid = middles[str[i + 1]]
        let str = strpart(str, 0, i) . mid . strpart(str, i + 2)
        let inc = strlen(mid) - 1
      endif
      let i = stridx(str, '%', i + 1 + inc)
    endwhile
    return str
  endfunction

  " Position the cursor once we've done all the funky substitution.
  function! s:position_cursor()
    if search('{cursor}') > 0
      let lnum = line('.')
      let line = getline(lnum)
      let cursor = stridx(line, '{cursor}')
      call setline(lnum, substitute(line, '{cursor}', '', ''))
    endif
    startinsert!
  endfunction

  " Internal function to create a new entry in the ChangeLog.
  function! s:new_changelog_entry(prefix)
    " Deal with 'paste' option.
    let save_paste = &paste
    let &paste = 1
    call cursor(1, 1)
    " Look for an entry for today by our user.
    let date = strftime(g:changelog_dateformat)
    let search = s:substitute_items(g:changelog_date_entry_search, date,
                                  \ s:username(), a:prefix)
    if search(search) > 0
      " Ok, now we look for the end of the date entry, and add an entry.
      call cursor(nextnonblank(line('.') + 1), 1)
      if search(g:changelog_date_end_entry_search, 'W') > 0
	let p = (line('.') == line('$')) ? line('.') : line('.') - 1
      else
        let p = line('.')
      endif
      let ls = split(s:substitute_items(g:changelog_new_entry_format, '', '', a:prefix),
                   \ '\n')
      call append(p, ls)
      call cursor(p + 1, 1)
    else
      " Flag for removing empty lines at end of new ChangeLogs.
      let remove_empty = line('$') == 1

      " No entry today, so create a date-user header and insert an entry.
      let todays_entry = s:substitute_items(g:changelog_new_date_format,
                                          \ date, s:username(), a:prefix)
      " Make sure we have a cursor positioning.
      if stridx(todays_entry, '{cursor}') == -1
        let todays_entry = todays_entry . '{cursor}'
      endif

      " Now do the work.
      call append(0, split(todays_entry, '\n'))

      " Remove empty lines at end of file.
      if remove_empty
        $-/^\s*$/-1,$delete
      endif

      " Reposition cursor once we're done.
      call cursor(1, 1)
    endif

    call s:position_cursor()

    " And reset 'paste' option
    let &paste = save_paste
  endfunction

  if exists(":NewChangelogEntry") != 2
    noremap <buffer> <silent> <Leader>o <Esc>:call <SID>new_changelog_entry('')<CR>
    command! -nargs=0 NewChangelogEntry call s:new_changelog_entry('')
  endif

  let b:undo_ftplugin = "setl com< fo< et< ai<"

  setlocal comments=
  setlocal formatoptions+=t
  setlocal noexpandtab
  setlocal autoindent

  if &textwidth == 0
    setlocal textwidth=78
    let b:undo_ftplugin .= " tw<"
  endif

  let &cpo = s:cpo_save
  unlet s:cpo_save
else
  let s:cpo_save = &cpo
  set cpo&vim

  " Add the Changelog opening mapping
  nnoremap <silent> <Leader>o :call <SID>open_changelog()<CR>

  function! s:open_changelog()
    let path = expand('%:p:h')
    if exists('b:changelog_path')
      let changelog = b:changelog_path
    else
      if exists('b:changelog_name')
        let name = b:changelog_name
      else
        let name = 'ChangeLog'
      endif
      while isdirectory(path)
        let changelog = path . '/' . name
        if filereadable(changelog)
          break
        endif
        let parent = substitute(path, '/\+[^/]*$', "", "")
        if path == parent
          break
        endif
        let path = parent
      endwhile
    endif
    if !filereadable(changelog)
      return
    endif

    if exists('b:changelog_entry_prefix')
      let prefix = call(b:changelog_entry_prefix, [])
    else
      let prefix = substitute(strpart(expand('%:p'), strlen(path)), '^/\+', "", "")
    endif

    let buf = bufnr(changelog)
    if buf != -1
      if bufwinnr(buf) != -1
        execute bufwinnr(buf) . 'wincmd w'
      else
        execute 'sbuffer' buf
      endif
    else
      execute 'split' fnameescape(changelog)
    endif

    call s:new_changelog_entry(prefix)
  endfunction

  let &cpo = s:cpo_save
  unlet s:cpo_save
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/share/vim/vim74/ftplugin/clojure.vim                                                            0100644 0000000 0000000 00000007266 13050207306 016740  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Clojure
" Author:	Meikel Brandmeyer <mb@kotka.de>
"
" Maintainer:	Sung Pae <self@sungpae.com>
" URL:		https://github.com/guns/vim-clojure-static
" License:	Same as Vim
" Last Change:	27 March 2014

if exists("b:did_ftplugin")
	finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = 'setlocal iskeyword< define< formatoptions< comments< commentstring< lispwords<'

setlocal iskeyword+=?,-,*,!,+,/,=,<,>,.,:,$

" There will be false positives, but this is better than missing the whole set
" of user-defined def* definitions.
setlocal define=\\v[(/]def(ault)@!\\S*

" Remove 't' from 'formatoptions' to avoid auto-wrapping code.
setlocal formatoptions-=t

" Lisp comments are routinely nested (e.g. ;;; SECTION HEADING)
setlocal comments=n:;
setlocal commentstring=;\ %s

" Specially indented symbols from clojure.core and clojure.test.
"
" Clojure symbols are indented in the defn style when they:
"
"   * Define vars and anonymous functions
"   * Create new lexical scopes or scopes with altered environments
"   * Create conditional branches from a predicate function or value
"
" The arglists for these functions are generally in the form of [x & body];
" Functions that accept a flat list of forms do not treat the first argument
" specially and hence are not indented specially.
"
" -*- LISPWORDS -*-
" Generated from https://github.com/guns/vim-clojure-static/blob/vim-release-010/clj/src/vim_clojure_static/generate.clj
setlocal lispwords=as->,binding,bound-fn,case,catch,cond->,cond->>,condp,def,definline,definterface,defmacro,defmethod,defmulti,defn,defn-,defonce,defprotocol,defrecord,defstruct,deftest,deftest-,deftype,doseq,dotimes,doto,extend,extend-protocol,extend-type,fn,for,if,if-let,if-not,if-some,let,letfn,locking,loop,ns,proxy,reify,set-test,testing,when,when-first,when-let,when-not,when-some,while,with-bindings,with-in-str,with-local-vars,with-open,with-precision,with-redefs,with-redefs-fn,with-test

" Provide insert mode completions for special forms and clojure.core. As
" 'omnifunc' is set by popular Clojure REPL client plugins, we also set
" 'completefunc' so that the user has some form of completion available when
" 'omnifunc' is set and no REPL connection exists.
for s:setting in ['omnifunc', 'completefunc']
	if exists('&' . s:setting) && empty(eval('&' . s:setting))
		execute 'setlocal ' . s:setting . '=clojurecomplete#Complete'
		let b:undo_ftplugin .= ' | setlocal ' . s:setting . '<'
	endif
endfor

" Take all directories of the CLOJURE_SOURCE_DIRS environment variable
" and add them to the path option.
"
" This is a legacy option for VimClojure users.
if exists('$CLOJURE_SOURCE_DIRS')
	for s:dir in split($CLOJURE_SOURCE_DIRS, (has("win32") || has("win64")) ? ';' : ':')
		let s:dir = fnameescape(s:dir)
		" Whitespace escaping for Windows
		let s:dir = substitute(s:dir, '\', '\\\\', 'g')
		let s:dir = substitute(s:dir, '\ ', '\\ ', 'g')
		execute "setlocal path+=" . s:dir . "/**"
	endfor
	let b:undo_ftplugin .= ' | setlocal path<'
endif

" Skip brackets in ignored syntax regions when using the % command
if exists('loaded_matchit')
	let b:match_words = &matchpairs
	let b:match_skip = 's:comment\|string\|regex\|character'
	let b:undo_ftplugin .= ' | unlet! b:match_words b:match_skip'
endif

" Win32 can filter files in the browse dialog
if has("gui_win32") && !exists("b:browsefilter")
	let b:browsefilter = "Clojure Source Files (*.clj)\t*.clj\n" .
			   \ "ClojureScript Source Files (*.cljs)\t*.cljs\n" .
			   \ "Java Source Files (*.java)\t*.java\n" .
			   \ "All Files (*.*)\t*.*\n"
	let b:undo_ftplugin .= ' | unlet! b:browsefilter'
endif

let &cpo = s:cpo_save

unlet! s:cpo_save s:setting s:dir

" vim:sts=8:sw=8:ts=8:noet
                                                                                                                                                                                                                                                                                                                                          usr/share/vim/vim74/ftplugin/cobol.vim                                                              0100644 0000000 0000000 00000022362 13050207306 016365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	cobol
" Author:	Tim Pope <vimNOSPAM@tpope.info>
" Last Update:	By ZyX: use shiftwidth()

" Insert mode mappings: <C-T> <C-D> <Tab>
" Normal mode mappings: < > << >> [[ ]] [] ][
" Visual mode mappings: < >

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal commentstring=\ \ \ \ \ \ *%s
setlocal comments=:*
setlocal fo+=croqlt
setlocal expandtab
setlocal textwidth=72

" matchit support
if exists("loaded_matchit")
    let s:ordot = '\|\ze\.\%( \@=\|$\)'
    let b:match_ignorecase=1
    "let b:match_skip = 'getline(".") =~ "^.\\{6\\}[*/C]"'
    let b:match_words=
    \ '\$if\>:$else\>:\$endif\>,' .
    \ '[$-]\@<!\<if\>:\<\%(then\|else\)\>:\<end-if\>'.s:ordot.',' .
    \ '-\@<!\<perform\s\+\%(\d\+\s\+times\|until\|varying\|with\s\+test\)\>:\<end-perform\>'.s:ordot . ',' .
    \ '-\@<!\<\%(search\|evaluate\)\>:\<\%(when\)\>:\<end-\%(search\|evaluate\)\>' .s:ordot . ',' .
    \ '-\@<!\<\%(add\|compute\|divide\|multiply\|subtract\)\>\%(.*\(\%$\|\%(\n\%(\%(\s*\|.\{6\}\)[*/].*\n\)*\)\=\s*\%(not\s\+\)\=on\s\+size\s\+error\>\)\)\@=:\%(\<not\s\+\)\@<!\<\%(not\s\+\)\=on\s\+size\s\+error\>:\<end-\%(add\|compute\|divide\|multiply\|subtract\)\>' .s:ordot . ',' .
    \ '-\@<!\<\%(string\|unstring\|accept\|display\|call\)\>\%(.*\(\%$\|\%(\n\%(\%(\s*\|.\{6\}\)[*/].*\n\)*\)\=\s*\%(not\s\+\)\=on\s\+\%(overflow\|exception\)\>\)\)\@=:\%(\<not\s\+\)\@<!\<\%(not\s\+\)\=on\s\+\%(overflow\|exception\)\>:\<end-\%(string\|unstring\|accept\|display\|call\)\>' .s:ordot . ',' .
    \ '-\@<!\<\%(delete\|rewrite\|start\|write\|read\)\>\%(.*\(\%$\|\%(\n\%(\%(\s*\|.\{6\}\)[*/].*\n\)*\)\=\s*\%(invalid\s\+key\|at\s\+end\|no\s\+data\|at\s\+end-of-page\)\>\)\)\@=:\%(\<not\s\+\)\@<!\<\%(not\s\+\)\=\%(invalid\s\+key\|at\s\+end\|no\s\+data\|at\s\+end-of-page\)\>:\<end-\%(delete\|rewrite\|start\|write\|read\)\>' .s:ordot
endif

if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "COBOL Source Files (*.cbl, *.cob)\t*.cbl;*.cob;*.lib\n".
		     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setlocal com< cms< fo< et< tw<" .
            \ " | unlet! b:browsefilter b:match_words b:match_ignorecase b:match_skip"
if !exists("g:no_plugin_maps") && !exists("g:no_cobol_maps")
    let b:undo_ftplugin = b:undo_ftplugin .
            \ " | sil! exe 'nunmap <buffer> <'" .
            \ " | sil! exe 'nunmap <buffer> >'" .
            \ " | sil! exe 'nunmap <buffer> <<'" .
            \ " | sil! exe 'nunmap <buffer> >>'" .
            \ " | sil! exe 'vunmap <buffer> <'" .
            \ " | sil! exe 'vunmap <buffer> >'" .
            \ " | sil! exe 'iunmap <buffer> <C-D>'" .
            \ " | sil! exe 'iunmap <buffer> <C-T>'" .
            \ " | sil! exe 'iunmap <buffer> <Tab>'" .
            \ " | sil! exe 'nunmap <buffer> <Plug>Traditional'" .
            \ " | sil! exe 'nunmap <buffer> <Plug>Comment'" .
            \ " | sil! exe 'nunmap <buffer> <Plug>DeComment'" .
            \ " | sil! exe 'vunmap <buffer> <Plug>VisualTraditional'" .
            \ " | sil! exe 'vunmap <buffer> <Plug>VisualComment'" .
            \ " | sil! exe 'iunmap <buffer> <Plug>VisualDeComment'" .
            \ " | sil! exe 'unmap  <buffer> [['" .
            \ " | sil! exe 'unmap  <buffer> ]]'" .
            \ " | sil! exe 'unmap  <buffer> []'" .
            \ " | sil! exe 'unmap  <buffer> ]['"
endif

if !exists("g:no_plugin_maps") && !exists("g:no_cobol_maps")
    if version >= 700
        nnoremap <silent> <buffer> > :set opfunc=<SID>IncreaseFunc<CR>g@
        nnoremap <silent> <buffer> < :set opfunc=<SID>DecreaseFunc<CR>g@
    endif
    nnoremap <silent> <buffer> >> :call CobolIndentBlock(1)<CR>
    nnoremap <silent> <buffer> << :call CobolIndentBlock(-1)<CR>
    vnoremap <silent> <buffer> > :call CobolIndentBlock(v:count1)<CR>
    vnoremap <silent> <buffer> < :call CobolIndentBlock(-v:count1)<CR>
    inoremap <silent> <buffer> <C-T> <C-R>=<SID>IncreaseIndent()<CR><C-R>=<SID>RestoreShiftwidth()<CR>
    inoremap <silent> <buffer> <C-D> <C-R>=<SID>DecreaseIndent()<CR><C-R>=<SID>RestoreShiftwidth()<CR>
    if !maparg("<Tab>","i")
        inoremap <silent> <buffer> <Tab> <C-R>=<SID>Tab()<CR><C-R>=<SID>RestoreShiftwidth()<CR>
    endif
    noremap <silent> <buffer> [[ m':call search('\c^\%(\s*\<Bar>.\{6\}\s\+\)\zs[A-Za-z0-9-]\+\s\+\%(division\<Bar>section\)\s*\.','bW')<CR>
    noremap <silent> <buffer> ]] m':call search('\c^\%(\s*\<Bar>.\{6\}\s\+\)\zs[A-Za-z0-9-]\+\s\+\%(division\<Bar>section\)\.','W')<CR>
    noremap <silent> <buffer> [] m':call <SID>toend('b')<CR>
    noremap <silent> <buffer> ][ m':call <SID>toend('')<CR>
    " For EnhancedCommentify
    noremap <silent> <buffer> <Plug>Traditional      :call <SID>Comment('t')<CR>
    noremap <silent> <buffer> <Plug>Comment          :call <SID>Comment('c')<CR>
    noremap <silent> <buffer> <Plug>DeComment        :call <SID>Comment('u')<CR>
    noremap <silent> <buffer> <Plug>VisualTraditional :'<,'>call <SID>Comment('t')<CR>
    noremap <silent> <buffer> <Plug>VisualComment     :'<,'>call <SID>Comment('c')<CR>
    noremap <silent> <buffer> <Plug>VisualDeComment   :'<,'>call <SID>Comment('u')<CR>
endif

let &cpo = s:cpo_save
unlet s:cpo_save

if exists("g:did_cobol_ftplugin_functions")
    finish
endif
let g:did_cobol_ftplugin_functions = 1

function! s:repeat(str,count)
    let i = 0
    let ret = ""
    while i < a:count
        let ret = ret . a:str
        let i = i + 1
    endwhile
    return ret
endfunction

function! s:increase(...)
    let lnum = '.'
    let sw = shiftwidth()
    let i = a:0 ? a:1 : indent(lnum)
    if i >= 11
        return sw - (i - 11) % sw
    elseif i >= 7
        return 11-i
    elseif i == 6
        return 1
    else
        return 6-i
    endif
endfunction

function! s:decrease(...)
    let lnum = '.'
    let sw = shiftwidth()
    let i = indent(a:0 ? a:1 : lnum)
    if i >= 11 + sw
        return 1 + (i + 12) % sw
    elseif i > 11
        return i-11
    elseif i > 7
        return i-7
    elseif i == 7
        return 1
    else
        return i
    endif
endfunction

function! CobolIndentBlock(shift)
    let head = strpart(getline('.'),0,7)
    let tail = strpart(getline('.'),7)
    let indent = match(tail,'[^ ]')
    let sw = shiftwidth()
    let shift = a:shift
    if shift > 0
        if indent < 4
            let tail = s:repeat(" ",4-indent).tail
            let shift = shift - 1
        endif
        let tail = s:repeat(" ",shift*sw).tail
        let shift = 0
    elseif shift < 0
        if (indent-4) > -shift * sw
            let tail = strpart(tail,-shift * sw)
        elseif (indent-4) > (-shift-1) * sw
            let tail = strpart(tail,indent - 4)
        else
            let tail = strpart(tail,indent)
        endif
    endif
    call setline('.',head.tail)
endfunction

function! s:IncreaseFunc(type)
    '[,']call CobolIndentBlock(1)
endfunction

function! s:DecreaseFunc(type)
    '[,']call CobolIndentBlock(-1)
endfunction

function! s:IncreaseIndent()
    let c = "\<C-T>"
    if exists("*InsertCtrlTWrapper")
        let key = InsertCtrlTWrapper()
        if key != c
            return key
        endif
    endif
    let interval = s:increase()
    let b:cobol_shiftwidth = &shiftwidth
    let &shiftwidth = 1
    let lastchar = strpart(getline('.'),col('.')-2,1)
    if lastchar == '0' || lastchar == '^'
        return "\<BS>".lastchar.c
    else
        return s:repeat(c,interval)
    endif
endfunction

function! s:DecreaseIndent()
    let c = "\<C-D>"
    if exists("*InsertCtrlDWrapper")
        " I hack Ctrl-D to delete when not at the end of the line.
        let key = InsertCtrlDWrapper()
        if key != c
            return key
        endif
    endif
    let interval = s:decrease()
    let b:cobol_shiftwidth = &shiftwidth
    let &shiftwidth = 1
    return s:repeat(c,interval)
endfunction

function! s:RestoreShiftwidth()
    if exists("b:cobol_shiftwidth")
        let &shiftwidth=b:cobol_shiftwidth
        unlet b:cobol_shiftwidth
    endif
    return ""
endfunction

function! s:Tab()
    if (strpart(getline('.'),0,col('.')-1) =~ '^\s*$' && &sta)
        return s:IncreaseIndent()
    " &softtabstop < 0: &softtabstop follows &shiftwidth
    elseif (&sts < 0 || &sts == shiftwidth()) && &sts != 8 && &et
        return s:repeat(" ",s:increase(col('.')-1))
    else
        return "\<Tab>"
    endif
endfunction

function! s:Comment(arg)
    " For EnhancedCommentify
    let line = getline('.')
    if (line =~ '^.\{6\}[*/C]' || a:arg == 'c') && a:arg != 'u'
        let line = substitute(line,'^.\{6\}\zs.',' ','')
    else
        let line = substitute(line,'^.\{6\}\zs.','*','')
    endif
    call setline('.',line)
endfunction

function! s:toend(direction)
    let ignore = '^\(\s*\|.\{6\}\)\%([*/]\|\s*$\)'
    let keep = line('.')
    keepjumps +
    while line('.') < line('$') && getline('.') =~ ignore
        keepjumps +
    endwhile
    let res = search('\c^\%(\s*\|.\{6\}\s\+\)\zs[A-Za-z0-9-]\+\s\+\%(division\|section\)\s*\.',a:direction.'W')
    if a:direction != 'b' && !res
        let res = line('$')
        keepjumps $
    elseif res
        keepjumps -
    endif
    if res
        while line('.') > 1 && getline('.') =~ ignore
            keepjumps -
        endwhile
        if line('.') == 1 && getline('.') =~ ignore
            exe "keepjumps ".keep
        endif
    else
        exe "keepjumps ".keep
    endif
endfunction
                                                                                                                                                                                                                                                                              usr/share/vim/vim74/ftplugin/conf.vim                                                               0100644 0000000 0000000 00000000646 13050207306 016215  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         generic configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                          usr/share/vim/vim74/ftplugin/config.vim                                                             0100644 0000000 0000000 00000002372 13050207306 016533  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	config
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "Bourne Shell Files (*.sh)\t*.sh\n" .
	    \	 "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/sh.vim ftplugin/sh_*.vim ftplugin/sh/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif

" Change the :browse e filter to primarily show configure-related files.
if has("gui_win32")
    let  b:browsefilter="Configure Scripts (configure.*, config.*)\tconfigure*;config.*\n" .
		\	s:browsefilter
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:browsefilter | " . b:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                      usr/share/vim/vim74/ftplugin/context.vim                                                            0100644 0000000 0000000 00000001673 13050207306 016755  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         ConTeXt typesetting engine
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< def< inc< sua< fo<"

setlocal comments=b:%D,b:%C,b:%M,:% commentstring=%\ %s formatoptions+=tcroql

let &l:define='\\\%([egx]\|char\|mathchar\|count\|dimen\|muskip\|skip\|toks\)\='
        \ .     'def\|\\font\|\\\%(future\)\=let'
        \ . '\|\\new\%(count\|dimen\|skip\|muskip\|box\|toks\|read\|write'
        \ .     '\|fam\|insert\|if\)'

let &l:include = '^\s*\%(input\|component\)'

setlocal suffixesadd=.tex

if exists("loaded_matchit")
  let b:match_ignorecase = 0
  let b:match_skip = 'r:\\\@<!\%(\\\\\)*%'
  let b:match_words = '(:),\[:],{:},\\(:\\),\\\[:\\],' .
        \ '\\start\(\a\+\):\\stop\1'
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                     usr/share/vim/vim74/ftplugin/cpp.vim                                                                0100644 0000000 0000000 00000000440 13050207306 016042  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	C++
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2001 Jan 15

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Behaves just like C
runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim
                                                                                                                                                                                                                                usr/share/vim/vim74/ftplugin/crm.vim                                                                0100644 0000000 0000000 00000000622 13050207306 016043  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         CRM114
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                              usr/share/vim/vim74/ftplugin/cs.vim                                                                 0100644 0000000 0000000 00000001442 13050207306 015670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	C#
" Maintainer:	Johannes Zellner <johannes@zellner.org>
" Last Change:	Tue, 09 Mar 2004 14:09:33 CET

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1
let s:keepcpo= &cpo
set cpo&vim

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,:///,://

if has("gui_win32") && !exists("b:browsefilter")
    let b:browsefilter = "C# Source Files (*.cs)\t*.cs\n" .
		       \ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                              usr/share/vim/vim74/ftplugin/csc.vim                                                                0100644 0000000 0000000 00000001336 13050207306 016035  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	csc
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

if exists("loaded_matchit")
    let b:match_words=
	\ '\<fix\>:\<endfix\>,' .
	\ '\<if\>:\<else\%(if\)\=\>:\<endif\>,' .
	\ '\<!loopondimensions\>\|\<!looponselected\>:\<!endloop\>'
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:match_words"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                  usr/share/vim/vim74/ftplugin/csh.vim                                                                0100644 0000000 0000000 00000003141 13050207306 016036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	csh
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal commentstring=#%s
setlocal formatoptions-=t
setlocal formatoptions+=crql

" Csh:  thanks to Johannes Zellner
" - Both foreach and end must appear alone on separate lines.
" - The words else and endif must appear at the beginning of input lines;
"   the if must appear alone on its input line or after an else.
" - Each case label and the default label must appear at the start of a
"   line.
" - while and end must appear alone on their input lines.
if exists("loaded_matchit")
    let b:match_words =
      \ '^\s*\<if\>.*(.*).*\<then\>:'.
      \   '^\s*\<else\>\s\+\<if\>.*(.*).*\<then\>:^\s*\<else\>:'.
      \   '^\s*\<endif\>,'.
      \ '\%(^\s*\<foreach\>\s\+\S\+\|^s*\<while\>\).*(.*):'.
      \   '\<break\>:\<continue\>:^\s*\<end\>,'.
      \ '^\s*\<switch\>.*(.*):^\s*\<case\>\s\+:^\s*\<default\>:^\s*\<endsw\>'
endif

" Change the :browse e filter to primarily show csh-related files.
if has("gui_win32")
    let  b:browsefilter="csh Scripts (*.csh)\t*.csh\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal commentstring< formatoptions<" .
		\     " | unlet! b:match_words b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                               usr/share/vim/vim74/ftplugin/css.vim                                                                0100644 0000000 0000000 00000001004 13050207306 016045  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         CSS
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo< ofu<"

setlocal comments=s1:/*,mb:*,ex:*/ commentstring&
setlocal formatoptions-=t formatoptions+=croql
setlocal omnifunc=csscomplete#CompleteCSS

let &l:include = '^\s*@import\s\+\%(url(\)\='

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/share/vim/vim74/ftplugin/cucumber.vim                                                           0100644 0000000 0000000 00000012315 13050207306 017071  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	Cucumber
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2013 Jun 01

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

let s:keepcpo= &cpo
set cpo&vim

setlocal formatoptions-=t formatoptions+=croql
setlocal comments=:# commentstring=#\ %s
setlocal omnifunc=CucumberComplete

let b:undo_ftplugin = "setl fo< com< cms< ofu<"

let b:cucumber_root = expand('%:p:h:s?.*[\/]\%(features\|stories\)\zs[\/].*??')

if !exists("g:no_plugin_maps") && !exists("g:no_cucumber_maps")
  nnoremap <silent><buffer> <C-]>       :<C-U>exe <SID>jump('edit',v:count)<CR>
  nnoremap <silent><buffer> [<C-D>      :<C-U>exe <SID>jump('edit',v:count)<CR>
  nnoremap <silent><buffer> ]<C-D>      :<C-U>exe <SID>jump('edit',v:count)<CR>
  nnoremap <silent><buffer> <C-W>]      :<C-U>exe <SID>jump('split',v:count)<CR>
  nnoremap <silent><buffer> <C-W><C-]>  :<C-U>exe <SID>jump('split',v:count)<CR>
  nnoremap <silent><buffer> <C-W>d      :<C-U>exe <SID>jump('split',v:count)<CR>
  nnoremap <silent><buffer> <C-W><C-D>  :<C-U>exe <SID>jump('split',v:count)<CR>
  nnoremap <silent><buffer> <C-W>}      :<C-U>exe <SID>jump('pedit',v:count)<CR>
  nnoremap <silent><buffer> [d          :<C-U>exe <SID>jump('pedit',v:count)<CR>
  nnoremap <silent><buffer> ]d          :<C-U>exe <SID>jump('pedit',v:count)<CR>
  let b:undo_ftplugin .=
        \ "|sil! nunmap <buffer> <C-]>" .
        \ "|sil! nunmap <buffer> [<C-D>" .
        \ "|sil! nunmap <buffer> ]<C-D>" .
        \ "|sil! nunmap <buffer> <C-W>]" .
        \ "|sil! nunmap <buffer> <C-W><C-]>" .
        \ "|sil! nunmap <buffer> <C-W>d" .
        \ "|sil! nunmap <buffer> <C-W><C-D>" .
        \ "|sil! nunmap <buffer> <C-W>}" .
        \ "|sil! nunmap <buffer> [d" .
        \ "|sil! nunmap <buffer> ]d"
endif

function! s:jump(command,count)
  let steps = s:steps('.')
  if len(steps) == 0 || len(steps) < a:count
    return 'echoerr "No matching step found"'
  elseif len(steps) > 1 && !a:count
    return 'echoerr "Multiple matching steps found"'
  else
    let c = a:count ? a:count-1 : 0
    return a:command.' +'.steps[c][1].' '.escape(steps[c][0],' %#')
  endif
endfunction

function! s:allsteps()
  let step_pattern = '\C^\s*\K\k*\>\s*(\=\s*\zs\S.\{-\}\ze\s*)\=\s*\%(do\|{\)\s*\%(|[^|]*|\s*\)\=\%($\|#\)'
  let steps = []
  for file in split(glob(b:cucumber_root.'/**/*.rb'),"\n")
    let lines = readfile(file)
    let num = 0
    for line in lines
      let num += 1
      if line =~ step_pattern
        let type = matchstr(line,'\w\+')
        let steps += [[file,num,type,matchstr(line,step_pattern)]]
      endif
    endfor
  endfor
  return steps
endfunction

function! s:steps(lnum)
  let c = match(getline(a:lnum), '\S') + 1
  while synIDattr(synID(a:lnum,c,1),'name') !~# '^$\|Region$'
    let c = c + 1
  endwhile
  let step = matchstr(getline(a:lnum)[c-1 : -1],'^\s*\zs.\{-\}\ze\s*$')
  return filter(s:allsteps(),'s:stepmatch(v:val[3],step)')
endfunction

function! s:stepmatch(receiver,target)
  if a:receiver =~ '^[''"].*[''"]$'
    let pattern = '^'.escape(substitute(a:receiver[1:-2],'$\w\+','(.*)','g'),'/').'$'
  elseif a:receiver =~ '^/.*/$'
    let pattern = a:receiver[1:-2]
  elseif a:receiver =~ '^%r..*.$'
    let pattern = escape(a:receiver[3:-2],'/')
  else
    return 0
  endif
  try
    let vimpattern = substitute(substitute(pattern,'\\\@<!(?:','%(','g'),'\\\@<!\*?','{-}','g')
    if a:target =~# '\v'.vimpattern
      return 1
    endif
  catch
  endtry
  if has("ruby") && pattern !~ '\\\@<!#{'
    ruby VIM.command("return #{if (begin; Kernel.eval('/'+VIM.evaluate('pattern')+'/'); rescue SyntaxError; end) === VIM.evaluate('a:target') then 1 else 0 end}")
  else
    return 0
  endif
endfunction

function! s:bsub(target,pattern,replacement)
  return  substitute(a:target,'\C\\\@<!'.a:pattern,a:replacement,'g')
endfunction

function! CucumberComplete(findstart,base) abort
  let indent = indent('.')
  let group = synIDattr(synID(line('.'),indent+1,1),'name')
  let type = matchstr(group,'\Ccucumber\zs\%(Given\|When\|Then\)')
  let e = matchend(getline('.'),'^\s*\S\+\s')
  if type == '' || col('.') < col('$') || e < 0
    return -1
  endif
  if a:findstart
    return e
  endif
  let steps = []
  for step in s:allsteps()
    if step[2] ==# type
      if step[3] =~ '^[''"]'
        let steps += [step[3][1:-2]]
      elseif step[3] =~ '^/\^.*\$/$'
        let pattern = step[3][2:-3]
        let pattern = substitute(pattern,'\C^(?:|I )','I ','')
        let pattern = s:bsub(pattern,'\\[Sw]','w')
        let pattern = s:bsub(pattern,'\\d','1')
        let pattern = s:bsub(pattern,'\\[sWD]',' ')
        let pattern = s:bsub(pattern,'\[\^\\\="\]','_')
        let pattern = s:bsub(pattern,'[[:alnum:]. _-][?*]?\=','')
        let pattern = s:bsub(pattern,'\[\([^^]\).\{-\}\]','\1')
        let pattern = s:bsub(pattern,'+?\=','')
        let pattern = s:bsub(pattern,'(\([[:alnum:]. -]\{-\}\))','\1')
        let pattern = s:bsub(pattern,'\\\([[:punct:]]\)','\1')
        if pattern !~ '[\\()*?]'
          let steps += [pattern]
        endif
      endif
    endif
  endfor
  call filter(steps,'strpart(v:val,0,strlen(a:base)) ==# a:base')
  return sort(steps)
endfunction

let &cpo = s:keepcpo
unlet s:keepcpo

" vim:set sts=2 sw=2:
                                                                                                                                                                                                                                                                                                                   usr/share/vim/vim74/ftplugin/cvsrc.vim                                                              0100644 0000000 0000000 00000000603 13050207306 016401  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         cvs(1) RC file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments= commentstring= formatoptions-=tcroql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                             usr/share/vim/vim74/ftplugin/debchangelog.vim                                                       0100644 0000000 0000000 00000026426 13050207306 017676  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file (GUI menu, folding and completion)
" Language:     Debian Changelog
" Maintainer:   Debian Vim Maintainers <pkg-vim-maintainers@lists.alioth.debian.org>
" Former Maintainers:   Michael Piefel <piefel@informatik.hu-berlin.de>
"                       Stefano Zacchiroli <zack@debian.org>
" Last Change:  2014-01-31
" License:      Vim License
" URL:          http://hg.debian.org/hg/pkg-vim/vim/file/unstable/runtime/ftplugin/debchangelog.vim

" Bug completion requires apt-listbugs installed for Debian packages or
" python-launchpadlib installed for Ubuntu packages

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin=1

" {{{1 Local settings (do on every load)
if exists("g:debchangelog_fold_enable")
  setlocal foldmethod=expr
  setlocal foldexpr=DebGetChangelogFold(v:lnum)
  setlocal foldtext=DebChangelogFoldText()
endif

" Debian changelogs are not supposed to have any other text width,
" so the user cannot override this setting
setlocal tw=78
setlocal comments=f:* 

" Clean unloading
let b:undo_ftplugin = "setlocal tw< comments< foldmethod< foldexpr< foldtext<"
" }}}1

if exists("g:did_changelog_ftplugin")
  finish
endif

" Don't load another plugin (this is global)
let g:did_changelog_ftplugin = 1

" {{{1 GUI menu

" Helper functions returning various data.
" Returns full name, either from $DEBFULLNAME or debianfullname.
" TODO Is there a way to determine name from anywhere else?
function <SID>FullName()
    if exists("$DEBFULLNAME")
	return $DEBFULLNAME
    elseif exists("g:debianfullname")
	return g:debianfullname
    else
	return "Your Name"
    endif
endfunction

" Returns email address, from $DEBEMAIL, $EMAIL or debianemail.
function <SID>Email()
    if exists("$DEBEMAIL")
	return $DEBEMAIL
    elseif exists("$EMAIL")
	return $EMAIL
    elseif exists("g:debianemail")
	return g:debianemail
    else
	return "your@email.address"
    endif
endfunction

" Returns date in RFC822 format.
function <SID>Date()
    let savelang = v:lc_time
    execute "language time C"
    let dateandtime = strftime("%a, %d %b %Y %X %z")
    execute "language time " . savelang
    return dateandtime
endfunction

function <SID>WarnIfNotUnfinalised()
    if match(getline("."), " -- [[:alpha:]][[:alnum:].]")!=-1
	echohl WarningMsg
	echo "The entry has not been unfinalised before editing."
	echohl None
	return 1
    endif
    return 0
endfunction

function <SID>Finalised()
    let savelinenum = line(".")
    normal 1G
    call search("^ -- ")
    if match(getline("."), " -- [[:alpha:]][[:alnum:].]")!=-1
	let returnvalue = 1
    else
	let returnvalue = 0
    endif
    execute savelinenum
    return returnvalue
endfunction

" These functions implement the menus
function NewVersion()
    " The new entry is unfinalised and shall be changed
    amenu disable Changelog.New\ Version
    amenu enable Changelog.Add\ Entry
    amenu enable Changelog.Close\ Bug
    amenu enable Changelog.Set\ Distribution
    amenu enable Changelog.Set\ Urgency
    amenu disable Changelog.Unfinalise
    amenu enable Changelog.Finalise
    call append(0, substitute(getline(1), '-\([[:digit:]]\+\))', '-$$\1)', ''))
    call append(1, "")
    call append(2, "")
    call append(3, " -- ")
    call append(4, "")
    call Urgency("low")
    normal 1G0
    call search(")")
    normal h
    normal 
    call setline(1, substitute(getline(1), '-\$\$', '-', ''))
    if exists("g:debchangelog_fold_enable")
        foldopen
    endif
    call AddEntry()
endfunction

function AddEntry()
    normal 1G
    call search("^ -- ")
    normal kk
    call append(".", "  * ")
    normal jjj
    let warn=<SID>WarnIfNotUnfinalised()
    normal kk
    if warn
	echohl MoreMsg
	call input("Hit ENTER")
	echohl None
    endif
    startinsert!
endfunction

function CloseBug()
    normal 1G
    call search("^ -- ")
    let warn=<SID>WarnIfNotUnfinalised()
    normal kk
    call append(".", "  *  (closes: #" . input("Bug number to close: ") . ")")
    normal j^ll
    startinsert
endfunction

function Distribution(dist)
    call setline(1, substitute(getline(1), ')  *\%(UNRELEASED\|\l\+\);', ") " . a:dist . ";", ""))
endfunction

function Urgency(urg)
    call setline(1, substitute(getline(1), "urgency=.*$", "urgency=" . a:urg, ""))
endfunction

function <SID>UnfinaliseMenu()
    " This means the entry shall be changed
    amenu disable Changelog.New\ Version
    amenu enable Changelog.Add\ Entry
    amenu enable Changelog.Close\ Bug
    amenu enable Changelog.Set\ Distribution
    amenu enable Changelog.Set\ Urgency
    amenu disable Changelog.Unfinalise
    amenu enable Changelog.Finalise
endfunction

function Unfinalise()
    call <SID>UnfinaliseMenu()
    normal 1G
    call search("^ -- ")
    call setline(".", " -- ")
endfunction

function <SID>FinaliseMenu()
    " This means the entry should not be changed anymore
    amenu enable Changelog.New\ Version
    amenu disable Changelog.Add\ Entry
    amenu disable Changelog.Close\ Bug
    amenu disable Changelog.Set\ Distribution
    amenu disable Changelog.Set\ Urgency
    amenu enable Changelog.Unfinalise
    amenu disable Changelog.Finalise
endfunction

function Finalise()
    call <SID>FinaliseMenu()
    normal 1G
    call search("^ -- ")
    call setline(".", " -- " . <SID>FullName() . " <" . <SID>Email() . ">  " . <SID>Date())
endfunction


function <SID>MakeMenu()
    amenu &Changelog.&New\ Version			:call NewVersion()<CR>
    amenu Changelog.&Add\ Entry				:call AddEntry()<CR>
    amenu Changelog.&Close\ Bug				:call CloseBug()<CR>
    menu Changelog.-sep-				<nul>

    amenu Changelog.Set\ &Distribution.&unstable	:call Distribution("unstable")<CR>
    amenu Changelog.Set\ Distribution.&frozen		:call Distribution("frozen")<CR>
    amenu Changelog.Set\ Distribution.&stable		:call Distribution("stable")<CR>
    menu Changelog.Set\ Distribution.-sep-		<nul>
    amenu Changelog.Set\ Distribution.frozen\ unstable	:call Distribution("frozen unstable")<CR>
    amenu Changelog.Set\ Distribution.stable\ unstable	:call Distribution("stable unstable")<CR>
    amenu Changelog.Set\ Distribution.stable\ frozen	:call Distribution("stable frozen")<CR>
    amenu Changelog.Set\ Distribution.stable\ frozen\ unstable	:call Distribution("stable frozen unstable")<CR>

    amenu Changelog.Set\ &Urgency.&low			:call Urgency("low")<CR>
    amenu Changelog.Set\ Urgency.&medium		:call Urgency("medium")<CR>
    amenu Changelog.Set\ Urgency.&high			:call Urgency("high")<CR>

    menu Changelog.-sep-				<nul>
    amenu Changelog.U&nfinalise				:call Unfinalise()<CR>
    amenu Changelog.&Finalise				:call Finalise()<CR>

    if <SID>Finalised()
	call <SID>FinaliseMenu()
    else
	call <SID>UnfinaliseMenu()
    endif
endfunction

augroup changelogMenu
au BufEnter * if &filetype == "debchangelog" | call <SID>MakeMenu() | endif
au BufLeave * if &filetype == "debchangelog" | silent! aunmenu Changelog | endif
augroup END

" }}}
" {{{1 folding

" look for an author name in the [zonestart zoneend] lines searching backward
function! s:getAuthor(zonestart, zoneend)
  let linepos = a:zoneend
  while linepos >= a:zonestart
    let line = getline(linepos)
    if line =~ '^ --'
      return substitute(line, '^ --\s*\([^<]\+\)\s*.*', '\1', '')
    endif
    let linepos -= 1
  endwhile
  return '[unknown]'
endfunction

" Look for a package source name searching backward from the givenline and
" returns it. Return the empty string if the package name can't be found
function! DebGetPkgSrcName(lineno)
  let lineidx = a:lineno
  let pkgname = ''
  while lineidx > 0
    let curline = getline(lineidx)
    if curline =~ '^\S'
      let pkgname = matchlist(curline, '^\(\S\+\).*$')[1]
      break
    endif
    let lineidx = lineidx - 1
  endwhile
  return pkgname
endfunction

function! DebChangelogFoldText()
  if v:folddashes == '-'  " changelog entry fold
    return foldtext() . ' -- ' . s:getAuthor(v:foldstart, v:foldend) . ' '
  endif
  return foldtext()
endfunction

function! DebGetChangelogFold(lnum)
  let line = getline(a:lnum)
  if line =~ '^\w\+'
    return '>1' " beginning of a changelog entry
  endif
  if line =~ '^\s\+\[.*\]'
    return '>2' " beginning of an author-specific chunk
  endif
  if line =~ '^ --'
    return '1'
  endif
  return '='
endfunction

if exists("g:debchangelog_fold_enable")
  silent! foldopen!   " unfold the entry the cursor is on (usually the first one)
endif

" }}}

" {{{1 omnicompletion for Closes: #

if !exists('g:debchangelog_listbugs_severities')
  let g:debchangelog_listbugs_severities = 'critical,grave,serious,important,normal,minor,wishlist'
endif

fun! DebCompleteBugs(findstart, base)
  if a:findstart
    let line = getline('.')

    " try to detect whether this is closes: or lp:
    let g:debchangelog_complete_mode = 'debbugs'
    let try_colidx = col('.') - 1
    let colidx = -1 " default to no-completion-possible

    while try_colidx > 0 && line[try_colidx - 1] =~ '\s\|\d\|#\|,\|:'
      let try_colidx = try_colidx - 1
      if line[try_colidx] == '#' && colidx == -1
        " found hash, where we complete from:
        let colidx = try_colidx
      elseif line[try_colidx] == ':'
        if try_colidx > 1 && strpart(line, try_colidx - 2, 3) =~ '\clp:'
          let g:debchangelog_complete_mode = 'lp'
        endif
        break
      endif
    endwhile
    return colidx
  else " return matches:
    let bug_lines = []
    if g:debchangelog_complete_mode == 'lp'
      if ! has('python')
        echoerr 'vim must be built with Python support to use LP bug completion'
        return
      endif
      let pkgsrc = DebGetPkgSrcName(line('.'))
      python << EOF
import vim
try:
    from launchpadlib.launchpad import Launchpad
    from lazr.restfulclient.errors import HTTPError
    # login anonymously
    lp = Launchpad.login_anonymously('debchangelog.vim', 'production')
    ubuntu = lp.distributions['ubuntu']
    try:
        sp = ubuntu.getSourcePackage(name=vim.eval('pkgsrc'))
        status = ('New', 'Incomplete', 'Confirmed', 'Triaged',
                  'In Progress', 'Fix Committed')
        tasklist = sp.searchTasks(status=status, order_by='id')
        liststr = '['
        for task in tasklist:
            bug = task.bug
            liststr += "'#%d - %s'," % (bug.id, bug.title.replace('\'', '\'\''))
        liststr += ']'
        vim.command('silent let bug_lines = %s' % liststr.encode('utf-8'))
    except HTTPError:
        pass
except ImportError:
    vim.command('echoerr \'python-launchpadlib >= 1.5.4 needs to be installed to use Launchpad bug completion\'')
EOF
    else
      if ! filereadable('/usr/sbin/apt-listbugs')
        echoerr 'apt-listbugs not found, you should install it to use Closes bug completion'
        return
      endif
      let pkgsrc = DebGetPkgSrcName(line('.'))
      let listbugs_output = system('/usr/sbin/apt-listbugs -s ' . g:debchangelog_listbugs_severities . ' list ' . pkgsrc . ' | grep "^ #" 2> /dev/null')
      let bug_lines = split(listbugs_output, '\n')
    endif
    let completions = []
    for line in bug_lines
      let parts = matchlist(line, '^\s*\(#\S\+\)\s*-\s*\(.*\)$')
      " filter only those which match a:base:
      if parts[1] !~ "^" . a:base
        continue
      endif
      let completion = {}
      let completion['word'] = parts[1]
      let completion['menu'] = parts[2]
      let completion['info'] = parts[0]
      let completions += [completion]
    endfor
    return completions
  endif
endfun

setlocal omnifunc=DebCompleteBugs

" }}}

" vim: set foldmethod=marker:
                                                                                                                                                                                                                                          usr/share/vim/vim74/ftplugin/debcontrol.vim                                                         0100644 0000000 0000000 00000003536 13050207306 017424  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file (GUI menu and folding)
" Language:     Debian control files
" Maintainer:   Debian Vim Maintainers <pkg-vim-maintainers@lists.alioth.debian.org>
" Former Maintainer:    Pierre Habouzit <madcoder@debian.org>
" Last Change:  2008-03-08
" URL:          http://hg.debian.org/hg/pkg-vim/vim/raw-file/tip/runtime/ftplugin/debcontrol.vim

" Do these settings once per buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin=1

" {{{1 Local settings (do on every load)
if exists("g:debcontrol_fold_enable")
  setlocal foldmethod=expr
  setlocal foldexpr=DebControlFold(v:lnum)
  setlocal foldtext=DebControlFoldText()
endif
setlocal textwidth=0

" Clean unloading
let b:undo_ftplugin = "setlocal tw< foldmethod< foldexpr< foldtext<"

" }}}1

" {{{1 folding

function! s:getField(f, lnum)
  let line = getline(a:lnum)
  let fwdsteps = 0
  while line !~ '^'.a:f.':'
    let fwdsteps += 1
    let line = getline(a:lnum + fwdsteps)
    if line == ''
      return 'unknown'
    endif
  endwhile
  return substitute(line, '^'.a:f.': *', '', '')
endfunction

function! DebControlFoldText()
  if v:folddashes == '-'  " debcontrol entry fold
    let type = substitute(getline(v:foldstart), ':.*', '', '')
    if type == 'Source'
      let ftext = substitute(foldtext(), ' *Source: *', ' ', '')
      return ftext . ' -- ' . s:getField('Maintainer', v:foldstart) . ' '
    endif
    let arch  = s:getField('Architecture', v:foldstart)
    let ftext = substitute(foldtext(), ' *Package: *', ' [' . arch . '] ', '')
    return ftext . ': ' . s:getField('Description', v:foldstart) . ' '
  endif
  return foldtext()
endfunction

function! DebControlFold(l)

  " This is for not merging blank lines around folds to them
  if getline(a:l) =~ '^Source:'
    return '>1'
  endif

  if getline(a:l) =~ '^Package:'
    return '>1'
  endif

  return '='
endfunction

" }}}1
                                                                                                                                                                  usr/share/vim/vim74/ftplugin/denyhosts.vim                                                          0100644 0000000 0000000 00000000567 13050207306 017312  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2007-12-04

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                         usr/share/vim/vim74/ftplugin/dictconf.vim                                                           0100644 0000000 0000000 00000000646 13050207306 017061  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         dict(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                          usr/share/vim/vim74/ftplugin/dictdconf.vim                                                          0100644 0000000 0000000 00000000647 13050207306 017226  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         dictd(8) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                         usr/share/vim/vim74/ftplugin/diff.vim                                                               0100644 0000000 0000000 00000000543 13050207306 016174  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Diff
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2005 Jul 27

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl modeline<"

" Don't use modelines in a diff, they apply to the diffed file
setlocal nomodeline
                                                                                                                                                             usr/share/vim/vim74/ftplugin/dircolors.vim                                                          0100644 0000000 0000000 00000000643 13050207306 017265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         dircolors(1) input file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                             usr/share/vim/vim74/ftplugin/docbk.vim                                                              0100644 0000000 0000000 00000001022 13050207306 016337  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	    DocBook
" Maintainer:	    Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2012-04-25

if exists('b:did_ftplugin')
  finish
endif

if !exists('b:docbk_type')
  if expand('%:e') == 'sgml'
    let b:docbk_type = 'sgml'
  else
    let b:docbk_type = 'xml'
  endif
endif

if b:docbk_type == 'sgml'
  runtime! ftplugin/sgml.vim ftplugin/sgml_*.vim ftplugin/sgml/*.vim
else
  runtime! ftplugin/xml.vim ftplugin/xml_*.vim ftplugin/xml/*.vim
endif

let b:undo_ftplugin = "unlet! b:docbk_type"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/share/vim/vim74/ftplugin/dockerfile.vim                                                         0100644 0000000 0000000 00000000544 13050207306 017374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	Dockerfile
" Maintainer:   Honza Pokorny <http://honza.ca>
" Last Change:	2014 Aug 29

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl commentstring<"

setlocal commentstring=#\ %s
                                                                                                                                                            usr/share/vim/vim74/ftplugin/dosbatch.vim                                                           0100644 0000000 0000000 00000001411 13050207306 017046  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:    MS-DOS .bat files
" Maintainer:  Mike Williams <mrw@eandem.co.uk>
" Last Change: 8th May 2012

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

" BAT comment formatting
setlocal comments=b:rem,b:@rem,b:REM,b:@REM,:::
setlocal formatoptions-=t formatoptions+=rol

" Define patterns for the browse file filter
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "DOS Batch Files (*.bat, *.cmd)\t*.bat;*.cmd\nAll Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setlocal comments< formatoptions<"
    \ . "| unlet! b:browsefiler"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                       usr/share/vim/vim74/ftplugin/dosini.vim                                                             0100644 0000000 0000000 00000000676 13050207306 016560  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Configuration File (ini file) for MSDOS/MS Windows
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:; commentstring=;\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                  usr/share/vim/vim74/ftplugin/dtd.vim                                                                0100644 0000000 0000000 00000002143 13050207306 016035  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	dtd
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal commentstring=<!--%s-->
setlocal comments=s:<!--,m:\ \ \ \ \ ,e:-->

setlocal formatoptions-=t
if !exists("g:ft_dtd_autocomment") || (g:ft_dtd_autocomment == 1)
    setlocal formatoptions+=croql
endif

if exists("loaded_matchit")
    let b:match_words = '<!--:-->,<!:>'
endif

" Change the :browse e filter to primarily show Java-related files.
if has("gui_win32")
    let  b:browsefilter="DTD Files (*.dtd)\t*.dtd\n" .
		\	"XML Files (*.xml)\t*.xml\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal commentstring< comments< formatoptions<" .
		\     " | unlet! b:matchwords b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                             usr/share/vim/vim74/ftplugin/dtrace.vim                                                             0100644 0000000 0000000 00000002177 13050207306 016533  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Language: D script as described in "Solaris Dynamic Tracing Guide",
"           http://docs.sun.com/app/docs/doc/817-6223
" Last Change: 2008/03/20
" Version: 1.2
" Maintainer: Nicolas Weber <nicolasweber@gmx.de>

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Using line continuation here.
let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = "setl fo< com< cms< isk<"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/

" dtrace uses /* */ comments. Set this explicitly, just in case the user
" changed this (/*%s*/ is the default)
setlocal commentstring=/*%s*/

setlocal iskeyword+=@,$

" When the matchit plugin is loaded, this makes the % command skip parens and
" braces in comments.
let b:match_words = &matchpairs
let b:match_skip = 's:comment\|string\|character'

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                 usr/share/vim/vim74/ftplugin/elinks.vim                                                             0100644 0000000 0000000 00000000650 13050207306 016550  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         elinks(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                        usr/share/vim/vim74/ftplugin/erlang.vim                                                             0100644 0000000 0000000 00000003423 13050207306 016534  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim ftplugin file
" Language:     Erlang
" Author:       Oscar Hellstrm <oscar@oscarh.net>
" Contributors: Ricardo Catalinas Jimnez <jimenezrick@gmail.com>
"               Eduardo Lopez (http://github.com/tapichu)
" License:      Vim license
" Version:      2012/01/25

if exists('b:did_ftplugin')
	finish
else
	let b:did_ftplugin = 1
endif

if exists('s:did_function_definitions')
	call s:SetErlangOptions()
	finish
else
	let s:did_function_definitions = 1
endif

let s:cpo_save = &cpo
set cpo&vim

if !exists('g:erlang_keywordprg')
	let g:erlang_keywordprg = 'erl -man'
endif

if !exists('g:erlang_folding')
	let g:erlang_folding = 0
endif

let s:erlang_fun_begin = '^\a\w*(.*$'
let s:erlang_fun_end   = '^[^%]*\.\s*\(%.*\)\?$'

function s:SetErlangOptions()
	if g:erlang_folding
		setlocal foldmethod=expr
		setlocal foldexpr=GetErlangFold(v:lnum)
		setlocal foldtext=ErlangFoldText()
	endif

	setlocal comments=:%%%,:%%,:%
	setlocal commentstring=%%s

	setlocal formatoptions+=ro
	let &l:keywordprg = g:erlang_keywordprg
endfunction

function GetErlangFold(lnum)
	let lnum = a:lnum
	let line = getline(lnum)

	if line =~ s:erlang_fun_end
		return '<1'
	endif

	if line =~ s:erlang_fun_begin && foldlevel(lnum - 1) == 1
		return '1'
	endif

	if line =~ s:erlang_fun_begin
		return '>1'
	endif

	return '='
endfunction

function ErlangFoldText()
	let line    = getline(v:foldstart)
	let foldlen = v:foldend - v:foldstart + 1
	let lines   = ' ' . foldlen . ' lines: ' . substitute(line, "[\ \t]*", '', '')
	if foldlen < 10
		let lines = ' ' . lines
	endif
	let retval = '+' . v:folddashes . lines

	return retval
endfunction

call s:SetErlangOptions()

let b:undo_ftplugin = "setlocal foldmethod< foldexpr< foldtext<"
	\ . " comments< commentstring< formatoptions<"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                             usr/share/vim/vim74/ftplugin/eruby.vim                                                              0100644 0000000 0000000 00000006116 13050207306 016414  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:		eRuby
" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
" URL:			https://github.com/vim-ruby/vim-ruby
" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "All Files (*.*)\t*.*\n"
let s:match_words = ""

if !exists("g:eruby_default_subtype")
  let g:eruby_default_subtype = "html"
endif

if &filetype =~ '^eruby\.'
  let b:eruby_subtype = matchstr(&filetype,'^eruby\.\zs\w\+')
elseif !exists("b:eruby_subtype")
  let s:lines = getline(1)."\n".getline(2)."\n".getline(3)."\n".getline(4)."\n".getline(5)."\n".getline("$")
  let b:eruby_subtype = matchstr(s:lines,'eruby_subtype=\zs\w\+')
  if b:eruby_subtype == ''
    let b:eruby_subtype = matchstr(substitute(expand("%:t"),'\c\%(\.erb\|\.eruby\|\.erubis\)\+$','',''),'\.\zs\w\+$')
  endif
  if b:eruby_subtype == 'rhtml'
    let b:eruby_subtype = 'html'
  elseif b:eruby_subtype == 'rb'
    let b:eruby_subtype = 'ruby'
  elseif b:eruby_subtype == 'yml'
    let b:eruby_subtype = 'yaml'
  elseif b:eruby_subtype == 'js'
    let b:eruby_subtype = 'javascript'
  elseif b:eruby_subtype == 'txt'
    " Conventional; not a real file type
    let b:eruby_subtype = 'text'
  elseif b:eruby_subtype == ''
    let b:eruby_subtype = g:eruby_default_subtype
  endif
endif

if exists("b:eruby_subtype") && b:eruby_subtype != ''
  exe "runtime! ftplugin/".b:eruby_subtype.".vim ftplugin/".b:eruby_subtype."_*.vim ftplugin/".b:eruby_subtype."/*.vim"
else
  runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
endif
unlet! b:did_ftplugin

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin
  unlet b:undo_ftplugin
endif
if exists("b:browsefilter")
  let s:browsefilter = b:browsefilter
  unlet b:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words
  unlet b:match_words
endif

runtime! ftplugin/ruby.vim ftplugin/ruby_*.vim ftplugin/ruby/*.vim
let b:did_ftplugin = 1

" Combine the new set of values with those previously included.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
endif
if exists ("b:browsefilter")
  let s:browsefilter = substitute(b:browsefilter,'\cAll Files (\*\.\*)\t\*\.\*\n','','') . s:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words . ',' . s:match_words
endif

" Change the browse dialog on Win32 to show mainly eRuby-related files
if has("gui_win32")
  let b:browsefilter="eRuby Files (*.erb, *.rhtml)\t*.erb;*.rhtml\n" . s:browsefilter
endif

" Load the combined list of match_words for matchit.vim
if exists("loaded_matchit")
  let b:match_words = s:match_words
endif

" TODO: comments=
setlocal commentstring=<%#%s%>

let b:undo_ftplugin = "setl cms< "
      \ " | unlet! b:browsefilter b:match_words | " . s:undo_ftplugin

let &cpo = s:save_cpo
unlet s:save_cpo

" vim: nowrap sw=2 sts=2 ts=8:
                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/share/vim/vim74/ftplugin/eterm.vim                                                              0100644 0000000 0000000 00000000712 13050207306 016376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         eterm(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s include=^\\s*include
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                      usr/share/vim/vim74/ftplugin/falcon.vim                                                             0100644 0000000 0000000 00000002500 13050207306 016521  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:     Falcon
" Author:       Steven Oliver <oliver.steven@gmail.com>
" Copyright:    Copyright (c) 2009-2013 Steven Oliver
" License:      You may redistribute this under the same terms as Vim itself
" --------------------------------------------------------------------------

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal softtabstop=4 shiftwidth=4 fileencoding=utf-8
setlocal suffixesadd=.fal,.ftd

" Matchit support
if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_ignorecase = 0

  let b:match_words =
	\ '\<\%(if\|case\|while\|until\|for\|do\|class\)\>=\@!' .
	\ ':' .
	\ '\<\%(else\|elsif\|when\)\>' .
	\ ':' .
	\ '\<end\>' .
	\ ',{:},\[:\],(:)'
endif

setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

" Windows allows you to filter the open file dialog
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "Falcon Source Files (*.fal *.ftd)\t*.fal;*.ftd\n" .
                     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setlocal tabstop< shiftwidth< expandtab< fileencoding<"
	\ . " suffixesadd< comments<"
	\ . "| unlet! b:browsefiler"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: set sw=4 sts=4 et tw=80 :
                                                                                                                                                                                                usr/share/vim/vim74/ftplugin/fetchmail.vim                                                          0100644 0000000 0000000 00000000640 13050207306 017216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         fetchmail(1) RC File
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                usr/share/vim/vim74/ftplugin/flexwiki.vim                                                           0100644 0000000 0000000 00000003524 13050207306 017110  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:     FlexWiki, http://www.flexwiki.com/
" Maintainer:   George V. Reilly  <george@reilly.org>
" Home:         http://www.georgevreilly.com/vim/flexwiki/
" Other Home:   http://www.vim.org/scripts/script.php?script_id=1529
" Author:       George V. Reilly
" Filenames:    *.wiki
" Last Change: Wed Apr 26 11:00 PM 2006 P
" Version:      0.3

if exists("b:did_ftplugin")
  finish
endif

let b:did_ftplugin = 1  " Don't load another plugin for this buffer

" Reset the following options to undo this plugin.
let b:undo_ftplugin = "setl tw< wrap< lbr< et< ts< fenc< bomb< ff<"

" Allow lines of unlimited length. Do NOT want automatic linebreaks,
" as a newline starts a new paragraph in FlexWiki.
setlocal textwidth=0
" Wrap long lines, rather than using horizontal scrolling.
setlocal wrap
" Wrap at a character in 'breakat' rather than at last char on screen
setlocal linebreak
" Don't transform <TAB> characters into spaces, as they are significant
" at the beginning of the line for numbered and bulleted lists.
setlocal noexpandtab
" 4-char tabstops, per flexwiki.el
setlocal tabstop=4
" Save *.wiki files in UTF-8
setlocal fileencoding=utf-8
" Add the UTF-8 Byte Order Mark to the beginning of the file
setlocal bomb
" Save <EOL>s as \n, not \r\n
setlocal fileformat=unix

if exists("g:flexwiki_maps")
  " Move up and down by display lines, to account for screen wrapping
  " of very long lines
  nmap <buffer> <Up>   gk
  nmap <buffer> k      gk
  vmap <buffer> <Up>   gk
  vmap <buffer> k      gk

  nmap <buffer> <Down> gj
  nmap <buffer> j      gj
  vmap <buffer> <Down> gj
  vmap <buffer> j      gj

  " for earlier versions - for when 'wrap' is set
  imap <buffer> <S-Down>   <C-o>gj
  imap <buffer> <S-Up>     <C-o>gk
  if v:version >= 700
      imap <buffer> <Down>   <C-o>gj
      imap <buffer> <Up>     <C-o>gk
  endif
endif
                                                                                                                                                                            usr/share/vim/vim74/ftplugin/fortran.vim                                                            0100644 0000000 0000000 00000010161 13050207306 016734  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim settings file
" Language:	Fortran 2008 (and older: Fortran 2003, 95, 90, 77, 66)
" Version:	0.49
" Last Change:	2013 Oct. 01
" Maintainer:	Ajit J. Thakkar <ajit@unb.ca>; <http://www2.unb.ca/~ajit/>
" Usage:	Do :help fortran-plugin from Vim
" Credits:
" Useful suggestions were made by Stefano Zacchiroli, Hendrik Merx, Ben
" Fritz, and David Barnett.

" Only do these settings when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

let s:cposet=&cpoptions
set cpoptions&vim

" Don't do other file type settings for this buffer
let b:did_ftplugin = 1

" Determine whether this is a fixed or free format source file
" if this hasn't been done yet
if !exists("b:fortran_fixed_source")
  if exists("fortran_free_source")
    " User guarantees free source form
    let b:fortran_fixed_source = 0
  elseif exists("fortran_fixed_source")
    " User guarantees fixed source form
    let b:fortran_fixed_source = 1
  else
    " Modern Fortran allows both fixed and free source form
    " assume fixed source form unless signs of free source form
    " are detected in the first five columns of the first s:lmax lines
    " Detection becomes more accurate and time-consuming if more lines
    " are checked. Increase the limit below if you keep lots of comments at
    " the very top of each file and you have a fast computer
    let s:lmax = 500
    if ( s:lmax > line("$") )
      let s:lmax = line("$")
    endif
    let b:fortran_fixed_source = 1
    let s:ln=1
    while s:ln <= s:lmax
      let s:test = strpart(getline(s:ln),0,5)
      if s:test !~ '^[Cc*]' && s:test !~ '^ *[!#]' && s:test =~ '[^ 0-9\t]' && s:test !~ '^[ 0-9]*\t'
	let b:fortran_fixed_source = 0
	break
      endif
      let s:ln = s:ln + 1
    endwhile
    unlet! s:lmax s:ln s:test
  endif
endif

" Set comments and textwidth according to source type
if (b:fortran_fixed_source == 1)
  setlocal comments=:!,:*,:C
  " Fixed format requires a textwidth of 72 for code
  setlocal tw=72
  " If you need to add "&" on continued lines so that the code is
  " compatible with both free and fixed format, then you should do so
  " in column 73 and uncomment the next line
  " setlocal tw=73
else
  setlocal comments=:!
  " Free format allows a textwidth of 132
  setlocal tw=132
endif

" Set commentstring for foldmethod=marker
setlocal cms=!%s

" Tabs are not a good idea in Fortran so the default is to expand tabs
if !exists("fortran_have_tabs")
  setlocal expandtab
endif

" Set 'formatoptions' to break text lines
setlocal fo+=t

setlocal include=^\\c#\\=\\s*include\\s\\+
setlocal suffixesadd+=.f08,.f03,.f95,.f90,.for,.f,.F,.f77,.ftn,.fpp

" Define patterns for the matchit plugin
if !exists("b:match_words")
  let s:notend = '\%(\<end\s\+\)\@<!'
  let s:notselect = '\%(\<select\s\+\)\@<!'
  let s:notelse = '\%(\<end\s\+\|\<else\s\+\)\@<!'
  let s:notprocedure = '\%(\s\+procedure\>\)\@!'
  let b:match_ignorecase = 1
  let b:match_words =
    \ '(:),' .
    \ '\<select\s*case\>:' . s:notselect. '\<case\>:\<end\s*select\>,' .
    \ s:notelse . '\<if\s*(.\+)\s*then\>:' .
    \ '\<else\s*\%(if\s*(.\+)\s*then\)\=\>:\<end\s*if\>,'.
    \ 'do\s\+\(\d\+\):\%(^\s*\)\@<=\1\s,'.
    \ s:notend . '\<do\>:\<end\s*do\>,'.
    \ s:notelse . '\<where\>:\<elsewhere\>:\<end\s*where\>,'.
    \ s:notend . '\<type\s*[^(]:\<end\s*type\>,'.
    \ s:notend . '\<forall\>:\<end\s*forall\>,'.
    \ s:notend . '\<associate\>:\<end\s*associate\>,'.
    \ s:notend . '\<enum\>:\<end\s*enum\>,'.
    \ s:notend . '\<interface\>:\<end\s*interface\>,'.
    \ s:notend . '\<subroutine\>:\<end\s*subroutine\>,'.
    \ s:notend . '\<function\>:\<end\s*function\>,'.
    \ s:notend . '\<module\>' . s:notprocedure . ':\<end\s*module\>,'.
    \ s:notend . '\<program\>:\<end\s*program\>'
endif

" File filters for :browse e
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "Fortran Files (*.f;*.for;*.f77;*.f90;*.f95;*.f03;*.f08;*.fpp;*.ftn)\t*.f;*.for;*.f77;*.f90;*.f95;*.f03;*.f08;*.fpp;*.ftn\n" .
    \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl fo< com< tw< cms< et< inc< sua<"
	\ . "| unlet! b:match_ignorecase b:match_words b:browsefilter"

let &cpoptions=s:cposet
unlet s:cposet

" vim:sw=2
                                                                                                                                                                                                                                                                                                                                                                                                               usr/share/vim/vim74/ftplugin/framescript.vim                                                        0100644 0000000 0000000 00000001400 13050207306 017574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim ftplugin file
" Language:         FrameScript
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-19

let s:cpo_save = &cpo
set cpo&vim

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl com< cms< fo< inc< | unlet! b:matchwords"

setlocal comments=s1:/*,mb:*,ex:*/,:// commentstring=/*\ %s\ */
setlocal formatoptions-=t formatoptions+=croql
setlocal include=^\\s*<#Include

if exists("loaded_matchit")
  let s:not_end = '\c\%(\<End\)\@<!'
  let b:match_words =
        \ s:not_end . '\<If\>:\c\<ElseIf\>:\c\<Else\>:\c\<EndIf\>,' .
        \ s:not_end . '\<Loop\>:\c\<EndLoop\>' .
        \ s:not_end . '\<Sub\>:\c\<EndSub\>'
  unlet s:not_end
endif

let &cpo = s:cpo_save 
unlet s:cpo_save
                                                                                                                                                                                                                                                                usr/share/vim/vim74/ftplugin/fvwm.vim                                                               0100644 0000000 0000000 00000000606 13050207306 016243  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Created	: Tue 09 May 2006 02:07:31 PM CDT
" Modified	: Tue 09 May 2006 02:07:31 PM CDT
" Author	: Gautam Iyer <gi1242@users.sourceforge.net>
" Description	: ftplugin for fvwm config files

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql
                                                                                                                          usr/share/vim/vim74/ftplugin/git.vim                                                                0100644 0000000 0000000 00000002302 13050207306 016042  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	generic git output
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2013 May 30

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

if !exists('b:git_dir')
  if expand('%:p') =~# '[\/]\.git[\/]modules[\/]'
    " Stay out of the way
  elseif expand('%:p') =~# '\.git\>'
    let b:git_dir = matchstr(expand('%:p'),'.*\.git\>')
  elseif $GIT_DIR != ''
    let b:git_dir = $GIT_DIR
  endif
  if (has('win32') || has('win64')) && exists('b:git_dir')
    let b:git_dir = substitute(b:git_dir,'\\','/','g')
  endif
endif

if exists('*shellescape') && exists('b:git_dir') && b:git_dir != ''
  if b:git_dir =~# '/\.git$' " Not a bare repository
    let &l:path = escape(fnamemodify(b:git_dir,':h'),'\, ').','.&l:path
  endif
  let &l:path = escape(b:git_dir,'\, ').','.&l:path
  let &l:keywordprg = 'git --git-dir='.shellescape(b:git_dir).' show'
else
  setlocal keywordprg=git\ show
endif
if has('gui_running')
  let &l:keywordprg = substitute(&l:keywordprg,'^git\>','git --no-pager','')
endif

setlocal includeexpr=substitute(v:fname,'^[^/]\\+/','','')
let b:undo_ftplugin = "setl keywordprg< path< includeexpr<"
                                                                                                                                                                                                                                                                                                                              usr/share/vim/vim74/ftplugin/gitcommit.vim                                                          0100644 0000000 0000000 00000004245 13050207306 017263  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	git commit file
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2013 May 30

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif

runtime! ftplugin/git.vim
let b:did_ftplugin = 1

setlocal nomodeline tabstop=8 formatoptions-=croq formatoptions+=tl

let b:undo_ftplugin = 'setl modeline< tabstop< formatoptions<'

if &textwidth == 0
  " make sure that log messages play nice with git-log on standard terminals
  setlocal textwidth=72
  let b:undo_ftplugin .= "|setl tw<"
endif

if exists("g:no_gitcommit_commands") || v:version < 700
  finish
endif

if !exists("b:git_dir")
  let b:git_dir = expand("%:p:h")
endif

command! -bang -bar -buffer -complete=custom,s:diffcomplete -nargs=* DiffGitCached :call s:gitdiffcached(<bang>0,b:git_dir,<f-args>)

function! s:diffcomplete(A,L,P)
  let args = ""
  if a:P <= match(a:L." -- "," -- ")+3
    let args = args . "-p\n--stat\n--shortstat\n--summary\n--patch-with-stat\n--no-renames\n-B\n-M\n-C\n"
  end
  if exists("b:git_dir") && a:A !~ '^-'
    let tree = fnamemodify(b:git_dir,':h')
    if strpart(getcwd(),0,strlen(tree)) == tree
      let args = args."\n".system("git diff --cached --name-only")
    endif
  endif
  return args
endfunction

function! s:gitdiffcached(bang,gitdir,...)
  let tree = fnamemodify(a:gitdir,':h')
  let name = tempname()
  let git = "git"
  if strpart(getcwd(),0,strlen(tree)) != tree
    let git .= " --git-dir=".(exists("*shellescape") ? shellescape(a:gitdir) : '"'.a:gitdir.'"')
  endif
  if a:0
    let extra = join(map(copy(a:000),exists("*shellescape") ? 'shellescape(v:val)' : "'\"'.v:val.'\"'"))
  else
    let extra = "-p --stat=".&columns
  endif
  call system(git." diff --cached --no-color --no-ext-diff ".extra." > ".(exists("*shellescape") ? shellescape(name) : name))
  exe "pedit ".(exists("*fnameescape") ? fnameescape(name) : name)
  wincmd P
  let b:git_dir = a:gitdir
  command! -bang -bar -buffer -complete=custom,s:diffcomplete -nargs=* DiffGitCached :call s:gitdiffcached(<bang>0,b:git_dir,<f-args>)
  nnoremap <buffer> <silent> q :q<CR>
  setlocal buftype=nowrite nobuflisted noswapfile nomodifiable filetype=git
endfunction
                                                                                                                                                                                                                                                                                                                                                           usr/share/vim/vim74/ftplugin/gitconfig.vim                                                          0100644 0000000 0000000 00000000570 13050207306 017235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	git config file
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2009 Dec 24

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

setlocal formatoptions-=t formatoptions+=croql
setlocal comments=:#,:; commentstring=;\ %s

let b:undo_ftplugin = "setl fo< com< cms<"
                                                                                                                                        usr/share/vim/vim74/ftplugin/gitrebase.vim                                                          0100644 0000000 0000000 00000002632 13050207306 017232  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	git rebase --interactive
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2010 May 21

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif

runtime! ftplugin/git.vim
let b:did_ftplugin = 1

setlocal comments=:# commentstring=#\ %s formatoptions-=t
if !exists("b:undo_ftplugin")
  let b:undo_ftplugin = ""
endif
let b:undo_ftplugin = b:undo_ftplugin."|setl com< cms< fo<"

function! s:choose(word)
  s/^\(\w\+\>\)\=\(\s*\)\ze\x\{4,40\}\>/\=(strlen(submatch(1)) == 1 ? a:word[0] : a:word) . substitute(submatch(2),'^$',' ','')/e
endfunction

function! s:cycle()
  call s:choose(get({'s':'edit','p':'squash','e':'reword','r':'fixup'},getline('.')[0],'pick'))
endfunction

command! -buffer -bar Pick   :call s:choose('pick')
command! -buffer -bar Squash :call s:choose('squash')
command! -buffer -bar Edit   :call s:choose('edit')
command! -buffer -bar Reword :call s:choose('reword')
command! -buffer -bar Fixup  :call s:choose('fixup')
command! -buffer -bar Cycle  :call s:cycle()
" The above are more useful when they are mapped; for example:
"nnoremap <buffer> <silent> S :Cycle<CR>

if exists("g:no_plugin_maps") || exists("g:no_gitrebase_maps")
  finish
endif

nnoremap <buffer> <expr> K col('.') < 7 && expand('<Lt>cword>') =~ '\X' && getline('.') =~ '^\w\+\s\+\x\+\>' ? 'wK' : 'K'

let b:undo_ftplugin = b:undo_ftplugin . "|nunmap <buffer> K"
                                                                                                      usr/share/vim/vim74/ftplugin/gitsendemail.vim                                                       0100644 0000000 0000000 00000000235 13050207306 017727  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	git send-email message
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2009 Dec 24

runtime! ftplugin/mail.vim
                                                                                                                                                                                                                                                                                                                                                                   usr/share/vim/vim74/ftplugin/go.vim                                                                 0100644 0000000 0000000 00000000555 13050207306 015674  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Go
" Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
" Last Change:	2014 Aug 16

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

setlocal formatoptions-=t

setlocal comments=s1:/*,mb:*,ex:*/,://
setlocal commentstring=//\ %s

let b:undo_ftplugin = 'setl fo< com< cms<'

" vim: sw=2 sts=2 et
                                                                                                                                                   usr/share/vim/vim74/ftplugin/gpg.vim                                                                0100644 0000000 0000000 00000000645 13050207306 016044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         gpg(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                           usr/share/vim/vim74/ftplugin/gprof.vim                                                              0100644 0000000 0000000 00000001653 13050207306 016404  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Language:    gprof
" Maintainer:  Dominique Pelle <dominique.pelle@gmail.com>
" Last Change: 2013 Jun 09

" When cursor is on one line of the gprof call graph,
" calling this function jumps to this function in the call graph.
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin=1

fun! <SID>GprofJumpToFunctionIndex()
  let l:line = getline('.')
  if l:line =~ '[\d\+\]$'
    " We're in a line in the call graph.
    norm! $y%
    call search('^' . escape(@", '[]'), 'sw')
    norm! zz
  elseif l:line =~ '^\(\s\+[0-9\.]\+\)\{3}\s\+'
    " We're in line in the flat profile.
    norm! 55|eby$
    call search('^\[\d\+\].*\d\s\+' .  escape(@", '[]*.') . '\>', 'sW')
    norm! zz
  endif
endfun

" Pressing <C-]> on a line in the gprof flat profile or in
" the call graph, jumps to the corresponding function inside
" the flat profile.
map <buffer> <silent> <C-]> :call <SID>GprofJumpToFunctionIndex()<CR>

" vim:sw=2 fdm=indent
                                                                                     usr/share/vim/vim74/ftplugin/group.vim                                                              0100644 0000000 0000000 00000000635 13050207306 016422  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         group(5) user group file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments= commentstring= formatoptions-=tcroq formatoptions+=l

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                   usr/share/vim/vim74/ftplugin/grub.vim                                                               0100644 0000000 0000000 00000000646 13050207306 016227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         grub(8) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                          usr/share/vim/vim74/ftplugin/haml.vim                                                               0100644 0000000 0000000 00000003537 13050207306 016213  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	Haml
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2013 Jun 01

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
unlet! b:did_ftplugin
set matchpairs-=<:>

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin
  unlet b:undo_ftplugin
endif
if exists("b:browsefilter")
  let s:browsefilter = b:browsefilter
  unlet b:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words
  unlet b:match_words
endif

runtime! ftplugin/ruby.vim ftplugin/ruby_*.vim ftplugin/ruby/*.vim
let b:did_ftplugin = 1

" Combine the new set of values with those previously included.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
endif
if exists ("b:browsefilter")
  let s:browsefilter = substitute(b:browsefilter,'\cAll Files (\*\.\*)\t\*\.\*\n','','') . s:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words . ',' . s:match_words
endif

" Change the browse dialog on Win32 to show mainly Haml-related files
if has("gui_win32")
  let b:browsefilter="Haml Files (*.haml)\t*.haml\nSass Files (*.sass)\t*.sass\n" . s:browsefilter
endif

" Load the combined list of match_words for matchit.vim
if exists("loaded_matchit")
  let b:match_words = s:match_words
endif

setlocal comments= commentstring=-#\ %s

let b:undo_ftplugin = "setl cms< com< "
      \ " | unlet! b:browsefilter b:match_words | " . s:undo_ftplugin

let &cpo = s:save_cpo
unlet s:save_cpo

" vim:set sw=2:
                                                                                                                                                                 usr/share/vim/vim74/ftplugin/hamster.vim                                                            0100644 0000000 0000000 00000003603 13050207306 016727  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:    Hamster Script
" Version:     2.0.6.0
" Maintainer:  David Fishburn <fishburn@ianywhere.com>
" Last Change: Wed Nov 08 2006 12:03:09 PM

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = "setl fo< com< tw< commentstring<"
	\ . "| unlet! b:match_ignorecase b:match_words b:match_skip"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Use the # sign for comments
setlocal comments=:#

" Format comments to be up to 78 characters long
if &tw == 0
  setlocal tw=78
endif

" Comments start with a double quote
setlocal commentstring=#%s

" Move around functions.
noremap <silent><buffer> [[ :call search('^\s*sub\>', "bW")<CR>
noremap <silent><buffer> ]] :call search('^\s*sub\>', "W")<CR>
noremap <silent><buffer> [] :call search('^\s*endsub\>', "bW")<CR>
noremap <silent><buffer> ][ :call search('^\s*endsub\>', "W")<CR>

" Move around comments
noremap <silent><buffer> ]# :call search('^\s*#\@!', "W")<CR>
noremap <silent><buffer> [# :call search('^\s*#\@!', "bW")<CR>

" Let the matchit plugin know what items can be matched.
if exists("loaded_matchit")
  let b:match_ignorecase = 0
  let b:match_words =
	\ '\<sub\>:\<return\>:\<endsub\>,' .
        \ '\<do\|while\|repeat\|for\>:\<break\>:\<continue\>:\<loop\|endwhile\|until\|endfor\>,' .
	\ '\<if\>:\<else\%[if]\>:\<endif\>' 

  " Ignore ":syntax region" commands, the 'end' argument clobbers if-endif
  " let b:match_skip = 'getline(".") =~ "^\\s*sy\\%[ntax]\\s\\+region" ||
  "	\ synIDattr(synID(line("."),col("."),1),"name") =~? "comment\\|string"'
endif

setlocal ignorecase
let &cpo = s:cpo_save
unlet s:cpo_save
setlocal cpo+=M		" makes \%( match \)
                                                                                                                             usr/share/vim/vim74/ftplugin/haskell.vim                                                            0100644 0000000 0000000 00000000661 13050207306 016710  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Haskell
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=s1fl:{-,mb:-,ex:-},:-- commentstring=--\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                               usr/share/vim/vim74/ftplugin/help.vim                                                               0100644 0000000 0000000 00000000656 13050207306 016221  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Vim help file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl fo< tw< cole< cocu<"

setlocal formatoptions+=tcroql textwidth=78
if has("conceal")
  setlocal cole=2 cocu=nc
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                  usr/share/vim/vim74/ftplugin/hostconf.vim                                                           0100644 0000000 0000000 00000000567 13050207306 017115  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2007-12-04

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                         usr/share/vim/vim74/ftplugin/hostsaccess.vim                                                        0100644 0000000 0000000 00000000650 13050207306 017605  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         hosts_access(5) control file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                        usr/share/vim/vim74/ftplugin/html.vim                                                               0100644 0000000 0000000 00000003131 13050207306 016224  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	html
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal matchpairs+=<:>
setlocal commentstring=<!--%s-->
setlocal comments=s:<!--,m:\ \ \ \ ,e:-->

if exists("g:ft_html_autocomment") && (g:ft_html_autocomment == 1)
    setlocal formatoptions-=t formatoptions+=croql
endif

if exists('&omnifunc')
  setlocal omnifunc=htmlcomplete#CompleteTags
  call htmlcomplete#DetectOmniFlavor()
endif

" HTML:  thanks to Johannes Zellner and Benji Fisher.
if exists("loaded_matchit")
    let b:match_ignorecase = 1
    let b:match_words = '<:>,' .
    \ '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,' .
    \ '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,' .
    \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
endif

" Change the :browse e filter to primarily show HTML-related files.
if has("gui_win32")
    let  b:browsefilter="HTML Files (*.html,*.htm)\t*.htm;*.html\n" .
		\	"JavaScript Files (*.js)\t*.js\n" .
		\	"Cascading StyleSheets (*.css)\t*.css\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions<" .
    \	" | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/share/vim/vim74/ftplugin/htmldjango.vim                                                         0100644 0000000 0000000 00000000513 13050207306 017410  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Django HTML template
" Maintainer:	Dave Hodder <dmh@dmh.org.uk>
" Last Change:	2007 Jan 25

" Only use this filetype plugin when no other was loaded.
if exists("b:did_ftplugin")
  finish
endif

" Use HTML and Django template ftplugins.
runtime! ftplugin/html.vim
runtime! ftplugin/django.vim
                                                                                                                                                                                     usr/share/vim/vim74/ftplugin/indent.vim                                                             0100644 0000000 0000000 00000000672 13050207306 016550  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         indent(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=s1:/*,mb:*,ex:*/ commentstring&
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                      usr/share/vim/vim74/ftplugin/initex.vim                                                             0100644 0000000 0000000 00000001755 13050207306 016572  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " filetype plugin for TeX and variants
" Language:     TeX (ft=initex)
" Maintainer:   Benji Fisher, Ph.D. <benji@member.AMS.org>
" Version:	1.0
" Last Change:	Wed 19 Apr 2006

" Only do this when not done yet for this buffer.
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer.
let b:did_ftplugin = 1

" Avoid problems if running in 'compatible' mode.
let s:save_cpo = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< define< include< sua<"

" Set 'comments' to format dashed lists in comments
setlocal com=sO:%\ -,mO:%\ \ ,eO:%%,:%

" Set 'commentstring' to recognize the % comment character:
" (Thanks to Ajit Thakkar.)
setlocal cms=%%s

" Allow "[d" to be used to find a macro definition:
let &l:define='\\\([egx]\|char\|mathchar\|count\|dimen\|muskip\|skip\|toks\)\='
	\ .	'def\|\\font\|\\\(future\)\=let'

" Tell Vim to recognize \input bar :
let &l:include = '\\input'
setlocal suffixesadd=.tex

let &cpo = s:save_cpo
unlet s:save_cpo

" vim:sts=2:sw=2:
                   usr/share/vim/vim74/ftplugin/ishd.vim                                                               0100644 0000000 0000000 00000002360 13050207306 016212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	InstallShield (ft=ishd)
" Maintainer:	Johannes Zellner <johannes@zellner.org>
" Last Change:	Sat, 24 May 2003 11:55:36 CEST

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

setlocal foldmethod=syntax

" Using line continuation here.
let s:cpo_save = &cpo
set cpo-=C

" matchit support
if exists("loaded_matchit")
    let b:match_ignorecase=0
    let b:match_words=
    \ '\%(^\s*\)\@<=\<function\>\s\+[^()]\+\s*(:\%(^\s*\)\@<=\<begin\>\s*$:\%(^\s*\)\@<=\<return\>:\%(^\s*\)\@<=\<end\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<repeat\>\s*$:\%(^\s*\)\@<=\<until\>\s\+.\{-}\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<switch\>\s*(.\{-}):\%(^\s*\)\@<=\<\%(case\|default\)\>:\%(^\s*\)\@<=\<endswitch\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<while\>\s*(.\{-}):\%(^\s*\)\@<=\<endwhile\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<for\>.\{-}\<\%(to\|downto\)\>:\%(^\s*\)\@<=\<endfor\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<if\>\s*(.\{-})\s*then:\%(^\s*\)\@<=\<else\s*if\>\s*([^)]*)\s*then:\%(^\s*\)\@<=\<else\>:\%(^\s*\)\@<=\<endif\>\s*;\s*$'
endif

if has("gui_win32") && !exists("b:browsefilter")
    let b:browsefilter = "InstallShield Files (*.rul)\t*.rul\n" .
		       \ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                usr/share/vim/vim74/ftplugin/j.vim                                                                  0100644 0000000 0000000 00000006012 13050207306 015512  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	J
" Maintainer:	David Bürgin <676c7473@gmail.com>
" URL:		https://github.com/glts/vim-j
" Last Change:	2014-04-05

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let s:save_cpo = &cpo
set cpo&vim

setlocal iskeyword=48-57,A-Z,_,a-z
setlocal comments=:NB.
setlocal commentstring=NB.\ %s
setlocal formatoptions-=t
setlocal shiftwidth=2 softtabstop=2 expandtab
setlocal matchpairs=(:)

let b:undo_ftplugin = 'setlocal matchpairs< expandtab< softtabstop< shiftwidth< formatoptions< commentstring< comments< iskeyword<'

" Section movement with ]] ][ [[ []. The start/end patterns below are amended
" inside the function in order to avoid matching on the current cursor line.
let s:sectionstart = '.\{-}\<\%([0-4]\|13\|noun\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(:\s*0\|def\s\+0\|define\)\>.*'
let s:sectionend = '\s*)\s*'

function! s:SearchSection(end, backwards, visualmode) abort
  if a:visualmode !=# ''
    normal! gv
  endif
  let flags = a:backwards ? 'bsW' : 'sW'
  if a:end
    call search('^' . s:sectionend . (a:backwards ? '\n\_.\{-}\%#' : '$'), flags)
  else
    call search('^' . s:sectionstart . (a:backwards ? '\n\_.\{-}\%#' : '$'), flags)
  endif
endfunction

noremap <script> <buffer> <silent> ]] :<C-U>call <SID>SearchSection(0, 0, '')<CR>
xnoremap <script> <buffer> <silent> ]] :<C-U>call <SID>SearchSection(0, 0, visualmode())<CR>
sunmap <buffer> ]]
noremap <script> <buffer> <silent> ][ :<C-U>call <SID>SearchSection(1, 0, '')<CR>
xnoremap <script> <buffer> <silent> ][ :<C-U>call <SID>SearchSection(1, 0, visualmode())<CR>
sunmap <buffer> ][
noremap <script> <buffer> <silent> [[ :<C-U>call <SID>SearchSection(0, 1, '')<CR>
xnoremap <script> <buffer> <silent> [[ :<C-U>call <SID>SearchSection(0, 1, visualmode())<CR>
sunmap <buffer> [[
noremap <script> <buffer> <silent> [] :<C-U>call <SID>SearchSection(1, 1, '')<CR>
xnoremap <script> <buffer> <silent> [] :<C-U>call <SID>SearchSection(1, 1, visualmode())<CR>
sunmap <buffer> []

let b:undo_ftplugin .= ' | silent! execute "unmap <buffer> ]]"'
                   \ . ' | silent! execute "unmap <buffer> ]["'
                   \ . ' | silent! execute "unmap <buffer> [["'
                   \ . ' | silent! execute "unmap <buffer> []"'

" Browse dialog filter on Windows (see ":help browsefilter")
if has('gui_win32') && !exists('b:browsefilter')
  let b:browsefilter = "J Script Files (*.ijs)\t*.ijs\n"
                   \ . "All Files (*.*)\t*.*\n"
  let b:undo_ftplugin .= ' | unlet! b:browsefilter'
endif

" Enhanced "%" matching (see ":help matchit")
if exists('loaded_matchit') && !exists('b:match_words')
  let b:match_ignorecase = 0
  let b:match_words = '^.\{-}\<\%([0-4]\|13\|noun\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(\:\s*0\|def\s\+0\|define\)\>:^\s*\:\s*$:^\s*)\s*$'
                  \ . ',\<\%(for\%(_\a\k*\)\=\|if\|select\|try\|whil\%(e\|st\)\)\.:\<\%(case\|catch[dt]\=\|else\%(if\)\=\|fcase\)\.:\<end\.'
  let b:undo_ftplugin .= ' | unlet! b:match_ignorecase b:match_words'
endif

let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/share/vim/vim74/ftplugin/java.vim                                                               0100644 0000000 0000000 00000003226 13050207306 016206  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Java
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Change:  2012 Mar 11
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" For filename completion, prefer the .java extension over the .class
" extension.
set suffixes+=.class

" Enable gf on import statements.  Convert . in the package
" name to / and append .java to the name, then search the path.
setlocal includeexpr=substitute(v:fname,'\\.','/','g')
setlocal suffixesadd=.java
if exists("g:ftplugin_java_source_path")
    let &l:path=g:ftplugin_java_source_path . ',' . &l:path
endif

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal formatoptions-=t formatoptions+=croql

" Set 'comments' to format dashed lists in comments. Behaves just like C.
setlocal comments& comments^=sO:*\ -,mO:*\ \ ,exO:*/

setlocal commentstring=//%s

" Change the :browse e filter to primarily show Java-related files.
if has("gui_win32")
    let  b:browsefilter="Java Files (*.java)\t*.java\n" .
		\	"Properties Files (*.prop*)\t*.prop*\n" .
		\	"Manifest Files (*.mf)\t*.mf\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal suffixes< suffixesadd<" .
		\     " formatoptions< comments< commentstring< path< includeexpr<" .
		\     " | unlet! b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                          usr/share/vim/vim74/ftplugin/javascript.vim                                                         0100644 0000000 0000000 00000002027 13050207306 017431  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Javascript
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:  2008 Jun 15
" URL:		http://gus.gscit.monash.edu.au/~djkea2/vim/ftplugin/javascript.vim

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo-=C

" Set 'formatoptions' to break comment lines but not other lines,
" " and insert the comment leader when hitting <CR> or using "o".
setlocal formatoptions-=t formatoptions+=croql

" Set completion with CTRL-X CTRL-O to autoloaded function.
if exists('&ofu')
    setlocal omnifunc=javascriptcomplete#CompleteJS
endif

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

setlocal commentstring=//%s

" Change the :browse e filter to primarily show Java-related files.
if has("gui_win32")
    let  b:browsefilter="Javascript Files (*.js)\t*.js\n" .
		\	"All Files (*.*)\t*.*\n"
endif
       
let b:undo_ftplugin = "setl fo< ofu< com< cms<" 

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/share/vim/vim74/ftplugin/jproperties.vim                                                        0100644 0000000 0000000 00000000501 13050207306 017624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	Java properties file
" Maintainer:	David Bürgin <676c7473@gmail.com>
" Last Change:	2013-11-19

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

setlocal formatoptions-=t
setlocal comments=:#,:!
setlocal commentstring=#\ %s

let b:undo_ftplugin = "setl cms< com< fo<"
                                                                                                                                                                                               usr/share/vim/vim74/ftplugin/json.vim                                                               0100644 0000000 0000000 00000000550 13050207306 016233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:		JSON
" Maintainer:		David Barnett <daviebdawg+vim@gmail.com>
" Last Change:		2014 Jul 16

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = 'setlocal formatoptions< comments< commentstring<'

setlocal formatoptions-=t

" JSON has no comments.
setlocal comments=
setlocal commentstring=
                                                                                                                                                        usr/share/vim/vim74/ftplugin/jsp.vim                                                                0100644 0000000 0000000 00000003733 13050207306 016064  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	jsp
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "Java Files (*.java)\t*.java\n" .
	    \	 "HTML Files (*.html, *.htm)\t*.html;*.htm\n" .
	    \	 "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
unlet b:did_ftplugin

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
    unlet b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
    unlet b:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words
    unlet b:match_words
endif

runtime! ftplugin/java.vim ftplugin/java_*.vim ftplugin/java/*.vim
let b:did_ftplugin = 1

" Combine the new set of values with those previously included.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
endif
if exists ("b:browsefilter")
    let s:browsefilter = b:browsefilter . s:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words . ',' . s:match_words
endif

" Load the combined list of match_words for matchit.vim
if exists("loaded_matchit")
    let b:match_words = s:match_words
endif

" Change the :browse e filter to primarily show JSP-related files.
if has("gui_win32")
    let  b:browsefilter="JSP Files (*.jsp)\t*.jsp\n" . s:browsefilter
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:browsefilter b:match_words | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                     usr/share/vim/vim74/ftplugin/kconfig.vim                                                            0100644 0000000 0000000 00000000567 13050207306 016712  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                         usr/share/vim/vim74/ftplugin/kwt.vim                                                                0100644 0000000 0000000 00000001523 13050207306 016070  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Kimwitu++
" Maintainer:	Michael Piefel <entwurf@piefel.de>
" Last Change:	10 March 2012

" Behaves almost like C++
runtime! ftplugin/cpp.vim ftplugin/cpp_*.vim ftplugin/cpp/*.vim

let s:cpo_save = &cpo
set cpo&vim

" Limit the browser to related files
if has("gui_win32") && !exists("b:browsefilter")
    let b:browsefilter = "Kimwitu/Kimwitu++ Files (*.k)\t*.k\n" .
		\ "Lex/Flex Files (*.l)\t*.l\n" .
		\ "Yacc/Bison Files (*.y)\t*.y\n" .
		\ "All Files (*.*)\t*.*\n"
endif

" Set the errorformat for the Kimwitu++ compiler
set efm+=kc%.%#:\ error\ at\ %f:%l:\ %m

if exists("b:undo_ftplugin")
    let b:undo_ftplugin = b:undo_ftplugin . " | setlocal efm<"
	\ . "| unlet! b:browsefiler"
else
    let b:undo_ftplugin = "setlocal efm<"
	\ . "| unlet! b:browsefiler"
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                             usr/share/vim/vim74/ftplugin/ld.vim                                                                 0100644 0000000 0000000 00000000712 13050207306 015661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         ld(1) script
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=s1:/*,mb:*,ex:*/ commentstring=/*%s*/ include=^\\s*INCLUDE
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                      usr/share/vim/vim74/ftplugin/lftp.vim                                                               0100644 0000000 0000000 00000000646 13050207306 016235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         lftp(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                          usr/share/vim/vim74/ftplugin/libao.vim                                                              0100644 0000000 0000000 00000000654 13050207306 016355  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         libao.conf(5) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                    usr/share/vim/vim74/ftplugin/limits.vim                                                             0100644 0000000 0000000 00000000650 13050207306 016564  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         limits(5) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                        usr/share/vim/vim74/ftplugin/liquid.vim                                                             0100644 0000000 0000000 00000003551 13050207306 016555  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:     Liquid
" Maintainer:   Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2010 May 21

if exists('b:did_ftplugin')
  finish
endif

if !exists('g:liquid_default_subtype')
  let g:liquid_default_subtype = 'html'
endif

if !exists('b:liquid_subtype')
  let s:lines = getline(1)."\n".getline(2)."\n".getline(3)."\n".getline(4)."\n".getline(5)."\n".getline("$")
  let b:liquid_subtype = matchstr(s:lines,'liquid_subtype=\zs\w\+')
  if b:liquid_subtype == ''
    let b:liquid_subtype = matchstr(&filetype,'^liquid\.\zs\w\+')
  endif
  if b:liquid_subtype == ''
    let b:liquid_subtype = matchstr(substitute(expand('%:t'),'\c\%(\.liquid\)\+$','',''),'\.\zs\w\+$')
  endif
  if b:liquid_subtype == ''
    let b:liquid_subtype = g:liquid_default_subtype
  endif
endif

if exists('b:liquid_subtype') && b:liquid_subtype != ''
  exe 'runtime! ftplugin/'.b:liquid_subtype.'.vim ftplugin/'.b:liquid_subtype.'_*.vim ftplugin/'.b:liquid_subtype.'/*.vim'
else
  runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
endif
let b:did_ftplugin = 1

if exists('b:undo_ftplugin')
  let b:undo_ftplugin .= '|'
else
  let b:undo_ftplugin = ''
endif
if exists('b:browsefilter')
  let b:browsefilter = "\n".b:browsefilter
else
  let b:browsefilter = ''
endif
if exists('b:match_words')
  let b:match_words .= ','
elseif exists('loaded_matchit')
  let b:match_words = ''
endif

if has('gui_win32')
  let b:browsefilter="Liquid Files (*.liquid)\t*.liquid" . b:browsefilter
endif

if exists('loaded_matchit')
  let b:match_words .= '\<\%(if\w*\|unless\|case\)\>:\<\%(elsif\|else\|when\)\>:\<end\%(if\w*\|unless\|case\)\>,\<\%(for\|tablerow\)\>:\%({%\s*\)\@<=empty\>:\<end\%(for\|tablerow\)\>,<\(capture\|comment\|highlight\)\>:\<end\1\>'
endif

setlocal commentstring={%\ comment\ %}%s{%\ endcomment\ %}

let b:undo_ftplugin .= 'setl cms< | unlet! b:browsefilter b:match_words'
                                                                                                                                                       usr/share/vim/vim74/ftplugin/lisp.vim                                                               0100644 0000000 0000000 00000001401 13050207306 016225  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:      Lisp
" Maintainer:    Sergey Khorev <sergey.khorev@gmail.com>
" URL:		 http://sites.google.com/site/khorser/opensource/vim
" Original author:    Dorai Sitaram <ds26@gte.com>
" Original URL:		 http://www.ccs.neu.edu/~dorai/vimplugins/vimplugins.html
" Last Change:   Oct 23, 2013

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

setl comments=:;
setl define=^\\s*(def\\k*
setl formatoptions-=t
setl iskeyword+=+,-,*,/,%,<,=,>,:,$,?,!,@-@,94
setl lisp
setl commentstring=;%s

setl comments^=:;;;,:;;,sr:#\|,mb:\|,ex:\|#

let b:undo_ftplugin = "setlocal comments< define< formatoptions< iskeyword< lisp< commentstring<"
                                                                                                                                                                                                                                                               usr/share/vim/vim74/ftplugin/logcheck.vim                                                           0100644 0000000 0000000 00000000764 13050207306 017050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:    Logcheck
" Maintainer:  Debian Vim Maintainers <pkg-vim-maintainers@lists.alioth.debian.org>
" Last Change: 2012 Jan 15
" License:     Vim License
" URL: http://hg.debian.org/hg/pkg-vim/vim/file/unstable/runtime/ftplugin/logcheck.vim

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl fo<"

" Do not hard-wrap non-comment lines since each line is a self-contained
" regular expression
setlocal formatoptions-=t
            usr/share/vim/vim74/ftplugin/loginaccess.vim                                                        0100644 0000000 0000000 00000000656 13050207306 017563  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         login.access(5) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                  usr/share/vim/vim74/ftplugin/logindefs.vim                                                          0100644 0000000 0000000 00000000654 13050207306 017241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         login.defs(5) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                    usr/share/vim/vim74/ftplugin/logtalk.dict                                                           0100644 0000000 0000000 00000003376 13050207306 017060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        encoding
calls
category
dynamic
end_category
end_object
end_protocol
info
initialization
object
protocol
synchronized
threaded
uses
alias
discontiguous
meta_predicate
mode
op
private
protected
public
current_object
current_protocol
current_category
object_property
protocol_property
category_property
create_object
create_protocol
create_category
abolish_object
abolish_protocol
abolish_category
complements
complements_object
extends
extends_object
extends_protocol
extends_category
implements
implements_protocol
imports
imports_category
instantiates
instantiates_class
specializes
specializes_class
abolish_events
current_event
define_events
logtalk_load
logtalk_compile
logtalk_library_path
current_logtalk_flag
set_logtalk_flag
threaded_call
threaded_once
threaded_ignore
threaded_exit
threaded_peek
threaded_wait
threaded_notify
self
this
sender
parameter
before
after
phrase
expand_term
goal_expansion
term_expansion
true
fail
call
catch
throw
unify_with_occurs_check
var
atom
integer
float
atomic
compound
nonvar
number
arg
copy_term
functor
current_predicate
predicate_property
abolish
assertz
asserta
clause
retract
retractall
bagof
findall
forall
setof
current_input
current_output
set_input
set_output
open
close
flush_output
stream_property
at_end_of_stream
set_stream_position
get_char
get_code
peek_char
peek_code
put_char
put_code
nl
get_byte
peek_byte
put_byte
read
read_term
write
writeq
write_canonical
atom_chars
atom_codes
atom_concat
number_chars
number_codes
current_op
char_conversion
current_char_conversion
once
repeat
atom_length
atom_concat
sub_atom
atom_chars
atom_codes
char_code
number_chars
number_codes
set_prolog_flag
current_prolog_flag
halt
abs
atan
ceiling
cos
exp
float_fractional_part
float_integer_part
floor
log
mod
rem
round
sign
sin
sqrt
truncate
                                                                                                                                                                                                                                                                  usr/share/vim/vim74/ftplugin/logtalk.vim                                                            0100644 0000000 0000000 00000000621 13050207306 016716  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Logtalk filetype plugin file
" Language:         Logtalk
" Maintainer:       Paulo Moura <pmoura@logtalk.org>
" Latest Revision:  2007-07-06

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl ts< sw< fdm< fdc< ai< dict<"

"setlocal ts=4
setlocal sw=4
setlocal fdm=syntax
setlocal fdc=2
setlocal autoindent
setlocal dict=$VIMRUNTIME/ftplugin/logtalk.dict
                                                                                                               usr/share/vim/vim74/ftplugin/lprolog.vim                                                            0100644 0000000 0000000 00000002377 13050207306 016751  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim settings file
" Language:     LambdaProlog (Teyjus)
" Maintainer:   Markus Mottl  <markus.mottl@gmail.com>
" URL:          http://www.ocaml.info/vim/ftplugin/lprolog.vim
" Last Change:  2006 Feb 05
"               2001 Sep 16 - fixed 'no_mail_maps'-bug (MM)
"               2001 Sep 02 - initial release  (MM)

" Only do these settings when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't do other file type settings for this buffer
let b:did_ftplugin = 1

" Error format
setlocal efm=%+A./%f:%l.%c:\ %m formatprg=fmt\ -w75\ -p\\%

" Formatting of comments
setlocal formatprg=fmt\ -w75\ -p\\%

" Add mappings, unless the user didn't want this.
if !exists("no_plugin_maps") && !exists("no_lprolog_maps")
  " Uncommenting
  if !hasmapto('<Plug>Comment')
    nmap <buffer> <LocalLeader>c <Plug>LUncomOn
    vmap <buffer> <LocalLeader>c <Plug>BUncomOn
    nmap <buffer> <LocalLeader>C <Plug>LUncomOff
    vmap <buffer> <LocalLeader>C <Plug>BUncomOff
  endif

  nnoremap <buffer> <Plug>LUncomOn mz0i/* <ESC>$A */<ESC>`z
  nnoremap <buffer> <Plug>LUncomOff <ESC>:s/^\/\* \(.*\) \*\//\1/<CR>
  vnoremap <buffer> <Plug>BUncomOn <ESC>:'<,'><CR>`<O<ESC>0i/*<ESC>`>o<ESC>0i*/<ESC>`<
  vnoremap <buffer> <Plug>BUncomOff <ESC>:'<,'><CR>`<dd`>dd`<
endif
                                                                                                                                                                                                                                                                 usr/share/vim/vim74/ftplugin/lua.vim                                                                0100644 0000000 0000000 00000001715 13050207306 016047  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file.
" Language:	Lua 4.0+
" Maintainer:	Max Ischenko <mfi@ukr.net>
" Last Change:	2012 Mar 07

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

" Set 'formatoptions' to break comment lines but not other lines, and insert
" the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

setlocal com=:--
setlocal cms=--%s
setlocal suffixesadd=.lua


" The following lines enable the macros/matchit.vim plugin for
" extended matching with the % key.
if exists("loaded_matchit")

  let b:match_ignorecase = 0
  let b:match_words =
    \ '\<\%(do\|function\|if\)\>:' .
    \ '\<\%(return\|else\|elseif\)\>:' .
    \ '\<end\>,' .
    \ '\<repeat\>:\<until\>'

endif " exists("loaded_matchit")

let &cpo = s:cpo_save
unlet s:cpo_save

let b:undo_ftplugin = "setlocal fo< com< cms< suffixesadd<"
                                                   usr/share/vim/vim74/ftplugin/m4.vim                                                                 0100644 0000000 0000000 00000000636 13050207306 015607  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         m4
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:#,:dnl commentstring=dnl\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                  usr/share/vim/vim74/ftplugin/mail.vim                                                               0100644 0000000 0000000 00000002123 13050207306 016202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Mail
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2012 Nov 20

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl modeline< tw< fo< comments<"

" Don't use modelines in e-mail messages, avoid trojan horses and nasty
" "jokes" (e.g., setting 'textwidth' to 5).
setlocal nomodeline

" many people recommend keeping e-mail messages 72 chars wide
if &tw == 0
  setlocal tw=72
endif

" Set 'formatoptions' to break text lines and keep the comment leader ">".
setlocal fo+=tcql

" Add n:> to 'comments, in case it was removed elsewhere
setlocal comments+=n:>

" Add mappings, unless the user doesn't want this.
if !exists("no_plugin_maps") && !exists("no_mail_maps")
  " Quote text by inserting "> "
  if !hasmapto('<Plug>MailQuote')
    vmap <buffer> <LocalLeader>q <Plug>MailQuote
    nmap <buffer> <LocalLeader>q <Plug>MailQuote
  endif
  vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>:noh<CR>``
  nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>:noh<CR>``
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/share/vim/vim74/ftplugin/mailaliases.vim                                                        0100644 0000000 0000000 00000000567 13050207306 017556  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                         usr/share/vim/vim74/ftplugin/mailcap.vim                                                            0100644 0000000 0000000 00000000646 13050207306 016676  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Mailcap configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                          usr/share/vim/vim74/ftplugin/make.vim                                                               0100644 0000000 0000000 00000001647 13050207306 016207  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Make
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2013 Apr 22

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl et< sts< fo< com< cms< inc<"

" Make sure a hard tab is used, required for most make programs
setlocal noexpandtab softtabstop=0

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set 'comments' to format dashed lists in comments
setlocal com=sO:#\ -,mO:#\ \ ,b:#

" Set 'commentstring' to put the marker after a #.
setlocal commentstring=#\ %s

" Including files.
let &l:include = '^\s*include'

" For matchit.vim, suggested by Albert Netymk.
if exists("loaded_matchit")
  let b:match_words = '\<if\(n\)\=\(eq\|def\)\>:\<else\>:\<endif\>,\<define\>:\<endef\>'
endif
                                                                                         usr/share/vim/vim74/ftplugin/man.vim                                                                0100644 0000000 0000000 00000011143 13050207306 016035  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	man
" Maintainer:	SungHyun Nam <goweol@gmail.com>
" Last Change:	2013 Jul 17

" To make the ":Man" command available before editing a manual page, source
" this script from your startup vimrc file.

" If 'filetype' isn't "man", we must have been called to only define ":Man".
if &filetype == "man"

  " Only do this when not done yet for this buffer
  if exists("b:did_ftplugin")
    finish
  endif
  let b:did_ftplugin = 1

  " Ensure Vim is not recursively invoked (man-db does this)
  " when doing ctrl-[ on a man page reference.
  if exists("$MANPAGER")
    let $MANPAGER = ""
  endif

  " allow dot and dash in manual page name.
  setlocal iskeyword+=\.,-

  " Add mappings, unless the user didn't want this.
  if !exists("no_plugin_maps") && !exists("no_man_maps")
    if !hasmapto('<Plug>ManBS')
      nmap <buffer> <LocalLeader>h <Plug>ManBS
    endif
    nnoremap <buffer> <Plug>ManBS :%s/.\b//g<CR>:setl nomod<CR>''

    nnoremap <buffer> <c-]> :call <SID>PreGetPage(v:count)<CR>
    nnoremap <buffer> <c-t> :call <SID>PopPage()<CR>
  endif

  let b:undo_ftplugin = "setlocal iskeyword<"

endif

if exists(":Man") != 2
  com -nargs=+ Man call s:GetPage(<f-args>)
  nmap <Leader>K :call <SID>PreGetPage(0)<CR>
endif

" Define functions only once.
if !exists("s:man_tag_depth")

let s:man_tag_depth = 0

let s:man_sect_arg = ""
let s:man_find_arg = "-w"
try
  if !has("win32") && $OSTYPE !~ 'cygwin\|linux' && system('uname -s') =~ "SunOS" && system('uname -r') =~ "^5"
    let s:man_sect_arg = "-s"
    let s:man_find_arg = "-l"
  endif
catch /E145:/
  " Ignore the error in restricted mode
endtry

func <SID>PreGetPage(cnt)
  if a:cnt == 0
    let old_isk = &iskeyword
    setl iskeyword+=(,)
    let str = expand("<cword>")
    let &l:iskeyword = old_isk
    let page = substitute(str, '(*\(\k\+\).*', '\1', '')
    let sect = substitute(str, '\(\k\+\)(\([^()]*\)).*', '\2', '')
    if match(sect, '^[0-9 ]\+$') == -1
      let sect = ""
    endif
    if sect == page
      let sect = ""
    endif
  else
    let sect = a:cnt
    let page = expand("<cword>")
  endif
  call s:GetPage(sect, page)
endfunc

func <SID>GetCmdArg(sect, page)
  if a:sect == ''
    return a:page
  endif
  return s:man_sect_arg.' '.a:sect.' '.a:page
endfunc

func <SID>FindPage(sect, page)
  let where = system("/usr/bin/man ".s:man_find_arg.' '.s:GetCmdArg(a:sect, a:page))
  if where !~ "^/"
    if matchstr(where, " [^ ]*$") !~ "^ /"
      return 0
    endif
  endif
  return 1
endfunc

func <SID>GetPage(...)
  if a:0 >= 2
    let sect = a:1
    let page = a:2
  elseif a:0 >= 1
    let sect = ""
    let page = a:1
  else
    return
  endif

  " To support:	    nmap K :Man <cword>
  if page == '<cword>'
    let page = expand('<cword>')
  endif

  if sect != "" && s:FindPage(sect, page) == 0
    let sect = ""
  endif
  if s:FindPage(sect, page) == 0
    echo "\nCannot find a '".page."'."
    return
  endif
  exec "let s:man_tag_buf_".s:man_tag_depth." = ".bufnr("%")
  exec "let s:man_tag_lin_".s:man_tag_depth." = ".line(".")
  exec "let s:man_tag_col_".s:man_tag_depth." = ".col(".")
  let s:man_tag_depth = s:man_tag_depth + 1

  " Use an existing "man" window if it exists, otherwise open a new one.
  if &filetype != "man"
    let thiswin = winnr()
    exe "norm! \<C-W>b"
    if winnr() > 1
      exe "norm! " . thiswin . "\<C-W>w"
      while 1
	if &filetype == "man"
	  break
	endif
	exe "norm! \<C-W>w"
	if thiswin == winnr()
	  break
	endif
      endwhile
    endif
    if &filetype != "man"
      new
      setl nonu fdc=0
    endif
  endif
  silent exec "edit $HOME/".page.".".sect."~"
  " Avoid warning for editing the dummy file twice
  setl buftype=nofile noswapfile

  setl ma nonu nornu nofen
  silent exec "norm 1GdG"
  let $MANWIDTH = winwidth(0)
  silent exec "r!/usr/bin/man ".s:GetCmdArg(sect, page)." | col -b"
  " Remove blank lines from top and bottom.
  while getline(1) =~ '^\s*$'
    silent norm ggdd
  endwhile
  while getline('$') =~ '^\s*$'
    silent norm Gdd
  endwhile
  1
  setl ft=man nomod
  setl bufhidden=hide
  setl nobuflisted
endfunc

func <SID>PopPage()
  if s:man_tag_depth > 0
    let s:man_tag_depth = s:man_tag_depth - 1
    exec "let s:man_tag_buf=s:man_tag_buf_".s:man_tag_depth
    exec "let s:man_tag_lin=s:man_tag_lin_".s:man_tag_depth
    exec "let s:man_tag_col=s:man_tag_col_".s:man_tag_depth
    exec s:man_tag_buf."b"
    exec s:man_tag_lin
    exec "norm ".s:man_tag_col."|"
    exec "unlet s:man_tag_buf_".s:man_tag_depth
    exec "unlet s:man_tag_lin_".s:man_tag_depth
    exec "unlet s:man_tag_col_".s:man_tag_depth
    unlet s:man_tag_buf s:man_tag_lin s:man_tag_col
  endif
endfunc

endif

" vim: set sw=2:
                                                                                                                                                                                                                                                                                                                                                                                                                             usr/share/vim/vim74/ftplugin/manconf.vim                                                            0100644 0000000 0000000 00000000660 13050207306 016705  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         man.conf(5) - man configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                usr/share/vim/vim74/ftplugin/markdown.vim                                                           0100644 0000000 0000000 00000001074 13050207306 017106  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:		Markdown
" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
" Last Change:		2013 May 30

if exists("b:did_ftplugin")
  finish
endif

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim

setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=>\ %s
setlocal formatoptions+=tcqln formatoptions-=r formatoptions-=o
setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^[-*+]\\s\\+

if exists('b:undo_ftplugin')
  let b:undo_ftplugin .= "|setl cms< com< fo< flp<"
else
  let b:undo_ftplugin = "setl cms< com< fo< flp<"
endif

" vim:set sw=2:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/share/vim/vim74/ftplugin/matlab.vim                                                             0100644 0000000 0000000 00000001211 13050207306 016515  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	matlab
" Maintainer:	Jake Wasserman <jwasserman at gmail dot com>
" Last Changed: 2006 Jan 12

if exists("b:did_ftplugin")
	finish
endif
let b:did_ftplugin = 1

let s:save_cpo = &cpo
set cpo-=C

if exists("loaded_matchit")
	let s:conditionalEnd = '\(([^()]*\)\@!\<end\>\([^()]*)\)\@!'
	let b:match_words = '\<if\>\|\<while\>\|\<for\>\|\<switch\>:' .
		\ s:conditionalEnd . ',\<if\>:\<elseif\>:\<else\>:' .
		\ s:conditionalEnd
endif

setlocal suffixesadd=.m
setlocal suffixes+=.asv

let b:undo_ftplugin = "setlocal suffixesadd< suffixes< "
	\ . "| unlet! b:match_words"

let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                       usr/share/vim/vim74/ftplugin/mf.vim                                                                 0100644 0000000 0000000 00000000624 13050207306 015666  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         MetaFont
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:% commentstring=%\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                            usr/share/vim/vim74/ftplugin/modconf.vim                                                            0100644 0000000 0000000 00000000721 13050207306 016707  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         modules.conf(5) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s include=^\\s*include
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                               usr/share/vim/vim74/ftplugin/mp.vim                                                                 0100644 0000000 0000000 00000001155 13050207306 015700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         MetaPost
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:% commentstring=%\ %s formatoptions-=t formatoptions+=croql

if exists(":FixBeginfigs") != 2
  command -nargs=0 FixBeginfigs call s:fix_beginfigs()

  function! s:fix_beginfigs()
    let i = 1
    g/^beginfig(\d*);$/s//\='beginfig('.i.');'/ | let i = i + 1
  endfunction
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/vim/vim74/ftplugin/mplayerconf.vim                                                        0100644 0000000 0000000 00000000714 13050207306 017603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         mplayer(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s include=^\\s*include
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                    usr/share/vim/vim74/ftplugin/mrxvtrc.vim                                                            0100644 0000000 0000000 00000001436 13050207306 016773  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Created	: Wed 26 Apr 2006 01:20:53 AM CDT
" Modified	: Fri 28 Apr 2006 03:24:01 AM CDT
" Author	: Gautam Iyer <gi1242@users.sourceforge.net>
" Description	: ftplugin for mrxvtrc

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl com< cms< fo<"

" Really any line that does not match an option is a comment. But use '!' for
" compatibility with x-defaults files, and "#" (preferred) for compatibility
" with all other config files.
"
" Comments beginning with "#" are preferred because Vim will not flag the
" first word as a spelling error if it is not capitalised. The '!' used as
" comment leaders makes Vim think that every comment line is a new sentence.

setlocal comments=:!,:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql
                                                                                                                                                                                                                                  usr/share/vim/vim74/ftplugin/msmessages.vim                                                         0100644 0000000 0000000 00000002165 13050207306 017435  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	MS Message files (*.mc)
" Maintainer:	Kevin Locke <kwl7@cornell.edu>
" Last Change:	2008 April 09
" Location:	http://kevinlocke.name/programs/vim/syntax/msmessages.vim

" Based on c.vim

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Using line continuation here.
let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = "setl fo< com< cms< | unlet! b:browsefilter"

" Set 'formatoptions' to format all lines, including comments
setlocal fo-=ct fo+=roql

" Comments includes both ";" which describes a "comment" which will be
" converted to C code and variants on "; //" which will remain comments
" in the generated C code
setlocal comments=:;,:;//,:;\ //,s:;\ /*\ ,m:;\ \ *\ ,e:;\ \ */
setlocal commentstring=;\ //\ %s

" Win32 can filter files in the browse dialog
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "MS Message Files (*.mc)\t*.mc\n" .
	\ "Resource Files (*.rc)\t*.rc\n" .
	\ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                           usr/share/vim/vim74/ftplugin/muttrc.vim                                                             0100644 0000000 0000000 00000000707 13050207306 016604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         mutt RC File
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2006-04-19

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

let &l:include = '^\s*source\>'

let &cpo = s:cpo_save
unlet s:cpo_save
                                                         usr/share/vim/vim74/ftplugin/nanorc.vim                                                             0100644 0000000 0000000 00000000663 13050207306 016547  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         nanorc(5) - GNU nano configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                             usr/share/vim/vim74/ftplugin/netrc.vim                                                              0100644 0000000 0000000 00000000640 13050207306 016375  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         netrc(5) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments= commentstring= formatoptions-=tcroq formatoptions+=l

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                usr/share/vim/vim74/ftplugin/nsis.vim                                                               0100644 0000000 0000000 00000001051 13050207306 016233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim ftplugin file
" Language:         NSIS script
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

let s:cpo_save = &cpo
set cpo&vim

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl com< cms< fo< def< inc<"

setlocal comments=s1:/*,mb:*,ex:*/,b:#,:; commentstring=;\ %s
setlocal formatoptions-=t formatoptions+=croql
setlocal define=^\\s*!define\\%(\\%(utc\\)\\=date\\|math\\)\\=
setlocal include=^\\s*!include\\%(/NONFATAL\\)\\=

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/share/vim/vim74/ftplugin/objc.vim                                                               0100644 0000000 0000000 00000000450 13050207306 016176  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Objective C
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2003 Jan 15

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Behaves just like C
runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim
                                                                                                                                                                                                                        usr/share/vim/vim74/ftplugin/ocaml.vim                                                              0100644 0000000 0000000 00000055001 13050207306 016356  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Language:    OCaml
" Maintainer:  David Baelde        <firstname.name@ens-lyon.org>
"              Mike Leary          <leary@nwlink.com>
"              Markus Mottl        <markus.mottl@gmail.com>
"              Pierre Vittet       <pierre-vittet@pvittet.com>
"              Stefano Zacchiroli  <zack@bononia.it>
"              Vincent Aravantinos <firstname.name@imag.fr>
" URL:         http://www.ocaml.info/vim/ftplugin/ocaml.vim
" Last Change:
"              2013 Jul 26 - load default compiler settings (MM)
"              2013 Jul 24 - removed superfluous efm-setting (MM)
"              2013 Jul 22 - applied fixes supplied by Hirotaka Hamada (MM)
"              2013 Mar 15 - Improved error format (MM)

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin=1

" Use standard compiler settings unless user wants otherwise
if !exists("current_compiler")
  :compiler ocaml
endif

" some macro
if exists('*fnameescape')
  function! s:Fnameescape(s)
    return fnameescape(a:s)
  endfun
else
  function! s:Fnameescape(s)
    return escape(a:s," \t\n*?[{`$\\%#'\"|!<")
  endfun
endif

" Error handling -- helps moving where the compiler wants you to go
let s:cposet=&cpoptions
set cpo&vim

" Add mappings, unless the user didn't want this.
if !exists("no_plugin_maps") && !exists("no_ocaml_maps")
  " (un)commenting
  if !hasmapto('<Plug>Comment')
    nmap <buffer> <LocalLeader>c <Plug>LUncomOn
    xmap <buffer> <LocalLeader>c <Plug>BUncomOn
    nmap <buffer> <LocalLeader>C <Plug>LUncomOff
    xmap <buffer> <LocalLeader>C <Plug>BUncomOff
  endif

  nnoremap <buffer> <Plug>LUncomOn gI(* <End> *)<ESC>
  nnoremap <buffer> <Plug>LUncomOff :s/^(\* \(.*\) \*)/\1/<CR>:noh<CR>
  xnoremap <buffer> <Plug>BUncomOn <ESC>:'<,'><CR>`<O<ESC>0i(*<ESC>`>o<ESC>0i*)<ESC>`<
  xnoremap <buffer> <Plug>BUncomOff <ESC>:'<,'><CR>`<dd`>dd`<

  nmap <buffer> <LocalLeader>s <Plug>OCamlSwitchEdit
  nmap <buffer> <LocalLeader>S <Plug>OCamlSwitchNewWin

  nmap <buffer> <LocalLeader>t <Plug>OCamlPrintType
  xmap <buffer> <LocalLeader>t <Plug>OCamlPrintType
endif

" Let % jump between structure elements (due to Issac Trotts)
let b:mw = ''
let b:mw = b:mw . ',\<let\>:\<and\>:\(\<in\>\|;;\)'
let b:mw = b:mw . ',\<if\>:\<then\>:\<else\>'
let b:mw = b:mw . ',\<\(for\|while\)\>:\<do\>:\<done\>,'
let b:mw = b:mw . ',\<\(object\|sig\|struct\|begin\)\>:\<end\>'
let b:mw = b:mw . ',\<\(match\|try\)\>:\<with\>'
let b:match_words = b:mw

let b:match_ignorecase=0

" switching between interfaces (.mli) and implementations (.ml)
if !exists("g:did_ocaml_switch")
  let g:did_ocaml_switch = 1
  nnoremap <Plug>OCamlSwitchEdit :<C-u>call OCaml_switch(0)<CR>
  nnoremap <Plug>OCamlSwitchNewWin :<C-u>call OCaml_switch(1)<CR>
  fun OCaml_switch(newwin)
    if (match(bufname(""), "\\.mli$") >= 0)
      let fname = s:Fnameescape(substitute(bufname(""), "\\.mli$", ".ml", ""))
      if (a:newwin == 1)
        exec "new " . fname
      else
        exec "arge " . fname
      endif
    elseif (match(bufname(""), "\\.ml$") >= 0)
      let fname = s:Fnameescape(bufname("")) . "i"
      if (a:newwin == 1)
        exec "new " . fname
      else
        exec "arge " . fname
      endif
    endif
  endfun
endif

" Folding support

" Get the modeline because folding depends on indentation
let s:s = line2byte(line('.'))+col('.')-1
if search('^\s*(\*:o\?caml:')
  let s:modeline = getline(".")
else
  let s:modeline = ""
endif
if s:s > 0
  exe 'goto' s:s
endif

" Get the indentation params
let s:m = matchstr(s:modeline,'default\s*=\s*\d\+')
if s:m != ""
  let s:idef = matchstr(s:m,'\d\+')
elseif exists("g:omlet_indent")
  let s:idef = g:omlet_indent
else
  let s:idef = 2
endif
let s:m = matchstr(s:modeline,'struct\s*=\s*\d\+')
if s:m != ""
  let s:i = matchstr(s:m,'\d\+')
elseif exists("g:omlet_indent_struct")
  let s:i = g:omlet_indent_struct
else
  let s:i = s:idef
endif

" Set the folding method
if exists("g:ocaml_folding")
  setlocal foldmethod=expr
  setlocal foldexpr=OMLetFoldLevel(v:lnum)
endif

let b:undo_ftplugin = "setlocal efm< foldmethod< foldexpr<"
	\ . "| unlet! b:mw b:match_words b:match_ignorecase"


" - Only definitions below, executed once -------------------------------------

if exists("*OMLetFoldLevel")
  finish
endif

function s:topindent(lnum)
  let l = a:lnum
  while l > 0
    if getline(l) =~ '\s*\%(\<struct\>\|\<sig\>\|\<object\>\)'
      return indent(l)
    endif
    let l = l-1
  endwhile
  return -s:i
endfunction

function OMLetFoldLevel(l)

  " This is for not merging blank lines around folds to them
  if getline(a:l) !~ '\S'
    return -1
  endif

  " We start folds for modules, classes, and every toplevel definition
  if getline(a:l) =~ '^\s*\%(\<val\>\|\<module\>\|\<class\>\|\<type\>\|\<method\>\|\<initializer\>\|\<inherit\>\|\<exception\>\|\<external\>\)'
    exe 'return ">' (indent(a:l)/s:i)+1 '"'
  endif

  " Toplevel let are detected thanks to the indentation
  if getline(a:l) =~ '^\s*let\>' && indent(a:l) == s:i+s:topindent(a:l)
    exe 'return ">' (indent(a:l)/s:i)+1 '"'
  endif

  " We close fold on end which are associated to struct, sig or object.
  " We use syntax information to do that.
  if getline(a:l) =~ '^\s*end\>' && synIDattr(synID(a:l, indent(a:l)+1, 0), "name") != "ocamlKeyword"
    return (indent(a:l)/s:i)+1
  endif

  " Folds end on ;;
  if getline(a:l) =~ '^\s*;;'
    exe 'return "<' (indent(a:l)/s:i)+1 '"'
  endif

  " Comments around folds aren't merged to them.
  if synIDattr(synID(a:l, indent(a:l)+1, 0), "name") == "ocamlComment"
    return -1
  endif

  return '='
endfunction

" Vim support for OCaml .annot files
"
" Last Change: 2007 Jul 17
" Maintainer:  Vincent Aravantinos <vincent.aravantinos@gmail.com>
" License:     public domain
"
" Originally inspired by 'ocaml-dtypes.vim' by Stefano Zacchiroli.
" The source code is quite radically different for we not use python anymore.
" However this plugin should have the exact same behaviour, that's why the
" following lines are the quite exact copy of Stefano's original plugin :
"
" <<
" Executing Ocaml_print_type(<mode>) function will display in the Vim bottom
" line(s) the type of an ocaml value getting it from the corresponding .annot
" file (if any).  If Vim is in visual mode, <mode> should be "visual" and the
" selected ocaml value correspond to the highlighted text, otherwise (<mode>
" can be anything else) it corresponds to the literal found at the current
" cursor position.
"
" Typing '<LocalLeader>t' (LocalLeader defaults to '\', see :h LocalLeader)
" will cause " Ocaml_print_type function to be invoked with the right
" argument depending on the current mode (visual or not).
" >>
"
" If you find something not matching this behaviour, please signal it.
"
" Differences are:
"   - no need for python support
"     + plus : more portable
"     + minus: no more lazy parsing, it looks very fast however
"
"   - ocamlbuild support, ie.
"     + the plugin finds the _build directory and looks for the
"       corresponding file inside;
"     + if the user decides to change the name of the _build directory thanks
"       to the '-build-dir' option of ocamlbuild, the plugin will manage in
"       most cases to find it out (most cases = if the source file has a unique
"       name among your whole project);
"     + if ocamlbuild is not used, the usual behaviour holds; ie. the .annot
"       file should be in the same directory as the source file;
"     + for vim plugin programmers:
"       the variable 'b:_build_dir' contains the inferred path to the build
"       directory, even if this one is not named '_build'.
"
" Bonus :
"   - latin1 accents are handled
"   - lists are handled, even on multiple lines, you don't need the visual mode
"     (the cursor must be on the first bracket)
"   - parenthesized expressions, arrays, and structures (ie. '(...)', '[|...|]',
"     and '{...}') are handled the same way

  " Copied from Stefano's original plugin :
  " <<
  "      .annot ocaml file representation
  "
  "      File format (copied verbatim from caml-types.el)
  "
  "      file ::= block *
  "      block ::= position <SP> position <LF> annotation *
  "      position ::= filename <SP> num <SP> num <SP> num
  "      annotation ::= keyword open-paren <LF> <SP> <SP> data <LF> close-paren
  "
  "      <SP> is a space character (ASCII 0x20)
  "      <LF> is a line-feed character (ASCII 0x0A)
  "      num is a sequence of decimal digits
  "      filename is a string with the lexical conventions of O'Caml
  "      open-paren is an open parenthesis (ASCII 0x28)
  "      close-paren is a closed parenthesis (ASCII 0x29)
  "      data is any sequence of characters where <LF> is always followed by
  "           at least two space characters.
  "
  "      - in each block, the two positions are respectively the start and the
  "        end of the range described by the block.
  "      - in a position, the filename is the name of the file, the first num
  "        is the line number, the second num is the offset of the beginning
  "        of the line, the third num is the offset of the position itself.
  "      - the char number within the line is the difference between the third
  "        and second nums.
  "
  "      For the moment, the only possible keyword is \"type\"."
  " >>


" 1. Finding the annotation file even if we use ocamlbuild

    " In:  two strings representing paths
    " Out: one string representing the common prefix between the two paths
  function! s:Find_common_path (p1,p2)
    let temp = a:p2
    while matchstr(a:p1,temp) == ''
      let temp = substitute(temp,'/[^/]*$','','')
    endwhile
    return temp
  endfun

    " After call:
    "
    "  Following information have been put in s:annot_file_list, using
    "  annot_file_name name as key:
    " - annot_file_path :
    "                       path to the .annot file corresponding to the
    "                       source file (dealing with ocamlbuild stuff)
    " - _build_path:
    "                       path to the build directory even if this one is
    "                       not named '_build'
    " - date_of_last annot:
    "                       Set to 0 until we load the file. It contains the
    "                       date at which the file has been loaded.
  function! s:Locate_annotation()
    let annot_file_name = s:Fnameescape(expand('%:t:r')).'.annot'
    if !exists ("s:annot_file_list[annot_file_name]")
      silent exe 'cd' s:Fnameescape(expand('%:p:h'))
      " 1st case : the annot file is in the same directory as the buffer (no ocamlbuild)
      let annot_file_path = findfile(annot_file_name,'.')
      if annot_file_path != ''
        let annot_file_path = getcwd().'/'.annot_file_path
        let _build_path = ''
      else
        " 2nd case : the buffer and the _build directory are in the same directory
        "      ..
        "     /  \
        "    /    \
        " _build  .ml
        "
        let _build_path = finddir('_build','.')
        if _build_path != ''
          let _build_path = getcwd().'/'._build_path
          let annot_file_path           = findfile(annot_file_name,'_build')
          if annot_file_path != ''
            let annot_file_path = getcwd().'/'.annot_file_path
          endif
        else
          " 3rd case : the _build directory is in a directory higher in the file hierarchy
          "            (it can't be deeper by ocamlbuild requirements)
          "      ..
          "     /  \
          "    /    \
          " _build  ...
          "           \
          "            \
          "           .ml
          "
          let _build_path = finddir('_build',';')
          if _build_path != ''
            let project_path                = substitute(_build_path,'/_build$','','')
            let path_relative_to_project    = s:Fnameescape(substitute(expand('%:p:h'),project_path.'/','',''))
            let annot_file_path           = findfile(annot_file_name,project_path.'/_build/'.path_relative_to_project)
          else
            let annot_file_path = findfile(annot_file_name,'**')
            "4th case : what if the user decided to change the name of the _build directory ?
            "           -> we relax the constraints, it should work in most cases
            if annot_file_path != ''
              " 4a. we suppose the renamed _build directory is in the current directory
              let _build_path = matchstr(annot_file_path,'^[^/]*')
              if annot_file_path != ''
                let annot_file_path = getcwd().'/'.annot_file_path
                let _build_path     = getcwd().'/'._build_path
              endif
            else
              let annot_file_name = ''
              "(Pierre Vittet: I have commented 4b because this was chrashing
              "my vim (it produced infinite loop))
              "
              " 4b. anarchy : the renamed _build directory may be higher in the hierarchy
              " this will work if the file for which we are looking annotations has a unique name in the whole project
              " if this is not the case, it may still work, but no warranty here
              "let annot_file_path = findfile(annot_file_name,'**;')
              "let project_path      = s:Find_common_path(annot_file_path,expand('%:p:h'))
              "let _build_path       = matchstr(annot_file_path,project_path.'/[^/]*')
            endif
          endif
        endif
      endif

      if annot_file_path == ''
        throw 'E484: no annotation file found'
      endif

      silent exe 'cd' '-'
      let s:annot_file_list[annot_file_name]= [annot_file_path, _build_path, 0]
    endif
  endfun

  " This variable contain a dictionnary of list. Each element of the dictionnary
  " represent an annotation system. An annotation system is a list with :
  " - annotation file name as it's key
  " - annotation file path as first element of the contained list
  " - build path as second element of the contained list
  " - annot_file_last_mod (contain the date of .annot file) as third element
  let s:annot_file_list = {}

" 2. Finding the type information in the annotation file

  " a. The annotation file is opened in vim as a buffer that
  " should be (almost) invisible to the user.

      " After call:
      " The current buffer is now the one containing the .annot file.
      " We manage to keep all this hidden to the user's eye.
    function! s:Enter_annotation_buffer(annot_file_path)
      let s:current_pos = getpos('.')
      let s:current_hidden = &l:hidden
      set hidden
      let s:current_buf = bufname('%')
      if bufloaded(a:annot_file_path)
        silent exe 'keepj keepalt' 'buffer' s:Fnameescape(a:annot_file_path)
      else
        silent exe 'keepj keepalt' 'view' s:Fnameescape(a:annot_file_path)
      endif
      call setpos(".", [0, 0 , 0 , 0])
    endfun

      " After call:
      "   The original buffer has been restored in the exact same state as before.
    function! s:Exit_annotation_buffer()
      silent exe 'keepj keepalt' 'buffer' s:Fnameescape(s:current_buf)
      let &l:hidden = s:current_hidden
      call setpos('.',s:current_pos)
    endfun

      " After call:
      "   The annot file is loaded and assigned to a buffer.
      "   This also handles the modification date of the .annot file, eg. after a
      "   compilation (return an updated annot_file_list).
    function! s:Load_annotation(annot_file_name)
      let annot = s:annot_file_list[a:annot_file_name]
      let annot_file_path = annot[0]
      let annot_file_last_mod = 0
      if exists("annot[2]")
        let annot_file_last_mod = annot[2]
      endif
      if bufloaded(annot_file_path) && annot_file_last_mod < getftime(annot_file_path)
        " if there is a more recent file
        let nr = bufnr(annot_file_path)
        silent exe 'keepj keepalt' 'bunload' nr
      endif
      if !bufloaded(annot_file_path)
        call s:Enter_annotation_buffer(annot_file_path)
        setlocal nobuflisted
        setlocal bufhidden=hide
        setlocal noswapfile
        setlocal buftype=nowrite
        call s:Exit_annotation_buffer()
        let annot[2] = getftime(annot_file_path)
        " List updated with the new date
        let s:annot_file_list[a:annot_file_name] = annot
      endif
    endfun

  "b. 'search' and 'match' work to find the type information

      "In:  - lin1,col1: postion of expression first char
      "     - lin2,col2: postion of expression last char
      "Out: - the pattern to be looked for to find the block
      " Must be called in the source buffer (use of line2byte)
    function! s:Block_pattern(lin1,lin2,col1,col2)
      let start_num1 = a:lin1
      let start_num2 = line2byte(a:lin1) - 1
      let start_num3 = start_num2 + a:col1
      let path       = '"\(\\"\|[^"]\)\+"'
      let start_pos  = path.' '.start_num1.' '.start_num2.' '.start_num3
      let end_num1   = a:lin2
      let end_num2   = line2byte(a:lin2) - 1
      let end_num3   = end_num2 + a:col2
      let end_pos    = path.' '.end_num1.' '.end_num2.' '.end_num3
      return '^'.start_pos.' '.end_pos."$"
      " rq: the '^' here is not totally correct regarding the annot file "grammar"
      " but currently the annotation file respects this, and it's a little bit faster with the '^';
      " can be removed safely.
    endfun

      "In: (the cursor position should be at the start of an annotation)
      "Out: the type information
      " Must be called in the annotation buffer (use of search)
    function! s:Match_data()
      " rq: idem as previously, in the following, the '^' at start of patterns is not necessary
      keepj while search('^type($','ce',line(".")) == 0
        keepj if search('^.\{-}($','e') == 0
          throw "no_annotation"
        endif
        keepj if searchpair('(','',')') == 0
          throw "malformed_annot_file"
        endif
      endwhile
      let begin = line(".") + 1
      keepj if searchpair('(','',')') == 0
        throw "malformed_annot_file"
      endif
      let end = line(".") - 1
      return join(getline(begin,end),"\n")
    endfun

      "In:  the pattern to look for in order to match the block
      "Out: the type information (calls s:Match_data)
      " Should be called in the annotation buffer
    function! s:Extract_type_data(block_pattern, annot_file_name)
      let annot_file_path = s:annot_file_list[a:annot_file_name][0]
      call s:Enter_annotation_buffer(annot_file_path)
      try
        if search(a:block_pattern,'e') == 0
          throw "no_annotation"
        endif
        call cursor(line(".") + 1,1)
        let annotation = s:Match_data()
      finally
        call s:Exit_annotation_buffer()
      endtry
      return annotation
    endfun

  "c. link this stuff with what the user wants
  " ie. get the expression selected/under the cursor

    let s:ocaml_word_char = '\w|[-]|'''

      "In:  the current mode (eg. "visual", "normal", etc.)
      "Out: the borders of the expression we are looking for the type
    function! s:Match_borders(mode)
      if a:mode == "visual"
        let cur = getpos(".")
        normal `<
        let col1 = col(".")
        let lin1 = line(".")
        normal `>
        let col2 = col(".")
        let lin2 = line(".")
        call cursor(cur[1],cur[2])
        return [lin1,lin2,col1-1,col2]
      else
        let cursor_line = line(".")
        let cursor_col  = col(".")
        let line = getline('.')
        if line[cursor_col-1:cursor_col] == '[|'
          let [lin2,col2] = searchpairpos('\[|','','|\]','n')
          return [cursor_line,lin2,cursor_col-1,col2+1]
        elseif     line[cursor_col-1] == '['
          let [lin2,col2] = searchpairpos('\[','','\]','n')
          return [cursor_line,lin2,cursor_col-1,col2]
        elseif line[cursor_col-1] == '('
          let [lin2,col2] = searchpairpos('(','',')','n')
          return [cursor_line,lin2,cursor_col-1,col2]
        elseif line[cursor_col-1] == '{'
          let [lin2,col2] = searchpairpos('{','','}','n')
          return [cursor_line,lin2,cursor_col-1,col2]
        else
          let [lin1,col1] = searchpos('\v%('.s:ocaml_word_char.'|\.)*','ncb')
          let [lin2,col2] = searchpos('\v%('.s:ocaml_word_char.'|\.)*','nce')
          if col1 == 0 || col2 == 0
            throw "no_expression"
          endif
          return [cursor_line,cursor_line,col1-1,col2]
        endif
      endif
    endfun

      "In:  the current mode (eg. "visual", "normal", etc.)
      "Out: the type information (calls s:Extract_type_data)
    function! s:Get_type(mode, annot_file_name)
      let [lin1,lin2,col1,col2] = s:Match_borders(a:mode)
      return s:Extract_type_data(s:Block_pattern(lin1,lin2,col1,col2), a:annot_file_name)
    endfun

      "In: A string destined to be printed in the 'echo buffer'. It has line
      "break and 2 space at each line beginning.
      "Out: A string destined to be yanked, without space and double space.
    function s:unformat_ocaml_type(res)
      "Remove end of line.
      let res = substitute (a:res, "\n", "", "g" )
      "remove double space
      let res =substitute(res , "  ", " ", "g")
      "remove space at begining of string.
      let res = substitute(res, "^ *", "", "g")
      return res
    endfunction

  "d. main
      "In:         the current mode (eg. "visual", "normal", etc.)
      "After call: the type information is displayed
    if !exists("*Ocaml_get_type")
      function Ocaml_get_type(mode)
        let annot_file_name = s:Fnameescape(expand('%:t:r')).'.annot'
        call s:Locate_annotation()
        call s:Load_annotation(annot_file_name)
        let res = s:Get_type(a:mode, annot_file_name)
        " Copy result in the unnamed buffer
        let @" = s:unformat_ocaml_type(res)
        return res
      endfun
    endif

    if !exists("*Ocaml_get_type_or_not")
      function Ocaml_get_type_or_not(mode)
        let t=reltime()
        try
          let res = Ocaml_get_type(a:mode)
          return res
        catch
          return ""
        endtry
      endfun
    endif

    if !exists("*Ocaml_print_type")
      function Ocaml_print_type(mode)
        if expand("%:e") == "mli"
          echohl ErrorMsg | echo "No annotations for interface (.mli) files" | echohl None
          return
        endif
        try
          echo Ocaml_get_type(a:mode)
        catch /E484:/
          echohl ErrorMsg | echo "No type annotations (.annot) file found" | echohl None
        catch /no_expression/
          echohl ErrorMsg | echo "No expression found under the cursor" | echohl None
        catch /no_annotation/
          echohl ErrorMsg | echo "No type annotation found for the given text" | echohl None
        catch /malformed_annot_file/
          echohl ErrorMsg | echo "Malformed .annot file" | echohl None
        endtry
      endfun
    endif

" Maps
  nnoremap <silent> <Plug>OCamlPrintType :<C-U>call Ocaml_print_type("normal")<CR>
  xnoremap <silent> <Plug>OCamlPrintType :<C-U>call Ocaml_print_type("visual")<CR>`<

let &cpoptions=s:cposet
unlet s:cposet

" vim:sw=2 fdm=indent
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/share/vim/vim74/ftplugin/occam.vim                                                              0100644 0000000 0000000 00000002421 13050207306 016343  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	occam
" Copyright:	Christian Jacobsen <clj3@kent.ac.uk>, Mario Schweigler <ms44@kent.ac.uk>
" Maintainer:	Mario Schweigler <ms44@kent.ac.uk>
" Last Change:	23 April 2003

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1
let s:keepcpo= &cpo
set cpo&vim

"{{{  Indent settings
" Set shift width for indent
setlocal shiftwidth=2
" Set the tab key size to two spaces
setlocal softtabstop=2
" Let tab keys always be expanded to spaces
setlocal expandtab
"}}}

"{{{  Formatting
" Break comment lines and insert comment leader in this case
setlocal formatoptions-=t formatoptions+=cql
setlocal comments+=:--
" Maximum length of comments is 78
setlocal textwidth=78
"}}}

"{{{  File browsing filters
" Win32 can filter files in the browse dialog
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "All Occam Files (*.occ *.inc)\t*.occ;*.inc\n" .
	\ "Occam Include Files (*.inc)\t*.inc\n" .
	\ "Occam Source Files (*.occ)\t*.occ\n" .
	\ "All Files (*.*)\t*.*\n"
endif
"}}}

"{{{  Undo settings
let b:undo_ftplugin = "setlocal shiftwidth< softtabstop< expandtab<"
	\ . " formatoptions< comments< textwidth<"
	\ . "| unlet! b:browsefiler"
"}}}

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                               usr/share/vim/vim74/ftplugin/pamconf.vim                                                            0100644 0000000 0000000 00000000645 13050207306 016712  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         pam(8) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                           usr/share/vim/vim74/ftplugin/pascal.vim                                                             0100644 0000000 0000000 00000001233 13050207306 016524  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	pascal
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 11 Apr 2011
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

if exists("loaded_matchit")
    let b:match_ignorecase = 1 " (pascal is case-insensitive)

    let b:match_words = '\<\%(begin\|case\|record\|object\|try\)\>'
    let b:match_words .= ':\<^\s*\%(except\|finally\)\>:\<end\>'
    let b:match_words .= ',\<repeat\>:\<until\>'
    let b:match_words .= ',\<if\>:\<else\>'
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:match_words"
                                                                                                                                                                                                                                                                                                                                                                     usr/share/vim/vim74/ftplugin/passwd.vim                                                             0100644 0000000 0000000 00000000634 13050207306 016566  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         passwd(5) password file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments= commentstring= formatoptions-=tcroq formatoptions+=l

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                    usr/share/vim/vim74/ftplugin/pdf.vim                                                                0100644 0000000 0000000 00000005065 13050207306 016041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	PDF
" Maintainer:	Tim Pope <vimNOSPAM@tpope.info>
" Last Change:	2007 Dec 16

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

setlocal commentstring=%%s
setlocal comments=:%
let b:undo_ftplugin = "setlocal cms< com< | unlet! b:match_words"

if exists("g:loaded_matchit")
    let b:match_words = '\<\%(\d\+\s\+\d\+\s\+\)obj\>:\<endobj\>,\<stream$:\<endstream\>,\<xref\>:\<trailer\>,<<:>>'
endif

if exists("g:no_plugin_maps") || exists("g:no_pdf_maps") || v:version < 700
    finish
endif

if !exists("b:pdf_tagstack")
    let b:pdf_tagstack = []
endif

let b:undo_ftplugin .= " | silent! nunmap <buffer> <C-]> | silent! nunmap <buffer> <C-T>"
nnoremap <silent><buffer> <C-]> :call <SID>Tag()<CR>
" Inline, so the error from an empty tag stack will be simple.
nnoremap <silent><buffer> <C-T> :if len(b:pdf_tagstack) > 0 <Bar> call setpos('.',remove(b:pdf_tagstack, -1)) <Bar> else <Bar> exe "norm! \<Lt>C-T>" <Bar> endif<CR>

function! s:Tag()
    call add(b:pdf_tagstack,getpos('.'))
    if getline('.') =~ '^\d\+$' && getline(line('.')-1) == 'startxref'
	return s:dodigits(getline('.'))
    elseif getline('.') =~ '/Prev\s\+\d\+\>\%(\s\+\d\)\@!' && expand("<cword>") =~ '^\d\+$'
	return s:dodigits(expand("<cword>"))
    elseif getline('.') =~ '^\d\{10\} \d\{5\} '
	return s:dodigits(matchstr(getline('.'),'^\d\+'))
    else
	let line = getline(".")
	let lastend = 0
	let pat = '\<\d\+\s\+\d\+\s\+R\>'
	while lastend >= 0
	    let beg = match(line,'\C'.pat,lastend)
	    let end = matchend(line,'\C'.pat,lastend)
	    if beg < col(".") && end >= col(".")
		return s:doobject(matchstr(line,'\C'.pat,lastend))
	    endif
	    let lastend = end
	endwhile
	return s:notag()
    endif
endfunction

function! s:doobject(string)
    let first = matchstr(a:string,'^\s*\zs\d\+')
    let second = matchstr(a:string,'^\s*\d\+\s\+\zs\d\+')
    norm! m'
    if first != '' && second != ''
	let oldline = line('.')
	let oldcol = col('.')
	1
	if !search('^\s*'.first.'\s\+'.second.'\s\+obj\>')
	    exe oldline
	    exe 'norm! '.oldcol.'|'
	    return s:notag()
	endif
    endif
endfunction

function! s:dodigits(digits)
    let digits = 0 + substitute(a:digits,'^0*','','')
    norm! m'
    if digits <= 0
	norm! 1go
    else
	" Go one character before the destination and advance.  This method
	" lands us after a newline rather than before, if that is our target.
	exe "goto ".(digits)."|norm! 1 "
    endif
endfunction

function! s:notag()
    silent! call remove(b:pdf_tagstack,-1)
    echohl ErrorMsg
    echo "E426: tag not found"
    echohl NONE
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/share/vim/vim74/ftplugin/perl.vim                                                               0100644 0000000 0000000 00000005420 13050207306 016225  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:      Perl
" Maintainer:    vim-perl <vim-perl@googlegroups.com>
" Homepage:      http://github.com/vim-perl/vim-perl
" Bugs/requests: http://github.com/vim-perl/vim-perl/issues
" Last Change:   2013-07-21

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal formatoptions-=t
setlocal formatoptions+=crqol
setlocal keywordprg=perldoc\ -f

setlocal comments=:#
setlocal commentstring=#%s

" Change the browse dialog on Win32 to show mainly Perl-related files
if has("gui_win32")
    let b:browsefilter = "Perl Source Files (*.pl)\t*.pl\n" .
		       \ "Perl Modules (*.pm)\t*.pm\n" .
		       \ "Perl Documentation Files (*.pod)\t*.pod\n" .
		       \ "All Files (*.*)\t*.*\n"
endif

" Provided by Ned Konz <ned at bike-nomad dot com>
"---------------------------------------------
setlocal include=\\<\\(use\\\|require\\)\\>
setlocal includeexpr=substitute(substitute(substitute(v:fname,'::','/','g'),'->\*','',''),'$','.pm','')
setlocal define=[^A-Za-z_]

" The following line changes a global variable but is necessary to make
" gf and similar commands work.  The change to iskeyword was incorrect.
" Thanks to Andrew Pimlott for pointing out the problem. If this causes a
" problem for you, add an after/ftplugin/perl.vim file that contains
"       set isfname-=:
set isfname+=:
set iskeyword+=:

" Set this once, globally.
if !exists("perlpath")
    if executable("perl")
      try
	if &shellxquote != '"'
	    let perlpath = system('perl -e "print join(q/,/,@INC)"')
	else
	    let perlpath = system("perl -e 'print join(q/,/,@INC)'")
	endif
	let perlpath = substitute(perlpath,',.$',',,','')
      catch /E145:/
	let perlpath = ".,,"
      endtry
    else
	" If we can't call perl to get its path, just default to using the
	" current directory and the directory of the current file.
	let perlpath = ".,,"
    endif
endif

" Append perlpath to the existing path value, if it is set.  Since we don't
" use += to do it because of the commas in perlpath, we have to handle the
" global / local settings, too.
if &l:path == ""
    if &g:path == ""
        let &l:path=perlpath
    else
        let &l:path=&g:path.",".perlpath
    endif
else
    let &l:path=&l:path.",".perlpath
endif
"---------------------------------------------

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal fo< com< cms< inc< inex< def< isf< kp< path<" .
	    \	      " | unlet! b:browsefilter"

" proper matching for matchit plugin
let b:match_skip = 's:comment\|string\|perlQQ\|perlShellCommand\|perlHereDoc\|perlSubstitution\|perlTranslation\|perlMatch\|perlFormatField'

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                usr/share/vim/vim74/ftplugin/perl6.vim                                                              0100644 0000000 0000000 00000004741 13050207306 016320  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:      Perl 6
" Maintainer:    vim-perl <vim-perl@googlegroups.com>
" Homepage:      http://github.com/vim-perl/vim-perl
" Bugs/requests: http://github.com/vim-perl/vim-perl/issues
" Last Change:   2013-07-21
" Contributors:  Hinrik Örn Sigurðsson <hinrik.sig@gmail.com>
"
" Based on ftplugin/perl.vim by Dan Sharp <dwsharp at hotmail dot com>

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal formatoptions-=t
setlocal formatoptions+=crqol
setlocal keywordprg=p6doc

setlocal comments=:#
setlocal commentstring=#%s

" Change the browse dialog on Win32 to show mainly Perl-related files
if has("gui_win32")
    let b:browsefilter = "Perl Source Files (*.pl)\t*.pl\n" .
               \ "Perl Modules (*.pm)\t*.pm\n" .
               \ "Perl Documentation Files (*.pod)\t*.pod\n" .
               \ "All Files (*.*)\t*.*\n"
endif

" Provided by Ned Konz <ned at bike-nomad dot com>
"---------------------------------------------
setlocal include=\\<\\(use\\\|require\\)\\>
setlocal includeexpr=substitute(substitute(v:fname,'::','/','g'),'$','.pm','')
setlocal define=[^A-Za-z_]

" The following line changes a global variable but is necessary to make
" gf and similar commands work. Thanks to Andrew Pimlott for pointing out
" the problem. If this causes a " problem for you, add an
" after/ftplugin/perl6.vim file that contains
"       set isfname-=:
set isfname+=:
setlocal iskeyword=48-57,_,A-Z,a-z,:,-

" Set this once, globally.
if !exists("perlpath")
    if executable("perl6")
        try
            if &shellxquote != '"'
                let perlpath = system('perl6 -e  "@*INC.join(q/,/).say"')
            else
                let perlpath = system("perl6 -e  '@*INC.join(q/,/).say'")
            endif
            let perlpath = substitute(perlpath,',.$',',,','')
        catch /E145:/
            let perlpath = ".,,"
        endtry
    else
        " If we can't call perl to get its path, just default to using the
        " current directory and the directory of the current file.
        let perlpath = ".,,"
    endif
endif

let &l:path=perlpath
"---------------------------------------------

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal fo< com< cms< inc< inex< def< isk<" .
        \         " | unlet! b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                               usr/share/vim/vim74/ftplugin/php.vim                                                                0100644 0000000 0000000 00000005375 13050207306 016063  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	php
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:keepcpo= &cpo
set cpo&vim

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "HTML Files (*.html, *.htm)\t*.html;*.htm\n" .
	    \	     "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words
endif
if exists("b:match_skip")
    unlet b:match_skip
endif

" Change the :browse e filter to primarily show PHP-related files.
if has("gui_win32")
    let  b:browsefilter="PHP Files (*.php)\t*.php\n" . s:browsefilter
endif

" ###
" Provided by Mikolaj Machowski <mikmach at wp dot pl>
setlocal include=\\\(require\\\|include\\\)\\\(_once\\\)\\\?
" Disabled changing 'iskeyword', it breaks a command such as "*"
" setlocal iskeyword+=$

if exists("loaded_matchit")
    let b:match_words = '<?php:?>,\<switch\>:\<endswitch\>,' .
		      \ '\<if\>:\<elseif\>:\<else\>:\<endif\>,' .
		      \ '\<while\>:\<endwhile\>,' .
		      \ '\<do\>:\<while\>,' .
		      \ '\<for\>:\<endfor\>,' .
		      \ '\<foreach\>:\<endforeach\>,' .
                      \ '(:),[:],{:},' .
		      \ s:match_words
endif
" ###

if exists('&omnifunc')
  setlocal omnifunc=phpcomplete#CompletePHP
endif

" Section jumping: [[ and ]] provided by Antony Scriven <adscriven at gmail dot com>
let s:function = '\(abstract\s\+\|final\s\+\|private\s\+\|protected\s\+\|public\s\+\|static\s\+\)*function'
let s:class = '\(abstract\s\+\|final\s\+\)*class'
let s:interface = 'interface'
let s:section = '\(.*\%#\)\@!\_^\s*\zs\('.s:function.'\|'.s:class.'\|'.s:interface.'\)'
exe 'nno <buffer> <silent> [[ ?' . escape(s:section, '|') . '?<CR>:nohls<CR>'
exe 'nno <buffer> <silent> ]] /' . escape(s:section, '|') . '/<CR>:nohls<CR>'
exe 'ono <buffer> <silent> [[ ?' . escape(s:section, '|') . '?<CR>:nohls<CR>'
exe 'ono <buffer> <silent> ]] /' . escape(s:section, '|') . '/<CR>:nohls<CR>'

setlocal commentstring=/*%s*/

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal commentstring< include< omnifunc<" .
	    \	      " | unlet! b:browsefilter b:match_words | " .
	    \	      s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                                                   usr/share/vim/vim74/ftplugin/pinfo.vim                                                              0100644 0000000 0000000 00000000647 13050207306 016404  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         pinfo(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                         usr/share/vim/vim74/ftplugin/plaintex.vim                                                           0100644 0000000 0000000 00000002176 13050207306 017114  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " plain TeX filetype plugin
" Language:     plain TeX (ft=plaintex)
" Maintainer:   Benji Fisher, Ph.D. <benji@member.AMS.org>
" Version:	1.1
" Last Change:	Wed 19 Apr 2006

" Only do this when not done yet for this buffer.
if exists("b:did_ftplugin")
  finish
endif

" Start with initex.  This will also define b:did_ftplugin and b:undo_ftplugin .
source $VIMRUNTIME/ftplugin/initex.vim

" Avoid problems if running in 'compatible' mode.
let s:save_cpo = &cpo
set cpo&vim

let b:undo_ftplugin .= "| unlet! b:match_ignorecase b:match_skip b:match_words"

" Allow "[d" to be used to find a macro definition:
let &l:define .= '\|\\new\(count\|dimen\|skip\|muskip\|box\|toks\|read\|write'
	\ .	'\|fam\|insert\)'

" The following lines enable the macros/matchit.vim plugin for
" extended matching with the % key.
" There is no default meaning for \(...\) etc., but many users define one.
if exists("loaded_matchit")
  let b:match_ignorecase = 0
    \ | let b:match_skip = 'r:\\\@<!\%(\\\\\)*%'
    \ | let b:match_words = '(:),\[:],{:},\\(:\\),\\\[:\\],\\{:\\}'
endif " exists("loaded_matchit")

let &cpo = s:save_cpo
unlet s:save_cpo

" vim:sts=2:sw=2:
                                                                                                                                                                                                                                                                                                                                                                                                  usr/share/vim/vim74/ftplugin/postscr.vim                                                            0100644 0000000 0000000 00000001756 13050207306 016770  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	PostScript
" Maintainer:	Mike Williams <mrw@eandem.co.uk>
" Last Change:  24th April 2012

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

" PS comment formatting
setlocal comments=b:%
setlocal formatoptions-=t formatoptions+=rol

" Define patterns for the matchit macro
if !exists("b:match_words")
  let b:match_ignorecase = 0
  let b:match_words = '<<:>>,\<begin\>:\<end\>,\<save\>:\<restore\>,\<gsave\>:\<grestore\>'
endif

" Define patterns for the browse file filter
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "PostScript Files (*.ps)\t*.ps\n" .
    \ "EPS Files (*.eps)\t*.eps\n" .
    \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setlocal comments< formatoptions<"
    \ . "| unlet! b:browsefiler b:match_ignorecase b:match_words"

let &cpo = s:cpo_save
unlet s:cpo_save
                  usr/share/vim/vim74/ftplugin/procmail.vim                                                           0100644 0000000 0000000 00000000723 13050207306 017072  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         procmail(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &l:include = '^\s*INCLUDERC\>'

let &cpo = s:cpo_save
unlet s:cpo_save
                                             usr/share/vim/vim74/ftplugin/prolog.vim                                                             0100644 0000000 0000000 00000000654 13050207306 016571  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Prolog
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=s1:/*,mb:*,ex:*/,:% commentstring=%\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                    usr/share/vim/vim74/ftplugin/protocols.vim                                                          0100644 0000000 0000000 00000000675 13050207306 017316  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         protocols(5) - Internet protocols definition file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                   usr/share/vim/vim74/ftplugin/pyrex.vim                                                              0100644 0000000 0000000 00000001376 13050207306 016440  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Pyrex
" Maintainer:	Marco Barisione <marco.bari@people.it>
" URL:		http://marcobari.altervista.org/pyrex_vim.html
" Last Change:	2012 May 18

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let s:keepcpo= &cpo
set cpo&vim

" Behaves just like Python
runtime! ftplugin/python.vim ftplugin/python_*.vim ftplugin/python/*.vim

if has("gui_win32") && exists("b:browsefilter")
    let  b:browsefilter = "Pyrex files (*.pyx,*.pxd)\t*.pyx;*.pxd\n" .
			\ "Python Files (*.py)\t*.py\n" .
			\ "C Source Files (*.c)\t*.c\n" .
			\ "C Header Files (*.h)\t*.h\n" .
			\ "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
			\ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                                                  usr/share/vim/vim74/ftplugin/python.vim                                                             0100644 0000000 0000000 00000003405 13050207306 016605  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	python
" Maintainer:	Johannes Zellner <johannes@zellner.org>
" Last Change:	2014 Feb 09
" Last Change By Johannes: Wed, 21 Apr 2004 13:13:08 CEST

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1
let s:keepcpo= &cpo
set cpo&vim

setlocal cinkeys-=0#
setlocal indentkeys-=0#
setlocal include=^\\s*\\(from\\\|import\\)
setlocal includeexpr=substitute(v:fname,'\\.','/','g')
setlocal suffixesadd=.py
setlocal comments=b:#,fb:-
setlocal commentstring=#\ %s

setlocal omnifunc=pythoncomplete#Complete

set wildignore+=*.pyc

nnoremap <silent> <buffer> ]] :call <SID>Python_jump('/^\(class\\|def\)')<cr>
nnoremap <silent> <buffer> [[ :call <SID>Python_jump('?^\(class\\|def\)')<cr>
nnoremap <silent> <buffer> ]m :call <SID>Python_jump('/^\s*\(class\\|def\)')<cr>
nnoremap <silent> <buffer> [m :call <SID>Python_jump('?^\s*\(class\\|def\)')<cr>

if !exists('*<SID>Python_jump')
  fun! <SID>Python_jump(motion) range
      let cnt = v:count1
      let save = @/    " save last search pattern
      mark '
      while cnt > 0
	  silent! exe a:motion
	  let cnt = cnt - 1
      endwhile
      call histdel('/', -1)
      let @/ = save    " restore last search pattern
  endfun
endif

if has("browsefilter") && !exists("b:browsefilter")
    let b:browsefilter = "Python Files (*.py)\t*.py\n" .
		       \ "All Files (*.*)\t*.*\n"
endif

" As suggested by PEP8.
setlocal expandtab shiftwidth=4 softtabstop=4 tabstop=8

" First time: try finding "pydoc".
if !exists('g:pydoc_executable')
    if executable('pydoc')
        let g:pydoc_executable = 1
    else
        let g:pydoc_executable = 0
    endif
endif
" If "pydoc" was found use it for keywordprg.
if g:pydoc_executable
    setlocal keywordprg=pydoc
endif

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                                           usr/share/vim/vim74/ftplugin/qf.vim                                                                 0100644 0000000 0000000 00000000713 13050207306 015671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:     Vim's quickfix window
" Maintainer:   Lech Lorens <Lech.Lorens@gmail.com>
" Last Changed: 30 Apr 2012

if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let b:undo_ftplugin = "set stl<"

" Display the command that produced the list in the quickfix window:
setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%-15(%l,%c%V%)\ %P
                                                     usr/share/vim/vim74/ftplugin/quake.vim                                                              0100644 0000000 0000000 00000000653 13050207306 016374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Quake[1-3] configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:// commentstring=//\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                     usr/share/vim/vim74/ftplugin/r.vim                                                                  0100644 0000000 0000000 00000001444 13050207306 015526  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language: R
" Maintainer: Jakson Alves de Aquino <jalvesaq@gmail.com>
" Last Change:	Sun Feb 23, 2014  04:07PM

" Only do this when not yet done for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal iskeyword=@,48-57,_,.
setlocal formatoptions-=t
setlocal commentstring=#\ %s
setlocal comments=:#',:###,:##,:#

if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "R Source Files (*.R)\t*.R\n" .
        \ "Files that include R (*.Rnw *.Rd *.Rmd *.Rrst)\t*.Rnw;*.Rd;*.Rmd;*.Rrst\n" .
        \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl cms< com< fo< isk< | unlet! b:browsefilter"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                            usr/share/vim/vim74/ftplugin/racc.vim                                                               0100644 0000000 0000000 00000000665 13050207306 016201  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Racc input file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=s1:/*,mb:*,ex:*/,:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                           usr/share/vim/vim74/ftplugin/readline.vim                                                           0100644 0000000 0000000 00000000652 13050207306 017050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         readline(3) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                      usr/share/vim/vim74/ftplugin/registry.vim                                                           0100644 0000000 0000000 00000001344 13050207306 017134  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Windows Registry export with regedit (*.reg)
" Maintainer:       Cade Forester <ahx2323@gmail.com>
" Latest Revision:  2014-01-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin =
  \ 'let b:browsefilter = "" | ' .
  \ 'setlocal ' .
  \    'comments< '.
  \    'commentstring< ' .
  \    'formatoptions< '


if has( 'gui_win32' )
\ && !exists( 'b:browsefilter' )
   let b:browsefilter =
      \ 'registry files (*.reg)\t*.reg\n' .
      \ 'All files (*.*)\t*.*\n'
endif

setlocal comments=:;
setlocal commentstring=;\ %s

setlocal formatoptions-=t
setlocal formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                            usr/share/vim/vim74/ftplugin/reva.vim                                                               0100644 0000000 0000000 00000001305 13050207306 016216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim ftplugin file
" Language:	Reva Forth
" Version:	7.1
" Last Change:	2008/01/11
" Maintainer:	Ron Aaron <ron@ronware.org>
" URL:		http://ronware.org/reva/
" Filetypes:	*.rf *.frt 
" NOTE: 	Forth allows any non-whitespace in a name, so you need to do:
" 		setlocal iskeyword=!,@,33-35,%,$,38-64,A-Z,91-96,a-z,123-126,128-255
"
" 		This goes with the syntax/reva.vim file.

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
 finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

setlocal sts=4 sw=4 
setlocal com=s1:/*,mb:*,ex:*/,:\|,:\\
setlocal fo=tcrqol
setlocal matchpairs+=\::;
setlocal iskeyword=!,@,33-35,%,$,38-64,A-Z,91-96,a-z,123-126,128-255
                                                                                                                                                                                                                                                                                                                           usr/share/vim/vim74/ftplugin/rhelp.vim                                                              0100644 0000000 0000000 00000001254 13050207306 016376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language: R help file
" Maintainer: Jakson Alves de Aquino <jalvesaq@gmail.com>
" Last Change:	Wed Jul 09, 2014  06:23PM

" Only do this when not yet done for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal iskeyword=@,48-57,_,.

if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "R Source Files (*.R *.Rnw *.Rd *.Rmd *.Rrst)\t*.R;*.Rnw;*.Rd;*.Rmd;*.Rrst\n" .
        \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl isk< | unlet! b:browsefilter"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: sw=2
                                                                                                                                                                                                                                                                                                                                                    usr/share/vim/vim74/ftplugin/rmd.vim                                                                0100644 0000000 0000000 00000002264 13050207306 016050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language: R help file
" Maintainer: Jakson Alves de Aquino <jalvesaq@gmail.com>
" Last Change:	Wed Jul 09, 2014  06:23PM
" Original work by Alex Zvoleff (adjusted for rmd by Michel Kuhlmann)

" Only do this when not yet done for this buffer
if exists("b:did_ftplugin")
  finish
endif

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim

setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=>\ %s
setlocal formatoptions+=tcqln
setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^\\s*[-*+]\\s\\+
setlocal iskeyword=@,48-57,_,.

let s:cpo_save = &cpo
set cpo&vim

" Enables pandoc if it is installed
unlet! b:did_ftplugin
runtime ftplugin/pandoc.vim

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "R Source Files (*.R *.Rnw *.Rd *.Rmd *.Rrst)\t*.R;*.Rnw;*.Rd;*.Rmd;*.Rrst\n" .
        \ "All Files (*.*)\t*.*\n"
endif

if exists('b:undo_ftplugin')
  let b:undo_ftplugin .= " | setl cms< com< fo< flp< isk< | unlet! b:browsefilter"
else
  let b:undo_ftplugin = "setl cms< com< fo< flp< isk< | unlet! b:browsefilter"
endif

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: sw=2
                                                                                                                                                                                                                                                                                                                                            usr/share/vim/vim74/ftplugin/rnc.vim                                                                0100644 0000000 0000000 00000000643 13050207306 016047  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Relax NG compact syntax
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                             usr/share/vim/vim74/ftplugin/rnoweb.vim                                                             0100644 0000000 0000000 00000001727 13050207306 016565  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language: Rnoweb
" Maintainer: Jakson Alves de Aquino <jalvesaq@gmail.com>
" Last Change:	Wed Jul 09, 2014  06:23PM

" Only do this when not yet done for this buffer
if exists("b:did_ftplugin")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

runtime! ftplugin/tex.vim

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Enables Vim-Latex-Suite, LaTeX-Box if installed
runtime ftplugin/tex_*.vim

setlocal iskeyword=@,48-57,_,.
setlocal suffixesadd=.bib,.tex
setlocal comments=b:%,b:#,b:##,b:###,b:#'

if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "R Source Files (*.R *.Rnw *.Rd *.Rmd *.Rrst)\t*.R;*.Rnw;*.Rd;*.Rmd;*.Rrst\n" .
        \ "All Files (*.*)\t*.*\n"
endif

if exists('b:undo_ftplugin')
  let b:undo_ftplugin .= " | setl isk< sua< com< | unlet! b:browsefilter"
else
  let b:undo_ftplugin = "setl isk< sua< com< | unlet! b:browsefilter"
endif

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: sw=2
                                         usr/share/vim/vim74/ftplugin/rpl.vim                                                                0100644 0000000 0000000 00000001154 13050207306 016060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:     RPL/2
" Maintainer:   Jol BERTRAND <rpl2@free.fr>
" Last Change:	2012 Mar 07
" Version: 		0.1

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

let b:undo_ftplugin = "setlocal fo< comments<"
                                                                                                                                                                                                                                                                                                                                                                                                                    usr/share/vim/vim74/ftplugin/rrst.vim                                                               0100644 0000000 0000000 00000002031 13050207306 016250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language: reStructuredText documentation format with R code
" Maintainer: Jakson Alves de Aquino <jalvesaq@gmail.com>
" Last Change:	Wed Jul 09, 2014  06:23PM
" Original work by Alex Zvoleff

" Only do this when not yet done for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=>\ %s
setlocal formatoptions+=tcqln
setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^\\s*[-*+]\\s\\+
setlocal iskeyword=@,48-57,_,.

if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "R Source Files (*.R *.Rnw *.Rd *.Rmd *.Rrst)\t*.R;*.Rnw;*.Rd;*.Rmd;*.Rrst\n" .
        \ "All Files (*.*)\t*.*\n"
endif

if exists('b:undo_ftplugin')
  let b:undo_ftplugin .= " | setl cms< com< fo< flp< isk< | unlet! b:browsefilter"
else
  let b:undo_ftplugin = "setl cms< com< fo< flp< isk< | unlet! b:browsefilter"
endif

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: sw=2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/share/vim/vim74/ftplugin/rst.vim                                                                0100644 0000000 0000000 00000000674 13050207306 016101  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         reStructuredText documentation format
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< et< fo<"

setlocal comments=fb:.. commentstring=..\ %s expandtab
setlocal formatoptions+=tcroql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                    usr/share/vim/vim74/ftplugin/ruby.vim                                                               0100644 0000000 0000000 00000036754 13050207306 016262  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:		Ruby
" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
" URL:			https://github.com/vim-ruby/vim-ruby
" Release Coordinator:  Doug Kearns <dougkearns@gmail.com>
" ----------------------------------------------------------------------------

if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

if has("gui_running") && !has("gui_win32")
  setlocal keywordprg=ri\ -T\ -f\ bs
else
  setlocal keywordprg=ri
endif

" Matchit support
if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_ignorecase = 0

  let b:match_words =
	\ '\<\%(if\|unless\|case\|while\|until\|for\|do\|class\|module\|def\|begin\)\>=\@!' .
	\ ':' .
	\ '\<\%(else\|elsif\|ensure\|when\|rescue\|break\|redo\|next\|retry\)\>' .
	\ ':' .
	\ '\<end\>' .
	\ ',{:},\[:\],(:)'

  let b:match_skip =
	\ "synIDattr(synID(line('.'),col('.'),0),'name') =~ '" .
	\ "\\<ruby\\%(String\\|StringDelimiter\\|ASCIICode\\|Escape\\|" .
	\ "Interpolation\\|NoInterpolation\\|Comment\\|Documentation\\|" .
	\ "ConditionalModifier\\|RepeatModifier\\|OptionalDo\\|" .
	\ "Function\\|BlockArgument\\|KeywordAsMethod\\|ClassVariable\\|" .
	\ "InstanceVariable\\|GlobalVariable\\|Symbol\\)\\>'"
endif

setlocal formatoptions-=t formatoptions+=croql

setlocal include=^\\s*\\<\\(load\\>\\\|require\\>\\\|autoload\\s*:\\=[\"']\\=\\h\\w*[\"']\\=,\\)
setlocal includeexpr=substitute(substitute(v:fname,'::','/','g'),'$','.rb','')
setlocal suffixesadd=.rb

if exists("&ofu") && has("ruby")
  setlocal omnifunc=rubycomplete#Complete
endif

" To activate, :set ballooneval
if has('balloon_eval') && exists('+balloonexpr')
  setlocal balloonexpr=RubyBalloonexpr()
endif


" TODO:
"setlocal define=^\\s*def

setlocal comments=:#
setlocal commentstring=#\ %s

if !exists('g:ruby_version_paths')
  let g:ruby_version_paths = {}
endif

function! s:query_path(root)
  let code = "print $:.join %q{,}"
  if &shell =~# 'sh' && $PATH !~# '\s'
    let prefix = 'env PATH='.$PATH.' '
  else
    let prefix = ''
  endif
  if &shellxquote == "'"
    let path_check = prefix.'ruby -e "' . code . '"'
  else
    let path_check = prefix."ruby -e '" . code . "'"
  endif

  let cd = haslocaldir() ? 'lcd' : 'cd'
  let cwd = getcwd()
  try
    exe cd fnameescape(a:root)
    let path = split(system(path_check),',')
    exe cd fnameescape(cwd)
    return path
  finally
    exe cd fnameescape(cwd)
  endtry
endfunction

function! s:build_path(path)
  let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
  if &g:path !~# '\v^\.%(,/%(usr|emx)/include)=,,$'
    let path = substitute(&g:path,',,$',',','') . ',' . path
  endif
  return path
endfunction

if !exists('b:ruby_version') && !exists('g:ruby_path') && isdirectory(expand('%:p:h'))
  let s:version_file = findfile('.ruby-version', '.;')
  if !empty(s:version_file)
    let b:ruby_version = get(readfile(s:version_file, '', 1), '')
    if !has_key(g:ruby_version_paths, b:ruby_version)
      let g:ruby_version_paths[b:ruby_version] = s:query_path(fnamemodify(s:version_file, ':p:h'))
    endif
  endif
endif

if exists("g:ruby_path")
  let s:ruby_path = type(g:ruby_path) == type([]) ? join(g:ruby_path, ',') : g:ruby_path
elseif has_key(g:ruby_version_paths, get(b:, 'ruby_version', ''))
  let s:ruby_paths = g:ruby_version_paths[b:ruby_version]
  let s:ruby_path = s:build_path(s:ruby_paths)
else
  if !exists('g:ruby_default_path')
    if has("ruby") && has("win32")
      ruby ::VIM::command( 'let g:ruby_default_path = split("%s",",")' % $:.join(%q{,}) )
    elseif executable('ruby')
      let g:ruby_default_path = s:query_path($HOME)
    else
      let g:ruby_default_path = map(split($RUBYLIB,':'), 'v:val ==# "." ? "" : v:val')
    endif
  endif
  let s:ruby_paths = g:ruby_default_path
  let s:ruby_path = s:build_path(s:ruby_paths)
endif

if stridx(&l:path, s:ruby_path) == -1
  let &l:path = s:ruby_path
endif
if exists('s:ruby_paths') && stridx(&l:tags, join(map(copy(s:ruby_paths),'v:val."/tags"'),',')) == -1
  let &l:tags = &tags . ',' . join(map(copy(s:ruby_paths),'v:val."/tags"'),',')
endif

if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "Ruby Source Files (*.rb)\t*.rb\n" .
                     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl fo< inc< inex< sua< def< com< cms< path< tags< kp<"
      \."| unlet! b:browsefilter b:match_ignorecase b:match_words b:match_skip"
      \."| if exists('&ofu') && has('ruby') | setl ofu< | endif"
      \."| if has('balloon_eval') && exists('+bexpr') | setl bexpr< | endif"

if !exists("g:no_plugin_maps") && !exists("g:no_ruby_maps")
  nnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','b','n')<CR>
  nnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','','n')<CR>
  nnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','b','n')<CR>
  nnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','','n')<CR>
  xnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','b','v')<CR>
  xnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','','v')<CR>
  xnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','b','v')<CR>
  xnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','','v')<CR>

  nnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','b','n')<CR>
  nnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','','n')<CR>
  nnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','b','n')<CR>
  nnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','','n')<CR>
  xnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','b','v')<CR>
  xnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','','v')<CR>
  xnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','b','v')<CR>
  xnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','','v')<CR>

  let b:undo_ftplugin = b:undo_ftplugin
        \."| sil! exe 'unmap <buffer> [[' | sil! exe 'unmap <buffer> ]]' | sil! exe 'unmap <buffer> []' | sil! exe 'unmap <buffer> ]['"
        \."| sil! exe 'unmap <buffer> [m' | sil! exe 'unmap <buffer> ]m' | sil! exe 'unmap <buffer> [M' | sil! exe 'unmap <buffer> ]M'"

  if maparg('im','n') == ''
    onoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
    onoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
    xnoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
    xnoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
    let b:undo_ftplugin = b:undo_ftplugin
          \."| sil! exe 'ounmap <buffer> im' | sil! exe 'ounmap <buffer> am'"
          \."| sil! exe 'xunmap <buffer> im' | sil! exe 'xunmap <buffer> am'"
  endif

  if maparg('iM','n') == ''
    onoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
    onoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
    xnoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
    xnoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
    let b:undo_ftplugin = b:undo_ftplugin
          \."| sil! exe 'ounmap <buffer> iM' | sil! exe 'ounmap <buffer> aM'"
          \."| sil! exe 'xunmap <buffer> iM' | sil! exe 'xunmap <buffer> aM'"
  endif

  if maparg("\<C-]>",'n') == ''
    nnoremap <silent> <buffer> <C-]>       :<C-U>exe  v:count1."tag <C-R>=RubyCursorIdentifier()<CR>"<CR>
    nnoremap <silent> <buffer> g<C-]>      :<C-U>exe         "tjump <C-R>=RubyCursorIdentifier()<CR>"<CR>
    nnoremap <silent> <buffer> g]          :<C-U>exe       "tselect <C-R>=RubyCursorIdentifier()<CR>"<CR>
    nnoremap <silent> <buffer> <C-W>]      :<C-U>exe v:count1."stag <C-R>=RubyCursorIdentifier()<CR>"<CR>
    nnoremap <silent> <buffer> <C-W><C-]>  :<C-U>exe v:count1."stag <C-R>=RubyCursorIdentifier()<CR>"<CR>
    nnoremap <silent> <buffer> <C-W>g<C-]> :<C-U>exe        "stjump <C-R>=RubyCursorIdentifier()<CR>"<CR>
    nnoremap <silent> <buffer> <C-W>g]     :<C-U>exe      "stselect <C-R>=RubyCursorIdentifier()<CR>"<CR>
    nnoremap <silent> <buffer> <C-W>}      :<C-U>exe          "ptag <C-R>=RubyCursorIdentifier()<CR>"<CR>
    nnoremap <silent> <buffer> <C-W>g}     :<C-U>exe        "ptjump <C-R>=RubyCursorIdentifier()<CR>"<CR>
    let b:undo_ftplugin = b:undo_ftplugin
          \."| sil! exe 'nunmap <buffer> <C-]>'| sil! exe 'nunmap <buffer> g<C-]>'| sil! exe 'nunmap <buffer> g]'"
          \."| sil! exe 'nunmap <buffer> <C-W>]'| sil! exe 'nunmap <buffer> <C-W><C-]>'"
          \."| sil! exe 'nunmap <buffer> <C-W>g<C-]>'| sil! exe 'nunmap <buffer> <C-W>g]'"
          \."| sil! exe 'nunmap <buffer> <C-W>}'| sil! exe 'nunmap <buffer> <C-W>g}'"
  endif

  if maparg("gf",'n') == ''
    " By using findfile() rather than gf's normal behavior, we prevent
    " erroneously editing a directory.
    nnoremap <silent> <buffer> gf         :<C-U>exe <SID>gf(v:count1,"gf",'edit')<CR>
    nnoremap <silent> <buffer> <C-W>f     :<C-U>exe <SID>gf(v:count1,"\<Lt>C-W>f",'split')<CR>
    nnoremap <silent> <buffer> <C-W><C-F> :<C-U>exe <SID>gf(v:count1,"\<Lt>C-W>\<Lt>C-F>",'split')<CR>
    nnoremap <silent> <buffer> <C-W>gf    :<C-U>exe <SID>gf(v:count1,"\<Lt>C-W>gf",'tabedit')<CR>
    let b:undo_ftplugin = b:undo_ftplugin
          \."| sil! exe 'nunmap <buffer> gf' | sil! exe 'nunmap <buffer> <C-W>f' | sil! exe 'nunmap <buffer> <C-W><C-F>' | sil! exe 'nunmap <buffer> <C-W>gf'"
  endif
endif

let &cpo = s:cpo_save
unlet s:cpo_save

if exists("g:did_ruby_ftplugin_functions")
  finish
endif
let g:did_ruby_ftplugin_functions = 1

function! RubyBalloonexpr()
  if !exists('s:ri_found')
    let s:ri_found = executable('ri')
  endif
  if s:ri_found
    let line = getline(v:beval_lnum)
    let b = matchstr(strpart(line,0,v:beval_col),'\%(\w\|[:.]\)*$')
    let a = substitute(matchstr(strpart(line,v:beval_col),'^\w*\%([?!]\|\s*=\)\?'),'\s\+','','g')
    let str = b.a
    let before = strpart(line,0,v:beval_col-strlen(b))
    let after  = strpart(line,v:beval_col+strlen(a))
    if str =~ '^\.'
      let str = substitute(str,'^\.','#','g')
      if before =~ '\]\s*$'
        let str = 'Array'.str
      elseif before =~ '}\s*$'
        " False positives from blocks here
        let str = 'Hash'.str
      elseif before =~ "[\"'`]\\s*$" || before =~ '\$\d\+\s*$'
        let str = 'String'.str
      elseif before =~ '\$\d\+\.\d\+\s*$'
        let str = 'Float'.str
      elseif before =~ '\$\d\+\s*$'
        let str = 'Integer'.str
      elseif before =~ '/\s*$'
        let str = 'Regexp'.str
      else
        let str = substitute(str,'^#','.','')
      endif
    endif
    let str = substitute(str,'.*\.\s*to_f\s*\.\s*','Float#','')
    let str = substitute(str,'.*\.\s*to_i\%(nt\)\=\s*\.\s*','Integer#','')
    let str = substitute(str,'.*\.\s*to_s\%(tr\)\=\s*\.\s*','String#','')
    let str = substitute(str,'.*\.\s*to_sym\s*\.\s*','Symbol#','')
    let str = substitute(str,'.*\.\s*to_a\%(ry\)\=\s*\.\s*','Array#','')
    let str = substitute(str,'.*\.\s*to_proc\s*\.\s*','Proc#','')
    if str !~ '^\w'
      return ''
    endif
    silent! let res = substitute(system("ri -f rdoc -T \"".str.'"'),'\n$','','')
    if res =~ '^Nothing known about' || res =~ '^Bad argument:' || res =~ '^More than one method'
      return ''
    endif
    return res
  else
    return ""
  endif
endfunction

function! s:searchsyn(pattern,syn,flags,mode)
  norm! m'
  if a:mode ==# 'v'
    norm! gv
  endif
  let i = 0
  let cnt = v:count ? v:count : 1
  while i < cnt
    let i = i + 1
    let line = line('.')
    let col  = col('.')
    let pos = search(a:pattern,'W'.a:flags)
    while pos != 0 && s:synname() !~# a:syn
      let pos = search(a:pattern,'W'.a:flags)
    endwhile
    if pos == 0
      call cursor(line,col)
      return
    endif
  endwhile
endfunction

function! s:synname()
  return synIDattr(synID(line('.'),col('.'),0),'name')
endfunction

function! s:wrap_i(back,forward)
  execute 'norm k'.a:forward
  let line = line('.')
  execute 'norm '.a:back
  if line('.') == line - 1
    return s:wrap_a(a:back,a:forward)
  endif
  execute 'norm jV'.a:forward.'k'
endfunction

function! s:wrap_a(back,forward)
  execute 'norm '.a:forward
  if line('.') < line('$') && getline(line('.')+1) ==# ''
    let after = 1
  endif
  execute 'norm '.a:back
  while getline(line('.')-1) =~# '^\s*#' && line('.')
    -
  endwhile
  if exists('after')
    execute 'norm V'.a:forward.'j'
  elseif line('.') > 1 && getline(line('.')-1) =~# '^\s*$'
    execute 'norm kV'.a:forward
  else
    execute 'norm V'.a:forward
  endif
endfunction

function! RubyCursorIdentifier()
  let asciicode    = '\%(\w\|[]})\"'."'".']\)\@<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)\)'
  let number       = '\%(\%(\w\|[]})\"'."'".']\s*\)\@<!-\)\=\%(\<[[:digit:]_]\+\%(\.[[:digit:]_]\+\)\=\%([Ee][[:digit:]_]\+\)\=\>\|\<0[xXbBoOdD][[:xdigit:]_]\+\>\)\|'.asciicode
  let operator     = '\%(\[\]\|<<\|<=>\|[!<>]=\=\|===\=\|[!=]\~\|>>\|\*\*\|\.\.\.\=\|=>\|[~^&|*/%+-]\)'
  let method       = '\%(\<[_a-zA-Z]\w*\>\%([?!]\|\s*=>\@!\)\=\)'
  let global       = '$\%([!$&"'."'".'*+,./:;<=>?@\`~]\|-\=\w\+\>\)'
  let symbolizable = '\%(\%(@@\=\)\w\+\>\|'.global.'\|'.method.'\|'.operator.'\)'
  let pattern      = '\C\s*\%('.number.'\|\%(:\@<!:\)\='.symbolizable.'\)'
  let [lnum, col]  = searchpos(pattern,'bcn',line('.'))
  let raw          = matchstr(getline('.')[col-1 : ],pattern)
  let stripped     = substitute(substitute(raw,'\s\+=$','=',''),'^\s*:\=','','')
  return stripped == '' ? expand("<cword>") : stripped
endfunction

function! s:gf(count,map,edit) abort
  if getline('.') =~# '^\s*require_relative\s*\(["'']\).*\1\s*$'
    let target = matchstr(getline('.'),'\(["'']\)\zs.\{-\}\ze\1')
    return a:edit.' %:h/'.target.'.rb'
  elseif getline('.') =~# '^\s*\%(require[( ]\|load[( ]\|autoload[( ]:\w\+,\)\s*\s*\%(::\)\=File\.expand_path(\(["'']\)\.\./.*\1,\s*__FILE__)\s*$'
    let target = matchstr(getline('.'),'\(["'']\)\.\./\zs.\{-\}\ze\1')
    return a:edit.' %:h/'.target.'.rb'
  elseif getline('.') =~# '^\s*\%(require \|load \|autoload :\w\+,\)\s*\(["'']\).*\1\s*$'
    let target = matchstr(getline('.'),'\(["'']\)\zs.\{-\}\ze\1')
  else
    let target = expand('<cfile>')
  endif
  let found = findfile(target, &path, a:count)
  if found ==# ''
    return 'norm! '.a:count.a:map
  else
    return a:edit.' '.fnameescape(found)
  endif
endfunction

"
" Instructions for enabling "matchit" support:
"
" 1. Look for the latest "matchit" plugin at
"
"         http://www.vim.org/scripts/script.php?script_id=39
"
"    It is also packaged with Vim, in the $VIMRUNTIME/macros directory.
"
" 2. Copy "matchit.txt" into a "doc" directory (e.g. $HOME/.vim/doc).
"
" 3. Copy "matchit.vim" into a "plugin" directory (e.g. $HOME/.vim/plugin).
"
" 4. Ensure this file (ftplugin/ruby.vim) is installed.
"
" 5. Ensure you have this line in your $HOME/.vimrc:
"         filetype plugin on
"
" 6. Restart Vim and create the matchit documentation:
"
"         :helptags ~/.vim/doc
"
"    Now you can do ":help matchit", and you should be able to use "%" on Ruby
"    keywords.  Try ":echo b:match_words" to be sure.
"
" Thanks to Mark J. Reed for the instructions.  See ":help vimrc" for the
" locations of plugin directories, etc., as there are several options, and it
" differs on Windows.  Email gsinclair@soyabean.com.au if you need help.
"

" vim: nowrap sw=2 sts=2 ts=8:
                    usr/share/vim/vim74/ftplugin/sass.vim                                                               0100644 0000000 0000000 00000001104 13050207306 016227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	Sass
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2010 Jul 26

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl cms< def< inc< inex< ofu< sua<"

setlocal commentstring=//\ %s
setlocal define=^\\s*\\%(@mixin\\\|=\\)
setlocal includeexpr=substitute(v:fname,'\\%(.*/\\\|^\\)\\zs','_','')
setlocal omnifunc=csscomplete#CompleteCSS
setlocal suffixesadd=.sass,.scss,.css

let &l:include = '^\s*@import\s\+\%(url(\)\=["'']\='

" vim:set sw=2:
                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/share/vim/vim74/ftplugin/scheme.vim                                                             0100644 0000000 0000000 00000003112 13050207306 016523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:      Scheme
" Maintainer:    Sergey Khorev <sergey.khorev@gmail.com>
" URL:		 http://sites.google.com/site/khorser/opensource/vim
" Original author:    Dorai Sitaram <ds26@gte.com>
" Original URL:		 http://www.ccs.neu.edu/~dorai/vimplugins/vimplugins.html
" Last Change:   Oct 23, 2013

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Copy-paste from ftplugin/lisp.vim
setl comments=:;
setl define=^\\s*(def\\k*
setl formatoptions-=t
setl iskeyword+=+,-,*,/,%,<,=,>,:,$,?,!,@-@,94
setl lisp
setl commentstring=;%s

setl comments^=:;;;,:;;,sr:#\|,mb:\|,ex:\|#

" Scheme-specific settings
if exists("b:is_mzscheme") || exists("is_mzscheme")
    " improve indenting
    setl iskeyword+=#,%,^
    setl lispwords+=module,parameterize,let-values,let*-values,letrec-values
    setl lispwords+=define-values,opt-lambda,case-lambda,syntax-rules,with-syntax,syntax-case
    setl lispwords+=define-signature,unit,unit/sig,compund-unit/sig,define-values/invoke-unit/sig
endif

if exists("b:is_chicken") || exists("is_chicken")
    " improve indenting
    setl iskeyword+=#,%,^
    setl lispwords+=let-optionals,let-optionals*,declare
    setl lispwords+=let-values,let*-values,letrec-values
    setl lispwords+=define-values,opt-lambda,case-lambda,syntax-rules,with-syntax,syntax-case
    setl lispwords+=cond-expand,and-let*,foreign-lambda,foreign-lambda*
endif

let b:undo_ftplugin = "setlocal comments< define< formatoptions< iskeyword< lispwords< lisp< commentstring<"
                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/share/vim/vim74/ftplugin/screen.vim                                                             0100644 0000000 0000000 00000000650 13050207306 016542  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         screen(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                        usr/share/vim/vim74/ftplugin/scss.vim                                                               0100644 0000000 0000000 00000000310 13050207306 016227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	SCSS
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2010 Jul 26

if exists("b:did_ftplugin")
  finish
endif

runtime! ftplugin/sass.vim

" vim:set sw=2:
                                                                                                                                                                                                                                                                                                                        usr/share/vim/vim74/ftplugin/sensors.vim                                                            0100644 0000000 0000000 00000000673 13050207306 016764  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         sensors.conf(5) - libsensors configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                     usr/share/vim/vim74/ftplugin/services.vim                                                           0100644 0000000 0000000 00000000670 13050207306 017110  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         services(5) - Internet network services list
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                        usr/share/vim/vim74/ftplugin/setserial.vim                                                          0100644 0000000 0000000 00000000653 13050207306 017261  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         setserial(8) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                     usr/share/vim/vim74/ftplugin/sgml.vim                                                               0100644 0000000 0000000 00000002272 13050207306 016227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	sgml
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "XML Files (*.xml)\t*.xml\n" .
	    \	     "All Files (*.*)\t*.*\n"

runtime! ftplugin/xml.vim ftplugin/xml_*.vim ftplugin/xml/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif

" Change the :browse e filter to primarily show xml-related files.
if has("gui_win32")
    let  b:browsefilter="SGML Files (*.sgml,*.sgm)\t*.sgm*\n" . s:browsefilter
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:browsefilter | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                      usr/share/vim/vim74/ftplugin/sh.vim                                                                 0100644 0000000 0000000 00000002262 13050207306 015676  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	sh
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal commentstring=#%s

" Shell:  thanks to Johannes Zellner
if exists("loaded_matchit")
    let s:sol = '\%(;\s*\|^\s*\)\@<='  " start of line
    let b:match_words =
    \ s:sol.'if\>:' . s:sol.'elif\>:' . s:sol.'else\>:' . s:sol. 'fi\>,' .
    \ s:sol.'\%(for\|while\)\>:' . s:sol. 'done\>,' .
    \ s:sol.'case\>:' . s:sol. 'esac\>'
endif

" Change the :browse e filter to primarily show shell-related files.
if has("gui_win32")
    let  b:browsefilter="Bourne Shell Scripts (*.sh)\t*.sh\n" .
		\	"Korn Shell Scripts (*.ksh)\t*.ksh\n" .
		\	"Bash Shell Scripts (*.bash)\t*.bash\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal cms< | unlet! b:browsefilter b:match_words"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                              usr/share/vim/vim74/ftplugin/sieve.vim                                                              0100644 0000000 0000000 00000000711 13050207306 016374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Sieve filtering language input file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=s1:/*,mb:*,ex:*/,:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                       usr/share/vim/vim74/ftplugin/slpconf.vim                                                            0100644 0000000 0000000 00000000721 13050207306 016726  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         RFC 2614 - An API for Service Location configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:#,:; commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                               usr/share/vim/vim74/ftplugin/slpreg.vim                                                             0100644 0000000 0000000 00000000720 13050207306 016555  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         RFC 2614 - An API for Service Location registration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:#,:; commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                usr/share/vim/vim74/ftplugin/slpspi.vim                                                             0100644 0000000 0000000 00000000707 13050207306 016600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         RFC 2614 - An API for Service Location SPI file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:#,:; commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                         usr/share/vim/vim74/ftplugin/spec.vim                                                               0100644 0000000 0000000 00000012155 13050207306 016220  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Plugin to update the %changelog section of RPM spec files
" Filename: spec.vim
" Maintainer: Igor Gnatenko i.gnatenko.brain@gmail.com
" Former Maintainer: Gustavo Niemeyer <niemeyer@conectiva.com> (until March 2014)
" Last Change: Sun Mar 2 11:24 MSK 2014 Igor Gnatenko

if exists("b:did_ftplugin")
	finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

if !exists("no_plugin_maps") && !exists("no_spec_maps")
	if !hasmapto("<Plug>SpecChangelog")
		map <buffer> <LocalLeader>c <Plug>SpecChangelog
	endif
endif

noremap <buffer> <unique> <script> <Plug>SpecChangelog :call <SID>SpecChangelog("")<CR>

if !exists("*s:SpecChangelog")
	function s:SpecChangelog(format)
		if strlen(a:format) == 0
			if !exists("g:spec_chglog_format")
				let email = input("Email address: ")
				let g:spec_chglog_format = "%a %b %d %Y " . l:email
				echo "\r"
			endif
			let format = g:spec_chglog_format
		else
			if !exists("g:spec_chglog_format")
				let g:spec_chglog_format = a:format
			endif
			let format = a:format
		endif
		let line = 0
		let name = ""
		let ver = ""
		let rel = ""
		let nameline = -1
		let verline = -1
		let relline = -1
		let chgline = -1
		while (line <= line("$"))
			let linestr = getline(line)
			if (name == "" && linestr =~? '^Name:')
				let nameline = line
				let name = substitute(strpart(linestr,5), '^[	 ]*\([^ 	]\+\)[		]*$','\1','')
			elseif (ver == "" && linestr =~? '^Version:')
				let verline = line
				let ver = substitute(strpart(linestr,8), '^[	 ]*\([^ 	]\+\)[		]*$','\1','')
			elseif (rel == "" && linestr =~? '^Release:')
				let relline = line
				let rel = substitute(strpart(linestr,8), '^[	 ]*\([^ 	]\+\)[		]*$','\1','')
			elseif (linestr =~? '^%changelog')
				let chgline = line
				execute line
				break
			endif
			let line = line+1
		endwhile
		if (nameline != -1 && verline != -1 && relline != -1)
			let include_release_info = exists("g:spec_chglog_release_info")
			let name = s:ParseRpmVars(name, nameline)
			let ver = s:ParseRpmVars(ver, verline)
			let rel = s:ParseRpmVars(rel, relline)
		else
			let include_release_info = 0
		endif
		if (chgline == -1)
			let option = confirm("Can't find %changelog. Create one? ","&End of file\n&Here\n&Cancel",3)
			if (option == 1)
				call append(line("$"),"")
				call append(line("$"),"%changelog")
				execute line("$")
				let chgline = line(".")
			elseif (option == 2)
				call append(line("."),"%changelog")
				normal j
				chgline = line(".")
			endif
		endif
		if (chgline != -1)
			let parsed_format = "* ".strftime(format)
			let release_info = "+ ".name."-".ver."-".rel
			let wrong_format = 0
			let wrong_release = 0
			let insert_line = 0
			if (getline(chgline+1) != parsed_format)
				let wrong_format = 1
			endif
			if (include_release_info && getline(chgline+2) != release_info)
				let wrong_release = 1
			endif
			if (wrong_format || wrong_release)
				if (include_release_info && !wrong_release && !exists("g:spec_chglog_never_increase_release"))
					let option = confirm("Increase release? ","&Yes\n&No",1)
					if (option == 1)
						execute relline
						normal 
						let rel = substitute(strpart(getline(relline),8), '^[	 ]*\([^ 	]\+\)[		]*$','\1','')
						let release_info = "+ ".name."-".ver."-".rel
					endif
				endif
				let n = 0
				call append(chgline+n, parsed_format)
				if include_release_info
					let n = n + 1
					call append(chgline+n, release_info)
				endif
				let n = n + 1
				call append(chgline+n,"- ")
				let n = n + 1
				call append(chgline+n,"")
				let insert_line = chgline+n
			else
				let line = chgline
				if !exists("g:spec_chglog_prepend")
					while !(getline(line+2) =~ '^\( *\|\*.*\)$')
						let line = line+1
					endwhile
				endif
				call append(line+1,"- ")
				let insert_line = line+2
			endif
			execute insert_line
			startinsert!
		endif
	endfunction
endif

if !exists("*s:ParseRpmVars")
    function s:ParseRpmVars(str, strline)
	let end = -1
	let ret = ""
	while (1)
		let start = match(a:str, "\%{", end+1)
		if (start == -1)
			let ret = ret . strpart(a:str, end+1)
			break
		endif
		let ret = ret . strpart(a:str, end+1, start-(end+1))
		let end = match(a:str, "}", start)
		if (end == -1)
			let ret = ret . strpart(a:str, start)
			break
		endif
		let varname = strpart(a:str, start+2, end-(start+2))
		execute a:strline
		let definestr = "^[ \t]*%define[ \t]\\+" . varname . "[ \t]\\+\\(.*\\)$"
		let linenum = search(definestr, "bW")
		if (linenum == 0)
			let definestr = substitute(definestr, "%define", "%global", "")
			let linenum = search(definestr, "bW")
		endif
		if (linenum != -1)
			let ret = ret .  substitute(getline(linenum), definestr, "\\1", "")
		else
			let ret = ret . strpart(str, start, end+1-start)
		endif
	endwhile
	return ret
    endfunction
endif

" The following lines, along with the macros/matchit.vim plugin,
" make it easy to navigate the different sections of a spec file
" with the % key (thanks to Max Ischenko).

let b:match_ignorecase = 0
let b:match_words =
  \ '^Name:^%description:^%clean:^%setup:^%build:^%install:^%files:' .
  \ '^%package:^%preun:^%postun:^%changelog'

let &cpo = s:cpo_save
unlet s:cpo_save

let b:undo_ftplugin = "unlet! b:match_ignorecase b:match_words"
                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/vim/vim74/ftplugin/sql.vim                                                                0100644 0000000 0000000 00000050122 13050207306 016061  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " SQL filetype plugin file
" Language:    SQL (Common for Oracle, Microsoft SQL Server, Sybase)
" Version:     11.0
" Maintainer:  David Fishburn <dfishburn dot vim at gmail dot com>
" Last Change: 2013 May 13
" Download:    http://vim.sourceforge.net/script.php?script_id=454

" For more details please use:
"        :h sql.txt
"
" This file should only contain values that are common to all SQL languages
" Oracle, Microsoft SQL Server, Sybase ASA/ASE, MySQL, and so on
" If additional features are required create:
"        vimfiles/after/ftplugin/sql.vim (Windows)
"        .vim/after/ftplugin/sql.vim     (Unix)
" to override and add any of your own settings.


" This file also creates a command, SQLSetType, which allows you to change
" SQL dialects on the fly.  For example, if I open an Oracle SQL file, it
" is color highlighted appropriately.  If I open an Informix SQL file, it
" will still be highlighted according to Oracles settings.  By running:
"     :SQLSetType sqlinformix
"
" All files called sqlinformix.vim will be loaded from the indent and syntax
" directories.  This allows you to easily flip SQL dialects on a per file
" basis.  NOTE: you can also use completion:
"     :SQLSetType <tab>
"
" To change the default dialect, add the following to your vimrc:
"    let g:sql_type_default = 'sqlanywhere'
"
" This file also creates a command, SQLGetType, which allows you to
" determine what the current dialect is in use.
"     :SQLGetType
"
" History
"
" Version 11.0 (May 2013)
"
" NF: Updated to use SyntaxComplete's new regex support for syntax groups.
"
" Version 10.0 (Dec 2012)
"
" NF: Changed all maps to use noremap instead of must map
" NF: Changed all visual maps to use xnoremap instead of vnoremap as they
"     should only be used in visual mode and not select mode.
" BF: Most of the maps were using doubled up backslashes before they were
"     changed to using the search() function, which meant they no longer
"     worked.
"
" Version 9.0
"
" NF: Completes 'b:undo_ftplugin'
" BF: Correctly set cpoptions when creating script
"
" Version 8.0
"
" NF: Improved the matchit plugin regex (Talek)
"
" Version 7.0
"
" NF: Calls the sqlcomplete#ResetCacheSyntax() function when calling
"     SQLSetType.
"
" Version 6.0
"
" NF: Adds the command SQLGetType
"
" Version 5.0
"
" NF: Adds the ability to choose the keys to control SQL completion, just add
"     the following to your .vimrc:
"    let g:ftplugin_sql_omni_key       = '<C-C>'
"    let g:ftplugin_sql_omni_key_right = '<Right>'
"    let g:ftplugin_sql_omni_key_left  = '<Left>'
"
" BF: format-options - Auto-wrap comments using textwidth was turned off
"                      by mistake.


" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

let s:save_cpo = &cpo
set cpo&vim

" Disable autowrapping for code, but enable for comments
" t	Auto-wrap text using textwidth
" c     Auto-wrap comments using textwidth, inserting the current comment
"       leader automatically.
setlocal formatoptions-=t
setlocal formatoptions+=c

" Functions/Commands to allow the user to change SQL syntax dialects
" through the use of :SQLSetType <tab> for completion.
" This works with both Vim 6 and 7.

if !exists("*SQL_SetType")
    " NOTE: You cannot use function! since this file can be
    " sourced from within this function.  That will result in
    " an error reported by Vim.
    function SQL_GetList(ArgLead, CmdLine, CursorPos)

        if !exists('s:sql_list')
            " Grab a list of files that contain "sql" in their names
            let list_indent   = globpath(&runtimepath, 'indent/*sql*')
            let list_syntax   = globpath(&runtimepath, 'syntax/*sql*')
            let list_ftplugin = globpath(&runtimepath, 'ftplugin/*sql*')

            let sqls = "\n".list_indent."\n".list_syntax."\n".list_ftplugin."\n"

            " Strip out everything (path info) but the filename
            " Regex
            "    From between two newline characters
            "    Non-greedily grab all characters
            "    Followed by a valid filename \w\+\.\w\+ (sql.vim)
            "    Followed by a newline, but do not include the newline
            "
            "    Replace it with just the filename (get rid of PATH)
            "
            "    Recursively, since there are many filenames that contain
            "    the word SQL in the indent, syntax and ftplugin directory
            let sqls = substitute( sqls,
                        \ '[\n]\%(.\{-}\)\(\w\+\.\w\+\)\n\@=',
                        \ '\1\n',
                        \ 'g'
                        \ )

            " Remove duplicates, since sqlanywhere.vim can exist in the
            " sytax, indent and ftplugin directory, yet we only want
            " to display the option once
            let index = match(sqls, '.\{-}\ze\n')
            while index > -1
                " Get the first filename
                let file = matchstr(sqls, '.\{-}\ze\n', index)
                " Recursively replace any *other* occurrence of that
                " filename with nothing (ie remove it)
                let sqls = substitute(sqls, '\%>'.(index+strlen(file)).'c\<'.file.'\>\n', '', 'g')
                " Move on to the next filename
                let index = match(sqls, '.\{-}\ze\n', (index+strlen(file)+1))
            endwhile

            " Sort the list if using version 7
            if v:version >= 700
                let mylist = split(sqls, "\n")
                let mylist = sort(mylist)
                let sqls   = join(mylist, "\n")
            endif

            let s:sql_list = sqls
        endif

        return s:sql_list

    endfunction

    function SQL_SetType(name)

        " User has decided to override default SQL scripts and
        " specify a vendor specific version
        " (ie Oracle, Informix, SQL Anywhere, ...)
        " So check for an remove any settings that prevent the
        " scripts from being executed, and then source the
        " appropriate Vim scripts.
        if exists("b:did_ftplugin")
            unlet b:did_ftplugin
        endif
        if exists("b:current_syntax")
            " echomsg 'SQLSetType - clearing syntax'
            syntax clear
        endif
        if exists("b:did_indent")
            " echomsg 'SQLSetType - clearing indent'
            unlet b:did_indent
            " Set these values to their defaults
            setlocal indentkeys&
            setlocal indentexpr&
        endif

        " Ensure the name is in the correct format
        let new_sql_type = substitute(a:name,
                    \ '\s*\([^\.]\+\)\(\.\w\+\)\?', '\L\1', '')

        " Do not specify a buffer local variable if it is
        " the default value
        if new_sql_type == 'sql'
          let new_sql_type = 'sqloracle'
        endif
        let b:sql_type_override = new_sql_type

        " Remove any cached SQL since a new sytax will have different
        " items and groups
        if !exists('g:loaded_sql_completion') || g:loaded_sql_completion >= 100
            call sqlcomplete#ResetCacheSyntax()
        endif

        " Vim will automatically source the correct files if we
        " change the filetype.  You cannot do this with setfiletype
        " since that command will only execute if a filetype has
        " not already been set.  In this case we want to override
        " the existing filetype.
        let &filetype = 'sql'

        if b:sql_compl_savefunc != ""
            " We are changing the filetype to SQL from some other filetype
            " which had OMNI completion defined.  We need to activate the
            " SQL completion plugin in order to cache some of the syntax items
            " while the syntax rules for SQL are active.
            call sqlcomplete#PreCacheSyntax()
        endif
    endfunction
    command! -nargs=* -complete=custom,SQL_GetList SQLSetType :call SQL_SetType(<q-args>)

endif

" Functions/Commands to allow the user determine current SQL syntax dialect
" This works with both Vim 6 and 7.

if !exists("*SQL_GetType")
    function SQL_GetType()
        if exists('b:sql_type_override')
            echomsg "Current SQL dialect in use:".b:sql_type_override
        else
            echomsg "Current SQL dialect in use:".g:sql_type_default
        endif
    endfunction
    command! -nargs=0 SQLGetType :call SQL_GetType()
endif

if exists("b:sql_type_override")
    " echo 'sourcing buffer ftplugin/'.b:sql_type_override.'.vim'
    if globpath(&runtimepath, 'ftplugin/'.b:sql_type_override.'.vim') != ''
        exec 'runtime ftplugin/'.b:sql_type_override.'.vim'
    " else
    "     echomsg 'ftplugin/'.b:sql_type_override.' not exist, using default'
    endif
elseif exists("g:sql_type_default")
    " echo 'sourcing global ftplugin/'.g:sql_type_default.'.vim'
    if globpath(&runtimepath, 'ftplugin/'.g:sql_type_default.'.vim') != ''
        exec 'runtime ftplugin/'.g:sql_type_default.'.vim'
    " else
    "     echomsg 'ftplugin/'.g:sql_type_default.'.vim not exist, using default'
    endif
endif

" If the above runtime command succeeded, do not load the default settings
if exists("b:did_ftplugin")
  finish
endif

let b:undo_ftplugin = "setl comments< formatoptions< define< omnifunc<" .
		    \ " | unlet! b:browsefilter b:match_words"

" Don't load another plugin for this buffer
let b:did_ftplugin     = 1
let b:current_ftplugin = 'sql'

" Win32 can filter files in the browse dialog
if has("gui_win32") && !exists("b:browsefilter")
    let b:browsefilter = "SQL Files (*.sql)\t*.sql\n" .
	  \ "All Files (*.*)\t*.*\n"
endif

" Some standard expressions for use with the matchit strings
let s:notend = '\%(\<end\s\+\)\@<!'
let s:when_no_matched_or_others = '\%(\<when\>\%(\s\+\%(\%(\<not\>\s\+\)\?<matched\>\)\|\<others\>\)\@!\)'
let s:or_replace = '\%(or\s\+replace\s\+\)\?'

" Define patterns for the matchit macro
if !exists("b:match_words")
    " SQL is generally case insensitive
    let b:match_ignorecase = 1

    " Handle the following:
    " if
    " elseif | elsif
    " else [if]
    " end if
    "
    " [while condition] loop
    "     leave
    "     break
    "     continue
    "     exit
    " end loop
    "
    " for
    "     leave
    "     break
    "     continue
    "     exit
    " end loop
    "
    " do
    "     statements
    " doend
    "
    " case
    " when
    " when
    " default
    " end case
    "
    " merge
    " when not matched
    " when matched
    "
    " EXCEPTION
    " WHEN column_not_found THEN
    " WHEN OTHERS THEN
    "
    " create[ or replace] procedure|function|event
                " \ '^\s*\<\%(do\|for\|while\|loop\)\>.*:'.

    " For ColdFusion support
    setlocal matchpairs+=<:>
    let b:match_words = &matchpairs .
		\ ',\<begin\>:\<end\>\W*$,'.
		\
                \ s:notend . '\<if\>:'.
                \ '\<elsif\>\|\<elseif\>\|\<else\>:'.
                \ '\<end\s\+if\>,'.
                \
                \ '\(^\s*\)\@<=\(\<\%(do\|for\|while\|loop\)\>.*\):'.
                \ '\%(\<exit\>\|\<leave\>\|\<break\>\|\<continue\>\):'.
                \ '\%(\<doend\>\|\%(\<end\s\+\%(for\|while\|loop\>\)\)\),'.
                \
                \ '\%('. s:notend . '\<case\>\):'.
                \ '\%('.s:when_no_matched_or_others.'\):'.
                \ '\%(\<when\s\+others\>\|\<end\s\+case\>\),' .
                \
                \ '\<merge\>:' .
                \ '\<when\s\+not\s\+matched\>:' .
                \ '\<when\s\+matched\>,' .
                \
                \ '\%(\<create\s\+' . s:or_replace . '\)\?'.
                \ '\%(function\|procedure\|event\):'.
                \ '\<returns\?\>'
                " \ '\<begin\>\|\<returns\?\>:'.
                " \ '\<end\>\(;\)\?\s*$'
                " \ '\<exception\>:'.s:when_no_matched_or_others.
                " \ ':\<when\s\+others\>,'.
		"
                " \ '\%(\<exception\>\|\%('. s:notend . '\<case\>\)\):'.
                " \ '\%(\<default\>\|'.s:when_no_matched_or_others.'\):'.
                " \ '\%(\%(\<when\s\+others\>\)\|\<end\s\+case\>\),' .
endif

" Define how to find the macro definition of a variable using the various
" [d, [D, [_CTRL_D and so on features
" Match these values ignoring case
" ie  DECLARE varname INTEGER
let &l:define = '\c\<\(VARIABLE\|DECLARE\|IN\|OUT\|INOUT\)\>'


" Mappings to move to the next BEGIN ... END block
" \W - no characters or digits
nnoremap <buffer> <silent> ]] :call search('\c^\s*begin\>', 'W' )<CR>
nnoremap <buffer> <silent> [[ :call search('\c^\s*begin\>', 'bW' )<CR>
nnoremap <buffer> <silent> ][ :call search('\c^\s*end\W*$', 'W' )<CR>
nnoremap <buffer> <silent> [] :call search('\c^\s*end\W*$', 'bW' )<CR>
xnoremap <buffer> <silent> ]] :<C-U>exec "normal! gv"<Bar>call search('\c^\s*begin\>', 'W' )<CR>
xnoremap <buffer> <silent> [[ :<C-U>exec "normal! gv"<Bar>call search('\c^\s*begin\>', 'bW' )<CR>
xnoremap <buffer> <silent> ][ :<C-U>exec "normal! gv"<Bar>call search('\c^\s*end\W*$', 'W' )<CR>
xnoremap <buffer> <silent> [] :<C-U>exec "normal! gv"<Bar>call search('\c^\s*end\W*$', 'bW' )<CR>


" By default only look for CREATE statements, but allow
" the user to override
if !exists('g:ftplugin_sql_statements')
    let g:ftplugin_sql_statements = 'create'
endif

" Predefined SQL objects what are used by the below mappings using
" the ]} style maps.
" This global variable allows the users to override it's value
" from within their vimrc.
" Note, you cannot use \?, since these patterns can be used to search
" backwards, you must use \{,1}
if !exists('g:ftplugin_sql_objects')
    let g:ftplugin_sql_objects = 'function,procedure,event,' .
                \ '\(existing\\|global\s\+temporary\s\+\)\{,1}' .
                \ 'table,trigger' .
                \ ',schema,service,publication,database,datatype,domain' .
                \ ',index,subscription,synchronization,view,variable'
endif

" Key to trigger SQL completion
if !exists('g:ftplugin_sql_omni_key')
    let g:ftplugin_sql_omni_key = '<C-C>'
endif
" Key to trigger drill into column list
if !exists('g:ftplugin_sql_omni_key_right')
    let g:ftplugin_sql_omni_key_right = '<Right>'
endif
" Key to trigger drill out of column list
if !exists('g:ftplugin_sql_omni_key_left')
    let g:ftplugin_sql_omni_key_left = '<Left>'
endif

" Replace all ,'s with bars, except ones with numbers after them.
" This will most likely be a \{,1} string.
let s:ftplugin_sql_objects =
            \ '\c^\s*' .
            \ '\(\(' .
            \ substitute(g:ftplugin_sql_statements, ',\d\@!', '\\\\|', 'g') .
            \ '\)\s\+\(or\s\+replace\s\+\)\{,1}\)\{,1}' .
            \ '\<\(' .
            \ substitute(g:ftplugin_sql_objects, ',\d\@!', '\\\\|', 'g') .
            \ '\)\>'

" Mappings to move to the next CREATE ... block
exec "nnoremap <buffer> <silent> ]} :call search('".s:ftplugin_sql_objects."', 'W')<CR>"
exec "nnoremap <buffer> <silent> [{ :call search('".s:ftplugin_sql_objects."', 'bW')<CR>"
" Could not figure out how to use a :call search() string in visual mode
" without it ending visual mode
" Unfortunately, this will add a entry to the search history
exec 'xnoremap <buffer> <silent> ]} /'.s:ftplugin_sql_objects.'<CR>'
exec 'xnoremap <buffer> <silent> [{ ?'.s:ftplugin_sql_objects.'<CR>'

" Mappings to move to the next COMMENT
"
" Had to double the \ for the \| separator since this has a special
" meaning on maps
let b:comment_leader = '\(--\\|\/\/\\|\*\\|\/\*\\|\*\/\)'
" Find the start of the next comment
let b:comment_start  = '^\(\s*'.b:comment_leader.'.*\n\)\@<!'.
            \ '\(\s*'.b:comment_leader.'\)'
" Find the end of the previous comment
let b:comment_end = '\(^\s*'.b:comment_leader.'.*\n\)'.
            \ '\(^\s*'.b:comment_leader.'\)\@!'
" Skip over the comment
let b:comment_jump_over  = "call search('".
            \ '^\(\s*'.b:comment_leader.'.*\n\)\@<!'.
            \ "', 'W')"
let b:comment_skip_back  = "call search('".
            \ '^\(\s*'.b:comment_leader.'.*\n\)\@<!'.
            \ "', 'bW')"
" Move to the start and end of comments
exec 'nnoremap <silent><buffer> ]" :call search('."'".b:comment_start."'".', "W" )<CR>'
exec 'nnoremap <silent><buffer> [" :call search('."'".b:comment_end."'".', "W" )<CR>'
exec 'xnoremap <silent><buffer> ]" :<C-U>exec "normal! gv"<Bar>call search('."'".b:comment_start."'".', "W" )<CR>'
exec 'xnoremap <silent><buffer> [" :<C-U>exec "normal! gv"<Bar>call search('."'".b:comment_end."'".', "W" )<CR>'

" Comments can be of the form:
"   /*
"    *
"    */
" or
"   --
" or
"   //
setlocal comments=s1:/*,mb:*,ex:*/,:--,://

" Set completion with CTRL-X CTRL-O to autoloaded function.
if exists('&omnifunc')
    " Since the SQL completion plugin can be used in conjunction
    " with other completion filetypes it must record the previous
    " OMNI function prior to setting up the SQL OMNI function
    let b:sql_compl_savefunc = &omnifunc

    " Source it to determine it's version
    runtime autoload/sqlcomplete.vim
    " This is used by the sqlcomplete.vim plugin
    " Source it for it's global functions
    runtime autoload/syntaxcomplete.vim

    setlocal omnifunc=sqlcomplete#Complete
    " Prevent the intellisense plugin from loading
    let b:sql_vis = 1
    if !exists('g:omni_sql_no_default_maps')
        let regex_extra = ''
        if exists('g:loaded_syntax_completion') && exists('g:loaded_sql_completion')
            if g:loaded_syntax_completion > 120 && g:loaded_sql_completion > 140
                let regex_extra = '\\w*'
            endif
        endif
        " Static maps which use populate the completion list
        " using Vim's syntax highlighting rules
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'a <C-\><C-O>:call sqlcomplete#Map("syntax")<CR><C-X><C-O>'
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'k <C-\><C-O>:call sqlcomplete#Map("sqlKeyword'.regex_extra.'")<CR><C-X><C-O>'
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'f <C-\><C-O>:call sqlcomplete#Map("sqlFunction'.regex_extra.'")<CR><C-X><C-O>'
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'o <C-\><C-O>:call sqlcomplete#Map("sqlOption'.regex_extra.'")<CR><C-X><C-O>'
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'T <C-\><C-O>:call sqlcomplete#Map("sqlType'.regex_extra.'")<CR><C-X><C-O>'
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'s <C-\><C-O>:call sqlcomplete#Map("sqlStatement'.regex_extra.'")<CR><C-X><C-O>'
        " Dynamic maps which use populate the completion list
        " using the dbext.vim plugin
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'t <C-\><C-O>:call sqlcomplete#Map("table")<CR><C-X><C-O>'
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'p <C-\><C-O>:call sqlcomplete#Map("procedure")<CR><C-X><C-O>'
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'v <C-\><C-O>:call sqlcomplete#Map("view")<CR><C-X><C-O>'
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'c <C-\><C-O>:call sqlcomplete#Map("column")<CR><C-X><C-O>'
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'l <C-\><C-O>:call sqlcomplete#Map("column_csv")<CR><C-X><C-O>'
        " The next 3 maps are only to be used while the completion window is
        " active due to the <CR> at the beginning of the map
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'L <C-Y><C-\><C-O>:call sqlcomplete#Map("column_csv")<CR><C-X><C-O>'
        " <C-Right> is not recognized on most Unix systems, so only create
        " these additional maps on the Windows platform.
        " If you would like to use these maps, choose a different key and make
        " the same map in your vimrc.
        " if has('win32')
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key_right.' <C-R>=sqlcomplete#DrillIntoTable()<CR>'
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key_left.'  <C-R>=sqlcomplete#DrillOutOfColumns()<CR>'
        " endif
        " Remove any cached items useful for schema changes
        exec 'inoremap <buffer> '.g:ftplugin_sql_omni_key.'R <C-\><C-O>:call sqlcomplete#Map("resetCache")<CR><C-X><C-O>'
    endif

    if b:sql_compl_savefunc != ""
        " We are changing the filetype to SQL from some other filetype
        " which had OMNI completion defined.  We need to activate the
        " SQL completion plugin in order to cache some of the syntax items
        " while the syntax rules for SQL are active.
        call sqlcomplete#ResetCacheSyntax()
        call sqlcomplete#PreCacheSyntax()
    endif
endif

let &cpo = s:save_cpo
unlet s:save_cpo

" vim:sw=4:
                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/share/vim/vim74/ftplugin/sshconfig.vim                                                          0100644 0000000 0000000 00000000655 13050207306 017253  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         OpenSSH client configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                   usr/share/vim/vim74/ftplugin/sudoers.vim                                                            0100644 0000000 0000000 00000000652 13050207306 016751  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         sudoers(5) configuration files
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                      usr/share/vim/vim74/ftplugin/svg.vim                                                                0100644 0000000 0000000 00000002260 13050207306 016061  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	svg
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "XML Files (*.xml)\t*.xml\n" .
	    \	     "All Files (*.*)\t*.*\n"

runtime! ftplugin/xml.vim ftplugin/xml_*.vim ftplugin/xml/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif

" Change the :browse e filter to primarily show xml-related files.
if has("gui_win32")
    let  b:browsefilter="SVG Files (*.svg)\t*.svg\n" . s:browsefilter
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:browsefilter | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                usr/share/vim/vim74/ftplugin/sysctl.vim                                                             0100644 0000000 0000000 00000000671 13050207306 016607  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         sysctl.conf(5) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:;,:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                       usr/share/vim/vim74/ftplugin/systemverilog.vim                                                      0100644 0000000 0000000 00000000357 13050207306 020203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:    SystemVerilog
" Maintainer:  kocha <kocha.lsifrontend@gmail.com>
" Last Change: 12-Aug-2013. 

if exists("b:did_ftplugin")
  finish
endif

" Behaves just like Verilog
runtime! ftplugin/verilog.vim
                                                                                                                                                                                                                                                                                 usr/share/vim/vim74/ftplugin/tcl.vim                                                                0100644 0000000 0000000 00000001752 13050207306 016051  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Tcl
" Maintainer:       Robert L Hicks <sigzero@gmail.com>
" Latest Revision:  2009-05-01

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:cpo_save = &cpo
set cpo-=C

setlocal comments=:#
setlocal commentstring=#%s
setlocal formatoptions+=croql

" Change the browse dialog on Windows to show mainly Tcl-related files
if has("gui_win32")
    let b:browsefilter = "Tcl Source Files (.tcl)\t*.tcl\n" .
                \ "Tcl Test Files (.test)\t*.test\n" .
                \ "All Files (*.*)\t*.*\n"
endif

"-----------------------------------------------------------------------------

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal fo< com< cms< inc< inex< def< isf< kp<" .
	    \	      " | unlet! b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:cpo_save
unlet s:cpo_save

" vim: set et ts=4 sw=4 tw=78:
                      usr/share/vim/vim74/ftplugin/tcsh.vim                                                               0100644 0000000 0000000 00000002267 13050207306 016232  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	tcsh
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "csh Files (*.csh)\t*.csh\n" .
	    \	     "All Files (*.*)\t*.*\n"

runtime! ftplugin/csh.vim ftplugin/csh_*.vim ftplugin/csh/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif

" Change the :browse e filter to primarily show tcsh-related files.
if has("gui_win32")
    let  b:browsefilter="tcsh Scripts (*.tcsh)\t*.tcsh\n" . s:browsefilter
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:browsefilter | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                         usr/share/vim/vim74/ftplugin/terminfo.vim                                                           0100644 0000000 0000000 00000000642 13050207306 017107  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         terminfo(5) definition
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                              usr/share/vim/vim74/ftplugin/tex.vim                                                                0100644 0000000 0000000 00000003151 13050207306 016062  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " LaTeX filetype plugin
" Language:     LaTeX (ft=tex)
" Maintainer:   Benji Fisher, Ph.D. <benji@member.AMS.org>
" Version:	1.4
" Last Change:	Wed 19 Apr 2006
"  URL:		http://www.vim.org/script.php?script_id=411

" Only do this when not done yet for this buffer.
if exists("b:did_ftplugin")
  finish
endif

" Start with plain TeX.  This will also define b:did_ftplugin .
source $VIMRUNTIME/ftplugin/plaintex.vim

" Avoid problems if running in 'compatible' mode.
let s:save_cpo = &cpo
set cpo&vim

let b:undo_ftplugin .= "| setl inex<"

" Allow "[d" to be used to find a macro definition:
" Recognize plain TeX \def as well as LaTeX \newcommand and \renewcommand .
" I may as well add the AMS-LaTeX DeclareMathOperator as well.
let &l:define .= '\|\\\(re\)\=new\(boolean\|command\|counter\|environment\|font'
	\ . '\|if\|length\|savebox\|theorem\(style\)\=\)\s*\*\=\s*{\='
	\ . '\|DeclareMathOperator\s*{\=\s*'

" Tell Vim how to recognize LaTeX \include{foo} and plain \input bar :
let &l:include .= '\|\\include{'
" On some file systems, "{" and "}" are inluded in 'isfname'.  In case the
" TeX file has \include{fname} (LaTeX only), strip everything except "fname".
let &l:includeexpr = "substitute(v:fname, '^.\\{-}{\\|}.*', '', 'g')"

" The following lines enable the macros/matchit.vim plugin for
" extended matching with the % key.
" ftplugin/plaintex.vim already defines b:match_skip and b:match_ignorecase
" and matches \(, \), \[, \], \{, and \} .
if exists("loaded_matchit")
  let b:match_words .= ',\\begin\s*\({\a\+\*\=}\):\\end\s*\1'
endif " exists("loaded_matchit")

let &cpo = s:save_cpo
unlet s:save_cpo

" vim:sts=2:sw=2:
                                                                                                                                                                                                                                                                                                                                                                                                                       usr/share/vim/vim74/ftplugin/text.vim                                                               0100644 0000000 0000000 00000000661 13050207306 016251  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:		Text
" Maintainer:		David Barnett <daviebdawg+vim@gmail.com>
" Last Change:		2014 Jul 09

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = 'setlocal comments< commentstring<'

" We intentionally don't set formatoptions-=t since text should wrap as text.

" Pseudo comment leaders to indent bulleted lists.
setlocal comments=fb:-,fb:*
setlocal commentstring=
                                                                               usr/share/vim/vim74/ftplugin/treetop.vim                                                            0100644 0000000 0000000 00000000624 13050207306 016746  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Treetop
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2011-03-14

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=b:# commentstring=#\ %s formatoptions-=tcroq formatoptions+=l

let b:undo_ftplugin = "setl com< cms< fo<"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                            usr/share/vim/vim74/ftplugin/tt2html.vim                                                            0100644 0000000 0000000 00000000662 13050207306 016664  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Language:      TT2 embedded with HTML
" Maintainer:    vim-perl <vim-perl@googlegroups.com>
" Homepage:      http://github.com/vim-perl/vim-perl
" Bugs/requests: http://github.com/vim-perl/vim-perl/issues
" Last Change:   2013-07-21

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
    finish
endif

" Just use the HTML plugin for now.
runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
                                                                              usr/share/vim/vim74/ftplugin/udevconf.vim                                                           0100644 0000000 0000000 00000000646 13050207306 017101  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         udev(8) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                          usr/share/vim/vim74/ftplugin/udevperm.vim                                                           0100644 0000000 0000000 00000000644 13050207306 017115  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         udev(8) permissions file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                            usr/share/vim/vim74/ftplugin/udevrules.vim                                                          0100644 0000000 0000000 00000000636 13050207306 017305  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         udev(8) rules file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                  usr/share/vim/vim74/ftplugin/updatedb.vim                                                           0100644 0000000 0000000 00000000657 13050207306 017062  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         updatedb.conf(5) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                 usr/share/vim/vim74/ftplugin/vb.vim                                                                 0100644 0000000 0000000 00000003563 13050207306 015700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	VisualBasic (ft=vb)
" Maintainer:	Johannes Zellner <johannes@zellner.org>
" Last Change:	Thu, 22 Nov 2001 12:56:14 W. Europe Standard Time

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

setlocal com=sr:'\ -,mb:'\ \ ,el:'\ \ ,:'

" we need this wrapper, as call doesn't allow a count
fun! <SID>VbSearch(pattern, flags)
    let cnt = v:count1
    while cnt > 0
	call search(a:pattern, a:flags)
	let cnt = cnt - 1
    endwhile
endfun

let s:cpo_save = &cpo
set cpo&vim

" NOTE the double escaping \\|
nnoremap <buffer> <silent> [[ :call <SID>VbSearch('^\s*\(\(private\|public\)\s\+\)\=\(function\\|sub\)', 'bW')<cr>
nnoremap <buffer> <silent> ]] :call <SID>VbSearch('^\s*\(\(private\|public\)\s\+\)\=\(function\\|sub\)', 'W')<cr>
nnoremap <buffer> <silent> [] :call <SID>VbSearch('^\s*\<end\>\s\+\(function\\|sub\)', 'bW')<cr>
nnoremap <buffer> <silent> ][ :call <SID>VbSearch('^\s*\<end\>\s\+\(function\\|sub\)', 'W')<cr>

" matchit support
if exists("loaded_matchit")
    let b:match_ignorecase=1
    let b:match_words=
    \ '\%(^\s*\)\@<=\<if\>.*\<then\>\s*$:\%(^\s*\)\@<=\<else\>:\%(^\s*\)\@<=\<elseif\>:\%(^\s*\)\@<=\<end\>\s\+\<if\>,' .
    \ '\%(^\s*\)\@<=\<for\>:\%(^\s*\)\@<=\<next\>,' .
    \ '\%(^\s*\)\@<=\<while\>:\%(^\s*\)\@<=\<wend\>,' .
    \ '\%(^\s*\)\@<=\<do\>:\%(^\s*\)\@<=\<loop\>\s\+\<while\>,' .
    \ '\%(^\s*\)\@<=\<select\>\s\+\<case\>:\%(^\s*\)\@<=\<case\>:\%(^\s*\)\@<=\<end\>\s\+\<select\>,' .
    \ '\%(^\s*\)\@<=\<enum\>:\%(^\s*\)\@<=\<end\>\s\<enum\>,' .
    \ '\%(^\s*\)\@<=\<with\>:\%(^\s*\)\@<=\<end\>\s\<with\>,' .
    \ '\%(^\s*\)\@<=\%(\<\%(private\|public\)\>\s\+\)\=\<function\>\s\+\([^ \t(]\+\):\%(^\s*\)\@<=\<\1\>\s*=:\%(^\s*\)\@<=\<end\>\s\+\<function\>,' .
    \ '\%(^\s*\)\@<=\%(\<\%(private\|public\)\>\s\+\)\=\<sub\>\s\+:\%(^\s*\)\@<=\<end\>\s\+\<sub\>'
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                             usr/share/vim/vim74/ftplugin/verilog.vim                                                            0100644 0000000 0000000 00000003221 13050207306 016727  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Verilog HDL
" Maintainer:	Chih-Tsun Huang <cthuang@larc.ee.nthu.edu.tw>
" Last Change:	Wed Sep  3 15:24:49 CST 2008
" URL:		http://larc.ee.nthu.edu.tw/~cthuang/vim/ftplugin/verilog.vim

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Set 'cpoptions' to allow line continuations
let s:cpo_save = &cpo
set cpo&vim

" Undo the plugin effect
let b:undo_ftplugin = "setlocal fo< com< tw<"
    \ . "| unlet! b:browsefilter b:match_ignorecase b:match_words"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croqlm1

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

" Format comments to be up to 78 characters long
if &textwidth == 0 
  setlocal tw=78
endif

" Win32 can filter files in the browse dialog
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "Verilog Source Files (*.v)\t*.v\n" .
	\ "All Files (*.*)\t*.*\n"
endif

" Let the matchit plugin know what items can be matched.
if exists("loaded_matchit")
  let b:match_ignorecase=0
  let b:match_words=
    \ '\<begin\>:\<end\>,' .
    \ '\<case\>\|\<casex\>\|\<casez\>:\<endcase\>,' .
    \ '\<module\>:\<endmodule\>,' .
    \ '\<if\>:\<else\>,' .
    \ '\<function\>:\<endfunction\>,' .
    \ '`ifdef\>:`else\>:`endif\>,' .
    \ '\<task\>:\<endtask\>,' .
    \ '\<specify\>:\<endspecify\>'
endif

" Reset 'cpoptions' back to the user's setting
let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                               usr/share/vim/vim74/ftplugin/vhdl.vim                                                               0100644 0000000 0000000 00000006651 13050207306 016227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " VHDL filetype plugin
" Language:    VHDL
" Maintainer:  R.Shankar <shankar.pec?gmail.com>
" Modified By: Gerald Lai <laigera+vim?gmail.com>
" Last Change: 2011 Dec 11

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
"setlocal fo-=t fo+=croqlm1

" Set 'comments' to format dashed lists in comments.
"setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

" Format comments to be up to 78 characters long
"setlocal tw=75

" Win32 can filter files in the browse dialog
"if has("gui_win32") && !exists("b:browsefilter")
"  let b:browsefilter = "Verilog Source Files (*.v)\t*.v\n" .
"   \ "All Files (*.*)\t*.*\n"
"endif

" Let the matchit plugin know what items can be matched.
if ! exists("b:match_words")  &&  exists("loaded_matchit")
  let b:match_ignorecase=1
  let s:notend = '\%(\<end\s\+\)\@<!'
  let b:match_words =
    \ s:notend.'\<if\>:\<elsif\>:\<else\>:\<end\s\+if\>,'.
    \ s:notend.'\<case\>:\<when\>:\<end\s\+case\>,'.
    \ s:notend.'\<loop\>:\<end\s\+loop\>,'.
    \ s:notend.'\<for\>:\<end\s\+for\>,'.
    \ s:notend.'\<generate\>:\<end\s\+generate\>,'.
    \ s:notend.'\<record\>:\<end\s\+record\>,'.
    \ s:notend.'\<units\>:\<end\s\+units\>,'.
    \ s:notend.'\<process\>:\<end\s\+process\>,'.
    \ s:notend.'\<block\>:\<end\s\+block\>,'.
    \ s:notend.'\<function\>:\<end\s\+function\>,'.
    \ s:notend.'\<entity\>:\<end\s\+entity\>,'.
    \ s:notend.'\<component\>:\<end\s\+component\>,'.
    \ s:notend.'\<architecture\>:\<end\s\+architecture\>,'.
    \ s:notend.'\<package\>:\<end\s\+package\>,'.
    \ s:notend.'\<procedure\>:\<end\s\+procedure\>,'.
    \ s:notend.'\<configuration\>:\<end\s\+configuration\>'
endif

" count repeat
function! <SID>CountWrapper(cmd)
  let i = v:count1
  if a:cmd[0] == ":"
    while i > 0
      execute a:cmd
      let i = i - 1
    endwhile
  else
    execute "normal! gv\<Esc>"
    execute "normal ".i.a:cmd
    let curcol = col(".")
    let curline = line(".")
    normal! gv
    call cursor(curline, curcol)
  endif
endfunction

" explore motion
" keywords: "architecture", "block", "configuration", "component", "entity", "function", "package", "procedure", "process", "record", "units"
let b:vhdl_explore = '\%(architecture\|block\|configuration\|component\|entity\|function\|package\|procedure\|process\|record\|units\)'
noremap  <buffer><silent>[[ :<C-u>cal <SID>CountWrapper(':cal search("\\%(--.*\\)\\@<!\\%(\\<end\\s\\+\\)\\@<!\\<".b:vhdl_explore."\\>\\c\\<Bar>\\%^","bW")')<CR>
noremap  <buffer><silent>]] :<C-u>cal <SID>CountWrapper(':cal search("\\%(--.*\\)\\@<!\\%(\\<end\\s\\+\\)\\@<!\\<".b:vhdl_explore."\\>\\c\\<Bar>\\%$","W")')<CR>
noremap  <buffer><silent>[] :<C-u>cal <SID>CountWrapper(':cal search("\\%(--.*\\)\\@<!\\<end\\s\\+".b:vhdl_explore."\\>\\c\\<Bar>\\%^","bW")')<CR>
noremap  <buffer><silent>][ :<C-u>cal <SID>CountWrapper(':cal search("\\%(--.*\\)\\@<!\\<end\\s\\+".b:vhdl_explore."\\>\\c\\<Bar>\\%$","W")')<CR>
vnoremap <buffer><silent>[[ :<C-u>cal <SID>CountWrapper('[[')<CR>
vnoremap <buffer><silent>]] :<C-u>cal <SID>CountWrapper(']]')<CR>
vnoremap <buffer><silent>[] :<C-u>cal <SID>CountWrapper('[]')<CR>
vnoremap <buffer><silent>][ :<C-u>cal <SID>CountWrapper('][')<CR>

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                       usr/share/vim/vim74/ftplugin/vim.vim                                                                0100644 0000000 0000000 00000005735 13050207306 016067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin
" Language:	Vim
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2014 Sep 07

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = "setl fo< isk< com< tw< commentstring<"
	\ . "| unlet! b:match_ignorecase b:match_words b:match_skip"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" To allow tag lookup via CTRL-] for autoload functions, '#' must be a
" keyword character.  E.g., for netrw#Nread().
setlocal isk+=#

" Set 'comments' to format dashed lists in comments
setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"

" Format comments to be up to 78 characters long
if &tw == 0
  setlocal tw=78
endif

" Comments start with a double quote
setlocal commentstring=\"%s

" Move around functions.
nnoremap <silent><buffer> [[ m':call search('^\s*fu\%[nction]\>', "bW")<CR>
vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "bW")<CR>
nnoremap <silent><buffer> ]] m':call search('^\s*fu\%[nction]\>', "W")<CR>
vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "W")<CR>
nnoremap <silent><buffer> [] m':call search('^\s*endf*\%[unction]\>', "bW")<CR>
vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "bW")<CR>
nnoremap <silent><buffer> ][ m':call search('^\s*endf*\%[unction]\>', "W")<CR>
vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "W")<CR>

" Move around comments
nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>

" Let the matchit plugin know what items can be matched.
if exists("loaded_matchit")
  let b:match_ignorecase = 0
  let b:match_words =
	\ '\<fu\%[nction]\>:\<retu\%[rn]\>:\<endf\%[unction]\>,' .
 	\ '\<\(wh\%[ile]\|for\)\>:\<brea\%[k]\>:\<con\%[tinue]\>:\<end\(w\%[hile]\|fo\%[r]\)\>,' .
	\ '\<if\>:\<el\%[seif]\>:\<en\%[dif]\>,' .
	\ '\<try\>:\<cat\%[ch]\>:\<fina\%[lly]\>:\<endt\%[ry]\>,' .
	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' .
	\ '(:)'
  " Ignore syntax region commands and settings, any 'en*' would clobber
  " if-endif.
  " - set spl=de,en
  " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ …
  let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
        \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
endif

let &cpo = s:cpo_save
unlet s:cpo_save

" removed this, because 'cpoptions' is a global option.
" setlocal cpo+=M		" makes \%( match \)
                                   usr/share/vim/vim74/ftplugin/vroom.vim                                                              0100644 0000000 0000000 00000001634 13050207306 016430  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Vroom (vim testing and executable documentation)
" Maintainer:	David Barnett (https://github.com/google/vim-ft-vroom)
" Last Change:	2014 Jul 23

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo-=C


let b:undo_ftplugin = 'setlocal formatoptions< shiftwidth< softtabstop<' .
    \ ' expandtab< iskeyword< comments< commentstring<'

setlocal formatoptions-=t

" The vroom interpreter doesn't accept anything but 2-space indent.
setlocal shiftwidth=2
setlocal softtabstop=2
setlocal expandtab

" To allow tag lookup and autocomplete for whole autoload functions, '#' must be
" a keyword character. This also conforms to the behavior of ftplugin/vim.vim.
setlocal iskeyword+=#

" Vroom files have no comments (text is inert documentation unless indented).
setlocal comments=
setlocal commentstring=


let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                    usr/share/vim/vim74/ftplugin/xdefaults.vim                                                          0100644 0000000 0000000 00000000725 13050207306 017265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         X resources files like ~/.Xdefaults (xrdb)
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=s1:/*,mb:*,ex:*/,:! commentstring& inc&
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                           usr/share/vim/vim74/ftplugin/xf86conf.vim                                                           0100644 0000000 0000000 00000000646 13050207306 016731  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         XFree86 Configuration File
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                          usr/share/vim/vim74/ftplugin/xhtml.vim                                                              0100644 0000000 0000000 00000003764 13050207306 016430  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	xhtml
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "HTML Files (*.html, *.htm)\t*.html;*.htm\n" .
	    \	     "XML Files (*.xml)\t*.xml\n" .
	    \	     "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/xml.vim ftplugin/xml_*.vim ftplugin/xml/*.vim
unlet b:did_ftplugin

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
    unlet b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
    unlet b:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words
    unlet b:match_words
endif

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
let b:did_ftplugin = 1

" Combine the new set of values with those previously included.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter . s:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words . "," . s:match_words
endif

" Load the combined list of match_words for matchit.vim
if exists("loaded_matchit")
    let b:match_words = s:match_words
endif

" Change the :browse e filter to primarily show tcsh-related files.
if has("gui_win32")
    let  b:browsefilter="XHTML files (*.xhtml, *.xhtm)\t*.xhtml;*.xhtm\n" . s:browsefilter
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:browsefilter b:match_words | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
            usr/share/vim/vim74/ftplugin/xinetd.vim                                                             0100644 0000000 0000000 00000000720 13050207306 016554  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         xinetd.conf(5) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s include=^\\s*include
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                usr/share/vim/vim74/ftplugin/xml.vim                                                                0100644 0000000 0000000 00000003567 13050207306 016075  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	xml
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal commentstring=<!--%s-->
setlocal comments=s:<!--,m:\ \ \ \ \ ,e:-->

setlocal formatoptions-=t
if !exists("g:ft_xml_autocomment") || (g:ft_xml_autocomment == 1)
    setlocal formatoptions+=croql
endif


" XML:  thanks to Johannes Zellner and Akbar Ibrahim
" - case sensitive
" - don't match empty tags <fred/>
" - match <!--, --> style comments (but not --, --)
" - match <!, > inlined dtd's. This is not perfect, as it
"   gets confused for example by
"       <!ENTITY gt ">">
if exists("loaded_matchit")
    let b:match_ignorecase=0
    let b:match_words =
     \  '<:>,' .
     \  '<\@<=!\[CDATA\[:]]>,'.
     \  '<\@<=!--:-->,'.
     \  '<\@<=?\k\+:?>,'.
     \  '<\@<=\([^ \t>/]\+\)\%(\s\+[^>]*\%([^/]>\|$\)\|>\|$\):<\@<=/\1>,'.
     \  '<\@<=\%([^ \t>/]\+\)\%(\s\+[^/>]*\|$\):/>'
endif

"
" For Omni completion, by Mikolaj Machowski.
if exists('&ofu')
  setlocal ofu=xmlcomplete#CompleteTags
endif
command! -nargs=+ XMLns call xmlcomplete#CreateConnection(<f-args>)
command! -nargs=? XMLent call xmlcomplete#CreateEntConnection(<f-args>)


" Change the :browse e filter to primarily show xml-related files.
if has("gui_win32")
    let  b:browsefilter="XML Files (*.xml)\t*.xml\n" .
		\	"DTD Files (*.dtd)\t*.dtd\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal commentstring< comments< formatoptions<" .
		\     " | unlet! b:match_ignorecase b:match_words b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                         usr/share/vim/vim74/ftplugin/xmodmap.vim                                                            0100644 0000000 0000000 00000000646 13050207306 016735  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         xmodmap(1) definition file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:! commentstring=!\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                          usr/share/vim/vim74/ftplugin/xs.vim                                                                 0100644 0000000 0000000 00000000721 13050207306 015714  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:      XS (Perl extension interface language)
" Maintainer:    vim-perl <vim-perl@googlegroups.com>
" Homepage:      http://github.com/vim-perl/vim-perl
" Bugs/requests: http://github.com/vim-perl/vim-perl/issues
" Last Change:   2013-07-21

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
    finish
endif

" Just use the C plugin for now.
runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim
                                               usr/share/vim/vim74/ftplugin/xsd.vim                                                                0100644 0000000 0000000 00000002223 13050207306 016057  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	xsd
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "XML Files (*.xml)\t*.xml\n" .
	    \	     "All Files (*.*)\t*.*\n"

runtime! ftplugin/xml.vim ftplugin/xml_*.vim ftplugin/xml/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif

" Change the :browse e filter to primarily show xsd-related files.
if has("gui_win32")
    let  b:browsefilter="XSD Files (*.xsd)\t*.xsd\n" . s:browsefilter
endif

let b:undo_ftplugin = "unlet! b:browsefilter | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                             usr/share/vim/vim74/ftplugin/xslt.vim                                                               0100644 0000000 0000000 00000001033 13050207306 016251  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	xslt
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

runtime! ftplugin/xml.vim ftplugin/xml_*.vim ftplugin/xml/*.vim

let b:did_ftplugin = 1

" Change the :browse e filter to primarily show xsd-related files.
if has("gui_win32") && exists("b:browsefilter")
    let  b:browsefilter="XSLT Files (*.xsl,*.xslt)\t*.xsl;*.xslt\n" . b:browsefilter
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/share/vim/vim74/ftplugin/yaml.vim                                                               0100644 0000000 0000000 00000000704 13050207306 016225  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         YAML (YAML Ain't Markup Language)
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< et< fo<"

setlocal comments=:# commentstring=#\ %s expandtab
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                            usr/share/vim/vim74/ftplugin/zimbu.vim                                                              0100644 0000000 0000000 00000012312 13050207306 016407  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:	Zimbu
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2012 Sep 08

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Using line continuation here.
let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = "setl fo< com< ofu< efm< tw< et< sts< sw< | if has('vms') | setl isk< | endif"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set completion with CTRL-X CTRL-O to autoloaded function.
if exists('&ofu')
  setlocal ofu=ccomplete#Complete
endif

" Set 'comments' to format dashed lists in comments.
" And to keep Zudocu comment characters.
setlocal comments=sO:#\ -,mO:#\ \ ,:#=,:#-,:#%,:#

setlocal errorformat^=%f\ line\ %l\ col\ %c:\ %m,ERROR:\ %m

" When the matchit plugin is loaded, this makes the % command skip parens and
" braces in comments.
let b:match_words = '\(^\s*\)\@<=\(MODULE\|CLASS\|INTERFACE\|BITS\|ENUM\|SHARED\|FUNC\|REPLACE\|DEFINE\|PROC\|EQUAL\|MAIN\|IF\|GENERATE_IF\|WHILE\|REPEAT\|WITH\|DO\|FOR\|SWITCH\|TRY\)\>\|{\s*$:\(^\s*\)\@<=\(ELSE\|ELSEIF\|GENERATE_ELSE\|GENERATE_ELSEIF\|CATCH\|FINALLY\)\>:\(^\s*\)\@<=\(}\|\<UNTIL\>\)'

let b:match_skip = 's:comment\|string\|zimbuchar'

setlocal tw=78
setlocal et sts=2 sw=2

" Does replace when a dot, space or closing brace is typed.
func! GCUpperDot(what)
  if v:char != ' ' && v:char != "\r" && v:char != "\x1b" && v:char != '.' && v:char != ')' && v:char != '}' && v:char != ','
    " no space or dot after the typed text
    let g:got_char = v:char
    return a:what
  endif
  return GCUpperCommon(a:what)
endfunc

" Does not replace when a dot is typed.
func! GCUpper(what)
  if v:char != ' ' && v:char != "\r" && v:char != "\x1b" && v:char != ')' && v:char != ','
    " no space or other "terminating" character after the typed text
    let g:got_char = v:char
    return a:what
  endif
  return GCUpperCommon(a:what)
endfunc

" Only replaces when a space is typed.
func! GCUpperSpace(what)
  if v:char != ' '
    " no space after the typed text
    let g:got_char = v:char
    return a:what
  endif
  return GCUpperCommon(a:what)
endfunc

func! GCUpperCommon(what)
  let col = col(".") - strlen(a:what)
  if col > 1 && getline('.')[col - 2] != ' '
    " no space before the typed text
    let g:got_char = 999
    return a:what
  endif
  let synName = synIDattr(synID(line("."), col(".") - 2, 1), "name")
  if synName =~ 'Comment\|String\|zimbuCregion\|\<c'
    " inside a comment or C code
    let g:got_char = 777
    return a:what
  endif
    let g:got_char = 1111
  return toupper(a:what)
endfunc

iabbr <buffer> <expr> alias GCUpperSpace("alias")
iabbr <buffer> <expr> arg GCUpperDot("arg")
iabbr <buffer> <expr> break GCUpper("break")
iabbr <buffer> <expr> case GCUpperSpace("case")
iabbr <buffer> <expr> catch GCUpperSpace("catch")
iabbr <buffer> <expr> check GCUpperDot("check")
iabbr <buffer> <expr> class GCUpperSpace("class")
iabbr <buffer> <expr> interface GCUpperSpace("interface")
iabbr <buffer> <expr> implements GCUpperSpace("implements")
iabbr <buffer> <expr> shared GCUpperSpace("shared")
iabbr <buffer> <expr> continue GCUpper("continue")
iabbr <buffer> <expr> default GCUpper("default")
iabbr <buffer> <expr> extends GCUpper("extends")
iabbr <buffer> <expr> do GCUpper("do")
iabbr <buffer> <expr> else GCUpper("else")
iabbr <buffer> <expr> elseif GCUpperSpace("elseif")
iabbr <buffer> <expr> enum GCUpperSpace("enum")
iabbr <buffer> <expr> exit GCUpper("exit")
iabbr <buffer> <expr> false GCUpper("false")
iabbr <buffer> <expr> fail GCUpper("fail")
iabbr <buffer> <expr> finally GCUpper("finally")
iabbr <buffer> <expr> for GCUpperSpace("for")
iabbr <buffer> <expr> func GCUpperSpace("func")
iabbr <buffer> <expr> if GCUpperSpace("if")
iabbr <buffer> <expr> import GCUpperSpace("import")
iabbr <buffer> <expr> in GCUpperSpace("in")
iabbr <buffer> <expr> io GCUpperDot("io")
iabbr <buffer> <expr> main GCUpper("main")
iabbr <buffer> <expr> module GCUpperSpace("module")
iabbr <buffer> <expr> new GCUpper("new")
iabbr <buffer> <expr> nil GCUpper("nil")
iabbr <buffer> <expr> ok GCUpper("ok")
iabbr <buffer> <expr> proc GCUpperSpace("proc")
iabbr <buffer> <expr> proceed GCUpper("proceed")
iabbr <buffer> <expr> return GCUpper("return")
iabbr <buffer> <expr> step GCUpperSpace("step")
iabbr <buffer> <expr> switch GCUpperSpace("switch")
iabbr <buffer> <expr> sys GCUpperDot("sys")
iabbr <buffer> <expr> this GCUpperDot("this")
iabbr <buffer> <expr> throw GCUpperSpace("throw")
iabbr <buffer> <expr> try GCUpper("try")
iabbr <buffer> <expr> to GCUpperSpace("to")
iabbr <buffer> <expr> true GCUpper("true")
iabbr <buffer> <expr> until GCUpperSpace("until")
iabbr <buffer> <expr> while GCUpperSpace("while")
iabbr <buffer> <expr> repeat GCUpper("repeat")

nnoremap <silent> <buffer> [[ m`:call ZimbuGoStartBlock()<CR>
nnoremap <silent> <buffer> ]] m`:call ZimbuGoEndBlock()<CR>

" Using a function makes sure the search pattern is restored
func! ZimbuGoStartBlock()
  ?^\s*\(FUNC\|PROC\|MAIN\|ENUM\|CLASS\|INTERFACE\)\>
endfunc
func! ZimbuGoEndBlock()
  /^\s*\(FUNC\|PROC\|MAIN\|ENUM\|CLASS\|INTERFACE\)\>
endfunc


let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                      usr/share/vim/vim74/ftplugin/zsh.vim                                                                0100644 0000000 0000000 00000001242 13050207306 016065  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype plugin file
" Language:         Zsh shell script
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2011-01-23

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let b:match_words =
      \   &matchpairs
      \ . ',\<if\>:\<elif\>:\<else\>:\<fi\>'
      \ . ',\<case\>:^\s*([^)]*):\<esac\>'
      \ . ',\<\%(select\|while\|until\|repeat\|for\%(each\)\=\)\>:\<done\>'
let b:match_skip = 's:comment\|string\|heredoc\|subst'

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                              usr/share/vim/vim74/ftplugin.vim                                                                    0100644 0000000 0000000 00000001713 13050207306 015264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim support file to switch on loading plugins for file types
"
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last change:	2006 Apr 30

if exists("did_load_ftplugin")
  finish
endif
let did_load_ftplugin = 1

augroup filetypeplugin
  au FileType * call s:LoadFTPlugin()

  func! s:LoadFTPlugin()
    if exists("b:undo_ftplugin")
      exe b:undo_ftplugin
      unlet! b:undo_ftplugin b:did_ftplugin
    endif

    let s = expand("<amatch>")
    if s != ""
      if &cpo =~# "S" && exists("b:did_ftplugin")
	" In compatible mode options are reset to the global values, need to
	" set the local values also when a plugin was already used.
	unlet b:did_ftplugin
      endif

      " When there is a dot it is used to separate filetype names.  Thus for
      " "aaa.bbb" load "aaa" and then "bbb".
      for name in split(s, '\.')
	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
      endfor
    endif
  endfunc
augroup END
                                                     usr/share/vim/vim74/ftplugof.vim                                                                    0100644 0000000 0000000 00000000521 13050207306 015256  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim support file to switch off loading plugins for file types
"
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2011 Oct 20

if exists("did_load_ftplugin")
  unlet did_load_ftplugin
endif

" Remove all autocommands in the filetypeplugin group, if any exist.
if exists("#filetypeplugin")
  silent! au! filetypeplugin *
endif
                                                                                                                                                                               usr/share/vim/vim74/gvimrc_example.vim                                                              0100644 0000000 0000000 00000003242 13050207306 016435  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " An example for a gvimrc file.
" The commands in this are executed when the GUI is started.
"
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last change:	2001 Sep 02
"
" To use it, copy it to
"     for Unix and OS/2:  ~/.gvimrc
"	      for Amiga:  s:.gvimrc
"  for MS-DOS and Win32:  $VIM\_gvimrc
"	    for OpenVMS:  sys$login:.gvimrc

" Make external commands work through a pipe instead of a pseudo-tty
"set noguipty

" set the X11 font to use
" set guifont=-misc-fixed-medium-r-normal--14-130-75-75-c-70-iso8859-1

set ch=2		" Make command line two lines high

set mousehide		" Hide the mouse when typing text

" Make shift-insert work like in Xterm
map <S-Insert> <MiddleMouse>
map! <S-Insert> <MiddleMouse>

" Only do this for Vim version 5.0 and later.
if version >= 500

  " I like highlighting strings inside C comments
  let c_comment_strings=1

  " Switch on syntax highlighting if it wasn't on yet.
  if !exists("syntax_on")
    syntax on
  endif

  " Switch on search pattern highlighting.
  set hlsearch

  " For Win32 version, have "K" lookup the keyword in a help file
  "if has("win32")
  "  let winhelpfile='windows.hlp'
  "  map K :execute "!start winhlp32 -k <cword> " . winhelpfile <CR>
  "endif

  " Set nice colors
  " background for normal text is light grey
  " Text below the last line is darker grey
  " Cursor is green, Cyan when ":lmap" mappings are active
  " Constants are not underlined but have a slightly lighter background
  highlight Normal guibg=grey90
  highlight Cursor guibg=Green guifg=NONE
  highlight lCursor guibg=Cyan guifg=NONE
  highlight NonText guibg=grey80
  highlight Constant gui=NONE guibg=grey95
  highlight Special gui=NONE guibg=grey95

endif
                                                                                                                                                                                                                                                                                                                                                              usr/share/vim/vim74/indent/                                                                         0040755 0000000 0000000 00000000000 13101201173 014172  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim74/indent/README.txt                                                               0100644 0000000 0000000 00000003147 13050207306 015701  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        This directory contains files to automatically compute the indent for a
type of file.

If you want to add your own indent file for your personal use, read the docs
at ":help indent-expression".  Looking at the existing files should give you
inspiration.

If you make a new indent file which would be useful for others, please send it
to Bram@vim.org.  Include instructions for detecting the file type for this
language, by file name extension or by checking a few lines in the file.
And please stick to the rules below.

If you have remarks about an existing file, send them to the maintainer of
that file.  Only when you get no response send a message to Bram@vim.org.

If you are the maintainer of an indent file and make improvements, e-mail the
new version to Bram@vim.org.


Rules for making an indent file:

You should use this check for "b:did_indent":

	" Only load this indent file when no other was loaded yet.
	if exists("b:did_indent")
	  finish
	endif
	let b:did_indent = 1

Always use ":setlocal" to set 'indentexpr'.  This avoids it being carried over
to other buffers.

To trigger the indenting after typing a word like "endif", add the word to the
'cinkeys' option with "+=".

You normally set 'indentexpr' to evaluate a function and then define that
function.  That function only needs to be defined once for as long as Vim is
running.  Add a test if the function exists and use ":finish", like this:
	if exists("*GetMyIndent")
	  finish
	endif

The user may have several options set unlike you, try to write the file such
that it works with any option settings.  Also be aware of certain features not
being compiled in.
                                                                                                                                                                                                                                                                                                                                                                                                                         usr/share/vim/vim74/indent/aap.vim                                                                  0100644 0000000 0000000 00000000411 13050207306 015450  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Aap recipe
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2005 Jun 24

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif

" Works mostly like Python.
runtime! indent/python.vim
                                                                                                                                                                                                                                                       usr/share/vim/vim74/indent/ada.vim                                                                  0100644 0000000 0000000 00000025611 13050207306 015445  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        "------------------------------------------------------------------------------
"  Description: Vim Ada indent file
"     Language: Ada (2005)
"	   $Id: ada.vim 887 2008-07-08 14:29:01Z krischik $
"    Copyright: Copyright (C) 2006 Martin Krischik
"   Maintainer: Martin Krischik <krischik@users.sourceforge.net>
"		Neil Bird <neil@fnxweb.com>
"		Ned Okie <nokie@radford.edu>
"      $Author: krischik $
"	 $Date: 2008-07-08 16:29:01 +0200 (Di, 08 Jul 2008) $
"      Version: 4.6
"    $Revision: 887 $
"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/indent/ada.vim $
"      History: 24.05.2006 MK Unified Headers
"		16.07.2006 MK Ada-Mode as vim-ball
"		15.10.2006 MK Bram's suggestion for runtime integration
"		05.11.2006 MK Bram suggested to save on spaces
"		19.09.2007 NO g: missing before ada#Comment
"    Help Page: ft-vim-indent
"------------------------------------------------------------------------------
" ToDo:
"  Verify handling of multi-line exprs. and recovery upon the final ';'.
"  Correctly find comments given '"' and "" ==> " syntax.
"  Combine the two large block-indent functions into one?
"------------------------------------------------------------------------------

" Only load this indent file when no other was loaded.
if exists("b:did_indent") || version < 700
   finish
endif

let b:did_indent = 45

setlocal indentexpr=GetAdaIndent()
setlocal indentkeys-=0{,0}
setlocal indentkeys+=0=~then,0=~end,0=~elsif,0=~when,0=~exception,0=~begin,0=~is,0=~record

" Only define the functions once.
if exists("*GetAdaIndent")
   finish
endif
let s:keepcpo= &cpo
set cpo&vim

if exists("g:ada_with_gnat_project_files")
   let s:AdaBlockStart = '^\s*\(if\>\|while\>\|else\>\|elsif\>\|loop\>\|for\>.*\<\(loop\|use\)\>\|declare\>\|begin\>\|type\>.*\<is\>[^;]*$\|\(type\>.*\)\=\<record\>\|procedure\>\|function\>\|accept\>\|do\>\|task\>\|package\>\|project\>\|then\>\|when\>\|is\>\)'
else
   let s:AdaBlockStart = '^\s*\(if\>\|while\>\|else\>\|elsif\>\|loop\>\|for\>.*\<\(loop\|use\)\>\|declare\>\|begin\>\|type\>.*\<is\>[^;]*$\|\(type\>.*\)\=\<record\>\|procedure\>\|function\>\|accept\>\|do\>\|task\>\|package\>\|then\>\|when\>\|is\>\)'
endif

" Section: s:MainBlockIndent {{{1
"
" Try to find indent of the block we're in
" prev_indent = the previous line's indent
" prev_lnum   = previous line (to start looking on)
" blockstart  = expr. that indicates a possible start of this block
" stop_at     = if non-null, if a matching line is found, gives up!
" No recursive previous block analysis: simply look for a valid line
" with a lesser or equal indent than we currently (on prev_lnum) have.
" This shouldn't work as well as it appears to with lines that are currently
" nowhere near the correct indent (e.g., start of line)!
" Seems to work OK as it 'starts' with the indent of the /previous/ line.
function s:MainBlockIndent (prev_indent, prev_lnum, blockstart, stop_at)
   let lnum = a:prev_lnum
   let line = substitute( getline(lnum), g:ada#Comment, '', '' )
   while lnum > 1
      if a:stop_at != ''  &&  line =~ '^\s*' . a:stop_at  &&  indent(lnum) < a:prev_indent
	 return a:prev_indent
      elseif line =~ '^\s*' . a:blockstart
	 let ind = indent(lnum)
	 if ind < a:prev_indent
	    return ind
	 endif
      endif

      let lnum = prevnonblank(lnum - 1)
      " Get previous non-blank/non-comment-only line
      while 1
	 let line = substitute( getline(lnum), g:ada#Comment, '', '' )
	 if line !~ '^\s*$' && line !~ '^\s*#'
	    break
	 endif
	 let lnum = prevnonblank(lnum - 1)
	 if lnum <= 0
	    return a:prev_indent
	 endif
      endwhile
   endwhile
   " Fallback - just move back one
   return a:prev_indent - &sw
endfunction MainBlockIndent

" Section: s:EndBlockIndent {{{1
"
" Try to find indent of the block we're in (and about to complete),
" including handling of nested blocks. Works on the 'end' of a block.
" prev_indent = the previous line's indent
" prev_lnum   = previous line (to start looking on)
" blockstart  = expr. that indicates a possible start of this block
" blockend    = expr. that indicates a possible end of this block
function s:EndBlockIndent( prev_indent, prev_lnum, blockstart, blockend )
   let lnum = a:prev_lnum
   let line = getline(lnum)
   let ends = 0
   while lnum > 1
      if getline(lnum) =~ '^\s*' . a:blockstart
	 let ind = indent(lnum)
	 if ends <= 0
	    if ind < a:prev_indent
	       return ind
	    endif
	 else
	    let ends = ends - 1
	 endif
      elseif getline(lnum) =~ '^\s*' . a:blockend
	 let ends = ends + 1
      endif

      let lnum = prevnonblank(lnum - 1)
      " Get previous non-blank/non-comment-only line
      while 1
	 let line = getline(lnum)
	 let line = substitute( line, g:ada#Comment, '', '' )
	 if line !~ '^\s*$'
	    break
	 endif
	 let lnum = prevnonblank(lnum - 1)
	 if lnum <= 0
	    return a:prev_indent
	 endif
      endwhile
   endwhile
   " Fallback - just move back one
   return a:prev_indent - &sw
endfunction EndBlockIndent

" Section: s:StatementIndent {{{1
"
" Return indent of previous statement-start
" (after we've indented due to multi-line statements).
" This time, we start searching on the line *before* the one given (which is
" the end of a statement - we want the previous beginning).
function s:StatementIndent( current_indent, prev_lnum )
   let lnum  = a:prev_lnum
   while lnum > 0
      let prev_lnum = lnum
      let lnum = prevnonblank(lnum - 1)
      " Get previous non-blank/non-comment-only line
      while 1
	 let line = substitute( getline(lnum), g:ada#Comment, '', '' )

	 if line !~ '^\s*$' && line !~ '^\s*#'
	    break
	 endif
	 let lnum = prevnonblank(lnum - 1)
	 if lnum <= 0
	    return a:current_indent
	 endif
      endwhile
      " Leave indent alone if our ';' line is part of a ';'-delineated
      " aggregate (e.g., procedure args.) or first line after a block start.
      if line =~ s:AdaBlockStart || line =~ '(\s*$'
	 return a:current_indent
      endif
      if line !~ '[.=(]\s*$'
	 let ind = indent(prev_lnum)
	 if ind < a:current_indent
	    return ind
	 endif
      endif
   endwhile
   " Fallback - just use current one
   return a:current_indent
endfunction StatementIndent


" Section: GetAdaIndent {{{1
"
" Find correct indent of a new line based upon what went before
"
function GetAdaIndent()
   " Find a non-blank line above the current line.
   let lnum = prevnonblank(v:lnum - 1)
   let ind = indent(lnum)
   let package_line = 0

   " Get previous non-blank/non-comment-only/non-cpp line
   while 1
      let line = substitute( getline(lnum), g:ada#Comment, '', '' )
      if line !~ '^\s*$' && line !~ '^\s*#'
	 break
      endif
      let lnum = prevnonblank(lnum - 1)
      if lnum <= 0
	 return ind
      endif
   endwhile

   " Get default indent (from prev. line)
   let ind = indent(lnum)
   let initind = ind

   " Now check what's on the previous line
   if line =~ s:AdaBlockStart  ||  line =~ '(\s*$'
      " Check for false matches to AdaBlockStart
      let false_match = 0
      if line =~ '^\s*\(procedure\|function\|package\)\>.*\<is\s*new\>'
	 " Generic instantiation
	 let false_match = 1
      elseif line =~ ')\s*;\s*$'  ||  line =~ '^\([^(]*([^)]*)\)*[^(]*;\s*$'
	 " forward declaration
	 let false_match = 1
      endif
      " Move indent in
      if ! false_match
	 let ind = ind + &sw
      endif
   elseif line =~ '^\s*\(case\|exception\)\>'
      " Move indent in twice (next 'when' will move back)
      let ind = ind + 2 * &sw
   elseif line =~ '^\s*end\s*record\>'
      " Move indent back to tallying 'type' preceeding the 'record'.
      " Allow indent to be equal to 'end record's.
      let ind = s:MainBlockIndent( ind+&sw, lnum, 'type\>', '' )
   elseif line =~ '\(^\s*new\>.*\)\@<!)\s*[;,]\s*$'
      " Revert to indent of line that started this parenthesis pair
      exe lnum
      exe 'normal! $F)%'
      if getline('.') =~ '^\s*('
	 " Dire layout - use previous indent (could check for g:ada#Comment here)
	 let ind = indent( prevnonblank( line('.')-1 ) )
      else
	 let ind = indent('.')
      endif
      exe v:lnum
   elseif line =~ '[.=(]\s*$'
      " A statement continuation - move in one
      let ind = ind + &sw
   elseif line =~ '^\s*new\>'
      " Multiple line generic instantiation ('package blah is\nnew thingy')
      let ind = s:StatementIndent( ind - &sw, lnum )
   elseif line =~ ';\s*$'
      " Statement end (but not 'end' ) - try to find current statement-start indent
      let ind = s:StatementIndent( ind, lnum )
   endif

   " Check for potential argument list on next line
   let continuation = (line =~ '[A-Za-z0-9_]\s*$')


   " Check current line; search for simplistic matching start-of-block
   let line = getline(v:lnum)
   if line =~ '^\s*#'
      " Start of line for ada-pp
      let ind = 0
   elseif continuation && line =~ '^\s*('
      " Don't do this if we've already indented due to the previous line
      if ind == initind
	 let ind = ind + &sw
      endif
   elseif line =~ '^\s*\(begin\|is\)\>'
      let ind = s:MainBlockIndent( ind, lnum, '\(procedure\|function\|declare\|package\|task\)\>', 'begin\>' )
   elseif line =~ '^\s*record\>'
      let ind = s:MainBlockIndent( ind, lnum, 'type\>\|for\>.*\<use\>', '' ) + &sw
   elseif line =~ '^\s*\(else\|elsif\)\>'
      let ind = s:MainBlockIndent( ind, lnum, 'if\>', '' )
   elseif line =~ '^\s*when\>'
      " Align 'when' one /in/ from matching block start
      let ind = s:MainBlockIndent( ind, lnum, '\(case\|exception\)\>', '' ) + &sw
   elseif line =~ '^\s*end\>\s*\<if\>'
      " End of if statements
      let ind = s:EndBlockIndent( ind, lnum, 'if\>', 'end\>\s*\<if\>' )
   elseif line =~ '^\s*end\>\s*\<loop\>'
      " End of loops
      let ind = s:EndBlockIndent( ind, lnum, '\(\(while\|for\)\>.*\)\?\<loop\>', 'end\>\s*\<loop\>' )
   elseif line =~ '^\s*end\>\s*\<record\>'
      " End of records
      let ind = s:EndBlockIndent( ind, lnum, '\(type\>.*\)\=\<record\>', 'end\>\s*\<record\>' )
   elseif line =~ '^\s*end\>\s*\<procedure\>'
      " End of procedures
      let ind = s:EndBlockIndent( ind, lnum, 'procedure\>.*\<is\>', 'end\>\s*\<procedure\>' )
   elseif line =~ '^\s*end\>\s*\<case\>'
      " End of case statement
      let ind = s:EndBlockIndent( ind, lnum, 'case\>.*\<is\>', 'end\>\s*\<case\>' )
   elseif line =~ '^\s*end\>'
      " General case for end
      let ind = s:MainBlockIndent( ind, lnum, '\(if\|while\|for\|loop\|accept\|begin\|record\|case\|exception\|package\)\>', '' )
   elseif line =~ '^\s*exception\>'
      let ind = s:MainBlockIndent( ind, lnum, 'begin\>', '' )
   elseif line =~ '^\s*then\>'
      let ind = s:MainBlockIndent( ind, lnum, 'if\>', '' )
   endif

   return ind
endfunction GetAdaIndent

let &cpo = s:keepcpo
unlet s:keepcpo

finish " 1}}}

"------------------------------------------------------------------------------
"   Copyright (C) 2006	Martin Krischik
"
"   Vim is Charityware - see ":help license" or uganda.txt for licence details.
"------------------------------------------------------------------------------
" vim: textwidth=78 wrap tabstop=8 shiftwidth=3 softtabstop=3 noexpandtab
" vim: foldmethod=marker
                                                                                                                       usr/share/vim/vim74/indent/ant.vim                                                                  0100644 0000000 0000000 00000000442 13050207306 015475  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:    ANT files
" Maintainer:  David Fishburn <fishburn@ianywhere.com>
" Last Change: Thu May 15 2003 10:02:54 PM

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif

" Use XML formatting rules
runtime! indent/xml.vim
                                                                                                                                                                                                                              usr/share/vim/vim74/indent/automake.vim                                                             0100644 0000000 0000000 00000000347 13050207306 016525  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	    automake
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2006-04-19

if exists("b:did_indent")
  finish
endif

" same as makefile indenting for now.
runtime! indent/make.vim
                                                                                                                                                                                                                                                                                         usr/share/vim/vim74/indent/awk.vim                                                                  0100644 0000000 0000000 00000017104 13050207306 015500  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        "  vim: set sw=3 sts=3:

" Awk indent script. It can handle multi-line statements and expressions.
" It works up to the point where the distinction between correct/incorrect
" and personal taste gets fuzzy. Drop me an e-mail for bug reports and
" reasonable style suggestions.
"
" Bugs:
" =====
" - Some syntax errors may cause erratic indentation.
" - Same for very unusual but syntacticly correct use of { }
" - In some cases it's confused by the use of ( and { in strings constants
" - This version likes the closing brace of a multiline pattern-action be on
"   character position 1 before the following pattern-action combination is
"   formatted

" Author:
" =======
" Erik Janssen, ejanssen@itmatters.nl
"
" History:
" ========
" 26-04-2002 Got initial version working reasonably well
" 29-04-2002 Fixed problems in function headers and max line width
"	     Added support for two-line if's without curly braces
" Fixed hang: 2011 Aug 31

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif

let b:did_indent = 1

setlocal indentexpr=GetAwkIndent()
" Mmm, copied from the tcl indent program. Is this okay?
setlocal indentkeys-=:,0#

" Only define the function once.
if exists("*GetAwkIndent")
    finish
endif

" This function contains a lot of exit points. It checks for simple cases
" first to get out of the function as soon as possible, thereby reducing the
" number of possibilities later on in the difficult parts

function! GetAwkIndent()

   " Find previous line and get it's indentation
   let prev_lineno = s:Get_prev_line( v:lnum )
   if prev_lineno == 0
      return 0
   endif
   let prev_data = getline( prev_lineno )
   let ind = indent( prev_lineno )

   " Increase indent if the previous line contains an opening brace. Search
   " for this brace the hard way to prevent errors if the previous line is a
   " 'pattern { action }' (simple check match on /{/ increases the indent then)

   if s:Get_brace_balance( prev_data, '{', '}' ) > 0
      return ind + &sw
   endif

   let brace_balance = s:Get_brace_balance( prev_data, '(', ')' )

   " If prev line has positive brace_balance and starts with a word (keyword
   " or function name), align the current line on the first '(' of the prev
   " line

   if brace_balance > 0 && s:Starts_with_word( prev_data )
      return s:Safe_indent( ind, s:First_word_len(prev_data), getline(v:lnum))
   endif

   " If this line starts with an open brace bail out now before the line
   " continuation checks.

   if getline( v:lnum ) =~ '^\s*{'
      return ind
   endif

   " If prev line seems to be part of multiline statement:
   " 1. Prev line is first line of a multiline statement
   "    -> attempt to indent on first ' ' or '(' of prev line, just like we
   "       indented the positive brace balance case above
   " 2. Prev line is not first line of a multiline statement
   "    -> copy indent of prev line

   let continue_mode = s:Seems_continuing( prev_data )
   if continue_mode > 0
     if s:Seems_continuing( getline(s:Get_prev_line( prev_lineno )) )
       " Case 2
       return ind
     else
       " Case 1
       if continue_mode == 1
	  " Need continuation due to comma, backslash, etc
	  return s:Safe_indent( ind, s:First_word_len(prev_data), getline(v:lnum))
       else
	 " if/for/while without '{'
	 return ind + &sw
       endif
     endif
   endif

   " If the previous line doesn't need continuation on the current line we are
   " on the start of a new statement.  We have to make sure we align with the
   " previous statement instead of just the previous line. This is a bit
   " complicated because the previous statement might be multi-line.
   "
   " The start of a multiline statement can be found by:
   "
   " 1 If the previous line contains closing braces and has negative brace
   "   balance, search backwards until cumulative brace balance becomes zero,
   "   take indent of that line
   " 2 If the line before the previous needs continuation search backward
   "   until that's not the case anymore. Take indent of one line down.

   " Case 1
   if prev_data =~ ')' && brace_balance < 0
      while brace_balance != 0 && prev_lineno > 0
	 let prev_lineno = s:Get_prev_line( prev_lineno )
	 let prev_data = getline( prev_lineno )
	 let brace_balance=brace_balance+s:Get_brace_balance(prev_data,'(',')' )
      endwhile
      let ind = indent( prev_lineno )
   else
      " Case 2
      if s:Seems_continuing( getline( prev_lineno - 1 ) )
	 let prev_lineno = prev_lineno - 2
	 let prev_data = getline( prev_lineno )
	 while prev_lineno > 0 && (s:Seems_continuing( prev_data ) > 0)
	    let prev_lineno = s:Get_prev_line( prev_lineno )
	    let prev_data = getline( prev_lineno )
	 endwhile
	 let ind = indent( prev_lineno + 1 )
      endif
   endif

   " Decrease indent if this line contains a '}'.
   if getline(v:lnum) =~ '^\s*}'
      let ind = ind - &sw
   endif

   return ind
endfunction

" Find the open and close braces in this line and return how many more open-
" than close braces there are. It's also used to determine cumulative balance
" across multiple lines.

function! s:Get_brace_balance( line, b_open, b_close )
   let line2 = substitute( a:line, a:b_open, "", "g" )
   let openb = strlen( a:line ) - strlen( line2 )
   let line3 = substitute( line2, a:b_close, "", "g" )
   let closeb = strlen( line2 ) - strlen( line3 )
   return openb - closeb
endfunction

" Find out whether the line starts with a word (i.e. keyword or function
" call). Might need enhancements here.

function! s:Starts_with_word( line )
  if a:line =~ '^\s*[a-zA-Z_0-9]\+\s*('
     return 1
  endif
  return 0
endfunction

" Find the length of the first word in a line. This is used to be able to
" align a line relative to the 'print ' or 'if (' on the previous line in case
" such a statement spans multiple lines.
" Precondition: only to be used on lines where 'Starts_with_word' returns 1.

function! s:First_word_len( line )
   let white_end = matchend( a:line, '^\s*' )
   if match( a:line, '^\s*func' ) != -1
     let word_end = matchend( a:line, '[a-z]\+\s\+[a-zA-Z_0-9]\+[ (]*' )
   else
     let word_end = matchend( a:line, '[a-zA-Z_0-9]\+[ (]*' )
   endif
   return word_end - white_end
endfunction

" Determine if 'line' completes a statement or is continued on the next line.
" This one is far from complete and accepts illegal code. Not important for
" indenting, however.

function! s:Seems_continuing( line )
  " Unfinished lines
  if a:line =~ '\(--\|++\)\s*$'
    return 0
  endif
  if a:line =~ '[\\,\|\&\+\-\*\%\^]\s*$'
    return 1
  endif
  " if/for/while (cond) eol
  if a:line =~ '^\s*\(if\|while\|for\)\s*(.*)\s*$' || a:line =~ '^\s*else\s*'
      return 2
   endif
  return 0
endfunction

" Get previous relevant line. Search back until a line is that is no
" comment or blank and return the line number

function! s:Get_prev_line( lineno )
   let lnum = a:lineno - 1
   let data = getline( lnum )
   while lnum > 0 && (data =~ '^\s*#' || data =~ '^\s*$')
      let lnum = lnum - 1
      let data = getline( lnum )
   endwhile
   return lnum
endfunction

" This function checks whether an indented line exceeds a maximum linewidth
" (hardcoded 80). If so and it is possible to stay within 80 positions (or
" limit num of characters beyond linewidth) by decreasing the indent (keeping
" it > base_indent), do so.

function! s:Safe_indent( base, wordlen, this_line )
   let line_base = matchend( a:this_line, '^\s*' )
   let line_len = strlen( a:this_line ) - line_base
   let indent = a:base
   if (indent + a:wordlen + line_len) > 80
     " Simple implementation good enough for the time being
     let indent = indent + 3
   endif
   return indent + a:wordlen
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/share/vim/vim74/indent/bib.vim                                                                  0100644 0000000 0000000 00000000532 13050207306 015447  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:      BibTeX
" Maintainer:    Dorai Sitaram <ds26@gte.com>
" URL:		 http://www.ccs.neu.edu/~dorai/vimplugins/vimplugins.html
" Last Change:   2005 Mar 28

" Only do this when not done yet for this buffer
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal cindent

let b:undo_indent = "setl cin<"
                                                                                                                                                                      usr/share/vim/vim74/indent/bst.vim                                                                  0100644 0000000 0000000 00000003577 13050207306 015517  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	bst
" Author:	Tim Pope <vimNOSPAM@tpope.info>
" $Id: bst.vim,v 1.1 2007/05/05 18:11:12 vimboss Exp $

if exists("b:did_indent")
    finish
endif
let b:did_indent = 1

setlocal expandtab
setlocal indentexpr=GetBstIndent(v:lnum)
"setlocal smartindent
setlocal cinkeys&
setlocal cinkeys-=0#
setlocal indentkeys&
"setlocal indentkeys+=0%

" Only define the function once.
if exists("*GetBstIndent")
    finish
endif

function! s:prevgood(lnum)
    " Find a non-blank line above the current line.
    " Skip over comments.
    let lnum = a:lnum
    while lnum > 0
        let lnum = prevnonblank(lnum - 1)
        if getline(lnum) !~ '^\s*%.*$'
            break
        endif
    endwhile
    return lnum
endfunction

function! s:strip(lnum)
    let line = getline(a:lnum)
    let line = substitute(line,'"[^"]*"','""','g')
    let line = substitute(line,'%.*','','')
    let line = substitute(line,'^\s\+','','')
    return line
endfunction

function! s:count(string,char)
    let str = substitute(a:string,'[^'.a:char.']','','g')
    return strlen(str)
endfunction

function! GetBstIndent(lnum) abort
    if a:lnum == 1
        return 0
    endif
    let lnum = s:prevgood(a:lnum)
    if lnum <= 0
        return indent(a:lnum - 1)
    endif
    let line = s:strip(lnum)
    let cline = s:strip(a:lnum)
    if cline =~ '^}' && exists("b:current_syntax")
        call cursor(a:lnum,indent(a:lnum))
        if searchpair('{','','}','bW',"synIDattr(synID(line('.'),col('.'),1),'name') =~? 'comment\\|string'")
            if col('.')+1 == col('$')
                return indent('.')
            else
                return virtcol('.')-1
            endif
        endif
    endif
    let fakeline = substitute(line,'^}','','').matchstr(cline,'^}')
    let ind = indent(lnum)
    let ind = ind + &sw * s:count(line,'{')
    let ind = ind - &sw * s:count(fakeline,'}')
    return ind
endfunction
                                                                                                                                 usr/share/vim/vim74/indent/c.vim                                                                    0100644 0000000 0000000 00000000505 13050207306 015135  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	C
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2005 Mar 27

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
   finish
endif
let b:did_indent = 1

" C indenting is built-in, thus this is very simple
setlocal cindent

let b:undo_indent = "setl cin<"
                                                                                                                                                                                           usr/share/vim/vim74/indent/cdl.vim                                                                  0100644 0000000 0000000 00000010114 13050207306 015452  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Description:	Comshare Dimension Definition Language (CDL)
" Author:	Raul Segura Acevedo <raulseguraaceved@netscape.net>
" Last Change:	Fri Nov 30 13:35:48  2001 CST

if exists("b:did_indent")
    "finish
endif
let b:did_indent = 1

setlocal indentexpr=CdlGetIndent(v:lnum)
setlocal indentkeys&
setlocal indentkeys+==~else,=~endif,=~then,;,),=

" Only define the function once.
if exists("*CdlGetIndent")
    "finish
endif

" find out if an "...=..." expresion its an asignment (or a conditional)
" it scans 'line' first, and then the previos lines
fun! CdlAsignment(lnum, line)
  let f = -1
  let lnum = a:lnum
  let line = a:line
  while lnum > 0 && f == -1
    " line without members [a] of [b]:[c]...
    let inicio = 0
    while 1
      " keywords that help to decide
      let inicio = matchend(line, '\c\<\(expr\|\a*if\|and\|or\|not\|else\|then\|memberis\|\k\+of\)\>\|[<>;]', inicio)
      if inicio < 0
	break
      endif
      " it's formula if there's a ';', 'elsE', 'theN', 'enDif' or 'expr'
      " conditional if there's a '<', '>', 'elseif', 'if', 'and', 'or', 'not',
      " 'memberis', 'childrenof' and other \k\+of funcions
      let f = line[inicio-1] =~? '[en;]' || strpart(line, inicio-4, 4) =~? 'ndif\|expr'
    endw
    let lnum = prevnonblank(lnum-1)
    let line = substitute(getline(lnum), '\c\(\[[^]]*]\(\s*of\s*\|:\)*\)\+', ' ', 'g')
  endw
  " if we hit the start of the file then f = -1, return 1 (formula)
  return f != 0
endf

fun! CdlGetIndent(lnum)
  let thisline = getline(a:lnum)
  if match(thisline, '^\s*\(\k\+\|\[[^]]*]\)\s*\(,\|;\s*$\)') >= 0
    " it's an attributes line
    return &sw
  elseif match(thisline, '^\c\s*\([{}]\|\/[*/]\|dimension\|schedule\|group\|hierarchy\|class\)') >= 0
    " it's a header or '{' or '}' or a comment
    return 0
  end

  let lnum = prevnonblank(a:lnum-1)
  " Hit the start of the file, use zero indent.
  if lnum == 0
    return 0
  endif

  " PREVIOUS LINE
  let ind = indent(lnum)
  let line = getline(lnum)
  let f = -1 " wether a '=' is a conditional or a asignment, -1 means we don't know yet
  " one 'closing' element at the beginning of the line has already reduced the
  "   indent, but 'else', 'elseif' & 'then' increment it for the next line
  " '=' at the beginning has already de right indent (increased for asignments)
  let inicio = matchend(line, '^\c\s*\(else\a*\|then\|endif\|/[*/]\|[);={]\)')
  if inicio > 0
    let c = line[inicio-1]
    " ')' and '=' don't change indent and are useless to set 'f'
    if c == '{'
      return &sw
    elseif c != ')' && c != '='
      let f = 1 " all but 'elseif' are followed by a formula
      if c ==? 'n' || c ==? 'e' " 'then', 'else'
	let ind = ind + &sw
      elseif strpart(line, inicio-6, 6) ==? 'elseif' " elseif, set f to conditional
	let ind = ind + &sw
	let f = 0
      end
    end
  end

  " remove members [a] of [b]:[c]... (inicio remainds valid)
  let line = substitute(line, '\c\(\[[^]]*]\(\s*of\s*\|:\)*\)\+', ' ', 'g')
  while 1
    " search for the next interesting element
    let inicio=matchend(line, '\c\<if\|endif\|[()=;]', inicio)
    if inicio < 0
      break
    end

    let c = line[inicio-1]
    " 'expr(...)' containing the formula
    if strpart(line, inicio-5, 5) ==? 'expr('
      let ind = 0
      let f = 1
    elseif c == ')' || c== ';' || strpart(line, inicio-5, 5) ==? 'endif'
      let ind = ind - &sw
    elseif c == '(' || c ==? 'f' " '(' or 'if'
      let ind = ind + &sw
    else " c == '='
      " if it is an asignment increase indent
      if f == -1 " we don't know yet, find out
	let f = CdlAsignment(lnum, strpart(line, 0, inicio))
      end
      if f == 1 " formula increase it
	let ind = ind + &sw
      end
    end
  endw

  " CURRENT LINE, if it starts with a closing element, decrease indent
  " or if it starts with '=' (asignment), increase indent
  if match(thisline, '^\c\s*\(else\|then\|endif\|[);]\)') >= 0
    let ind = ind - &sw
  elseif match(thisline, '^\s*=') >= 0
    if f == -1 " we don't know yet if is an asignment, find out
      let f = CdlAsignment(lnum, "")
    end
    if f == 1 " formula increase it
      let ind = ind + &sw
    end
  end

  return ind
endfun
                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/share/vim/vim74/indent/ch.vim                                                                   0100644 0000000 0000000 00000000726 13050207306 015312  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Ch
" Maintainer:	SoftIntegration, Inc. <info@softintegration.com>
" URL:		http://www.softintegration.com/download/vim/indent/ch.vim
" Last change:	2006 Apr 30
"		Created based on cpp.vim
"
" Ch is a C/C++ interpreter with many high level extensions


" Only load this indent file when no other was loaded.
if exists("b:did_indent")
   finish
endif
let b:did_indent = 1

" Ch indenting is built-in, thus this is very simple
setlocal cindent
                                          usr/share/vim/vim74/indent/chaiscript.vim                                                           0100644 0000000 0000000 00000002157 13050207306 017051  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:     ChaiScript
" Maintainer:	Jason Turner <lefticus 'at' gmail com>

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetChaiScriptIndent()
setlocal autoindent

" Only define the function once.
if exists("*GetChaiScriptIndent")
  finish
endif

function! GetChaiScriptIndent()
  " Find a non-blank line above the current line.
  let lnum = prevnonblank(v:lnum - 1)

  " Hit the start of the file, use zero indent.
  if lnum == 0
    return 0
  endif

  " Add a 'shiftwidth' after lines that start a block:
  " lines containing a {
  let ind = indent(lnum)
  let flag = 0
  let prevline = getline(lnum)
  if prevline =~ '^.*{.*'
    let ind = ind + &shiftwidth
    let flag = 1
  endif

  " Subtract a 'shiftwidth' after lines containing a { followed by a }
  " to keep it balanced
  if flag == 1 && prevline =~ '.*{.*}.*'
    let ind = ind - &shiftwidth
  endif

  " Subtract a 'shiftwidth' on lines ending with }
  if getline(v:lnum) =~ '^\s*\%(}\)'
    let ind = ind - &shiftwidth
  endif

  return ind
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                 usr/share/vim/vim74/indent/changelog.vim                                                            0100644 0000000 0000000 00000000410 13050207306 016635  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	generic Changelog file
" Maintainer:	noone
" Last Change:	2005 Mar 29

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
   finish
endif
let b:did_indent = 1

setlocal ai

let b:undo_indent = "setl ai<"
                                                                                                                                                                                                                                                        usr/share/vim/vim74/indent/clojure.vim                                                              0100644 0000000 0000000 00000020427 13050207306 016363  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Clojure
" Author:	Meikel Brandmeyer <mb@kotka.de>
" URL:		http://kotka.de/projects/clojure/vimclojure.html
"
" Maintainer:	Sung Pae <self@sungpae.com>
" URL:		https://github.com/guns/vim-clojure-static
" License:	Same as Vim
" Last Change:	27 March 2014

" TODO: Indenting after multibyte characters is broken:
"       (let [Δ (if foo
"                bar    ; Indent error
"                baz)])

if exists("b:did_indent")
	finish
endif
let b:did_indent = 1

let s:save_cpo = &cpo
set cpo&vim

let b:undo_indent = 'setlocal autoindent< smartindent< expandtab< softtabstop< shiftwidth< indentexpr< indentkeys<'

setlocal noautoindent nosmartindent
setlocal softtabstop=2 shiftwidth=2 expandtab
setlocal indentkeys=!,o,O

if exists("*searchpairpos")

	if !exists('g:clojure_maxlines')
		let g:clojure_maxlines = 100
	endif

	if !exists('g:clojure_fuzzy_indent')
		let g:clojure_fuzzy_indent = 1
	endif

	if !exists('g:clojure_fuzzy_indent_patterns')
		let g:clojure_fuzzy_indent_patterns = ['^with', '^def', '^let']
	endif

	if !exists('g:clojure_fuzzy_indent_blacklist')
		let g:clojure_fuzzy_indent_blacklist = ['-fn$', '\v^with-%(meta|out-str|loading-context)$']
	endif

	if !exists('g:clojure_special_indent_words')
		let g:clojure_special_indent_words = 'deftype,defrecord,reify,proxy,extend-type,extend-protocol,letfn'
	endif

	if !exists('g:clojure_align_multiline_strings')
		let g:clojure_align_multiline_strings = 0
	endif

	if !exists('g:clojure_align_subforms')
		let g:clojure_align_subforms = 0
	endif

	function! s:SynIdName()
		return synIDattr(synID(line("."), col("."), 0), "name")
	endfunction

	function! s:CurrentChar()
		return getline('.')[col('.')-1]
	endfunction

	function! s:CurrentWord()
		return getline('.')[col('.')-1 : searchpos('\v>', 'n', line('.'))[1]-2]
	endfunction

	function! s:IsParen()
		return s:CurrentChar() =~# '\v[\(\)\[\]\{\}]' &&
		     \ s:SynIdName() !~? '\vstring|regex|comment|character'
	endfunction

	" Returns 1 if string matches a pattern in 'patterns', which may be a
	" list of patterns, or a comma-delimited string of implicitly anchored
	" patterns.
	function! s:MatchesOne(patterns, string)
		let list = type(a:patterns) == type([])
			   \ ? a:patterns
			   \ : map(split(a:patterns, ','), '"^" . v:val . "$"')
		for pat in list
			if a:string =~# pat | return 1 | endif
		endfor
	endfunction

	function! s:MatchPairs(open, close, stopat)
		" Stop only on vector and map [ resp. {. Ignore the ones in strings and
		" comments.
		if a:stopat == 0
			let stopat = max([line(".") - g:clojure_maxlines, 0])
		else
			let stopat = a:stopat
		endif

		let pos = searchpairpos(a:open, '', a:close, 'bWn', "!s:IsParen()", stopat)
		return [pos[0], virtcol(pos)]
	endfunction

	function! s:ClojureCheckForStringWorker()
		" Check whether there is the last character of the previous line is
		" highlighted as a string. If so, we check whether it's a ". In this
		" case we have to check also the previous character. The " might be the
		" closing one. In case the we are still in the string, we search for the
		" opening ". If this is not found we take the indent of the line.
		let nb = prevnonblank(v:lnum - 1)

		if nb == 0
			return -1
		endif

		call cursor(nb, 0)
		call cursor(0, col("$") - 1)
		if s:SynIdName() !~? "string"
			return -1
		endif

		" This will not work for a " in the first column...
		if s:CurrentChar() == '"'
			call cursor(0, col("$") - 2)
			if s:SynIdName() !~? "string"
				return -1
			endif
			if s:CurrentChar() != '\\'
				return -1
			endif
			call cursor(0, col("$") - 1)
		endif

		let p = searchpos('\(^\|[^\\]\)\zs"', 'bW')

		if p != [0, 0]
			return p[1] - 1
		endif

		return indent(".")
	endfunction

	function! s:CheckForString()
		let pos = getpos('.')
		try
			let val = s:ClojureCheckForStringWorker()
		finally
			call setpos('.', pos)
		endtry
		return val
	endfunction

	function! s:StripNamespaceAndMacroChars(word)
		return substitute(a:word, "\\v%(.*/|[#'`~@^,]*)(.*)", '\1', '')
	endfunction

	function! s:ClojureIsMethodSpecialCaseWorker(position)
		" Find the next enclosing form.
		call search('\S', 'Wb')

		" Special case: we are at a '(('.
		if s:CurrentChar() == '('
			return 0
		endif
		call cursor(a:position)

		let nextParen = s:MatchPairs('(', ')', 0)

		" Special case: we are now at toplevel.
		if nextParen == [0, 0]
			return 0
		endif
		call cursor(nextParen)

		call search('\S', 'W')
		let w = s:StripNamespaceAndMacroChars(s:CurrentWord())
		if g:clojure_special_indent_words =~# '\V\<' . w . '\>'
			return 1
		endif

		return 0
	endfunction

	function! s:IsMethodSpecialCase(position)
		let pos = getpos('.')
		try
			let val = s:ClojureIsMethodSpecialCaseWorker(a:position)
		finally
			call setpos('.', pos)
		endtry
		return val
	endfunction

	function! GetClojureIndent()
		" Get rid of special case.
		if line(".") == 1
			return 0
		endif

		" We have to apply some heuristics here to figure out, whether to use
		" normal lisp indenting or not.
		let i = s:CheckForString()
		if i > -1
			return i + !!g:clojure_align_multiline_strings
		endif

		call cursor(0, 1)

		" Find the next enclosing [ or {. We can limit the second search
		" to the line, where the [ was found. If no [ was there this is
		" zero and we search for an enclosing {.
		let paren = s:MatchPairs('(', ')', 0)
		let bracket = s:MatchPairs('\[', '\]', paren[0])
		let curly = s:MatchPairs('{', '}', bracket[0])

		" In case the curly brace is on a line later then the [ or - in
		" case they are on the same line - in a higher column, we take the
		" curly indent.
		if curly[0] > bracket[0] || curly[1] > bracket[1]
			if curly[0] > paren[0] || curly[1] > paren[1]
				return curly[1]
			endif
		endif

		" If the curly was not chosen, we take the bracket indent - if
		" there was one.
		if bracket[0] > paren[0] || bracket[1] > paren[1]
			return bracket[1]
		endif

		" There are neither { nor [ nor (, ie. we are at the toplevel.
		if paren == [0, 0]
			return 0
		endif

		" Now we have to reimplement lispindent. This is surprisingly easy, as
		" soon as one has access to syntax items.
		"
		" - Check whether we are in a special position after a word in
		"   g:clojure_special_indent_words. These are special cases.
		" - Get the next keyword after the (.
		" - If its first character is also a (, we have another sexp and align
		"   one column to the right of the unmatched (.
		" - In case it is in lispwords, we indent the next line to the column of
		"   the ( + sw.
		" - If not, we check whether it is last word in the line. In that case
		"   we again use ( + sw for indent.
		" - In any other case we use the column of the end of the word + 2.
		call cursor(paren)

		if s:IsMethodSpecialCase(paren)
			return paren[1] + &shiftwidth - 1
		endif

		" In case we are at the last character, we use the paren position.
		if col("$") - 1 == paren[1]
			return paren[1]
		endif

		" In case after the paren is a whitespace, we search for the next word.
		call cursor(0, col('.') + 1)
		if s:CurrentChar() == ' '
			call search('\v\S', 'W')
		endif

		" If we moved to another line, there is no word after the (. We
		" use the ( position for indent.
		if line(".") > paren[0]
			return paren[1]
		endif

		" We still have to check, whether the keyword starts with a (, [ or {.
		" In that case we use the ( position for indent.
		let w = s:CurrentWord()
		if stridx('([{', w[0]) > -1
			return paren[1]
		endif

		" Test words without namespace qualifiers and leading reader macro
		" metacharacters.
		"
		" e.g. clojure.core/defn and #'defn should both indent like defn.
		let ww = s:StripNamespaceAndMacroChars(w)

		if &lispwords =~# '\V\<' . ww . '\>'
			return paren[1] + &shiftwidth - 1
		endif

		if g:clojure_fuzzy_indent
			\ && !s:MatchesOne(g:clojure_fuzzy_indent_blacklist, ww)
			\ && s:MatchesOne(g:clojure_fuzzy_indent_patterns, ww)
			return paren[1] + &shiftwidth - 1
		endif

		call search('\v\_s', 'cW')
		call search('\v\S', 'W')
		if paren[0] < line(".")
			return paren[1] + (g:clojure_align_subforms ? 0 : &shiftwidth - 1)
		endif

		call search('\v\S', 'bW')
		return virtcol(".") + 1
	endfunction

	setlocal indentexpr=GetClojureIndent()

else

	" In case we have searchpairpos not available we fall back to
	" normal lisp indenting.
	setlocal indentexpr=
	setlocal lisp
	let b:undo_indent .= '| setlocal lisp<'

endif

let &cpo = s:save_cpo
unlet! s:save_cpo

" vim:sts=8:sw=8:ts=8:noet
                                                                                                                                                                                                                                         usr/share/vim/vim74/indent/cmake.vim                                                                0100644 0000000 0000000 00000005302 13050207306 015773  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Program:      CMake - Cross-Platform Makefile Generator
" Module:       $RCSfile: cmake-indent.vim,v $
" Language:     CMake (ft=cmake)
" Author:       Andy Cedilnik <andy.cedilnik@kitware.com>
" Maintainer:   Karthik Krishnan <karthik.krishnan@kitware.com>
" Last Change:  $Date: 2008-01-16 16:53:53 $
" Version:      $Revision: 1.9 $
"
" Licence:      The CMake license applies to this file. See
"               http://www.cmake.org/HTML/Copyright.html
"               This implies that distribution with Vim is allowed

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=CMakeGetIndent(v:lnum)
setlocal indentkeys+==ENDIF(,ENDFOREACH(,ENDMACRO(,ELSE(,ELSEIF(,ENDWHILE(

" Only define the function once.
if exists("*CMakeGetIndent")
  finish
endif
let s:keepcpo= &cpo
set cpo&vim

fun! CMakeGetIndent(lnum)
  let this_line = getline(a:lnum)

  " Find a non-blank line above the current line.
  let lnum = a:lnum
  let lnum = prevnonblank(lnum - 1)
  let previous_line = getline(lnum)

  " Hit the start of the file, use zero indent.
  if lnum == 0
    return 0
  endif

  let ind = indent(lnum)

  let or = '\|'
  " Regular expressions used by line indentation function.
  let cmake_regex_comment = '#.*'
  let cmake_regex_identifier = '[A-Za-z][A-Za-z0-9_]*'
  let cmake_regex_quoted = '"\([^"\\]\|\\.\)*"'
  let cmake_regex_arguments = '\(' . cmake_regex_quoted .
                    \       or . '\$(' . cmake_regex_identifier . ')' .
                    \       or . '[^()\\#"]' . or . '\\.' . '\)*'

  let cmake_indent_comment_line = '^\s*' . cmake_regex_comment
  let cmake_indent_blank_regex = '^\s*$'
  let cmake_indent_open_regex = '^\s*' . cmake_regex_identifier .
                    \           '\s*(' . cmake_regex_arguments .
                    \           '\(' . cmake_regex_comment . '\)\?$'

  let cmake_indent_close_regex = '^' . cmake_regex_arguments .
                    \            ')\s*' .
                    \            '\(' . cmake_regex_comment . '\)\?$'

  let cmake_indent_begin_regex = '^\s*\(IF\|MACRO\|FOREACH\|ELSE\|ELSEIF\|WHILE\|FUNCTION\)\s*('
  let cmake_indent_end_regex = '^\s*\(ENDIF\|ENDFOREACH\|ENDMACRO\|ELSE\|ELSEIF\|ENDWHILE\|ENDFUNCTION\)\s*('

  " Add
  if previous_line =~? cmake_indent_comment_line " Handle comments
    let ind = ind
  else
    if previous_line =~? cmake_indent_begin_regex
      let ind = ind + &sw
    endif
    if previous_line =~? cmake_indent_open_regex
      let ind = ind + &sw
    endif
  endif

  " Subtract
  if this_line =~? cmake_indent_end_regex
    let ind = ind - &sw
  endif
  if previous_line =~? cmake_indent_close_regex
    let ind = ind - &sw
  endif

  return ind
endfun

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                                                                                                              usr/share/vim/vim74/indent/cobol.vim                                                                0100644 0000000 0000000 00000020005 13050207306 016006  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	cobol
" Author:	Tim Pope <vimNOSPAM@tpope.info>
" $Id: cobol.vim,v 1.1 2007/05/05 18:08:19 vimboss Exp $

if exists("b:did_indent")
    finish
endif
let b:did_indent = 1

setlocal expandtab
setlocal indentexpr=GetCobolIndent(v:lnum)
setlocal indentkeys&
setlocal indentkeys+=0<*>,0/,0$,0=01,=~division,=~section,0=~end,0=~then,0=~else,0=~when,*<Return>,.

" Only define the function once.
if exists("*GetCobolIndent")
    finish
endif

let s:skip = 'getline(".") =~ "^.\\{6\\}[*/$-]\\|\"[^\"]*\""'

function! s:prevgood(lnum)
    " Find a non-blank line above the current line.
    " Skip over comments.
    let lnum = a:lnum
    while lnum > 0
        let lnum = prevnonblank(lnum - 1)
        let line = getline(lnum)
        if line !~? '^\s*[*/$-]' && line !~? '^.\{6\}[*/$CD-]'
            break
        endif
    endwhile
    return lnum
endfunction

function! s:stripped(lnum)
    return substitute(strpart(getline(a:lnum),0,72),'^\s*','','')
endfunction

function! s:optionalblock(lnum,ind,blocks,clauses)
    let ind = a:ind
    let clauses = '\c\<\%(\<NOT\s\+\)\@<!\%(NOT\s\+\)\=\%('.a:clauses.'\)'
    let begin = '\c-\@<!\<\%('.a:blocks.'\)\>'
    let beginfull = begin.'\ze.*\%(\n\%(\s*\%([*/$-].*\)\=\n\)*\)\=\s*\%('.clauses.'\)'
    let end   = '\c\<end-\%('.a:blocks.'\)\>\|\%(\.\%( \|$\)\)\@='
    let cline = s:stripped(a:lnum)
    let line  = s:stripped(s:prevgood(a:lnum))
    if cline =~? clauses "&& line !~? '^search\>'
        call cursor(a:lnum,1)
        let lastclause = searchpair(beginfull,clauses,end,'bWr',s:skip)
        if getline(lastclause) =~? clauses && s:stripped(lastclause) !~? '^'.begin
            let ind = indent(lastclause)
        elseif lastclause > 0
            let ind = indent(lastclause) + &sw
            "let ind = ind + &sw
        endif
    elseif line =~? clauses && cline !~? end
        let ind = ind + &sw
    endif
    return ind
endfunction

function! GetCobolIndent(lnum) abort
    let minshft = 6
    let ashft = minshft + 1
    let bshft = ashft + 4
    " (Obsolete) numbered lines
    if getline(a:lnum) =~? '^\s*\d\{6\}\%($\|[ */$CD-]\)'
        return 0
    endif
    let cline = s:stripped(a:lnum)
    " Comments, etc. must start in the 7th column
    if cline =~? '^[*/$-]'
        return minshft
    elseif cline =~# '^[CD]' && indent(a:lnum) == minshft
        return minshft
    endif
    " Divisions, sections, and file descriptions start in area A
    if cline =~? '\<\(DIVISION\|SECTION\)\%($\|\.\)' || cline =~? '^[FS]D\>'
        return ashft
    endif
    " Fields
    if cline =~? '^0*\(1\|77\)\>'
        return ashft
    endif
    if cline =~? '^\d\+\>'
        let cnum = matchstr(cline,'^\d\+\>')
        let default = 0
        let step = -1
        while step < 2
        let lnum = a:lnum
        while lnum > 0 && lnum < line('$') && lnum > a:lnum - 500 && lnum < a:lnum + 500
            let lnum = step > 0 ? nextnonblank(lnum + step) : prevnonblank(lnum + step)
            let line = getline(lnum)
            let lindent = indent(lnum)
            if line =~? '^\s*\d\+\>'
                let num = matchstr(line,'^\s*\zs\d\+\>')
                if 0+cnum == num
                    return lindent
                elseif 0+cnum > num && default < lindent + &sw
                    let default = lindent + &sw
                endif
            elseif lindent < bshft && lindent >= ashft
                break
            endif
        endwhile
        let step = step + 2
        endwhile
        return default ? default : bshft
    endif
    let lnum = s:prevgood(a:lnum)
    " Hit the start of the file, use "zero" indent.
    if lnum == 0
        return ashft
    endif
    " Initial spaces are ignored
    let line = s:stripped(lnum)
    let ind = indent(lnum)
    " Paragraphs.  There may be some false positives.
    if cline =~? '^\(\a[A-Z0-9-]*[A-Z0-9]\|\d[A-Z0-9-]*\a\)\.' "\s*$'
        if cline !~? '^EXIT\s*\.' && line =~? '\.\s*$'
            return ashft
        endif
    endif
    " Paragraphs in the identification division.
    "if cline =~? '^\(PROGRAM-ID\|AUTHOR\|INSTALLATION\|' .
                "\ 'DATE-WRITTEN\|DATE-COMPILED\|SECURITY\)\>'
        "return ashft
    "endif
    if line =~? '\.$'
        " XXX
        return bshft
    endif
    if line =~? '^PERFORM\>'
        let perfline = substitute(line, '\c^PERFORM\s*', "", "")
        if perfline =~? '^\%(\k\+\s\+TIMES\)\=\s*$'
            let ind = ind + &sw
        elseif perfline =~? '^\%(WITH\s\+TEST\|VARYING\|UNTIL\)\>.*[^.]$'
            let ind = ind + &sw
        endif
    endif
    if line =~? '^\%(IF\|THEN\|ELSE\|READ\|EVALUATE\|SEARCH\|SELECT\)\>'
        let ind = ind + &sw
    endif
    let ind = s:optionalblock(a:lnum,ind,'ADD\|COMPUTE\|DIVIDE\|MULTIPLY\|SUBTRACT','ON\s\+SIZE\s\+ERROR')
    let ind = s:optionalblock(a:lnum,ind,'STRING\|UNSTRING\|ACCEPT\|DISPLAY\|CALL','ON\s\+OVERFLOW\|ON\s\+EXCEPTION')
    if cline !~? '^AT\s\+END\>' || line !~? '^SEARCH\>'
        let ind = s:optionalblock(a:lnum,ind,'DELETE\|REWRITE\|START\|WRITE\|READ','INVALID\s\+KEY\|AT\s\+END\|NO\s\+DATA\|AT\s\+END-OF-PAGE')
    endif
    if cline =~? '^WHEN\>'
        call cursor(a:lnum,1)
        " We also search for READ so that contained AT ENDs are skipped
        let lastclause = searchpair('\c-\@<!\<\%(SEARCH\|EVALUATE\|READ\)\>','\c\<\%(WHEN\|AT\s\+END\)\>','\c\<END-\%(SEARCH\|EVALUATE\|READ\)\>','bW',s:skip)
        let g:foo = s:stripped(lastclause)
        if s:stripped(lastclause) =~? '\c\<\%(WHEN\|AT\s\+END\)\>'
            "&& s:stripped(lastclause) !~? '^\%(SEARCH\|EVALUATE\|READ\)\>'
            let ind = indent(lastclause)
        elseif lastclause > 0
            let ind = indent(lastclause) + &sw
        endif
    elseif line =~? '^WHEN\>'
        let ind = ind + &sw
    endif
    "I'm not sure why I had this
    "if line =~? '^ELSE\>-\@!' && line !~? '\.$'
        "let ind = indent(s:prevgood(lnum))
    "endif
    if cline =~? '^\(END\)\>-\@!'
        " On lines with just END, 'guess' a simple shift left
        let ind = ind - &sw
    elseif cline =~? '^\(END-IF\|THEN\|ELSE\)\>-\@!'
        call cursor(a:lnum,indent(a:lnum))
        let match = searchpair('\c-\@<!\<IF\>','\c-\@<!\%(THEN\|ELSE\)\>','\c-\@<!\<END-IF\>\zs','bnW',s:skip)
        if match > 0
            let ind = indent(match)
        endif
    elseif cline =~? '^END-[A-Z]'
        let beginword = matchstr(cline,'\c\<END-\zs[A-Z0-9-]\+')
        let endword = 'END-'.beginword
        let first = 0
        let suffix = '.*\%(\n\%(\%(\s*\|.\{6\}\)[*/].*\n\)*\)\=\s*'
        if beginword =~? '^\%(ADD\|COMPUTE\|DIVIDE\|MULTIPLY\|SUBTRACT\)$'
            let beginword = beginword . suffix . '\<\%(NOT\s\+\)\=ON\s\+SIZE\s\+ERROR'
            let g:beginword = beginword
            let first = 1
        elseif beginword =~? '^\%(STRING\|UNSTRING\)$'
            let beginword = beginword . suffix . '\<\%(NOT\s\+\)\=ON\s\+OVERFLOW'
            let first = 1
        elseif beginword =~? '^\%(ACCEPT\|DISPLAY\)$'
            let beginword = beginword . suffix . '\<\%(NOT\s\+\)\=ON\s\+EXCEPTION'
            let first = 1
        elseif beginword ==? 'CALL'
            let beginword = beginword . suffix . '\<\%(NOT\s\+\)\=ON\s\+\%(EXCEPTION\|OVERFLOW\)'
            let first = 1
        elseif beginword =~? '^\%(DELETE\|REWRITE\|START\|READ\|WRITE\)$'
            let first = 1
            let beginword = beginword . suffix . '\<\%(NOT\s\+\)\=\(INVALID\s\+KEY'
            if beginword =~? '^READ'
                let first = 0
                let beginword = beginword . '\|AT\s\+END\|NO\s\+DATA'
            elseif beginword =~? '^WRITE'
                let beginword = beginword . '\|AT\s\+END-OF-PAGE'
            endif
            let beginword = beginword . '\)'
        endif
        call cursor(a:lnum,indent(a:lnum))
        let match = searchpair('\c-\@<!\<'.beginword.'\>','','\c\<'.endword.'\>\zs','bnW'.(first? 'r' : ''),s:skip)
        if match > 0
            let ind = indent(match)
        elseif cline =~? '^\(END-\(READ\|EVALUATE\|SEARCH\|PERFORM\)\)\>'
            let ind = ind - &sw
        endif
    endif
    return ind < bshft ? bshft : ind
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/share/vim/vim74/indent/config.vim                                                               0100644 0000000 0000000 00000004166 13050207306 016167  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:         Autoconf configure.{ac,in} file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2006-12-20
" TODO:             how about nested [()]'s in one line
"                   what's wrong with '\\\@!'?

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif

runtime! indent/sh.vim          " will set b:did_indent

setlocal indentexpr=GetConfigIndent()
setlocal indentkeys=!^F,o,O,=then,=do,=else,=elif,=esac,=fi,=fin,=fil,=done
setlocal nosmartindent

" Only define the function once.
if exists("*GetConfigIndent")
  finish
endif

" get the offset (indent) of the end of the match of 'regexp' in 'line'
function s:GetOffsetOf(line, regexp)
  let end = matchend(a:line, a:regexp)
  let width = 0
  let i = 0
  while i < end
    if a:line[i] != "\t"
      let width = width + 1
    else
      let width = width + &ts - (width % &ts)
    endif
    let i = i + 1
  endwhile
  return width
endfunction

function GetConfigIndent()
  " Find a non-blank line above the current line.
  let lnum = prevnonblank(v:lnum - 1)

  " Hit the start of the file, use zero indent.
  if lnum == 0
    return 0
  endif

  " where to put this
  let ind = GetShIndent()
  let line = getline(lnum)

  " if previous line has unmatched, unescaped opening parentheses,
  " indent to its position. TODO: not failsafe if multiple ('s
  if line =~ '\\\@<!([^)]*$'
    let ind = s:GetOffsetOf(line, '\\\@!(')
  endif

  " if previous line has unmatched opening bracket,
  " indent to its position. TODO: same as above
  if line =~ '\[[^]]*$'
    let ind = s:GetOffsetOf(line, '\[')
  endif

  " if previous line had an unmatched closing parantheses,
  " indent to the matching opening parantheses
  if line =~ '[^(]\+\\\@<!)$'
    call search(')', 'bW')
    let lnum = searchpair('\\\@<!(', '', ')', 'bWn')
    let ind = indent(lnum)
  endif

  " if previous line had an unmatched closing bracket,
  " indent to the matching opening bracket
  if line =~ '[^[]\+]$'
    call search(']', 'bW')
    let lnum = searchpair('\[', '', ']', 'bWn')
    let ind = indent(lnum)
  endif

  return ind
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                          usr/share/vim/vim74/indent/cpp.vim                                                                  0100644 0000000 0000000 00000000511 13050207306 015472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	C++
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2008 Nov 29

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
   finish
endif
let b:did_indent = 1

" C++ indenting is built-in, thus this is very simple
setlocal cindent

let b:undo_indent = "setl cin<"
                                                                                                                                                                                       usr/share/vim/vim74/indent/cs.vim                                                                   0100644 0000000 0000000 00000000507 13050207306 015322  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	C#
" Maintainer:	Johannes Zellner <johannes@zellner.org>
" Last Change:	Fri, 15 Mar 2002 07:53:54 CET

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
   finish
endif
let b:did_indent = 1

" C# is like indenting C
setlocal cindent

let b:undo_indent = "setl cin<"
                                                                                                                                                                                         usr/share/vim/vim74/indent/css.vim                                                                  0100644 0000000 0000000 00000003267 13050207306 015513  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	    CSS
" Maintainer:	    Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2012-05-30

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetCSSIndent()
setlocal indentkeys=0{,0},!^F,o,O
setlocal nosmartindent

let b:undo_indent = "setl smartindent< indentkeys< indentexpr<"

if exists("*GetCSSIndent")
  finish
endif
let s:keepcpo= &cpo
set cpo&vim

function s:prevnonblanknoncomment(lnum)
  let lnum = a:lnum
  while lnum > 1
    let lnum = prevnonblank(lnum)
    let line = getline(lnum)
    if line =~ '\*/'
      while lnum > 1 && line !~ '/\*'
        let lnum -= 1
      endwhile
      if line =~ '^\s*/\*'
        let lnum -= 1
      else
        break
      endif
    else
      break
    endif
  endwhile
  return lnum
endfunction

function s:count_braces(lnum, count_open)
  let n_open = 0
  let n_close = 0
  let line = getline(a:lnum)
  let pattern = '[{}]'
  let i = match(line, pattern)
  while i != -1
    if synIDattr(synID(a:lnum, i + 1, 0), 'name') !~ 'css\%(Comment\|StringQ\{1,2}\)'
      if line[i] == '{'
        let n_open += 1
      elseif line[i] == '}'
        if n_open > 0
          let n_open -= 1
        else
          let n_close += 1
        endif
      endif
    endif
    let i = match(line, pattern, i + 1)
  endwhile
  return a:count_open ? n_open : n_close
endfunction

function GetCSSIndent()
  let line = getline(v:lnum)
  if line =~ '^\s*\*'
    return cindent(v:lnum)
  endif

  let pnum = s:prevnonblanknoncomment(v:lnum - 1)
  if pnum == 0
    return 0
  endif

  return indent(pnum) + s:count_braces(pnum, 1) * &sw
        \ - s:count_braces(v:lnum, 0) * &sw
endfunction

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                                                                                                                         usr/share/vim/vim74/indent/cucumber.vim                                                             0100644 0000000 0000000 00000005100 13050207306 016514  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Cucumber
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2013 May 30

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal autoindent
setlocal indentexpr=GetCucumberIndent()
setlocal indentkeys=o,O,*<Return>,<:>,0<Bar>,0#,=,!^F

let b:undo_indent = 'setl ai< inde< indk<'

" Only define the function once.
if exists("*GetCucumberIndent")
  finish
endif

function! s:syn(lnum)
  return synIDattr(synID(a:lnum,1+indent(a:lnum),1),'name')
endfunction

function! GetCucumberIndent()
  let line  = getline(prevnonblank(v:lnum-1))
  let cline = getline(v:lnum)
  let nline = getline(nextnonblank(v:lnum+1))
  let syn = s:syn(prevnonblank(v:lnum-1))
  let csyn = s:syn(v:lnum)
  let nsyn = s:syn(nextnonblank(v:lnum+1))
  if csyn ==# 'cucumberFeature' || cline =~# '^\s*Feature:'
    " feature heading
    return 0
  elseif csyn ==# 'cucumberExamples' || cline =~# '^\s*\%(Examples\|Scenarios\):'
    " examples heading
    return 2 * &sw
  elseif csyn =~# '^cucumber\%(Background\|Scenario\|ScenarioOutline\)$' || cline =~# '^\s*\%(Background\|Scenario\|Scenario Outline\):'
    " background, scenario or outline heading
    return &sw
  elseif syn ==# 'cucumberFeature' || line =~# '^\s*Feature:'
    " line after feature heading
    return &sw
  elseif syn ==# 'cucumberExamples' || line =~# '^\s*\%(Examples\|Scenarios\):'
    " line after examples heading
    return 3 * &sw
  elseif syn =~# '^cucumber\%(Background\|Scenario\|ScenarioOutline\)$' || line =~# '^\s*\%(Background\|Scenario\|Scenario Outline\):'
    " line after background, scenario or outline heading
    return 2 * &sw
  elseif cline =~# '^\s*[@#]' && (nsyn == 'cucumberFeature' || nline =~# '^\s*Feature:' || indent(prevnonblank(v:lnum-1)) <= 0)
    " tag or comment before a feature heading
    return 0
  elseif cline =~# '^\s*@'
    " other tags
    return &sw
  elseif cline =~# '^\s*[#|]' && line =~# '^\s*|'
    " mid-table
    " preserve indent
    return indent(prevnonblank(v:lnum-1))
  elseif cline =~# '^\s*|' && line =~# '^\s*[^|]'
    " first line of a table, relative indent
    return indent(prevnonblank(v:lnum-1)) + &sw
  elseif cline =~# '^\s*[^|]' && line =~# '^\s*|'
    " line after a table, relative unindent
    return indent(prevnonblank(v:lnum-1)) - &sw
  elseif cline =~# '^\s*#' && getline(v:lnum-1) =~ '^\s*$' && (nsyn =~# '^cucumber\%(Background\|Scenario\|ScenarioOutline\)$' || nline =~# '^\s*\%(Background\|Scenario\|Scenario Outline\):')
    " comments on scenarios
    return &sw
  endif
  return indent(prevnonblank(v:lnum-1))
endfunction

" vim:set sts=2 sw=2:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/share/vim/vim74/indent/cuda.vim                                                                 0100644 0000000 0000000 00000000461 13050207306 015630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	CUDA
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2008 Nov 29

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
   finish
endif
let b:did_indent = 1

" It's just like C indenting
setlocal cindent

let b:undo_indent = "setl cin<"
                                                                                                                                                                                                               usr/share/vim/vim74/indent/d.vim                                                                    0100644 0000000 0000000 00000000776 13050207306 015150  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file for the D programming language (version 0.137).
"
" Language:	D
" Maintainer:	Jason Mills<jmills@cs.mun.ca>
" Last Change:	2005 Nov 22
" Version:	0.1
"
" Please email me with bugs, comments, and suggestion. Put vim in the subject
" to ensure the email will not be marked has spam.
"

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif

let b:did_indent = 1

" D indenting is a lot like the built-in C indenting.
setlocal cindent

" vim: ts=8 noet
  usr/share/vim/vim74/indent/dictconf.vim                                                             0100644 0000000 0000000 00000000505 13050207306 016504  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:         dict(1) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2006-12-20

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentkeys=0{,0},!^F,o,O cinwords= autoindent smartindent
setlocal nosmartindent
inoremap <buffer> # X#
                                                                                                                                                                                           usr/share/vim/vim74/indent/dictdconf.vim                                                            0100644 0000000 0000000 00000000506 13050207306 016651  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:         dictd(8) configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2006-12-20

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentkeys=0{,0},!^F,o,O cinwords= autoindent smartindent
setlocal nosmartindent
inoremap <buffer> # X#
                                                                                                                                                                                          usr/share/vim/vim74/indent/docbk.vim                                                                0100644 0000000 0000000 00000000504 13050207306 015774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	    DocBook Documentation Format
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2006-04-19

if exists("b:did_indent")
  finish
endif

" Same as XML indenting for now.
runtime! indent/xml.vim

if exists('*XmlIndentGet')
  setlocal indentexpr=XmlIndentGet(v:lnum,0)
endif
                                                                                                                                                                                            usr/share/vim/vim74/indent/dtd.vim                                                                  0100644 0000000 0000000 00000026624 13050207306 015500  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	    DTD (Document Type Definition for XML)
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2011-07-08

let s:cpo_save = &cpo
set cpo&vim

setlocal indentexpr=GetDTDIndent()
setlocal indentkeys=!^F,o,O,>
setlocal nosmartindent

if exists("*GetDTDIndent")
  finish
endif

" TODO: Needs to be adjusted to stop at [, <, and ].
let s:token_pattern = '^[^[:space:]]\+'

function s:lex1(input, start, ...)
  let pattern = a:0 > 0 ? a:1 : s:token_pattern
  let start = matchend(a:input, '^\_s*', a:start)
  if start == -1
    return ["", a:start]
  endif
  let end = matchend(a:input, pattern, start)
  if end == -1
    return ["", a:start]
  endif
  let token = strpart(a:input, start, end - start)
  return [token, end]
endfunction

function s:lex(input, start, ...)
  let pattern = a:0 > 0 ? a:1 : s:token_pattern
  let info = s:lex1(a:input, a:start, pattern)
  while info[0] == '--'
    let info = s:lex1(a:input, info[1], pattern)
    while info[0] != "" && info[0] != '--'
      let info = s:lex1(a:input, info[1], pattern)
    endwhile
    if info[0] == ""
      return info
    endif
    let info = s:lex1(a:input, info[1], pattern)
  endwhile
  return info
endfunction

function s:indent_to_innermost_parentheses(line, end)
  let token = '('
  let end = a:end
  let parentheses = [end - 1]
  while token != ""
    let [token, end] = s:lex(a:line, end, '^\%([(),|]\|[A-Za-z0-9_-]\+\|#P\=CDATA\|%[A-Za-z0-9_-]\+;\)[?*+]\=')
    if token[0] == '('
      call add(parentheses, end - 1)
    elseif token[0] == ')'
      if len(parentheses) == 1
        return [-1, end]
      endif
      call remove(parentheses, -1)
    endif
  endwhile
  return [parentheses[-1] - strridx(a:line, "\n", parentheses[-1]), end]
endfunction

" TODO: Line and end could be script global (think OO members).
function GetDTDIndent()
  if v:lnum == 1
    return 0
  endif
  
  " Begin by searching back for a <! that isn’t inside a comment.
  " From here, depending on what follows immediately after, parse to
  " where we’re at to determine what to do.
  if search('<!', 'bceW') == 0
    return indent(v:lnum - 1)
  endif
  let lnum = line('.')
  let col = col('.')
  let indent = indent('.')
  let line = lnum == v:lnum ? getline(lnum) : join(getline(lnum, v:lnum - 1), "\n")

  let [declaration, end] = s:lex1(line, col)
  if declaration == ""
    return indent + &sw
  elseif declaration == '--'
    " We’re looking at a comment.  Now, simply determine if the comment is
    " terminated or not.  If it isn’t, let Vim take care of that using
    " 'comments' and 'autoindent'. Otherwise, indent to the first lines level.
    while declaration != ""
      let [declaration, end] = s:lex(line, end)
      if declaration == "-->"
        return indent
      endif
    endwhile
    return -1
  elseif declaration == 'ELEMENT'
    " Check for element name.  If none exists, indent one level.
    let [name, end] = s:lex(line, end)
    if name == ""
      return indent + &sw
    endif

    " Check for token following element name.  This can be a specification of
    " whether the start or end tag may be omitted.  If nothing is found, indent
    " one level.
    let [token, end] = s:lex(line, end, '^\%([-O(]\|ANY\|EMPTY\)')
    let n = 0
    while token =~ '[-O]' && n < 2
      let [token, end] = s:lex(line, end, '^\%([-O(]\|ANY\|EMPTY\)')
      let n += 1
    endwhile
    if token == ""
      return indent + &sw
    endif

    " Next comes the content model.  If the token we’ve found isn’t a
    " parenthesis it must be either ANY, EMPTY or some random junk.  Either
    " way, we’re done indenting this element, so set it to that of the first
    " line so that the terminating “>” winds up having the same indention.
    if token != '('
      return indent
    endif

    " Now go through the content model.  We need to keep track of the nesting
    " of parentheses.  As soon as we hit 0 we’re done.  If that happens we must
    " have a complete content model.  Thus set indention to be the same as that
    " of the first line so that the terminating “>” winds up having the same
    " indention.  Otherwise, we’ll indent to the innermost parentheses not yet
    " matched.
    let [indent_of_innermost, end] = s:indent_to_innermost_parentheses(line, end)
    if indent_of_innermost != -1
      return indent_of_innermost
    endif

    " Finally, look for any additions and/or exceptions to the content model.
    " This is defined by a “+” or “-” followed by another content model
    " declaration.
    " TODO: Can the “-” be separated by whitespace from the “(”?
    let seen = { '+(': 0, '-(': 0 }
    while 1
      let [additions_exceptions, end] = s:lex(line, end, '^[+-](')
      if additions_exceptions != '+(' && additions_exceptions != '-('
        let [token, end] = s:lex(line, end)
        if token == '>'
          return indent
        endif
        " TODO: Should use s:lex here on getline(v:lnum) and check for >.
        return getline(v:lnum) =~ '^\s*>' || count(values(seen), 0) == 0 ? indent : (indent + &sw)
      endif

      " If we’ve seen an addition or exception already and this is of the same
      " kind, the user is writing a broken DTD.  Time to bail.
      if seen[additions_exceptions]
        return indent
      endif
      let seen[additions_exceptions] = 1

      let [indent_of_innermost, end] = s:indent_to_innermost_parentheses(line, end)
      if indent_of_innermost != -1
        return indent_of_innermost
      endif
    endwhile
  elseif declaration == 'ATTLIST'
    " Check for element name.  If none exists, indent one level.
    let [name, end] = s:lex(line, end)
    if name == ""
      return indent + &sw
    endif

    " Check for any number of attributes.
    while 1
      " Check for attribute name.  If none exists, indent one level, unless the
      " current line is a lone “>”, in which case we indent to the same level
      " as the first line.  Otherwise, if the attribute name is “>”, we have
      " actually hit the end of the attribute list, in which case we indent to
      " the same level as the first line.
      let [name, end] = s:lex(line, end)
      if name == ""
        " TODO: Should use s:lex here on getline(v:lnum) and check for >.
        return getline(v:lnum) =~ '^\s*>' ? indent : (indent + &sw)
      elseif name == ">"
        return indent
      endif

      " Check for attribute value declaration.  If none exists, indent two
      " levels.  Otherwise, if it’s an enumerated value, check for nested
      " parentheses and indent to the innermost one if we don’t reach the end
      " of the listc.  Otherwise, just continue with looking for the default
      " attribute value.
      " TODO: Do validation of keywords
      " (CDATA|NMTOKEN|NMTOKENS|ID|IDREF|IDREFS|ENTITY|ENTITIES)?
      let [value, end] = s:lex(line, end, '^\%((\|[^[:space:]]\+\)')
      if value == ""
        return indent + &sw * 2
      elseif value == 'NOTATION'
        " If this is a enumerated value based on notations, read another token
        " for the actual value.  If it doesn’t exist, indent three levels.
        " TODO: If validating according to above, value must be equal to '('.
        let [value, end] = s:lex(line, end, '^\%((\|[^[:space:]]\+\)')
        if value == ""
          return indent + &sw * 3
        endif
      endif

      if value == '('
        let [indent_of_innermost, end] = s:indent_to_innermost_parentheses(line, end)
        if indent_of_innermost != -1
          return indent_of_innermost
        endif
      endif

      " Finally look for the attribute’s default value.  If non exists, indent
      " two levels.
      let [default, end] = s:lex(line, end, '^\%("\_[^"]*"\|#\(REQUIRED\|IMPLIED\|FIXED\)\)')
      if default == ""
        return indent + &sw * 2
      elseif default == '#FIXED'
        " We need to look for the fixed value.  If non exists, indent three
        " levels.
        let [default, end] = s:lex(line, end, '^"\_[^"]*"')
        if default == ""
          return indent + &sw * 3
        endif
      endif
    endwhile
  elseif declaration == 'ENTITY'
    " Check for entity name.  If none exists, indent one level.  Otherwise, if
    " the name actually turns out to be a percent sign, “%”, this is a
    " parameter entity.  Read another token to determine the entity name and,
    " again, if none exists, indent one level.
    let [name, end] = s:lex(line, end)
    if name == ""
      return indent + &sw
    elseif name == '%'
      let [name, end] = s:lex(line, end)
      if name == ""
        return indent + &sw
      endif
    endif

    " Now check for the entity value.  If none exists, indent one level.  If it
    " does exist, indent to same level as first line, as we’re now done with
    " this entity.
    "
    " The entity value can be a string in single or double quotes (no escapes
    " to worry about, as entities are used instead).  However, it can also be
    " that this is an external unparsed entity.  In that case we have to look
    " further for (possibly) a public ID and an URI followed by the NDATA
    " keyword and the actual notation name.  For the public ID and URI, indent
    " two levels, if they don’t exist.  If the NDATA keyword doesn’t exist,
    " indent one level.  Otherwise, if the actual notation name doesn’t exist,
    " indent two level.  If it does, indent to same level as first line, as
    " we’re now done with this entity.
    let [value, end] = s:lex(line, end)
    if value == ""
      return indent + &sw
    elseif value == 'SYSTEM' || value == 'PUBLIC'
      let [quoted_string, end] = s:lex(line, end, '\%("[^"]\+"\|''[^'']\+''\)')
      if quoted_string == ""
        return indent + &sw * 2
      endif

      if value == 'PUBLIC'
        let [quoted_string, end] = s:lex(line, end, '\%("[^"]\+"\|''[^'']\+''\)')
        if quoted_string == ""
          return indent + &sw * 2
        endif
      endif

      let [ndata, end] = s:lex(line, end)
      if ndata == ""
        return indent + &sw
      endif

      let [name, end] = s:lex(line, end)
      return name == "" ? (indent + &sw * 2) : indent
    else
      return indent
    endif
  elseif declaration == 'NOTATION'
    " Check for notation name.  If none exists, indent one level.
    let [name, end] = s:lex(line, end)
    if name == ""
      return indent + &sw
    endif

    " Now check for the external ID.  If none exists, indent one level.
    let [id, end] = s:lex(line, end)
    if id == ""
      return indent + &sw
    elseif id == 'SYSTEM' || id == 'PUBLIC'
      let [quoted_string, end] = s:lex(line, end, '\%("[^"]\+"\|''[^'']\+''\)')
      if quoted_string == ""
        return indent + &sw * 2
      endif

      if id == 'PUBLIC'
        let [quoted_string, end] = s:lex(line, end, '\%("[^"]\+"\|''[^'']\+''\|>\)')
        if quoted_string == ""
          " TODO: Should use s:lex here on getline(v:lnum) and check for >.
          return getline(v:lnum) =~ '^\s*>' ? indent : (indent + &sw * 2)
        elseif quoted_string == '>'
          return indent
        endif
      endif
    endif

    return indent
  endif

  " TODO: Processing directives could be indented I suppose.  But perhaps it’s
  " just as well to let the user decide how to indent them (perhaps extending
  " this function to include proper support for whatever processing directive
  " language they want to use).

  " Conditional sections are simply passed along to let Vim decide what to do
  " (and hence the user).
  return -1
endfunction

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                            usr/share/vim/vim74/indent/dtrace.vim                                                               0100644 0000000 0000000 00000000703 13050207306 016155  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language: D script as described in "Solaris Dynamic Tracing Guide",
"           http://docs.sun.com/app/docs/doc/817-6223
" Last Change: 2008/03/20
" Version: 1.2
" Maintainer: Nicolas Weber <nicolasweber@gmx.de>

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
   finish
endif
let b:did_indent = 1

" Built-in C indenting works nicely for dtrace.
setlocal cindent

let b:undo_indent = "setl cin<"
                                                             usr/share/vim/vim74/indent/dylan.vim                                                                0100644 0000000 0000000 00000005146 13050207306 016030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Dylan
" Version:	0.01
" Last Change:	2003 Feb 04
" Maintainer:	Brent A. Fulgham <bfulgham@debian.org>

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentkeys+==~begin,=~block,=~case,=~cleanup,=~define,=~end,=~else,=~elseif,=~exception,=~for,=~finally,=~if,=~otherwise,=~select,=~unless,=~while

" Define the appropriate indent function but only once
setlocal indentexpr=DylanGetIndent()
if exists("*DylanGetIndent")
  finish
endif

function DylanGetIndent()
  " Get the line to be indented
  let cline = getline(v:lnum)

  " Don't reindent comments on first column
  if cline =~ '^/\[/\*]'
    return 0
  endif

  "Find the previous non-blank line
  let lnum = prevnonblank(v:lnum - 1)
  "Use zero indent at the top of the file
  if lnum == 0
    return 0
  endif

  let prevline=getline(lnum)
  let ind = indent(lnum)
  let chg = 0

  " If previous line was a comment, use its indent
  if prevline =~ '^\s*//'
    return ind
  endif

  " If previous line was a 'define', indent
  if prevline =~? '\(^\s*\(begin\|block\|case\|define\|else\|elseif\|for\|finally\|if\|select\|unless\|while\)\|\s*\S*\s*=>$\)'
    let chg = &sw
  " local methods indent the shift-width, plus 6 for the 'local'
  elseif prevline =~? '^\s*local'
    let chg = &sw + 6
  " If previous line was a let with no closing semicolon, indent
  elseif prevline =~? '^\s*let.*[^;]\s*$'
    let chg = &sw
  " If previous line opened a parenthesis, and did not close it, indent
  elseif prevline =~ '^.*(\s*[^)]*\((.*)\)*[^)]*$'
    return = match( prevline, '(.*\((.*)\|[^)]\)*.*$') + 1
  "elseif prevline =~ '^.*(\s*[^)]*\((.*)\)*[^)]*$'
  elseif prevline =~ '^[^(]*)\s*$'
    " This line closes a parenthesis.  Find opening
    let curr_line = prevnonblank(lnum - 1)
    while curr_line >= 0
      let str = getline(curr_line)
      if str !~ '^.*(\s*[^)]*\((.*)\)*[^)]*$'
	let curr_line = prevnonblank(curr_line - 1)
      else
	break
      endif
    endwhile
    if curr_line < 0
      return -1
    endif
    let ind = indent(curr_line)
    " Although we found the closing parenthesis, make sure this
    " line doesn't start with an indentable command:
    let curr_str = getline(curr_line)
    if curr_str =~? '^\s*\(begin\|block\|case\|define\|else\|elseif\|for\|finally\|if\|select\|unless\|while\)'
      let chg = &sw
    endif
  endif

  " If a line starts with end, un-indent (even if we just indented!)
  if cline =~? '^\s*\(cleanup\|end\|else\|elseif\|exception\|finally\|otherwise\)'
    let chg = chg - &sw
  endif

  return ind + chg
endfunction

" vim:sw=2 tw=130
                                                                                                                                                                                                                                                                                                                                                                                                                          usr/share/vim/vim74/indent/eiffel.vim                                                               0100644 0000000 0000000 00000006210 13050207306 016144  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Eiffel
" Maintainer:	Jocelyn Fiat <jfiat@eiffel.com>
" Previous-Maintainer:	David Clarke <gadicath@dishevelled.net>
" Contributions from: Thilo Six
" $Date: 2004/12/09 21:33:52 $
" $Revision: 1.3 $
" URL: https://github.com/eiffelhub/vim-eiffel

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetEiffelIndent()
setlocal nolisp
setlocal nosmartindent
setlocal nocindent
setlocal autoindent
setlocal comments=:--
setlocal indentkeys+==end,=else,=ensure,=require,=check,=loop,=until
setlocal indentkeys+==creation,=feature,=inherit,=class,=is,=redefine,=rename,=variant
setlocal indentkeys+==invariant,=do,=local,=export

let b:undo_indent = "setl smartindent< indentkeys< indentexpr< autoindent< comments< "

" Define some stuff
" keywords grouped by indenting
let s:trust_user_indent = '\(+\)\(\s*\(--\).*\)\=$'
let s:relative_indent = '^\s*\(deferred\|class\|feature\|creation\|inherit\|loop\|from\|until\|if\|else\|elseif\|ensure\|require\|check\|do\|local\|invariant\|variant\|rename\|redefine\|do\|export\)\>'
let s:outdent = '^\s*\(else\|invariant\|variant\|do\|require\|until\|loop\|local\)\>'
let s:no_indent = '^\s*\(class\|feature\|creation\|inherit\)\>'
let s:single_dent = '^[^-]\+[[:alnum:]]\+ is\(\s*\(--\).*\)\=$'
let s:inheritance_dent = '\s*\(redefine\|rename\|export\)\>'


" Only define the function once.
if exists("*GetEiffelIndent")
  finish
endif

let s:keepcpo= &cpo
set cpo&vim

function GetEiffelIndent()

  " Eiffel Class indenting
  "
  " Find a non-blank line above the current line.
  let lnum = prevnonblank(v:lnum - 1)

  " At the start of the file use zero indent.
  if lnum == 0
    return 0
  endif

  " trust the user's indenting
  if getline(lnum) =~ s:trust_user_indent
    return -1
  endif

  " Add a 'shiftwidth' after lines that start with an indent word
  let ind = indent(lnum)
  if getline(lnum) =~ s:relative_indent
    let ind = ind + &sw
  endif

  " Indent to single indent
  if getline(v:lnum) =~ s:single_dent && getline(v:lnum) !~ s:relative_indent
	   \ && getline(v:lnum) !~ '\s*\<\(and\|or\|implies\)\>'
     let ind = &sw
  endif

  " Indent to double indent
  if getline(v:lnum) =~ s:inheritance_dent
     let ind = 2 * &sw
  endif

  " Indent line after the first line of the function definition
  if getline(lnum) =~ s:single_dent
     let ind = ind + &sw
  endif

  " The following should always be at the start of a line, no indenting
  if getline(v:lnum) =~ s:no_indent
     let ind = 0
  endif

  " Subtract a 'shiftwidth', if this isn't the first thing after the 'is'
  " or first thing after the 'do'
  if getline(v:lnum) =~ s:outdent && getline(v:lnum - 1) !~ s:single_dent
	\ && getline(v:lnum - 1) !~ '^\s*do\>'
    let ind = ind - &sw
  endif

  " Subtract a shiftwidth for end statements
  if getline(v:lnum) =~ '^\s*end\>'
    let ind = ind - &sw
  endif

  " set indent of zero end statements that are at an indent of 3, this should
  " only ever be the class's end.
  if getline(v:lnum) =~ '^\s*end\>' && ind == &sw
    let ind = 0
  endif

  return ind
endfunction

let &cpo = s:keepcpo
unlet s:keepcpo

" vim:sw=2
                                                                                                                                                                                                                                                                                                                                                                                        usr/share/vim/vim74/indent/erlang.vim                                                               0100644 0000000 0000000 00000132233 13050207306 016167  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:     Erlang (http://www.erlang.org)
" Author:       Csaba Hoch <csaba.hoch@gmail.com>
" Contributors: Edwin Fine <efine145_nospam01 at usa dot net>
"               Pawel 'kTT' Salata <rockplayer.pl@gmail.com>
"               Ricardo Catalinas Jiménez <jimenezrick@gmail.com>
" Last Update:  2013-Jul-21
" License:      Vim license
" URL:          https://github.com/hcs42/vim-erlang

" Note About Usage:
"   This indentation script works best with the Erlang syntax file created by
"   Kreąimir Marľić (Kresimir Marzic) and maintained by Csaba Hoch.

" Notes About Implementation:
"
" - LTI = Line to indent.
" - The index of the first line is 1, but the index of the first column is 0.


" Initialization {{{1
" ==============

" Only load this indent file when no other was loaded
" Vim 7 or later is needed
if exists("b:did_indent") || version < 700
  finish
else
  let b:did_indent = 1
endif

setlocal indentexpr=ErlangIndent()
setlocal indentkeys+=0=end,0=of,0=catch,0=after,0=when,0=),0=],0=},0=>>

" Only define the functions once
if exists("*ErlangIndent")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

" Logging library {{{1
" ===============

" Purpose:
"   Logs the given string using the ErlangIndentLog function if it exists.
" Parameters:
"   s: string
function! s:Log(s)
  if exists("*ErlangIndentLog")
    call ErlangIndentLog(a:s)
  endif
endfunction

" Line tokenizer library {{{1
" ======================

" Indtokens are "indentation tokens".

" Purpose:
"   Calculate the new virtual column after the given segment of a line.
" Parameters:
"   line: string
"   first_index: integer -- the index of the first character of the segment
"   last_index: integer -- the index of the last character of the segment
"   vcol: integer -- the virtual column of the first character of the token
"   tabstop: integer -- the value of the 'tabstop' option to be used
" Returns:
"   vcol: integer
" Example:
"   " index:    0 12 34567
"   " vcol:     0 45 89
"   s:CalcVCol("\t'\tx', b", 1, 4, 4)  -> 10
function! s:CalcVCol(line, first_index, last_index, vcol, tabstop)

  " We copy the relevent segment of the line, otherwise if the line were
  " e.g. `"\t", term` then the else branch below would consume the `", term`
  " part at once.
  let line = a:line[a:first_index : a:last_index]

  let i = 0
  let last_index = a:last_index - a:first_index
  let vcol = a:vcol

  while 0 <= i && i <= last_index

    if line[i] ==# "\t"
      " Example (when tabstop == 4):
      "
      " vcol + tab -> next_vcol
      " 0 + tab -> 4
      " 1 + tab -> 4
      " 2 + tab -> 4
      " 3 + tab -> 4
      " 4 + tab -> 8
      "
      " next_i - i == the number of tabs
      let next_i = matchend(line, '\t*', i + 1)
      let vcol = (vcol / a:tabstop + (next_i - i)) * a:tabstop
      call s:Log('new vcol after tab: '. vcol)
    else
      let next_i = matchend(line, '[^\t]*', i + 1)
      let vcol += next_i - i
      call s:Log('new vcol after other: '. vcol)
    endif
    let i = next_i
  endwhile

  return vcol
endfunction

" Purpose:
"   Go through the whole line and return the tokens in the line.
" Parameters:
"   line: string -- the line to be examined
"   string_continuation: bool
"   atom_continuation: bool
" Returns:
"   indtokens = [indtoken]
"   indtoken = [token, vcol, col]
"   token = string (examples: 'begin', '<variable>', '}')
"   vcol = integer (the virtual column of the first character of the token)
"   col = integer
function! s:GetTokensFromLine(line, string_continuation, atom_continuation,
                             \tabstop)

  let linelen = strlen(a:line) " The length of the line
  let i = 0 " The index of the current character in the line
  let vcol = 0 " The virtual column of the current character
  let indtokens = []

  if a:string_continuation
    let i = matchend(a:line, '^\%([^"\\]\|\\.\)*"', 0)
    if i ==# -1
      call s:Log('    Whole line is string continuation -> ignore')
      return []
    else
      let vcol = s:CalcVCol(a:line, 0, i - 1, 0, a:tabstop)
      call add(indtokens, ['<string_end>', vcol, i])
    endif
  elseif a:atom_continuation
    let i = matchend(a:line, "^\\%([^'\\\\]\\|\\\\.\\)*'", 0)
    if i ==# -1
      call s:Log('    Whole line is quoted atom continuation -> ignore')
      return []
    else
      let vcol = s:CalcVCol(a:line, 0, i - 1, 0, a:tabstop)
      call add(indtokens, ['<quoted_atom_end>', vcol, i])
    endif
  endif

  while 0 <= i && i < linelen

    let next_vcol = ''

    " Spaces
    if a:line[i] ==# ' '
      let next_i = matchend(a:line, ' *', i + 1)

    " Tabs
    elseif a:line[i] ==# "\t"
      let next_i = matchend(a:line, '\t*', i + 1)

      " See example in s:CalcVCol
      let next_vcol = (vcol / a:tabstop + (next_i - i)) * a:tabstop

    " Comment
    elseif a:line[i] ==# '%'
      let next_i = linelen

    " String token: "..."
    elseif a:line[i] ==# '"'
      let next_i = matchend(a:line, '\%([^"\\]\|\\.\)*"', i + 1)
      if next_i ==# -1
        call add(indtokens, ['<string_start>', vcol, i])
      else
        let next_vcol = s:CalcVCol(a:line, i, next_i - 1, vcol, a:tabstop)
        call add(indtokens, ['<string>', vcol, i])
      endif

    " Quoted atom token: '...'
    elseif a:line[i] ==# "'"
      let next_i = matchend(a:line, "\\%([^'\\\\]\\|\\\\.\\)*'", i + 1)
      if next_i ==# -1
        call add(indtokens, ['<quoted_atom_start>', vcol, i])
      else
        let next_vcol = s:CalcVCol(a:line, i, next_i - 1, vcol, a:tabstop)
        call add(indtokens, ['<quoted_atom>', vcol, i])
      endif

    " Keyword or atom or variable token or number
    elseif a:line[i] =~# '[a-zA-Z_@0-9]'
      let next_i = matchend(a:line,
                           \'[[:alnum:]_@:]*\%(\s*#\s*[[:alnum:]_@:]*\)\=',
                           \i + 1)
      call add(indtokens, [a:line[(i):(next_i - 1)], vcol, i])

    " Character token: $<char> (as in: $a)
    elseif a:line[i] ==# '$'
      call add(indtokens, ['$.', vcol, i])
      let next_i = i + 2

    " Dot token: .
    elseif a:line[i] ==# '.'

      let next_i = i + 1

      if i + 1 ==# linelen || a:line[i + 1] =~# '[[:blank:]%]'
        " End of clause token: . (as in: f() -> ok.)
        call add(indtokens, ['<end_of_clause>', vcol, i])

      else
        " Possibilities:
        " - Dot token in float: . (as in: 3.14)
        " - Dot token in record: . (as in: #myrec.myfield)
        call add(indtokens, ['.', vcol, i])
      endif

    " Equal sign
    elseif a:line[i] ==# '='
      " This is handled separately so that "=<<" will be parsed as
      " ['=', '<<'] instead of ['=<', '<']. Although Erlang parses it
      " currently in the latter way, that may be fixed some day.
      call add(indtokens, [a:line[i], vcol, i])
      let next_i = i + 1

    " Three-character tokens
    elseif i + 1 < linelen &&
         \ index(['=:=', '=/='], a:line[i : i + 1]) != -1
      call add(indtokens, [a:line[i : i + 1], vcol, i])
      let next_i = i + 2

    " Two-character tokens
    elseif i + 1 < linelen &&
         \ index(['->', '<<', '>>', '||', '==', '/=', '=<', '>=', '++', '--',
         \        '::'],
         \       a:line[i : i + 1]) != -1
      call add(indtokens, [a:line[i : i + 1], vcol, i])
      let next_i = i + 2

    " Other character: , ; < > ( ) [ ] { } # + - * / : ? = ! |
    else
      call add(indtokens, [a:line[i], vcol, i])
      let next_i = i + 1

    endif

    if next_vcol ==# ''
      let vcol += next_i - i
    else
      let vcol = next_vcol
    endif

    let i = next_i

  endwhile

  return indtokens

endfunction

" TODO: doc, handle "not found" case
function! s:GetIndtokenAtCol(indtokens, col)
  let i = 0
  while i < len(a:indtokens)
    if a:indtokens[i][2] ==# a:col
      return [1, i]
    elseif a:indtokens[i][2] > a:col
      return [0, s:IndentError('No token at col ' . a:col . ', ' .
                              \'indtokens = ' . string(a:indtokens),
                              \'', '')]
    endif
    let i += 1
  endwhile
  return [0, s:IndentError('No token at col ' . a:col . ', ' .
                           \'indtokens = ' . string(a:indtokens),
                           \'', '')]
endfunction

" Stack library {{{1
" =============

" Purpose:
"   Push a token onto the parser's stack.
" Parameters:
"   stack: [token]
"   token: string
function! s:Push(stack, token)
  call s:Log('    Stack Push: "' . a:token . '" into ' . string(a:stack))
  call insert(a:stack, a:token)
endfunction

" Purpose:
"   Pop a token from the parser's stack.
" Parameters:
"   stack: [token]
"   token: string
" Returns:
"   token: string -- the removed element
function! s:Pop(stack)
  let head = remove(a:stack, 0)
  call s:Log('    Stack Pop: "' . head . '" from ' . string(a:stack))
  return head
endfunction

" Library for accessing and storing tokenized lines {{{1
" =================================================

" The Erlang token cache: an `lnum -> indtokens` dictionary that stores the
" tokenized lines.
let s:all_tokens = {}
let s:file_name = ''
let s:last_changedtick = -1

" Purpose:
"   Clear the Erlang token cache if we have a different file or the file has
"   been changed since the last indentation.
function! s:ClearTokenCacheIfNeeded()
  let file_name = expand('%:p')
  if file_name != s:file_name ||
   \ b:changedtick != s:last_changedtick
    let s:file_name = file_name
    let s:last_changedtick = b:changedtick
    let s:all_tokens = {}
  endif
endfunction

" Purpose:
"   Return the tokens of line `lnum`, if that line is not empty. If it is
"   empty, find the first non-empty line in the given `direction` and return
"   the tokens of that line.
" Parameters:
"   lnum: integer
"   direction: 'up' | 'down'
" Returns:
"   result: [] -- the result is an empty list if we hit the beginning or end
"                  of the file
"           | [lnum, indtokens]
"   lnum: integer -- the index of the non-empty line that was found and
"                    tokenized
"   indtokens: [indtoken] -- the tokens of line `lnum`
function! s:TokenizeLine(lnum, direction)

  call s:Log('Tokenizing starts from line ' . a:lnum)
  if a:direction ==# 'up'
    let lnum = prevnonblank(a:lnum)
  else " a:direction ==# 'down'
    let lnum = nextnonblank(a:lnum)
  endif

  " We hit the beginning or end of the file
  if lnum ==# 0
    let indtokens = []
    call s:Log('  We hit the beginning or end of the file.')

    " The line has already been parsed
  elseif has_key(s:all_tokens, lnum)
    let indtokens = s:all_tokens[lnum]
    call s:Log('Cached line ' . lnum . ': ' . getline(lnum))
    call s:Log("  Tokens in the line:\n    - " . join(indtokens, "\n    - "))

    " The line should be parsed now
  else

    " Parse the line
    let line = getline(lnum)
    let string_continuation = s:IsLineStringContinuation(lnum)
    let atom_continuation = s:IsLineAtomContinuation(lnum)
    let indtokens = s:GetTokensFromLine(line, string_continuation,
                                       \atom_continuation, &tabstop)
    let s:all_tokens[lnum] = indtokens
    call s:Log('Tokenizing line ' . lnum . ': ' . line)
    call s:Log("  Tokens in the line:\n    - " . join(indtokens, "\n    - "))

  endif

  return [lnum, indtokens]
endfunction

" Purpose:
"   As a helper function for PrevIndToken and NextIndToken, the FindIndToken
"   function finds the first line with at least one token in the given
"   direction.
" Parameters:
"   lnum: integer
"   direction: 'up' | 'down'
" Returns:
"   result: [] -- the result is an empty list if we hit the beginning or end
"                  of the file
"           | indtoken
function! s:FindIndToken(lnum, dir)
  let lnum = a:lnum
  while 1
    let lnum += (a:dir ==# 'up' ? -1 : 1)
    let [lnum, indtokens] = s:TokenizeLine(lnum, a:dir)
    if lnum ==# 0
      " We hit the beginning or end of the file
      return []
    elseif !empty(indtokens)
      return indtokens[a:dir ==# 'up' ? -1 : 0]
    endif
  endwhile
endfunction

" Purpose:
"   Find the token that directly precedes the given token.
" Parameters:
"   lnum: integer -- the line of the given token
"   i: the index of the given token within line `lnum`
" Returns:
"   result = [] -- the result is an empty list if the given token is the first
"                  token of the file
"          | indtoken
function! s:PrevIndToken(lnum, i)
  call s:Log('    PrevIndToken called: lnum=' . a:lnum . ', i =' . a:i)

  " If the current line has a previous token, return that
  if a:i > 0
    return s:all_tokens[a:lnum][a:i - 1]
  else
    return s:FindIndToken(a:lnum, 'up')
  endif
endfunction

" Purpose:
"   Find the token that directly succeeds the given token.
" Parameters:
"   lnum: integer -- the line of the given token
"   i: the index of the given token within line `lnum`
" Returns:
"   result = [] -- the result is an empty list if the given token is the last
"                  token of the file
"          | indtoken
function! s:NextIndToken(lnum, i)
  call s:Log('    NextIndToken called: lnum=' . a:lnum . ', i =' . a:i)

  " If the current line has a next token, return that
  if len(s:all_tokens[a:lnum]) > a:i + 1
    return s:all_tokens[a:lnum][a:i + 1]
  else
    return s:FindIndToken(a:lnum, 'down')
  endif
endfunction

" ErlangCalcIndent helper functions {{{1
" =================================

" Purpose:
"   This function is called when the parser encounters a syntax error.
"
"   If we encounter a syntax error, we return
"   g:erlang_unexpected_token_indent, which is -1 by default. This means that
"   the indentation of the LTI will not be changed.
" Parameter:
"   msg: string
"   token: string
"   stack: [token]
" Returns:
"   indent: integer
function! s:IndentError(msg, token, stack)
  call s:Log('Indent error: ' . a:msg . ' -> return')
  call s:Log('  Token = ' . a:token . ', ' .
            \'  stack = ' . string(a:stack))
  return g:erlang_unexpected_token_indent
endfunction

" Purpose:
"   This function is called when the parser encounters an unexpected token,
"   and the parser will return the number given back by UnexpectedToken.
"
"   If we encounter an unexpected token, we return
"   g:erlang_unexpected_token_indent, which is -1 by default. This means that
"   the indentation of the LTI will not be changed.
" Parameter:
"   token: string
"   stack: [token]
" Returns:
"   indent: integer
function! s:UnexpectedToken(token, stack)
  call s:Log('    Unexpected token ' . a:token . ', stack = ' .
            \string(a:stack) . ' -> return')
  return g:erlang_unexpected_token_indent
endfunction

if !exists('g:erlang_unexpected_token_indent')
  let g:erlang_unexpected_token_indent = -1
endif

" Purpose:
"   Return whether the given line starts with a string continuation.
" Parameter:
"   lnum: integer
" Returns:
"   result: bool
" Example:
"   f() ->           % IsLineStringContinuation = false
"       "This is a   % IsLineStringContinuation = false
"       multiline    % IsLineStringContinuation = true
"       string".     % IsLineStringContinuation = true
function! s:IsLineStringContinuation(lnum)
  if has('syntax_items')
    return synIDattr(synID(a:lnum, 1, 0), 'name') =~# '^erlangString'
  else
    return 0
  endif
endfunction

" Purpose:
"   Return whether the given line starts with an atom continuation.
" Parameter:
"   lnum: integer
" Returns:
"   result: bool
" Example:
"   'function with   % IsLineAtomContinuation = true, but should be false
"   weird name'() -> % IsLineAtomContinuation = true
"       ok.          % IsLineAtomContinuation = false
function! s:IsLineAtomContinuation(lnum)
  if has('syntax_items')
    return synIDattr(synID(a:lnum, 1, 0), 'name') =~# '^erlangQuotedAtom'
  else
    return 0
  endif
endfunction

" Purpose:
"   Return whether the 'catch' token (which should be the `i`th token in line
"   `lnum`) is standalone or part of a try-catch block, based on the preceding
"   token.
" Parameters:
"   lnum: integer
"   i: integer
" Return:
"   is_standalone: bool
function! s:IsCatchStandalone(lnum, i)
  call s:Log('    IsCatchStandalone called: lnum=' . a:lnum . ', i=' . a:i)
  let prev_indtoken = s:PrevIndToken(a:lnum, a:i)

  " If we hit the beginning of the file, it is not a catch in a try block
  if prev_indtoken == []
    return 1
  endif

  let prev_token = prev_indtoken[0]

  if prev_token =~# '[A-Z_@0-9]'
    let is_standalone = 0
  elseif prev_token =~# '[a-z]'
    if index(['after', 'and', 'andalso', 'band', 'begin', 'bnot', 'bor', 'bsl',
            \ 'bsr', 'bxor', 'case', 'catch', 'div', 'not', 'or', 'orelse',
            \ 'rem', 'try', 'xor'], prev_token) != -1
      " If catch is after these keywords, it is standalone
      let is_standalone = 1
    else
      " If catch is after another keyword (e.g. 'end') or an atom, it is
      " part of try-catch.
      "
      " Keywords:
      " - may precede 'catch': end
      " - may not precede 'catch': fun if of receive when
      " - unused: cond let query
      let is_standalone = 0
    endif
  elseif index([')', ']', '}', '<string>', '<string_end>', '<quoted_atom>',
              \ '<quoted_atom_end>', '$.'], prev_token) != -1
    let is_standalone = 0
  else
    " This 'else' branch includes the following tokens:
    "   -> == /= =< < >= > =:= =/= + - * / ++ -- :: < > ; ( [ { ? = ! . |
    let is_standalone = 1
  endif

  call s:Log('   "catch" preceded by "' . prev_token  . '" -> catch ' .
            \(is_standalone ? 'is standalone' : 'belongs to try-catch'))
  return is_standalone

endfunction

" Purpose:
"   This function is called when a begin-type element ('begin', 'case',
"   '[', '<<', etc.) is found. It asks the caller to return if the stack
" Parameters:
"   stack: [token]
"   token: string
"   curr_vcol: integer
"   stored_vcol: integer
"   sw: integer -- number of spaces to be used after the begin element as
"                  indentation
" Returns:
"   result: [should_return, indent]
"   should_return: bool -- if true, the caller should return `indent` to Vim
"   indent -- integer
function! s:BeginElementFoundIfEmpty(stack, token, curr_vcol, stored_vcol, sw)
  if empty(a:stack)
    if a:stored_vcol ==# -1
      call s:Log('    "' . a:token . '" directly preceeds LTI -> return')
      return [1, a:curr_vcol + a:sw]
    else
      call s:Log('    "' . a:token .
                \'" token (whose expression includes LTI) found -> return')
      return [1, a:stored_vcol]
    endif
  else
    return [0, 0]
  endif
endfunction

" Purpose:
"   This function is called when a begin-type element ('begin', 'case', '[',
"   '<<', etc.) is found, and in some cases when 'after' and 'when' is found.
"   It asks the caller to return if the stack is already empty.
" Parameters:
"   stack: [token]
"   token: string
"   curr_vcol: integer
"   stored_vcol: integer
"   end_token: end token that belongs to the begin element found (e.g. if the
"              begin element is 'begin', the end token is 'end')
"   sw: integer -- number of spaces to be used after the begin element as
"                  indentation
" Returns:
"   result: [should_return, indent]
"   should_return: bool -- if true, the caller should return `indent` to Vim
"   indent -- integer
function! s:BeginElementFound(stack, token, curr_vcol, stored_vcol, end_token, sw)

  " Return 'return' if the stack is empty
  let [ret, res] = s:BeginElementFoundIfEmpty(a:stack, a:token, a:curr_vcol,
                                             \a:stored_vcol, a:sw)
  if ret | return [ret, res] | endif

  if a:stack[0] ==# a:end_token
    call s:Log('    "' . a:token . '" pops "' . a:end_token . '"')
    call s:Pop(a:stack)
    if !empty(a:stack) && a:stack[0] ==# 'align_to_begin_element'
      call s:Pop(a:stack)
      if empty(a:stack)
        return [1, a:curr_vcol]
      else
        return [1, s:UnexpectedToken(a:token, a:stack)]
      endif
    else
      return [0, 0]
    endif
  else
    return [1, s:UnexpectedToken(a:token, a:stack)]
  endif
endfunction

" Purpose:
"   This function is called when we hit the beginning of a file or an
"   end-of-clause token -- i.e. when we found the beginning of the current
"   clause.
"
"   If the stack contains an '->' or 'when', this means that we can return
"   now, since we were looking for the beginning of the clause.
" Parameters:
"   stack: [token]
"   token: string
"   stored_vcol: integer
" Returns:
"   result: [should_return, indent]
"   should_return: bool -- if true, the caller should return `indent` to Vim
"   indent -- integer
function! s:BeginningOfClauseFound(stack, token, stored_vcol)
  if !empty(a:stack) && a:stack[0] ==# 'when'
    call s:Log('    BeginningOfClauseFound: "when" found in stack')
    call s:Pop(a:stack)
    if empty(a:stack)
      call s:Log('    Stack is ["when"], so LTI is in a guard -> return')
      return [1, a:stored_vcol + &sw + 2]
    else
      return [1, s:UnexpectedToken(a:token, a:stack)]
    endif
  elseif !empty(a:stack) && a:stack[0] ==# '->'
    call s:Log('    BeginningOfClauseFound: "->" found in stack')
    call s:Pop(a:stack)
    if empty(a:stack)
      call s:Log('    Stack is ["->"], so LTI is in function body -> return')
      return [1, a:stored_vcol + &sw]
    elseif a:stack[0] ==# ';'
      call s:Pop(a:stack)
      if empty(a:stack)
        call s:Log('    Stack is ["->", ";"], so LTI is in a function head ' .
                  \'-> return')
        return [0, a:stored_vcol]
      else
        return [1, s:UnexpectedToken(a:token, a:stack)]
      endif
    else
      return [1, s:UnexpectedToken(a:token, a:stack)]
    endif
  else
    return [0, 0]
  endif
endfunction

let g:erlang_indent_searchpair_timeout = 2000

" TODO
function! s:SearchPair(lnum, curr_col, start, middle, end)
  call cursor(a:lnum, a:curr_col + 1)
  let [lnum_new, col1_new] = 
      \searchpairpos(a:start, a:middle, a:end, 'bW',
                    \'synIDattr(synID(line("."), col("."), 0), "name") ' .
                    \'=~? "string\\|quotedatom\\|todo\\|comment\\|' . 
                    \'erlangmodifier"',
                    \0, g:erlang_indent_searchpair_timeout)
  return [lnum_new, col1_new - 1]
endfunction

function! s:SearchEndPair(lnum, curr_col)
  return s:SearchPair(
         \ a:lnum, a:curr_col,
         \ '\C\<\%(case\|try\|begin\|receive\|if\)\>\|' .
         \ '\<fun\>\%(\s\|\n\|%.*$\)*(',
         \ '',
         \ '\<end\>')
endfunction

" ErlangCalcIndent {{{1
" ================

" Purpose:
"   Calculate the indentation of the given line.
" Parameters:
"   lnum: integer -- index of the line for which the indentation should be
"                    calculated
"   stack: [token] -- initial stack
" Return:
"   indent: integer -- if -1, that means "don't change the indentation";
"                      otherwise it means "indent the line with `indent`
"                      number of spaces or equivalent tabs"
function! s:ErlangCalcIndent(lnum, stack)
  let res = s:ErlangCalcIndent2(a:lnum, a:stack)
  call s:Log("ErlangCalcIndent returned: " . res)
  return res
endfunction

function! s:ErlangCalcIndent2(lnum, stack)

  let lnum = a:lnum
  let stored_vcol = -1 " Virtual column of the first character of the token that
                   " we currently think we might align to.
  let mode = 'normal'
  let stack = a:stack
  let semicolon_abscol = ''

  " Walk through the lines of the buffer backwards (starting from the
  " previous line) until we can decide how to indent the current line.
  while 1

    let [lnum, indtokens] = s:TokenizeLine(lnum, 'up')

    " Hit the start of the file
    if lnum ==# 0
      let [ret, res] = s:BeginningOfClauseFound(stack, 'beginning_of_file',
                                               \stored_vcol)
      if ret | return res | endif

      return 0
    endif

    let i = len(indtokens) - 1
    let last_token_of_line = 1

    while i >= 0

      let [token, curr_vcol, curr_col] = indtokens[i]
      call s:Log('  Analyzing the following token: ' . string(indtokens[i]))

      if len(stack) > 256 " TODO: magic number
        return s:IndentError('Stack too long', token, stack)
      endif

      if token ==# '<end_of_clause>'
        let [ret, res] = s:BeginningOfClauseFound(stack, token, stored_vcol)
        if ret | return res | endif

        if stored_vcol ==# -1
          call s:Log('    End of clause directly preceeds LTI -> return')
          return 0
        else
          call s:Log('    End of clause (but not end of line) -> return')
          return stored_vcol
        endif

      elseif stack == ['prev_term_plus']
        if token =~# '[a-zA-Z_@]' ||
         \ token ==# '<string>' || token ==# '<string_start>' ||
         \ token ==# '<quoted_atom>' || token ==# '<quoted_atom_start>'
          call s:Log('    previous token found: curr_vcol + plus = ' .
                    \curr_vcol . " + " . plus)
          return curr_vcol + plus
        endif

      elseif token ==# 'begin'
        let [ret, res] = s:BeginElementFound(stack, token, curr_vcol,
                                            \stored_vcol, 'end', &sw)
        if ret | return res | endif

      " case EXPR of BRANCHES end
      " try EXPR catch BRANCHES end
      " try EXPR after BODY end
      " try EXPR catch BRANCHES after BODY end
      " try EXPR of BRANCHES catch BRANCHES end
      " try EXPR of BRANCHES after BODY end
      " try EXPR of BRANCHES catch BRANCHES after BODY end
      " receive BRANCHES end
      " receive BRANCHES after BRANCHES end

      " This branch is not Emacs-compatible
      elseif (index(['of', 'receive', 'after', 'if'], token) != -1 ||
           \  (token ==# 'catch' && !s:IsCatchStandalone(lnum, i))) &&
           \ !last_token_of_line &&
           \ (empty(stack) || stack ==# ['when'] || stack ==# ['->'] ||
           \  stack ==# ['->', ';'])

        " If we are after of/receive, but these are not the last
        " tokens of the line, we want to indent like this:
        "
        "   % stack == []
        "   receive stored_vcol,
        "           LTI
        "
        "   % stack == ['->', ';']
        "   receive stored_vcol ->
        "               B;
        "           LTI
        "
        "   % stack == ['->']
        "   receive stored_vcol ->
        "               LTI
        "
        "   % stack == ['when']
        "   receive stored_vcol when
        "               LTI

        " stack = []  =>  LTI is a condition
        " stack = ['->']  =>  LTI is a branch
        " stack = ['->', ';']  =>  LTI is a condition
        " stack = ['when']  =>  LTI is a guard
        if empty(stack) || stack == ['->', ';']
          call s:Log('    LTI is in a condition after ' .
                    \'"of/receive/after/if/catch" -> return')
          return stored_vcol
        elseif stack == ['->']
          call s:Log('    LTI is in a branch after ' .
                    \'"of/receive/after/if/catch" -> return')
          return stored_vcol + &sw
        elseif stack == ['when']
          call s:Log('    LTI is in a guard after ' .
                    \'"of/receive/after/if/catch" -> return')
          return stored_vcol + &sw
        else
          return s:UnexpectedToken(token, stack)
        endif

      elseif index(['case', 'if', 'try', 'receive'], token) != -1

        " stack = []  =>  LTI is a condition
        " stack = ['->']  =>  LTI is a branch
        " stack = ['->', ';']  =>  LTI is a condition
        " stack = ['when']  =>  LTI is in a guard
        if empty(stack)
          " pass
        elseif (token ==# 'case' && stack[0] ==# 'of') ||
             \ (token ==# 'if') ||
             \ (token ==# 'try' && (stack[0] ==# 'of' ||
             \                     stack[0] ==# 'catch' ||
             \                     stack[0] ==# 'after')) ||
             \ (token ==# 'receive')

          " From the indentation point of view, the keyword
          " (of/catch/after/end) before the LTI is what counts, so
          " when we reached these tokens, and the stack already had
          " a catch/after/end, we didn't modify it.
          "
          " This way when we reach case/try/receive (i.e. now),
          " there is at most one of/catch/after/end token in the
          " stack.
          if token ==# 'case' || token ==# 'try' ||
           \ (token ==# 'receive' && stack[0] ==# 'after')
            call s:Pop(stack)
          endif

          if empty(stack)
            call s:Log('    LTI is in a condition; matching ' .
                      \'"case/if/try/receive" found')
            let stored_vcol = curr_vcol + &sw
          elseif stack[0] ==# 'align_to_begin_element'
            call s:Pop(stack)
            let stored_vcol = curr_vcol
          elseif len(stack) > 1 && stack[0] ==# '->' && stack[1] ==# ';'
            call s:Log('    LTI is in a condition; matching ' .
                      \'"case/if/try/receive" found')
            call s:Pop(stack)
            call s:Pop(stack)
            let stored_vcol = curr_vcol + &sw
          elseif stack[0] ==# '->'
            call s:Log('    LTI is in a branch; matching ' .
                      \'"case/if/try/receive" found')
            call s:Pop(stack)
            let stored_vcol = curr_vcol + 2 * &sw
          elseif stack[0] ==# 'when'
            call s:Log('    LTI is in a guard; matching ' .
                      \'"case/if/try/receive" found')
            call s:Pop(stack)
            let stored_vcol = curr_vcol + 2 * &sw + 2
          endif

        endif

        let [ret, res] = s:BeginElementFound(stack, token, curr_vcol,
                                            \stored_vcol, 'end', &sw)
        if ret | return res | endif

      elseif token ==# 'fun'
        let next_indtoken = s:NextIndToken(lnum, i)
        call s:Log('    Next indtoken = ' . string(next_indtoken))

        if !empty(next_indtoken) && next_indtoken[0] ==# '('
          " We have an anonymous function definition
          " (e.g. "fun () -> ok end")

          " stack = []  =>  LTI is a condition
          " stack = ['->']  =>  LTI is a branch
          " stack = ['->', ';']  =>  LTI is a condition
          " stack = ['when']  =>  LTI is in a guard
          if empty(stack)
            call s:Log('    LTI is in a condition; matching "fun" found')
            let stored_vcol = curr_vcol + &sw
          elseif len(stack) > 1 && stack[0] ==# '->' && stack[1] ==# ';'
            call s:Log('    LTI is in a condition; matching "fun" found')
            call s:Pop(stack)
            call s:Pop(stack)
          elseif stack[0] ==# '->'
            call s:Log('    LTI is in a branch; matching "fun" found')
            call s:Pop(stack)
            let stored_vcol = curr_vcol + 2 * &sw
          elseif stack[0] ==# 'when'
            call s:Log('    LTI is in a guard; matching "fun" found')
            call s:Pop(stack)
            let stored_vcol = curr_vcol + 2 * &sw + 2
          endif

          let [ret, res] = s:BeginElementFound(stack, token, curr_vcol,
                                              \stored_vcol, 'end', &sw)
          if ret | return res | endif
        else
          " Pass: we have a function reference (e.g. "fun f/0")
        endif

      elseif token ==# '['
        " Emacs compatibility
        let [ret, res] = s:BeginElementFound(stack, token, curr_vcol,
                                            \stored_vcol, ']', 1)
        if ret | return res | endif

      elseif token ==# '<<'
        " Emacs compatibility
        let [ret, res] = s:BeginElementFound(stack, token, curr_vcol,
                                            \stored_vcol, '>>', 2)
        if ret | return res | endif

      elseif token ==# '(' || token ==# '{'

        let end_token = (token ==# '(' ? ')' :
                        \token ==# '{' ? '}' : 'error')

        if empty(stack)
          " We found the opening paren whose block contains the LTI.
          let mode = 'inside'
        elseif stack[0] ==# end_token
          call s:Log('    "' . token . '" pops "' . end_token . '"')
          call s:Pop(stack)

          if !empty(stack) && stack[0] ==# 'align_to_begin_element'
            " We found the opening paren whose closing paren
            " starts LTI
            let mode = 'align_to_begin_element'
          else
            " We found the opening pair for a closing paren that
            " was already in the stack.
            let mode = 'outside'
          endif
        else
          return s:UnexpectedToken(token, stack)
        endif

        if mode ==# 'inside' || mode ==# 'align_to_begin_element'

          if last_token_of_line && i != 0
            " Examples: {{{
            "
            " mode == 'inside':
            "
            "     my_func(
            "       LTI
            "
            "     [Variable, {
            "        LTI
            "
            " mode == 'align_to_begin_element':
            "
            "     my_func(
            "       Params
            "      ) % LTI
            "
            "     [Variable, {
            "        Terms
            "       } % LTI
            " }}}
            let stack = ['prev_term_plus']
            let plus = (mode ==# 'inside' ? 2 : 1)
            call s:Log('    "' . token .
                      \'" token found at end of line -> find previous token')
          elseif mode ==# 'align_to_begin_element'
            " Examples: {{{
            "
            " mode == 'align_to_begin_element' && !last_token_of_line
            "
            "     my_func(stored_vcol
            "            ) % LTI
            "
            "     [Variable, {stored_vcol
            "                } % LTI
            "
            " mode == 'align_to_begin_element' && i == 0
            "
            "     (
            "       stored_vcol
            "     ) % LTI
            "
            "     {
            "       stored_vcol
            "     } % LTI
            " }}}
            call s:Log('    "' . token . '" token (whose closing token ' .
                      \'starts LTI) found -> return')
            return curr_vcol
          elseif stored_vcol ==# -1
            " Examples: {{{
            "
            " mode == 'inside' && stored_vcol == -1 && !last_token_of_line
            "
            "     my_func(
            "             LTI
            "     [Variable, {
            "                 LTI
            "
            " mode == 'inside' && stored_vcol == -1 && i == 0
            "
            "     (
            "      LTI
            "
            "     {
            "      LTI
            " }}}
            call s:Log('    "' . token .
                      \'" token (which directly precedes LTI) found -> return')
            return curr_vcol + 1
          else
            " Examples: {{{
            "
            " mode == 'inside' && stored_vcol != -1 && !last_token_of_line
            "
            "     my_func(stored_vcol,
            "             LTI
            "
            "     [Variable, {stored_vcol,
            "                 LTI
            "
            " mode == 'inside' && stored_vcol != -1 && i == 0
            "
            "     (stored_vcol,
            "      LTI
            "
            "     {stored_vcol,
            "      LTI
            " }}}
            call s:Log('    "' . token .
                      \'" token (whose block contains LTI) found -> return')
            return stored_vcol
          endif
        endif

      elseif index(['end', ')', ']', '}', '>>'], token) != -1

        " If we can be sure that there is synchronization in the Erlang
        " syntax, we use searchpair to make the script quicker. Otherwise we
        " just push the token onto the stack and keep parsing.
    
        " No synchronization -> no searchpair optimization
        if !exists('b:erlang_syntax_synced')
          call s:Push(stack, token)

        " We don't have searchpair optimization for '>>'
        elseif token ==# '>>'
          call s:Push(stack, token)

        elseif token ==# 'end'
          let [lnum_new, col_new] = s:SearchEndPair(lnum, curr_col)

          if lnum_new ==# 0
            return s:IndentError('Matching token for "end" not found',
                                \token, stack)
          else
            if lnum_new != lnum
              call s:Log('    Tokenize for "end" <<<<')
              let [lnum, indtokens] = s:TokenizeLine(lnum_new, 'up')
              call s:Log('    >>>> Tokenize for "end"')
            endif

            let [success, i] = s:GetIndtokenAtCol(indtokens, col_new)
            if !success | return i | endif
            let [token, curr_vcol, curr_col] = indtokens[i]
            call s:Log('    Match for "end" in line ' . lnum_new . ': ' .
                      \string(indtokens[i]))
          endif

        else " token is one of the following: ')', ']', '}'

          call s:Push(stack, token)

          " We have to escape '[', because this string will be interpreted as a
          " regexp
          let open_paren = (token ==# ')' ? '(' :
                           \token ==# ']' ? '\[' :
                           \               '{')

          let [lnum_new, col_new] = s:SearchPair(lnum, curr_col,
                                                \open_paren, '', token)

          if lnum_new ==# 0
            return s:IndentError('Matching token not found',
                                \token, stack)
          else
            if lnum_new != lnum
              call s:Log('    Tokenize the opening paren <<<<')
              let [lnum, indtokens] = s:TokenizeLine(lnum_new, 'up')
              call s:Log('    >>>>')
            endif

            let [success, i] = s:GetIndtokenAtCol(indtokens, col_new)
            if !success | return i | endif
            let [token, curr_vcol, curr_col] = indtokens[i]
            call s:Log('    Match in line ' . lnum_new . ': ' .
                      \string(indtokens[i]))

            " Go back to the beginning of the loop and handle the opening paren
            continue
          endif
        endif

      elseif token ==# ';'

        if empty(stack)
          call s:Push(stack, ';')
        elseif index([';', '->', 'when', 'end', 'after', 'catch'],
                    \stack[0]) != -1
          " Pass:
          "
          " - If the stack top is another ';', then one ';' is
          "   enough.
          " - If the stack top is an '->' or a 'when', then we
          "   should keep that, because they signify the type of the
          "   LTI (branch, condition or guard).
          " - From the indentation point of view, the keyword
          "   (of/catch/after/end) before the LTI is what counts, so
          "   if the stack already has a catch/after/end, we don't
          "   modify it. This way when we reach case/try/receive,
          "   there will be at most one of/catch/after/end token in
          "   the stack.
        else
          return s:UnexpectedToken(token, stack)
        endif

      elseif token ==# '->'

        if empty(stack) && !last_token_of_line
          call s:Log('    LTI is in expression after arrow -> return')
          return stored_vcol
        elseif empty(stack) || stack[0] ==# ';' || stack[0] ==# 'end'
          " stack = [';']  -> LTI is either a branch or in a guard
          " stack = ['->']  ->  LTI is a condition
          " stack = ['->', ';']  -> LTI is a branch
          call s:Push(stack, '->')
        elseif index(['->', 'when', 'end', 'after', 'catch'], stack[0]) != -1
          " Pass:
          "
          " - If the stack top is another '->', then one '->' is
          "   enough.
          " - If the stack top is a 'when', then we should keep
          "   that, because this signifies that LTI is a in a guard.
          " - From the indentation point of view, the keyword
          "   (of/catch/after/end) before the LTI is what counts, so
          "   if the stack already has a catch/after/end, we don't
          "   modify it. This way when we reach case/try/receive,
          "   there will be at most one of/catch/after/end token in
          "   the stack.
        else
          return s:UnexpectedToken(token, stack)
        endif

      elseif token ==# 'when'

        " Pop all ';' from the top of the stack
        while !empty(stack) && stack[0] ==# ';'
          call s:Pop(stack)
        endwhile

        if empty(stack)
          if semicolon_abscol != ''
            let stored_vcol = semicolon_abscol
          endif
          if !last_token_of_line
            " Example:
            "   when A,
            "        LTI
            let [ret, res] = s:BeginElementFoundIfEmpty(stack, token, curr_vcol,
                                                       \stored_vcol, &sw)
            if ret | return res | endif
          else
            " Example:
            "   when
            "       LTI
            call s:Push(stack, token)
          endif
        elseif index(['->', 'when', 'end', 'after', 'catch'], stack[0]) != -1
          " Pass:
          " - If the stack top is another 'when', then one 'when' is
          "   enough.
          " - If the stack top is an '->' or a 'when', then we
          "   should keep that, because they signify the type of the
          "   LTI (branch, condition or guard).
          " - From the indentation point of view, the keyword
          "   (of/catch/after/end) before the LTI is what counts, so
          "   if the stack already has a catch/after/end, we don't
          "   modify it. This way when we reach case/try/receive,
          "   there will be at most one of/catch/after/end token in
          "   the stack.
        else
          return s:UnexpectedToken(token, stack)
        endif

      elseif token ==# 'of' || token ==# 'after' ||
           \ (token ==# 'catch' && !s:IsCatchStandalone(lnum, i))

        if token ==# 'after'
          " If LTI is between an 'after' and the corresponding
          " 'end', then let's return
          let [ret, res] = s:BeginElementFoundIfEmpty(stack, token, curr_vcol,
                                                     \stored_vcol, &sw)
          if ret | return res | endif
        endif

        if empty(stack) || stack[0] ==# '->' || stack[0] ==# 'when'
          call s:Push(stack, token)
        elseif stack[0] ==# 'catch' || stack[0] ==# 'after' || stack[0] ==# 'end'
          " Pass: From the indentation point of view, the keyword
          " (of/catch/after/end) before the LTI is what counts, so
          " if the stack already has a catch/after/end, we don't
          " modify it. This way when we reach case/try/receive,
          " there will be at most one of/catch/after/end token in
          " the stack.
        else
          return s:UnexpectedToken(token, stack)
        endif

      elseif token ==# '||' && empty(stack) && !last_token_of_line

        call s:Log('    LTI is in expression after "||" -> return')
        return stored_vcol

      else
        call s:Log('    Misc token, stack unchanged = ' . string(stack))

      endif

      if empty(stack) || stack[0] ==# '->' || stack[0] ==# 'when'
        let stored_vcol = curr_vcol
        let semicolon_abscol = ''
        call s:Log('    Misc token when the stack is empty or has "->" ' .
                  \'-> setting stored_vcol to ' . stored_vcol)
      elseif stack[0] ==# ';'
        let semicolon_abscol = curr_vcol
        call s:Log('    Setting semicolon-stored_vcol to ' . stored_vcol)
      endif

      let i -= 1
      call s:Log('    Token processed. stored_vcol=' . stored_vcol)

      let last_token_of_line = 0

    endwhile " iteration on tokens in a line

    call s:Log('  Line analyzed. stored_vcol=' . stored_vcol)

    if empty(stack) && stored_vcol != -1 &&
     \ (!empty(indtokens) && indtokens[0][0] != '<string_end>' &&
     \                       indtokens[0][0] != '<quoted_atom_end>')
      call s:Log('    Empty stack at the beginning of the line -> return')
      return stored_vcol
    endif

    let lnum -= 1

  endwhile " iteration on lines

endfunction

" ErlangIndent function {{{1
" =====================

function! ErlangIndent()

  call s:ClearTokenCacheIfNeeded()

  let currline = getline(v:lnum)
  call s:Log('Indenting line ' . v:lnum . ': ' . currline)

  if s:IsLineStringContinuation(v:lnum) || s:IsLineAtomContinuation(v:lnum)
    call s:Log('String or atom continuation found -> ' .
              \'leaving indentation unchanged')
    return -1
  endif

  let ml = matchlist(currline,
                    \'^\(\s*\)\(\%(end\|of\|catch\|after\)\>\|[)\]}]\|>>\)')

  " If the line has a special beginning, but not a standalone catch
  if !empty(ml) && !(ml[2] ==# 'catch' && s:IsCatchStandalone(v:lnum, 0))

    let curr_col = len(ml[1])

    " If we can be sure that there is synchronization in the Erlang
    " syntax, we use searchpair to make the script quicker.
    if ml[2] ==# 'end' && exists('b:erlang_syntax_synced')

      let [lnum, col] = s:SearchEndPair(v:lnum, curr_col)

      if lnum ==# 0
        return s:IndentError('Matching token for "end" not found',
                            \'end', [])
      else
        call s:Log('    Tokenize for "end" <<<<')
        let [lnum, indtokens] = s:TokenizeLine(lnum, 'up')
        call s:Log('    >>>> Tokenize for "end"')

        let [success, i] = s:GetIndtokenAtCol(indtokens, col)
        if !success | return i | endif
        let [token, curr_vcol, curr_col] = indtokens[i]
        call s:Log('    Match for "end" in line ' . lnum . ': ' .
                   \string(indtokens[i]))
        return curr_vcol
      endif

    else

      call s:Log("  Line type = 'end'")
      let new_col = s:ErlangCalcIndent(v:lnum - 1,
                                      \[ml[2], 'align_to_begin_element'])
    endif
  else
    call s:Log("  Line type = 'normal'")

    let new_col = s:ErlangCalcIndent(v:lnum - 1, [])
    if currline =~# '^\s*when\>'
      let new_col += 2
    endif
  endif

  if new_col < -1
    call s:Log('WARNING: returning new_col == ' . new_col)
    return g:erlang_unexpected_token_indent
  endif

  return new_col

endfunction

" Cleanup {{{1
" =======

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: sw=2 et fdm=marker
                                                                                                                                                                                                                                                                                                                                                                     usr/share/vim/vim74/indent/eruby.vim                                                                0100644 0000000 0000000 00000004161 13050207306 016043  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:		eRuby
" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
" URL:			https://github.com/vim-ruby/vim-ruby
" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>

if exists("b:did_indent")
  finish
endif

runtime! indent/ruby.vim
unlet! b:did_indent
setlocal indentexpr=

if exists("b:eruby_subtype")
  exe "runtime! indent/".b:eruby_subtype.".vim"
else
  runtime! indent/html.vim
endif
unlet! b:did_indent

if &l:indentexpr == ''
  if &l:cindent
    let &l:indentexpr = 'cindent(v:lnum)'
  else
    let &l:indentexpr = 'indent(prevnonblank(v:lnum-1))'
  endif
endif
let b:eruby_subtype_indentexpr = &l:indentexpr

let b:did_indent = 1

setlocal indentexpr=GetErubyIndent()
setlocal indentkeys=o,O,*<Return>,<>>,{,},0),0],o,O,!^F,=end,=else,=elsif,=rescue,=ensure,=when

" Only define the function once.
if exists("*GetErubyIndent")
  finish
endif

function! GetErubyIndent(...)
  if a:0 && a:1 == '.'
    let v:lnum = line('.')
  elseif a:0 && a:1 =~ '^\d'
    let v:lnum = a:1
  endif
  let vcol = col('.')
  call cursor(v:lnum,1)
  let inruby = searchpair('<%','','%>','W')
  call cursor(v:lnum,vcol)
  if inruby && getline(v:lnum) !~ '^<%\|^\s*[-=]\=%>'
    let ind = GetRubyIndent(v:lnum)
  else
    exe "let ind = ".b:eruby_subtype_indentexpr
  endif
  let lnum = prevnonblank(v:lnum-1)
  let line = getline(lnum)
  let cline = getline(v:lnum)
  if cline =~# '^\s*<%[-=]\=\s*\%(}\|end\|else\|\%(ensure\|rescue\|elsif\|when\).\{-\}\)\s*\%([-=]\=%>\|$\)'
    let ind = ind - &sw
  endif
  if line =~# '\S\s*<%[-=]\=\s*\%(}\|end\).\{-\}\s*\%([-=]\=%>\|$\)'
    let ind = ind - &sw
  endif
  if line =~# '\%({\|\<do\)\%(\s*|[^|]*|\)\=\s*[-=]\=%>'
    let ind = ind + &sw
  elseif line =~# '<%[-=]\=\s*\%(module\|class\|def\|if\|for\|while\|until\|else\|elsif\|case\|when\|unless\|begin\|ensure\|rescue\)\>.*%>'
    let ind = ind + &sw
  endif
  if line =~# '^\s*<%[=#-]\=\s*$' && cline !~# '^\s*end\>'
    let ind = ind + &sw
  endif
  if line !~# '^\s*<%' && line =~# '%>\s*$'
    let ind = ind - &sw
  endif
  if cline =~# '^\s*[-=]\=%>\s*$'
    let ind = ind - &sw
  endif
  return ind
endfunction

" vim:set sw=2 sts=2 ts=8 noet:
                                                                                                                                                                                                                                                                                                                                                                                                               usr/share/vim/vim74/indent/eterm.vim                                                                0100644 0000000 0000000 00000001176 13050207306 016034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:         Eterm configuration file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2006-12-20

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetEtermIndent()
setlocal indentkeys=!^F,o,O,=end
setlocal nosmartindent

if exists("*GetEtermIndent")
  finish
endif

function GetEtermIndent()
  let lnum = prevnonblank(v:lnum - 1)
  if lnum == 0
    return 0
  endif

  let ind = indent(lnum)

  if getline(lnum) =~ '^\s*begin\>'
    let ind = ind + &sw
  endif

  if getline(v:lnum) =~ '^\s*end\>'
    let ind = ind - &sw
  endif

  return ind
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                  usr/share/vim/vim74/indent/falcon.vim                                                               0100644 0000000 0000000 00000033236 13050207306 016164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language: Falcon
" Maintainer: Steven Oliver <oliver.steven@gmail.com>
" Website: https://steveno@github.com/steveno/falconpl-vim.git
" Credits: This is, to a great extent, a copy n' paste of ruby.vim.

" 1. Setup {{{1
" ============

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif
let b:did_indent = 1

setlocal nosmartindent

" Setup indent function and when to use it
setlocal indentexpr=FalconGetIndent(v:lnum)
setlocal indentkeys=0{,0},0),0],!^F,o,O,e
setlocal indentkeys+==~case,=~catch,=~default,=~elif,=~else,=~end,=~\"

" Define the appropriate indent function but only once
if exists("*FalconGetIndent")
    finish
endif

let s:cpo_save = &cpo
set cpo&vim

" 2. Variables {{{1
" ============

" Regex of syntax group names that are strings AND comments
let s:syng_strcom = '\<falcon\%(String\|StringEscape\|Comment\)\>'

" Regex of syntax group names that are strings
let s:syng_string = '\<falcon\%(String\|StringEscape\)\>'

" Regex that defines blocks.
"
" Note that there's a slight problem with this regex and s:continuation_regex.
" Code like this will be matched by both:
"
"   method_call do |(a, b)|
"
" The reason is that the pipe matches a hanging "|" operator.
"
let s:block_regex =
      \ '\%(\<do:\@!\>\|%\@<!{\)\s*\%(|\s*(*\s*\%([*@&]\=\h\w*,\=\s*\)\%(,\s*(*\s*[*@&]\=\h\w*\s*)*\s*\)*|\)\=\s*\%(#.*\)\=$'

let s:block_continuation_regex = '^\s*[^])}\t ].*'.s:block_regex

" Regex that defines continuation lines.
" TODO: this needs to deal with if ...: and so on
let s:continuation_regex =
      \ '\%(%\@<![({[\\.,:*/%+]\|\<and\|\<or\|\%(<%\)\@<![=-]\|\W[|&?]\|||\|&&\)\s*\%(#.*\)\=$'

" Regex that defines bracket continuations
let s:bracket_continuation_regex = '%\@<!\%([({[]\)\s*\%(#.*\)\=$'

" Regex that defines continuation lines, not including (, {, or [.
let s:non_bracket_continuation_regex = '\%([\\.,:*/%+]\|\<and\|\<or\|\%(<%\)\@<![=-]\|\W[|&?]\|||\|&&\)\s*\%(#.*\)\=$'

" Keywords to indent on
let s:falcon_indent_keywords = '^\s*\(case\|catch\|class\|enum\|default\|elif\|else' .
    \ '\|for\|function\|if.*"[^"]*:.*"\|if \(\(:\)\@!.\)*$\|loop\|object\|select' .
    \ '\|switch\|try\|while\|\w*\s*=\s*\w*([$\)'

" Keywords to deindent on
let s:falcon_deindent_keywords = '^\s*\(case\|catch\|default\|elif\|else\|end\)'

" 3. Functions {{{1
" ============

" Check if the character at lnum:col is inside a string, comment, or is ascii.
function s:IsInStringOrComment(lnum, col)
    return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom
endfunction

" Check if the character at lnum:col is inside a string.
function s:IsInString(lnum, col)
    return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string
endfunction

" Check if the character at lnum:col is inside a string delimiter
function s:IsInStringDelimiter(lnum, col)
    return synIDattr(synID(a:lnum, a:col, 1), 'name') == 'falconStringDelimiter'
endfunction

" Find line above 'lnum' that isn't empty, in a comment, or in a string.
function s:PrevNonBlankNonString(lnum)
    let in_block = 0
    let lnum = prevnonblank(a:lnum)
    while lnum > 0
	" Go in and out of blocks comments as necessary.
	" If the line isn't empty (with opt. comment) or in a string, end search.
	let line = getline(lnum)
	if line =~ '^=begin'
	    if in_block
		let in_block = 0
	    else
		break
	    endif
	elseif !in_block && line =~ '^=end'
	    let in_block = 1
	elseif !in_block && line !~ '^\s*#.*$' && !(s:IsInStringOrComment(lnum, 1)
		    \ && s:IsInStringOrComment(lnum, strlen(line)))
	    break
	endif
	let lnum = prevnonblank(lnum - 1)
    endwhile
    return lnum
endfunction

" Find line above 'lnum' that started the continuation 'lnum' may be part of.
function s:GetMSL(lnum)
    " Start on the line we're at and use its indent.
    let msl = a:lnum
    let msl_body = getline(msl)
    let lnum = s:PrevNonBlankNonString(a:lnum - 1)
    while lnum > 0
	" If we have a continuation line, or we're in a string, use line as MSL.
	" Otherwise, terminate search as we have found our MSL already.
	let line = getline(lnum)
	
	if s:Match(line, s:non_bracket_continuation_regex) &&
          	\ s:Match(msl, s:non_bracket_continuation_regex)
	    " If the current line is a non-bracket continuation and so is the
	    " previous one, keep its indent and continue looking for an MSL.
	    "    
	    " Example:
	    "   method_call one,
	    "       two,
	    "           three
	    "           
	    let msl = lnum
	elseif s:Match(lnum, s:non_bracket_continuation_regex) &&
		    \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
	    " If the current line is a bracket continuation or a block-starter, but
	    " the previous is a non-bracket one, respect the previous' indentation,
	    " and stop here.
	    " 
	    " Example:
	    "   method_call one,
	    "       two {
	    "           three
	    "
	    return lnum
	elseif s:Match(lnum, s:bracket_continuation_regex) &&
		    \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
	    " If both lines are bracket continuations (the current may also be a
	    " block-starter), use the current one's and stop here
	    "
	    " Example:
	    "   method_call(
	    "       other_method_call(
	    "             foo
	    return msl
	elseif s:Match(lnum, s:block_regex) &&
		    \ !s:Match(msl, s:continuation_regex) &&
		    \ !s:Match(msl, s:block_continuation_regex)
	    " If the previous line is a block-starter and the current one is
	    " mostly ordinary, use the current one as the MSL.
	    " 
	    " Example:
	    "   method_call do
	    "       something
	    "           something_else
	    return msl
	else
	    let col = match(line, s:continuation_regex) + 1
	    if (col > 0 && !s:IsInStringOrComment(lnum, col))
			\ || s:IsInString(lnum, strlen(line))
		let msl = lnum
	    else
		break
	    endif
	endif
	
	let msl_body = getline(msl)
	let lnum = s:PrevNonBlankNonString(lnum - 1)
    endwhile
    return msl
endfunction

" Check if line 'lnum' has more opening brackets than closing ones.
function s:ExtraBrackets(lnum)
    let opening = {'parentheses': [], 'braces': [], 'brackets': []}
    let closing = {'parentheses': [], 'braces': [], 'brackets': []}

    let line = getline(a:lnum)
    let pos  = match(line, '[][(){}]', 0)

    " Save any encountered opening brackets, and remove them once a matching
    " closing one has been found. If a closing bracket shows up that doesn't
    " close anything, save it for later.
    while pos != -1
	if !s:IsInStringOrComment(a:lnum, pos + 1)
	    if line[pos] == '('
		call add(opening.parentheses, {'type': '(', 'pos': pos})
	    elseif line[pos] == ')'
		if empty(opening.parentheses)
		    call add(closing.parentheses, {'type': ')', 'pos': pos})
		else
		    let opening.parentheses = opening.parentheses[0:-2]
		endif
	    elseif line[pos] == '{'
		call add(opening.braces, {'type': '{', 'pos': pos})
	    elseif line[pos] == '}'
		if empty(opening.braces)
		    call add(closing.braces, {'type': '}', 'pos': pos})
		else
		    let opening.braces = opening.braces[0:-2]
		endif
	    elseif line[pos] == '['
		call add(opening.brackets, {'type': '[', 'pos': pos})
	    elseif line[pos] == ']'
		if empty(opening.brackets)
		    call add(closing.brackets, {'type': ']', 'pos': pos})
		else
		    let opening.brackets = opening.brackets[0:-2]
		endif
	    endif
	endif
	
	let pos = match(line, '[][(){}]', pos + 1)
    endwhile

    " Find the rightmost brackets, since they're the ones that are important in
    " both opening and closing cases
    let rightmost_opening = {'type': '(', 'pos': -1}
    let rightmost_closing = {'type': ')', 'pos': -1}

    for opening in opening.parentheses + opening.braces + opening.brackets
	if opening.pos > rightmost_opening.pos
	    let rightmost_opening = opening
	endif
    endfor

    for closing in closing.parentheses + closing.braces + closing.brackets
	if closing.pos > rightmost_closing.pos
	    let rightmost_closing = closing
	endif
    endfor

    return [rightmost_opening, rightmost_closing]
endfunction

function s:Match(lnum, regex)
    let col = match(getline(a:lnum), '\C'.a:regex) + 1
    return col > 0 && !s:IsInStringOrComment(a:lnum, col) ? col : 0
endfunction

function s:MatchLast(lnum, regex)
    let line = getline(a:lnum)
    let col = match(line, '.*\zs' . a:regex)
    while col != -1 && s:IsInStringOrComment(a:lnum, col)
	let line = strpart(line, 0, col)
	let col = match(line, '.*' . a:regex)
    endwhile
    return col + 1
endfunction

" 4. FalconGetIndent Routine {{{1
" ============

function FalconGetIndent(...)
    " For the current line, use the first argument if given, else v:lnum
    let clnum = a:0 ? a:1 : v:lnum

    " Use zero indent at the top of the file
    if clnum == 0
        return 0
    endif

    let line = getline(clnum)
    let ind = -1

    " If we got a closing bracket on an empty line, find its match and indent
    " according to it.  For parentheses we indent to its column - 1, for the
    " others we indent to the containing line's MSL's level.  Return -1 if fail.
    let col = matchend(line, '^\s*[]})]')
    if col > 0 && !s:IsInStringOrComment(clnum, col)
	call cursor(clnum, col)
	let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
	if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
	    if line[col-1]==')' && col('.') != col('$') - 1
		let ind = virtcol('.') - 1
	    else
		let ind = indent(s:GetMSL(line('.')))
	    endif
	endif
	return ind
    endif

    " If we have a deindenting keyword, find its match and indent to its level.
    " TODO: this is messy
    if s:Match(clnum, s:falcon_deindent_keywords)
	call cursor(clnum, 1)
	if searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW',
		    \ s:end_skip_expr) > 0
	    let msl  = s:GetMSL(line('.'))
	    let line = getline(line('.'))

	    if strpart(line, 0, col('.') - 1) =~ '=\s*$' &&
			\ strpart(line, col('.') - 1, 2) !~ 'do'
		let ind = virtcol('.') - 1
	    elseif getline(msl) =~ '=\s*\(#.*\)\=$'
		let ind = indent(line('.'))
	    else
		let ind = indent(msl)
	    endif
	endif
	return ind
    endif

    " If we are in a multi-line string or line-comment, don't do anything to it.
    if s:IsInString(clnum, matchend(line, '^\s*') + 1)
	return indent('.')
    endif

    " Find a non-blank, non-multi-line string line above the current line.
    let lnum = s:PrevNonBlankNonString(clnum - 1)

    " If the line is empty and inside a string, use the previous line.
    if line =~ '^\s*$' && lnum != prevnonblank(clnum - 1)
	return indent(prevnonblank(clnum))
    endif

    " At the start of the file use zero indent.
    if lnum == 0
	return 0
    endif

    " Set up variables for the previous line.
    let line = getline(lnum)
    let ind = indent(lnum)

    " If the previous line ended with a block opening, add a level of indent.
    if s:Match(lnum, s:block_regex)
	return indent(s:GetMSL(lnum)) + &sw
    endif

    " If it contained hanging closing brackets, find the rightmost one, find its
    " match and indent according to that.
    if line =~ '[[({]' || line =~ '[])}]\s*\%(#.*\)\=$'
	let [opening, closing] = s:ExtraBrackets(lnum)

	if opening.pos != -1
	    if opening.type == '(' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
		if col('.') + 1 == col('$')
		    return ind + &sw
		else
		    return virtcol('.')
		endif
	    else
		let nonspace = matchend(line, '\S', opening.pos + 1) - 1
		return nonspace > 0 ? nonspace : ind + &sw
	    endif
	elseif closing.pos != -1
	    call cursor(lnum, closing.pos + 1)
	    normal! %

	    if s:Match(line('.'), s:falcon_indent_keywords)
		return indent('.') + &sw
	    else
		return indent('.')
	    endif
	else
	    call cursor(clnum, vcol)
	end
    endif

    " If the previous line ended with an "end", match that "end"s beginning's
    " indent.
    let col = s:Match(lnum, '\%(^\|[^.:@$]\)\<end\>\s*\%(#.*\)\=$')
    if col > 0
	call cursor(lnum, col)
	if searchpair(s:end_start_regex, '', s:end_end_regex, 'bW',
		    \ s:end_skip_expr) > 0
	    let n = line('.')
	    let ind = indent('.')
	    let msl = s:GetMSL(n)
	    if msl != n
		let ind = indent(msl)
	    end
	    return ind
	endif
    end

    let col = s:Match(lnum, s:falcon_indent_keywords)
    if col > 0
	call cursor(lnum, col)
	let ind = virtcol('.') - 1 + &sw
	" TODO: make this better (we need to count them) (or, if a searchpair
	" fails, we know that something is lacking an end and thus we indent a
	" level
	if s:Match(lnum, s:end_end_regex)
	    let ind = indent('.')
	endif
	return ind
    endif

    " Set up variables to use and search for MSL to the previous line.
    let p_lnum = lnum
    let lnum = s:GetMSL(lnum)

    " If the previous line wasn't a MSL and is continuation return its indent.
    " TODO: the || s:IsInString() thing worries me a bit.
    if p_lnum != lnum
	if s:Match(p_lnum, s:non_bracket_continuation_regex) || s:IsInString(p_lnum,strlen(line))
	    return ind
	endif
    endif

    " Set up more variables, now that we know we wasn't continuation bound.
    let line = getline(lnum)
    let msl_ind = indent(lnum)

    " If the MSL line had an indenting keyword in it, add a level of indent.
    " TODO: this does not take into account contrived things such as
    " module Foo; class Bar; end
    if s:Match(lnum, s:falcon_indent_keywords)
	let ind = msl_ind + &sw
	if s:Match(lnum, s:end_end_regex)
	    let ind = ind - &sw
	endif
	return ind
    endif

    " If the previous line ended with [*+/.,-=], but wasn't a block ending or a
    " closing bracket, indent one extra level.
    if s:Match(lnum, s:non_bracket_continuation_regex) && !s:Match(lnum, '^\s*\([\])}]\|end\)')
	if lnum == p_lnum
	    let ind = msl_ind + &sw
	else
	    let ind = msl_ind
	endif
	return ind
    endif

  return ind
endfunction

" }}}1

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: set sw=4 sts=4 et tw=80 :
                                                                                                                                                                                                                                                                                                                                                                  usr/share/vim/vim74/indent/fortran.vim                                                              0100644 0000000 0000000 00000014637 13050207306 016401  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Fortran95 (and Fortran90, Fortran77, F and elf90)
" Version:	0.40
" Last Change:	2011 Dec. 28
" Maintainer:	Ajit J. Thakkar <ajit@unb.ca>; <http://www.unb.ca/chem/ajit/>
" Usage:	Do :help fortran-indent from Vim

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

let s:cposet=&cpoptions
set cpoptions&vim

setlocal indentkeys+==~end,=~case,=~if,=~else,=~do,=~where,=~elsewhere,=~select
setlocal indentkeys+==~endif,=~enddo,=~endwhere,=~endselect,=~elseif
setlocal indentkeys+==~type,=~interface,=~forall,=~associate,=~block,=~enum
setlocal indentkeys+==~endforall,=~endassociate,=~endblock,=~endenum
if exists("b:fortran_indent_more") || exists("g:fortran_indent_more")
  setlocal indentkeys+==~function,=~subroutine,=~module,=~contains,=~program
  setlocal indentkeys+==~endfunction,=~endsubroutine,=~endmodule
  setlocal indentkeys+==~endprogram
endif

" Determine whether this is a fixed or free format source file
" if this hasn't been done yet
if !exists("b:fortran_fixed_source")
  if exists("fortran_free_source")
    " User guarantees free source form
    let b:fortran_fixed_source = 0
  elseif exists("fortran_fixed_source")
    " User guarantees fixed source form
    let b:fortran_fixed_source = 1
  else
    " f90 and f95 allow both fixed and free source form
    " assume fixed source form unless signs of free source form
    " are detected in the first five columns of the first 250 lines
    " Detection becomes more accurate and time-consuming if more lines
    " are checked. Increase the limit below if you keep lots of comments at
    " the very top of each file and you have a fast computer
    let s:lmax = 500
    if ( s:lmax > line("$") )
      let s:lmax = line("$")
    endif
    let b:fortran_fixed_source = 1
    let s:ln=1
    while s:ln <= s:lmax
      let s:test = strpart(getline(s:ln),0,5)
      if s:test !~ '^[Cc*]' && s:test !~ '^ *[!#]' && s:test =~ '[^ 0-9\t]' && s:test !~ '^[ 0-9]*\t'
	let b:fortran_fixed_source = 0
	break
      endif
      let s:ln = s:ln + 1
    endwhile
  endif
endif

" Define the appropriate indent function but only once
if (b:fortran_fixed_source == 1)
  setlocal indentexpr=FortranGetFixedIndent()
  if exists("*FortranGetFixedIndent")
    finish
  endif
else
  setlocal indentexpr=FortranGetFreeIndent()
  if exists("*FortranGetFreeIndent")
    finish
  endif
endif

function FortranGetIndent(lnum)
  let ind = indent(a:lnum)
  let prevline=getline(a:lnum)
  " Strip tail comment
  let prevstat=substitute(prevline, '!.*$', '', '')
  let prev2line=getline(a:lnum-1)
  let prev2stat=substitute(prev2line, '!.*$', '', '')

  "Indent do loops only if they are all guaranteed to be of do/end do type
  if exists("b:fortran_do_enddo") || exists("g:fortran_do_enddo")
    if prevstat =~? '^\s*\(\d\+\s\)\=\s*\(\a\w*\s*:\)\=\s*do\>'
      let ind = ind + &sw
    endif
    if getline(v:lnum) =~? '^\s*\(\d\+\s\)\=\s*end\s*do\>'
      let ind = ind - &sw
    endif
  endif

  "Add a shiftwidth to statements following if, else, else if, case,
  "where, else where, forall, type, interface and associate statements
  if prevstat =~? '^\s*\(case\|else\|else\s*if\|else\s*where\)\>'
	\ ||prevstat=~? '^\s*\(type\|interface\|associate\|enum\)\>'
	\ ||prevstat=~?'^\s*\(\d\+\s\)\=\s*\(\a\w*\s*:\)\=\s*\(forall\|where\|block\)\>'
	\ ||prevstat=~? '^\s*\(\d\+\s\)\=\s*\(\a\w*\s*:\)\=\s*if\>'
     let ind = ind + &sw
    " Remove unwanted indent after logical and arithmetic ifs
    if prevstat =~? '\<if\>' && prevstat !~? '\<then\>'
      let ind = ind - &sw
    endif
    " Remove unwanted indent after type( statements
    if prevstat =~? '^\s*type\s*('
      let ind = ind - &sw
    endif
  endif

  "Indent program units unless instructed otherwise
  if !exists("b:fortran_indent_less") && !exists("g:fortran_indent_less")
    let prefix='\(\(pure\|impure\|elemental\|recursive\)\s\+\)\{,2}'
    let type='\(\(integer\|real\|double\s\+precision\|complex\|logical'
          \.'\|character\|type\|class\)\s*\S*\s\+\)\='
    if prevstat =~? '^\s*\(module\|contains\|program\)\>'
            \ ||prevstat =~? '^\s*'.prefix.'subroutine\>'
            \ ||prevstat =~? '^\s*'.prefix.type.'function\>'
            \ ||prevstat =~? '^\s*'.type.prefix.'function\>'
      let ind = ind + &sw
    endif
    if getline(v:lnum) =~? '^\s*contains\>'
          \ ||getline(v:lnum)=~? '^\s*end\s*'
          \ .'\(function\|subroutine\|module\|program\)\>'
      let ind = ind - &sw
    endif
  endif

  "Subtract a shiftwidth from else, else if, elsewhere, case, end if,
  " end where, end select, end forall, end interface, end associate,
  " end enum, and end type statements
  if getline(v:lnum) =~? '^\s*\(\d\+\s\)\=\s*'
        \. '\(else\|else\s*if\|else\s*where\|case\|'
        \. 'end\s*\(if\|where\|select\|interface\|'
        \. 'type\|forall\|associate\|enum\)\)\>'
    let ind = ind - &sw
    " Fix indent for case statement immediately after select
    if prevstat =~? '\<select\s\+\(case\|type\)\>'
      let ind = ind + &sw
    endif
  endif

  "First continuation line
  if prevstat =~ '&\s*$' && prev2stat !~ '&\s*$'
    let ind = ind + &sw
  endif
  "Line after last continuation line
  if prevstat !~ '&\s*$' && prev2stat =~ '&\s*$'
    let ind = ind - &sw
  endif

  return ind
endfunction

function FortranGetFreeIndent()
  "Find the previous non-blank line
  let lnum = prevnonblank(v:lnum - 1)

  "Use zero indent at the top of the file
  if lnum == 0
    return 0
  endif

  let ind=FortranGetIndent(lnum)
  return ind
endfunction

function FortranGetFixedIndent()
  let currline=getline(v:lnum)
  "Don't indent comments, continuation lines and labelled lines
  if strpart(currline,0,6) =~ '[^ \t]'
    let ind = indent(v:lnum)
    return ind
  endif

  "Find the previous line which is not blank, not a comment,
  "not a continuation line, and does not have a label
  let lnum = v:lnum - 1
  while lnum > 0
    let prevline=getline(lnum)
    if (prevline =~ "^[C*!]") || (prevline =~ "^\s*$")
	\ || (strpart(prevline,5,1) !~ "[ 0]")
      " Skip comments, blank lines and continuation lines
      let lnum = lnum - 1
    else
      let test=strpart(prevline,0,5)
      if test =~ "[0-9]"
	" Skip lines with statement numbers
	let lnum = lnum - 1
      else
	break
      endif
    endif
  endwhile

  "First line must begin at column 7
  if lnum == 0
    return 6
  endif

  let ind=FortranGetIndent(lnum)
  return ind
endfunction

let &cpoptions=s:cposet
unlet s:cposet

" vim:sw=2 tw=130
                                                                                                 usr/share/vim/vim74/indent/framescript.vim                                                          0100644 0000000 0000000 00000001422 13050207306 017231  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:         FrameScript
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-19

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetFrameScriptIndent()
setlocal indentkeys=!^F,o,O,0=~Else,0=~EndIf,0=~EndLoop,0=~EndSub
setlocal nosmartindent

if exists("*GetFrameScriptIndent")
  finish
endif

function GetFrameScriptIndent()
  let lnum = prevnonblank(v:lnum - 1)

  if lnum == 0
    return 0
  endif

  if getline(v:lnum) =~ '^\s*\*'
    return cindent(v:lnum)
  endif

  let ind = indent(lnum)

  if getline(lnum) =~? '^\s*\%(If\|Loop\|Sub\)'
    let ind = ind + &sw
  endif

  if getline(v:lnum) =~? '^\s*\%(Else\|End\%(If\|Loop\|Sub\)\)'
    let ind = ind - &sw
  endif

  return ind
endfunction
                                                                                                                                                                                                                                              usr/share/vim/vim74/indent/gitconfig.vim                                                            0100644 0000000 0000000 00000001461 13050207306 016666  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	git config file
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2013 May 30

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal autoindent
setlocal indentexpr=GetGitconfigIndent()
setlocal indentkeys=o,O,*<Return>,0[,],0;,0#,=,!^F

let b:undo_indent = 'setl ai< inde< indk<'

" Only define the function once.
if exists("*GetGitconfigIndent")
  finish
endif

function! GetGitconfigIndent()
  let line  = getline(prevnonblank(v:lnum-1))
  let cline = getline(v:lnum)
  if line =~  '\\\@<!\%(\\\\\)*\\$'
    " odd number of slashes, in a line continuation
    return 2 * &sw
  elseif cline =~ '^\s*\['
    return 0
  elseif cline =~ '^\s*\a'
    return &sw
  elseif cline == ''       && line =~ '^\['
    return &sw
  else
    return -1
  endif
endfunction
                                                                                                                                                                                                               usr/share/vim/vim74/indent/gitolite.vim                                                             0100644 0000000 0000000 00000001744 13050207306 016541  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	gitolite configuration
" URL:		https://github.com/tmatilai/gitolite.vim
" Maintainer:	Teemu Matilainen <teemu.matilainen@iki.fi>
" Last Change:	2011-12-24

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal autoindent
setlocal indentexpr=GetGitoliteIndent()
setlocal indentkeys=o,O,*<Return>,!^F,=repo,\",=

" Only define the function once.
if exists("*GetGitoliteIndent")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

function! GetGitoliteIndent()
  let prevln = prevnonblank(v:lnum-1)
  let pline = getline(prevln)
  let cline = getline(v:lnum)

  if cline =~ '^\s*\(C\|R\|RW\|RW+\|RWC\|RW+C\|RWD\|RW+D\|RWCD\|RW+CD\|-\)[ \t=]'
    return &sw
  elseif cline =~ '^\s*config\s'
    return &sw
  elseif pline =~ '^\s*repo\s' && cline =~ '^\s*\(#.*\)\?$'
    return &sw
  elseif cline =~ '^\s*#'
    return indent(prevln)
  elseif cline =~ '^\s*$'
    return -1
  else
    return 0
  endif
endfunction

let &cpo = s:cpo_save
unlet s:cpo_save
                            usr/share/vim/vim74/indent/go.vim                                                                   0100644 0000000 0000000 00000003535 13050207306 015326  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Go
" Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
" Last Change:	2014 Aug 16
"
" TODO:
" - function invocations split across lines
" - general line splits (line ends in an operator)

if exists('b:did_indent')
  finish
endif
let b:did_indent = 1

" C indentation is too far off useful, mainly due to Go's := operator.
" Let's just define our own.
setlocal nolisp
setlocal autoindent
setlocal indentexpr=GoIndent(v:lnum)
setlocal indentkeys+=<:>,0=},0=)

if exists('*GoIndent')
  finish
endif

" The shiftwidth() function is relatively new.
" Don't require it to exist.
if exists('*shiftwidth')
  function s:sw() abort
    return shiftwidth()
  endfunction
else
  function s:sw() abort
    return &shiftwidth
  endfunction
endif

function! GoIndent(lnum)
  let l:prevlnum = prevnonblank(a:lnum-1)
  if l:prevlnum == 0
    " top of file
    return 0
  endif

  " grab the previous and current line, stripping comments.
  let l:prevl = substitute(getline(l:prevlnum), '//.*$', '', '')
  let l:thisl = substitute(getline(a:lnum), '//.*$', '', '')
  let l:previ = indent(l:prevlnum)

  let l:ind = l:previ

  if l:prevl =~ '[({]\s*$'
    " previous line opened a block
    let l:ind += s:sw()
  endif
  if l:prevl =~# '^\s*\(case .*\|default\):$'
    " previous line is part of a switch statement
    let l:ind += s:sw()
  endif
  " TODO: handle if the previous line is a label.

  if l:thisl =~ '^\s*[)}]'
    " this line closed a block
    let l:ind -= s:sw()
  endif

  " Colons are tricky.
  " We want to outdent if it's part of a switch ("case foo:" or "default:").
  " We ignore trying to deal with jump labels because (a) they're rare, and
  " (b) they're hard to disambiguate from a composite literal key.
  if l:thisl =~# '^\s*\(case .*\|default\):$'
    let l:ind -= s:sw()
  endif

  return l:ind
endfunction

" vim: sw=2 sts=2 et
                                                                                                                                                                   usr/share/vim/vim74/indent/haml.vim                                                                 0100644 0000000 0000000 00000004215 13050207306 015636  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Haml
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2013 May 30

if exists("b:did_indent")
  finish
endif
runtime! indent/ruby.vim
unlet! b:did_indent
let b:did_indent = 1

setlocal autoindent sw=2 et
setlocal indentexpr=GetHamlIndent()
setlocal indentkeys=o,O,*<Return>,},],0),!^F,=end,=else,=elsif,=rescue,=ensure,=when

" Only define the function once.
if exists("*GetHamlIndent")
  finish
endif

let s:attributes = '\%({.\{-\}}\|\[.\{-\}\]\)'
let s:tag = '\%([%.#][[:alnum:]_-]\+\|'.s:attributes.'\)*[<>]*'

if !exists('g:haml_self_closing_tags')
  let g:haml_self_closing_tags = 'base|link|meta|br|hr|img|input'
endif

function! GetHamlIndent()
  let lnum = prevnonblank(v:lnum-1)
  if lnum == 0
    return 0
  endif
  let line = substitute(getline(lnum),'\s\+$','','')
  let cline = substitute(substitute(getline(v:lnum),'\s\+$','',''),'^\s\+','','')
  let lastcol = strlen(line)
  let line = substitute(line,'^\s\+','','')
  let indent = indent(lnum)
  let cindent = indent(v:lnum)
  if cline =~# '\v^-\s*%(elsif|else|when)>'
    let indent = cindent < indent ? cindent : indent - &sw
  endif
  let increase = indent + &sw
  if indent == indent(lnum)
    let indent = cindent <= indent ? -1 : increase
  endif

  let group = synIDattr(synID(lnum,lastcol,1),'name')

  if line =~ '^!!!'
    return indent
  elseif line =~ '^/\%(\[[^]]*\]\)\=$'
    return increase
  elseif group == 'hamlFilter'
    return increase
  elseif line =~ '^'.s:tag.'[&!]\=[=~-]\s*\%(\%(if\|else\|elsif\|unless\|case\|when\|while\|until\|for\|begin\|module\|class\|def\)\>\%(.*\<end\>\)\@!\|.*do\%(\s*|[^|]*|\)\=\s*$\)'
    return increase
  elseif line =~ '^'.s:tag.'[&!]\=[=~-].*,\s*$'
    return increase
  elseif line == '-#'
    return increase
  elseif group =~? '\v^(hamlSelfCloser)$' || line =~? '^%\v%('.g:haml_self_closing_tags.')>'
    return indent
  elseif group =~? '\v^%(hamlTag|hamlAttributesDelimiter|hamlObjectDelimiter|hamlClass|hamlId|htmlTagName|htmlSpecialTagName)$'
    return increase
  elseif synIDattr(synID(v:lnum,1,1),'name') ==? 'hamlRubyFilter'
    return GetRubyIndent()
  else
    return indent
  endif
endfunction

" vim:set sw=2:
                                                                                                                                                                                                                                                                                                                                                                                   usr/share/vim/vim74/indent/hamster.vim                                                              0100644 0000000 0000000 00000002577 13050207306 016371  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:    Hamster Script 
" Version:     2.0.6.0
" Last Change: Wed Nov 08 2006 12:02:42 PM
" Maintainer:  David Fishburn <fishburn@ianywhere.com>

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentkeys+==~if,=~else,=~endif,=~endfor,=~endwhile
setlocal indentkeys+==~do,=~until,=~while,=~repeat,=~for,=~loop
setlocal indentkeys+==~sub,=~endsub

" Define the appropriate indent function but only once
setlocal indentexpr=HamGetFreeIndent()
if exists("*HamGetFreeIndent")
  finish
endif

function HamGetIndent(lnum)
  let ind = indent(a:lnum)
  let prevline=getline(a:lnum)

  " Add a shiftwidth to statements following if,  else, elseif,
  " case, select, default, do, until, while, for, start
  if prevline =~? '^\s*\<\(if\|else\%(if\)\?\|for\|repeat\|do\|while\|sub\)\>' 
    let ind = ind + &sw
  endif

  " Subtract a shiftwidth from else, elseif, end(if|while|for), until
  let line = getline(v:lnum)
  if line =~? '^\s*\(else\|elseif\|loop\|until\|end\%(if\|while\|for\|sub\)\)\>'
    let ind = ind - &sw
  endif

  return ind
endfunction

function HamGetFreeIndent()
  " Find the previous non-blank line
  let lnum = prevnonblank(v:lnum - 1)

  " Use zero indent at the top of the file
  if lnum == 0
    return 0
  endif

  let ind=HamGetIndent(lnum)
  return ind
endfunction

" vim:sw=2 tw=80
                                                                                                                                 usr/share/vim/vim74/indent/html.vim                                                                 0100644 0000000 0000000 00000075227 13050207306 015674  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent script for HTML
" Header: "{{{
" Maintainer:	Bram Moolenaar
" Original Author: Andy Wokula <anwoku@yahoo.de>
" Last Change:	2014 Aug 23
" Version:	1.0
" Description:	HTML indent script with cached state for faster indenting on a
"		range of lines.
"		Supports template systems through hooks.
"		Supports Closure stylesheets.
"
" Credits:
"	indent/html.vim (2006 Jun 05) from J. Zellner
"	indent/css.vim (2006 Dec 20) from N. Weibull
"
" History:
" 2014 June	(v1.0) overhaul (Bram)
" 2012 Oct 21	(v0.9) added support for shiftwidth()
" 2011 Sep 09	(v0.8) added HTML5 tags (thx to J. Zuckerman)
" 2008 Apr 28	(v0.6) revised customization
" 2008 Mar 09	(v0.5) fixed 'indk' issue (thx to C.J. Robinson)
"}}}

" Init Folklore, check user settings (2nd time ++)
if exists("b:did_indent") "{{{
  finish
endif
let b:did_indent = 1

setlocal indentexpr=HtmlIndent()
setlocal indentkeys=o,O,<Return>,<>>,{,},!^F

" "j1" is included to make cindent() work better with Javascript.
setlocal cino=j1
" "J1" should be included, but it doen't work properly before 7.4.355.
if has("patch-7.4.355")
  setlocal cino+=J1
endif
" Before patch 7.4.355 indenting after "(function() {" does not work well, add
" )2 to limit paren search.
if !has("patch-7.4.355")
  setlocal cino+=)2
endif

" Needed for % to work when finding start/end of a tag.
setlocal matchpairs+=<:>

let b:undo_indent = "setlocal inde< indk< cino<"

" b:hi_indent keeps state to speed up indenting consecutive lines.
let b:hi_indent = {"lnum": -1}

"""""" Code below this is loaded only once. """""
if exists("*HtmlIndent") && !exists('g:force_reload_html')
  call HtmlIndent_CheckUserSettings()
  finish
endif

" shiftwidth() exists since patch 7.3.694
if exists('*shiftwidth')
  let s:ShiftWidth = function('shiftwidth')
else
  func! s:ShiftWidth()
    return &shiftwidth
  endfunc
endif

" Allow for line continuation below.
let s:cpo_save = &cpo
set cpo-=C
"}}}

" Check and process settings from b:html_indent and g:html_indent... variables.
" Prefer using buffer-local settings over global settings, so that there can
" be defaults for all HTML files and exceptions for specific types of HTML
" files.
func! HtmlIndent_CheckUserSettings()
  "{{{
  let inctags = ''
  if exists("b:html_indent_inctags")
    let inctags = b:html_indent_inctags
  elseif exists("g:html_indent_inctags")
    let inctags = g:html_indent_inctags
  endif
  let b:hi_tags = {}
  if len(inctags) > 0
    call s:AddITags(b:hi_tags, split(inctags, ","))
  endif

  let autotags = ''
  if exists("b:html_indent_autotags")
    let autotags = b:html_indent_autotags
  elseif exists("g:html_indent_autotags")
    let autotags = g:html_indent_autotags
  endif
  let b:hi_removed_tags = {}
  if autotags
    call s:RemoveITags(b:hi_removed_tags, split(autotags, ","))
  endif

  " Syntax names indicating being inside a string of an attribute value.
  let string_names = []
  if exists("b:html_indent_string_names")
    let string_names = b:html_indent_string_names
  elseif exists("g:html_indent_string_names")
    let string_names = g:html_indent_string_names
  endif
  let b:hi_insideStringNames = ['htmlString']
  if len(string_names) > 0
    for s in string_names
      call add(b:hi_insideStringNames, s)
    endfor
  endif

  " Syntax names indicating being inside a tag.
  let tag_names = []
  if exists("b:html_indent_tag_names")
    let tag_names = b:html_indent_tag_names
  elseif exists("g:html_indent_tag_names")
    let tag_names = g:html_indent_tag_names
  endif
  let b:hi_insideTagNames = ['htmlTag', 'htmlScriptTag']
  if len(tag_names) > 0
    for s in tag_names
      call add(b:hi_insideTagNames, s)
    endfor
  endif

  let indone = {"zero": 0
              \,"auto": "indent(prevnonblank(v:lnum-1))"
              \,"inc": "b:hi_indent.blocktagind + s:ShiftWidth()"}

  let script1 = ''
  if exists("b:html_indent_script1")
    let script1 = b:html_indent_script1
  elseif exists("g:html_indent_script1")
    let script1 = g:html_indent_script1
  endif
  if len(script1) > 0
    let b:hi_js1indent = get(indone, script1, indone.zero)
  else
    let b:hi_js1indent = 0
  endif

  let style1 = ''
  if exists("b:html_indent_style1")
    let style1 = b:html_indent_style1
  elseif exists("g:html_indent_style1")
    let style1 = g:html_indent_style1
  endif
  if len(style1) > 0
    let b:hi_css1indent = get(indone, style1, indone.zero)
  else
    let b:hi_css1indent = 0
  endif

  if !exists('b:html_indent_line_limit')
    if exists('g:html_indent_line_limit')
      let b:html_indent_line_limit = g:html_indent_line_limit
    else
      let b:html_indent_line_limit = 200
    endif
  endif
endfunc "}}}

" Init Script Vars
"{{{
let b:hi_lasttick = 0
let b:hi_newstate = {}
let s:countonly = 0
 "}}}

" Fill the s:indent_tags dict with known tags.
" The key is "tagname" or "/tagname".  {{{
" The value is:
" 1   opening tag
" 2   "pre"
" 3   "script"
" 4   "style"
" 5   comment start
" -1  closing tag
" -2  "/pre"
" -3  "/script"
" -4  "/style"
" -5  comment end
let s:indent_tags = {}
let s:endtags = [0,0,0,0,0,0]   " long enough for the highest index
"}}}

" Add a list of tag names for a pair of <tag> </tag> to "tags".
func! s:AddITags(tags, taglist)
  "{{{
  for itag in a:taglist
    let a:tags[itag] = 1
    let a:tags['/' . itag] = -1
  endfor
endfunc "}}}

" Take a list of tag name pairs that are not to be used as tag pairs.
func! s:RemoveITags(tags, taglist)
  "{{{
  for itag in a:taglist
    let a:tags[itag] = 1
    let a:tags['/' . itag] = 1
  endfor
endfunc "}}}

" Add a block tag, that is a tag with a different kind of indenting.
func! s:AddBlockTag(tag, id, ...)
  "{{{
  if !(a:id >= 2 && a:id < len(s:endtags))
    echoerr 'AddBlockTag ' . a:id
    return
  endif
  let s:indent_tags[a:tag] = a:id
  if a:0 == 0
    let s:indent_tags['/' . a:tag] = -a:id
    let s:endtags[a:id] = "</" . a:tag . ">"
  else
    let s:indent_tags[a:1] = -a:id
    let s:endtags[a:id] = a:1
  endif
endfunc "}}}

" Add known tag pairs.
" Self-closing tags and tags that are sometimes {{{
" self-closing (e.g., <p>) are not here (when encountering </p> we can find
" the matching <p>, but not the other way around).
" Old HTML tags:
call s:AddITags(s:indent_tags, [
    \ 'a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big',
    \ 'blockquote', 'body', 'button', 'caption', 'center', 'cite', 'code',
    \ 'colgroup', 'del', 'dfn', 'dir', 'div', 'dl', 'em', 'fieldset', 'font',
    \ 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'html',
    \ 'i', 'iframe', 'ins', 'kbd', 'label', 'legend', 'li',
    \ 'map', 'menu', 'noframes', 'noscript', 'object', 'ol',
    \ 'optgroup', 'q', 's', 'samp', 'select', 'small', 'span', 'strong', 'sub',
    \ 'sup', 'table', 'textarea', 'title', 'tt', 'u', 'ul', 'var', 'th', 'td',
    \ 'tr', 'tbody', 'tfoot', 'thead'])

" Tags added 2011 Sep 09 (especially HTML5 tags):
call s:AddITags(s:indent_tags, [
    \ 'area', 'article', 'aside', 'audio', 'bdi', 'canvas',
    \ 'command', 'datalist', 'details', 'embed', 'figure', 'footer',
    \ 'header', 'group', 'keygen', 'mark', 'math', 'meter', 'nav', 'output',
    \ 'progress', 'ruby', 'section', 'svg', 'texture', 'time', 'video',
    \ 'wbr', 'text'])
"}}}

" Add Block Tags: these contain alien content
"{{{
call s:AddBlockTag('pre', 2)
call s:AddBlockTag('script', 3)
call s:AddBlockTag('style', 4)
call s:AddBlockTag('<!--', 5, '-->')
"}}}

" Return non-zero when "tagname" is an opening tag, not being a block tag, for
" which there should be a closing tag.  Can be used by scripts that include
" HTML indenting.
func! HtmlIndent_IsOpenTag(tagname)
  "{{{
  if get(s:indent_tags, a:tagname) == 1
    return 1
  endif
  return get(b:hi_tags, a:tagname) == 1
endfunc "}}}

" Get the value for "tagname", taking care of buffer-local tags.
func! s:get_tag(tagname)
  "{{{
  let i = get(s:indent_tags, a:tagname)
  if (i == 1 || i == -1) && get(b:hi_removed_tags, a:tagname) != 0
    return 0
  endif
  if i == 0
    let i = get(b:hi_tags, a:tagname)
  endif
  return i
endfunc "}}}

" Count the number of start and end tags in "text".
func! s:CountITags(text)
  "{{{
  " Store the result in s:curind and s:nextrel.
  let s:curind = 0  " relative indent steps for current line [unit &sw]:
  let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
  let s:block = 0		" assume starting outside of a block
  let s:countonly = 1	" don't change state
  call substitute(a:text, '<\zs/\=\w\+\>\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
  let s:countonly = 0
endfunc "}}}

" Count the number of start and end tags in text.
func! s:CountTagsAndState(text)
  "{{{
  " Store the result in s:curind and s:nextrel.  Update b:hi_newstate.block.
  let s:curind = 0  " relative indent steps for current line [unit &sw]:
  let s:nextrel = 0  " relative indent steps for next line [unit &sw]:

  let s:block = b:hi_newstate.block
  let tmp = substitute(a:text, '<\zs/\=\w\+\>\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
  if s:block == 3
    let b:hi_newstate.scripttype = s:GetScriptType(matchstr(tmp, '\C.*<SCRIPT\>\zs[^>]*'))
  endif
  let b:hi_newstate.block = s:block
endfunc "}}}

" Used by s:CountITags() and s:CountTagsAndState().
func! s:CheckTag(itag)
  "{{{
  " Returns an empty string or "SCRIPT".
  " a:itag can be "tag" or "/tag" or "<!--" or "-->"
  let ind = s:get_tag(a:itag)
  if ind == -1
    " closing tag
    if s:block != 0
      " ignore itag within a block
      return ""
    endif
    if s:nextrel == 0
      let s:curind -= 1
    else
      let s:nextrel -= 1
    endif
  elseif ind == 1
    " opening tag
    if s:block != 0
      return ""
    endif
    let s:nextrel += 1
  elseif ind != 0
    " block-tag (opening or closing)
    return s:CheckBlockTag(a:itag, ind)
  " else ind==0 (other tag found): keep indent
  endif
  return ""
endfunc "}}}

" Used by s:CheckTag(). Returns an empty string or "SCRIPT".
func! s:CheckBlockTag(blocktag, ind)
  "{{{
  if a:ind > 0
    " a block starts here
    if s:block != 0
      " already in a block (nesting) - ignore
      " especially ignore comments after other blocktags
      return ""
    endif
    let s:block = a:ind		" block type
    if s:countonly
      return ""
    endif
    let b:hi_newstate.blocklnr = v:lnum
    " save allover indent for the endtag
    let b:hi_newstate.blocktagind = b:hi_indent.baseindent + (s:nextrel + s:curind) * s:ShiftWidth()
    if a:ind == 3
      return "SCRIPT"    " all except this must be lowercase
      " line is to be checked again for the type attribute
    endif
  else
    let s:block = 0
    " we get here if starting and closing a block-tag on the same line
  endif
  return ""
endfunc "}}}

" Return the <script> type: either "javascript" or ""
func! s:GetScriptType(str)
  "{{{
  if a:str == "" || a:str =~ "java"
    return "javascript"
  else
    return ""
  endif
endfunc "}}}

" Look back in the file, starting at a:lnum - 1, to compute a state for the
" start of line a:lnum.  Return the new state.
func! s:FreshState(lnum)
  "{{{
  " A state is to know ALL relevant details about the
  " lines 1..a:lnum-1, initial calculating (here!) can be slow, but updating is
  " fast (incremental).
  " TODO: this should be split up in detecting the block type and computing the
  " indent for the block type, so that when we do not know the indent we do
  " not need to clear the whole state and re-detect the block type again.
  " State:
  "	lnum		last indented line == prevnonblank(a:lnum - 1)
  "	block = 0	a:lnum located within special tag: 0:none, 2:<pre>,
  "			3:<script>, 4:<style>, 5:<!--
  "	baseindent	use this indent for line a:lnum as a start - kind of
  "			autoindent (if block==0)
  "	scripttype = ''	type attribute of a script tag (if block==3)
  "	blocktagind	indent for current opening (get) and closing (set)
  "			blocktag (if block!=0)
  "	blocklnr	lnum of starting blocktag (if block!=0)
  "	inattr		line {lnum} starts with attributes of a tag
  let state = {}
  let state.lnum = prevnonblank(a:lnum - 1)
  let state.scripttype = ""
  let state.blocktagind = -1
  let state.block = 0
  let state.baseindent = 0
  let state.blocklnr = 0
  let state.inattr = 0

  if state.lnum == 0
    return state
  endif

  " Heuristic:
  " remember startline state.lnum
  " look back for <pre, </pre, <script, </script, <style, </style tags
  " remember stopline
  " if opening tag found,
  "	assume a:lnum within block
  " else
  "	look back in result range (stopline, startline) for comment
  "	    \ delimiters (<!--, -->)
  "	if comment opener found,
  "	    assume a:lnum within comment
  "	else
  "	    assume usual html for a:lnum
  "	    if a:lnum-1 has a closing comment
  "		look back to get indent of comment opener
  " FI

  " look back for a blocktag
  call cursor(a:lnum, 1)
  let [stopline, stopcol] = searchpos('\c<\zs\/\=\%(pre\>\|script\>\|style\>\)', "bW")
  if stopline > 0
    " fugly ... why isn't there searchstr()
    let tagline = tolower(getline(stopline))
    let blocktag = matchstr(tagline, '\/\=\%(pre\>\|script\>\|style\>\)', stopcol - 1)
    if blocktag[0] != "/"
      " opening tag found, assume a:lnum within block
      let state.block = s:indent_tags[blocktag]
      if state.block == 3
        let state.scripttype = s:GetScriptType(matchstr(tagline, '\>[^>]*', stopcol))
      endif
      let state.blocklnr = stopline
      " check preceding tags in the line:
      call s:CountITags(tagline[: stopcol-2])
      let state.blocktagind = indent(stopline) + (s:curind + s:nextrel) * s:ShiftWidth()
      return state
    elseif stopline == state.lnum
      " handle special case: previous line (= state.lnum) contains a
      " closing blocktag which is preceded by line-noise;
      " blocktag == "/..."
      let swendtag = match(tagline, '^\s*</') >= 0
      if !swendtag
        let [bline, bcol] = searchpos('<'.blocktag[1:].'\>', "bW")
        call s:CountITags(tolower(getline(bline)[: bcol-2]))
        let state.baseindent = indent(bline) + (s:curind + s:nextrel) * s:ShiftWidth()
        return state
      endif
    endif
  endif

  " else look back for comment
  call cursor(a:lnum, 1)
  let [comlnum, comcol, found] = searchpos('\(<!--\)\|-->', 'bpW', stopline)
  if found == 2
    " comment opener found, assume a:lnum within comment
    let state.block = 5
    let state.blocklnr = comlnum
    " check preceding tags in the line:
    call s:CountITags(tolower(getline(comlnum)[: comcol-2]))
    let state.blocktagind = indent(comlnum) + (s:curind + s:nextrel) * s:ShiftWidth()
    return state
  endif

  " else within usual HTML
  let text = tolower(getline(state.lnum))

  " Check a:lnum-1 for closing comment (we need indent from the opening line).
  " Not when other tags follow (might be --> inside a string).
  let comcol = stridx(text, '-->')
  if comcol >= 0 && match(text, '[<>]', comcol) <= 0
    call cursor(state.lnum, comcol + 1)
    let [comlnum, comcol] = searchpos('<!--', 'bW')
    if comlnum == state.lnum
      let text = text[: comcol-2]
    else
      let text = tolower(getline(comlnum)[: comcol-2])
    endif
    call s:CountITags(text)
    let state.baseindent = indent(comlnum) + (s:curind + s:nextrel) * s:ShiftWidth()
    " TODO check tags that follow "-->"
    return state
  endif

  " Check if the previous line starts with end tag.
  let swendtag = match(text, '^\s*</') >= 0

  " If previous line ended in a closing tag, line up with the opening tag.
  if !swendtag && text =~ '</\w\+\s*>\s*$'
    call cursor(state.lnum, 99999)
    normal! F<
    let start_lnum = HtmlIndent_FindStartTag()
    if start_lnum > 0
      let state.baseindent = indent(start_lnum)
      if col('.') > 2
        " check for tags before the matching opening tag.
        let text = getline(start_lnum)
        let swendtag = match(text, '^\s*</') >= 0
        call s:CountITags(text[: col('.') - 2])
        let state.baseindent += s:nextrel * s:ShiftWidth()
        if !swendtag
          let state.baseindent += s:curind * s:ShiftWidth()
        endif
      endif
      return state
    endif
  endif

  " Else: no comments. Skip backwards to find the tag we're inside.
  let [state.lnum, found] = HtmlIndent_FindTagStart(state.lnum)
  " Check if that line starts with end tag.
  let text = getline(state.lnum)
  let swendtag = match(text, '^\s*</') >= 0
  call s:CountITags(tolower(text))
  let state.baseindent = indent(state.lnum) + s:nextrel * s:ShiftWidth()
  if !swendtag
    let state.baseindent += s:curind * s:ShiftWidth()
  endif
  return state
endfunc "}}}

" Indent inside a <pre> block: Keep indent as-is.
func! s:Alien2()
  "{{{
  return -1
endfunc "}}}

" Return the indent inside a <script> block for javascript.
func! s:Alien3()
  "{{{
  let lnum = prevnonblank(v:lnum - 1)
  while lnum > 1 && getline(lnum) =~ '^\s*/[/*]'
    " Skip over comments to avoid that cindent() aligns with the <script> tag
    let lnum = prevnonblank(lnum - 1)
  endwhile
  if lnum == b:hi_indent.blocklnr
    " indent for the first line after <script>
    return eval(b:hi_js1indent)
  endif
  if b:hi_indent.scripttype == "javascript"
    return cindent(v:lnum)
  else
    return -1
  endif
endfunc "}}}

" Return the indent inside a <style> block.
func! s:Alien4()
  "{{{
  if prevnonblank(v:lnum-1) == b:hi_indent.blocklnr
    " indent for first content line
    return eval(b:hi_css1indent)
  endif
  return s:CSSIndent()
endfunc "}}}

" Indending inside a <style> block.  Returns the indent.
func! s:CSSIndent()
  "{{{
  " This handles standard CSS and also Closure stylesheets where special lines
  " start with @.
  " When the line starts with '*' or the previous line starts with "/*"
  " and does not end in "*/", use C indenting to format the comment.
  " Adopted $VIMRUNTIME/indent/css.vim
  let curtext = getline(v:lnum)
  if curtext =~ '^\s*[*]'
        \ || (v:lnum > 1 && getline(v:lnum - 1) =~ '\s*/\*'
        \     && getline(v:lnum - 1) !~ '\*/\s*$')
    return cindent(v:lnum)
  endif

  let min_lnum = b:hi_indent.blocklnr
  let prev_lnum = s:CssPrevNonComment(v:lnum - 1, min_lnum)
  let [prev_lnum, found] = HtmlIndent_FindTagStart(prev_lnum)
  if prev_lnum <= min_lnum
    " Just below the <style> tag, indent for first content line after comments.
    return eval(b:hi_css1indent)
  endif

  " If the current line starts with "}" align with it's match.
  if curtext =~ '^\s*}'
    call cursor(v:lnum, 1)
    try
      normal! %
      " Found the matching "{", align with it after skipping unfinished lines.
      let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
      return indent(align_lnum)
    catch
      " can't find it, try something else, but it's most likely going to be
      " wrong
    endtry
  endif

  " add indent after {
  let brace_counts = HtmlIndent_CountBraces(prev_lnum)
  let extra = brace_counts.c_open * s:ShiftWidth()

  let prev_text = getline(prev_lnum)
  let below_end_brace = prev_text =~ '}\s*$'

  " Search back to align with the first line that's unfinished.
  let align_lnum = s:CssFirstUnfinished(prev_lnum, min_lnum)

  " Handle continuation lines if aligning with previous line and not after a
  " "}".
  if extra == 0 && align_lnum == prev_lnum && !below_end_brace
    let prev_hasfield = prev_text =~ '^\s*[a-zA-Z0-9-]\+:'
    let prev_special = prev_text =~ '^\s*\(/\*\|@\)'
    if curtext =~ '^\s*\(/\*\|@\)'
      " if the current line is not a comment or starts with @ (used by template
      " systems) reduce indent if previous line is a continuation line
      if !prev_hasfield && !prev_special
        let extra = -s:ShiftWidth()
      endif
    else
      let cur_hasfield = curtext =~ '^\s*[a-zA-Z0-9-]\+:'
      let prev_unfinished = s:CssUnfinished(prev_text)
      if !cur_hasfield && (prev_hasfield || prev_unfinished)
        " Continuation line has extra indent if the previous line was not a
        " continuation line.
        let extra = s:ShiftWidth()
        " Align with @if
        if prev_text =~ '^\s*@if '
          let extra = 4
        endif
      elseif cur_hasfield && !prev_hasfield && !prev_special
        " less indent below a continuation line
        let extra = -s:ShiftWidth()
      endif
    endif
  endif

  if below_end_brace
    " find matching {, if that line starts with @ it's not the start of a rule
    " but something else from a template system
    call cursor(prev_lnum, 1)
    call search('}\s*$')
    try
      normal! %
      " Found the matching "{", align with it.
      let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
      let special = getline(align_lnum) =~ '^\s*@'
    catch
      let special = 0
    endtry
    if special
      " do not reduce indent below @{ ... }
      if extra < 0
        let extra += s:ShiftWidth()
      endif
    else
      let extra -= (brace_counts.c_close - (prev_text =~ '^\s*}')) * s:ShiftWidth()
    endif
  endif

  " if no extra indent yet...
  if extra == 0
    if brace_counts.p_open > brace_counts.p_close
      " previous line has more ( than ): add a shiftwidth
      let extra = s:ShiftWidth()
    elseif brace_counts.p_open < brace_counts.p_close
      " previous line has more ) than (: subtract a shiftwidth
      let extra = -s:ShiftWidth()
    endif
  endif

  return indent(align_lnum) + extra
endfunc "}}}

" Inside <style>: Whether a line is unfinished.
func! s:CssUnfinished(text)
  "{{{
  return a:text =~ '\s\(||\|&&\|:\)\s*$'
endfunc "}}}

" Search back for the first unfinished line above "lnum".
func! s:CssFirstUnfinished(lnum, min_lnum)
  "{{{
  let align_lnum = a:lnum
  while align_lnum > a:min_lnum && s:CssUnfinished(getline(align_lnum - 1))
    let align_lnum -= 1
  endwhile
  return align_lnum
endfunc "}}}

" Find the non-empty line at or before "lnum" that is not a comment.
func! s:CssPrevNonComment(lnum, stopline)
  "{{{
  " caller starts from a line a:lnum + 1 that is not a comment
  let lnum = prevnonblank(a:lnum)
  while 1
    let ccol = match(getline(lnum), '\*/')
    if ccol < 0
      " No comment end thus its something else.
      return lnum
    endif
    call cursor(lnum, ccol + 1)
    " Search back for the /* that starts the comment
    let lnum = search('/\*', 'bW', a:stopline)
    if indent(".") == virtcol(".") - 1
      " The  found /* is at the start of the line. Now go back to the line
      " above it and again check if it is a comment.
      let lnum = prevnonblank(lnum - 1)
    else
      " /* is after something else, thus it's not a comment line.
      return lnum
    endif
  endwhile
endfunc "}}}

" Check the number of {} and () in line "lnum". Return a dict with the counts.
func! HtmlIndent_CountBraces(lnum)
  "{{{
  let brs = substitute(getline(a:lnum), '[''"].\{-}[''"]\|/\*.\{-}\*/\|/\*.*$\|[^{}()]', '', 'g')
  let c_open = 0
  let c_close = 0
  let p_open = 0
  let p_close = 0
  for brace in split(brs, '\zs')
    if brace == "{"
      let c_open += 1
    elseif brace == "}"
      if c_open > 0
        let c_open -= 1
      else
        let c_close += 1
      endif
    elseif brace == '('
      let p_open += 1
    elseif brace == ')'
      if p_open > 0
        let p_open -= 1
      else
        let p_close += 1
      endif
    endif
  endfor
  return {'c_open': c_open,
        \ 'c_close': c_close,
        \ 'p_open': p_open,
        \ 'p_close': p_close}
endfunc "}}}

" Return the indent for a comment: <!-- -->
func! s:Alien5()
  "{{{
  let curtext = getline(v:lnum)
  if curtext =~ '^\s*\zs-->'
    " current line starts with end of comment, line up with comment start.
    call cursor(v:lnum, 0)
    let lnum = search('<!--', 'b')
    if lnum > 0
      " TODO: what if <!-- is not at the start of the line?
      return indent(lnum)
    endif

    " Strange, can't find it.
    return -1
  endif

  let prevlnum = prevnonblank(v:lnum - 1)
  let prevtext = getline(prevlnum)
  let idx = match(prevtext, '^\s*\zs<!--')
  if idx >= 0
    " just below comment start, add a shiftwidth
    return idx + s:ShiftWidth()
  endif

  " Some files add 4 spaces just below a TODO line.  It's difficult to detect
  " the end of the TODO, so let's not do that.

  " Align with the previous non-blank line.
  return indent(prevlnum)
endfunc "}}}

" When the "lnum" line ends in ">" find the line containing the matching "<".
func! HtmlIndent_FindTagStart(lnum)
  "{{{
  " Avoids using the indent of a continuation line.
  " Moves the cursor.
  " Return two values:
  " - the matching line number or "lnum".
  " - a flag indicating whether we found the end of a tag.
  " This method is global so that HTML-like indenters can use it.
  " To avoid matching " > " or " < " inside a string require that the opening
  " "<" is followed by a word character and the closing ">" comes after a
  " non-white character.
  let idx = match(getline(a:lnum), '\S>\s*$')
  if idx > 0
    call cursor(a:lnum, idx)
    let lnum = searchpair('<\w', '' , '\S>', 'bW', '', max([a:lnum - b:html_indent_line_limit, 0]))
    if lnum > 0
      return [lnum, 1]
    endif
  endif
  return [a:lnum, 0]
endfunc "}}}

" Find the unclosed start tag from the current cursor position.
func! HtmlIndent_FindStartTag()
  "{{{
  " The cursor must be on or before a closing tag.
  " If found, positions the cursor at the match and returns the line number.
  " Otherwise returns 0.
  let tagname = matchstr(getline('.')[col('.') - 1:], '</\zs\w\+\ze')
  let start_lnum = searchpair('<' . tagname . '\>', '', '</' . tagname . '\>', 'bW')
  if start_lnum > 0
    return start_lnum
  endif
  return 0
endfunc "}}}

" Moves the cursor from a "<" to the matching ">".
func! HtmlIndent_FindTagEnd()
  "{{{
  " Call this with the cursor on the "<" of a start tag.
  " This will move the cursor to the ">" of the matching end tag or, when it's
  " a self-closing tag, to the matching ">".
  " Limited to look up to b:html_indent_line_limit lines away.
  let text = getline('.')
  let tagname = matchstr(text, '\w\+\|!--', col('.'))
  if tagname == '!--'
    call search('--\zs>')
  elseif s:get_tag('/' . tagname) != 0
    " tag with a closing tag, find matching "</tag>"
    call searchpair('<' . tagname, '', '</' . tagname . '\zs>', 'W', '', line('.') + b:html_indent_line_limit)
  else
    " self-closing tag, find the ">"
    call search('\S\zs>')
  endif
endfunc "}}}

" Indenting inside a start tag. Return the correct indent or -1 if unknown.
func! s:InsideTag(foundHtmlString)
  "{{{
  if a:foundHtmlString
    " Inside an attribute string.
    " Align with the previous line or use an external function.
    let lnum = v:lnum - 1
    if lnum > 1
      if exists('b:html_indent_tag_string_func')
        return b:html_indent_tag_string_func(lnum)
      endif
      return indent(lnum)
    endif
  endif

  " Should be another attribute: " attr="val".  Align with the previous
  " attribute start.
  let lnum = v:lnum
  while lnum > 1
    let lnum -= 1
    let text = getline(lnum)
    " Find a match with one of these, align with "attr":
    "       attr=
    "  <tag attr=
    "  text<tag attr=
    "  <tag>text</tag>text<tag attr=
    " For long lines search for the first match, finding the last match
    " gets very slow.
    if len(text) < 300
      let idx = match(text, '.*\s\zs[_a-zA-Z0-9-]\+="')
    else
      let idx = match(text, '\s\zs[_a-zA-Z0-9-]\+="')
    endif
    if idx > 0
      " Found the attribute.  TODO: assumes spaces, no Tabs.
      return idx
    endif
  endwhile
  return -1
endfunc "}}}

" THE MAIN INDENT FUNCTION. Return the amount of indent for v:lnum.
func! HtmlIndent()
  "{{{
  if prevnonblank(v:lnum - 1) <= 1
    " First non-blank line has no indent.
    return 0
  endif

  let curtext = tolower(getline(v:lnum))
  let indentunit = s:ShiftWidth()

  let b:hi_newstate = {}
  let b:hi_newstate.lnum = v:lnum

  " When syntax HL is enabled, detect we are inside a tag.  Indenting inside
  " a tag works very differently. Do not do this when the line starts with
  " "<", it gets the "htmlTag" ID but we are not inside a tag then.
  if curtext !~ '^\s*<'
    normal! ^
    let stack = synstack(v:lnum, col('.'))  " assumes there are no tabs
    let foundHtmlString = 0
    for synid in reverse(stack)
      let name = synIDattr(synid, "name")
      if index(b:hi_insideStringNames, name) >= 0
        let foundHtmlString = 1
      elseif index(b:hi_insideTagNames, name) >= 0
        " Yes, we are inside a tag.
        let indent = s:InsideTag(foundHtmlString)
        if indent >= 0
          " Do not keep the state. TODO: could keep the block type.
          let b:hi_indent.lnum = 0
          return indent
        endif
      endif
    endfor
  endif

  " does the line start with a closing tag?
  let swendtag = match(curtext, '^\s*</') >= 0

  if prevnonblank(v:lnum - 1) == b:hi_indent.lnum && b:hi_lasttick == b:changedtick - 1
    " use state (continue from previous line)
  else
    " start over (know nothing)
    let b:hi_indent = s:FreshState(v:lnum)
  endif

  if b:hi_indent.block >= 2
    " within block
    let endtag = s:endtags[b:hi_indent.block]
    let blockend = stridx(curtext, endtag)
    if blockend >= 0
      " block ends here
      let b:hi_newstate.block = 0
      " calc indent for REST OF LINE (may start more blocks):
      call s:CountTagsAndState(strpart(curtext, blockend + strlen(endtag)))
      if swendtag && b:hi_indent.block != 5
        let indent = b:hi_indent.blocktagind + s:curind * indentunit
        let b:hi_newstate.baseindent = indent + s:nextrel * indentunit
      else
        let indent = s:Alien{b:hi_indent.block}()
        let b:hi_newstate.baseindent = b:hi_indent.blocktagind + s:nextrel * indentunit
      endif
    else
      " block continues
      " indent this line with alien method
      let indent = s:Alien{b:hi_indent.block}()
    endif
  else
    " not within a block - within usual html
    let b:hi_newstate.block = b:hi_indent.block
    if swendtag
      " The current line starts with an end tag, align with its start tag.
      call cursor(v:lnum, 1)
      let start_lnum = HtmlIndent_FindStartTag()
      if start_lnum > 0
        " check for the line starting with something inside a tag:
        " <sometag               <- align here
        "    attr=val><open>     not here
        let text = getline(start_lnum)
        let angle = matchstr(text, '[<>]')
        if angle == '>'
          call cursor(start_lnum, 1)
          normal! f>%
          let start_lnum = line('.')
          let text = getline(start_lnum)
        endif

        let indent = indent(start_lnum)
        if col('.') > 2
          let swendtag = match(text, '^\s*</') >= 0
          call s:CountITags(text[: col('.') - 2])
          let indent += s:nextrel * s:ShiftWidth()
          if !swendtag
            let indent += s:curind * s:ShiftWidth()
          endif
        endif
      else
        " not sure what to do
        let indent = b:hi_indent.baseindent
      endif
      let b:hi_newstate.baseindent = indent
    else
      call s:CountTagsAndState(curtext)
      let indent = b:hi_indent.baseindent
      let b:hi_newstate.baseindent = indent + (s:curind + s:nextrel) * indentunit
    endif
  endif

  let b:hi_lasttick = b:changedtick
  call extend(b:hi_indent, b:hi_newstate, "force")
  return indent
endfunc "}}}

" Check user settings when loading this script the first time.
call HtmlIndent_CheckUserSettings()

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: fdm=marker ts=8 sw=2 tw=78
                                                                                                                                                                                                                                                                                                                                                                         usr/share/vim/vim74/indent/htmldjango.vim                                                           0100644 0000000 0000000 00000000421 13050207306 017037  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Django HTML template
" Maintainer:	Dave Hodder <dmh@dmh.org.uk>
" Last Change:	2007 Jan 25

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif

" Use HTML formatting rules.
runtime! indent/html.vim
                                                                                                                                                                                                                                               usr/share/vim/vim74/indent/idlang.vim                                                               0100644 0000000 0000000 00000003036 13050207306 016153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " IDL (Interactive Data Language) indent file.
" Language: IDL (ft=idlang)
" Last change:	2012 May 18
" Maintainer: Aleksandar Jelenak <ajelenak AT yahoo.com>

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
   finish
endif
let b:did_indent = 1

setlocal indentkeys=o,O,0=endif,0=ENDIF,0=endelse,0=ENDELSE,0=endwhile,0=ENDWHILE,0=endfor,0=ENDFOR,0=endrep,0=ENDREP

setlocal indentexpr=GetIdlangIndent(v:lnum)

" Only define the function once.
if exists("*GetIdlangIndent")
   finish
endif

function GetIdlangIndent(lnum)
   " First non-empty line above the current line.
   let pnum = prevnonblank(v:lnum-1)
   " v:lnum is the first non-empty line -- zero indent.
   if pnum == 0
      return 0
   endif
   " Second non-empty line above the current line.
   let pnum2 = prevnonblank(pnum-1)

   " Current indent.
   let curind = indent(pnum)

   " Indenting of continued lines.
   if getline(pnum) =~ '\$\s*\(;.*\)\=$'
      if getline(pnum2) !~ '\$\s*\(;.*\)\=$'
	 let curind = curind+&sw
      endif
   else
      if getline(pnum2) =~ '\$\s*\(;.*\)\=$'
	 let curind = curind-&sw
      endif
   endif

   " Indenting blocks of statements.
   if getline(v:lnum) =~? '^\s*\(endif\|endelse\|endwhile\|endfor\|endrep\)\>'
      if getline(pnum) =~? 'begin\>'
      elseif indent(v:lnum) > curind-&sw
	 let curind = curind-&sw
      else
	 return -1
      endif
   elseif getline(pnum) =~? 'begin\>'
      if indent(v:lnum) < curind+&sw
	 let curind = curind+&sw
      else
	 return -1
      endif
   endif
   return curind
endfunction

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/share/vim/vim74/indent/ishd.vim                                                                 0100644 0000000 0000000 00000003461 13050207306 015646  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Description:	InstallShield indenter
" Author:	Johannes Zellner <johannes@zellner.org>
" Last Change:	Tue, 27 Apr 2004 14:54:59 CEST

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif
let b:did_indent = 1

setlocal autoindent
setlocal indentexpr=GetIshdIndent(v:lnum)
setlocal indentkeys&
setlocal indentkeys+==else,=elseif,=endif,=end,=begin,<:>
" setlocal indentkeys-=0#

let b:undo_indent = "setl ai< indentexpr< indentkeys<"

" Only define the function once.
if exists("*GetIshdIndent")
    finish
endif

fun! GetIshdIndent(lnum)
    " labels and preprocessor get zero indent immediately
    let this_line = getline(a:lnum)
    let LABELS_OR_PREPROC = '^\s*\(\<\k\+\>:\s*$\|#.*\)'
    let LABELS_OR_PREPROC_EXCEPT = '^\s*\<default\+\>:'
    if this_line =~ LABELS_OR_PREPROC && this_line !~ LABELS_OR_PREPROC_EXCEPT
	return 0
    endif

    " Find a non-blank line above the current line.
    " Skip over labels and preprocessor directives.
    let lnum = a:lnum
    while lnum > 0
	let lnum = prevnonblank(lnum - 1)
	let previous_line = getline(lnum)
	if previous_line !~ LABELS_OR_PREPROC || previous_line =~ LABELS_OR_PREPROC_EXCEPT
	    break
	endif
    endwhile

    " Hit the start of the file, use zero indent.
    if lnum == 0
	return 0
    endif

    let ind = indent(lnum)

    " Add
    if previous_line =~ '^\s*\<\(function\|begin\|switch\|case\|default\|if.\{-}then\|else\|elseif\|while\|repeat\)\>'
	let ind = ind + &sw
    endif

    " Subtract
    if this_line =~ '^\s*\<endswitch\>'
	let ind = ind - 2 * &sw
    elseif this_line =~ '^\s*\<\(begin\|end\|endif\|endwhile\|else\|elseif\|until\)\>'
	let ind = ind - &sw
    elseif this_line =~ '^\s*\<\(case\|default\)\>'
	if previous_line !~ '^\s*\<switch\>'
	    let ind = ind - &sw
	endif
    endif

    return ind
endfun
                                                                                                                                                                                                               usr/share/vim/vim74/indent/j.vim                                                                    0100644 0000000 0000000 00000003371 13050207306 015150  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	J
" Maintainer:	David Bürgin <676c7473@gmail.com>
" URL:		https://github.com/glts/vim-j
" Last Change:	2014-04-05

if exists('b:did_indent')
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetJIndent()
setlocal indentkeys-=0{,0},:,0#
setlocal indentkeys+=0),0<:>,=case.,=catch.,=catchd.,=catcht.,=do.,=else.,=elseif.,=end.,=fcase.

let b:undo_indent = 'setlocal indentkeys< indentexpr<'

if exists('*GetJIndent')
  finish
endif

" If g:j_indent_definitions is true, the bodies of explicit definitions of
" adverbs, conjunctions, and verbs will be indented. Default is false (0).
if !exists('g:j_indent_definitions')
  let g:j_indent_definitions = 0
endif

function GetJIndent() abort
  let prevlnum = prevnonblank(v:lnum-1)
  if prevlnum == 0
    return 0
  endif
  let indent = indent(prevlnum)
  let prevline = getline(prevlnum)
  if prevline =~# '^\s*\%(case\|catch[dt]\=\|do\|else\%(if\)\=\|fcase\|for\%(_\a\k*\)\=\|if\|select\|try\|whil\%(e\|st\)\)\.\%(\%(\<end\.\)\@!.\)*$'
    " Increase indentation after an initial control word that starts or
    " continues a block and is not terminated by "end."
    let indent += shiftwidth()
  elseif g:j_indent_definitions && (prevline =~# '\<\%([1-4]\|13\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(:\s*0\|def\s\+0\|define\)\>' || prevline =~# '^\s*:\s*$')
    " Increase indentation in explicit definitions of adverbs, conjunctions,
    " and verbs
    let indent += shiftwidth()
  endif
  " Decrease indentation in lines that start with either control words that
  " continue or end a block, or the special items ")" and ":"
  if getline(v:lnum) =~# '^\s*\%()\|:\|\%(case\|catch[dt]\=\|do\|else\%(if\)\=\|end\|fcase\)\.\)'
    let indent -= shiftwidth()
  endif
  return indent
endfunction
                                                                                                                                                                                                                                                                       usr/share/vim/vim74/indent/java.vim                                                                 0100644 0000000 0000000 00000010023 13050207306 015630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Java
" Previous Maintainer: Toby Allsopp <toby.allsopp@peace.com>
" Current Maintainer: Hong Xu <xuhdev@gmail.com>
" Last Change:	2012 May 18
" Version: 1.0
" License: Same as Vim.
" Copyright (c) 2012 Hong Xu
" Before 2012, this file is maintained by Toby Allsopp.

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

" Indent Java anonymous classes correctly.
setlocal cindent cinoptions& cinoptions+=j1

" The "extends" and "implements" lines start off with the wrong indent.
setlocal indentkeys& indentkeys+=0=extends indentkeys+=0=implements

" Set the function to do the work.
setlocal indentexpr=GetJavaIndent()

let b:undo_indent = "set cin< cino< indentkeys< indentexpr<"

" Only define the function once.
if exists("*GetJavaIndent")
  finish
endif
let s:keepcpo= &cpo
set cpo&vim

function! SkipJavaBlanksAndComments(startline)
  let lnum = a:startline
  while lnum > 1
    let lnum = prevnonblank(lnum)
    if getline(lnum) =~ '\*/\s*$'
      while getline(lnum) !~ '/\*' && lnum > 1
        let lnum = lnum - 1
      endwhile
      if getline(lnum) =~ '^\s*/\*'
        let lnum = lnum - 1
      else
        break
      endif
    elseif getline(lnum) =~ '^\s*//'
      let lnum = lnum - 1
    else
      break
    endif
  endwhile
  return lnum
endfunction

function GetJavaIndent()

  " Java is just like C; use the built-in C indenting and then correct a few
  " specific cases.
  let theIndent = cindent(v:lnum)

  " If we're in the middle of a comment then just trust cindent
  if getline(v:lnum) =~ '^\s*\*'
    return theIndent
  endif

  " find start of previous line, in case it was a continuation line
  let lnum = SkipJavaBlanksAndComments(v:lnum - 1)

  " If the previous line starts with '@', we should have the same indent as
  " the previous one
  if getline(lnum) =~ '^\s*@\S\+\s*$'
    return indent(lnum)
  endif

  let prev = lnum
  while prev > 1
    let next_prev = SkipJavaBlanksAndComments(prev - 1)
    if getline(next_prev) !~ ',\s*$'
      break
    endif
    let prev = next_prev
  endwhile

  " Try to align "throws" lines for methods and "extends" and "implements" for
  " classes.
  if getline(v:lnum) =~ '^\s*\(extends\|implements\)\>'
        \ && getline(lnum) !~ '^\s*\(extends\|implements\)\>'
    let theIndent = theIndent + &sw
  endif

  " correct for continuation lines of "throws", "implements" and "extends"
  let cont_kw = matchstr(getline(prev),
        \ '^\s*\zs\(throws\|implements\|extends\)\>\ze.*,\s*$')
  if strlen(cont_kw) > 0
    let amount = strlen(cont_kw) + 1
    if getline(lnum) !~ ',\s*$'
      let theIndent = theIndent - (amount + &sw)
      if theIndent < 0
        let theIndent = 0
      endif
    elseif prev == lnum
      let theIndent = theIndent + amount
      if cont_kw ==# 'throws'
        let theIndent = theIndent + &sw
      endif
    endif
  elseif getline(prev) =~ '^\s*\(throws\|implements\|extends\)\>'
        \ && (getline(prev) =~ '{\s*$'
        \  || getline(v:lnum) =~ '^\s*{\s*$')
    let theIndent = theIndent - &sw
  endif

  " When the line starts with a }, try aligning it with the matching {,
  " skipping over "throws", "extends" and "implements" clauses.
  if getline(v:lnum) =~ '^\s*}\s*\(//.*\|/\*.*\)\=$'
    call cursor(v:lnum, 1)
    silent normal %
    let lnum = line('.')
    if lnum < v:lnum
      while lnum > 1
        let next_lnum = SkipJavaBlanksAndComments(lnum - 1)
        if getline(lnum) !~ '^\s*\(throws\|extends\|implements\)\>'
              \ && getline(next_lnum) !~ ',\s*$'
          break
        endif
        let lnum = prevnonblank(next_lnum)
      endwhile
      return indent(lnum)
    endif
  endif

  " Below a line starting with "}" never indent more.  Needed for a method
  " below a method with an indented "throws" clause.
  let lnum = SkipJavaBlanksAndComments(v:lnum - 1)
  if getline(lnum) =~ '^\s*}\s*\(//.*\|/\*.*\)\=$' && indent(lnum) < theIndent
    let theIndent = indent(lnum)
  endif

  return theIndent
endfunction

let &cpo = s:keepcpo
unlet s:keepcpo

" vi: sw=2 et
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/share/vim/vim74/indent/javascript.vim                                                           0100644 0000000 0000000 00000000520 13050207306 017056  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Javascript
" Maintainer:	None!  Wanna improve this?
" Last Change:	2007 Jan 22

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
   finish
endif
let b:did_indent = 1

" C indenting is not too bad.
setlocal cindent
setlocal cinoptions+=j1,J1

let b:undo_indent = "setl cin<"
                                                                                                                                                                                usr/share/vim/vim74/indent/json.vim                                                                 0100644 0000000 0000000 00000010463 13050207306 015670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:		JSON
" Mantainer:		Eli Parra <eli@elzr.com> https://github.com/elzr/vim-json
" Last Change:          2014 Aug 29
"   https://github.com/jakar/vim-json/commit/20b650e22aa750c4ab6a66aa646bdd95d7cd548a#diff-e81fc111b2052e306d126bd9989f7b7c
" Original Author:	Rogerz Zhang <rogerz.zhang at gmail.com> http://github.com/rogerz/vim-json
" Acknowledgement:      Based off of vim-javascript maintained by Darrick Wiebe 
"                       http://www.vim.org/scripts/script.php?script_id=2765

" 0. Initialization {{{1
" =================

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal nosmartindent

" Now, set up our indentation expression and keys that trigger it.
setlocal indentexpr=GetJSONIndent()
setlocal indentkeys=0{,0},0),0[,0],!^F,o,O,e

" Only define the function once.
if exists("*GetJSONIndent")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

" 1. Variables {{{1
" ============

let s:line_term = '\s*\%(\%(\/\/\).*\)\=$'
" Regex that defines blocks.
let s:block_regex = '\%({\)\s*\%(|\%([*@]\=\h\w*,\=\s*\)\%(,\s*[*@]\=\h\w*\)*|\)\=' . s:line_term

" 2. Auxiliary Functions {{{1
" ======================

" Check if the character at lnum:col is inside a string.
function s:IsInString(lnum, col)
  return synIDattr(synID(a:lnum, a:col, 1), 'name') == 'jsonString'
endfunction

" Find line above 'lnum' that isn't empty, or in a string.
function s:PrevNonBlankNonString(lnum)
  let lnum = prevnonblank(a:lnum)
  while lnum > 0
    " If the line isn't empty or in a string, end search.
    let line = getline(lnum)
    if !(s:IsInString(lnum, 1) && s:IsInString(lnum, strlen(line)))
      break
    endif
    let lnum = prevnonblank(lnum - 1)
  endwhile
  return lnum
endfunction

" Check if line 'lnum' has more opening brackets than closing ones.
function s:LineHasOpeningBrackets(lnum)
  let open_0 = 0
  let open_2 = 0
  let open_4 = 0
  let line = getline(a:lnum)
  let pos = match(line, '[][(){}]', 0)
  while pos != -1
    let idx = stridx('(){}[]', line[pos])
    if idx % 2 == 0
      let open_{idx} = open_{idx} + 1
    else
      let open_{idx - 1} = open_{idx - 1} - 1
    endif
    let pos = match(line, '[][(){}]', pos + 1)
  endwhile
  return (open_0 > 0) . (open_2 > 0) . (open_4 > 0)
endfunction

function s:Match(lnum, regex)
  let col = match(getline(a:lnum), a:regex) + 1
  return col > 0 && !s:IsInString(a:lnum, col) ? col : 0
endfunction

" 3. GetJSONIndent Function {{{1
" =========================

function GetJSONIndent()
  " 3.1. Setup {{{2
  " ----------

  " Set up variables for restoring position in file.  Could use v:lnum here.
  let vcol = col('.')

  " 3.2. Work on the current line {{{2
  " -----------------------------

  " Get the current line.
  let line = getline(v:lnum)
  let ind = -1

  " If we got a closing bracket on an empty line, find its match and indent
  " according to it.
  let col = matchend(line, '^\s*[]}]')

  if col > 0 && !s:IsInString(v:lnum, col)
    call cursor(v:lnum, col)
    let bs = strpart('{}[]', stridx('}]', line[col - 1]) * 2, 2)

    let pairstart = escape(bs[0], '[')
    let pairend = escape(bs[1], ']')
    let pairline = searchpair(pairstart, '', pairend, 'bW')

    if pairline > 0 
      let ind = indent(pairline)
    else
      let ind = virtcol('.') - 1
    endif

    return ind
  endif

  " If we are in a multi-line string, don't do anything to it.
  if s:IsInString(v:lnum, matchend(line, '^\s*') + 1)
    return indent('.')
  endif

  " 3.3. Work on the previous line. {{{2
  " -------------------------------

  let lnum = prevnonblank(v:lnum - 1)

  if lnum == 0
    return 0
  endif

  " Set up variables for current line.
  let line = getline(lnum)
  let ind = indent(lnum)

  " If the previous line ended with a block opening, add a level of indent.
  " if s:Match(lnum, s:block_regex)
    " return indent(lnum) + &sw
  " endif

  " If the previous line contained an opening bracket, and we are still in it,
  " add indent depending on the bracket type.
  if line =~ '[[({]'
    let counts = s:LineHasOpeningBrackets(lnum)
    if counts[0] == '1' || counts[1] == '1' || counts[2] == '1'
      return ind + &sw
    else
      call cursor(v:lnum, vcol)
    end
  endif

  " }}}2

  return ind
endfunction

" }}}1

let &cpo = s:cpo_save
unlet s:cpo_save

" vim:set sw=2 sts=2 ts=8 noet:
                                                                                                                                                                                                             usr/share/vim/vim74/indent/jsp.vim                                                                  0100644 0000000 0000000 00000000716 13050207306 015513  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim filetype indent file
" Language:    JSP files
" Maintainer:  David Fishburn <fishburn@ianywhere.com>
" Version:     1.0
" Last Change: Wed Nov 08 2006 11:08:05 AM

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif

" If there has been no specific JSP indent script created, 
" use the default html indent script which will handle
" html, javascript and most of the JSP constructs.
runtime! indent/html.vim


                                                  usr/share/vim/vim74/indent/ld.vim                                                                   0100644 0000000 0000000 00000003331 13050207306 015312  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:         ld(1) script
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2006-12-20

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetLDIndent()
setlocal indentkeys=0{,0},!^F,o,O
setlocal nosmartindent

if exists("*GetLDIndent")
  finish
endif

function s:prevnonblanknoncomment(lnum)
  let lnum = a:lnum
  while lnum > 1
    let lnum = prevnonblank(lnum)
    let line = getline(lnum)
    if line =~ '\*/'
      while lnum > 1 && line !~ '/\*'
        let lnum -= 1
      endwhile
      if line =~ '^\s*/\*'
        let lnum -= 1
      else
        break
      endif
    else
      break
    endif
  endwhile
  return lnum
endfunction

function s:count_braces(lnum, count_open)
  let n_open = 0
  let n_close = 0
  let line = getline(a:lnum)
  let pattern = '[{}]'
  let i = match(line, pattern)
  while i != -1
    if synIDattr(synID(a:lnum, i + 1, 0), 'name') !~ 'ld\%(Comment\|String\)'
      if line[i] == '{'
        let n_open += 1
      elseif line[i] == '}'
        if n_open > 0
          let n_open -= 1
        else
          let n_close += 1
        endif
      endif
    endif
    let i = match(line, pattern, i + 1)
  endwhile
  return a:count_open ? n_open : n_close
endfunction

function GetLDIndent()
  let line = getline(v:lnum)
  if line =~ '^\s*\*'
    return cindent(v:lnum)
  elseif line =~ '^\s*}'
    return indent(v:lnum) - &sw
  endif

  let pnum = s:prevnonblanknoncomment(v:lnum - 1)
  if pnum == 0
    return 0
  endif

  let ind = indent(pnum) + s:count_braces(pnum, 1) * &sw

  let pline = getline(pnum)
  if pline =~ '}\s*$'
    let ind -= (s:count_braces(pnum, 0) - (pline =~ '^\s*}' ? 1 : 0)) * &sw
  endif

  return ind
endfunction
                                                                                                                                                                                                                                                                                                       usr/share/vim/vim74/indent/lifelines.vim                                                            0100644 0000000 0000000 00000001175 13050207306 016671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	LifeLines
" Maintainer:	Patrick Texier <p.texier@orsennes.com>
" Location:	<http://patrick.texier.free.fr/vim/indent/lifelines.vim>
" Last Change:	2010 May 7

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif
let b:did_indent = 1

" LifeLines uses cindent without ; line terminator, C functions
" declarations, C keywords, C++ formating
setlocal cindent
setlocal cinwords=""
setlocal cinoptions+=+0
setlocal cinoptions+=p0
setlocal cinoptions+=i0
setlocal cinoptions+=t0
setlocal cinoptions+=*500

let b:undo_indent = "setl cin< cino< cinw<"
" vim: ts=8 sw=4
                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/vim/vim74/indent/liquid.vim                                                               0100644 0000000 0000000 00000003527 13050207306 016211  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:     Liquid
" Maintainer:   Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2013 May 30

if exists('b:did_indent')
  finish
endif

set indentexpr=
if exists('b:liquid_subtype')
  exe 'runtime! indent/'.b:liquid_subtype.'.vim'
else
  runtime! indent/html.vim
endif
unlet! b:did_indent

if &l:indentexpr == ''
  if &l:cindent
    let &l:indentexpr = 'cindent(v:lnum)'
  else
    let &l:indentexpr = 'indent(prevnonblank(v:lnum-1))'
  endif
endif
let b:liquid_subtype_indentexpr = &l:indentexpr

let b:did_indent = 1

setlocal indentexpr=GetLiquidIndent()
setlocal indentkeys=o,O,*<Return>,<>>,{,},0),0],o,O,!^F,=end,=endif,=endunless,=endifchanged,=endcase,=endfor,=endtablerow,=endcapture,=else,=elsif,=when,=empty

" Only define the function once.
if exists('*GetLiquidIndent')
  finish
endif

function! s:count(string,pattern)
  let string = substitute(a:string,'\C'.a:pattern,"\n",'g')
  return strlen(substitute(string,"[^\n]",'','g'))
endfunction

function! GetLiquidIndent(...)
  if a:0 && a:1 == '.'
    let v:lnum = line('.')
  elseif a:0 && a:1 =~ '^\d'
    let v:lnum = a:1
  endif
  let vcol = col('.')
  call cursor(v:lnum,1)
  exe "let ind = ".b:liquid_subtype_indentexpr
  let lnum = prevnonblank(v:lnum-1)
  let line = getline(lnum)
  let cline = getline(v:lnum)
  let line  = substitute(line,'\C^\%(\s*{%\s*end\w*\s*%}\)\+','','')
  let line .= matchstr(cline,'\C^\%(\s*{%\s*end\w*\s*%}\)\+')
  let cline = substitute(cline,'\C^\%(\s*{%\s*end\w*\s*%}\)\+','','')
  let ind += &sw * s:count(line,'{%\s*\%(if\|elsif\|else\|unless\|ifchanged\|case\|when\|for\|empty\|tablerow\|capture\)\>')
  let ind -= &sw * s:count(line,'{%\s*end\%(if\|unless\|ifchanged\|case\|for\|tablerow\|capture\)\>')
  let ind -= &sw * s:count(cline,'{%\s*\%(elsif\|else\|when\|empty\)\>')
  let ind -= &sw * s:count(cline,'{%\s*end\w*$')
  return ind
endfunction
                                                                                                                                                                         usr/share/vim/vim74/indent/lisp.vim                                                                 0100644 0000000 0000000 00000000541 13050207306 015662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Lisp
" Maintainer:    Sergey Khorev <sergey.khorev@gmail.com>
" URL:		 http://sites.google.com/site/khorser/opensource/vim
" Last Change:	2012 Jan 10

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
   finish
endif
let b:did_indent = 1

setlocal ai nosi

let b:undo_indent = "setl ai< si<"
                                                                                                                                                               usr/share/vim/vim74/indent/logtalk.vim                                                              0100644 0000000 0000000 00000003232 13050207306 016350  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        "  Maintainer:	Paulo Moura <pmoura@logtalk.org>
"  Revised on:	2008.06.02
"  Language:	Logtalk

" This Logtalk indent file is a modified version of the Prolog
" indent file written by Gergely Kontra

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
	finish
endif

let b:did_indent = 1

setlocal indentexpr=GetLogtalkIndent()
setlocal indentkeys-=:,0#
setlocal indentkeys+=0%,-,0;,>,0)

" Only define the function once.
if exists("*GetLogtalkIndent")
	finish
endif

function! GetLogtalkIndent()
	" Find a non-blank line above the current line.
	let pnum = prevnonblank(v:lnum - 1)
	" Hit the start of the file, use zero indent.
	if pnum == 0
		return 0
	endif
	let line = getline(v:lnum)
	let pline = getline(pnum)

	let ind = indent(pnum)
	" Previous line was comment -> use previous line's indent
	if pline =~ '^\s*%'
		retu ind
	endif
	" Check for entity opening directive on previous line
	if pline =~ '^\s*:-\s\(object\|protocol\|category\)\ze(.*,$'
		let ind = ind + &sw
	" Check for clause head on previous line
	elseif pline =~ ':-\s*\(%.*\)\?$'
		let ind = ind + &sw
	" Check for entity closing directive on previous line
	elseif pline =~ '^\s*:-\send_\(object\|protocol\|category\)\.\(%.*\)\?$'
		let ind = ind - &sw
	" Check for end of clause on previous line
	elseif pline =~ '\.\s*\(%.*\)\?$'
		let ind = ind - &sw
	endif
	" Check for opening conditional on previous line
	if pline =~ '^\s*\([(;]\|->\)' && pline !~ '\.\s*\(%.*\)\?$' && pline !~ '^.*\([)][,]\s*\(%.*\)\?$\)'
		let ind = ind + &sw
	endif
	" Check for closing an unclosed paren, or middle ; or ->
	if line =~ '^\s*\([);]\|->\)'
		let ind = ind - &sw
	endif
	return ind
endfunction
                                                                                                                                                                                                                                                                                                                                                                      usr/share/vim/vim74/indent/lua.vim                                                                  0100644 0000000 0000000 00000003572 13050207306 015503  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Lua script
" Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
" First Author:	Max Ischenko <mfi 'at' ukr.net>
" Last Change:	2007 Jul 23

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetLuaIndent()

" To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
" on the current line ('else' is default and includes 'elseif').
setlocal indentkeys+=0=end,0=until

setlocal autoindent

" Only define the function once.
if exists("*GetLuaIndent")
  finish
endif

function! GetLuaIndent()
  " Find a non-blank line above the current line.
  let prevlnum = prevnonblank(v:lnum - 1)

  " Hit the start of the file, use zero indent.
  if prevlnum == 0
    return 0
  endif

  " Add a 'shiftwidth' after lines that start a block:
  " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{'
  let ind = indent(prevlnum)
  let prevline = getline(prevlnum)
  let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
  if midx == -1
    let midx = match(prevline, '{\s*$')
    if midx == -1
      let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
    endif
  endif

  if midx != -1
    " Add 'shiftwidth' if what we found previously is not in a comment and
    " an "end" or "until" is not present on the same line.
    if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
      let ind = ind + &shiftwidth
    endif
  endif

  " Subtract a 'shiftwidth' on end, else (and elseif), until and '}'
  " This is the part that requires 'indentkeys'.
  let midx = match(getline(v:lnum), '^\s*\%(end\|else\|until\|}\)')
  if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
    let ind = ind - &shiftwidth
  endif

  return ind
endfunction
                                                                                                                                      usr/share/vim/vim74/indent/mail.vim                                                                 0100644 0000000 0000000 00000000464 13050207306 015641  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	Mail
" Maintainer:	Bram Moolenaar
" Last Change:	2009 Jun 03

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

" What works best is auto-indenting, disable other indenting.
" For formatting see the ftplugin.
setlocal autoindent nosmartindent nocindent indentexpr=
                                                                                                                                                                                                            usr/share/vim/vim74/indent/make.vim                                                                 0100644 0000000 0000000 00000006547 13050207306 015644  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:         Makefile
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2007-05-07

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetMakeIndent()
setlocal indentkeys=!^F,o,O,<:>,=else,=endif
setlocal nosmartindent

if exists("*GetMakeIndent")
  finish
endif

let s:comment_rx = '^\s*#'
let s:rule_rx = '^[^ \t#:][^#:]*:\{1,2}\%([^=:]\|$\)'
let s:continued_rule_rx = '^[^#:]*:\{1,2}\%([^=:]\|$\)'
let s:continuation_rx = '\\$'
let s:assignment_rx = '^\s*\h\w*\s*[+?]\==\s*\zs.*\\$'
let s:folded_assignment_rx = '^\s*\h\w*\s*[+?]\=='
" TODO: This needs to be a lot more restrictive in what it matches.
let s:just_inserted_rule_rx = '^\s*[^#:]\+:\{1,2}$'
let s:conditional_directive_rx = '^ *\%(ifn\=\%(eq\|def\)\|else\)\>'
let s:end_conditional_directive_rx = '^\s*\%(else\|endif\)\>'

function s:remove_continuation(line)
  return substitute(a:line, s:continuation_rx, "", "")
endfunction

function GetMakeIndent()
  " TODO: Should this perhaps be v:lnum -1?
"  let prev_lnum = prevnonblank(v:lnum - 1)
  let prev_lnum = v:lnum - 1
  if prev_lnum == 0
    return 0
  endif
  let prev_line = getline(prev_lnum)

  let prev_prev_lnum = prev_lnum - 1
  let prev_prev_line = prev_prev_lnum != 0 ? getline(prev_prev_lnum) : ""

  " TODO: Deal with comments.  In comments, continuations aren't interesting.
  if prev_line =~ s:continuation_rx
    if prev_prev_line =~ s:continuation_rx
      return indent(prev_lnum)
    elseif prev_line =~ s:rule_rx
      return &sw
    elseif prev_line =~ s:assignment_rx
      call cursor(prev_lnum, 1)
      if search(s:assignment_rx, 'W') != 0
        return virtcol('.') - 1
      else
        " TODO: ?
        return &sw
      endif
    else
      " TODO: OK, this might be a continued shell command, so perhaps indent
      " properly here?  Leave this out for now, but in the next release this
      " should be using indent/sh.vim somehow.
      "if prev_line =~ '^\t' " s:rule_command_rx
      "  if prev_line =~ '^\s\+[@-]\%(if\)\>'
      "    return indent(prev_lnum) + 2
      "  endif
      "endif
      return indent(prev_lnum) + &sw
    endif
  elseif prev_prev_line =~ s:continuation_rx
    let folded_line = s:remove_continuation(prev_prev_line) . ' ' . s:remove_continuation(prev_line)
    let lnum = prev_prev_lnum - 1
    let line = getline(lnum)
    while line =~ s:continuation_rx
      let folded_line = s:remove_continuation(line) . ' ' . folded_line
      let lnum -= 1
      let line = getline(lnum)
    endwhile
    let folded_lnum = lnum + 1
    if folded_line =~ s:rule_rx
      if getline(v:lnum) =~ s:rule_rx
        return 0
      else
        return &ts
      endif
    else
"    elseif folded_line =~ s:folded_assignment_rx
      if getline(v:lnum) =~ s:rule_rx
        return 0
      else
        return indent(folded_lnum)
      endif
"    else
"      " TODO: ?
"      return indent(prev_lnum)
    endif
  elseif prev_line =~ s:rule_rx
    if getline(v:lnum) =~ s:rule_rx
      return 0
    else
      return &ts
    endif
  elseif prev_line =~ s:conditional_directive_rx
    return &sw
  else
    let line = getline(v:lnum)
    if line =~ s:just_inserted_rule_rx
      return 0
    elseif line =~ s:end_conditional_directive_rx
      return v:lnum - 1 == 0 ? 0 : indent(v:lnum - 1) - &sw
    else
      return v:lnum - 1 == 0 ? 0 : indent(v:lnum - 1)
    endif
  endif
endfunction
                                                                                                                                                         usr/share/vim/vim74/indent/matlab.vim                                                               0100644 0000000 0000000 00000003610 13050207306 016153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Matlab indent file
" Language:	Matlab
" Maintainer:	Christophe Poucet <christophe.poucet@pandora.be>
" Last Change:	6 January, 2001

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

" Some preliminary setting
setlocal indentkeys=!,o,O=end,=case,=else,=elseif,=otherwise,=catch


setlocal indentexpr=GetMatlabIndent(v:lnum)

" Only define the function once.
if exists("*GetMatlabIndent")
  finish
endif

function GetMatlabIndent(lnum)
  " Give up if this line is explicitly joined.
  if getline(a:lnum - 1) =~ '\\$'
    return -1
  endif

  " Search backwards for the first non-empty line.
  let plnum = a:lnum - 1
  while plnum > 0 && getline(plnum) =~ '^\s*$'
    let plnum = plnum - 1
  endwhile

  if plnum == 0
    " This is the first non-empty line, use zero indent.
    return 0
  endif

  let curind = indent(plnum)

  " If the current line is a stop-block statement...
  if getline(v:lnum) =~ '^\s*\(end\|else\|elseif\|case\|otherwise\|catch\)\>'
    " See if this line does not follow the line right after an openblock
    if getline(plnum) =~ '^\s*\(for\|if\|else\|elseif\|case\|while\|switch\|try\|otherwise\|catch\)\>'
    " See if the user has already dedented
    elseif indent(v:lnum) > curind - &sw
      " If not, recommend one dedent
	let curind = curind - &sw
    else
      " Otherwise, trust the user
      return -1
    endif
"  endif

  " If the previous line opened a block
  elseif getline(plnum) =~ '^\s*\(for\|if\|else\|elseif\|case\|while\|switch\|try\|otherwise\|catch\)\>'
    " See if the user has already indented
    if indent(v:lnum) < curind + &sw
      "If not, recommend indent
      let curind = curind + &sw
    else
      " Otherwise, trust the user
      return -1
    endif
  endif



  " If we got to here, it means that the user takes the standardversion, so we return it
  return curind
endfunction

" vim:sw=2
                                                                                                                        usr/share/vim/vim74/indent/mma.vim                                                                  0100644 0000000 0000000 00000004263 13050207306 015472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:     Mathematica
" Author:       steve layland <layland@wolfram.com>
" Last Change:  Sat May  10 18:56:22 CDT 2005
" Source:       http://vim.sourceforge.net/scripts/script.php?script_id=1274
"               http://members.wolfram.com/layland/vim/indent/mma.vim
"
" NOTE:
" Empty .m files will automatically be presumed to be Matlab files
" unless you have the following in your .vimrc:
"
"       let filetype_m="mma"
"
" Credits:
" o steve hacked this out of a random indent file in the Vim 6.1
"   distribution that he no longer remembers...sh.vim?  Thanks!

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif
let b:did_indent = 1

setlocal indentexpr=GetMmaIndent()
setlocal indentkeys+=0[,0],0(,0)
setlocal nosi "turn off smart indent so we don't over analyze } blocks

if exists("*GetMmaIndent")
    finish
endif

function GetMmaIndent()

    " Hit the start of the file, use zero indent.
    if v:lnum == 0
        return 0
    endif

     " Find a non-blank line above the current line.
    let lnum = prevnonblank(v:lnum - 1)

    " use indenting as a base
    let ind = indent(v:lnum)
    let lnum = v:lnum

    " if previous line has an unmatched bracket, or ( indent.
    " doesn't do multiple parens/blocks/etc...

    " also, indent only if this line if this line isn't starting a new
    " block... TODO - fix this with indentkeys?
    if getline(v:lnum-1) =~ '\\\@<!\%(\[[^\]]*\|([^)]*\|{[^}]*\)$' && getline(v:lnum) !~ '\s\+[\[({]'
        let ind = ind+&sw
    endif

    " if this line had unmatched closing block,
    " indent to the matching opening block
    if getline(v:lnum) =~ '[^[]*]\s*$'
        " move to the closing bracket
        call search(']','bW')
        " and find it's partner's indent
        let ind = indent(searchpair('\[','',']','bWn'))
    " same for ( blocks
    elseif getline(v:lnum) =~ '[^(]*)$'
        call search(')','bW')
        let ind = indent(searchpair('(','',')','bWn'))

    " and finally, close { blocks if si ain't already set
    elseif getline(v:lnum) =~ '[^{]*}'
        call search('}','bW')
        let ind = indent(searchpair('{','','}','bWn'))
    endif

    return ind
endfunction

                                                                                                                                                                                                                                                                                                                                             usr/share/vim/vim74/indent/mp.vim                                                                   0100644 0000000 0000000 00000014577 13050207306 015345  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " MetaPost indent file
" Language:	MetaPost
" Maintainer:	Eugene Minkovskii <emin@mccme.ru>
" Last Change:	2012 May 18
" Version: 0.1
" ==========================================================================

" Identation Rules: {{{1
" First of all, MetaPost language don't expect any identation rules.
" This screept need for you only if you (not MetaPost) need to do
" exactly code. If you don't need to use indentation, see
" :help filetype-indent-off
"
" Note: Every rules of identation in MetaPost or TeX languages (and in some
" other of course) is very subjective. I can release only my vision of this
" promlem.
"
" ..........................................................................
" Example of correct (by me) identation {{{2
" shiftwidth=4
" ==========================================================================
" for i=0 upto 99:
"     z[i] = (0,1u) rotated (i*360/100);
" endfor
" draw z0 -- z10 -- z20
"         withpen ...     % <- 2sw because breaked line
"         withcolor ...;  % <- same as previous
" draw z0 for i=1 upto 99:
"             -- z[i]             % <- 1sw from left end of 'for' satement
"         endfor withpen ...      % <- 0sw from left end of 'for' satement
"                 withcolor ...;  % <- 2sw because breaked line
" draw if One:     % <- This is internal if (like 'for' above)
"          one
"      elsif Other:
"          other
"      fi withpen ...;
" if one:          % <- This is external if
"     draw one;
" elseif other:
"     draw other;
" fi
" draw z0; draw z1;
" }}}
" }}}

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetMetaPostIndent()
setlocal indentkeys+=;,<:>,=if,=for,=def,=end,=else,=fi

" Only define the function once.
if exists("*GetMetaPostIndent")
  finish
endif
let s:keepcpo= &cpo
set cpo&vim

" Auxiliary Definitions: {{{1
function! MetaNextNonblankNoncomment(pos)
  " Like nextnonblank() but ignore comment lines
  let tmp = nextnonblank(a:pos)
  while tmp && getline(tmp) =~ '^\s*%'
    let tmp = nextnonblank(tmp+1)
  endwhile
  return tmp
endfunction

function! MetaPrevNonblankNoncomment(pos)
  " Like prevnonblank() but ignore comment lines
  let tmp = prevnonblank(a:pos)
  while tmp && getline(tmp) =~ '^\s*%'
    let tmp = prevnonblank(tmp-1)
  endwhile
  return tmp
endfunction

function! MetaSearchNoncomment(pattern, ...)
  " Like search() but ignore commented areas
  if a:0
    let flags = a:1
  elseif &wrapscan
    let flags = "w"
  else
    let flags = "W"
  endif
  let cl  = line(".")
  let cc  = col(".")
  let tmp = search(a:pattern, flags)
  while tmp && synIDattr(synID(line("."), col("."), 1), "name") =~
        \ 'm[fp]\(Comment\|TeXinsert\|String\)'
    let tmp = search(a:pattern, flags)
  endwhile
  if !tmp
    call cursor(cl,cc)
  endif
  return tmp
endfunction
" }}}

function! GetMetaPostIndent()
  " not indent in comment ???
  if synIDattr(synID(line("."), col("."), 1), "name") =~
        \ 'm[fp]\(Comment\|TeXinsert\|String\)'
    return -1
  endif
  " Some RegExps: {{{1
  " end_of_item: all of end by ';'
  "            + all of end by :endfor, :enddef, :endfig, :endgroup, :fi
  "            + all of start by :beginfig(num), :begingroup
  "            + all of start by :for, :if, :else, :elseif and end by ':'
  "            + all of start by :def, :vardef             and end by '='
  let end_of_item = '\('                              .
        \ ';\|'                                       .
        \ '\<\(end\(for\|def\|fig\|group\)\|fi\)\>\|' .
        \ '\<begin\(group\>\|fig\s*(\s*\d\+\s*)\)\|'  .
        \ '\<\(for\|if\|else\(if\)\=\)\>.\+:\|'       .
        \ '\<\(var\)\=def\>.\+='                      . '\)'
  " }}}
  " Save: current position {{{1
  let cl = line   (".")
  let cc = col    (".")
  let cs = getline(".")
  " if it is :beginfig or :endfig use zero indent
  if  cs =~ '^\s*\(begin\|end\)fig\>'
    return 0
  endif
  " }}}
  " Initialise: ind variable {{{1
  " search previous item not in current line
  let p_semicol_l = MetaSearchNoncomment(end_of_item,"bW")
  while p_semicol_l == cl
    let p_semicol_l = MetaSearchNoncomment(end_of_item,"bW")
  endwhile
  " if this is first item in program use zero indent
  if !p_semicol_l
    return 0
  endif
  " if this is multiline item, remember first indent
  if MetaNextNonblankNoncomment(p_semicol_l+1) < cl
    let ind = indent(MetaNextNonblankNoncomment(p_semicol_l+1))
  " else --- search pre-previous item for search first line in previous item
  else
    " search pre-previous item not in current line
    let pp_semicol_l = MetaSearchNoncomment(end_of_item,"bW")
    while pp_semicol_l == p_semicol_l
      let pp_semicol_l = MetaSearchNoncomment(end_of_item,"bW")
    endwhile
    " if we find pre-previous item, remember indent of previous item
    " else --- remember zero
    if pp_semicol_l
      let ind = indent(MetaNextNonblankNoncomment(line(".")+1))
    else
      let ind = 0
    endif
  endif
  " }}}
  " Increase Indent: {{{1
  " if it is an internal/external :for or :if statements {{{2
  let pnn_s = getline(MetaPrevNonblankNoncomment(cl-1))
  if  pnn_s =~ '\<\(for\|if\)\>.\+:\s*\($\|%\)'
    let ind = match(pnn_s, '\<\(for\|if\)\>.\+:\s*\($\|%\)') + &sw
  " }}}
  " if it is a :def, :vardef, :beginfig, :begingroup, :else, :elseif {{{2
  elseif pnn_s =~ '^\s*\('                       .
        \ '\(var\)\=def\|'                       .
        \ 'begin\(group\|fig\s*(\s*\d\+\s*)\)\|' .
        \ 'else\(if\)\='                         . '\)\>'
    let ind = ind + &sw
  " }}}
  " if it is a broken line {{{2
  elseif pnn_s !~ end_of_item.'\s*\($\|%\)'
    let ind = ind + (2 * &sw)
  endif
  " }}}
  " }}}
  " Decrease Indent: {{{1
  " if this is :endfor or :enddef statements {{{2
  " this is correct because :def cannot be inside :for
  if  cs  =~ '\<end\(for\|def\)\=\>'
    call MetaSearchNoncomment('\<for\>.\+:\s*\($\|%\)' . '\|' .
                            \ '^\s*\(var\)\=def\>',"bW")
    if col(".") > 1
      let ind = col(".") - 1
    else
      let ind = indent(".")
    endif
  " }}}
  " if this is :fi, :else, :elseif statements {{{2
  elseif cs =~ '\<\(else\(if\)\=\|fi\)\>'
    call MetaSearchNoncomment('\<if\>.\+:\s*\($\|%\)',"bW")
    let ind = col(".") - 1
  " }}}
  " if this is :endgroup statement {{{2
  elseif cs =~ '^\s*endgroup\>'
    let ind = ind - &sw
  endif
  " }}}
  " }}}

  return ind
endfunction
"

let &cpo = s:keepcpo
unlet s:keepcpo

" vim:sw=2:fdm=marker
                                                                                                                                 usr/share/vim/vim74/indent/objc.vim                                                                 0100644 0000000 0000000 00000003155 13050207306 015634  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        "   Vim indent file
"   Language:	    Objective-C
"   Maintainer:	    Kazunobu Kuriyama <kazunobu.kuriyama@nifty.com>
"   Last Change:    2004 May 16
"


" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif
let b:did_indent = 1
setlocal cindent

" Set the function to do the work.
setlocal indentexpr=GetObjCIndent()

" To make a colon (:) suggest an indentation other than a goto/swich label,
setlocal indentkeys-=:
setlocal indentkeys+=<:>

" Only define the function once.
if exists("*GetObjCIndent")
    finish
endif

function s:GetWidth(line, regexp)
    let end = matchend(a:line, a:regexp)
    let width = 0
    let i = 0
    while i < end
	if a:line[i] != "\t"
	    let width = width + 1
	else
	    let width = width + &ts - (width % &ts)
	endif
	let i = i + 1
    endwhile
    return width
endfunction

function s:LeadingWhiteSpace(line)
    let end = strlen(a:line)
    let width = 0
    let i = 0
    while i < end
	let char = a:line[i]
	if char != " " && char != "\t"
	    break
	endif
	if char != "\t"
	    let width = width + 1
	else
	    let width = width + &ts - (width % &ts)
	endif
	let i = i + 1
    endwhile
    return width
endfunction


function GetObjCIndent()
    let theIndent = cindent(v:lnum)

    let prev_line = getline(v:lnum - 1)
    let cur_line = getline(v:lnum)

    if prev_line !~# ":" || cur_line !~# ":"
	return theIndent
    endif

    if prev_line !~# ";"
	let prev_colon_pos = s:GetWidth(prev_line, ":")
	let delta = s:GetWidth(cur_line, ":") - s:LeadingWhiteSpace(cur_line)
	let theIndent = prev_colon_pos - delta
    endif

    return theIndent
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/vim/vim74/indent/ocaml.vim                                                                0100644 0000000 0000000 00000021626 13050207306 016015  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:     OCaml
" Maintainers:  Jean-Francois Yuen   <jfyuen@happycoders.org>
"               Mike Leary           <leary@nwlink.com>
"               Markus Mottl         <markus.mottl@gmail.com>
" URL:          http://www.ocaml.info/vim/indent/ocaml.vim
" Last Change:  2013 Jun 29
"               2005 Jun 25 - Fixed multiple bugs due to 'else\nreturn ind' working
"               2005 May 09 - Added an option to not indent OCaml-indents specially (MM)
"               2013 June   - commented textwidth (Marc Weber)
"
" Marc Weber's comment: This file may contain a lot of (very custom) stuff
" which eventually should be moved somewhere else ..

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
 finish
endif
let b:did_indent = 1

setlocal expandtab
setlocal indentexpr=GetOCamlIndent()
setlocal indentkeys+=0=and,0=class,0=constraint,0=done,0=else,0=end,0=exception,0=external,0=if,0=in,0=include,0=inherit,0=initializer,0=let,0=method,0=open,0=then,0=type,0=val,0=with,0;;,0>\],0\|\],0>},0\|,0},0\],0)
setlocal nolisp
setlocal nosmartindent

" At least Marc Weber and Markus Mottl do not like this:
" setlocal textwidth=80

" Comment formatting
if !exists("no_ocaml_comments")
 if (has("comments"))
   setlocal comments=sr:(*,mb:*,ex:*)
   setlocal fo=cqort
 endif
endif

" Only define the function once.
if exists("*GetOCamlIndent")
 finish
endif

" Define some patterns:
let s:beflet = '^\s*\(initializer\|method\|try\)\|\(\<\(begin\|do\|else\|in\|then\|try\)\|->\|<-\|=\|;\|(\)\s*$'
let s:letpat = '^\s*\(let\|type\|module\|class\|open\|exception\|val\|include\|external\)\>'
let s:letlim = '\(\<\(sig\|struct\)\|;;\)\s*$'
let s:lim = '^\s*\(exception\|external\|include\|let\|module\|open\|type\|val\)\>'
let s:module = '\<\%(begin\|sig\|struct\|object\)\>'
let s:obj = '^\s*\(constraint\|inherit\|initializer\|method\|val\)\>\|\<\(object\|object\s*(.*)\)\s*$'
let s:type = '^\s*\%(class\|let\|type\)\>.*='

" Skipping pattern, for comments
function! s:GetLineWithoutFullComment(lnum)
 let lnum = prevnonblank(a:lnum - 1)
 let lline = substitute(getline(lnum), '(\*.*\*)\s*$', '', '')
 while lline =~ '^\s*$' && lnum > 0
   let lnum = prevnonblank(lnum - 1)
   let lline = substitute(getline(lnum), '(\*.*\*)\s*$', '', '')
 endwhile
 return lnum
endfunction

" Indent for ';;' to match multiple 'let'
function! s:GetInd(lnum, pat, lim)
 let llet = search(a:pat, 'bW')
 let old = indent(a:lnum)
 while llet > 0
   let old = indent(llet)
   let nb = s:GetLineWithoutFullComment(llet)
   if getline(nb) =~ a:lim
     return old
   endif
   let llet = search(a:pat, 'bW')
 endwhile
 return old
endfunction

" Indent pairs
function! s:FindPair(pstart, pmid, pend)
 call search(a:pend, 'bW')
 return indent(searchpair(a:pstart, a:pmid, a:pend, 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"'))
endfunction

" Indent 'let'
function! s:FindLet(pstart, pmid, pend)
 call search(a:pend, 'bW')
 return indent(searchpair(a:pstart, a:pmid, a:pend, 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment" || getline(".") =~ "^\\s*let\\>.*=.*\\<in\\s*$" || getline(prevnonblank(".") - 1) =~ s:beflet'))
endfunction

function! GetOCamlIndent()
 " Find a non-commented line above the current line.
 let lnum = s:GetLineWithoutFullComment(v:lnum)

 " At the start of the file use zero indent.
 if lnum == 0
   return 0
 endif

 let ind = indent(lnum)
 let lline = substitute(getline(lnum), '(\*.*\*)\s*$', '', '')

 " Return double 'shiftwidth' after lines matching:
 if lline =~ '^\s*|.*->\s*$'
   return ind + &sw + &sw
 endif

 let line = getline(v:lnum)

 " Indent if current line begins with 'end':
 if line =~ '^\s*end\>'
   return s:FindPair(s:module, '','\<end\>')

 " Indent if current line begins with 'done' for 'do':
 elseif line =~ '^\s*done\>'
   return s:FindPair('\<do\>', '','\<done\>')

 " Indent if current line begins with '}' or '>}':
 elseif line =~ '^\s*\(\|>\)}'
   return s:FindPair('{', '','}')

 " Indent if current line begins with ']', '|]' or '>]':
 elseif line =~ '^\s*\(\||\|>\)\]'
   return s:FindPair('\[', '','\]')

 " Indent if current line begins with ')':
 elseif line =~ '^\s*)'
   return s:FindPair('(', '',')')

 " Indent if current line begins with 'let':
 elseif line =~ '^\s*let\>'
   if lline !~ s:lim . '\|' . s:letlim . '\|' . s:beflet
     return s:FindLet(s:type, '','\<let\s*$')
   endif

 " Indent if current line begins with 'class' or 'type':
 elseif line =~ '^\s*\(class\|type\)\>'
   if lline !~ s:lim . '\|\<and\s*$\|' . s:letlim
     return s:FindLet(s:type, '','\<\(class\|type\)\s*$')
   endif

 " Indent for pattern matching:
 elseif line =~ '^\s*|'
   if lline !~ '^\s*\(|[^\]]\|\(match\|type\|with\)\>\)\|\<\(function\|parser\|private\|with\)\s*$'
     call search('|', 'bW')
     return indent(searchpair('^\s*\(match\|type\)\>\|\<\(function\|parser\|private\|with\)\s*$', '', '^\s*|', 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment" || getline(".") !~ "^\\s*|.*->"'))
   endif

 " Indent if current line begins with ';;':
 elseif line =~ '^\s*;;'
   if lline !~ ';;\s*$'
     return s:GetInd(v:lnum, s:letpat, s:letlim)
   endif

 " Indent if current line begins with 'in':
 elseif line =~ '^\s*in\>'
   if lline !~ '^\s*\(let\|and\)\>'
     return s:FindPair('\<let\>', '', '\<in\>')
   endif

 " Indent if current line begins with 'else':
 elseif line =~ '^\s*else\>'
   if lline !~ '^\s*\(if\|then\)\>'
     return s:FindPair('\<if\>', '', '\<else\>')
   endif

 " Indent if current line begins with 'then':
 elseif line =~ '^\s*then\>'
   if lline !~ '^\s*\(if\|else\)\>'
     return s:FindPair('\<if\>', '', '\<then\>')
   endif

 " Indent if current line begins with 'and':
 elseif line =~ '^\s*and\>'
   if lline !~ '^\s*\(and\|let\|type\)\>\|\<end\s*$'
     return ind - &sw
   endif

 " Indent if current line begins with 'with':
 elseif line =~ '^\s*with\>'
   if lline !~ '^\s*\(match\|try\)\>'
     return s:FindPair('\<\%(match\|try\)\>', '','\<with\>')
   endif

 " Indent if current line begins with 'exception', 'external', 'include' or
 " 'open':
 elseif line =~ '^\s*\(exception\|external\|include\|open\)\>'
   if lline !~ s:lim . '\|' . s:letlim
     call search(line)
     return indent(search('^\s*\(\(exception\|external\|include\|open\|type\)\>\|val\>.*:\)', 'bW'))
   endif

 " Indent if current line begins with 'val':
 elseif line =~ '^\s*val\>'
   if lline !~ '^\s*\(exception\|external\|include\|open\)\>\|' . s:obj . '\|' . s:letlim
     return indent(search('^\s*\(\(exception\|include\|initializer\|method\|open\|type\|val\)\>\|external\>.*:\)', 'bW'))
   endif

 " Indent if current line begins with 'constraint', 'inherit', 'initializer'
 " or 'method':
 elseif line =~ '^\s*\(constraint\|inherit\|initializer\|method\)\>'
   if lline !~ s:obj
     return indent(search('\<\(object\|object\s*(.*)\)\s*$', 'bW')) + &sw
   endif

 endif

 " Add a 'shiftwidth' after lines ending with:
 if lline =~ '\(:\|=\|->\|<-\|(\|\[\|{\|{<\|\[|\|\[<\|\<\(begin\|do\|else\|fun\|function\|functor\|if\|initializer\|object\|parser\|private\|sig\|struct\|then\|try\)\|\<object\s*(.*)\)\s*$'
   let ind = ind + &sw

 " Back to normal indent after lines ending with ';;':
 elseif lline =~ ';;\s*$' && lline !~ '^\s*;;'
   let ind = s:GetInd(v:lnum, s:letpat, s:letlim)

 " Back to normal indent after lines ending with 'end':
 elseif lline =~ '\<end\s*$'
   let ind = s:FindPair(s:module, '','\<end\>')

 " Back to normal indent after lines ending with 'in':
 elseif lline =~ '\<in\s*$' && lline !~ '^\s*in\>'
   let ind = s:FindPair('\<let\>', '', '\<in\>')

 " Back to normal indent after lines ending with 'done':
 elseif lline =~ '\<done\s*$'
   let ind = s:FindPair('\<do\>', '','\<done\>')

 " Back to normal indent after lines ending with '}' or '>}':
 elseif lline =~ '\(\|>\)}\s*$'
   let ind = s:FindPair('{', '','}')

 " Back to normal indent after lines ending with ']', '|]' or '>]':
 elseif lline =~ '\(\||\|>\)\]\s*$'
   let ind = s:FindPair('\[', '','\]')

 " Back to normal indent after comments:
 elseif lline =~ '\*)\s*$'
   call search('\*)', 'bW')
   let ind = indent(searchpair('(\*', '', '\*)', 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"'))

 " Back to normal indent after lines ending with ')':
 elseif lline =~ ')\s*$'
   let ind = s:FindPair('(', '',')')

 " If this is a multiline comment then align '*':
 elseif lline =~ '^\s*(\*' && line =~ '^\s*\*'
   let ind = ind + 1

 else
 " Don't change indentation of this line
 " for new lines (indent==0) use indentation of previous line

 " This is for preventing removing indentation of these args:
 "   let f x =
 "     let y = x + 1 in
 "     Printf.printf
 "       "o"           << here
 "       "oeuth"       << don't touch indentation

   let i = indent(v:lnum)
   return i == 0 ? ind : i

 endif

 " Subtract a 'shiftwidth' after lines matching 'match ... with parser':
 if lline =~ '\<match\>.*\<with\>\s*\<parser\s*$'
   let ind = ind - &sw
 endif

 return ind

endfunction

" vim:sw=2
                                                                                                          usr/share/vim/vim74/indent/occam.vim                                                                0100644 0000000 0000000 00000011032 13050207306 015772  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:	occam
" Maintainer:	Mario Schweigler <ms44@kent.ac.uk>
" Last Change:	23 April 2003

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

"{{{  Settings
" Set the occam indent function
setlocal indentexpr=GetOccamIndent()
" Indent after new line and after initial colon
setlocal indentkeys=o,O,0=:
"}}}

" Only define the function once
if exists("*GetOccamIndent")
  finish
endif
let s:keepcpo= &cpo
set cpo&vim

"{{{  Indent definitions
" Define carriage return indent
let s:FirstLevelIndent = '^\C\s*\(IF\|ALT\|PRI\s\+ALT\|PAR\|SEQ\|PRI\s\+PAR\|WHILE\|VALOF\|CLAIM\|FORKING\)\>\|\(--.*\)\@<!\(\<PROC\>\|??\|\<CASE\>\s*\(--.*\)\=\_$\)'
let s:FirstLevelNonColonEndIndent = '^\C\s*PROTOCOL\>\|\(--.*\)\@<!\<\(\(CHAN\|DATA\)\s\+TYPE\|FUNCTION\)\>'
let s:SecondLevelIndent = '^\C\s*\(IF\|ALT\|PRI\s\+ALT\)\>\|\(--.*\)\@<!?\s*\<CASE\>\s*\(--.*\)\=\_$'
let s:SecondLevelNonColonEndIndent = '\(--.*\)\@<!\<\(CHAN\|DATA\)\s\+TYPE\>'

" Define colon indent
let s:ColonIndent = '\(--.*\)\@<!\<PROC\>'
let s:ColonNonColonEndIndent = '^\C\s*PROTOCOL\>\|\(--.*\)\@<!\<\(\(CHAN\|DATA\)\s\+TYPE\|FUNCTION\)\>'

let s:ColonEnd = '\(--.*\)\@<!:\s*\(--.*\)\=$'
let s:ColonStart = '^\s*:\s*\(--.*\)\=$'

" Define comment
let s:CommentLine = '^\s*--'
"}}}

"{{{  function GetOccamIndent()
" Auxiliary function to get the correct indent for a line of occam code
function GetOccamIndent()

  " Ensure magic is on
  let save_magic = &magic
  setlocal magic

  " Get reference line number
  let linenum = prevnonblank(v:lnum - 1)
  while linenum > 0 && getline(linenum) =~ s:CommentLine
    let linenum = prevnonblank(linenum - 1)
  endwhile

  " Get current indent
  let curindent = indent(linenum)

  " Get current line
  let line = getline(linenum)

  " Get previous line number
  let prevlinenum = prevnonblank(linenum - 1)
  while prevlinenum > 0 && getline(prevlinenum) =~ s:CommentLine
    let prevlinenum = prevnonblank(prevlinenum - 1)
  endwhile

  " Get previous line
  let prevline = getline(prevlinenum)

  " Colon indent
  if getline(v:lnum) =~ s:ColonStart

    let found = 0

    while found < 1

      if line =~ s:ColonStart
	let found = found - 1
      elseif line =~ s:ColonIndent || (line =~ s:ColonNonColonEndIndent && line !~ s:ColonEnd)
	let found = found + 1
      endif

      if found < 1
	let linenum = prevnonblank(linenum - 1)
	if linenum > 0
	  let line = getline(linenum)
	else
	  let found = 1
	endif
      endif

    endwhile

    if linenum > 0
      let curindent = indent(linenum)
    else
      let colonline = getline(v:lnum)
      let tabstr = ''
      while strlen(tabstr) < &tabstop
	let tabstr = ' ' . tabstr
      endwhile
      let colonline = substitute(colonline, '\t', tabstr, 'g')
      let curindent = match(colonline, ':')
    endif

    " Restore magic
    if !save_magic|setlocal nomagic|endif

    return curindent
  endif

  if getline(v:lnum) =~ '^\s*:'
    let colonline = getline(v:lnum)
    let tabstr = ''
    while strlen(tabstr) < &tabstop
      let tabstr = ' ' . tabstr
    endwhile
    let colonline = substitute(colonline, '\t', tabstr, 'g')
    let curindent = match(colonline, ':')

    " Restore magic
    if !save_magic|setlocal nomagic|endif

    return curindent
  endif

  " Carriage return indenat
  if line =~ s:FirstLevelIndent || (line =~ s:FirstLevelNonColonEndIndent && line !~ s:ColonEnd)
	\ || (line !~ s:ColonStart && (prevline =~ s:SecondLevelIndent
	\ || (prevline =~ s:SecondLevelNonColonEndIndent && prevline !~ s:ColonEnd)))
    let curindent = curindent + &shiftwidth

    " Restore magic
    if !save_magic|setlocal nomagic|endif

    return curindent
  endif

  " Commented line
  if getline(prevnonblank(v:lnum - 1)) =~ s:CommentLine

    " Restore magic
    if !save_magic|setlocal nomagic|endif

    return indent(prevnonblank(v:lnum - 1))
  endif

  " Look for previous second level IF / ALT / PRI ALT
  let found = 0

  while !found

    if indent(prevlinenum) == curindent - &shiftwidth
      let found = 1
    endif

    if !found
      let prevlinenum = prevnonblank(prevlinenum - 1)
      while prevlinenum > 0 && getline(prevlinenum) =~ s:CommentLine
	let prevlinenum = prevnonblank(prevlinenum - 1)
      endwhile
      if prevlinenum == 0
	let found = 1
      endif
    endif

  endwhile

  if prevlinenum > 0
    if getline(prevlinenum) =~ s:SecondLevelIndent
      let curindent = curindent + &shiftwidth
    endif
  endif

  " Restore magic
  if !save_magic|setlocal nomagic|endif

  return curindent

endfunction
"}}}

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/share/vim/vim74/indent/pascal.vim                                                               0100644 0000000 0000000 00000013025 13050207306 016157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:    Pascal
" Maintainer:  Neil Carter <n.carter@swansea.ac.uk>
" Created:     2004 Jul 13
" Last Change: 2011 Apr 01
"
" This is version 2.0, a complete rewrite.
"
" For further documentation, see http://psy.swansea.ac.uk/staff/carter/vim/


if exists("b:did_indent")
	finish
endif
let b:did_indent = 1

setlocal indentexpr=GetPascalIndent(v:lnum)
setlocal indentkeys&
setlocal indentkeys+==end;,==const,==type,==var,==begin,==repeat,==until,==for
setlocal indentkeys+==program,==function,==procedure,==object,==private
setlocal indentkeys+==record,==if,==else,==case

if exists("*GetPascalIndent")
	finish
endif


function! s:GetPrevNonCommentLineNum( line_num )

	" Skip lines starting with a comment
	let SKIP_LINES = '^\s*\(\((\*\)\|\(\*\ \)\|\(\*)\)\|{\|}\)'

	let nline = a:line_num
	while nline > 0
		let nline = prevnonblank(nline-1)
		if getline(nline) !~? SKIP_LINES
			break
		endif
	endwhile

	return nline
endfunction


function! s:PurifyCode( line_num )
	" Strip any trailing comments and whitespace
	let pureline = 'TODO'
	return pureline
endfunction


function! GetPascalIndent( line_num )

	" Line 0 always goes at column 0
	if a:line_num == 0
		return 0
	endif

	let this_codeline = getline( a:line_num )


	" SAME INDENT

	" Middle of a three-part comment
	if this_codeline =~ '^\s*\*'
		return indent( a:line_num - 1)
	endif


	" COLUMN 1 ALWAYS

	" Last line of the program
	if this_codeline =~ '^\s*end\.'
		return 0
	endif

	" Compiler directives, allowing "(*" and "{"
	"if this_codeline =~ '^\s*\({\|(\*\)$\(IFDEF\|IFNDEF\|ELSE\|ENDIF\)'
	if this_codeline =~ '^\s*\({\|(\*\)\$'
		return 0
	endif

	" section headers
	if this_codeline =~ '^\s*\(program\|procedure\|function\|type\)\>'
		return 0
	endif

	" Subroutine separators, lines ending with "const" or "var"
	if this_codeline =~ '^\s*\((\*\ _\+\ \*)\|\(const\|var\)\)$'
		return 0
	endif


	" OTHERWISE, WE NEED TO LOOK FURTHER BACK...

	let prev_codeline_num = s:GetPrevNonCommentLineNum( a:line_num )
	let prev_codeline = getline( prev_codeline_num )
	let indnt = indent( prev_codeline_num )


	" INCREASE INDENT

	" If the PREVIOUS LINE ended in these items, always indent
	if prev_codeline =~ '\<\(type\|const\|var\)$'
		return indnt + &shiftwidth
	endif

	if prev_codeline =~ '\<repeat$'
		if this_codeline !~ '^\s*until\>'
			return indnt + &shiftwidth
		else
			return indnt
		endif
	endif

	if prev_codeline =~ '\<\(begin\|record\)$'
		if this_codeline !~ '^\s*end\>'
			return indnt + &shiftwidth
		else
			return indnt
		endif
	endif

	" If the PREVIOUS LINE ended with these items, indent if not
	" followed by "begin"
	if prev_codeline =~ '\<\(\|else\|then\|do\)$' || prev_codeline =~ ':$'
		if this_codeline !~ '^\s*begin\>'
			return indnt + &shiftwidth
		else
			" If it does start with "begin" then keep the same indent
			"return indnt + &shiftwidth
			return indnt
		endif
	endif

	" Inside a parameter list (i.e. a "(" without a ")"). ???? Considers
	" only the line before the current one. TODO: Get it working for
	" parameter lists longer than two lines.
	if prev_codeline =~ '([^)]\+$'
		return indnt + &shiftwidth
	endif


	" DECREASE INDENT

	" Lines starting with "else", but not following line ending with
	" "end".
	if this_codeline =~ '^\s*else\>' && prev_codeline !~ '\<end$'
		return indnt - &shiftwidth
	endif

	" Lines after a single-statement branch/loop.
	" Two lines before ended in "then", "else", or "do"
	" Previous line didn't end in "begin"
	let prev2_codeline_num = s:GetPrevNonCommentLineNum( prev_codeline_num )
	let prev2_codeline = getline( prev2_codeline_num )
	if prev2_codeline =~ '\<\(then\|else\|do\)$' && prev_codeline !~ '\<begin$'
		" If the next code line after a single statement branch/loop
		" starts with "end", "except" or "finally", we need an
		" additional unindentation.
		if this_codeline =~ '^\s*\(end;\|except\|finally\|\)$'
			" Note that we don't return from here.
			return indnt - &shiftwidth - &shiftwidth
		endif
		return indnt - &shiftwidth
	endif

	" Lines starting with "until" or "end". This rule must be overridden
	" by the one for "end" after a single-statement branch/loop. In
	" other words that rule should come before this one.
	if this_codeline =~ '^\s*\(end\|until\)\>'
		return indnt - &shiftwidth
	endif


	" MISCELLANEOUS THINGS TO CATCH

	" Most "begin"s will have been handled by now. Any remaining
	" "begin"s on their own line should go in column 1.
	if this_codeline =~ '^\s*begin$'
		return 0
	endif


" ____________________________________________________________________
" Object/Borland Pascal/Delphi Extensions
"
" Note that extended-pascal is handled here, unless it is simpler to
" handle them in the standard-pascal section above.


	" COLUMN 1 ALWAYS

	" section headers at start of line.
	if this_codeline =~ '^\s*\(interface\|implementation\|uses\|unit\)\>'
		return 0
	endif


	" INDENT ONCE

	" If the PREVIOUS LINE ended in these items, always indent.
	if prev_codeline =~ '^\s*\(unit\|uses\|try\|except\|finally\|private\|protected\|public\|published\)$'
		return indnt + &shiftwidth
	endif

	" ???? Indent "procedure" and "functions" if they appear within an
	" class/object definition. But that means overriding standard-pascal
	" rule where these words always go in column 1.


	" UNINDENT ONCE

	if this_codeline =~ '^\s*\(except\|finally\)$'
		return indnt - &shiftwidth
	endif

	if this_codeline =~ '^\s*\(private\|protected\|public\|published\)$'
		return indnt - &shiftwidth
	endif


" ____________________________________________________________________

	" If nothing changed, return same indent.
	return indnt
endfunction

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/share/vim/vim74/indent/perl.vim                                                                 0100644 0000000 0000000 00000013263 13050207306 015662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:      Perl 5
" Maintainer:    vim-perl <vim-perl@googlegroups.com>
" Homepage:      http://github.com/vim-perl/vim-perl
" Bugs/requests: http://github.com/vim-perl/vim-perl/issues
" Last Change:   2013-07-24

" Suggestions and improvements by :
"   Aaron J. Sherman (use syntax for hints)
"   Artem Chuprina (play nice with folding)

" TODO things that are not or not properly indented (yet) :
" - Continued statements
"     print "foo",
"       "bar";
"     print "foo"
"       if bar();
" - Multiline regular expressions (m//x)
" (The following probably needs modifying the perl syntax file)
" - qw() lists
" - Heredocs with terminators that don't match \I\i*

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif
let b:did_indent = 1

" Is syntax highlighting active ?
let b:indent_use_syntax = has("syntax")

setlocal indentexpr=GetPerlIndent()
setlocal indentkeys+=0=,0),0],0=or,0=and
if !b:indent_use_syntax
    setlocal indentkeys+=0=EO
endif

let s:cpo_save = &cpo
set cpo-=C

function! GetPerlIndent()

    " Get the line to be indented
    let cline = getline(v:lnum)

    " Indent POD markers to column 0
    if cline =~ '^\s*=\L\@!'
        return 0
    endif

    " Don't reindent comments on first column
    if cline =~ '^#.'
        return 0
    endif

    " Get current syntax item at the line's first char
    let csynid = ''
    if b:indent_use_syntax
        let csynid = synIDattr(synID(v:lnum,1,0),"name")
    endif

    " Don't reindent POD and heredocs
    if csynid == "perlPOD" || csynid == "perlHereDoc" || csynid =~ "^pod"
        return indent(v:lnum)
    endif

    " Indent end-of-heredocs markers to column 0
    if b:indent_use_syntax
        " Assumes that an end-of-heredoc marker matches \I\i* to avoid
        " confusion with other types of strings
        if csynid == "perlStringStartEnd" && cline =~ '^\I\i*$'
            return 0
        endif
    else
        " Without syntax hints, assume that end-of-heredocs markers begin with EO
        if cline =~ '^\s*EO'
            return 0
        endif
    endif

    " Now get the indent of the previous perl line.

    " Find a non-blank line above the current line.
    let lnum = prevnonblank(v:lnum - 1)
    " Hit the start of the file, use zero indent.
    if lnum == 0
        return 0
    endif
    let line = getline(lnum)
    let ind = indent(lnum)
    " Skip heredocs, POD, and comments on 1st column
    if b:indent_use_syntax
        let skippin = 2
        while skippin
            let synid = synIDattr(synID(lnum,1,0),"name")
            if (synid == "perlStringStartEnd" && line =~ '^\I\i*$')
                        \ || (skippin != 2 && synid == "perlPOD")
                        \ || (skippin != 2 && synid == "perlHereDoc")
                        \ || synid == "perlComment"
                        \ || synid =~ "^pod"
                let lnum = prevnonblank(lnum - 1)
                if lnum == 0
                    return 0
                endif
                let line = getline(lnum)
                let ind = indent(lnum)
                let skippin = 1
            else
                let skippin = 0
            endif
        endwhile
    else
        if line =~ "^EO"
            let lnum = search("<<[\"']\\=EO", "bW")
            let line = getline(lnum)
            let ind = indent(lnum)
        endif
    endif

    " Indent blocks enclosed by {}, (), or []
    if b:indent_use_syntax
        " Find a real opening brace
        " NOTE: Unlike Perl character classes, we do NOT need to escape the
        " closing brackets with a backslash.  Doing so just puts a backslash
        " in the character class and causes sorrow.  Instead, put the closing
        " bracket as the first character in the class.
        let braceclass = '[][(){}]'
        let bracepos = match(line, braceclass, matchend(line, '^\s*[])}]'))
        while bracepos != -1
            let synid = synIDattr(synID(lnum, bracepos + 1, 0), "name")
            " If the brace is highlighted in one of those groups, indent it.
            " 'perlHereDoc' is here only to handle the case '&foo(<<EOF)'.
            if synid == ""
                        \ || synid == "perlMatchStartEnd"
                        \ || synid == "perlHereDoc"
                        \ || synid == "perlBraces"
                        \ || synid =~ "^perlFiledescStatement"
                        \ || synid =~ '^perl\(Sub\|Block\|Package\)Fold'
                let brace = strpart(line, bracepos, 1)
                if brace == '(' || brace == '{' || brace == '['
                    let ind = ind + &sw
                else
                    let ind = ind - &sw
                endif
            endif
            let bracepos = match(line, braceclass, bracepos + 1)
        endwhile
        let bracepos = matchend(cline, '^\s*[])}]')
        if bracepos != -1
            let synid = synIDattr(synID(v:lnum, bracepos, 0), "name")
            if synid == ""
                        \ || synid == "perlMatchStartEnd"
                        \ || synid == "perlBraces"
                        \ || synid =~ '^perl\(Sub\|Block\|Package\)Fold'
                let ind = ind - &sw
            endif
        endif
    else
        if line =~ '[{[(]\s*\(#[^])}]*\)\=$'
            let ind = ind + &sw
        endif
        if cline =~ '^\s*[])}]'
            let ind = ind - &sw
        endif
    endif

    " Indent lines that begin with 'or' or 'and'
    if cline =~ '^\s*\(or\|and\)\>'
        if line !~ '^\s*\(or\|and\)\>'
            let ind = ind + &sw
        endif
    elseif line =~ '^\s*\(or\|and\)\>'
        let ind = ind - &sw
    endif

    return ind

endfunction

let &cpo = s:cpo_save
unlet s:cpo_save

" vim:ts=8:sts=4:sw=4:expandtab:ft=vim
                                                                                                                                                                                                                                                                                                                                             usr/share/vim/vim74/indent/perl6.vim                                                                0100644 0000000 0000000 00000006657 13050207306 015761  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim indent file
" Language:      Perl 6
" Maintainer:    vim-perl <vim-perl@googlegroups.com>
" Homepage:      http://github.com/vim-perl/vim-perl
" Bugs/requests: http://github.com/vim-perl/vim-perl/issues
" Last Change:   2013-07-21
" Contributors:  Andy Lester <andy@petdance.com>
"                Hinrik Örn Sigurðsson <hinrik.sig@gmail.com>
"
" Adapted from indent/perl.vim by Rafael Garcia-Suarez <rgarciasuarez@free.fr>

" Suggestions and improvements by :
"   Aaron J. Sherman (use syntax for hints)
