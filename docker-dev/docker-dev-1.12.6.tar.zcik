n        = 3,                            /* True implies that driver can talk directly to device (e.g. serial data link via sense lines) */
    kIsMonoDev                  = 4,                            /* Says whether there's an RGB (0) or Monochrome (1) connection. */
    kUncertainConnection        = 5,                            /* There may not be a display (no sense lines?). */
    kTaggingInfoNonStandard     = 6,                            /* Set when csConnectTaggedType/csConnectTaggedData are non-standard (i.e., not the Apple CRT sense codes). */
    kReportsDDCConnection       = 7,                            /* Card can do ddc (set kHasDirectConnect && kHasDDCConnect if you actually found a ddc display). */
    kHasDDCConnection           = 8,                            /* Card has ddc connect now. */
    kConnectionInactive         = 9,                            /* Set when the connection is NOT currently active (generally used in a multiconnection environment). */
    kDependentConnection        = 10,                           /* Set when some ascpect of THIS connection depends on another (will generally be set in a kModeSimulscan environment). */
    kBuiltInConnection          = 11,                           /* Set when connection is KNOWN to be built-in (this is not the same as kHasDirectConnection). */
    kOverrideConnection         = 12,                           /* Set when the reported connection is not the true one, but is one that has been forced through a SetConnection call */
    kFastCheckForDDC            = 13,                           /* Set when all 3 are true: 1) sense codes indicate DDC display could be attached 2) attempted fast check 3) DDC failed */
    kReportsHotPlugging         = 14,                           /* Detects and reports hot pluggging on connector (via VSL also implies DDC will be up to date w/o force read) */
    kStereoSyncConnection       = 15                            /* Connection supports stereo sync signalling */
};


/* csDisplayType values in VDDisplayConnectInfo */
enum {
    kUnknownConnect             = 1,                            /* Not sure how we'll use this, but seems like a good idea. */
    kPanelConnect               = 2,                            /* For use with fixed-in-place LCD panels. */
    kPanelTFTConnect            = 2,                            /* Alias for kPanelConnect */
    kFixedModeCRTConnect        = 3,                            /*  For use with fixed-mode (i.e., very limited range) displays. */
    kMultiModeCRT1Connect       = 4,                            /* 320x200 maybe, 12" maybe, 13" (default), 16" certain, 19" maybe, 21" maybe */
    kMultiModeCRT2Connect       = 5,                            /* 320x200 maybe, 12" maybe, 13" certain, 16" (default), 19" certain, 21" maybe */
    kMultiModeCRT3Connect       = 6,                            /* 320x200 maybe, 12" maybe, 13" certain, 16" certain, 19" default, 21" certain */
    kMultiModeCRT4Connect       = 7,                            /* Expansion to large multi mode (not yet used) */
    kModelessConnect            = 8,                            /* Expansion to modeless model (not yet used) */
    kFullPageConnect            = 9,                            /* 640x818 (to get 8bpp in 512K case) and 640x870 (these two only) */
    kVGAConnect                 = 10,                           /* 640x480 VGA default -- question everything else */
    kNTSCConnect                = 11,                           /* NTSC ST (default), FF, STconv, FFconv */
    kPALConnect                 = 12,                           /* PAL ST (default), FF, STconv, FFconv */
    kHRConnect                  = 13,                           /* Straight-6 connect -- 640x480 and 640x400 (to get 8bpp in 256K case) (these two only) */
    kPanelFSTNConnect           = 14,                           /* For use with fixed-in-place LCD FSTN (aka "Supertwist") panels */
    kMonoTwoPageConnect         = 15,                           /* 1152x870 Apple color two-page display */
    kColorTwoPageConnect        = 16,                           /* 1152x870 Apple B&W two-page display */
    kColor16Connect             = 17,                           /* 832x624 Apple B&W two-page display */
    kColor19Connect             = 18,                           /* 1024x768 Apple B&W two-page display */
    kGenericCRT                 = 19,                           /* Indicates nothing except that connection is CRT in nature. */
    kGenericLCD                 = 20,                           /* Indicates nothing except that connection is LCD in nature. */
    kDDCConnect                 = 21,                           /* DDC connection, always set kHasDDCConnection */
    kNoConnect                  = 22                            /* No display is connected - load sensing or similar level of hardware detection is assumed (used by resident drivers that support hot plugging when nothing is currently connected) */
};

/* csTimingFlags values in VDTimingInfoRec */
enum {
    kModeValid                  = 0,                            /* Says that this mode should NOT be trimmed. */
    kModeSafe                   = 1,                            /* This mode does not need confirmation */
    kModeDefault                = 2,                            /* This is the default mode for this type of connection */
    kModeShowNow                = 3,                            /* This mode should always be shown (even though it may require a confirm) */
    kModeNotResize              = 4,                            /* This mode should not be used to resize the display (eg. mode selects a different connector on card) */
    kModeRequiresPan            = 5,                            /* This mode has more pixels than are actually displayed */
    kModeInterlaced             = 6,                            /* This mode is interlaced (single pixel lines look bad). */
    kModeShowNever              = 7,                            /* This mode should not be shown in the user interface. */
    kModeSimulscan              = 8,                            /* Indicates that more than one display connection can be driven from a single framebuffer controller. */
    kModeNotPreset              = 9,                            /* Indicates that the timing is not a factory preset for the current display (geometry may need correction) */
    kModeBuiltIn                = 10,                           /* Indicates that the display mode is for the built-in connect only (on multiconnect devices like the PB 3400) Only the driver is quieried */
    kModeStretched              = 11,                           /* Indicates that the display mode will be stretched/distorted to match the display aspect ratio */
    kModeNotGraphicsQuality     = 12,                           /* Indicates that the display mode is not the highest quality (eg. stretching artifacts).  Intended as a hint */
    kModeValidateAgainstDisplay = 13                            /* Indicates that this mode should be validated against the display EDID */
};

/* csDepthFlags in VDVideoParametersInfoRec */
enum {
    kDepthDependent             = 0,                            /* Says that this depth mode may cause dependent changes in other framebuffers (and . */
    kDepthDependentMask         = (1 << kDepthDependent)        /* mask for kDepthDependent */    
};

/* csResolutionFlags bit flags for VDResolutionInfoRec */
enum {
    kResolutionHasMultipleDepthSizes = 0                        /* Says that this mode has different csHorizontalPixels, csVerticalLines at different depths (usually slightly larger at lower depths) */
};


enum {
                                                                /*    Power Mode constants for VDPowerStateRec.powerState.  Note the numeric order does not match the power state order */
    kAVPowerOff                 = 0,                            /* Power fully off*/
    kAVPowerStandby             = 1,
    kAVPowerSuspend             = 2,
    kAVPowerOn                  = 3,
    kHardwareSleep              = 128,
    kHardwareWake               = 129,
    kHardwareWakeFromSuspend    = 130,
    kHardwareWakeToDoze         = 131,
    kHardwareWakeToDozeFromSuspend = 132,
    kHardwarePark               = 133,
    kHardwareDrive              = 134
};

/* Reduced perf level, for GetPowerState, SetPowerState*/
enum {
    kPowerStateReducedPowerMask   = 0x00000300,
    kPowerStateFullPower          = 0x00000000,
    kPowerStateReducedPower1      = 0x00000100,
    kPowerStateReducedPower2      = 0x00000200,
    kPowerStateReducedPower3      = 0x00000300
};

enum {
                                                                /*    Power Mode masks and bits for VDPowerStateRec.powerFlags.  */
    kPowerStateNeedsRefresh     = 0,                            /* When leaving this power mode, a display will need refreshing   */
    kPowerStateSleepAwareBit    = 1,                            /* if gestaltPCCardDockingSelectorFix, Docking mgr checks this bit before checking kPowerStateSleepAllowedBit */
    kPowerStateSleepForbiddenBit = 2,                           /* if kPowerStateSleepAwareBit, Docking mgr checks this bit before sleeping */
    kPowerStateSleepCanPowerOffBit = 3,                         /* supports power down sleep (ie PCI power off)*/
    kPowerStateSleepNoDPMSBit   = 4,                            /* Bug #2425210.  Do not use DPMS with this display.*/
    kPowerStateSleepWaketoDozeBit = 5,                          /* Supports Wake to Doze */
    kPowerStateSleepWakeNeedsProbeBit = 6,                      /* Does not sense connection changes on wake */

    kPowerStateNeedsRefreshMask = (1 << kPowerStateNeedsRefresh),
    kPowerStateSleepAwareMask   = (1 << kPowerStateSleepAwareBit),
    kPowerStateSleepForbiddenMask = (1 << kPowerStateSleepForbiddenBit),
    kPowerStateSleepCanPowerOffMask = (1 << kPowerStateSleepCanPowerOffBit),
    kPowerStateSleepNoDPMSMask  = (1 << kPowerStateSleepNoDPMSBit),
    kPowerStateSleepWaketoDozeMask = (1 << kPowerStateSleepWaketoDozeBit),
    kPowerStateSleepWakeNeedsProbeMask = (1 << kPowerStateSleepWakeNeedsProbeBit),

    kPowerStateSupportsReducedPower1Bit = 10,
    kPowerStateSupportsReducedPower2Bit = 11,
    kPowerStateSupportsReducedPower3Bit = 12,
    kPowerStateSupportsReducedPower1BitMask = (1 << 10),
    kPowerStateSupportsReducedPower2BitMask = (1 << 11),
    kPowerStateSupportsReducedPower3BitMask = (1 << 12)
};


enum {
                                                                /* Control Codes */
    cscReset                    = 0,
    cscKillIO                   = 1,
    cscSetMode                  = 2,
    cscSetEntries               = 3,
    cscSetGamma                 = 4,
    cscGrayPage                 = 5,
    cscGrayScreen               = 5,
    cscSetGray                  = 6,
    cscSetInterrupt             = 7,
    cscDirectSetEntries         = 8,
    cscSetDefaultMode           = 9,
    cscSwitchMode               = 10,                           /* Takes a VDSwitchInfoPtr */         
    cscSetSync                  = 11,                           /* Takes a VDSyncInfoPtr */           
    cscSavePreferredConfiguration = 16,                         /* Takes a VDSwitchInfoPtr */         
    cscSetHardwareCursor        = 22,                           /* Takes a VDSetHardwareCursorPtr */  
    cscDrawHardwareCursor       = 23,                           /* Takes a VDDrawHardwareCursorPtr */ 
    cscSetConvolution           = 24,                           /* Takes a VDConvolutionInfoPtr */    
    cscSetPowerState            = 25,                           /* Takes a VDPowerStatePtr */         
    cscPrivateControlCall       = 26,                           /* Takes a VDPrivateSelectorDataRec*/
    cscSetMultiConnect          = 28,                           /* From a GDI point of view, this call should be implemented completely in the HAL and not at all in the core.*/
    cscSetClutBehavior          = 29,                           /* Takes a VDClutBehavior */
    cscSetDetailedTiming        = 31,                           /* Takes a VDDetailedTimingPtr */
    cscDoCommunication          = 33,                           /* Takes a VDCommunicationPtr */
    cscProbeConnection          = 34,                           /* Takes nil pointer */
                                                                /* (may generate a kFBConnectInterruptServiceType service interrupt) */
    cscSetScaler                = 36,                           /* Takes a VDScalerPtr */
    cscSetMirror                = 37,                           /* Takes a VDMirrorPtr*/
    cscSetFeatureConfiguration  = 38,                           /* Takes a VDConfigurationPtr*/
    cscUnusedCall               = 127                           /* This call used to expand the scrn resource.  Its imbedded data contains more control info */
};

enum {
                                                                /* Status Codes */
    cscGetMode                  = 2,
    cscGetEntries               = 3,
    cscGetPageCnt               = 4,
    cscGetPages                 = 4,                            /* This is what C&D 2 calls it. */
    cscGetPageBase              = 5,
    cscGetBaseAddr              = 5,                            /* This is what C&D 2 calls it. */
    cscGetGray                  = 6,
    cscGetInterrupt             = 7,
    cscGetGamma                 = 8,
    cscGetDefaultMode           = 9,
    cscGetCurMode               = 10,                           /* Takes a VDSwitchInfoPtr */
    cscGetSync                  = 11,                           /* Takes a VDSyncInfoPtr */  
    cscGetConnection            = 12,                           /* Return information about the connection to the display */
    cscGetModeTiming            = 13,                           /* Return timing info for a mode */
    cscGetModeBaseAddress       = 14,                           /* Return base address information about a particular mode */
    cscGetScanProc              = 15,                           /* QuickTime scan chasing routine */
    cscGetPreferredConfiguration = 16,                          /* Takes a VDSwitchInfoPtr */               
    cscGetNextResolution        = 17,                           /* Takes a VDResolutionInfoPtr */           
    cscGetVideoParameters       = 18,                           /* Takes a VDVideoParametersInfoPtr */      
    cscGetGammaInfoList         = 20,                           /* Takes a VDGetGammaListPtr */             
    cscRetrieveGammaTable       = 21,                           /* Takes a VDRetrieveGammaPtr */            
    cscSupportsHardwareCursor   = 22,                           /* Takes a VDSupportsHardwareCursorPtr */   
    cscGetHardwareCursorDrawState = 23,                         /* Takes a VDHardwareCursorDrawStatePtr */  
    cscGetConvolution           = 24,                           /* Takes a VDConvolutionInfoPtr */          
    cscGetPowerState            = 25,                           /* Takes a VDPowerStatePtr */               
    cscPrivateStatusCall        = 26,                           /* Takes a VDPrivateSelectorDataRec*/
    cscGetDDCBlock              = 27,                           /* Takes a VDDDCBlockRec  */
    cscGetMultiConnect          = 28,                           /* From a GDI point of view, this call should be implemented completely in the HAL and not at all in the core.*/
    cscGetClutBehavior          = 29,                           /* Takes a VDClutBehavior */
    cscGetTimingRanges          = 30,                           /* Takes a VDDisplayTimingRangePtr */
    cscGetDetailedTiming        = 31,                           /* Takes a VDDetailedTimingPtr */
    cscGetCommunicationInfo     = 32,                           /* Takes a VDCommunicationInfoPtr */
    cscGetScalerInfo            = 35,                           /* Takes a VDScalerInfoPtr */
    cscGetScaler                = 36,                           /* Takes a VDScalerPtr */
    cscGetMirror                = 37,                           /* Takes a VDMirrorPtr*/
    cscGetFeatureConfiguration  = 38,                           /* Takes a VDConfigurationPtr*/
    cscGetFeatureList           = 39
};

/* Bit definitions for the Get/Set Sync call*/
enum {
    kDisableHorizontalSyncBit   = 0,
    kDisableVerticalSyncBit     = 1,
    kDisableCompositeSyncBit    = 2,
    kEnableSyncOnBlue           = 3,
    kEnableSyncOnGreen          = 4,
    kEnableSyncOnRed            = 5,
    kNoSeparateSyncControlBit   = 6,
    kTriStateSyncBit            = 7,
    kHorizontalSyncMask         = 0x01,
    kVerticalSyncMask           = 0x02,
    kCompositeSyncMask          = 0x04,
    kDPMSSyncMask               = 0x07,
    kTriStateSyncMask           = 0x80,
    kSyncOnBlueMask             = 0x08,
    kSyncOnGreenMask            = 0x10,
    kSyncOnRedMask              = 0x20,
    kSyncOnMask                 = 0x38
};

enum {
                                                                /*    Power Mode constants for translating DPMS modes to Get/SetSync calls.  */
    kDPMSSyncOn                 = 0,
    kDPMSSyncStandby            = 1,
    kDPMSSyncSuspend            = 2,
    kDPMSSyncOff                = 7
};

/* Bit definitions for the Get/Set Convolution call*/
enum {
    kConvolved                  = 0,
    kLiveVideoPassThru          = 1,
    kConvolvedMask              = 0x01,
    kLiveVideoPassThruMask      = 0x02
};



struct VPBlock {
    UInt32                           vpBaseOffset;               /*Offset to page zero of video RAM (From minorBaseOS).*/
#if __LP64__
    UInt32                           vpRowBytes;                 /*Width of each row of video memory.*/
#else
    SInt16                           vpRowBytes;                 /*Width of each row of video memory.*/
#endif
    Rect                            vpBounds;                   /*BoundsRect for the video display (gives dimensions).*/
    SInt16                           vpVersion;                  /*PixelMap version number.*/
    SInt16                           vpPackType;
    UInt32                           vpPackSize;
    UInt32                            vpHRes;                     /*Horizontal resolution of the device (pixels per inch).*/
    UInt32                            vpVRes;                     /*Vertical resolution of the device (pixels per inch).*/
    SInt16                           vpPixelType;                /*Defines the pixel type.*/
    SInt16                           vpPixelSize;                /*Number of bits in pixel.*/
    SInt16                           vpCmpCount;                 /*Number of components in pixel.*/
    SInt16                           vpCmpSize;                  /*Number of bits per component*/
    UInt32                            vpPlaneBytes;               /*Offset from one plane to the next.*/
};
typedef struct VPBlock                  VPBlock;
typedef VPBlock *                       VPBlockPtr;

struct VDEntryRecord {
    Ptr                             csTable;                    /* pointer to color table entry=value, r,g,b:INTEGER*/
};
typedef struct VDEntryRecord            VDEntryRecord;

typedef VDEntryRecord *                 VDEntRecPtr;
/* Parm block for SetGray control call */

struct VDGrayRecord {
    Boolean                         csMode;                     /*Same as GDDevType value (0=color, 1=mono)*/
    SInt8                           filler;
};
typedef struct VDGrayRecord             VDGrayRecord;

typedef VDGrayRecord *                  VDGrayPtr;
/* Parm block for SetInterrupt call */

struct VDFlagRecord {
    SInt8                           csMode;
    SInt8                           filler;
};
typedef struct VDFlagRecord             VDFlagRecord;

typedef VDFlagRecord *                  VDFlagRecPtr;
/* Parm block for SetEntries control call */

struct VDSetEntryRecord {
    ColorSpec *                     csTable;                    /*Pointer to an array of color specs*/
    SInt16                           csStart;                    /*Which spec in array to start with, or -1*/
    SInt16                           csCount;                    /*Number of color spec entries to set*/
};
typedef struct VDSetEntryRecord         VDSetEntryRecord;

typedef VDSetEntryRecord *              VDSetEntryPtr;
/* Parm block for SetGamma control call */

struct VDGammaRecord {
    Ptr                             csGTable;                   /*pointer to gamma table*/
};
typedef struct VDGammaRecord            VDGammaRecord;

typedef VDGammaRecord *                 VDGamRecPtr;

struct VDSwitchInfoRec {
    DepthMode                  csMode;                     /* mode depth*/
    DisplayModeID                   csData;                     /* functional sResource of mode*/
    UInt16                  csPage;                     /* page to switch in*/
    Ptr                             csBaseAddr;                 /* base address of page (return value)*/
    uintptr_t                   csReserved;                 /* Reserved (set to 0) */
};
typedef struct VDSwitchInfoRec          VDSwitchInfoRec;

typedef VDSwitchInfoRec *               VDSwitchInfoPtr;

struct VDTimingInfoRec {
    DisplayModeID                   csTimingMode;               /* timing mode (a la InitGDevice) */
    uintptr_t                   csTimingReserved;           /* reserved */
    UInt32                   csTimingFormat;             /* what format is the timing info */
    UInt32                   csTimingData;               /* data supplied by driver */
    UInt32                   csTimingFlags;              /* mode within device */
};
typedef struct VDTimingInfoRec          VDTimingInfoRec;

typedef VDTimingInfoRec *               VDTimingInfoPtr;

struct VDDisplayConnectInfoRec {
    UInt16                  csDisplayType;              /* Type of display connected */
    UInt8                   csConnectTaggedType;        /* type of tagging */
    UInt8                   csConnectTaggedData;        /* tagging data */
    UInt32                   csConnectFlags;             /* tell us about the connection */
    uintptr_t                   csDisplayComponent;         /* if the card has a direct connection to the display, it returns the display component here (FUTURE) */
    uintptr_t                   csConnectReserved;          /* reserved */
};
typedef struct VDDisplayConnectInfoRec  VDDisplayConnectInfoRec;

typedef VDDisplayConnectInfoRec *       VDDisplayConnectInfoPtr;

struct VDMultiConnectInfoRec {
    UInt32                   csDisplayCountOrNumber;     /* For GetMultiConnect, returns count n of 1..n connections; otherwise, indicates the ith connection.*/
    VDDisplayConnectInfoRec         csConnectInfo;              /* Standard VDDisplayConnectionInfo for connection i.*/
};
typedef struct VDMultiConnectInfoRec    VDMultiConnectInfoRec;

typedef VDMultiConnectInfoRec *         VDMultiConnectInfoPtr;
/* RawSenseCode
    This abstract data type is not exactly abstract.  Rather, it is merely enumerated constants
    for the possible raw sense code values when 'standard' sense code hardware is implemented.

    For 'standard' sense code hardware, the raw sense is obtained as follows:
        o Instruct the frame buffer controller NOT to actively drive any of the monitor sense lines
        o Read the state of the monitor sense lines 2, 1, and 0.  (2 is the MSB, 0 the LSB)

    IMPORTANT Note: 
    When the 'kTaggingInfoNonStandard' bit of 'csConnectFlags' is FALSE, then these constants 
    are valid 'csConnectTaggedType' values in 'VDDisplayConnectInfo' 

*/
typedef UInt8                   RawSenseCode;
enum {
    kRSCZero                    = 0,
    kRSCOne                     = 1,
    kRSCTwo                     = 2,
    kRSCThree                   = 3,
    kRSCFour                    = 4,
    kRSCFive                    = 5,
    kRSCSix                     = 6,
    kRSCSeven                   = 7
};


/* ExtendedSenseCode
    This abstract data type is not exactly abstract.  Rather, it is merely enumerated constants
    for the values which are possible when the extended sense algorithm is applied to hardware
    which implements 'standard' sense code hardware.

    For 'standard' sense code hardware, the extended sense code algorithm is as follows:
    (Note:  as described here, sense line 'A' corresponds to '2', 'B' to '1', and 'C' to '0')
        o Drive sense line 'A' low and read the values of 'B' and 'C'.  
        o Drive sense line 'B' low and read the values of 'A' and 'C'.
        o Drive sense line 'C' low and read the values of 'A' and 'B'.

    In this way, a six-bit number of the form BC/AC/AB is generated. 

    IMPORTANT Note: 
    When the 'kTaggingInfoNonStandard' bit of 'csConnectFlags' is FALSE, then these constants 
    are valid 'csConnectTaggedData' values in 'VDDisplayConnectInfo' 

*/
typedef UInt8                   ExtendedSenseCode;
enum {
    kESCZero21Inch              = 0x00,                         /* 21" RGB                     */
    kESCOnePortraitMono         = 0x14,                         /* Portrait Monochrome              */
    kESCTwo12Inch               = 0x21,                         /* 12" RGB                    */
    kESCThree21InchRadius       = 0x31,                         /* 21" RGB (Radius)               */
    kESCThree21InchMonoRadius   = 0x34,                         /* 21" Monochrome (Radius)           */
    kESCThree21InchMono         = 0x35,                         /* 21" Monochrome               */
    kESCFourNTSC                = 0x0A,                         /* NTSC                     */
    kESCFivePortrait            = 0x1E,                         /* Portrait RGB              */
    kESCSixMSB1                 = 0x03,                         /* MultiScan Band-1 (12" thru 1Six")  */
    kESCSixMSB2                 = 0x0B,                         /* MultiScan Band-2 (13" thru 19")       */
    kESCSixMSB3                 = 0x23,                         /* MultiScan Band-3 (13" thru 21")       */
    kESCSixStandard             = 0x2B,                         /* 13"/14" RGB or 12" Monochrome   */
    kESCSevenPAL                = 0x00,                         /* PAL                        */
    kESCSevenNTSC               = 0x14,                         /* NTSC                     */
    kESCSevenVGA                = 0x17,                         /* VGA                        */
    kESCSeven16Inch             = 0x2D,                         /* 16" RGB (GoldFish)               */
    kESCSevenPALAlternate       = 0x30,                         /* PAL (Alternate)                */
    kESCSeven19Inch             = 0x3A,                         /* Third-Party 19"                 */
    kESCSevenDDC                = 0x3E,                         /* DDC display                   */
    kESCSevenNoDisplay          = 0x3F                          /* No display connected           */
};

/* DepthMode
    This abstract data type is used to to reference RELATIVE pixel depths.
    Its definition is largely derived from its past usage, analogous to 'xxxVidMode'

    Bits per pixel DOES NOT directly map to 'DepthMode'  For example, on some
    graphics hardware, 'kDepthMode1' may represent 1 BPP, whereas on other
    hardware, 'kDepthMode1' may represent 8BPP.

    DepthMode IS considered to be ordinal, i.e., operations such as <, >, ==, etc.
    behave as expected.  The values of the constants which comprise the set are such
    that 'kDepthMode4 < kDepthMode6' behaves as expected.
*/
enum {
    kDepthMode1                 = 128,
    kDepthMode2                 = 129,
    kDepthMode3                 = 130,
    kDepthMode4                 = 131,
    kDepthMode5                 = 132,
    kDepthMode6                 = 133
};

enum {
    kFirstDepthMode             = 128,                          /* These constants are obsolete, and just included    */
    kSecondDepthMode            = 129,                          /* for clients that have converted to the above     */
    kThirdDepthMode             = 130,                          /* kDepthModeXXX constants.                */
    kFourthDepthMode            = 131,
    kFifthDepthMode             = 132,
    kSixthDepthMode             = 133
};



struct VDPageInfo {
    DepthMode                           csMode;                     /* mode within device*/
    DisplayModeID                            csData;                     /* data supplied by driver*/
    SInt16                           csPage;                     /* page to switch in*/
    Ptr                             csBaseAddr;                 /* base address of page*/
};
typedef struct VDPageInfo               VDPageInfo;

typedef VDPageInfo *                    VDPgInfoPtr;

struct VDSizeInfo {
    SInt16                           csHSize;                    /* desired/returned h size*/
    SInt16                           csHPos;                     /* desired/returned h position*/
    SInt16                           csVSize;                    /* desired/returned v size*/
    SInt16                           csVPos;                     /* desired/returned v position*/
};
typedef struct VDSizeInfo               VDSizeInfo;

typedef VDSizeInfo *                    VDSzInfoPtr;

struct VDSettings {
    SInt16                           csParamCnt;                 /* number of params*/
    SInt16                           csBrightMax;                /* max brightness*/
    SInt16                           csBrightDef;                /* default brightness*/
    SInt16                           csBrightVal;                /* current brightness*/
    SInt16                           csCntrstMax;                /* max contrast*/
    SInt16                           csCntrstDef;                /* default contrast*/
    SInt16                           csCntrstVal;                /* current contrast*/
    SInt16                           csTintMax;                  /* max tint*/
    SInt16                           csTintDef;                  /* default tint*/
    SInt16                           csTintVal;                  /* current tint*/
    SInt16                           csHueMax;                   /* max hue*/
    SInt16                           csHueDef;                   /* default hue*/
    SInt16                           csHueVal;                   /* current hue*/
    SInt16                           csHorizDef;                 /* default horizontal*/
    SInt16                           csHorizVal;                 /* current horizontal*/
    SInt16                           csHorizMax;                 /* max horizontal*/
    SInt16                           csVertDef;                  /* default vertical*/
    SInt16                           csVertVal;                  /* current vertical*/
    SInt16                           csVertMax;                  /* max vertical*/
};
typedef struct VDSettings               VDSettings;
typedef VDSettings *                    VDSettingsPtr;

struct VDDefMode {
    UInt8                           csID;
    SInt8                           filler;
};
typedef struct VDDefMode                VDDefMode;
typedef VDDefMode *                     VDDefModePtr;

struct VDSyncInfoRec {
    UInt8                           csMode;
    UInt8                           csFlags;
};
typedef struct VDSyncInfoRec            VDSyncInfoRec;

typedef VDSyncInfoRec *                 VDSyncInfoPtr;
/*
   All displayModeID values from 0x80000000 to 0xFFFFFFFF and 0x00
   are reserved for Apple Computer.
*/
/* Constants for the cscGetNextResolution call */
enum {
    kDisplayModeIDCurrent       = 0x00,                         /* Reference the Current DisplayModeID */
    kDisplayModeIDInvalid       = (IODisplayModeID)0xFFFFFFFF,             /* A bogus DisplayModeID in all cases */
    kDisplayModeIDFindFirstResolution = (IODisplayModeID)0xFFFFFFFE,       /* Used in cscGetNextResolution to reset iterator */
    kDisplayModeIDNoMoreResolutions = (IODisplayModeID)0xFFFFFFFD,         /* Used in cscGetNextResolution to indicate End Of List */
    kDisplayModeIDFindFirstProgrammable = (IODisplayModeID)0xFFFFFFFC,     /* Used in cscGetNextResolution to find unused programmable timing */
    kDisplayModeIDBootProgrammable = (IODisplayModeID)0xFFFFFFFB,          /* This is the ID given at boot time by the OF driver to a programmable timing */
    kDisplayModeIDReservedBase  = (IODisplayModeID)0x80000000              /* Lowest (unsigned) DisplayModeID reserved by Apple */
};

/* Constants for the GetGammaInfoList call */
enum {
    kGammaTableIDFindFirst      = (GammaTableID)0xFFFFFFFE,             /* Get the first gamma table ID */
    kGammaTableIDNoMoreTables   = (GammaTableID)0xFFFFFFFD,             /* Used to indicate end of list */
    kGammaTableIDSpecific       = 0x00                          /* Return the info for the given table id */
};

/* Constants for GetMultiConnect call*/
enum {
    kGetConnectionCount         = 0xFFFFFFFF,             /* Used to get the number of possible connections in a "multi-headed" framebuffer environment.*/
    kActivateConnection         = (0 << kConnectionInactive),   /* Used for activating a connection (csConnectFlags value).*/
    kDeactivateConnection       = (1 << kConnectionInactive)    /* Used for deactivating a connection (csConnectFlags value.)*/
};

/* VDCommunicationRec.csBusID values*/
enum {
    kVideoDefaultBus            = 0
};


/* VDCommunicationInfoRec.csBusType values*/
enum {
    kVideoBusTypeInvalid        = 0,
    kVideoBusTypeI2C            = 1,
    kVideoBusTypeDisplayPort    = 2
};


/* VDCommunicationRec.csSendType and VDCommunicationRec.csReplyType values*/
enum {
    kVideoNoTransactionType     = 0,    /* No transaction*/
    kVideoNoTransactionTypeMask = (1 << kVideoNoTransactionType),
    kVideoSimpleI2CType         = 1,    /* Simple I2C message*/
    kVideoSimpleI2CTypeMask     = (1 << kVideoSimpleI2CType),
    kVideoDDCciReplyType        = 2,    /* DDC/ci message (with imbedded length)*/
    kVideoDDCciReplyTypeMask    = (1 << kVideoDDCciReplyType),
    kVideoCombinedI2CType       = 3,    /* Combined format I2C R/~W transaction*/
    kVideoCombinedI2CTypeMask   = (1 << kVideoCombinedI2CType),
    kVideoDisplayPortNativeType       = 4,    /* DisplayPort Native */
    kVideoDisplayPortNativeTypeMask   = (1 << kVideoDisplayPortNativeType)
};

// VDCommunicationRec.csCommFlags and VDCommunicationInfoRec.csSupportedCommFlags
enum {
    kVideoReplyMicroSecDelayBit   = 0,    /* If bit set, the driver should delay csMinReplyDelay micro seconds between send and receive*/
    kVideoReplyMicroSecDelayMask  = (1 << kVideoReplyMicroSecDelayBit),
    kVideoUsageAddrSubAddrBit     = 1,    /* If bit set, the driver understands to use the lower 16 bits of the address field as two 8 bit values (address/subaddress) for the I2C transaction*/
    kVideoUsageAddrSubAddrMask    = (1 << kVideoUsageAddrSubAddrBit)
};


struct VDResolutionInfoRec {
    DisplayModeID                   csPreviousDisplayModeID;    /* ID of the previous resolution in a chain */
    DisplayModeID                   csDisplayModeID;            /* ID of the next resolution */
    UInt32                   csHorizontalPixels;         /* # of pixels in a horizontal line at the max depth */
    UInt32                   csVerticalLines;            /* # of lines in a screen at the max depth */
    Fixed                           csRefreshRate;              /* Vertical Refresh Rate in Hz */
    DepthMode                       csMaxDepthMode;             /* 0x80-based number representing max bit depth */
    UInt32                   csResolutionFlags;          /* Reserved - flag bits */
    uintptr_t                   csReserved;                 /* Reserved */
};
typedef struct VDResolutionInfoRec      VDResolutionInfoRec;

typedef VDResolutionInfoRec *           VDResolutionInfoPtr;

struct VDVideoParametersInfoRec {
    DisplayModeID                   csDisplayModeID;            /* the ID of the resolution we want info on */
    DepthMode                       csDepthMode;                /* The bit depth we want the info on (0x80 based) */
    VPBlockPtr                      csVPBlockPtr;               /* Pointer to a video parameter block */
    UInt32                   csPageCount;                /* Number of pages supported by the resolution */
    VideoDeviceType                 csDeviceType;               /* Device Type:  Direct, Fixed or CLUT; */
    UInt32                          csDepthFlags;               /* Flags */
};
typedef struct VDVideoParametersInfoRec VDVideoParametersInfoRec;

typedef VDVideoParametersInfoRec *      VDVideoParametersInfoPtr;

struct VDGammaInfoRec {
    GammaTableID                    csLastGammaID;              /* the ID of the previous gamma table */
    GammaTableID                    csNextGammaID;              /* the ID of the next gamma table */
    Ptr                             csGammaPtr;                 /* Ptr to a gamma table data */
    uintptr_t                   csReserved;                 /* Reserved */
};
typedef struct VDGammaInfoRec           VDGammaInfoRec;

typedef VDGammaInfoRec *                VDGammaInfoPtr;

struct VDGetGammaListRec {
    GammaTableID                    csPreviousGammaTableID;     /* ID of the previous gamma table */
    GammaTableID                    csGammaTableID;             /* ID of the gamma table following csPreviousDisplayModeID */
    UInt32                   csGammaTableSize;           /* Size of the gamma table in bytes */
    char *                          csGammaTableName;           /* Gamma table name (c-string) */
};
typedef struct VDGetGammaListRec        VDGetGammaListRec;

typedef VDGetGammaListRec *             VDGetGammaListPtr;

struct VDRetrieveGammaRec {
    GammaTableID                    csGammaTableID;             /* ID of gamma table to retrieve */
    GammaTbl *                      csGammaTablePtr;            /* Location to copy desired gamma to */
};
typedef struct VDRetrieveGammaRec       VDRetrieveGammaRec;

typedef VDRetrieveGammaRec *            VDRetrieveGammaPtr;

struct VDSetHardwareCursorRec {
    void *                          csCursorRef;                /* reference to cursor data */
    UInt32                          csReserved1;                /* reserved for future use */
    UInt32                          csReserved2;                /* should be ignored */
};
typedef struct VDSetHardwareCursorRec   VDSetHardwareCursorRec;

typedef VDSetHardwareCursorRec *        VDSetHardwareCursorPtr;

struct VDDrawHardwareCursorRec {
    SInt32                          csCursorX;                  /* x coordinate */
    SInt32                          csCursorY;                  /* y coordinate */
    UInt32                          csCursorVisible;            /* true if cursor is must be visible */
    UInt32                          csReserved1;                /* reserved for future use */
    UInt32                          csReserved2;                /* should be ignored */
};
typedef struct VDDrawHardwareCursorRec  VDDrawHardwareCursorRec;

typedef VDDrawHardwareCursorRec *       VDDrawHardwareCursorPtr;

struct VDSupportsHardwareCursorRec {
    UInt32                          csSupportsHardwareCursor;
                                                                /* true if hardware cursor is supported */
    UInt32                          csReserved1;                /* reserved for future use */
    UInt32                          csReserved2;                /* must be zero */
};
typedef struct VDSupportsHardwareCursorRec VDSupportsHardwareCursorRec;

typedef VDSupportsHardwareCursorRec *   VDSupportsHardwareCursorPtr;

struct VDHardwareCursorDrawStateRec {
    SInt32                          csCursorX;                  /* x coordinate */
    SInt32                          csCursorY;                  /* y coordinate */
    UInt32                          csCursorVisible;            /* true if cursor is visible */
    UInt32                          csCursorSet;                /* true if cursor successfully set by last set control call */
    UInt32                          csReserved1;                /* reserved for future use */
    UInt32                          csReserved2;                /* must be zero */
};
typedef struct VDHardwareCursorDrawStateRec VDHardwareCursorDrawStateRec;

typedef VDHardwareCursorDrawStateRec *  VDHardwareCursorDrawStatePtr;

struct VDConvolutionInfoRec {
    DisplayModeID                   csDisplayModeID;            /* the ID of the resolution we want info on */
    DepthMode                       csDepthMode;                /* The bit depth we want the info on (0x80 based) */
    UInt32                   csPage;
    UInt32                          csFlags;
    UInt32                          csReserved;
};
typedef struct VDConvolutionInfoRec     VDConvolutionInfoRec;

typedef VDConvolutionInfoRec *          VDConvolutionInfoPtr;

struct VDPowerStateRec {
    UInt32                   powerState;
    UInt32                   powerFlags;

    uintptr_t                powerReserved1;
    uintptr_t                powerReserved2;
};
typedef struct VDPowerStateRec          VDPowerStateRec;

typedef VDPowerStateRec *               VDPowerStatePtr;
/*
    Private Data to video drivers.
    
    In versions of MacOS with multiple address spaces (System 8), the OS 
    must know the extent of parameters in order to move them between the caller
    and driver.  The old private-selector model for video drivers does not have
    this information so:
    
    For post-7.x Systems private calls should be implemented using the cscPrivateCall
*/

struct VDPrivateSelectorDataRec {
    LogicalAddress                  privateParameters;          /* Caller's parameters*/
    ByteCount                       privateParametersSize;      /* Size of data sent from caller to driver*/
    LogicalAddress                  privateResults;             /* Caller's return area. Can be nil, or same as privateParameters.*/
    ByteCount                       privateResultsSize;         /* Size of data driver returns to caller. Can be nil, or same as privateParametersSize.*/
};
typedef struct VDPrivateSelectorDataRec VDPrivateSelectorDataRec;


struct VDPrivateSelectorRec {
    UInt32                          reserved;                   /* Reserved (set to 0). */
    VDPrivateSelectorDataRec        data[1];
};
typedef struct VDPrivateSelectorRec     VDPrivateSelectorRec;

struct VDDDCBlockRec {
    UInt32                          ddcBlockNumber;             /* Input -- DDC EDID (Extended Display Identification Data) number (1-based) */
    ResType                         ddcBlockType;               /* Input -- DDC block type (EDID/VDIF) */
    UInt32                          ddcFlags;                   /* Input -- DDC Flags*/
    UInt32                          ddcReserved;                /* Reserved */
    Byte                            ddcBlockData[128];          /* Output -- DDC EDID/VDIF data (kDDCBlockSize) */
};
typedef struct VDDDCBlockRec            VDDDCBlockRec;

typedef VDDDCBlockRec *                 VDDDCBlockPtr;

enum {
                                                                /* timingSyncConfiguration*/
    kSyncInterlaceMask          = (1 << 7),
    kSyncAnalogCompositeMask    = 0,
    kSyncAnalogCompositeSerrateMask = (1 << 2),
    kSyncAnalogCompositeRGBSyncMask = (1 << 1),
    kSyncAnalogBipolarMask      = (1 << 3),
    kSyncAnalogBipolarSerrateMask = (1 << 2),
    kSyncAnalogBipolarSRGBSyncMask = (1 << 1),
    kSyncDigitalCompositeMask   = (1 << 4),
    kSyncDigitalCompositeSerrateMask = (1 << 2),
    kSyncDigitalCompositeMatchHSyncMask = (1 << 2),
    kSyncDigitalSeperateMask    = (1 << 4) + (1 << 3),
    kSyncDigitalVSyncPositiveMask = (1 << 2),
    kSyncDigitalHSyncPositiveMask = (1 << 1)
};




struct VDDisplayTimingRangeRec {
    UInt32                          csRangeSize;                /* Init to sizeof(VDDisplayTimingRangeRec) */
    UInt32                          csRangeType;                /* Init to 0 */
    UInt32                          csRangeVersion;             /* Init to 0 */
    UInt32                          csRangeReserved;            /* Init to 0 */

    UInt32                          csRangeBlockIndex;          /* Requested block (first index is 0)*/
    UInt32                          csRangeGroup;               /* set to 0 */
    UInt32                          csRangeBlockCount;          /* # blocks */
    UInt32                          csRangeFlags;               /* dependent video */

    UInt64                          csMinPixelClock;            /* Min dot clock in Hz */
    UInt64                          csMaxPixelClock;            /* Max dot clock in Hz */

    UInt32                          csMaxPixelError;            /* Max dot clock error */
    UInt32                          csTimingRangeSyncFlags;
    UInt32                          csTimingRangeSignalLevels;
    UInt32                          csTimingRangeSupportedSignalConfigs;

    UInt32                          csMinFrameRate;             /* Hz */
    UInt32                          csMaxFrameRate;             /* Hz */
    UInt32                          csMinLineRate;              /* Hz */
    UInt32                          csMaxLineRate;              /* Hz */


    UInt32                          csMaxHorizontalTotal;       /* Clocks - Maximum total (active + blanking) */
    UInt32                          csMaxVerticalTotal;         /* Clocks - Maximum total (active + blanking) */
    UInt32                          csMaxTotalReserved1;        /* Reserved */
    UInt32                          csMaxTotalReserved2;        /* Reserved */



                                                                /* Some cards require that some timing elements*/
                                                                /* be multiples of a "character size" (often 8*/
                                                                /* clocks).  The "xxxxCharSize" fields document*/
                                                                /* those requirements.*/


    UInt8                           csCharSizeHorizontalActive; /* Character size */
    UInt8                           csCharSizeHorizontalBlanking; /* Character size */
    UInt8                           csCharSizeHorizontalSyncOffset; /* Character size */
    UInt8                           csCharSizeHorizontalSyncPulse; /* Character size */

    UInt8                           csCharSizeVerticalActive;   /* Character size */
    UInt8                           csCharSizeVerticalBlanking; /* Character size */
    UInt8                           csCharSizeVerticalSyncOffset; /* Character size */
    UInt8                           csCharSizeVerticalSyncPulse; /* Character size */

    UInt8                           csCharSizeHorizontalBorderLeft; /* Character size */
    UInt8                           csCharSizeHorizontalBorderRight; /* Character size */
    UInt8                           csCharSizeVerticalBorderTop; /* Character size */
    UInt8                           csCharSizeVerticalBorderBottom; /* Character size */

    UInt8                           csCharSizeHorizontalTotal;  /* Character size for active + blanking */
    UInt8                           csCharSizeVerticalTotal;    /* Character size for active + blanking */
    UInt16                          csCharSizeReserved1;        /* Reserved (Init to 0) */


    UInt32                          csMinHorizontalActiveClocks;
    UInt32                          csMaxHorizontalActiveClocks;
    UInt32                          csMinHorizontalBlankingClocks;
    UInt32                          csMaxHorizontalBlankingClocks;

    UInt32                          csMinHorizontalSyncOffsetClocks;
    UInt32                          csMaxHorizontalSyncOffsetClocks;
    UInt32                          csMinHorizontalPulseWidthClocks;
    UInt32                          csMaxHorizontalPulseWidthClocks;

    UInt32                          csMinVerticalActiveClocks;
    UInt32                          csMaxVerticalActiveClocks;
    UInt32                          csMinVerticalBlankingClocks;
    UInt32                          csMaxVerticalBlankingClocks;

    UInt32                          csMinVerticalSyncOffsetClocks;
    UInt32                          csMaxVerticalSyncOffsetClocks;
    UInt32                          csMinVerticalPulseWidthClocks;
    UInt32                          csMaxVerticalPulseWidthClocks;


    UInt32                          csMinHorizontalBorderLeft;
    UInt32                          csMaxHorizontalBorderLeft;
    UInt32                          csMinHorizontalBorderRight;
    UInt32                          csMaxHorizontalBorderRight;

    UInt32                          csMinVerticalBorderTop;
    UInt32                          csMaxVerticalBorderTop;
    UInt32                          csMinVerticalBorderBottom;
    UInt32                          csMaxVerticalBorderBottom;

    UInt32                          csMaxNumLinks;                /* number of links, if zero, assume link 1 */
    UInt32                          csMinLink0PixelClock;         /* min pixel clock for link 0 (kHz) */
    UInt32                          csMaxLink0PixelClock;         /* max pixel clock for link 0 (kHz) */
    UInt32                          csMinLink1PixelClock;         /* min pixel clock for link 1 (kHz) */
    UInt32                          csMaxLink1PixelClock;         /* max pixel clock for link 1 (kHz) */

    UInt32                          csReserved6;                /* Reserved (Init to 0)*/
    UInt32                          csReserved7;                /* Reserved (Init to 0)*/
    UInt32                          csReserved8;                /* Reserved (Init to 0)*/
};
typedef struct VDDisplayTimingRangeRec  VDDisplayTimingRangeRec;

typedef VDDisplayTimingRangeRec *       VDDisplayTimingRangePtr;

enum {
                                                                /* csDisplayModeState*/
    kDMSModeReady               = 0,                            /* Display Mode ID is configured and ready*/
    kDMSModeNotReady            = 1,                            /* Display Mode ID is is being programmed*/
    kDMSModeFree                = 2                             /* Display Mode ID is not associated with a timing*/
};


/* Video driver Errors -10930 to -10959 */
enum {
    kTimingChangeRestrictedErr  = -10930,
    kVideoI2CReplyPendingErr    = -10931,
    kVideoI2CTransactionErr     = -10932,
    kVideoI2CBusyErr            = -10933,
    kVideoI2CTransactionTypeErr = -10934,
    kVideoBufferSizeErr         = -10935,
    kVideoCannotMirrorErr       = -10936
};


enum {
                                                                /* csTimingRangeSignalLevels*/
    kRangeSupportsSignal_0700_0300_Bit = 0,
    kRangeSupportsSignal_0714_0286_Bit = 1,
    kRangeSupportsSignal_1000_0400_Bit = 2,
    kRangeSupportsSignal_0700_0000_Bit = 3,
    kRangeSupportsSignal_0700_0300_Mask = (1 << kRangeSupportsSignal_0700_0300_Bit),
    kRangeSupportsSignal_0714_0286_Mask = (1 << kRangeSupportsSignal_0714_0286_Bit),
    kRangeSupportsSignal_1000_0400_Mask = (1 << kRangeSupportsSignal_1000_0400_Bit),
    kRangeSupportsSignal_0700_0000_Mask = (1 << kRangeSupportsSignal_0700_0000_Bit)
};


enum {
                                                                /* csSignalConfig*/
    kDigitalSignalBit            = 0,                            /* Do not set.  Mac OS does not currently support arbitrary digital timings*/
    kAnalogSetupExpectedBit      = 1,                            /* Analog displays - display expects a blank-to-black setup or pedestal.  See VESA signal standards.*/
    kInterlacedCEA861SyncModeBit = 2,

    kDigitalSignalMask            = (1 << kDigitalSignalBit),
    kAnalogSetupExpectedMask      = (1 << kAnalogSetupExpectedBit),
    kInterlacedCEA861SyncModeMask = (1 << kInterlacedCEA861SyncModeBit)
};


enum {
                                                                /* csSignalLevels for analog*/
    kAnalogSignalLevel_0700_0300 = 0,
    kAnalogSignalLevel_0714_0286 = 1,
    kAnalogSignalLevel_1000_0400 = 2,
    kAnalogSignalLevel_0700_0000 = 3
};


enum {
                                                                /* csTimingRangeSyncFlags*/
    kRangeSupportsSeperateSyncsBit = 0,
    kRangeSupportsSyncOnGreenBit = 1,
    kRangeSupportsCompositeSyncBit = 2,
    kRangeSupportsVSyncSerrationBit = 3,
    kRangeSupportsSeperateSyncsMask = (1 << kRangeSupportsSeperateSyncsBit),
    kRangeSupportsSyncOnGreenMask = (1 << kRangeSupportsSyncOnGreenBit),
    kRangeSupportsCompositeSyncMask = (1 << kRangeSupportsCompositeSyncBit),
    kRangeSupportsVSyncSerrationMask = (1 << kRangeSupportsVSyncSerrationBit)
};



enum {
                                                                /* csHorizontalSyncConfig and csVerticalSyncConfig*/
    kSyncPositivePolarityBit    = 0,                            /* Digital separate sync polarity for analog interfaces (0 => negative polarity)*/
    kSyncPositivePolarityMask   = (1 << kSyncPositivePolarityBit)
};




/* For timings with kDetailedTimingFormat.*/

struct VDDetailedTimingRec {
    UInt32                          csTimingSize;               /* Init to sizeof(VDDetailedTimingRec)*/
    UInt32                          csTimingType;               /* Init to 0*/
    UInt32                          csTimingVersion;            /* Init to 0*/
    UInt32                          csTimingReserved;           /* Init to 0*/

    DisplayModeID                   csDisplayModeID;            /* Init to 0*/
    UInt32                          csDisplayModeSeed;          /* */
    UInt32                          csDisplayModeState;         /* Display Mode state*/
    UInt32                          csDisplayModeAlias;         /* Mode to use when programmed.*/

    UInt32                          csSignalConfig;
    UInt32                          csSignalLevels;

    UInt64                          csPixelClock;               /* Hz*/

    UInt64                          csMinPixelClock;            /* Hz - With error what is slowest actual clock */
    UInt64                          csMaxPixelClock;            /* Hz - With error what is fasted actual clock */


    UInt32                          csHorizontalActive;         /* Pixels*/
    UInt32                          csHorizontalBlanking;       /* Pixels*/
    UInt32                          csHorizontalSyncOffset;     /* Pixels*/
    UInt32                          csHorizontalSyncPulseWidth; /* Pixels*/

    UInt32                          csVerticalActive;           /* Lines*/
    UInt32                          csVerticalBlanking;         /* Lines*/
    UInt32                          csVerticalSyncOffset;       /* Lines*/
    UInt32                          csVerticalSyncPulseWidth;   /* Lines*/

    UInt32                          csHorizontalBorderLeft;     /* Pixels*/
    UInt32                          csHorizontalBorderRight;    /* Pixels*/
    UInt32                          csVerticalBorderTop;        /* Lines*/
    UInt32                          csVerticalBorderBottom;     /* Lines*/

    UInt32                          csHorizontalSyncConfig;
    UInt32                          csHorizontalSyncLevel;      /* Future use (init to 0)*/
    UInt32                          csVerticalSyncConfig;
    UInt32                          csVerticalSyncLevel;        /* Future use (init to 0)*/

    UInt32                          csNumLinks;                 /* number of links, if 0 = assume link - 0 */

    UInt32                          csReserved2;                /* Init to 0*/
    UInt32                          csReserved3;                /* Init to 0*/
    UInt32                          csReserved4;                /* Init to 0*/

    UInt32                          csReserved5;                /* Init to 0*/
    UInt32                          csReserved6;                /* Init to 0*/
    UInt32                          csReserved7;                /* Init to 0*/
    UInt32                          csReserved8;                /* Init to 0*/
};
typedef struct VDDetailedTimingRec      VDDetailedTimingRec;

typedef VDDetailedTimingRec *           VDDetailedTimingPtr;

/* csScalerFeatures */
enum {
    kScaleStretchOnlyMask         = (1<<0),                     /* True means the driver cannot add borders to avoid non-square pixels */
    kScaleCanUpSamplePixelsMask   = (1<<1),                     /* True means timings with more active clocks than pixels (ie 640x480 pixels on a 1600x1200 timing) */
    kScaleCanDownSamplePixelsMask = (1<<2),                     /* True means timings with fewer active clocks than pixels (ie 1600x1200  pixels on a 640x480 timing) */
    kScaleCanScaleInterlacedMask  = (1<<3),                     /* True means can scale an interlaced timing */
    kScaleCanSupportInsetMask     = (1<<4),                     /* True means can scale a timing with insets */
    kScaleCanRotateMask           = (1<<5),                     /* True means can rotate image */
    kScaleCanBorderInsetOnlyMask  = (1<<6)                      /* True means can scale a timing with insets */
};

/* csScalerFlags */
enum {
    kScaleStretchToFitMask      = 0x00000001,                   /* True means the driver should avoid borders and allow non-square pixels */

    kScaleRotateFlagsMask       = 0x000000f0,

    kScaleSwapAxesMask          = 0x00000010,
    kScaleInvertXMask           = 0x00000020,
    kScaleInvertYMask           = 0x00000040,

    kScaleRotate0Mask           = 0x00000000,
    kScaleRotate90Mask          = kScaleSwapAxesMask | kScaleInvertXMask,
    kScaleRotate180Mask         = kScaleInvertXMask  | kScaleInvertYMask,
    kScaleRotate270Mask         = kScaleSwapAxesMask | kScaleInvertYMask
};

typedef UInt32                  VDClutBehavior;
typedef VDClutBehavior *        VDClutBehaviorPtr;
enum {
    kSetClutAtSetEntries        = 0,                            /* SetEntries behavior is to update clut during SetEntries call*/
    kSetClutAtVBL               = 1                             /* SetEntries behavior is to upate clut at next vbl*/
};


struct VDCommunicationRec {
    SInt32                          csBusID;                    /* kVideoDefaultBus for single headed cards.*/
    UInt32                          csCommFlags;                /* Always zero*/
    UInt32                          csMinReplyDelay;            /* Minimum delay between send and reply transactions (units depend on csCommFlags)*/
    UInt32                          csReserved2;                /* Always zero*/

    UInt32                          csSendAddress;              /* Usually I2C address (eg 0x6E)*/
    UInt32                          csSendType;                 /* See kVideoSimpleI2CType etc.*/
    LogicalAddress                  csSendBuffer;               /* Pointer to the send buffer*/
    ByteCount                       csSendSize;                 /* Number of bytes to send*/

    UInt32                          csReplyAddress;             /* Address from which to read (eg 0x6F for kVideoDDCciReplyType I2C address)*/
    UInt32                          csReplyType;                /* See kVideoDDCciReplyType etc.*/
    LogicalAddress                  csReplyBuffer;              /* Pointer to the reply buffer*/
    ByteCount                       csReplySize;                /* Max bytes to reply (size of csReplyBuffer)*/

    UInt32                          csReserved3;
    UInt32                          csReserved4;
    UInt32                          csReserved5;                /* Always zero*/
    UInt32                          csReserved6;                /* Always zero*/
};
typedef struct VDCommunicationRec       VDCommunicationRec;

typedef VDCommunicationRec *            VDCommunicationPtr;

struct VDCommunicationInfoRec {
    SInt32                          csBusID;                    /* kVideoDefaultBus for single headed cards. */
    UInt32                          csBusType;                  /* See kVideoBusI2C etc.*/
    SInt32                          csMinBus;                   /* Minimum bus (usually kVideoDefaultBus).  Used to probe additional busses*/
    SInt32                          csMaxBus;                   /* Max bus (usually kVideoDefaultBus).  Used to probe additional busses*/

    UInt32                          csSupportedTypes;           /* Bit field for first 32 supported transaction types.  Eg. 0x07 => support for kVideoNoTransactionType, kVideoSimpleI2CType and kVideoDDCciReplyType.*/
    UInt32                          csSupportedCommFlags;       /* Return the flags csCommFlags understood by this driver. */
    UInt32                          csReserved2;                /* Always zero*/
    UInt32                          csReserved3;                /* Always zero*/

    UInt32                          csReserved4;                /* Always zero*/
    UInt32                          csReserved5;                /* Always zero*/
    UInt32                          csReserved6;                /* Always zero*/
    UInt32                          csReserved7;                /* Always zero*/
};
typedef struct VDCommunicationInfoRec   VDCommunicationInfoRec;

typedef VDCommunicationInfoRec *        VDCommunicationInfoPtr;


struct VDScalerRec {
    UInt32                          csScalerSize;               /* Init to sizeof(VDScalerRec) */
    UInt32                          csScalerVersion;            /* Init to 0 */
    UInt32                          csReserved1;                /* Init to 0 */
    UInt32                          csReserved2;                /* Init to 0 */
    
    DisplayModeID                   csDisplayModeID;            /* Display Mode ID modified by this call. */
    UInt32                          csDisplayModeSeed;          /*  */
    UInt32                          csDisplayModeState;         /* Display Mode state */
    UInt32                          csReserved3;                /* Init to 0 */
    
    UInt32                          csScalerFlags;              /* Init to 0 */
    UInt32                          csHorizontalPixels;         /* Graphics system addressable pixels */
    UInt32                          csVerticalPixels;           /* Graphics system addressable lines */
    UInt32                          csHorizontalInset;          /* Border pixels for underscan */
    UInt32                          csVerticalInset;            /* Border lines for underscan */
    UInt32                          csReserved6;                /* Init to 0 */
    UInt32                          csReserved7;                /* Init to 0 */
    UInt32                          csReserved8;                /* Init to 0 */
};
typedef struct VDScalerRec   VDScalerRec;
typedef VDScalerRec  *VDScalerPtr;

struct VDScalerInfoRec {
    UInt32                          csScalerInfoSize;           /* Init to sizeof(VDScalerInfoRec) */
    UInt32                          csScalerInfoVersion;        /* Init to 0 */
    UInt32                          csReserved1;                /* Init to 0 */
    UInt32                          csReserved2;                /* Init to 0 */
    
    UInt32                          csScalerFeatures;           /* Feature flags */
    UInt32                          csMaxHorizontalPixels;      /* limit to horizontal scaled pixels */
    UInt32                          csMaxVerticalPixels;        /* limit to vertical scaled pixels */
    UInt32                          csReserved3;                /* Init to 0 */

    UInt32                          csReserved4;                /* Init to 0 */
    UInt32                          csReserved5;                /* Init to 0 */
    UInt32                          csReserved6;                /* Init to 0 */
    UInt32                          csReserved7;                /* Init to 0 */
};
typedef struct VDScalerInfoRec   VDScalerInfoRec;
typedef VDScalerInfoRec *VDScalerInfoPtr;

enum {
    /* csMirrorFeatures*/
    kMirrorSameDepthOnlyMirrorMask = (1 << 0),                  /* Commonly true - Mirroring can only be done if the displays are the same bitdepth*/
    kMirrorSameSizeOnlyMirrorMask = (1 << 1),                   /* Commonly false - Mirroring can only be done if the displays are the same size*/
    kMirrorSameTimingOnlyMirrorMask = (1 << 2),                 /* Sometimes true - Mirroring can only be done if the displays are the same timing*/
    kMirrorCommonGammaMask        = (1 << 3)                    /* Sometimes true - Only one gamma correction LUT.*/
};

enum {
    /* csMirrorSupportedFlags and csMirrorFlags*/
    kMirrorCanMirrorMask          = (1 << 0),                   /* Set means we can HW mirrored right now (uses csMirrorEntryID)*/
    kMirrorAreMirroredMask        = (1 << 1),                   /* Set means we are HW mirrored right now (uses csMirrorEntryID)*/
    kMirrorUnclippedMirrorMask    = (1 << 2),                   /* Set means mirrored displays are not clipped to their intersection*/
    kMirrorHAlignCenterMirrorMask = (1 << 3),                   /* Set means mirrored displays can/should be centered horizontally*/
    kMirrorVAlignCenterMirrorMask = (1 << 4),                   /* Set means mirrored displays can/should be centered vertically*/
    kMirrorCanChangePixelFormatMask = (1 << 5),                 /* Set means mirrored the device should change the pixel format of mirrored displays to allow mirroring.*/
    kMirrorCanChangeTimingMask    = (1 << 6),                   /* Set means mirrored the device should change the timing of mirrored displays to allow mirroring.*/
    kMirrorClippedMirrorMask      = (1 << 7)                    /* Set means mirrored displays are clipped to their intersection (driver handles blacking and base address adjustment)*/
};

struct VDMirrorRec {
    UInt32              csMirrorSize;           /* Init to sizeof(VDMirrorRec)*/
    UInt32              csMirrorVersion;        /* Init to 0*/
    
    RegEntryID          csMirrorRequestID;   /* Input RegEntryID to check for mirroring support and state*/
    RegEntryID          csMirrorResultID;    /* Output RegEntryID of the next mirrored device*/
    
    UInt32              csMirrorFeatures;       /* Output summary features of the driver*/
    UInt32              csMirrorSupportedFlags; /* Output configuration options supported by the driver*/
    UInt32              csMirrorFlags;          /* Output configuration options active now*/
    UInt32              csReserved1;            /* Init to 0*/
    
    
    UInt32              csReserved2;            /* Init to 0*/
    UInt32              csReserved3;            /* Init to 0*/
    UInt32              csReserved4;            /* Init to 0*/
    UInt32              csReserved5;            /* Init to 0*/
};
typedef struct VDMirrorRec VDMirrorRec;
typedef VDMirrorRec * VDMirrorPtr;

struct VDConfigurationRec {
    UInt32              csConfigFeature;        /* input what feature to config - always input*/
    UInt32              csConfigSupport;        /* output support value - always output*/
    uintptr_t           csConfigValue;          /* input/output feature value - input on Control(), output on Status()*/
    uintptr_t           csReserved1;
    uintptr_t           csReserved2;
};
typedef struct VDConfigurationRec       VDConfigurationRec;
typedef VDConfigurationRec *            VDConfigurationPtr;

enum
{
    kDVIPowerSwitchFeature        = (1 << 0),   /* Used for csConfigFeature*/
    kDVIPowerSwitchSupportMask    = (1 << 0),   /* Read-only*/
    kDVIPowerSwitchActiveMask     = (1 << 0),   /* Read/write for csConfigValue*/
};

struct VDConfigurationFeatureListRec
{
    OSType *    csConfigFeatureList;
    ItemCount   csNumConfigFeatures;
    uintptr_t   csReserved1;
    uintptr_t   csReserved2;
};
typedef struct VDConfigurationFeatureListRec   VDConfigurationFeatureListRec;
typedef VDConfigurationFeatureListRec *        VDConfigurationFeatureListRecPtr;


#ifndef __LP64__
#pragma options align=reset
#endif

#ifdef __cplusplus
}
#endif

#endif /* __IOMACOSVIDEO__ */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             network/                                                                                            0040755 0001750 0001750 00000000000 12612224741 032270  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOEthernetController.h                                                                              0100644 0001750 0001750 00000006575 12567452435 036541  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/network                                                               /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOETHERNETCONTROLLER_H
#define _IOETHERNETCONTROLLER_H

#include <IOKit/network/IONetworkController.h>

/*! @defined kIOEthernetControllerClass
    @abstract kIOEthernetControllerClass is the name of the
        IOEthernetController class. */

#define kIOEthernetControllerClass        "IOEthernetController"

/*! @defined kIOEthernetAddressSize
    @abstract The number of bytes in an Ethernet hardware address. */

#define kIOEthernetAddressSize            6

/*! @defined kIOEthernetMaxPacketSize
    @abstract The maximum size of an Ethernet packet, including
        the FCS bytes. */

#define kIOEthernetMaxPacketSize          1518

/*! @defined kIOEthernetMinPacketSize
    @abstract The minimum size of an Ethernet packet, including
        the FCS bytes. */

#define kIOEthernetMinPacketSize          64

/*! @defined kIOEthernetCRCSize
    @abstract The size in bytes of the 32-bit CRC value appended
        to the end of each Ethernet frame. */

#define kIOEthernetCRCSize                4

/*! @defined kIOEthernetWakeOnLANFilterGroup
    @abstract kIOEthernetWakeOnLANFilterGroup describes the name assigned
        to the Ethernet Wake-On-LAN filter group. This group represents
        wake filters that are supported by the controller. */

#define kIOEthernetWakeOnLANFilterGroup   "IOEthernetWakeOnLANFilterGroup"

/*! @defined kIOEthernetDisabledWakeOnLANFilterGroup
    @abstract kIOEthernetDisabledWakeOnLANFilterGroup describes the name
        assigned to the disabled Ethernet Wake-On-LAN filter group. This
        group represents wake filters that are currently disabled.
        Membership in this group is dynamic. */

#define kIOEthernetDisabledWakeOnLANFilterGroup \
        "IOEthernetDisabledWakeOnLANFilterGroup"

/*! @enum Wake On LAN Filters
    @abstract All filters in the Wake-on-LAN filter group.
    @discussion Each filter listed will respond to a network event that
        will trigger a system wake-up.
    @constant kIOEthernetWakeOnMagicPacket Reception of a Magic Packet.
    @constant kIOEthernetWakeOnPacketAddressMatch Reception of a packet
    which passes through any of the address filtering mechanisms based
    on its destination Ethernet address. This may include unicast,
    broadcast, or multicast addresses depending on the current state
    and setting of the corresponding packet filters. */

enum {
    kIOEthernetWakeOnMagicPacket         = 0x00000001,
    kIOEthernetWakeOnPacketAddressMatch  = 0x00000002
};

#endif /* !_IOETHERNETCONTROLLER_H */
                                                                                                                                   IOEthernetInterface.h                                                                               0100644 0001750 0001750 00000005465 12567452435 036313  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/network                                                               /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOETHERNETINTERFACE_H
#define _IOETHERNETINTERFACE_H

/*! @defined kIOEthernetInterfaceClass
    @abstract The name of the
        IOEthernetInterface class. 
*/

#define kIOEthernetInterfaceClass     "IOEthernetInterface"

/*! @defined kIOActivePacketFilters
    @abstract A property of IOEthernetInterface objects.
    @discussion The kIOActivePacketFilters property has an OSDictionary value that describes the current
        set of packet filters that have been successfully activated. Each
        entry in the dictionary is a key/value pair consisting of the filter
        group name, and an OSNumber describing the set of active filters for
        that group. Entries in this dictionary will mirror those in
        kIORequiredPacketFilters if the controller has reported success for
        all filter change requests from the IOEthernetInterface object. 
*/

#define kIOActivePacketFilters        "IOActivePacketFilters"

/*! @defined kIORequiredPacketFilters
    @abstract A property of IOEthernetInterface objects.
    @discussion The kIORequiredPacketFilters property has an OSDictionary value that describes the current
        set of required packet filters. Each entry in the dictionary is a
        key/value pair consisting of the filter group name, and an OSNumber
        describing the set of required filters for that group. 
*/

#define kIORequiredPacketFilters      "IORequiredPacketFilters"

/*! @defined kIOMulticastAddressList
    @abstract A property of IOEthernetInterface objects.
    @discussion The kIOMulticastAddressList property is an OSData object that describes the
        list of multicast addresses that are being used by the
        controller to match against the destination address of an
        incoming frame. 
*/

#define kIOMulticastAddressList       "IOMulticastAddressList"
#define kIOMulticastFilterData        kIOMulticastAddressList    

#endif /* !_IOETHERNETINTERFACE_H */
                                                                                                                                                                                                           IOEthernetStats.h                                                                                   0100644 0001750 0001750 00000013317 12567452435 035504  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/network                                                               /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * IOEthernetStats.h - Ethernet MIB statistics definitions.
 *
 * HISTORY
 */

#ifndef _IOETHERNETSTATS_H
#define _IOETHERNETSTATS_H

/*! @header IOEthernetStats.h
    @discussion Ethernet statistics. */

//---------------------------------------------------------------------------
// Ethernet-like statistics group.

/*! @typedef IODot3StatsEntry
    @discussion Ethernet MIB statistics structure.
    @field alignmentErrors            dot3StatsAlignmentErrors.
    @field fcsErrors                  dot3StatsFCSErrors.
    @field singleCollisionFrames      dot3StatsSingleCollisionFrames.
    @field multipleCollisionFrames    dot3StatsMultipleCollisionFrames.
    @field sqeTestErrors              dot3StatsSQETestErrors.
    @field deferredTransmissions      dot3StatsDeferredTransmissions.
    @field lateCollisions             dot3StatsLateCollisions.
    @field excessiveCollisions        dot3StatsExcessiveCollisions.
    @field internalMacTransmitErrors  dot3StatsInternalMacTransmitErrors.
    @field carrierSenseErrors         dot3StatsCarrierSenseErrors.
    @field frameTooLongs              dot3StatsFrameTooLongs.
    @field internalMacReceiveErrors   dot3StatsInternalMacReceiveErrors.
    @field etherChipSet               dot3StatsEtherChipSet.
    @field missedFrames               dot3StatsMissedFrames (not in RFC1650).
    */

typedef struct {
    UInt32 alignmentErrors;
    UInt32 fcsErrors;
    UInt32 singleCollisionFrames;
    UInt32 multipleCollisionFrames;
    UInt32 sqeTestErrors;
    UInt32 deferredTransmissions;
    UInt32 lateCollisions;
    UInt32 excessiveCollisions;
    UInt32 internalMacTransmitErrors;
    UInt32 carrierSenseErrors;
    UInt32 frameTooLongs;
    UInt32 internalMacReceiveErrors;
    UInt32 etherChipSet;
    UInt32 missedFrames;
} IODot3StatsEntry;

//---------------------------------------------------------------------------
// Ethernet-like collision statistics group (optional).

/*! @typedef IODot3CollEntry
    @discussion Collision statistics structure.
    @field collFrequencies            dot3StatsCollFrequencies. */

typedef struct {
    UInt32 collFrequencies[16];
} IODot3CollEntry;

//---------------------------------------------------------------------------
// Receiver extra statistics group (not defined by RFC 1650).

/*! @typedef IODot3RxExtraEntry
    @discussion Extra receiver statistics not defined by RFC1650.
    @field overruns            receiver overruns.
    @field watchdogTimeouts    watchdog timer expirations.
    @field frameTooShorts      runt frames.
    @field collisionErrors     frames damages by late collision.
    @field phyErrors           PHY receive errors.
    @field timeouts            receiver timeouts.
    @field interrupts          receiver interrupts.
    @field resets              receiver resets.
    @field resourceErrors      receiver resource shortages.
    */

typedef struct {
    UInt32 overruns;
    UInt32 watchdogTimeouts;
    UInt32 frameTooShorts;
    UInt32 collisionErrors;
    UInt32 phyErrors;
    UInt32 timeouts;
    UInt32 interrupts;
    UInt32 resets;
    UInt32 resourceErrors;
    UInt32 reserved[4];
} IODot3RxExtraEntry;

//---------------------------------------------------------------------------
// Transmitter extra statistics group (not defined by RFC 1650).

/*! @typedef IODot3TxExtraEntry
    @discussion Extra transmitter statistics not defined by RFC1650.
    @field underruns           transmit underruns.
    @field jabbers             jabber events.
    @field phyErrors           PHY transmit errors.
    @field timeouts            transmitter timeouts.
    @field interrupts          transmitter interrupts.
    @field resets              transmitter resets.
    @field resourceErrors      transmitter resource shortages.
    */

typedef struct {
    UInt32 underruns;
    UInt32 jabbers;
    UInt32 phyErrors;
    UInt32 timeouts;
    UInt32 interrupts;
    UInt32 resets;
    UInt32 resourceErrors;
    UInt32 reserved[4];
} IODot3TxExtraEntry;

//---------------------------------------------------------------------------
// Aggregate Ethernet statistics.

/*! @typedef IOEthernetStats
    @discussion Aggregate Ethernet statistics structure.
    @field dot3StatsEntry      IODot3StatsEntry statistics group.
    @field dot3CollEntry       IODot3CollEntry statistics group.
    @field dot3RxExtraEntry    IODot3RxExtraEntry statistics group.
    @field dot3TxExtraEntry    IODot3TxExtraEntry statistics group.
    */

typedef struct {
    IODot3StatsEntry    dot3StatsEntry;
    IODot3CollEntry     dot3CollEntry;
    IODot3RxExtraEntry  dot3RxExtraEntry;
    IODot3TxExtraEntry  dot3TxExtraEntry;   
} IOEthernetStats;

/*! @defined kIOEthernetStatsKey
    @discussion Defines the name of an IONetworkData that contains
    an IOEthernetStats. */

#define kIOEthernetStatsKey             "IOEthernetStatsKey"

#endif /* !_IOETHERNETSTATS_H */
                                                                                                                                                                                                                                                                                                                 IONetworkController.h                                                                               0100644 0001750 0001750 00000025341 12567452435 036404  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/network                                                               /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKCONTROLLER_H
#define _IONETWORKCONTROLLER_H

/*! @defined kIONetworkControllerClass
    @abstract The name of the IONetworkController class. */

#define kIONetworkControllerClass   "IONetworkController"

/*! @defined kIOVendor
    @abstract A property of IONetworkController objects.
    @discussion The kIOVendor property is a property of IONetworkController objects.  It has an OSString value 	that describes the vendor of the network controller. */

#define kIOVendor                "IOVendor"

/*! @defined kIOModel
    @abstract A property of IONetworkController objects.
    @discussion The kIOModel property is a property of IONetworkController objects.  It has an OSString value that 	describes the model of the network controller. */

#define kIOModel                 "IOModel"

/*! @defined kIORevision
    @abstract A property of IONetworkController objects.
    @discussion The kIORevision property is a property of IONetworkController objects.  It has an OSString value 	that describes the revision level of the network controller. */

#define kIORevision              "IORevision"

/*! @defined kIOFeatures
    @abstract A property of IONetworkController objects.
    @discussion The kIOFeatures property is a property of IONetworkController objects. It has an OSNumber value 	that describes generic features defined by IONetworkController that are supported by the
        network controller. */

#define kIOFeatures              "IOFeatures"

/*! @defined kIOMediumDictionary
    @abstract A property of IONetworkController objects.
    @discussion The kIOMediumDictionary property is a property of IONetworkController
        objects.  It has an OSDictionary value that is a container for the
        collection of IONetworkMedium objects that represent the media
        types supported by the network controller.
        Each entry in the dictionary is a key/value pair consisting of
        the medium name, and a dictionary value that contains the
        properties for that medium entry. */

#define kIOMediumDictionary      "IOMediumDictionary"

/*! @defined kIODefaultMedium
    @abstract A property of IONetworkController objects.
    @discussion The kIODefaultMedium property is a property of IONetworkController
        objects.  It has an OSString value that describes the name of the
        default medium. This definition may change or disappear in the
        future. */

#define kIODefaultMedium         "IODefaultMedium"

/*! @defined kIOSelectedMedium
    @abstract A property of IONetworkController objects.
    @discussion The kIOSelectedMedium property is a property of IONetworkController
        objects.  It has an OSSymbol value that describes the name of the
        current selected medium. This name can be used as a key into the
        medium dictionary to gather additional information about the
        selected medium. */

#define kIOSelectedMedium         "IOSelectedMedium"

/*! @defined kIOActiveMedium
    @abstract A property of IONetworkController objects.
    @discussion The kIOActiveMedium property is a property of IONetworkController
        objects.  It has an OSSymbol value that describes the name of the
        active medium. This is the name of the medium where an active
        link has been established. This name can be used as a key into
        the medium dictionary to gather additional information about the
        active medium. */

#define kIOActiveMedium          "IOActiveMedium"

/*! @defined kIOLinkSpeed
    @abstract A property of IONetworkController objects.
    @discussion The kIOLinkSpeed property is a property of IONetworkController
        objects. It has an OSNumber value that describes the speed of the
    	link established over the active medium in bits per second. */

#define kIOLinkSpeed             "IOLinkSpeed"

/*! @defined kIOLinkStatus
    @abstract A property of IONetworkController objects.
    @discussion The kIOLinkStatus property is a property of IONetworkController
        objects. It has an OSNumber value that describes the current network
        link status. See IONetworkMedium for the definition of the link
        status bits. */

#define kIOLinkStatus            "IOLinkStatus"

/*! @defined kIOLinkData
    @abstract A property of IONetworkController objects.
    @discussion The kIOLinkData property is a property of IONetworkController
        objects. It has an OSData value that contains additional information
        describing the active link that was established.
        Its interpretation is not defined. */

#define kIOLinkData              "IOLinkData"

/*! @defined kIOPacketFilters
    @abstract A property of IONetworkController objects.
    @discussion The kIOPacketFilters property is a property of IONetworkController
        objects. It has an OSDictionary value that describes the entire
        set of packet filters supported by the controller. Each entry
        in the dictionary is a key/value pair consisting of the filter
        group name, and an OSNumber describing the set of supported
        filters for that group. */

#define kIOPacketFilters         "IOPacketFilters"

/*! @defined kIOMACAddress
    @abstract A property of IONetworkController objects.
    @discussion The kIOMACAddress property is a property of IONetworkController
        objects. It has an OSData value that describes the hardware
        MAC (media access controller) address, or station address,
        of the network controller. */

#define kIOMACAddress            "IOMACAddress"

/*! @defined kIOMaxPacketSize
    @abstract A property of IONetworkController objects.
    @discussion The kIOMaxPacketSize property is a property of IONetworkController
        objects. It has an OSNumber value that describes the maximum
        packet size supported by the controller. */

#define kIOMaxPacketSize         "IOMaxPacketSize"

/*! @defined kIOMinPacketSize
    @abstract A property of IONetworkController objects.
    @discussion The kIOMinPacketSize property is a property of IONetworkController
        objects. It has an OSNumber value that describes the minimum
        packet size supported by the controller. */

#define kIOMinPacketSize         "IOMinPacketSize"

/*! @defined kIONetworkFilterGroup
    @abstract The name assigned to the standard network filter group. */

#define kIONetworkFilterGroup    "IONetworkFilterGroup"

/*! @enum StandardPacketFilters
    @abstract All standard packet filters. 
    @discussion Each filter will allow the reception of certain class of packets
        depending on its destination MAC address.
    @constant kIOPacketFilterUnicast Reception of unicast packets.
    @constant kIOPacketFilterBroadcast Reception of broadcast packets.
    @constant kIOPacketFilterMulticast Reception of multicast packets
        addressed to a set of multicast addresses.
    @constant kIOPacketFilterMulticastAll Reception of all multicast
        packets.
    @constant kIOPacketFilterPromiscuous Reception of all packets.
    @constant kIOPacketFilterPromiscuousAll Reception of all packets,
        including bad packets. */

enum {
    kIOPacketFilterUnicast         = 0x1,
    kIOPacketFilterBroadcast       = 0x2,
    kIOPacketFilterMulticast       = 0x10,
    kIOPacketFilterMulticastAll    = 0x20,
    kIOPacketFilterPromiscuous     = 0x100,
    kIOPacketFilterPromiscuousAll  = 0x200
};

/*! @enum Network Feature Flags
    @abstract Feature flags returned by the getFeatures() method.
    @constant kIONetworkFeatureNoBSDWait Set this bit in the value
        returned by getFeatures() to disable the automatic wait for
        "IOBSD" resource by the IONetworkController::start() method. 
    @constant kIONetworkFeatureHardwareVlan Set this bit in the value
        returned by getFeatures() to indicate the controller supports hardware
        stripping and stuffing of 802.1q vlan tags.  If the controller supports
        this feature it must enable it when initializing so that all received
        packets delivered to higher layers have the tag stripped.  The controller
        should use setVlanTag() to provide the tag information out of band.
    @constant kIONetworkFeatureSoftwareVlan Set this bit in the value
        returned by getFeatures() to indicate that the controller can support software
        based vlan by transmitting and receiving packets 4 bytes longer that normal. 
    @constant kIONetworkFeatureMultiPages Set this bit if the driver is
	capable of handling packets coming down from the network stack that
	reside in virtually, but not in physically contiguous span of the
	external mbuf clusters.  In this case, the data area of a packet in
	the external mbuf cluster might cross one or more physical pages that
	are disjoint, depending on the interface MTU and the packet size.
	Such a use of larger than system page size clusters by the network
	stack is done for better system efficiency.  Drivers that utilize the
	IOMbufNaturalMemoryCursor with the getPhysicalSegmentsWithCoalesce
	interfaces and enumerate the list of vectors should set this flag
	for possible gain in performance during bulk data transfer.
    @constant kIONetworkFeatureTSOIPv4 Set this bit to advertise support
        for TCP/IPv4 segmentation offload.
    @constant kIONetworkFeatureTSOIPv6 Set this bit to advertise support
        for TCP/IPv6 segmentation offload.
    @constant kIONetworkFeatureTransmitCompletionStatus Set this bit to
        advertise the capability to report per-packet transmit completion status.
        See <code>IONetworkInterface::reportTransmitCompletionStatus</code>.
*/

enum {
    kIONetworkFeatureNoBSDWait                  = 0x01,
    kIONetworkFeatureHardwareVlan               = 0x02,
    kIONetworkFeatureSoftwareVlan               = 0x04,
    kIONetworkFeatureMultiPages                 = 0x08,
    kIONetworkFeatureTSOIPv4                    = 0x10,
    kIONetworkFeatureTSOIPv6                    = 0x20,
    kIONetworkFeatureTransmitCompletionStatus   = 0x40
};

#endif /* !_IONETWORKCONTROLLER_H */
                                                                                                                                                                                                                                                                                               IONetworkData.h                                                                                     0100644 0001750 0001750 00000006727 12567452435 035141  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/network                                                               /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKDATA_H
#define _IONETWORKDATA_H

#define IONetworkParameter IONetworkData  // FIXME

/*! @enum NetworkDataAccessTypes
    @abstract Constants that describe access types.
    @constant kIONetworkDataAccessTypeRead  Read access.
    @constant kIONetworkDataAccessTypeWrite Write access.
    @constant kIONetworkDataAccessTypeReset Reset access.
    @constant kIONetworkDataAccessTypeSerialize Serialization access. 
*/

enum {
    kIONetworkDataAccessTypeRead        = 0x01,
    kIONetworkDataAccessTypeWrite       = 0x02,
    kIONetworkDataAccessTypeReset       = 0x04,
    kIONetworkDataAccessTypeSerialize   = 0x08,
    kIONetworkDataAccessTypeMask        = 0xff
};

/*! @define kIONetworkDataBasicAccessTypes
    @discussion The default access types supported by an IONetworkData
    object. Allow read() and serialize(). */

#define kIONetworkDataBasicAccessTypes \
       (kIONetworkDataAccessTypeRead | kIONetworkDataAccessTypeSerialize)

/*! @enum NetworkDataBufferTypes
    @abstract The types of data buffers that can be managed by an IONetworkData object.
    @constant kIONetworkDataBufferTypeInternal An internal data buffer
              allocated by the init() method.
    @constant kIONetworkDataBufferTypeExternal An external (persistent) data
              buffer.
    @constant kIONetworkDataBufferTypeNone No data buffer. The only useful 
              action perfomed by an IONetworkData object with this buffer type 
              is to call the access notification handler. 
*/

enum {
    kIONetworkDataBufferTypeInternal = 0,
    kIONetworkDataBufferTypeExternal,
    kIONetworkDataBufferTypeNone
};

/*! @defined kIONetworkDataBytes
    @abstract A property of IONetworkData objects.
    @discussion The kIONetworkDataBytes property is an OSData that describes
        the data buffer of an IONetworkData object. This property is present
        only if kIONetworkDataAccessTypeSerialize access is supported. 
*/

#define kIONetworkDataBytes             "Data"

/*! @defined kIONetworkDataAccessTypes
    @abstract A property of IONetworkData objects.
    @discussion The kIONetworkDataAccessTypes property is an OSNumber that
        describes the supported access types of an IONetworkData object. 
*/

#define kIONetworkDataAccessTypes       "Access Types"

/*! @defined kIONetworkDataSize
    @abstract A property of IONetworkData objects.
    @discussion The kIONetworkDataSize property is an OSNumber that
        describes the size of the data buffer of an IONetworkData object. 
*/

#define kIONetworkDataSize              "Size"


#endif /* !_IONETWORKDATA_H */
                                         IONetworkInterface.h                                                                                0100644 0001750 0001750 00000015040 12567452435 036154  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/network                                                               /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKINTERFACE_H
#define _IONETWORKINTERFACE_H

/*! @defined kIONetworkInterfaceClass
    @abstract The name of the IONetworkInterface class. 
*/

#define kIONetworkInterfaceClass  "IONetworkInterface"

/*! @defined kIONetworkData
    @abstract A property of IONetworkInterface objects. 
    @discussion The kIONetworkData property has an OSDictionary value and is a
        container for the set of IONetworkData objects managed by the interface.
        Each entry in the dictionary is a key/value pair consisting of
        the network data name, and an OSDictionary describing the
        contents of the network data. 
*/

#define kIONetworkData            "IONetworkData"

/*! @defined kIOInterfaceType
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceType property has an OSNumber value that
        specifies the type of network interface that this interface represents.
        The type constants are defined in bsd/net/if_types.h. 
*/

#define kIOInterfaceType          "IOInterfaceType"

/*! @defined kIOMaxTransferUnit
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOMaxTransferUnit property has an OSNumber value that
        specifies the maximum transfer unit for the interface in bytes.
*/

#define kIOMaxTransferUnit        "IOMaxTransferUnit"

/*! @defined kIOMediaAddressLength
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOMediaAddressLength property has an OSNumber value that
        specifies the size of the media address in bytes. 
*/

#define kIOMediaAddressLength     "IOMediaAddressLength"

/*! @defined kIOMediaHeaderLength
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOMediaHeaderLength property has an OSNumber value that
        specifies the size of the media header in bytes. 
*/

#define kIOMediaHeaderLength      "IOMediaHeaderLength"

/*! @defined kIOInterfaceFlags
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceFlags property has an OSNumber value that
        specifies the current value of the interface flags. The flag constants
        are defined in bsd/net/if.h. 
*/

#define kIOInterfaceFlags         "IOInterfaceFlags"

/*! @defined kIOInterfaceExtraFlags
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceExtraFlags property has an OSNumber value that
        specifies the current value of the interface eflags. The eflag constants
        are defined in bsd/net/if.h. 
*/

#define kIOInterfaceExtraFlags    "IOInterfaceExtraFlags"

/*! @defined kIOInterfaceUnit
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceUnit property has an OSNumber value that
        describes the unit number assigned to the interface object. 
*/

#define kIOInterfaceUnit          "IOInterfaceUnit"

/*! @defined kIOInterfaceState
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceState property has an OSNumber value that
        describes the current state of the interface object. This property is
        not exported to BSD via the ifnet structure. 
*/

#define kIOInterfaceState         "IOInterfaceState"

/*! @defined kIOInterfaceNamePrefix
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceNamePrefix property has an OSString value that
        describes the string prefix for the BSD name assigned to the interface. 
*/

#define kIOInterfaceNamePrefix    "IOInterfaceNamePrefix"

/*! @defined kIOPrimaryInterface
    @abstract A property of IONetworkInterface objects.
    @discussion The kIOInterfaceNamePrefix property has an OSBoolean value that
        describes whether the interface is the primary or the built-in network
        interface. 
*/

#define kIOPrimaryInterface       "IOPrimaryInterface"

/*! @defined kIOBuiltin
    @abstract kIOBuiltin is a property of IONetworkInterface
        objects. It has an OSBoolean value.
    @discussion The kIOBuiltin property describes whether the
        interface is built-in. 
*/

#define kIOBuiltin                "IOBuiltin"

/*! @defined kIOLocation
    @abstract kIOLocation is a property of IONetworkInterface
        objects. It has an OSString value.
    @discussion The kIOLocation property describes the physical 
        location of built-in interfaces. 
*/

#define kIOLocation               "IOLocation"

/*! @defined kIONetworkNoBSDAttachKey
    @abstract kIONetworkNoBSDAttachKey is a property of IONetworkInterface
        objects. It has an OSBoolean value.
    @discussion Adding a property with this key and the value kOSBooleanTrue
        before the interface is published will hold off the BSD attach.
        When the interface is ready to attach to BSD, remove the property
        and then re-publish the interface by calling registerService().
*/

#define kIONetworkNoBSDAttachKey  "IONetworkNoBSDAttach"

/*! @enum InterfaceObjectStates
    @discussion Constants used to encode the state of the interface object.
   @constant kIONetworkInterfaceRegisteredState The interface object has
        registered with the data link layer.
    @constant kIONetworkInterfaceOpenedState One or more clients have an
        open on the interface object.
    @constant kIONetworkInterfaceDisabledState The interface is temporarily
        unable to service its clients. This will occur when the network
        controller that is servicing the interface has entered a low power
        state that renders it unusable. 
*/

enum {
    kIONetworkInterfaceRegisteredState  = 0x1,
    kIONetworkInterfaceOpenedState      = 0x2,
    kIONetworkInterfaceDisabledState    = 0x4
};

#endif /* !_IONETWORKINTERFACE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                IONetworkLib.h                                                                                      0100644 0001750 0001750 00000016000 12566177313 034755  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/network                                                               /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * HISTORY
 *
 */

#ifndef _IONETWORKLIB_H
#define _IONETWORKLIB_H

#include <IOKit/IOKitLib.h>
#include <IOKit/network/IONetworkData.h>
#include <IOKit/network/IONetworkMedium.h>
#include <IOKit/network/IONetworkStats.h>
#include <IOKit/network/IOEthernetStats.h>
#include <IOKit/network/IONetworkUserClient.h>

typedef UInt32 IONDHandle;

#ifdef __cplusplus
extern "C" {
#endif

/*! @function IONetworkOpen
    @abstract Open a connection to an IONetworkInterface object.
    An IONetworkUserClient object is created to manage the connection. */

    IOReturn IONetworkOpen(io_object_t obj, io_connect_t * con);

/*! @function IONetworkClose
    @abstract Close the connection to an IONetworkInterface object. */

    IOReturn IONetworkClose(io_connect_t con);

/*! @function IONetworkWriteData
    @abstract Write to the buffer of a network data object.
    @param conObj The connection object.
    @param dataHandle The handle of a network data object.
    @param srcBuf The data to write is taken from this buffer.
    @param inSize The size of the source buffer.
    @result kIOReturnSuccess on success, or an error code otherwise. */

    IOReturn IONetworkWriteData(io_connect_t conObj,
                                IONDHandle   dataHandle,
                                UInt8 *      srcBuf,
                                UInt32       inSize);

/*! @function IONetworkReadData
    @abstract Read the buffer of a network data object.
    @param conObj The connection object.
    @param dataHandle The handle of a network data object.
    @param destBuf The buffer where the data read shall be written to.
    @param inOutSizeP Pointer to an integer that the caller must initialize
           to contain the size of the buffer. This function will overwrite
           it with the actual number of bytes written to the buffer.
    @result kIOReturnSuccess on success, or an error code otherwise. */

    IOReturn IONetworkReadData(io_connect_t conObj,
                                IONDHandle   dataHandle,
                                UInt8 *      destBuf,
                                UInt32 *     inOutSizeP);

/*! @function IONetworkResetData
    @abstract Fill the buffer of a network data object with zeroes.
    @param conObject The connection object.
    @param dataHandle The handle of a network data object.
    @result kIOReturnSuccess on success, or an error code otherwise. */

    IOReturn IONetworkResetData(io_connect_t conObject, IONDHandle dataHandle);

/*! @function IONetworkGetDataCapacity
    @abstract Get the capacity (in bytes) of a network data object.
    @param conObject The connection object.
    @param dataHandle The handle of a network data object.
    @param capacityP Upon success, the capacity is written to this address.
    @result kIOReturnSuccess on success, or an error code otherwise. */

    IOReturn IONetworkGetDataCapacity(io_connect_t conObject,
                                      IONDHandle   dataHandle,
                                      UInt32 *     capacityP);

/*! @function IONetworkGetDataHandle
    @abstract Get the handle of a network data object with the given name.
    @param conObject The connection object.
    @param dataName The name of the network data object.
    @param dataHandleP Upon success, the handle is written to this address.
    @result kIOReturnSuccess on success, or an error code otherwise. */

    IOReturn IONetworkGetDataHandle(io_connect_t conObject,
                                    const char * dataName,
                                    IONDHandle * dataHandleP);

/*! @function IONetworkSetPacketFiltersMask
    @abstract Set the packet filters for a given filter group.
    @discussion A network controller may support a number of packets filters
    that can accept or reject a type of packet seen on the network. A filter
    group identifies a set of related filters, such as all filters that will
    allow a packet to pass upstream based on the destination address encoded
    within the packet. This function allows an user-space program to set the
    filtering performed by a given filter group.
    @param connect The connection object returned from IONetworkOpen(). 
    @param filterGroup The name of the packet filter group.
    @param filtersMask A mask of filters to set.
    @param options No options are currently defined.
    @result An IOReturn error code. */

	IOReturn IONetworkSetPacketFiltersMask( io_connect_t    connect,
                                            const io_name_t filterGroup,
                                            UInt32          filtersMask,
                                            IOOptionBits    options );

/*! @enum IONetworkPacketFilterOptions
    @constant kIONetworkSupportedPacketFilters Indicate the filters that are
    supported by the hardware. */

    enum {
        kIONetworkSupportedPacketFilters = 0x0001
    };

/*! @function IONetworkGetPacketFiltersMask
    @abstract Get the packet filters for a given filter group.
    @discussion A network controller may support a number of packets filters
    that can accept or reject a type of packet seen on the network. A filter
    group identifies a set of related filters, such as all filters that will
    allow a packet to pass upstream based on the destination address encoded
    within the packet. This function allows an user-space program to get the
    filtering performed by a given filter group.
    @param connect The connection object returned from IONetworkOpen(). 
    @param filterGroup The name of the packet filter group.
    @param filtersMask Pointer to the return value containing a mask of
    packet filters.
    @param options kIONetworkSupportedPacketFilters may be set to fetch the
    filters that are supported by the hardware.
    @result An IOReturn error code. */

    IOReturn IONetworkGetPacketFiltersMask( io_connect_t    connect,
                                            const io_name_t filterGroup,
                                            UInt32 *        filtersMask,
                                            IOOptionBits    options );

#ifdef __cplusplus
}
#endif

#endif /* !_IONETWORKLIB_H */
IONetworkMedium.h                                                                                   0100644 0001750 0001750 00000015303 12567452435 035476  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/network                                                               /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKMEDIUM_H
#define _IONETWORKMEDIUM_H

__BEGIN_DECLS

#include <net/if_media.h>

/*! @typedef IOMediumType
    @discussion A 32-bit value divided into fields which describes
    a single medium type. */

typedef UInt32 IOMediumType;

/*! @defined kIOMediumType
    @abstract A property of IONetworkMedium objects.
    @discussion The kIOMediumType property is an OSNumber object that describes the type of
        medium that this object represents. 
*/

#define kIOMediumType           "Type"

/*! @defined kIOMediumFlags
    @abstract A property of IONetworkMedium objects.
    @discussion The kIOMediumFlags property is an OSNumber object that describes a set of
        attributes assigned to the medium. 
*/

#define kIOMediumFlags          "Flags"

/*! @defined kIOMediumSpeed
    @abstract A property of IONetworkMedium objects.
    @discussion The kIOMediumSpeed property is an OSNumber object that describes the maximum link
        speed supported by the medium in bits per second. 
*/

#define kIOMediumSpeed          "Speed"

/*! @defined kIOMediumIndex
    @abstract A property of IONetworkMedium objects.
    @discussion The kIOMediumIndex property is an OSNumber object that describes an index assigned
        by the owner of the medium object. Its interpretation is driver
        specific.
*/

#define kIOMediumIndex          "Index"

//===========================================================================
// Medium Type (IOMediumType).
//
// The medium type is encoded by a 32-bit value. The definitions of
// the fields and the encoding for each field is adapted from FreeBSD.
//
// Bits     Definition
// -------------------
//  4-0     medium subtype
//  7-5     network type
// 15-8     network specific options
// 19-16    reserved
// 27-20    common options
// 31-28    instance number

// Ethernet.
//
enum {
    kIOMediumEthernet             =  IFM_ETHER,
    kIOMediumEthernetAuto         =  ( IFM_AUTO    | IFM_ETHER ),
    kIOMediumEthernetManual       =  ( IFM_MANUAL  | IFM_ETHER ),
    kIOMediumEthernetNone         =  ( IFM_NONE    | IFM_ETHER ),
    kIOMediumEthernet10BaseT      =  ( IFM_10_T    | IFM_ETHER ),
    kIOMediumEthernet10Base2      =  ( IFM_10_2    | IFM_ETHER ),
    kIOMediumEthernet10Base5      =  ( IFM_10_5    | IFM_ETHER ),
    kIOMediumEthernet100BaseTX    =  ( IFM_100_TX  | IFM_ETHER ),
    kIOMediumEthernet100BaseFX    =  ( IFM_100_FX  | IFM_ETHER ),
    kIOMediumEthernet100BaseT4    =  ( IFM_100_T4  | IFM_ETHER ),
    kIOMediumEthernet100BaseVG    =  ( IFM_100_VG  | IFM_ETHER ),
    kIOMediumEthernet100BaseT2    =  ( IFM_100_T2  | IFM_ETHER ),
    kIOMediumEthernet1000BaseSX   =  ( IFM_1000_SX | IFM_ETHER ),
    kIOMediumEthernet10BaseSTP    =  ( IFM_10_STP  | IFM_ETHER ),
    kIOMediumEthernet10BaseFL     =  ( IFM_10_FL   | IFM_ETHER ),
    kIOMediumEthernet1000BaseLX   =  ( IFM_1000_LX | IFM_ETHER ),
    kIOMediumEthernet1000BaseCX   =  ( IFM_1000_CX | IFM_ETHER ),
    kIOMediumEthernet1000BaseTX   =  ( IFM_1000_T  | IFM_ETHER ), //deprecated- use kIOMediumEthernet1000BaseT instead
    kIOMediumEthernet1000BaseT    =  ( IFM_1000_T  | IFM_ETHER ),
    kIOMediumEthernetHomePNA1     =  ( IFM_HPNA_1  | IFM_ETHER ),
	kIOMediumEthernet10GBaseSR    =  ( IFM_10G_SR  | IFM_ETHER ),
	kIOMediumEthernet10GBaseLR    =  ( IFM_10G_LR  | IFM_ETHER ),
    kIOMediumEthernet10GBaseCX4   =  ( IFM_10G_CX4 | IFM_ETHER ),
    kIOMediumEthernet10GBaseT     =  ( IFM_10G_T   | IFM_ETHER ),
    kIOMediumEthernet2500BaseT    =  ( IFM_2500_T  | IFM_ETHER ),
    kIOMediumEthernet5000BaseT    =  ( IFM_5000_T  | IFM_ETHER )
};

// IEEE 802.11 Wireless.
//
enum {
    kIOMediumIEEE80211            =  IFM_IEEE80211,
    kIOMediumIEEE80211Auto        =  ( IFM_AUTO           | IFM_IEEE80211 ),
    kIOMediumIEEE80211Manual      =  ( IFM_MANUAL         | IFM_IEEE80211 ),
    kIOMediumIEEE80211None        =  ( IFM_NONE           | IFM_IEEE80211 ),
    kIOMediumIEEE80211FH1         =  ( IFM_IEEE80211_FH1  | IFM_IEEE80211 ),
    kIOMediumIEEE80211FH2         =  ( IFM_IEEE80211_FH2  | IFM_IEEE80211 ),
    kIOMediumIEEE80211DS2         =  ( IFM_IEEE80211_DS2  | IFM_IEEE80211 ),
    kIOMediumIEEE80211DS5         =  ( IFM_IEEE80211_DS5  | IFM_IEEE80211 ),
    kIOMediumIEEE80211DS11        =  ( IFM_IEEE80211_DS11 | IFM_IEEE80211 ),
    kIOMediumIEEE80211DS1         =  ( IFM_IEEE80211_DS1  | IFM_IEEE80211 ),
    kIOMediumIEEE80211OptionAdhoc =  IFM_IEEE80211_ADHOC
};

// Common options.
//
enum {
    kIOMediumOptionFullDuplex     = IFM_FDX,
    kIOMediumOptionHalfDuplex     = IFM_HDX,
    kIOMediumOptionFlowControl    = IFM_FLOW,
    kIOMediumOptionEEE            = IFM_EEE,
    kIOMediumOptionFlag0          = IFM_FLAG0,
    kIOMediumOptionFlag1          = IFM_FLAG1,
    kIOMediumOptionFlag2          = IFM_FLAG2,
    kIOMediumOptionLoopback       = IFM_LOOP
};

// Medium type masks.
//
#define kIOMediumSubTypeMask        IFM_TMASK
#define kIOMediumNetworkTypeMask    IFM_NMASK
#define kIOMediumOptionsMask        IFM_OMASK
#define kIOMediumCommonOptionsMask  IFM_GMASK
#define kIOMediumInstanceShift      IFM_ISHIFT
#define kIOMediumInstanceMask       IFM_IMASK

// Medium type field accessors.
//
#define IOMediumGetSubType(x)       ((x)  & kIOMediumSubTypeMask)
#define IOMediumGetNetworkType(x)   ((x)  & kIOMediumNetworkTypeMask)
#define IOMediumGetInstance(x)      (((x) & kIOMediumInstanceMask) >> \
                                            kIOMediumInstanceShift)

//===========================================================================
// Medium flags.


//===========================================================================
// Link status bits.
//
enum {
    kIONetworkLinkValid           = IFM_AVALID,     // link status is valid
    kIONetworkLinkActive          = IFM_ACTIVE,     // link is up/active.
    kIONetworkLinkNoNetworkChange = IFM_WAKESAMENET
};

__END_DECLS


#endif /* !_IONETWORKMEDIUM_H */
                                                                                                                                                                                                                                                                                                                             IONetworkStack.h                                                                                    0100644 0001750 0001750 00000002514 12567452435 035323  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/network                                                               /*
 * Copyright (c) 1998-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKSTACK_H
#define _IONETWORKSTACK_H

// User-client keys
//
#define kIONetworkStackUserCommandKey   "IONetworkStackUserCommand"
#define kIONetworkStackUserCommand      "IONetworkStackUserCommand"

enum {
    kIONetworkStackRegisterInterfaceWithUnit        = 0,
    kIONetworkStackRegisterInterfaceWithLowestUnit  = 1,
    kIONetworkStackRegisterInterfaceAll             = 2
};

#endif /* !_IONETWORKSTACK_H */
                                                                                                                                                                                    IONetworkStats.h                                                                                    0100644 0001750 0001750 00000006026 12567452435 035356  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/network                                                               /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKSTATS_H
#define _IONETWORKSTATS_H

/*! @header IONetworkStats.h
    @discussion Generic network statistics. */

//------------------------------------------------------------------------
// Generic network statistics. Common to all network interfaces.
//
// WARNING: This structure must match the statistics field in
// ifnet->if_data. This structure will overlay a portion of ifnet.

/*! @typedef IONetworkStats
        @discussion Generic network statistics structure.
        @field inputPackets count input packets.
        @field inputErrors count input errors.
        @field outputPackets count output packets.
        @field outputErrors count output errors.
        @field collisions count collisions on CDMA networks. */

typedef struct {
        UInt32  inputPackets;
        UInt32  inputErrors;
        UInt32  outputPackets;
        UInt32  outputErrors;
        UInt32  collisions;
} IONetworkStats;

/*! @defined kIONetworkStatsKey
        @discussion Defines the name of an IONetworkData that contains
        an IONetworkStats. */

#define kIONetworkStatsKey              "IONetworkStatsKey"

//------------------------------------------------------------------------
// Output queue statistics.

/*! @typedef IOOutputQueueStats
        @discussion Statistics recorded by IOOutputQueue objects.
        @field capacity queue capacity.
        @field size current size of the queue.
        @field peakSize peak size of the queue.
        @field dropCount number of packets dropped.
        @field outputCount number of output packets.
        @field retryCount number of retries.
        @field stallCount number of queue stalls. */

typedef struct {
        UInt32  capacity;
        UInt32  size;
        UInt32  peakSize;
        UInt32  dropCount;
        UInt32  outputCount;
        UInt32  retryCount;
        UInt32  stallCount;
        UInt32  reserved[4];
} IOOutputQueueStats;

/*! @defined kIOOutputQueueStatsKey
        @discussion Defines the name of an IONetworkData that contains
        an IOOutputQueueStats. */

#define kIOOutputQueueStatsKey          "IOOutputQueueStatsKey"

#endif /* !_IONETWORKSTATS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          IONetworkUserClient.h                                                                               0100644 0001750 0001750 00000002750 12567452435 036335  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/network                                                               /*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IONETWORKUSERCLIENT_H
#define _IONETWORKUSERCLIENT_H

// IONetworkUserClient type ID.
//
#define kIONetworkUserClientTypeID   0xff000001
#define kIONUCType                   0xff000001  // FIXME

// IONetworkUserClient call structure definitions.
//
enum {
        kIONUCResetNetworkDataIndex          = 0,
        kIONUCWriteNetworkDataIndex          = 1,
        kIONUCReadNetworkDataIndex           = 2,
        kIONUCGetNetworkDataCapacityIndex    = 3,
        kIONUCGetNetworkDataHandleIndex      = 4,
        kIONUCLastIndex
};


#endif /* !_IONETWORKUSERCLIENT_H */
                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/ps/0040755 0001750 0001750 00000000000 12612224741 031300  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        IOPSKeys.h                                                                                          0100644 0001750 0001750 00000104352 12566177313 033014  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/ps                                                                    /*
 * Copyright (c) 2002-2010 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 *  @header     IOPSKeys.h
 *  
 *  @discussion
 *              IOPSKeys.h defines C strings for use accessing power source data in IOPowerSource
 *              CFDictionaries, as returned by <code>@link //apple_ref/c/func/IOPSGetPowerSourceDescription IOPSGetPowerSourceDescription @/link</code>
 *              Note that all of these C strings must be converted to CFStrings before use. You can wrap
 *              them with the CFSTR() macro, or create a CFStringRef (that you must later CFRelease()) using CFStringCreateWithCString().
 */  

#ifndef _IOPSKEYS_H_
#define _IOPSKEYS_H_

/*!
 * @group       IOPSPowerAdapter Keys
 * 
 * @discussion
 *              Use these kIOPSPowerAdapter keys to decipher the dictionary returned
 *              by @link //apple_ref/c/func/IOPSCopyExternalPowerAdapterDetails IOPSCopyExternalPowerAdapterDetails @/link
 */
 
/*!
 * @define      kIOPSPowerAdapterIDKey
 *
 * @abstract    This key refers to the attached external AC power adapter's ID.
 *              The value associated with this key is a CFNumberRef kCFNumberIntType integer.
 *
 * @discussion  This key may be present in the dictionary returned from 
 *              @link //apple_ref/c/func/IOPSCopyExternalPowerAdapterDetails IOPSCopyExternalPowerAdapterDetails @/link
 *              This key might not be defined in the adapter details dictionary.
 */
#define kIOPSPowerAdapterIDKey          "AdapterID"

/*!
 * @define      kIOPSPowerAdapterWattsKey
 *
 * @abstract    This key refers to the wattage of the external AC power adapter attached to a portable.
 *              The value associated with this key is a CFNumberRef kCFNumberIntType integer value, in units of watts.
 *
 * @discussion  This key may be present in the dictionary returned from 
 *              @link //apple_ref/c/func/IOPSCopyExternalPowerAdapterDetails IOPSCopyExternalPowerAdapterDetails @/link
 *              This key might not be defined in the adapter details dictionary.
 */
#define kIOPSPowerAdapterWattsKey       "Watts"

/*!
 * @define      kIOPSPowerAdapterRevisionKey
 *
 * @abstract    The power adapter's revision.
 *              The value associated with this key is a CFNumberRef kCFNumberIntType integer value
 *
 * @discussion  This key may be present in the dictionary returned from 
 *              @link //apple_ref/c/func/IOPSCopyExternalPowerAdapterDetails IOPSCopyExternalPowerAdapterDetails @/link
 *              This key might not be defined in the adapter details dictionary.
 */
#define kIOPSPowerAdapterRevisionKey   "AdapterRevision"

/*!
 * @define      kIOPSPowerAdapterSerialNumberKey
 *
 * @abstract    The power adapter's serial number.
 *              The value associated with this key is a CFNumberRef kCFNumberIntType integer value
 *
 * @discussion  This key may be present in the dictionary returned from 
 *              @link //apple_ref/c/func/IOPSCopyExternalPowerAdapterDetails IOPSCopyExternalPowerAdapterDetails @/link
 *              This key might not be defined in the adapter details dictionary.
 */ 
#define kIOPSPowerAdapterSerialNumberKey    "SerialNumber"

/*!
 * @define      kIOPSPowerAdapterFamilyKey
 *
 * @abstract    The power adapter's family code.
 *              The value associated with this key is a CFNumberRef kCFNumberIntType integer value
 *
 * @discussion  This key may be present in the dictionary returned from 
 *              @link //apple_ref/c/func/IOPSCopyExternalPowerAdapterDetails IOPSCopyExternalPowerAdapterDetails @/link
 *              This key might not be defined in the adapter details dictionary.
 */
#define kIOPSPowerAdapterFamilyKey          "FamilyCode"

/*!
 * @define      kIOPSPowerAdapterCurrentKey     
 *
 * @abstract    This key refers to the current of the external AC power adapter attached to a portable. 
 *              The value associated with this key is a CFNumberRef kCFNumberIntType integer value, in units of mAmps.
 *
 * @discussion  This key may be present in the dictionary returned from 
 *              @link //apple_ref/c/func/IOPSCopyExternalPowerAdapterDetails IOPSCopyExternalPowerAdapterDetails @/link
 *              This key might not be defined in the adapter details dictionary.
 */
#define kIOPSPowerAdapterCurrentKey         "Current"

/*!
 * @define      kIOPSPowerAdapterSourceKey     
 *
 * @abstract    This key refers to the source of the power.
 *              The value associated with this key is a CFNumberRef kCFNumberIntType integer value.
 *
 * @discussion  This key may be present in the dictionary returned from 
 *              @link //apple_ref/c/func/IOPSCopyExternalPowerAdapterDetails IOPSCopyExternalPowerAdapterDetails @/link
 *              This key might not be defined in the adapter details dictionary.
 */
#define kIOPSPowerAdapterSourceKey          "Source"


/*! 
 * @group       Internal Keys
 * 
 */

/*!
 * @define      kIOPSUPSManagementClaimed
 * 
 * @abstract    Claims UPS management for a third-party driver.
 * @discussion  kIOPSUPSManagementClaimed is obsolete. Do not use. 
 * @deprecated  Unsupported in OS X 10.5 and later.
 */
#define kIOPSUPSManagementClaimed       "/IOKit/UPSPowerManagementClaimed"

/*!
 * @define      kIOPSLowWarnLevelKey 
 *
 * @abstract    Key for the "Warning" UPS low power trigger-level. Default is 50%.
*/
#define kIOPSLowWarnLevelKey           "Low Warn Level"

/*!
 * @define      kIOPSDeadWarnLevelKey 
 *
 * @abstract    Key for the "Shutdown System" low power trigger-level. Default is 20%.
 */
#define kIOPSDeadWarnLevelKey          "Shutdown Level"


/*!
 * @define      kIOPSDynamicStorePath
 *
 * @abstract    This is only used for internal bookkeeping, and should be ignored.
 */
#define kIOPSDynamicStorePath          "/IOKit/PowerSources"


/*!
 * @group       Power Source Commands (UPS)
 *
 */ 

/*!
 * @define      kIOPSCommandDelayedRemovePowerKey
 *
 * @abstract    Command to give a UPS when it should remove power from its AC plugs in a specified amount of time
 * @discussion
 *              <ul>
 *                  <li>The matching argument should be a CFNumber of kCFNumberIntType specifying when the UPS should
 *                  <li>remove power from its AC power ports.
 *              </ul>
 */
#define kIOPSCommandDelayedRemovePowerKey     "Delayed Remove Power"

/*!
 * @define      kIOPSCommandEnableAudibleAlarmKey
 *
 * @abstract    Command to give a UPS when it should either enable or disable the audible alarm.
 * @discussion
 *              <ul>
 *                  <li>The matching argument should be a CFBooleanRef where kCFBooleanTrue enables the alarm and 
 *                  <li>kCFBooleanFalse diables the alarm
 *              </ul>
 */

#define kIOPSCommandEnableAudibleAlarmKey     "Enable Audible Alarm"

/*!
 * @define      kIOPSCommandStartupDelayKey
 *
 * @abstract Tell UPS how long it should wait for 
 * @discussion
 *              <ul>
 *                  <li>The matching argument should be a CFNumber of kCFNumberIntType specifying when the UPS should
 *                  <li>remove power from its AC power ports.
 *              </ul>
 */
#define kIOPSCommandStartupDelayKey           "Startup Delay"

/*!
 * @define      kIOPSCommandSetCurrentLimitKey
 *
 * @abstract Tell the UPS the max current it can draw from an attached power source
 * @discussion
 *              <ul>
 *                  <li>The matching argument should be a CFNumber of kCFNumberIntType specifying the UPS' new current
 *                  <li>limit in mA.
 */
#define kIOPSCommandSetCurrentLimitKey        "Set Current Limit"

/*!
 * @define      kIOPSCommandSetRequiredVoltageKey
 *
 * @abstract Tell the UPS the minimum voltage it needs to provide.
 * @discussion
 *              <ul>
 *                  <li>The matching argument should be a CFNumber of kCFNumberIntType specifying the required voltage
 *                  <li>from a UPS in mV.
 */
#define kIOPSCommandSetRequiredVoltageKey       "Set Required Voltage"

/*!
 * @define      kIOPSCommandSendCurrentStateOfCharge
 *
 * @abstract Tell the UPS the device's current state of charge
 * @discussion
 *              <ul>
 *                  <li>The matching argument should be a CFNumber of kCFNumberIntType specifying the device's
 *                  <li>state of charge as a percentage.
 */
#define kIOPSCommandSendCurrentStateOfCharge       "Send Current State of Charge"


/*!
 * @group       Power Source data keys
 *
 */

/*              These keys specify the values in a dictionary of PowerSource details.
 *              Use these keys in conjunction with the dictionary returned by 
 *              <code>@link //apple_ref/c/func/IOPSGetPowerSourceDescription IOPSGetPowerSourceDescription @/link</code>
 * 
 *              Clients of <code>@link //apple_ref/c/func/IOPSCreatePowerSource IOPSCreatePowerSource @/link</code>
 *              must specify these keys in their power source dictionaries.
 *              Each key is labelled with one of these labels that indicate what information is REQUIRED. to
 *              represent a power source in OS X.
 *
 *              <ul>
 *                  <li> For power source creators: Providing this key is REQUIRED.
 *                  <li> For power source creators: Providing this key is RECOMMENDED.
 *                  <li> For power source creators: Providing this key is OPTIONAL.
 *                  <li> This key is DEPRECATED, do not provide it. 
 *              </ul>
 *
 */ 

/*!
 * @define      kIOPSPowerSourceIDKey
 *
 * @abstract    CFNumber key uniquely identifying a UPS attached to the system.
 *
 * @discussion
 *              <ul>
 *              <li> Apple UPS power sources will publish this key.
 *              <li> Callers should not set this key; OS X power management will publish this key for UPS's.
 *              <li> Type CFNumber, kCFNumberIntType, uniquely identifying an attached UPS.
 *              </ul>
 */
 
#define kIOPSPowerSourceIDKey          "Power Source ID"

 
/*!
 * @define      kIOPSPowerSourceStateKey
 *
 * @abstract    CFDictionary key for the current source of power.
 *
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For power source creators: Providing this key is REQUIRED.
 *              <li> <code>@link kIOPSBatteryPowerValue @/link</code> indicates power source is drawing internal power; 
 *                   <code>@link kIOPSACPowerValue@/link</code> indicates power source is connected to an external power source.
 *              <li> Type CFString, value is <code>@link kIOPSACPowerValue@/link</code>, <code>@link kIOPSBatteryPowerValue@/link</code>, or <code>@link kIOPSOffLineValue@/link</code>.
 *              </ul>
 */

#define kIOPSPowerSourceStateKey       "Power Source State"

/*!
 * @define      kIOPSCurrentCapacityKey
 * @abstract    CFDictionary key for the current power source's capacity.
 * 
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key in units of percent.
 *              <li> The power source's software may specify the units for this key. 
 *                   The units must be consistent for all capacities reported by this power source.
 *                   The power source will usually define this number in units of percent, or mAh.
 *              <li> Clients may derive a percentage of power source battery remaining by dividing "Current Capacity" by "Max Capacity"
 *              <li> For power source creators: Providing this key is REQUIRED.
 *              <li> Type CFNumber kCFNumberIntType (signed integer)
 *              </ul>
 */

#define kIOPSCurrentCapacityKey        "Current Capacity"

/*!
 * @define      kIOPSMaxCapacityKey
 * @abstract    CFDictionary key for the current power source's maximum or "Full Charge Capacity"
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key in units of percent. The value is usually 100%.
 *              <li> The power source's software may specify the units for this key. The units must be consistent for all capacities reported by this power source.
 *              <li> For power source creators: Providing this key is REQUIRED.
 *              <li> Type CFNumber kCFNumberIntType (signed integer)
 *              </ul>
 */

#define kIOPSMaxCapacityKey            "Max Capacity"

/*!
 * @define      kIOPSDesignCapacityKey
 * @abstract    CFDictionary key for the current power source's design capacity
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources might not publish this key.
 *              <li> The power source's software may specify the units for this key. The units must be consistent for all capacities reported by this power source.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFNumber kCFNumberIntType (signed integer)
 *              </ul>
 */

#define kIOPSDesignCapacityKey          "DesignCapacity"

/*!
 * @define      kIOPSNominalCapacityKey
 * @abstract    CFDictionary key for the current power source's normalized full, or "nominal", charge capacity
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources might not publish this key.
 *              <li> The power source's software may specify the units for this key. The units must be consistent for all capacities reported by this power source.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFNumber kCFNumberIntType (signed integer)
 *              </ul>
 */

#define kIOPSNominalCapacityKey         "Nominal Capacity"

/*!
 * @define      kIOPSTimeToEmptyKey
 * @abstract    CFDictionary key for the current power source's time remaining until empty.
 * @discussion
 *              Only valid if the power source is running off its own power. That's when the 
 *              <code>@link kIOPSPowerSourceStateKey @/link</code> has value <code>@link kIOPSBatteryPowerValue @/link</code> 
 *              and the value of <code>@link kIOPSIsChargingKey @/link</code> is kCFBooleanFalse.
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFNumber kCFNumberIntType (signed integer), units are minutes
 *              <li> A value of -1 indicates "Still Calculating the Time", otherwise estimated minutes left on the battery.
 *              </ul>
 */


#define kIOPSTimeToEmptyKey            "Time to Empty"

/*!
 * @define      kIOPSTimeToFullChargeKey
 * @abstract    CFDictionary key for the current power source's time remaining until empty.
 * @discussion
 *              Only valid if the value of <code>@link kIOPSIsChargingKey @/link</code> is kCFBooleanTrue.
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFNumber kCFNumberIntType (signed integer), units are minutes
 *              <li>A value of -1 indicates "Still Calculating the Time", otherwise estimated minutes until fully charged.
 *              </ul>
 */

#define kIOPSTimeToFullChargeKey       "Time to Full Charge"

/*!
 * @define      kIOPSIsChargingKey
 * @abstract    CFDictionary key for the current power source's charging state
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For power source creators: Providing this key is REQUIRED.
 *              <li> Type CFBoolean - kCFBooleanTrue or kCFBooleanFalse
 *              </ul>
 */

#define kIOPSIsChargingKey             "Is Charging"

/*!
 * @define      kIOPSInternalFailureKey
 * @abstract    CFDictionary key for whether the current power source has experienced a failure
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources might not publish this key.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFBoolean - kCFBooleanTrue or kCFBooleanFalse
 *              </ul>
 */

#define kIOPSInternalFailureKey        "Internal Failure"

/*!
 * @define      kIOPSIsPresentKey
 * @abstract    CFDictionary key for the current power source's presence. 
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For instance, a portable with the capacity for two batteries but 
 *                  with only one present would show two power source dictionaries, 
 *                  but kIOPSIsPresentKey would have the value kCFBooleanFalse in one of them.
 *              <li> For power source creators: Providing this key is REQUIRED.
 *              <li> Type CFBoolean - kCFBooleanTrue or kCFBooleanFalse
 *              </ul>
 */

#define kIOPSIsPresentKey              "Is Present"

/*!
 * @define      kIOPSVoltageKey
 * @abstract    CFDictionary key for the current power source's electrical voltage.
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFNumber kCFNumberIntType (signed integer) - units are mV
 *              </ul>
 */

#define kIOPSVoltageKey                "Voltage"

/*!
 * @define      kIOPSCurrentKey
 * @abstract    CFDictionary key for the current power source's electrical current.
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFNumber kCFNumberIntType (signed integer) - units are mA
 *              </ul>
 */

#define kIOPSCurrentKey                "Current"

/*!
 * @define      kIOPSTemperatureKey
 * @abstract    CFDictionary key for the current power source's temperature.
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFNumber kCFNumberIntType (signed integer) - units are C
 *              </ul>
 */
#define kIOPSTemperatureKey                         "Temperature"

/*!
 * @define      kIOPSNameKey
 * @abstract    CFDictionary key for the current power source's name.
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For power source creators: Providing this key is REQUIRED.
 *              <li> Type CFStringRef
 *              </ul>
 */

#define kIOPSNameKey                   "Name"


/*!
 * @define      kIOPSTypeKey
 * @abstract    CFDictionary key for the type of the power source
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For power source creators: Providing this key is REQUIRED.
 *              <li> Type CFStringRef. Valid transport types are kIOPSUPSType or kIOPSInternalBatteryType.
 *              </ul>
 */

#define kIOPSTypeKey          "Type"


/*!
 * @define      kIOPSTransportTypeKey
 * @abstract    CFDictionary key for the current power source's data transport type (e.g. the means that the power source conveys power source data to the OS X machine). 
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> A value of <code>@link kIOPSInternalType @/link</code> describes an internal power source.
 *              <li> <code>@link kIOPSUSBTransportType @/link</code>, <code>@link kIOPSNetworkTransportType @/link</code>, and <code>@link kIOPSSerialTransportType @/link</code> usually describe UPS's.
 *              <li> For power source creators: Providing this key is REQUIRED.
 *              <li> Type CFStringRef. Valid transport types are kIOPSSerialTransportType, 
 *                  kIOPSUSBTransportType, kIOPSNetworkTransportType, kIOPSInternalType
 *              </ul>
 */

#define kIOPSTransportTypeKey          "Transport Type"

/*!
 * @define      kIOPSVendorIDKey
 * @abstract    CFDictionary key for the current power source's vendor ID.
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFNumberRef
 *              </ul>
 */

#define kIOPSVendorIDKey          "Vendor ID"

/*!
 * @define      kIOPSProductIDKey
 * @abstract    CFDictionary key for the current power source's product ID.
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFNumberRef
 *              </ul>
 */

#define kIOPSProductIDKey          "Product ID"

/*!
 * @define      kIOPSVendorDataKey
 * @abstract    CFDictionary key for arbitrary vendor data.
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources are not required to publish this key.
 *              <li> For power source creators: Providing this key is OPTIONAL.
 *              <li>CFDictionary; contents determined by the power source software. OS X will not look at this data.
 *              </ul>
 */

#define kIOPSVendorDataKey          "Vendor Specific Data"

/*!
 * @define      kIOPSBatteryHealthKey
 * @abstract    CFDictionary key for the current power source's "health" estimate.
 * @discussion
 *              <ul>
 *              <li> Apple-defined battery power sources will publish this key.
 *              <li> Use value <code>@link kIOPSGoodValue @/link</code> to describe a well-performing power source, 
 *              <li> Use <code>@link kIOPSFairValue @/link</code> to describe a functional power source with limited capacity
 *              <li> And use  <code>@link kIOPSPoorValue @/link</code> to describe a power source that's not capable of Providing power.
 *              <li> For power source creators: Providing this key is OPTIONAL.
 *              <li> Type CFStringRef
 *              </ul>
 */

#define kIOPSBatteryHealthKey       "BatteryHealth"

/*!
 * @define      kIOPSBatteryHealthConditionKey
 * @abstract    kIOPSBatteryHealthConditionKey broadly describes the battery's health.
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will publish this key.
 *              <li> Value is one of the "Battery Health Condition Values" strings described in this file.
 *              <li> For power source creators: Providing this key is OPTIONAL - these keys have values only used by Apple power sources.
 *              <li> Type CFStringRef
 *              </ul>
 */

#define kIOPSBatteryHealthConditionKey       "BatteryHealthCondition"

/*!
 * @define      kIOPSBatteryFailureModesKey
 * @abstract    Enumerates a battery's failures and error conditions. 
 * @discussion 
 *              Various battery failures will be listed here. A battery may suffer from more than one 
 *              type of failure simultaneously, so this key has a CFArray value.
 *
 *              If BatteryFailureModesKey is not defined (or is set to an empty dictionary), 
 *                  then the battery has no detectable failures.
 *
 *              Each entry in the array should be a short descriptive string describing the error.
 *              <li> Apple-defined power sources will publish this key if any battery errors exist.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFArrayRef
 *              </ul>
 */
#define kIOPSBatteryFailureModesKey          "BatteryFailureModes"

/*!
 * @define      kIOPSHealthConfidenceKey    
 * @abstract    CFDictionary key for our confidence in the accuracy of our 
 *              power source's "health" estimate. 
 * @deprecated  In OS X 10.6 and later.
 * @discussion
 *              <ul>
 *              <li> Apple-defined power sources will no longer publish this key.
 *              <li> Power source creators should not publish this key.
 *              <li> For power source creators: This key is DEPRECATED, do not implement it. 
 *              <li> Type CFStringRef
 *              </ul>
 */

#define kIOPSHealthConfidenceKey    "HealthConfidence"


/*!
 * @define      kIOPSMaxErrKey
 * @abstract    CFDictionary key for the current power source's percentage error in capacity reporting. 
 * @discussion
 *              In internal batteries, this refers to the battery pack's estimated percentage error.
 *              <ul>
 *              <li> Apple-defined battery power sources will publish this key, but only if it's defined for the battery.
 *              <li> For power source creators: Providing this key is OPTIONAL.
 *              <li> Type CFNumberRef kCFNumberIntType, non-negative integer
 *              </ul>
 */

#define kIOPSMaxErrKey              "MaxErr"

/*!
 * @define      kIOPSIsChargedKey
 * @abstract    CFDictionary key indicates whether the battery is charged. 
 * @discussion
 *              A battery must be plugged in to an external power source in order to be fully charged.
 *              Note that a battery may validly be plugged in, not charging, and <100% charge.
 *              e.g. A battery with capacity >= 95% and not charging, is defined as charged.
 *              <ul>
 *                  <li> Apple-defined power sources will publish this key.
 *                  <li> For power source creators: Providing this key is REQUIRED.
 *                  <li> Type CFBoolean - kCFBooleanTrue or kCFBooleanFalse
 *              </ul>
 */

#define kIOPSIsChargedKey                   "Is Charged"

/*!
 * @define      kIOPSIsFinishingChargeKey
 * @abstract    CFDictionary key indicates whether the battery is finishing off its charge.
 * @discussion
 *              When this is true, the system UI should indicate that the battery is "Finishing Charge."
 *              Some batteries may continue charging after they report 100% capacity.
 *              <ul>
 *              <li> Apple-defined battery power sources will publish this key.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFBoolean - kCFBooleanTrue or kCFBooleanFalse
 *              </ul>
 */

#define kIOPSIsFinishingChargeKey              "Is Finishing Charge"

/*!
 * @define      kIOPSHardwareSerialNumberKey
 * @abstract    A unique serial number that identifies the power source.
 * @discussion  For Apple-manufactured batteries, this is an alphanumeric string generated
 *                  during the battery manufacturing process.
 *              <ul>
 *              <li> Apple-defined power sources will publish this key if the hardware provides the serial number.
 *              <li> For power source creators: Providing this key is RECOMMENDED.
 *              <li> Type CFStringRef
 *              </ul>
 */


#define kIOPSHardwareSerialNumberKey            "Hardware Serial Number"



/*
 * @group       Transport types
 * @abstract    Possible values for <code>@link kIOPSTransportTypeKey @/link</code>
 */
/*!
 * @define      kIOPSSerialTransportType
 * @abstract    Value for key <code>@link kIOPSTransportTypeKey @/link</code>. 
 * @discussion  Indicates the power source is a UPS attached over a serial connection.
 */
#define kIOPSSerialTransportType       "Serial"

/*!
 * @define      kIOPSUSBTransportType
 * @abstract    Value for key <code>@link kIOPSTransportTypeKey @/link</code>. 
 * @discussion  Indicates the power source is a UPS attached over a USB connection.
 */
#define kIOPSUSBTransportType          "USB"

/*!
 * @define      kIOPSNetworkTransportType
 * @abstract    Value for key <code>@link kIOPSTransportTypeKey @/link</code>. 
 * @discussion  Indicates the power source is a UPS attached over a network connection (and it may be managing several computers).
 */
#define kIOPSNetworkTransportType      "Ethernet"

/*!
 * @define      kIOPSInternalType
 * @abstract    Value for key <code>@link kIOPSTransportTypeKey @/link</code>. Indicates the power source is an internal battery.
*/
#define kIOPSInternalType              "Internal"


/*
 * @group       PowerSource Types
 * @discussion
 * A string that broadly describes the type of power source. One of these strings must be passed
 * as an argument to IOPSCreatePowerSource() when defining a new system power source.
 */

/*!
 * @define      kIOPSInternalBatteryType 
 *
 * @abstract    Represents a battery residing inside a Mac.
 */
#define kIOPSInternalBatteryType    "InternalBattery"

/*!
 * @define      kIOPSUPSType 
 *
 * @abstract    Represents an external attached UPS.
 */
#define kIOPSUPSType                "UPS"

/*
 * PS state 
 */
/*!
 * @define      kIOPSOffLineValue
 * @abstract    Value for key kIOPSPowerSourceStateKey. Power source is off-line or no longer connected.
*/
#define kIOPSOffLineValue              "Off Line"

/*!
 * @define      kIOPSACPowerValue
 * @abstract    Value for key kIOPSPowerSourceStateKey. Power source is connected to external or AC power, and is not draining the internal battery.
*/
#define kIOPSACPowerValue              "AC Power"

/*!
 * @define      kIOPSBatteryPowerValue
 * @abstract    Value for key kIOPSPowerSourceStateKey. Power source is currently using the internal battery.
*/
#define kIOPSBatteryPowerValue         "Battery Power"



/*!
 * @group Battery Health values
 */
/*!
 * @define      kIOPSPoorValue
 * @abstract    Value for key <code>@link kIOPSBatteryHealthKey @/link</code>.
*/
#define kIOPSPoorValue                  "Poor"

/*!
 * @define      kIOPSFairValue
 * @abstract    Value for key <code>@link kIOPSBatteryHealthKey @/link</code>.
*/
#define kIOPSFairValue                  "Fair"

/*!
 * @define      kIOPSGoodValue
 * @abstract    Value for key <code>@link kIOPSBatteryHealthKey @/link</code>.
*/
#define kIOPSGoodValue                  "Good"



/*
 * @group       Battery Health Condition values
 */
/*!
 * @define      kIOPSCheckBatteryValue
 *
 * @abstract    Value for key <code>@link kIOPSBatteryHealthConditionKey @/link</code>
 *
 * @discussion  This value indicates that the battery should be checked out by a licensed Mac repair service.
 */
#define kIOPSCheckBatteryValue                      "Check Battery"

/*!
 * @define      kIOPSPermanentFailureValue
 *
 * @abstract    Value for key <code>@link kIOPSBatteryHealthConditionKey @/link</code>
 *
 * @discussion  Indicates the battery needs replacement.
 */
#define kIOPSPermanentFailureValue                  "Permanent Battery Failure"


/*!
 * @group       Battery Failure Mode values
 */

/*!
 * @define      kIOPSFailureExternalInput
 *
 * @abstract    Value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureExternalInput                   "Externally Indicated Failure"
/*!
 *  @define     kIOPSFailureSafetyOverVoltage
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureSafetyOverVoltage               "Safety Over-Voltage"
/*!
 *  @define     kIOPSFailureChargeOverTemp
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureChargeOverTemp                  "Charge Over-Temperature"
/*!
 *  @define     kIOPSFailureDischargeOverTemp
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureDischargeOverTemp               "Discharge Over-Temperature"
/*!
 *  @define     kIOPSFailureCellImbalance
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureCellImbalance                   "Cell Imbalance"
/*!
 *  @define     kIOPSFailureChargeFET
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureChargeFET                       "Charge FET"
/*!
 *  @define     kIOPSFailureDischargeFET
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureDischargeFET                    "Discharge FET"
/*!
 *  @define     kIOPSFailureDataFlushFault
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureDataFlushFault                  "Data Flush Fault"
/*!
 *  @define     kIOPSFailurePermanentAFEComms
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailurePermanentAFEComms               "Permanent AFE Comms"
/*!
 *  @define     kIOPSFailurePeriodicAFEComms
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailurePeriodicAFEComms                "Periodic AFE Comms"
/*!
 *  @define     kIOPSFailureChargeOverCurrent
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureChargeOverCurrent               "Charge Over-Current"
/*!
 *  @define     kIOPSFailureDischargeOverCurrent
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureDischargeOverCurrent            "Discharge Over-Current"
/*!
 *  @define     kIOPSFailureOpenThermistor
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureOpenThermistor                  "Open Thermistor"
/*!
 *  @define     kIOPSFailureFuseBlown
 *
 *  @abstract   Potential value for key <code>@link kIOPSBatteryFailureModesKey@/link</code>
 */
#define kIOPSFailureFuseBlown                       "Fuse Blown"

#endif
                                                                                                                                                                                                                                                                                      IOPowerSources.h                                                                                    0100644 0001750 0001750 00000042045 12566177313 034276  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/ps                                                                    /*
 * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * HISTORY
 *
 */

#ifndef _IOKIT_IOPOWERSOURCES_H
#define _IOKIT_IOPOWERSOURCES_H

#include <sys/cdefs.h>
__BEGIN_DECLS


/*! 
 * @header IOPowerSources.h
 *
 * @discussion  IOPowerSources provides uniform access to the state of power sources attached to the system.
 *              You can receive a change notification when any power source data changes.
 *              "Power sources" currently include batteries and UPS devices.
 *
 *              The header follows CF semantics in that it is the caller's responsibility to 
 *              CFRelease() anything returned by a "Copy" function, and the caller should not 
 *              CFRelease() anything returned by a "Get" function.
 */

/*!
 *  @functiongroup Low Power Warnings
 */

/*! @constant   kIOPSNotifyLowBattery
 *
 *  @abstract   Notify(3) key. IOKit posts kIOPSNotifyLowBattery notifications when the
 *              system is drawing from limited battery power, and the battery time 
 *              remaining drops into a warnable level.
 * 
 *              See also kIOPSNotifyPowerSource, and kIOPSNotifyTimeRemaining
 */
#define kIOPSNotifyLowBattery   "com.apple.system.powersources.lowbattery"

/*!
 * @enum       IOPSLowBatteryWarningLevel
 *
 * @discussion Possible return values from <code>@link IOPSGetBatteryWarningLevel@/link</code>
 */
typedef enum {
/*! @constant   kIOPSLowBatteryWarningNone
 *
 *  @abstract   The system is not in a low battery situation, or is on drawing from an external power source.
 *
 *  @discussion The system displays no low power warnings; neither should application clients of this
 *              API.
 */
    kIOPSLowBatteryWarningNone  = 1,

/*! @constant   kIOPSLowBatteryWarningEarly
 *
 *  @abstract   The system is in an early low battery situation.
 *
 *  @discussion Per Apple's definition, the battery has dropped below 22% remaining power.
 *              OS X alerts the user by changing the color of BatteryMonitor to red. 
 *              Warning the user is optional for full screen apps.
 */
    kIOPSLowBatteryWarningEarly = 2,

/*! @constant   kIOPSLowBatteryWarningFinal
 *
 *  @abstract   The battery can provide no more than 10 minutes of runtime.
 *
 *  @discussion OS X makes no guarantees that the system shall remain in Final Warning for 10 minutes.
 *              Batteries are frequently calibrated differently and may provide runtime 
 *              for more, or less, than the estimated 10 minutes.
 */
    kIOPSLowBatteryWarningFinal = 3
} IOPSLowBatteryWarningLevel;

/*! @function   IOPSGetBatteryWarningLevel
 *
 *  @abstract   Indicates whether the system is at a low battery warning level.
 *
 *  @discussion If your app runs in full screen mode and occludes OS X's battery monitor's low
 *              battery warnings, you should alert the user at least when the system 
 *              is in kIOPSLowBatteryWarnFinal.
 */
IOPSLowBatteryWarningLevel IOPSGetBatteryWarningLevel(void);

/*!
 *  @functiongroup Quick Power Source Info
 */

/*! 
 * @define      kIOPSNotifyTimeRemaining
 *              C-string key for a notification of changes to any power source's time remaining estimate.
 *              IOKit also posts this notification  when the active power source changes between AC, Battery, and UPS.
 *
 *              If you only need to detect when the power source changes between AC, Battery, or UPS, please use
 *              <code>@link kIOPSNotifyPowerSource @/link</code>; your code will run less often and conserve battery life.
 *
 *              See API <code>@link IOPSGetTimeRemainingEstimate @/link</code> to determine whether the active power source is
 *              limited or unlimited; and to determine the estimated time remaining until empty.
 *
 *              Use notify(3) API to register for notifications.
 */
#define kIOPSNotifyTimeRemaining                "com.apple.system.powersources.timeremaining"
#define kIOPSTimeRemainingNotificationKey       kIOPSNotifyTimeRemaining

/*!
 * @define      kIOPSNotifyPowerSource
 * @abstract    C-string key for a notification of changes to the active power source.
 * @discussion  Use this notification to discover when the active power source changes from AC power (unlimited/wall power),
 *              to Battery Power or UPS Power (limited power). IOKit will not deliver this notification when a battery's
 *              time remaining changes, only when the active power source changes. This makes it a more effiicent
 *              choice for clients only interested in differentiating AC vs Battery.
 *
 *              See API <code>@link IOPSGetTimeRemainingEstimate @/link</code> to determine whether the active power source is
 *              limited or unlimited.
 *
 *              Example: IOKit posts kIOPSNotifyPowerSource upon connecting or disconnecting AC power to a laptop.
 *                       IOKit posts kIOPSNotifyPowerSource upon a UPS losing AC Power; as the system switches to a limited
 *                       UPS battery power source.
 *
 *              Use notify(3) API to register for notifications.
 * */
#define kIOPSNotifyPowerSource                  "com.apple.system.powersources.source"

/*!
 * @define      kIOPSNotifyAttach
 * @abstract    C-string key for a notification when a power source is attached or detached.
 * @discussion  Example: IOKit posts kIOPSNotifyAttach upon detection of internal battery.
 *                       IOKit posts kIOPSNotifyAttach when a user attaches or detaches an external UPS.
 *
 *              Note that IOKit doesn't deliver kIOPSNotifyAttach upon plugging or unplugging AC Power to a laptop; see
 *              <code>@link kIOPSNotifyPowerSource@/link</code> for changes to the active power source.
 *
 *              IOKit may take many seconds to discover a built-in battery at boot time. If your user process runs
 *              at early boot, use kIOPSNotifyAttach to detect an IOPowerSource's appearance.
 *              Use notify(3) API to register for notifications.
 */
#define kIOPSNotifyAttach                       "com.apple.system.powersources.attach"

/*!
 * @define      kIOPSNotifyAnyPowerSource
 * @abstract    C-string key for a notification that of changes to any attribute of any IOPowerSource.
 * @discussion  Use notify(3) API to register for notifications.
 *              IOKit posts this notificatino more frequently than the other notifications, and thus uses more
 *              energy to run your code. To conserve CPU cycles and battery life, please consider another notification 
 *              that also fits your needs. Please consider these instead:
 *                  <code>@link kIOPSNotifyPowerSource @/link</code>,
 *                  <code>@link kIOPSNotifyTimeRemaining @/link</code>
 *
 */
#define kIOPSNotifyAnyPowerSource               "com.apple.system.powersources"

/*!
 * @constant    kIOPSTimeRemainingUnknown
 *              Possible return value from <code>@link IOPSGetTimeRemainingEstimate@/link</code>
 *              Indicates the system is connected to a limited power source, but the system is still
 *              calculating a time remaining estimate. Check for a valid estimate again when IOKit posts the
 *              notification <code>@link kIOPSPowerSourcesNotificationKey@/link</code>.
 */
#define     kIOPSTimeRemainingUnknown           ((CFTimeInterval)-1.0)

/*!
 * @constant    kIOPSTimeRemainingUnlimited
 *              Possible return value from <code>@link IOPSGetTimeRemainingEstimate@/link</code>
 *              Indicates the system is connected to an external power source, without a time limit.
 */
#define     kIOPSTimeRemainingUnlimited         ((CFTimeInterval)-2.0)

 
/*!
 * @constant    kIOPMUPSPowerKey
 *              Possible return value from <code>@link IOPSGetProvidingPowerSourceType@/link</code>
 *              Indicates that the system is connected to an external power source, that identifies itself as
 *              as an UPS.
 */

#define kIOPMUPSPowerKey                                "UPS Power"

/*!
 * @constant    kIOPMBatteryPowerKey
 *              Possible return value from <code>@link IOPSGetProvidingPowerSourceType@/link</code>
 *              Indicates that the system is connected to internal battery power source.
 */
#define kIOPMBatteryPowerKey                            "Battery Power"

/*!
 * @constant    kIOPMACPowerKey
 *              Possible return value from <code>@link IOPSGetProvidingPowerSourceType@/link</code>
 *              Indicates that the system is connected to an external unlimited power source.
 */
#define kIOPMACPowerKey                                 "AC Power"


/*! 
 * @function    IOPSGetTimeRemainingEstimate
 *
 * @abstract    Returns the estimated minutes remaining until all power sources 
 *              (battery and/or UPS's) are empty, or returns <code>@link kIOPSTimeRemainingUnlimited@/link </code>
 *              if attached to an unlimited power source.
 *
 * @discussion  
 *              If attached to an "Unlimited" power source, like AC power or any external source, the 
 *              return value is <code>@link kIOPSTimeRemainingUnlimited@/link </code>
 *
 *              If the system is on "Limited" power, like a battery or UPS,
 *              but is still calculating the time remaining, which may 
 *              take several seconds after each system power event 
 *              (e.g. waking from sleep, or unplugging AC Power), the return value is 
 *              <code>@link kIOPSTimeRemainingUnknown@/link </code>
 *
 *              Otherwise, if the system is on "Limited" power and the system has an accurate time
 *              remaining estimate, the system returns a CFTimeInterval estimate of the time
 *              remaining until the system is out of battery power.
 *
 *              If you require more detailed battery information, use 
 *              <code>@link IOPSCopyPowerSourcesInfo @/link></code>
 *              and <code>@link IOPSGetPowerSourceDescription @/link></code>.
 *
 * @result      
 *              Returns <code>@link kIOPSTimeRemainingUnknown@/link</code> if the 
 *              OS cannot determine the time remaining. 
 *              
 *              Returns <code>@link kIOPSTimeRemainingUnlimited@/link</code> if the 
 *              system has an unlimited power source.
 *
 *              Otherwise returns a positive number of type CFTimeInterval, indicating the time
 *              remaining in seconds until all power sources are depleted.
 */
CFTimeInterval IOPSGetTimeRemainingEstimate(void);


/*! 
 *  @functiongroup Power Source Descriptions
 */

typedef void  (*IOPowerSourceCallbackType)(void *context);

/*! @function   IOPSCopyPowerSourcesInfo
 *
 *  @abstract   Returns a blob of Power Source information in an opaque CFTypeRef. 
 *
 *  @discussion Clients should not directly access data in the returned CFTypeRef - 
 *              they should use the accessor functions IOPSCopyPowerSourcesList and 
 *              IOPSGetPowerSourceDescription, instead.
 *
 *  @result     NULL if errors were encountered, a CFTypeRef otherwise.
 *              Caller must CFRelease() the return value when done accessing it.
 */
CFTypeRef IOPSCopyPowerSourcesInfo(void);

/*! @function   IOPSCopyPowerSourcesList
 *
 *  @abstract   Returns a CFArray of Power Source handles, each of type CFTypeRef.
 *
 *  @discussion The caller shouldn't directly access the CFTypeRefs, but should use
 *              IOPSGetPowerSourceDescription on each member of the CFArrayRef.
 *
 *  @param      blob Takes the CFTypeRef returned by IOPSCopyPowerSourcesInfo()
 *
 *  @result     Returns NULL if errors were encountered, otherwise a CFArray of CFTypeRefs.
 *              Caller must CFRelease() the returned CFArrayRef.
 */
CFArrayRef IOPSCopyPowerSourcesList(CFTypeRef blob);

/*! @function   IOPSGetPowerSourceDescription
 *  
 *  @abstract Returns a CFDictionary with readable information about the specific power source.
 *
 *  @discussion See the C-strings defined in IOPSKeys.h for specific keys into the dictionary.
 *              Don't expect all keys to be present in any dictionary. Some power sources, for example,
 *              may not support the "Time Remaining To Empty" key and it will not be present in their dictionaries.
 *
 *  @param      blob The CFTypeRef returned by IOPSCopyPowerSourcesInfo()
 *
 *  @param      ps One of the CFTypeRefs in the CFArray returned by IOPSCopyPowerSourcesList()
 *
 *  @result     Returns NULL if an error was encountered, otherwise a CFDictionary. Caller should 
 *              NOT release the returned CFDictionary - it will be released as part of the CFTypeRef returned by
 *              IOPSCopyPowerSourcesInfo().
 */
CFDictionaryRef IOPSGetPowerSourceDescription(CFTypeRef blob, CFTypeRef ps);

/*! @function    IOPSGetProvidingPowerSourceType
 *
 *  @abstract    Indicates the power source the computer is currently drawing from.
 *
 *  @discussion  Determines which power source is providing power.
 *
 *  @param       snapshot The CFTypeRef returned by IOPSCopyPowerSourcesInfo()
 *
 *  @result      One of: CFSTR(kIOPMACPowerKey), CFSTR(kIOPMBatteryPowerKey), CFSTR(kIOPMUPSPowerKey)
 */
CFStringRef     IOPSGetProvidingPowerSourceType(CFTypeRef snapshot);

/*! @function   IOPSNotificationCreateRunLoopSource
 *  
 *  @abstract   Returns a CFRunLoopSourceRef that notifies the caller when power source
 *              information changes.
 *
 *  @discussion Returns a CFRunLoopSourceRef for scheduling with your CFRunLoop. 
 *              If your project does not use a CFRunLoop, you can alternatively
 *              receive notifications via mach port, dispatch, or signal, via <code>notify.h</code>
 *              using the name <code>@link kIOPSTimeRemainingNotificationKey @/link</code>.
 *
 *              IOKit delivers this notification when percent remaining or time remaining changes.
 *              Thus it fires fairly frequently while discharging or charging the battery; 
 *              please consider using:
 *              <code>@link IOPSCreateLimitedPowerNotification @/link</code> if you only require
 *              notifications when the power source type changes from limited to unlimited.
 *
 *  @param      callback A function to be called whenever any power source is added, removed, or changes.
 *
 *  @param      context Any user-defined pointer, passed to the IOPowerSource callback.
 *
 *  @result     Returns NULL if an error was encountered, otherwise a CFRunLoopSource. Caller must
 *              release the CFRunLoopSource.
 */
CFRunLoopSourceRef IOPSNotificationCreateRunLoopSource(IOPowerSourceCallbackType callback, void *context);

/*! @function   IOPSCreateLimitedPowerNotification
 *
 *  @abstract   Returns a CFRunLoopSourceRef that notifies the caller when power source
 *              changes from an unlimited power source (like attached to wall, car, or airplane power), to a limited
 *              power source (like a battery or UPS).
 *
 *  @discussion Returns a CFRunLoopSourceRef for scheduling with your CFRunLoop.
 *              If your project does not use a CFRunLoop, you can alternatively
 *              receive this notification via <code>notify.h</code>
 *              using the name <code>@link kIOPSNotifyPowerSource @/link</code>
 *
 *  @param      callback A function to be called whenever the power source changes from AC to DC..
 *
 *  @param      context Any user-defined pointer, passed to the IOPowerSource callback.
 *
 *  @result     Returns NULL if an error was encountered, otherwise a CFRunLoopSource. Caller must
 *              release the CFRunLoopSource.
 */
CFRunLoopSourceRef IOPSCreateLimitedPowerNotification(IOPowerSourceCallbackType callback, void *context) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0);

/*! @function   IOPSCopyExternalPowerAdapterDetails
 *
 *  @abstract   Returns a CFDictionary that describes the attached (AC) external
 *              power adapter (if any external power adapter is attached.
 *
 *  @discussion Use the kIOPSPowerAdapter... keys described in IOPSKeys.h
 *              to interpret the returned CFDictionary.
 *
 *  @result     Returns a CFDictionary on success. Caller must release the returned
 *              dictionary. If no adapter is attached, or if there's an error,  returns NULL.
 */
CFDictionaryRef IOPSCopyExternalPowerAdapterDetails(void);

__END_DECLS

#endif /* _IOKIT_IOPOWERSOURCES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           IOUPSPlugIn.h                                                                                       0100644 0001750 0001750 00000025350 12566215405 033417  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/ps                                                                    /*
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*! 
    @header IOUPSPlugIn.h
    
    IOUPSPlugIn.h is the header that defines the software used by ioupsd in user-space to communicate with 
    UPS devices.
    <p>
    <b>NOTE:</b>
    Kernel extensions should have the following key/value pair in their personality in order to be 
    recognized by ioupsd:
    <pre>
        <key>UPSDevice</key>
        <true/>
    </pre>
    </p>
    <p>
    To communicate with a UPS device, an instance of IOUPSPlugInInterface (a struct which is defined below) 
    is created. The methods of IOUPSPlugInInterface allow ioupsd to communicate with the device.
    </p>
    <p>
    To obtain an IOUPSPlugInInterface for a UPS device, use the function IOCreatePlugInInterfaceForService() 
    defined in IOKit/IOCFPlugIn.h. (Note the "i" in "PlugIn" is 
    always upper-case.) Quick usage reference:<br>
    <ul>
            <li>'service' is a reference to the IOKit registry entry of the kernel object 
                    (usually of type IOHIDDevice) representing the device
                    of interest. This reference can be obtained using the functions defined in
                    IOKit/IOKitLib.h.</li>
            <li>'plugInType' should be CFUUIDGetUUIDBytes(kIOCFPlugInInterfaceID)</li>
            <li>'interfaceType' should be CFUUIDGetUUIDBytes(kIOUPSPlugInTypeID) when using IOUPSPlugIn</li>
    </ul>
    The interface returned by IOCreatePlugInInterfaceForService() should be deallocated using 
    IODestroyPlugInInterface(). Do not call Release() on it.
    </p>
*/
 
#ifndef _IOKIT_PM_IOUPSPLUGIN_H
#define _IOKIT_PM_IOUPSPLUGIN_H

#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/IOCFPlugIn.h>


/* 40A57A4E-26A0-11D8-9295-000A958A2C78 */
/*! 
    @define kIOUPSPlugInTypeID
    @discussion Type ID for the IOUPSPlugInInterface. Corresponds to an
                 available UPS device. 
*/
#define kIOUPSPlugInTypeID CFUUIDGetConstantUUIDWithBytes(NULL, 	\
    0x40, 0xa5, 0x7a, 0x4e, 0x26, 0xa0, 0x11, 0xd8,			\
    0x92, 0x95, 0x00, 0x0a, 0x95, 0x8a, 0x2c, 0x78)

/* 63F8BFC4-26A0-11D8-88B4-000A958A2C78 */
/*! 
    @define kIOUPSPlugInInterfaceID
    @discussion Interface ID for the IOUPSPlugInInterface. Corresponds to an
                 available UPS device. 
*/
#define kIOUPSPlugInInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL, 	\
    0x63, 0xf8, 0xbf, 0xc4, 0x26, 0xa0, 0x11, 0xd8, 			\
    0x88, 0xb4, 0x0, 0xa, 0x95, 0x8a, 0x2c, 0x78)
    
/* E60E0799-9AA6-49DF-B55B-A5C94BA07A4A */
/*! 
    @define kIOUPSPlugInInterfaceID_v140
    @discussion Interface ID for the IOUPSPlugInInterface. Corresponds to an
                 available UPS device. 
*/
#define kIOUPSPlugInInterfaceID_v140 CFUUIDGetConstantUUIDWithBytes(NULL, 	\
    0xe6, 0xe, 0x7, 0x99, 0x9a, 0xa6, 0x49, 0xdf,               \
    0xb5, 0x5b, 0xa5, 0xc9, 0x4b, 0xa0, 0x7a, 0x4a)


/*! 
    @typedef IOUPSEventCallbackFunction
    @discussion Type and arguments of callout C function that is used when a
                completion routine is called.  This function pointer is set
                via setEventCallback and is called when an event is available 
                from the UPS. 
    @param target void * pointer to your data, often a pointer to an object.
    @param result Completion result of desired operation.
    @param refcon void * pointer to more data.
    @param sender Interface instance sending the completion routine.
    @param event CFDictionaryRef containing event data.
*/
typedef void (*IOUPSEventCallbackFunction)
              (void *	 		target,
               IOReturn 		result,
               void * 			refcon,
               void * 			sender,
               CFDictionaryRef  event);

#define IOUPSPLUGINBASE							\
    IOReturn (*getProperties)(	void * thisPointer, 			\
                                CFDictionaryRef * properties);		\
    IOReturn (*getCapabilities)(void * thisPointer, 			\
                                CFSetRef * capabilities);		\
    IOReturn (*getEvent)(	void * thisPointer, 			\
                                CFDictionaryRef * event);		\
    IOReturn (*setEventCallback)(void * thisPointer, 			\
                                IOUPSEventCallbackFunction callback,	\
                                void * callbackTarget,  		\
                                void * callbackRefcon);			\
    IOReturn (*sendCommand)(	void * thisPointer, 			\
                                CFDictionaryRef command)
                                
#define IOUPSPLUGIN_V140							\
    IOReturn (*createAsyncEventSource)(void * thisPointer,      \
                                CFTypeRef * source)


typedef struct IOUPSPlugInInterface {
    IUNKNOWN_C_GUTS;
    IOUPSPLUGINBASE;
} IOUPSPlugInInterface;

typedef struct IOUPSPlugInInterface_v140 {
    IUNKNOWN_C_GUTS;
    IOUPSPLUGINBASE;
    IOUPSPLUGIN_V140;
} IOUPSPlugInInterface_v140;

//
//  BEGIN READABLE STRUCTURE DEFINITIONS 
//  
//  This portion of uncompiled code provides a more reader friendly representation of 
//  the CFPlugin methods defined above.

#if 0
/*!  
	@interface IOUPSPlugInInterface
	@discussion Represents and provides management functions for a UPS device.
*/

typedef struct IOUPSPlugInInterface {
    IUNKNOWN_C_GUTS;

    /*!
            @function 	getProperties 
            @abstract	Used to obtain the properties of the UPS device such as the 
                        name and transport.
            @discussion Property keys are defined in IOPSKeys.h.  This is not an 
                        allocation method.  Thus the caller does not release the
                        CFDictionary that is returned.
            @param	thisPointer 	The UPS Interface to use.
            @param   	properties 	Pointer to a CFDictionaryRef that contains 
                                        the properties.
            @result	An IOReturn error code.
    */
    IOReturn (*getProperties)(	void * thisPointer,
                                CFDictionaryRef * properties);

    /*!
            @function 	getCapabilities 
            @abstract	Used to obtain the capabilities of the UPS device.
            @discussion Keys are defined in IOPSKeys.h and begin with kIOPS.  This 
                        is not an allocation method.  Thus the caller does not 
                        release the CFSet that is returned.
            @param	thisPointer 	The UPS Interface to use.
            @param   	capabilities 	Pointer to a CFSetRef that contains the 
                                        capabilities.
            @result	An IOReturn error code.
    */
    IOReturn (*getCapabilities)(void * thisPointer,
                                CFSetRef * capabilities);

    /*!
            @function 	getEvent 
            @abstract	Used to poll the current state of the UPS.  
            @discussion Keys are defined in IOPSKeys.h and begin with kIOPS.  This 
                        is not an allocation method.  Thus the caller does not 
                        release the CFDictionary that is returned.
            @param	thisPointer 	The UPS Interface to use.
            @param   	event 		Pointer to a CFDictionaryRef that contains
                                        the current event state.
            @result	An IOReturn error code.
    */
    IOReturn (*getEvent)(	void * thisPointer,
                                CFDictionaryRef * event);

    /*!
            @function	setEventCallback 
            @abstract	Set the callback that should be called to handle an event 
                        from the UPS.
            @discussion The proivided callback method should be called whenever there
                        is a change of state in the UPS.  This should be used in 
                        conjunction with createAsyncEventSource.
            @param      thisPointer     The UPS Interface to use.
            @param   	callback        A callback handler of type 
                                        IOUPSEventCallbackFunction.
            @param   	callbackTarget	The address to be targeted by this callback.
            @param   	callbackRefcon	A user specified reference value. This will 
                                        be passed to all callback functions.
            @result	An IOReturn error code.
    */
    IOReturn (*setEventCallback)(void * thisPointer,
                                IOUPSEventCallbackFunction callback,
                                void * callbackTarget,
                                void * callbackRefcon);

    /*!
            @function 	sendCommand 
            @abstract	Send a command to the UPS.
            @discussion	Command keys are defined in IOPSKeys.h and begin with 
                        kIOPSCommand.  An error should be returned if your device does
                        not know how to respond to a command.
            @param      thisPointer     The UPS Interface to use.
            @param   	command         CFDictionaryRef that contains the command.
            @result	An IOReturn error code.
    */
    IOReturn (*sendCommand)(	void * thisPointer,
                                CFDictionaryRef command);
                                
    /*!
            @function 	createAsyncEventSource 
            @abstract	Used to create an async run loop event source of the plugin. 
            @discussion This is an allocation method.  Thus the caller must 
                        release the object that is returned.
            @param      thisPointer 	The UPS Interface to use.
            @param   	source          Pointer to a CFTypeRef.  It is expected that this
                                        point to either a CFRunLoopSourceRef, a
                                        CFRunLoopTimerRef or a CFArray containing the
                                        aforementioned types.
            @result	An IOReturn error code.
    */
    IOReturn (*createAsyncEventSource)(	void * thisPointer,
                                        CFTypeRef * source);


} IOUPSPlugInInterface;
#endif

//  END READABLE STRUCTURE DEFINITIONS 

#endif /* !_IOKIT_PM_IOUPSPLUGIN_H */
                                                                                                                                                                                                                                                                                        pwr_mgt/                                                                                            0040755 0001750 0001750 00000000000 12612224741 032256  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOPM.h                                                                                              0100644 0001750 0001750 00000112101 12567450737 033203  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/pwr_mgt                                                               /*
 * Copyright (c) 1998-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _IOKIT_IOPM_H
#define _IOKIT_IOPM_H

#include <IOKit/IOTypes.h>
#include <IOKit/IOMessage.h>
#include <IOKit/IOReturn.h>

/*! @header IOPM.h
    @abstract Defines power management constants and keys used by both in-kernel and user space power management.
    @discussion IOPM.h defines a range of power management constants used in several in-kernel and user space APIs. Most significantly, the IOPMPowerFlags used to specify the fields of an IOPMPowerState struct are defined here.

    Most of the constants defined in IOPM.h are deprecated or for Apple internal use only, and are not elaborated on in headerdoc.
*/

enum {
    kIOPMMaxPowerStates = 10,
    IOPMMaxPowerStates = kIOPMMaxPowerStates
};

/*! @enum IOPMPowerFlags
    @abstract Bits are used in defining capabilityFlags, inputPowerRequirements, and outputPowerCharacter in the IOPMPowerState structure.
    @discussion These bits may be bitwise-OR'd together in the IOPMPowerState capabilityFlags field, the outputPowerCharacter field, and/or the inputPowerRequirement field. 
    
    The comments clearly mark whether each flag should be used in the capabilityFlags field, outputPowerCharacter field, and inputPowerRequirement field, or all three.
    
    The value of capabilityFlags, inputPowerRequirement or outputPowerCharacter may be 0. Most drivers implement their 'OFF' state, used when asleep, by defininf each of the 3 fields as 0.
    
    The bits listed below are only the most common bits used to define a device's power states. Your device's IO family may require that your device specify other input or output power flags to interact properly. Consult family-specific documentation to determine if your IOPower plane parents or children require other power flags; they probably don't.

    @constant kIOPMPowerOn Indicates the device is on, requires power, and provides power. Useful as a: Capability, InputPowerRequirement, OutputPowerCharacter

    @constant kIOPMDeviceUsable Indicates the device is usable in this state. Useful only as a Capability

    @constant kIOPMLowPower 
    Indicates device is in a low power state. May be bitwis-OR'd together
    with kIOPMDeviceUsable flag, to indicate the device is still usable.
    
    A device with a capability of kIOPMLowPower may:
       Require either 0 or kIOPMPowerOn from its power parent
       Offer either kIOPMLowPower, kIOPMPowerOn, or 0 (no power at all)
         to its power plane children.

    Useful only as a Capability, although USB drivers should consult USB family documentation for other valid circumstances to use the kIOPMLowPower bit.

    @constant kIOPMPreventIdleSleep
    In the capability field of a power state, disallows idle system sleep while the device is in that state.
    
    For example, displays and disks set this capability for their ON power state; since the system may not idle sleep while the display (and thus keyboard or mouse) or the disk is active.

    Useful only as a Capability.
    
    @constant kIOPMSleepCapability
    Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
    
    @constant kIOPMRestartCapability
    Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
    
    @constant kIOPMSleep
    Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.

    @constant kIOPMRestart
    Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.

    @constant kIOPMInitialDeviceState
    Indicates the initial power state for the device. If <code>initialPowerStateForDomainState()</code> returns a power state with this flag set in the capability field, then the initial power change is performed without calling the driver's <code>setPowerState()</code>.

    @constant kIOPMRootDomainState
    An indication that the power flags represent the state of the root power
    domain. This bit must not be set in the IOPMPowerState structure.
    Power Management may pass this bit to initialPowerStateForDomainState()
    to map from a global system state to the desired device state.
*/
typedef unsigned long IOPMPowerFlags;
enum {
    kIOPMPowerOn                    = 0x00000002,
    kIOPMDeviceUsable               = 0x00008000,
    kIOPMLowPower                   = 0x00010000,
    kIOPMPreventIdleSleep           = 0x00000040,
    kIOPMSleepCapability            = 0x00000004,
    kIOPMRestartCapability          = 0x00000080,
    kIOPMSleep                      = 0x00000001,
    kIOPMRestart                    = 0x00000080,
    kIOPMInitialDeviceState         = 0x00000100,
    kIOPMRootDomainState            = 0x00000200
};

/*
 * Private IOPMPowerFlags
 *
 * For Apple use only
 * Not for use with non-Apple drivers
 * Their behavior is undefined
 */
enum {
    kIOPMClockNormal                = 0x0004,
    kIOPMClockRunning               = 0x0008,
    kIOPMPreventSystemSleep         = 0x0010,
    kIOPMDoze                       = 0x0400,
    kIOPMChildClamp                 = 0x0080,
    kIOPMChildClamp2                = 0x0200,
    kIOPMNotPowerManaged            = 0x0800
};

/*
 * Deprecated IOPMPowerFlags
 * Their behavior is undefined when used in IOPMPowerState
 * Capability, InputPowerRequirement, or OutputPowerCharacter fields.
 */
enum {
    kIOPMMaxPerformance             = 0x4000,
    kIOPMPassThrough                = 0x0100,
    kIOPMAuxPowerOn                 = 0x0020,
    kIOPMNotAttainable              = 0x0001,
    kIOPMContextRetained            = 0x2000,
    kIOPMConfigRetained             = 0x1000,
    kIOPMStaticPowerValid           = 0x0800,
    kIOPMSoftSleep                  = 0x0400,
    kIOPMCapabilitiesMask =     kIOPMPowerOn | kIOPMDeviceUsable | 
                                kIOPMMaxPerformance | kIOPMContextRetained | 
                                kIOPMConfigRetained | kIOPMSleepCapability |
                                kIOPMRestartCapability
};

/*
 * Support for old names of IOPMPowerFlag constants
 */
enum {
    IOPMNotAttainable           = kIOPMNotAttainable,
    IOPMPowerOn                 = kIOPMPowerOn,
    IOPMClockNormal             = kIOPMClockNormal,
    IOPMClockRunning            = kIOPMClockRunning,
    IOPMAuxPowerOn              = kIOPMAuxPowerOn,
    IOPMDeviceUsable            = kIOPMDeviceUsable,
    IOPMMaxPerformance          = kIOPMMaxPerformance,
    IOPMContextRetained         = kIOPMContextRetained,
    IOPMConfigRetained          = kIOPMConfigRetained,
    IOPMNotPowerManaged         = kIOPMNotPowerManaged,
    IOPMSoftSleep               = kIOPMSoftSleep
};


enum {
    kIOPMNextHigherState        = 1,
    kIOPMHighestState           = 2,
    kIOPMNextLowerState         = 3,
    kIOPMLowestState            = 4
};

enum {
    IOPMNextHigherState         = kIOPMNextHigherState,
    IOPMHighestState            = kIOPMHighestState,
    IOPMNextLowerState          = kIOPMNextLowerState,
    IOPMLowestState             = kIOPMLowestState
};

// Internal commands used by power managment command queue
enum {
    kIOPMBroadcastAggressiveness = 1,
    kIOPMUnidleDevice
};

// Power consumption unknown value
enum {
    kIOPMUnknown = 0xFFFF
};

/*******************************************************************************
 *
 * Root Domain property keys of interest
 *
 ******************************************************************************/

/* AppleClamshellState 
 * reflects the state of the clamshell (lid) on a portable.
 * It has a boolean value.
 *  true        == clamshell is closed
 *  false       == clamshell is open
 *  not present == no clamshell on this hardware
 */
#define kAppleClamshellStateKey             "AppleClamshellState"

/* AppleClamshellCausesSleep 
 * reflects the clamshell close behavior on a portable. 
 * It has a boolean value.
 *  true        == system will sleep when clamshell is closed
 *  false       == system will not sleep on clamshell close 
 *                  (typically external display mode)
 *  not present == no clamshell on this hardware
 */
#define kAppleClamshellCausesSleepKey       "AppleClamshellCausesSleep"

/* kIOPMSleepWakeUUIDKey
 * Key refers to a CFStringRef that will uniquely identify
 * a sleep/wake cycle for logging & tracking.
 * The key becomes valid at the beginning of a sleep cycle - before we
 * initiate any sleep/wake notifications.
 * The key becomes invalid at the completion of a system wakeup. The
 * property will not be present in the IOPMrootDomain's registry entry
 * when it is invalid.
 * 
 * See IOPMrootDomain notification kIOPMMessageSleepWakeUUIDChange
 */
 #define kIOPMSleepWakeUUIDKey              "SleepWakeUUID"

/* kIOPMBootSessionUUIDKey
 * Key refers to a CFStringRef that will uniquely identify
 * a boot cycle.
 * The key becomes valid at boot time and remains valid 
 * till shutdown. The property value will remain same across 
 * sleep/wake/hibernate cycle.
 */
#define kIOPMBootSessionUUIDKey             "BootSessionUUID"

/* kIOPMDeepSleepEnabledKey
 * Indicates the Deep Sleep enable state.
 * It has a boolean value.
 *  true        == Deep Sleep is enabled
 *  false       == Deep Sleep is disabled
 *  not present == Deep Sleep is not supported on this hardware
 */
#define kIOPMDeepSleepEnabledKey            "Standby Enabled"

/* kIOPMDeepSleepDelayKey
 * Key refers to a CFNumberRef that represents the delay in seconds before
 * entering Deep Sleep state. The property is not present if Deep Sleep is
 * unsupported.
 */
#define kIOPMDeepSleepDelayKey              "Standby Delay"

/* kIOPMDestroyFVKeyOnStandbyKey
 * Specifies if FileVault key can be stored when going to standby mode
 * It has a boolean value,
 *  true        == Destroy FV key when going to standby mode
 *  false       == Retain FV key when going to standby mode
 *  not present == Retain FV key when going to standby mode
 */
#define kIOPMDestroyFVKeyOnStandbyKey       "DestroyFVKeyOnStandby"

/*******************************************************************************
 *
 * Properties that can control power management behavior
 *
 ******************************************************************************/

/* kIOPMResetPowerStateOnWakeKey
 * If an IOService publishes this key with the value of kOSBooleanTrue,
 * then PM will disregard the influence from changePowerStateToPriv() or
 * any activity tickles that occurred before system sleep when resolving
 * the initial device power state on wake. Influences from power children
 * and changePowerStateTo() are not eliminated. At the earliest opportunity
 * upon system wake, PM will query the driver for a new power state to be
 * installed as the initial changePowerStateToPriv() influence, by calling
 * initialPowerStateForDomainState() with both kIOPMRootDomainState and
 * kIOPMPowerOn flags set. The default implementation will always return
 * the lowest power state. Drivers can override this default behavior to
 * immediately raise the power state when there are work blocked on the
 * power change, and cannot afford to wait until the next activity tickle.
 * This property should be statically added to a driver's plist or set at
 * runtime before calling PMinit().
 */
#define kIOPMResetPowerStateOnWakeKey       "IOPMResetPowerStateOnWake"

/*******************************************************************************
 *
 * Driver PM Assertions
 *
 ******************************************************************************/

/* Driver Assertion bitfield description
 * Driver PM assertions are defined by these bits.
 */
enum {
    /*! kIOPMDriverAssertionCPUBit
     * When set, PM kernel will prefer to leave the CPU and core hardware
     * running in "Dark Wake" state, instead of sleeping.
     */
    kIOPMDriverAssertionCPUBit                      = 0x01,

    /*! kIOPMDriverAssertionUSBExternalDeviceBit
     * When set, driver is informing PM that an external USB device is attached.
     */
    kIOPMDriverAssertionUSBExternalDeviceBit        = 0x04,

    /*! kIOPMDriverAssertionBluetoothHIDDevicePairedBit
     * When set, driver is informing PM that a Bluetooth HID device is paired.
     */
    kIOPMDriverAssertionBluetoothHIDDevicePairedBit = 0x08,

    /*! kIOPMDriverAssertionExternalMediaMountedBit
     * When set, driver is informing PM that an external media is mounted.
     */
    kIOPMDriverAssertionExternalMediaMountedBit     = 0x10,

    /*! kIOPMDriverAssertionReservedBit5
     * Reserved for Thunderbolt.
     */
    kIOPMDriverAssertionReservedBit5                = 0x20,

    /*! kIOPMDriverAssertionPreventDisplaySleepBit
     * When set, the display should remain powered on while the system's awake.
     */
    kIOPMDriverAssertionPreventDisplaySleepBit      = 0x40,

    /*! kIOPMDriverAssertionReservedBit7
     * Reserved for storage family.
     */
    kIOPMDriverAssertionReservedBit7                = 0x80,

    /*! kIOPMDriverAssertionMagicPacketWakeEnabledBit
     * When set, driver is informing PM that magic packet wake is enabled.
     */
    kIOPMDriverAssertionMagicPacketWakeEnabledBit   = 0x100,

    /*! kIOPMDriverAssertionNetworkKeepAliveActiveBit
     * When set, driver is informing PM that it is holding the network
     * interface up to do TCPKeepAlive
     */
    kIOPMDriverAssertionNetworkKeepAliveActiveBit   = 0x200
};

 /* kIOPMAssertionsDriverKey
  * This kIOPMrootDomain key refers to a CFNumberRef property, containing
  * a bitfield describing the aggregate PM assertion levels.
  * Example: A value of 0 indicates that no driver has asserted anything.
  * Or, a value of <link>kIOPMDriverAssertionCPUBit</link>
  *   indicates that a driver (or drivers) have asserted a need for CPU and video.
  */
#define kIOPMAssertionsDriverKey            "DriverPMAssertions"

 /* kIOPMAssertionsDriverKey
  * This kIOPMrootDomain key refers to a CFNumberRef property, containing
  * a bitfield describing the aggregate PM assertion levels.
  * Example: A value of 0 indicates that no driver has asserted anything.
  * Or, a value of <link>kIOPMDriverAssertionCPUBit</link>
  *   indicates that a driver (or drivers) have asserted a need for CPU and video.
  */
#define kIOPMAssertionsDriverDetailedKey    "DriverPMAssertionsDetailed"

/*******************************************************************************
 *
 * Kernel Driver assertion detailed dictionary keys
 *
 * Keys decode the Array & dictionary data structure under IOPMrootDomain property 
 *  kIOPMAssertionsDriverKey.
 *
 */
#define kIOPMDriverAssertionIDKey               "ID"
#define kIOPMDriverAssertionCreatedTimeKey      "CreatedTime"
#define kIOPMDriverAssertionModifiedTimeKey     "ModifiedTime"
#define kIOPMDriverAssertionOwnerStringKey      "Owner"
#define kIOPMDriverAssertionOwnerServiceKey     "ServicePtr"
#define kIOPMDriverAssertionRegistryEntryIDKey  "RegistryEntryID"
#define kIOPMDriverAssertionLevelKey            "Level"
#define kIOPMDriverAssertionAssertedKey         "Assertions"

/*******************************************************************************
 *
 * Root Domain general interest messages
 *
 * Available by registering for interest type 'gIOGeneralInterest' 
 * on IOPMrootDomain. 
 *
 ******************************************************************************/

/* kIOPMMessageClamshellStateChange
 * Delivered as a general interest notification on the IOPMrootDomain
 * IOPMrootDomain sends this message when state of either AppleClamshellState
 * or AppleClamshellCausesSleep changes. If this clamshell change results in
 * a sleep, the sleep will initiate soon AFTER delivery of this message.
 * The state of both variables is encoded in a bitfield argument sent with
 * the message. Check bits 0 and 1 using kClamshellStateBit & kClamshellSleepBit
 */
enum {
    kClamshellStateBit = (1 << 0),
    kClamshellSleepBit = (1 << 1)
};

#define kIOPMMessageClamshellStateChange   \
                iokit_family_msg(sub_iokit_powermanagement, 0x100)

/* kIOPMMessageFeatureChange
 * Delivered when the set of supported features ("Supported Features" dictionary
 * under IOPMrootDomain registry) changes in some way. Typically addition or
 * removal of a supported feature.
 * RootDomain passes no argument with this message.
 */
#define kIOPMMessageFeatureChange           \
                iokit_family_msg(sub_iokit_powermanagement, 0x110)

/* kIOPMMessageInflowDisableCancelled
 * The battery has drained completely to its "Fully Discharged" state. 
 * If a user process has disabled battery inflow for battery 
 * calibration, we forcibly re-enable Inflow at this point.
 * If inflow HAS been forcibly re-enabled, bit 0
 * (kInflowForciblyEnabledBit) will be set.
 */
enum {
    kInflowForciblyEnabledBit = (1 << 0)
};

/* kIOPMMessageInternalBatteryFullyDischarged
 * The battery has drained completely to its "Fully Discharged" state. 
 */
#define kIOPMMessageInternalBatteryFullyDischarged  \
                iokit_family_msg(sub_iokit_powermanagement, 0x120)

/* kIOPMMessageSystemPowerEventOccurred
 * Some major system thermal property has changed, and interested clients may
 * modify their behavior.
 */
#define kIOPMMessageSystemPowerEventOccurred  \
                iokit_family_msg(sub_iokit_powermanagement, 0x130)

/* kIOPMMessageSleepWakeUUIDChange
 * Either a new SleepWakeUUID has been specified at the beginning of a sleep,
 * or we're removing the existing property upon completion of a wakeup.
 */
#define kIOPMMessageSleepWakeUUIDChange  \
                iokit_family_msg(sub_iokit_powermanagement, 0x140)
                
/* kIOPMMessageSleepWakeUUIDSet
 * Argument accompanying the kIOPMMessageSleepWakeUUIDChange notification when 
 * a new UUID has been specified.
 */
#define kIOPMMessageSleepWakeUUIDSet                    ((void *)1)

/* kIOPMMessageSleepWakeUUIDCleared
 * Argument accompanying the kIOPMMessageSleepWakeUUIDChange notification when 
 * the current UUID has been removed.
 */
#define kIOPMMessageSleepWakeUUIDCleared                ((void *)0)

/*! kIOPMMessageDriverAssertionsChanged
 *  Sent when kernel PM driver assertions have changed.
 */
#define kIOPMMessageDriverAssertionsChanged  \
                iokit_family_msg(sub_iokit_powermanagement, 0x150)

/*! kIOPMMessageDarkWakeThermalEmergency
 * Sent when machine becomes unsustainably warm in DarkWake.
 * Kernel PM might choose to put the machine back to sleep right after.
 */
#define kIOPMMessageDarkWakeThermalEmergency \
                iokit_family_msg(sub_iokit_powermanagement, 0x160)

/*******************************************************************************
 *
 * Power commands issued to root domain
 * Use with IOPMrootDomain::receivePowerNotification()
 *
 * These commands are issued from system drivers only:
 *      ApplePMU, AppleSMU, IOGraphics, AppleACPIFamily
 *
 * TODO: deprecate kIOPMAllowSleep and kIOPMPreventSleep
 ******************************************************************************/
enum {
  kIOPMSleepNow                 = (1<<0),  // put machine to sleep now
  kIOPMAllowSleep               = (1<<1),  // allow idle sleep
  kIOPMPreventSleep             = (1<<2),  // do not allow idle sleep
  kIOPMPowerButton              = (1<<3),  // power button was pressed
  kIOPMClamshellClosed          = (1<<4),  // clamshell was closed
  kIOPMPowerEmergency           = (1<<5),  // battery dangerously low
  kIOPMDisableClamshell         = (1<<6),  // do not sleep on clamshell closure
  kIOPMEnableClamshell          = (1<<7),  // sleep on clamshell closure
  kIOPMProcessorSpeedChange     = (1<<8),  // change the processor speed
  kIOPMOverTemp                 = (1<<9),  // system dangerously hot
  kIOPMClamshellOpened          = (1<<10), // clamshell was opened
  kIOPMDWOverTemp               = (1<<11)  // DarkWake thermal limits exceeded.
};


/*******************************************************************************
 *
 * Power Management Return Codes
 *
 ******************************************************************************/
enum {
    kIOPMNoErr                  = 0,

    // Returned by driver's setPowerState(), powerStateWillChangeTo(),
    // powerStateDidChangeTo(), or acknowledgeSetPowerState() to
    // implicitly acknowledge power change upon function return.
    kIOPMAckImplied             = 0,

    // Deprecated
    kIOPMWillAckLater           = 1,

    // Returned by requestPowerDomainState() to indicate
    // unrecognized specification parameter.
    kIOPMBadSpecification       = 4,

    // Returned by requestPowerDomainState() to indicate
    // no power state matches search specification.
    kIOPMNoSuchState            = 5,

    // Deprecated
    kIOPMCannotRaisePower       = 6,

    // Deprecated
    kIOPMParameterError         = 7,

    // Returned when power management state is accessed
    // before driver has called PMinit().
    kIOPMNotYetInitialized      = 8,

    // And the old constants; deprecated
    IOPMNoErr = kIOPMNoErr,
    IOPMAckImplied = kIOPMAckImplied, 
    IOPMWillAckLater = kIOPMWillAckLater,
    IOPMBadSpecification = kIOPMBadSpecification,
    IOPMNoSuchState = kIOPMNoSuchState,
    IOPMCannotRaisePower = kIOPMCannotRaisePower,
    IOPMParameterError = kIOPMParameterError,
    IOPMNotYetInitialized = kIOPMNotYetInitialized
};


// IOPMPowerSource class descriptive strings
// Power Source state is published as properties to the IORegistry under these 
// keys.
#define kIOPMPSExternalConnectedKey                 "ExternalConnected"
#define kIOPMPSExternalChargeCapableKey             "ExternalChargeCapable"
#define kIOPMPSBatteryInstalledKey                  "BatteryInstalled"
#define kIOPMPSIsChargingKey                        "IsCharging"
#define kIOPMFullyChargedKey                        "FullyCharged"
#define kIOPMPSAtWarnLevelKey                       "AtWarnLevel"
#define kIOPMPSAtCriticalLevelKey                   "AtCriticalLevel"
#define kIOPMPSCurrentCapacityKey                   "CurrentCapacity"
#define kIOPMPSMaxCapacityKey                       "MaxCapacity"
#define kIOPMPSDesignCapacityKey                    "DesignCapacity"
#define kIOPMPSTimeRemainingKey                     "TimeRemaining"
#define kIOPMPSAmperageKey                          "Amperage"
#define kIOPMPSVoltageKey                           "Voltage"
#define kIOPMPSCycleCountKey                        "CycleCount"
#define kIOPMPSMaxErrKey                            "MaxErr"
#define kIOPMPSAdapterInfoKey                       "AdapterInfo"
#define kIOPMPSLocationKey                          "Location"
#define kIOPMPSErrorConditionKey                    "ErrorCondition"
#define kIOPMPSManufacturerKey                      "Manufacturer"
#define kIOPMPSManufactureDateKey                   "ManufactureDate"
#define kIOPMPSModelKey                             "Model"
#define kIOPMPSSerialKey                            "Serial"
#define kIOPMDeviceNameKey                          "DeviceName"
#define kIOPMPSLegacyBatteryInfoKey                 "LegacyBatteryInfo"
#define kIOPMPSBatteryHealthKey                     "BatteryHealth"
#define kIOPMPSHealthConfidenceKey                  "HealthConfidence"
#define kIOPMPSCapacityEstimatedKey	                "CapacityEstimated"
#define kIOPMPSBatteryChargeStatusKey               "ChargeStatus"
#define kIOPMPSBatteryTemperatureKey                "Temperature"
#define kIOPMPSAdapterDetailsKey		    "AdapterDetails"
#define kIOPMPSChargerConfigurationKey		    "ChargerConfiguration"

// kIOPMPSBatteryChargeStatusKey may have one of the following values, or may have
// no value. If kIOPMBatteryChargeStatusKey has a NULL value (or no value) associated with it
// then charge is proceeding normally. If one of these battery charge status reasons is listed,
// then the charge may have been interrupted.
#define kIOPMBatteryChargeStatusTooHot              "HighTemperature"
#define kIOPMBatteryChargeStatusTooCold             "LowTemperature"
#define kIOPMBatteryChargeStatusTooHotOrCold	    "HighOrLowTemperature"
#define kIOPMBatteryChargeStatusGradient            "BatteryTemperatureGradient"

// Definitions for battery location, in case of multiple batteries.
// A location of 0 is unspecified
// Location is undefined for single battery systems
enum {
    kIOPMPSLocationLeft = 1001,
    kIOPMPSLocationRight = 1002
};

// Battery quality health types, specified by BatteryHealth and HealthConfidence
// properties in an IOPMPowerSource battery kext.
enum {
    kIOPMUndefinedValue = 0,
    kIOPMPoorValue      = 1,
    kIOPMFairValue      = 2,
    kIOPMGoodValue      = 3
};

// Keys for kIOPMPSAdapterDetailsKey dictionary
#define kIOPMPSAdapterDetailsIDKey		    "AdapterID"
#define kIOPMPSAdapterDetailsWattsKey		    "Watts"
#define kIOPMPSAdapterDetailsRevisionKey	    "AdapterRevision"
#define kIOPMPSAdapterDetailsSerialNumberKey	    "SerialNumber"
#define kIOPMPSAdapterDetailsFamilyKey		    "FamilyCode"
#define kIOPMPSAdapterDetailsAmperageKey	    "Amperage"
#define kIOPMPSAdapterDetailsDescriptionKey	    "Description"
#define kIOPMPSAdapterDetailsPMUConfigurationKey    "PMUConfiguration"

// Battery's time remaining estimate is invalid this long (seconds) after a wake
#define kIOPMPSInvalidWakeSecondsKey           "BatteryInvalidWakeSeconds"

// Battery must wait this long (seconds) after being completely charged before
// the battery is settled.
#define kIOPMPSPostChargeWaitSecondsKey        "PostChargeWaitSeconds"

// Battery must wait this long (seconds) after being completely discharged 
// before the battery is settled.
#define kIOPMPSPostDishargeWaitSecondsKey      "PostDischargeWaitSeconds"


/* CPU Power Management status keys
 * Pass as arguments to IOPMrootDomain::systemPowerEventOccurred
 * Or as arguments to IOPMSystemPowerEventOccurred()
 * Or to decode the dictionary obtained from IOPMCopyCPUPowerStatus()
 * These keys reflect restrictions placed on the CPU by the system
 * to bring the CPU's power consumption within allowable thermal and 
 * power constraints.
 */


/* kIOPMGraphicsPowerLimitsKey
 *   The key representing the dictionary of graphics power limits.
 *   The dictionary contains the other kIOPMCPUPower keys & their associated
 *   values (e.g. Speed limit, Processor Count, and Schedule limits).
 */
#define kIOPMGraphicsPowerLimitsKey                     "Graphics_Power_Limits"

/* kIOPMGraphicsPowerLimitPerformanceKey
 *   The key representing the percent of overall performance made available
 *   by the graphics chip as a percentage (integer 0 - 100).
 */
#define kIOPMGraphicsPowerLimitPerformanceKey           "Graphics_Power_Performance"



/* kIOPMCPUPowerLimitsKey
 *   The key representing the dictionary of CPU Power Limits.
 *   The dictionary contains the other kIOPMCPUPower keys & their associated
 *   values (e.g. Speed limit, Processor Count, and Schedule limits).
 */
#define kIOPMCPUPowerLimitsKey                          "CPU_Power_Limits"

/* kIOPMCPUPowerLimitProcessorSpeedKey defines the speed & voltage limits placed 
 *   on the CPU.
 *   Represented as a percentage (0-100) of maximum CPU speed.
 */
#define kIOPMCPUPowerLimitProcessorSpeedKey             "CPU_Speed_Limit"

/* kIOPMCPUPowerLimitProcessorCountKey reflects how many, if any, CPUs have been
 *   taken offline. Represented as an integer number of CPUs (0 - Max CPUs).
 */
#define kIOPMCPUPowerLimitProcessorCountKey             "CPU_Available_CPUs"

/* kIOPMCPUPowerLimitSchedulerTimeKey represents the percentage (0-100) of CPU time 
 *   available. 100% at normal operation. The OS may limit this time for a percentage
 *   less than 100%.
 */
#define kIOPMCPUPowerLimitSchedulerTimeKey              "CPU_Scheduler_Limit"


/* Thermal Level Warning Key
 * Indicates the thermal constraints placed on the system. This value may 
 * cause clients to action to consume fewer system resources.
 * The value associated with this warning is defined by the platform.
 */
#define kIOPMThermalLevelWarningKey                     "Thermal_Level_Warning"

/* Thermal Warning Level values
 *      kIOPMThermalLevelNormal   - under normal operating conditions
 *      kIOPMThermalLevelDanger   - thermal pressure may cause system slowdown
 *      kIOPMThermalLevelCritical - thermal conditions may cause imminent shutdown
 *
 * The platform may define additional thermal levels if necessary.
 * Platform specific values are defined from 100 and above
 */
enum {
  kIOPMThermalLevelNormal    = 0,
  kIOPMThermalLevelDanger    = 5,
  kIOPMThermalLevelCritical  = 10,

  kIOPMThermalLevelWarning = 100,
  kIOPMThermalLevelTrap    = 110,

  kIOPMThermalLevelUnknown = 255,
};

#define kIOPMThermalWarningLevelNormal kIOPMThermalLevelNormal
#define kIOPMThermalWarningLevelDanger kIOPMThermalLevelWarning
#define kIOPMThermalWarningLevelCrisis kIOPMThermalLevelCritical

// PM Settings Controller setting types
// Settings types used primarily with:
//      IOPMrootDomain::registerPMSettingController
// The values are identical to the similarly named keys for use in user space
// PM settings work. Those keys are defined in IOPMLibPrivate.h.
#define kIOPMSettingWakeOnRingKey                   "Wake On Modem Ring"
#define kIOPMSettingRestartOnPowerLossKey           "Automatic Restart On Power Loss"
#define kIOPMSettingWakeOnACChangeKey               "Wake On AC Change"
#define kIOPMSettingSleepOnPowerButtonKey           "Sleep On Power Button"
#define kIOPMSettingWakeOnClamshellKey              "Wake On Clamshell Open"
#define kIOPMSettingReduceBrightnessKey             "ReduceBrightness"
#define kIOPMSettingDisplaySleepUsesDimKey          "Display Sleep Uses Dim"
#define kIOPMSettingTimeZoneOffsetKey               "TimeZoneOffsetSeconds"
#define kIOPMSettingMobileMotionModuleKey           "MobileMotionModule"
#define kIOPMSettingGraphicsSwitchKey               "GPUSwitch"

// Setting controlling drivers can register to receive scheduled wake data
// Either in "CF seconds" type, or structured calendar data in a formatted
// IOPMCalendarStruct defined below.
#define kIOPMSettingAutoWakeSecondsKey              "wake"
#define kIOPMSettingAutoWakeCalendarKey             "WakeByCalendarDate"
#define kIOPMSettingAutoPowerSecondsKey             "poweron"
#define kIOPMSettingAutoPowerCalendarKey            "PowerByCalendarDate"

// Debug seconds auto wake
// Used by sleep cycling debug tools
#define kIOPMSettingDebugWakeRelativeKey            "WakeRelativeToSleep"
#define kIOPMSettingDebugPowerRelativeKey           "PowerRelativeToShutdown"

// Maintenance wake calendar.
#define kIOPMSettingMaintenanceWakeCalendarKey      "MaintenanceWakeCalendarDate"


struct IOPMCalendarStruct {
    UInt32      year;
    UInt8       month;
    UInt8       day;
    UInt8       hour;
    UInt8       minute;
    UInt8       second;
    UInt8       selector;
};
typedef struct IOPMCalendarStruct IOPMCalendarStruct;

// SetAggressiveness types
enum {
    kPMGeneralAggressiveness = 0,
    kPMMinutesToDim,
    kPMMinutesToSpinDown,
    kPMMinutesToSleep,
    kPMEthernetWakeOnLANSettings,
    kPMSetProcessorSpeed,
    kPMPowerSource,
    kPMMotionSensor,
    kPMLastAggressivenessType
};
#define kMaxType (kPMLastAggressivenessType-1)

// SetAggressiveness values for the kPMPowerSource aggressiveness type
enum {
    kIOPMInternalPower = 1,
    kIOPMExternalPower
};

#define kIOREMSleepEnabledKey               "REMSleepEnabled"

// Strings for deciphering the dictionary returned from IOPMCopyBatteryInfo
#define kIOBatteryInfoKey                   "IOBatteryInfo"
#define kIOBatteryCurrentChargeKey          "Current"
#define kIOBatteryCapacityKey               "Capacity"
#define kIOBatteryFlagsKey                  "Flags"
#define kIOBatteryVoltageKey                "Voltage"
#define kIOBatteryAmperageKey               "Amperage"
#define kIOBatteryCycleCountKey             "Cycle Count"

enum {
    kIOBatteryInstalled         = (1 << 2),
    kIOBatteryCharge            = (1 << 1),
    kIOBatteryChargerConnect    = (1 << 0)
};

// Private power management message indicating battery data has changed
// Indicates new data resides in the IORegistry
#define kIOPMMessageBatteryStatusHasChanged         iokit_family_msg(sub_iokit_pmu, 0x100)

// Apple private Legacy messages for re-routing AutoWake and AutoPower messages to the PMU
// through newer user space IOPMSchedulePowerEvent API
#define kIOPMUMessageLegacyAutoWake                 iokit_family_msg(sub_iokit_pmu, 0x200)
#define kIOPMUMessageLegacyAutoPower                iokit_family_msg(sub_iokit_pmu, 0x210)

// For use with IOPMPowerSource bFlags
#define IOPM_POWER_SOURCE_REV   2
enum {
  kIOPMACInstalled      = kIOBatteryChargerConnect,
  kIOPMBatteryCharging  = kIOBatteryCharge,
  kIOPMBatteryInstalled = kIOBatteryInstalled,
  kIOPMUPSInstalled     = (1<<3),
  kIOPMBatteryAtWarn    = (1<<4),
  kIOPMBatteryDepleted  = (1<<5),
  kIOPMACnoChargeCapability = (1<<6),     // AC adapter cannot charge battery
  kIOPMRawLowBattery    = (1<<7),         // used only by  Platform Expert
  kIOPMForceLowSpeed    = (1<<8),         // set by Platfm Expert, chk'd by Pwr Plugin
  kIOPMClosedClamshell  = (1<<9),         // set by PMU - reflects state of the clamshell
  kIOPMClamshellStateOnWake = (1<<10)     // used only by Platform Expert
};

// **********************************************
// Internal power management data structures
// **********************************************

struct IOPowerStateChangeNotification {
    void *        powerRef;
    unsigned long    returnValue;
    unsigned long    stateNumber;
    IOPMPowerFlags    stateFlags;
};
typedef struct IOPowerStateChangeNotification IOPowerStateChangeNotification;
typedef IOPowerStateChangeNotification sleepWakeNote;

/*! @struct IOPMSystemCapabilityChangeParameters
    @abstract A structure describing a system capability change.
    @discussion A system capability change is a system level transition from a set
        of system capabilities to a new set of system capabilities. Power management
        sends a <code>kIOMessageSystemCapabilityChange</code> message and provides
        this structure as the message data (by reference) to
        <code>gIOPriorityPowerStateInterest</code> clients when system capability
        changes.
    @field notifyRef An identifier for this message notification. Clients with pending
        I/O can signal completion by calling <code>allowPowerChange()</code> with this
        value as the argument. Clients that are able to process the notification
        synchronously should ignore this field.
    @field maxWaitForReply A return value to the caller indicating the maximum time in
        microseconds to wait for the <code>allowPowerChange()</code> call. The default
        value is zero, which indicates the client processing has finished, and power
        management should not wait for an <code>allowPowerChange()</code> call.
    @field changeFlags Flags will be set to indicate whether the notification precedes
        the capability change (<code>kIOPMSystemCapabilityWillChange</code>), or after
        the capability change has occurred (<code>kIOPMSystemCapabilityDidChange</code>).
    @field __reserved1 Set to zero.
    @field fromCapabilities The system capabilities at the start of the transition.
    @field toCapabilities The system capabilities at the end of the transition.
    @field __reserved2 Set to zero.
 */
struct IOPMSystemCapabilityChangeParameters {
    uint32_t    notifyRef;
    uint32_t    maxWaitForReply;
    uint32_t    changeFlags;
    uint32_t    __reserved1;
    uint32_t    fromCapabilities;
    uint32_t    toCapabilities;
    uint32_t    __reserved2[4];
};

/*! @enum IOPMSystemCapabilityChangeFlags
    @constant kIOPMSystemCapabilityWillChange Indicates the system capability will change.
    @constant kIOPMSystemCapabilityDidChange Indicates the system capability has changed.
*/
enum {
    kIOPMSystemCapabilityWillChange = 0x01,
    kIOPMSystemCapabilityDidChange  = 0x02
};

enum {
    kIOPMSystemCapabilityCPU        = 0x01,
    kIOPMSystemCapabilityGraphics   = 0x02,
    kIOPMSystemCapabilityAudio      = 0x04,
    kIOPMSystemCapabilityNetwork    = 0x08
};

#endif /* ! _IOKIT_IOPM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                               IOPMKeys.h                                                                                          0100644 0001750 0001750 00000006416 12566177313 034045  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/pwr_mgt                                                               /*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
    @header IOPMKeys.h
    
    IOPMKeys.h defines C strings for use accessing power management data.
    Note that all of these C strings must be converted to CFStrings before use. You can wrap
    them with the CFSTR() macro, or create a CFStringRef (that you must later CFRelease()) using CFStringCreateWithCString()
 */
 
#ifndef _IOPMKEYS_H_
#define _IOPMKEYS_H_
 
/*
 * Types of power event
 * These are potential arguments to IOPMSchedulePowerEvent().
 * These are all potential values of the kIOPMPowerEventTypeKey in the CFDictionaries
 * returned by IOPMCopyScheduledPowerEvents().
 */
/*!
    @define kIOPMAutoWake 
    @abstract Value for scheduled wake from sleep.
*/
#define kIOPMAutoWake                                   "wake"

/*!
    @define kIOPMAutoPowerOn 
    @abstract Value for scheduled power on from off state.
*/
#define kIOPMAutoPowerOn                                "poweron"

/*!
    @define kIOPMAutoWakeOrPowerOn 
    @abstract Value for scheduled wake from sleep, or power on. The system will either wake OR
        power on, whichever is necessary.
*/

#define kIOPMAutoWakeOrPowerOn                          "wakepoweron"
/*!
    @define kIOPMAutoSleep
    @abstract Value for scheduled sleep.
*/

#define kIOPMAutoSleep                                   "sleep"
/*!
    @define kIOPMAutoShutdown 
    @abstract Value for scheduled shutdown.
*/

#define kIOPMAutoShutdown                               "shutdown"
/*!
    @define kIOPMAutoRestart 
    @abstract Value for scheduled restart.
*/

#define kIOPMAutoRestart                                "restart"

/*
 * Keys for evaluating the CFDictionaries returned by IOPMCopyScheduledPowerEvents()
 */
/*!
    @define kIOPMPowerEventTimeKey 
    @abstract Key for the time of the scheduled power event. Value is a CFDateRef.
*/
#define kIOPMPowerEventTimeKey                          "time"

/*!
    @define kIOPMPowerEventAppNameKey 
    @abstract Key for the CFBundleIdentifier of the app that scheduled the power event. Value is a CFStringRef.
*/
#define kIOPMPowerEventAppNameKey                       "scheduledby"

/*!
    @define kIOPMPowerEventTypeKey 
    @abstract Key for the type of power event. Value is a CFStringRef, with the c-string value of one of the "kIOPMAuto" strings.
*/
#define kIOPMPowerEventTypeKey                          "eventtype"

#endif
                                                                                                                                                                                                                                                  IOPMLib.h                                                                                           0100644 0001750 0001750 00000177017 12566177313 033646  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/pwr_mgt                                                               /*
 * Copyright (c) 1998-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#include <CoreFoundation/CFArray.h>
#include <IOKit/IOKitLib.h>
#include <IOKit/pwr_mgt/IOPMLibDefs.h>
#include <IOKit/pwr_mgt/IOPMKeys.h>
#include <Availability.h>

#ifndef _IOKIT_PWRMGT_IOPMLIB_
#define _IOKIT_PWRMGT_IOPMLIB_

#ifdef __cplusplus
extern "C" {
#endif

/*!
@header IOPMLib.h
    IOPMLib provides access to common power management facilities, like initiating 
    system sleep, getting current idle timer values, registering for sleep/wake notifications, 
    and preventing system sleep.
*/

/*! @function IOPMFindPowerManagement
    @abstract Finds the Root Power Domain IOService.
    @param master_device_port  Just pass in MACH_PORT_NULL for master device port.
    @result Returns a io_connect_t handle on the root domain. Must be released with IOServiceClose() when done.
 */
io_connect_t IOPMFindPowerManagement( mach_port_t master_device_port )
                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
    
/*! @function IOPMSetAggressiveness
    @abstract Sets one of the aggressiveness factors in IOKit Power Management.
    @param fb  Representation of the Root Power Domain from IOPMFindPowerManagement.
    @param type Specifies which aggressiveness factor is being set.
    @param aggressiveness New value of the aggressiveness factor.
    @result Returns kIOReturnSuccess or an error condition if request failed.
*/
IOReturn IOPMSetAggressiveness (io_connect_t fb, unsigned long type, unsigned long aggressiveness )
                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
                            
/*! @function IOPMGetAggressiveness
    @abstract Retrieves the current value of one of the aggressiveness factors in IOKit Power Management.
    @param fb  Representation of the Root Power Domain from IOPMFindPowerManagement.
    @param type Specifies which aggressiveness factor is being retrieved.
    @param aggressiveness Points to where to store the retrieved value of the aggressiveness factor.
    @result Returns kIOReturnSuccess or an error condition if request failed. 
 */
IOReturn IOPMGetAggressiveness ( io_connect_t fb, unsigned long type, unsigned long * aggressiveness )
                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;

/*! @function IOPMSleepEnabled
    @abstract Tells whether the system supports full sleep, or just doze
    @result Returns true if the system supports sleep, false if some hardware prevents full sleep.
 */
boolean_t IOPMSleepEnabled ( void ) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;

/*! @function IOPMSleepSystem
    @abstract Request that the system initiate sleep.
    @discussion For security purposes, caller must be root or the console user.
    @param fb  Port used to communicate to the kernel,  from IOPMFindPowerManagement.
    @result Returns kIOReturnSuccess or an error condition if request failed.
 */
IOReturn IOPMSleepSystem ( io_connect_t fb ) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;

/*! @function IOPMCopyBatteryInfo
     @abstract Request battery data from the system.
     @discussion This API is supported, but not recommended. Developers should prefer to use
     the IOPowerSources API. IOPowerSources provides more battery data, and notifications
     when battery state changes)
     @param masterPort The master port obtained from IOMasterPort(). Just pass MACH_PORT_NULL.
     @param info A CFArray of CFDictionaries containing raw battery data. Use these keys, defined in IOPM.h
            to read from the dictionary:
         <pre>
         <code>@link kIOBatteryInfoKey @/link</code>
         <code>@link kIOBatteryCurrentChargeKey @/link</code>
         <code>@link kIOBatteryCapacityKey @/link</code>
         <code>@link kIOBatteryFlagsKey @/link</code>
         <code>@link kIOBatteryVoltageKey @/link</code>
         <code>@link kIOBatteryAmperageKey @/link</code>
         <code>@link kIOBatteryCycleCountKey @/link</code>
         </pre>
     @result Returns kIOReturnSuccess or an error condition if request failed.
 */
IOReturn IOPMCopyBatteryInfo( mach_port_t masterPort, CFArrayRef * info )
                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*!
    @functiongroup Notifications
*/    


/*! @function IORegisterApp
    @abstract DEPRECATED - An obsolete method for interacting with driver power state changes.
    @discussion This function is obsolete and deprecated. To receive notifications of driver power state changes,
        			Please use IOServiceAddInterestNotification with interest type gIOGeneralInterest instead.
 */
io_connect_t IORegisterApp( void * refcon,
                            io_service_t theDriver,
                            IONotificationPortRef * thePortRef,
                            IOServiceInterestCallback callback,
                            io_object_t * notifier )
                            __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA);
    
/*! @function       IORegisterForSystemPower
    @abstract       Connects the caller to the Root Power Domain IOService for the purpose of receiving sleep & wake notifications for the system.
				    Does not provide system shutdown and restart notifications.
    @discussion     Provides sleep/wake notifications to applications. Requires that applications acknowledge
                    some, but not all notifications. Register for sleep/wake notifications will deliver these messages
                    over the sleep/wake lifecycle:
            <ul>
            <li>kIOMessageSystemWillSleep is delivered at the point the system is initiating a 
                non-abortable sleep.
                Callers MUST acknowledge this event by calling @link IOAllowPowerChange @/link.
                If a caller does not acknowledge the sleep notification, the sleep will continue anyway after
                a 30 second timeout (resulting in bad user experience). 
                Delivered before any hardware is powered off.

            <li>kIOMessageSystemWillPowerOn is delivered at early wakeup time, before most hardware has been
                powered on. Be aware that any attempts to access disk, network, the display, etc. may result
                in errors or blocking your process until those resources become available.
                Caller must NOT acknowledge kIOMessageSystemWillPowerOn; the caller must simply return from its handler.
            
            <li>kIOMessageSystemHasPoweredOn is delivered at wakeup completion time, after all device drivers and
                hardware have handled the wakeup event. Expect this event 1-5 or more seconds after initiating
                system wakeup.
                Caller must NOT acknowledge kIOMessageSystemHasPoweredOn; the caller must simply return from its handler.

            <li>kIOMessageCanSystemSleep indicates the system is pondering an idle sleep, but gives apps the
                chance to veto that sleep attempt. 
                Caller must acknowledge kIOMessageCanSystemSleep by calling @link IOAllowPowerChange @/link
                or @link IOCancelPowerChange @/link. Calling IOAllowPowerChange will not veto the sleep; any
                app that calls IOCancelPowerChange will veto the idle sleep. A kIOMessageCanSystemSleep 
                notification will be followed up to 30 seconds later by a kIOMessageSystemWillSleep message.
                or a kIOMessageSystemWillNotSleep message.

            <li>kIOMessageSystemWillNotSleep is delivered when some app client has vetoed an idle sleep
                request. kIOMessageSystemWillNotSleep may follow a kIOMessageCanSystemSleep notification,
                but will not otherwise be sent.
                Caller must NOT acknowledge kIOMessageSystemWillNotSleep; the caller must simply return from its handler.
            </ul>
        To deregister for sleep/wake notifications, the caller must make two calls, in this order:
            <ol><li> Call IODeregisterForSystemPower with the 'notifier' argument returned here.
            <li> Then call IONotificationPortDestroy passing the 'thePortRef' argument
                returned here.
            </ol>  
    @param refcon       Caller may provide data to receive as an argument to 'callback' on power state changes.
    @param thePortRef   On return, thePortRef is a pointer to an IONotificationPortRef, which will deliver the power notifications. 
                        The port is allocated by this function and must be later released by the caller (after calling <code>@link IODeregisterForSystemPower @/link</code>). 
                        The caller should also enable IONotificationPortRef by calling <code>@link IONotificationPortGetRunLoopSource @/link</code>, or 
                        <code>@link IONotificationPortGetMachPort @/link</code>, or <code>@link IONotificationPortSetDispatchQueue @/link</code>.
    @param callback     A c-function which is called during the notification.
    @param notifier     On success, returns a pointer to a unique notifier which caller must keep and pass to a subsequent call to IODeregisterForSystemPower.
    @result             Returns a io_connect_t session for the IOPMrootDomain or IO_OBJECT_NULL if request failed.
                        Caller must close return value via IOServiceClose() after calling IODeregisterForSystemPower on the notifier argument.
 */
io_connect_t IORegisterForSystemPower ( void * refcon,
                                        IONotificationPortRef * thePortRef,
                                        IOServiceInterestCallback callback,
                                        io_object_t * notifier )
                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;                                        
/*! @function           IODeregisterApp
    @abstract           Disconnects the caller from an IOService after receiving power state change notifications from the IOService. (Caller must also release IORegisterApp's return io_connect_t and returned IONotificationPortRef for complete clean-up).
    @param notifier     An object from IORegisterApp.
    @result             Returns kIOReturnSuccess or an error condition if request failed.
 */
IOReturn IODeregisterApp ( io_object_t * notifier ) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;

/*! @function           IODeregisterForSystemPower
    @abstract           Disconnects the caller from the Root Power Domain IOService after receiving system power state change notifications. (Caller must also destroy the IONotificationPortRef returned from IORegisterForSystemPower.)
    @param notifier     The object returned from IORegisterForSystemPower.
    @result             Returns kIOReturnSuccess or an error condition if request failed.
*/
IOReturn IODeregisterForSystemPower ( io_object_t * notifier )
                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;
                            
/*! @function           IOAllowPowerChange
    @abstract           The caller acknowledges notification of a power state change on a device it has registered for notifications for via IORegisterForSystemPower or IORegisterApp.
    @discussion         Must be used when handling kIOMessageCanSystemSleep and kIOMessageSystemWillSleep messages from IOPMrootDomain system power. The caller should not call IOAllowPowerChange in response to any messages 
                        except for these two.
    @param kernelPort   Port used to communicate to the kernel,  from IORegisterApp or IORegisterForSystemPower.
    @param notificationID A copy of the notification ID which came as part of the power state change notification being acknowledged.
    @result             Returns kIOReturnSuccess or an error condition if request failed.
*/
IOReturn IOAllowPowerChange ( io_connect_t kernelPort, long notificationID )
                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;

/*! @function IOCancelPowerChange
    @abstract The caller denies an idle system sleep power state change.
    @discussion Should only called in response to kIOMessageCanSystemSleep messages from IOPMrootDomain. IOCancelPowerChange has no meaning for responding to kIOMessageSystemWillSleep (which is non-abortable) or any other messages. 
    
    When an app responds to a kIOMessageCanSystemSleep message by calling IOCancelPowerChange, the app
    vetoes the idle sleep request. The system will stay awake. 
    The idle timer will elapse again after a period of inactivity, and the system will
    send out the same kIOMessageCanSystemSleep message, and interested applications will respond gain.
 
    @param kernelPort  Port used to communicate to the kernel,  from IORegisterApp or IORegisterForSystemPower.
    @param notificationID A copy of the notification ID which came as part of the power state change notification being acknowledged.
    @result Returns kIOReturnSuccess or an error condition if request failed.
 */
IOReturn IOCancelPowerChange ( io_connect_t kernelPort, long notificationID )
                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;

/*!
    @functiongroup ScheduledEvents
*/    

/*! @function IOPMSchedulePowerEvent
    @abstract Schedule the machine to wake from sleep, power on, go to sleep, or shutdown. 
    @discussion This event will be added to the system's queue of power events and stored persistently on disk. The sleep and shutdown events present a graphical warning and allow a console user to cancel the event. Must be called as root.
    @param time_to_wake Date and time that the system will power on/off.
    @param my_id A CFStringRef identifying the calling app by CFBundleIdentifier. May be NULL.
    @param type The type of power on you desire, either wake from sleep or power on. Choose from:
        <ul>
                <li>CFSTR(<code>kIOPMAutoWake</code>) == wake machine, 
                <li>CFSTR(<code>kIOPMAutoPowerOn</code>) == power on machine, 
                <li>CFSTR(<code>kIOPMAutoWakeOrPowerOn</code>) == wake or power on,
                <li>CFSTR(<code>kIOPMAutoSleep</code>) == sleep machine, 
                <li>CFSTR(<code>kIOPMAutoShutdown</code>) == power off machine,
                <li>CFSTR(<code>kIOPMAutoRestart</code>) == restart the machine.
        </ul>
    @result kIOReturnSuccess on success, otherwise on failure
*/
IOReturn IOPMSchedulePowerEvent(CFDateRef time_to_wake, CFStringRef my_id, CFStringRef type);

/*! @function IOPMCancelScheduledPowerEvent
    @abstract Cancel a previously scheduled power event.
    @discussion Arguments mirror those to IOPMSchedulePowerEvent. All arguments must match the original arguments from when the power on was scheduled. Must be called as root.
    @param time_to_wake Cancel entry with this date and time.
    @param my_id Cancel entry with this name.
    @param type Type to cancel
    @result kIOReturnSuccess on success, otherwise on failure
*/
IOReturn IOPMCancelScheduledPowerEvent(CFDateRef time_to_wake, CFStringRef my_id, CFStringRef type);

/*! @function IOPMCopyScheduledPowerEvents
    @abstract List all scheduled system power events
    @discussion Returns a CFArray of CFDictionaries of power events. Each CFDictionary  contains keys for CFSTR(kIOPMPowerEventTimeKey), CFSTR(kIOPMPowerEventAppNameKey), and CFSTR(kIOPMPowerEventTypeKey).
    @result A CFArray of CFDictionaries of power events. The CFArray must be released by the caller. NULL if there are no scheduled events.
*/
CFArrayRef IOPMCopyScheduledPowerEvents(void); 

    
#pragma mark IOKit Power Assertions
/*!
 *
 * @functiongroup   IOPMAssertions
 *
 */
    
        
/*!
 * @define          kIOPMAssertPreventUserIdleSystemSleep
 *
 * @abstract        Prevents the system from sleeping automatically due to a lack of user activity.
 *
 * @discussion      When asserted and set to level <code>@link kIOPMAssertionLevelOn@/link</code>,
 *                  will prevent the system from sleeping due to a period of idle user activity.
 *                  Create this assertion with
 *                      <code>@link IOPMAssertionCreateWithName @/link</code>
 *                      or <code>@link IOPMAssertionCreateWithDescription @/link</code>
 *
 *                  The display may dim and idle sleep while <code>kIOPMAssertPreventUserIdleSystemSleep</code> is
 *                  enabled, but the system may not idle sleep. The system may still sleep for lid close, 
 *                  Apple menu, low battery, or other sleep reasons.
 *
 *                  This assertion has no effect if the system is in Dark Wake.
 *
 */
#define kIOPMAssertPreventUserIdleSystemSleep               CFSTR("PreventUserIdleSystemSleep")

/*!
 * @define          kIOPMAssertPreventUserIdleDisplaySleep
 *
 * @abstract        Prevents the display from dimming automatically.
 *
 * @discussion      Create this assertion with
 *                      <code>@link IOPMAssertionCreateWithName @/link</code>
 *                      or <code>@link IOPMAssertionCreateWithDescription @/link</code>.
 * 
 *                  When asserted and set to level <code>@link kIOPMAssertionLevelOn@/link</code>,
 *                  will prevent the display from turning off due to a period of idle user activity.
 *                  Note that the display may still sleep for other reasons, like a user closing a
 *                  portable's lid or the machine sleeping. If the display is already off, this
 *                  assertion does not light up the display. If display needs to be turned on, then
 *                  consider calling function <code>@link IOPMAssertionDeclareUserActivity@/link</code>.
 *
 *                  While the display is prevented from dimming, the system cannot go into idle sleep.
 *
 *                  This assertion has no effect if the system is in Dark Wake.
 */
#define kIOPMAssertPreventUserIdleDisplaySleep              CFSTR("PreventUserIdleDisplaySleep")

/*!
 * @define          kIOPMAssertPreventDiskIdle
 *
 * @abstract        Prevent attached disks from idling into lower power states.
 *
 * @discussion      When asserted and set to level <code>@link kIOPMAssertionLevelOn@/link</code>,
 *                  will prevent attached disks and optical media from idling into lower power states.
 *                  Create this assertion with
 *                      <code>@link IOPMAssertionCreateWithName @/link</code>
 *                      or <code>@link IOPMAssertionCreateWithDescription @/link</code>.
 *
 *                  Apps who rely on real-time access to disks should create this assertion to avoid
 *                  latencies caused by disks changing power states. For example, audio and video performance
 *                  or recording apps may benefit from this assertion. Most Apps should not take this assertion;
 *                  preventing disk idle consumes battery life, and most apps don't require the low latency
 *                  disk access that this provides.
 *
 *                  This assertion doesn't increase a disk's power state (it just prevents that device from idling).
 *                  After creating this assertion, the caller should perform disk I/O on the necessary drives to
 *                  ensure that they're in a usable power state.
 *
 *                  The system may still sleep while this assertion is active.
 *                  Callers should also take <code>@link kIOPMAssertPreventUserIdleSystemSleep@/link</code>
 *                  if necessary, to prevent idle system sleep.
 */
#define kIOPMAssertPreventDiskIdle                          CFSTR("PreventDiskIdle")

/*!
 * @define          kIOPMAssertNetworkClientActive
 *
 * @abstract        Keeps the system awake while OS X serves active network clients.
 *
 * @discussion      When asserted and set to level <code>@link kIOPMAssertionLevelOn@/link</code>,
 *                  will keep the computer awake. Create this assertion with 
 *                      <code>@link IOPMAssertionCreateWithName @/link</code>
 *                      or <code>@link IOPMAssertionCreateWithDescription @/link</code>.
 *
 *                  Instead of taking this assertion, most callers should instead use: 
 *                  <code>@link IOPMDeclareNetworkClientActivity @/link</code>
 *                  it takes the assertion, but with a built-in timeout.
 *
 *                  This assertion keeps the system awake in dark or full wake,
 *                  as long as the system is on AC power. On battery, this assertion can 
 *                  prevent system from going into idle sleep.
 *                  IOKit power assertions are suggestions and OS X may not honor them under
 *                  battery, thermal, or user  circumstances.
 *
 *                  This assertion provides CPU, disk, and network connectivity. 
 *                  If the network is no longer available, this assertion may stop working 
 *                  and allow the system to go to sleep.
 *
 *                  Callers should take this assertion when they have remote clients connected and active.
 *                  Please <code>@link IOPMAssertionRelease @/link></code> this assertion if remote clients become 
 *                  inactive, idle, or disconnected. 
 *                  If your process already manages user timeouts and tracks activity,
 *                  you can take this assertion directly with 
 *                  <code>@link IOPMAssertionCreateWithProperties @/link</code>. 
 *
 *                  IOKit can manage remote client idleness for you if you call 
 *                  <code>@link IOPMDeclareNetworkClientActivity @/link</code> upon every remote access,
 *
 *                  This assertion is a suggestion; Mac OS X may need to sleep the system even if
 *                  this assertion is active.
 */
#define kIOPMAssertNetworkClientActive                             CFSTR("NetworkClientActive")
    

    
/*! @/defineblock   IOPMAssertionDictionary Keys*/

/*!
 * @typedef         IOPMAssertionID
 *
 * @abstract        Type for AssertionID arguments to <code>@link IOPMAssertionCreateWithProperties@/link</code>
 *                  and <code>@link IOPMAssertionRelease@/link</code>
 */
typedef uint32_t IOPMAssertionID;


/*!
 * @enum            kIOPMNullAssertionID
 *
 * @abstract        This value represents a non-initialized assertion ID
 *
 * @constant        kIOPMNullAssertionID
 *                  This value represents a non-initialized assertion ID.
 *
 */
enum {
    kIOPMNullAssertionID = 0
};

/*!
 * @typedef         IOPMAssertionLevel
 *
 * @abstract        Type for AssertionLevel argument to IOPMAssertionCreate
 *
 * @discussion      Possible values for <code>IOPMAssertionLevel</code> are
 *                  <code>@link kIOPMAssertionLevelOff@/link</code>
 *                  and <code>@link kIOPMAssertionLevelOn@/link</code>
 */
typedef uint32_t IOPMAssertionLevel;

/*!
 * @enum            Assertion Levels
 */
enum {
    /*!
     * @constant    kIOPMAssertionLevelOff
     * @abstract    Level for a disabled assertion, passed as an argument to IOPMAssertionCreate.
    */
    kIOPMAssertionLevelOff = 0,

    /*!
     * @constant    kIOPMAssertionLevelOn
     * @abstract    Level for an enabled assertion, passed as an argument to IOPMAssertionCreate.
    */
    kIOPMAssertionLevelOn  = 255
 };


typedef enum {
    kIOPMUserActiveLocal,   /* User is local on the system */
    kIOPMUserActiveRemote   /* Remote User connected to the system */
} IOPMUserActiveType;

    
/*! @function           IOPMAssertionCreateWithDescription
 *
 * @abstract            The preferred API to create a power assertion.
 *
 * @description         Creates an IOPMAssertion. This is the preferred API to call to create an assertion.
 *                      It allows the caller to specify the Name, Details, and HumanReadableReason at creation time.
 *                      There are other keys that can further describe an assertion, but most developers don't need
 *                      to use them. Use <code>@link IOPMAssertionSetProperty @/link</code> or
 *                      <code>@link IOPMAssertionCreateWithProperties @/link</code> if you need to specify properties
 *                      that aren't available here.
 * 
 * @param AssertionType An assertion type constant. 
 *	                    Caller must specify this argument.
 *
 * @param Name          A CFString value to correspond to key <code>@link kIOPMAssertionNameKey@/link</code>.
 *	                    Caller must specify this argument.
 *
 * @param Details 	    A CFString value to correspond to key <code>@link kIOPMAssertionDetailsKey@/link</code>.
 *	                    Caller my pass NULL, but it helps power users and administrators identify the
 *                      reasons for this assertion.
 *
 * @param HumanReadableReason
 *                      A CFString value to correspond to key <code>@link kIOPMAssertionHumanReadableReasonKey@/link</code>.
 *                      Caller may pass NULL, but if it's specified OS X may display it to users 
 *                      to describe the active assertions on their system.
 *
 * @param LocalizationBundlePath
 *	                    A CFString value to correspond to key <code>@link kIOPMAssertionLocalizationBundlePathKey@/link</code>.
 *                      This bundle path should include a localization for the string <code>HumanReadableReason</code>
 *                      Caller may pass NULL, but this argument is required if caller specifies <code>HumanReadableReason</code> 
 *
 * @param Timeout       Specifies a timeout for this assertion. Pass 0 for no timeout.
 *
 * @param TimeoutAction Specifies a timeout action. Caller my pass NULL. If a timeout is specified but a TimeoutAction is not, 
 *                      the default timeout action is <code>kIOPMAssertionTimeoutActionTurnOff</code>
 *
 * @param AssertionID   (Output) On successful return, contains a unique reference to a PM assertion.
 *
 * @result              kIOReturnSuccess, or another IOKit return code on error.
 */
IOReturn	IOPMAssertionCreateWithDescription(
                                           CFStringRef  AssertionType, 
                                           CFStringRef  Name, 
                                           CFStringRef  Details,
                                           CFStringRef  HumanReadableReason,
                                           CFStringRef  LocalizationBundlePath,
                                           CFTimeInterval   Timeout,
                                           CFStringRef  TimeoutAction,
                                           IOPMAssertionID  *AssertionID)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);
    


/*!
 * @function                    IOPMAssertionCreateWithProperties
 *
 * @abstract                    Creates an IOPMAssertion with more flexibility than <code>@link IOPMAssertionCreateWithDescription @/link</code>.
 * @param AssertionProperties   Dictionary providing the properties of the assertion that need to be created.
 * @param AssertionID           (Output) On successful return, contains a unique reference to a PM assertion.
 *
 * @discussion          
 *      Create a new PM assertion - the caller must specify the type of assertion, initial level, and its 
 *      properties as @link IOPMAssertionDictionaryKeys@/link keys in the <code>AssertionProperties</code> dictionary.
 *      The following keys are recommend and/or required to be specified in the AssertionProperties 
 *      dictionary argument.
 *      <ul>
 *          <li> REQUIRED: <code>kIOPMAssertionTypeKey</code> define the assertion type.
 *
 *          <li> REQUIRED: <code>kIOPMAssertionValueKey</code> define an inital value.
 *
 *          <li> REQUIRED: <code>kIOPMAssertionNameKey</code> Caller must describe the name for the activity that
 *               requires the change in behavior provided by the assertion. 
 *
 *          <li> OPTIONAL: <code>kIOPMAssertionDetailsKey</code> Caller may describe context-specific data about the
 *               assertion. 
 *
 *          <li> OPTIONAL: <code>kIOPMAssertionHumanReadableReasonKey</code> Caller may describe the reason for creating the assertion
 *              in a localizable CFString. This should be a human readable phrase that describes the actions the
 *              calling process is taking while the assertion is held, like "Downloading TV episodes", or "Compiling Projects"
 *
 *          <li> OPTIONAL: <code>kIOPMAssertionLocalizationBundlePathKey</code> Caller may provide its bundle's path, where OS X
 *              can localize for GUI display the CFString specified by <code>@link kIOPMAssertionHumanReadableReasonKey@/link</code>.
 *
 *          <li> OPTIONAL: <code>kIOPMAssertionPlugInIDKey</code> if the caller is a plugin with a different identity than the process
 *              it's loaded in.
 *
 *          <li> OPTIONAL: <code>kIOPMAssertionFrameworkIDKey</code> if the caller is a framework acting on behalf of a process.
 *
 *          <li> OPTIONAL: The caller may specify a timeout.
 *      </ul>
 */
IOReturn IOPMAssertionCreateWithProperties(
                             CFDictionaryRef      AssertionProperties,
                             IOPMAssertionID      *AssertionID)
                            __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_3_2);

/*!
 * @function            IOPMAssertionDeclareUserActivity
 *
 * @abstract            Declares that the user is active on the system. 
 *
 * @discussion          This causes the display to power on and postpone display sleep, 
 *                      up to the user's display sleep Energy Saver settings. 
 *
 *                      If you need to hold the display awake for a longer period and you know
 *                      how long you'd like to hold it, consider taking assertion 
 *                      <code>@link kIOPMAssertPreventUserIdleDisplaySleep @/link</code> using
 *                      <code>@link IOPMAssertionCreateWithDescription @/link</code> API instead.
 *
 *                      No special privileges are necessary to make this call - any process may
 *                      call this API. Caller must specify an AssertionName - NULL is not
 *                      a valid input.
 *
 * @param AssertionName     A string that describes the name of the caller and the activity being
 *                          handled by this assertion (e.g. "Mail Compacting Mailboxes"). Name may be no longer
 *                          than 128 characters.
 *
 * @param   userType        This parameter specifies if the active user is located locally in front of the
 *                          system or connected to the system over the network. Various components of the system
 *                          are maintained at different power levels depending on user location.
 *
 * @param AssertionID       On Success, unique id will be returned in this parameter. Caller
 *                          may call this function again with the unique id retured previously to report continous
 *                          user activity. The unique id returned by this function may change on each call depending
 *                          on how frequently this function call is repeated and the current display sleep timer value.
 *                          If you make this call more than once, track the returned value for
 *                          assertionID, and pass it in as an argument on each call.
 *
 * @result                  Returns kIOReturnSuccess on success, any other return indicates
 *                          PM could not successfully activate the specified assertion.
 */
IOReturn IOPMAssertionDeclareUserActivity(
                                          CFStringRef          AssertionName,
                                          IOPMUserActiveType   userType,
                                          IOPMAssertionID      *AssertionID)
AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER;   /* This API is introduced in 10.7.3 */
    

/*!
 * @function            IOPMDeclareNetworkClientActivity
 *
 * @abstract            A convenience function for handling remote network clients; this is a wrapper for
 *                      holding <code>@link kIOPMAssertNetworkClientActive @/link </code>
 *
 * @discussion          Call this whenever you detect activity from your remote network clients.
 *                      This call generates an IPC call, and may block.
 *
 *                      On the first invocation, this will populate parameter
 *                      <code>AssertionID</code> with a new assertion ID.
 *                      You should pass in this returned assertion ID on every access.
 *                      
 *                      When system is on AC power, every call to <code>IOPMDeclareNetworkClientActivity</code> 
 *                      prevents system from idle sleeping and from demand sleeping for the duration of
 *                      system sleep timer. When system is on Battery power, every call to 
 *                      <code>IOPMDeclareNetworkClientActivity</code> prevents system from idle sleeping for the 
 *                      duration of system sleep timer.
 *
 *                      Assertion created by this interface is valid only for the duration of system sleep timer
 *                      from the last call. IOKit will disable <code>AssertionID</code> after that duration.
 *
 *                      If you detect that your remote client is no longer active, please immediately call
 *                      <code>@link IOPMAssertionRelease@/link</code. Do not wait for the timeout.
 *
 *                      If your process can detect when remote clients are active and idle, you can skip
 *                      this API and directly create <code>@link kIOPMAssertNetworkClientActive @/link</code> yourself.
 *
 *                      If your remote clients require access to the framebuffer or the GPU, then this
 *                      isn't the appropriate call for you. Please see 
 *                      <code>@link IOPMAssertionDeclareUserActivity @/link</code> and pass in argument
 *                      <code>@link kIOPMUserActiveRemote @/link</code>.
 *
 * @param AssertionName     A string that describes the name of the caller and the activity being
 *                          handled by this assertion (e.g. "Serving a podcast"). The name must be less than
 *                          128 characters.
 * *
 * @param AssertionID       On Success, unique id will be returned in this parameter. Caller
 *                          may call this function again with the unique id retured previously to report additional
 *                          user activity. The unique id returned by this function may change on each call depending
 *                          on how frequently this function call is repeated and the current system sleep timer value.
 *                          If you make this call more than once, track the returned value for
 *                          assertionID, and pass it in as an argument on each call.
 *
 * @result                  Returns kIOReturnSuccess on success, any other return indicates
 *                          PM could not successfully activate the specified assertion.
 */
IOReturn IOPMDeclareNetworkClientActivity(
                                          CFStringRef          AssertionName,
                                          IOPMAssertionID      *AssertionID)
    __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

    
/*!
 * @function            IOPMAssertionRetain
 *
 * @abstract            Increments the assertion's retain count.
 * @discussion          Increments the retain count according to CoreFoundation style retain/release semantics.
 *                      Retain count can be inspected in the assertion's info dictionary at
 *                      key <code>@link kIOPMAssertionRetainCountKey@/link</code>
 * @param theAssertion  The assertion ID to retain.
 */    
void IOPMAssertionRetain(IOPMAssertionID theAssertion)
                            __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_3_2);

/*!
 * @function            IOPMAssertionRelease
 *
 * @abstract            Decrements the assertion's retain count.
 *
 * @discussion          If the retain count becomes zero, then this also frees and deactivates
 *                      the assertion referred to by <code>assertionID</code>
 *
 *                      Calls to <code>@link IOPMAssertionCreate@/link</code> and <code>@link IOPMAssertionRetain@/link</code>
 *                      must each be paired with calls to IOPMAssertionRelease.
 *
 * @param               AssertionID The assertion_id, returned from IOPMAssertionCreate, to cancel.
 *
 * @result              Returns kIOReturnSuccess on success.
 */
IOReturn IOPMAssertionRelease(IOPMAssertionID AssertionID)
                            AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
    

/*!
 * @function            IOPMAssertionCopyProperties
 * @abstract            Copies details about an <code>IOPMAssertion</code>.
 * @discussion          Returns a dictionary describing an IOPMAssertion's specifications and current state.
 * @param theAssertion  The assertion ID to copy info about.
 * @result              A dictionary describing the assertion with keys specified in See @link IOPMAssertionDictionaryKeys@/link. 
 *                      It's the caller's responsibility to release this dictionary.
 */
CFDictionaryRef IOPMAssertionCopyProperties(IOPMAssertionID theAssertion)
                            __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_3_2);

/*!
 * @function            IOPMAssertionSetProperty
 * @abstract            Sets a property in the assertion.
 * @discussion          Only the process that created an assertion may change its properties.
 * @param theAssertion  The <code>@link IOPMAssertionID@/link</code> of the assertion to modify.
 * @param theProperty   The CFString key, from <code>@link IOPMAssertionDictionaryKeys@/link</code> to modify.
 * @param theValue      The property to set. It must be a CFNumber or CFString, as specified by the property key named in whichProperty.
 * @result              Returns <code>@link kIOReturnNotPriviliged@/link</code> if the caller doesn't 
 *                          have permission to modify this assertion.
 *                      Returns <code>@link kIOReturnNotFound@/link</code> if PM can't locate this assertion.
 *                      Returns <code>@link kIOReturnError@/link</code> upon an unidentified error.
 *                      Returns <code>@link kIOReturnSuccess@/link</code> otherwise.
 */
IOReturn IOPMAssertionSetProperty(IOPMAssertionID theAssertion, CFStringRef theProperty, CFTypeRef theValue)
                            __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_3_2);

/*!
 * @function            IOPMCopyAssertionsByProcess
 *
 * @abstract            Returns a dictionary listing all assertions, grouped by their owning process.
 *
 * @discussion          Notes: One process may have multiple assertions. Several processes may
 *                      have asserted the same assertion to different levels.
 *
 * @param AssertionsByPID On success, this returns a dictionary of assertions per process.
 *                      At the top level, keys to the CFDictionary are pids stored as CFNumbers (kCFNumberIntType).
 *                      The value associated with each CFNumber pid is a CFArray of active assertions.
 *                      Each entry in the CFArray is an assertion represented as a CFDictionary. See the keys
 *                      kIOPMAssertionTypeKey and kIOPMAssertionLevelKey. 
 *                      Caller must CFRelease() this dictionary when done.
 *
 * @result              Returns kIOReturnSuccess on success.
 */
IOReturn IOPMCopyAssertionsByProcess(CFDictionaryRef *AssertionsByPID)
                            AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
    
/*!
 * @function            IOPMCopyAssertionsStatus
 *
 * @abstract            Returns a list of available assertions and their system-wide levels.
 *
 * @discussion          The system-wide level is the maximum of all individual assertions' levels.
 *
 * @param AssertionsStatus On success, this returns a CFDictionary of all assertions currently available.
 *                      The keys in the dictionary are the assertion types, and the value of each is a CFNumber that
 *                      represents the aggregate level for that assertion.  Caller must CFRelease() this dictionary when done.
 *
 * @result Returns      kIOReturnSuccess on success.
 */
IOReturn IOPMCopyAssertionsStatus(CFDictionaryRef *AssertionsStatus)
                            AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

    
    

/*!
 * @function            IOPMAssertionCreate
 *
 * @abstract            This is a deprecated call to create a power assertion.
 *
 * @deprecated          IOPMAssertionCreate is deprecated in favor of <code>@link IOPMAssertionCreateWithProperties@/link</code>.
 *                      Please use that version of this API instead.
 *
 * @discussion          No special privileges necessary to make this call - any process may
 *                      activate a power assertion.
 *
 * @param AssertionType     The CFString assertion type to request from the PM system.
 * @param AssertionLevel    Pass kIOPMAssertionLevelOn or kIOPMAssertionLevelOff.
 * @param AssertionID       On success, a unique id will be returned in this parameter.
 *
 * @result              Returns kIOReturnSuccess on success, any other return indicates
 *                          PM could not successfully activate the specified assertion.
 */
IOReturn IOPMAssertionCreate(CFStringRef        AssertionType, 
                           IOPMAssertionLevel   AssertionLevel,
                           IOPMAssertionID      *AssertionID)
                            __OSX_AVAILABLE_BUT_DEPRECATED
                            (__MAC_10_5,__MAC_10_6,__IPHONE_2_0, __IPHONE_2_1);

/*!
 * @function            IOPMAssertionCreateWithName
 *
 * @abstract            The simplest API to create a power assertion.
 *
 * @deprecated          IOPMAssertionCreate is deprecated in favor of <code>@link IOPMAssertionCreateWithProperties@/link</code>.
 *                      Please use that version of this API instead.
 *
 * @discussion          No special privileges are necessary to make this call - any process may
 *                      activate a power assertion. Caller must specify an AssertionName - NULL is not
 *                      a valid input.
 *
 * @param AssertionType     The CFString assertion type to request from the PM system.
 * @param AssertionLevel    Pass kIOPMAssertionLevelOn or kIOPMAssertionLevelOff.
 * @param AssertionName     A string that describes the name of the caller and the activity being
 *                          handled by this assertion (e.g. "Mail Compacting Mailboxes"). Name may be no longer 
 *                          than 128 characters.
 *
 * @param AssertionID       On success, a unique id will be returned in this parameter.
 *
 * @result                  Returns kIOReturnSuccess on success, any other return indicates
 *                          PM could not successfully activate the specified assertion.
 */
IOReturn IOPMAssertionCreateWithName(
                        CFStringRef          AssertionType, 
                        IOPMAssertionLevel   AssertionLevel,
                        CFStringRef          AssertionName,
                        IOPMAssertionID      *AssertionID)
                        AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;                           
                           
/*!
 * @define          kIOPMAssertionTimeoutKey
 * @abstract        kIOPMAssertionTimeoutKey specifies an outer bound, in seconds, that this assertion should be asserted.
 *
 * @discussion      If your application hangs, or is unable to complete its assertion task in a reasonable amount of time,
 *                  specifying a timeout allows PM to disable your assertion so the system can resume normal activity.
 *                  Once a timeout with the <code>@link kIOPMAssertionTimeoutActionTurnOff@/link</code> assertion fires, the level
 *                  will be set to <code>@link kIOPMAssertionTimeoutActionTurnOff@/link</code>. The assertion may be re-armed by calling
 *                  <code>@link IOPMAssertionSetProperty@/link</code> and setting a new value for for 
 *                  <code>kIOPMAssertionTimeoutKey</code>.
 *
 *                  This key may be specified in the dictionary passed to <code>@link IOPMAssertionCreateWithProperties@/link</code>.
 *
 *                  This key may be present in the dictionary returned from <code>@link IOPMAssertionCopyProperties@/link</code>.
 */
#define kIOPMAssertionTimeoutKey                CFSTR("TimeoutSeconds")


/*!
 * @define          kIOPMAssertionTimeoutActionKey
 *
 * @abstract        Specifies the action to take upon timeout expiration.
 *
 * @discussion      Specifying the timeout action only has meaning if you also specify an <code>@link kIOPMAssertionTimeoutKey@/link</code>
 *                  If the caller does not specify a timeout action, the default action is <code>@link kIOPMAssertionTimeoutActionTurnOff@/link</code>
 *
 *                  This key may be specified in the dictionary passed to <code>@link IOPMAssertionCreateWithProperties@/link</code>.
 *
 *                  This key may be present in the dictionary returned from <code>@link IOPMAssertionCopyProperties@/link</code>.
 */
#define kIOPMAssertionTimeoutActionKey          CFSTR("TimeoutAction")

/*!
 * @define          kIOPMAssertionTimeoutActionLog
 *
 * @abstract        A potential value for <code>@link kIOPMAssertionTimeoutActionKey@/link</code>
 *
 * @discussion      When this timeout action is specified, PM will log the timeout event
 *                  but will not turn off or affect the setting of the assertion in any way.
 *
 */
#define kIOPMAssertionTimeoutActionLog          CFSTR("TimeoutActionLog")

/*!
 * @define          kIOPMAssertionTimeoutActionTurnOff
 *
 * @discussion      When a timeout expires with this action, Power Management will log the timeout event,
 *                  and will set the assertion's level to <code>@link kIOPMAssertionLevelOff@/link</code>.
 */
#define kIOPMAssertionTimeoutActionTurnOff      CFSTR("TimeoutActionTurnOff")

/*!
 * @define          kIOPMAssertionTimeoutActionRelease
 *
 * @discussion      When a timeout expires with this action, Power Management will log the timeout event,
 *                  and will release the assertion.
 */
#define kIOPMAssertionTimeoutActionRelease      CFSTR("TimeoutActionRelease")

/*!
 * @define          kIOPMAssertionRetainCountKey
 *
 * @discussion      kIOPMAssertionRetainCountKey reflects the CoreFoundation-style retain count on this assertion.
 *                  Creating or retaining an assertion increments its retain count.
 *                  Release an assertion decrements its retain count.
 *                  When the retain count decrements to zero, the OS will destroy the object.
 *
 *                  This key can be found in the dictionary returned from <code>@link IOPMAssertionCopyProperties@/link</code>.
 */
#define kIOPMAssertionRetainCountKey            CFSTR("RetainCount")

/*!
 * @define          kIOPMAssertionNameKey
 *
 * @abstract        The CFDictionary key for assertion name. Setting this key is required when you're creating an assertion.
 *
 * @discussion      <code>kIOPMAssertionNameKey</code> describes the the activity the assertion is protecting. The creator should
 *                  specify a CFString value for this key in the dictionary passed to <code>@link IOPMAssertionCreateWithProperties@/link</code>
 *
 *                  The assertion name is separate from the assertion type's behavior - specify a CFString
 *                  like "Checking mail" or "Compiling" that describes the task that this assertion protects.
 *
 *                  The CFString you associate with this key does not have to be localizable (OS X will not attempt to localize it.)
 *
 *                  Describe your assertion as thoroughly as possible. See these other keys that can you can also set to add explanation
 *                  to an assertion:
 *                  <ul>
 *                      <li> OPTIONAL <code>@link kIOPMAssertionDetailsKey@/link</code>
 *                      <li> OPTIONAL <code>@link kIOPMAssertionHumanReadableReasonKey @/link</code>
 *                      <li> OPTIONAL <code>@link kIOPMAssertionLocalizationBundlePathKey@/link</code>
 *                  </ul>
 */
#define kIOPMAssertionNameKey                  CFSTR("AssertName")

/*!
 * @define          kIOPMAssertionDetailsKey
 *
 * @abstract        You may provide extra, contextual information about an assertion for admins and for debugging
 *                  in this key. Setting this key in an assertion dictionary is optional.
 *
 * @discussion      Please name your assertion something unique with <code>@link kIOPMAssertionNameKey@/link</code> first.
 *                  If you have more data to describe this assertion, put it here as a CFString.
 *
 *  '               EXAMPLE: OS X creates an assertion named <code>com.apple.powermanagement.tty</code> to prevent sleep for
 *                  remote-logged in users. To identify the cause for these assertions, OS X sets <code>kIOPMAssertionDetailsKey</code>
 *                  to the CFString device path of the active remote session(s), e.g. "/dev/ttys000 /dev/ttys004"
 *
 *                  The CFString you associate with this key does not have to be localizable (OS X will not attempt to localize it.)
 *
 *                  Describe your assertion as thoroughly as possible. See these other keys that can you can set to add explanation
 *                  to an assertion:
 *                  <ul>
 *                      <li>REQUIRED <code>@link kIOPMAssertionNameKey@/link</code>
 *                      <li>OPTIONAL <code>@link kIOPMAssertionHumanReadableReasonKey @/link</code>
 *                      <li>OPTIONAL <code>@link kIOPMAssertionLocalizationBundlePathKey@/link</code>
 *                  </ul>
 */
#define kIOPMAssertionDetailsKey             CFSTR("Details")

/*!
 * @define          kIOPMAssertionHumanReadableReasonKey
 *
 * @abstract        Optional key that provides a localizable string for OS X to display PM Assertions in the GUI.
 *
 * @discussion      The caller should specify this string in <code>@link IOPMAssertionCreateWithProperties@/link</code>.
 *                  If present, OS X may display this string, localized to the user's language, to explain changes in system
 *                  behavior caused by the assertion.
 *
 *                  If set, the caller must also specify a bundle path for the key
 *                      <code>@link kIOPMAssertionLocalizationBundlePathKey@/link</code>
 *                  The bundle at that path should contain localization info for the specified string.
 *
 *                  This key may be specified in the dictionary passed to <code>@link IOPMAssertionCreateWithProperties@/link</code>.
 *
 *                  This key may be present in the dictionary returned from <code>@link IOPMAssertionCopyProperties@/link</code>.
 *
 *                  Describe your assertion as thoroughly as possible. See these other keys that can you can set to add explanation
 *                  to an assertion:
 *                  <ul>
 *                      <li>REQUIRED <code>@link kIOPMAssertionNameKey@/link</code>
 *                      <li>OPTIONAL <code>@link kIOPMAssertionDetailsKey @/link</code>
 *                  </ul>
 */
#define kIOPMAssertionHumanReadableReasonKey    CFSTR("HumanReadableReason")

/*!
 * @define          kIOPMAssertionLocalizationBundlePathKey
 *
 * @abstract        Refers to a CFURL, as a CFString, identifying the path to the caller's
 *                  bundle, which contains localization info.
 *
 * @discussion      The bundle must contain localizations for
 *                  <code>@link kIOPMAssertionHumanReadableReasonKey@/link</code>
 *
 *                  This key may be specified in the dictionary passed to <code>@link IOPMAssertionCreateWithProperties@/link</code>.
 *
 *                  This key may be present in the dictionary returned from <code>@link IOPMAssertionCopyProperties@/link</code>.
 */
#define kIOPMAssertionLocalizationBundlePathKey   CFSTR("BundlePath")

/*!
 * @define          kIOPMAssertionFrameworkIDKey
 *
 * @abstract        Specify if the assertion creator is a framework.
 *
 * @discussion      If the code that creates the assertion resides in a framework or library, the caller
 *                  should specify a CFBundleIdentifier, as a CFString, identifying that bundle here.
 *                  This info helps developers and administrators determine the source of an assertion.
 *
 *                  This key may be specified in the dictionary passed to <code>@link IOPMAssertionCreateWithProperties@/link</code>.
 *
 *                  This key may be present in the dictionary returned from <code>@link IOPMAssertionCopyProperties@/link</code>.
 */
#define kIOPMAssertionFrameworkIDKey            CFSTR("FrameworkBundleID")

/*!
 * @define          kIOPMAssertionPlugInIDKey
 *
 * @abstract        Specify if the assertion creator is a plugin.
 *
 * @discussion      If the code that creates the assertion resides in a plugin, the caller
 *                  should specify a CFBundleIdentifier, as a CFString, identifying the plugin's bundle here.
 *                  This info helps developers and administrators determine the source of an assertion.
 *
 *                  This key may be specified in the dictionary passed to <code>@link IOPMAssertionCreateWithProperties@/link</code>.
 *
 *                  This key may be present in the dictionary returned from <code>@link IOPMAssertionCopyProperties@/link</code>.
 */
#define kIOPMAssertionPlugInIDKey               CFSTR("PlugInBundleID")

/*!
 * @define          kIOPMAssertionTypeKey
 *
 * @abstract        The CFDictionary key for assertion type in an assertion info dictionary.
 *
 * @discussion      The value for this key will be a CFStringRef, with the value of the assertion
 *                  type specified at creation time.
 *                  Note that OS X may substitute a support assertion type string if the caller
 *                  specifies a deprecated assertion type; in that case the value for this key could
 *                  differ from the caller-provided assertion type.
 */
#define kIOPMAssertionTypeKey                   CFSTR("AssertType")

/*!
 * @define          kIOPMAssertionLevelKey
 *
 * @abstract        The CFDictionary key for assertion level in an assertion info dictionary.
 *
 * @discussion      The value for this key will be a CFNumber, kCFNumberIntType with value
 *                  <code>kIOPMAssertionLevelOff</code> or <code>kIOPMAssertionLevelOn</code>.
 *                  The level reflects the assertion's level set at creation, or adjusted via
 *                  <code>@link IOPMAssertionSetProperty@/link</code>
 */
#define kIOPMAssertionLevelKey                  CFSTR("AssertLevel")


/*!
 * @define          kIOPMAssertionTypePreventUserIdleSystemSleep
 * @abstract        This assertion type is identical to <code>@link kIOPMAssertPreventUserIdleSystemSleep @/link</code>
 *                  Please use that instead.
 */
#define kIOPMAssertionTypePreventUserIdleSystemSleep        kIOPMAssertPreventUserIdleSystemSleep
    
/*!
 * @define          kIOPMAssertionTypePreventUserIdleDisplaySleep
 * @abstract        This assertion type is identical to <code>@link kIOPMAssertPreventUserIdleDisplaySleep @/link</code>
 *                  Please use that instead.
 */
#define kIOPMAssertionTypePreventUserIdleDisplaySleep       kIOPMAssertPreventUserIdleDisplaySleep
    
/*!
 * @define          kIOPMAssertionTypePreventSystemSleep
 * @deprecated      Deprecated in 10.9. This assertion is not supported in any OS X releases.
 * @abstract        This assertion is deprecated. Do not use it.
 * @discussion      Please consider using either assertion type for system activities:
 *                      <ul>
 *                          <li><code>@link kIOPMAssertRemoteAccess @/link</code></li>
 *                          <li><code>@link kIOPMAssertPreventUserIdleSystemSleep @/link</code></li>
 *                      </ul>
 */
#define kIOPMAssertionTypePreventSystemSleep                CFSTR("PreventSystemSleep")

/*!
 * @define          kIOPMAssertionTypeNoIdleSleep
 * @deprecated      Deprecated in 10.7.
 * @abstract        Please use assertion type <code>@link kIOPMAssertPreventUserIdleSystemSleep@/link</code> instead.
 */
#define kIOPMAssertionTypeNoIdleSleep                       CFSTR("NoIdleSleepAssertion")

/*!
 * @define          kIOPMAssertionTypeNoDisplaySleep
 * @deprecated      Deprecated in 10.7.
 * @abstract        Please use assertion type <code>@link kIOPMAssertPreventUserIdleDisplaySleep@/link</code> instead.
 */
#define kIOPMAssertionTypeNoDisplaySleep                    CFSTR("NoDisplaySleepAssertion")

    
#pragma mark IOSystemLoadAdvisory
/*!
 * @functiongroup IOSystemLoadAdvisory
 */

/*! @define kIOSystemLoadAdvisoryNotifyName
   @abstract The notification by this name fires when system "SystemLoadAdvisory" status changes.
   @discussion Pass this string as an argument to register via notify(3).
            You can query SystemLoadAdvisory state via notify_get_state() when this notification
            fires - this is more efficient than calling IOGetSystemLoadAdvisory(), and returns
            an identical combined SystemLoadAdvisory value.
 */
#define kIOSystemLoadAdvisoryNotifyName   "com.apple.system.powermanagement.SystemLoadAdvisory"

/*! @typedef IOSystemLoadAdvisoryLevel
   @abstract Return type for IOGetSystemLoadAdvisory
   @discussion Value is one of kIOSystemLoadAdvisoryLevelGreat, kIOSystemLoadAdvisoryLevelOK,
       or kIOSystemLoadAdvisoryLevelBad.
 */
typedef int IOSystemLoadAdvisoryLevel;

enum {
    kIOSystemLoadAdvisoryLevelBad       = 1,
    kIOSystemLoadAdvisoryLevelOK        = 2,
    kIOSystemLoadAdvisoryLevelGreat     = 3
};

/*! @define kIOSystemLoadAdvisoryUserLevelKey
   @abstract Key for dictionary returned by IOCopySystemLoadAdvisoryDetailed
   @discussion Indicates user activity constraints on the current SystemLoadAdvisory level.
 */
#define kIOSystemLoadAdvisoryUserLevelKey             CFSTR("UserLevel")

/*! @define kIOSystemLoadAdvisoryBatteryLevelKey
   @abstract Key for dictionary returned by IOCopySystemLoadAdvisoryDetailed
   @discussion Indicates battery constraints on the current SystemLoadAdvisory level.
 */
#define kIOSystemLoadAdvisoryBatteryLevelKey          CFSTR("BatteryLevel")

/*! @define kIOSystemLoadAdvisoryThermalLevelKey
   @abstract Key for dictionary returned by IOCopySystemLoadAdvisoryDetailed
   @discussion Indicates thermal constraints on the current SystemLoadAdvisory level.
 */
#define kIOSystemLoadAdvisoryThermalLevelKey          CFSTR("ThermalLevel")

/*! @define kIOSystemLoadAdvisoryCombinedLevelKey
   @abstract Key for dictionary returned by IOCopySystemLoadAdvisoryDetailed
   @discussion Provides a combined level based on UserLevel, BatteryLevel,
        and ThermalLevels; the combined level is the minimum of these levels. 
        In the future, this combined level may represent new levels as well.
        The combined level is identical to the value returned by IOGetSystemLoadAdvisory().
 */
#define kIOSystemLoadAdvisoryCombinedLevelKey         CFSTR("CombinedLevel")

/*! @function IOGetSystemLoadAdvisory
   @abstract Returns a hint about whether now would be a good time to perform time-insensitive 
        work.
   @discussion Based on user and system load, IOGetSystemLoadAdvisory determines "better" and "worse"
   times to run optional or time-insensitive CPU or disk work.
    
   Applications may use this result to avoid degrading the user experience. If it is a 
   "Bad" or "OK" time to perform work, applications should slow down and perform work
   less aggressively.
   
   There is no guarantee that the system will ever be in "Great" condition to perform work -
   all essential work must still be performed even in "Bad", or "OK" times. 
   Completely optional work, such as updating caches, may be postponed indefinitely.
   
   Note: You may more efficiently read the SystemLoadAdvisory level using notify_get_state() instead
        of IOGetSystemLoadAdvisory. The results are identical. notify_get_state() requires that you
        pass the token argument received by registering for SystemLoadAdvisory notifications.
   
   @return IOSystemLoadAdvisoryLevel - one of:
   <ul>
        <li>kIOSystemLoadAdvisoryLevelGreat - A Good time to perform time-insensitive work.
        <li>kIOSystemLoadAdvisoryLevelOK - An OK time to perform time-insensitive work.
        <li>kIOSystemLoadAdvisoryLevelBad - A Bad time to perform time-insensitive work.
    </ul>
 */
   
IOSystemLoadAdvisoryLevel IOGetSystemLoadAdvisory( void );

/*! @function IOCopySystemLoadAdvisoryDetailed
   @abstract Indicates how user activity, battery level, and thermal level each 
        contribute to the overall "SystemLoadAdvisory" level. In the future, 
        this combined level may represent new levels as well.
   @discussion See dictionary keys defined above.
   @return Returns a CFDictionaryRef, or NULL on error. Caller must release the
        returned dictionary.
 */
CFDictionaryRef IOCopySystemLoadAdvisoryDetailed(void);


/*!
 * @functiongroup CPU Power & Thermal
 */
/*! 
 * @define      kIOPMCPUPowerNotificationKey
 * @abstract    Key to register for BSD style notifications on CPU power or thermal change.
 */

#define kIOPMCPUPowerNotificationKey            "com.apple.system.power.CPU"
/*! 
 * @define      kIOPMThermalWarningNotificationKey
 * @abstract    Key to register for BSD style notifications on system thermal warnings.
 */
#define kIOPMThermalWarningNotificationKey      "com.apple.system.power.thermal_warning"
    
/*!
 * @function    IOPMCopyCPUPowerStatus
 * @abstract    Copy status of all current CPU power levels.
 * @discussion  The returned dictionary may define some of these keys, 
 *              as defined in IOPM.h:
 *              <ul>   
 *                  <li>kIOPMCPUPowerLimitProcessorSpeedKey
 *                  <li>kIOPMCPUPowerLimitProcessorCountKey
 *                  <li>kIOPMCPUPowerLimitSchedulerTimeKey        
 *              </ul>
 * @param       cpuPowerStatus Upon success, a pointer to a dictionary defining CPU power; 
 *              otherwise NULL. Pointer will be populated with a newly created dictionary 
 *              upon successful return. Caller must release dictionary.
 * @result      kIOReturnSuccess, or other error report. Returns kIOReturnNotFound if 
 *              CPU PowerStatus has not been published.
 */
IOReturn IOPMCopyCPUPowerStatus(CFDictionaryRef *cpuPowerStatus);
    
/*! 
 * @function    IOPMGetThermalWarningLevel
 * @abstract    Get thermal warning level of the system.
 * @result      An integer pointer declaring the power warning level of the system. 
 *              The value of the integer is one of (defined in IOPM.h):
 *              <ul>
 *                  <li>kIOPMThermalWarningLevelNormal
 *                  <li>kIOPMThermalWarningLevelDanger
 *                  <li>kIOPMThermalWarningLevelCrisis
 *              </ul>
 *              Upon success the thermal level value will be found at the 
 *              pointer argument.
 * @result      kIOReturnSuccess, or other error report. Returns kIOReturnNotFound if 
 *              thermal warning level has not been published.
 */
IOReturn IOPMGetThermalWarningLevel(uint32_t *thermalLevel);
    


#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IOPMLibDefs.h                                                                                       0100644 0001750 0001750 00000004017 12567450737 034442  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/pwr_mgt                                                               /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


#define	kPMSetAggressiveness            0
#define	kPMGetAggressiveness            1
#define	kPMSleepSystem                  2
#define	kPMAllowPowerChange             3
#define	kPMCancelPowerChange            4
#define	kPMShutdownSystem               5
#define	kPMRestartSystem                6
#define kPMSleepSystemOptions           7
#define kPMSetMaintenanceWakeCalendar   8
#define kPMSetUserAssertionLevels       9
#define kPMActivityTickle               10
#define kPMGetSystemSleepType           11
#define kPMSetClamshellSleepState       12
#define kPMSleepWakeWatchdogEnable      13
#define kPMSleepWakeDebugTrig           14
#define kPMSetDisplayPowerOn            15

#define kNumPMMethods                   16
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 sbp2/                                                                                               0040755 0001750 0001750 00000000000 12612224741 031445  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOFireWireSBP2Lib.h                                                                                 0100644 0001750 0001750 00000140451 12566177703 034657  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/sbp2                                                                  /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOFIREWIRESBP2LIB_H_
#define _IOKIT_IOFIREWIRESBP2LIB_H_

#include <IOKit/firewire/IOFireWireFamilyCommon.h>
#include <IOKit/IOMessage.h>

/* A45B8156-B51B-11D4-AB4B-000A277E7234 */
#define kIOFireWireSBP2LibTypeID CFUUIDGetConstantUUIDWithBytes(NULL,		\
    0xA4, 0x5B, 0x81, 0x56, 0xB5, 0x1B, 0x11, 0xD4,							\
    0xAB, 0x4B, 0x00, 0x0A, 0x27, 0x7E, 0x72, 0x34 )

/* AE3A2684-B51B-11D4-B516-000A277E7234 */
#define kIOFireWireSBP2LibFactoryID CFUUIDGetConstantUUIDWithBytes(NULL, 	\
    0xAE, 0x3A, 0x26, 0x84, 0xB5, 0x1B, 0x11, 0xD4,							\
    0xB5, 0x16, 0x00, 0x0A, 0x27, 0x7E, 0x72, 0x34 )

/* B63446A8-B51B-11D4-AAB0-000A277E7234 */
#define kIOFireWireSBP2LibLUNInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0xB6, 0x34, 0x46, 0xA8, 0xB5, 0x1B, 0x11, 0xD4,						    	\
    0xAA, 0xB0, 0x00, 0x0A, 0x27, 0x7E, 0x72, 0x34 )

/* BBE32C26-BAD4-11D4-A580-000A277E7234 */
#define kIOFireWireSBP2LibLoginInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0xBB, 0xE3, 0x2C, 0x26, 0xBA, 0xD4, 0x11, 0xD4, 							\
	0xA5, 0x80, 0x00, 0x0A, 0x27, 0x7E, 0x72, 0x34 )

/* 0D818E2E-BC55-11D4-9B72-000A277E7234 */
#define kIOFireWireSBP2LibORBInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0x0D, 0x81, 0x8E, 0x2E, 0xBC, 0x55, 0x11, 0xD4, 							\
	0x9B, 0x72, 0x00, 0x0A, 0x27, 0x7E, 0x72, 0x34 )

/* ECD3E338-BDBC-11D4-A592-000A277E7234 */
#define kIOFireWireSBP2LibMgmtORBInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0xEC, 0xD3, 0xE3, 0x38, 0xBD, 0xBC, 0x11, 0xD4,									\
	0xA5, 0x92, 0x00, 0x0A, 0x27, 0x7E, 0x72, 0x34 )

//////////////////////

#define kIOMessageFWSBP2ReconnectComplete		((UInt32)iokit_fw_err(0x3E8))
#define kIOMessageFWSBP2ReconnectFailed       	((UInt32)iokit_fw_err(0x3E9))

/*!
 * Direction of transfer, with respect to the described memory.
 */
enum IODirection
{
    kIODirectionNone  = 0,
    kIODirectionIn    = 1,	// User land 'read'
    kIODirectionOut   = 2,	// User land 'write'
    kIODirectionOutIn = 3
};

/*! Virtual address range for SBP2. */
typedef struct 
{
	void * address;
	UInt32 length;
} FWSBP2VirtualRange;

//////////////////////

/*! @enum Login Option Flags
    @discussion
	Passed to the setLoginFlags member function.
 */
enum
{
	kFWSBP2DontSynchronizeMgmtAgent = (1 << 0),
    kFWSBP2ExclusiveLogin 			= (1 << 5)
};

/*! @enum ORB Option Flags
    @discussion
	Passed to the setCommandFlags member function.
 */
enum
{
    kFWSBP2CommandCompleteNotify			= (1 << 0),
    kFWSBP2CommandTransferDataFromTarget	= (1 << 1),
    kFWSBP2CommandImmediate					= (1 << 2),
    
    kFWSBP2CommandNormalORB					= (1 << 5),
    kFWSBP2CommandReservedORB				= (1 << 6),
    kFWSBP2CommandVendorORB					= (1 << 7),
    kFWSBP2CommandDummyORB					= (1 << 8),
    kFWSBP2CommandCheckGeneration			= (1 << 9),
	
	kFWSBP2CommandFixedSize					= (1 << 10),
	kFWSBP2CommandVirtualORBs				= (1 << 11)     // handy for debugging
};

/*! @enum SBP2 setCommandFunction values
    @discussion
	Passed to the setCommandFunction member function.
 */
enum
{
    kFWSBP2QueryLogins			= 1,
    kFWSBP2AbortTask			= 0xb,
    kFWSBP2AbortTaskSet			= 0xc,
    kFWSBP2LogicalUnitReset		= 0xe,
    kFWSBP2TargetReset			= 0xf
};

/*! @enum SBP2 Notification Events
    @discussion
	Passed to the setStatusNotifyProc member function.
 */
enum
{
    kFWSBP2NormalCommandStatus	= 6,
    kFWSBP2NormalCommandTimeout	= 7,
    kFWSBP2UnsolicitedStatus	= 8,
    kFWSBP2NormalCommandReset	= 9
};

/*! 
    @typedef FWSBP2LoginResponse
    @param length Length of login response.
    @param loginID Unique id representing this login. 
    @param commandBlockAgentAddressHi High 32 bits of command block agent address.
    @param commandBlockAgentAddressLo Low 32 bits of command block agent address.
    @param reserved Reserved.
    @param reconnectHold Reconnect timeout encoded as 2^reconnectHold seconds.
*/

typedef struct
{
    UInt16		length;
    UInt16		loginID;
    UInt32		commandBlockAgentAddressHi;
    UInt32		commandBlockAgentAddressLo;
    UInt16		reserved;
    UInt16		reconnectHold;
} FWSBP2LoginResponse;

/*! 
    @typedef FWSBP2StatusBlock
    @param details Src, Resp, D, Len fields of status block format
    @param sbpStatus SBP2 specific status
    @param orbOffsetHi High 32 bits of address of orb status is for.
    @param orbOffsetLo Low 32 bits of address of orb status is for.
    @param status Up to 48 bytes of additional data. Length is determined by len field.
*/

typedef struct
{
    UInt8		details;
    UInt8		sbpStatus;
    UInt16		orbOffsetHi;
    UInt32		orbOffsetLo;
    UInt32		status[6];
} FWSBP2StatusBlock;

// struct sent to login complete handler

/*! 
    @typedef FWSBP2LoginCompleteParams
    @param refCon refCon set on login object.
    @param generation FireWire generation value.
    @param status Status of login attempt.
    @param loginResponse Pointer to login response struct.
    @param statusBlock Pointer to status block buffer.
    @param statusBlockLength Length of entire status block.
*/

typedef struct
{
    void * 								refCon;			// refCon from login object
    UInt32								generation;		// generation this login was attempted in 
    IOReturn							status;			// status of login attempt
    FWSBP2LoginResponse *				loginResponse;		// pointer to loginResponse buffer
    FWSBP2StatusBlock *					statusBlock;		// pointer to statusBlock buffer
    UInt32								statusBlockLength;	// size of statusBlock buffer
} FWSBP2LoginCompleteParams;

// struct sent to logout complete handler

/*! 
    @typedef FWSBP2LogoutCompleteParams
    @param refCon refCon set on login object.
    @param generation FireWire generation value.
    @param status Status of login attempt.
    @param statusBlock Pointer to status block buffer.
    @param statusBlockLength Length of entire status block.
*/

typedef struct
{
    void * 								refCon;			// refCon from login object
    UInt32								generation;		// generation this login was attempted in
    IOReturn							status;				// status of login attempt
    FWSBP2StatusBlock *					statusBlock;		// pointer to statusBlock buffer
    UInt32								statusBlockLength;	// size of statusBlock buffer
} FWSBP2LogoutCompleteParams;

// struct sent with reconnect notification

/*! 
    @typedef FWSBP2ReconnectParams
    @param refCon refCon set on LUN object.
    @param generation FireWire generation value.
    @param status Status of reconnect attempt.
    @param reconnectStatusBlock Pointer to status block buffer.
    @param reconnectStatusBlockLength Length of entire status block.
*/

typedef struct
{
    void *				 	refCon;			// refCon from lun object
    UInt32					generation;		// generation this login was attempted in

    IOReturn				status;			// status of reconnect attempt

    FWSBP2StatusBlock *		reconnectStatusBlock;		// pointer to statusBlock buffer
    UInt32					reconnectStatusBlockLength;	// size of statusBlock buffer
} FWSBP2ReconnectParams;

/*! 
    @typedef FWSBP2NotifyParams
    @param refCon refCon set on Login object for unsolicited status or refCon set ORB for normal status.
    @param notificationEvent Type of event we are being notified of.
    @param message buffer containing message.
    @param length length of message field.
    @param generation FireWire generation value.
*/

typedef struct
{
    void *			refCon; 				// refCon from ORB object
    UInt32 			notificationEvent;
    const void * 	message;
    UInt32			length;
    UInt32			generation;
} FWSBP2NotifyParams;

//////////////////////

typedef void (*IOFWSBP2MessageCallback)( void * refCon, UInt32 type, void * arg );

/*! 
    @typedef IOFWSBP2LoginCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param params Structure containing additional information about the status of the login. 
*/

typedef void (*IOFWSBP2LoginCallback)( void * refCon, FWSBP2LoginCompleteParams * params );

/*! 
    @typedef IOFWSBP2LogoutCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param params Structure containing additional information about the status of the logout. 
*/

typedef void (*IOFWSBP2LogoutCallback)( void * refCon, FWSBP2LogoutCompleteParams * params );

/*! 
    @typedef IOFWSBP2ORBAppendCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param status Indicates success or failure of operation. 
    @param orb refCon set on management orb.
*/

typedef void (*IOFWSBP2ORBAppendCallback)( void * refCon, IOReturn status, void * orb );

/*! 
    @typedef IOFWSBP2ORBCompleteCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param status Indicates success or failure of operation. 
    @param orb refCon set on management orb.
*/

typedef void (*IOFWSBP2ORBCompleteCallback)( void * refCon, IOReturn status, void * orb );

/*! 
    @typedef IOFWSBP2NotifyCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param params FWSBP2NotifyParams containing notification information.
*/

typedef void (*IOFWSBP2NotifyCallback)(void * refCon, FWSBP2NotifyParams * params);

/*! 
    @typedef IOFWSBP2StatusCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param status Indicates success or failure of operation. 
*/

typedef void (*IOFWSBP2StatusCallback)(void * refCon, IOReturn status);

/*! 
    @typedef IOFWSBP2FetchAgentWriteCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param status Indicates success or failure of operation. 
    @param orbRefCon refCon from last orb in chain.
*/

typedef void (*IOFWSBP2FetchAgentWriteCallback)(void * refCon, IOReturn status, void * orbRefCon );

//////////////////////


/*!
    @class IOFireWireSBP2LibLUNInterface
    @abstract Initial interface disovered for all drivers. 
    @discussion The IOFireWireSBP2LibLUNInterface is the initial interface discovered by most drivers. It supplies the methods that control the operation of the LUN as a whole.  Methods that control the behavior and execution of an SBP2 login session are supplied in a separate IOFireWireSBP2LibLoginInterface object. The LUN can be used to create one of these login objects.
    The LUN can also create IOFireWireSBP2LibManagementORBInterfaces for configuring and appending non-login related management functions.  Login related management functions (ie. Login, Logout, Reconnect) are supplied by the IOFireWireSBP2LibLoginInterface.
    Finally the LUN can supply a reference to the IOFireWireUnit.  This can be useful if a driver wishes to access the standard FireWire APIs.  
*/
typedef struct
{

	IUNKNOWN_C_GUTS;

	UInt16	version;						
    UInt16	revision;

    /*!
		@function open
		@abstract Exclusively opens a connection to the in-kernel device.
		@discussion Exclusively opens a connection to the in-kernel device.  As long as the in-kernel 
        device object is open, no other drivers will be able to open a connection to the device. When 
        open the device on the bus may disappear, but the in-kernel object representing it will stay
        instantiated and can begin communicating with the device again if it ever reappears. 
        @param self Pointer to IOFireWireSBP2LibLUNInterface.
        @result Returns kIOReturnSuccess on success.
    */
    
	IOReturn (*open)( void * self );
    
    /*!
		@function openWithSessionRef
		@abstract Opens a connection to a device that is already open.
		@discussion Sometimes it is desirable to open multiple user clients on a device.  In the case 
        of FireWire sometimes we wish to have both the FireWire User Client and the SBP2 User Client 
        open at the same time. 
		<p>The technique to arbitrate this is as follows :</p>
		<p>First open normally the device furthest from the root in the IORegistry.</p>
		<p>Second, get its sessionRef with the getSessionRef call.</p>
		<p>Third open the device further up the chain by calling this method and passing the sessionRef returned from the call in step 2.</p>
		@param sessionRef SessionRef returned from getSessionRef call. 
        @param self Pointer to IOFireWireSBP2LibLUNInterface.
        @result Returns kIOReturnSuccess on success.
    */
    
	IOReturn (*openWithSessionRef)( void * self, IOFireWireSessionRef sessionRef );

    /*!
		@function getSessionRef
		@abstract Returns the session reference to an already open device.
		@discussion Sometimes it is desirable to open multiple user clients on a device.  In the case 
        of FireWire sometimes we wish to have both the FireWire User Client and the SBP2 User Client 
        open at the same time.  
		<p>The technique to arbitrate this is as follows:</p> 
		<p>First open normally the device furthest from the root in the IORegistry.</p>  
		<p>Second, get its sessionRef with a call to this method.</p>
		<p>Third open the device further up the chain by calling openWithSessionRef and passing the sessionRef returned from this call.</p>
        @param self Pointer to IOFireWireSBP2LibLUNInterface.
        @result Returns a sessionRef on success.
    */

	IOFireWireSessionRef (*getSessionRef)(void * self);

    /*!
		@function close
		@abstract Opens a connection to a device that is not already open.
		@discussion Closes an exclusive access to the device.  When a device is closed it may be 
        unloaded by the kernel.  If it is unloaded and then later reappears it will be represented 
        by a different object.  You won't be able to use this user client on the new object.  The 
        new object will have to be looked up in the IORegistry and a new user client will have to 
        be opened on it. 
        @param self Pointer to IOFireWireSBP2LibLUNInterface.
    */

	void (*close)( void * self );

    /*!
		@function addCallbackDispatcherToRunLoop
		@abstract Adds a dispatcher for kernel callbacks to the specified runloop.
		@discussion The user space portions of the SBP2 api communicate with the in-kernel services by 
        messaging the kernel.  Similarly, the kernel messages the user space services in response.  
        These responses need to be picked up by a piece of code.  This call adds that code to the specified
        runloop.  Most drivers will call this method on the runloop that was created when your task was 
        created.  To avoid deadlock you must avoid sleeping (or spin waiting) the runloop to wait for 
        SBP2 response.  If you do this the dispatcher will never get to run and you will wait forever.
        @param self Pointer to IOFireWireSBP2LibLUNInterface.
        @param cfRunLoopRef Reference to a runloop
        @result Returns kIOReturnSuccess on success.
    */
    	
	IOReturn (*addCallbackDispatcherToRunLoop)( void *self, CFRunLoopRef cfRunLoopRef );
	
    /*!
		@function removeCallbackDispatcherFromRunLoop
		@abstract Removes a dispatcher for kernel callbacks from the specified runloop.
		@discussion Undoes the work of addCallbackDispatcherToRunLoop.
        @param self Pointer to IOFireWireSBP2LibLUNInterface.
    */
    
    void (*removeCallbackDispatcherFromRunLoop)( void * self );
    
    /*!
		@function setMessageCallback
		@abstract Set callback for user space message routine.
		@discussion In FireWire & SBP2 bus status messages are delivered via IOKit's message routine.  
        This routine is emulated in user space for SBP2 & FireWire messages via this callback.  You should
        register here for bus reset, and reconnect messages.
        @param self Pointer to IOFireWireSBP2LibLUNInterface.
        @param refCon RefCon to be returned as first argument of completion routine
        @param callback Address of completion routine.
    */
    
	void (*setMessageCallback)( void *self, void * refCon, IOFWSBP2MessageCallback callback);

    /*!
		@function setRefCon
		@abstract Sets the ORB refCon.
		@discussion Sets a user defined value on the ORB that can be retrieved later with the 
        method getRefCon.
        @param self Pointer to IOFireWireSBP2LibLUNInterface.
        @param refCon a user defined value.
    */
    
	void (*setRefCon)( void * self, void * refCon );
    
    /*!
		@function getRefCon
		@abstract Returns the refCon set with setRefCon.
		@discussion Returns the user defined value previously stored in the ORB with setRefCon.
        @param self Pointer to IOFireWireSBP2LibLUNInterface.
        @result Returns the previously stored user defined value.
	*/

	void * (*getRefCon)( void * self);
    
    /*!
		@function createLogin
		@abstract Creates a new IOFireWireSBP2LibLoginInterface object.
		@discussion	Creates a new IOFireWireSBP2LibLoginInterface object for the LUN.  Login 
        objects supply most of the SBP2 APIs related to login maintenance and Normal 
        Command ORB execution.
        @param self Pointer to IOFireWireSBP2LibLUNInterface.
        @param iid UUID for desired type of IOFireWireSBP2LibLoginInterface.
        @result Returns a pointer to a new IOFireWireSBP2LibLoginInterface.
	*/

	IUnknownVTbl** (*createLogin)( void * self, REFIID iid );
    
    /*!
		@function createMgmtORB
		@abstract Creates a new IOFireWireSBP2LibMgmntORBInterface object.
		@discussion	Creates a new IOFireWireSBP2LibMgmtORBInterface object.  Management objects let you 
        execute commands like QueryLogins, LogicalUnitReset, and AbortTask.  These commands are 
        configured after they are created here.  When they are done executing (after a call to submit) 
        the supplied completion routine will be called with the supplied refcon.  Usually this refCon
        is the "this" pointer of completion method's object.
        @param self Pointer to IOFireWireSBP2LibLUNInterface.
        @param iid UUID for desired type of IOFireWireSBP2LibMgmtORBInterface.
        @result Returns a pointer to a new IOFireWireSBP2Login.
	*/

	IUnknownVTbl** (*createMgmtORB)( void * self, REFIID iid );

} IOFireWireSBP2LibLUNInterface;



/*!
    @class IOFireWireSBP2LibORBInterface
    @abstract Represents an SBP2 normal command ORB.  Supplies the APIs for configuring normal
    command ORBs.  This includes setting the command block and writing the page tables for I/O.
    The ORBs are executed using the submitORB method in IOFireWireSBP2LibLoginInterface.
*/
typedef struct
{

	IUNKNOWN_C_GUTS;

	UInt16	version;						
    UInt16	revision;

    /*!
		@function setRefCon
		@abstract Sets the ORB refCon.
		@discussion Sets a user defined value on the ORB that can be retrieved later with the 
        method getRefCon.
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @param refCon a user defined value.
    */
    
	void (*setRefCon)( void * self, void * refCon );

    /*!
		@function getRefCon
		@abstract Returns the refCon set with setRefCon.
		@discussion Returns the user defined value previously stored in the ORB with setRefCon.
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @result Returns the previously stored user defined value.
	*/

	void * (*getRefCon)( void * self );	
    
    /*! 
        @function setCommandFlags
        @abstract Sets configuration flags for the ORB.
        @discussion Sets the configuration flags for the ORB.  These can be any of the following:
		<p>kFWSBP2CommandCompleteNotify - Set the notify bit as specified in SBP2 standard. Set to receive completion/timeout notification on this ORB.  You almost always want to set this.</p>
		<p>kFWSBP2CommandTransferDataFromTarget - Transfer direction as specified in SBP2 standard.  Set if data is to be written by the device into the host's memory.</p>
		<p>kFWSBP2CommandImmediate - Immediate Append.  ORB address will be written to fetch agent and not chained.  It is only legal to have one immediate ORB in progress at a time.</p>
		<p>kFWSBP2CommandNormalORB - ORB format 0 - Format specified by SBP2 standard.  Set this for most ORBs.</p>
		<p>kFWSBP2CommandReservedORB - ORB format 1 - Format reserved by SBP2 standard for future standardization.</p>
		<p>kFWSBP2CommandVendorORB - ORB format 2 - Format specified by SBP2 standard for vendor dependent ORBs.</p>
		<p>kFWSBP2CommandDummyORB - ORB format 3 - Format specified by SBP2 standard for dummy ORBs.</p>
		<p>kFWSBP2CommandCheckGeneration - If set upon submitORB, the ORB will only be appended if generation set with setCommandGeneration() matches the current generation.  Pretty much all SBP2 drivers need sophisticated logic to track login state, so this is generally not used. </p>
		<p>kFWSBP2CommandFixedSize - Do not allocate more memory for page table if needed.  If there is not enough space in the currently allocated page table, the setCommandBuffers call will fail.  This is important to set if your device is the backing store, as we don't want to cause memory allocations on the paging path. </p>
		<p>kFWSBP2CommandVirtualORBs - Normally ORBs are backed by physical address spaces.  Setting this flag makes this ORB backed by a pseudo address space.  This can make ORBs easier to see in a bus trace.  Virtual ORBs will have an address in the form of ffcX.XXXX.0000.0000.  Pseudo address space backed ORBs are slower, so you won't want to set for deployment builds.</p>
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @param flags The flags to be set.
    */
    
	void (*setCommandFlags)( void * self, UInt32 flags );

    /*! 
        @function setMaxORBPayloadSize
        @abstract Sets max payload size for the ORB.
        @discussion This sets the maximum payload size for this ORB only.  This size is clipped by 
        the global max payload size set in the login object.
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @param size The maximum payload size in bytes.
    */
    
	void (*setMaxORBPayloadSize)( void * self, UInt32 size );

    /*! 
        @function setCommandTimeout
        @abstract Sets the timeout of the ORB.
        @discussion This sets the timeout for the ORB in milliseconds. Note that ORBs without timeouts 
        can be "lost."  You will obviously not recieve timeout notification for timeouts of zero.  But 
        perhaps less obviously you will not recieve orb reset notification, which is really a sort of
        accelerated timeout notification for bus reset situations.  
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @param timeout The timeout duration in milliseconds.
    */
    
	void (*setCommandTimeout)( void * self, UInt32 timeout );

    /*! 
        @function setCommandGeneration
        @abstract Sets the command generation.
        @discussion This sets the bus generation this ORB should be appended in.  It is only meaningful 
        when combined with the kFWSBP2CommandCheckGeneration flags above.
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @param generation The bus generation for command execution.
    */

	void (*setCommandGeneration)( void * self, UInt32 generation );

    /*! 
        @function setCommandBuffersAsRanges
        @abstract Creates a page table from a list of ranges.
        @discussion Creates a page table with the given parameters. Any addresses mapped by this method 
        must remain valid until setCommandBuffers is called again or releaseCommandBuffers is called.  
        The SBP2 services do not release references to the command buffers just because the command 
        has completed.
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @param ranges An array of ranges representing the data to be transfered.
        @param withCount The number of ranges in the ranges array.
        @param withDirection An IODirection indicating the direction of data transfer.
        @param offset Offset in bytes into data to begin writing table at.
        @param length Number of bytes of data to map from offset.
        @result Returns KIOReturnSuccess if the page table was written successfully. 
    */

    IOReturn (*setCommandBuffersAsRanges)( void * self, FWSBP2VirtualRange * ranges, UInt32 withCount,
											UInt32 withDirection, UInt32 offset, 
											UInt32 length );

    /*! 
        @function releaseCommandBuffers
        @abstract Releases SBP2's reference to the command buffers.
        @discussion When you create a page table with one of the variants of setCommandBuffers.  
        SBP2 holds on to a reference to the buffers until this method is called.  This means that 
        if a command completed and you released the buffers 
        without calling this method you could leave FW in an inconsistent state.  
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @result Returns KIOReturnSuccess if the page table was cleared successfully. 
    */
    
    IOReturn (*releaseCommandBuffers)( void * self );
    
    /*! 
        @function setCommandBlock
        @abstract Sets the command block portion of the ORB.
        @discussion Copys the data provided in the buffer to the command block portion of the ORB.
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @param buffer Pointer to buffer to copy command block from.
        @param length Number of bytes of data to copy.
        @result Returns KIOReturnSuccess if the command block was updated successfully. 
    */

    IOReturn (*setCommandBlock)( void * self, void * buffer, UInt32 length );
    
    /*! 
        @function LSIWorkaroundSetCommandBuffersAsRanges
        @abstract Creates a page table with the LSI workaround from a list of ranges.
        @discussion Creates an LSI workaround page table with the given parameters. Any addresses 
        mapped by this method routine must remain valid until setCommandBuffers is called again
        or releaseCommandBuffers is called. The SBP2 services do not release references to the 
        command buffers just because the command has completed.
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @param ranges An array of ranges representing the data to be transfered.
        @param withCount The number of ranges in the ranges array.
        @param withDirection An IODirection indicating the direction of data transfer.
        @param offset Offset in bytes into data to begin writing table at.
        @param length Number of bytes of data to map from offset.
        @result Returns KIOReturnSuccess if the page table was written successfully. 
    */
    
    IOReturn (*LSIWorkaroundSetCommandBuffersAsRanges)( void * self, FWSBP2VirtualRange * ranges, UInt32 withCount,
											UInt32 withDirection, UInt32 offset, 
											UInt32 length );

    /*!
		@function LSIWorkaroundSyncBuffersForOutput
		@abstract Synchronize the buffers for output.
		@discussion	Since double buffering may be invovled in the workaround.  The driver needs to 
        indicate when these buffers should be syncronized with the original descriptor.  For data 
        that will be output LSIWorkaroundSyncBuffersForOutput should be called before submiting the ORB.
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @result Returns kIOReturnSuccess if sync was successful.
	*/
    
    IOReturn (*LSIWorkaroundSyncBuffersForOutput)( void * self );

    /*!
		@function LSIWorkaroundSyncBuffersForInput
		@abstract Synchronize the buffers for input.
		@discussion	Since double buffering may be invovled in the workaround.  The driver needs to 
        indicate when these buffers should be syncronized with the original descriptor.  For data 
        that will be input LSIWorkaroundSyncBuffersForInput should be called after receiving completion status 
        for the ORB.
        @param self Pointer to IOFireWireSBP2LibORBInterface.
        @result Returns kIOReturnSuccess if sync was successful.
	*/

    IOReturn (*LSIWorkaroundSyncBuffersForInput)( void * self );
		
} IOFireWireSBP2LibORBInterface;

 /*!
    @class IOFireWireSBP2LibLoginInterface
    @abstract Supplies the login maintenance and Normal Command ORB execution portions of the API.
    @discussion Supplies APIs for login maintenance and command execution.  Drivers can use this 
    object to create IOFireWireSBP2LibORBInterface objects and execute them.  Solicited and unsolicited status 
    callback routines can be registered and the SBP2 services will notify the driver when the 
    appropriate status arrives.
    This class also handles login maintenance.  Supplies APIs for logging in and logging out and 
    attempts to reconnect to the LUN after bus resets.  The base FireWire services deliver bus 
    reset notification via the IOKit message routine.  The SBP2 services build on this behavior 
    and deliver reconnectFailed and reconnectComplete through the message routine as well.
*/
typedef struct
 {

	IUNKNOWN_C_GUTS;

	UInt16	version;						
    UInt16	revision;

    /*!
		@function submitLogin
		@abstract Attempts to login to the LUN.		
        @discussion This call begins the login process.  The login object should be configured prior 
        to this call. If kIOReturnSuccess is returned from this call then the loginCompletion routine 
        will be called when the login completes (successfully or unsuccesfully). 
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @result Returns kIOReturnSuccess login has successlly begun.
	*/

	IOReturn (*submitLogin)( void * self );

    /*!
		@function submitLogout
		@abstract Attempts to logout of the LUN.		
        @discussion This call begins the logout process.  If kIOReturnSuccess is returned from this call then
        the logoutCompletion routine will be called when the logout completes (successfully or unsuccesfully). 
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @result Returns kIOReturnSuccess if logout has successfully begun.
	*/

	IOReturn (*submitLogout)( void * self );

    /*!
		@function setLoginFlags
		@abstract Sets login configuration flags.
		@discussion Configures the login behavior according to the provided flags.  Currently two 
        flags are defined for this API.  kFWSBP2ExclusiveLogin sets the exclusive login bit in the 
        login ORB. kFWSBP2DontSynchronizeMgmtAgent allows simultaneous logins or reconnects to LUNs
        with a common management agent (ie LUNs in the same unit directory).
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param flags the login configuration flags.
	*/
    
	void (*setLoginFlags)( void * self, UInt32 flags );

    /*!
		@function setLoginCallback
		@abstract Sets the callback to be called when a login attempt is complete.
		@discussion The supplied callback is called when a login attempt has completed. "status" in the
        callback's params should be checked to determine the success or failure of the login attempt.
        The "refCon" field in the params will return the refcon set with setRefCon.   
        If "statusBlock" is non-null then login status was written and it has been supplied here.  If 
        the login attempt was successful then the login response will be supplied in the "loginResponse" 
        buffer.  Note: all buffers supplied to callbacks are only valid for the duration of the callback.  
        Also, you are not to modify the contents of any supplied buffer.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param refCon refCon passed to callback.	
        @param callback address of callback method of type FWSBP2LoginCallback.
	*/

	void (*setLoginCallback)( void * self, void * refCon, IOFWSBP2LoginCallback callback );

    /*!
		@function setLogoutCallback
		@abstract Sets the callback to be called when a logout attempt is complete.
		@discussion The supplied callback is called when a logout attempt has completed. "status" in the
        callback's params should be checked to determine the success or failure of the logout attempt.
        The "refCon" field in the params will return the refcon set with setRefCon.  
        If "statusBlock" is non-null then logout status was written and it has been supplied here. 
        Note: all buffers supplied to callbacks are only valid for the duration of the callback.  
        Also, you are not to modify the contents of any supplied buffer.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param refCon refCon passed to callback.	
        @param callback address of callback method of type FWSBP2LogoutCallback.
	*/

	void (*setLogoutCallback)( void * self, void * refCon, IOFWSBP2LogoutCallback callback );

    /*!
		@function setRefCon
		@abstract Sets the login refCon.
		@discussion Sets a user defined value on the login that can be retrieved later with the 
        method getRefCon.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param refCon a user defined value.
    */

	void (*setRefCon)( void * self, void * refCon );

    /*!
		@function getRefCon
		@abstract Returns the refCon set with setRefCon.
		@discussion Returns the user defined value previously stored in the login with setRefCon.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @result Returns the previously stored user defined value.
	*/

	void * (*getRefCon)( void * self);

    /*!
		@function getMaxCommandBlockSize
		@abstract Returns the maximum command block size.
		@discussion The device publishes an upper limit on the size of command block that it can 
        accept.  That value can be accessed via this method.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @result Returns a UInt32 containing the maximum command block size.
	*/

	UInt32 (*getMaxCommandBlockSize)( void * self);

    /*!
		@function getLoginID
		@abstract Returns the current login ID.
		@discussion When we successfully login to a device.  The device gives us a unique login id.  
        This is used internally for reconnecting to the device after bus resets and for certain other 
        management ORBs.  Most drivers are probably not interested in this value.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @result Returns a UInt32 containing the current login ID.
	*/
    
	UInt32 (*getLoginID)( void * self);

    /*!
		@function setMaxPayloadSize
		@abstract Sets the maximum data transfer length for a normal command ORB.
		@discussion Sets the maximum data transfer length for a normal command ORB.  This value is 
        the maximum for all ORBs sent to this LUN.  This can be trimmed further on an ORB by ORB basis, 
        by a similar call in the IOFireWireSBP2ORB itself.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param size The desired maximum payload size in bytes.
	*/

	void (*setMaxPayloadSize)( void * self, UInt32 size );

    /*!
		@function setReconnectTime
		@abstract Sets the desired reconnect duration.
		@discussion The target and initiator arbitrate the duration of the reconnect timeout.  Here 
        the initiator specifies its desired timeout time in 2^reconnectTime seconds.  After a 
        successful login the device returns the actual timeout value it wishes to use.  This value 
        may be less than the reconnect timeout that the intiator specified if this is all that the 
        device can support.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param time The desired reconnect timeout encoded as 2^reconnectTime seconds.
	*/

	void (*setReconnectTime)( void * self, UInt32 time );

    /*!
		@function createORB
		@abstract Creates a new IOFireWireSBP2ORB for this login.
		@discussion	Create a new IOFireWireSBP2ORB for this login.  It can be configured 
        with it's accessors and executed with submitORB below.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param iid UUID for the desired type of IOFireWireSBP2LibLoginInterface.
        @result Returns a pointer to the new ORB object.
	*/
    
	IUnknownVTbl** (*createORB)( void * self, REFIID iid );

    /*!
		@function submitORB
		@abstract Submits the given orb
		@discussion	Starts execution of the given ORB.  If the ORB is an immediate ORB it's 
        addresss is written to the fetch agent.  If it is a non immediate orb its address 
        is appended to the last orb of the currently processing chain.  The doorbell is not 
        rung automatically it must be run manually with the ringDoorbell command described below.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param orb The orb to be executed.	
        @result Returns kIOReturnSuccess if the ORB has been started successfully.
	*/

	IOReturn (*submitORB)( void * self, IOFireWireSBP2LibORBInterface ** orb );

    /*!
		@function setUnsolicitedStatusNotify
		@abstract Sets the callback to be called on normal command status.
		@discussion The supplied callback is called when unsolicited status is recieved.
        "notificationEvent" in the callback's params will indicate what happened.  In this 
        case it will be set to kFWSBP2UnsolicitedStatus. If "len" is 
        non-zero then "message" contains the data written to the status block. Note: any buffers 
        returned by callbacks are only valid for the duration of the login and should not have 
        their contents modified. The "refCon" field in the callback's
        params will return the refcon set with setRefCon. 
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param refCon refCon passed to callback.	
        @param callback address of callback method of type FWSBP2NotifyCallback.
	*/

	void (*setUnsolicitedStatusNotify)( void * self, void * refCon, IOFWSBP2NotifyCallback callback );
    
    /*!
		@function setStatusNotify
		@abstract Sets the callback to be called on normal command status.
		@discussion The supplied callback is called when normal command status is recieved, when 
        a normal command times out, or when a normal command is aborted. 
        "notificationEvent" in the callback's params will indicate what happened.
        It will be set to one of the following values: kFWSBP2NormalCommandReset, kFWSBP2NormalCommandStatus, 
        or kFWSBP2NormalCommandTimeout.  If the event type is kFWSBP2NormalCommandTimeout and "len" is 
        non-zero then "message" contains the data written to the status block.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param refCon refCon passed to callback.	
        @param callback Address of callback method of type FWSBP2NotifyCallback.
	*/

	void (*setStatusNotify)( void * self, void * refCon, IOFWSBP2NotifyCallback callback );

    /*!
		@function setFetchAgentResetCallback
		@abstract Sets the callback to be called when a fetch agent reset completes.
		@discussion The fetch agent state machine on the device can be reset by a write to a specific 
        register.  The SBP2 services offer a utility method to reset the fetch agent.  You can register 
        a callback routine here to be notified when this rest write completes.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param refCon refCon passed to callback.	
        @param callback address of callback method of type FWSBP2FetchAgentWriteCallback.
	*/

	void (*setFetchAgentResetCallback)( void * self, void * refCon, IOFWSBP2StatusCallback callback );

    /*!
		@function submitFetchAgentReset
		@abstract Resets the LUN's fetch agent.
		@discussion The fetch agent state machine on the device can be reset by a write to a specific 
        register.  This reset can be intiated by a call to this method.  Notification of the completion 
        of this write can be had by registering a callback with the setFetchAgentResetCallback method.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @result Returns kIOReturnSuccess if the reset started successfully.
	*/

	IOReturn (*submitFetchAgentReset)( void * self );

    /*!
		@function setFetchAgentWriteCallback
		@abstract Sets the callback to be called when the fetch agent write completes.
		@discussion When an immediate orb is executed with submitORB, it's address is written to a 
        specific address on the device.  This address is called the fetch agent.  The device the 
        reads that orb from the Mac's memory and executes it.  With this call you can register to 
        be called back when this write to the fetch agent completes.  The SBP2 services guarantee 
        that the fetch agent write will be complete before status is reported for an ORB, so for 
        most drivers this notification is not required.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param refCon refCon passed to callback.	
        @param callback address of callback method of type FWSBP2FetchAgentWriteCallback.
	*/

	void (*setFetchAgentWriteCallback)( void * self, void * refCon, IOFWSBP2FetchAgentWriteCallback callback );

    /*!
		@function ringDoorbell
		@abstract Rings the doorbell on the LUN.
		@discussion Non-immediate appends to the ORB chain may require the fetch agent state machine 
        to be notified of the new ORB's presence.  This is accomplished by writing to the so called 
        doorbell register.  This method begins one of those writes.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @result Returns kIOReturnSuccess if the ring started successfully.
	*/

	IOReturn (*ringDoorbell)( void * self );

    /*!
		@function enableUnsolicitedStatus
		@abstract Enables unsolicited status.
		@discussion After unsolicited is sent the device will not send any additional unsolicited status 
        until a specific register is written.  This serves as a sort of flow-control for unsolicited status.  
        After unsolicited status is recieved and processed drivers will want to reenable the delivery 
        of unsolicted status by a call to this method.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @result Returns kIOReturnSuccess if the status enable write started successfully.
	*/

	IOReturn (*enableUnsolicitedStatus)( void * self );

    /*!
		@function setBusyTimeoutRegisterValue
		@abstract Sets the value to be written to the BUSY_TIMEOUT register.
		@discussion 1394-1995 defines a register known as the BUSY_TIMEOUT register. This register 
        controls the busy retry behavior of your device.  The initial value for this register is 
        0x00000000.  Which means busied transactions will not be retried.  Since most devices want 
        their transactions retired on busy acks, the SBP2 service automatically updates the 
        BUSY_TIMEOUT register with the value specified here whenever necessary.  Most drivers should 
        set this value to 0x0000000f.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param timeout desired value of the BUSY_TIMEOUT register.
    */
    
	IOReturn (*setBusyTimeoutRegisterValue)( void * self, UInt32 timeout );

    /*!
		@function setPassword
		@abstract Sets the login password.
		@discussion Sets the login password using a buffer and a length.  An alternate version exists 
        that accepts an IOMemoryDescriptor.  If the password length is 8 or less the password is copied 
        directly into the login orb.  If the length is greater than 8 the buffer is referenced by address 
        in the login ORB.  In this case the buffer is not copied and should remain allocated for the 
        duration of the login attempt.
        @param self Pointer to IOFireWireSBP2LibLoginInterface object.
        @param buffer a pointer to the password buffer.
        @param length the length in bytes of the password buffer.
        @result Returns kIOReturnSuccess on success.
	*/
    	
    IOReturn (*setPassword)( void * self, void * buffer, UInt32 length );
	
} IOFireWireSBP2LibLoginInterface;


/*!
	@class IOFireWireSBP2LibMgmtORBInterface
    @abstract Supplies non login related management ORBs.  Management ORBs can be executed independent 
    of a login, if necessary.  Management ORBs are created using the IOFireWireSBP2LibLUNInterface.
*/
typedef struct
{

	IUNKNOWN_C_GUTS;

	UInt16	version;						
    UInt16	revision;

    /*!
		@function submitORB
		@abstract Submits this ORB for execution.
		@discussion Submits this ORB for execution
        @param self Pointer to a IOFireWireSBP2LibMgmtORBInterface.
    */
    
	IOReturn (*submitORB)( void * self );
    
    /*!
		@function setORBCompleteCallback
		@abstract Sets the ORB completion routine.
		@discussion Sets the completion routine to be called when the ORB finishes execution. The refCon 
        set with setRefCon will also be passed as the third argument to the completion handler.
        @param self Pointer to a IOFireWireSBP2LibMgmtORBInterface.
        @param refCon refCon passed as first argument to completion routine
    */
    
	void (*setORBCompleteCallback)( void * self, void * refCon, 
													IOFWSBP2ORBCompleteCallback callback );
    /*!
		@function setRefCon
		@abstract Sets the login refCon.
		@discussion Sets a user defined value on the login that can be retrieved later with the 
        method getRefCon.
        @param self Pointer to a IOFireWireSBP2LibMgmtORBInterface.
        @param refCon a user defined value.
    */
    
	void (*setRefCon)( void * self, void * refCon );

   /*!
		@function getRefCon
		@abstract Returns the current function of the management ORB.
		@discussion Returns the function of the management ORB.  This is the same value that was 
        set with setCommandFunction.
        @param self Pointer to a IOFireWireSBP2LibMgmtORBInterface.
        @result Returns the function of the management ORB.
	*/

	void * (*getRefCon)( void * self);	

    /*!
		@function setCommandFunction
		@abstract Sets the function of the management ORB.
		@discussion Sets the the function of the management ORB.  Legal values are kFWSBP2QueryLogins,
        kFWSBP2AbortTask, kFWSBP2AbortTaskSet,  kFWSBP2LogicalUnitReset, and kFWSBP2TargetReset.
        @param self Pointer to a IOFireWireSBP2LibMgmtORBInterface.
        @param function a value indicating the desired management function.
        @result Returns kIOReturnSuccess if function was a legal function.
	*/
    	
    IOReturn (*setCommandFunction)( void * self, UInt32 function );

    /*!
		@function setManageeORB
		@abstract Sets the command to be managed by the management ORB.
		@discussion All management functions except kFWSBP2QueryLogins require a reference to an ORB of 
        some sort.  kFWSBP2AbortTask requires a reference to the ORB to be aborted.  
        This method allows you to set the Normal Command ORB to be managed.
        @param self Pointer to a IOFireWireSBP2LibMgmtORBInterface.
        @param command a reference to an IOFireWireSBP2Login or an IOFireWireSBP2ORB.
        @result Returns kIOReturnSuccess on a success.
 	*/

	IOReturn (*setManageeORB)( void * self, void * command );

    /*!
		@function setManageeLogin
		@abstract Sets the command to be managed by the management ORB.
		@discussion All management functions except kFWSBP2QueryLogins require a reference to an ORB of 
        some sort.  kFWSBP2AbortTaskSet,  kFWSBP2LogicalUnitReset, and kFWSBP2TargetReset require a 
        reference to the login ORB.    
        This method allows you to set the login ORB to be managed.
        @param self Pointer to a IOFireWireSBP2LibMgmtORBInterface.
        @param command a reference to an IOFireWireSBP2Login or an IOFireWireSBP2ORB.
        @result Returns kIOReturnSuccess on a success.
 	*/
    
	IOReturn (*setManageeLogin)( void * self, void * command );

    /*!
		@function setResponseBuffer
		@abstract Sets the response buffer for the management ORB.
		@discussion Sets the response buffer for the management ORB.  kFWSBP2QueryLogins returns 
        a response to its query and needs to write it somewhere.  This routine allows you to 
        specify the location.        
        @param self Pointer to a IOFireWireSBP2LibMgmtORBInterface.
        @param buf backing store for buffer
        @param len length of buffer.
        @result Returns kIOReturnSuccess on a success.
	*/

	IOReturn (*setResponseBuffer)( void * self, void * buf, UInt32 len );
		
} IOFireWireSBP2LibMgmtORBInterface;

#endif
                                                                                                                                                                                                                       scsi/                                                                                               0040755 0001750 0001750 00000000000 12612224741 031540  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOSCSIMultimediaCommandsDevice.h                                                                    0100644 0001750 0001750 00000070705 12567470660 037541  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/scsi                                                                  /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_SCSI_MULTIMEDIA_COMMANDS_DEVICE_H_
#define _IOKIT_IO_SCSI_MULTIMEDIA_COMMANDS_DEVICE_H_

#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif

#include <IOKit/storage/IOStorageDeviceCharacteristics.h>

// Build includes
#include <TargetConditionals.h>


//-----------------------------------------------------------------------------
//	Constants
//-----------------------------------------------------------------------------


// Message constants
#define kIOMessageTrayStateChange			0x69000035
#define kIOMessageTrayStateHasChanged		kIOMessageTrayStateChange // DEPRECATED, use kIOMessageTrayStateChange instead

// Message values for kIOMessageTrayStateChange
enum
{
	kMessageTrayStateChangeRequestAccepted	= 0,
	kMessageTrayStateChangeRequestRejected	= 1
};

#define kIOMessageMediaAccessChange			0x69000036

// Message values for kIOMessageMediaAccessChange
enum
{
	kMessageDeterminingMediaPresence	= 0,
	kMessageFoundMedia					= 1,
	kMessageMediaTypeDetermined			= 2
};

// IOKit property keys and constants
#define	kIOPropertySupportedCDFeatures		kIOPropertySupportedCDFeaturesKey
#define	kIOPropertySupportedDVDFeatures		kIOPropertySupportedDVDFeaturesKey
#define	kIOPropertySupportedBDFeatures		kIOPropertySupportedBDFeaturesKey
#define kIOPropertyLowPowerPolling			"Low Power Polling"

typedef UInt32 CDFeatures;
enum
{
	kCDFeaturesAnalogAudioBit			= 0,	// Analog Audio playback
	kCDFeaturesReadStructuresBit		= 1,	// CD-ROM
	kCDFeaturesWriteOnceBit				= 2,	// CD-R
	kCDFeaturesReWriteableBit			= 3,	// CD-R/W
	kCDFeaturesCDDAStreamAccurateBit	= 4,	// CD-DA stream accurate
	kCDFeaturesPacketWriteBit			= 5,	// Packet Writing
	kCDFeaturesTAOWriteBit				= 6,	// CD Track At Once
	kCDFeaturesSAOWriteBit				= 7,	// CD Mastering - Session At Once
	kCDFeaturesRawWriteBit				= 8,	// CD Mastering - Raw
	kCDFeaturesTestWriteBit				= 9,	// CD Mastering/TAO - Test Write
	kCDFeaturesBUFWriteBit				= 10	// CD Mastering/TAO - Buffer Underrun Free
};

enum
{
	kCDFeaturesAnalogAudioMask 			= (1 << kCDFeaturesAnalogAudioBit),
	kCDFeaturesReadStructuresMask		= (1 << kCDFeaturesReadStructuresBit),
	kCDFeaturesWriteOnceMask			= (1 << kCDFeaturesWriteOnceBit),
	kCDFeaturesReWriteableMask			= (1 << kCDFeaturesReWriteableBit),
	kCDFeaturesCDDAStreamAccurateMask	= (1 << kCDFeaturesCDDAStreamAccurateBit),
	kCDFeaturesPacketWriteMask			= (1 << kCDFeaturesPacketWriteBit),
	kCDFeaturesTAOWriteMask				= (1 << kCDFeaturesTAOWriteBit),
	kCDFeaturesSAOWriteMask				= (1 << kCDFeaturesSAOWriteBit),
	kCDFeaturesRawWriteMask				= (1 << kCDFeaturesRawWriteBit),
	kCDFeaturesTestWriteMask			= (1 << kCDFeaturesTestWriteBit),
	kCDFeaturesBUFWriteMask				= (1 << kCDFeaturesBUFWriteBit)
};

typedef	UInt32 DVDFeatures;
enum
{
	kDVDFeaturesCSSBit 					= 0,	// DVD-CSS
	kDVDFeaturesReadStructuresBit 		= 1,	// DVD-ROM
	kDVDFeaturesWriteOnceBit			= 2,	// DVD-R
	kDVDFeaturesRandomWriteableBit		= 3,	// DVD-RAM
	kDVDFeaturesReWriteableBit			= 4,	// DVD-RW
	kDVDFeaturesTestWriteBit			= 5,	// DVD-R Write - Test Write
	kDVDFeaturesBUFWriteBit				= 6,	// DVD-R Write - Buffer Underrun Free
	kDVDFeaturesPlusRBit				= 7,	// DVD+R
	kDVDFeaturesPlusRWBit				= 8,	// DVD+RW (implies backgound format support)
	kDVDFeaturesHDReadBit				= 9,	// HD DVD-ROM
	kDVDFeaturesHDRBit					= 10,	// HD DVD-R
	kDVDFeaturesHDRAMBit				= 11,	// HD DVD-RAM
	kDVDFeaturesHDRWBit					= 12	// HD DVD-RW
};

enum
{
	kDVDFeaturesCSSMask 				= (1 << kDVDFeaturesCSSBit),
	kDVDFeaturesReadStructuresMask 		= (1 << kDVDFeaturesReadStructuresBit),
	kDVDFeaturesWriteOnceMask			= (1 << kDVDFeaturesWriteOnceBit),
	kDVDFeaturesRandomWriteableMask		= (1 << kDVDFeaturesRandomWriteableBit),
	kDVDFeaturesReWriteableMask			= (1 << kDVDFeaturesReWriteableBit),
	kDVDFeaturesTestWriteMask			= (1 << kDVDFeaturesTestWriteBit),
	kDVDFeaturesBUFWriteMask			= (1 << kDVDFeaturesBUFWriteBit),
	kDVDFeaturesPlusRMask				= (1 << kDVDFeaturesPlusRBit),
	kDVDFeaturesPlusRWMask				= (1 << kDVDFeaturesPlusRWBit),
	kDVDFeaturesHDReadMask				= (1 << kDVDFeaturesHDReadBit),
	kDVDFeaturesHDRMask					= (1 << kDVDFeaturesHDRBit),
	kDVDFeaturesHDRAMMask				= (1 << kDVDFeaturesHDRAMBit),
	kDVDFeaturesHDRWMask				= (1 << kDVDFeaturesHDRWBit)
};

typedef	UInt32 BDFeatures;
enum
{
	kBDFeaturesReadBit					= 0,	// BD-ROM
	kBDFeaturesWriteBit					= 1		// BD-R / BD-RE
};

enum
{
	kBDFeaturesReadMask					= (1 << kBDFeaturesReadBit),
	kBDFeaturesWriteMask				= (1 << kBDFeaturesWriteBit)
};

enum
{
	kDiscStatusEmpty 					= 0,
	kDiscStatusIncomplete				= 1,
	kDiscStatusComplete					= 2,
	kDiscStatusOther					= 3,
	kDiscStatusMask						= 0x03,
	kDiscStatusErasableMask				= 0x10
};


#if defined(KERNEL) && defined(__cplusplus)

// MMC power states as defined in T10:1228D SCSI Multimedia Commands - 2 (MMC-2)
// Revision 11a, August 30, 1999, page 312 (Annex F).
enum
{
	kMMCPowerStateSystemSleep	= 0,
	kMMCPowerStateSleep 		= 1,
	kMMCPowerStateStandby 		= 2,
	kMMCPowerStateIdle			= 3,
	kMMCPowerStateActive		= 4,
	kMMCNumPowerStates			= 5
};

enum
{
	kMediaStateUnlocked	= 0,
	kMediaStateLocked 	= 1
};


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// General IOKit headers
#include <IOKit/IOLib.h>
#include <IOKit/IOMemoryDescriptor.h>

// Generic IOKit storage related headers
#include <IOKit/storage/IOStorage.h>
#include <IOKit/storage/IOCDTypes.h>
#include <IOKit/storage/IODVDTypes.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIPrimaryCommandsDevice.h>

// Forward definitions for internal use only classes
class SCSIMultimediaCommands;
class SCSIBlockCommands;


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOSCSIMultimediaCommandsDevice : public IOSCSIPrimaryCommandsDevice
{
	
	OSDeclareAbstractStructors ( IOSCSIMultimediaCommandsDevice )
	
private:
	
	static void		AsyncReadWriteComplete ( SCSITaskIdentifier completedTask );
	
protected:
	
    // Reserve space for future expansion.
    struct IOSCSIMultimediaCommandsDeviceExpansionData
	{
		IONotifier *		fPowerDownNotifier;
		bool				fDeviceSupportsPowerOff;
		BDFeatures			fSupportedBDFeatures;
		bool				fDeviceSupportsAsyncNotification;
		bool				fDeviceSupportsFastSpindown;
		UInt8				fCDLoadingMechanism;
        bool                fDoNotLockMedia;
	};
    IOSCSIMultimediaCommandsDeviceExpansionData * fIOSCSIMultimediaCommandsDeviceReserved;
	
	#define fPowerDownNotifier 					fIOSCSIMultimediaCommandsDeviceReserved->fPowerDownNotifier
	#define fDeviceSupportsPowerOff 			fIOSCSIMultimediaCommandsDeviceReserved->fDeviceSupportsPowerOff
	#define fSupportedBDFeatures				fIOSCSIMultimediaCommandsDeviceReserved->fSupportedBDFeatures
	#define fDeviceSupportsAsyncNotification	fIOSCSIMultimediaCommandsDeviceReserved->fDeviceSupportsAsyncNotification
	#define fDeviceSupportsFastSpindown			fIOSCSIMultimediaCommandsDeviceReserved->fDeviceSupportsFastSpindown
	#define fCDLoadingMechanism					fIOSCSIMultimediaCommandsDeviceReserved->fCDLoadingMechanism
    #define fDoNotLockMedia                     fIOSCSIMultimediaCommandsDeviceReserved->fDoNotLockMedia
	
	CDFeatures						fSupportedCDFeatures;
	DVDFeatures						fSupportedDVDFeatures;

	UInt16							fCurrentDiscSpeed;	
	bool							fMediaChanged; 
	bool							fMediaPresent;
	
	// The byte count of each physical block on the media.
	UInt32							fMediaBlockSize;
	
	// The total number of blocks of fMediaBlockSize on the media.
	UInt32							fMediaBlockCount;
	
	// Flags used to indicate device feature
	bool							fMediaIsRemovable;
	bool							fMediaIsWriteProtected;
	UInt32							fMediaType;
	
	thread_call_t					fPollingThread;
	bool							fDeviceSupportsLowPowerPolling;
	bool							fLowPowerPollingEnabled;
	UInt32							fPollingMode;
	
	enum
	{
		kPollingMode_Suspended		= 0,
		kPollingMode_NewMedia 		= 1,
		kPollingMode_MediaRemoval	= 2
	};
	
	virtual IOReturn	setProperties ( OSObject * properties );
	
	virtual void 		CreateStorageServiceNub ( void );
	virtual bool		DetermineDeviceCharacteristics ( void );
	virtual IOReturn	DetermineIfMediaIsRemovable ( void );
	virtual IOReturn	DetermineDeviceFeatures ( void );
	virtual void		DetermineMediaType ( void );
	virtual bool		CheckForDVDMediaType ( void );
	virtual bool		CheckForCDMediaType ( void );
	virtual void		PollForMedia ( void );
	virtual void		EnablePolling ( void );
	virtual void		DisablePolling ( void );
	virtual void		CheckWriteProtection ( void );
	virtual bool		ClearNotReadyStatus ( void );
		
	virtual IOReturn	GetDeviceConfiguration ( void );
	virtual IOReturn	GetDeviceConfigurationSize ( UInt32 * size );
	virtual IOReturn	ParseFeatureList ( UInt32 numProfiles, UInt8 * firstFeaturePtr );
	
	virtual IOReturn	GetMechanicalCapabilities ( void );
	virtual IOReturn	GetMechanicalCapabilitiesSize ( UInt32 * size );
	virtual IOReturn	ParseMechanicalCapabilities ( UInt8 * mechanicalCapabilitiesPtr );

	virtual IOReturn	CheckForLowPowerPollingSupport ( void );
	virtual IOReturn	GetCurrentPowerStateOfDrive ( UInt32 * powerState );

	virtual IOReturn	IssueRead ( IOMemoryDescriptor *	buffer,
									UInt64					startBlock,
									UInt64					blockCount );

	virtual IOReturn	IssueRead ( IOMemoryDescriptor *	buffer,
									void *					clientData,
									UInt64					startBlock,
									UInt64					blockCount );
	
	virtual IOReturn	IssueWrite ( IOMemoryDescriptor *	buffer,
									UInt64					startBlock,
									UInt64					blockCount );
	
	virtual IOReturn	IssueWrite ( IOMemoryDescriptor *	buffer,
									void *					clientData,
									UInt64					startBlock,
									UInt64					blockCount );

    virtual void		SetMediaCharacteristics ( UInt32 blockSize, UInt32 blockCount );
 	virtual void		ResetMediaCharacteristics ( void );

	UInt8				ConvertBCDToHex ( UInt8 binaryCodedDigit );

	// ------ User Client Support ------
	
	virtual IOReturn 	HandleSetUserClientExclusivityState ( IOService * userClient, bool state );

	// ----- Power Management Support ------
	
	// We override this method to set our power states and register ourselves
	// as a power policy maker.
	virtual void 		InitializePowerManagement ( IOService * provider );
	
	// We override this method so that when we register for power management,
	// we go to our active power state (which the drive is definitely in
	// at startup time).
	virtual UInt32		GetInitialPowerState ( void );

	// We override this method in order to provide the number of transitions
	// from Fully active to Sleep state so that the idle timer can be adjusted
	// to the appropriate time period based on the disk spindown time set in
	// the Energy Saver prefs panel.
	virtual UInt32		GetNumberOfPowerStateTransitions ( void );
	
	// The TicklePowerManager method is called to tell the power manager that the
	// device needs to be in a certain power state to handle requests.
	virtual void		TicklePowerManager ( void );

	// The HandlePowerChange method is the state machine for power management.
	// It is guaranteed to be on its own thread of execution (different from
	// the power manager thread AND the workloop thread. This routine can
	// send sync or async calls to the drive without worrying about threading
	// issues.
	virtual void		HandlePowerChange ( void );

	// The HandleCheckPowerState (void) method is on the serialized side of the command
	// gate and can change member variables safely without multi-threading issues.
	// It's main purpose is to call the superclass' HandleCheckPowerState ( UInt32 maxPowerState )
	// with the max power state the class registered with.
	virtual void		HandleCheckPowerState ( void );

	// The CheckMediaPresence method is called to see if the media which we
	// anticipated being there is still there.
	virtual bool		CheckMediaPresence ( void );
	
	virtual bool		InitializeDeviceSupport ( void );
	virtual void		StartDeviceSupport ( void );
	virtual void		SuspendDeviceSupport ( void );
	virtual void		ResumeDeviceSupport ( void );
	virtual void		StopDeviceSupport ( void );
	virtual void		TerminateDeviceSupport ( void );
	
	virtual void		free ( void );

	virtual IOReturn	VerifyDeviceState ( void );


public:
	
	virtual IOReturn 	setAggressiveness ( unsigned long type, unsigned long minutes );
	
	virtual IOReturn	SyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					startBlock,
											UInt64					blockCount );
	
	virtual IOReturn	AsyncReadWrite (	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											void *					clientData );

	virtual IOReturn	EjectTheMedia ( void );
	virtual IOReturn	GetTrayState ( UInt8 * trayState );
	virtual IOReturn	SetTrayState ( UInt8 trayState );
	virtual IOReturn	FormatMedia ( UInt64 byteCapacity );
	virtual UInt32		GetFormatCapacities ( 	UInt64 * capacities,
												UInt32   capacitiesMaxCount ) const;
	virtual IOReturn	LockUnlockMedia ( bool doLock );
	virtual IOReturn	SynchronizeCache ( void );
	virtual IOReturn	ReportBlockSize ( UInt64 * blockSize );
	virtual IOReturn	ReportEjectability ( bool * isEjectable );
	virtual IOReturn	ReportLockability ( bool * isLockable );
	virtual IOReturn	ReportPollRequirements ( bool * pollIsRequired,
												 bool * pollIsExpensive );
	virtual IOReturn	ReportMaxReadTransfer (  UInt64 	blockSize,
												 UInt64 * 	max );
	virtual IOReturn	ReportMaxValidBlock ( UInt64 * maxBlock );
	virtual IOReturn	ReportMaxWriteTransfer ( UInt64	blockSize,
												UInt64 * max );
	virtual IOReturn	ReportMediaState ( 	bool * mediaPresent,
											bool * changed );
	virtual IOReturn	ReportRemovability ( bool * isRemovable );
	virtual IOReturn	ReportWriteProtection ( bool * isWriteProtected );
	
	static 	void		sPollForMedia ( void * pdtDriver, void * refCon );

	/* CD Specific */
	virtual IOReturn	SetMediaAccessSpeed ( UInt16 kilobytesPerSecond );
	
	virtual IOReturn	GetMediaAccessSpeed ( UInt16 * kilobytesPerSecond );

	virtual IOReturn	AsyncReadCD ( 	IOMemoryDescriptor * buffer,
										UInt32 block,
										UInt32 nblks,
										CDSectorArea sectorArea,
										CDSectorType sectorType,
										void *	clientData );
	
	virtual IOReturn	ReadISRC ( UInt8 track, CDISRC isrc );
	
	virtual IOReturn	ReadMCN ( CDMCN mcn);
	
	virtual IOReturn	ReadTOC ( IOMemoryDescriptor * buffer );
	
	/* DVD Specific */
	virtual UInt32			GetMediaType		( void );
    
	virtual IOReturn		ReportKey			( IOMemoryDescriptor * buffer,
												  const DVDKeyClass keyClass,
												  const UInt32 lba,
												  const UInt8 agid,
												  const DVDKeyFormat keyFormat );
												  
	virtual IOReturn		SendKey				( IOMemoryDescriptor * buffer,
												  const DVDKeyClass keyClass,
												  const UInt8 agid,
												  const DVDKeyFormat keyFormat );
												  
	virtual IOReturn		ReadDVDStructure 	( 	IOMemoryDescriptor * 		buffer,
													const UInt32 				length,
													const UInt8					structureFormat,
													const UInt32				logicalBlockAddress,
													const UInt8					layer,
													const UInt8 				agid );

	// The block size decoding for Read CD and Read CD MSF  as defined in table 255
    bool	GetBlockSize (
						UInt32 *					requestedByteCount,
						SCSICmdField3Bit 			EXPECTED_SECTOR_TYPE,
						SCSICmdField1Bit 			SYNC,
						SCSICmdField2Bit 			HEADER_CODES,
						SCSICmdField1Bit 			USER_DATA,
						SCSICmdField1Bit 			EDC_ECC,
						SCSICmdField2Bit 			ERROR_FIELD,
						SCSICmdField3Bit 			SUBCHANNEL_SELECTION_BITS );
	
	SCSICmdField4Byte ConvertMSFToLBA ( SCSICmdField3Byte MSF );
	
	// The GET CONFIGURATION command as defined in section 6.1.4
    virtual bool GET_CONFIGURATION (
						SCSITaskIdentifier			request,
   						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField2Bit 			RT, 
						SCSICmdField2Byte 			STARTING_FEATURE_NUMBER, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The GET EVENT/STATUS NOTIFICATION command as defined in section 6.1.5
    virtual bool GET_EVENT_STATUS_NOTIFICATION (
						SCSITaskIdentifier			request,
	    				IOMemoryDescriptor *		dataBuffer,
						SCSICmdField1Bit 			IMMED, 
						SCSICmdField1Byte 			NOTIFICATION_CLASS_REQUEST, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The GET PERFORMANCE command as defined in section 6.1.6
    virtual bool GET_PERFORMANCE (
						SCSITaskIdentifier			request,
	   					IOMemoryDescriptor *		dataBuffer,
						SCSICmdField2Bit 			TOLERANCE, 
						SCSICmdField1Bit 			WRITE, 
						SCSICmdField2Bit 			EXCEPT, 
						SCSICmdField4Byte 			STARTING_LBA, 
						SCSICmdField2Byte 			MAXIMUM_NUMBER_OF_DESCRIPTORS, 
						SCSICmdField1Byte 			CONTROL );

	// The LOAD/UNLOAD MEDIUM command as defined in section 6.1.7
    virtual bool LOAD_UNLOAD_MEDIUM (
						SCSITaskIdentifier			request,
						SCSICmdField1Bit 			IMMED, 
						SCSICmdField1Bit 			LO_UNLO, 
						SCSICmdField1Bit 			START, 
						SCSICmdField1Byte 			SLOT, 
						SCSICmdField1Byte 			CONTROL );

	// The MECHANISM STATUS command as defined in section 6.1.8
    virtual bool MECHANISM_STATUS (
						SCSITaskIdentifier			request,
	   					IOMemoryDescriptor *		dataBuffer,
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );
	
	virtual bool READ_10 (
						SCSITaskIdentifier			request,
		    			IOMemoryDescriptor 			*dataBuffer, 
		    			UInt32						blockSize,
		    			SCSICmdField1Bit 			DPO, 
		    			SCSICmdField1Bit 			FUA,
						SCSICmdField1Bit 			RELADR, 
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField2Byte 			TRANSFER_LENGTH, 
						SCSICmdField1Byte 			CONTROL );
	
	// The READ CD command as defined in section 6.1.15
    virtual bool READ_CD (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField3Bit 			EXPECTED_SECTOR_TYPE,
						SCSICmdField1Bit 			RELADR,
						SCSICmdField4Byte 			STARTING_LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField3Byte 			TRANSFER_LENGTH, 
						SCSICmdField1Bit 			SYNC,
						SCSICmdField2Bit 			HEADER_CODES,
						SCSICmdField1Bit 			USER_DATA,
						SCSICmdField1Bit 			EDC_ECC,
						SCSICmdField2Bit 			ERROR_FIELD,
						SCSICmdField3Bit 			SUBCHANNEL_SELECTION_BITS,
						SCSICmdField1Byte 			CONTROL );

	// The READ CD MSF command as defined in section 6.1.16
    virtual bool READ_CD_MSF (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField3Bit 			EXPECTED_SECTOR_TYPE,
						SCSICmdField3Byte 			STARTING_MSF, 
						SCSICmdField3Byte 			ENDING_MSF, 
						SCSICmdField1Bit 			SYNC,
						SCSICmdField2Bit 			HEADER_CODES,
						SCSICmdField1Bit 			USER_DATA,
						SCSICmdField1Bit 			EDC_ECC,
						SCSICmdField2Bit 			ERROR_FIELD,
						SCSICmdField3Bit 			SUBCHANNEL_SELECTION_BITS,
						SCSICmdField1Byte 			CONTROL );

	// The READ CAPACITY command as defined in section 6.1.17
    virtual bool READ_CAPACITY (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField1Bit 			RELADR,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField1Bit 			PMI,
						SCSICmdField1Byte 			CONTROL );

	// The READ DISC INFORMATION command as defined in section 6.1.18
    virtual bool READ_DISC_INFORMATION (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The READ DVD STRUCTURE command as defined in section 6.1.19
    virtual bool READ_DVD_STRUCTURE (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField4Byte 			ADDRESS,
						SCSICmdField1Byte 			LAYER_NUMBER, 
						SCSICmdField1Byte 			FORMAT, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField2Bit 			AGID,
						SCSICmdField1Byte 			CONTROL );

	// The READ FORMAT CAPACITIES command as defined in section 6.1.20
    virtual bool READ_FORMAT_CAPACITIES (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );
	
	// The READ SUB-CHANNEL command as defined in section 6.1.23
    virtual bool READ_SUB_CHANNEL (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField1Bit 			MSF,
						SCSICmdField1Bit 			SUBQ,
						SCSICmdField1Byte 			SUB_CHANNEL_PARAMETER_LIST, 
						SCSICmdField1Byte 			TRACK_NUMBER, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The READ TOC/PMA/ATIP command as defined in section 6.1.24/25
    virtual bool READ_TOC_PMA_ATIP (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField1Bit 			MSF,
						SCSICmdField4Bit 			FORMAT,
						SCSICmdField1Byte			TRACK_SESSION_NUMBER,
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The READ TRACK INFORMATION command as defined in section 6.1.26
    virtual bool READ_TRACK_INFORMATION (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField2Bit 			ADDRESS_NUMBER_TYPE,
						SCSICmdField4Byte			LOGICAL_BLOCK_ADDRESS_TRACK_SESSION_NUMBER,
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	/*********************** LEGACY COMMAND SUPPORT ***********************/
	// The SET CD SPEED command as defined in section 6.1.36
    virtual bool SET_CD_SPEED (
						SCSITaskIdentifier			request,
						SCSICmdField2Byte 			LOGICAL_UNIT_READ_SPEED, 
						SCSICmdField2Byte 			LOGICAL_UNIT_WRITE_SPEED, 
						SCSICmdField1Byte 			CONTROL );
	/*********************** END LEGACY COMMAND SUPPORT ***********************/

	// The SET READ AHEAD command as defined in section 6.1.37
    virtual bool SET_READ_AHEAD (
						SCSITaskIdentifier			request,
						SCSICmdField4Byte 			TRIGGER_LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField4Byte 			READ_AHEAD_LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField1Byte 			CONTROL );

	// The SET STREAMING command as defined in section 6.1.38
    virtual bool SET_STREAMING (
						SCSITaskIdentifier			request,
	 		   			IOMemoryDescriptor *		dataBuffer,
						SCSICmdField2Byte 			PARAMETER_LIST_LENGTH, 
						SCSICmdField1Byte 			CONTROL );
	
	virtual bool START_STOP_UNIT ( 
						SCSITaskIdentifier			request,
						SCSICmdField1Bit 			IMMED, 
						SCSICmdField4Bit 			POWER_CONDITIONS, 
						SCSICmdField1Bit 			LOEJ, 
						SCSICmdField1Bit 			START, 
						SCSICmdField1Byte 			CONTROL );

	// The SYNCHRONIZE CACHE command as defined in section 6.1.40
    virtual bool SYNCHRONIZE_CACHE (
						SCSITaskIdentifier			request,
						SCSICmdField1Bit 			IMMED, 
						SCSICmdField1Bit 			RELADR, 
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField2Byte 			NUMBER_OF_BLOCKS, 
						SCSICmdField1Byte 			CONTROL );

	// The WRITE (10) command as defined in section 6.1.41
    virtual bool WRITE_10 (
						SCSITaskIdentifier			request,
		    			IOMemoryDescriptor *		dataBuffer, 
		    			UInt32						blockSize,
						SCSICmdField1Bit 			DPO, 
						SCSICmdField1Bit 			FUA, 
						SCSICmdField1Bit 			RELADR, 
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField2Byte 			TRANSFER_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The WRITE AND VERIFY (10) command as defined in section 6.1.42
    virtual bool WRITE_AND_VERIFY_10 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
		    			UInt32						blockSize,
						SCSICmdField1Bit 			DPO, 
						SCSICmdField1Bit 			BYT_CHK, 
						SCSICmdField1Bit 			RELADR, 
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField4Byte 			TRANSFER_LENGTH, 
						SCSICmdField1Byte 			CONTROL );
	
	/* Added with 10.1.3 */
	OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 1 );
	
	virtual IOReturn	ReadTOC (	IOMemoryDescriptor *	buffer,
									CDTOCFormat				format,
									UInt8					msf,
									UInt32					trackSessionNumber,
									UInt16 *				actualByteCount );
	
	/* Added with 10.1.3 */
	OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 2 );
    
	virtual IOReturn	ReadDiscInfo (	IOMemoryDescriptor *	buffer,
										UInt16 *				actualByteCount );
	
	/* Added with 10.1.3 */
	OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 3 );
	
	virtual IOReturn	ReadTrackInfo (	IOMemoryDescriptor *	buffer,
										UInt32					address,
										CDTrackInfoAddressType	addressType,
										UInt16 *				actualByteCount );
	
	/* Added with 10.2 */
	OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 4 );
	
	virtual IOReturn	PowerDownHandler ( void * 		refCon,
										   UInt32 		messageType,
										   IOService * 	provider,
										   void * 		messageArgument,
										   vm_size_t 	argSize );
	
	/* Added with 10.3.3 */
	OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 5 );
	
	
protected:
	
	
	virtual void AsyncReadWriteCompletion ( SCSITaskIdentifier completedTask );
	
	
public:
	
	
	/* Added with 10.5 */
    OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 6 );
	
	virtual	IOReturn	ReadDiscStructure (	IOMemoryDescriptor * 		buffer,
											const UInt32 				length,
											const UInt8					structureFormat,
											const UInt32				logicalBlockAddress,
											const UInt8					layer,
											const UInt8 				agid,
											const UInt8					mediaType );
	
	
	bool		CheckForBDMediaType ( void );
	
	
    bool		READ_DISC_STRUCTURE (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField4Bit 			MEDIA_TYPE,
						SCSICmdField4Byte 			ADDRESS,
						SCSICmdField1Byte 			LAYER_NUMBER, 
						SCSICmdField1Byte 			FORMAT, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField2Bit 			AGID,
						SCSICmdField1Byte 			CONTROL );
	
	
    OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 7 );
	
	virtual	IOReturn	ReserveTrack (	UInt8		reservationType,
										UInt8		reservationFormat,
										UInt64		ReservationParameter );
	
	
	bool		RESERVE_TRACK_V2 (	SCSITaskIdentifier		request,
									SCSICmdField1Bit		RMZ,
									SCSICmdField1Bit		ARSV,
									SCSICmdField7Byte		RESERVATION_PARAMETER,
									SCSICmdField1Byte 		CONTROL					);
	
	
	bool		REPORT_KEY_V2 (	SCSITaskIdentifier			request,
								IOMemoryDescriptor *		dataBuffer,
								SCSICmdField4Byte			LOGICAL_BLOCK_ADDRESS,
								SCSICmdField1Byte			KEY_CLASS,
								SCSICmdField2Byte 			ALLOCATION_LENGTH,
								SCSICmdField2Bit 			AGID,
								SCSICmdField6Bit 			KEY_FORMAT,
								SCSICmdField1Byte 			CONTROL					);
	
	
	bool		SEND_KEY_V2 (	SCSITaskIdentifier			request,
								IOMemoryDescriptor *		dataBuffer,
								SCSICmdField1Byte			KEY_CLASS,
								SCSICmdField2Byte 			PARAMETER_LIST_LENGTH,
								SCSICmdField2Bit 			AGID,
								SCSICmdField6Bit 			KEY_FORMAT,
								SCSICmdField1Byte 			CONTROL					);
	
	
protected:
	
	
	void		SetPollingMode ( UInt32 newPollingMode );
	
	
public:
	
	
	/* 10.6.0 */
	
	IOReturn	RequestIdle ( void );
	
private:
	
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 	8 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 	9 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 10 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 11 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 12 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 13 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 14 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 15 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 16 );
    
};

#endif /* defined(KERNEL) && defined(__cplusplus) */

#endif /* _IOKIT_IO_SCSI_MULTIMEDIA_COMMANDS_DEVICE_H_ */
                                                           SCSICmds_INQUIRY_Definitions.h                                                                      0100644 0001750 0001750 00000100665 12567470660 037055  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/scsi                                                                  /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_CMDS_INQUIRY_H_
#define _IOKIT_SCSI_CMDS_INQUIRY_H_


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSI Inquiry Definitions
	@discussion
	This file contains all definitions for the data returned from
	the INQUIRY (0x12) command.
*/


/*!
 * @enum Payload sizes
 * @discussion
 * Definitions for sizes related to the INQUIRY data.
 * @constant kINQUIRY_StandardDataHeaderSize
 * INQUIRY data header size.
 * @constant kINQUIRY_MaximumDataSize
 * Maximum size for INQUIRY data.
*/
enum
{
	kINQUIRY_StandardDataHeaderSize			= 5,
	kINQUIRY_MaximumDataSize				= 255	
};


/*!
@enum INQUIRY field sizes
@discussion
Sizes for some of the inquiry data fields.
@constant kINQUIRY_VENDOR_IDENTIFICATION_Length
Size of VENDOR_IDENTIFICATION field.
@constant kINQUIRY_PRODUCT_IDENTIFICATION_Length
Size of PRODUCT_IDENTIFICATION field.
@constant kINQUIRY_PRODUCT_REVISION_LEVEL_Length
Size of PRODUCT_REVISION_LEVEL field.
*/
enum
{
	kINQUIRY_VENDOR_IDENTIFICATION_Length	= 8,
	kINQUIRY_PRODUCT_IDENTIFICATION_Length	= 16,
	kINQUIRY_PRODUCT_REVISION_LEVEL_Length	= 4
};


/*!
@struct SCSICmd_INQUIRY_StandardData
@discussion
This structure defines the format of the required standard data that is 
returned for the INQUIRY command.  This is the data that is required to
be returned from all devices.
*/
typedef struct SCSICmd_INQUIRY_StandardData
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		RMB;								// 7 = removable
	UInt8		VERSION;							// 7/6 = ISO/IEC, 5-3 = ECMA, 2-0 = ANSI.
	UInt8		RESPONSE_DATA_FORMAT;				// 7 = AERC, 6 = Obsolete, 5 = NormACA, 4 = HiSup 3-0 = Response data format. (SPC-3 obsoletes AERC)
													// If ANSI Version = 0, this is ATAPI and bits 7-4 = ATAPI version.
	UInt8		ADDITIONAL_LENGTH;					// Number of additional bytes available in inquiry data
	UInt8		SCCSReserved;						// SCC-2 device flag and reserved fields (SPC-3 adds PROTECT 3PC TPGS, and ACC)
	UInt8		flags1;								// First byte of support flags (See SPC-3 section 6.4.2)
	UInt8		flags2;								// Second byte of support flags (Byte 7) (See SPC-3 section 6.4.2)
	char		VENDOR_IDENTIFICATION[kINQUIRY_VENDOR_IDENTIFICATION_Length];
	char		PRODUCT_IDENTIFICATION[kINQUIRY_PRODUCT_IDENTIFICATION_Length];
	char		PRODUCT_REVISION_LEVEL[kINQUIRY_PRODUCT_REVISION_LEVEL_Length];
} SCSICmd_INQUIRY_StandardData;
typedef SCSICmd_INQUIRY_StandardData * SCSICmd_INQUIRY_StandardDataPtr;


/*!
@struct SCSICmd_INQUIRY_StandardDataAll
@discussion
This structure defines the all of the fields that can be returned in
repsonse to the INQUIRy request for the standard data.  There is no
requirement as to how much of the additional data must be returned by a device.
*/
typedef struct SCSICmd_INQUIRY_StandardDataAll
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		RMB;								// 7 = removable
	UInt8		VERSION;							// 7/6 = ISO/IEC, 5-3 = ECMA, 2-0 = ANSI.
	UInt8		RESPONSE_DATA_FORMAT;				// 7 = AERC, 6 = Obsolete, 5 = NormACA, 4 = HiSup 3-0 = Response data format.
													// If ANSI Version = 0, this is ATAPI and bits 7-4 = ATAPI version.
	UInt8		ADDITIONAL_LENGTH;					// Number of additional bytes available in inquiry data
	UInt8		SCCSReserved;						// SCC-2 device flag and reserved fields
	UInt8		flags1;								// First byte of support flags (Byte 6)
	UInt8		flags2;								// Second byte of support flags (Byte 7)
	char		VENDOR_IDENTIFICATION[kINQUIRY_VENDOR_IDENTIFICATION_Length];
	char		PRODUCT_IDENTIFICATION[kINQUIRY_PRODUCT_IDENTIFICATION_Length];
	char		PRODUCT_REVISION_LEVEL[kINQUIRY_PRODUCT_REVISION_LEVEL_Length];
	
	// Following is the optional data that may be returned by a device.
	UInt8		VendorSpecific1[20];
	UInt8		flags3;								// Third byte of support flags, mainly SPI-3 (Byte 56)
	UInt8		Reserved1;
	UInt16		VERSION_DESCRIPTOR[8];
	UInt8		Reserved2[22];
	UInt8		VendorSpecific2[160];
} SCSICmd_INQUIRY_StandardDataAll;


/*!
@enum Peripheral Qualifier
@discussion
Inquiry Peripheral Qualifier definitions
@constant kINQUIRY_PERIPHERAL_QUALIFIER_Connected
Peripheral Device is connected.
@constant kINQUIRY_PERIPHERAL_QUALIFIER_SupportedButNotConnected
Peripheral Device is supported, but not connected.
@constant kINQUIRY_PERIPHERAL_QUALIFIER_NotSupported
Peripheral Device is not supported.
@constant kINQUIRY_PERIPHERAL_QUALIFIER_Mask
Mask to use for PERIPHERAL_DEVICE_TYPE field.
*/
enum
{
	kINQUIRY_PERIPHERAL_QUALIFIER_Connected					= 0x00,
	kINQUIRY_PERIPHERAL_QUALIFIER_SupportedButNotConnected	= 0x20,
	kINQUIRY_PERIPHERAL_QUALIFIER_NotSupported				= 0x60,
	kINQUIRY_PERIPHERAL_QUALIFIER_Mask						= 0xE0
};


/*!
@enum Peripheral Device types
@discussion
Inquiry Peripheral Device type definitions
@constant kINQUIRY_PERIPHERAL_TYPE_DirectAccessSBCDevice
SBC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_SequentialAccessSSCDevice
Sequential Access (Tape) SSC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_PrinterSSCDevice
SSC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_ProcessorSPCDevice
SPC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_WriteOnceSBCDevice
SBC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_CDROM_MMCDevice
MMC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_ScannerSCSI2Device
SCSI2 Device.
@constant kINQUIRY_PERIPHERAL_TYPE_OpticalMemorySBCDevice
SBC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_MediumChangerSMCDevice
SMC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_CommunicationsSSCDevice
Comms SSC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_StorageArrayControllerSCC2Device
SCC2 Device.
@constant kINQUIRY_PERIPHERAL_TYPE_EnclosureServicesSESDevice
SES Device.
@constant kINQUIRY_PERIPHERAL_TYPE_SimplifiedDirectAccessRBCDevice
RBC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_OpticalCardReaderOCRWDevice
OCRW Device.
@constant kINQUIRY_PERIPHERAL_TYPE_ObjectBasedStorageDevice
OSD device.
@constant kINQUIRY_PERIPHERAL_TYPE_AutomationDriveInterface
Automation Drive Interface device.
@constant kINQUIRY_PERIPHERAL_TYPE_WellKnownLogicalUnit
Well known logical unit.
@constant kINQUIRY_PERIPHERAL_TYPE_UnknownOrNoDeviceType
Unknown or no device.
@constant kINQUIRY_PERIPHERAL_TYPE_Mask
Mask to use for PERIPHERAL_DEVICE_TYPE field.
*/
enum
{
	kINQUIRY_PERIPHERAL_TYPE_DirectAccessSBCDevice				= 0x00,
	kINQUIRY_PERIPHERAL_TYPE_SequentialAccessSSCDevice			= 0x01,
	kINQUIRY_PERIPHERAL_TYPE_PrinterSSCDevice					= 0x02,
	kINQUIRY_PERIPHERAL_TYPE_ProcessorSPCDevice					= 0x03,
	kINQUIRY_PERIPHERAL_TYPE_WriteOnceSBCDevice					= 0x04,
	kINQUIRY_PERIPHERAL_TYPE_CDROM_MMCDevice					= 0x05,
	kINQUIRY_PERIPHERAL_TYPE_ScannerSCSI2Device					= 0x06,
	kINQUIRY_PERIPHERAL_TYPE_OpticalMemorySBCDevice				= 0x07,
	kINQUIRY_PERIPHERAL_TYPE_MediumChangerSMCDevice				= 0x08,
	kINQUIRY_PERIPHERAL_TYPE_CommunicationsSSCDevice			= 0x09,
	/* 0x0A - 0x0B ASC IT8 Graphic Arts Prepress Devices */
	kINQUIRY_PERIPHERAL_TYPE_StorageArrayControllerSCC2Device	= 0x0C,
	kINQUIRY_PERIPHERAL_TYPE_EnclosureServicesSESDevice			= 0x0D,
	kINQUIRY_PERIPHERAL_TYPE_SimplifiedDirectAccessRBCDevice	= 0x0E,
	kINQUIRY_PERIPHERAL_TYPE_OpticalCardReaderOCRWDevice		= 0x0F,
	/* 0x10 - 0x1E Reserved Device Types */
	kINQUIRY_PERIPHERAL_TYPE_ObjectBasedStorageDevice			= 0x11,
	kINQUIRY_PERIPHERAL_TYPE_AutomationDriveInterface			= 0x12,
	kINQUIRY_PERIPHERAL_TYPE_WellKnownLogicalUnit				= 0x1E,
	kINQUIRY_PERIPHERAL_TYPE_UnknownOrNoDeviceType				= 0x1F,
	
	
	kINQUIRY_PERIPHERAL_TYPE_Mask								= 0x1F
};


/*!
@enum Removable Bit field definitions
@discussion
Inquiry Removable Bit field definitions
@constant kINQUIRY_PERIPHERAL_RMB_MediumFixed
Medium type is fixed disk.
@constant kINQUIRY_PERIPHERAL_RMB_MediumRemovable
Medium type is removable disk.
@constant kINQUIRY_PERIPHERAL_RMB_BitMask
Mask to use for RMB field.
*/
enum
{
	kINQUIRY_PERIPHERAL_RMB_MediumFixed 						= 0x00,
	kINQUIRY_PERIPHERAL_RMB_MediumRemovable 					= 0x80,
	kINQUIRY_PERIPHERAL_RMB_BitMask 							= 0x80
};


/*!
@enum Version field definitions
@discussion
Definitions for bits/masks in the INQUIRY Version field.
@constant kINQUIRY_ISO_IEC_VERSION_Mask
Mask for valid bits for ISO/IEC Version.
@constant kINQUIRY_ECMA_VERSION_Mask
Mask for valid bits for ECMA Version.
@constant kINQUIRY_ANSI_VERSION_NoClaimedConformance
No ANSI conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_SCSI_1_Compliant
SCSI-1 conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_SCSI_2_Compliant
SCSI-2 conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_SCSI_SPC_Compliant
SPC conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_SCSI_SPC_2_Compliant
SPC-2 conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_SCSI_SPC_3_Compliant
SPC-3 conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_Mask
Mask for valid bits for ANSI Version.
*/
enum
{
	kINQUIRY_ISO_IEC_VERSION_Mask								= 0xC0,
	
	kINQUIRY_ECMA_VERSION_Mask									= 0x38,
	
	kINQUIRY_ANSI_VERSION_NoClaimedConformance					= 0x00,
	kINQUIRY_ANSI_VERSION_SCSI_1_Compliant						= 0x01,
	kINQUIRY_ANSI_VERSION_SCSI_2_Compliant						= 0x02,
	kINQUIRY_ANSI_VERSION_SCSI_SPC_Compliant					= 0x03,
	kINQUIRY_ANSI_VERSION_SCSI_SPC_2_Compliant					= 0x04,
	kINQUIRY_ANSI_VERSION_SCSI_SPC_3_Compliant					= 0x05,
	kINQUIRY_ANSI_VERSION_Mask									= 0x07
};


/*!
@enum Response Data Format field definitions
@discussion
Definitions for bits/masks in the INQUIRY RESPONSE_DATA_FORMAT field.
@constant kINQUIRY_Byte3_HISUP_Bit
HISUP bit definition.
@constant kINQUIRY_Byte3_NORMACA_Bit
NORMACA bit definition.
@constant kINQUIRY_Byte3_AERC_Bit
AERC bit definition.
@constant kINQUIRY_RESPONSE_DATA_FORMAT_Mask
Mask for valid bits for RESPONSE_DATA_FORMAT.
@constant kINQUIRY_Byte3_HISUP_Mask
Mask to use to test the HISUP bit.
@constant kINQUIRY_Byte3_NORMACA_Mask
Mask to use to test the NORMACA bit.
@constant kINQUIRY_Byte3_AERC_Mask
Mask to use to test the AERC bit.
*/
enum
{
	// Bit definitions
	// Bits 0-3: RESPONSE DATA FORMAT
	kINQUIRY_Byte3_HISUP_Bit				= 4,
	kINQUIRY_Byte3_NORMACA_Bit				= 5,
	// Bit 6 is Obsolete
	kINQUIRY_Byte3_AERC_Bit					= 7,
	
	// Masks
	kINQUIRY_RESPONSE_DATA_FORMAT_Mask		= 0x0F, // Bits 0-3
	kINQUIRY_Byte3_HISUP_Mask				= (1 << kINQUIRY_Byte3_HISUP_Bit),
	kINQUIRY_Byte3_NORMACA_Mask				= (1 << kINQUIRY_Byte3_NORMACA_Bit),
	// Bit 6 is Obsolete
	kINQUIRY_Byte3_AERC_Mask				= (1 << kINQUIRY_Byte3_AERC_Bit)
};


/*!
@enum SCCS field definitions
@discussion
Definitions for bits/masks in the INQUIRY SCCSReserved field.
@constant kINQUIRY_Byte5_SCCS_Bit
SCCS bit definition.
@constant kINQUIRY_Byte5_ACC_Bit
ACC bit definition.
@constant kINQUIRY_Byte5_ExplicitTPGS_Bit
Explicit TPGS bit definition.
@constant kINQUIRY_Byte5_ImplicitTPGS_Bit
Implicit TPGS bit definition.
@constant kINQUIRY_Byte5_3PC_Bit
3PC bit definition.
@constant kINQUIRY_Byte5_PROTECT_Bit
PROTECT bit definition.
@constant kINQUIRY_Byte5_SCCS_Mask
Mask to use to test the SCCS bit.
@constant kINQUIRY_Byte5_ACC_Mask
Mask to use to test the ACC bit.
@constant kINQUIRY_Byte5_ExplicitTPGS_Mask
Mask to use for the Explicit TPGS bits.
@constant kINQUIRY_Byte5_ImplicitTPGS_Mask
Mask to use for the Implicit TPGS bits.
@constant kINQUIRY_Byte5_3PC_Mask
Mask to use to test the 3PC bit.
@constant kINQUIRY_Byte5_PROTECT_Mask
Mask to use to test the PROTECT bit.
*/
enum
{
	// Bit definitions
	kINQUIRY_Byte5_SCCS_Bit					= 7,
	kINQUIRY_Byte5_ACC_Bit					= 6,
	kINQUIRY_Byte5_ExplicitTPGS_Bit			= 5,
	kINQUIRY_Byte5_ImplicitTPGS_Bit			= 4,
	kINQUIRY_Byte5_3PC_Bit					= 3,
	// Bits 1-2: Reserved
	kINQUIRY_Byte5_PROTECT_Bit				= 0,
	
	// Masks
	kINQUIRY_Byte5_SCCS_Mask				= (1 << kINQUIRY_Byte5_SCCS_Bit),
	kINQUIRY_Byte5_ACC_Mask					= (1 << kINQUIRY_Byte5_ACC_Bit),
	kINQUIRY_Byte5_ExplicitTPGS_Mask		= (1 << kINQUIRY_Byte5_ExplicitTPGS_Bit),
	kINQUIRY_Byte5_ImplicitTPGS_Mask		= (1 << kINQUIRY_Byte5_ImplicitTPGS_Bit),

	kINQUIRY_Byte5_3PC_Mask					= (1 << kINQUIRY_Byte5_3PC_Bit),
	// Bits 1-2: Reserved
	kINQUIRY_Byte5_PROTECT_Mask				= (1 << kINQUIRY_Byte5_PROTECT_Bit)
};


/*!
@enum flags1 field definitions
@discussion
Definitions for bits/masks in the INQUIRY flags1 field.
@constant kINQUIRY_Byte6_ADDR16_Bit
ADDR16 bit definition.
@constant kINQUIRY_Byte6_MCHNGR_Bit
MCHNGR bit definition.
@constant kINQUIRY_Byte6_MULTIP_Bit
MULTIP bit definition.
@constant kINQUIRY_Byte6_VS_Bit
VS bit definition.
@constant kINQUIRY_Byte6_ENCSERV_Bit
ENCSERV bit definition.
@constant kINQUIRY_Byte6_BQUE_Bit
BQUE bit definition.
@constant kINQUIRY_Byte6_ADDR16_Mask
Mask to use to test the ADDR16 bit.
@constant kINQUIRY_Byte6_MCHNGR_Mask
Mask to use to test the MCHNGR bit.
@constant kINQUIRY_Byte6_MULTIP_Mask
Mask to use to test the MULTIP bit.
@constant kINQUIRY_Byte6_VS_Mask
Mask to use to test the VS bit.
@constant kINQUIRY_Byte6_ENCSERV_Mask
Mask to use to test the ENCSERV bit.
@constant kINQUIRY_Byte6_BQUE_Mask
Mask to use to test the BQUE bit.
*/
enum
{
	// Byte offset
	kINQUIRY_Byte6_Offset					= 6,
	
	// Bit definitions
	kINQUIRY_Byte6_ADDR16_Bit				= 0,	// SPI Specific
	// Bit 1 is Obsolete
	// Bit 2 is Obsolete
	kINQUIRY_Byte6_MCHNGR_Bit				= 3,
	kINQUIRY_Byte6_MULTIP_Bit				= 4,
	kINQUIRY_Byte6_VS_Bit					= 5,	
	kINQUIRY_Byte6_ENCSERV_Bit				= 6,	
	kINQUIRY_Byte6_BQUE_Bit					= 7,	

	// Masks
	kINQUIRY_Byte6_ADDR16_Mask				= (1 << kINQUIRY_Byte6_ADDR16_Bit),	// SPI Specific
	// Bit 1 is Obsolete
	// Bit 2 is Obsolete
	kINQUIRY_Byte6_MCHNGR_Mask				= (1 << kINQUIRY_Byte6_MCHNGR_Bit),
	kINQUIRY_Byte6_MULTIP_Mask				= (1 << kINQUIRY_Byte6_MULTIP_Bit),
	kINQUIRY_Byte6_VS_Mask					= (1 << kINQUIRY_Byte6_VS_Bit),
	kINQUIRY_Byte6_ENCSERV_Mask				= (1 << kINQUIRY_Byte6_ENCSERV_Bit),
	kINQUIRY_Byte6_BQUE_Mask				= (1 << kINQUIRY_Byte6_BQUE_Bit)
};


/*!
@enum flags2 field definitions
@discussion
Definitions for bits/masks in the INQUIRY flags2 field.
@constant kINQUIRY_Byte7_VS_Bit
VS bit definition.
@constant kINQUIRY_Byte7_CMDQUE_Bit
CMDQUE bit definition.
@constant kINQUIRY_Byte7_TRANDIS_Bit
TRANDIS bit definition.
@constant kINQUIRY_Byte7_LINKED_Bit
LINKED bit definition.
@constant kINQUIRY_Byte7_SYNC_Bit
SYNC bit definition.
@constant kINQUIRY_Byte7_WBUS16_Bit
WBUS16 bit definition.
@constant kINQUIRY_Byte7_RELADR_Bit
RELADR bit definition.
@constant kINQUIRY_Byte7_VS_Mask
Mask to use to test the VS bit.
@constant kINQUIRY_Byte7_CMDQUE_Mask
Mask to use to test the CMDQUE bit.
@constant kINQUIRY_Byte7_TRANDIS_Mask
Mask to use to test the TRANDIS bit.
@constant kINQUIRY_Byte7_LINKED_Mask
Mask to use to test the LINKED bit.
@constant kINQUIRY_Byte7_SYNC_Mask
Mask to use to test the SYNC bit.
@constant kINQUIRY_Byte7_WBUS16_Mask
Mask to use to test the WBUS16 bit.
@constant kINQUIRY_Byte7_RELADR_Mask
Mask to use to test the RELADR bit.
*/
enum
{
	// Byte offset
	kINQUIRY_Byte7_Offset					= 7,
	
	// Bit definitions
	kINQUIRY_Byte7_VS_Bit					= 0,
	kINQUIRY_Byte7_CMDQUE_Bit				= 1,
	kINQUIRY_Byte7_TRANDIS_Bit				= 2,	// SPI Specific
	kINQUIRY_Byte7_LINKED_Bit				= 3,
	kINQUIRY_Byte7_SYNC_Bit					= 4,	// SPI Specific
	kINQUIRY_Byte7_WBUS16_Bit				= 5,	// SPI Specific
	// Bit 6 is Obsolete
	kINQUIRY_Byte7_RELADR_Bit				= 7,
	
	// Masks
	kINQUIRY_Byte7_VS_Mask					= (1 << kINQUIRY_Byte7_VS_Bit),
	kINQUIRY_Byte7_CMDQUE_Mask				= (1 << kINQUIRY_Byte7_CMDQUE_Bit),
	kINQUIRY_Byte7_TRANDIS_Mask				= (1 << kINQUIRY_Byte7_TRANDIS_Bit),// SPI Specific
	kINQUIRY_Byte7_LINKED_Mask				= (1 << kINQUIRY_Byte7_LINKED_Bit),
	kINQUIRY_Byte7_SYNC_Mask				= (1 << kINQUIRY_Byte7_SYNC_Bit),	// SPI Specific
	kINQUIRY_Byte7_WBUS16_Mask				= (1 << kINQUIRY_Byte7_WBUS16_Bit),	// SPI Specific
	// Bit 6 is Obsolete
	kINQUIRY_Byte7_RELADR_Mask				= (1 << kINQUIRY_Byte7_RELADR_Bit)
};


/*!
@enum Byte 56 features field definitions
@discussion
Definitions for bits/masks in the INQUIRY Byte 56 field.
Inquiry Byte 56 features (for devices that report an ANSI VERSION of
kINQUIRY_ANSI_VERSION_SCSI_SPC_Compliant or later).
These are SPI-3 Specific.
@constant kINQUIRY_Byte56_IUS_Bit
IUS bit definition.
@constant kINQUIRY_Byte56_QAS_Bit
QAS bit definition.
@constant kINQUIRY_Byte56_IUS_Mask
Mask to use to test the IUS bit.
@constant kINQUIRY_Byte56_QAS_Mask
Mask to use to test the QAS bit.
@constant kINQUIRY_Byte56_CLOCKING_Mask
Mask to use to test CLOCKING bits.
@constant kINQUIRY_Byte56_CLOCKING_ONLY_ST
Single-transition clocking only.
@constant kINQUIRY_Byte56_CLOCKING_ONLY_DT
Double-transition clocking only.
@constant kINQUIRY_Byte56_CLOCKING_ST_AND_DT
Single-transition and double-transition clocking.
*/
enum
{
	// Byte offset
	kINQUIRY_Byte56_Offset					= 56,

	// Bit definitions
	kINQUIRY_Byte56_IUS_Bit					= 0,
	kINQUIRY_Byte56_QAS_Bit					= 1,
	// Bits 2 and 3 are the CLOCKING bits
	// All other bits are reserved
	
	kINQUIRY_Byte56_IUS_Mask				= (1 << kINQUIRY_Byte56_IUS_Bit),
	kINQUIRY_Byte56_QAS_Mask				= (1 << kINQUIRY_Byte56_QAS_Bit),
	kINQUIRY_Byte56_CLOCKING_Mask			= 0x0C,

	// Definitions for the CLOCKING bits
	kINQUIRY_Byte56_CLOCKING_ONLY_ST		= 0x00,
	kINQUIRY_Byte56_CLOCKING_ONLY_DT		= 0x04,
	// kINQUIRY_Byte56_CLOCKING_RESERVED	= 0x08,
	kINQUIRY_Byte56_CLOCKING_ST_AND_DT		= 0x0C
};


/*!
@define kINQUIRY_VERSION_DESCRIPTOR_MaxCount
Maximum number of INQUIRY version descriptors supported.
*/
#define	kINQUIRY_VERSION_DESCRIPTOR_MaxCount		8


/*!
@enum kINQUIRY_VERSION_DESCRIPTOR_SAT
SAT specification version descriptor.
*/
enum
{
	kINQUIRY_VERSION_DESCRIPTOR_SAT					= 0x1EA0
};

/*!
 @enum kINQUIRY_VERSION_DESCRIPTOR_NVME
 NVMe specification version descriptor.
 */
enum
{
	kINQUIRY_VERSION_DESCRIPTOR_NVME				= 0x8080
};


/*
IORegistry property names for information derived from the Inquiry data.
The Peripheral Device Type is the only property that the 
generic Logical Unit Drivers will use to match. These properties are
listed in order of matching priority. First is the Peripheral Device Type.
Second is the Vendor Identification. Third is the Product Identification.
Last is the Product Revision Level. To match a particular product, you would
specify the Peripheral Device Type, Vendor Identification, and Product
Identification. To restrict the match to a particular firmware revision, you
would add the Product Revision Level. To not match on a particular product,
but on a particular vendor's products, you would only include the 
Peripheral Device Type and the Vendor Identification.
*/

/*!
@define kIOPropertySCSIPeripheralDeviceType
SCSI Peripheral Device Type as reported in the INQUIRY data.
*/
#define kIOPropertySCSIPeripheralDeviceType			"Peripheral Device Type"

/*!
@define kIOPropertySCSIPeripheralDeviceTypeSize
Size of the kIOPropertySCSIPeripheralDeviceType key.
*/
#define kIOPropertySCSIPeripheralDeviceTypeSize		8

/*!
@define kIOPropertyTPGSInfo
TPGS Info as reported in the INQUIRY data.
*/
#define kIOPropertyTPGSInfo							"TPGS Information"

/*!
@define kIOPropertyHiSup
Hierarchical LUN Support as reported in the INQUIRY data.
*/
#define kIOPropertyHiSup							"Hierarchical LUN Support"

/*!
@define kIOPropertyTPGSInfoSize
Size of the kIOPropertyTPGSInfo key.
*/
#define kIOPropertyTPGSInfoSize						8

/* These properties are listed in order of matching priority */

/*!
@define kIOPropertySCSIVendorIdentification
Vendor ID as reported in the INQUIRY data. Additional space characters (0x20)
are truncated.
*/
#define kIOPropertySCSIVendorIdentification			"Vendor Identification"

/*!
@define kIOPropertySCSIProductIdentification
Product ID as reported in the INQUIRY data. Additional space characters (0x20)
are truncated.
*/
#define kIOPropertySCSIProductIdentification		"Product Identification"

/*!
@define kIOPropertySCSIProductRevisionLevel
Product Revision Level as reported in the INQUIRY data.
*/
#define kIOPropertySCSIProductRevisionLevel			"Product Revision Level"


/*!
@enum INQUIRY Page Codes
@discussion INQUIRY Page Codes to be used when EVPD is set in the
INQUIRY command.
@constant kINQUIRY_Page00_PageCode
Page Code 00h.
@constant kINQUIRY_Page80_PageCode
Page Code 80h.
@constant kINQUIRY_Page83_PageCode
Page Code 83h.
@constant kINQUIRY_Page89_PageCode
Page Code 89h.
*/
enum
{
	kINQUIRY_Page00_PageCode				= 0x00,
	kINQUIRY_Page80_PageCode				= 0x80,
	kINQUIRY_Page83_PageCode				= 0x83,
	kINQUIRY_Page89_PageCode				= 0x89,
	kINQUIRY_PageB1_PageCode				= 0xB1
};	


/*!
@struct SCSICmd_INQUIRY_Page00_Header
@discussion INQUIRY Page 00h Header.
*/
typedef struct SCSICmd_INQUIRY_Page00_Header
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 00h
	UInt8		RESERVED;							// reserved field
	UInt8		PAGE_LENGTH;						// n-3 bytes
} SCSICmd_INQUIRY_Page00_Header;


/*!
@struct SCSICmd_INQUIRY_Page00_Header_SPC_16
@discussion INQUIRY Page 00h Header.
*/
typedef struct SCSICmd_INQUIRY_Page00_Header_SPC_16
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 00h
	UInt16		PAGE_LENGTH;						// n-3 bytes
} SCSICmd_INQUIRY_Page00_Header_SPC_16;

/*!
@struct SCSICmd_INQUIRY_Page80_Header
@discussion INQUIRY Page 80h Header.
*/
typedef struct SCSICmd_INQUIRY_Page80_Header
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 80h
	UInt8		RESERVED;							// reserved field
	UInt8		PAGE_LENGTH;						// n-3 bytes
	UInt8		PRODUCT_SERIAL_NUMBER;				// 4-n
} SCSICmd_INQUIRY_Page80_Header;


/*!
@struct SCSICmd_INQUIRY_Page80_Header_SPC_16
@discussion INQUIRY Page 80h Header with 16 bytes INQUIRY Command.
*/
typedef struct SCSICmd_INQUIRY_Page80_Header_SPC_16
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;					// Must be equal to 80h
	UInt16		PAGE_LENGTH;					// n-3 bytes
	UInt8		PRODUCT_SERIAL_NUMBER;				// 4-n
} SCSICmd_INQUIRY_Page80_Header_SPC_16;


/*!
@define kIOPropertySCSIINQUIRYUnitSerialNumber
Key that describes the INQUIRY Unit Serial Number in the IORegistry.
*/
#define kIOPropertySCSIINQUIRYUnitSerialNumber		"INQUIRY Unit Serial Number"


/*!
@struct SCSICmd_INQUIRY_Page83_Header
@discussion INQUIRY Page 83h Header.
*/
typedef struct SCSICmd_INQUIRY_Page83_Header
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 83h
	UInt8		RESERVED;							// reserved field
	UInt8		PAGE_LENGTH;						// n-3 bytes
} SCSICmd_INQUIRY_Page83_Header;


/*!
@struct SCSICmd_INQUIRY_Page83_Header_SPC_16
@discussion INQUIRY Page 83h Header used with the 16 byte INQUIRY command.
*/
typedef struct SCSICmd_INQUIRY_Page83_Header_SPC_16
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 83h
	UInt16		PAGE_LENGTH;						// n-3 bytes
} SCSICmd_INQUIRY_Page83_Header_SPC_16;


/*!
@struct SCSICmd_INQUIRY_Page83_Identification_Descriptor
@discussion INQUIRY Page 83h Identification Descriptor.
*/
typedef struct SCSICmd_INQUIRY_Page83_Identification_Descriptor
{
	UInt8		CODE_SET;							// 7-4 = Protocol Identifier. 3-0 = Code Set
	UInt8		IDENTIFIER_TYPE;					// 7 = PIV 5-4 = ASSOCIATION 3-0 = Identifier
	UInt8		RESERVED;							
	UInt8		IDENTIFIER_LENGTH;
	UInt8		IDENTIFIER;
} SCSICmd_INQUIRY_Page83_Identification_Descriptor;


/*!
@enum INQUIRY Page 83h Code Set
@discussion
Definitions for the Code Set field.
@constant kINQUIRY_Page83_CodeSetBinaryData
The identifier contains binary data.
@constant kINQUIRY_Page83_CodeSetASCIIData
The identifier contains ASCII data.
@constant kINQUIRY_Page83_CodeSetUTF8Data
The identifier contains UTF-8 data.
*/
enum
{
	kINQUIRY_Page83_CodeSetReserved			= 0x0,
	kINQUIRY_Page83_CodeSetBinaryData		= 0x1,
	kINQUIRY_Page83_CodeSetASCIIData		= 0x2,
	kINQUIRY_Page83_CodeSetUTF8Data			= 0x3,
	// 0x4 - 0xF reserved
	kINQUIRY_Page83_CodeSetMask				= 0xF
};	


/*!
@enum INQUIRY Page 83h Association
@discussion
Definitions for the Association field.
@constant kINQUIRY_Page83_AssociationLogicalUnit
Association of the identifier is with the logical unit.
@constant kINQUIRY_Page83_AssociationDevice
Association of the identifier is with the device (same as logical unit in SPC-2).
@constant kINQUIRY_Page83_AssociationTargetPort
Association of the identifier is with the target port.
@constant kINQUIRY_Page83_AssociationTargetDevice
Association of the identifier is with the target device (i.e. all ports).
@constant kINQUIRY_Page83_AssociationMask
Mask to use to determine association.
*/
enum
{	
	// SPC-3 - Association is changed to be specific to 
	// Logical Units
	kINQUIRY_Page83_AssociationLogicalUnit	= 0x00,
	
	// Backwards compatibility for SPC-2
	kINQUIRY_Page83_AssociationDevice 		= kINQUIRY_Page83_AssociationLogicalUnit,
	
	// Association is related to a Target Port
	kINQUIRY_Page83_AssociationTargetPort	= 0x10,
	
	// SPC-3 - Added as specific association to
	// a Target device.
	kINQUIRY_Page83_AssociationTargetDevice	= 0x20,
	
	kINQUIRY_Page83_AssociationMask			= 0x30,
	kINQUIRY_Page83_AssociationShift		= 4
};	
		

/*!
@enum INQUIRY Page 83h Identifier Type
@discussion
Definitions for the Identifier Type field.
@constant kINQUIRY_Page83_IdentifierTypeVendorSpecific
Vendor Specific Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeVendorID
Vendor Specific Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeIEEE_EUI64
EUI-64 Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeNAAIdentifier
NAA Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeRelativePortIdentifier
Relative Target Port Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeTargetPortGroup
Target Port Group Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeLogicalUnitGroup
Logical Unit Group Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeMD5LogicalUnitIdentifier
MD5 Logical Unit Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeSCSINameString
SCSI Name String Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeMask
Mask to use to determine association.
@constant kINQUIRY_Page83_ProtocolIdentifierValidBit
PIV Bit definition.
@constant kINQUIRY_Page83_ProtocolIdentifierValidMask
Mask to use to determine if PIV is set.
*/
enum
{
	kINQUIRY_Page83_IdentifierTypeVendorSpecific			= 0,
	kINQUIRY_Page83_IdentifierTypeVendorID					= 1,
	kINQUIRY_Page83_IdentifierTypeIEEE_EUI64				= 2,
	kINQUIRY_Page83_IdentifierTypeNAAIdentifier				= 3,
	kINQUIRY_Page83_IdentifierTypeRelativePortIdentifier	= 4,
	kINQUIRY_Page83_IdentifierTypeTargetPortGroup			= 5,
	kINQUIRY_Page83_IdentifierTypeLogicalUnitGroup			= 6,
	kINQUIRY_Page83_IdentifierTypeMD5LogicalUnitIdentifier  = 7,
	kINQUIRY_Page83_IdentifierTypeSCSINameString			= 8,
	// 0x9 - 0xF Reserved
	
	kINQUIRY_Page83_IdentifierTypeMask						= 0xF,
	
	kINQUIRY_Page83_ProtocolIdentifierValidBit				= 7,
	kINQUIRY_Page83_ProtocolIdentifierValidMask				= (1 << kINQUIRY_Page83_ProtocolIdentifierValidBit)
	
};	

// Backwards compatibility
#define kINQUIRY_Page83_IdentifierTypeFCNameIdentifier		kINQUIRY_Page83_IdentifierTypeNAAIdentifier
#define kINQUIRY_Page83_IdentifierTypeUndefined				kINQUIRY_Page83_IdentifierTypeVendorSpecific


/*!
@enum Protocol Identifier values
@discussion
Definitions for the protocol identifier values.
@constant kSCSIProtocolIdentifier_FibreChannel
FibreChannel Protocol Identifier.
@constant kSCSIProtocolIdentifier_ParallelSCSI
Parallel SCSI Protocol Identifier.
@constant kSCSIProtocolIdentifier_SSA
SSA Protocol Identifier.
@constant kSCSIProtocolIdentifier_FireWire
FireWire (IEEE-1394) Protocol Identifier.
@constant kSCSIProtocolIdentifier_RDMA
RDMA Protocol Identifier.
@constant kSCSIProtocolIdentifier_iSCSI
iSCSI Protocol Identifier.
@constant kSCSIProtocolIdentifier_SAS
SAS Protocol Identifier.
@constant kSCSIProtocolIdentifier_ADT
ADT Protocol Identifier.
@constant kSCSIProtocolIdentifier_ATAPI
ATAPI Protocol Identifier.
@constant kSCSIProtocolIdentifier_None
No Protocol Identifier.
*/
enum
{
	kSCSIProtocolIdentifier_FibreChannel					= 0,
	kSCSIProtocolIdentifier_ParallelSCSI					= 1,
	kSCSIProtocolIdentifier_SSA								= 2,
	kSCSIProtocolIdentifier_FireWire						= 3,
	kSCSIProtocolIdentifier_RDMA							= 4,
	kSCSIProtocolIdentifier_iSCSI							= 5,
	kSCSIProtocolIdentifier_SAS								= 6,
	kSCSIProtocolIdentifier_ADT								= 7,
	kSCSIProtocolIdentifier_ATAPI							= 8,
	// 0x9-0xE Reserved
	kSCSIProtocolIdentifier_None							= 0xF
};


/*!
@define kIOPropertySCSIINQUIRYDeviceIdentification
Device Identification key.
*/
#define kIOPropertySCSIINQUIRYDeviceIdentification		"INQUIRY Device Identification"


/*!
@define kIOPropertySCSIINQUIRYDeviceIdCodeSet
Code Set type key.
*/
#define kIOPropertySCSIINQUIRYDeviceIdCodeSet			"Code Set"


/*!
@define kIOPropertySCSIINQUIRYDeviceIdType
Identifier Type key.
*/
#define kIOPropertySCSIINQUIRYDeviceIdType				"Identifier Type"


/*!
@define kIOPropertySCSIINQUIRYDeviceIdAssociation
Association key.
*/
#define kIOPropertySCSIINQUIRYDeviceIdAssociation		"Association"


/*!
@define kIOPropertySCSIINQUIRYDeviceIdentifier
Identifier key (data or string).
*/
#define kIOPropertySCSIINQUIRYDeviceIdentifier			"Identifier"
		



/*!
@struct SCSICmd_INQUIRY_Page83_RelativeTargetPort_Identifier
@discussion INQUIRY Page 83h Relative Target Port Identifier.
*/
typedef struct SCSICmd_INQUIRY_Page83_RelativeTargetPort_Identifier
{
	UInt16		OBSOLETE;
	UInt16		RELATIVE_TARGET_PORT_IDENTIFIER;
} SCSICmd_INQUIRY_Page83_RelativeTargetPort_Identifier;


/*!
@struct SCSICmd_INQUIRY_Page83_TargetPortGroup_Identifier
@discussion INQUIRY Page 83h Target Port Group Identifier.
*/
typedef struct SCSICmd_INQUIRY_Page83_TargetPortGroup_Identifier
{
	UInt16		RESERVED;
	UInt16		TARGET_PORT_GROUP;
} SCSICmd_INQUIRY_Page83_TargetPortGroup_Identifier;


/*!
@struct SCSICmd_INQUIRY_Page83_LogicalUnitGroup_Identifier
@discussion INQUIRY Page 83h Logical Unit Group Identifier.
*/
typedef struct SCSICmd_INQUIRY_Page83_LogicalUnitGroup_Identifier
{
	UInt16		RESERVED;
	UInt16		LOGICAL_UNIT_GROUP;
} SCSICmd_INQUIRY_Page83_LogicalUnitGroup_Identifier;


/*!
@struct SCSICmd_INQUIRY_Page89_Data
@discussion INQUIRY Page 89h data as defined in the SAT 1.0
specification. This section contians all structures and
definitions used by the INQUIRY command in response to a request
for page 89h - ATA information VPD Page.
*/
typedef struct SCSICmd_INQUIRY_Page89_Data
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 89h
	UInt16		PAGE_LENGTH;						// Must be equal to 238h
	UInt32		Reserved;
	UInt8		SAT_VENDOR_IDENTIFICATION[kINQUIRY_VENDOR_IDENTIFICATION_Length];
	UInt8		SAT_PRODUCT_IDENTIFICATION[kINQUIRY_PRODUCT_IDENTIFICATION_Length];
	UInt8		SAT_PRODUCT_REVISION_LEVEL[kINQUIRY_PRODUCT_REVISION_LEVEL_Length];
	UInt8		ATA_DEVICE_SIGNATURE[20];
	UInt8		COMMAND_CODE;
	UInt8		Reserved2[3];
	UInt8		IDENTIFY_DATA[512];
} SCSICmd_INQUIRY_Page89_Data;


/*!
@struct SCSICmd_INQUIRY_PageB1_Data
@discussion INQUIRY Page B1h data as defined in the SBC 
specification. This section contians all structures and
definitions used by the INQUIRY command in response to a request
for page B1h - Block Device Characteristics VPD Page.
*/
typedef struct SCSICmd_INQUIRY_PageB1_Data
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to B1h
	UInt8		Reserved;
	UInt8		PAGE_LENGTH;						// Must be equal to 3Ch
	UInt16		MEDIUM_ROTATION_RATE;	
	UInt8		Reserved2[58];
} SCSICmd_INQUIRY_PageB1_Data;

enum
{
	kINQUIRY_PageB1_Page_Length	= 0x3C
};


/*!
@define kIOPropertySATVendorIdentification
Vendor Identification of the SATL.
*/
#define kIOPropertySATVendorIdentification			"SAT Vendor Identification"


/*!
@define kIOPropertySATProductIdentification
Product Identification of the SATL.
*/
#define kIOPropertySATProductIdentification			"SAT Product Identification"


/*!
@define kIOPropertySATProductRevisonLevel
Product Revision Level of the SATL.
*/
#define kIOPropertySATProductRevisonLevel			"SAT Product Revision Level"


#endif	/* _IOKIT_SCSI_CMDS_INQUIRY_H_ */
                                                                           SCSICmds_MODE_Definitions.h                                                                         0100644 0001750 0001750 00000034741 12567470660 036442  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/scsi                                                                  /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_CMDS_MODE_DEFINITIONS_H_
#define _IOKIT_SCSI_CMDS_MODE_DEFINITIONS_H_


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSI Request Sense Definitions
	@discussion
	This file contains all definitions for the data returned from
	the MODE_SENSE_6 and MODE_SENSE_10 commands.
*/

#pragma pack(1)

/*!
@struct SPCModeParameterHeader6
@discussion
Mode Parameter Header for the MODE_SENSE_6 command.
*/
typedef struct SPCModeParameterHeader6
{
	UInt8		MODE_DATA_LENGTH;
	UInt8		MEDIUM_TYPE;
	UInt8		DEVICE_SPECIFIC_PARAMETER;
	UInt8		BLOCK_DESCRIPTOR_LENGTH;
} SPCModeParameterHeader6;


/*!
@struct SPCModeParameterHeader10
@discussion
Mode Parameter Header for the MODE_SENSE_10 command.
*/
typedef struct SPCModeParameterHeader10
{
	UInt16		MODE_DATA_LENGTH;
	UInt8		MEDIUM_TYPE;
	UInt8		DEVICE_SPECIFIC_PARAMETER;
	UInt8		LONGLBA;
	UInt8		RESERVED;
	UInt16		BLOCK_DESCRIPTOR_LENGTH;
} SPCModeParameterHeader10;


/*!
@enum Long LBA Bitfield definitions
@discussion
Long LBA Bitfield definitions for Mode Parameter Header
for MODE_SENSE_10 command.
@constant kModeSenseParameterHeader10_LongLBABit
Bit to indicate Long LBA block descriptors follow.
@constant kModeSenseParameterHeader10_LongLBAMask
Mask to test for kModeSenseParameterHeader10_LongLBABit.
*/
enum
{
	kModeSenseParameterHeader10_LongLBABit	=  0,
	kModeSenseParameterHeader10_LongLBAMask	=  (1 << kModeSenseParameterHeader10_LongLBABit),
};


/*!
@enum Device Specific Parameter Bitfield definitions
@discussion
SBC definitions for Device Specific Parameter in the
Mode Sense Header Block.
@constant kModeSenseSBCDeviceSpecific_DPOFUABit
Bit to indicate DPO and FUA bits are accepted by the device server.
@constant kModeSenseSBCDeviceSpecific_WriteProtectBit
Bit to indicate medium is write protected.
@constant kModeSenseSBCDeviceSpecific_DPOFUAMask
Mask to test for kModeSenseSBCDeviceSpecific_DPOFUABit.
@constant kModeSenseSBCDeviceSpecific_WriteProtectMask
Mask to test for kModeSenseSBCDeviceSpecific_WriteProtectBit.
*/
enum
{
	kModeSenseSBCDeviceSpecific_DPOFUABit	 		=  4,
	kModeSenseSBCDeviceSpecific_WriteProtectBit	 	=  7,
	kModeSenseSBCDeviceSpecific_DPOFUAMask 			=  (1 << kModeSenseSBCDeviceSpecific_DPOFUABit),
	kModeSenseSBCDeviceSpecific_WriteProtectMask 	=  (1 << kModeSenseSBCDeviceSpecific_WriteProtectBit)
};


/*!
@struct ModeParameterBlockDescriptor
@discussion
General mode parameter block descriptor.
*/
typedef struct ModeParameterBlockDescriptor
{
	UInt8		DENSITY_CODE;
	UInt8		NUMBER_OF_BLOCKS[3];
	UInt8		RESERVED;
	UInt8		BLOCK_LENGTH[3];
} ModeParameterBlockDescriptor;


/*!
@struct DASDModeParameterBlockDescriptor
@discussion
Direct Access Storage Device mode parameter block descriptor.
*/
typedef struct DASDModeParameterBlockDescriptor
{
	UInt32		NUMBER_OF_BLOCKS;
	UInt8		DENSITY_CODE;
	UInt8		BLOCK_LENGTH[3];
} DASDModeParameterBlockDescriptor;


/*!
@struct LongLBAModeParameterBlockDescriptor
@discussion
Long LBA mode parameter block descriptor.
*/
typedef struct LongLBAModeParameterBlockDescriptor
{
	UInt64		NUMBER_OF_BLOCKS;
	UInt8		DENSITY_CODE;
	UInt8		RESERVED[3];
	UInt32		BLOCK_LENGTH;
} LongLBAModeParameterBlockDescriptor;


/*!
@struct ModePageFormatHeader
@discussion
Mode Page format header.
*/
typedef struct ModePageFormatHeader
{
	UInt8		PS_PAGE_CODE;
	UInt8		PAGE_LENGTH;
} ModePageFormatHeader;


/*!
@enum Mode Page Format bit definitions
@discussion
Mode Page Format bit definitions.
@constant kModePageFormat_PS_Bit
Bit to indicate Parameters Saveable.
@constant kModePageFormat_PAGE_CODE_Mask
Mask to obtain the PAGE_CODE from the PS_PAGE_CODE field.
@constant kModePageFormat_PS_Mask
Mask to test for kModePageFormat_PS_Bit.
*/
enum
{
	kModePageFormat_PS_Bit			= 7,
	
	kModePageFormat_PAGE_CODE_Mask	= 0x3F,
	kModePageFormat_PS_Mask			= (1 << kModePageFormat_PS_Bit)
};


#if 0
#pragma mark -
#pragma mark SPC Mode Pages
#pragma mark -
#endif


/*!
@enum SPC Mode Pages
@discussion
SPC Mode Page definitions.
@constant kSPCModePagePowerConditionCode
Power Conditions Mode Page value.
@constant kSPCModePageAllPagesCode
All Mode Pages value.
*/
enum
{
	kSPCModePagePowerConditionCode		= 0x1A,
	kSPCModePageAllPagesCode			= 0x3F
};

/*!
@struct SPCModePagePowerCondition
@discussion
Power Conditions Mode Page (PAGE CODE 0x1A) format.
*/
typedef struct SPCModePagePowerCondition
{
	ModePageFormatHeader	header;
	UInt8					RESERVED;
	UInt8					IDLE_STANDBY;
	UInt32					IDLE_CONDITION_TIMER;
	UInt32					STANDBY_CONDITION_TIMER;
} SPCModePagePowerCondition;


#if 0
#pragma mark -
#pragma mark 0x00 SBC Direct Access Mode Pages
#pragma mark -
#endif


/*!
@enum SBC Mode Pages
@discussion
SBC Mode Page definitions.
@constant kSBCModePageFormatDeviceCode
Format Device Mode Page value.
@constant kSBCModePageRigidDiskGeometryCode
Rigid Disk Geometry Page value.
@constant kSBCModePageFlexibleDiskCode
Flexible Disk Page value.
@constant kSBCModePageCachingCode
Caching Page value.
*/
enum
{
	kSBCModePageFormatDeviceCode		= 0x03,
	kSBCModePageRigidDiskGeometryCode	= 0x04,
	kSBCModePageFlexibleDiskCode		= 0x05,
	kSBCModePageCachingCode				= 0x08
};


/*!
@struct SBCModePageFormatDevice
@discussion
Format Device Mode Page (PAGE CODE 0x03) format.
*/
typedef struct SBCModePageFormatDevice
{
	ModePageFormatHeader	header;
	UInt16					TRACKS_PER_ZONE;
	UInt16					ALTERNATE_SECTORS_PER_ZONE;
	UInt16					ALTERNATE_TRACKS_PER_ZONE;
	UInt16					ALTERNATE_TRACKS_PER_LOGICAL_UNIT;
	UInt16					SECTORS_PER_TRACK;
	UInt16					DATA_BYTES_PER_PHYSICAL_SECTOR;
	UInt16					INTERLEAVE;
	UInt16					TRACK_SKEW_FACTOR;
	UInt16					CYLINDER_SKEW_FACTOR;
	UInt8					SSEC_HSEC_RMB_SURF;
	UInt8					RESERVED[3];
} SBCModePageFormatDevice;


/*!
@struct SBCModePageRigidDiskGeometry
@discussion
Rigid Disk Geometry Mode Page (PAGE CODE 0x04) format.
*/
typedef struct SBCModePageRigidDiskGeometry
{
	ModePageFormatHeader	header;
	UInt8					NUMBER_OF_CYLINDERS[3];
	UInt8					NUMBER_OF_HEADS;
	UInt8					STARTING_CYLINDER_WRITE_PRECOMPENSATION[3];
	UInt8					STARTING_CYLINDER_REDUCED_WRITE_CURRENT[3];
	UInt16					DEVICE_STEP_RATE;
	UInt8					LANDING_ZONE_CYLINDER[3];
	UInt8					RPL;
	UInt8					ROTATIONAL_OFFSET;
	UInt8					RESERVED;
	UInt16					MEDIUM_ROTATION_RATE;
	UInt8					RESERVED1[2];
} SBCModePageRigidDiskGeometry;


/*!
@enum Rigid Disk Geometry bitfields
@discussion
Bit field masks for Rigid Disk Geometry structure fields.
@constant kSBCModePageRigidDiskGeometry_RPL_Mask
Mask for use with the RPL field.
*/
enum
{
	kSBCModePageRigidDiskGeometry_RPL_Mask	= 0x03
};


/*!
@struct SBCModePageFlexibleDisk
@discussion
Flexible Disk Mode Page (PAGE CODE 0x05) format.
*/
typedef struct SBCModePageFlexibleDisk
{
	ModePageFormatHeader	header;
	UInt16					TRANSFER_RATE;
	UInt8					NUMBER_OF_HEADS;
	UInt8					SECTORS_PER_TRACK;
	UInt16					DATA_BYTES_PER_SECTOR;
	UInt16					NUMBER_OF_CYLINDERS;
	UInt16					STARTING_CYLINDER_WRITE_PRECOMPENSATION;
	UInt16					STARTING_CYLINDER_REDUCED_WRITE_CURRENT;
	UInt16					DEVICE_STEP_RATE;
	UInt8					DEVICE_STEP_PULSE_WIDTH;
	UInt16					HEAD_SETTLE_DELAY;
	UInt8					MOTOR_ON_DELAY;
	UInt8					MOTOR_OFF_DELAY;
	UInt8					TRDY_SSN_MO;
	UInt8					SPC;
	UInt8					WRITE_COMPENSATION;
	UInt8					HEAD_LOAD_DELAY;
	UInt8					HEAD_UNLOAD_DELAY;
	UInt8					PIN_34_PIN_2;
	UInt8					PIN_4_PIN_1;
	UInt16					MEDIUM_ROTATION_RATE;
	UInt8					RESERVED[2];
} SBCModePageFlexibleDisk;


/*!
@enum TRDY_SSN_MO bitfields
@discussion
Bit field definitions and masks for Flexible Disk TRDY_SSN_MO field.
@constant kSBCModePageFlexibleDisk_MO_Bit
MO Bit definition.
@constant kSBCModePageFlexibleDisk_SSN_Bit
SSN Bit definition.
@constant kSBCModePageFlexibleDisk_TRDY_Bit
TRDY Bit definition.
@constant kSBCModePageFlexibleDisk_MO_Mask
Mask for use with TRDY_SSN_MO field.
@constant kSBCModePageFlexibleDisk_SSN_Mask
Mask for use with TRDY_SSN_MO field.
@constant kSBCModePageFlexibleDisk_TRDY_Mask
Mask for use with TRDY_SSN_MO field.
*/
enum
{
	// Bits 0:4 Reserved
	kSBCModePageFlexibleDisk_MO_Bit		= 5,
	kSBCModePageFlexibleDisk_SSN_Bit	= 6,
	kSBCModePageFlexibleDisk_TRDY_Bit	= 7,
	
	kSBCModePageFlexibleDisk_MO_Mask	= (1 << kSBCModePageFlexibleDisk_MO_Bit),
	kSBCModePageFlexibleDisk_SSN_Mask	= (1 << kSBCModePageFlexibleDisk_SSN_Bit),
	kSBCModePageFlexibleDisk_TRDY_Mask	= (1 << kSBCModePageFlexibleDisk_TRDY_Bit)
};


/*!
@enum SPC bitfields
@discussion
Bit field definitions and masks for Flexible Disk SPC field.
@constant kSBCModePageFlexibleDisk_SPC_Mask
Mask for use with SPC field.
*/
enum
{
	kSBCModePageFlexibleDisk_SPC_Mask	= 0x0F
};


/*!
@enum PIN_34_PIN_2 bitfields
@discussion
Bit field definitions and masks for Flexible Disk PIN_34_PIN_2 field.
@constant kSBCModePageFlexibleDisk_PIN_2_Mask
Mask for use with PIN_34_PIN_2 field.
@constant kSBCModePageFlexibleDisk_PIN_34_Mask
Mask for use with PIN_34_PIN_2 field.
*/
enum
{
	kSBCModePageFlexibleDisk_PIN_2_Mask		= 0x0F,
	kSBCModePageFlexibleDisk_PIN_34_Mask	= 0xF0
};


/*!
@enum PIN_4_PIN_1 bitfields
@discussion
Bit field definitions and masks for Flexible Disk PIN_4_PIN_1 field.
@constant kSBCModePageFlexibleDisk_PIN_1_Mask
Mask for use with PIN_4_PIN_1 field.
@constant kSBCModePageFlexibleDisk_PIN_4_Mask
Mask for use with PIN_4_PIN_1 field.
*/
enum
{
	kSBCModePageFlexibleDisk_PIN_1_Mask		= 0x0F,
	kSBCModePageFlexibleDisk_PIN_4_Mask		= 0xF0
};


/*!
@struct SBCModePageCaching
@discussion
Caching Mode Page (PAGE CODE 0x08) format.
*/
typedef struct SBCModePageCaching
{
	ModePageFormatHeader	header;
	UInt8					flags;
	UInt8					DEMAND_READ_WRITE_RETENTION_PRIORITY;
	UInt16					DISABLE_PREFETCH_TRANSFER_LENGTH;
	UInt16					MINIMUM_PREFETCH;
	UInt16					MAXIMUM_PREFETCH;
	UInt16					MAXIMUM_PREFETCH_CEILING;
	UInt8					flags2;
	UInt8					NUMBER_OF_CACHE_SEGMENTS;
	UInt16					CACHE_SEGMENT_SIZE;
	UInt8					RESERVED;
	UInt8					NON_CACHE_SEGMENT_SIZE[3];
} SBCModePageCaching;


/*!
@enum Caching flags bitfields
@discussion
Bit field definitions and masks for Caching flags field.
@constant kSBCModePageCaching_RCD_Bit
RCD Bit definition.
@constant kSBCModePageCaching_MF_Bit
MF Bit definition.
@constant kSBCModePageCaching_WCE_Bit
WCE Bit definition.
@constant kSBCModePageCaching_SIZE_Bit
SIZE Bit definition.
@constant kSBCModePageCaching_DISC_Bit
DISC Bit definition.
@constant kSBCModePageCaching_CAP_Bit
CAP Bit definition.
@constant kSBCModePageCaching_ABPF_Bit
ABPF Bit definition.
@constant kSBCModePageCaching_IC_Bit
IC Bit definition.
@constant kSBCModePageCaching_RCD_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_MF_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_WCE_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_SIZE_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_DISC_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_CAP_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_ABPF_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_IC_Mask
Mask for use with flags field.
*/
enum
{
	kSBCModePageCaching_RCD_Bit		= 0,
	kSBCModePageCaching_MF_Bit		= 1,
	kSBCModePageCaching_WCE_Bit		= 2,
	kSBCModePageCaching_SIZE_Bit	= 3,
	kSBCModePageCaching_DISC_Bit	= 4,
	kSBCModePageCaching_CAP_Bit		= 5,
	kSBCModePageCaching_ABPF_Bit	= 6,
	kSBCModePageCaching_IC_Bit		= 7,

	kSBCModePageCaching_RCD_Mask	= (1 << kSBCModePageCaching_RCD_Bit),
	kSBCModePageCaching_MF_Mask		= (1 << kSBCModePageCaching_MF_Bit),
	kSBCModePageCaching_WCE_Mask	= (1 << kSBCModePageCaching_WCE_Bit),
	kSBCModePageCaching_SIZE_Mask	= (1 << kSBCModePageCaching_SIZE_Bit),
	kSBCModePageCaching_DISC_Mask	= (1 << kSBCModePageCaching_DISC_Bit),
	kSBCModePageCaching_CAP_Mask	= (1 << kSBCModePageCaching_CAP_Bit),
	kSBCModePageCaching_ABPF_Mask	= (1 << kSBCModePageCaching_ABPF_Bit),
	kSBCModePageCaching_IC_Mask		= (1 << kSBCModePageCaching_IC_Bit)
};


/*!
@enum Demand Read/Write Retention masks
@discussion
Demand Read/Write Retention masks.
@constant kSBCModePageCaching_DEMAND_WRITE_Mask
Mask for the DEMAND_READ_WRITE_RETENTION_PRIORITY field.
@constant kSBCModePageCaching_DEMAND_READ_Mask
Mask for the DEMAND_READ_WRITE_RETENTION_PRIORITY field.
*/
enum
{
	kSBCModePageCaching_DEMAND_WRITE_Mask	= 0x00FF,
	kSBCModePageCaching_DEMAND_READ_Mask 	= 0xFF00
};

/*!
@enum Caching flags2 bitfields
@discussion
Bit field definitions and masks for Caching flags2 field.
@constant kSBCModePageCaching_VS1_Bit
VS1 Bit definition.
@constant kSBCModePageCaching_VS2_Bit
VS2 Bit definition.
@constant kSBCModePageCaching_DRA_Bit
DRA Bit definition.
@constant kSBCModePageCaching_LBCSS_Bit
LBCSS Bit definition.
@constant kSBCModePageCaching_FSW_Bit
FSW Bit definition.
@constant kSBCModePageCaching_VS1_Mask
Mask for use with flags2 field.
@constant kSBCModePageCaching_VS2_Mask
Mask for use with flags2 field.
@constant kSBCModePageCaching_DRA_Mask
Mask for use with flags2 field.
@constant kSBCModePageCaching_LBCSS_Mask
Mask for use with flags2 field.
@constant kSBCModePageCaching_FSW_Mask
Mask for use with flags2 field.
*/
enum
{
	// Bits 0:2 Reserved
	kSBCModePageCaching_VS1_Bit		= 3,
	kSBCModePageCaching_VS2_Bit		= 4,
	kSBCModePageCaching_DRA_Bit		= 5,
	kSBCModePageCaching_LBCSS_Bit	= 6,
	kSBCModePageCaching_FSW_Bit		= 7,

	kSBCModePageCaching_VS1_Mask	= (1 << kSBCModePageCaching_VS1_Bit),
	kSBCModePageCaching_VS2_Mask	= (1 << kSBCModePageCaching_VS2_Bit),
	kSBCModePageCaching_DRA_Mask	= (1 << kSBCModePageCaching_DRA_Bit),
	kSBCModePageCaching_LBCSS_Mask	= (1 << kSBCModePageCaching_LBCSS_Bit),
	kSBCModePageCaching_FSW_Mask	= (1 << kSBCModePageCaching_FSW_Bit)
};

#pragma options align=reset

#endif	/* _IOKIT_SCSI_CMDS_MODE_DEFINITIONS_H_ */
                               SCSICmds_READ_CAPACITY_Definitions.h                                                                0100644 0001750 0001750 00000007072 12567470660 037703  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/scsi                                                                  /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_CMDS_READ_CAPACITY_H_
#define _IOKIT_SCSI_CMDS_READ_CAPACITY_H_


#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSI Request Sense Definitions
	@discussion
	This file contains all definitions for the data returned from
	the READ CAPACITY 10 (0x25) and READ CAPACITY 16 (0x9E) commands.
*/

/*!
@enum READ CAPACITY Payload Sizes
@discussion
Sizes of the payload for the READ CAPACITY 10 and
READ CAPACITY 16 commands.
@constant kREPORT_CAPACITY_DataSize
Data size for a READ_CAPACITY command.
@constant kREPORT_CAPACITY_16_DataSize
Data size for a READ_CAPACITY_16 command.
*/
enum
{
	kREPORT_CAPACITY_DataSize		= 8,
	kREPORT_CAPACITY_16_DataSize	= 32
};


/*!
@constant kREPORT_CAPACITY_MaximumLBA
@discussion
Maximum LBA supported via READ CAPACITY 10 command.
*/
#define 	kREPORT_CAPACITY_MaximumLBA			0xFFFFFFFFUL


/*!
@constant kREPORT_CAPACITY_16_MaximumLBA
@discussion
Maximum LBA supported via READ CAPACITY 16 command.
*/
#define 	kREPORT_CAPACITY_16_MaximumLBA		0xFFFFFFFFFFFFFFFFULL


/*!
@struct SCSI_Capacity_Data
@discussion
Capacity return structure for READ CAPACITY 10 command.
*/
typedef struct SCSI_Capacity_Data
{
	UInt32		RETURNED_LOGICAL_BLOCK_ADDRESS;
	UInt32		BLOCK_LENGTH_IN_BYTES;
} SCSI_Capacity_Data;


/*!
@struct SCSI_Capacity_Data_Long
@discussion
Capacity return structure for READ CAPACITY 16 command.
*/
typedef struct SCSI_Capacity_Data_Long
{
	UInt64		RETURNED_LOGICAL_BLOCK_ADDRESS;
	UInt32		BLOCK_LENGTH_IN_BYTES;
	UInt8		RTO_EN_PROT_EN;
	UInt8		Reserved[19];
} SCSI_Capacity_Data_Long;


/*!
@enum RTO_EN definitions
@discussion
Values for the REFERENCE TAG OWN (RTO_EN) bit in the
READ CAPACITY Long Data structure.
@constant kREAD_CAPACITY_RTO_Enabled
Reference Tag Own enabled.
@constant kREAD_CAPACITY_RTO_Disabled
Reference Tag Own disabled.
@constant kREAD_CAPACITY_RTO_Mask
Mask to use when checking the RTO_EN_PROT_EN field.
*/
enum
{
	kREAD_CAPACITY_RTO_Enabled								= 0x02,
	kREAD_CAPACITY_RTO_Disabled								= 0x00,
	kREAD_CAPACITY_RTO_Mask									= 0x02
};


/*!
@enum PROTECTION INFORMATION definitions
@discussion
Values for the PROTECTION INFORMATION (PROT_EN) bit in the
READ CAPACITY Long Data structure.
@constant kREAD_CAPACITY_PROT_Enabled
Protection Information enabled.
@constant kREAD_CAPACITY_PROT_Disabled
Protection Information disabled.
@constant kREAD_CAPACITY_PROT_Mask
Mask to use when checking the RTO_EN_PROT_EN field.
*/

enum
{
	kREAD_CAPACITY_PROT_Enabled								= 0x01,
	kREAD_CAPACITY_PROT_Disabled							= 0x00,
	kREAD_CAPACITY_PROT_Mask								= 0x01
};


#endif	/* _IOKIT_SCSI_CMDS_READ_CAPACITY_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      SCSICmds_REPORT_LUNS_Definitions.h                                                                  0100644 0001750 0001750 00000010156 12567470660 037564  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/scsi                                                                  /*
 * Copyright (c) 2004-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_CMDS_REPORT_LUNS_DEFINITIONS_H_
#define _IOKIT_SCSI_CMDS_REPORT_LUNS_DEFINITIONS_H_


#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSI Request Sense Definitions
	@discussion
	This file contains all definitions for the data returned from
	the REPORT_LUNS (0xA0) command.
*/


/*!
@struct SCSICmd_REPORT_LUNS_LUN_ENTRY
@discussion
This structure represents a single LUN entry in a LUN list
returned via the REPORT_LUNS command.
*/
typedef struct SCSICmd_REPORT_LUNS_LUN_ENTRY
{
	UInt16		FIRST_LEVEL_ADDRESSING;
	UInt16		SECOND_LEVEL_ADDRESSING;
	UInt16		THIRD_LEVEL_ADDRESSING;
	UInt16		FOURTH_LEVEL_ADDRESSING;
} SCSICmd_REPORT_LUNS_LUN_ENTRY;


/*!
@constant kREPORT_LUNS_HeaderSize
@discussion
Size of the REPORT_LUNS header as defined in the SPC-3 specification.
*/
#define kREPORT_LUNS_HeaderSize		8

/*!
@enum REPORT_LUNS addressing methods.
@discussion
REPORT_LUNS addressing methods described in
SAM-2 documents.
@constant kREPORT_LUNS_ADDRESS_METHOD_PERIPHERAL_DEVICE
Peripheral Device Addressing Method.
@constant kREPORT_LUNS_ADDRESS_DEVICE_TYPE_SPECIFIC
Device Type Specific Addressing Method.
@constant kREPORT_LUNS_ADDRESS_METHOD_LOGICAL_UNIT
Logical Unit Specific Addressing Method.
@constant kREPORT_LUNS_ADDRESS_METHOD_OFFSET
Offset to the address method data.
*/
enum
{
	kREPORT_LUNS_ADDRESS_METHOD_PERIPHERAL_DEVICE	= 0,
	kREPORT_LUNS_ADDRESS_METHOD_FLAT_SPACE			= 1,
	kREPORT_LUNS_ADDRESS_DEVICE_TYPE_SPECIFIC		= kREPORT_LUNS_ADDRESS_METHOD_FLAT_SPACE,
	kREPORT_LUNS_ADDRESS_METHOD_LOGICAL_UNIT 		= 2,
	// Reserved [3]
	kREPORT_LUNS_ADDRESS_METHOD_OFFSET				= 14
};


/*!
@struct REPORT_LUNS_LOGICAL_UNIT_ADDRESSING
@discussion
This structure represents a LUN Addressing scheme.
*/
typedef struct REPORT_LUNS_LOGICAL_UNIT_ADDRESSING
{
#ifdef __LITTLE_ENDIAN__
	UInt16		LUN			: 5;
	UInt16		BUS_NUMBER	: 3;
	UInt16		TARGET		: 6;
	UInt16		reserved2	: 1;
	UInt16		reserved	: 1;
#else /* !__LITTLE_ENDIAN__ */
	UInt16		reserved	: 1;
	UInt16		reserved2	: 1;
	UInt16		TARGET		: 6;
	UInt16		BUS_NUMBER	: 3;
	UInt16		LUN			: 5;
#endif /* !__LITTLE_ENDIAN__ */
} REPORT_LUNS_LOGICAL_UNIT_ADDRESSING;


/*!
@struct REPORT_LUNS_PERIPHERAL_DEVICE_ADDRESSING
@discussion
This structure represents a Peripheral Device Addressing scheme.
*/
typedef struct REPORT_LUNS_PERIPHERAL_DEVICE_ADDRESSING
{
#ifdef __LITTLE_ENDIAN__
	UInt16		TARGET_LUN		: 8;
	UInt16		BUS_IDENTIFIER	: 6;
	UInt16		reserved2		: 1;
	UInt16		reserved		: 1;
#else /* !__LITTLE_ENDIAN__ */
	UInt16		reserved		: 1;
	UInt16		reserved2		: 1;
	UInt16		BUS_IDENTIFIER	: 6;
	UInt16		TARGET_LUN		: 8;
#endif /* !__LITTLE_ENDIAN__ */
} REPORT_LUNS_PERIPHERAL_DEVICE_ADDRESSING;


/*!
@struct SCSICmd_REPORT_LUNS_Header
@discussion
This structure defines the format of the data that is returned for
the REPORT_LUNS command.
*/
typedef struct SCSICmd_REPORT_LUNS_Header
{
	UInt32							LUN_LIST_LENGTH;	// LUN list length in bytes.
	UInt32							RESERVED;
	SCSICmd_REPORT_LUNS_LUN_ENTRY	LUN[1];				// Variable length list. Must have at least LUN 0 if
} SCSICmd_REPORT_LUNS_Header;							// Target supports REPORT_LUNS command.


#endif	/* _IOKIT_SCSI_CMDS_REPORT_LUNS_DEFINITIONS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                  SCSICmds_REQUEST_SENSE_Defs.h                                                                       0100644 0001750 0001750 00000015760 12567470660 036411  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/scsi                                                                  /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_CMDS_REQUEST_SENSE_H_
#define _IOKIT_SCSI_CMDS_REQUEST_SENSE_H_


#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSI Request Sense Definitions
	@discussion
	This file contains all definitions for the data returned from
	the REQUEST SENSE (0x03) command and from auto sense on protocols
	that support it.
*/


/*!
@enum kSenseDefaultSize
@discussion
The default size for SCSI Request Sense data.
*/
enum
{
	kSenseDefaultSize	= 18
};


/*!
@struct SCSI_Sense_Data
@discussion
The basic SCSI Request Sense data structure.
*/
typedef struct SCSI_Sense_Data
{
	UInt8		VALID_RESPONSE_CODE;				// 7 = Valid. 6-0 = Response Code.
	UInt8		SEGMENT_NUMBER;						// Segment number
	UInt8		SENSE_KEY;							// 7 = FILEMARK, 6 = EOM, 5 = ILI, 3-0 = SENSE KEY.
	UInt8		INFORMATION_1;						// INFORMATION.
	UInt8		INFORMATION_2;						// INFORMATION.
	UInt8		INFORMATION_3;						// INFORMATION.
	UInt8		INFORMATION_4;						// INFORMATION.
	UInt8		ADDITIONAL_SENSE_LENGTH;			// Number of additional bytes available in sense data
	UInt8		COMMAND_SPECIFIC_INFORMATION_1;		// Command Specific Information
	UInt8		COMMAND_SPECIFIC_INFORMATION_2;		// Command Specific Information
	UInt8		COMMAND_SPECIFIC_INFORMATION_3;		// Command Specific Information
	UInt8		COMMAND_SPECIFIC_INFORMATION_4;		// Command Specific Information
	UInt8		ADDITIONAL_SENSE_CODE;				// Additional Sense Code
	UInt8		ADDITIONAL_SENSE_CODE_QUALIFIER;	// Additional Sense Code Qualifier
	UInt8		FIELD_REPLACEABLE_UNIT_CODE;		// Field Replaceable Unit Code
	UInt8		SKSV_SENSE_KEY_SPECIFIC_MSB;		// 7 = Sense Key Specific Valid bit, 6-0 Sense Key Specific MSB
	UInt8		SENSE_KEY_SPECIFIC_MID;				// Sense Key Specific Middle
	UInt8		SENSE_KEY_SPECIFIC_LSB;				// Sense Key Specific LSB
} SCSI_Sense_Data;


/*!
@enum Sense Valid
@discussion
Masks to use to determine if sense data is valid or not.
@constant kSENSE_DATA_VALID
Sense data is valid.
@constant kSENSE_NOT_DATA_VALID
Sense data is not valid.
@constant kSENSE_DATA_VALID_Mask
Validity mask to use when checking the VALID_RESPONSE_CODE field.
*/
enum
{
	kSENSE_DATA_VALID										= 0x80,
	kSENSE_NOT_DATA_VALID									= 0x00,
	kSENSE_DATA_VALID_Mask									= 0x80
};


/*!
@enum Sense Response Codes
@discussion
Masks and values to determine the Response Code.
@constant kSENSE_RESPONSE_CODE_Current_Errors
Response code indicating current errors are reported.
@constant kSENSE_RESPONSE_CODE_Deferred_Errors
Response code indicating deferred errors are reported.
@constant kSENSE_RESPONSE_CODE_Mask
Mask to use when checking the VALID_RESPONSE_CODE field.
*/
enum
{
	kSENSE_RESPONSE_CODE_Current_Errors						= 0x70,
	kSENSE_RESPONSE_CODE_Deferred_Errors					= 0x71,
	kSENSE_RESPONSE_CODE_Mask								= 0x7F
};


/*!
@enum FILEMARK bit field definitions
@discussion
Masks and values to determine the FileMark bit field.
@constant kSENSE_FILEMARK_Set
Filemark bit is set.
@constant kSENSE_FILEMARK_Not_Set
Filemark bit is not set.
@constant kSENSE_FILEMARK_Mask
Mask to use when checking the SENSE_KEY field for the FILEMARK bit.
*/
enum
{
	kSENSE_FILEMARK_Set										= 0x80,
	kSENSE_FILEMARK_Not_Set 								= 0x00,
	kSENSE_FILEMARK_Mask 									= 0x80
};


/*!
@enum EOM bit field definitions
@discussion
Masks and values to determine the End Of Medium bit field.
@constant kSENSE_EOM_Set
End Of Medium bit is set.
@constant kSENSE_EOM_Not_Set
End Of Medium bit is not set.
@constant kSENSE_EOM_Mask
Mask to use when checking the SENSE_KEY field for the EOM bit.
*/
enum
{
	kSENSE_EOM_Set											= 0x40,
	kSENSE_EOM_Not_Set 										= 0x00,
	kSENSE_EOM_Mask 										= 0x40
};


/*!
@enum ILI bit field definitions
@discussion
Masks and values to determine the Incorrect Length Indicator bit field.
@constant kSENSE_ILI_Set
Incorrect Length Indicator bit is set.
@constant kSENSE_ILI_Not_Set
Incorrect Length Indicator bit is not set.
@constant kSENSE_ILI_Mask
Mask to use when checking the SENSE_KEY field for the ILI bit.
*/
enum
{
	kSENSE_ILI_Set											= 0x20,
	kSENSE_ILI_Not_Set 										= 0x00,
	kSENSE_ILI_Mask 										= 0x20
};


/*!
@enum Sense Key definitions
@discussion
Masks and values to determine the SENSE_KEY.
@constant kSENSE_KEY_NO_SENSE
No sense data is present.
@constant kSENSE_KEY_RECOVERED_ERROR
A recovered error has occurred.
@constant kSENSE_KEY_NOT_READY
Device server is not ready.
@constant kSENSE_KEY_MEDIUM_ERROR
Device server detected a medium error.
@constant kSENSE_KEY_HARDWARE_ERROR
Device server detected a hardware error.
@constant kSENSE_KEY_ILLEGAL_REQUEST
Device server detected an illegal request.
@constant kSENSE_KEY_UNIT_ATTENTION
Device server indicates a unit attention condition.
@constant kSENSE_KEY_DATA_PROTECT
Device server indicates a data protect condition.
@constant kSENSE_KEY_BLANK_CHECK
Device server indicates a blank check condition.
@constant kSENSE_KEY_VENDOR_SPECIFIC
Device server indicates a vendor specific condition.
@constant kSENSE_KEY_COPY_ABORTED
Device server indicates a copy aborted condition.
@constant kSENSE_KEY_ABORTED_COMMAND
Device server indicates an aborted command condition.
@constant kSENSE_KEY_VOLUME_OVERFLOW
Device server indicates a volume overflow condition.
@constant kSENSE_KEY_MISCOMPARE
Device server indicates a miscompare condition.
@constant kSENSE_KEY_Mask
Mask to use when checking the SENSE_KEY field for the SENSE_KEY value.
*/
enum
{
	kSENSE_KEY_NO_SENSE										= 0x00,
	kSENSE_KEY_RECOVERED_ERROR								= 0x01,
	kSENSE_KEY_NOT_READY									= 0x02,
	kSENSE_KEY_MEDIUM_ERROR									= 0x03,
	kSENSE_KEY_HARDWARE_ERROR								= 0x04,
	kSENSE_KEY_ILLEGAL_REQUEST								= 0x05,
	kSENSE_KEY_UNIT_ATTENTION								= 0x06,
	kSENSE_KEY_DATA_PROTECT									= 0x07,
	kSENSE_KEY_BLANK_CHECK									= 0x08,
	kSENSE_KEY_VENDOR_SPECIFIC								= 0x09,
	kSENSE_KEY_COPY_ABORTED									= 0x0A,
	kSENSE_KEY_ABORTED_COMMAND								= 0x0B,
	/* SENSE KEY 0x0C is obsoleted */
	kSENSE_KEY_VOLUME_OVERFLOW								= 0x0D,
	kSENSE_KEY_MISCOMPARE									= 0x0E,
	/* SENSE KEY 0x0F is reserved */
	kSENSE_KEY_Mask 										= 0x0F
};


#endif	/* _IOKIT_SCSI_CMDS_REQUEST_SENSE_H_ */
                SCSICommandDefinitions.h                                                                            0100644 0001750 0001750 00000031055 12567470660 036162  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/scsi                                                                  /*
 * Copyright (c) 2001-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_COMMAND_DEFINITIONS_H_
#define _IOKIT_SCSI_COMMAND_DEFINITIONS_H_


#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSICommandDefinitions
	@discussion
	This file contains all the definitions for types and constants that are
	used by the command set classes for building CDBs. The field type
	definitions are used for the parameters passed to a method that builds and
	sends any SCSI defined command to clearly identify the type of value
	expected for a parameter.
	
	The command methods will then use the appropriate mask to verify that the
	value passed into a parameter is of the specified type.
	
	Currently only types and masks are defined for 8 bytes and smaller fields.
	If a command is defined that uses a larger field, these should be expanded
	to include those sizes.
*/ 

#pragma mark Field Type Definitions
/* These are the type definitions used for the parameters of methods that
 * build and send Command Descriptor Blocks.
 */

/* 1 Byte or smaller fields. */

/*! @typedef SCSICmdField1Bit */
typedef UInt8	SCSICmdField1Bit;

/*! @typedef SCSICmdField2Bit */
typedef UInt8	SCSICmdField2Bit;

/*! @typedef SCSICmdField3Bit */
typedef UInt8	SCSICmdField3Bit;

/*! @typedef SCSICmdField4Bit */
typedef UInt8	SCSICmdField4Bit;

/*! @typedef SCSICmdField5Bit */
typedef UInt8	SCSICmdField5Bit;

/*! @typedef SCSICmdField6Bit */
typedef UInt8	SCSICmdField6Bit;

/*! @typedef SCSICmdField7Bit */
typedef UInt8	SCSICmdField7Bit;

/*! @typedef SCSICmdField1Byte */
typedef UInt8	SCSICmdField1Byte;

/* 2 Bytes or smaller fields. */

/*! @typedef SCSICmdField9Bit */
typedef UInt16	SCSICmdField9Bit;

/*! @typedef SCSICmdField10Bit */
typedef UInt16	SCSICmdField10Bit;

/*! @typedef SCSICmdField11Bit */
typedef UInt16	SCSICmdField11Bit;

/*! @typedef SCSICmdField12Bit */
typedef UInt16	SCSICmdField12Bit;

/*! @typedef SCSICmdField13Bit */
typedef UInt16	SCSICmdField13Bit;

/*! @typedef SCSICmdField14Bit */
typedef UInt16	SCSICmdField14Bit;

/*! @typedef SCSICmdField15Bit */
typedef UInt16	SCSICmdField15Bit;

/*! @typedef SCSICmdField2Byte */
typedef UInt16	SCSICmdField2Byte;

/* 3 Bytes or smaller fields. */

/*! @typedef SCSICmdField17Bit */
typedef UInt32	SCSICmdField17Bit;

/*! @typedef SCSICmdField18Bit */
typedef UInt32	SCSICmdField18Bit;

/*! @typedef SCSICmdField19Bit */
typedef UInt32	SCSICmdField19Bit;

/*! @typedef SCSICmdField20Bit */
typedef UInt32	SCSICmdField20Bit;

/*! @typedef SCSICmdField21Bit */
typedef UInt32	SCSICmdField21Bit;

/*! @typedef SCSICmdField22Bit */
typedef UInt32	SCSICmdField22Bit;

/*! @typedef SCSICmdField23Bit */
typedef UInt32	SCSICmdField23Bit;

/*! @typedef SCSICmdField3Byte */
typedef UInt32	SCSICmdField3Byte;

/* 4 Bytes or smaller fields. */

/*! @typedef SCSICmdField25Bit */
typedef UInt32	SCSICmdField25Bit;

/*! @typedef SCSICmdField26Bit */
typedef UInt32	SCSICmdField26Bit;

/*! @typedef SCSICmdField27Bit */
typedef UInt32	SCSICmdField27Bit;

/*! @typedef SCSICmdField28Bit */
typedef UInt32	SCSICmdField28Bit;

/*! @typedef SCSICmdField29Bit */
typedef UInt32	SCSICmdField29Bit;

/*! @typedef SCSICmdField30Bit */
typedef UInt32	SCSICmdField30Bit;

/*! @typedef SCSICmdField31Bit */
typedef UInt32	SCSICmdField31Bit;

/*! @typedef SCSICmdField4Byte */
typedef UInt32	SCSICmdField4Byte;

/* 5 Bytes or smaller fields. */

/*! @typedef SCSICmdField33Bit */
typedef UInt64	SCSICmdField33Bit;

/*! @typedef SCSICmdField34Bit */
typedef UInt64	SCSICmdField34Bit;

/*! @typedef SCSICmdField35Bit */
typedef UInt64	SCSICmdField35Bit;

/*! @typedef SCSICmdField36Bit */
typedef UInt64	SCSICmdField36Bit;

/*! @typedef SCSICmdField37Bit */
typedef UInt64	SCSICmdField37Bit;

/*! @typedef SCSICmdField38Bit */
typedef UInt64	SCSICmdField38Bit;

/*! @typedef SCSICmdField39Bit */
typedef UInt64	SCSICmdField39Bit;

/*! @typedef SCSICmdField5Byte */
typedef UInt64	SCSICmdField5Byte;

/* 6 Bytes or smaller fields. */

/*! @typedef SCSICmdField41Bit */
typedef UInt64	SCSICmdField41Bit;

/*! @typedef SCSICmdField42Bit */
typedef UInt64	SCSICmdField42Bit;

/*! @typedef SCSICmdField43Bit */
typedef UInt64	SCSICmdField43Bit;

/*! @typedef SCSICmdField44Bit */
typedef UInt64	SCSICmdField44Bit;

/*! @typedef SCSICmdField45Bit */
typedef UInt64	SCSICmdField45Bit;

/*! @typedef SCSICmdField46Bit */
typedef UInt64	SCSICmdField46Bit;

/*! @typedef SCSICmdField47Bit */
typedef UInt64	SCSICmdField47Bit;

/*! @typedef SCSICmdField6Byte */
typedef UInt64	SCSICmdField6Byte;

/* 7 Bytes or smaller fields. */

/*! @typedef SCSICmdField49Bit */
typedef UInt64	SCSICmdField49Bit;

/*! @typedef SCSICmdField50Bit */
typedef UInt64	SCSICmdField50Bit;

/*! @typedef SCSICmdField51Bit */
typedef UInt64	SCSICmdField51Bit;

/*! @typedef SCSICmdField52Bit */
typedef UInt64	SCSICmdField52Bit;

/*! @typedef SCSICmdField53Bit */
typedef UInt64	SCSICmdField53Bit;

/*! @typedef SCSICmdField54Bit */
typedef UInt64	SCSICmdField54Bit;

/*! @typedef SCSICmdField55Bit */
typedef UInt64	SCSICmdField55Bit;

/*! @typedef SCSICmdField7Byte */
typedef UInt64	SCSICmdField7Byte;

/* 8 Bytes or smaller fields. */

/*! @typedef SCSICmdField57Bit */
typedef UInt64	SCSICmdField57Bit;

/*! @typedef SCSICmdField58Bit */
typedef UInt64	SCSICmdField58Bit;

/*! @typedef SCSICmdField59Bit */
typedef UInt64	SCSICmdField59Bit;

/*! @typedef SCSICmdField60Bit */
typedef UInt64	SCSICmdField60Bit;

/*! @typedef SCSICmdField61Bit */
typedef UInt64	SCSICmdField61Bit;

/*! @typedef SCSICmdField62Bit */
typedef UInt64	SCSICmdField62Bit;

/*! @typedef SCSICmdField63Bit */
typedef UInt64	SCSICmdField63Bit;

/*! @typedef SCSICmdField8Byte */
typedef UInt64	SCSICmdField8Byte;


#pragma mark Field Mask Definitions
/* These are masks that are used to verify that the values passed into the
 * parameters for the fields are not larger than the field size.
 *
 * NB: These have changed from enums to #define since enums greater than
 * 32 bits in size are not well-defined in C99.
 */

/* 1 Byte or smaller fields. */

/*! @constant kSCSICmdFieldMask1Bit */
#define 	kSCSICmdFieldMask1Bit		0x01

/*! @constant kSCSICmdFieldMask2Bit */
#define 	kSCSICmdFieldMask2Bit		0x03

/*! @constant kSCSICmdFieldMask3Bit */
#define 	kSCSICmdFieldMask3Bit		0x07

/*! @constant kSCSICmdFieldMask4Bit */
#define 	kSCSICmdFieldMask4Bit		0x0F

/*! @constant kSCSICmdFieldMask5Bit */
#define 	kSCSICmdFieldMask5Bit		0x1F

/*! @constant kSCSICmdFieldMask6Bit */
#define 	kSCSICmdFieldMask6Bit		0x3F

/*! @constant kSCSICmdFieldMask7Bit */
#define 	kSCSICmdFieldMask7Bit		0x7F

#define 	kSCSICmdFieldMask1Byte		0xFF

/* 2 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask9Bit */
#define 	kSCSICmdFieldMask9Bit		0x01FF

/*! @constant kSCSICmdFieldMask10Bit */
#define 	kSCSICmdFieldMask10Bit		0x03FF

/*! @constant kSCSICmdFieldMask11Bit */
#define 	kSCSICmdFieldMask11Bit		0x07FF

/*! @constant kSCSICmdFieldMask12Bit */
#define 	kSCSICmdFieldMask12Bit		0x0FFF

/*! @constant kSCSICmdFieldMask13Bit */
#define 	kSCSICmdFieldMask13Bit		0x1FFF

/*! @constant kSCSICmdFieldMask14Bit */
#define 	kSCSICmdFieldMask14Bit		0x3FFF

/*! @constant kSCSICmdFieldMask15Bit */
#define 	kSCSICmdFieldMask15Bit		0x7FFF

/*! @constant kSCSICmdFieldMask2Byte */
#define 	kSCSICmdFieldMask2Byte		0xFFFF

/* 3 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask17Bit */
#define 	kSCSICmdFieldMask17Bit		0x01FFFF

/*! @constant kSCSICmdFieldMask18Bit */
#define 	kSCSICmdFieldMask18Bit		0x03FFFF

/*! @constant kSCSICmdFieldMask19Bit */
#define 	kSCSICmdFieldMask19Bit		0x07FFFF

/*! @constant kSCSICmdFieldMask20Bit */
#define 	kSCSICmdFieldMask20Bit		0x0FFFFF

/*! @constant kSCSICmdFieldMask21Bit */
#define 	kSCSICmdFieldMask21Bit		0x1FFFFF

/*! @constant kSCSICmdFieldMask22Bit */
#define 	kSCSICmdFieldMask22Bit		0x3FFFFF

/*! @constant kSCSICmdFieldMask23Bit */
#define 	kSCSICmdFieldMask23Bit		0x7FFFFF

/*! @constant kSCSICmdFieldMask3Byte */
#define 	kSCSICmdFieldMask3Byte		0xFFFFFF

/* 4 Bytes or smaller fields. */
/*! @constant kSCSICmdFieldMask25Bit */
#define 	kSCSICmdFieldMask25Bit		0x01FFFFFFUL

/*! @constant kSCSICmdFieldMask26Bit */
#define 	kSCSICmdFieldMask26Bit		0x03FFFFFFUL

/*! @constant kSCSICmdFieldMask27Bit */
#define 	kSCSICmdFieldMask27Bit		0x07FFFFFFUL

/*! @constant kSCSICmdFieldMask28Bit */
#define 	kSCSICmdFieldMask28Bit		0x0FFFFFFFUL

/*! @constant kSCSICmdFieldMask29Bit */
#define 	kSCSICmdFieldMask29Bit		0x1FFFFFFFUL

/*! @constant kSCSICmdFieldMask30Bit */
#define 	kSCSICmdFieldMask30Bit		0x3FFFFFFFUL

/*! @constant kSCSICmdFieldMask31Bit */
#define 	kSCSICmdFieldMask31Bit		0x7FFFFFFFUL

/*! @constant kSCSICmdFieldMask4Byte */
#define 	kSCSICmdFieldMask4Byte		0xFFFFFFFFUL

/* 5 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask33Bit */
#define 	kSCSICmdFieldMask33Bit		0x01FFFFFFFFULL

/*! @constant kSCSICmdFieldMask34Bit */
#define 	kSCSICmdFieldMask34Bit		0x03FFFFFFFFULL

/*! @constant kSCSICmdFieldMask35Bit */
#define 	kSCSICmdFieldMask35Bit		0x07FFFFFFFFULL

/*! @constant kSCSICmdFieldMask36Bit */
#define 	kSCSICmdFieldMask36Bit		0x0FFFFFFFFFULL

/*! @constant kSCSICmdFieldMask37Bit */
#define 	kSCSICmdFieldMask37Bit		0x1FFFFFFFFFULL

/*! @constant kSCSICmdFieldMask38Bit */
#define 	kSCSICmdFieldMask38Bit		0x3FFFFFFFFFULL

/*! @constant kSCSICmdFieldMask39Bit */
#define 	kSCSICmdFieldMask39Bit		0x7FFFFFFFFFULL

/*! @constant kSCSICmdFieldMask5Byte */
#define 	kSCSICmdFieldMask5Byte		0xFFFFFFFFFFULL

/* 6 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask41Bit */
#define 	kSCSICmdFieldMask41Bit		0x01FFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask42Bit */
#define 	kSCSICmdFieldMask42Bit		0x03FFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask43Bit */
#define 	kSCSICmdFieldMask43Bit		0x07FFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask44Bit */
#define 	kSCSICmdFieldMask44Bit		0x0FFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask45Bit */
#define 	kSCSICmdFieldMask45Bit		0x1FFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask46Bit */
#define 	kSCSICmdFieldMask46Bit		0x3FFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask47Bit */
#define 	kSCSICmdFieldMask47Bit		0x7FFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask6Byte */
#define 	kSCSICmdFieldMask6Byte		0xFFFFFFFFFFFFULL

/* 7 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask49Bit */
#define 	kSCSICmdFieldMask49Bit		0x01FFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask50Bit */
#define 	kSCSICmdFieldMask50Bit		0x03FFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask51Bit */
#define 	kSCSICmdFieldMask51Bit		0x07FFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask52Bit */
#define 	kSCSICmdFieldMask52Bit		0x0FFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask53Bit */
#define 	kSCSICmdFieldMask53Bit		0x1FFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask54Bit */
#define 	kSCSICmdFieldMask54Bit		0x3FFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask55Bit */
#define 	kSCSICmdFieldMask55Bit		0x7FFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask7Byte */
#define 	kSCSICmdFieldMask7Byte		0xFFFFFFFFFFFFFFULL

/* 8 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask57Bit */
#define 	kSCSICmdFieldMask57Bit		0x01FFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask58Bit */
#define 	kSCSICmdFieldMask58Bit		0x03FFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask59Bit */
#define 	kSCSICmdFieldMask59Bit		0x07FFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask60Bit */
#define 	kSCSICmdFieldMask60Bit		0x0FFFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask61Bit */
#define 	kSCSICmdFieldMask61Bit		0x1FFFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask62Bit */
#define 	kSCSICmdFieldMask62Bit		0x3FFFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask63Bit */
#define 	kSCSICmdFieldMask63Bit		0x7FFFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask8Byte */
#define 	kSCSICmdFieldMask8Byte		0xFFFFFFFFFFFFFFFFULL

#endif	/* _IOKIT_SCSI_COMMAND_DEFINITIONS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   SCSICommandOperationCodes.h                                                                         0100644 0001750 0001750 00000142433 12567470660 036630  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/scsi                                                                  /*
 * Copyright (c) 2001-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCSI_COMMAND_OPERATION_CODES_H_
#define _SCSI_COMMAND_OPERATION_CODES_H_

#pragma mark About this file
/* This file contains the operation code definitions for all commands defined
 * by the SCSI specifications.  The commands are listed in three formats:
 * 1) All commands are listed in alphabetical order.  This list is the live
 * enumeration for all of the command constants.
 * 2) The commands are listed in ascending numerical order.
 * 3) The commands are grouped by Peripheral Device Type.
 * 
 * In the command listings by Peripheral Device Type, there will be a comment
 * following each command.  This comment indentifies the section of the related
 * specification where the commands is defined and the requirement type of the
 * command, Mandatory or Optional.
 * If a specification redefines an optional command from SPC as mandatory,
 * the command will be relisted in the Peripheral Device Type command list with
 * the mandatory tag next to it.
 * All commands that are listed in SPC as Device Type Specifc will be relisted
 * as a comment in all specifications lists that support that command with the
 * appropriate Mandatory or Optional tag for that specification.
 *
 * The section number and the requirement type of the command are based on the 
 * version of the specification listed in the header comment for the Peripheral
 * Device Type.  This data is provided for informational purposes only.  The 
 * specification document and version that the device adheres to as indicated 
 * by the data returned in response to the INQUIRY command should be used as
 * the authorative source for supported and required behavior of the device.
 * 
 * The SPC set is listed before all other Peripheral Device Type commands as
 * this is the base document from which all of the other documents are derived.  
 *
 * The Peripheral Device Types and associated command sets as defined by SPC-2,
 * section 7.4.1 are as follows:
 *  Peripheral Device Type                  Associated Command Specification
 *  ------------------------------------    -----------------------------------
 *  0x00 Direct Access Device               SBC - SCSI-3 Block Commands
 *  0x01 Sequential Access Device           SSC - SCSI-3 Stream Commands
 *  0x02 Printer Device                     SSC - SCSI-3 Stream Commands
 *  0x03 Processor Device                   SPC - SCSI Primary Commands-2
 *  0x04 Write Once Device                  SBC - SCSI-3 Block Commands
 *  0x05 CD-ROM Device                      MMC - SCSI Multimedia Commands-2
 *  0x06 Scanner Device                     SGC - SCSI-3 Graphics Commands
 *  0x07 Optical Memory Device              SBC - SCSI-3 Block Commands
 *  0x08 Medium Changer Device              SMC - SCSI-3 Medium Changer Cmds
 *  0x09 Communications Device              SSC - SCSI-3 Stream Commands
 *  0x0A - 0x0B Graphic Arts Prepress Dev   ASC IT8
 *  0x0C Storage Array Controller Device    SCC-2 - SCSI Controller Commands-2
 *  0x0D Enclosure Services                 SES - SCSI-3 Enclosure Services
 *  0x0E Simplified Direct Access Device    RBC - SCSI Reduced Block Commands
 *  0x0F Optical Card Reader/Writer Device  OCRW - SCSI Specification for 
 *                                              Optical Card Reader/Writer
 *  0x10 Reserved                    		No command specification
 *	0x11 Object-Based Storage Device		OSD - SCSI Object Based Storage 
 *												Device Commands
 *  0x12 - 0x14 Reserved                    No command specification
 *  0x15 Multimedia Media Access Engine     RMC - Reduced Multimedia Commands
 *  0x16 - 0x1E Reserved                    No command specification
 *  0x1F Unknown or No Device               No command specification
 */ 

#pragma mark -
#pragma mark Command Definitions by Name
/* All SCSI Commands listed in alphabetical order.  These are the live
 * definitions of the commands.  All other command lists are informative.
 */
enum 
{
    kSCSICmd_ACCESS_CONTROL_IN              = 0x86,
    kSCSICmd_ACCESS_CONTROL_OUT             = 0x87,
    kSCSICmd_BLANK                          = 0xA1,
    kSCSICmd_CHANGE_DEFINITION              = 0x40,
    kSCSICmd_CLOSE_TRACK_SESSION            = 0x5B,
    kSCSICmd_COMPARE                        = 0x39,
    kSCSICmd_COPY                           = 0x18,
    kSCSICmd_COPY_AND_VERIFY                = 0x3A,
    kSCSICmd_ERASE_10						= 0x2C,
    kSCSICmd_ERASE_12						= 0xAC,
    kSCSICmd_EXTENDED_COPY                  = 0x83,
    kSCSICmd_FORMAT_UNIT                    = 0x04,
    kSCSICmd_GET_CONFIGURATION              = 0x46,
    kSCSICmd_GET_EVENT_STATUS_NOTIFICATION  = 0x4A,
    kSCSICmd_GET_PERFORMANCE                = 0xAC,
    kSCSICmd_INQUIRY                        = 0x12,
    kSCSICmd_LOAD_UNLOAD_MEDIUM             = 0xA6,
    kSCSICmd_LOCK_UNLOCK_CACHE              = 0x36,
    kSCSICmd_LOCK_UNLOCK_CACHE_16           = 0x92,
    kSCSICmd_LOG_SELECT                     = 0x4C,
    kSCSICmd_LOG_SENSE                      = 0x4D,
    kSCSICmd_MAINTENANCE_IN               	= 0xA3,
    kSCSICmd_MAINTENANCE_OUT                = 0xA4,
    kSCSICmd_MECHANISM_STATUS               = 0xBD,
    kSCSICmd_MEDIUM_SCAN                    = 0x38,
    kSCSICmd_MODE_SELECT_6                  = 0x15,
    kSCSICmd_MODE_SELECT_10                 = 0x55,
    kSCSICmd_MODE_SENSE_6                   = 0x1A,
    kSCSICmd_MODE_SENSE_10                  = 0x5A,
    kSCSICmd_MOVE_MEDIUM_ATTACHED           = 0xA7,
    kSCSICmd_PAUSE_RESUME                   = 0x4B,
    kSCSICmd_PERSISTENT_RESERVE_IN          = 0x5E,
    kSCSICmd_PERSISTENT_RESERVE_OUT         = 0x5F,
    kSCSICmd_PLAY_AUDIO_10                  = 0x45,
    kSCSICmd_PLAY_AUDIO_12                  = 0xA5,
    kSCSICmd_PLAY_AUDIO_MSF                 = 0x47,
    kSCSICmd_PLAY_AUDIO_TRACK_INDEX         = 0x48,
    kSCSICmd_PLAY_CD                        = 0xBC,
    kSCSICmd_PLAY_RELATIVE_10               = 0x49,
    kSCSICmd_PLAY_RELATIVE_12               = 0xA9,
    kSCSICmd_PREFETCH                       = 0x34,
    kSCSICmd_PREFETCH_16                    = 0x90,
    kSCSICmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E,
    kSCSICmd_READ_6                         = 0x08,
    kSCSICmd_READ_10                        = 0x28,
    kSCSICmd_READ_12                        = 0xA8,
    kSCSICmd_READ_16                        = 0x88,
    kSCSICmd_READ_ATTRIBUTE                 = 0x8C,
    kSCSICmd_READ_BUFFER                    = 0x3C,
    kSCSICmd_READ_BUFFER_CAPACITY           = 0x5C,
    kSCSICmd_READ_CAPACITY                  = 0x25,
    kSCSICmd_READ_CD                        = 0xBE,
    kSCSICmd_READ_CD_MSF                    = 0xB9,
    kSCSICmd_READ_DEFECT_DATA_10            = 0x37,
    kSCSICmd_READ_DEFECT_DATA_12            = 0xB7,
    kSCSICmd_READ_DISC_INFORMATION          = 0x51,
    kSCSICmd_READ_DVD_STRUCTURE             = 0xAD,
    kSCSICmd_READ_DISC_STRUCTURE            = 0xAD,
    kSCSICmd_READ_ELEMENT_STATUS_ATTACHED   = 0xB4,
    kSCSICmd_READ_FORMAT_CAPACITIES         = 0x23,
    kSCSICmd_READ_GENERATION				= 0x29,
    kSCSICmd_READ_HEADER                    = 0x44,
    kSCSICmd_READ_LONG                      = 0x3E,
    kSCSICmd_READ_MASTER_CUE                = 0x59,
    kSCSICmd_READ_SUB_CHANNEL               = 0x42,
    kSCSICmd_READ_TOC_PMA_ATIP              = 0x43,
    kSCSICmd_READ_TRACK_INFORMATION         = 0x52,
    kSCSICmd_READ_UPDATED_BLOCK_10			= 0x2D,
    kSCSICmd_REASSIGN_BLOCKS                = 0x07,
    kSCSICmd_REBUILD                        = 0x81,
    kSCSICmd_RECEIVE                        = 0x08,
    kSCSICmd_RECEIVE_COPY_RESULTS           = 0x84,
    kSCSICmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C,
    kSCSICmd_REDUNDANCY_GROUP_IN			= 0xBA,
    kSCSICmd_REDUNDANCY_GROUP_OUT			= 0xBB,
    kSCSICmd_REGENERATE                     = 0x82,
    kSCSICmd_RELEASE_6                      = 0x17,
    kSCSICmd_RELEASE_10                     = 0x57,
    kSCSICmd_REPAIR_TRACK                   = 0x58,
    kSCSICmd_REPORT_DEVICE_IDENTIFIER    	= 0xA3,
    kSCSICmd_REPORT_KEY                     = 0xA4,
    kSCSICmd_REPORT_LUNS                    = 0xA0, 
    kSCSICmd_REQUEST_SENSE                  = 0x03,
    kSCSICmd_RESERVE_6                      = 0x16,
    kSCSICmd_RESERVE_10                     = 0x56,
    kSCSICmd_RESERVE_TRACK                  = 0x53,
    kSCSICmd_REZERO_UNIT                    = 0x01,
    kSCSICmd_SCAN_MMC                       = 0xBA,
    kSCSICmd_SEARCH_DATA_EQUAL_10           = 0x31,
    kSCSICmd_SEARCH_DATA_EQUAL_12           = 0xB1,
    kSCSICmd_SEARCH_DATA_HIGH_10            = 0x30,
    kSCSICmd_SEARCH_DATA_HIGH_12            = 0xB0,
    kSCSICmd_SEARCH_DATA_LOW_10             = 0x32,
    kSCSICmd_SEARCH_DATA_LOW_12             = 0xB2,
    kSCSICmd_SEEK_6                         = 0x0B,
    kSCSICmd_SEEK_10                        = 0x2B,
    kSCSICmd_SEND                           = 0x0A,
    kSCSICmd_SEND_CUE_SHEET                 = 0x5D,
    kSCSICmd_SEND_DIAGNOSTICS               = 0x1D,
    kSCSICmd_SEND_DVD_STRUCTURE             = 0xBF,
    kSCSICmd_SEND_EVENT                     = 0xA2,
    kSCSICmd_SEND_KEY                       = 0xA3,
    kSCSICmd_SEND_OPC_INFORMATION           = 0x54,
    kSCSICmd_SERVICE_ACTION_IN		        = 0x9E,
    kSCSICmd_SERVICE_ACTION_OUT		        = 0x9F,
    kSCSICmd_SET_CD_SPEED                   = 0xBB,
    kSCSICmd_SET_DEVICE_IDENTIFIER      	= 0xA4,
    kSCSICmd_SET_LIMITS_10                  = 0x33,
    kSCSICmd_SET_LIMITS_12                  = 0xB3,
    kSCSICmd_SET_READ_AHEAD                 = 0xA7,
    kSCSICmd_SET_STREAMING                  = 0xB6,
    kSCSICmd_SPARE_IN		                = 0xBC,
    kSCSICmd_SPARE_OUT		                = 0xBD,
    kSCSICmd_START_STOP_UNIT                = 0x1B,
    kSCSICmd_STOP_PLAY_SCAN                 = 0x4E,
    kSCSICmd_SYNCHRONIZE_CACHE              = 0x35,
    kSCSICmd_SYNCHRONIZE_CACHE_16           = 0x91,
    kSCSICmd_TEST_UNIT_READY                = 0x00,
	kSCSICmd_UPDATE_BLOCK					= 0x3D,
    kSCSICmd_VERIFY_10                      = 0x2F,
    kSCSICmd_VERIFY_12                      = 0xAF,
    kSCSICmd_VERIFY_16                      = 0x8F,
    kSCSICmd_VOLUME_SET_IN                  = 0xBE,
    kSCSICmd_VOLUME_SET_OUT                 = 0xBF,
    kSCSICmd_WRITE_6                        = 0x0A,
    kSCSICmd_WRITE_10                       = 0x2A,
    kSCSICmd_WRITE_12                       = 0xAA,
    kSCSICmd_WRITE_16                       = 0x8A,
    kSCSICmd_WRITE_AND_VERIFY_10            = 0x2E,
	kSCSICmd_WRITE_AND_VERIFY_12            = 0xAE,
	kSCSICmd_WRITE_AND_VERIFY_16            = 0x8E,
	kSCSICmd_WRITE_ATTRIBUTE	            = 0x8D,
    kSCSICmd_WRITE_BUFFER                   = 0x3B,
    kSCSICmd_WRITE_LONG                     = 0x3F,
    kSCSICmd_WRITE_SAME                     = 0x41,
    kSCSICmd_WRITE_SAME_16                  = 0x93,
    kSCSICmd_XDREAD                         = 0x52,
    kSCSICmd_XDWRITE                        = 0x50,
    kSCSICmd_XDWRITE_EXTENDED               = 0x80,
    kSCSICmd_XDWRITEREAD_10           		= 0x53,
    kSCSICmd_XPWRITE                        = 0x51,
    
    kSCSICmdVariableLengthCDB				= 0x7F
};

/* Service Action Definitions for the Variable Length CDB (7Fh) command */
enum
{
	kSCSIServiceAction_READ_32				= 0x0009,
	kSCSIServiceAction_VERIFY_32			= 0x000A,
	kSCSIServiceAction_WRITE_32				= 0x000B,
	kSCSIServiceAction_WRITE_AND_VERIFY_32	= 0x000C,
	kSCSIServiceAction_WRITE_SAME_32		= 0x000D,
	kSCSIServiceAction_XDREAD_32			= 0x0003,
	kSCSIServiceAction_XDWRITE_32			= 0x0004,
	kSCSIServiceAction_XDWRITEREAD_32		= 0x0007,
	kSCSIServiceAction_XPWRITE_32			= 0x0006
};

/* Service Action Definitions for the MAINTENANCE IN (A3h) command */
enum
{
	kSCSIServiceAction_REPORT_ALIASES								= 0x0B,
	kSCSIServiceAction_REPORT_DEVICE_IDENTIFIER						= 0x05,
	kSCSIServiceAction_REPORT_PRIORITY								= 0x0E,
	kSCSIServiceAction_REPORT_SUPPORTED_OPERATION_CODES				= 0x0C,
	kSCSIServiceAction_REPORT_SUPPORTED_TASK_MANAGEMENT_FUNCTIONS	= 0x0D,
	kSCSIServiceAction_REPORT_TARGET_PORT_GROUPS					= 0x0A
};

/* Service Action Definitions for the MAINTENANCE OUT (A4h) command */
enum
{
	kSCSIServiceAction_CHANGE_ALIASES			= 0x0B,
	kSCSIServiceAction_SET_DEVICE_IDENTIFIER	= 0x06,
	kSCSIServiceAction_SET_PRIORITY				= 0x0E,
	kSCSIServiceAction_SET_TARGET_PORT_GROUPS	= 0x0A	
};

/* Service Action Definitions for the SERVICE ACTION IN (9Eh) command */
enum
{
	kSCSIServiceAction_READ_CAPACITY_16		= 0x10,
	kSCSIServiceAction_READ_LONG_16			= 0x11	
};

/* Service Action Definitions for the SERVICE ACTION OUT (9Fh) command */
enum
{
	kSCSIServiceAction_WRITE_LONG_16		= 0x11	
};

#pragma mark -
#pragma mark Command Definitions by Number
#if 0
enum 
{
};
#endif


#pragma mark -
#pragma mark All Types SPC Commands
/* Commands defined by the T10:1236-D SCSI Primary Commands-2 (SPC-2) 
 * command specification.  The definitions and section numbers are based on
 * section 7 of the revision 18, 21 May 2000 version of the specification.
 *
 * These commands are defined for all devices.
 */
enum 
{
    kSPCCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kSPCCmd_COMPARE                        = 0x39, /* Sec. 7.2: Optional */
    kSPCCmd_COPY                           = 0x18, /* Sec. 7.3: Optional */
    kSPCCmd_COPY_AND_VERIFY                = 0x3A, /* Sec. 7.4: Optional */
    kSPCCmd_EXTENDED_COPY                  = 0x83, /* Sec. 7.5: Optional */
    kSPCCmd_INQUIRY                        = 0x12, /* Sec. 7.6: Mandatory */
    kSPCCmd_LOG_SELECT                     = 0x4C, /* Sec. 7.7: Optional */
    kSPCCmd_LOG_SENSE                      = 0x4D, /* Sec. 7.8: Optional */
    kSPCCmd_MODE_SELECT_6                  = 0x15, /* Sec. 7.9: Device Type
													* Specific */
    kSPCCmd_MODE_SELECT_10                 = 0x55, /* Sec. 7.10: Device Type
													* Specific */
    kSPCCmd_MODE_SENSE_6                   = 0x1A, /* Sec. 7.11: Device Type
													* Specific */
    kSPCCmd_MODE_SENSE_10                  = 0x5A, /* Sec. 7.12: Device Type
													* Specific */
    kSPCCmd_MOVE_MEDIUM_ATTACHED           = 0xA7, /* Defined in SMC */
    kSPCCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* Sec. 7.13: Device Type
													* Specific */
    kSPCCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* Sec. 7.14: Device Type
													* Specific */
    kSPCCmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E, /* Sec. 7.15: Device Type
													* Specific */
    kSPCCmd_READ_BUFFER                    = 0x3C, /* Sec. 7.16: Optional */
    kSPCCmd_READ_ELEMENT_STATUS_ATTACHED   = 0xB4, /* Defined in SMC */
    kSPCCmd_RECEIVE_COPY_RESULTS           = 0x84, /* Sec. 7.17: Optional */
    kSPCCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* Sec. 7.18: Optional */
    kSPCCmd_RELEASE_10                     = 0x57, /* Sec. 7.19: Device Type
													* Specific */
    kSPCCmd_RELEASE_6                      = 0x17, /* Sec. 7.20: Device Type
													* Specific */
    kSPCCmd_REPORT_DEVICE_IDENTIFIER       = 0xA3, /* Sec. 7.21: Optional */
    kSPCCmd_REPORT_LUNS                    = 0xA0, /* Sec. 7.22: Mandatory for
													* LUN Supporting devices*/
    kSPCCmd_REQUEST_SENSE                  = 0x03, /* Sec. 7.23: Device Type
													* Specific */
    kSPCCmd_RESERVE_10                     = 0x56, /* Sec. 7.24: Device Type
													* Specific */
    kSPCCmd_RESERVE_6                      = 0x16, /* Sec. 7.25: Device Type
													* Specific */
    kSPCCmd_SEND_DIAGNOSTICS               = 0x1D, /* Sec. 7.26: Optional */
    kSPCCmd_SET_DEVICE_IDENTIFIER          = 0xA4, /* Sec. 7.27: Optional */
    kSPCCmd_TEST_UNIT_READY                = 0x00, /* Sec. 7.28: Mandatory */
    kSPCCmd_WRITE_BUFFER                   = 0x3B  /* Sec. 7.29: Optional */
};

#pragma mark -
#pragma mark 0x00 SBC Direct Access Commands
/* Commands defined by the T10:990-D SCSI-3 Block Commands (SBC) command
 * specification.  The definitions and section numbers are based on section 6.1
 * of the revision 8c, 13 November 1997 version of the specification. 
 */
enum
{
    kSBCCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kSBCCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kSBCCmd_COPY                           = 0x18, /* SPC: Optional */
    kSBCCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional*/
    kSBCCmd_FORMAT_UNIT                    = 0x04, /* Sec. 6.1.1: Mandatory */
    kSBCCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kSBCCmd_LOCK_UNLOCK_CACHE              = 0x36, /* Sec. 6.1.2: Optional */
    kSBCCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kSBCCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kSBCCmd_MODE_SELECT_6                  = 0x15, /* SPC: Optional */
    kSBCCmd_MODE_SELECT_10                 = 0x55, /* SPC: Optional */
    kSBCCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Optional */
    kSBCCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Optional */
    kSBCCmd_MOVE_MEDIUM_ATTACHED           = 0xA7, /* SMC: Optional */
    kSBCCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* SPC: Optional */
    kSBCCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* SPC: Optional */
    kSBCCmd_PREFETCH                       = 0x34, /* Sec. 6.1.3: Optional */
    kSBCCmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E, /* SPC: Optional */
    kSBCCmd_READ_6                         = 0x08, /* Sec. 6.1.4: Mandatory */
    kSBCCmd_READ_10                        = 0x28, /* Sec. 6.1.5: Mandatory */
    kSBCCmd_READ_12                        = 0xA8, /* Sec. 6.2.4: Optional */
    kSBCCmd_READ_BUFFER                    = 0x3C, /* SPC: Optional */
    kSBCCmd_READ_CAPACITY                  = 0x25, /* Sec. 6.1.6: Mandatory */
    kSBCCmd_READ_DEFECT_DATA_10            = 0x37, /* Sec. 6.1.7: Optional */
    kSBCCmd_READ_DEFECT_DATA_12            = 0xB7, /* Sec. 6.2.5: Optional */
    kSBCCmd_READ_ELEMENT_STATUS_ATTACHED   = 0xB4, /* SMC: Optional */
    kSBCCmd_READ_GENERATION			       = 0x29, /* Sec. 6.2.6: Optional */
    kSBCCmd_READ_LONG                      = 0x3E, /* Sec. 6.1.8: Optional */
    kSBCCmd_READ_UPDATED_BLOCK_10		   = 0x2D, /* Sec. 6.2.7: Optional */
    kSBCCmd_REASSIGN_BLOCKS                = 0x07, /* Sec. 6.1.9: Optional */
    kSBCCmd_REBUILD                        = 0x81, /* Sec. 6.1.10: Optional */
    kSBCCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* SPC: Optional */
    kSBCCmd_REGENERATE                     = 0x82, /* Sec. 6.1.11: Optional */
    kSBCCmd_RELEASE_6                      = 0x17, /* SPC: Optional */
    kSBCCmd_RELEASE_10                     = 0x57, /* SPC: Mandatory */
    kSBCCmd_REPORT_LUNS                    = 0xA0, /* SPC: Optional */
    kSBCCmd_REQUEST_SENSE                  = 0x03, /* SPC: Mandatory */
    kSBCCmd_RESERVE_6                      = 0x16, /* SPC: Optional */
    kSBCCmd_RESERVE_10                     = 0x56, /* SPC: Mandatory */
    kSBCCmd_REZERO_UNIT                    = 0x01, /* Obsolete */
    kSBCCmd_SEARCH_DATA_EQUAL_10           = 0x31, /* Obsolete */
    kSBCCmd_SEARCH_DATA_HIGH_10            = 0x30, /* Obsolete */
    kSBCCmd_SEARCH_DATA_LOW_10             = 0x32, /* Obsolete */
    kSBCCmd_SEEK_6                         = 0x0B, /* Obsolete */
    kSBCCmd_SEEK_10                        = 0x2B, /* Sec. 6.1.12: Optional */
    kSBCCmd_SEND_DIAGNOSTICS               = 0x1D, /* SPC: Mandatory */
    kSBCCmd_SET_LIMITS_10                  = 0x33, /* Sec. 6.1.13: Optional */
    kSBCCmd_SET_LIMITS_12                  = 0xB3, /* Sec. 6.2.8: Optional */
    kSBCCmd_START_STOP_UNIT                = 0x1B, /* Sec. 6.1.14: Optional */
    kSBCCmd_SYNCHRONIZE_CACHE              = 0x35, /* Sec. 6.1.15: Optional */
    kSBCCmd_TEST_UNIT_READY                = 0x00, /* SPC: Mandatory */
	kSBCCmd_UPDATE_BLOCK                   = 0x3D, /* Sec. 6.2.9: Optional */
    kSBCCmd_VERIFY_10                      = 0x2F, /* Sec. 6.1.16: Optional */
    kSBCCmd_WRITE_6                        = 0x0A, /* Sec. 6.1.17: Optional */
    kSBCCmd_WRITE_10                       = 0x2A, /* Sec. 6.1.18: Optional */
    kSBCCmd_WRITE_12                       = 0xAA, /* Sec. 6.2.13: Optional */
    kSBCCmd_WRITE_AND_VERIFY_10            = 0x2E, /* Sec. 6.1.19: Optional */
    kSBCCmd_WRITE_AND_VERIFY_12            = 0xAE, /* Sec. 6.2.15: Optional */
    kSBCCmd_WRITE_BUFFER                   = 0x3B, /* SPC: Optional */
    kSBCCmd_WRITE_LONG                     = 0x3F, /* Sec. 6.1.20: Optional */
    kSBCCmd_WRITE_SAME                     = 0x41, /* Sec. 6.1.21: Optional */
    kSBCCmd_XDREAD                         = 0x52, /* Sec. 6.1.22: Optional */
    kSBCCmd_XDWRITE                        = 0x50, /* Sec. 6.1.23: Optional */
    kSBCCmd_XDWRITE_EXTENDED               = 0x80, /* Sec. 6.1.24: Optional */
    kSBCCmd_XPWRITE                        = 0x51  /* Sec. 6.1.25: Optional */
};

#pragma mark -
#pragma mark 0x01 SSC Sequential Access Commands
/* Commands defined by the T10:997-D SCSI-3 Stream Commands (SSC) command
 * specification.  The definitions and section numbers are based on section 5
 * of the revision 22, January 1, 2000 version of the specification. 
 */
enum
{
    kSSCSeqCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kSSCSeqCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kSSCSeqCmd_COPY                           = 0x18, /* SPC: Optional */
    kSSCSeqCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional */
    kSSCSeqCmd_ERASE                          = 0x19, /* Sec. 5.3.1: Mandatory */
    kSSCSeqCmd_FORMAT_MEDIUM                  = 0x04, /* Sec. 5.3.2: Optional */
    kSSCSeqCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kSSCSeqCmd_LOAD_UNLOAD                    = 0x1B, /* Sec. 5.3.3: Optional */
    kSSCSeqCmd_LOCATE                         = 0x2B, /* Sec. 5.3.4: Optional */
    kSSCSeqCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kSSCSeqCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kSSCSeqCmd_MODE_SELECT_6                  = 0x15, /* SPC: Mandatory */
    kSSCSeqCmd_MODE_SELECT_10                 = 0x55, /* SPC: Optional */
    kSSCSeqCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Mandatory */
    kSSCSeqCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Optional */
    kSSCSeqCmd_MOVE_MEDIUM                    = 0xA5, /* SMC: Optional */
    kSSCSeqCmd_MOVE_MEDIUM_ATTACHED           = 0xA7, /* SMC: Optional */
    kSSCSeqCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* SPC: Optional */
    kSSCSeqCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* SPC: Optional */
    kSSCSeqCmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E, /* SPC: Optional */
    kSSCSeqCmd_READ_6                         = 0x08, /* Sec. 5.3.5: Mandatory */
    kSSCSeqCmd_READ_BLOCK_LIMITS              = 0x05, /* Sec. 5.3.6: Mandatory */
    kSSCSeqCmd_READ_BUFFER                    = 0x3C, /* SPC: Optional */
    kSSCSeqCmd_READ_ELEMENT_STATUS            = 0xB8, /* SMC: Optional */
    kSSCSeqCmd_READ_ELEMENT_STATUS_ATTACHED   = 0xB4, /* SMC: Optional */
    kSSCSeqCmd_READ_POSITION                  = 0x34, /* Sec. 5.3.7: Mandatory */
    kSSCSeqCmd_READ_REVERSE                   = 0x0F, /* Sec. 5.3.8: Optional */
    kSSCSeqCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* SPC: Optional */
    kSSCSeqCmd_RECOVER_BUFFERED_DATA          = 0x14, /* Sec. 5.3.9: Optional */
    kSSCSeqCmd_RELEASE_6                      = 0x17, /* SPC: Mandatory */
    kSSCSeqCmd_RELEASE_10                     = 0x57, /* SPC: Mandatory */
    kSSCSeqCmd_REPORT_DENSITY_SUPPORT         = 0x44, /* Sec. 5.3.10: Mandatory*/
    kSSCSeqCmd_REPORT_LUNS                    = 0xA0, /* SPC: Mandatory */
    kSSCSeqCmd_REQUEST_SENSE                  = 0x03, /* SPC: Mandatory */
    kSSCSeqCmd_RESERVE_6                      = 0x16, /* SPC: Mandatory */
    kSSCSeqCmd_RESERVE_10                     = 0x56, /* SPC: Mandatory */
    kSSCSeqCmd_REWIND                         = 0x01, /* Sec. 5.3.11: Mandatory*/
    kSSCSeqCmd_SEND_DIAGNOSTICS               = 0x1D, /* SPC: Mandatory */
    kSSCSeqCmd_SPACE                          = 0x11, /* Sec. 5.3.12: Mandatory*/
    kSSCSeqCmd_TEST_UNIT_READY                = 0x00, /* SPC: Mandatory */
    kSSCSeqCmd_VERIFY_6                       = 0x13, /* Sec. 5.3.13: Optional */
    kSSCSeqCmd_WRITE_6                        = 0x0A, /* Sec. 5.3.14: Mandatory*/
    kSSCSeqCmd_WRITE_BUFFER                   = 0x3B, /* SPC: Optional */
    kSSCSeqCmd_WRITE_FILEMARKS                = 0x10  /* Sec. 5.3.15: Mandatory*/
};

#pragma mark -
#pragma mark 0x02 SSC Printer Commands
/* Commands defined by the T10:997-D SCSI-3 Stream Commands (SSC) command
 * specification.  The definitions and section numbers are based on section 6
 * of the revision 22, January 1, 2000 version of the specification. 
 */
enum 
{
    kSSCPrinterCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kSSCPrinterCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kSSCPrinterCmd_COPY                           = 0x18, /* SPC: Optional */
    kSSCPrinterCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional */
    kSSCPrinterCmd_FORMAT                         = 0x04, /* Sec. 6.2.1: Optional */
    kSSCPrinterCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kSSCPrinterCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kSSCPrinterCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kSSCPrinterCmd_MODE_SELECT_6                  = 0x15, /* SPC: Mandatory */
    kSSCPrinterCmd_MODE_SELECT_10                 = 0x55, /* SPC: Optional */
    kSSCPrinterCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Mandatory */
    kSSCPrinterCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Optional */
    kSSCPrinterCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* SPC: Optional */
    kSSCPrinterCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* SPC: Optional */
    kSSCPrinterCmd_PRINT                          = 0x0A, /* Sec. 6.2.2: Mandatory */
    kSSCPrinterCmd_READ_BUFFER                    = 0x3C, /* SPC: Optional */
    kSSCPrinterCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* SPC: Optional */
    kSSCPrinterCmd_RECOVER_BUFFERED_DATA          = 0x14, /* Sec. 6.2.3: Optional */
    kSSCPrinterCmd_RELEASE_6                      = 0x17, /* SPC: Mandatory */
    kSSCPrinterCmd_RELEASE_10                     = 0x57, /* SPC: Mandatory */
    kSSCPrinterCmd_REPORT_LUNS                    = 0xA0, /* SPC: Mandatory */
    kSSCPrinterCmd_REQUEST_SENSE                  = 0x03, /* SPC: Mandatory */
    kSSCPrinterCmd_RESERVE_6                      = 0x16, /* SPC: Mandatory */
    kSSCPrinterCmd_RESERVE_10                     = 0x56, /* SPC: Mandatory */
    kSSCPrinterCmd_SEND_DIAGNOSTICS               = 0x1D, /* SPC: Mandatory */
    kSSCPrinterCmd_SLEW_AND_PRINT                 = 0x0B, /* Sec. 6.2.4: Optional */
    kSSCPrinterCmd_STOP_PRINT                     = 0x1B, /* Sec. 6.2.5: Optional */
    kSSCPrinterCmd_SYNCHRONIZE_BUFFER             = 0x10, /* Sec. 6.2.6: Optional */
    kSSCPrinterCmd_TEST_UNIT_READY                = 0x00, /* SPC: Mandatory */
    kSSCPrinterCmd_WRITE_BUFFER                   = 0x3B  /* SPC: Optional */
};
  
#pragma mark -
#pragma mark 0x03 SPC Processor Commands
/* Commands defined by the T10:1236-D SCSI Primary Commands-2 (SPC-2) 
 * command specification.  The definitions and section numbers are based on
 * section 9 of the revision 18, 21 May 2000 version of the specification.
 */
enum 
{
    kSPCProcCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kSPCProcCmd_COMPARE                        = 0x39, /* Sec. 7.2: Optional */
    kSPCProcCmd_COPY                           = 0x18, /* Sec. 7.3: Optional */
    kSPCProcCmd_COPY_AND_VERIFY                = 0x3A, /* Sec. 7.4: Optional */
    kSPCProcCmd_EXTENDED_COPY                  = 0x83, /* Sec. 7.5: Optional */
    kSPCProcCmd_INQUIRY                        = 0x12, /* Sec. 7.6: Mandatory */
    kSPCProcCmd_LOG_SELECT                     = 0x4C, /* Sec. 7.7: Optional */
    kSPCProcCmd_LOG_SENSE                      = 0x4D, /* Sec. 7.8: Optional */
    kSPCProcCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* Sec. 7.13: Optional */
    kSPCProcCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* Sec. 7.14: Optional */
    kSPCProcCmd_READ_BUFFER                    = 0x3C, /* Sec. 7.16: Optional */
    kSPCProcCmd_RECEIVE                        = 0x08, /* Sec. 9.2: Optional */
    kSPCProcCmd_RECEIVE_COPY_RESULTS           = 0x84, /* Sec. 7.17: Optional */
    kSPCProcCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* Sec. 7.18: Optional */
    kSPCProcCmd_RELEASE_10                     = 0x57, /* Sec. 7.19: Optional */
    kSPCProcCmd_RELEASE_6                      = 0x17, /* Sec. 7.20: Optional */
    kSPCProcCmd_REPORT_LUNS                    = 0xA0, /* Sec. 7.22: Optional */
    kSPCProcCmd_REQUEST_SENSE                  = 0x03, /* Sec. 7.23: Mandatory */
    kSPCProcCmd_RESERVE_10                     = 0x56, /* Sec. 7.24: Optional */
    kSPCProcCmd_RESERVE_6                      = 0x16, /* Sec. 7.25: Optional */
    kSPCProcCmd_SEND                           = 0x0A, /* Sec. 9.3: Optional */
    kSPCProcCmd_SEND_DIAGNOSTICS               = 0x1D, /* Sec. 7.26: Mandatory */
    kSPCProcCmd_TEST_UNIT_READY                = 0x00, /* Sec. 7.27: Mandatory */
    kSPCProcCmd_WRITE_BUFFER                   = 0x3B  /* Sec. 7.29: Optional */
};

#pragma mark -
#pragma mark 0x04 SBC Write Once Commands
/* Commands defined by the T10:990-D SCSI-3 Block Commands (SBC) command
 * specification.  The definitions and section numbers are based on section 6.3
 * of the revision 8c, 13 November 1997 version of the specification. 
 */
enum
{
    kSBCWOCmd_CHANGE_DEFINITION              = 0x40, /* SPC: Optional */
    kSBCWOCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kSBCWOCmd_COPY                           = 0x18, /* SPC: Optional */
    kSBCWOCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional*/
    kSBCWOCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kSBCWOCmd_LOCK_UNLOCK_CACHE              = 0x36, /* Sec. 6.1.2: Optional */
    kSBCWOCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kSBCWOCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kSBCWOCmd_MEDIUM_SCAN                    = 0x38, /* Sec. 6.2.3: Optional */
    kSBCWOCmd_MODE_SELECT_6                  = 0x15, /* SPC: Optional */
    kSBCWOCmd_MODE_SELECT_10                 = 0x55, /* SPC: Optional */
    kSBCWOCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Optional */
    kSBCWOCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Optional */
    kSBCWOCmd_MOVE_MEDIUM                    = 0xA5, /* SMC: Optional */
    kSBCWOCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* SPC: Optional */
    kSBCWOCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* SPC: Optional */
    kSBCWOCmd_PREFETCH                       = 0x34, /* Sec. 6.1.3: Optional */
    kSBCWOCmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E, /* SPC: Optional */
    kSBCWOCmd_READ_6                         = 0x08, /* Sec. 6.1.4: Optional */
    kSBCWOCmd_READ_10                        = 0x28, /* Sec. 6.1.5: Mandatory */
    kSBCWOCmd_READ_12                        = 0xA8, /* Sec. 6.2.4: Optional */
    kSBCWOCmd_READ_BUFFER                    = 0x3C, /* SPC: Optional */
    kSBCWOCmd_READ_CAPACITY                  = 0x25, /* Sec. 6.1.6: Mandatory */
    kSBCWOCmd_READ_ELEMENT_STATUS            = 0xB8, /* SMC: Optional */
    kSBCWOCmd_READ_LONG                      = 0x3E, /* Sec. 6.1.8: Optional */
    kSBCWOCmd_REASSIGN_BLOCKS                = 0x07, /* Sec. 6.1.9: Optional */
    kSBCWOCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* SPC: Optional */
    kSBCWOCmd_RELEASE_6                      = 0x17, /* SPC: Optional */
    kSBCWOCmd_RELEASE_10                     = 0x57, /* SPC: Mandatory */
    kSBCWOCmd_REQUEST_SENSE                  = 0x03, /* SPC: Mandatory */
    kSBCWOCmd_RESERVE_6                      = 0x16, /* SPC: Optional */
    kSBCWOCmd_RESERVE_10                     = 0x56, /* SPC: Mandatory */
    kSBCWOCmd_REZERO_UNIT                    = 0x01, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_EQUAL_10           = 0x31, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_EQUAL_12           = 0xB1, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_HIGH_10            = 0x30, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_HIGH_12            = 0xB0, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_LOW_10             = 0x32, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_LOW_12             = 0xB2, /* Obsolete */
    kSBCWOCmd_SEEK_6                         = 0x0B, /* Obsolete */
    kSBCWOCmd_SEEK_10                        = 0x2B, /* Sec. 6.1.12: Optional */
    kSBCWOCmd_SEND_DIAGNOSTICS               = 0x1D, /* SPC: Mandatory */
    kSBCWOCmd_SET_LIMITS_10                  = 0x33, /* Sec. 6.1.13: Optional */
    kSBCWOCmd_SET_LIMITS_12                  = 0xB3, /* Sec. 6.2.8: Optional */
    kSBCWOCmd_START_STOP_UNIT                = 0x1B, /* Sec. 6.1.14: Optional */
    kSBCWOCmd_SYNCHRONIZE_CACHE              = 0x35, /* Sec. 6.1.15: Optional */
    kSBCWOCmd_TEST_UNIT_READY                = 0x00, /* SPC: Mandatory */
    kSBCWOCmd_VERIFY_10                      = 0x2F, /* Sec. 6.2.10: Optional */
    kSBCWOCmd_VERIFY_12                      = 0xAF, /* Sec. 6.2.11: Optional */
    kSBCWOCmd_WRITE_6                        = 0x0A, /* Sec. 6.1.17: Optional */
    kSBCWOCmd_WRITE_10                       = 0x2A, /* Sec. 6.2.10: Mandatory*/
    kSBCWOCmd_WRITE_12                       = 0xAA, /* Sec. 6.2.13: Optional */
    kSBCWOCmd_WRITE_AND_VERIFY_10            = 0x2E, /* Sec. 6.2.14: Optional */
    kSBCWOCmd_WRITE_AND_VERIFY_12            = 0xAE, /* Sec. 6.2.15: Optional */
    kSBCWOCmd_WRITE_BUFFER                   = 0x3B, /* SPC: Optional */
    kSBCWOCmd_WRITE_LONG                     = 0x3F  /* Sec. 6.1.20: Optional */
};

#pragma mark -
#pragma mark 0x05 MMC CD-ROM Commands
/* Commands defined by the T10:1363-D SCSI Multimedia Commands-3 (MMC-3) 
 * specification.  The definitions and section numbers are based on section 6.1
 * of the revision 01, March 03, 2000 version of the specification. 
 *
 * NOTE: The comments following each command may not be accurate.  These are
 * not from the MMC-3 specification, but have been derived from the SCSI-2 and
 * original MMC specifications.  Unlike the other SCSI command specifications,
 * MMC-2 and MMC-3 do not provide a command requirement type and therefore does
 * not relist the SPC commands with these requirements as they apply to MMC
 * devices.  The MMC-2 and MMC-3 specifications also refer back to the SBC
 * specification which seems invalid since MMC devices do not represent a
 * Peripheral Device Type defined by SBC.  It is assumed that the SBC
 * references refer to the Peripheral Device Type 0x00 - Direct Access Commands
 * definitions from that specification.
 */
enum 
{
    kMMCCmd_BLANK                          = 0xA1, /* Sec. 6.1.1: */
    kMMCCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kMMCCmd_CLOSE_TRACK_SESSION            = 0x5B, /* Sec. 6.1.2: */
    kMMCCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kMMCCmd_COPY                           = 0x18, /* SPC: Optional */
    kMMCCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional */
    kMMCCmd_ERASE                          = 0x2C, /* SBC: */
    kMMCCmd_FORMAT_UNIT                    = 0x04, /* Sec. 6.1.3: */
    kMMCCmd_GET_CONFIGURATION              = 0x46, /* Sec. 6.1.4: */
    kMMCCmd_GET_EVENT_STATUS_NOTIFICATION  = 0x4A, /* Sec. 6.1.5: */
    kMMCCmd_GET_PERFORMANCE                = 0xAC, /* Sec. 6.1.6: */
    kMMCCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kMMCCmd_LOAD_UNLOAD_MEDIUM             = 0xA6, /* Sec. 6.1.7: */
    kMMCCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kMMCCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kMMCCmd_MECHANISM_STATUS               = 0xBD, /* Sec. 6.1.8: */
    kMMCCmd_MODE_SELECT_6                  = 0x15, /* SPC: Mandatory */
    kMMCCmd_MODE_SELECT_10                 = 0x55, /* SPC: Mandatory */
    kMMCCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Mandatory */
    kMMCCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Mandatory */
    kMMCCmd_PAUSE_RESUME                   = 0x4B, /* Sec. 6.1.9: */
    kMMCCmd_PLAY_AUDIO_10                  = 0x45, /* Sec. 6.1.10: */
    kMMCCmd_PLAY_AUDIO_12                  = 0xA5, /* Sec. 6.1.11: */
    kMMCCmd_PLAY_AUDIO_MSF                 = 0x47, /* Sec. 6.1.12: */
    kMMCCmd_PLAY_AUDIO_TRACK_INDEX         = 0x48, /* Obsolete */
    kMMCCmd_PLAY_CD                        = 0xBC, /* Sec. 6.1.13: */
    kMMCCmd_PLAY_RELATIVE_10               = 0x49, /* Obsolete */
    kMMCCmd_PLAY_RELATIVE_12               = 0xA9, /* Obsolete */
    kMMCCmd_PREFETCH                       = 0x34, /* Optional */
    kMMCCmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E, /* Optional */
    kMMCCmd_READ_6                         = 0x08, /* Optional */
    kMMCCmd_READ_10                        = 0x28, /* Mandatory */
    kMMCCmd_READ_12                        = 0xA8, /* Optional */
    kMMCCmd_READ_BUFFER                    = 0x3C, /* Optional */
    kMMCCmd_READ_BUFFER_CAPACITY           = 0x5C, /* Sec. 6.1.15: */
    kMMCCmd_READ_CD                        = 0xBE, /* Sec. 6.1.16: */
    kMMCCmd_READ_CD_MSF                    = 0xB9, /* Sec. 6.1.17: */
    kMMCCmd_READ_CAPACITY                  = 0x25, /* Sec. 6.1.18: */
    kMMCCmd_READ_DISC_INFORMATION          = 0x51, /* Sec. 6.1.19: */
    kMMCCmd_READ_DVD_STRUCTURE             = 0xAD, /* Sec. 6.1.20: */
    kMMCCmd_READ_DISC_STRUCTURE            = 0xAD, /* Sec. 6.1.20: */
    kMMCCmd_READ_FORMAT_CAPACITIES         = 0x23, /* Sec. 6.1.21: */
    kMMCCmd_READ_HEADER                    = 0x44, /* Sec. 6.1.22: */
    kMMCCmd_READ_LONG                      = 0x3E, /* Optional */
    kMMCCmd_READ_MASTER_CUE                = 0x59, /* Sec. 6.1.23: */
    kMMCCmd_READ_SUB_CHANNEL               = 0x42, /* Sec. 6.1.24: */
    kMMCCmd_READ_TOC_PMA_ATIP              = 0x43, /* Sec. 6.1.25: */
    kMMCCmd_READ_TRACK_INFORMATION         = 0x52, /* Sec. 6.1.27: */
    kMMCCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* Optional */
    kMMCCmd_RELEASE_6                      = 0x17, /* Mandatory */
    kMMCCmd_RELEASE_10                     = 0x57, /* Optional */
    kMMCCmd_REPAIR_TRACK                   = 0x58, /* Sec. 6.1.28: */
    kMMCCmd_REPORT_KEY                     = 0xA4, /* Sec. 6.1.29: */
    kMMCCmd_REQUEST_SENSE                  = 0x03, /* Mandatory */
    kMMCCmd_RESERVE_6                      = 0x16, /* Mandatory */
    kMMCCmd_RESERVE_10                     = 0x56, /* Optional */
    kMMCCmd_RESERVE_TRACK                  = 0x53, /* Sec. 6.1.30: */
    kMMCCmd_SCAN_MMC                       = 0xBA, /* Sec. 6.1.31: */
    kMMCCmd_SEARCH_DATA_EQUAL_10           = 0x31, /* Obsolete */
    kMMCCmd_SEARCH_DATA_EQUAL_12           = 0xB1, /* Obsolete */
    kMMCCmd_SEARCH_DATA_HIGH_10            = 0x30, /* Obsolete */
    kMMCCmd_SEARCH_DATA_HIGH_12            = 0xB0, /* Obsolete */
    kMMCCmd_SEARCH_DATA_LOW_10             = 0x32, /* Obsolete */
    kMMCCmd_SEARCH_DATA_LOW_12             = 0xB2, /* Obsolete */
    kMMCCmd_SEEK_6                         = 0x0B, /* Obsolete */
    kMMCCmd_SEEK_10                        = 0x2B, /* SBC: */
    kMMCCmd_SEND_CUE_SHEET                 = 0x5D, /* Sec. 6.1.32: */
    kMMCCmd_SEND_DIAGNOSTICS               = 0x1D, /* Mandatory */
    kMMCCmd_SEND_DVD_STRUCTURE             = 0xBF, /* Sec. 6.1.33: */
    kMMCCmd_SEND_EVENT                     = 0xA2, /* Sec. 6.1.34: */
    kMMCCmd_SEND_KEY                       = 0xA3, /* Sec. 6.1.35: */
    kMMCCmd_SEND_OPC_INFORMATION           = 0x54, /* Sec. 6.1.36: */
    kMMCCmd_SET_CD_SPEED                   = 0xBB, /* Sec. 6.1.37: */
    kMMCCmd_SET_LIMITS_10                  = 0x33, /* Optional */
    kMMCCmd_SET_LIMITS_12                  = 0xB3, /* Optional */
    kMMCCmd_SET_READ_AHEAD                 = 0xA7, /* Sec. 6.1.38: */
    kMMCCmd_SET_STREAMING                  = 0xB6, /* Sec. 6.1.39: */
    kMMCCmd_START_STOP_UNIT                = 0x1B, /* Optional */
    kMMCCmd_STOP_PLAY_SCAN                 = 0x4E, /* Sec. 6.1.40: */
    kMMCCmd_SYNCHRONIZE_CACHE              = 0x35, /* Sec. 6.1.41: */
    kMMCCmd_TEST_UNIT_READY                = 0x00, /* Mandatory */
    kMMCCmd_VERIFY_10                      = 0x2F, /* Optional */
    kMMCCmd_VERIFY_12                      = 0xAF, /* Optional */
    kMMCCmd_WRITE_10                       = 0x2A, /* Sec. 6.1.42: */
    kMMCCmd_WRITE_12                       = 0xAA, /* Sec. 6.1.43: */
    kMMCCmd_WRITE_AND_VERIFY_10            = 0x2E, /* Sec. 6.1.44: */
    kMMCCmd_WRITE_BUFFER                   = 0x3B  /* Optional */
};

#pragma mark -
#pragma mark 0x06 SGC Scanner Commands
/* Commands defined by the T10:998-D SCSI-3 Graphics Commands (SGC)
 * specification.  The definitions and section numbers are based on section 6
 * of the revision 0, April 1995 version of the specification. 
 */
enum 
{
    kSGCCmd_CHANGE_DEFINITION              = 0x40, /* SPC: Optional */
    kSGCCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kSGCCmd_COPY                           = 0x18, /* SPC: Optional */
    kSGCCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional */
    kSGCCmd_GET_DATA_BUFFER_STATUS         = 0x34, /* Sec. 6.1.1: Optional */
    kSGCCmd_GET_WINDOW                     = 0x25, /* Sec. 6.1.2: Optional */
    kSGCCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kSGCCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kSGCCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kSGCCmd_MODE_SELECT_6                  = 0x15, /* SPC: Optional */
    kSGCCmd_MODE_SELECT_10                 = 0x55, /* SPC: Optional */
    kSGCCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Optional */
    kSGCCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Optional */
    kSGCCmd_OBJECT_POSITION                = 0x31, /* Sec. 6.1.3: Optional */
    kSGCCmd_PORT_STATUS                    = 0x11, /* SPC (??): Mandatory
													* for dual port devices */
    kSGCCmd_READ                           = 0x28, /* Sec. 6.1.4: Mandatory */
    kSGCCmd_READ_BUFFER                    = 0x3C, /* SPC: Optional */
    kSGCCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* SPC: Optional */
    kSGCCmd_RELEASE_6                      = 0x17, /* SPC: Mandatory */
    kSGCCmd_REQUEST_SENSE                  = 0x03, /* SPC: Mandatory */
    kSGCCmd_RESERVE_6                      = 0x16, /* SPC: Mandatory */
    kSGCCmd_SCAN                           = 0x1B, /* Sec. 6.1.5: Optional */
    kSGCCmd_SEND                           = 0x1B, /* Sec. 6.1.6: Optional */
    kSGCCmd_SEND_DIAGNOSTICS               = 0x1D, /* SPC: Mandatory */
    kSGCCmd_SET_WINDOW                     = 0x24, /* Sec. 6.1.7: Mandatory */
    kSGCCmd_TEST_UNIT_READY                = 0x00, /* SPC: Mandatory */
    kSGCCmd_WRITE_BUFFER                   = 0x3B  /* SPC: Optional */
};

#pragma mark -
#pragma mark 0x07 SBC Optical Media Commands
/* Commands defined by the T10:990-D SCSI-3 Block Commands (SBC) 
 * (revision 8c, 13 November 1998) command specification.  
 */

#pragma mark -
#pragma mark 0x08 SMC Medium Changer Commands
/* Commands defined by the T10:1228-D SCSI-3 Medium Changer Commands-2 (SMC-2)
 * (revision 0, March 16, 2000) command specification.  
 */
enum
{
    /* Commands For Independent Medium Changers */
    kSMCCmd_EXCHANGE_MEDIUM                = 0xA6, /* Optional */
    kSMCCmd_INITIALIZE_ELEMENT_STATUS      = 0x07, /* Optional */
    kSMCCmd_MODE_SELECT_6                  = 0x15, /* Optional */
    kSMCCmd_MODE_SELECT_10                 = 0x55, /* Optional */
    kSMCCmd_MODE_SENSE_6                   = 0x1A, /* Optional */
    kSMCCmd_MODE_SENSE_10                  = 0x5A, /* Optional */
    kSMCCmd_MOVE_MEDIUM                    = 0xA5, /* Mandatory */
    kSMCCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* Optional */
    kSMCCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* Optional */
    kSMCCmd_POSITION_TO_ELEMENT            = 0x2B, /* Optional */
    kSMCCmd_READ_ELEMENT_STATUS            = 0xB8, /* Mandatory */
    kSMCCmd_RELEASE_ELEMENT_6              = 0x16, /* Optional */
    kSMCCmd_RELEASE_ELEMENT_10             = 0x56, /* Optional */
    kSMCCmd_REQUEST_VOLUME_ELEMENT_ADDRESS = 0xB5, /* Optional */
    kSMCCmd_REQUEST_SENSE                  = 0x03, /* Mandatory */
    kSMCCmd_RESERVE_ELEMENT_6              = 0x16, /* Optional */
    kSMCCmd_RESERVE_ELEMENT_10             = 0x56  /* Optional */
};

#pragma mark -
#pragma mark 0x09 SSC Communications Commands
/* Commands defined by the T10:997-D SCSI-3 Stream Commands (SSC) 
 * (revision 22, January 1, 2000) command specification. 
 */
  
#pragma mark -
#pragma mark 0x0A ASC IT8 Prepress Commands
#pragma mark 0x0B ASC IT8 Prepress Commands
/* Commands defined by the ASC IT8 <title goes here> specification
 * (revision xx, month day, year) command specification.  
 */
#if 0
enum
{
};
#endif

#pragma mark -
#pragma mark 0x0C SCC Array Controller Commands
/* Commands defined by the ANSI NCITS.318-199x SCSI Controller
 * Commands (SCC-2) ratified command specification.  
 */
enum
{
    kSCCCmd_MAINTENANCE_IN                 = 0xA3, /* Mandatory */
    kSCCCmd_MAINTENANCE_OUT                = 0xA4, /* Optional */
    kSCCCmd_MODE_SELECT_6                  = 0x15, /* Optional */
    kSCCCmd_MODE_SELECT_10                 = 0x55, /* Optional */
    kSCCCmd_MODE_SENSE_6                   = 0x1A, /* Optional */
    kSCCCmd_MODE_SENSE_10                  = 0x5A, /* Optional */
    kSCCCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* Optional */
    kSCCCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* Optional */
    kSCCCmd_PORT_STATUS                    = 0x1F, /* Optional */
    kSCCCmd_REDUNDANCY_GROUP_IN            = 0xBA, /* Mandatory */
    kSCCCmd_REDUNDANCY_GROUP_OUT           = 0xBB, /* Optional */
    kSCCCmd_RELEASE_6                      = 0x17, /* Optional */
    kSCCCmd_RELEASE_10                     = 0x57, /* Optional */
    kSCCCmd_REPORT_LUNS                    = 0xA0, /* Mandatory */
    kSCCCmd_REQUEST_SENSE                  = 0x03, /* Mandatory */
    kSCCCmd_RESERVE_6                      = 0x16, /* Optional */
    kSCCCmd_RESERVE_10                     = 0x56, /* Optional*/
    kSCCCmd_SEND_DIAGNOSTICS               = 0x1D, /* Optional */
    kSCCCmd_SPARE_IN                       = 0xBC, /* Mandatory */
    kSCCCmd_SPARE_OUT                      = 0xBD  /* Optional */
};

#pragma mark -
#pragma mark 0x0D SES Enclosure Services Commands
/* Commands defined by the T10:1212-D SCSI-3 Enclosure Services (SES) 
 * (revision 8b, February 11, 1998) command specification.  
 */
enum
{
    kSESCmd_MODE_SELECT_6                  = 0x15, /* Optional */
    kSESCmd_MODE_SELECT_10                 = 0x55, /* Optional */
    kSESCmd_MODE_SENSE_6                   = 0x1A, /* Optional */
    kSESCmd_MODE_SENSE_10                  = 0x5A, /* Optional */
    kSESCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* Optional */
    kSESCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* Optional */
    kSESCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x17, /* Mandatory */
    kSESCmd_RELEASE_6                      = 0x17, /* Optional */
    kSESCmd_RELEASE_10                     = 0x57, /* Optional */
    kSESCmd_REQUEST_SENSE                  = 0x03, /* Mandatory */
    kSESCmd_RESERVE_6                      = 0x16, /* Optional */
    kSESCmd_RESERVE_10                     = 0x56, /* Optional */
    kSESCmd_SEND_DIAGNOSTICS               = 0x1D  /* Mandatory */
};

#pragma mark -
#pragma mark 0x0E RBC Reduced Block Commands
/* Commands defined by the T10:1240-D Reduced Block Commands (RBC) 
 * (revision 10a, August 18, 1999) command specification.  
 */
enum
{
    kRBCCmd_FORMAT_UNIT                    = 0x04, /* Optional */
    kRBCCmd_READ_10                        = 0x28, /* Mandatory */
    kRBCCmd_READ_CAPACITY                  = 0x25, /* Mandatory */
    kRBCCmd_START_STOP_UNIT                = 0x1B, /* Mandatory */
    kRBCCmd_SYNCHRONIZE_CACHE              = 0x35, /* Optional */
    kRBCCmd_VERIFY_10                      = 0x2F, /* Mandatory */
    kRBCCmd_WRITE_10                       = 0x2A, /* Mandatory */
    kRBCCmd_WRITE_BUFFER                   = 0x3B  /* Mandatory for fixed media
												    * Optional for removable */
};

#pragma mark -
#pragma mark 0x0F OCRW Optical Card Commands
/* Commands defined by the ISO/IEC 14776-381 SCSI Specification for
 * Optical Card Reader/Writer (OCRW) ratified command specification.  
 */
#if 0
enum
{
};
#endif

#pragma mark -
#pragma mark 0x11 OSD Object-based Storage Commands
/* Commands defined by the T10:1355-D Object-based Storage Commands (OSD) 
 * (revision 1, 18 May 2000) command specification.  
 */
#if 0
enum
{
};
#endif

#pragma mark -
#pragma mark 0x15 RMC Simplified Multimedia Commands
/* Commands defined by the T10:1364-D Reduced Multimedia Commands (RMC) 
 * (revision 1, November 11, 1999) command specification.  
 */
#if 0
enum
{
};
#endif

#endif	/* _SCSI_COMMAND_OPERATION_CODES_H_ */
                                                                                                                                                                                                                                     SCSITask.h                                                                                          0100644 0001750 0001750 00000035162 12567470660 033315  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/scsi                                                                  /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_SCSI_TASK_H_
#define _IOKIT_SCSI_TASK_H_


#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSITask
SCSITask typedefs and constants used inside the kernel and user space.

Note that the SCSITaskIdentifier is an opaque object and that directly
casting the SCSITaskIdentifier to any other type is discouraged. The SCSITask
implementation changes when necessary to accomodate architectural changes,
performance improvements, and bug fixes.

Device and protocol layer drivers that need to access information
contained in a SCSITask should use the appropriate accessor methods in
IOSCSIPrimaryCommandsDevice.h or IOSCSIProtocolServices.h
*/


/*! @typedef SCSIDeviceIdentifier
    @abstract 64-bit number to represent a SCSI Device.
	@discussion If the identifier can either be that of an initiator or a target,
    SCSIDeviceIdentifier should be used.
*/

typedef UInt64 					SCSIDeviceIdentifier;

/*! @typedef SCSITargetIdentifier
    @abstract 64-bit number to represent a SCSI Target Device.
	@discussion If the identifier is for a target only and not an initiator, then
	SCSITargetIdentifier should be used.
*/

typedef SCSIDeviceIdentifier 	SCSITargetIdentifier;

/*! @typedef SCSIInitiatorIdentifier
    @abstract 64-bit number to represent a SCSI Initiator Device.
	@discussion If the identifier is for an initiator only and not a target, then
	SCSIInitiatorIdentifier should be used.
*/

typedef SCSIDeviceIdentifier 	SCSIInitiatorIdentifier;

/*! @typedef SCSILogicalUnitBytes[8]
    @abstract 8-Byte array to represent LUN information
    @discussion The SCSI Primary Commands specification treats the 64-bits
	of LUN information as 4 2-byte structures.
	
	Use of the 64-bit SCSILogicalUnitNumber is now deprecated. Since it
	was not defined on Mac OS X how the 64-bits were encoded for hierarchical
	units and all usage was simply as a 64-bit number, changing the encoding
	scheme now would result in non-binary compatible code. New APIs have been
	added to retrieve the LUN bytes from the SCSITask and set them in the SCSITask.
 */
typedef UInt8					SCSILogicalUnitBytes[8];
typedef UInt64					SCSILogicalUnitNumber;          // DEPRECATED


/*! @typedef SCSITaggedTaskIdentifier
    @abstract 64-bit number to represent a unique task identifier.
	@discussion The Tagged Task Identifier is used when a Task has a Task Attribute other
	than SIMPLE. The SCSI Application Layer client that controls the Logical
	Unit for which a Task is intended is required to guarantee that the Task
	Tag Identifier is unique. Zero cannot be used a a Tag value as this is used
	to when a Tagged Task Identifier value is needed for a Task with a SIMPLE 
	attribute.
*/

typedef UInt64 SCSITaggedTaskIdentifier;

/*!
	@enum Untagged Task Identifier
	@discussion The Untagged Task Identifier is used to indicate no unique tag
	is associated with the Task.
	@constant kSCSIUntaggedTaskIdentifier This value means the task is untagged.
 */

enum
{
	kSCSIUntaggedTaskIdentifier = 0
};

/*!
	@typedef SCSITaskAttribute
	@abstract Attributes for task delivery.
	@discussion The Task Attribute defines how this task should be managed
	when determing order for queueing and submission to the 
	appropriate device server. The Task Attribute is set by the SCSI
	Application Layer and cannot be modified by the SCSI Protocol Layer.
	@constant kSCSITask_SIMPLE The task has a simple attribute.
	@constant kSCSITask_ORDERED The task has an ordered attribute.
	@constant kSCSITask_HEAD_OF_QUEUE The task has a head-of-queue attribute.
	@constant kSCSITask_ACA The task has an auto-contingent-allegiance attribute.
 */

typedef enum SCSITaskAttribute
{
	kSCSITask_SIMPLE			= 0,
	kSCSITask_ORDERED			= 1,
	kSCSITask_HEAD_OF_QUEUE		= 2,
	kSCSITask_ACA				= 3
} SCSITaskAttribute;

/*!
	@typedef SCSITaskState
	@abstract Attributes for task state.
	@discussion The Task State represents the current state of the task.
	The state is set to NEW_TASK when the task is created.  The SCSI Protocol
	Layer will then adjust the state as the task is queued and during
	execution. The SCSI Application Layer can examine the state to monitor
	the progress of a task. The Task State can only be modified by the SCSI
	Protocol Layer.  The SCSI Application Layer can only read the state.
	@constant kSCSITaskState_NEW_TASK The task state is new task.
	@constant kSCSITaskState_ENABLED The task is enabled and queued.
	@constant kSCSITaskState_BLOCKED The task is blocked.
	@constant kSCSITaskState_DORMANT The task is dormant.
	@constant kSCSITaskState_ENDED The task is complete.
 */

typedef enum SCSITaskState
{
	kSCSITaskState_NEW_TASK		= 0,
	kSCSITaskState_ENABLED		= 1,
	kSCSITaskState_BLOCKED		= 2,
	kSCSITaskState_DORMANT		= 3,
	kSCSITaskState_ENDED		= 4
} SCSITaskState;


/*!
	@typedef SCSIServiceResponse
	@abstract Attributes for task service response.
	@discussion The Service Response represents the execution status of
	a service request made to a Protocol Services Driver. The Service
	Response can only be modified by the SCSI Protocol Layer. The SCSI
	Application Layer can only read the state.
 */

typedef enum SCSIServiceResponse
{
	/*!
	@constant kSCSIServiceResponse_Request_In_Process
	Not defined in SAM specification, but is a service response used
	for asynchronous commands that are not yet completed.
	*/
	kSCSIServiceResponse_Request_In_Process					= 0,

	/*!
	@constant kSCSIServiceResponse_SERVICE_DELIVERY_OR_TARGET_FAILURE
	The service request failed because of a delivery or target failure.
	*/
	kSCSIServiceResponse_SERVICE_DELIVERY_OR_TARGET_FAILURE	= 1,

	/*!
	@constant kSCSIServiceResponse_TASK_COMPLETE
	The task completed.
	*/
	kSCSIServiceResponse_TASK_COMPLETE 						= 2,
	
	/*!
	@constant kSCSIServiceResponse_LINK_COMMAND_COMPLETE
	The linked command completed.
	*/
	kSCSIServiceResponse_LINK_COMMAND_COMPLETE				= 3,
	
	/*!
	@constant kSCSIServiceResponse_FUNCTION_COMPLETE
	The task management function completed.
	*/
	kSCSIServiceResponse_FUNCTION_COMPLETE					= 4,
	
	/*!
	@constant kSCSIServiceResponse_FUNCTION_REJECTED
	The task management function was rejected.
	*/
	kSCSIServiceResponse_FUNCTION_REJECTED					= 5
} SCSIServiceResponse;

/*!
	@typedef SCSITaskStatus
	@abstract Attributes for task status.
	@discussion The Task Status represents the completion status
	of the task which provides the  SCSI Application Layer with
	additional information about how to procede in handling a
	completed task.
	
	The SCSI Architecture Model specification only defines task
	status values for when a task completes with a service response
	of either TASK_COMPLETED or LINK_COMMAND_COMPLETE.
	
	Since additional information will aid in error recovery when
	a task fails to be completed by a device due to a service
	response of kSCSIServiceResponse_SERVICE_DELIVERY_OR_TARGET_FAILURE,
	additional values have been defined that can be returned by the
	SCSI Protocol Layer to inform the SCSI Application Layer of the
	cause of the delivery failure.
	
	The Task Status can only be modified by the SCSI Protocol Layer.
	The SCSI Application Layer can only read the status
*/
typedef enum SCSITaskStatus
{
	
	/*!
	@constant kSCSITaskStatus_GOOD
	The task completed with a status of GOOD.
	*/
	
	kSCSITaskStatus_GOOD						= 0x00,

	/*!
	@constant kSCSITaskStatus_CHECK_CONDITION
	The task completed with a status of CHECK_CONDITION. Additional
	information about the condition should be available in the sense data.
	*/
	
	kSCSITaskStatus_CHECK_CONDITION				= 0x02,
	
	/*!
	@constant kSCSITaskStatus_CONDITION_MET
	The task completed with a status of CONDITION_MET.
	*/
	
	kSCSITaskStatus_CONDITION_MET				= 0x04,
	
	/*!
	@constant kSCSITaskStatus_BUSY
	The task completed with a status of BUSY. The device server might need
	time to process a request and a delay may be required.
	*/
	kSCSITaskStatus_BUSY						= 0x08,

	/*!
	@constant kSCSITaskStatus_INTERMEDIATE
	The task completed with a status of INTERMEDIATE.
	*/
	kSCSITaskStatus_INTERMEDIATE				= 0x10,

	/*!
	@constant kSCSITaskStatus_INTERMEDIATE_CONDITION_MET
	The task completed with a status of INTERMEDIATE_CONDITION_MET.
	*/
	kSCSITaskStatus_INTERMEDIATE_CONDITION_MET	= 0x14,

	/*!
	@constant kSCSITaskStatus_RESERVATION_CONFLICT
	The task completed with a status of RESERVATION_CONFLICT.
	*/
	kSCSITaskStatus_RESERVATION_CONFLICT		= 0x18,

	/*!
	@constant kSCSITaskStatus_TASK_SET_FULL
	The task completed with a status of TASK_SET_FULL. The device server
	may need to complete a task before the initiator sends another.
	*/
	kSCSITaskStatus_TASK_SET_FULL				= 0x28,
	
	/*!
	@constant kSCSITaskStatus_ACA_ACTIVE
	The task completed with a status of ACA_ACTIVE. The device server may
	need the initiator to clear the Auto-Contingent Allegiance condition
	before it will respond to new commands.
	*/
	kSCSITaskStatus_ACA_ACTIVE					= 0x30,
	
	/*!
	@constant kSCSITaskStatus_TaskTimeoutOccurred
	If a task is aborted by the SCSI Protocol Layer due to it exceeding
	the timeout value specified by the task, the task status shall be
	set to kSCSITaskStatus_TaskTimeoutOccurred.
	*/
	
	kSCSITaskStatus_TaskTimeoutOccurred			= 0x01,
	
	/*!
	@constant kSCSITaskStatus_ProtocolTimeoutOccurred
	If a task is aborted by the SCSI Protocol Layer due to it exceeding a
	timeout value specified by the support for the protocol or a related
	specification, the task status shall be set to
	kSCSITaskStatus_ProtocolTimeoutOccurred.
	*/
	
	kSCSITaskStatus_ProtocolTimeoutOccurred		= 0x02,
	
	/*!
	@constant kSCSITaskStatus_DeviceNotResponding
	If a task is unable to be delivered due to a failure of the device not
	accepting the task or the device acknowledging the attempt to send it the
	device the task status shall be set to kSCSITaskStatus_DeviceNotResponding.
	This will allow the SCSI Application driver to perform the necessary steps
	to try to recover the device. This shall only be reported after the SCSI
	Protocol Layer driver has attempted all protocol specific attempts to recover
	the device.
	*/
	
	kSCSITaskStatus_DeviceNotResponding			= 0x03,
	
	/*!
	@constant kSCSITaskStatus_DeviceNotPresent
	If the task is unable to be delivered because the device has been
	detached, the task status shall be set to kSCSITaskStatus_DeviceNotPresent.
	This will allow the SCSI Application Layer to halt the sending of tasks
	to the device and, if supported, perform any device failover or system
	cleanup.
	*/
	kSCSITaskStatus_DeviceNotPresent			= 0x04,
	
	/*!
	@constant kSCSITaskStatus_DeliveryFailure
	If the task is unable to be
	delivered to the device due to a failure in the SCSI Protocol Layer,
	such as a bus reset or communications error, but the device is is
	known to be functioning properly, the task status shall be set to 
	kSCSITaskStatus_DeliveryFailure. This can also be reported if the
	task could not be delivered due to a protocol error that has since
	been corrected.
	 */
	kSCSITaskStatus_DeliveryFailure				= 0x05,
	
	/*!
	@constant kSCSITaskStatus_No_Status
	This status is not defined by
	the SCSI specifications, but is here to provide a status that can
	be returned in cases where there is not status available from the
	device or protocol, for example, when the service response is
	neither TASK_COMPLETED nor LINK_COMMAND_COMPLETE or when the
	service response is SERVICE_DELIVERY_OR_TARGET_FAILURE and the
	reason for failure could not be determined.
	*/
	kSCSITaskStatus_No_Status					= 0xFF
} SCSITaskStatus;

/*!
	@enum Command Descriptor Block Size
	@discussion Command Descriptor Block Size constants.
*/
enum
{
	/*!
	@constant kSCSICDBSize_Maximum This is the largest size a Command Descriptor
	Block can be as specified in SPC-2.
	*/
	kSCSICDBSize_Maximum 	= 16,

	/*!
	@constant kSCSICDBSize_6Byte Use this for a 6-byte CDB.
	*/
	kSCSICDBSize_6Byte 		= 6,

	/*!
	@constant kSCSICDBSize_10Byte Use this for a 10-byte CDB.
	*/
	kSCSICDBSize_10Byte 	= 10,

	/*!
	@constant kSCSICDBSize_12Byte Use this for a 12-byte CDB.
	*/
	kSCSICDBSize_12Byte 	= 12,

	/*!
	@constant kSCSICDBSize_16Byte Use this for a 16-byte CDB.
	*/
	kSCSICDBSize_16Byte 	= 16
};

typedef UInt8 SCSICommandDescriptorBlock[kSCSICDBSize_Maximum];

/*!
	@enum Data Transfer Direction
	@discussion DataTransferDirection constants.
*/
enum
{
	/*!
	@constant kSCSIDataTransfer_NoDataTransfer Use this for tasks
	that transfer no data.
	*/
	kSCSIDataTransfer_NoDataTransfer		= 0x00,

	/*!
	@constant kSCSIDataTransfer_FromInitiatorToTarget Use this for tasks that transfer
	data from the initiator to the target.
	*/
	kSCSIDataTransfer_FromInitiatorToTarget	= 0x01,

	/*!
	@constant kSCSIDataTransfer_FromTargetToInitiator Use this for tasks that transfer
	data from the target to the initiator.
	*/
	kSCSIDataTransfer_FromTargetToInitiator	= 0x02
};


#if defined(KERNEL) && defined(__cplusplus)

/* Libkern includes */
#include <libkern/c++/OSObject.h>


/*!
	@enum SCSITaskMode
	@discussion The SCSI Task mode is used by the SCSI
	Protocol Layer to indicate what mode the task is executing.
*/
typedef enum SCSITaskMode
{
	kSCSITaskMode_CommandExecution	= 1,
	kSCSITaskMode_Autosense			= 2
} SCSITaskMode;

/*!
	@typedef SCSITaskIdentifier
	@discussion This is an opaque object that represents a task.
	This is used so that drivers for both the SCSI Protocol Layer
	and the SCSI  Application Layer cannot modify the SCSITask object
	directly but must instead use the inherited methods to do so. This
	allows the implementation of SCSITask to change without directly
	impacting device and protocol layer drivers. In addition, it
	prevents changing of properties that are not allowed to be
	changed by a given layer.
*/
typedef OSObject *	SCSITaskIdentifier;


/*!
	@typedef SCSITaskCompletion
	@discussion This is the typedef for completion routines that
	work with SCSITaskIdentifiers.
*/
typedef void ( *SCSITaskCompletion )( SCSITaskIdentifier completedTask );


#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif /* _IOKIT_SCSI_TASK_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                              SCSITaskLib.h                                                                                       0100644 0001750 0001750 00000151707 12567470660 033750  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/scsi                                                                  /*
 * Copyright (c) 2001-2009 Apple Inc. All rights reserved. 
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __SCSI_TASK_LIB_H__
#define __SCSI_TASK_LIB_H__

#include <IOKit/scsi/SCSITask.h>
#include <IOKit/scsi/SCSICommandDefinitions.h>
#include <IOKit/scsi/SCSICmds_INQUIRY_Definitions.h>
#include <IOKit/scsi/SCSICmds_REQUEST_SENSE_Defs.h>

#if !KERNEL
	#include <CoreFoundation/CFPlugIn.h>
	#if COREFOUNDATION_CFPLUGINCOM_SEPARATE
		#include <CoreFoundation/CFPlugInCOM.h>
	#endif
	
	#include <IOKit/IOReturn.h>
	#include <IOKit/IOTypes.h>
	#include <IOKit/IOCFPlugIn.h>
	
#ifdef __cplusplus
extern "C" {
#endif


/*! @header SCSITaskLib
SCSITaskLib implements non-kernel task access to specific IOKit object types, namely
any SCSI Peripheral Device for which there isn't an in-kernel driver and for authoring
devices such as CD-R/W and DVD-R/W drives.
*/


// 7D66678E-08A2-11D5-A1B8-0030657D052A
/*! @defined kIOSCSITaskDeviceUserClientTypeID
    @discussion Factory ID for creating an SCSITask Device User Client. */

#define kIOSCSITaskDeviceUserClientTypeID	CFUUIDGetConstantUUIDWithBytes(NULL,			\
										0x7D, 0x66, 0x67, 0x8E, 0x08, 0xA2, 0x11, 0xD5,		\
										0xA1, 0xB8, 0x00, 0x30, 0x65, 0x7D, 0x05, 0x2A)

// 97ABCF2C-23CC-11D5-A0E8-003065704866
/*! @defined kIOMMCDeviceUserClientTypeID
    @discussion Factory ID for creating an MMC Device User Client. */

#define kIOMMCDeviceUserClientTypeID 														\
										CFUUIDGetConstantUUIDWithBytes(NULL,				\
										0x97, 0xAB, 0xCF, 0x2C, 0x23, 0xCC, 0x11, 0xD5,		\
										0xA0, 0xE8, 0x00, 0x30, 0x65, 0x70, 0x48, 0x66)

// 63326D72-08A2-11D5-865F-0030657D052A
/*! @defined kIOSCSITaskLibFactoryID
    @discussion UUID for the SCSITaskLib Factory. */

#define kIOSCSITaskLibFactoryID			CFUUIDGetConstantUUIDWithBytes(NULL,				\
										0x63, 0x32, 0x6D, 0x72, 0x08, 0xA2, 0x11, 0xD5,		\
										0x86, 0x5F, 0x00, 0x30, 0x65, 0x7D, 0x05, 0x2A)


//0B85B63C-462E-11D5-A9D6-003065704866
/*! @defined kIOSCSITaskInterfaceID
    @discussion InterfaceID for SCSITaskInterface. */
#define kIOSCSITaskInterfaceID			CFUUIDGetConstantUUIDWithBytes(NULL,				\
										0x0B, 0x85, 0xB6, 0x3C, 0x46, 0x2E, 0x11, 0xD5,		\
										0xA9, 0xD6, 0x00, 0x30, 0x65, 0x70, 0x48, 0x66)


// 1BBC4132-08A5-11D5-90ED-0030657D052A
/*! @defined kIOSCSITaskDeviceInterfaceID
    @discussion InterfaceID for SCSITaskDeviceInterface. */
#define kIOSCSITaskDeviceInterfaceID 														\
                                        CFUUIDGetConstantUUIDWithBytes(NULL,				\
										0x1B, 0xBC, 0x41, 0x32, 0x08, 0xA5, 0x11, 0xD5,		\
										0x90, 0xED, 0x00, 0x30, 0x65, 0x7D, 0x05, 0x2A)

// 1F651106-23CC-11D5-BBDB-003065704866
/*! @defined kIOMMCDeviceInterfaceID
    @discussion InterfaceID for MMCDeviceInterface. */
#define kIOMMCDeviceInterfaceID 															\
                                        CFUUIDGetConstantUUIDWithBytes(NULL,				\
										0x1F, 0x65, 0x11, 0x06, 0x23, 0xCC, 0x11, 0xD5,		\
										0xBB, 0xDB, 0x00, 0x30, 0x65, 0x70, 0x48, 0x66)


// The following UUID constants are deprecated because of possible name-space collisions
// Eventually this switch will be set to 0 and then removed entirely.
#define OLD_UUIDS 1
#if OLD_UUIDS

#define kSCSITaskDeviceInterfaceID		kIOSCSITaskDeviceInterfaceID
#define kMMCDeviceInterfaceID			kIOMMCDeviceInterfaceID
#define kSCSITaskInterfaceID			kIOSCSITaskInterfaceID
#define kSCSITaskDeviceUserClientTypeID	kIOSCSITaskDeviceUserClientTypeID
#define kMMCDeviceUserClientTypeID 		kIOMMCDeviceUserClientTypeID
#define kSCSITaskLibFactoryID 			kIOSCSITaskLibFactoryID

#endif /* OLD_UUIDS */


#endif /* !KERNEL */

/*! @defined kIOPropertySCSITaskUserClientInstanceGUID
    @discussion IORegistry property for the SCSITaskUserClient GUID.
	This GUID helps uniquely identify and track SCSITask enabled devices */

#define kIOPropertySCSITaskUserClientInstanceGUID	"SCSITaskUserClient GUID"

/*! @defined kIOPropertySCSITaskDeviceCategory
    @discussion IORegistry property for the SCSITaskUserClient.
	This category identifies which type of device and interface
	to the device is used in conjunction with the SCSITaskUserClient. */

#define kIOPropertySCSITaskDeviceCategory			"SCSITaskDeviceCategory"

/*! @defined kIOPropertySCSITaskUserClientDevice
    @discussion IORegistry property for the SCSI Task User Client.
	This property identifies an SCSITask enabled device. */

#define kIOPropertySCSITaskUserClientDevice			"SCSITaskUserClientDevice"

/*! @defined kIOPropertySCSITaskAuthoringDevice
    @discussion IORegistry property for the SCSI Task User Client.
	This property identifies an SCSITask enabled device capable of authoring. */

#define kIOPropertySCSITaskAuthoringDevice			"SCSITaskAuthoringDevice"

/*!
	@enum MMCDeviceTrayState
	@abstract Used to identify the state of an MMCDevice's tray (if applicable).
	@discussion Used to identify the state of an MMCDevice's tray (if applicable).
	@constant kMMCDeviceTrayClosed This value means the tray is closed.
	@constant kMMCDeviceTrayOpen This value means the tray is open.
 */

enum
{
	kMMCDeviceTrayClosed 	= 0,
	kMMCDeviceTrayOpen		= 1,
	kMMCDeviceTrayMask		= 0x1
};


#if defined(__LP64__)
typedef IOAddressRange	SCSITaskSGElement;
#else
typedef IOVirtualRange	SCSITaskSGElement;
#endif


#if !KERNEL

/*! @typedef SCSITaskCallbackFunction
    @abstract Asynchronous callback routine definition.
	@discussion Asynchronous callback routine definition. Any function which is used
	as a callback routine for SCSITasks must conform to this function definition.
	@param serviceResponse An SCSIServiceResponse returned by the protocol transport.
	@param taskStatus An SCSITaskStatus to indicate the task's status
	@param bytesTransferred A total byte count of bytes transferred.
    @param refCon The refCon passed when the task was executed.
*/

typedef void ( *SCSITaskCallbackFunction ) ( SCSIServiceResponse 	serviceResponse,
											 SCSITaskStatus 		taskStatus,
											 UInt64 				bytesTransferred,
											 void *					refCon );

/*! 
	@class SCSITaskInterface
    @abstract Basic interface for a SCSITask.  
    @discussion After rendezvous with a SCSITask Device in the IORegistry you can create
    an instance of this interface using the CreateSCSITask method in the
    SCSITaskDeviceInterface. Once you have this interface, or one of its subclasses,
    you can manipulate SCSITasks to send to the device.
*/

typedef struct SCSITaskInterface
{

	IUNKNOWN_C_GUTS;
	
	/*! Interface version */
	UInt16	version;
	
	/*! Interface revision */
	UInt16	revision;
	
	/*! @function IsTaskActive
    @abstract Method to find out if the task is active or not.
    @discussion Method to find out if the task is active or not. The task is
    considered "active" if the SCSITaskState is not kSCSITaskState_NEW
    nor kSCSITaskState_ENDED.
    @param task Pointer to an instance of an SCSITaskInterface.
    @result Returns 0 if the task is not active, non-zero if it is active.
	*/

	Boolean	( *IsTaskActive ) ( void * task );

	/*! @function SetTaskAttribute
    @abstract Method to set the task's attribute.
    @discussion This method can be used to set the SCSITask's SCSITaskAttribute field.
    Valid values are defined in SCSITask.h
    @param task Pointer to an instance of an SCSITaskInterface.
	@param inAttribute The new attribute value to be stored in the SCSITask.
    @result Returns kIOReturnSuccess or kIOReturnError.
	*/

	IOReturn	( *SetTaskAttribute ) ( void * task, SCSITaskAttribute inAttribute );

	/*! @function GetTaskAttribute
    @abstract Method to get the task's attribute.
    @discussion This method can be used to get the SCSITasks' SCSITaskAttribute field.
    Valid values are defined in SCSITask.h
    @param task Pointer to an instance of an SCSITaskInterface.
	@param outAttribute Pointer to the attribute value stored in the SCSITask.
    @result Returns kIOReturnSuccess or kIOReturnError.
	*/
	
	IOReturn	( *GetTaskAttribute ) ( void * task, SCSITaskAttribute * outAttribute );

	/*! @function SetCommandDescriptorBlock
    @abstract Method to set the task's SCSICommandDescriptorBlock.
    @discussion This method can be used to set the SCSITasks' SCSICommandDescriptorBlock.
    @param task Pointer to an instance of an SCSITaskInterface.
	@param inCDB Pointer to an array of values to be stored in the SCSITask's
	SCSICommandDescriptorBlock.
	@param inSize The size of the array inCDB. Valid values are 6, 10, 12, and 16
	which have enums defined in SCSITask.h.
    @result Returns kIOReturnSuccess or kIOReturnError.
	*/
	
	IOReturn	( *SetCommandDescriptorBlock ) ( void * task, UInt8 * inCDB, UInt8 inSize );

	/*! @function GetCommandDescriptorBlockSize
    @abstract Method to get the task's SCSICommandDescriptorBlock size.
    @discussion This method can be used to get the size of the SCSITask's
    SCSICommandDescriptorBlock.
    @param task Pointer to an instance of an SCSITaskInterface.
    @result UInt8 which is the size of the SCSICommandDescriptorBlock. Valid values
    are 6, 10, 12, and 16 which have enums defined in SCSITask.h 
	*/

	UInt8	( *GetCommandDescriptorBlockSize ) ( void * task );

	/*! @function GetCommandDescriptorBlock
    @abstract Method to get the task's SCSICommandDescriptorBlock.
    @discussion This method can be used to get the SCSITasks' SCSICommandDescriptorBlock.
    @param task Pointer to an instance of an SCSITaskInterface.
	@param outCDB Pointer to an array the size of the SCSICommandDescriptorBlock in
	question. Clients should call GetCommandDescriptorBlockSize first to find out
	how large an array should be passed in.
    @result Returns kIOReturnSucces or kIOReturnError.  
	*/

	IOReturn	( *GetCommandDescriptorBlock ) ( void * task, UInt8 * outCDB );

	/*! @function SetScatterGatherEntries
    @abstract Method to set the task's scatter-gather list entries.
    @discussion This method can be used to set the SCSITask's scatter-gather
    list entries. Scatter-gather lists are represented as an array of SCSITaskSGElements.
    The SCSITaskSGElement structure has two elements, the address of the buffer and the
    length of the buffer.
    @param task Pointer to an instance of an SCSITaskInterface.
	@param inScatterGatherList Pointer to an array of SCSITaskSGElements.
	@param inScatterGatherEntries The size of the inScatterGatherList array.
	@param inTransferCount The TOTAL amount of data to transfer. The length of all the
	entries in the scatter-gather list should at least add up to the amount
	in inTransferCount.
	@param inTransferDirection The transfer direction as defined in
	SCSITask.h. Valid values are kSCSIDataTransfer_NoDataTransfer,
	kSCSIDataTransfer_FromTargetToInitiator, and kSCSIDataTransfer_FromInitiatorToTarget.
    @result Returns kIOReturnSucces or kIOReturnError.  
	*/

	IOReturn	( *SetScatterGatherEntries ) ( void *				task,
											   SCSITaskSGElement *	inScatterGatherList,
											   UInt8				inScatterGatherEntries,
											   UInt64				inTransferCount,
											   UInt8				inTransferDirection );

	/*! @function SetTimeoutDuration
    @abstract Method to set the timeout duration for the SCSITask.
    @discussion This method can be used to set the timeout duration for the SCSITask.
    The timeout duration is counted in milliseconds. A value of zero is equivalent
    to "Wait Forever", but on some buses, this isn't possible, so ULONG_MAX is used.
    @param task Pointer to an instance of an SCSITaskInterface.
	@param inTimeoutDurationMS UInt32 representing the timeout in milliseconds.
    @result Returns kIOReturnSucces or kIOReturnError.  
	*/

	IOReturn	( *SetTimeoutDuration ) ( void * task, UInt32 inTimeoutDurationMS );

	/*! @function GetTimeoutDuration
    @abstract Method to get the timeout duration for the SCSITask.
    @discussion This method can be used to get the timeout duration for the SCSITask.
    The timeout duration is counted in milliseconds.
    @param task Pointer to an instance of an SCSITaskInterface.
    @result Returns a value between zero and ULONG_MAX.  
	*/
	
	UInt32	( *GetTimeoutDuration ) ( void * task );

	/*! @function SetTaskCompletionCallback
    @abstract Method to set the asynchronous completion routine for the SCSITask.
    @discussion This method can be used to set the asynchronous completion routine
    for the SCSITask.
    @param task Pointer to an instance of an SCSITaskInterface.
	@param callback SCSITaskCallbackFunction to be called upon completion of the SCSITask.
	@param refCon A value to be returned to the caller upon completion of the routine.
	This field is not used by the SCSITaskInterface.
    @result Returns kIOReturnSuccess, kIOReturnError, or kIOReturnNotPermitted if the
    client has not called AddCallbackDispatcherToRunLoop on the SCSITaskDeviceInterface.
	*/
	
	IOReturn	( *SetTaskCompletionCallback ) ( void *						task,
												 SCSITaskCallbackFunction	callback,
												 void *						refCon );
	/*! @function ExecuteTaskAsync
    @abstract Method to execute the SCSITask asynchronously.
    @discussion This method can be used to execute the SCSITask asynchronously.
    @param task Pointer to an instance of an SCSITaskInterface.
	@result Returns a valid IOReturn code such as kIOReturnSuccess, kIOReturnError, kIOReturnVMError, kIOReturnCannotWire, etc.
	It will return kIOReturnNotPermitted if the client has not called AddCallbackDispatcherToRunLoop on the SCSITaskDeviceInterface.
    NOTE: IOReturn is defined as kern_return_t and as such, you may get errors back that do not fall under the IOKit subsystem
    error domain (sys_iokit) defined in IOReturn.h.
	*/
	
	IOReturn	( *ExecuteTaskAsync ) ( void * task );

	/*! @function ExecuteTaskSync
    @abstract Method to execute the SCSITask synchronously.
    @discussion This method can be used to execute the SCSITask synchronously.
    @param task Pointer to an instance of an SCSITaskInterface.
	@param senseDataBuffer Pointer to a buffer for REQUEST_SENSE data. May
	be NULL if caller does not wish to have sense data returned. If caller has
	previously called SetAutoSenseDataBuffer(), this parameter is ignored.
	@param outStatus Pointer to an SCSITaskStatus. May
	be NULL if caller does not wish to have task status returned.
	@param realizedTransferCount Pointer to an UInt64 which reflects how much data was
	actually transferred. May be NULL if caller does not wish to know
	how many bytes were transferred.
    @result Returns a valid IOReturn code such as kIOReturnSuccess, kIOReturnError, kIOReturnVMError, kIOReturnCannotWire, etc.
    NOTE: IOReturn is defined as kern_return_t and as such, you may get errors back that do not fall under the IOKit subsystem
    error domain (sys_iokit) defined in IOReturn.h.
	*/

	IOReturn	( *ExecuteTaskSync ) ( void *				task,
									   SCSI_Sense_Data *	senseDataBuffer,
									   SCSITaskStatus *		outStatus,
									   UInt64 *				realizedTransferCount );

	/*! @function AbortTask
    @abstract Method to abort the SCSITask.
    @discussion This method can be used to abort an SCSITask which is already in progress.
    @param task Pointer to an instance of an SCSITaskInterface.
    @result Returns kIOReturnSuccess, kIOReturnUnsupported or kIOReturnError.
	*/

	IOReturn	( *AbortTask ) ( void * task );

	/*! @function GetSCSIServiceResponse
    @abstract Method to get the SCSIServiceResponse from the SCSITask.
    @discussion This method can be used to get the SCSIServiceResponse from the SCSITask.
    @param task Pointer to an instance of an SCSITaskInterface.
	@param outServiceResponse Pointer to an SCSIServiceResponse.
    @result Returns kIOReturnSuccess or kIOReturnError.
	*/

	IOReturn	( *GetSCSIServiceResponse ) ( void * 				task,
											  SCSIServiceResponse * outServiceResponse );

	/*! @function GetTaskState
    @abstract Method to get the SCSITaskState from the SCSITask.
    @discussion This method can be used to get the SCSITaskState from the SCSITask.
    @param task Pointer to an instance of an SCSITaskInterface.
	@param outState Pointer to an SCSITaskState.
    @result Returns kIOReturnSuccess or kIOReturnError.
	*/

	IOReturn	( *GetTaskState ) ( void * task, SCSITaskState * outState );

	/*! @function GetTaskStatus
    @abstract Method to get the SCSITaskStatus from the SCSITask.
    @discussion This method can be used to get the SCSITaskStatus from the SCSITask.
    @param task Pointer to an instance of an SCSITaskInterface.
	@param outStatus Pointer to an SCSITaskStatus.
    @result Returns kIOReturnSuccess or kIOReturnError.
	*/

	IOReturn	( *GetTaskStatus ) ( void * task, SCSITaskStatus * outStatus );

	/*! @function GetRealizedDataTransferCount
    @abstract Method to get the actual transfer count in bytes from the SCSITask.
    @discussion This method can be used to get the actual transfer count in bytes
    from the SCSITask.
    @param task Pointer to an instance of an SCSITaskInterface.
    @result Returns a UInt64 value of bytes transferred.
	*/

	UInt64	( *GetRealizedDataTransferCount ) ( void * task );
	
	/*! @function GetAutoSenseData
    @abstract Method to get the auto-sense data from the SCSITask.
    @discussion This method can be used to get the auto-sense data from the SCSITask.
    @param task Pointer to an instance of an SCSITaskInterface.
	@param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data structure.
	If caller has previously called SetAutoSenseDataBuffer(), this routine will return
	an error.
    @result Returns kIOReturnSuccess if sense data is valid, otherwise kIOReturnError.
	*/

	IOReturn	( *GetAutoSenseData ) ( void * task, SCSI_Sense_Data * senseDataBuffer );
	
	
	/* Added in 10.2 */
	
	
	/*! @function SetAutoSenseDataBuffer
    @abstract Method to set the auto-sense data for the SCSITask.
    @discussion This method can be used to set the auto-sense data buffer for the SCSITask.
    @param task Pointer to an instance of an SCSITaskInterface.
	@param senseDataBuffer Pointer to a buffer. May be be NULL if the caller wants to
	restrict the size to be less than the normal 18 bytes of sense data.
	@param senseDataLength Amount of sense data to retrieve. Zero is not a valid value.
    @result Returns kIOReturnSuccess if sense data buffer was set, otherwise kIOReturnError.
	*/
	
	IOReturn	( *SetAutoSenseDataBuffer ) ( void *			task,
											  SCSI_Sense_Data * senseDataBuffer,
											  UInt8				senseDataLength );
	
	/* Added in 10.6 */
	
	/*! @function ResetForNewTask
    @abstract Method to reset the SCSITask to defaults.
    @discussion This method can be used to reset the SCSITask to defaults.
    @param task Pointer to an instance of an SCSITaskInterface.
    @result Returns kIOReturnSuccess if reset was successful, otherwise kIOReturnError.
	*/
	
	IOReturn	( *ResetForNewTask ) ( void * task );
	
} SCSITaskInterface;


/*! 
	@class SCSITaskDeviceInterface
    @abstract Basic interface for a SCSITask Device.  
    @discussion After rendezvous with a SCSITask Device in the IORegistry you can create
    an instance of this interface as a proxy to the IOService. Once you have this interface,
    or one of its subclasses, you can create SCSITasks to send to the device. Use the
    CreateSCSITask method to create new SCSITask instances for this device.
*/

typedef struct SCSITaskDeviceInterface
{

	IUNKNOWN_C_GUTS;

	/*! Interface version */
	UInt16	version;
	
	/*! Interface revision */
	UInt16	revision;
	
	/*! @function IsExclusiveAccessAvailable
    @abstract Method to find out if the device can be opened exclusively by the caller.
    @discussion Method to find out if the device can be opened exclusively by the caller.
    @param self Pointer to an instance of an SCSITaskDeviceInterface.
    @result Returns false if the device has been opened for exclusive access, otherwise true.
	*/
	
	Boolean ( *IsExclusiveAccessAvailable ) ( void * self );
	
	/*! @function AddCallbackDispatcherToRunLoop
    @abstract Convenience method to add asynchronous callback mechanisms to the CFRunLoop
    of choice.
    @discussion Once a SCSITaskDeviceInterface is opened, the client may make synchronous
    or asynchronous requests to the device. This method creates and initializes a
    mach_port_t for receiving asynchronous callback notifications via the CFRunLoop mechanism.
	@param self Pointer to a SCSITaskDeviceInterface instance.
    @param cfRunLoopRef The CFRunLoop to which asynchronous callback notifications should
    be attached.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, or kIOReturnNoMemory if a mach port could not be
    allocated and initialized properly.
	*/

	IOReturn ( *AddCallbackDispatcherToRunLoop ) ( void * self, CFRunLoopRef cfRunLoopRef );
	
	/*! @function RemoveCallbackDispatcherFromRunLoop
    @abstract Convenience method to remove asynchronous callback mechanisms from the CFRunLoop.
    @discussion Once a SCSITaskDeviceInterface is opened, the client may make synchronous
    or asynchronous requests to the device.
	This method removes the asynchronous notifications delivered via the CFRunLoop. This
	should be called only after calling AddCallbackDispatcherToRunLoop.
	@param self Pointer to a SCSITaskDeviceInterface instance.
	*/
	
	void ( *RemoveCallbackDispatcherFromRunLoop ) ( void * self );
	
	/*! @function ObtainExclusiveAccess
    @abstract Method to obtain exclusive access to the device so that SCSITasks can be sent
    to it.
    @discussion Once a SCSITaskDeviceInterface is opened, the client may request exclusive
    access to the device. Once the client has successfully gained exclusive access, it
    becomes the Logical Unit Driver and all in-kernel Logical Unit Drivers are quiesced.
	@param self Pointer to a SCSITaskDeviceInterface instance.
	@result Returns kIOReturnSuccess if exclusive access was granted, else if media is
	still mounted it returns kIOReturnBusy. If another client already has exclusive
	access, kIOReturnExclusiveAccess is returned.
	*/
	
	IOReturn ( *ObtainExclusiveAccess ) ( void * self );

	/*! @function ReleaseExclusiveAccess
    @abstract Method to release exclusive access to the device so that other clients
    can send commands to it.
    @discussion Once a SCSITaskDeviceInterface is opened, the client may request
    exclusive access to the device.
	Once the client has successfully gained exclusive access, it becomes the Logical
	Unit Driver and all in-kernel Logical Unit Drivers (if any are matched on the device)
	are quiesced. This method releases this access and unquiesces the in-kernel
	drivers (if any).	
	@param self Pointer to a SCSITaskDeviceInterface instance.
	@result Returns kIOReturnSuccess if exclusive access was released, else some
	appropriate error.
	*/
	
	IOReturn ( *ReleaseExclusiveAccess ) ( void * self );
	
	/*! @function CreateSCSITask
    @abstract Method to create SCSITasks.
    @discussion Once a SCSITaskDeviceInterface is opened, the client may request
    exclusive access to the device.
	Once the client has successfully gained exclusive access, it becomes the Logical
	Unit Driver. It then can use this method to allocate SCSITasks to be sent to the device.
	@param self Pointer to a SCSITaskDeviceInterface instance.
	@result Returns a handle to an instance of a SCSITaskInterface or NULL if one
	could not be allocated.
	*/

	SCSITaskInterface ** ( *CreateSCSITask )( void * self );
	
} SCSITaskDeviceInterface;


/*! 
	@class MMCDeviceInterface
    @abstract Basic interface for an MMC-2 Compliant Device.  
    @discussion After rendezvous with a MMC-2 Compliant Device in the IORegistry
    you can create an instance of this interface as a proxy to the IOService. Once
    you have this interface, or one of its subclasses, you can issue some select
    MMC-2 calls to the device without getting exclusive access first.
*/

typedef struct MMCDeviceInterface
{

	IUNKNOWN_C_GUTS;

	/*! Interface version */
	UInt16	version;
	
	/*! Interface revision */
	UInt16	revision;
	
	/*! @function Inquiry
    @abstract Issues an INQUIRY command to the device as defined in SPC-2.
    @discussion Once an MMCDeviceInterface is opened, the client may send this command
    to get inquiry data from the drive.
    @param self Pointer to an MMCDeviceInterface for one IOService.
    @param inquiryBuffer A pointer to a buffer the size of the SCSICmd_INQUIRY_StandardData
    struct found in SCSICmds_INQUIRY_Definitions.h.
    @param inqBufferSize The amount of INQUIRY data to ask the device for (some devices
    return less INQUIRY data than the size of SCSICmd_INQUIRY_StandardData and will need
    to be reset if more than that amount is specified). This value must be less than the
    size of SCSICmd_INQUIRY_StandardData.
    @param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask which
    was executed. Valid SCSITaskStatus values are defined in SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct found
    in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/

	IOReturn ( *Inquiry )(	void *							self,
							SCSICmd_INQUIRY_StandardData *	inquiryBuffer,
							UInt32							inqBufferSize,
							SCSITaskStatus *				taskStatus,
							SCSI_Sense_Data *				senseDataBuffer );
	
	/*! @function TestUnitReady
    @abstract Issues a TEST_UNIT_READY command to the device as defined in SPC-2.
    @discussion Once an MMCDeviceInterface is opened, the client may send this command
    to test if the drive is ready.
    @param self Pointer to an MMCDeviceInterface for one IOService.
    @param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask
    which was executed. Valid SCSITaskStatus values are defined in
    SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct
    found in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/

 	IOReturn ( *TestUnitReady )( 	void *				self,
 									SCSITaskStatus *	taskStatus,
 									SCSI_Sense_Data *	senseDataBuffer  );
	
	
	
	/* This version of GetPerformance is OBSOLETED by Mt. Fuji 5. Please use the newly
	 * introduced API at the end of this struct
	 */
	
	/*! @function GetPerformance
    @abstract Issues a GET_PERFORMANCE command to the device as defined in MMC-2.
    @discussion Once an MMCDeviceInterface is opened, the client may send this command
    to get performance information from the device.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param TOLERANCE The TOLERANCE field as described for the GET_PERFORMANCE command in MMC-2.
	@param WRITE The WRITE bit as described in MMC-2 for the GET_PERFORMANCE command.
	@param EXCEPT The EXCEPT field as described in MMC-2 for the GET_PERFORMANCE command.
	@param STARTING_LBA The STARTING_LBA field as described in MMC-2 for the GET_PERFORMANCE command.
	@param MAXIMUM_NUMBER_OF_DESCRIPTORS The MAXIMUM_NUMBER_OF_DESCRIPTORS field as
	described in MMC-2 for the GET_PERFORMANCE command.
	@param buffer Pointer to the buffer where the mode sense data should be placed.
	@param bufferSize Size of the buffer.
    @param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask
    which was executed. Valid SCSITaskStatus values are defined in
    SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct
    found in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/
	
	IOReturn ( *GetPerformance )(	void * 				self,
									SCSICmdField2Bit	TOLERANCE,
									SCSICmdField1Bit	WRITE,
									SCSICmdField2Bit	EXCEPT,
									SCSICmdField4Byte	STARTING_LBA,
									SCSICmdField2Byte	MAXIMUM_NUMBER_OF_DESCRIPTORS,
									void *				buffer,
									SCSICmdField2Byte	bufferSize,
									SCSITaskStatus * 	taskStatus,
									SCSI_Sense_Data *	senseDataBuffer );
	
	/*! @function GetConfiguration
    @abstract Issues a GET_CONFIGURATION command to the device as defined in MMC-2.
    @discussion Once an MMCDeviceInterface is opened, the client may send this command
    to get configuration information from the device.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param RT The RT field as described for the GET_CONFIGURATION command in MMC-2.
	@param STARTING_FEATURE_NUMBER The STARTING_FEATURE_NUMBER field as described in MMC-2
	for the GET_CONFIGURATION command.
	@param buffer Pointer to the buffer where the mode sense data should be placed.
	@param bufferSize Size of the buffer.
    @param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask
    which was executed. Valid SCSITaskStatus values are defined in
    SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct
    found in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/

	IOReturn ( *GetConfiguration )(	void *				self,
									SCSICmdField1Byte	RT,
									SCSICmdField2Byte	STARTING_FEATURE_NUMBER,
									void *				buffer,
									SCSICmdField2Byte	bufferSize,
									SCSITaskStatus *	taskStatus,
									SCSI_Sense_Data *	senseDataBuffer );

	/*! @function ModeSense10
    @abstract Issues a MODE_SENSE_10 command to the device as defined in SPC-2.
    @discussion Once an MMCDeviceInterface is opened, the client may send this command
    to get mode page information from the device.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param LLBAA The LLBAA bit as defined in SPC-2 for the MODE_SENSE_10 command.
	@param DBD The DBD bit as defined in SPC-2 for the MODE_SENSE_10 command.
	@param PC The PC bits as defined in SPC-2 for the MODE_SENSE_10 command.
	@param PAGE_CODE The PAGE_CODE bits as defined in SPC-2 for the MODE_SENSE_10 command.
	@param buffer Pointer to the buffer where the mode sense data should be placed.
	@param bufferSize Size of the buffer.
    @param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask
    which was executed. Valid SCSITaskStatus values are defined in
    SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct
    found in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/

	IOReturn ( *ModeSense10 )(	void *				self,
								SCSICmdField1Bit	LLBAA,
								SCSICmdField1Bit	DBD,
								SCSICmdField2Bit	PC,
								SCSICmdField6Bit	PAGE_CODE,
								void *				buffer,
								SCSICmdField2Byte	bufferSize,
								SCSITaskStatus * 	taskStatus,
								SCSI_Sense_Data * 	senseDataBuffer );
	
	/*! @function SetWriteParametersModePage
	@abstract Issues a MODE_SELECT command to the device as defined in SPC-2 with the
	Write Parameters Mode Page Code as defined in MMC-2.
	@discussion Once an MMCDeviceInterface is opened, the client may send this command
    to set the default values returned in a READ_DISC_INFORMATION call.
	@param buffer Pointer to buffer (including mode parameter header).
    @param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask
    which was executed. Valid SCSITaskStatus values are defined in
    SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct
    found in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/
	
	IOReturn ( *SetWriteParametersModePage )( 	void * 				self,
												void * 				buffer,
												SCSICmdField1Byte 	bufferSize,
												SCSITaskStatus *	taskStatus,
												SCSI_Sense_Data *	senseDataBuffer );


	/*! @function GetTrayState
    @abstract Issues a GET_EVENT_STATUS_NOTIFICATION command to the device as defined in MMC-2.
    @discussion Once an MMCDeviceInterface is opened, the client may send this command to
    find out if the device's medium tray is open.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param trayState Pointer to a UInt8 which will hold the tray state on completion of
	the routine. The tray state can be one of two values,
	kMMCDeviceTrayClosed or kMMCDeviceTrayOpen.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, or kIOReturnExclusiveAccess if the device is already
	opened for exclusive access by another client.
	*/
	
	IOReturn ( *GetTrayState )( void * self, UInt8 * trayState );
	
	/*! @function SetTrayState
    @abstract Issues a START_STOP_UNIT command to the device as defined in SBC-3.
    @discussion Once an MMCDeviceInterface is opened and all volumes associated
    with that device's media have been unmounted, the client may send this command
    to eject the tray.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param trayState A UInt8 describing which tray state is desired. The tray state
	can be one of two values, kMMCDeviceTrayClosed or kMMCDeviceTrayOpen.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNotPermitted if media is inserted,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/
	
	IOReturn ( *SetTrayState )( void * self, UInt8 trayState );
 	
	/*! @function ReadTableOfContents
    @abstract Issues a READ_TOC_PMA_ATIP command to the device as defined in MMC-2/SFF-8020i.
    @discussion Once an MMCDeviceInterface is opened the client may send this command
    to read the table of contents from the media.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param MSF The MSF bit as defined in MMC-2/SFF-8020i.
    @param FORMAT The FORMAT field as defined in MMC-2/SFF-8020i.
	@param TRACK_SESSION_NUMBER The TRACK_SESSION_NUMBER field as defined in MMC-2/SFF-8020i.
	@param buffer Pointer to the buffer to be used for this function.
	@param bufferSize The size of the data transfer requested.
	@param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask
	which was executed. Valid SCSITaskStatus values are defined in
	SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct
    found in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/

	IOReturn ( *ReadTableOfContents )(	void *				self,
										SCSICmdField1Bit 	MSF,
										SCSICmdField4Bit 	FORMAT,
										SCSICmdField1Byte	TRACK_SESSION_NUMBER,
										void *				buffer,
										SCSICmdField2Byte	bufferSize,
										SCSITaskStatus *	taskStatus,
										SCSI_Sense_Data *	senseDataBuffer );
	
	/*! @function ReadDiscInformation
    @abstract Issues a READ_DISC_INFORMATION command to the device as defined in MMC-2.
    @discussion Once an MMCDeviceInterface is opened the client may send this command
    to read information about the disc (CD-R/RW, (un)finalized, etc..
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param buffer Pointer to the buffer to be used for this function.
	@param bufferSize The size of the data transfer requested.
	@param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask which
	was executed. Valid SCSITaskStatus values are defined in SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct found
    in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection
    to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created, or
    kIOReturnExclusiveAccess if the device is already opened for exclusive access
    by another client.
	*/

	IOReturn ( *ReadDiscInformation ) (	void *				self,
										void *				buffer,
										SCSICmdField2Byte	bufferSize,
										SCSITaskStatus *	taskStatus,
										SCSI_Sense_Data *	senseDataBuffer );
	
	/*! @function ReadTrackInformation
    @abstract Issues a READ_TRACK_INFORMATION command to the device as defined in MMC-2.
    @discussion Once an MMCDeviceInterface is opened the client may send this command to
    read information about selected tracks on the disc.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param ADDRESS_NUMBER_TYPE The ADDRESS/NUMBER_TYPE field as defined in MMC-2.
    @param LOGICAL_BLOCK_ADDRESS_TRACK_SESSION_NUMBER The LOGICAL_BLOCK_ADDRESS/SESSION_NUMBER
    field as defined in MMC-2.
	@param buffer Pointer to the buffer to be used for this function.
	@param bufferSize The size of the data transfer requested.
	@param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask which
	was executed. Valid SCSITaskStatus values are defined in SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct found
    in SCSICmds_REQUEST_SENSE_Defs.h. The sense data is only valid
    if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/

	IOReturn ( *ReadTrackInformation ) (	void *				self,
											SCSICmdField2Bit	ADDRESS_NUMBER_TYPE,
											SCSICmdField4Byte	LOGICAL_BLOCK_ADDRESS_TRACK_SESSION_NUMBER,
											void *				buffer,
											SCSICmdField2Byte	bufferSize,
											SCSITaskStatus *	taskStatus,
											SCSI_Sense_Data *	senseDataBuffer );
	
	/*! @function ReadDVDStructure
    @abstract Issues a READ_DVD_STRUCTURE command to the device as defined in MMC-2.
    @discussion Once an MMCDeviceInterface is opened the client may send this command to
    read information about DVD specific structures on the disc.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param ADDRESS The ADDRESS field as defined in MMC-2.
    @param LAYER_NUMBER The LAYER_NUMBER field as defined in MMC-2.
    @param FORMAT The FORMAT field as defined in MMC-2.
	@param buffer Pointer to the buffer to be used for this function.
	@param bufferSize The size of the data transfer requested.
	@param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask
	which was executed. Valid SCSITaskStatus values are defined in
	SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct
    found in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/

	IOReturn ( *ReadDVDStructure ) (	void *				self,
										SCSICmdField4Byte	ADDRESS,
										SCSICmdField1Byte	LAYER_NUMBER,
										SCSICmdField1Byte	FORMAT,
										void *				buffer,
										SCSICmdField2Byte	bufferSize,
										SCSITaskStatus *	taskStatus,
										SCSI_Sense_Data *	senseDataBuffer );
	
	/*! @function GetSCSITaskDeviceInterface
    @abstract Gets a handle to the SCSITaskDeviceInterface without closing the user
    client connection which was initiated by IOCreateCFPlugInForService.
    @discussion Once an MMCDeviceInterface is opened the client may use this function
    to get a handle to the interface used to create and send SCSITasks directly to the device.
    @param self Pointer to an MMCDeviceInterface for one IOService.
    @result Returns a handle to a SCSITaskDeviceInterface if successful, otherwise NULL.
	*/
	
	SCSITaskDeviceInterface ** 	( *GetSCSITaskDeviceInterface )( void * self );
	
	/* Added in Mac OS X 10.2 */
	
	/*! @function GetPerformanceV2
    @abstract Issues a GET_PERFORMANCE command to the device as defined in Mt. Fuji 5.
    @discussion Once an MMCDeviceInterface is opened, the client may send this command
    to get performance information from the device.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param DATA_TYPE The DATA_TYPE field as described for the GET_PERFORMANCE command in Mt. Fuji 5.
	@param STARTING_LBA The STARTING_LBA field as described in Mt. Fuji 5 for the GET_PERFORMANCE command.
	@param MAXIMUM_NUMBER_OF_DESCRIPTORS The MAXIMUM_NUMBER_OF_DESCRIPTORS field as
	described in Mt. Fuji 5 for the GET_PERFORMANCE command.
	@param TYPE The TYPE field as described for the GET_PERFORMANCE command in Mt. Fuji 5.
	@param buffer Pointer to the buffer where the mode sense data should be placed.
	@param bufferSize Size of the buffer.
    @param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask
    which was executed. Valid SCSITaskStatus values are defined in
    SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct
    found in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/
	
	IOReturn ( *GetPerformanceV2 )( void * 				self,
									SCSICmdField5Bit 	DATA_TYPE,
									SCSICmdField4Byte	STARTING_LBA,
									SCSICmdField2Byte	MAXIMUM_NUMBER_OF_DESCRIPTORS,
									SCSICmdField1Byte	TYPE,
									void *				buffer,
									SCSICmdField2Byte	bufferSize,
									SCSITaskStatus *	taskStatus,
									SCSI_Sense_Data *	senseDataBuffer );
	
	/* Added in Mac OS X 10.3 */
	
	/*! @function SetCDSpeed
    @abstract Issues a SET_CD_SPEED command to the device as defined in MMC-2.
    @discussion Once an MMCDeviceInterface is opened the client may send this command to
				change the read and/or write CD speed of the drive.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param LOGICAL_UNIT_READ_SPEED The LOGICAL_UNIT_READ_SPEED field as defined in MMC-2.
    @param LOGICAL_UNIT_WRITE_SPEED The LOGICAL_UNIT_WRITE_SPEED field as defined in MMC-2.
	@param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask
		   which was executed. Valid SCSITaskStatus values are defined in SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct
		   found in SCSICmds_REQUEST_SENSE_Defs.h.  The sense data is only valid if the
		   SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
			connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
			or kIOReturnExclusiveAccess if the device is already opened for exclusive access
			by another client.
	*/

	IOReturn ( *SetCDSpeed ) (	void *				self,
								SCSICmdField2Byte	LOGICAL_UNIT_READ_SPEED,
								SCSICmdField2Byte	LOGICAL_UNIT_WRITE_SPEED,
								SCSITaskStatus *	taskStatus,
								SCSI_Sense_Data *	senseDataBuffer );
	
	
	/* Added in Mac OS X 10.3 */
	
	/*! @function ReadFormatCapacities
    @abstract Issues a READ_FORMAT_CAPACITIES command to the device as defined in MMC-2.
    @discussion Once an MMCDeviceInterface is opened the client may send this command to
				get format capacity information from the media.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param buffer Pointer to the buffer where the mode sense data should be placed.
	@param bufferSize Size of the buffer.
	@param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask
		   which was executed. Valid SCSITaskStatus values are defined in SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct
		   found in SCSICmds_REQUEST_SENSE_Defs.h.  The sense data is only valid if the
		   SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
			connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
			or kIOReturnExclusiveAccess if the device is already opened for exclusive access
			by another client.
	*/
	
	IOReturn ( *ReadFormatCapacities ) ( void *					self,
										 void *					buffer,
										 SCSICmdField2Byte		bufferSize,
										 SCSITaskStatus *		taskStatus,
										 SCSI_Sense_Data *		senseDataBuffer );
	
	/*! @function ReadDiscStructure
    @abstract Issues a READ_DISC_STRUCTURE command to the device as defined in MMC-5.
    @discussion Once an MMCDeviceInterface is opened the client may send this command to
    read information about Disc specific structures on the disc.
    @param self Pointer to an MMCDeviceInterface for one IOService.
	@param MEDIA_TYPE The MEDIA_TYPE field as defined in MMC-5.
	@param ADDRESS The ADDRESS field as defined in MMC-5.
    @param LAYER_NUMBER The LAYER_NUMBER field as defined in MMC-5.
    @param FORMAT The FORMAT field as defined in MMC-5.
	@param buffer Pointer to the buffer to be used for this function.
	@param bufferSize The size of the data transfer requested.
	@param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask
	which was executed. Valid SCSITaskStatus values are defined in
	SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct
    found in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/

	IOReturn ( *ReadDiscStructure ) (	void *				self,
										SCSICmdField4Bit	MEDIA_TYPE,
										SCSICmdField4Byte	ADDRESS,
										SCSICmdField1Byte	LAYER_NUMBER,
										SCSICmdField1Byte	FORMAT,
										void *				buffer,
										SCSICmdField2Byte	bufferSize,
										SCSITaskStatus *	taskStatus,
										SCSI_Sense_Data *	senseDataBuffer );
	
	/*! @function ReadDiscInformationV2
    @abstract Issues a READ_DISC_INFORMATION command to the device as defined in MMC-5.
    @discussion Once an MMCDeviceInterface is opened the client may send this command
    to read information about the disc (CD-R/RW, (un)finalized, etc..
    @param self Pointer to an MMCDeviceInterface for one IOService.
    @param DATA_TYPE The DATA_TYPE field as defined in MMC-5.
	@param buffer Pointer to the buffer to be used for this function.
	@param bufferSize The size of the data transfer requested.
	@param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask which
	was executed. Valid SCSITaskStatus values are defined in SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct found
    in SCSICmds_REQUEST_SENSE_Defs.h.
	The sense data is only valid if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection
    to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created, or
    kIOReturnExclusiveAccess if the device is already opened for exclusive access
    by another client.
	*/

	IOReturn ( *ReadDiscInformationV2 ) (	void *				self,
											SCSICmdField3Bit	DATA_TYPE,
											void *				buffer,
											SCSICmdField2Byte	bufferSize,
											SCSITaskStatus *	taskStatus,
											SCSI_Sense_Data *	senseDataBuffer );
	
	/*! @function ReadTrackInformationV2
    @abstract Issues a READ_TRACK_INFORMATION command to the device as defined in Mt. Fuji 5.
    @discussion Once an MMCDeviceInterface is opened the client may send this command to
    read information about selected tracks on the disc.
    @param self Pointer to an MMCDeviceInterface for one IOService.
    @param OPEN The OPEN field as defined in Mt. Fuji 5.
	@param ADDRESS_NUMBER_TYPE The ADDRESS/NUMBER_TYPE field as defined in Mt. Fuji 5.
    @param LOGICAL_BLOCK_ADDRESS_TRACK_SESSION_NUMBER The LOGICAL_BLOCK_ADDRESS/SESSION_NUMBER
    field as defined in Mt. Fuji 5.
	@param buffer Pointer to the buffer to be used for this function.
	@param bufferSize The size of the data transfer requested.
	@param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask which
	was executed. Valid SCSITaskStatus values are defined in SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct found
    in SCSICmds_REQUEST_SENSE_Defs.h. The sense data is only valid
    if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/

	IOReturn ( *ReadTrackInformationV2 ) (	void *				self,
											SCSICmdField1Bit	OPEN,
											SCSICmdField2Bit	ADDRESS_NUMBER_TYPE,
											SCSICmdField4Byte	LOGICAL_BLOCK_ADDRESS_TRACK_SESSION_NUMBER,
											void *				buffer,
											SCSICmdField2Byte	bufferSize,
											SCSITaskStatus *	taskStatus,
											SCSI_Sense_Data *	senseDataBuffer );
	
	/* Added in 10.6 */
	
	/*! @function SetStreaming
    @abstract Issues a SET_STREAMING command to the device as defined in MMC-5.
    @discussion Once an MMCDeviceInterface is opened the client may send this command to
    change streaming attributes. Clients should check for the Real-time Streaming Feature
    (107h) before using this command.
    @param self Pointer to an MMCDeviceInterface for one IOService.
    @param TYPE The TYPE field as defined in MMC-5.
	@param buffer Pointer to the buffer to be used for this function.
	@param bufferSize The size of the data transfer requested.
	@param taskStatus Pointer to a SCSITaskStatus to get the status of the SCSITask which
	was executed. Valid SCSITaskStatus values are defined in SCSITask.h
    @param senseDataBuffer Pointer to a buffer the size of the SCSI_Sense_Data struct found
    in SCSICmds_REQUEST_SENSE_Defs.h. The sense data is only valid
    if the SCSITaskStatus is kSCSITaskStatus_CHECK_CONDITION.
    @result Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no
    connection to an IOService, kIOReturnNoMemory if a SCSITask couldn't be created,
	or kIOReturnExclusiveAccess if the device is already opened for exclusive access
	by another client.
	*/
	
	IOReturn ( *SetStreaming ) (	void *				self,
									SCSICmdField1Byte	TYPE,
									void *				buffer,
									SCSICmdField2Byte	bufferSize,
									SCSITaskStatus *	taskStatus,
									SCSI_Sense_Data *	senseDataBuffer );
	
} MMCDeviceInterface;
	
#endif

#if !KERNEL

#ifdef __cplusplus
}
#endif

#endif /* !KERNEL */

#endif /* __SCSI_TASK_LIB_H__ */
                                                         serial/                                                                                             0040755 0001750 0001750 00000000000 12612224741 032056  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOSerialKeys.h                                                                                      0100644 0001750 0001750 00000005450 12567452410 034540  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/serial                                                                /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * IOSerialKeys.h
 *
 * 2000-10-21	gvdl	Initial real change to IOKit serial family.
 *
 */

/*
Sample Matching dictionary
{
    IOProviderClass = kIOSerialBSDServiceValue;
    kIOSerialBSDTypeKey = kIOSerialBSDAllTypes
			| kIOSerialBSDModemType
			| kIOSerialBSDRS232Type;
    kIOTTYDeviceKey = <Raw Unique Device Name>;
    kIOTTYBaseNameKey = <Raw Unique Device Name>;
    kIOTTYSuffixKey = <Raw Unique Device Name>;
    kIOCalloutDeviceKey = <Callout Device Name>;
    kIODialinDeviceKey = <Dialin Device Name>;
}

Note only the IOProviderClass is mandatory.  The other keys allow the searcher to reduce the size of the set of matching devices.
*/

/* Service Matching That is the 'IOProviderClass' */
#define kIOSerialBSDServiceValue	"IOSerialBSDClient"

/* Matching keys */
#define kIOSerialBSDTypeKey		"IOSerialBSDClientType"

/* Currently possible kIOSerialBSDTypeKey values. */
#define kIOSerialBSDAllTypes		"IOSerialStream"
#define kIOSerialBSDModemType		"IOModemSerialStream"
#define kIOSerialBSDRS232Type		"IORS232SerialStream"

// Properties that resolve to a /dev device node to open for
// a particular service
#define kIOTTYDeviceKey			"IOTTYDevice"
#define kIOTTYBaseNameKey		"IOTTYBaseName"
#define kIOTTYSuffixKey			"IOTTYSuffix"

#define kIOCalloutDeviceKey		"IOCalloutDevice"
#define kIODialinDeviceKey		"IODialinDevice"

// Property 'ioctl' wait for the tty device to go idle.
#define kIOTTYWaitForIdleKey		"IOTTYWaitForIdle"

#if KERNEL
extern const OSSymbol *gIOSerialBSDServiceValue;
extern const OSSymbol *gIOSerialBSDTypeKey;
extern const OSSymbol *gIOSerialBSDAllTypes;
extern const OSSymbol *gIOSerialBSDModemType;
extern const OSSymbol *gIOSerialBSDRS232Type;
extern const OSSymbol *gIOTTYDeviceKey;
extern const OSSymbol *gIOTTYBaseNameKey;
extern const OSSymbol *gIOTTYSuffixKey;
extern const OSSymbol *gIOCalloutDeviceKey;
extern const OSSymbol *gIODialinDeviceKey;
#endif /* KERNEL */
                                                                                                                                                                                                                        ioss.h                                                                                              0100644 0001750 0001750 00000005314 12567452410 033211  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/serial                                                                /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1997 Apple Computer, Inc. All Rights Reserved */

/* ioctl's for all Apple IOSerialStream based streaming serial ports */

#ifndef _SYS_IOSS_H
#define _SYS_IOSS_H

#ifndef _POSIX_SOURCE

#include <sys/termios.h>
#include <sys/ttycom.h>

/*
 * External clock baud rates, for use with cfsetospeed
 */
#define _MAKE_EXT(x)	(((x) << 1) | 1)
#define BEXT1	    	_MAKE_EXT(1)
#define BEXT2	    	_MAKE_EXT(2)
#define BEXT4	    	_MAKE_EXT(4)
#define BEXT8	    	_MAKE_EXT(8)
#define BEXT16	    	_MAKE_EXT(16)
#define BEXT32	    	_MAKE_EXT(32)
#define BEXT64	    	_MAKE_EXT(64)
#define BEXT128	    	_MAKE_EXT(128)
#define BEXT256	    	_MAKE_EXT(256)

// ul - unsigned long for x86_64
// us - unsigned long for i386
// speed and shspeed correspondingly
typedef __uint64_t	user_ul_t;
typedef __uint64_t	user_speed_t;
typedef __uint32_t	user_us_t;
typedef __uint32_t	user_shspeed_t;

/*
 * Sets the receive latency (in microseconds) with the default
 * value of 0 meaning a 256 / 3 character delay latency.
 */
#define IOSSDATALAT    _IOW('T', 0, unsigned long)
#define IOSSDATALAT_32    _IOW('T', 0, user_us_t)
#define IOSSDATALAT_64    _IOW('T', 0, user_ul_t)

/*
 * Controls the pre-emptible status of IOSS based serial dial in devices
 * (i.e. /dev/tty.* devices).  If true an open tty.* device is pre-emptible by
 * a dial out call.  Once a dial in call is established then setting pre-empt
 * to false will halt any further call outs on the cu device.
 */
#define IOSSPREEMPT    _IOW('T', 1, int)

/*
 * Sets the input speed and output speed to a non-traditional baud rate
 */
#define IOSSIOSPEED    _IOW('T', 2, speed_t)
#define IOSSIOSPEED_32    _IOW('T', 2, user_shspeed_t)
#define IOSSIOSPEED_64    _IOW('T', 2, user_speed_t)

#endif  /*_POSIX_SOURCE */

/*
 * END OF PROTECTED INCLUDE.
 */
#endif /* !_SYS_IOSS_H */
                                                                                                                                                                                                                                                                                                                    storage/                                                                                            0040755 0001750 0001750 00000000000 12612224741 032243  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOAppleLabelScheme.h                                                                                0100644 0001750 0001750 00000004564 12567452411 036006  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * This header contains the IOAppleLabelScheme class definition.
 */

#ifndef _IOAPPLELABELSCHEME_H
#define _IOAPPLELABELSCHEME_H

#include <IOKit/IOTypes.h>

/*
 * kIOAppleLabelSchemeClass is the name of the IOAppleLabelScheme class.
 */

#define kIOAppleLabelSchemeClass "IOAppleLabelScheme"

/*
 * Apple Label Scheme Definitions
 */

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/* Label scheme. */

struct applelabel
{
    uint8_t  al_boot0[416];               /* (reserved for boot area)         */
    uint16_t al_magic;                    /* (the magic number)               */
    uint16_t al_type;                     /* (label type)                     */
    uint32_t al_flags;                    /* (generic flags)                  */
    uint64_t al_offset;                   /* (offset of property area, bytes) */
    uint32_t al_size;                     /* (size of property area, bytes)   */
    uint32_t al_checksum;                 /* (checksum of property area)      */
    uint8_t  al_boot1[72];                /* (reserved for boot area)         */
};

/* Label scheme signature (al_magic). */

#define AL_MAGIC 0x414C

/* Label scheme version (al_type). */

#define AL_TYPE_DEFAULT 0x0000

/* Label scheme flags (al_flags). */

#define AL_FLAG_DEFAULT 0x00000000

#pragma pack(pop)                        /* (reset to default struct packing) */

#endif /* !_IOAPPLELABELSCHEME_H */
                                                                                                                                            IOApplePartitionScheme.h                                                                            0100644 0001750 0001750 00000012562 12567452411 036735  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * This header contains the IOApplePartitionScheme class definition.
 */

#ifndef _IOAPPLEPARTITIONSCHEME_H
#define _IOAPPLEPARTITIONSCHEME_H

#include <IOKit/IOTypes.h>

/*
 * kIOApplePartitionSchemeClass is the name of the IOApplePartitionScheme class.
 */

#define kIOApplePartitionSchemeClass "IOApplePartitionScheme"

/*
 * Apple Partition Map Definitions
 */

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/* Structure constants. */

#define DPISTRLEN 32

/* Partition map entry, as found in blocks 1 to dpme_map_entries of the disk. */

typedef struct dpme
{
    UInt16  dpme_signature;       /* (unique value for partition entry, 'PM') */
    UInt16  dpme_reserved_1;      /* (reserved for future use)                */
    UInt32  dpme_map_entries;     /* (number of partition entries)            */
    UInt32  dpme_pblock_start;    /* (physical block start of partition)      */
    UInt32  dpme_pblocks;         /* (physical block count of partition)      */
    char    dpme_name[DPISTRLEN]; /* (name of partition)                      */
    char    dpme_type[DPISTRLEN]; /* (type of partition, eg. Apple_HFS)       */
    UInt32  dpme_lblock_start;    /* (logical block start of partition)       */
    UInt32  dpme_lblocks;         /* (logical block count of partition)       */
    UInt32  dpme_flags;           /* (partition flags, see defines below)     */
    UInt32  dpme_boot_block;      /* (logical block start of boot code)       */
    UInt32  dpme_boot_bytes;      /* (byte count of boot code)                */
    UInt32  dpme_load_addr;       /* (load address in memory of boot code)    */
    UInt32  dpme_load_addr_2;     /* (reserved for future use)                */
    UInt32  dpme_goto_addr;       /* (jump address in memory of boot code)    */
    UInt32  dpme_goto_addr_2;     /* (reserved for future use)                */
    UInt32  dpme_checksum;        /* (checksum of boot code)                  */
    UInt8   dpme_process_id[16];  /* (processor type)                         */
    UInt32  dpme_reserved_2[32];  /* (reserved for future use)                */
    UInt32  dpme_reserved_3[62];  /* (reserved for future use)                */
} DPME;

/* Driver descriptor map entry. */

typedef struct DDMap
{
    UInt32  ddBlock;              /* (driver's block start, sbBlkSize-blocks) */
    UInt16  ddSize;               /* (driver's block count, 512-blocks)       */
    UInt16  ddType;               /* (driver's system type)                   */
} DDMap;

/* Driver descriptor map, as found in block zero of the disk. */

typedef struct Block0
{
    UInt16  sbSig;                     /* (unique value for block zero, 'ER') */
    UInt16  sbBlkSize;                 /* (block size for this device)        */
    UInt32  sbBlkCount;                /* (block count for this device)       */
    UInt16  sbDevType;                 /* (device type)                       */
    UInt16  sbDevId;                   /* (device id)                         */
    UInt32  sbDrvrData;                /* (driver data)                       */
    UInt16  sbDrvrCount;               /* (driver descriptor count)           */
    DDMap   sbDrvrMap[8];              /* (driver descriptor table)           */
    UInt8   sbReserved[430];           /* (reserved for future use)           */
} Block0;

/* Partition map signature (sbSig). */

#define BLOCK0_SIGNATURE 0x4552

/* Partition map entry signature (dpme_signature). */

#define DPME_SIGNATURE 0x504D

/* Partition map entry flags (dpme_flags). */

#define DPME_FLAGS_VALID          0x00000001                   /* (bit 0)     */
#define DPME_FLAGS_ALLOCATED      0x00000002                   /* (bit 1)     */
#define DPME_FLAGS_IN_USE         0x00000004                   /* (bit 2)     */
#define DPME_FLAGS_BOOTABLE       0x00000008                   /* (bit 3)     */
#define DPME_FLAGS_READABLE       0x00000010                   /* (bit 4)     */
#define DPME_FLAGS_WRITABLE       0x00000020                   /* (bit 5)     */
#define DPME_FLAGS_OS_PIC_CODE    0x00000040                   /* (bit 6)     */
#define DPME_FLAGS_OS_SPECIFIC_2  0x00000080                   /* (bit 7)     */
#define DPME_FLAGS_OS_SPECIFIC_1  0x00000100                   /* (bit 8)     */
#define DPME_FLAGS_RESERVED_2     0xFFFFFE00                   /* (bit 9..31) */

#pragma pack(pop)                        /* (reset to default struct packing) */

#endif /* !_IOAPPLEPARTITIONSCHEME_H */
                                                                                                                                              IOBDBlockStorageDevice.h                                                                            0100644 0001750 0001750 00000003016 12567452545 036564  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 2006-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOBDBlockStorageDevice
 * @abstract
 * This header contains the IOBDBlockStorageDevice class definition.
 */

#ifndef	_IOBDBLOCKSTORAGEDEVICE_H
#define	_IOBDBLOCKSTORAGEDEVICE_H

#include <IOKit/storage/IOBDTypes.h>

/*!
 * @defined kIOBDBlockStorageDeviceClass
 * @abstract
 * kIOBDBlockStorageDeviceClass is the name of the IOBDBlockStorageDevice class.
 * @discussion
 * kIOBDBlockStorageDeviceClass is the name of the IOBDBlockStorageDevice class.
 */

#define kIOBDBlockStorageDeviceClass "IOBDBlockStorageDevice"

#endif /* !_IOBDBLOCKSTORAGEDEVICE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  IOBDMedia.h                                                                                         0100644 0001750 0001750 00000004015 12567452545 034104  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 2006-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOBDMedia
 * @abstract
 * This header contains the IOBDMedia class definition.
 */

#ifndef _IOBDMEDIA_H
#define _IOBDMEDIA_H

/*!
 * @defined kIOBDMediaClass
 * @abstract
 * kIOBDMediaClass is the name of the IOBDMedia class.
 * @discussion
 * kIOBDMediaClass is the name of the IOBDMedia class.
 */

#define kIOBDMediaClass "IOBDMedia"

/*!
 * @defined kIOBDMediaTypeKey
 * @abstract
 * kIOBDMediaTypeKey is a property of IOBDMedia objects.  It has an OSString
 * value.
 * @discussion
 * The kIOBDMediaTypeKey property identifies the BD media type (BD-ROM, BD-R,
 * BD-RE, etc).  See the kIOBDMediaType contants for possible values.
 */

#define kIOBDMediaTypeKey "Type"

/*!
 * @defined kIOBDMediaTypeROM
 * The kIOBDMediaTypeKey constant for BD-ROM media.
 */

#define kIOBDMediaTypeROM "BD-ROM"

/*!
 * @defined kIOBDMediaTypeR
 * The kIOBDMediaTypeKey constant for BD-R media.
 */

#define kIOBDMediaTypeR "BD-R"

/*!
 * @defined kIOBDMediaTypeRE
 * The kIOBDMediaTypeKey constant for BD-RE media.
 */

#define kIOBDMediaTypeRE "BD-RE"

#endif /* !_IOBDMEDIA_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   IOBDMediaBSDClient.h                                                                                0100644 0001750 0001750 00000007752 12567452545 035607  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 2006-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOBDMEDIABSDCLIENT_H
#define _IOBDMEDIABSDCLIENT_H

#include <sys/ioctl.h>
#include <sys/types.h>

#include <IOKit/storage/IOBDTypes.h>

/*
 * Definitions
 *
 * ioctl                        description
 * ---------------------------- ------------------------------------------------
 * DKIOCBDREADSTRUCTURE         see IOBDMedia::readStructure()    in IOBDMedia.h
 *
 * DKIOCBDREADDISCINFO          see IOBDMedia::readDiscInfo()     in IOBDMedia.h
 * DKIOCBDREADTRACKINFO         see IOBDMedia::readTrackInfo()    in IOBDMedia.h
 *
 * DKIOCBDREPORTKEY             see IOBDMedia::reportKey()        in IOBDMedia.h
 * DKIOCBDSENDKEY               see IOBDMedia::sendKey()          in IOBDMedia.h
 *
 * DKIOCBDGETSPEED              see IOBDMedia::getSpeed()         in IOBDMedia.h
 * DKIOCBDSETSPEED              see IOBDMedia::setSpeed()         in IOBDMedia.h
 *
 *         in /System/Library/Frameworks/Kernel.framework/Headers/IOKit/storage/
 */

typedef struct
{
    uint8_t  format;

    uint8_t  reserved0008[3];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  grantID;
    uint8_t  layer;

    uint8_t  reserved0080[4];                      /* reserved, clear to zero */

    uint16_t bufferLength;
    void *   buffer;
} dk_bd_read_structure_t;

typedef struct
{
    uint8_t  format;
    uint8_t  keyClass;

    uint8_t  reserved0016[2];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  grantID;

    uint8_t  reserved0072[5];                      /* reserved, clear to zero */

    uint16_t bufferLength;
    void *   buffer;
} dk_bd_report_key_t;

typedef struct
{
    uint8_t  format;
    uint8_t  keyClass;

    uint8_t  reserved0016[6];                      /* reserved, clear to zero */

    uint8_t  grantID;

    uint8_t  reserved0072[5];                      /* reserved, clear to zero */

    uint16_t bufferLength;
    void *   buffer;
} dk_bd_send_key_t;

typedef struct
{
    uint8_t  reserved0000[14];                     /* reserved, clear to zero */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_bd_read_disc_info_t;

typedef struct
{
    uint8_t  reserved0000[4];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  addressType;

    uint8_t  reserved0072[5];                      /* reserved, clear to zero */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_bd_read_track_info_t;

#define DKIOCBDREADSTRUCTURE   _IOW('d', 160, dk_bd_read_structure_t)
#define DKIOCBDREPORTKEY       _IOW('d', 161, dk_bd_report_key_t)
#define DKIOCBDSENDKEY         _IOW('d', 162, dk_bd_send_key_t)

#define DKIOCBDGETSPEED        _IOR('d', 163, uint16_t)
#define DKIOCBDSETSPEED        _IOW('d', 163, uint16_t)

#define DKIOCBDREADDISCINFO    _IOWR('d', 164, dk_bd_read_disc_info_t)
#define DKIOCBDREADTRACKINFO   _IOWR('d', 165, dk_bd_read_track_info_t)

#define DKIOCBDSPLITTRACK      _IOW('d', 166, uint32_t)

#endif /* !_IOBDMEDIABSDCLIENT_H */
                      IOBDTypes.h                                                                                         0100644 0001750 0001750 00000006537 12567452545 034204  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 2006-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef	_BDTYPES_H
#define	_BDTYPES_H

#include <IOKit/IOTypes.h>

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/*
 * Media Types
 */

enum
{
    kBDMediaTypeUnknown   = 0x0300,
    kBDMediaTypeROM       = 0x0302, /* BD-ROM */
    kBDMediaTypeRE        = 0x0303, /* BD-RE  */
    kBDMediaTypeR         = 0x0304, /* BD-R   */

    kBDMediaTypeMin       = 0x0300,
    kBDMediaTypeMax       = 0x03FF
};

typedef UInt32 BDMediaType;

/*
 * Media Speed (kB/s)
 */

#define kBDSpeedMin 0x1126
#define kBDSpeedMax 0xFFFF

/*
 * MMC Formats
 */

// Read Disc Information Format
struct BDDiscInfo
{
    UInt16 dataLength;
#ifdef __LITTLE_ENDIAN__
    UInt8  discStatus:2;
    UInt8  stateOfLastSession:2;
    UInt8  erasable:1;
    UInt8  dataType:3;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  dataType:3;
    UInt8  erasable:1;
    UInt8  stateOfLastSession:2;
    UInt8  discStatus:2;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  reserved2;
    UInt8  numberOfSessionsLSB;
    UInt8  firstTrackNumberInLastSessionLSB;
    UInt8  lastTrackNumberInLastSessionLSB;
    UInt8  reserved4[2];
    UInt8  numberOfSessionsMSB;
    UInt8  firstTrackNumberInLastSessionMSB;
    UInt8  lastTrackNumberInLastSessionMSB;
    UInt8  reserved6[22];
};
typedef struct BDDiscInfo BDDiscInfo;

// Read Track Information Format
struct BDTrackInfo
{
    UInt16 dataLength;
    UInt8  trackNumberLSB;
    UInt8  sessionNumberLSB;
    UInt8  reserved;
#ifdef __LITTLE_ENDIAN__
    UInt8  reserved2:5;
    UInt8  damage:1;
    UInt8  reserved3:2;

    UInt8  reserved4:6;
    UInt8  blank:1;
    UInt8  reservedTrack:1;

    UInt8  nextWritableAddressValid:1;
    UInt8  lastRecordedAddressValid:1;
    UInt8  reserved5:6;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved3:2;
    UInt8  damage:1;
    UInt8  reserved2:5;

    UInt8  reservedTrack:1;
    UInt8  blank:1;
    UInt8  reserved4:6;

    UInt8  reserved5:6;
    UInt8  lastRecordedAddressValid:1;
    UInt8  nextWritableAddressValid:1;
#endif /* !__LITTLE_ENDIAN__ */
    UInt32 trackStartAddress;
    UInt32 nextWritableAddress;
    UInt32 freeBlocks;
    UInt32 clusterSize;
    UInt32 trackSize;
    UInt32 lastRecordedAddress;
    UInt8  trackNumberMSB;
    UInt8  sessionNumberMSB;
    UInt8  reserved6;
    UInt8  reserved7;
};
typedef struct BDTrackInfo BDTrackInfo;

#pragma pack(pop)                        /* (reset to default struct packing) */

#endif /* _BDTYPES_H */
                                                                                                                                                                 IOBlockStorageDevice.h                                                                              0100644 0001750 0001750 00000003235 12567452411 036351  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOBlockStorageDevice
 * @abstract
 * This header contains the IOBlockStorageDevice class definition.
 */

#ifndef _IOBLOCKSTORAGEDEVICE_H
#define _IOBLOCKSTORAGEDEVICE_H

#include <IOKit/IOTypes.h>
#include <IOKit/storage/IOStorageDeviceCharacteristics.h>

/*!
 * @defined kIOBlockStorageDeviceClass
 * @abstract
 * The name of the IOBlockStorageDevice class.
 */

#define kIOBlockStorageDeviceClass "IOBlockStorageDevice"

/*!
 * @defined kIOBlockStorageDeviceWriteCacheStateKey
 * @abstract
 * The name of the property used to get or set the write cache state of the
 * block storage device.
 */
#define kIOBlockStorageDeviceWriteCacheStateKey	"WriteCacheState"

#endif /* !_IOBLOCKSTORAGEDEVICE_H */
                                                                                                                                                                                                                                                                                                                                                                   IOBlockStorageDriver.h                                                                              0100644 0001750 0001750 00000021050 12567452412 036401  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOBlockStorageDriver
 * @abstract
 * This header contains the IOBlockStorageDriver class definition.
 */

#ifndef _IOBLOCKSTORAGEDRIVER_H
#define _IOBLOCKSTORAGEDRIVER_H

#include <IOKit/IOTypes.h>

/*!
 * @defined kIOBlockStorageDriverClass
 * @abstract
 * The name of the IOBlockStorageDriver class.
 */

#define kIOBlockStorageDriverClass "IOBlockStorageDriver"

/*!
 * @defined kIOBlockStorageDriverStatisticsKey
 * @abstract
 * Holds a table of numeric values describing the driver's
 * operating statistics.
 * @discussion
 * This property holds a table of numeric values describing the driver's
 * operating statistics.  The table is an OSDictionary, where each entry
 * describes one given statistic.
 */

#define kIOBlockStorageDriverStatisticsKey "Statistics"

/*!
 * @defined kIOBlockStorageDriverStatisticsBytesReadKey
 * @abstract
 * Describes the number of bytes read since the block storage
 * driver was instantiated.
 * @discussion
 * This property describes the number of bytes read since the block storage
 * driver was instantiated.  It is one of the statistic entries listed under
 * the top-level kIOBlockStorageDriverStatisticsKey property table.  It has
 * an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsBytesReadKey "Bytes (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsBytesWrittenKey
 * @abstract
 * Describes the number of bytes written since the block storage
 * driver was instantiated. 
 * @discussion
 * This property describes the number of bytes written since the block storage
 * driver was instantiated.  It is one of the statistic entries listed under the
 * top-level kIOBlockStorageDriverStatisticsKey property table.  It has an
 * OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsBytesWrittenKey "Bytes (Write)"

/*!
 * @defined kIOBlockStorageDriverStatisticsReadErrorsKey
 * @abstract
 * Describes the number of read errors encountered since the block
 * storage driver was instantiated. 
 * @discussion
 * This property describes the number of read errors encountered since the block
 * storage driver was instantiated.  It is one of the statistic entries listed
 * under the top-level kIOBlockStorageDriverStatisticsKey property table.  It
 * has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsReadErrorsKey "Errors (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsWriteErrorsKey
 * @abstract
 * Describes the number of write errors encountered since the
 * block storage driver was instantiated.
 * @discussion
 * This property describes the number of write errors encountered since the
 * block storage driver was instantiated.  It is one of the statistic entries
 * listed under the top-level kIOBlockStorageDriverStatisticsKey property table. 
 * It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsWriteErrorsKey "Errors (Write)"

/*!
 * @defined kIOBlockStorageDriverStatisticsLatentReadTimeKey
 * @abstract
 * Describes the number of nanoseconds of latency during reads
 * since the block storage driver was instantiated. 
 * @discussion
 * This property describes the number of nanoseconds of latency during reads
 * since the block storage driver was instantiated.  It is one of the statistic
 * entries listed under the top-level kIOBlockStorageDriverStatisticsKey
 * property table.  It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsLatentReadTimeKey "Latency Time (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsLatentWriteTimeKey
 * @abstract
 * Describes the number of nanoseconds of latency during writes
 * since the block storage driver was instantiated. 
 * @discussion
 * This property describes the number of nanoseconds of latency during writes
 * since the block storage driver was instantiated.  It is one of the statistic
 * entries listed under the top-level kIOBlockStorageDriverStatisticsKey
 * property table.  It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsLatentWriteTimeKey "Latency Time (Write)"

/*!
 * @defined kIOBlockStorageDriverStatisticsReadsKey
 * @abstract
 * Describes the number of read operations processed since the
 * block storage driver was instantiated.
 * @discussion
 * This property describes the number of read operations processed since the
 * block storage driver was instantiated.  It is one of the statistic entries
 * listed under the top-level kIOBlockStorageDriverStatisticsKey property table.
 * It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsReadsKey "Operations (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsWritesKey
 * @abstract
 * Describes the number of write operations processed since the
 * block storage driver was instantiated.
 * @discussion
 * This property describes the number of write operations processed since the
 * block storage driver was instantiated.  It is one of the statistic entries
 * listed under the top-level kIOBlockStorageDriverStatisticsKey property table.
 * It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsWritesKey "Operations (Write)"

/*!
 * @defined kIOBlockStorageDriverStatisticsReadRetriesKey
 * @abstract
 * Describes the number of read retries required since the block
 * storage driver was instantiated.
 * @discussion
 * This property describes the number of read retries required since the block
 * storage driver was instantiated.  It is one of the statistic entries listed
 * under the top-level kIOBlockStorageDriverStatisticsKey property table.  It
 * has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsReadRetriesKey "Retries (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsWriteRetriesKey
 * @abstract
 * Describes the number of write retries required since the block
 * storage driver was instantiated.
 * @discussion
 * This property describes the number of write retries required since the block
 * storage driver was instantiated.  It is one of the statistic entries listed
 * under the top-level kIOBlockStorageDriverStatisticsKey property table.  It
 * has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsWriteRetriesKey "Retries (Write)"

/*!
 * @defined kIOBlockStorageDriverStatisticsTotalReadTimeKey
 * @abstract
 * Describes the number of nanoseconds spent performing reads
 * since the block storage driver was instantiated.
 * @discussion
 * This property describes the number of nanoseconds spent performing reads
 * since the block storage driver was instantiated.  It is one of the statistic
 * entries listed under the top-level kIOBlockStorageDriverStatisticsKey
 * property table.  It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsTotalReadTimeKey "Total Time (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsTotalWriteTimeKey
 * @abstract
 * Describes the number of nanoseconds spent performing writes
 * since the block storage driver was instantiated.
 * @discussion
 * This property describes the number of nanoseconds spent performing writes
 * since the block storage driver was instantiated.  It is one of the statistic
 * entries listed under the top-level kIOBlockStorageDriverStatisticsKey
 * property table.  It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsTotalWriteTimeKey "Total Time (Write)"

/*!
 * @enum IOMediaState
 * @abstract
 * The different states that getMediaState() can report.
 * @constant kIOMediaStateOffline
 * Media is not available.
 * @constant kIOMediaStateOnline
 * Media is available and ready for operations.
 * @constant kIOMediaStateBusy
 * Media is available, but not ready for operations.
 */

enum
{
    kIOMediaStateOffline = 0,
    kIOMediaStateOnline  = 1,
    kIOMediaStateBusy    = 2
};

typedef UInt32 IOMediaState;

#endif /* !_IOBLOCKSTORAGEDRIVER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        IOCDBlockStorageDevice.h                                                                            0100644 0001750 0001750 00000003016 12567452643 036564  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOCDBlockStorageDevice
 * @abstract
 * This header contains the IOCDBlockStorageDevice class definition.
 */

#ifndef _IOCDBLOCKSTORAGEDEVICE_H
#define _IOCDBLOCKSTORAGEDEVICE_H

#include <IOKit/storage/IOCDTypes.h>

/*!
 * @defined kIOCDBlockStorageDeviceClass
 * @abstract
 * kIOCDBlockStorageDeviceClass is the name of the IOCDBlockStorageDevice class.
 * @discussion
 * kIOCDBlockStorageDeviceClass is the name of the IOCDBlockStorageDevice class.
 */

#define kIOCDBlockStorageDeviceClass "IOCDBlockStorageDevice"

#endif /* !_IOCDBLOCKSTORAGEDEVICE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  IOCDMedia.h                                                                                         0100644 0001750 0001750 00000005212 12567452643 034104  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOCDMedia
 * @abstract
 * This header contains the IOCDMedia class definition.
 */

#ifndef _IOCDMEDIA_H
#define _IOCDMEDIA_H

/*!
 * @defined kIOCDMediaClass
 * @abstract
 * kIOCDMediaClass is the name of the IOCDMedia class.
 * @discussion
 * kIOCDMediaClass is the name of the IOCDMedia class.
 */

#define kIOCDMediaClass "IOCDMedia"

/*!
 * @defined kIOCDMediaTOCKey
 * @abstract
 * kIOCDMediaTOCKey is a property of IOCDMedia objects.  It has an OSData value
 * and a CDTOC structure.
 * @discussion
 * The kIOCDMediaTOCKey property contains the CD's full table of contents,
 * formatted as a CDTOC structure.  The CDTOC structure is same as what is
 * returned by a READ TOC command, format 0x02.  All fields in the TOC are
 * guaranteed to be binary-encoded (no BCD-encoded numbers are ever passed).
 */

#define kIOCDMediaTOCKey "TOC"

/*!
 * @defined kIOCDMediaTypeKey
 * @abstract
 * kIOCDMediaTypeKey is a property of IOCDMedia objects.  It has an OSString
 * value.
 * @discussion
 * The kIOCDMediaTypeKey property identifies the CD media type (CD-ROM, CD-R,
 * CD-RW, etc).  See the kIOCDMediaType contants for possible values.
 */

#define kIOCDMediaTypeKey "Type"

/*!
 * @defined kIOCDMediaTypeROM
 * The kIOCDMediaTypeKey constant for CD-ROM media (inclusive of the CD-I,
 * CD-ROM XA, and CD Audio standards, and mixed mode combinations thereof).
 */

#define kIOCDMediaTypeROM "CD-ROM"

/*!
 * @defined kIOCDMediaTypeR
 * The kIOCDMediaTypeKey constant for CD Recordable (CD-R) media.
 */

#define kIOCDMediaTypeR "CD-R"

/*!
 * @defined kIOCDMediaTypeRW
 * The kIOCDMediaTypeKey constant for CD ReWritable (CD-RW) media.
 */

#define kIOCDMediaTypeRW "CD-RW"

#endif /* !_IOCDMEDIA_H */
                                                                                                                                                                                                                                                                                                                                                                                      IOCDMediaBSDClient.h                                                                                0100644 0001750 0001750 00000011134 12567452643 035574  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOCDMEDIABSDCLIENT_H
#define _IOCDMEDIABSDCLIENT_H

#include <sys/ioctl.h>

#include <IOKit/storage/IOCDTypes.h>

/*
 * Definitions
 *
 * ioctl                        description
 * ---------------------------- ------------------------------------------------
 * DKIOCCDREAD                  see IOCDMedia::readCD()           in IOCDMedia.h
 * DKIOCCDREADTOC               see IOCDMedia::readTOC()          in IOCDMedia.h
 *
 * DKIOCCDREADDISCINFO          see IOCDMedia::readDiscInfo()     in IOCDMedia.h
 * DKIOCCDREADTRACKINFO         see IOCDMedia::readTrackInfo()    in IOCDMedia.h
 *
 * DKIOCCDREADISRC              see IOCDMedia::readISRC()         in IOCDMedia.h
 * DKIOCCDREADMCN               see IOCDMedia::readMCN()          in IOCDMedia.h
 *
 * DKIOCCDGETSPEED              see IOCDMedia::getSpeed()         in IOCDMedia.h
 * DKIOCCDSETSPEED              see IOCDMedia::setSpeed()         in IOCDMedia.h
 *
 *         in /System/Library/Frameworks/Kernel.framework/Headers/IOKit/storage/
 */

typedef struct
{
    uint64_t offset;

    uint8_t  sectorArea;
    uint8_t  sectorType;

#ifdef __LP64__
    uint8_t  reserved0080[10];                     /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0080[6];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint32_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_cd_read_t;

typedef struct
{
    CDISRC   isrc;
    uint8_t  track;

    uint8_t  reserved0112[2];                      /* reserved, clear to zero */
} dk_cd_read_isrc_t;

typedef struct
{
    CDMCN    mcn;

    uint8_t  reserved0112[2];                      /* reserved, clear to zero */
} dk_cd_read_mcn_t;

typedef struct
{
    uint8_t  format;
    uint8_t  formatAsTime;

    uint8_t  reserved0016[5];                      /* reserved, clear to zero */

    union
    {
        uint8_t session;
        uint8_t track;
    } address;

#ifdef __LP64__
    uint8_t  reserved0064[6];                      /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0064[2];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_cd_read_toc_t;

typedef struct
{
#ifdef __LP64__
    uint8_t  reserved0000[14];                     /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0000[10];                     /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_cd_read_disc_info_t;

typedef struct
{
    uint8_t  reserved0000[4];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  addressType;

#ifdef __LP64__
    uint8_t  reserved0072[5];                      /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0072[1];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_cd_read_track_info_t;

#define DKIOCCDREAD          _IOWR('d', 96, dk_cd_read_t)

#define DKIOCCDREADISRC      _IOWR('d', 97, dk_cd_read_isrc_t)
#define DKIOCCDREADMCN       _IOWR('d', 98, dk_cd_read_mcn_t)

#define DKIOCCDGETSPEED      _IOR('d', 99, uint16_t)
#define DKIOCCDSETSPEED      _IOW('d', 99, uint16_t)

#define DKIOCCDREADTOC       _IOWR('d', 100, dk_cd_read_toc_t)

#define DKIOCCDREADDISCINFO  _IOWR('d', 101, dk_cd_read_disc_info_t)
#define DKIOCCDREADTRACKINFO _IOWR('d', 102, dk_cd_read_track_info_t)

#endif /* !_IOCDMEDIABSDCLIENT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                    IOCDPartitionScheme.h                                                                               0100644 0001750 0001750 00000003537 12567452643 036173  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * @header IOCDPartitionScheme
 * @abstract
 * This header contains the IOCDPartitionScheme class definition.
 */

#ifndef _IOCDPARTITIONSCHEME_H
#define _IOCDPARTITIONSCHEME_H

#include <IOKit/storage/IOCDTypes.h>

/*
 * @defined kIOCDPartitionSchemeClass
 * @abstract
 * kIOCDPartitionSchemeClass is the name of the IOCDPartitionScheme class.
 * @discussion
 * kIOCDPartitionSchemeClass is the name of the IOCDPartitionScheme class.
 */

#define kIOCDPartitionSchemeClass "IOCDPartitionScheme"

/*
 * @defined kIOMediaSessionIDKey
 * @abstract
 * kIOMediaSessionIDKey is property of IOMedia objects.  It has an OSNumber
 * value.
 * @discussion
 * The kIOMediaSessionIDKey property is placed into each IOMedia instance
 * created by the CD partition scheme.  It identifies the session number
 * the track was recorded on.
 */

#define kIOMediaSessionIDKey "Session ID"

#endif /* !_IOCDPARTITIONSCHEME_H */
                                                                                                                                                                 IOCDTypes.h                                                                                         0100644 0001750 0001750 00000030010 12567452643 034163  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef	_IOCDTYPES_H
#define	_IOCDTYPES_H

#include <IOKit/IOTypes.h>
#include <libkern/OSByteOrder.h>

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/*
 * Minutes, Seconds, Frames (M:S:F)
 *
 * All M:S:F values passed across I/O Kit APIs are guaranteed to be
 * binary-encoded numbers (no BCD-encoded numbers are ever passed).
 */

typedef struct
{
    UInt8 minute;
    UInt8 second;
    UInt8 frame;
} CDMSF;

/*
 * Media Catalogue Numbers (MCN), International Standard Recording Codes (ISRC)
 *
 * All MCN and ISRC values passed across I/O Kit APIs are guaranteed
 * to have a zero-terminating byte, for convenient use as C strings.
 */

#define kCDMCNMaxLength  13
#define kCDISRCMaxLength 12

typedef char CDMCN [kCDMCNMaxLength  + 1];
typedef char CDISRC[kCDISRCMaxLength + 1];

/*
 * Audio Status
 *
 * All CDAudioStatus fields passed across I/O Kit APIs are guaranteed to
 * be binary-encoded numbers (no BCD-encoded numbers are ever passed).
 */

#define kCDAudioStatusUnsupported 0x00
#define kCDAudioStatusActive      0x11
#define kCDAudioStatusPaused      0x12
#define kCDAudioStatusSuccess     0x13
#define kCDAudioStatusFailure     0x14
#define kCDAudioStatusNone        0x15

typedef struct
{
    UInt8 status;
    struct
    {
        CDMSF time;
        struct
        {
            UInt8 index;
            UInt8 number;
            CDMSF time;
        } track;
    } position;
} CDAudioStatus;

/*
 * Table Of Contents
 *
 * All CDTOC fields passed across I/O Kit APIs are guaranteed to be
 * binary-encoded numbers (no BCD-encoded numbers are ever passed).
 */

typedef struct
{
    UInt8 session;
#ifdef __LITTLE_ENDIAN__
    UInt8 control:4, adr:4;
#else /* !__LITTLE_ENDIAN__ */
    UInt8 adr:4, control:4;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8 tno;
    UInt8 point;
    CDMSF address;
    UInt8 zero;
    CDMSF p;
} CDTOCDescriptor;

typedef struct
{
    UInt16          length;
    UInt8           sessionFirst;
    UInt8           sessionLast;
    CDTOCDescriptor descriptors[0];
} CDTOC;

/*
 * Table Of Contents Descriptor Count Convenience Function
 */

static inline UInt32 CDTOCGetDescriptorCount(CDTOC * toc)
{
    UInt32 tocSize = OSSwapBigToHostInt16(toc->length) + (UInt32) sizeof(toc->length);

    return (tocSize < (UInt32) sizeof(CDTOC)) ? 0 : 
           (tocSize - (UInt32) sizeof(CDTOC)) / (UInt32) sizeof(CDTOCDescriptor);
}

/*
 * M:S:F To LBA Convenience Function
 */

static inline UInt32 CDConvertMSFToLBA(CDMSF msf)
{
    return (((msf.minute * 60U) + msf.second) * 75U) + msf.frame - 150U;
}

/*
 * M:S:F To Clipped LBA Convenience Function
 */

static inline UInt32 CDConvertMSFToClippedLBA(CDMSF msf)
{
    return (msf.minute == 0 && msf.second <= 1) ? 0 : CDConvertMSFToLBA(msf);
}

/*
 * LBA To M:S:F Convenience Function
 */

static inline CDMSF CDConvertLBAToMSF(UInt32 lba)
{
    CDMSF msf;

    lba += 150;
    msf.minute = (lba / (75 * 60));
    msf.second = (lba % (75 * 60)) / 75;
    msf.frame  = (lba % (75     ));
    
    return msf;
}

/*
 * Track Number To M:S:F Convenience Function
 *
 * The CDTOC structure is assumed to be complete, that is, none of
 * the descriptors are missing or clipped due to an insufficiently
 * sized buffer holding the CDTOC contents.
 */

static inline CDMSF CDConvertTrackNumberToMSF(UInt8 track, CDTOC * toc)
{
    UInt32 count = CDTOCGetDescriptorCount(toc);
    UInt32 i;
    CDMSF  msf   = { 0xFF, 0xFF, 0xFF };

    for (i = 0; i < count; i++)
    {
        if (toc->descriptors[i].point == track && toc->descriptors[i].adr == 1)
        {
            msf = toc->descriptors[i].p;
            break;
        }
    }

    return msf;
}

/*
 * Sector Areas, Sector Types
 *
 * Bytes Per Type      CDDA       Mode1      Mode2   Mode2Form1 Mode2Form2
 *       Per Area  +----------+----------+----------+----------+----------+
 * Sync            | 0        | 12       | 12       | 12       | 12       |
 * Header          | 0        | 4        | 4        | 4        | 4        |
 * SubHeader       | 0        | 0        | 0        | 8        | 8        |
 * User            | 2352     | 2048     | 2336     | 2048     | 2328     |
 * Auxiliary       | 0        | 288      | 0        | 280      | 0        |
 * ErrorFlags      | 294      | 294      | 294      | 294      | 294      |
 * SubChannel      | 96       | 96       | 96       | 96       | 96       |
 * SubChannelQ     | 16       | 16       | 16       | 16       | 16       |
 *                 +----------+----------+----------+----------+----------+
 */

typedef enum
{
    kCDSectorAreaSync        = 0x80,
    kCDSectorAreaHeader      = 0x20,
    kCDSectorAreaSubHeader   = 0x40,
    kCDSectorAreaUser        = 0x10,
    kCDSectorAreaAuxiliary   = 0x08,
    kCDSectorAreaErrorFlags  = 0x02,
    kCDSectorAreaSubChannel  = 0x01,
    kCDSectorAreaSubChannelQ = 0x04
} CDSectorArea;

typedef enum
{
    kCDSectorTypeUnknown     = 0x00,
    kCDSectorTypeCDDA        = 0x01,
    kCDSectorTypeMode1       = 0x02,
    kCDSectorTypeMode2       = 0x03,
    kCDSectorTypeMode2Form1  = 0x04,
    kCDSectorTypeMode2Form2  = 0x05,
    kCDSectorTypeCount       = 0x06
} CDSectorType;

typedef enum
{
    kCDSectorSizeCDDA        = 2352,
    kCDSectorSizeMode1       = 2048,
    kCDSectorSizeMode2       = 2336,
    kCDSectorSizeMode2Form1  = 2048,
    kCDSectorSizeMode2Form2  = 2328,
    kCDSectorSizeWhole       = 2352
} CDSectorSize;

/*
 * Media Types
 */

enum
{
    kCDMediaTypeUnknown      = 0x0100,
    kCDMediaTypeROM          = 0x0102, /* CD-ROM */
    kCDMediaTypeR            = 0x0104, /* CD-R   */
    kCDMediaTypeRW           = 0x0105, /* CD-RW  */

    kCDMediaTypeMin          = 0x0100,
    kCDMediaTypeMax          = 0x01FF
};

typedef UInt32 CDMediaType;

/*
 * Media Speed (kB/s)
 */

#define kCDSpeedMin 0x00B0
#define kCDSpeedMax 0xFFFF

/*
 * MMC Formats
 */

// Read Table Of Contents Format Types
typedef UInt8 CDTOCFormat;
enum
{
    kCDTOCFormatTOC  = 0x02, // CDTOC
    kCDTOCFormatPMA  = 0x03, // CDPMA
    kCDTOCFormatATIP = 0x04, // CDATIP
    kCDTOCFormatTEXT = 0x05  // CDTEXT
};

// Read Table Of Contents Format 0x03
struct CDPMADescriptor
{
    UInt8 reserved;
#ifdef __LITTLE_ENDIAN__
    UInt8 control:4, adr:4;
#else /* !__LITTLE_ENDIAN__ */
    UInt8 adr:4, control:4;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8 tno;
    UInt8 point;
    CDMSF address;
    UInt8 zero;
    CDMSF p;
};
typedef struct CDPMADescriptor CDPMADescriptor;

struct CDPMA
{
    UInt16          dataLength;
    UInt8           reserved;
    UInt8           reserved2;
    CDPMADescriptor descriptors[0];
};
typedef struct CDPMA CDPMA;

// Read Table Of Contents Format 0x04
struct CDATIP
{
    UInt16 dataLength;
    UInt8  reserved[2];
#ifdef __LITTLE_ENDIAN__
    UInt8  referenceSpeed:3;
    UInt8  reserved3:1;
    UInt8  indicativeTargetWritingPower:3;
    UInt8  reserved2:1;

    UInt8  reserved5:6;
    UInt8  unrestrictedUse:1;
    UInt8  reserved4:1;

    UInt8  a3Valid:1;
    UInt8  a2Valid:1;
    UInt8  a1Valid:1;
    UInt8  discSubType:3;
    UInt8  discType:1;
    UInt8  reserved6:1;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved2:1;
    UInt8  indicativeTargetWritingPower:3;
    UInt8  reserved3:1;
    UInt8  referenceSpeed:3;

    UInt8  reserved4:1;
    UInt8  unrestrictedUse:1;
    UInt8  reserved5:6;

    UInt8  reserved6:1;
    UInt8  discType:1;
    UInt8  discSubType:3;
    UInt8  a1Valid:1;
    UInt8  a2Valid:1;
    UInt8  a3Valid:1;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  reserved7;
    CDMSF  startTimeOfLeadIn;
    UInt8  reserved8;
    CDMSF  lastPossibleStartTimeOfLeadOut;
    UInt8  reserved9;
    UInt8  a1[3];
    UInt8  reserved10;
    UInt8  a2[3];
    UInt8  reserved11;
    UInt8  a3[3];
    UInt8  reserved12;
};
typedef struct CDATIP CDATIP;

// Read Table Of Contents Format 0x05
struct CDTEXTDescriptor
{
    UInt8 packType;
    UInt8 trackNumber;
    UInt8 sequenceNumber;
#ifdef __LITTLE_ENDIAN__
    UInt8 characterPosition:4;
    UInt8 blockNumber:3;
    UInt8 doubleByteCharacterCode:1;
#else /* !__LITTLE_ENDIAN__ */
    UInt8 doubleByteCharacterCode:1;
    UInt8 blockNumber:3;
    UInt8 characterPosition:4;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8 textData[12];
    UInt8 reserved[2];
};
typedef struct CDTEXTDescriptor CDTEXTDescriptor;

struct CDTEXT
{
    UInt16           dataLength;
    UInt8            reserved;
    UInt8            reserved2;
    CDTEXTDescriptor descriptors[0];
};
typedef struct CDTEXT CDTEXT;

// Read Disc Information Format
struct CDDiscInfo
{
    UInt16 dataLength;
#ifdef __LITTLE_ENDIAN__
    UInt8  discStatus:2;
    UInt8  stateOfLastSession:2;
    UInt8  erasable:1;
    UInt8  reserved:3;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved:3;
    UInt8  erasable:1;
    UInt8  stateOfLastSession:2;
    UInt8  discStatus:2;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  numberOfFirstTrack;
    UInt8  numberOfSessionsLSB;
    UInt8  firstTrackNumberInLastSessionLSB;
    UInt8  lastTrackNumberInLastSessionLSB;
#ifdef __LITTLE_ENDIAN__
    UInt8  reserved3:5;
    UInt8  unrestrictedUse:1;
    UInt8  discBarCodeValid:1;
    UInt8  discIdentificationValid:1;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  discIdentificationValid:1;
    UInt8  discBarCodeValid:1;
    UInt8  unrestrictedUse:1;
    UInt8  reserved3:5;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  discType;
    UInt8  numberOfSessionsMSB;
    UInt8  firstTrackNumberInLastSessionMSB;
    UInt8  lastTrackNumberInLastSessionMSB;
    UInt32 discIdentification;
    UInt8  reserved7;
    CDMSF  lastSessionLeadInStartTime;
    UInt8  reserved8;
    CDMSF  lastPossibleStartTimeOfLeadOut;
    UInt8  discBarCode[8];
    UInt8  reserved9;
    UInt8  numberOfOPCTableEntries;
    UInt8  opcTableEntries[0];
};
typedef struct CDDiscInfo CDDiscInfo;

// Read Track Information Address Types
typedef UInt8 CDTrackInfoAddressType;
enum
{
    kCDTrackInfoAddressTypeLBA           = 0x00,
    kCDTrackInfoAddressTypeTrackNumber   = 0x01,
    kCDTrackInfoAddressTypeSessionNumber = 0x02,
};

// Read Track Information Format
struct CDTrackInfo
{
    UInt16 dataLength;
    UInt8  trackNumberLSB;
    UInt8  sessionNumberLSB;
    UInt8  reserved;
#ifdef __LITTLE_ENDIAN__
    UInt8  trackMode:4;
    UInt8  copy:1;
    UInt8  damage:1;
    UInt8  reserved3:2;

    UInt8  dataMode:4;
    UInt8  fixedPacket:1;
    UInt8  packet:1;
    UInt8  blank:1;
    UInt8  reservedTrack:1;

    UInt8  nextWritableAddressValid:1;
    UInt8  lastRecordedAddressValid:1;
    UInt8  reserved5:6;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved3:2;
    UInt8  damage:1;
    UInt8  copy:1;
    UInt8  trackMode:4;

    UInt8  reservedTrack:1;
    UInt8  blank:1;
    UInt8  packet:1;
    UInt8  fixedPacket:1;
    UInt8  dataMode:4;

    UInt8  reserved5:6;
    UInt8  lastRecordedAddressValid:1;
    UInt8  nextWritableAddressValid:1;
#endif /* !__LITTLE_ENDIAN__ */
    UInt32 trackStartAddress;
    UInt32 nextWritableAddress;
    UInt32 freeBlocks;
    UInt32 fixedPacketSize;
    UInt32 trackSize;
    UInt32 lastRecordedAddress;
    UInt8  trackNumberMSB;
    UInt8  sessionNumberMSB;
    UInt8  reserved6;
    UInt8  reserved7;
};
typedef struct CDTrackInfo CDTrackInfo;

#pragma pack(pop)                        /* (reset to default struct packing) */

#endif /* _IOCDTYPES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        IODVDBlockStorageDevice.h                                                                           0100644 0001750 0001750 00000003033 12567452466 036715  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IODVDBlockStorageDevice
 * @abstract
 * This header contains the IODVDBlockStorageDevice class definition.
 */

#ifndef	_IODVDBLOCKSTORAGEDEVICE_H
#define	_IODVDBLOCKSTORAGEDEVICE_H

#include <IOKit/storage/IODVDTypes.h>

/*!
 * @defined kIODVDBlockStorageDeviceClass
 * @abstract
 * kIODVDBlockStorageDeviceClass is the name of the IODVDBlockStorageDevice class.
 * @discussion
 * kIODVDBlockStorageDeviceClass is the name of the IODVDBlockStorageDevice class.
 */

#define kIODVDBlockStorageDeviceClass "IODVDBlockStorageDevice"

#endif /* !_IODVDBLOCKSTORAGEDEVICE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     IODVDMedia.h                                                                                        0100644 0001750 0001750 00000006174 12567452466 034246  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IODVDMedia
 * @abstract
 * This header contains the IODVDMedia class definition.
 */

#ifndef _IODVDMEDIA_H
#define _IODVDMEDIA_H

/*!
 * @defined kIODVDMediaClass
 * @abstract
 * kIODVDMediaClass is the name of the IODVDMedia class.
 * @discussion
 * kIODVDMediaClass is the name of the IODVDMedia class.
 */

#define kIODVDMediaClass "IODVDMedia"

/*!
 * @defined kIODVDMediaTypeKey
 * @abstract
 * kIODVDMediaTypeKey is a property of IODVDMedia objects.  It has an OSString
 * value.
 * @discussion
 * The kIODVDMediaTypeKey property identifies the DVD media type (DVD-ROM,
 * DVD-R, DVD-RW, DVD+RW, DVD-RAM, etc).  See the kIODVDMediaType contants
 * for possible values.
 */

#define kIODVDMediaTypeKey "Type"

/*!
 * @defined kIODVDMediaTypeROM
 * The kIODVDMediaTypeKey constant for DVD-ROM media.
 */

#define kIODVDMediaTypeROM "DVD-ROM"

/*!
 * @defined kIODVDMediaTypeR
 * The kIODVDMediaTypeKey constant for DVD Recordable (DVD-R) media.
 */

#define kIODVDMediaTypeR "DVD-R"

/*!
 * @defined kIODVDMediaTypeRW
 * The kIODVDMediaTypeKey constant for DVD ReWritable (DVD-RW) media.
 */

#define kIODVDMediaTypeRW "DVD-RW"

/*!
 * @defined kIODVDMediaTypePlusR
 * The kIODVDMediaTypeKey constant for DVD "Plus" Recordable (DVD+R) media.
 */

#define kIODVDMediaTypePlusR "DVD+R"

/*!
 * @defined kIODVDMediaTypePlusRW
 * The kIODVDMediaTypeKey constant for DVD "Plus" ReWritable (DVD+RW) media.
 */

#define kIODVDMediaTypePlusRW "DVD+RW"

/*!
 * @defined kIODVDMediaTypeRAM
 * The kIODVDMediaTypeKey constant for DVD-RAM media.
 */

#define kIODVDMediaTypeRAM "DVD-RAM"

/*!
 * @defined kIODVDMediaTypeHDROM
 * The kIODVDMediaTypeKey constant for HD DVD-ROM media.
 */

#define kIODVDMediaTypeHDROM "HD DVD-ROM"

/*!
 * @defined kIODVDMediaTypeHDR
 * The kIODVDMediaTypeKey constant for HD DVD Recordable (HD DVD-R) media.
 */

#define kIODVDMediaTypeHDR "HD DVD-R"

/*!
 * @defined kIODVDMediaTypeHDRW
 * The kIODVDMediaTypeKey constant for HD DVD ReWritable (HD DVD-RW) media.
 */

#define kIODVDMediaTypeHDRW "HD DVD-RW"

/*!
 * @defined kIODVDMediaTypeHDRAM
 * The kIODVDMediaTypeKey constant for HD DVD-RAM media.
 */

#define kIODVDMediaTypeHDRAM "HD DVD-RAM"

#endif /* !_IODVDMEDIA_H */
                                                                                                                                                                                                                                                                                                                                                                                                    IODVDMediaBSDClient.h                                                                               0100644 0001750 0001750 00000011015 12567452466 035724  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IODVDMEDIABSDCLIENT_H
#define _IODVDMEDIABSDCLIENT_H

#include <sys/ioctl.h>

#include <IOKit/storage/IODVDTypes.h>

/*
 * Definitions
 *
 * ioctl                        description
 * ---------------------------- ------------------------------------------------
 * DKIOCDVDREADSTRUCTURE        see IODVDMedia::readStructure()  in IODVDMedia.h
 *
 * DKIOCDVDREADDISCINFO         see IODVDMedia::readDiscInfo()   in IODVDMedia.h
 * DKIOCDVDREADRZONEINFO        see IODVDMedia::readRZoneInfo()  in IODVDMedia.h
 *
 * DKIOCDVDREPORTKEY            see IODVDMedia::reportKey()      in IODVDMedia.h
 * DKIOCDVDSENDKEY              see IODVDMedia::sendKey()        in IODVDMedia.h
 *
 * DKIOCDVDGETSPEED             see IODVDMedia::getSpeed()       in IODVDMedia.h
 * DKIOCDVDSETSPEED             see IODVDMedia::setSpeed()       in IODVDMedia.h
 *
 *         in /System/Library/Frameworks/Kernel.framework/Headers/IOKit/storage/
 */

typedef struct
{
    uint8_t  format;

    uint8_t  reserved0008[3];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  grantID;
    uint8_t  layer;

#ifdef __LP64__
    uint8_t  reserved0080[4];                      /* reserved, clear to zero */
#endif /* __LP64__ */

    uint16_t bufferLength;
    void *   buffer;
} dk_dvd_read_structure_t;

typedef struct
{
    uint8_t  format;
    uint8_t  keyClass;

    uint8_t  reserved0016[2];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  grantID;

#ifdef __LP64__
    uint8_t  reserved0072[5];                      /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0072[1];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;
    void *   buffer;
} dk_dvd_report_key_t;

typedef struct
{
    uint8_t  format;
    uint8_t  keyClass;

    uint8_t  reserved0016[6];                      /* reserved, clear to zero */

    uint8_t  grantID;

#ifdef __LP64__
    uint8_t  reserved0072[5];                      /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0072[1];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;
    void *   buffer;
} dk_dvd_send_key_t;

typedef struct
{
#ifdef __LP64__
    uint8_t  reserved0000[14];                     /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0000[10];                     /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_dvd_read_disc_info_t;

typedef struct
{
    uint8_t  reserved0000[4];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  addressType;

#ifdef __LP64__
    uint8_t  reserved0072[5];                      /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0072[1];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_dvd_read_rzone_info_t;

#define DKIOCDVDREADSTRUCTURE   _IOW('d', 128, dk_dvd_read_structure_t)
#define DKIOCDVDREPORTKEY       _IOW('d', 129, dk_dvd_report_key_t)
#define DKIOCDVDSENDKEY         _IOW('d', 130, dk_dvd_send_key_t)

#define DKIOCDVDGETSPEED        _IOR('d', 131, uint16_t)
#define DKIOCDVDSETSPEED        _IOW('d', 131, uint16_t)

#define DKIOCDVDREADDISCINFO    _IOWR('d', 132, dk_dvd_read_disc_info_t)
#define DKIOCDVDREADRZONEINFO   _IOWR('d', 133, dk_dvd_read_rzone_info_t)

#endif /* !_IODVDMEDIABSDCLIENT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   IODVDTypes.h                                                                                        0100644 0001750 0001750 00000024337 12567452466 034334  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef	_IODVDTYPES_H
#define	_IODVDTYPES_H

#include <IOKit/IOTypes.h>

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/*
 * Media Types
 */

enum
{
    kDVDMediaTypeUnknown   = 0x0200,
    kDVDMediaTypeROM       = 0x0202, /* DVD-ROM    */
    kDVDMediaTypeRAM       = 0x0203, /* DVD-RAM    */
    kDVDMediaTypeR         = 0x0204, /* DVD-R      */
    kDVDMediaTypeRW        = 0x0205, /* DVD-RW     */
    kDVDMediaTypePlusRW    = 0x0206, /* DVD+RW     */
    kDVDMediaTypePlusR     = 0x0207, /* DVD+R      */
    kDVDMediaTypeHDROM     = 0x0212, /* HD DVD-ROM */
    kDVDMediaTypeHDRAM     = 0x0213, /* HD DVD-RAM */
    kDVDMediaTypeHDR       = 0x0214, /* HD DVD-R   */
    kDVDMediaTypeHDRW      = 0x0215, /* HD DVD-RW  */

    kDVDMediaTypeMin       = 0x0200,
    kDVDMediaTypeMax       = 0x02FF
};

typedef UInt32 DVDMediaType;

/*
 * Media Speed (kB/s)
 */

#define kDVDSpeedMin 0x0546
#define kDVDSpeedMax 0xFFFF

/*
 * MMC Formats
 */

typedef UInt8	DVDCPRMRegionCode;
enum
{
	kDVDCPRMRegion1		= 0xFE,
	kDVDCPRMRegion2		= 0xFD,
	kDVDCPRMRegion3		= 0xFB,
	kDVDCPRMRegion4		= 0xF7,
	kDVDCPRMRegion5		= 0xEF,
	kDVDCPRMRegion6		= 0xDF
};

typedef UInt8	DVDRegionalPlaybackControlScheme;
enum
{
	kDVDRegionalPlaybackControlSchemePhase1		= 0x00,
	kDVDRegionalPlaybackControlSchemePhase2		= 0x01
};

typedef UInt8	DVDBookType;
enum
{
	kDVDBookTypeROM					= 0x0,
	kDVDBookTypeRAM					= 0x1,
	kDVDBookTypeR					= 0x2,
	kDVDBookTypeRW					= 0x3,
	kDVDBookTypeHDROM				= 0x4,
	kDVDBookTypeHDRAM				= 0x5,
	kDVDBookTypeHDR					= 0x6,
	kDVDBookTypeHDRW				= 0x7,
	kDVDBookTypePlusRW				= 0x9,
	kDVDBookTypePlusR				= 0xA,
	kDVDBookTypePlusRWDoubleLayer	= 0xD,
	kDVDBookTypePlusRDoubleLayer	= 0xE
};

typedef UInt8	DVDKeyClass;
enum
{
	kDVDKeyClassCSS_CPPM_CPRM	= 0x00,
	kDVDKeyClassRSSA			= 0x01
};

typedef UInt8	DVDKeyFormat;
enum
{
	kDVDKeyFormatAGID_CSS			= 0x00,
	kDVDKeyFormatChallengeKey		= 0x01,
	kDVDKeyFormatKey1				= 0x02,
	kDVDKeyFormatKey2				= 0x03,
	kDVDKeyFormatTitleKey			= 0x04,
	kDVDKeyFormatASF				= 0x05,
	kDVDKeyFormatSetRegion			= 0x06,
	kDVDKeyFormatRegionState		= 0x08,
	kDVDKeyFormatAGID_CSS2			= 0x10,
	kDVDKeyFormatAGID_CPRM			= 0x11,
	kDVDKeyFormatAGID_Invalidate	= 0x3F
};	

typedef UInt8	DVDStructureFormat;
enum
{
	kDVDStructureFormatPhysicalFormatInfo			= 0x00,
	kDVDStructureFormatCopyrightInfo				= 0x01,
	kDVDStructureFormatDiscKeyInfo					= 0x02,
	// skip BCA
	kDVDStructureFormatManufacturingInfo			= 0x04
};

// Read DVD Structures Format 0x00
struct DVDPhysicalFormatInfo
{
	UInt8		dataLength[2];
	UInt8		reserved[2];
#ifdef __LITTLE_ENDIAN__
	// Byte 0
	UInt8		partVersion:4;
	UInt8		bookType:4;
	
	// Byte 1
	UInt8		minimumRate:4;
	UInt8		discSize:4;
	
	// Byte 2
	UInt8		layerType:4;
	UInt8		trackPath:1;
	UInt8		numberOfLayers:2;
	UInt8		reserved2:1;
	
	// Byte 3
	UInt8		trackDensity:4;
	UInt8		linearDensity:4;
#else /* !__LITTLE_ENDIAN__ */
	// Byte 0
	UInt8		bookType:4;
	UInt8		partVersion:4;
	
	// Byte 1
	UInt8		discSize:4;
	UInt8		minimumRate:4;
	
	// Byte 2
	UInt8		reserved2:1;
	UInt8		numberOfLayers:2;
	UInt8		trackPath:1;
	UInt8		layerType:4;
	
	// Byte 3
	UInt8		linearDensity:4;
	UInt8		trackDensity:4;
#endif /* !__LITTLE_ENDIAN__ */
	
	// Bytes 4-15
	UInt8		zero1;		// always 0x00
	UInt8		startingPhysicalSectorNumberOfDataArea[3];
	UInt8		zero2;		// always 0x00
	UInt8		endPhysicalSectorNumberOfDataArea[3];
	UInt8		zero3;		// always 0x00
	UInt8		endSectorNumberInLayerZero[3];
	
	// Byte 16
#ifdef __LITTLE_ENDIAN__
	UInt8		reserved1:7;
	UInt8		bcaFlag:1;
#else /* !__LITTLE_ENDIAN__ */
	UInt8		bcaFlag:1;
	UInt8		reserved1:7;
#endif /* !__LITTLE_ENDIAN__ */
	
	// Bytes 17-2047
	UInt8		mediaSpecific[2031];
};
typedef struct DVDPhysicalFormatInfo DVDPhysicalFormatInfo;

// Read DVD Structures Format 0x01
struct DVDCopyrightInfo
{
	UInt8				dataLength[2];
	UInt8				reserved[2];
	UInt8				copyrightProtectionSystemType;
	DVDCPRMRegionCode	regionMask;
	UInt8				reserved2[2];
};
typedef struct DVDCopyrightInfo DVDCopyrightInfo;

// Read DVD Structures Format 0x02
struct DVDDiscKeyInfo
{
	UInt8		dataLength[2];
	UInt8		reserved[2];
	UInt8		discKeyStructures[2048];
};
typedef struct DVDDiscKeyInfo DVDDiscKeyInfo;

// Read DVD Structures Format 0x04
struct DVDManufacturingInfo
{
	UInt8		dataLength[2];
	UInt8		reserved[2];
	UInt8		discManufacturingInfo[2048];
};
typedef struct DVDManufacturingInfo DVDManufacturingInfo;

// ReportKey Format 0x00
struct DVDAuthenticationGrantIDInfo
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
	UInt8	reserved2[3];
#ifdef __LITTLE_ENDIAN__
	UInt8	reservedBits:6;
	UInt8	grantID:2;
#else /* !__LITTLE_ENDIAN__ */
	UInt8	grantID:2;
	UInt8	reservedBits:6;
#endif /* !__LITTLE_ENDIAN__ */
};
typedef struct DVDAuthenticationGrantIDInfo DVDAuthenticationGrantIDInfo;

// ReportKey and SendKey Format 0x01
struct DVDChallengeKeyInfo
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
	UInt8	challengeKeyValue[10];
	UInt8	reserved2[2];
};
typedef struct DVDChallengeKeyInfo DVDChallengeKeyInfo;

// ReportKey Format 0x02
struct DVDKey1Info
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
	UInt8	key1Value[5];
	UInt8	reserved2[3];
};
typedef struct DVDKey1Info DVDKey1Info;

// SendKey Format 0x03
struct DVDKey2Info
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
	UInt8	key2Value[5];
	UInt8	reserved2[3];
};
typedef struct DVDKey2Info DVDKey2Info;

// ReportKey Format 0x04
struct DVDTitleKeyInfo
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
#ifdef __LITTLE_ENDIAN__
	UInt8	CP_MOD:4;
	UInt8	CGMS:2;
	UInt8	CP_SEC:1;
	UInt8	CPM:1;
#else /* !__LITTLE_ENDIAN__ */
	UInt8	CPM:1;
	UInt8	CP_SEC:1;
	UInt8	CGMS:2;
	UInt8	CP_MOD:4;
#endif /* !__LITTLE_ENDIAN__ */
	UInt8	titleKeyValue[5];
	UInt8	reserved2[2];
};
typedef struct DVDTitleKeyInfo DVDTitleKeyInfo;

// ReportKey Format 0x05
struct DVDAuthenticationSuccessFlagInfo
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
	UInt8	reserved2[3];
#ifdef __LITTLE_ENDIAN__
	UInt8	successFlag:1;
	UInt8	reservedBits:7;
#else /* !__LITTLE_ENDIAN__ */
	UInt8	reservedBits:7;
	UInt8	successFlag:1;
#endif /* !__LITTLE_ENDIAN__ */
};
typedef struct DVDAuthenticationSuccessFlagInfo DVDAuthenticationSuccessFlagInfo;

// ReportKey Format 0x08
struct DVDRegionPlaybackControlInfo
{
	UInt8									dataLength[2];
	UInt8									reserved[2];
#ifdef __LITTLE_ENDIAN__
	UInt8									numberUserResets:3;
	UInt8									numberVendorResets:3;
	UInt8									typeCode:2;
#else /* !__LITTLE_ENDIAN__ */
	UInt8									typeCode:2;
	UInt8									numberVendorResets:3;
	UInt8									numberUserResets:3;
#endif /* !__LITTLE_ENDIAN__ */
	DVDCPRMRegionCode						driveRegion;
	DVDRegionalPlaybackControlScheme		rpcScheme;
	UInt8									reserved2;
};
typedef struct DVDRegionPlaybackControlInfo DVDRegionPlaybackControlInfo;

// Read Disc Information Format
struct DVDDiscInfo
{
    UInt16 dataLength;
#ifdef __LITTLE_ENDIAN__
    UInt8  discStatus:2;
    UInt8  stateOfLastBorder:2;
    UInt8  erasable:1;
    UInt8  reserved:3;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved:3;
    UInt8  erasable:1;
    UInt8  stateOfLastBorder:2;
    UInt8  discStatus:2;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  reserved2;
    UInt8  numberOfBordersLSB;
    UInt8  firstRZoneNumberInLastBorderLSB;
    UInt8  lastRZoneNumberInLastBorderLSB;
#ifdef __LITTLE_ENDIAN__
    UInt8  reserved3:5;
    UInt8  unrestrictedUse:1;
    UInt8  discBarCodeValid:1;
    UInt8  reserved4:1;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved4:1;
    UInt8  discBarCodeValid:1;
    UInt8  unrestrictedUse:1;
    UInt8  reserved3:5;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  reserved5;
    UInt8  numberOfBordersMSB;
    UInt8  firstRZoneNumberInLastBorderMSB;
    UInt8  lastRZoneNumberInLastBorderMSB;
    UInt8  reserved6[4];
    UInt8  reserved7[4];
    UInt8  reserved8[4];
    UInt8  discBarCode[8];
    UInt8  reserved9;
    UInt8  numberOfOPCTableEntries;
    UInt8  opcTableEntries[0];
};
typedef struct DVDDiscInfo DVDDiscInfo;

// Read RZone Information Address Types
typedef UInt8 DVDRZoneInfoAddressType;
enum
{
    kDVDRZoneInfoAddressTypeLBA          = 0x00,
    kDVDRZoneInfoAddressTypeRZoneNumber  = 0x01,
    kDVDRZoneInfoAddressTypeBorderNumber = 0x02,
};

// Read RZone Information Format
struct DVDRZoneInfo
{
    UInt16 dataLength;
    UInt8  rzoneNumberLSB;
    UInt8  borderNumberLSB;
    UInt8  reserved;
#ifdef __LITTLE_ENDIAN__
    UInt8  reserved2:4;
    UInt8  copy:1;
    UInt8  damage:1;
    UInt8  reserved3:2;

    UInt8  reserved4:4;
    UInt8  restrictedOverwrite:1;
    UInt8  incremental:1;
    UInt8  blank:1;
    UInt8  reservedRZone:1;

    UInt8  nextWritableAddressValid:1;
    UInt8  lastRecordedAddressValid:1;
    UInt8  reserved5:6;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved3:2;
    UInt8  damage:1;
    UInt8  copy:1;
    UInt8  reserved2:4;

    UInt8  reservedRZone:1;
    UInt8  blank:1;
    UInt8  incremental:1;
    UInt8  restrictedOverwrite:1;
    UInt8  reserved4:4;

    UInt8  reserved5:6;
    UInt8  lastRecordedAddressValid:1;
    UInt8  nextWritableAddressValid:1;
#endif /* !__LITTLE_ENDIAN__ */
    UInt32 rzoneStartAddress;
    UInt32 nextWritableAddress;
    UInt32 freeBlocks;
    UInt32 blockingFactor;
    UInt32 rzoneSize;
    UInt32 lastRecordedAddress;
    UInt8  rzoneNumberMSB;
    UInt8  borderNumberMSB;
    UInt8  reserved6;
    UInt8  reserved7;
};
typedef struct DVDRZoneInfo DVDRZoneInfo;

#pragma pack(pop)                        /* (reset to default struct packing) */

#endif /* _IODVDTYPES_H */
                                                                                                                                                                                                                                                                                                 IOFDiskPartitionScheme.h                                                                            0100644 0001750 0001750 00000007731 12567452412 036677  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * This header contains the IOFDiskPartitionScheme class definition.
 */

#ifndef _IOFDISKPARTITIONSCHEME_H
#define _IOFDISKPARTITIONSCHEME_H

#include <IOKit/IOTypes.h>

/*
 * kIOFDiskPartitionSchemeClass is the name of the IOFDiskPartitionScheme class.
 */

#define kIOFDiskPartitionSchemeClass "IOFDiskPartitionScheme"

/*
 * FDisk Partition Map Definitions
 */

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/* Structure constants. */

#define DISK_BLK0SZ sizeof(struct disk_blk0)    /* (size of partition map)    */
#define DISK_BOOTSZ 446                         /* (size of boot code in map) */
#define DISK_NPART  4                           /* (number of entries in map) */

/* Partition map entry. */

struct fdisk_part
{
    UInt8   bootid;    /* (is active boot partition?)                         */
    UInt8   beghead;   /* (beginning head)                                    */
    UInt8   begsect;   /* (beginning sector; beginning cylinder, high 2 bits) */
    UInt8   begcyl;    /* (beginning cylinder, low 8 bits)                    */
    UInt8   systid;    /* (type)                                              */
    UInt8   endhead;   /* (ending head)                                       */
    UInt8   endsect;   /* (ending sector; ending cylinder, high 2 bits)       */
    UInt8   endcyl;    /* (ending cylinder, low 8 bits)                       */
    UInt32  relsect;   /* (block start)                                       */
    UInt32  numsect;   /* (block count)                                       */
};

/* Partition map, as found in block zero of the disk (or extended partition). */

struct disk_blk0
{
    UInt8             bootcode[DISK_BOOTSZ];    /* (boot code)                */
    struct fdisk_part parts[DISK_NPART];        /* (partition entries)        */
    UInt16            signature;                /* (unique signature for map) */
};

/* Partition map signature (signature). */

#define DISK_SIGNATURE 0xAA55

/* Partition map entry types (systid). */

#define FDISK_PARTITION_TYPE_01 "DOS_FAT_12"
#define FDISK_PARTITION_TYPE_04 "DOS_FAT_16_S"
#define FDISK_PARTITION_TYPE_06 "DOS_FAT_16"
#define FDISK_PARTITION_TYPE_07 "Windows_NTFS"
#define FDISK_PARTITION_TYPE_0B "DOS_FAT_32"
#define FDISK_PARTITION_TYPE_0C "Windows_FAT_32"
#define FDISK_PARTITION_TYPE_0E "Windows_FAT_16"
#define FDISK_PARTITION_TYPE_42 "Windows_LDM"
#define FDISK_PARTITION_TYPE_82 "Linux_Swap"
#define FDISK_PARTITION_TYPE_83 "Linux"
#define FDISK_PARTITION_TYPE_8E "Linux_LVM"
#define FDISK_PARTITION_TYPE_A5 "FreeBSD"
#define FDISK_PARTITION_TYPE_A6 "OpenBSD"
#define FDISK_PARTITION_TYPE_A7 "Apple_Rhapsody_UFS"
#define FDISK_PARTITION_TYPE_A8 "Apple_UFS"
#define FDISK_PARTITION_TYPE_A9 "NetBSD"
#define FDISK_PARTITION_TYPE_AB "Apple_Boot"
#define FDISK_PARTITION_TYPE_AE "Apple_Encrypted"
#define FDISK_PARTITION_TYPE_AF "Apple_HFS"
#define FDISK_PARTITION_TYPE_FD "Linux_RAID"

#pragma pack(pop)                        /* (reset to default struct packing) */

#endif /* !_IOFDISKPARTITIONSCHEME_H */
                                       IOFilterScheme.h                                                                                    0100644 0001750 0001750 00000002560 12567452412 035225  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOFilterScheme
 * @abstract
 * This header contains the IOFilterScheme class definition.
 */

#ifndef _IOFILTERSCHEME_H
#define _IOFILTERSCHEME_H

/*!
 * @defined kIOFilterSchemeClass
 * @abstract
 * The name of the IOFilterScheme class.
 * @discussion
 * kIOFilterSchemeClass is the name of the IOFilterScheme class.
 */

#define kIOFilterSchemeClass "IOFilterScheme"

#endif /* !_IOFILTERSCHEME_H */
                                                                                                                                                IOFireWireStorageCharacteristics.h                                                                  0100644 0001750 0001750 00000004011 12567471025 040742  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_FIREWIRE_STORAGE_DEVICE_CHARACTERISTICS_H_
#define _IOKIT_IO_FIREWIRE_STORAGE_DEVICE_CHARACTERISTICS_H_

//
//	Bridge Characteristics - Characteristics defined for FireWire bridges.
//

/*!
@defined kIOPropertyBridgeCharacteristicsKey
@discussion This key is used to define Bridge Characteristics for a particular
devices's bridge chipset. It has an associated dictionary which lists the
bridge characteristics.

Requirement: Optional

Example:
<pre>
@textblock
<dict>
	<key>Bridge Characteristics</key>
	<dict>
		<key>Bridge Vendor Name</key>
		<string>Oxford Semiconductor</string>
		<key>Bridge Model Name</key>
		<string>FW911</string>
		<key>Bridge Revision Level</key>
		<string>3.7</string>
	</dict>
</dict>
@/textblock
</pre>
*/

#define kIOPropertyBridgeCharacteristicsKey		"Bridge Characteristics"
#define kIOPropertyBridgeVendorNameKey			"Bridge Vendor Name"
#define kIOPropertyBridgeModelNameKey			"Bridge Model Name"
#define kIOPropertyBridgeRevisionLevelKey		"Bridge Revision Level"

#endif	/* _IOKIT_IO_FIREWIRE_STORAGE_DEVICE_CHARACTERISTICS_H_ */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       IOGUIDPartitionScheme.h                                                                             0100644 0001750 0001750 00000004601 12567452412 036420  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * This header contains the IOGUIDPartitionScheme class definition.
 */

#ifndef _IOGUIDPARTITIONSCHEME_H
#define _IOGUIDPARTITIONSCHEME_H

#include <IOKit/IOTypes.h>

/*
 * kIOGUIDPartitionSchemeClass is the name of the IOGUIDPartitionScheme class.
 */

#define kIOGUIDPartitionSchemeClass "IOGUIDPartitionScheme"

/*
 * GUID Partition Map Definitions
 */

#include <uuid/uuid.h>

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/* Partition map. */

struct gpt_hdr
{
    uint8_t  hdr_sig[8];
    uint32_t hdr_revision;
    uint32_t hdr_size;
    uint32_t hdr_crc_self;
    uint32_t __reserved;
    uint64_t hdr_lba_self;
    uint64_t hdr_lba_alt;
    uint64_t hdr_lba_start;
    uint64_t hdr_lba_end;
    uuid_t   hdr_uuid;
    uint64_t hdr_lba_table;
    uint32_t hdr_entries;
    uint32_t hdr_entsz;
    uint32_t hdr_crc_table;
    uint32_t padding;
};

/* Partition map entry. */

struct gpt_ent
{
    uuid_t   ent_type;
    uuid_t   ent_uuid;
    uint64_t ent_lba_start;
    uint64_t ent_lba_end;
    uint64_t ent_attr;
    uint16_t ent_name[36];
};

/* Partition map signature (hdr_sig). */

#define GPT_HDR_SIG "EFI PART"

/* Partition map version (hdr_revision). */

#define GPT_HDR_REVISION 0x00010000

/* Partition map entry flags (ent_attr). */

#define GPT_ENT_ATTR_PLATFORM 0x00000001

#pragma pack(pop)                        /* (reset to default struct packing) */

#endif /* !_IOGUIDPARTITIONSCHEME_H */
                                                                                                                               IOMedia.h                                                                                           0100644 0001750 0001750 00000015352 12567452412 033675  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOMedia
 * @abstract
 * This header contains the IOMedia class definition.
 */

#ifndef _IOMEDIA_H
#define _IOMEDIA_H

#include <IOKit/IOTypes.h>

/*!
 * @defined kIOMediaClass
 * @abstract
 * The name of the IOMedia class.
 */

#define kIOMediaClass "IOMedia"

/*!
 * @defined kIOMediaContentKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaContentKey property has an OSString
 * value and contains a description of the media's
 * contents.  The description is the same as the hint at the time of the
 * object's creation, but it is possible that the description has been overridden
 * by a client (which has probed the media and identified the content correctly)
 * of the media object.  It is more accurate than the hint for this reason.  The
 * string is formed in the likeness of Apple's "Apple_HFS" strings or in the
 * likeness of a UUID.
 */

#define kIOMediaContentKey "Content"

/*!
 * @defined kIOMediaContentHintKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaContentHintKey property has an OSString
 * value and contains a hint of the media's contents.
 * The hint is set at the time of the object's creation, should the creator have
 * a clue as to what it may contain.  The hint string does not change for the
 * lifetime of the object and is formed in the likeness of Apple's "Apple_HFS"
 * strings or in the likeness of a UUID.
 */

#define kIOMediaContentHintKey "Content Hint"

/*!
 * @defined kIOMediaEjectableKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaEjectableKey property has an OSBoolean
 * value and describes whether the media is ejectable
 * from the drive mechanism under software control.  Implies IOMediaRemovable
 * is also true.
 */

#define kIOMediaEjectableKey "Ejectable"

/*!
 * @defined kIOMediaLeafKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaLeafKey property has an OSBoolean value and describes whether the media is a leaf, that is,
 * it is the deepest media object in this branch of the I/O Registry.
 */

#define kIOMediaLeafKey "Leaf"

/*!
 * @defined kIOMediaOpenKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaOpenKey property has an OSBoolean value and describes whether
 * a client presently has an open on this media.
 */

#define kIOMediaOpenKey "Open"

/*!
 * @defined kIOMediaPreferredBlockSizeKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaPreferredBlockSizeKey property has an
 * OSNumber value and describes the media's natural
 * block size in bytes.  This information is useful to clients that want to
 * optimize access to the media.
 */

#define kIOMediaPreferredBlockSizeKey "Preferred Block Size"

/*!
 * @defined kIOMediaRemovableKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaRemovableKey property has an OSBoolean
 * value and describes whether the media is removable
 * from the drive mechanism.
 */

#define kIOMediaRemovableKey "Removable"

/*!
 * @defined kIOMediaSizeKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaSizeKey property has an OSNumber value and describes the total length of the media in
 * bytes.
 */

#define kIOMediaSizeKey "Size"

/*!
 * @defined kIOMediaUUIDKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaUUIDKey property has an OSString value and contains a persistent
 * Universal Unique Identifier for the media if such an identifier is available.
 */

#define kIOMediaUUIDKey "UUID"

/*!
 * @defined kIOMediaWholeKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaWholeKey property has an OSBoolean
 * value and describes whether the media is whole, that is,
 * it represents the whole disk (the physical disk, or a virtual replica
 * thereof).
 */

#define kIOMediaWholeKey "Whole"

/*!
 * @defined kIOMediaWritableKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaWritableKey property has an OSBoolean
 * value and describes whether the media is writable.
 */

#define kIOMediaWritableKey "Writable"

/*!
 * @defined kIOMediaContentMaskKey
 * @abstract
 * A property of IOMedia clients.
 * @discussion
 * The kIOMediaContentMaskKey property has an OSString
 * value and must exist in all IOMedia clients that
 * drive new content (that is, produce new media objects).  When the client
 * matches against the provider media, the value of the client's
 * kIOMediaContentMaskKey property is used to replace the provider's
 * kIOMediaContentKey property.
 */

#define kIOMediaContentMaskKey "Content Mask"

/*!
 * @defined kIOMediaIconKey
 * @abstract
 * A property of any object in the media stack.
 * @discussion
 * kIOMediaIconKey is a property of any object in the media stack that wishes
 * to override the default icon shown for the media objects in the stack.  It
 * is usually defined in a provider object below the media object.  It has an
 * OSDictionary value, with properties identical to the kIOIconKey definition,
 * that is, kCFBundleIdentifierKey and kIOBundleResourceFileKey.
 */

#define kIOMediaIconKey "IOMediaIcon"

/*!
 * @enum IOMediaAttributeMask
 * @discussion
 * The IOMediaAttributeMask bit mask describes various attributes of
 * the media object, such as its ejectability and its removability.
 * @constant kIOMediaAttributeEjectableMask
 * Indicates whether the media is ejectable from the drive mechanism
 * under software control.  Implies kIOMediaAttributeRemovableMask.
 * @constant kIOMediaAttributeRemovableMask
 * Indicates whether the media is removable from the drive mechanism.
 */

enum
{
    kIOMediaAttributeEjectableMask = 0x00000001,
    kIOMediaAttributeRemovableMask = 0x00000002,
    kIOMediaAttributeReservedMask  = 0xFFFFFFFC
};

typedef UInt32 IOMediaAttributeMask;

#endif /* !_IOMEDIA_H */
                                                                                                                                                                                                                                                                                      IOMediaBSDClient.h                                                                                  0100644 0001750 0001750 00000002101 12567452412 035351  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOMEDIABSDCLIENT_H
#define _IOMEDIABSDCLIENT_H

#include <sys/disk.h>

#endif /* !_IOMEDIABSDCLIENT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                               IOPartitionScheme.h                                                                                 0100644 0001750 0001750 00000005051 12567452412 035747  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOPartitionScheme
 * @abstract
 * This header contains the IOPartitionScheme class definition.
 */

#ifndef _IOPARTITIONSCHEME_H
#define _IOPARTITIONSCHEME_H

/*!
 * @defined kIOPartitionSchemeClass
 * @abstract
 * The name of the IOPartitionScheme class.
 * @discussion
 * kIOPartitionSchemeClass is the name of the IOPartitionScheme class.
 */

#define kIOPartitionSchemeClass "IOPartitionScheme"

/*!
 * @defined kIOMediaBaseKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaBaseKey property has an OSNumber value and is placed into an
 * IOMedia instance created via the partition scheme. It describes the byte
 * offset of the partition relative to the provider media.
 */

#define kIOMediaBaseKey "Base"

/*!
 * @defined kIOMediaLiveKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaLiveKey property has an OSBoolean
 * value and is placed into an IOMedia instance
 * created via the partition scheme.  It describes whether the
 * partition is live, that is, it is up-to-date with respect
 * to the on-disk partition table.
 */

#define kIOMediaLiveKey "Live"

/*!
 * @defined kIOMediaPartitionIDKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaPartitionIDKey property has an OSNumber
 * value and is placed into an IOMedia instance
 * created via the partition scheme.  It is an ID that differentiates one 
 * partition from the other (within a given scheme).  It is typically an index
 * into the on-disk partition table.
 */

#define kIOMediaPartitionIDKey "Partition ID"

#endif /* !_IOPARTITIONSCHEME_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       IOStorage.h                                                                                         0100644 0001750 0001750 00000010147 12567452412 034257  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOStorage
 * @abstract
 * This header contains the IOStorage class definition.
 */

#ifndef _IOSTORAGE_H
#define _IOSTORAGE_H

#include <sys/kernel_types.h>
#include <IOKit/IOTypes.h>

/*!
 * @defined kIOStorageClass
 * @abstract
 * The name of the IOStorage class.
 */

#define kIOStorageClass "IOStorage"

/*!
 * @defined kIOStorageCategory
 * @abstract
 * kIOStorageCategory is a value for IOService's kIOMatchCategoryKey property.
 * @discussion
 * The kIOStorageCategory value is the standard value for the IOService property
 * kIOMatchCategoryKey ("IOMatchCategory") for all storage drivers.  All storage
 * objects that expect to drive new content (that is, produce new media objects)
 * are expected to compete within the kIOStorageCategory namespace.
 *
 * See the IOService documentation for more information on match categories.
 */

#define kIOStorageCategory "IOStorage"                /* (as IOMatchCategory) */

/*!
 * @defined kIOStorageFeaturesKey
 * @abstract
 * A property of any object in the storage stack.
 * @discussion
 * kIOStorageFeaturesKey is a property of any object in the storage stack that
 * wishes to express support of additional features, such as Force Unit Access.
 * It is typically defined in the device object below the block storage driver
 * object.  It has an OSDictionary value, where each entry describes one given
 * feature.
 */

#define kIOStorageFeaturesKey "IOStorageFeatures"

/*!
 * @defined kIOStorageFeatureBarrier
 * @abstract
 * Describes the presence of the Barrier feature.
 * @discussion
 * This property describes the ability of the storage stack to honor a write
 * barrier, guaranteeing that on power loss, writes after the barrier will not
 * be visible until all writes before the barrier are visible.  It is one of the
 * feature entries listed under the top-level kIOStorageFeaturesKey property
 * table.  It has an OSBoolean value.
 */

#define kIOStorageFeatureBarrier "Barrier"

/*!
 * @defined kIOStorageFeatureForceUnitAccess
 * @abstract
 * Describes the presence of the Force Unit Access feature.
 * @discussion
 * This property describes the ability of the storage stack to force a request
 * to access the media.  It is one of the feature entries listed under the top-
 * level kIOStorageFeaturesKey property table.  It has an OSBoolean value.
 */

#define kIOStorageFeatureForceUnitAccess "Force Unit Access"

/*!
 * @defined kIOStorageFeaturePriority
 * @abstract
 * Describes the presence of the Priority feature.
 * @discussion
 * This property describes the ability of the storage stack to enforce the
 * priority of a request.  It is one of the feature entries listed under the
 * top-level kIOStorageFeaturesKey property table.  It has an OSBoolean value.
 */

#define kIOStorageFeaturePriority "Priority"

/*!
 * @defined kIOStorageFeatureUnmap
 * @abstract
 * Describes the presence of the Unmap feature.
 * @discussion
 * This property describes the ability of the storage stack to delete unused
 * data from the media.  It is one of the feature entries listed under the top-
 * level kIOStorageFeaturesKey property table.  It has an OSBoolean value.
 */

#define kIOStorageFeatureUnmap "Unmap"

#endif /* !_IOSTORAGE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                         IOStorageCardCharacteristics.h                                                                      0100644 0001750 0001750 00000021771 12567452412 040112  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_STORAGE_CARD_CHARACTERISTICS_H_
#define _IOKIT_IO_STORAGE_CARD_CHARACTERISTICS_H_

		
/*
 *	Card Characteristics - Characteristics defined for cards.
 */

/*!
@defined kIOPropertyCardCharacteristicsKey
@discussion This key is used to define Card Characteristics for a particular
piece of MMC/SD media and it has an associated dictionary which lists the
card characteristics.
 
Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardCharacteristicsKey				"Card Characteristics"


/*!
@defined kIOPropertySlotKey
@discussion This key is used to define the slot number for the device
 
Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Slot</key>
	<integer>1<integer>
 </dict>
@/textblock
</pre>
*/
#define kIOPropertySlotKey								"Slot"


/*!
@defined kIOProperty64BitKey
@discussion This key defines wether the device supports 64-bit.
 
Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>64-bit</key>
	<true/>
</dict>
@/textblock
</pre>
*/
#define kIOProperty64BitKey								"64-bit"


/*!
@defined kIOPropertyClockDivisorKey
 @discussion This key defines the current clock divisor for the device.

Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Clock Divisor</key>
	<integer>128</integer>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyClockDivisorKey						"Clock Divisor"


/*!
@defined kIOPropertyBaseFrequencyKey
@discussion This key defines the current base frequency for the device.
 
Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Base Frequency</key>
	<integer>50</integer>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyBaseFrequencyKey						"Base Frequency"


/*!
@defined kIOPropertyBusVoltageKey
@discussion This key defines the current bus voltage for the device in mV
 
Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Bus Voltage</key>
	<integer>3300</integer>
</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyBusVoltageKey						"Bus Voltage"


/*!
@defined kIOPropertyBusWidthKey
@discussion This key defines the current bus width for the device.

Requirement: Mandatory.
 
Example:
<pre>
@textblock
<dict>
	<key>Bus Width</key>
	<integer>4</integer>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyBusWidthKey							"Bus Width"


/*!
@defined kIOPropertyCardPresentKey
@discussion This key defines wether a MMC or SD card is physically present.
 
Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Card Present</key>
	<true/>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardPresentKey						"Card Present"


/*!
 @defined kIOPropertyProductSerialNumberKey
 @discussion This key is used to indicate the card serial number ID.
 
 Requirement: Mandatory
 
 Example:
 <pre>
 @textblock
 <dict>
	 <key>Card Characteristics</key>
	 <dict>
		 <key>Product Name</key>
		 <string>SD32G</string>
		 <key>Product Revision Level</key>
		 <string>1.0</string>
		 <key>Card Type</key>
		 <string>SDHC</string>
		 <key>Serial Number</key>
		 <data>0045ff</data>
	 </dict>
 </dict>
 @/textblock
 </pre>
 */
#define kIOPropertyProductSerialNumberKey				"Serial Number"


/*!
 @defined kIOPropertyManufacturerIDKey
 @discussion This key is used to indicate the card manufacturer ID.
 
 Requirement: Optional
 
 Example:
 <pre>
 @textblock
 <dict>
	 <key>Card Characteristics</key>
	 <dict>
		 <key>Product Name</key>
		 <string>SD32G</string>
		 <key>Product Revision Level</key>
		 <string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
		<key>Manufacturer ID</key>
		<data>03</data>
	 </dict>
 </dict>
 @/textblock
 </pre>
 */
#define kIOPropertyManufacturerIDKey					"Manufacturer ID"


/*!
@defined kIOPropertyApplicationIDKey
 @discussion This key is used to indicate the card application ID.

Requirement: Optional

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
		<key>Application ID</key>
		<data>ffff</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyApplicationIDKey						"Application ID"


/*!
@defined kIOPropertyManufacturingDateKey
 @discussion This key is used to indicate the card manufacturing date.

Requirement: Mandatory.
 
Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
		<key>Manufacturing Date</key>
		<string>2009-12</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyManufacturingDateKey					"Manufacturing Date"


/*!
@defined kIOPropertySpeedClassKey
 @discussion This key is used to indicate SD card speed class.

Requirement: Mandatory.
 
Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
		<key>Speed Class</key>
		<data>02</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySpeedClassKey						"Speed Class"


/*!
@defined kIOPropertySpecificationVersionKey
@discussion This key is used to indicate the card specification version.

Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
		<key>Specification Version</key>
		<string>3.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySpecificationVersionKey				"Specification Version"


/*!
@defined kIOPropertyCardTypeKey
 @discussion This key is used to indicate the card type is MMC.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>MMC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardTypeKey							"Card Type"


/*!
@defined kIOPropertyCardTypeMMCKey
 @discussion This key is used to indicate the card type is MMC.

 Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		 <key>Product Name</key>
		 <string>SD32G</string>
		 <key>Product Revision Level</key>
		 <string>1.0</string>
		 <key>Card Type</key>
		 <string>MMC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardTypeMMCKey						"MMC"


/*!
@defined kIOPropertyCardTypeSDSCKey
 @discussion This key is used to indicate the card type is SDSC.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		 <key>Product Name</key>
		 <string>SD32G</string>
		 <key>Product Revision Level</key>
		 <string>1.0</string>
		 <key>Card Type</key>
		 <string>SDSC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardTypeSDSCKey						"SDSC"


/*!
@defined kIOPropertyCardTypeSDHCKey
 @discussion This key is used to indicate the card type is SDHC.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardTypeSDHCKey						"SDHC"


/*!
@defined kIOPropertyCardTypeSDXCKey
 @discussion This key is used to indicate the card type is SDXC.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDXC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardTypeSDXCKey						"SDXC"


#endif	/* _IOKIT_IO_STORAGE_CARD_CHARACTERISTICS_H_ */
       IOStorageControllerCharacteristics.h                                                                0100644 0001750 0001750 00000073443 12567452412 041367  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_STORAGE_CONTROLLER_CHARACTERISTICS_H_
#define _IOKIT_IO_STORAGE_CONTROLLER_CHARACTERISTICS_H_


/*
 *	Controller Characteristics - Characteristics defined for controllers.
 */


/*!
@defined kIOPropertyControllerCharacteristicsKey
@discussion This key is used to define Controller Characteristics for a particular
device and it has an associated dictionary which lists the
controller characteristics.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyControllerCharacteristicsKey		"Controller Characteristics"


/*!
@defined kIOPropertySASAddressKey
@discussion This key is the unique 64-bit SAS Address for the device server
node located at this port, or for the initiating host port.

Requirement: Mandatory for SAS.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>SAS Address</key>
		<data>0011223344556677</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySASAddressKey					"SAS Address"


/*!
@defined kIOPropertySCSIPortIdentifierKey
@discussion This key is the unique port identifier for the device server
node located at this port, or for the initiating host port.  The format for
this data is allowed to be vendor-specific, as long as it is guaranteed to
be unique.  Length is arbitrary, to allow for itnerfaces with non-standard
identifier rules.  It is recommended to have this be a copy of an existing
standard unique identifier for this port, should one  already exist for your
interface type

Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Unique SCSI Port Identifier</key>
		<data>0011223344556677</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIPortIdentifierKey		"Unique SCSI Port Identifier"


/*!
@defined kIOPropertyFibreChannelNodeWorldWideNameKey
@discussion This key is the unique 64-bit World Wide Name for the device server
node located at this port, or for the initiating host port.

Requirement: Mandatory for Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Node World Wide Name</key>
		<data>0011223344556677</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelNodeWorldWideNameKey		"Node World Wide Name"


/*!
@defined kIOPropertyFibreChannelPortWorldWideNameKey
@discussion This key is the unique 64-bit World Wide Name for the port.

Requirement: Mandatory for Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port World Wide Name</key>
		<data>0011223344556677</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelPortWorldWideNameKey		"Port World Wide Name"


/*!
@defined kIOPropertyFibreChannelAddressIdentifierKey
@discussion This key is the 24-bit Address Identifier (S_ID or D_ID) as
defined in the FC-FS specification. It contains the address identifier
of the source or destination Nx_Port.

Note: This value can change. It is not a static value.

Requirement: Optional (only necessary for Fibre Channel Interface).

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Address Identifier</key>
		<data>001122</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelAddressIdentifierKey		"Address Identifier"


/*!
@defined kIOPropertyFibreChannelALPAKey
@discussion This key is the 8-bit Arbitrated Loop Physical Address
(AL_PA) value as defined in the FC-AL-2 specification.

Note: This value can change. It is not a static value.

Requirement: Optional (only necessary for Fibre Channel Interface).

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>AL_PA</key>
		<data>04</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelALPAKey					"AL_PA"


/*!
@defined kIOPropertyPortStatusKey
@discussion This key is associated with the current port
status of the physical link. The port status is either
"Link Established", "No Link Established", or "Link Failed".

Note: This value can change when the port status changes. It
is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Status</key>
		<string>Link Established</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortStatusKey						"Port Status"


/*!
@defined kIOPropertyPortSpeedKey
@discussion This key is associated with the current port
speed. The port speed can be any valid speed for the interconnect.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (1 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedKey							"Port Speed"


/*!
@defined kIOPropertyPortTopologyKey
@discussion This key is associated with the current port
topology. The port topology can be any valid topology for the interconnect.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>Automatic (N_Port)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyKey						"Port Topology"


/*!
@defined kIOPropertyPortDescriptionKey
@discussion This key is associated with an human
readable port description. Examples include
"Channel A", "Port 1", etc.

Requirement: Optional for all interconnects.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Description</key>
		<string>Channel A</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortDescriptionKey					"Port Description"


/*!
@defined kIOPropertySCSIParallelSignalingTypeKey
@discussion This key is associated with the signaling type
used for this SCSI Parallel bus. Valid values include
"High Voltage Differential", "Low Voltage Differential",
and "Single Ended".

Requirement: Optional for SCSI Parallel Interface. Not
defined for any other physical interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>SCSI Parallel Signaling Type</key>
		<string>High Voltage Differential</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIParallelSignalingTypeKey			"SCSI Parallel Signaling Type"


/*!
@defined kIOPropertyFibreChannelCableDescriptionKey
@discussion This key is associated with the cabling type
used for this Fibre Channel port. Valid values include
"Copper" and "Fiber Optic".

Requirement: Optional for Fibre Channel Interface. Not
defined for any other physical interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Fibre Channel Cabling Type</key>
		<string>Copper</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelCableDescriptionKey		"Fibre Channel Cabling Type"


/*!
@defined kIOPropertyEncryptionTypeKey
@discussion This key is associated with the encryption type
used for this storage controller. Valid values currently include
"AES-XTS", "AES-XEX" and "AES-CBC".

Requirement: Optional for all storage controllers.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Encryption Type</key>
		<string>AES-XTS</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyEncryptionTypeKey	"Encryption Type"


/*!
@defined kIOPropertyLowPowerModeKey
@discussion This key is associated with whether the storage
device has low-power mode enabled. If enabled, it will set this 
key to true.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Low Power Mode</key>
		<true/>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyLowPowerModeKey		"Low Power Mode"


/*
 *	Values - Values for the characteristics defined above.
 */


/*!
@defined kIOPropertyPortStatusLinkEstablishedKey
@discussion This key defines the value of Link Established for the key
kIOPropertyPortStatusKey.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Status</key>
		<string>Link Established</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortStatusLinkEstablishedKey			"Link Established"


/*!
@defined kIOPropertyPortStatusNoLinkEstablishedKey
@discussion This key defines the value of No Link Established for the key
kIOPropertyPortStatusKey.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Status</key>
		<string>No Link Established</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortStatusNoLinkEstablishedKey		"No Link Established"


/*!
@defined kIOPropertyPortStatusLinkFailedKey
@discussion This key defines the value of Link Failed for the key
kIOPropertyPortStatusKey.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Status</key>
		<string>Link Failed</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortStatusLinkFailedKey				"Link Failed"


/*!
@defined kIOPropertyPortSpeedAutomaticKey
@discussion This key defines the value of Automatic for the key
kIOPropertyPortSpeedKey. If the speed of the port is automatically
adjusted by the host/device and a definitive speed is not known,
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomaticKey				"Automatic"


/*!
@defined kIOPropertyPortSpeed1GigabitKey
@discussion This key defines the value of 1 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 1 Gigabit
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>1 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed1GigabitKey					"1 Gigabit"

/*!
@defined kIOPropertyPortSpeed1_5GigabitKey
@discussion This key defines the value of 1.5 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 1.5 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>1.5 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed1_5GigabitKey				"1.5 Gigabit"


/*!
@defined kIOPropertyPortSpeed2GigabitKey
@discussion This key defines the value of 2 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 2 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>2 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed2GigabitKey					"2 Gigabit"


/*!
@defined kIOPropertyPortSpeed3GigabitKey
@discussion This key defines the value of 3 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 3 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>3 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed3GigabitKey					"3 Gigabit"


/*!
@defined kIOPropertyPortSpeed4GigabitKey
@discussion This key defines the value of 4 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 4 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>4 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed4GigabitKey					"4 Gigabit"

/*!
@defined kIOPropertyPortSpeed6GigabitKey
@discussion This key defines the value of 6 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 6 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>6 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed6GigabitKey					"6 Gigabit"


/*!
@defined kIOPropertyPortSpeed8GigabitKey
@discussion This key defines the value of 8 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 8 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>8 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed8GigabitKey					"8 Gigabit"


/*!
@defined kIOPropertyPortSpeed10GigabitKey
@discussion This key defines the value of 10 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 10 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>10 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed10GigabitKey				"10 Gigabit"


/*!
@defined kIOPropertyPortSpeed12GigabitKey
@discussion This key defines the value of 12 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 12 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>12 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed12GigabitKey				"12 Gigabit"


/*!
@defined kIOPropertyPortSpeed16GigabitKey
@discussion This key defines the value of 16 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 16 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>16 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
 */
#define kIOPropertyPortSpeed16GigabitKey				"16 Gigabit"


/*!
@defined kIOPropertyPortSpeed40GigabitKey
@discussion This key defines the value of 40 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 40 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>40 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed40GigabitKey				"40 Gigabit"


/*!
@defined kIOPropertyPortSpeedAutomatic1GigabitKey
@discussion This key defines the value of Automatic (1 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
1 Gigabit per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (1 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic1GigabitKey		"Automatic (1 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic1_5GigabitKey
@discussion This key defines the value of Automatic (1.5 Gigabit) for the key
kIOPropertyPortSpeedKey. If the speed of the port is
1.5 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (1.5 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic1_5GigabitKey		"Automatic (1.5 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic2GigabitKey
@discussion This key defines the value of Automatic (2 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
2 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (2 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic2GigabitKey		"Automatic (2 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic3GigabitKey
@discussion This key defines the value of Automatic (3 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
3 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (3 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic3GigabitKey		"Automatic (3 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic4GigabitKey
@discussion This key defines the value of Automatic (4 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
4 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (4 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic4GigabitKey		"Automatic (4 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic6GigabitKey
@discussion This key defines the value of Automatic (6 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
6 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (6 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic6GigabitKey		"Automatic (6 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic8GigabitKey
@discussion This key defines the value of Automatic (8 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
8 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (8 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic8GigabitKey		"Automatic (8 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic10GigabitKey
@discussion This key defines the value of Automatic (10 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
10 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (10 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic10GigabitKey		"Automatic (10 Gigabit)"


/*!
@defined kIOPropertyPortTopologyAutomaticKey
@discussion This key defines the value of Automatic for the key
kIOPropertyPortTopologyKey. If the topology of the port is automatically
adjusted by the host/device and a definitive topology is not known,
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>Automatic</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyAutomaticKey				"Automatic"


/*!
@defined kIOPropertyPortTopologyNPortKey
@discussion This key defines the value of N_Port for the key
kIOPropertyPortTopologyKey. If the topology of the port is an N_Port,
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>N_Port</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyNPortKey					"N_Port"


/*!
@defined kIOPropertyPortTopologyNLPortKey
@discussion This key defines the value of NL_Port for the key
kIOPropertyPortTopologyKey. If the topology of the port is an NL_Port,
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>NL_Port</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyNLPortKey				"NL_Port"


/*!
@defined kIOPropertyPortTopologyAutomaticNPortKey
@discussion This key defines the value of Automatic (N_Port) for the key
kIOPropertyPortTopologyKey. If the topology of the port is
N_Port and is automatically determined by host software, this
key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>Automatic (N_Port)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyAutomaticNPortKey		"Automatic (N_Port)"


/*!
@defined kIOPropertyPortTopologyAutomaticNLPortKey
@discussion This key defines the value of Automatic (NL_Port) for the key
kIOPropertyPortTopologyKey. If the topology of the port is
NL_Port and is automatically determined by host software, this
key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>Automatic (NL_Port)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyAutomaticNLPortKey		"Automatic (NL_Port)"


/*!
@defined kIOPropertySCSIParallelSignalingTypeHVDKey
@discussion This key defines the value of High Voltage Differential for the key
kIOPropertySCSIParallelSignalingTypeKey. If the signaling type of the port is
High Voltage Differential, this key should be used.

Requirement: Optional for SCSI Parallel Interface interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>SCSI Parallel Signaling Type</key>
		<string>High Voltage Differential</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIParallelSignalingTypeHVDKey		"High Voltage Differential"


/*!
@defined kIOPropertySCSIParallelSignalingTypeLVDKey
@discussion This key defines the value of Low Voltage Differential for the key
kIOPropertySCSIParallelSignalingTypeKey. If the signaling type of the port is
Low Voltage Differential, this key should be used.

Requirement: Optional for SCSI Parallel Interface interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>SCSI Parallel Signaling Type</key>
		<string>Low Voltage Differential</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIParallelSignalingTypeLVDKey		"Low Voltage Differential"


/*!
@defined kIOPropertySCSIParallelSignalingTypeSEKey
@discussion This key defines the value of Single Ended for the key
kIOPropertySCSIParallelSignalingTypeKey. If the signaling type of the port is
Single Ended, this key should be used.

Requirement: Optional for SCSI Parallel Interface interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>SCSI Parallel Signaling Type</key>
		<string>Single Ended</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIParallelSignalingTypeSEKey		"Single Ended"


/*!
@defined kIOPropertyFibreChannelCableDescriptionCopperKey
@discussion This key defines the value of Copper for the key
kIOPropertyFibreChannelCableDescriptionKey. If the cabling is
Copper, this key should be used.

Requirement: Optional for Fibre Channel Interface interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Fibre Channel Cabling Type</key>
		<string>Copper</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelCableDescriptionCopperKey		"Copper"


/*!
@defined kIOPropertyFibreChannelCableDescriptionFiberOpticKey
@discussion This key defines the value of Fiber Optic for the key
kIOPropertyFibreChannelCableDescriptionKey. If the cabling is
Fiber Optic, this key should be used.

Requirement: Optional for Fibre Channel Interface interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Fibre Channel Cabling Type</key>
		<string>Fiber Optic</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelCableDescriptionFiberOpticKey	"Fiber Optic"


/*!
@defined kIOPropertyAESCBCKey
@discussion This key defines the value of AES-CBC for the key
kIOPropertyEncryptionTypeKey. If the encryption used is
AES-CBC, this key should be used.

Requirement: Optional for all storage controllers.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Encryption Type</key>
		<string>AES-CBC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyAESCBCKey	"AES-CBC"


/*!
@defined kIOPropertyAESXTSKey
@discussion This key defines the value of AES-XTS for the key
kIOPropertyEncryptionTypeKey. If the encryption used is
AES-XTS, this key should be used.

Requirement: Optional for all storage controllers.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Encryption Type</key>
		<string>AES-XTS</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyAESXTSKey	"AES-XTS"


/*!
@defined kIOPropertyAESXEXKey
@discussion This key defines the value of AES-XEX for the key
kIOPropertyEncryptionTypeKey. If the encryption used is
AES-XEX, this key should be used.

Requirement: Optional for all storage controllers.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Encryption Type</key>
		<string>AES-XEX</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyAESXEXKey	"AES-XEX"


#endif	/* _IOKIT_IO_STORAGE_CONTROLLER_CHARACTERISTICS_H_ */
                                                                                                                                                                                                                             IOStorageDeviceCharacteristics.h                                                                    0100644 0001750 0001750 00000034616 12567452412 040442  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_STORAGE_DEVICE_CHARACTERISTICS_H_
#define _IOKIT_IO_STORAGE_DEVICE_CHARACTERISTICS_H_

#include <IOKit/storage/IOStorageProtocolCharacteristics.h>

/*
 *	Device Characteristics - Characteristics defined for devices.
 */

/*!
@defined kIOPropertyDeviceCharacteristicsKey
@discussion This key is used to define Device Characteristics for a particular
device and it has an associated dictionary which lists the
device characteristics. The device characteristics are Command Set specific
and are listed in the header files for each command set.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyDeviceCharacteristicsKey		"Device Characteristics"


/*!
@defined kIOPropertyVendorNameKey
@discussion This key is used to define the Vendor Name for a particular device
and it has an associated string.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyVendorNameKey				"Vendor Name"


/*!
@defined kIOPropertyProductNameKey
@discussion This key is used to define the Product Name for a particular device
and it has an associated string.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyProductNameKey				"Product Name"


/*!
@defined kIOPropertyProductRevisionLevelKey
@discussion This key is used to define the Product Revision Level for a
particular device and it has an associated string.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyProductRevisionLevelKey		"Product Revision Level"


/*!
@defined kIOPropertyProductSerialNumberKey
@discussion This key is used to define the Product Serial Number for a
particular device and it has an associated data.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Serial Number</key>
		<string>123456789</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyProductSerialNumberKey		"Serial Number"


/*!
@defined kIOPropertySupportedCDFeaturesKey
@discussion This key is used to define the supported CD Features for a
particular optical device and it has an associated bitfield. See
<IOKit/scsi/IOSCSIMultimediaCommandsDevice.h> for definitions of the
bits and associated bitmasks.

Requirement: Mandatory for optical devices (Peripheral Device Type 05h).

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>SuperDrive</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>CD Features</key>
		<integer>1663</integer>
		<key>DVD Features</key>
		<integer>103</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySupportedCDFeaturesKey		"CD Features"


/*!
@defined kIOPropertySupportedDVDFeaturesKey
@discussion This key is used to define the supported DVD Features for a
particular optical device and it has an associated bitfield. See
<IOKit/scsi/IOSCSIMultimediaCommandsDevice.h> for definitions of the
bits and associated bitmasks.

Requirement: Mandatory for optical devices (Peripheral Device Type 05h).

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>SuperDrive</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>CD Features</key>
		<integer>1663</integer>
		<key>DVD Features</key>
		<integer>103</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySupportedDVDFeaturesKey		"DVD Features"


/*!
@defined kIOPropertySupportedBDFeaturesKey
@discussion This key is used to define the supported BD Features for a
particular optical device and it has an associated bitfield. See
<IOKit/scsi/IOSCSIMultimediaCommandsDevice.h> for definitions of the
bits and associated bitmasks.

Requirement: Mandatory for optical devices (Peripheral Device Type 05h).

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>SuperDrive</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>CD Features</key>
		<integer>1663</integer>
		<key>DVD Features</key>
		<integer>103</integer>
		<key>BD Features</key>
		<integer>21</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySupportedBDFeaturesKey		"BD Features"


/*!
@defined kIOPropertyRigidDiskGeometryKey
@discussion This key is used to define a dictionary containing
rigid disk geometry information.

Requirement: Optional. If a device publishes this dictionary, it
must publish all key/value pairs which are deemed Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Rigid Disk Geometry</key>
		<dict>
			<key>Sector Count per Track</key>
			<integer>12345</integer>
			<key>Head Count</key>
			<integer>12</integer>
			<key>Cylinder Count</key>
			<integer>12345</integer>
			<key>Bytes per Physical Sector</key>
			<integer>512</integer>
		</dict>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyRigidDiskGeometryKey			"Rigid Disk Geometry"


/*!
@defined kIOPropertySectorCountPerTrackKey
@discussion This key is used to define the number of sectors per
each track for a particular medium.

Requirement: Mandatory element of the Rigid Disk Geometry dictionary.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Rigid Disk Geometry</key>
		<dict>
			<key>Sector Count per Track</key>
			<integer>12345</integer>
		</dict>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySectorCountPerTrackKey		"Sector Count per Track"


/*!
@defined kIOPropertyHeadCountKey
@discussion This key is used to define the number of heads for
a particular medium.

Requirement: Mandatory element of the Rigid Disk Geometry dictionary.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Rigid Disk Geometry</key>
		<dict>
			<key>Sector Count per Track</key>
			<integer>12345</integer>
			<key>Head Count</key>
			<integer>12</integer>
			<key>Cylinder Count</key>
			<integer>12345</integer>
			<key>Bytes per Physical Sector</key>
			<integer>512</integer>
		</dict>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyHeadCountKey					"Head Count"


/*!
@defined kIOPropertyCylinderCountKey
@discussion This key is used to define the number of heads for
a particular medium.

Requirement: Mandatory element of the Rigid Disk Geometry dictionary.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Rigid Disk Geometry</key>
		<dict>
			<key>Sector Count per Track</key>
			<integer>12345</integer>
			<key>Head Count</key>
			<integer>12</integer>
			<key>Cylinder Count</key>
			<integer>12345</integer>
			<key>Bytes per Physical Sector</key>
			<integer>512</integer>
		</dict>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCylinderCountKey				"Cylinder Count"


/*!
@defined kIOPropertyBytesPerPhysicalSectorKey
@discussion This key is used to define the number of heads for
a particular medium.

Requirement: Mandatory element of the Rigid Disk Geometry dictionary.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Rigid Disk Geometry</key>
		<dict>
			<key>Sector Count per Track</key>
			<integer>12345</integer>
			<key>Head Count</key>
			<integer>12</integer>
			<key>Cylinder Count</key>
			<integer>12345</integer>
			<key>Bytes per Physical Sector</key>
			<integer>512</integer>
		</dict>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyBytesPerPhysicalSectorKey	"Bytes per Physical Sector"


/*!
@defined kIOPropertyPhysicalBlockSizeKey
@discussion This key is used to define the physical block size of a hard disk drive.

Requirement: Mandatory for hard disk drives with physical block size other than 512 bytes.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Physical Block Size</key>
		<integer>4096</integer>
		<key>Logical Block Size</key>
		<integer>512</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalBlockSizeKey		"Physical Block Size"


/*!
@defined kIOPropertyLogicalBlockSizeKey
@discussion This key is used to define the logical block size of a hard disk drive.

Requirement: Mandatory for hard disk drives with logical block size other than 512 bytes
or that does not match its physical block size.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Physical Block Size</key>
		<integer>4096</integer>
		<key>Logical Block Size</key>
		<integer>512</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyLogicalBlockSizeKey		"Logical Block Size"


/*!
@defined kIOPropertyTargetDiskModeKey
@discussion This key is used to indicate the device is another computer in Target Disk Mode.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>AAPL</string>
		<key>Product Name</key>
		<string>FireWire Target</string>
		<key>Product Revision Level</key>
		<string>0000</string>
		<key>Target Disk Mode</key>
		<true/>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyTargetDiskModeKey		"Target Disk Mode"


/*!
@defined kIOPropertyMediumTypeKey
@discussion This key is used to indicate the medium type of the device.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>AAPL</string>
		<key>Product Name</key>
		<string>FireWire Target</string>
		<key>Product Revision Level</key>
		<string>0000</string>
		<key>Medium Type</key>
		<string>Rotational</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyMediumTypeKey		"Medium Type"


/*!
@defined kIOPropertyMediumTypeRotationalKey
@discussion This key is used to indicate the medium type of the device is rotational.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>AAPL</string>
		<key>Product Name</key>
		<string>FireWire Target</string>
		<key>Product Revision Level</key>
		<string>0000</string>
		<key>Medium Type</key>
		<string>Rotational</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyMediumTypeRotationalKey		"Rotational"


/*!
@defined kIOPropertyMediumTypeSolidStateKey
@discussion This key is used to indicate the medium type of the device is solid state.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>AAPL</string>
		<key>Product Name</key>
		<string>FireWire Target</string>
		<key>Product Revision Level</key>
		<string>0000</string>
		<key>Medium Type</key>
		<string>Solid State</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyMediumTypeSolidStateKey		"Solid State"


/*!
@defined kIOPropertyMediumRotationRateKey
@discussion This key is used to indicate the medium rotation rate in RPM of the device.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>AAPL</string>
		<key>Product Name</key>
		<string>FireWire Target</string>
		<key>Product Revision Level</key>
		<string>0000</string>
		<key>Rotation Rate</key>
		<integer>7200</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyMediumRotationRateKey		"Rotation Rate"


#endif	/* _IOKIT_IO_STORAGE_DEVICE_CHARACTERISTICS_H_ */
                                                                                                                  IOStorageProtocolCharacteristics.h                                                                  0100644 0001750 0001750 00000036220 12567452412 041035  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_STORAGE_PROTOCOL_CHARACTERISTICS_H_
#define _IOKIT_IO_STORAGE_PROTOCOL_CHARACTERISTICS_H_

#include <IOKit/storage/IOStorageControllerCharacteristics.h>

/*
 *	Protocol Characteristics - Characteristics defined for protocols.
 */

/*!
@defined kIOPropertyProtocolCharacteristicsKey
@discussion This key is used to define Protocol Characteristics for a particular
protocol and it has an associated dictionary which lists the
protocol characteristics.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>ATAPI</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define	kIOPropertyProtocolCharacteristicsKey		"Protocol Characteristics"


/*!
@defined kIOPropertySCSIInitiatorIdentifierKey
@discussion An identifier that will uniquely identify this SCSI Initiator for the
SCSI Domain.

Requirement: Mandatory for SCSI Parallel Interface, SAS,
and Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
		<key>SCSI Initiator Identifier</key>
		<integer>7</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIInitiatorIdentifierKey		"SCSI Initiator Identifier"


/*!
@defined kIOPropertySCSIDomainIdentifierKey
@discussion An identifier that will uniquely identify this SCSI Domain for the
Physical Interconnect type. This identifier is only guaranteed to be unique for
any given Physical Interconnect and is not guaranteed to be the same across
restarts or shutdowns.

Requirement: Mandatory for SCSI Parallel Interface and Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
		<key>SCSI Domain Identifier</key>
		<integer>0</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIDomainIdentifierKey			"SCSI Domain Identifier"


/*!
@defined kIOPropertySCSITargetIdentifierKey
@discussion This is the SCSI Target Identifier for a given SCSI Target Device.

Requirement: Mandatory for SCSI Parallel Interface and Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
		<key>SCSI Target Identifier</key>
		<integer>3</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSITargetIdentifierKey			"SCSI Target Identifier"


/*!
@defined kIOPropertySCSILogicalUnitNumberKey
@discussion This key is the SCSI Logical Unit Number for the device server
controlled by the driver.

Requirement: Mandatory for SCSI Parallel Interface, SAS, and Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
		<key>SCSI Logical Unit Number</key>
		<integer>2</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSILogicalUnitNumberKey			"SCSI Logical Unit Number"


/*!
@defined kIOPropertyPhysicalInterconnectTypeKey
@discussion This key is used to define the Physical Interconnect to which
a device is attached.

Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeKey		"Physical Interconnect"


/*!
@defined kIOPropertyPhysicalInterconnectLocationKey
@discussion This key is used to define the Physical Interconnect
Location.

Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectLocationKey	"Physical Interconnect Location"


/*!
@defined kIOPropertySCSIProtocolMultiInitKey
@discussion This protocol characteristics key is used to inform the system
that the protocol supports having multiple devices that act as initiators.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Fibre Channel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
		<key>Multiple Initiators</key>
		<string>True</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIProtocolMultiInitKey			"Multiple Initiators"


/*
 *	Values - Values for the characteristics defined above.
 */


/*!
@defined kIOPropertyInternalKey
@discussion This key defines the value of Internal for the key
kIOPropertyPhysicalInterconnectLocationKey. If the device is
connected to an internal bus, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>ATA</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyInternalKey						"Internal"


/*!
@defined kIOPropertyExternalKey
@discussion This key defines the value of External for the key
kIOPropertyPhysicalInterconnectLocationKey. If the device is
connected to an external bus, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Fibre Channel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyExternalKey						"External"


/*!
@defined kIOPropertyInternalExternalKey
@discussion This key defines the value of Internal/External for the key
kIOPropertyPhysicalInterconnectLocationKey. If the device is connected
to a bus and it is indeterminate whether it is internal or external,
this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal/External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyInternalExternalKey				"Internal/External"


/*!
@defined kIOPropertyInterconnectFileKey
@discussion This key defines the value of File for the key
kIOPropertyPhysicalInterconnectLocationKey. If the device is a file
that is being represented as a storage device, this key should be set.

NOTE: This key should only be used when the Physical Interconnect is set to
Virtual Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Virtual Interface</string>
		<key>Physical Interconnect Location</key>
		<string>File</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyInterconnectFileKey						"File"


/*!
@defined kIOPropertyInterconnectRAMKey
@discussion This key defines the value of RAM for the key
kIOPropertyPhysicalInterconnectLocationKey. If the device is system memory
that is being represented as a storage device, this key should be set.

NOTE: This key should only be used when the Physical Interconnect is set to
Virtual Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Virtual Interface</string>
		<key>Physical Interconnect Location</key>
		<string>RAM</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyInterconnectRAMKey						"RAM"


/*!
@defined kIOPropertyPhysicalInterconnectTypeATA
@discussion This key defines the value of ATA for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to an ATA bus, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>ATA</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeATA				"ATA"


/*!
@defined kIOPropertyPhysicalInterconnectTypeSerialATA
@discussion This key defines the value of SATA for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a SATA bus, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SATA</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeSerialATA		"SATA"


/*!
@defined kIOPropertyPhysicalInterconnectTypeSerialAttachedSCSI
@discussion This key defines the value of SAS for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a SAS bus, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SAS</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeSerialAttachedSCSI	"SAS"


/*!
@defined kIOPropertyPhysicalInterconnectTypeATAPI
@discussion This key defines the value of ATAPI for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to an ATA bus and follows the ATAPI command specification, this key
should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>ATAPI</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeATAPI			"ATAPI"


/*!
@defined kIOPropertyPhysicalInterconnectTypeUSB
@discussion This key defines the value of USB for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a USB port, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>USB</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeUSB				"USB"


/*!
@defined kIOPropertyPhysicalInterconnectTypeFireWire
@discussion This key defines the value of USB for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a FireWire port, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>FireWire</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeFireWire			"FireWire"


/*!
 @defined kIOPropertyPhysicalInterconnectTypeSecureDigital
 @discussion This key defines the value of Secure Digital for the key
 kIOPropertyPhysicalInterconnectTypeSecureDigital. If the device is
 connected to a Secure Digital port and follows the Secure Digital 
 specification, this key should be set. 
 
 Example:
 <pre>
 @textblock
 <dict>
    <key>Protocol Characteristics</key>
    <dict>
        <key>Physical Interconnect</key>
        <string>Secure Digital</string>
        <key>Physical Interconnect Location</key>
        <string>Internal</string>
    </dict>
 </dict>
 @/textblock
 </pre>
 */
#define kIOPropertyPhysicalInterconnectTypeSecureDigital	"Secure Digital"


/*!
@defined kIOPropertyPhysicalInterconnectTypeSCSIParallel
@discussion This key defines the value of SCSI Parallel Interface for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a SCSI Parallel port, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeSCSIParallel		"SCSI Parallel Interface"


/*!
@defined kIOPropertyPhysicalInterconnectTypeFibreChannel
@discussion This key defines the value of Fibre Channel Interface for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a Fibre Channel port, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Fibre Channel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeFibreChannel		"Fibre Channel Interface"


/*!
@defined kIOPropertyPhysicalInterconnectTypeVirtual
@discussion This key defines the value of Virtual Interface for the key
kIOPropertyPhysicalInterconnectTypeVirtual. If the device is being made to look
like a storage device, but is not such in actuality, such as a File or RAM, this
key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Virtual Interface</string>
		<key>Physical Interconnect Location</key>
		<string>File</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeVirtual		"Virtual Interface"


/*!
@defined kIOPropertyPhysicalInterconnectTypePCI
@discussion This key defines the value of PCI for the key
kIOPropertyPhysicalInterconnectTypePCI. If the device is connected
via PCI, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>PCI</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypePCI		"PCI"


#endif	/* _IOKIT_IO_STORAGE_PROTOCOL_CHARACTERISTICS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                ata/                                                                                                0040755 0001750 0001750 00000000000 12612224741 033010  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage                                                               ATASMARTLib.h                                                                                       0100644 0001750 0001750 00000026444 12567452710 035043  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage/ata                                                           /*
 * Copyright (c) 1998-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef __ATA_SMART_LIB_H__
#define __ATA_SMART_LIB_H__


/*! @defined kIOPropertySMARTCapableKey
	@discussion Property to search for in IORegistry to find SMART capable devices
	without hardcoding the search to a particular device class. */
#define kIOPropertySMARTCapableKey		"SMART Capable"


#include <IOKit/IOReturn.h>
#include <IOKit/IOTypes.h>


#if !KERNEL
	#include <CoreFoundation/CFPlugIn.h>
	#if COREFOUNDATION_CFPLUGINCOM_SEPARATE
		#include <CoreFoundation/CFPlugInCOM.h>
	#endif
	
	#include <IOKit/IOCFPlugIn.h>
	#include <IOKit/storage/ata/IOATAStorageDefines.h>
	
#ifdef __cplusplus
extern "C" {
#endif


/*! @header ATASMARTLib
 ATASMARTLib implements non-kernel task access to ATA SMART data.
*/


/* 5E659F92-20D3-11D6-BDB5-0003935A76B2 */
/*! @defined kIOATASMARTLibFactoryID
    @discussion UUID for the IOATASMARTInterface Factory. */

#define kIOATASMARTLibFactoryID			CFUUIDGetConstantUUIDWithBytes(NULL,				\
										0x5E, 0x65, 0x9F, 0x92, 0x20, 0xD3, 0x11, 0xD6,		\
										0xBD, 0xB5, 0x00, 0x03, 0x93, 0x5A, 0x76, 0xB2)


/* 24514B7A-2804-11D6-8A02-003065704866 */
/*! @defined kIOATASMARTUserClientTypeID
    @discussion Factory ID for creating an ATA SMART user client. */
#define kIOATASMARTUserClientTypeID		CFUUIDGetConstantUUIDWithBytes(NULL,				\
										0x24, 0x51, 0x4B, 0x7A, 0x28, 0x04, 0x11, 0xD6,		\
										0x8A, 0x02, 0x00, 0x30, 0x65, 0x70, 0x48, 0x66)

/* 08ABE21C-20D4-11D6-8DF6-0003935A76B2 */
/*! @defined kIOATASMARTInterfaceID
    @discussion InterfaceID for IOATASMARTInterface. */
#define kIOATASMARTInterfaceID			CFUUIDGetConstantUUIDWithBytes(NULL,				\
										0x08, 0xAB, 0xE2, 0x1C, 0x20, 0xD4, 0x11, 0xD6,		\
										0x8D, 0xF6, 0x00, 0x03, 0x93, 0x5A, 0x76, 0xB2)


#endif	/* !KERNEL */


// Off-line data collection status byte values ( offset 362 into 
// device SMART data structure ) See section 8.54.5.8.1 of ATA/ATAPI-6.
enum
{
	kATASMARTOffLineCollectionNeverStarted		= 0x00,
	kATASMARTOffLineCollectionNoError			= 0x02,
	kATASMARTOffLineCollectionSuspendedByHost	= 0x04,
	kATASMARTOffLineCollectionAbortedByHost		= 0x05,
	kATASMARTOffLineCollectionFatalError		= 0x06,
	
	kATASMARTOffLineCollectionMask				= 0x7F
};

// Self-test execution status values ( offset 363 into 
// Device SMART data structure ) See section 8.54.5.8.2 of ATA/ATAPI-6.
enum
{
	kATASMARTSelfTestStatusNoError 							= 0x00,
	kATASMARTSelfTestStatusAbortedByHost 					= 0x01,
	kATASMARTSelfTestStatusInterruptedByReset				= 0x02,
	kATASMARTSelfTestStatusFatalError 						= 0x03,
	kATASMARTSelfTestStatusPreviousTestUnknownFailure 		= 0x04,
	kATASMARTSelfTestStatusPreviousTestElectricalFailure	= 0x05,
	kATASMARTSelfTestStatusPreviousTestServoFailure			= 0x06,
	kATASMARTSelfTestStatusPreviousTestReadFailure			= 0x07,
	kATASMARTSelfTestStatusInProgress						= 0x0F
};


/*
 *	512 byte Device SMART data structure - 
 *	See section 8.54.5.8 of T13:1410D (ATA/ATAPI-6).
 */
typedef struct ATASMARTData
{
	UInt8		vendorSpecific1[362];
	UInt8		offLineDataCollectionStatus;
	UInt8		selfTestExecutionStatus;
	UInt8		secondsToCompleteOffLineActivity[2];
	UInt8		vendorSpecific2;
	UInt8		offLineDataCollectionCapability;
	UInt8		SMARTCapability[2];
	UInt8		errorLoggingCapability;
	UInt8		vendorSpecific3;
	UInt8		shortTestPollingInterval;		/* expressed in minutes */
	UInt8		extendedTestPollingInterval; 	/* expressed in minutes */
	UInt8		reserved[12];
	UInt8		vendorSpecific4[125];
	UInt8		checksum;
} ATASMARTData;


/*
 *	512 byte Device SMART data thresholds structure. Not
 *	strictly part of ATA/ATAPI-6.
 */
typedef struct ATASMARTDataThresholds
{
	UInt8		vendorSpecific1[362];
	UInt8		vendorSpecific2[149];
	UInt8		checksum;
} ATASMARTDataThresholds;


typedef struct ATASMARTLogEntry
{
	UInt8	numberOfSectors;
	UInt8	reserved;
} ATASMARTLogEntry;


typedef struct ATASMARTLogDirectory
{
	UInt8				SMARTLoggingVersion[2];
	ATASMARTLogEntry	entries[255];
} ATASMARTLogDirectory;


#if !KERNEL

/*! 
 *	@interface IOATASMARTInterface
 *	@abstract Self-Monitoring, Analysis, and Reporting
 *	Technology Interface.  
 *	@discussion See section 6.14 and section 8.54 of T13:1410D ATA/ATAPI-6
 *	for details on Self-Monitoring, Analysis, and Reporting Technology
 *	feature set.
 */

typedef struct IOATASMARTInterface
{
	
	IUNKNOWN_C_GUTS;
	
	UInt16		version;
	UInt16		revision;
	
	/* 
	 * MANDATORY API support. If the device claims SMART feature set compliance, it
	 * must implement the following functions.
	 */
	
	
    /*!
		@function SMARTEnableDisableOperations
		@abstract toggle SMART Operations.
		@discussion See section 8.54.1 and 8.54.3 of ATA/ATAPI-6.
		@param enable Passing true will ENABLE SMART operations,
		false will DISABLE SMART operations.
		@result Returns kIOReturnSuccess if successful, kIOReturnNoDevice
		if there is no connection to an IOService, kIOReturnExclusiveAccess
		if it is already opened by another client.
	*/
	
	IOReturn ( *SMARTEnableDisableOperations ) ( void *		interface,
												 Boolean	enable );
	
    /*!
		@function SMARTEnableDisableAutosave
		@abstract toggle SMART Autosave.
		@discussion	See section 8.54.2 of ATA/ATAPI-6.
		@param enable Passing true will ENABLE SMART Autosave, false will
		DISABLE SMART Autosave.
		@result Returns kIOReturnSuccess if successful, kIOReturnNoDevice
		if there is no connection to an IOService, kIOReturnExclusiveAccess
		if it is already opened by another client.
	*/
	
	IOReturn ( *SMARTEnableDisableAutosave ) ( void *	interface,
											   Boolean	enable );
	
    /*!
		@function SMARTReturnStatus
		@abstract see if device has detected a threshold exceeded condition.
		@discussion	The caller will poll this function and if
		exceededCondition is non-zero and we returned kIOReturnSuccess the
		device threshold exceeded condition. This would prompt the caller
		to call ATASMARTReadData to get more information. See section
		8.54.7 of ATA/ATAPI-6.
		@param exceededCondition
		if exceededCondition is non-zero the device threshold
		exceeded condition.
		@result Returns kIOReturnSuccess if successful, kIOReturnNoDevice
		if there is no connection to an IOService, kIOReturnExclusiveAccess
		if it is already opened by another client.	
	*/
	
	IOReturn ( *SMARTReturnStatus ) ( void *		interface,
									  Boolean * 	exceededCondition );
	

	/* 
	 * OPTIONAL API support. If the device claims SMART feature set compliance, it
	 * may implement one or more of the following functions. Please consult the
	 * technical manual for the device to see what functions are supported.
	 */


    /*!
		@function SMARTExecuteOffLineImmediate
		@abstract immediately initiate collection of SMART data.
		@discussion	See section 8.54.4 of ATA/ATAPI-6.
		@param extendedTest passing true will collect "off-line" extended test,
		false short test.
		@result Returns kIOReturnSuccess if successful,
		kIOReturnNoDevice if there is no connection to an IOService,
		kIOReturnExclusiveAccess if it is already opened by another client.	
	*/
	
	IOReturn ( *SMARTExecuteOffLineImmediate ) ( void *		interface,
												 Boolean	extendedTest );
	
    /*!
		@function SMARTReadData
		@abstract Retrieves 512 byte device SMART data structure.
		@discussion	See section 8.54.5 of ATA/ATAPI-6.
		Will return an appropiate error if command can not be completed.
	*/
	
	IOReturn ( *SMARTReadData ) ( void * interface, ATASMARTData * data );	
	
    /*!
		@function SMARTValidateReadData
		@abstract Test the integrity of the device SMART data structure.
		@discussion	The data structure checksum is the two's complement
		of the sum of the first 511 bytes in the data structure. The sum
		of all 512 bytes will be zero when the checksum is correct. See
		section 8.54.5.8.7 of ATA/ATAPI-6. Will return an error if
		checksum fails.
	*/
	
	IOReturn ( *SMARTValidateReadData ) ( void *				interface,
										  const ATASMARTData *	data );
	
	
    /*!
		@function SMARTReadDataThresholds
		@abstract Retrieves 512 byte device SMART data thresholds structure.
		@discussion	Retrieves 512 byte device SMART data thresholds structure.
		This command is not defined as part of ATA/ATAPI-6, but is implemented
		by a large variety of manufacturers. Will return an appropiate error if
		command can not be completed.
	*/
	
	IOReturn ( *SMARTReadDataThresholds ) ( void *						interface,
											ATASMARTDataThresholds *	dataThresholds );
	
    /*!
		@function SMARTReadLogDirectory
		@abstract Reads the 512-byte log directory.
		@discussion	The log directory is a directory of all possible
		SMART logs available from the drive.
	*/
	
	IOReturn ( *SMARTReadLogDirectory ) ( void *				 interface,
										  ATASMARTLogDirectory * logData );
	
    /*!
		@function SMARTReadLogAtAddress
		@abstract Reads the 512-byte log at the specified logOffset in the log.
		@discussion	Reads the 512-byte log at the specified logOffset in the log.
		See section 8.54.6.4 of ATA/ATAPI-6.
	*/
	
	IOReturn ( *SMARTReadLogAtAddress ) ( void *		interface,
										  UInt32		logOffset,
										  void *		buffer,
										  UInt32		size );
	
    /*!
		@function SMARTWriteLogAtAddress
		@abstract Writes to the 512-byte log at the specified logOffset in the log.
		@discussion	Writes to the 512-byte log at the specified logOffset in the log.
		See section 8.54.8.4 of ATA/ATAPI-6.
	*/
	
	IOReturn ( *SMARTWriteLogAtAddress ) ( void *			interface,
										   UInt32			logOffset,
										   const void *		buffer,
										   UInt32			size );
	
	/*!
		@function GetATAIdentifyData
		@abstract Reads the 512-byte data provided by the drive in response
		to the ATA IDENTIFY DEVICE command.
		@discussion Reads the 512-byte data provided by the drive in response
		to the ATA IDENTIFY DEVICE command.
		See section 8.15 of ATA/ATAPI-6.
		The data placed in buffer is guaranteed to be in native endian form on return.
		(i.e. it will be byte swapped on big endian platforms, so the caller need not
		do anything)
		@param interface A valid IOATASMARTInterface**.
		@param buffer A valid buffer.
		@param inSize The number of bytes to place in the buffer.
		@param outSize The number of bytes placed in the buffer. Can be NULL if the information
		is not required by the caller.
		@return An IOReturn result code. If inSize is greater than 512 or less than 1,
				kIOReturnBadArgument is returned.
	*/
	
	IOReturn ( *GetATAIdentifyData ) ( void *				interface,
									   void *				buffer,
									   UInt32				inSize,
									   UInt32 *				outSize );
	
} IOATASMARTInterface;


#ifdef __cplusplus
}
#endif

#endif	/* !KERNEL */

#endif	/* __ATA_SMART_LIB_H__ */                                                                                                                                                                                                                            IOATAStorageDefines.h                                                                               0100644 0001750 0001750 00000022315 12567452710 036651  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/storage/ata                                                           /*
 * Copyright (c) 1998-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_ATA_STORAGE_DEFINES_H_
#define _IOKIT_IO_ATA_STORAGE_DEFINES_H_

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif
	
/*
 * Important word offsets in device identify data as
 * defined in ATA-5 standard
 */
	
enum
{
	kATAIdentifyConfiguration				= 0,
	kATAIdentifyLogicalCylinderCount 		= 1,
	kATAIdentifyLogicalHeadCount			= 3,
	kATAIdentifySectorsPerTrack				= 6,
	kATAIdentifySerialNumber				= 10,
	kATAIdentifyFirmwareRevision			= 23,
	kATAIdentifyModelNumber					= 27,
	kATAIdentifyMultipleSectorCount			= 47,
	kATAIdentifyDriveCapabilities			= 49,
	kATAIdentifyDriveCapabilitiesExtended	= 50,
	kATAIdentifyPIOTiming					= 51,
	kATAIdentifyExtendedInfoSupport			= 53,
	kATAIdentifyCurrentCylinders			= 54,
	kATAIdentifyCurrentHeads				= 55,
	kATAIdentifyCurrentSectors				= 56,
	kATAIdentifyCurrentCapacity				= 57,
	kATAIdentifyCurrentMultipleSectors		= 59,
	kATAIdentifyLBACapacity					= 60,
	kATAIdentifySingleWordDMA				= 62,
	kATAIdentifyMultiWordDMA				= 63,
	kATAIdentifyAdvancedPIOModes			= 64,
	kATAIdentifyMinMultiWordDMATime			= 65,
	kATAIdentifyRecommendedMultiWordDMATime	= 66,
	kATAIdentifyMinPIOTime					= 67,
	kATAIdentifyMinPIOTimeWithIORDY			= 68,
	kATAIdentifyQueueDepth					= 75,
	kATAIdentifyMajorVersion				= 80,
	kATAIdentifyMinorVersion				= 81,
	kATAIdentifyCommandSetSupported			= 82,
	kATAIdentifyCommandSetSupported2		= 83,
	kATAIdentifyCommandExtension1			= 84,
	kATAIdentifyCommandExtension2			= 85,
	kATAIdentifyCommandsEnabled				= 86,
	kATAIdentifyCommandsDefault				= 87,
	kATAIdentifyUltraDMASupported			= 88,
	kATAIdentifyPhysicalLogicalSectorSize	= 106,
	kATAIdentifyWordsPerLogicalSector1		= 117,
	kATAIdentifyWordsPerLogicalSector2		= 118,
	kATAIdentifyLogicalSectorAlignment		= 209,
	kATAIdentifyIntegrity					= 255
};
	

/* 
 * Important bits in device identify data
 * as defined in ATA-5 standard
 */
 
enum
{
	// Configuration field (word 0)
	kFixedDeviceBit			= 6,							// Fixed disk indicator bit
	kRemoveableMediaBit		= 7,							// Removable media indicator bit
	kNonMagneticDriveBit	= 15,							// Non-magnetic drive indicator bit
	
	kFixedDeviceMask		= (1 << kFixedDeviceBit),		// Mask for fixed disk indicator
	kRemoveableMediaMask	= (1 << kRemoveableMediaBit),	// Mask for removable media indicator
	kNonMagneticDriveMask	= (1 << kNonMagneticDriveBit),	// Mask for non-magnetic drive indicator

	// Capabilities field (word 49)
	kDMABit					= 8,							// DMA supported bit
	kLBABit					= 9,							// LBA supported bit
	kIORDYDisableBit		= 10,							// IORDY can be disabled bit
	kIORDYBit				= 11,							// IORDY supported bit
	kStandbyTimerBit		= 13,							// Standby timer supported bit

	kDMASupportedMask		= (1 << kDMABit),				// Mask for DMA supported
	kLBASupportedMask		= (1 << kLBABit),				// Mask for LBA supported
	kDMADisableMask			= (1 << kIORDYDisableBit),		// Mask for DMA supported
	kIORDYSupportedMask		= (1 << kIORDYBit),				// Mask for IORDY supported
	kStandbySupportedMask	= (1 << kStandbyTimerBit),		// Mask for Standby Timer supported

	// Extensions field (word 53)
	kCurFieldsValidBit		= 0,							// Bit to show words 54-58 are valid
	kExtFieldsValidBit		= 1,							// Bit to show words 64-70 are valid
	kCurFieldsValidMask		= (1 << kCurFieldsValidBit),	// Mask for current fields valid
	kExtFieldsValidMask		= (1 << kExtFieldsValidBit),	// Extension word valid

	// Advanced PIO Transfer Modes field (word 64)
	kMode3Bit				= 0,							// Bit to indicate mode 3 is supported
	kMode3Mask				= (1 << kMode3Bit),				// Mask for mode 3 support
	
	// Integrity of Identify data (word 255)
	kChecksumValidCookie	= 0xA5							// Bits 7:0 if device supports feature
	
};


/* String size constants */
enum
{
	kSizeOfATAModelString 		= 40,
	kSizeOfATARevisionString	= 8
};

/* ATA Command timeout constants ( in milliseconds ) */
enum
{
	kATATimeout10Seconds	= 10000,
	kATATimeout30Seconds	= 30000,
	kATATimeout45Seconds	= 45000,
	kATATimeout1Minute		= 60000,
	kATADefaultTimeout		= kATATimeout30Seconds
};


/* Retry constants */
enum
{
	kATAZeroRetries		= 0,
	kATADefaultRetries	= 4
};

/* max number of blocks supported in ATA transaction */
enum
{
	kIOATASectorCount8Bit	= 8,
	kIOATASectorCount16Bit	= 16
};

enum
{
	kIOATAMaximumBlockCount8Bit		= (1 << kIOATASectorCount8Bit),
	kIOATAMaximumBlockCount16Bit	= (1 << kIOATASectorCount16Bit),
	
	// For backwards compatibility
	kIOATAMaxBlocksPerXfer			= kIOATAMaximumBlockCount8Bit
};



/* Power Management time constants (in seconds) */
enum
{
	kSecondsInAMinute	= 60,
	k5Minutes			= 5 * kSecondsInAMinute
};

/* Bits for features published in Word 82 of device identify data */
enum
{
	kATASupportsSMARTBit					= 0,
	kATASupportsPowerManagementBit  		= 3,
	kATASupportsWriteCacheBit				= 5
};

/* Masks for features published in Word 82 of device identify data */
enum
{
	kATASupportsSMARTMask					= (1 << kATASupportsSMARTBit),
	kATASupportsPowerManagementMask 		= (1 << kATASupportsPowerManagementBit),
	kATASupportsWriteCacheMask				= (1 << kATASupportsWriteCacheBit)
};

/* Bits for features published in Word 83 of device identify data */
enum
{
	kATASupportsCompactFlashBit				= 2,
	kATASupportsAdvancedPowerManagementBit 	= 3,
	
	kATASupports48BitAddressingBit			= 10,
	
	kATASupportsFlushCacheBit				= 12,
	kATASupportsFlushCacheExtendedBit		= 13
};

/* Masks for features published in Word 83 of device identify data */
enum
{
	kATASupportsCompactFlashMask			= (1 << kATASupportsCompactFlashBit),
	kATASupportsAdvancedPowerManagementMask = (1 << kATASupportsAdvancedPowerManagementBit),
	
	kATASupports48BitAddressingMask			= (1 << kATASupports48BitAddressingBit),
	
	kATASupportsFlushCacheMask				= (1 << kATASupportsFlushCacheBit),
	kATASupportsFlushCacheExtendedMask		= (1 << kATASupportsFlushCacheExtendedBit),
	
	// Mask to ensure data is valid
	kIdentifyWordValidationMask				= 0xC000,
	kIdentifyWordValid						= 0x4000
};

/* Bits for features published in Word 84 of device identify data */
enum
{
	kATAForceUnitAccessFeatureBit			= 6,
};

/* Masks for features published in Word 84 of device identify data */
enum
{
	kATAForceUnitAccessFeatureMask			= (1 << kATAForceUnitAccessFeatureBit),
};

/* Bits for features published in Word 85 of device identify data */
enum
{
	kATAWriteCacheEnabledBit				= 5
};

/* Masks for features published in Word 85 of device identify data */
enum
{
	kATAWriteCacheEnabledMask				= (1 << kATAWriteCacheEnabledBit)
};


/* Bits for features published in Word 106 of device identify data */
enum
{
	kATAPhysicalLogicalEnabledBit0			= 15,
	kATAPhysicalLogicalEnabledBit1			= 14,
	kATAMultipleLogicalSectorsBit			= 13,
	kATAValidLogicalSectorSizeBit			= 12	
};

/* Masks for features published in Word 106 of device identify data */
enum
{
	kATAPhysicalLogicalEnabledMask			= (1 << kATAPhysicalLogicalEnabledBit0) | (1 << kATAPhysicalLogicalEnabledBit1),
	kATAPhysicalLogicalEnabledValue			= (0 << kATAPhysicalLogicalEnabledBit0) | (1 << kATAPhysicalLogicalEnabledBit1),
	kATAMultipleLogicalSectorsMask			= (1 << kATAMultipleLogicalSectorsBit),
	kATAValidLogicalSectorSizeMask			= (1 << kATAValidLogicalSectorSizeBit),
	kATAPhysicalSectorSizeMask				= 0xF,
	kATALogicalSectorAlignmentMask			= 0x3FFF
};

// Property table keys
#define kIOATASupportedFeaturesKey		"ATA Features"

/* ATA supported features */
enum
{
	kIOATAFeaturePowerManagement			= 0x01,		/* OBSOLETE */
	kIOATAFeatureWriteCache					= 0x02,		/* OBSOLETE */
	kIOATAFeatureAdvancedPowerManagement 	= 0x04,
	kIOATAFeatureCompactFlash				= 0x08,
	kIOATAFeature48BitLBA					= 0x10,
	kIOATAFeatureSMART						= 0x20
};

/* ATA Advanced Power Management settings (valid settings range from 1-254),
the settings below are the more common settings */
enum
{
	kIOATAMaxPerformance					= 0xFE,
	kIOATADefaultPerformance			 	= 0x80,
	kIOATAMaxPowerSavings					= 0x01
};

/* ATA Transfer Mode bit masks */
enum
{
	kATAEnableUltraDMAModeMask 		= 0x40,
	kATAEnableMultiWordDMAModeMask	= 0x20,
	kATAEnablePIOModeMask			= 0x08
};


typedef uint32_t	ATAOperationType;
enum
{
	kATAOperationTypeRead				= 0,
	kATAOperationTypeWrite				= 1,
	kATAOperationTypeFlushCache			= 2,
	kATAOperationTypeSMART				= 3,
	kATAOperationTypeConfiguration		= 4,
	kATAOperationTypePowerManagement	= 5,
	kATAOperationTypeSMS				= 6
};

#if defined(KERNEL)

typedef struct __ATAIORequest *	ATARequestIdentifier;

#endif	// defined(KERNEL)
	
#ifdef __cplusplus
}
#endif

#endif	/* _IOKIT_IO_ATA_STORAGE_DEFINES_H_ */
                                                                                                                                                                                                                                                                                                                   stream/                                                                                             0040755 0001750 0001750 00000000000 12612224741 032072  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOStreamLib.h                                                                                       0100644 0001750 0001750 00000031514 12567451750 034371  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/stream                                                                /*
 *  Copyright 2006 Apple Computer, Inc. All rights reserved.
 *
 */

#if !defined(__IOKIT_IOSTREAMLIB_H)
#define __IOKIT_IOSTREAMLIB_H

/*!
    @header IOStreamLib.h
    @abstract IOCFPlugin library for using IOStream objects.
    @discussion
    The IOStream plugin provides a convenient set of functions for accessing and manipulating
    IOStream objects from user programs.
 */

#include <sys/cdefs.h>

#include <IOKit/IOKitLib.h>
#include <IOKit/IOCFPlugIn.h>
#include <CoreFoundation/CoreFoundation.h>

#include <IOKit/stream/IOStreamShared.h>

__BEGIN_DECLS    
    
#pragma mark IOStream UUIDs

//   uuid: 57C89438-A0A2-4AFC-9FF2-DE64C02F815C

#define kIOStreamLibTypeID \
    CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault, \
                                    0x57, 0xC8, 0x94, 0x38, 0xA0, 0xA2, 0x4A, 0xFC, \
                                    0x9F, 0xF2, 0xDE, 0x64, 0xC0, 0x2F, 0x81, 0x5C \
                                    )
    
// kIOStreamInterfaceID_v1
//   uuid: E2DFDF5F-3FAD-4487-9EEA-3FCF147EBB3D 
#define kIOStreamInterfaceID_v1	\
    CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault, \
                                    0xE2, 0xDF, 0xDF, 0x5F, 0x3F, 0xAD, 0x44, 0x87, \
                                    0x9E, 0xEA, 0x3F, 0xCF, 0x14, 0x7E, 0xBB, 0x3D \
                                    )

#define kIOStreamInterfaceID kIOStreamInterfaceID_v1

/*!
@typedef IOStreamRef
 */
typedef struct IOStreamInterface_v1_t ** IOStreamRef;


/*!
    @typedef IOStreamCallback
 */
typedef void (*IOStreamOutputCallback) (
                                  IOStreamRef stream,
                                  void *context
                                  );

typedef struct IOStreamInterface_v1_t
{
    IUNKNOWN_C_GUTS;
    UInt32 Version;
    UInt32 Revision;

    /*!
        @functiongroup Opening and closing streams
     */
    
    /*!
    @function Open
     @abstract Open an IOStream from user space.
     @discussion The Open function opens the stream and maps the memory
     for the shared
     input and output queues into the current task, as well as the memory
     for all the buffers in the queue.  It also creates the notification
     ports for input and output.
     @param stream The reference to the stream returned by QueryInterface.
     @param options Open options.  Currently unused.
     @result If the stream could not be opened or the buffers could not
     be mapped, an error will be returned.
     */
    
    IOReturn (*Open)( IOStreamRef stream, IOOptionBits options );

    /*!
    @function Close
     @abstract Closes an IOStream.
     @discussion Calling Close umaps all shared memory for the stream
     and frees all user resources used by the stream.
     @param stream The IOStreamRef of the stream to close.
     @result Returns kIOReturnSuccess if the stream was successfully
     closed and the buffers unmapped.
     */
    IOReturn (*Close)( IOStreamRef stream );
    
    /*!
        @functiongroup Buffer information
     */
    
    /*!
        @function GetBufferCount
     @abstract Gets the number of buffers in the stream.
     @param stream The IOStreamRef of the stream to operate on.
     @result Returns then number of buffers in the stream.
     */
    
    IOItemCount (*GetBufferCount)( IOStreamRef stream );
    
    /*!
        @function GetBufferInfo
     @abstract Gets information about a buffer in an IOStream.
     @param stream The IOStreamRef of the stream to operate on.
     @param bufferID
     @param dataBufferAddressOut
     @param dataBufferSizeOut
     @param controlBufferAddressOut
     @param controlBufferSizeOut
     @result Returns kIOReturnSuccess if the buffer ID was valid.
     */
    
    IOReturn (*GetBufferInfo)( IOStreamRef stream,
                               IOStreamBufferID bufferID,
                               void **dataBufferAddressOut,  IOByteCount *dataBufferSizeOut,
                               void **controlBufferAddressOut, IOByteCount *controlBufferSizeOut );
    
    
    /*!
        @functiongroup Input and output
     */
    
    /*!
        @function GetOutputPort
     @abstract Get the notification port for buffers moving out from kernel
     to user space.
     @param stream The IOStreamRef of the stream to operate on.
     @result A CFMachPortRef of the output notification port.
     */
    CFMachPortRef (*GetOutputPort)( IOStreamRef stream );
    
    /*!
    @function GetInputPort
     @abstract Get the notification port for buffers moving in from user
     to kernel space.
     @param stream The IOStreamRef of the stream to operate on.
     @result A CFMachPortRef for the input notification port.
     */
    CFMachPortRef (*GetInputPort)( IOStreamRef stream );
    
    /*!
        @function GetOutputQueue
     @abstract Get the shared memory queue for buffers moving out from kernel
     to user space.
     @param stream The IOStreamRef of the stream to operate on.
     @result A pointer to the shared memory IOStreamBufferQueue structure for the output queue.
     @discussion   If you use the notification functions, you should never need
     to access the queues directly.
     */
    IOStreamBufferQueue *(*GetOutputQueue)( IOStreamRef stream );
    
    /*!
        @function GetInputQueue
     @abstract Get the shared memory queue for buffers moving in from user
     to kernel space.
     @param stream The IOStreamRef of the stream to operate on.
     @result A pointer to the shared memory IOStreamBufferQueue structure for the input queue.
     @discussion   If you use the notification functions, you should never need
     to access the queues directly.
     */
    IOStreamBufferQueue *(*GetInputQueue)( IOStreamRef stream );
    
    /*!
        @function SetOutputCallback
     @abstract Set the callback function to be called when a new buffer
     is available from the kernel.
     @param stream The IOStreamRef of the stream to operate on.
     Pass NULL to remove the callback.
     @result Returns kIOReturnSuccess if the callback was successfully
     set or removed.
     
     */
    IOReturn
        (*SetOutputCallback)( IOStreamRef stream,
                             IOStreamOutputCallback callback,
                             void *context );
    
    /*!
        @functiongroup Run loop operations
     */
    
    /*!
        @function GetRunLoopSource
     @abstract Gets a CFRunLoopSource for the CFMachPort used for notifications
     from the kernel that data is ready.
     @param stream The IOStreamRef of the stream to operate on.
     @result The CFRunLoopSourceRef for the run loop source, or NULL if
     there was an error creating the source.
     */
    
    CFRunLoopSourceRef
        (*GetRunLoopSource)( IOStreamRef stream );
    
    /*!
        @function AddToRunLoop
     @abstract Add the CFRunLoopSource for the notification port to a run loop.
     @param stream The IOStreamRef of the stream to operate on.
     @param runLoop The run loop to which to add the notification source.
     @result Returns kIOReturnSuccess if the source was successfully added
     to the run loop.
     */
    
    IOReturn
        (*AddToRunLoop)( IOStreamRef stream,
                              CFRunLoopRef runLoop );
    
    /*!
        @function RemoveFromRunLoop
     @abstract Remove the CFRunLoopSource for the notification port from a run loop.
     @param stream The IOStreamRef of the stream to operate on.
     @param runLoop The run loop from which to remove the notification source.
     @result Returns kIOReturnSuccess if the source was successfully removed
     from the run loop.
     
     */
    IOReturn
        (*RemoveFromRunLoop)( IOStreamRef stream,
                                   CFRunLoopRef runLoop );
    
    /*!
        @functiongroup Buffer operations on streams
     */
    
    /*!
        @function DequeueOutputEntry
     @abstract Get the next IOStreamBufferQueueEntry available from the output queue.
     @param stream The IOStreamRef of the stream to operate on.
     @param entry A pointer to an IOStreamBufferQueueEntry structure.  The next available
     entry from the output queue will be copied into it.
     @result The IOStreamBufferID of the next available buffer, or
     kInvalidIOStreamBufferID if no buffer is in the queue.
     
     */
    IOReturn (*DequeueOutputEntry)( IOStreamRef stream, IOStreamBufferQueueEntry *entry );
    
    /*!
        @function EnqueueInputEntry
     */

    IOReturn (*EnqueueInputEntry)( IOStreamRef stream, IOStreamBufferQueueEntry *entry);
    
    /*!
        @function EnqueueInputBuffer
     @abstract Send a buffer to the kernel side of the IOStream on the input queue.
     @param stream The IOStreamRef of the stream to operate on.
     @param bufferID The IOStreamBufferID of the buffer to place on the queue.
     @param dataLength The length of the valid data in the buffer.
     @result Returns kIOReturnSuccess if the buffer was successfully placed
     on the input queue.
     
     */
    
    IOReturn (*EnqueueInputBuffer)( IOStreamRef stream, IOStreamBufferID bufferID,
                                    IOByteCount dataOffset, IOByteCount dataLength,
                                    IOByteCount controlOffset, IOByteCount controlLength );
    
    /*!
        @functiongroup Notifications
     */
    
    /*!
        @function SendInputNotification
     @abstract Send a notification to the kernel side of the IOStream
     that data is available in the input queue.
     @param stream The IOStreamRef of the stream to operate on.
     @param token A value to pass to the stream's notification function.
     This is unused by IOStream but may be used by subclasses.
     @result Returns kIOReturnSuccess if the notification was successfully sent.
     */
    
    IOReturn (*SendInputNotification)( IOStreamRef stream, UInt32 token );
    
    /*!
        @function SendInputSyncNotification
     @abstract Notify the kernel side of the stream that input is ready
     by using a fast trap to call directly into the stream user client driver.
     This will transfer control to the kernel and continue executing
     on your same thread, rather than sending the notification to a separate thread.
     @param stream The IOStreamRef of the stream to operate on.
     @param token A value to pass to the stream's notification function.
     This is unused by IOStream but may be used by subclasses.
     @result Returns kIOReturnSuccess if the notification was successfully sent.

     */
    IOReturn (*SendInputSyncNotification)( IOStreamRef stream, UInt32 token );
    
    /*!
        @functiongroup Buffer convenience functions
     */
        
    /*!
        @function GetDataBuffer
     @abstract Get a pointer to the data area of an IOStreamBuffer.
     @param stream The IOStreamRef of the stream owning the buffer.
     @param bufferID The IOStreamBufferID of the buffer to operate on.
     @result A pointer to the data buffer area of the IOStreamBuffer,
     or NULL if it does not have a data buffer.
     
     */
    void *(*GetDataBuffer)( IOStreamRef stream, IOStreamBufferID bufferID );
    
    /*!
        @function GetDataBufferLength
     @abstract Get the length of the data area of an IOStreamBuffer.
     @param stream The IOStreamRef of the stream owning the buffer.
     @param bufferID The IOStreamBufferID of the buffer to operate on.
     @result The length in bytes of the data buffer, or 0 if there is no
     data buffer.

     */
    IOByteCount (*GetDataBufferLength)( IOStreamRef stream, IOStreamBufferID bufferID );
    
    /*!
        @function GetControlBuffer
     @abstract Get a pointer to the control area of an IOStreamBuffer.
     @param stream The IOStreamRef of the stream owning the buffer.
     @param bufferID The IOStreamBufferID of the buffer to operate on.
     @result A pointer to the control buffer area of the IOStreamBuffer,
     or NULL if it does not have a control buffer.
     
     */
    void *(*GetControlBuffer)( IOStreamRef stream, IOStreamBufferID bufferID );
    
    /*!
        @function GetControlBufferLength
     @abstract Get the length of the control area of an IOStreamBuffer.
     @param stream The IOStreamRef of the stream owning the buffer.
     @param bufferID The IOStreamBufferID of the buffer to operate on.
     @result The length in bytes of the control buffer, or 0 if there is no
     control buffer.
     
     */
    IOByteCount (*GetControlBufferLength)( IOStreamRef stream, IOStreamBufferID bufferID );
    
    /*!
        @function StartStream
    */
    IOReturn (*StartStream)( IOStreamRef stream );
    
    /*!
        @function StopStream
     */
    IOReturn (*StopStream)( IOStreamRef stream );
    
    /*!
        @function SuspendStream
     */
    IOReturn (*SuspendStream)( IOStreamRef stream );
    
    /*!
        @function GetMode
     */
    IOStreamMode (*GetMode)( IOStreamRef stream );
    
    /*!
        @function SetMode
     */
    IOReturn (*SetMode)( IOStreamRef stream, IOStreamMode mode );
    
} IOStreamInterface;


__END_DECLS

#endif /* ! __IOKIT_IOSTREAMLIB_H */
                                                                                                                                                                                    IOStreamShared.h                                                                                    0100644 0001750 0001750 00000011167 12567451750 035073  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/stream                                                                /*
 *  IOStreamShared.h
 *  IOStreamFamily
 *
 *  Copyright 2006 Apple Computer, Inc. All rights reserved.
 *
 */

#if !defined(__IOKIT_IOSTREAMSHARED_H)
#define __IOKIT_IOSTREAMSHARED_H

#include <sys/cdefs.h>

#include <IOKit/IOTypes.h>

/*!
    @header IOStreamShared.h
    IOStream definitions shared between kernel and user space.
 */

__BEGIN_DECLS    
   
// Buffer numbers are guaranteed to go from 0 to bufferCount - 1.
/*!
    @typedef IOStreamBufferID
 */
typedef UInt32 IOStreamBufferID;
#define kIOStreamBufferIDInvalid (~0)

// This is the header for the shared-memory queue used to send buffer notifications
// from kernel to user space or vice versa.

// Queue entry in input or output queue

#ifdef __cplusplus

/*!
    @struct IOStreamBufferQueueEntry
    @field bufferID     The ID of the buffer passed in this queue entry.
    @field dataLength   The length of the valid data in the buffer.
    @field reserved     Reserved for future use.
*/
    
struct IOStreamBufferQueueEntry {
    IOStreamBufferID    bufferID;
    UInt32              dataOffset;
    UInt32              dataLength;
    UInt32              controlOffset;
    UInt32              controlLength;
    UInt32              reserved[3];
};


/*!
    @struct IOStreamBufferQueue
    @field entryCount   The number of queue entries in the queue.
    @field headIndex    The index of the next queue slot that will be filled in by the queue writer.
    @field tailIndex    The index of the next queue slot that can be read by the queue reader.
    @field reserved     Reserved for future use.
    @field queue        The array of queue entries.
 */

struct IOStreamBufferQueue {
    UInt32                      entryCount;
    volatile UInt32             headIndex;
    volatile UInt32             tailIndex;
    UInt32                      reserved;
    IOStreamBufferQueueEntry    queue[0];
};

#else

typedef struct __IOStreamBufferQueueEntry {
    IOStreamBufferID    bufferID;
    UInt32              dataOffset;
    UInt32              dataLength;
    UInt32              controlOffset;
    UInt32              controlLength;
    UInt32              reserved[3];
} IOStreamBufferQueueEntry;

typedef struct __IOStreamBufferQueue {
    UInt32                      entryCount;
    volatile UInt32             headIndex;
    volatile UInt32             tailIndex;
    UInt32                      reserved;
    IOStreamBufferQueueEntry    queue[0];
} IOStreamBufferQueue;

#endif

/*!
    @enum Memory mapping types
    @constant kIOStreamMemoryTypeOutputQueue
    @constant kIOStreamMemoryTypeInputQueue
    @constant kIOStreamMemoryTypeBufferData
    @constant kIOStreamMemoryTypeBufferControl
    @constant kIOStreamBufferIDMask
    @constant kIOStreamMemoryTypeMask
    @abstract Memory types used with IOConnectMapMemory().
    @discussion
 */
enum {
    kIOStreamMemoryTypeOutputQueue   = 0x10000000,
    kIOStreamMemoryTypeInputQueue    = 0x20000000,
    kIOStreamMemoryTypeBufferData    = 0x30000000,
    kIOStreamMemoryTypeBufferControl = 0x40000000,
    kIOStreamBufferIDMask            = 0x0FFFFFFF,
    kIOStreamMemoryTypeMask          = 0xF0000000
};

/*!
    @enum Mach port types
    @constant kIOStreamPortTypeOutput
    @constant kIOStreamPortTypeInput
    @abstract Port types used with IOConnectSetNotificationPort().
    @discussion
 */
enum {
    kIOStreamPortTypeOutput,
    kIOStreamPortTypeInput
};

/*!
    @enum IOStream open options
    @discussion
 */
 
enum {
    kIOStreamOptionOpenExclusive = 0x00010000,
    kIOStreamOptionOpenShared    = 0x00020000
};

/*!
    @enum User client methods
    @constant kIOStreamMethodOpen
    @constant kIOStreamMethodClose
    @constant kIOStreamMethodStart
    @constant kIOStreamMethodStop
    @constant kIOStreamMethodSuspend
    @constant kIOStreamMethodGetMode
    @constant kIOStreamMethodSetMode
 
    @abstract Client method numbers used with IOConnectMethod...() functions.
    @discussion
 */
enum {
    kIOStreamMethodOpen,
    kIOStreamMethodClose,
    kIOStreamMethodStart,
    kIOStreamMethodStop,
    kIOStreamMethodSuspend,
    kIOStreamMethodGetMode,
    kIOStreamMethodSetMode,
    kIOStreamMethodGetBufferCount
};

/*!
    @enum User client traps
    @constant kIOStreamEnqueueInputTrap
    @constant kIOStreamEnqueueInputSyncTrap
    @abstract Client trap numbers used with IOConnectTrap..() functions.
    @discussion
 */
enum {
    kIOStreamEnqueueInputTrap,
    kIOStreamEnqueueInputSyncTrap
};

typedef enum {
    kIOStreamModeInput,         // From user to kernel space
    kIOStreamModeOutput,        // From kernel to user space
    kIOStreamModeInputOutput    // bidirectional
} IOStreamMode;


__END_DECLS

#endif /* ! __IOKIT_IOSTREAMSHARED_H */

                                                                                                                                                                                                                                                                                                                                                                                                         usb/                                                                                                0040755 0001750 0001750 00000000000 12612224741 031370  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOUSBLib.h                                                                                          0100644 0001750 0001750 00000765022 12567452726 033101  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/usb                                                                   /*
 * Copyright  2006-2014 Apple Inc. All rights reserved. 
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOUSBLIB_H
#define _IOUSBLIB_H

#include <IOKit/usb/USB.h>
#include <IOKit/IOKitLib.h>

#include <CoreFoundation/CFRunLoop.h>
#include <CoreFoundation/CFPlugIn.h>
#if COREFOUNDATION_CFPLUGINCOM_SEPARATE
#include <CoreFoundation/CFPlugInCOM.h>
#endif

#include <sys/cdefs.h>

__BEGIN_DECLS

/*!
    @header IOUSBLib
    This documentation describes the details of the programming interface for accessing USB devices and USB
    interfaces from code running in user space.  This documentation assumes that you have a basic understanding
    of the material contained in <a href="http://developer.apple.com/documentation/DeviceDrivers/Conceptual/AccessingHardware/index.html"><i>Accessing Hardware From Applications</i></a>
    For definitions of I/O Kit terms used in this documentation, such as matching dictionary, family, and driver, see the overview of I/O Kit terms and concepts 
    in the "Device Access and the I/O Kit" chapter of <i>Accessing Hardware From Applications</i>.
    
    This documentation also assumes you have read <a href="http://developer.apple.com/documentation/DeviceDrivers/Conceptual/USBBook/index.html"><i>Working With USB Device Interfaces</i></a>.
    Please review that document before using this reference.
    
    All of the information described in this document is contained in the header file <font face="Courier New,Courier,Monaco">IOUSBLib.h</font> found at 
    <font face="Courier New,Courier,Monaco">/System/Library/Frameworks/IOKit.framework/Headers/usb/IOUSBLib.h</font>.
*/

// 9dc7b780-9ec0-11d4-a54f-000a27052861
/*!
    @defined kIOUSBDeviceUserClientTypeID
    @discussion This UUID constant is used to obtain a device interface corresponding to 
  an io_service_t corresponding to an IOUSBDevice in the kernel. Once you have 
  obtained the device interface for the service, you must use the QueryInterface 
  function to obtain the device interface for the user client itself.
  
  Example:
  <pre>
  @textblock
  io_service_t            usbDeviceRef;   // obtained earlier
        
  IOCFPlugInInterface     **iodev;        // fetching this now
        
  SInt32                  score;          // not used
  IOReturn                err;
        
  err = IOCreatePlugInInterfaceForService(usbDeviceRef,
                                    kIOUSBDeviceUserClientTypeID,
                                    kIOCFPlugInInterfaceID,
                                    &iodev,
                                    &score);
    @/textblock
    </pre>
*/

#define kIOUSBDeviceUserClientTypeID CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0x9d, 0xc7, 0xb7, 0x80, 0x9e, 0xc0, 0x11, 0xD4,			\
    0xa5, 0x4f, 0x00, 0x0a, 0x27, 0x05, 0x28, 0x61)



// 2d9786c6-9ef3-11d4-ad51-000a27052861
/*!
    @defined kIOUSBInterfaceUserClientTypeID
    @discussion This UUID constant is used to obtain a device interface corresponding to 
  an io_service_t corresponding to an IOUSBInterface in the kernel. Once you have 
  obtained the device interface for the service, you must use the QueryInterface 
  function to obtain the device interface for the user client itself.
  
  Example:
  <pre>
  @textblock
  io_service_t        usbInterfaceRef;	// obtained earlier
    
  IOCFPlugInInterface	**iodev;                // fetching this now
    
  SInt32              score;                  // not used
  IOReturn            err;
    
  err = IOCreatePlugInInterfaceForService(usbInterfaceRef,
                                    kIOUSBInterfaceUserClientTypeID,
                                    kIOCFPlugInInterfaceID,
                                    &iodev,
                                    &score);
    @/textblock
    </pre>
*/
#define kIOUSBInterfaceUserClientTypeID CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0x2d, 0x97, 0x86, 0xc6, 0x9e, 0xf3, 0x11, 0xD4,			\
    0xad, 0x51, 0x00, 0x0a, 0x27, 0x05, 0x28, 0x61)





// 4547a8aa-9ef3-11d4-a9bd-000a27052861
/*!
    @defined kIOUSBFactoryID
    @discussion This UUID constant is used internally by the system, and 
    should not have to be used by any driver code to access the device interfaces.
*/
#define kIOUSBFactoryID CFUUIDGetConstantUUIDWithBytes(NULL,		\
    0x45, 0x47, 0xa8, 0xaa, 0x9e, 0xf3, 0x11, 0xD4,			\
    0xa9, 0xbd, 0x00, 0x0a, 0x27, 0x05, 0x28, 0x61)




// 5c8187d0-9ef3-11d4-8b45-000a27052861
/*!
    @defined kIOUSBDeviceInterfaceID
    @discussion This UUID constant is used to obtain a device interface corresponding 
    to an IOUSBDevice user client in the kernel. The type of this device interface is 
    IOUSBDeviceInterface. This device interface is obtained after the device interface for 
    the service itself has been obtained.
    
    <b>Note:</b> The IOUSBDeviceInterface is returned by all versions of the IOUSBFamily 
    currently shipping. However, there are some functions that are available only in 
    IOUSBFamily version 1.8.2 and above. Access to these functions, in addition to the functions 
    contained in IOUSBDeviceInterface, can be obtained by using one of the other UUIDs listed in this header.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface		**iodev; 	// obtained earlier
    
    IOUSBDeviceInterface	**dev;		// fetching this now
    IOReturn                    err;
    
    err = (*iodev)->QueryInterface(iodev,
                                    CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID),
                                    (LPVoid)&dev);
    @/textblock
    </pre>
*/
#define kIOUSBDeviceInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0x5c, 0x81, 0x87, 0xd0, 0x9e, 0xf3, 0x11, 0xD4,			\
    0x8b, 0x45, 0x00, 0x0a, 0x27, 0x05, 0x28, 0x61)





// 73c97ae8-9ef3-11d4-b1d0-000a27052861
/*!
    @defined kIOUSBInterfaceInterfaceID
    @discussion This UUID constant is used to obtain a device interface corresponding 
    to an IOUSBInterface user client in the kernel. The type of this device interface 
    is IOUSBInterfaceInterface. This device interface is obtained after the device interface 
    for the service itself has been obtained.
    
    <b>Note:</b> The IOUSBInterfaceInterface is returned by all versions of the IOUSBFamily 
    currently shipping. However, there are some functions which are available only in 
    IOUSBFamily version 1.8.2 and above. Access to these functions, as well as to all of the functions 
    contained in IOUSBInterfaceInterface, can be obtained by using one of the other UUIDs listed in this header.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface		**iodev; 	// obtained earlier
    
    IOUSBInterfaceInterface	**intf;		// fetching this now
    IOReturn                    err;
    
    err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID),
                                (LPVoid)&intf);
    @/textblock
    </pre>
*/
#define kIOUSBInterfaceInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0x73, 0xc9, 0x7a, 0xe8, 0x9e, 0xf3, 0x11, 0xD4,			\
    0xb1, 0xd0, 0x00, 0x0a, 0x27, 0x05, 0x28, 0x61)





// 152FC496-4891-11D5-9D52-000A27801E86
/*!
    @defined kIOUSBDeviceInterfaceID182
    @discussion This UUID constant is used to obtain a device interface corresponding to 
    an IOUSBDevice user client in the kernel. The type of this device interface is 
    IOUSBDeviceInterface182. This device interface is obtained after the device interface 
    for the service itself has been obtained.
    
    <b>Note:</b> The IOUSBDeviceInterface182 is returned only by version 1.8.2 
    or above of the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X
    version 10.0.4. If your software is running on an earlier version of Mac OS X,
    you will need to use the UUID kIOUSBDeviceInterfaceID and you will not have access to some functions.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface		**iodev; 	// obtained earlier
    
    IOUSBDeviceInterface182	**dev;		// fetching this now
    IOReturn                    err;
    
    err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID182),
                                (LPVoid)&dev);
    @/textblock
    </pre>
*/
#define kIOUSBDeviceInterfaceID182 CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0x15, 0x2f, 0xc4, 0x96, 0x48, 0x91, 0x11, 0xD5,			\
    0x9d, 0x52, 0x00, 0x0a, 0x27, 0x80, 0x1e, 0x86)





// 3C9EE1EB-2402-11B2-8E7E-000A27801E86
/*!
    @defined kIOUSBDeviceInterfaceID187
    @discussion This UUID constant is used to obtain a device interface corresponding 
    to an IOUSBDevice user client in the kernel. The type of this device interface is 
    IOUSBDeviceInterface187. This device interface is obtained after the device interface 
    for the service itself has been obtained (see @link kIOUSBDeviceUserClientTypeID kIOUSBDeviceUserClientTypeID @/link).
    
    <b>Note:</b> The IOUSBDeviceInterface187 is returned only by version 1.8.7 or above of 
    the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.1.2. If your 
    software is running on an earlier version of Mac OS X you will need to use UUID kIOUSBDeviceInterfaceID
    or kIOUSBDeviceInterfaceID182 and you will not have access to some functions.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface		**iodev; 	// obtained earlier
    
    IOUSBDeviceInterface187	**dev;		// fetching this now
    IOReturn                    err;
    
    err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID187),
                                (LPVoid)&dev);
    @/textblock
    </pre>
*/
#define kIOUSBDeviceInterfaceID187 CFUUIDGetConstantUUIDWithBytes(NULL, \
    0x3C, 0x9E, 0xE1, 0xEB, 0x24, 0x02, 0x11, 0xB2, 			\
    0x8E, 0x7E, 0x00, 0x0A, 0x27, 0x80, 0x1E, 0x86)





// C809B8D8-0884-11D7-BB96-0003933E3E3E
/*!
    @defined kIOUSBDeviceInterfaceID197
    @discussion This UUID constant is used to obtain a device interface corresponding to 
    an IOUSBDevice user client in the kernel. The type of this device interface is 
    IOUSBDeviceInterface197. This device interface is obtained after the device interface for 
    the service itself has been obtained.
    
    <b>Note:</b> The IOUSBDeviceInterface197 is returned only by version 1.9.7 or above of the 
    IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.2.3. If your software 
    is running on an earlier version of Mac OS X you will need to use UUID kIOUSBDeviceInterfaceID, 
    kIOUSBDeviceInterfaceID182, or kIOUSBDeviceInterfaceID187 and you will not have access to some functions.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface		**iodev; 	// obtained earlier
    
    IOUSBDeviceInterface197	**dev;		// fetching this now
    IOReturn                    err;
    
    err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID197),
                                (LPVoid)&dev);
    @/textblock
    </pre>
*/
#define kIOUSBDeviceInterfaceID197 CFUUIDGetConstantUUIDWithBytes(NULL, \
    0xC8, 0x09, 0xB8, 0xD8, 0x08, 0x84, 0x11, 0xD7, 			\
    0xBB, 0x96, 0x00, 0x03, 0x93, 0x3E, 0x3E, 0x3E)





// FE2FD52F-3B5A-473B-978B-AD99001EB3ED
/*!
@defined kIOUSBDeviceInterfaceID245
 @discussion This UUID constant is used to obtain a device interface corresponding to 
 an IOUSBDevice user client in the kernel. The type of this device interface is 
 IOUSBDeviceInterface245. This device interface is obtained after the device interface for 
 the service itself has been obtained.
 
 <b>Note:</b> The IOUSBDeviceInterface245 is returned only by version 2.4.5 or above of the 
 IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.4.5 (for Intel). This version
 does not add any more functions to the interface.  It is used to allow us to fix an overrelease in our termination without affecting
 any current drivers:  In previous versions, we would end up releasing our IOService, even though we had not retained it.  For 
 IOUSBDeviceInterfaceID245 clients we will retain the IOService.
 
 Example:
 <pre>
 @textblock
 IOCFPluginInterface		**iodev; 	// obtained earlier
 
 IOUSBDeviceInterface245	**dev;		// fetching this now
 IOReturn                    err;
 
 err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID245),
                                (LPVoid)&dev);
 @/textblock
 </pre>
 */
#define kIOUSBDeviceInterfaceID245 CFUUIDGetConstantUUIDWithBytes(NULL, \
   0xFE, 0x2F, 0xD5, 0x2F, 0x3B, 0x5A, 0x47, 0x3B, 			\
   0x97, 0x7B, 0xAD, 0x99, 0x00, 0x1E, 0xB3, 0xED)






// 396104F7-943D-4893-90F1-69BD6CF5C2EB
/*!
 @defined kIOUSBDeviceInterfaceID300
 @discussion This UUID constant is used to obtain a device interface corresponding to 
 an IOUSBDevice user client in the kernel. The type of this device interface is 
 IOUSBDeviceInterface300. This device interface is obtained after the device interface for 
 the service itself has been obtained.
 
 <b>Note:</b> The IOUSBDeviceInterface300 is returned only by version 3.0.0 or above of the 
 IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.5. If your software 
 is running on an earlier version of Mac OS X you will need to use UUID kIOUSBDeviceInterfaceID, 
 kIOUSBDeviceInterfaceID182, kIOUSBDeviceInterfaceID187, kIOUSBDeviceInterfaceID197, or kIOUSBDeviceInterfaceID245 
 and you will not have access to some functions.
 
 Example:
 <pre>
 @textblock
 IOCFPluginInterface		**iodev; 	// obtained earlier
 
 IOUSBDeviceInterface300	**dev;		// fetching this now
 IOReturn                    err;
 
 err = (*iodev)->QueryInterface(iodev,
 CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID300),
 (LPVoid)&dev);
 @/textblock
 </pre>
 */
#define kIOUSBDeviceInterfaceID300 CFUUIDGetConstantUUIDWithBytes(NULL, \
0x39, 0x61, 0x04, 0xF7, 0x94, 0x3D, 0x48, 0x93, 			\
0x90, 0xF1, 0x69, 0xBD, 0x6C, 0xF5, 0xC2, 0xEB)






// 01A2D0E9-42F6-4A87-8B8B-77057C8CE0CE
/*!
 @defined kIOUSBDeviceInterfaceID320
 @discussion This UUID constant is used to obtain a device interface corresponding to 
 an IOUSBDevice user client in the kernel. The type of this device interface is 
 IOUSBDeviceInterface320. This device interface is obtained after the device interface for 
 the service itself has been obtained.
 
 <b>Note:</b> The IOUSBDeviceInterface320 is returned only by version 3.2.0 or above of the 
 IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.5.4 If your software 
 is running on an earlier version of Mac OS X you will need to use UUID kIOUSBDeviceInterfaceID, 
 kIOUSBDeviceInterfaceID182, kIOUSBDeviceInterfaceID187, kIOUSBDeviceInterfaceID197, kIOUSBDeviceInterfaceID245, 
 or kIOUSBDeviceInterfaceID300  and you will not have access to some functions.
 
 Example:
 <pre>
 @textblock
 IOCFPluginInterface		**iodev; 	// obtained earlier
 
 IOUSBDeviceInterface320	**dev;		// fetching this now
 IOReturn                    err;
 
 err = (*iodev)->QueryInterface(iodev,
 CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID320),
 (LPVoid)&dev);
 @/textblock
 </pre>
 */
#define kIOUSBDeviceInterfaceID320 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorSystemDefault,	\
0x01, 0xA2, 0xD0, 0xE9, 0x42, 0xF6, 0x4A, 0x87,													\
0x8B, 0x8B, 0x77, 0x05, 0x7C, 0x8C, 0xE0, 0xCE)






// A33CF047-4B5B-48E2-B57D-0207FCEAE13B
/*!
 @defined kIOUSBDeviceInterfaceID500
 @discussion This UUID constant is used to obtain a device interface corresponding to
 an IOUSBDevice user client in the kernel. The type of this device interface is
 IOUSBDeviceInterface500. This device interface is obtained after the device interface for
 the service itself has been obtained.
 
 <b>Note:</b> The IOUSBDeviceInterface500 is returned only by version 5.0.0 or above of the
 IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.7.3 If your software
 is running on an earlier version of Mac OS X you will need to use UUID kIOUSBDeviceInterfaceID,
 kIOUSBDeviceInterfaceID182, kIOUSBDeviceInterfaceID187, kIOUSBDeviceInterfaceID197, kIOUSBDeviceInterfaceID245, kIOUSBDeviceInterfaceID300,
 or kIOUSBDeviceInterfaceID320  and you will not have access to some functions.
 
 Example:
 <pre>
 @textblock
 IOCFPluginInterface		**iodev; 	// obtained earlier
 
 IOUSBDeviceInterface500	**dev;		// fetching this now
 IOReturn                    err;
 
 err = (*iodev)->QueryInterface(iodev,
 CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID500),
 (LPVoid)&dev);
 @/textblock
 </pre>
 */
#define kIOUSBDeviceInterfaceID500 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorSystemDefault, 	\
0xA3, 0x3C, 0xF0, 0x47, 0x4B, 0x5B, 0x48, 0xE2, 												\
0xB5, 0x7D, 0x02, 0x07, 0xFC, 0xEA, 0xE1, 0x3B)





// 4AAC1B2E-24C2-476A-964D-91333534F2CC
/*!
 @defined kIOUSBDeviceInterfaceID650
 @discussion This UUID constant is used to obtain a device interface corresponding to
 an IOUSBDevice user client in the kernel. The type of this device interface is
 IOUSBDeviceInterface650. This device interface is obtained after the device interface for
 the service itself has been obtained.
 
 <b>Note:</b> The IOUSBDeviceInterface650 is returned only by version 650.4.0 or above of the
 IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.9 If your software
 is running on an earlier version of Mac OS X you will need to use UUID kIOUSBDeviceInterfaceID,
 kIOUSBDeviceInterfaceID182, kIOUSBDeviceInterfaceID187, kIOUSBDeviceInterfaceID197, kIOUSBDeviceInterfaceID245, kIOUSBDeviceInterfaceID300, 
 kIOUSBDeviceInterfaceID320 or kIOUSBDeviceInterfaceID500 and you will not have access to some functions.
 
 Example:
 <pre>
 @textblock
 IOCFPluginInterface		**iodev; 	// obtained earlier
 
 IOUSBDeviceInterface650	**dev;		// fetching this now
 IOReturn                    err;
 
 err = (*iodev)->QueryInterface(iodev,
 CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID650),
 (LPVoid)&dev);
 @/textblock
 </pre>
 */
#define kIOUSBDeviceInterfaceID650 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorSystemDefault, 	\
0x4A, 0xAC, 0x1B, 0x2E, 0x24, 0xC2, 0x47, 0x6A, 												\
0x96, 0x4D, 0x91, 0x33, 0x35, 0x34, 0xF2, 0xCC)





// 4923AC4C-4896-11D5-9208-000A27801E86
/*!
    @defined kIOUSBInterfaceInterfaceID182
    @discussion This UUID constant is used to obtain a interface interface corresponding to
    an IOUSBInterface user client in the kernel. The type of this device interface is 
    IOUSBInterfaceInterface182. This device interface is obtained after the device interface 
    for the service itself has been obtained.
    
    <b>Note:</b> The IOUSBInterfaceInterface182 is returned only by version 1.8.2 
    or above of the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X
    version 10.0.4. If your software is running on an earlier version of Mac OS X,
    you will need to use the UUID kIOUSBInterfaceInterfaceID and you will not have 
    access to some functions.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface         **iodev; 	// obtained earlier
    
    IOUSBInterfaceInterface182	**intf;		// fetching this now
    IOReturn                    err;
    
    err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID182),
                                (LPVoid)&intf);
    @/textblock
    </pre>
*/
#define kIOUSBInterfaceInterfaceID182 CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0x49, 0x23, 0xac, 0x4c, 0x48, 0x96, 0x11, 0xD5,				\
    0x92, 0x08, 0x00, 0x0a, 0x27, 0x80, 0x1e, 0x86)





// 1C438356-74C4-11D5-92E6-000A27801E86
/*!
    @defined kIOUSBInterfaceInterfaceID183
    @discussion This UUID constant is used to obtain a device interface corresponding to 
    an IOUSBInterface user client in the kernel. The type of this device interface 
    is IOUSBInterfaceInterface183. This device interface is obtained after the device 
    interface for the service itself has been obtained.
    
    <b>Note:</b> The IOUSBInterfaceInterface183 is returned only by version 1.8.3 
    or above of the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X
    version 10.1. If your software is running on a version of Mac OS X prior to 10.1
    you will need to use the UUID kIOUSBInterfaceInterfaceID
    or kIOUSBInterfaceInterfaceID182 and you will not have access to some functions.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface             **iodev; 	// obtained earlier
    
    IOUSBInterfaceInterface183      **intf;     // fetching this now
    IOReturn                        err;
    
    err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID183),
                                (LPVoid)&intf);
    @/textblock
    </pre>
*/
#define kIOUSBInterfaceInterfaceID183 CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0x1c, 0x43, 0x83, 0x56, 0x74, 0xc4, 0x11, 0xD5,				\
    0x92, 0xe6, 0x00, 0x0a, 0x27, 0x80, 0x1e, 0x86)





// 8FDB8455-74A6-11D6-97B1-003065D3608E
/*!
    @defined kIOUSBInterfaceInterfaceID190
    @discussion This UUID constant is used to obtain a device interface corresponding 
    to an IOUSBInterface user client in the kernel. The type of this device interface 
    is IOUSBInterfaceInterface190. This device interface is obtained after the device 
    interface for the service itself has been obtained.
    
    <b>Note:</b> The IOUSBInterfaceInterface190 is returned only by version 1.9 or above 
    of the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.2. 
    If your software is running on a version of Mac OS X prior to 10.2 you will need to 
    use the UUID kIOUSBInterfaceInterfaceID, kIOUSBInterfaceInterfaceID182, or
    kIOUSBInterfaceInterfaceID183 and you will not have access to some functions.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface             **iodev; 	// obtained earlier
    
    IOUSBInterfaceInterface190      **intf;     // fetching this now
    IOReturn                        err;
    
    err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID190),
                                (LPVoid)&intf);
    @/textblock
    </pre>
*/
#define kIOUSBInterfaceInterfaceID190 CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0x8f, 0xdb, 0x84, 0x55, 0x74, 0xa6, 0x11, 0xD6,				\
    0x97, 0xb1, 0x00, 0x30, 0x65, 0xd3, 0x60, 0x8e)





// 6C798A6E-D6E9-11D6-ADD6-0003933E3E3E
/*!
    @defined kIOUSBInterfaceInterfaceID192
    @discussion This UUID constant is used to obtain a device interface corresponding to 
    an IOUSBInterface user client in the kernel. The type of this device interface is 
    IOUSBInterfaceInterface192. This device interface is obtained after the device interface 
    for the service itself has been obtained.
    
    <b>Note:</b> The IOUSBInterfaceInterface192 is returned only by version 1.9.2 or above of 
    the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.2.3. If your 
    software is running on a version of Mac OS X prior to 10.2.3 you will need to use the 
    UUID kIOUSBInterfaceInterfaceID, kIOUSBInterfaceInterfaceID182, kIOUSBInterfaceInterfaceID183, 
    or kIOUSBInterfaceInterfaceID190 and you will not have access to some functions.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface             **iodev; 	// obtained earlier
    
    IOUSBInterfaceInterface192      **intf;     // fetching this now
    IOReturn                        err;
    
    err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID192),
                                (LPVoid)&intf);
    @/textblock
    </pre>
*/
#define kIOUSBInterfaceInterfaceID192 CFUUIDGetConstantUUIDWithBytes(NULL, 	\
    0x6C, 0x79, 0x8A, 0x6E, 0xD6, 0xE9, 0x11, 0xD6, 				\
    0xAD, 0xD6, 0x00, 0x03, 0x93, 0x3E, 0x3E, 0x3E)





// C63D3C92-0884-11D7-9692-0003933E3E3E
/*!
    @defined kIOUSBInterfaceInterfaceID197
    @discussion This UUID constant is used to obtain a device interface corresponding to 
    an IOUSBInterface user client in the kernel. The type of this device interface is 
    IOUSBInterfaceInterface197. This device interface is obtained after the device interface 
    for the service itself has been obtained.
    
    <b>Note:</b> The IOUSBInterfaceInterface197 is returned only by version 1.9.7 or above of 
    the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.2.5. If your software 
    is running on a version of Mac OS X prior to 10.2.5 you will need to use the UUID kIOUSBInterfaceInterfaceID,
    kIOUSBInterfaceInterfaceID182, kIOUSBInterfaceInterfaceID183, kIOUSBInterfaceInterfaceID190, or
    kIOUSBInterfaceInterfaceID192 and you will not have access to some functions.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface             **iodev; 	// obtained earlier
    
    IOUSBInterfaceInterface197      **intf;     // fetching this now
    IOReturn                        err;
    
    err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID197),
                                (LPVoid)&intf);
    @/textblock
    </pre>
*/
#define kIOUSBInterfaceInterfaceID197 CFUUIDGetConstantUUIDWithBytes(NULL, 	\
    0xC6, 0x3D, 0x3C, 0x92, 0x08, 0x84, 0x11, 0xD7,				\
    0x96, 0x92, 0x00, 0x03, 0x93, 0x3E, 0x3E, 0x3E)





// 770DE60C-2FE8-11D8-A582-000393DCB1D0
/*!
@defined kIOUSBInterfaceInterfaceID220
 @discussion This UUID constant is used to obtain a device interface corresponding to
 an IOUSBInterface user client in the kernel. The type of this device interface is
 IOUSBInterfaceInterface197. This device interface is obtained after the device interface
 for the service itself has been obtained.

 <b>Note:</b> The IOUSBInterfaceInterface220 is returned only by version 2.2.0 or above of
 the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.4. If your software
 is running on a version of Mac OS X prior to 10.4 you will need to use the UUID kIOUSBInterfaceInterfaceID,
 kIOUSBInterfaceInterfaceID182, kIOUSBInterfaceInterfaceID183, kIOUSBInterfaceInterfaceID190, kIOUSBInterfaceInterfaceID192,
 or kIOUSBInterfaceInterfaceID197 and you will not have access to some functions.

 Example:
 <pre>
 @textblock
 IOCFPluginInterface             **iodev; 	// obtained earlier

 IOUSBInterfaceInterface220      **intf;     // fetching this now
 IOReturn                        err;

 err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID220),
                                (LPVoid)&intf);
 @/textblock
 </pre>
 */
#define kIOUSBInterfaceInterfaceID220 CFUUIDGetConstantUUIDWithBytes(NULL, 	\
    0x77, 0x0D, 0xE6, 0x0C, 0x2F, 0xE8, 0x11, 0xD8, 				\
    0xA5, 0x82, 0x00, 0x03, 0x93, 0xDC, 0xB1, 0xD0)





// 64BABDD2-0F6B-4B4F-8E3E-DC36046987AD
/*!
@defined kIOUSBInterfaceInterfaceID245
 @discussion This UUID constant is used to obtain a device interface corresponding to
 an IOUSBInterface user client in the kernel. The type of this device interface is
 IOUSBInterfaceInterface245. This device interface is obtained after the device interface
 for the service itself has been obtained.
 
 <b>Note:</b> The IOUSBInterfaceInterface245 is returned only by version 2.4.5 or above of
 the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.4.5.  This version
 does not add any new functions.  It is used to allow us to fix a leak in our termination without affecting
 any current drivers:  In previous versions, we would not release a reference to the IOUSBDevice.  For 
 IOUSBInterfaceInterfaceID245 clients we will now release that reference.
 
 Example:
 <pre>
 @textblock
 IOCFPluginInterface             **iodev; 	// obtained earlier
 
 IOUSBInterfaceInterface245      **intf;     // fetching this now
 IOReturn                        err;
 
 err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID245),
                                (LPVoid)&intf);
 @/textblock
 </pre>
 */
#define kIOUSBInterfaceInterfaceID245 CFUUIDGetConstantUUIDWithBytes(NULL, 	\
	0x64, 0xBA, 0xBD, 0xD2, 0x0F, 0x6B, 0x4B, 0x4F,							\
	0x8E, 0x3E, 0xDC, 0x36, 0x04, 0x69, 0x87, 0xAD)





// BCEAADDC-884D-4F27-8340-36D69FAB90F6
/*!
@defined kIOUSBInterfaceInterfaceID300
 @discussion This UUID constant is used to obtain a device interface corresponding to
 an IOUSBInterface user client in the kernel. The type of this device interface is
 IOUSBInterfaceInterface300. This device interface is obtained after the device interface
 for the service itself has been obtained.
 
 <b>Note:</b> The IOUSBInterfaceInterface300 is returned only by version 3.0.0 or above of
 the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.5.  If your software
 is running on a version of Mac OS X prior to 10.5 you will need to use the UUID kIOUSBInterfaceInterfaceID,
 kIOUSBInterfaceInterfaceID182, kIOUSBInterfaceInterfaceID183, kIOUSBInterfaceInterfaceID190, kIOUSBInterfaceInterfaceID192,
 kIOUSBInterfaceInterfaceID197, kIOUSBInterfaceInterfaceID220, or kIOUSBInterfaceInterfaceID245 and you will not have access to some functions.
 
 Example:
 <pre>
 @textblock
 IOCFPluginInterface             **iodev; 	// obtained earlier
 
 IOUSBInterfaceInterface300      **intf;     // fetching this now
 IOReturn                        err;
 
 err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID300),
                                (LPVoid)&intf);
 @/textblock
 </pre>
 */
#define kIOUSBInterfaceInterfaceID300 CFUUIDGetConstantUUIDWithBytes(NULL, 	\
	0xBC, 0xEA, 0xAD, 0xDC, 0x88, 0x4D, 0x4F, 0x27,							\
	0x83, 0x40, 0x36, 0xD6, 0x9F, 0xAB, 0x90, 0xF6)





// 6C0D38C3-B093-4EA7-809B-09FB5DDDAC16
/*!
 @defined kIOUSBInterfaceInterfaceID500
 @discussion This UUID constant is used to obtain a device interface corresponding to
 an IOUSBInterface user client in the kernel. The type of this device interface is
 IOUSBInterfaceInterface500. This device interface is obtained after the device interface
 for the service itself has been obtained.
 
 <b>Note:</b> The IOUSBInterfaceInterface500 is returned only by version 5.0.0 or above of
 the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.7.3.  If your software
 is running on a version of Mac OS X prior to 10.7.3 you will need to use the UUID kIOUSBInterfaceInterfaceID,
 kIOUSBInterfaceInterfaceID182, kIOUSBInterfaceInterfaceID183, kIOUSBInterfaceInterfaceID190, kIOUSBInterfaceInterfaceID192,
 kIOUSBInterfaceInterfaceID197, kIOUSBInterfaceInterfaceID220, kIOUSBInterfaceInterfaceID245, or kIOUSBInterfaceInterfaceID300 and you will not have access to some functions.
 
 Example:
 <pre>
 @textblock
 IOCFPluginInterface             **iodev; 	// obtained earlier
 
 IOUSBInterfaceInterface500      **intf;     // fetching this now
 IOReturn                        err;
 
 err = (*iodev)->QueryInterface(iodev,
 CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID500),
 (LPVoid)&intf);
 @/textblock
 </pre>
 */
#define kIOUSBInterfaceInterfaceID500 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorSystemDefault, \
	0x6C, 0x0D, 0x38, 0xC3, 0xB0, 0x93, 0x4E, 0xA7, 											\
	0x80, 0x9B, 0x09, 0xFB, 0x5D, 0xDD, 0xAC, 0x16)





// 6AE44D3F-EB45-487F-8E8E-B93B99F8EA9E
/*!
 @defined kIOUSBInterfaceInterfaceID550
 @discussion This UUID constant is used to obtain a device interface corresponding to
 an IOUSBInterface user client in the kernel. The type of this device interface is
 kIOUSBInterfaceInterfaceID550. This device interface is obtained after the device interface
 for the service itself has been obtained.
 
 <b>Note:</b> The kIOUSBInterfaceInterfaceID550 is returned only by version 5.5.0 or above of
 the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.7.3.  If your software
 is running on a version of Mac OS X prior to 10.8.x you will need to use the UUID kIOUSBInterfaceInterfaceID,
 kIOUSBInterfaceInterfaceID182, kIOUSBInterfaceInterfaceID183, kIOUSBInterfaceInterfaceID190, kIOUSBInterfaceInterfaceID192,
 kIOUSBInterfaceInterfaceID197, kIOUSBInterfaceInterfaceID220, kIOUSBInterfaceInterfaceID245, kIOUSBInterfaceInterfaceID300, or kIOUSBInterfaceInterfaceID500 and you will not have access to some functions.
 
 Example:
 <pre>
 @textblock
 IOCFPluginInterface             **iodev; 	// obtained earlier
 
 IOUSBInterfaceInterface550      **intf;     // fetching this now
 IOReturn                        err;
 
 err = (*iodev)->QueryInterface(iodev,
 CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID550),
 (LPVoid)&intf);
 @/textblock
 </pre>
 */
#define kIOUSBInterfaceInterfaceID550 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorSystemDefault, \
    0x6A, 0xE4, 0x4D, 0x3F, 0xEB, 0x45, 0x48, 0x7F, 											\
    0x8E, 0x8E, 0xB9, 0x3B, 0x99, 0xF8, 0xEA, 0x9E)





// 08151A89-8081-4087-8F9E-0AFEDFDB5D9F
/*!
 @defined kIOUSBInterfaceInterfaceID650
 @discussion This UUID constant is used to obtain a device interface corresponding to
 an IOUSBInterface user client in the kernel. The type of this device interface is
 kIOUSBInterfaceInterfaceID650. This device interface is obtained after the device interface
 for the service itself has been obtained.
 
 <b>Note:</b> The kIOUSBInterfaceInterfaceID650 is returned only by version 650.4.0 or above of
 the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.9.  If your software
 is running on a version of Mac OS X prior to 10.9 you will need to use the UUID kIOUSBInterfaceInterfaceID,
 kIOUSBInterfaceInterfaceID182, kIOUSBInterfaceInterfaceID183, kIOUSBInterfaceInterfaceID190, kIOUSBInterfaceInterfaceID192,
 kIOUSBInterfaceInterfaceID197, kIOUSBInterfaceInterfaceID220, kIOUSBInterfaceInterfaceID245, kIOUSBInterfaceInterfaceID300, 
 kIOUSBInterfaceInterfaceID500 or kIOUSBInterfaceInterfaceID550 and you will not have access to some functions.
 
 Example:
 <pre>
 @textblock
 IOCFPluginInterface             **iodev; 	// obtained earlier
 
 IOUSBInterfaceInterface650      **intf;     // fetching this now
 IOReturn                        err;
 
 err = (*iodev)->QueryInterface(iodev,
 CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID650),
 (LPVoid)&intf);
 @/textblock
 </pre>
 */
#define kIOUSBInterfaceInterfaceID650 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorSystemDefault, \
    0x08, 0x15, 0x1A, 0x89, 0x80, 0x81, 0x40, 0x87, 											\
    0x8F, 0x9E, 0x0A, 0xFE, 0xDF, 0xDB, 0x5D, 0x9F)





// 17F9E59C-B0A1-401D-9AC0-8DE27AC6047E
/*!
 @defined kIOUSBInterfaceInterfaceID700
 @discussion This UUID constant is used to obtain an interface interface corresponding to
 an IOUSBInterface user client in the kernel. The type of this device interface is
 kIOUSBInterfaceInterfaceID700. This device interface is obtained after the device interface
 for the service itself has been obtained.
 
 <b>Note:</b> The kIOUSBInterfaceInterfaceID700 is returned only by version 700.4.0 or above of
 the IOUSBFamily. This version of IOUSBFamily shipped with Mac OS X version 10.10.  If your software
 is running on a version of Mac OS X prior to 10.10 you will need to use the UUID kIOUSBInterfaceInterfaceID,
 kIOUSBInterfaceInterfaceID182, kIOUSBInterfaceInterfaceID183, kIOUSBInterfaceInterfaceID190, kIOUSBInterfaceInterfaceID192,
 kIOUSBInterfaceInterfaceID197, kIOUSBInterfaceInterfaceID220, kIOUSBInterfaceInterfaceID245, kIOUSBInterfaceInterfaceID300,
 kIOUSBInterfaceInterfaceID500, kIOUSBInterfaceInterfaceID550 or kIOUSBInterfaceInterfaceID650, and you will not have access to some functions.
 
 Example:
 <pre>
 @textblock
 IOCFPluginInterface             **iodev; 	// obtained earlier
 
 IOUSBInterfaceInterface700      **intf;     // fetching this now
 IOReturn                        err;
 
 err = (*iodev)->QueryInterface(iodev,
 CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID700),
 (LPVoid)&intf);
 @/textblock
 </pre>
 */

#define kIOUSBInterfaceInterfaceID700 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorSystemDefault, \
0x17, 0xF9, 0xE5, 0x9C, 0xB0, 0xA1, 0x40, 0x1D,                                                 \
0x9A, 0xC0, 0x8D, 0xE2, 0x7A, 0xC6, 0x04, 0x7E)



/*!
 @interface IOUSBDeviceInterface
 @abstract   The object you use to access USB devices from user space, returned by all versions of the IOUSBFamily
 currently shipping.
 @discussion The functions listed here will work with any version of the IOUSBDeviceInterface, including
 the one shipped with Mac OS X version 10.0. 
 */

typedef struct IOUSBDeviceStruct {
    IUNKNOWN_C_GUTS;
    
    /*!
    @function CreateDeviceAsyncEventSource
    @abstract   Creates a run loop source for delivery of all asynchronous notifications on this device.
    @discussion The Mac OS X kernel does not spawn a thread to callback to the client. Instead it delivers 
                completion notifications (see @link //apple_ref/C/instm/IOUSBInterfaceInterface/CreateInterfaceAsyncPort/ CreateInterfaceAsyncPort @/link). This routine 
                wraps that port with the appropriate routing code so that the completion notifications can be 
                automatically routed through the client's CFRunLoop.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      source Pointer to a CFRunLoopSourceRef to return the newly created run loop event source.
    @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
	*/

    IOReturn (*CreateDeviceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    
    /*!
    @function GetDeviceAsyncEventSource
    @abstract   Returns the CFRunLoopSourceRef for this IOService instance.
    @param      self Pointer to the IOUSBDeviceInterface.
    @result     Returns the run loop source if one has been created, 0 otherwise.
	*/

    CFRunLoopSourceRef (*GetDeviceAsyncEventSource)(void *self);
    
    /*!
    @function CreateDeviceAsyncPort
    @abstract   Creates and registers a mach_port_t for asynchronous communications.
    @discussion The Mac OS X kernel does not spawn a thread to callback to the client. Instead it delivers 
                completion notifications on this mach port. After receiving a message on this port the 
                client is obliged to call the IOKitLib.h IODispatchCalloutFromMessage() function for 
                decoding the notification message.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      port Pointer to a mach_port_t to return the newly created port.
    @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
	*/

    IOReturn (*CreateDeviceAsyncPort)(void *self, mach_port_t *port); 
    
    /*!
    @function GetDeviceAsyncPort
    @abstract   Returns the mach_port_t port for this IOService instance.
    @param      self Pointer to the IOUSBDeviceInterface.
    @result     Returns the port if one exists, 0 otherwise.
	*/

    mach_port_t (*GetDeviceAsyncPort)(void *self);
    
    /*!
    @function USBDeviceOpen
    @abstract   Opens the IOUSBDevice for exclusive access.
    @discussion Before the client can issue commands that change the state of the device, it 
                must have succeeded in opening the device. This establishes an exclusive link 
                between the client's task and the actual device.
    @param      self Pointer to the IOUSBDeviceInterface.
    @result     Returns kIOReturnExclusiveAccess if some other task has the device opened already,
                kIOReturnError if the connection with the kernel cannot be established or kIOReturnSuccess if successful.
	*/

    IOReturn (*USBDeviceOpen)(void *self);
    
    /*!
    @function USBDeviceClose
    @abstract   Closes the task's connection to the IOUSBDevice.
    @discussion Releases the client's exclusive access to the IOUSBDevice.
    @param      self Pointer to the IOUSBDeviceInterface.
    @result     Returns kIOReturnSuccess if successful, some other mach error if the connection is no longer valid.
	*/

    IOReturn (*USBDeviceClose)(void *self);
    
    /*!
    @function GetDeviceClass
    @abstract   Returns the USB Class (bDeviceClass) of the device.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      devClass Pointer to UInt8 to hold the device Class.
    @result      Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDeviceClass)(void *self, UInt8 *devClass);
    
    /*!
    @function GetDeviceSubClass
    @abstract   Returns the USB Subclass (bDeviceSubClass) of the device.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      devSubClass Pointer to UInt8 to hold the device Subclass.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDeviceSubClass)(void *self, UInt8 *devSubClass);
    
    /*!
    @function GetDeviceProtocol
    @abstract   Returns the USB Protocol (bDeviceProtocol) of the interface.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      devProtocol Pointer to UInt8 to hold the device Protocol.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDeviceProtocol)(void *self, UInt8 *devProtocol);
    
    /*!
    @function GetDeviceVendor
    @abstract   Returns the USB Vendor ID (idVendor) of the device.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      devVendor   Pointer to UInt16 to hold the vendorID.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    
    /*!
    @function GetDeviceProduct
    @abstract    Returns the USB Product ID (idProduct) of the device.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      devProduct  Pointer to UInt16 to hold the ProductID.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    
    /*!
    @function GetDeviceReleaseNumber
    @abstract   Returns the Device Release Number (bcdDevice) of the device.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      devRelNum   Pointer to UInt16 to hold the Device Release Number.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    
    /*!
    @function GetDeviceAddress
    @abstract   Returns the address of the device on its bus.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      addr    Pointer to USBDeviceAddress to hold the result.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDeviceAddress)(void *self, USBDeviceAddress *addr);
    
    /*!
    @function GetDeviceBusPowerAvailable
    @abstract   Returns the power available to the device.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      powerAvailable Pointer to UInt32 to hold the power available (in 2 mA increments).
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDeviceBusPowerAvailable)(void *self, UInt32 *powerAvailable);
    
    /*!
	 @function GetDeviceSpeed
	 @abstract   Returns the speed of the device.
	 @discussion The device does not have to be open to use this function.
	 @param      self Pointer to the IOUSBDeviceInterface.
	 @param      devSpeed Pointer to UInt8 to hold the speed (kUSBDeviceSpeedLow, kUSBDeviceSpeedFull, kUSBDeviceSpeedHigh, or kUSBDeviceSpeedSuper).
	 @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	 */
    IOReturn (*GetDeviceSpeed)(void *self, UInt8 *devSpeed);
    
    /*!
    @function GetNumberOfConfigurations
    @abstract   Returns the number of supported configurations in this device.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      numConfig Pointer to UInt8 to hold the number of configurations.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetNumberOfConfigurations)(void *self, UInt8 *numConfig);
    
    /*!
    @function GetLocationID
    @abstract   Returns the location ID.
    @discussion The location ID is a 32 bit number which is unique among all USB devices in the system, and 
                which will not change on a system reboot unless the topology of the bus itself changes. The 
                device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      locationID Pointer to UInt32 to hold the location ID.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    
    /*!
    @function GetConfigurationDescriptorPtr
    @abstract   Returns a pointer to a configuration descriptor for a given index.
    @discussion Note that this will point to the data as received from the USB bus and hence will be in USB bus 
                order (i.e. little endian).  The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      configIndex The index (zero based) of the desired config descriptor.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetConfigurationDescriptorPtr)(void *self, UInt8 configIndex, IOUSBConfigurationDescriptorPtr *desc);
    
    /*!
    @function GetConfiguration
    @abstract   Returns the currently selected configuration in the device.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      configNum Pointer to UInt8 to hold the configuration value.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetConfiguration)(void *self, UInt8 *configNum);
    
    /*!
    @function SetConfiguration
    @abstract   Sets the configuration in the device.
    @discussion Note that setting the configuration causes any existing IOUSBInterface objects attached to the 
                IOUSBDevice to be destroyed, and all of the interfaces in the new configuration to be instantiated 
                as new IOUSBInterface objects.  The device must be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      configNum The value of the desired configuration (from IOUSBConfigurationDescriptor.bConfigurationValue).
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, 
                or kIOReturnNotOpen if the device is not open for exclusive access.
	*/

    IOReturn (*SetConfiguration)(void *self, UInt8 configNum);
    
    /*!
    @function GetBusFrameNumber
    @abstract   Gets the current frame number of the bus to which the device is attached.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      frame Pointer to UInt64 to hold the frame number.
    @param      atTime Pointer to a returned AbsoluteTime, which is the system time ("wall time") when the frame number register was read. This
				system time could be the time at the beginning, middle, or end of the given frame.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    
    /*!
    @function ResetDevice
    @abstract   Tells the IOUSBFamily to issue a reset to the device.
    @discussion It will not reenumerate the device, which means that the cached device descriptor values will not 
                be updated after the reset. (If you want the IOUSBFamily to reload the cached values, use the call
                USBDeviceReEnumerate). Prior to version 1.8.5 of the IOUSBFamily, this call also sent a message to 
                all clients of the IOUSBDevice (IOUSBInterfaces and their drivers).  The device must be open to use 
                this function.  
                
                This behavior was eliminated in version 1.8.5 of the IOUSBFamily.
    @param      self Pointer to the IOUSBDeviceInterface.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the device is not open for exclusive access.
	*/

    IOReturn (*ResetDevice)(void *self);
    
    /*!
    @function DeviceRequest
    @abstract   Sends a USB request on the default control pipe.
    @discussion The device must be open to issue this call. Care should be taken when issuing a device request which
                changes the state of the device. Use the API, for example, to change the configuration of the device 
                or to select an alternate setting on an interface.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      req Pointer to an IOUSBDevRequest containing the request.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
				kIOReturnAborted if the thread is interrupted before the call completes, 
                or kIOReturnNotOpen if the device is not open for exclusive access.
	*/

    IOReturn (*DeviceRequest)(void *self, IOUSBDevRequest *req);
    
    /*!
    @function DeviceRequestAsync
    @abstract   Sends an asynchronous USB request on the default control pipe.
    @discussion The device must be open to issue this command. Care should be taken when issuing a device request which 
                changes the state of the device. Use the API, for example, to change the configuration of the device or 
                to select an alternate setting on an interface.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      req Pointer to an IOUSBDevRequest containing the request.
    @param      callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the number of bytes that were actually transferred.  
	 			A message addressed to this callback is posted to the Async port upon completion.
    @param      refCon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                kIOReturnNotOpen if the device is not open for exclusive access, or kIOUSBNoAsyncPortErr if no Async 
                port has been created for this interface.
	*/

    IOReturn (*DeviceRequestAsync)(void *self, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    
    /*!
    @function CreateInterfaceIterator
    @abstract   Creates an iterator to iterate over some or all of the interfaces of a device.
    @discussion The device does not have to be open to use this function.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      req Pointer an IOUSBFindInterfaceRequest structure describing the desired interfaces.
    @param      iter Pointer to a an io_iterator_t to contain the new iterator.
    @result     Returns kIOReturnSuccess if successful or kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*CreateInterfaceIterator)(void *self, IOUSBFindInterfaceRequest *req, io_iterator_t *iter);
    
} IOUSBDeviceInterface;

	/*!
    @interface IOUSBDeviceInterface182
    @abstract   The object you use to access USB devices from user space, returned by the IOUSBFamily version
                1.8.2 and above.
    @discussion The functions listed here include all of the functions defined for the IOUSBDeviceInterface and
                some new functions that are available on Mac OS X version 10.0.4 and later.
    @super IOUSBDeviceInterface
	*/

typedef struct IOUSBDeviceStruct182 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateDeviceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetDeviceAsyncEventSource)(void *self);
    IOReturn (*CreateDeviceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetDeviceAsyncPort)(void *self);
    IOReturn (*USBDeviceOpen)(void *self);
    IOReturn (*USBDeviceClose)(void *self);
    IOReturn (*GetDeviceClass)(void *self, UInt8 *devClass);
    IOReturn (*GetDeviceSubClass)(void *self, UInt8 *devSubClass);
    IOReturn (*GetDeviceProtocol)(void *self, UInt8 *devProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetDeviceAddress)(void *self, USBDeviceAddress *addr);
    IOReturn (*GetDeviceBusPowerAvailable)(void *self, UInt32 *powerAvailable);
    IOReturn (*GetDeviceSpeed)(void *self, UInt8 *devSpeed);
    IOReturn (*GetNumberOfConfigurations)(void *self, UInt8 *numConfig);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetConfigurationDescriptorPtr)(void *self, UInt8 configIndex, IOUSBConfigurationDescriptorPtr *desc);
    IOReturn (*GetConfiguration)(void *self, UInt8 *configNum);
    IOReturn (*SetConfiguration)(void *self, UInt8 configNum);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ResetDevice)(void *self);
    IOReturn (*DeviceRequest)(void *self, IOUSBDevRequest *req);
    IOReturn (*DeviceRequestAsync)(void *self, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*CreateInterfaceIterator)(void *self, IOUSBFindInterfaceRequest *req, io_iterator_t *iter);
    
    /*!
    @function USBDeviceOpenSeize
    @abstract  Opens the IOUSBDevice for exclusive access.
    @discussion This function opens the IOUSBDevice for exclusive access. If another client 
                has the device opened, an attempt is made to get that client to close it before 
                returning.  Before the client can issue commands that change the state of the device, 
                it must have succeeded in opening the device. This establishes an exclusive 
                link between the client's task and the actual device.
    @availability This function is only available with IOUSBDeviceInterface182 and above.
    @param      self Pointer to the IOUSBDeviceInterface.
    @result     Returns kIOReturnExclusiveAccess if some other task has the device opened already and refuses
                to close it, kIOReturnError if the connection with the kernel can not be established or kIOReturnSuccess if successful.
	*/

    IOReturn (*USBDeviceOpenSeize)(void *self);
    
    /*!
    @function DeviceRequestTO
    @abstract   Sends a USB request on the default control pipe.
    @discussion This function sends a USB request on the default control pipe. The IOUSBDevRequestTO structure 
                allows the client to specify timeout values for this request.  The device must be open to issue this command. 
                Care should be taken when issuing a device request which changes the state of the device. Use the 
                API, for example, to change the configuration of the device or to select an alternate setting on 
                an interface.
    @availability This function is only available with IOUSBDeviceInterface182 and above.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      req Pointer to an IOUSBDevRequestTO containing the request.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
				kIOReturnAborted if the thread is interrupted before the call completes, 
               or kIOReturnNotOpen if the device is not open for exclusive access.
	*/

    IOReturn (*DeviceRequestTO)(void *self, IOUSBDevRequestTO *req);
    
    /*!
    @function DeviceRequestAsyncTO
    @abstract   Sends an asynchronous USB request on the default control pipe.
    @discussion This function sends an asynchronous USB request on the default control pipe.  The IOUSBDevRequestTO 
                structure allows the client to specify timeout values for this request.  The device must be open to 
                issue this command. Care should be taken when issuing a device request which changes the state of 
                the device. Use the API, for example, to change the configuration of the device or to select an 
                alternate setting on an interface.
    @availability This function is only available with IOUSBDeviceInterface182 and above.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      req Pointer to an IOUSBDevRequestTO containing the request.
    @param      callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the number of bytes that were actually transferred
	 			in the DeviceRequest.  A message addressed to this callback is posted to the 
                Async port upon completion.
    @param      refCon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                kIOReturnNotOpen if the device is not open for exclusive access, orkIOUSBNoAsyncPortErr if no Async 
                port has been created for this interface.
	*/

    IOReturn (*DeviceRequestAsyncTO)(void *self, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    
    /*!
    @function USBDeviceSuspend
    @abstract   Tells the USB Family to either suspend or resume the port to which a device is attached.
    @discussion The device must be open to use this function.
    @availability This function is only available with IOUSBDeviceInterface182 and above.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      suspend TRUE to cause the port to be suspended, FALSE to cause it to be resumed.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the device is not open for exclusive access.
	*/

    IOReturn (*USBDeviceSuspend)(void *self, Boolean suspend);
    
    /*!
    @function USBDeviceAbortPipeZero
    @abstract   Aborts a transaction on the default control pipe.
    @discussion The device must be open to use this function.
    @availability This function is only available with IOUSBDeviceInterface182 and above.
    @param      self Pointer to the IOUSBDeviceInterface.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the device is not open for exclusive access.
	*/

    IOReturn (*USBDeviceAbortPipeZero)(void *self);
    
    /*!
    @function USBGetManufacturerStringIndex
    @abstract   Returns the manufacturer string index in the device descriptor.
    @discussion The device does not have to be open to use this function.
    @availability This function is only available with IOUSBDeviceInterface182 and above.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      msi Pointer to UInt8 to hold the string index.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*USBGetManufacturerStringIndex)(void *self, UInt8 *msi);
    
    /*!
    @function USBGetProductStringIndex
    @abstract   Returns the product string index in the device descriptor.
    @discussion The device does not have to be open to use this function.
    @availability This function is only available with IOUSBDeviceInterface182 and above.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      psi Pointer to UInt8 to hold the string index.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*USBGetProductStringIndex)(void *self, UInt8 *psi);
    
    /*!
    @function USBGetSerialNumberStringIndex
    @abstract   Returns the serial number string index in the device descriptor.
    @discussion The device does not have to be open to use this function.
    @availability This function is only available with IOUSBDeviceInterface182 and above.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      snsi Pointer to UInt8 to hold the string index.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*USBGetSerialNumberStringIndex)(void *self, UInt8 *snsi);
    
} IOUSBDeviceInterface182;

	/*!
    @interface IOUSBDeviceInterface187
    @abstract   The object you use to access USB devices from user space, returned by the IOUSBFamily version
                10.8.7 and above.
    @discussion The functions listed here include all of the functions defined for the IOUSBDeviceInterface,
                IOUSBDeviceInterface182, and some new functions that are available on Mac OS X version 10.1.2 and later.
    @super IOUSBDeviceInterface182
	*/


typedef struct IOUSBDeviceStruct187 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateDeviceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetDeviceAsyncEventSource)(void *self);
    IOReturn (*CreateDeviceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetDeviceAsyncPort)(void *self);
    IOReturn (*USBDeviceOpen)(void *self);
    IOReturn (*USBDeviceClose)(void *self);
    IOReturn (*GetDeviceClass)(void *self, UInt8 *devClass);
    IOReturn (*GetDeviceSubClass)(void *self, UInt8 *devSubClass);
    IOReturn (*GetDeviceProtocol)(void *self, UInt8 *devProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetDeviceAddress)(void *self, USBDeviceAddress *addr);
    IOReturn (*GetDeviceBusPowerAvailable)(void *self, UInt32 *powerAvailable);
    IOReturn (*GetDeviceSpeed)(void *self, UInt8 *devSpeed);
    IOReturn (*GetNumberOfConfigurations)(void *self, UInt8 *numConfig);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetConfigurationDescriptorPtr)(void *self, UInt8 configIndex, IOUSBConfigurationDescriptorPtr *desc);
    IOReturn (*GetConfiguration)(void *self, UInt8 *configNum);
    IOReturn (*SetConfiguration)(void *self, UInt8 configNum);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ResetDevice)(void *self);
    IOReturn (*DeviceRequest)(void *self, IOUSBDevRequest *req);
    IOReturn (*DeviceRequestAsync)(void *self, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*CreateInterfaceIterator)(void *self, IOUSBFindInterfaceRequest *req, io_iterator_t *iter);
    IOReturn (*USBDeviceOpenSeize)(void *self);
    IOReturn (*DeviceRequestTO)(void *self, IOUSBDevRequestTO *req);
    IOReturn (*DeviceRequestAsyncTO)(void *self, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*USBDeviceSuspend)(void *self, Boolean suspend);
    IOReturn (*USBDeviceAbortPipeZero)(void *self);
    IOReturn (*USBGetManufacturerStringIndex)(void *self, UInt8 *msi);
    IOReturn (*USBGetProductStringIndex)(void *self, UInt8 *psi);
    IOReturn (*USBGetSerialNumberStringIndex)(void *self, UInt8 *snsi);
    
    /*!
    @function USBDeviceReEnumerate
    @abstract   Tells the IOUSBFamily to reenumerate the device.
    @discussion This function will send a terminate message to all clients of the IOUSBDevice (such as 
                IOUSBInterfaces and their drivers, as well as the current User Client), emulating an unplug 
                of the device. The IOUSBFamily will then enumerate the device as if it had just 
                been plugged in. This call should be used by clients wishing to take advantage 
                of the Device Firmware Update Class specification.  The device must be open to use this function, except when you are passing the kUSBReEnumerateCaptureDeviceBit or 
                kUSBReEnumerateReleaseDeviceBit options.  In those cases you either need to (1) have the "com.apple.vm.device-access" entitlement set and the IOUSBDevice needs to have successfully been authorized by
                the IOKit's IOServiceAuthorize() APIs or (2) run with root privileges. 
    @availability This function is only available with IOUSBDeviceInterface187 and above.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      options A UInt32 with a bit mask of options.  See USB.h and the USBReEnumerateOptions enum.  If the kUSBReEnumerateCaptureDeviceBit is used
                the client needs to either (1) have the "com.apple.vm.device-access" entitlement set and the IOUSBDevice needs to have successfully been authorized by
                the IOKit's IOServiceAuthorize() APIs or (2) run with root privileges.  Using that bit will terminate any kernel drivers for all non-mass storage interfaces
                attached to the device, as well as for any kernel driver that is attached to the device.  Specifying the kUSBReEnumerateReleaseDeviceBit will cause the IOUSBDevice to
                be returned to the OS and the driver for that device to be reloaded.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the device is not open for exclusive access.
	*/

    IOReturn (*USBDeviceReEnumerate)(void *self, UInt32 options);
} IOUSBDeviceInterface187;

	/*!
    @interface IOUSBDeviceInterface197
    @abstract   The object you use to access USB devices from user space, returned by the IOUSBFamily version
                1.9.7 and above.
    @discussion The functions listed here include all of the functions defined for the IOUSBDeviceInterface,
                IOUSBDeviceInterface182, IOUSBDeviceInterface187, and some new functions that are available 
                on Mac OS X version 10.2.3 and later.
    @super IOUSBDeviceInterface187
	*/


typedef struct IOUSBDeviceStruct197 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateDeviceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetDeviceAsyncEventSource)(void *self);
    IOReturn (*CreateDeviceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetDeviceAsyncPort)(void *self);
    IOReturn (*USBDeviceOpen)(void *self);
    IOReturn (*USBDeviceClose)(void *self);
    IOReturn (*GetDeviceClass)(void *self, UInt8 *devClass);
    IOReturn (*GetDeviceSubClass)(void *self, UInt8 *devSubClass);
    IOReturn (*GetDeviceProtocol)(void *self, UInt8 *devProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetDeviceAddress)(void *self, USBDeviceAddress *addr);
    IOReturn (*GetDeviceBusPowerAvailable)(void *self, UInt32 *powerAvailable);
    IOReturn (*GetDeviceSpeed)(void *self, UInt8 *devSpeed);
    IOReturn (*GetNumberOfConfigurations)(void *self, UInt8 *numConfig);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetConfigurationDescriptorPtr)(void *self, UInt8 configIndex, IOUSBConfigurationDescriptorPtr *desc);
    IOReturn (*GetConfiguration)(void *self, UInt8 *configNum);
    IOReturn (*SetConfiguration)(void *self, UInt8 configNum);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ResetDevice)(void *self);
    IOReturn (*DeviceRequest)(void *self, IOUSBDevRequest *req);
    IOReturn (*DeviceRequestAsync)(void *self, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*CreateInterfaceIterator)(void *self, IOUSBFindInterfaceRequest *req, io_iterator_t *iter);
    IOReturn (*USBDeviceOpenSeize)(void *self);
    IOReturn (*DeviceRequestTO)(void *self, IOUSBDevRequestTO *req);
    IOReturn (*DeviceRequestAsyncTO)(void *self, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*USBDeviceSuspend)(void *self, Boolean suspend);
    IOReturn (*USBDeviceAbortPipeZero)(void *self);
    IOReturn (*USBGetManufacturerStringIndex)(void *self, UInt8 *msi);
    IOReturn (*USBGetProductStringIndex)(void *self, UInt8 *psi);
    IOReturn (*USBGetSerialNumberStringIndex)(void *self, UInt8 *snsi);
    IOReturn (*USBDeviceReEnumerate)(void *self, UInt32 options);
    
    /*!
    @function GetBusMicroFrameNumber
    @abstract   Gets the current micro frame number of the bus to which the device is attached.
    @discussion The device does not have to be open to use this function.
    @availability This function is only available with IOUSBDeviceInterface197 and above.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      microFrame Pointer to UInt64 to hold the microframe number.
    @param      atTime Pointer to an AbsoluteTime, which should be within 1ms of the time when the bus 
                frame number was acquired.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetBusMicroFrameNumber)(void *self, UInt64 *microFrame, AbsoluteTime *atTime);
    
    /*!
    @function GetIOUSBLibVersion
    @abstract   Returns the version of the IOUSBLib and the version of the IOUSBFamily.
    @discussion The device does not have to be open to use this function.
    @availability This function is only available with IOUSBDeviceInterface197 and above.
    @param      self Pointer to the IOUSBDeviceInterface.
    @param      ioUSBLibVersion Pointer to a NumVersion structure that on return will contain the version of 
                the IOUSBLib.
    @param      usbFamilyVersion Pointer to a NumVersion structure that on return will contain the version of 
                the IOUSBFamily.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetIOUSBLibVersion)(void *self, NumVersion *ioUSBLibVersion, NumVersion *usbFamilyVersion);
} IOUSBDeviceInterface197;


	/*!
	@interface IOUSBDeviceInterface245
	@abstract   The object you use to access USB devices from user space, returned by the IOUSBFamily version
	2.4.5 and above.
	@discussion The functions listed here include all of the functions defined for the IOUSBDeviceInterface,
	IOUSBDeviceInterface182, IOUSBDeviceInterface187, IOUSBDeviceInterface197, and some new functions that are available 
	on Mac OS X version 10.2.3 and later.
	@super IOUSBDeviceInterface197
	*/


typedef struct IOUSBDeviceStruct245 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateDeviceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetDeviceAsyncEventSource)(void *self);
    IOReturn (*CreateDeviceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetDeviceAsyncPort)(void *self);
    IOReturn (*USBDeviceOpen)(void *self);
    IOReturn (*USBDeviceClose)(void *self);
    IOReturn (*GetDeviceClass)(void *self, UInt8 *devClass);
    IOReturn (*GetDeviceSubClass)(void *self, UInt8 *devSubClass);
    IOReturn (*GetDeviceProtocol)(void *self, UInt8 *devProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetDeviceAddress)(void *self, USBDeviceAddress *addr);
    IOReturn (*GetDeviceBusPowerAvailable)(void *self, UInt32 *powerAvailable);
    IOReturn (*GetDeviceSpeed)(void *self, UInt8 *devSpeed);
    IOReturn (*GetNumberOfConfigurations)(void *self, UInt8 *numConfig);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetConfigurationDescriptorPtr)(void *self, UInt8 configIndex, IOUSBConfigurationDescriptorPtr *desc);
    IOReturn (*GetConfiguration)(void *self, UInt8 *configNum);
    IOReturn (*SetConfiguration)(void *self, UInt8 configNum);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ResetDevice)(void *self);
    IOReturn (*DeviceRequest)(void *self, IOUSBDevRequest *req);
    IOReturn (*DeviceRequestAsync)(void *self, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*CreateInterfaceIterator)(void *self, IOUSBFindInterfaceRequest *req, io_iterator_t *iter);
    IOReturn (*USBDeviceOpenSeize)(void *self);
    IOReturn (*DeviceRequestTO)(void *self, IOUSBDevRequestTO *req);
    IOReturn (*DeviceRequestAsyncTO)(void *self, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*USBDeviceSuspend)(void *self, Boolean suspend);
    IOReturn (*USBDeviceAbortPipeZero)(void *self);
    IOReturn (*USBGetManufacturerStringIndex)(void *self, UInt8 *msi);
    IOReturn (*USBGetProductStringIndex)(void *self, UInt8 *psi);
    IOReturn (*USBGetSerialNumberStringIndex)(void *self, UInt8 *snsi);
    IOReturn (*USBDeviceReEnumerate)(void *self, UInt32 options);
    IOReturn (*GetBusMicroFrameNumber)(void *self, UInt64 *microFrame, AbsoluteTime *atTime);
    IOReturn (*GetIOUSBLibVersion)(void *self, NumVersion *ioUSBLibVersion, NumVersion *usbFamilyVersion);
} IOUSBDeviceInterface245;



/*!
 @interface IOUSBDeviceInterface300
 @abstract   The object you use to access USB devices from user space, returned by the IOUSBFamily version 3.0.0 and above.
 @discussion The functions listed here include all of the functions defined for the IOUSBDeviceInterface,
 IOUSBDeviceInterface182, IOUSBDeviceInterface187, IOUSBDeviceInterface197, IOUSBDeviceInterface245, 
 and some new functions that are available on Mac OS X version 10.5 and later.
 @super IOUSBDeviceInterface245
 */


typedef struct IOUSBDeviceStruct300 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateDeviceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetDeviceAsyncEventSource)(void *self);
    IOReturn (*CreateDeviceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetDeviceAsyncPort)(void *self);
    IOReturn (*USBDeviceOpen)(void *self);
    IOReturn (*USBDeviceClose)(void *self);
    IOReturn (*GetDeviceClass)(void *self, UInt8 *devClass);
    IOReturn (*GetDeviceSubClass)(void *self, UInt8 *devSubClass);
    IOReturn (*GetDeviceProtocol)(void *self, UInt8 *devProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetDeviceAddress)(void *self, USBDeviceAddress *addr);
    IOReturn (*GetDeviceBusPowerAvailable)(void *self, UInt32 *powerAvailable);
    IOReturn (*GetDeviceSpeed)(void *self, UInt8 *devSpeed);
    IOReturn (*GetNumberOfConfigurations)(void *self, UInt8 *numConfig);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetConfigurationDescriptorPtr)(void *self, UInt8 configIndex, IOUSBConfigurationDescriptorPtr *desc);
    IOReturn (*GetConfiguration)(void *self, UInt8 *configNum);
    IOReturn (*SetConfiguration)(void *self, UInt8 configNum);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ResetDevice)(void *self);
    IOReturn (*DeviceRequest)(void *self, IOUSBDevRequest *req);
    IOReturn (*DeviceRequestAsync)(void *self, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*CreateInterfaceIterator)(void *self, IOUSBFindInterfaceRequest *req, io_iterator_t *iter);
    IOReturn (*USBDeviceOpenSeize)(void *self);
    IOReturn (*DeviceRequestTO)(void *self, IOUSBDevRequestTO *req);
    IOReturn (*DeviceRequestAsyncTO)(void *self, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*USBDeviceSuspend)(void *self, Boolean suspend);
    IOReturn (*USBDeviceAbortPipeZero)(void *self);
    IOReturn (*USBGetManufacturerStringIndex)(void *self, UInt8 *msi);
    IOReturn (*USBGetProductStringIndex)(void *self, UInt8 *psi);
    IOReturn (*USBGetSerialNumberStringIndex)(void *self, UInt8 *snsi);
    IOReturn (*USBDeviceReEnumerate)(void *self, UInt32 options);
    IOReturn (*GetBusMicroFrameNumber)(void *self, UInt64 *microFrame, AbsoluteTime *atTime);
    IOReturn (*GetIOUSBLibVersion)(void *self, NumVersion *ioUSBLibVersion, NumVersion *usbFamilyVersion);
	
    /*!
	 @function GetBusFrameNumberWithTime
	 @abstract   Gets a recent frame number of the bus to which the device is attached, along with a system time corresponding to the start of that frame
	 @discussion The device does not have to be open to use this function.
	 @availability This function is only available with IOUSBDeviceInterface300 and above.
	 @param      self Pointer to the IOUSBDeviceInterface.
	 @param      frame Pointer to UInt64 to hold the frame number.
	 @param      atTime Pointer to a returned AbsoluteTime, which is the system time ("wall time") as close as possible to the beginning of that USB frame. The jitter on this value may be as much as 200 microseconds.
	 @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or kIOReturnUnsupported is the bus doesn't support this function.
	 */
	
    IOReturn (*GetBusFrameNumberWithTime)(void *self, UInt64 *frame, AbsoluteTime *atTime);
} IOUSBDeviceInterface300;





/*!
 @interface IOUSBDeviceInterface320
 @abstract   The object you use to access USB devices from user space, returned by the IOUSBFamily version 3.2.0 and above.
 @discussion The functions listed here include all of the functions defined for the IOUSBDeviceInterface,
 IOUSBDeviceInterface182, IOUSBDeviceInterface187, IOUSBDeviceInterface197, IOUSBDeviceInterface245, or IOUSBDeviceInterface300
 and some new functions that are available on Mac OS X version 10.5.4 and later.
 @super IOUSBDeviceInterface300
 */

typedef struct IOUSBDeviceStruct320 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateDeviceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetDeviceAsyncEventSource)(void *self);
    IOReturn (*CreateDeviceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetDeviceAsyncPort)(void *self);
    IOReturn (*USBDeviceOpen)(void *self);
    IOReturn (*USBDeviceClose)(void *self);
    IOReturn (*GetDeviceClass)(void *self, UInt8 *devClass);
    IOReturn (*GetDeviceSubClass)(void *self, UInt8 *devSubClass);
    IOReturn (*GetDeviceProtocol)(void *self, UInt8 *devProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetDeviceAddress)(void *self, USBDeviceAddress *addr);
    IOReturn (*GetDeviceBusPowerAvailable)(void *self, UInt32 *powerAvailable);
    IOReturn (*GetDeviceSpeed)(void *self, UInt8 *devSpeed);
    IOReturn (*GetNumberOfConfigurations)(void *self, UInt8 *numConfig);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetConfigurationDescriptorPtr)(void *self, UInt8 configIndex, IOUSBConfigurationDescriptorPtr *desc);
    IOReturn (*GetConfiguration)(void *self, UInt8 *configNum);
    IOReturn (*SetConfiguration)(void *self, UInt8 configNum);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ResetDevice)(void *self);
    IOReturn (*DeviceRequest)(void *self, IOUSBDevRequest *req);
    IOReturn (*DeviceRequestAsync)(void *self, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*CreateInterfaceIterator)(void *self, IOUSBFindInterfaceRequest *req, io_iterator_t *iter);
    IOReturn (*USBDeviceOpenSeize)(void *self);
    IOReturn (*DeviceRequestTO)(void *self, IOUSBDevRequestTO *req);
    IOReturn (*DeviceRequestAsyncTO)(void *self, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*USBDeviceSuspend)(void *self, Boolean suspend);
    IOReturn (*USBDeviceAbortPipeZero)(void *self);
    IOReturn (*USBGetManufacturerStringIndex)(void *self, UInt8 *msi);
    IOReturn (*USBGetProductStringIndex)(void *self, UInt8 *psi);
    IOReturn (*USBGetSerialNumberStringIndex)(void *self, UInt8 *snsi);
    IOReturn (*USBDeviceReEnumerate)(void *self, UInt32 options);
    IOReturn (*GetBusMicroFrameNumber)(void *self, UInt64 *microFrame, AbsoluteTime *atTime);
    IOReturn (*GetIOUSBLibVersion)(void *self, NumVersion *ioUSBLibVersion, NumVersion *usbFamilyVersion);
    IOReturn (*GetBusFrameNumberWithTime)(void *self, UInt64 *frame, AbsoluteTime *atTime);
	
    /*!
	 @function GetUSBDeviceInformation
	 @abstract 	Returns status information about the USB device, such as whether the device is captive or whether it is in the suspended state.
	 @discussion The device does not have to be open to use this function.
	 @availability This function is only available with IOUSBDeviceInterface320 and above.
	 @param      self Pointer to the IOUSBDeviceInterface.
	 @param      info Pointer to a buffer that returns a bit field of information on the device (see the USBDeviceInformationBits in USB.h).
	 @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or kIOReturnUnsupported is the bus doesn't support this function.
	 */
    IOReturn (*GetUSBDeviceInformation)(void *self, UInt32 *info);

	/*!
	 @function RequestExtraPower
	 @abstract				Clients can use this API to reserve extra power for use by this device while the machine is asleep or while it is awake.  Units are milliAmps (mA).
	 @discussion			The device has to be open to use this function.
	 @availability			This function is only available with IOUSBDeviceInterface320 and above.
	 @param self			Pointer to the IOUSBDeviceInterface.
	 @param type			Indicates whether the power is to be used during wake or sleep (One of kUSBPowerDuringSleep or kUSBPowerDuringWake)
	 @param requestedPower 	Amount of power desired, in mA
	 @param powerAvailable 	Amount of power that was reserved, in mA
	 @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or kIOReturnUnsupported is the bus doesn't support this function.
	 */
	IOReturn (*RequestExtraPower)(void *self, UInt32 type, UInt32 requestedPower, UInt32 *powerAvailable);

	/*!
	 @function ReturnExtraPower
	 @abstract				Clients can use this API to tell the system that they will not use power that was previously reserved by using the RequestExtraPower API.
	 @discussion			The device has to be open to use this function.
	 @availability			This function is only available with IOUSBDeviceInterface320 and above.
	 @param      self		Pointer to the IOUSBDeviceInterface.
	 @param type			Indicates whether the power is to be used during wake or sleep (One of kUSBPowerDuringSleep or kUSBPowerDuringWake)
	 @param powerReturned 	Amount of power to be returned, in mA.
	 @result				If the returnedPower was not previously allocated, an error will be returned.  This will include the case for power that was requested for sleep but was returned for wake. Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	 */
	IOReturn (*ReturnExtraPower)(void *self, UInt32 type, UInt32 powerReturned);
	
	/*!
	 @function GetExtraPowerAllocated
	 @abstract				Clients can use this API to ask how much extra power has already been reserved by this device.  Units are milliAmps (mA).
	 @discussion			The device has to be open to use this function.
	 @availability			This function is only available with IOUSBDeviceInterface320 and above.
	 @param      self		Pointer to the IOUSBDeviceInterface.
	 @param type			Indicates whether the allocated power was to be used during wake or sleep (One of kUSBPowerDuringSleep or kUSBPowerDuringWake)
	 @param powerAllocated 	Amount of power to be returned, in mA.
	 @result				Value returned can be 0 if no power has been allocated. Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	 */
	IOReturn (*GetExtraPowerAllocated)(void *self, UInt32 type, UInt32 *powerAllocated);
	
} IOUSBDeviceInterface320;





/*!
 @interface IOUSBDeviceInterface500
 @abstract   The object you use to access USB devices from user space, returned by the IOUSBFamily version 5.0.0 and above.
 @discussion The functions listed here include all of the functions defined for the IOUSBDeviceInterface,
 IOUSBDeviceInterface182, IOUSBDeviceInterface187, IOUSBDeviceInterface197, IOUSBDeviceInterface245, IOUSBDeviceInterface300, or IOUSBDeviceInterface320
 and some new functions that are available on Mac OS X version 10.7.3 and later.
 @super IOUSBDeviceInterface320
 */

typedef struct IOUSBDeviceStruct500 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateDeviceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetDeviceAsyncEventSource)(void *self);
    IOReturn (*CreateDeviceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetDeviceAsyncPort)(void *self);
    IOReturn (*USBDeviceOpen)(void *self);
    IOReturn (*USBDeviceClose)(void *self);
    IOReturn (*GetDeviceClass)(void *self, UInt8 *devClass);
    IOReturn (*GetDeviceSubClass)(void *self, UInt8 *devSubClass);
    IOReturn (*GetDeviceProtocol)(void *self, UInt8 *devProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetDeviceAddress)(void *self, USBDeviceAddress *addr);
    IOReturn (*GetDeviceBusPowerAvailable)(void *self, UInt32 *powerAvailable);
    IOReturn (*GetDeviceSpeed)(void *self, UInt8 *devSpeed);
    IOReturn (*GetNumberOfConfigurations)(void *self, UInt8 *numConfig);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetConfigurationDescriptorPtr)(void *self, UInt8 configIndex, IOUSBConfigurationDescriptorPtr *desc);
    IOReturn (*GetConfiguration)(void *self, UInt8 *configNum);
    IOReturn (*SetConfiguration)(void *self, UInt8 configNum);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ResetDevice)(void *self);
    IOReturn (*DeviceRequest)(void *self, IOUSBDevRequest *req);
    IOReturn (*DeviceRequestAsync)(void *self, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*CreateInterfaceIterator)(void *self, IOUSBFindInterfaceRequest *req, io_iterator_t *iter);
    IOReturn (*USBDeviceOpenSeize)(void *self);
    IOReturn (*DeviceRequestTO)(void *self, IOUSBDevRequestTO *req);
    IOReturn (*DeviceRequestAsyncTO)(void *self, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*USBDeviceSuspend)(void *self, Boolean suspend);
    IOReturn (*USBDeviceAbortPipeZero)(void *self);
    IOReturn (*USBGetManufacturerStringIndex)(void *self, UInt8 *msi);
    IOReturn (*USBGetProductStringIndex)(void *self, UInt8 *psi);
    IOReturn (*USBGetSerialNumberStringIndex)(void *self, UInt8 *snsi);
    IOReturn (*USBDeviceReEnumerate)(void *self, UInt32 options);
    IOReturn (*GetBusMicroFrameNumber)(void *self, UInt64 *microFrame, AbsoluteTime *atTime);
    IOReturn (*GetIOUSBLibVersion)(void *self, NumVersion *ioUSBLibVersion, NumVersion *usbFamilyVersion);
    IOReturn (*GetBusFrameNumberWithTime)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*GetUSBDeviceInformation)(void *self, UInt32 *info);
	IOReturn (*RequestExtraPower)(void *self, UInt32 type, UInt32 requestedPower, UInt32 *powerAvailable);
	IOReturn (*ReturnExtraPower)(void *self, UInt32 type, UInt32 powerReturned);
	IOReturn (*GetExtraPowerAllocated)(void *self, UInt32 type, UInt32 *powerAllocated);
    /*!
	 @function GetBandwidthAvailableForDevice
	 @abstract   Returns the amount of bandwidth available on the bus for allocation to
	 periodic pipes.  If the device is a high or super speed device, it will be the number of bytes per microframe (125 secs). If it is a full
	 speed device, it will be the number of bytes per frame (1ms)
	 @discussion This function is useful for determining the correct AltInterface setting as well as for using
	 SetPipePolicy. The interface does not have to be open to use this function.
	 @availability This function is only available with IOUSBDeviceInterface500 and above.
	 @param      self Pointer to the IOUSBDeviceInterface.
	 @param      bandwidth Pointer to UInt32 to hold the amount of bandwidth available (in bytes per frame or microframe).
	 @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	 */
	
    IOReturn (*GetBandwidthAvailableForDevice)(void *self, UInt32 *bandwidth);
	
} IOUSBDeviceInterface500;






/*!
 @interface IOUSBDeviceInterface650
 @abstract   The object you use to access USB devices from user space, returned by the IOUSBFamily version 650.4.0 and above.
 @discussion The functions listed here include all of the functions defined for the IOUSBDeviceInterface,
 IOUSBDeviceInterface182, IOUSBDeviceInterface187, IOUSBDeviceInterface197, IOUSBDeviceInterface245, IOUSBDeviceInterface300, 
 IOUSBDeviceInterface320 or IOUSBDeviceInterface500
 and some new functions that are available on Mac OS X version 10.9 and later.
 @super IOUSBDeviceInterface500
 */

typedef struct IOUSBDeviceStruct650 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateDeviceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetDeviceAsyncEventSource)(void *self);
    IOReturn (*CreateDeviceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetDeviceAsyncPort)(void *self);
    IOReturn (*USBDeviceOpen)(void *self);
    IOReturn (*USBDeviceClose)(void *self);
    IOReturn (*GetDeviceClass)(void *self, UInt8 *devClass);
    IOReturn (*GetDeviceSubClass)(void *self, UInt8 *devSubClass);
    IOReturn (*GetDeviceProtocol)(void *self, UInt8 *devProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetDeviceAddress)(void *self, USBDeviceAddress *addr);
    IOReturn (*GetDeviceBusPowerAvailable)(void *self, UInt32 *powerAvailable);
    IOReturn (*GetDeviceSpeed)(void *self, UInt8 *devSpeed);
    IOReturn (*GetNumberOfConfigurations)(void *self, UInt8 *numConfig);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetConfigurationDescriptorPtr)(void *self, UInt8 configIndex, IOUSBConfigurationDescriptorPtr *desc);
    IOReturn (*GetConfiguration)(void *self, UInt8 *configNum);
    IOReturn (*SetConfiguration)(void *self, UInt8 configNum);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ResetDevice)(void *self);
    IOReturn (*DeviceRequest)(void *self, IOUSBDevRequest *req);
    IOReturn (*DeviceRequestAsync)(void *self, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*CreateInterfaceIterator)(void *self, IOUSBFindInterfaceRequest *req, io_iterator_t *iter);
    IOReturn (*USBDeviceOpenSeize)(void *self);
    IOReturn (*DeviceRequestTO)(void *self, IOUSBDevRequestTO *req);
    IOReturn (*DeviceRequestAsyncTO)(void *self, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*USBDeviceSuspend)(void *self, Boolean suspend);
    IOReturn (*USBDeviceAbortPipeZero)(void *self);
    IOReturn (*USBGetManufacturerStringIndex)(void *self, UInt8 *msi);
    IOReturn (*USBGetProductStringIndex)(void *self, UInt8 *psi);
    IOReturn (*USBGetSerialNumberStringIndex)(void *self, UInt8 *snsi);
    IOReturn (*USBDeviceReEnumerate)(void *self, UInt32 options);
    IOReturn (*GetBusMicroFrameNumber)(void *self, UInt64 *microFrame, AbsoluteTime *atTime);
    IOReturn (*GetIOUSBLibVersion)(void *self, NumVersion *ioUSBLibVersion, NumVersion *usbFamilyVersion);
    IOReturn (*GetBusFrameNumberWithTime)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*GetUSBDeviceInformation)(void *self, UInt32 *info);
	IOReturn (*RequestExtraPower)(void *self, UInt32 type, UInt32 requestedPower, UInt32 *powerAvailable);
	IOReturn (*ReturnExtraPower)(void *self, UInt32 type, UInt32 powerReturned);
	IOReturn (*GetExtraPowerAllocated)(void *self, UInt32 type, UInt32 *powerAllocated);
    IOReturn (*GetBandwidthAvailableForDevice)(void *self, UInt32 *bandwidth);
    
    /*!
     @function SetConfigurationV2
     @abstract   Sets the configuration in the device.
     @discussion Note that setting the configuration causes any existing IOUSBInterface objects attached to the
     IOUSBDevice to be destroyed, and all of the interfaces in the new configuration to be instantiated
     as new IOUSBInterface objects.  The device must be open to use this function.
     @param      self Pointer to the IOUSBDeviceInterface.
     @param      configNum The value of the desired configuration (from IOUSBConfigurationDescriptor.bConfigurationValue)
     @param      startInterfaceMatching true if IOUSBFamily should call IOKit to match the IOUSBInterface nubs.  If false is set, the client
                 needs to either (1) have the "com.apple.vm.device-access" entitlement and have the IOUSBDevice authorized
                 via the IOKit's IOServiceAuthorize() API or (1) have root privileges.
     @param      issueRemoteWakeup true if IOUSBFamily should send the command to enable remote wakeup in the device
     @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
     or kIOReturnNotOpen if the device is not open for exclusive access.
     */
    
    IOReturn (*SetConfigurationV2)(void *self, UInt8 configNum, bool startInterfaceMatching, bool issueRemoteWakeup);

    
    /*!
	 @function RegisterForNotification
	 @abstract   Registers a callback routine to be invoked when certain events occur in the kernel.
	 @discussion The callback function will be called, for example when the underlying IOUSBDevice is 
                 going to be suspended due to some kind of kernel activity. It will also be called when
                 the underlying IOUSBDevice is resumed.
	 @availability This function is only available with IOUSBDeviceInterface650 and above.
	 @param      self Pointer to the IOUSBDeviceInterface.
	 @param      notificationMask Specifies the desired type of notification
     @param      callback An IOAsyncCallback2 method. Upon completion, the arg0 argument of the AsyncCallback2 will contain the
                 notification type, and arg1 will contain a notificationToken which should be used when calling AcknowledgeNotification
     @param      refCon Arbitrary pointer which is passed as a parameter to the callback routine.
     @param      pRegistrationToken A pointer to a UInt64 which will contain a registration token if the function is
                 successful. This registration token can then later be used to call UnregisterNotification.
	 @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	 */
    IOReturn (*RegisterForNotification)(void * self, UInt64 notificationMask, IOAsyncCallback2 callback, void *refCon, UInt64 *pRegistrationToken);

    
    
    /*!
	 @function UnregisterNotification
	 @abstract   Unregisters a previously registered callback routine
	 @discussion The callback routine will no longer be invoked when events occur
	 @availability This function is only available with IOUSBDeviceInterface650 and above.
	 @param      self Pointer to the IOUSBDeviceInterface.
     @param      registrationToken The registration token which was obtained in the call to RegisterForNotification
	 @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	 */
    IOReturn (*UnregisterNotification)(void *self, UInt64 registrationToken);

    
    /*!
	 @function AcknowledgeNotification
	 @abstract   Acknowledges a notification event
	 @discussion Some events in the kernel will wait for an acknowledgement from all interested parties before proceeding.
                 For example, if an IOUSBDevice is about to be suspended, any User Code which has registered to receive
                 that event will be notified and should acknowledge the notification when it is ready for the IOUSBDevice
                 to be suspended.
	 @availability This function is only available with IOUSBDeviceInterface650 and above.
	 @param      self Pointer to the IOUSBDeviceInterface.
     @param      notificationToken The notification token which was passed in to the callback routine
	 @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	 */
    IOReturn (*AcknowledgeNotification)(void *self, UInt64 notificationToken);

} IOUSBDeviceInterface650;






	/*!
    @interface IOUSBInterfaceInterface
    @abstract   The object you use to access a USB device interface from user space, returned by all versions
                of the IOUSBFamily currently shipping.
    @discussion The functions listed here will work with any version of the IOUSBInterfaceInterface, including
                the one shipped with Mac OS X version 10.0.
	*/
typedef struct IOUSBInterfaceStruct {
    IUNKNOWN_C_GUTS;
    
    /*!
    @function CreateInterfaceAsyncEventSource
    @abstract   Creates a run loop source for delivery of all asynchronous notifications on this device.
    @discussion The Mac OS X kernel does not spawn a thread to callback to the client. Instead 
                it delivers completion notifications on a Mach port (see {@link CreateInterfaceAsyncPort}). This 
                routine wraps that port with the appropriate routing code so that 
                the completion notifications can be automatically routed through the client's 
                CFRunLoop.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      source Pointer to a CFRunLoopSourceRef to return the newly created run loop event source.
    @result     Returns kIOReturnSuccess if successful or a kern_return_t if failed.
	*/

    IOReturn (*CreateInterfaceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    
    /*!
    @function GetInterfaceAsyncEventSource
    @abstract   Returns the CFRunLoopSourceRef for this IOService instance.
    @discussion (description)
    @param      self Pointer to the IOUSBInterfaceInterface.
    @result     Returns the run loop source if one has been created, 0 otherwise.
	*/

    CFRunLoopSourceRef (*GetInterfaceAsyncEventSource)(void *self);
    
    /*!
    @function CreateInterfaceAsyncPort
    @abstract   Creates and registers a mach_port_t for asynchronous communications.
    @discussion The Mac OS X kernel does not spawn a thread to callback to the client. Instead 
                it delivers completion notifications on this Mach port. After receiving a message 
                on this port the client is obliged to call the IOKitLib.h: IODispatchCalloutFromMessage() 
                function for decoding the notification message.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @result     Returns kIOReturnSuccess if successful or a kern_return_t if failed.
	*/

    IOReturn (*CreateInterfaceAsyncPort)(void *self, mach_port_t *port);
    
    /*!
    @function GetInterfaceAsyncPort
    @abstract   Returns the mach_port_t port for this IOService instance.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @result     Returns the port if one exists, 0 otherwise.
	*/

    mach_port_t (*GetInterfaceAsyncPort)(void *self);
    
    /*!
    @function USBInterfaceOpen
    @abstract   Opensthe IOUSBInterface for exclusive access.
    @discussion Before the client can transfer data to and from the interface, it must have 
                succeeded in opening the interface. This establishes an exclusive link between 
                the client's task and the actual interface device. Opening the interface causes 
                pipes to be created on each endpoint contained in the interface. If the interface 
                contains isochronous endpoints, an attempt is made to allocate bandwidth on 
                the bus for each of those pipes. If there is not enough bandwidth available, 
                an isochronous pipe may be created with a bandwidth of zero. The software must 
                then call SetPipePolicy to change the size of that pipe before it can be used 
                for I/O.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @result     Returns kIOReturnExclusiveAccess if some other task has the device opened already,
                kIOReturnError if the connection with the kernel cannot be established or
                kIOReturnSuccess if successful.
	*/

    IOReturn (*USBInterfaceOpen)(void *self);
    
    /*!
    @function USBInterfaceClose
    @abstract   Closes the task's connection to the IOUSBInterface.
    @discussion Releases the client's exclusive access to the IOUSBInterface.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*USBInterfaceClose)(void *self);
    
    /*!
    @function GetInterfaceClass
    @abstract   Returns the USB Class of the interface  (bInterfaceClass).
    @discussion The interface does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      intfClass Pointer to UInt8 to hold the interface Class.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetInterfaceClass)(void *self, UInt8 *intfClass);
    
    /*!
    @function GetInterfaceSubClass
    @abstract   Returns the USB Subclass of the interface (bInterfaceSubClass).
    @discussion The interface does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      intfSubClass Pointer to UInt8 to hold the interface Subclass.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetInterfaceSubClass)(void *self, UInt8 *intfSubClass);
    
    /*!
    @function GetInterfaceProtocol
    @abstract   Returns the USB Protocol of the interface (bInterfaceProtocol).
    @discussion The interface does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      intfProtocol Pointer to UInt8 to hold the interface Protocol.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetInterfaceProtocol)(void *self, UInt8 *intfProtocol);
    
    /*!
    @function GetDeviceVendor
    @abstract   Returns the USB Vendor ID (idVendor) of the device of which this interface is a part.
    @discussion The interface does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      devVendor Pointer to UInt16 to hold the vendorID.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    
    /*!
    @function GetDeviceProduct
    @abstract   Returns the USB Product ID (idProduct) of the device of which this interface is a part.
    @discussion The interface does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      devProduct Pointer to UInt16 to hold the ProductID.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    
    /*!
    @function GetDeviceReleaseNumber
    @abstract   Returns the Device Release Number (bcdDevice) of the device of which this interface is a part.
    @discussion The interface does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      devRelNum Pointer to UInt16 to hold the Release Number.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    
    /*!
    @function GetConfigurationValue
    @abstract   Returns the current configuration value set in the device (the interface will be part of that configuration.)
    @discussion The interface does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      configVal Pointer to UInt8 to hold the configuration value.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetConfigurationValue)(void *self, UInt8 *configVal);
    
    /*!
    @function GetInterfaceNumber
    @abstract   Returns the interface number (zero-based index) of this interface within the current configuration of the device.
    @discussion The interface does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      intfNumber Pointer to UInt8 to hold the interface number.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetInterfaceNumber)(void *self, UInt8 *intfNumber);
    
    /*!
    @function GetAlternateSetting
    @abstract   Returns the alternate setting currently selected in this interface.
    @discussion The interface does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      intfAltSetting Pointer to UInt8 to hold the alternate setting value.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetAlternateSetting)(void *self, UInt8 *intfAltSetting);
    
    /*!
    @function GetNumEndpoints
    @abstract   Returns the number of endpoints in this interface.
    @discussion The interface does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      intfNumEndpoints Pointer to UInt8 to hold the number of endpoints.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetNumEndpoints)(void *self, UInt8 *intfNumEndpoints);
    
    /*!
    @function GetLocationID
    @abstract   Returns the location ID.
    @discussion The location ID is a 32 bit number which is unique among all USB devices in the system, and which 
                will not change on a system reboot unless the topology of the bus itself changes.  The interface 
                does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      locationID Pointer to UInt32 to hold the location ID.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    
    /*!
    @function GetDevice
    @abstract   Returns the device of which this interface is part.
    @discussion The interface does not have to be open to use this function. The returned device can be used to 
                create a CFPlugin to talk to the device.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      device Pointer to io_service_t to hold the result.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetDevice)(void *self, io_service_t *device);
    
    /*!
    @function SetAlternateInterface
    @abstract   Changes the AltInterface setting.
    @discussion The interface must be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      alternateSetting The new alternate setting for the interface.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*SetAlternateInterface)(void *self, UInt8 alternateSetting);
    
    /*!
    @function GetBusFrameNumber
    @abstract   Gets the current frame number of the bus to which the interface and its device are attached.
    @discussion The interface does not have to be open to use this function.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      frame Pointer to UInt64 to hold the frame number.
    @param      atTime Pointer to an AbsoluteTime, which should be within 1ms of the time when the bus frame 
                number was attained.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    
    /*!
    @function ControlRequest
    @abstract   Sends a USB request on a control pipe.
    @discussion If the request is a standard request which will change the state of the device, the device must 
                be open, which means you should be using the IOUSBDeviceInterface for this command.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index of the control pipe to use. Use zero for the default control pipe on the device.
    @param      req Pointer to an IOUSBDevRequest containing the request.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
				kIOReturnAborted if the thread is interrupted before the call completes, 
                or kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*ControlRequest)(void *self, UInt8 pipeRef, IOUSBDevRequest *req);
    
    /*!
    @function ControlRequestAsync
    @abstract   Sends an asynchronous USB request on a control pipe. 
    @discussion Use pipeRef=0 for the default device control pipe.  If the request is a standard request which will 
                change the state of the device, the device must be open, which means you should be using the 
                IOUSBDeviceInterface for this command.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index of the control pipe to use. Use zero for the default control pipe on the device.
    @param      req Pointer to an IOUSBDevRequest containing the request.
	 @param     callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the number of bytes that were actually transferred.
	 			A message addressed to this callback is posted to the Async 
                port upon completion.
    @param      refCon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                kIOReturnNotOpen if the interface is not open for exclusive access, or kIOUSBNoAsyncPortErr if no 
                Async port has been created for this interface.
	*/

    IOReturn (*ControlRequestAsync)(void *self, UInt8 pipeRef, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    
    /*!
    @function GetPipeProperties
    @abstract   Gets the properties for a pipe.
    @discussion Once an interface is opened, all of the pipes in that interface get created by the kernel. The number
                of pipes can be retrieved by GetNumEndpoints. The client can then get the properties of any pipe 
                using an index of 1 to GetNumEndpoints. Pipe 0 is the default control pipe in the device.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      direction Pointer to an UInt8 to get the direction of the pipe.
    @param      number Pointer to an UInt8 to get the pipe number.
    @param      transferType Pointer to an UInt8 to get the transfer type of the pipe.
	@param      maxPacketSize Pointer to an UInt16 to get the maxPacketSize of the pipe. This maxPacketSize is the FULL maxPacketSize, which takes into account the multipler for HS Isoc pipes
				and the burst and the multiplier for SS Isoc pipes. It could also have been adjusted by SetPipePolicy.
    @param      interval Pointer to an UInt8 to get the interval for polling the pipe for data (in milliseconds).
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*GetPipeProperties)(void *self, UInt8 pipeRef, UInt8 *direction, UInt8 *number, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    
    /*!
    @function GetPipeStatus
    @abstract   Gets the current status of a pipe.
    @discussion The interface must be open for the pipe to exist.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @result     Returns kIOReturnNoDevice if there is no connection to an IOService, or kIOReturnNotOpen
                if the interface is not open for exclusive access. Otherwise, the status of the pipe is returned. 
                Returns kIOUSBPipeStalled if the pipe is stalled. See @link //apple_ref/C/instm/IOUSBInterfaceInterface/ClearPipeStall/ ClearPipeStall @/link 
                or @link //apple_ref/C/instm/IOUSBInterfaceInterface190/ClearPipeStallBothEnds/ ClearPipeStallBothEnds @/link for
                more information.
	*/

    IOReturn (*GetPipeStatus)(void *self, UInt8 pipeRef);
    
    /*!
    @function AbortPipe
    @abstract   Aborts any outstanding transactions on the pipe with status kIOReturnAborted.
    @discussion If there are outstanding asynchronous transactions on the pipe, the callbacks will happen. 
                Note that this command will also clear the halted bit on the endpoint
                in the controller, but will NOT clear the data toggle bit.  If you want to clear the data toggle bit as well, see @link //apple_ref/C/instm/IOUSBInterfaceInterface/ClearPipeStall/ ClearPipeStall @/link or 
                @link //apple_ref/C/instm/IOUSBInterfaceInterface190/ClearPipeStallBothEnds/ ClearPipeStallBothEnds @/link for more information.  The interface must be open for the pipe to exist.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the interface is not open for exclusive access.

	*/

    IOReturn (*AbortPipe)(void *self, UInt8 pipeRef);
    
    /*!
    @function ResetPipe
    @abstract   Equivalent to ClearPipeStall.
    @discussion The interface must be open for the pipe to exist.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*ResetPipe)(void *self, UInt8 pipeRef);
    
    /*!
    @function ClearPipeStall
    @abstract   Clears the halted bit and the data toggle bit on the pipe's endpoint in the controller.
    @discussion This function also returns any outstanding transactions on the pipe with status kIOUSBTransactionReturned.
                If there are outstanding asynchronous transactions on the pipe, the callbacks will happen. The data 
                toggle may need to be resynchronized. The driver may handle this by sending a ClearFeature(ENDPOINT_HALT) 
                to the default control pipe, specifying the device's endpoint for this pipe. See also 
                @link //apple_ref/C/instm/IOUSBInterfaceInterface190/ClearPipeStallBothEnds/ ClearPipeStallBothEnds @/link.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*ClearPipeStall)(void *self, UInt8 pipeRef);
    
    /*!
    @function ReadPipe
    @abstract   Reads data on a <b>BULK IN</b> or an <b>INTERRUPT</b> pipe.
    @discussion The interface must be open for the pipe to exist.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints). 
    @param      buf Buffer to hold the data.
    @param      size On entry: a pointer to the size of the buffer pointed to by buf.
                On exit: a pointer to the number of bytes actually read from the device.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*ReadPipe)(void *self, UInt8 pipeRef, void *buf, UInt32 *size);
    
    /*!
    @function WritePipe
    @abstract   Writes data on a <b>BULK OUT</b> or <b>INTERRUPT OUT</b> pipe.
    @discussion The interface must be open for the pipe to exist.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      buf Buffer to hold the data.
    @param      size The size of the data buffer.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
				kIOReturnAborted if the thread is interrupted before the call completes, 
                or kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*WritePipe)(void *self, UInt8 pipeRef, void *buf, UInt32 size);
    
    /*!
    @function ReadPipeAsync
    @abstract   Performs an asynchronous read on a <b>BULK IN</b> or an <b>INTERRUPT</b> pipe.
    @discussion The interface must be open for the pipe to exist.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      buf Buffer to hold the data.
    @param      size The size of the buffer pointed to by buf.
	@param      callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the number of bytes that were actually read.
	 			A message addressed to this callback is posted to the Async 
                port upon completion.
    @param      refcon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
				kIOReturnAborted if the thread is interrupted before the call completes, 
                or kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*ReadPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    
    /*!
    @function WritePipeAsync
    @abstract   Performs an asynchronous write on a <b>BULK OUT</b> or <b>INTERRUPT OUT</b> pipe.
    @discussion The interface must be open for the pipe to exist.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      buf Buffer to hold the data.
    @param      size The size of the buffer pointed to by buf.
    @param      callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the number of bytes that were actually written.
	 			A message addressed to this callback is posted to the Async 
                port upon completion.
    @param      refcon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*WritePipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    
    /*!
    @function ReadIsochPipeAsync
    @abstract   Performs a read on an <b>ISOCHRONOUS</b> pipe.
    @discussion The interface must be open for the pipe to exist.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      buf Buffer to hold the data.
    @param      frameStart The bus frame number on which to start the read (obtained from GetBusFrameNumber).
    @param      numFrames The number of frames for which to transfer data.
    @param      frameList A pointer to an array of IOUSBIsocFrame structures describing the frames.
    @param      callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the framelist pointer, which can be used to associate the completion with a particular request.
	 			A message addressed to this callback is posted to the Async port upon completion.
    @param      refcon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*ReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
                                  
    /*!
    @function WriteIsochPipeAsync
    @abstract   Performs an asynchronous write on an <b>ISOCHRONOUS</b> pipe.
    @discussion The interface must be open for the pipe to exist.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      buf Buffer to hold the data.
    @param      frameStart The bus frame number on which to start the write (obtained from GetBusFrameNumber).
    @param      numFrames The number of frames for which to transfer data.
    @param      frameList A pointer to an array of IOUSBIsocFrame structures describing the frames.
    @param      callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the framelist pointer, which can be used to associate the completion with a particular request.
	 			A message addressed to this callback is posted to the Async 
                port upon completion.
    @param      refcon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
                or kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*WriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
} IOUSBInterfaceInterface;





	/*!
    @interface IOUSBInterfaceInterface182
    @abstract   The object you use to access a USB device interface from user space, returned by the IOUSBFamily
                version 1.8.2 and above.
    @discussion The functions listed here include all of the functions defined for the IOUSBInterfaceInterface and
                some new functions that are available on Mac OS X version 10.0.4 and later.
    @super  IOUSBInterfaceInterface
	*/

typedef struct IOUSBInterfaceStruct182 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateInterfaceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetInterfaceAsyncEventSource)(void *self);
    IOReturn (*CreateInterfaceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetInterfaceAsyncPort)(void *self);
    IOReturn (*USBInterfaceOpen)(void *self);
    IOReturn (*USBInterfaceClose)(void *self);
    IOReturn (*GetInterfaceClass)(void *self, UInt8 *intfClass);
    IOReturn (*GetInterfaceSubClass)(void *self, UInt8 *intfSubClass);
    IOReturn (*GetInterfaceProtocol)(void *self, UInt8 *intfProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetConfigurationValue)(void *self, UInt8 *configVal);
    IOReturn (*GetInterfaceNumber)(void *self, UInt8 *intfNumber);
    IOReturn (*GetAlternateSetting)(void *self, UInt8 *intfAltSetting);
    IOReturn (*GetNumEndpoints)(void *self, UInt8 *intfNumEndpoints);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetDevice)(void *self, io_service_t *device);
    IOReturn (*SetAlternateInterface)(void *self, UInt8 alternateSetting);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ControlRequest)(void *self, UInt8 pipeRef, IOUSBDevRequest *req);
    IOReturn (*ControlRequestAsync)(void *self, UInt8 pipeRef, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*GetPipeProperties)(void *self, UInt8 pipeRef, UInt8 *direction, UInt8 *number, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*GetPipeStatus)(void *self, UInt8 pipeRef);
    IOReturn (*AbortPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ResetPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ClearPipeStall)(void *self, UInt8 pipeRef);
    IOReturn (*ReadPipe)(void *self, UInt8 pipeRef, void *buf, UInt32 *size);
    IOReturn (*WritePipe)(void *self, UInt8 pipeRef, void *buf, UInt32 size);
    IOReturn (*ReadPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
                                  
    /*!
    @function ControlRequestTO
    @abstract   Sends a USB request on a control pipe.
    @discussion The IOUSBDevRequestTO structure allows the client to specify timeout values for this request.  If 
                the request is a standard request which will change the state of the device, the device must be open,
                which means you should be using the IOUSBDeviceInterface for this command.
    @availability This function is only available with IOUSBInterfaceInterface182 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index of the control pipe to use. Use zero for the default control pipe on the device.
    @param      req Pointer to an IOUSBDevRequestTO containing the request.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or
				kIOReturnAborted if the thread is interrupted before the call completes, 
                kIOReturnNotOpen if the interface is not open for exclusive access.
	*/
                              
    IOReturn (*ControlRequestTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req);
    
    /*!
    @function ControlRequestAsyncTO
    @abstract   Sends an asynchronous USB request on a control pipe.
    @discussion The IOUSBDevRequestTO structure allows the client to specify timeout values for this request. Use 
                pipeRef=0 for the default device control pipe.  If the request is a standard request which will 
                change the state of the device, the device must be open, which means you should be using the 
                IOUSBDeviceInterface for this command.
    @availability This function is only available with IOUSBInterfaceInterface182 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index of the control pipe to use. Use zero for the default control pipe on the device.
    @param      req Pointer to an IOUSBDevRequestTO containing the request.
    @param      callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the number of bytes that were actually transferred.
	 			A message addressed to this callback is posted to the Async 
                port upon completion.
    @param      refCon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or
                kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*ControlRequestAsyncTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    
    /*!
    @function ReadPipeTO
    @abstract   Performs a read on a <b>BULK IN</b> pipe, specifying timeout values.
    @discussion The interface must be open for the pipe to exist.
    
                If a timeout is specified and the request times out, the driver may need to resynchronize the data 
                toggle. See @link //apple_ref/C/instm/IOUSBInterfaceInterface/ClearPipeStall/ ClearPipeStall @/link 
                or @link //apple_ref/C/instm/IOUSBInterfaceInterface190/ClearPipeStallBothEnds/ ClearPipeStallBothEnds @/link.
                
                
		Timeouts do not apply to interrupt pipes, so you should use the ReadPipe API to perform a read from 
                an interrupt pipe.
    @availability This function is only available with IOUSBInterfaceInterface182 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      buf Buffer to hold the data.
    @param      size Pointer to the size of the buffer pointed to by buf.
    @param      noDataTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if no 
                data is transferred in this amount of time, the request will be aborted and returned.
    @param      completionTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if 
                the entire request is not completed in this amount of time, the request will be aborted and returned.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
				kIOReturnAborted if the thread is interrupted before the call completes, or
                kIOReturnNotOpen if the interface is not open for exclusive access.  Returns kIOReturnBadArgument if timeout 
                values are specified for an interrupt pipe.  If an error is returned, the size parameter is not updated and the buffer will
				NOT contain any valid data.
	*/

    IOReturn (*ReadPipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 *size, UInt32 noDataTimeout, UInt32 completionTimeout);
    
    /*!
    @function WritePipeTO
    @abstract   Performs a write on a <b>BULK OUT</b> pipe, with specified timeout values.
    @discussion The interface must be open for the pipe to exist.
    
                If a timeout is specified and the request times out, the driver may need to resynchronize the data 
                toggle. See @link //apple_ref/C/instm/IOUSBInterfaceInterface/ClearPipeStall/ ClearPipeStall @/link 
                or @link //apple_ref/C/instm/IOUSBInterfaceInterface190/ClearPipeStallBothEnds/ ClearPipeStallBothEnds @/link.
    @availability This function is only available with IOUSBInterfaceInterface182 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      buf Buffer to hold the data.
    @param      size The size of the buffer pointed to by buf.
    @param      noDataTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if no 
                data is transferred in this amount of time, the request will be aborted and returned.
    @param      completionTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if 
                the entire request is not completed in this amount of time, the request will be aborted and returned.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService,
				kIOReturnAborted if the thread is interrupted before the call completes, or
                kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*WritePipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout);
    
    /*!
    @function ReadPipeAsyncTO
    @abstract   Performs an asynchronous read on a <b>BULK IN </b>pipe, with specified timeout values.
    @discussion The interface must be open for the pipe to exist.
    
                If a timeout is specified and the request times out, the driver may need to resynchronize the data 
                toggle. See @link //apple_ref/C/instm/IOUSBInterfaceInterface/ClearPipeStall/ ClearPipeStall @/link 
                or @link //apple_ref/C/instm/IOUSBInterfaceInterface190/ClearPipeStallBothEnds/ ClearPipeStallBothEnds @/link.
                
                Timeouts do not apply to interrupt pipes, so you should use the ReadPipeAsync API to perform an 
                asynchronous read from an interrupt pipe.
    @availability This function is only available with IOUSBInterfaceInterface182 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      buf Buffer to hold the data.
    @param      size The size of the buffer pointed to by buf.
    @param      noDataTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if no 
                data is transferred in this amount of time, the request will be aborted and returned.
    @param      completionTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if 
                the entire request is not completed in this amount of time, the request will be aborted and returned.
    @param      callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the number of bytes that were actually read.
	 			A message addressed to this callback is posted to the Async port 
                upon completion.
    @param      refcon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or
                kIOReturnNotOpen if the interface is not open for exclusive access.  Returns kIOReturnBadArgument if timeout 
	 values are specified for an interrupt pipe.  If an error is returned, the size parameter is not updated and the buffer will
	 NOT contain any valid data.
	*/

    IOReturn (*ReadPipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    
    /*!
    @function WritePipeAsyncTO
    @abstract   Performs an asynchronous write on a <b>BULK OUT</b> pipe, with specified timeout values.
    @discussion The interface must be open for the pipe to exist.
    
                If a timeout is specified and the request times out, the driver may need to resynchronize the data 
                toggle. See @link //apple_ref/C/instm/IOUSBInterfaceInterface/ClearPipeStall/ ClearPipeStall @/link 
                or @link //apple_ref/C/instm/IOUSBInterfaceInterface190/ClearPipeStallBothEnds/ ClearPipeStallBothEnds @/link.
    @availability This function is only available with IOUSBInterfaceInterface182 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      buf Buffer to hold the data.
    @param      size The size of the buffer pointed to by buf.
    @param      noDataTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if no 
                data is transferred in this amount of time, the request will be aborted and returned.
    @param      completionTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if 
                the entire request is not completed in this amount of time, the request will be aborted and returned.
    @param      callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the number of bytes that were actually written.
	   			A message addressed to this callback is posted to the Async port 
                upon completion.
    @param      refcon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or
                kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*WritePipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    
    /*!
    @function USBInterfaceGetStringIndex
    @abstract   Returns the string index in the interface descriptor.
    @discussion The interface does not have to be open to use this function.
    @availability This function is only available with IOUSBInterfaceInterface182 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      si Pointer to UInt8 to hold the string index.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*USBInterfaceGetStringIndex)(void *self, UInt8 *si);
} IOUSBInterfaceInterface182;






	/*!
    @interface IOUSBInterfaceInterface183
    @abstract   The object you use to access a USB device interface from user space, returned by the IOUSBFamily
                version 1.8.3 and above.
    @discussion The functions listed here include all of the functions defined for the IOUSBInterfaceInterface, 
                IOUSBInterfaceInterface182, and some new functions that are available on Mac OS X version 10.1 
                and later.
    @super IOUSBInterfaceInterface182
	*/

typedef struct IOUSBInterfaceStruct183 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateInterfaceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetInterfaceAsyncEventSource)(void *self);
    IOReturn (*CreateInterfaceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetInterfaceAsyncPort)(void *self);
    IOReturn (*USBInterfaceOpen)(void *self);
    IOReturn (*USBInterfaceClose)(void *self);
    IOReturn (*GetInterfaceClass)(void *self, UInt8 *intfClass);
    IOReturn (*GetInterfaceSubClass)(void *self, UInt8 *intfSubClass);
    IOReturn (*GetInterfaceProtocol)(void *self, UInt8 *intfProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetConfigurationValue)(void *self, UInt8 *configVal);
    IOReturn (*GetInterfaceNumber)(void *self, UInt8 *intfNumber);
    IOReturn (*GetAlternateSetting)(void *self, UInt8 *intfAltSetting);
    IOReturn (*GetNumEndpoints)(void *self, UInt8 *intfNumEndpoints);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetDevice)(void *self, io_service_t *device);
    IOReturn (*SetAlternateInterface)(void *self, UInt8 alternateSetting);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ControlRequest)(void *self, UInt8 pipeRef, IOUSBDevRequest *req);
    IOReturn (*ControlRequestAsync)(void *self, UInt8 pipeRef, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*GetPipeProperties)(void *self, UInt8 pipeRef, UInt8 *direction, UInt8 *number, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*GetPipeStatus)(void *self, UInt8 pipeRef);
    IOReturn (*AbortPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ResetPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ClearPipeStall)(void *self, UInt8 pipeRef);
    IOReturn (*ReadPipe)(void *self, UInt8 pipeRef, void *buf, UInt32 *size);
    IOReturn (*WritePipe)(void *self, UInt8 pipeRef, void *buf, UInt32 size);
    IOReturn (*ReadPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ControlRequestTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req);
    IOReturn (*ControlRequestAsyncTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*ReadPipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 *size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*WritePipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*ReadPipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*USBInterfaceGetStringIndex)(void *self, UInt8 *si);
    
    /*!
    @function USBInterfaceOpenSeize
    @abstract   Opens the IOUSBInterface for exclusive access.
    @discussion If another client has the device open, an attempt is made to get that client to close it before 
                returning.
                
                Before the client can issue commands that change the state of the device, it must have succeeded 
                in opening the device. This establishes an exclusive link between the clients task and the actual 
                device.
    @availability This function is only available with IOUSBInterfaceInterface183 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @result     Returns kIOReturnExclusiveAccess if some other task has the interface open already and refuses to 
                close it, kIOReturnError if the connection with the kernel cannot be established or kIOReturnSuccess
                if successful.
	*/

    IOReturn (*USBInterfaceOpenSeize)(void *self);
} IOUSBInterfaceInterface183;






	/*!
    @interface IOUSBInterfaceInterface190
    @abstract   The object you use to access a USB device interface from user space, returned by the IOUSBFamily
                version 1.9 and above.
    @discussion The functions listed here include all of the functions defined for the IOUSBInterfaceInterface, 
                IOUSBInterfaceInterface182, IOUSBInterfaceInterface183, and some new functions that are available 
                on Mac OS X version 10.2 and later.
    @super IOUSBInterfaceInterface183
	*/

typedef struct IOUSBInterfaceStruct190 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateInterfaceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetInterfaceAsyncEventSource)(void *self);
    IOReturn (*CreateInterfaceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetInterfaceAsyncPort)(void *self);
    IOReturn (*USBInterfaceOpen)(void *self);
    IOReturn (*USBInterfaceClose)(void *self);
    IOReturn (*GetInterfaceClass)(void *self, UInt8 *intfClass);
    IOReturn (*GetInterfaceSubClass)(void *self, UInt8 *intfSubClass);
    IOReturn (*GetInterfaceProtocol)(void *self, UInt8 *intfProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetConfigurationValue)(void *self, UInt8 *configVal);
    IOReturn (*GetInterfaceNumber)(void *self, UInt8 *intfNumber);
    IOReturn (*GetAlternateSetting)(void *self, UInt8 *intfAltSetting);
    IOReturn (*GetNumEndpoints)(void *self, UInt8 *intfNumEndpoints);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetDevice)(void *self, io_service_t *device);
    IOReturn (*SetAlternateInterface)(void *self, UInt8 alternateSetting);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ControlRequest)(void *self, UInt8 pipeRef, IOUSBDevRequest *req);
    IOReturn (*ControlRequestAsync)(void *self, UInt8 pipeRef, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*GetPipeProperties)(void *self, UInt8 pipeRef, UInt8 *direction, UInt8 *number, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*GetPipeStatus)(void *self, UInt8 pipeRef);
    IOReturn (*AbortPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ResetPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ClearPipeStall)(void *self, UInt8 pipeRef);
    IOReturn (*ReadPipe)(void *self, UInt8 pipeRef, void *buf, UInt32 *size);
    IOReturn (*WritePipe)(void *self, UInt8 pipeRef, void *buf, UInt32 size);
    IOReturn (*ReadPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ControlRequestTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req);
    IOReturn (*ControlRequestAsyncTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*ReadPipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 *size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*WritePipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*ReadPipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*USBInterfaceGetStringIndex)(void *self, UInt8 *si);
    IOReturn (*USBInterfaceOpenSeize)(void *self);
    
    /*!
    @function ClearPipeStallBothEnds
    @abstract   Equivalent to ClearPipeStall.
    @discussion This function is equivalent to ClearPipeStall except that it also attempts to clear the halt and
                toggle bits on the device's endpoint for the pipe by sending a ClearFeature(ENDPOINT_HALT) to the 
                default control pipe in the device, specifying the endpoint for the pipe represented by pipeRef. For
                most devices, this resynchronizes the data toggle between the two endpoints to ensure that there is 
                no loss of data.
    @availability This function is only available with IOUSBInterfaceInterface190 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or
                kIOReturnNotOpen if the interface is not open for exclusive access.
	*/

    IOReturn (*ClearPipeStallBothEnds)(void *self, UInt8 pipeRef);
    
    /*!
    @function SetPipePolicy
    @abstract   Changes the amount of bandwidth of an isochronous pipe or interrupt pipe, or the polling interval of an interrupt pipe.
    @discussion A pipe may be made smaller or larger (up to the maxPacketSize specified in the endpoint descriptor).
                When an interface is first opened, all pipes are created with their descriptor-supplied maxPacketSize.
                For isochronous or interrupt pipes, if there is not enough bandwidth on the bus to allocate to the pipe, the pipe
                is created with a reserved bandwidth of zero. Any attempts to transfer data on a pipe with zero 
                bandwidth will result in a kIOReturnNoBandwidth error. The pipe must first be given some bandwidth 
                using this call.  This can also be used to return bandwidth for an isochronous or an interrupt pipe.  If the driver
				knows that the device will not be sending the maxPacketSize data, it can use this call to return that unused bandwidth to the
				system.  If an interrupt pipe wants to change the polling interval, it can do so with this call.
                
                The interface must be open for the pipe to exist.
     
    @availability This function is only available with IOUSBInterfaceInterface190 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      maxPacketSize The desired size for the isochronous or interrupt pipe. For Full Speed endpoints and High Speed endpoints which 
                are not High Bandwidth (i.e. only a single packet is transferred in a microframe), valid values are 0 through the maxPacketSize
                defined in the endpoint descriptor. For High Speed High Bandwidth (i.e. 2 or 3 packets transferred in a microframe) and Super Speed endpoints,
                valid values are 0 and the maxPacketSize of the endpoint. The maxPacketSize of the endpoint is calculated as the base maxPacketSize
                multiplies by the burst size and the multiplier. See the USB 2.0 and the USB 3.0 specifications for more detail. Using a value of 0 for maxPacketSize
                maintains the handle for the pipe but unreserves any bandwidth on the bus.
	@param      maxInterval  applies only to interrupt endpoints. maxInterval has the same value as the bInterval field of the endpoint.
                For Low Speed and Full Speed interrupt endpoints, it is the desired polling interval in milliseconds, up to a maximum of 128 ms.
                The system can only poll devices powers of 2 (1, 2, 4, 8, 16, 32, 64, or 128 ms).
                For High Speed and Super Speed endpoints, maxInterval is used as an exponent for a (2 ^ (maxInterval-1)) value representing the number
                of 125uS microframes between service intervals. See the USB 2.0 and the USB 3.0 specifications for more info. The lower layers may 
                schedule the endpoint for service at an interval value equal to or less than the value specified. A value of 0 is illegal.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or
                kIOReturnNotOpen if the interface is not open for exclusive access.  May also return kIOReturnNoBandwidth 
                if there is not enough bandwidth available on the bus, or kIOReturnBadArgument if the desired 
                maxPacketSize is outside of the allowed range.
	*/

    IOReturn (*SetPipePolicy)(void *self, UInt8 pipeRef, UInt16 maxPacketSize, UInt8 maxInterval);
    
    /*!
    @function GetBandwidthAvailable
    @abstract   Returns the amount of bandwidth available on the bus for allocation to 
                isochronous pipes.  If the device is a high speed device, it will be the number of bytes per microframe (125 secs). If it is a full
				speed device, it will be the number of bytes per frame (1ms)
    @discussion This function is useful for determining the correct AltInterface setting as well as for using 
                SetPipePolicy.
                
                The interface does not have to be open to use this function.
    @availability This function is only available with IOUSBInterfaceInterface190 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      bandwidth Pointer to UInt32 to hold the amount of bandwidth available (in bytes per 1ms frame).
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetBandwidthAvailable)(void *self, UInt32 *bandwidth);
    
    /*!
    @function GetEndpointProperties
    @abstract   Returns the transfer type, max packet size, and interval of a specified endpoint, whether or not 
                the endpoint has a pipe currently established.
    @discussion This function may be useful for determining which alternate interface to select when trying to 
                balance bandwidth allocations among isochronous pipes.
                
                The interface does not have to be open to use this function.
    @availability This function is only available with IOUSBInterfaceInterface190 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      alternateSetting Specifies the alternate setting within the current interface.
    @param      endpointNumber Specifies the desired endpoint number.
    @param      direction Specifies the desired direction.
    @param      transferType Pointer to UInt8 to hold the endpoint's transfer type (kUSBControl, kUSBIsoc, etc).
    @param      maxPacketSize Pointer to UInt16 to hold the maxPacketSize of the endpoint.
    @param      interval Pointer to UInt8 to hold the polling interval for interrupt endpoints.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetEndpointProperties)(void *self, UInt8 alternateSetting, UInt8 endpointNumber, UInt8 direction, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
} IOUSBInterfaceInterface190;





	/*!
    @interface IOUSBInterfaceInterface192
    @abstract   The object you use to access a USB device interface from user space, returned by the IOUSBFamily
                version 1.9.2 and above.
    @discussion The functions listed here include all of the functions defined for the IOUSBInterfaceInterface, 
                IOUSBInterfaceInterface182, IOUSBInterfaceInterface183, IOUSBInterfaceInterface190, and some new 
                functions that are available on Mac OS X version 10.2.3 and later.
    @super IOUSBInterfaceInterface190
	*/

typedef struct IOUSBInterfaceStruct192 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateInterfaceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetInterfaceAsyncEventSource)(void *self);
    IOReturn (*CreateInterfaceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetInterfaceAsyncPort)(void *self);
    IOReturn (*USBInterfaceOpen)(void *self);
    IOReturn (*USBInterfaceClose)(void *self);
    IOReturn (*GetInterfaceClass)(void *self, UInt8 *intfClass);
    IOReturn (*GetInterfaceSubClass)(void *self, UInt8 *intfSubClass);
    IOReturn (*GetInterfaceProtocol)(void *self, UInt8 *intfProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetConfigurationValue)(void *self, UInt8 *configVal);
    IOReturn (*GetInterfaceNumber)(void *self, UInt8 *intfNumber);
    IOReturn (*GetAlternateSetting)(void *self, UInt8 *intfAltSetting);
    IOReturn (*GetNumEndpoints)(void *self, UInt8 *intfNumEndpoints);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetDevice)(void *self, io_service_t *device);
    IOReturn (*SetAlternateInterface)(void *self, UInt8 alternateSetting);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ControlRequest)(void *self, UInt8 pipeRef, IOUSBDevRequest *req);
    IOReturn (*ControlRequestAsync)(void *self, UInt8 pipeRef, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*GetPipeProperties)(void *self, UInt8 pipeRef, UInt8 *direction, UInt8 *number, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*GetPipeStatus)(void *self, UInt8 pipeRef);
    IOReturn (*AbortPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ResetPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ClearPipeStall)(void *self, UInt8 pipeRef);
    IOReturn (*ReadPipe)(void *self, UInt8 pipeRef, void *buf, UInt32 *size);
    IOReturn (*WritePipe)(void *self, UInt8 pipeRef, void *buf, UInt32 size);
    IOReturn (*ReadPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ControlRequestTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req);
    IOReturn (*ControlRequestAsyncTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*ReadPipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 *size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*WritePipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*ReadPipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*USBInterfaceGetStringIndex)(void *self, UInt8 *si);
    IOReturn (*USBInterfaceOpenSeize)(void *self);
    IOReturn (*ClearPipeStallBothEnds)(void *self, UInt8 pipeRef);
 	IOReturn (*SetPipePolicy)(void *self, UInt8 pipeRef, UInt16 maxPacketSize, UInt8 maxInterval);
 	IOReturn (*GetBandwidthAvailable)(void *self, UInt32 *bandwidth);
 	IOReturn (*GetEndpointProperties)(void *self, UInt8 alternateSetting, UInt8 endpointNumber, UInt8 direction, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);

    /*!
    @function LowLatencyReadIsochPipeAsync
    @abstract   Performs an asynchronous read on a isochronous pipe and updates the frame list at primary interrupt time.
    @discussion The LowLatencyReadIsochPipeAsync() and LowLatencyWriteIsochPipeAsync() 
                calls are analogous to ReadIsochPipeAsync() and WriteIsochPipeAsync(). They differ in that the frame
                list data is updated at <em>primary interrupt time</em>. This means that the client can inspect the
                frStatus and frActCount fields as soon as the transaction completes, without having to wait for the 
                callback to happen (depending on the value of updateFrequency). The callback will still happen when 
                all the frames have been received.
                
                The client can specify how often the USB stack should update the frame list data by specifying the 
                updateFrequency: this value can range from 0 - 8. If the value is between 1 and 8, the 
                frame list will be updated every updateFrequency milliseconds. If the value is 0, the 
                frame list will only be updated once all the frames in the transfer have been received. For example,
                consider a transfer with numFrames equal to 64. If the update frequency is 4, the frame 
                list data will be updated every 4 milliseconds. If the update frequency is 0, the frame list will 
                only be updated at the end of the transfer, after the 64 frames have been sent or received. The 
                difference between using an update frequency of 0 and using the non-low latency isoch calls is that 
                in the former case, the frame list will be updated at primary interrupt time, while in the latter, 
                it will be updated at secondary interrupt time. Regardless of the value of updateFrequency, 
                the frame list will <em>always</em> be updated on the last frame of a transfer.
                
                The rationale for adding this call is that because completion routines run on the USB Workloop, they 
                can be scheduled to run a number of milliseconds after the USB transfer has finished. This latency 
                is variable and depends on what other higher priority threads are running on the system. This latency 
                presents a problem for applications, such as audio processing, that depend on receiving data, 
                processing it, and sending it back out, and need to do this as fast as possible. Since applications 
                that use isochronous data know when the data should be available, they can look at the frame list at 
                the expected time and note the frActCount and frStatus (and frTimeStamp
                if needed) and determine how many valid bytes are in their data buffer and whether there was an 
                error. They can then access their data buffer and process the actual data.
                
                In order to update the frame list at primary interrupt time and to allow the client to see that 
                update, the frame list buffer needs to be shared between the kernel and user space. The same thing 
                applies to the data buffer. This is a difference between the low latency isoch calls and the regular 
                isoch calls. The LowLatencyCreateBuffer() call is used to pre-allocate the buffers. The 
                client <em>must</em> use that call to allocate the data and the frame list buffers. The client can 
                pass a portion of the buffer that was previously allocated. The USB stack will range-check the data 
                and frame list buffers to make sure they are within the ranges of the buffers previously allocated. 
                This allows the client, if it so desires, to allocate a large data buffer and pass portions of it to 
                the read or write calls. The same applies to the frame list buffers. Of course, the client can also 
                pre-allocate several data buffers and several frame list buffers and use those for each transfer. 
                Once the transfer completes, the buffers can be reused in subsequent calls. When all transfers are 
                finished, the client needs to call LowLatencyDestroyBuffer() for each buffer that was 
                created with LowLatencyCreateBuffer().
                
                The interface must be open for the pipe to exist. The buf pointer and the frameList 
                pointer need to be pre-allocated using LowLatencyCreateBuffer(). 
                After using them, they should be freed using LowLatencyDestroyBuffer().
    @availability This function is only available with IOUSBInterfaceInterface192 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      buf Buffer to hold the data, previously allocated with LowLatencyCreateBuffer() 
                using a kUSBLowLatencyReadBuffer type.
    @param      frameStart The bus frame number on which to start the read (obtained from GetBusFrameNumber).
    @param      numFrames The number of frames for which to transfer data.
    @param      updateFrequency Specifies how often, in milliseconds, the frame list data should be updated. Valid 
                range is 0 - 8. If 0, it means that the framelist should be updated at the end of the transfer.
    @param      frameList A pointer to an array of IOUSBLowLatencyIsocFrame structures describing the frames.
    @param      callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the framelist pointer, which can be used to associate the completion with a particular request.
	 			A message addressed to this callback is posted to 
                the Async port upon completion.
    @param      refcon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or
                kIOReturnNotOpen if the interface is not open for exclusive access.  Will return kIOUSBLowLatencyBufferNotPreviouslyAllocated 
                or kIOUSBLowLatencyFrameListNotPreviouslyAllocated if the buffer or the frameList were 
                not previously allocated using LowLatencyCreateBuffer().
	*/

    IOReturn (*LowLatencyReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, UInt32 updateFrequency, IOUSBLowLatencyIsocFrame *frameList,
                                         IOAsyncCallback1 callback, void *refcon);
                                         
	/*!
    @function LowLatencyWriteIsochPipeAsync
    @abstract   Performs an asynchronous write on an isochronous pipe and updates the frame list at primary interrupt time.
    @discussion The LowLatencyReadIsochPipeAsync() and LowLatencyWriteIsochPipeAsync() 
                calls are analogous to ReadIsochPipeAsync() and WriteIsochPipeAsync(). 
                They differ in that the frame list data is updated at <em>primary interrupt time</em>. This means that 
                the client can inspect the frStatus and frActCount fields as soon as the 
                transaction completes, without having to wait for the callback to happen (depending on the value of 
                updateFrequency). The callback will still happen when the all the frames have been received.
                
                The client can specify how often the USB stack should update the frame list data by specifying the 
                updateFrequency: this value can range from 0 - 8. If the value is between 1 and 8, the 
                frame list will be updated every updateFrequency milliseconds. If the value is 0, the 
                frame list will only be updated once all the frames in the transfer have been received. For example, 
                consider a transfer with numFrames equal to 64. If the update frequency is 4, the frame 
                list data will be updated every 4 milliseconds. If the update frequency is 0, the frame list will 
                only be updated at the end of the transfer, after the 64 frames have been sent or received. The 
                difference between using an update frequency of 0 and using the non-low latency isoch calls is that 
                in the former case, the frame list will be updated at primary interrupt time, while in the latter, 
                it will be updated at secondary interrupt time. Regardless of the value of updateFrequency, 
                the frame list will <em>always</em> be updated on the last frame of a transfer.
                
                The rationale for adding this call is that because completion routines run on the USB Workloop, 
                they can be scheduled to run a number of milliseconds after the USB transfer has finished. This 
                latency is variable and depends on what other higher priority threads are running on the system. 
                This latency presents a problem for applications, such as audio processing, that depend on receiving 
                data, processing it, and sending it back out, and need to do this as fast as possible. Since applications 
                that use isochronous data know when the data should be available, they can look at the frame list at 
                the expected time and note the frActCount and frStatus (and frTimeStamp 
                if needed) and determine how many valid bytes are in their data buffer and whether there was an error. 
                They can then access their data buffer and process the actual data.
                
                In order to update the frame list at primary interrupt time and to allow the client to see that 
                update, the frame list buffer needs to be shared between the kernel and user space. The same thing 
                applies to the data buffer. This is a difference between the low latency isoch calls and the regular 
                isoch calls. The LowLatencyCreateBuffer() call is used to pre-allocate the buffers. The 
                <em>client</em> must use that call to allocate the data and the frame list buffers. The client can 
                pass a portion of the buffer that was previously allocated. The USB stack will range-check the data 
                and frame list buffers to make sure they are within the ranges of the buffers previously allocated. 
                This allows the client, if it so desires, to allocate a large data buffer and pass portions of it to 
                the read or write calls. The same applies to the frame list buffers. Of course, the client can also 
                pre-allocate several data buffers and several frame list buffers and use those for each transfer. 
                Once the transfer completes, the buffers can be reused in subsequent calls. When all transfers are 
                finished, the client needs to call LowLatencyDestroyBuffer() for each buffer that was 
                created with LowLatencyCreateBuffer().
                
                 The interface must be open for the pipe to exist. The buf pointer and the frameList 
                pointer need to be pre-allocated using LowLatencyCreateBuffer(). After using them, they 
                should be freed using LowLatencyDestroyBuffer().
    @availability This function is only available with IOUSBInterfaceInterface192 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      pipeRef Index for the desired pipe (1 - GetNumEndpoints).
    @param      buf Buffer to hold the data, previously allocated with LowLatencyCreateBuffer() 
                using a kUSBLowLatencyWriteBuffer type.
    @param      frameStart The bus frame number on which to start the write (obtained from GetBusFrameNumber).
    @param      numFrames The number of frames for which to transfer data.
    @param      updateFrequency Specifies how often, in milliseconds, should the frame list data be updated. Valid 
                range is 0 - 8. If 0, it means that the framelist should be updated at the end of the transfer.
    @param      frameList A pointer to an array of IOUSBLowLatencyIsocFrame structures describing the frames.
    @param      callback An IOAsyncCallback1 method. Upon completion, the arg0 argument of the AsyncCallback1 will contain the framelist pointer, which can be used to associate the completion with a particular request.
	 			A message addressed to this callback is posted to 
                the Async port upon completion.
    @param      refcon Arbitrary pointer which is passed as a parameter to the callback routine.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or
                kIOReturnNotOpen if the interface is not open for exclusive access.  Will return kIOUSBLowLatencyBufferNotPreviouslyAllocated 
                or kIOUSBLowLatencyFrameListNotPreviouslyAllocated if the buffer or the frameList were 
                not previously allocated using LowLatencyCreateBuffer().
	*/

    IOReturn (*LowLatencyWriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, UInt32 updateFrequency, IOUSBLowLatencyIsocFrame *frameList,
                                          IOAsyncCallback1 callback, void *refcon);
                                          
	/*!
    @function LowLatencyCreateBuffer
    @abstract   Allocates a buffer of type bufferType.
    @discussion This function allocates a buffer of type bufferType. The buffer can then be used with 
                the LowLatencyIsochReadPipeAsync() or LowLatencyIsochWritePipeAsync() calls.
                
                The LowLatencyIsochReadPipeAsync() or LowLatencyIsochWritePipeAsync() calls 
                require the clients to pre-allocate the data buffer and the frame list buffer parameters. This call 
                is used to allocate those buffers. After the client is done using the buffers, they need to be 
                released through the LowLatencyDestroyBuffer() call.
                
                If the buffer is to be used for reading data, the type passed in should be kUSBLowLatencyReadBuffer.
                If the buffer is to be used for writing data, the type should be kUSBLowLatencyWriteBuffer. For
                frame list data, the type should be kUSBLowLatencyFrameListBuffer.
                
                The client can create multiple data and frame list buffers, or it can allocate a large buffer and 
                then use only a portion of the buffer in calls to LowLatencyReadIsochPipeAsync() 
                or LowLatencyWriteIsochPipeAsync().
                
                The interface must be open for the pipe to exist.
    @availability This function is only available with IOUSBInterfaceInterface192 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      buffer Pointer to a pointer that will receive the pointer to the buffer created by this call.
    @param      size The size of the buffer to be created in bytes.
    @param      bufferType Type of buffer: one of kUSBLowLatencyWriteBuffer, kUSBLowLatencyReadBuffer, 
                or kUSBLowLatencyFrameListBuffer. See the documentation for USB.h.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or
                kIOReturnNotOpen if the interface is not open for exclusive access.  If the buffer can't be allocated, 
                it will return kIOReturnNoMemory.
	*/

    IOReturn (*LowLatencyCreateBuffer)(void * self, void **buffer, IOByteCount size, UInt32 bufferType);
    
    /*!
    @function LowLatencyDestroyBuffer
    @abstract   Releases a buffer that was previously allocated using LowLatencyCreateBuffer().
    @discussion The interface must be open for the pipe to exist.
    @availability This function is only available with IOUSBInterfaceInterface192 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      buffer Pointer to the buffer previously allocated using LowLatencyCreateBuffer().
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or
                kIOReturnNotOpen if the interface is not open for exclusive access.  If the buffer was not previously 
                allocated using LowLatencyCreateBuffer() it will return kIOReturnBadArgument. 
	*/

    IOReturn (*LowLatencyDestroyBuffer) (void * self, void * buffer );
} IOUSBInterfaceInterface192;






	/*!
    @interface IOUSBInterfaceInterface197
    @abstract   The object you use to access a USB device interface from user space, returned by the IOUSBFamily
                version 1.9.7 and above.
    @discussion The functions listed here include all of the functions defined for the IOUSBInterfaceInterface, 
                IOUSBInterfaceInterface182, IOUSBInterfaceInterface183, IOUSBInterfaceInterface190, IOUSBInterfaceInterface192, 
                and some new functions that are available on Mac OS X version 10.2.5 and later.
    @super IOUSBInterfaceInterface192
	*/

typedef struct IOUSBInterfaceStruct197 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateInterfaceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetInterfaceAsyncEventSource)(void *self);
    IOReturn (*CreateInterfaceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetInterfaceAsyncPort)(void *self);
    IOReturn (*USBInterfaceOpen)(void *self);
    IOReturn (*USBInterfaceClose)(void *self);
    IOReturn (*GetInterfaceClass)(void *self, UInt8 *intfClass);
    IOReturn (*GetInterfaceSubClass)(void *self, UInt8 *intfSubClass);
    IOReturn (*GetInterfaceProtocol)(void *self, UInt8 *intfProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetConfigurationValue)(void *self, UInt8 *configVal);
    IOReturn (*GetInterfaceNumber)(void *self, UInt8 *intfNumber);
    IOReturn (*GetAlternateSetting)(void *self, UInt8 *intfAltSetting);
    IOReturn (*GetNumEndpoints)(void *self, UInt8 *intfNumEndpoints);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetDevice)(void *self, io_service_t *device);
    IOReturn (*SetAlternateInterface)(void *self, UInt8 alternateSetting);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ControlRequest)(void *self, UInt8 pipeRef, IOUSBDevRequest *req);
    IOReturn (*ControlRequestAsync)(void *self, UInt8 pipeRef, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*GetPipeProperties)(void *self, UInt8 pipeRef, UInt8 *direction, UInt8 *number, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*GetPipeStatus)(void *self, UInt8 pipeRef);
    IOReturn (*AbortPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ResetPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ClearPipeStall)(void *self, UInt8 pipeRef);
    IOReturn (*ReadPipe)(void *self, UInt8 pipeRef, void *buf, UInt32 *size);
    IOReturn (*WritePipe)(void *self, UInt8 pipeRef, void *buf, UInt32 size);
    IOReturn (*ReadPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                  IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ControlRequestTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req);
    IOReturn (*ControlRequestAsyncTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*ReadPipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 *size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*WritePipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*ReadPipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*USBInterfaceGetStringIndex)(void *self, UInt8 *si);
    IOReturn (*USBInterfaceOpenSeize)(void *self);
    IOReturn (*ClearPipeStallBothEnds)(void *self, UInt8 pipeRef);
 	IOReturn (*SetPipePolicy)(void *self, UInt8 pipeRef, UInt16 maxPacketSize, UInt8 maxInterval);
 	IOReturn (*GetBandwidthAvailable)(void *self, UInt32 *bandwidth);
 	IOReturn (*GetEndpointProperties)(void *self, UInt8 alternateSetting, UInt8 endpointNumber, UInt8 direction, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*LowLatencyReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, UInt32 updateFrequency, IOUSBLowLatencyIsocFrame *frameList,
                                         IOAsyncCallback1 callback, void *refcon);
    IOReturn (*LowLatencyWriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, UInt32 updateFrequency, IOUSBLowLatencyIsocFrame *frameList,
                                          IOAsyncCallback1 callback, void *refcon);
    IOReturn (*LowLatencyCreateBuffer)(void * self, void **buffer, IOByteCount size, UInt32 bufferType);
    IOReturn (*LowLatencyDestroyBuffer) (void * self, void * buffer );

    /*!
    @function GetBusMicroFrameNumber
    @abstract   Gets the current micro frame number of the bus to which the interface and its device are attached.
    @discussion The interface does not have to be open to use this function.
    @availability This function is only available with IOUSBInterfaceInterface197 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      microFrame Pointer to UInt64 to hold the microrame number.
    @param      atTime Pointer to an AbsoluteTime, which should be within 1ms of the time when the bus frame number 
                was attained.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetBusMicroFrameNumber)(void *self, UInt64 *microFrame, AbsoluteTime *atTime);
    
    /*!
    @function GetFrameListTime
    @abstract   Returns the number of microseconds in each USB Frame.
    @discussion This function can be used to determine whether the device is functioning in full speed or a high 
                speed. In the case of a full speed device, the returned value will be kUSBFullSpeedMicrosecondsInFrame.  
                In the case of a high speed device, the return value will be kUSBHighSpeedMicrosecondsInFrame.  
                (This API should really be called GetUSBFrameTime).
                
                The interface does not have to be open to use this function.
    @availability This function is only available with IOUSBInterfaceInterface197 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      microsecondsInFrame Pointer to UInt32 to hold the number of microseconds in each USB frame.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetFrameListTime)(void *self, UInt32 *microsecondsInFrame);
    
    /*!
    @function GetIOUSBLibVersion
    @abstract   Returns the version of the IOUSBLib and the version of the IOUSBFamily.
    @discussion The interface does not have to be open to use this function.
    @availability This function is only available with IOUSBInterfaceInterface197 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      ioUSBLibVersion Pointer to a NumVersion structure that on return will contain 
                the version of the IOUSBLib.
    @param      usbFamilyVersion Pointer to a NumVersion structure that on return will contain 
                the version of the IOUSBFamily.
    @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
	*/

    IOReturn (*GetIOUSBLibVersion)(void *self, NumVersion *ioUSBLibVersion, NumVersion *usbFamilyVersion);
} IOUSBInterfaceInterface197;





/*!
 @interface IOUSBInterfaceInterface220
 @abstract   The object you use to access a USB device interface from user space, returned by the IOUSBFamily
 version 2.2.0 and above.
 @discussion The functions listed here include all of the functions defined for the IOUSBInterfaceInterface,
 IOUSBInterfaceInterface182, IOUSBInterfaceInterface183, IOUSBInterfaceInterface190, IOUSBInterfaceInterface192
 and IOUSBInterfaceInterface197, as well as some new functions that are available on Mac OS X version 10.4 and later.
 @super IOUSBInterfaceInterface197
 */

typedef struct IOUSBInterfaceStruct220 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateInterfaceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetInterfaceAsyncEventSource)(void *self);
    IOReturn (*CreateInterfaceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetInterfaceAsyncPort)(void *self);
    IOReturn (*USBInterfaceOpen)(void *self);
    IOReturn (*USBInterfaceClose)(void *self);
    IOReturn (*GetInterfaceClass)(void *self, UInt8 *intfClass);
    IOReturn (*GetInterfaceSubClass)(void *self, UInt8 *intfSubClass);
    IOReturn (*GetInterfaceProtocol)(void *self, UInt8 *intfProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetConfigurationValue)(void *self, UInt8 *configVal);
    IOReturn (*GetInterfaceNumber)(void *self, UInt8 *intfNumber);
    IOReturn (*GetAlternateSetting)(void *self, UInt8 *intfAltSetting);
    IOReturn (*GetNumEndpoints)(void *self, UInt8 *intfNumEndpoints);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetDevice)(void *self, io_service_t *device);
    IOReturn (*SetAlternateInterface)(void *self, UInt8 alternateSetting);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ControlRequest)(void *self, UInt8 pipeRef, IOUSBDevRequest *req);
    IOReturn (*ControlRequestAsync)(void *self, UInt8 pipeRef, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*GetPipeProperties)(void *self, UInt8 pipeRef, UInt8 *direction, UInt8 *number, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*GetPipeStatus)(void *self, UInt8 pipeRef);
    IOReturn (*AbortPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ResetPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ClearPipeStall)(void *self, UInt8 pipeRef);
    IOReturn (*ReadPipe)(void *self, UInt8 pipeRef, void *buf, UInt32 *size);
    IOReturn (*WritePipe)(void *self, UInt8 pipeRef, void *buf, UInt32 size);
    IOReturn (*ReadPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                   IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                    IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ControlRequestTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req);
    IOReturn (*ControlRequestAsyncTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*ReadPipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 *size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*WritePipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*ReadPipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*USBInterfaceGetStringIndex)(void *self, UInt8 *si);
    IOReturn (*USBInterfaceOpenSeize)(void *self);
    IOReturn (*ClearPipeStallBothEnds)(void *self, UInt8 pipeRef);
    IOReturn (*SetPipePolicy)(void *self, UInt8 pipeRef, UInt16 maxPacketSize, UInt8 maxInterval);
    IOReturn (*GetBandwidthAvailable)(void *self, UInt32 *bandwidth);
    IOReturn (*GetEndpointProperties)(void *self, UInt8 alternateSetting, UInt8 endpointNumber, UInt8 direction, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*LowLatencyReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, UInt32 updateFrequency, IOUSBLowLatencyIsocFrame *frameList,
                                             IOAsyncCallback1 callback, void *refcon);
    IOReturn (*LowLatencyWriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, UInt32 updateFrequency, IOUSBLowLatencyIsocFrame *frameList,
                                              IOAsyncCallback1 callback, void *refcon);
    IOReturn (*LowLatencyCreateBuffer)(void * self, void **buffer, IOByteCount size, UInt32 bufferType);
    IOReturn (*LowLatencyDestroyBuffer) (void * self, void * buffer );
    IOReturn (*GetBusMicroFrameNumber)(void *self, UInt64 *microFrame, AbsoluteTime *atTime);
    IOReturn (*GetFrameListTime)(void *self, UInt32 *microsecondsInFrame);
    IOReturn (*GetIOUSBLibVersion)(void *self, NumVersion *ioUSBLibVersion, NumVersion *usbFamilyVersion);

    /*!
        @function FindNextAssociatedDescriptor
     @abstract   Find the next descriptor of the requested type associated with the interface.
     @discussion The interface does not have to be open to use this function.
     @availability This function is only available with IOUSBInterfaceInterface220 and above.
     @param self Pointer to the IOUSBInterfaceInterface.
     @param currentDescriptor Descriptor to start searching from, NULL to start from beginning of list.
     @param descriptorType Descriptor type to search for, or kUSBAnyDesc to return any descriptor type.
     @result Pointer to the descriptor, or NULL if no matching descriptors found.

     */

    IOUSBDescriptorHeader * (*FindNextAssociatedDescriptor)(void *self, const void *currentDescriptor, UInt8 descriptorType);

    /*!
        @function FindNextAltInterface
     @discussion return alternate interface descriptor satisfying the requirements specified in request, or NULL if there aren't any.
     discussion request is updated with the properties of the returned interface.
     @param self Pointer to the IOUSBInterfaceInterface.
     @param current interface descriptor to start searching from, NULL to start at alternate interface 0.
     @param request specifies what properties an interface must have to match.
     @result Pointer to a matching interface descriptor, or NULL if none match.
     */
    
    IOUSBDescriptorHeader * (*FindNextAltInterface)(void *self, const void *current,
                                                                 IOUSBFindInterfaceRequest *request);
} IOUSBInterfaceInterface220;





/*!
 @interface IOUSBInterfaceInterface245
 @abstract   The object you use to access a USB device interface from user space, returned by the IOUSBFamily
 version 2.4.5 and above.
 @discussion The functions listed here include all of the functions defined for the IOUSBInterfaceInterface,
 IOUSBInterfaceInterface182, IOUSBInterfaceInterface183, IOUSBInterfaceInterface190, IOUSBInterfaceInterface192,
 IOUSBInterfaceInterface197 and IOUSBInterfaceInterface220, as well as some new functions that are available on 
 Mac OS X version 10.4.6 and later.
 @super IOUSBInterfaceInterface220
 */

typedef struct IOUSBInterfaceStruct245 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateInterfaceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetInterfaceAsyncEventSource)(void *self);
    IOReturn (*CreateInterfaceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetInterfaceAsyncPort)(void *self);
    IOReturn (*USBInterfaceOpen)(void *self);
    IOReturn (*USBInterfaceClose)(void *self);
    IOReturn (*GetInterfaceClass)(void *self, UInt8 *intfClass);
    IOReturn (*GetInterfaceSubClass)(void *self, UInt8 *intfSubClass);
    IOReturn (*GetInterfaceProtocol)(void *self, UInt8 *intfProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetConfigurationValue)(void *self, UInt8 *configVal);
    IOReturn (*GetInterfaceNumber)(void *self, UInt8 *intfNumber);
    IOReturn (*GetAlternateSetting)(void *self, UInt8 *intfAltSetting);
    IOReturn (*GetNumEndpoints)(void *self, UInt8 *intfNumEndpoints);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetDevice)(void *self, io_service_t *device);
    IOReturn (*SetAlternateInterface)(void *self, UInt8 alternateSetting);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ControlRequest)(void *self, UInt8 pipeRef, IOUSBDevRequest *req);
    IOReturn (*ControlRequestAsync)(void *self, UInt8 pipeRef, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*GetPipeProperties)(void *self, UInt8 pipeRef, UInt8 *direction, UInt8 *number, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*GetPipeStatus)(void *self, UInt8 pipeRef);
    IOReturn (*AbortPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ResetPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ClearPipeStall)(void *self, UInt8 pipeRef);
    IOReturn (*ReadPipe)(void *self, UInt8 pipeRef, void *buf, UInt32 *size);
    IOReturn (*WritePipe)(void *self, UInt8 pipeRef, void *buf, UInt32 size);
    IOReturn (*ReadPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                   IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                    IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ControlRequestTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req);
    IOReturn (*ControlRequestAsyncTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*ReadPipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 *size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*WritePipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*ReadPipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*USBInterfaceGetStringIndex)(void *self, UInt8 *si);
    IOReturn (*USBInterfaceOpenSeize)(void *self);
    IOReturn (*ClearPipeStallBothEnds)(void *self, UInt8 pipeRef);
    IOReturn (*SetPipePolicy)(void *self, UInt8 pipeRef, UInt16 maxPacketSize, UInt8 maxInterval);
    IOReturn (*GetBandwidthAvailable)(void *self, UInt32 *bandwidth);
    IOReturn (*GetEndpointProperties)(void *self, UInt8 alternateSetting, UInt8 endpointNumber, UInt8 direction, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*LowLatencyReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, UInt32 updateFrequency, IOUSBLowLatencyIsocFrame *frameList,
                                             IOAsyncCallback1 callback, void *refcon);
    IOReturn (*LowLatencyWriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, UInt32 updateFrequency, IOUSBLowLatencyIsocFrame *frameList,
                                              IOAsyncCallback1 callback, void *refcon);
    IOReturn (*LowLatencyCreateBuffer)(void * self, void **buffer, IOByteCount size, UInt32 bufferType);
    IOReturn (*LowLatencyDestroyBuffer) (void * self, void * buffer );
    IOReturn (*GetBusMicroFrameNumber)(void *self, UInt64 *microFrame, AbsoluteTime *atTime);
    IOReturn (*GetFrameListTime)(void *self, UInt32 *microsecondsInFrame);
    IOReturn (*GetIOUSBLibVersion)(void *self, NumVersion *ioUSBLibVersion, NumVersion *usbFamilyVersion);
    IOUSBDescriptorHeader * (*FindNextAssociatedDescriptor)(void *self, const void *currentDescriptor, UInt8 descriptorType);
    IOUSBDescriptorHeader * (*FindNextAltInterface)(void *self, const void *current, IOUSBFindInterfaceRequest *request);
} IOUSBInterfaceInterface245;





/*!
 @interface IOUSBInterfaceInterface300
 @abstract   The object you use to access a USB device interface from user space, returned by the IOUSBFamily
 version 3.0.0 and above.
 @discussion The functions listed here include all of the functions defined for the IOUSBInterfaceInterface,
 IOUSBInterfaceInterface182, IOUSBInterfaceInterface183, IOUSBInterfaceInterface190, IOUSBInterfaceInterface192,
 IOUSBInterfaceInterface197, IOUSBInterfaceInterface220 and IOUSBInterfaceInterface245, as well as some new functions 
 that are available on Mac OS X version 10.5 and later.
 @super IOUSBInterfaceInterface245
 */

typedef struct IOUSBInterfaceStruct300 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateInterfaceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetInterfaceAsyncEventSource)(void *self);
    IOReturn (*CreateInterfaceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetInterfaceAsyncPort)(void *self);
    IOReturn (*USBInterfaceOpen)(void *self);
    IOReturn (*USBInterfaceClose)(void *self);
    IOReturn (*GetInterfaceClass)(void *self, UInt8 *intfClass);
    IOReturn (*GetInterfaceSubClass)(void *self, UInt8 *intfSubClass);
    IOReturn (*GetInterfaceProtocol)(void *self, UInt8 *intfProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetConfigurationValue)(void *self, UInt8 *configVal);
    IOReturn (*GetInterfaceNumber)(void *self, UInt8 *intfNumber);
    IOReturn (*GetAlternateSetting)(void *self, UInt8 *intfAltSetting);
    IOReturn (*GetNumEndpoints)(void *self, UInt8 *intfNumEndpoints);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetDevice)(void *self, io_service_t *device);
    IOReturn (*SetAlternateInterface)(void *self, UInt8 alternateSetting);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ControlRequest)(void *self, UInt8 pipeRef, IOUSBDevRequest *req);
    IOReturn (*ControlRequestAsync)(void *self, UInt8 pipeRef, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*GetPipeProperties)(void *self, UInt8 pipeRef, UInt8 *direction, UInt8 *number, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*GetPipeStatus)(void *self, UInt8 pipeRef);
    IOReturn (*AbortPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ResetPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ClearPipeStall)(void *self, UInt8 pipeRef);
    IOReturn (*ReadPipe)(void *self, UInt8 pipeRef, void *buf, UInt32 *size);
    IOReturn (*WritePipe)(void *self, UInt8 pipeRef, void *buf, UInt32 size);
    IOReturn (*ReadPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt32 size, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                   IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame *frameList,
                                    IOAsyncCallback1 callback, void *refcon);
    IOReturn (*ControlRequestTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req);
    IOReturn (*ControlRequestAsyncTO)(void *self, UInt8 pipeRef, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*ReadPipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 *size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*WritePipeTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout);
    IOReturn (*ReadPipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*WritePipeAsyncTO)(void *self, UInt8 pipeRef, void *buf, UInt32 size, UInt32 noDataTimeout, UInt32 completionTimeout, IOAsyncCallback1 callback, void *refcon);
    IOReturn (*USBInterfaceGetStringIndex)(void *self, UInt8 *si);
    IOReturn (*USBInterfaceOpenSeize)(void *self);
    IOReturn (*ClearPipeStallBothEnds)(void *self, UInt8 pipeRef);
    IOReturn (*SetPipePolicy)(void *self, UInt8 pipeRef, UInt16 maxPacketSize, UInt8 maxInterval);
    IOReturn (*GetBandwidthAvailable)(void *self, UInt32 *bandwidth);
    IOReturn (*GetEndpointProperties)(void *self, UInt8 alternateSetting, UInt8 endpointNumber, UInt8 direction, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*LowLatencyReadIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, UInt32 updateFrequency, IOUSBLowLatencyIsocFrame *frameList,
                                             IOAsyncCallback1 callback, void *refcon);
    IOReturn (*LowLatencyWriteIsochPipeAsync)(void *self, UInt8 pipeRef, void *buf, UInt64 frameStart, UInt32 numFrames, UInt32 updateFrequency, IOUSBLowLatencyIsocFrame *frameList,
                                              IOAsyncCallback1 callback, void *refcon);
    IOReturn (*LowLatencyCreateBuffer)(void * self, void **buffer, IOByteCount size, UInt32 bufferType);
    IOReturn (*LowLatencyDestroyBuffer) (void * self, void * buffer );
    IOReturn (*GetBusMicroFrameNumber)(void *self, UInt64 *microFrame, AbsoluteTime *atTime);
    IOReturn (*GetFrameListTime)(void *self, UInt32 *microsecondsInFrame);
    IOReturn (*GetIOUSBLibVersion)(void *self, NumVersion *ioUSBLibVersion, NumVersion *usbFamilyVersion);
    IOUSBDescriptorHeader * (*FindNextAssociatedDescriptor)(void *self, const void *currentDescriptor, UInt8 descriptorType);
    IOUSBDescriptorHeader * (*FindNextAltInterface)(void *self, const void *current, IOUSBFindInterfaceRequest *request);

    /*!
    @function GetBusFrameNumberWithTime
    @abstract   Gets a recent frame number of the bus to which the device is attached, along with a system time corresponding to the start of that frame
    @discussion The device does not have to be open to use this function.
    @availability This function is only available with IOUSBInterfaceInterface300 and above.
    @param      self Pointer to the IOUSBInterfaceInterface.
    @param      frame Pointer to UInt64 to hold the frame number.
    @param      atTime Pointer to a returned AbsoluteTime, which is the system time ("wall time") as close as possible to the beginning of that USB frame. The jitter on this value may be as much as 200 microseconds.
	@result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or kIOReturnUnsupported is the bus doesn't support this function.
	*/

    IOReturn (*GetBusFrameNumberWithTime)(void *self, UInt64 *frame, AbsoluteTime *atTime);
} IOUSBInterfaceInterface300;





/*!
 @interface IOUSBInterfaceInterface500
 @abstract   The object you use to access a USB device interface from user space, returned by the IOUSBFamily
 version 5.0.0 and above.
 @discussion The functions listed here include all of the functions defined for the IOUSBInterfaceInterface,
 IOUSBInterfaceInterface182, IOUSBInterfaceInterface183, IOUSBInterfaceInterface190, IOUSBInterfaceInterface192,
 IOUSBInterfaceInterface197, IOUSBInterfaceInterface220, IOUSBInterfaceInterface245 and IOUSBInterfaceInterface300
 as well as some new functions that are available on Mac OS X version 10.7.3 and later.
 @super IOUSBInterfaceInterface300
 */

typedef struct IOUSBInterfaceStruct500 {
    IUNKNOWN_C_GUTS;
    IOReturn (*CreateInterfaceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);
    CFRunLoopSourceRef (*GetInterfaceAsyncEventSource)(void *self);
    IOReturn (*CreateInterfaceAsyncPort)(void *self, mach_port_t *port);
    mach_port_t (*GetInterfaceAsyncPort)(void *self);
    IOReturn (*USBInterfaceOpen)(void *self);
    IOReturn (*USBInterfaceClose)(void *self);
    IOReturn (*GetInterfaceClass)(void *self, UInt8 *intfClass);
    IOReturn (*GetInterfaceSubClass)(void *self, UInt8 *intfSubClass);
    IOReturn (*GetInterfaceProtocol)(void *self, UInt8 *intfProtocol);
    IOReturn (*GetDeviceVendor)(void *self, UInt16 *devVendor);
    IOReturn (*GetDeviceProduct)(void *self, UInt16 *devProduct);
    IOReturn (*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);
    IOReturn (*GetConfigurationValue)(void *self, UInt8 *configVal);
    IOReturn (*GetInterfaceNumber)(void *self, UInt8 *intfNumber);
    IOReturn (*GetAlternateSetting)(void *self, UInt8 *intfAltSetting);
    IOReturn (*GetNumEndpoints)(void *self, UInt8 *intfNumEndpoints);
    IOReturn (*GetLocationID)(void *self, UInt32 *locationID);
    IOReturn (*GetDevice)(void *self, io_service_t *device);
    IOReturn (*SetAlternateInterface)(void *self, UInt8 alternateSetting);
    IOReturn (*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);
    IOReturn (*ControlRequest)(void *self, UInt8 pipeRef, IOUSBDevRequest *req);
    IOReturn (*ControlRequestAsync)(void *self, UInt8 pipeRef, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);
    IOReturn (*GetPipeProperties)(void *self, UInt8 pipeRef, UInt8 *direction, UInt8 *number, UInt8 *transferType, UInt16 *maxPacketSize, UInt8 *interval);
    IOReturn (*GetPipeStatus)(void *self, UInt8 pipeRef);
    IOReturn (*AbortPipe)(void *self, UInt8 pipeRef);
    IOReturn (*ResetPipe)(void *self, UInt8 pipeRef);
    IOReturn 