of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_get_context.3                 0100644 0001750 0001750 00000064614 12566166531 026376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_get_euid.3                    0100644 0001750 0001750 00000064614 12566166531 025640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_get_guid.3                    0100644 0001750 0001750 00000064614 12566166531 025642  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_get_name.3                    0100644 0001750 0001750 00000064614 12566166531 025632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_get_pid.3                     0100644 0001750 0001750 00000064614 12566166531 025466  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_resume.3                      0100644 0001750 0001750 00000064614 12566166531 025353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_send_barrier.3                0100644 0001750 0001750 00000064614 12566166531 026512  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_send_message.3                0100644 0001750 0001750 00000064614 12566166531 026510  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_send_message_with_reply.3     0100644 0001750 0001750 00000064614 12566166531 030756  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_send_message_with_reply_sync.30100644 0001750 0001750 00000064614 12566166531 032012  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_set_context.3                 0100644 0001750 0001750 00000064614 12566166531 026412  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_set_event_handler.3           0100644 0001750 0001750 00000064614 12566166531 027544  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_set_finalizer_f.3             0100644 0001750 0001750 00000064614 12566166531 027216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_set_target_queue.3            0100644 0001750 0001750 00000064614 12566166531 027420  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_connection_suspend.3                     0100644 0001750 0001750 00000064614 12566166531 025534  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_copy.3                                   0100644 0001750 0001750 00000022304 12566166531 022574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011-2012 Apple Inc. All rights reserved.
.Dd 1 March, 2012
.Dt xpc_object 3
.Os Darwin
.Sh NAME
.Nm xpc_object
.Nd XPC object protocol
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_retain
.Fa "xpc_object_t object"
.Fc
.Ft void
.Fo xpc_release
.Fa "xpc_object_t object"
.Fc
.Ft xpc_type_t
.Fo xpc_get_type
.Fa "xpc_object_t object"
.Fc
.Ft xpc_object_t
.Fo xpc_copy
.Fa "xpc_object_t object"
.Fc
.Ft bool
.Fo xpc_equal
.Fa "xpc_object_t object1"
.Fa "xpc_object_t object2"
.Fc
.Ft size_t
.Fo xpc_hash
.Fa "xpc_object_t object"
.Fc
.Ft char *
.Fo xpc_copy_description
.Fa "xpc_object_t object"
.Fc
.Sh DESCRIPTION
XPC objects share functions for coordinating memory management, type checking,
comparing for equality, and hashing.
.Sh MEMORY MANAGEMENT
Objects returned by creation functions in the XPC framework may be uniformly
retained and released with the functions
.Fn xpc_retain
and
.Fn xpc_release
respectively.
.Pp
The XPC framework does not guarantee that any given client has the last or only
reference to a given object. Objects may be retained internally by the system.
.Pp
Functions which return objects follow the conventional create, copy and get
naming rules:
.Bl -tag -width "XXcreate" -compact -offset indent
.It \(bu create
A new object with a single reference is returned. This reference should be
released by the caller.
.It \(bu copy
A copy or retained object reference is returned. This reference should be
released by the caller.
.It \(bu get
An unretained reference to an existing object is returned. The caller
.Em must not
release this reference, and is responsible for retaining the object for later
use if necessary.
.El
.Ss INTEGRATION WITH OBJECTIVE-C
.Bd -filled -offset indent
When building with an Objective-C or Objective-C++ compiler, XPC objects are
declared as Objective-C types. This results in the following differences
compared to building as plain C/C++:
.Bl -dash
.It
if Objective-C Automated Reference Counting is enabled, XPC objects are
memory managed by the Objective-C runtime and explicit calls to the
.Fn xpc_retain
and
.Fn xpc_release
functions will produce build errors.
.Pp
.Em Note :
when ARC is enabled, care needs to be taken with XPC API returning an interior
pointer that is only valid as long as an associated object has not been
released. If that object is held in a variable with automatic storage, it may
need to be annotated with the
.Li objc_precise_lifetime
attribute, or stored in a
.Li __strong
instance variable instead, to ensure that the object is not prematurely
released. The functions returning interior pointers are:
.Bl -bullet -compact -offset indent
.It
.Xr xpc_data_get_bytes_ptr 3 ,
.Xr xpc_string_get_string_ptr 3 ,
.Xr xpc_uuid_get_bytes 3
.It
.Xr xpc_array_get_data 3 ,
.Xr xpc_array_get_string 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_dictionary_get_uuid 3
.El
.It
the Blocks runtime automatically retains and releases XPC objects captured by
blocks upon
.Fn Block_copy
and
.Fn Block_release ,
e.g.\& as performed during asynchronous execution of a block via
.Xr dispatch_async 3 .
.Pp
.Em Note :
retain cycles may be encountered if XPC connection objects are captured by
their handler blocks; these cycles can be broken by declaring the captured
object
.Li __weak
or by calling
.Xr xpc_connection_cancel 3
to cause its handler blocks to be released explicitly.
.It
XPC objects can be added directly to Cocoa collections, and their
lifetime is tracked by the Objective-C static analyzer.
.El
.Pp
Integration of XPC objects with Objective-C requires targeting Mac\ OS\ X
10.8 or later, and is disabled when building with Objective-C Garbage
Collection or for the legacy Objective-C runtime. It can also be disabled
manually by using compiler options to define the
.Dv OS_OBJECT_USE_OBJC
preprocessor macro to
.Li 0 .
.Ed
.Pp
.Em Important :
When building with a plain C/C++ compiler or when integration with Objective-C
is disabled, XPC objects are
.Em not
automatically retained and released when captured by a block. Therefore, when a
XPC object is captured by a block that will be executed asynchronously, the
object must be manually retained and released:
.Pp
.Bd -literal -offset indent
xpc_retain(object);
dispatch_async(queue, ^{
	do_something_with_object(object);
	xpc_release(object);
});
.Ed
.Sh TYPES
The
.Fn xpc_get_type
function returns the type of an XPC object as a pointer of type
.Ft xpc_type t .
The returned type may be compared against the type constants defined by the
XPC framework with simple pointer equality.
.Pp
Type constants:
.Bl -bullet -compact -offset indent
.It
XPC_TYPE_CONNECTION
.It
XPC_TYPE_ENDPOINT
.It
XPC_TYPE_NULL
.It
XPC_TYPE_BOOL
.It
XPC_TYPE_INT64
.It
XPC_TYPE_UINT64
.It
XPC_TYPE_DOUBLE
.It
XPC_TYPE_DATE
.It
XPC_TYPE_DATA
.It
XPC_TYPE_STRING
.It
XPC_TYPE_UUID
.It
XPC_TYPE_FD
.It
XPC_TYPE_SHMEM
.It
XPC_TYPE_ARRAY
.It
XPC_TYPE_DICTIONARY
.El
.Sh BOXED OBJECTS AND COLLECTIONS
Most XPC object types are boxed representations of primitive C language types
or low-level operating system handles. These boxed objects are immutable.
.Pp
The XPC framework provides two collection types: dictionaries and arrays.
These types are mutable and may have boxed objects added or removed from the
collection.
.Pp
A suite of primitive get and set functions are available for the dictionary
and array types. These functions allow for the insertion and extraction of
primitive values from the collection directly, without the need for
intermediate boxed objects.
.Pp
The following is a list of primitive get and set functions for the dictionary
collection type:
.Pp
.Bl -bullet -compact -offset indent
.It
.Xr xpc_dictionary_set_bool 3 ,
.Xr xpc_dictionary_get_bool 3 ,
.Xr xpc_array_set_bool 3 ,
.Xr xpc_array_get_bool 3
.It
.Xr xpc_dictionary_set_int64 3 ,
.Xr xpc_dictionary_get_int64 3 ,
.Xr xpc_array_set_int64 3 ,
.Xr xpc_array_get_int64 3
.It
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_array_set_uint64 3 ,
.Xr xpc_array_get_uint64 3
.It
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_array_set_double 3 ,
.Xr xpc_array_get_double 3
.It
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_array_set_date 3 ,
.Xr xpc_array_get_date 3
.It
.Xr xpc_dictionary_set_data 3 ,
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_array_set_data 3 ,
.Xr xpc_array_get_data 3
.It
.Xr xpc_dictionary_set_string 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_array_set_string 3 ,
.Xr xpc_array_get_string 3
.It
.Xr xpc_dictionary_set_uuid 3 ,
.Xr xpc_dictionary_get_uuid 3 ,
.Xr xpc_array_set_uuid 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_set_fd 3 ,
.Xr xpc_dictionary_dup_fd 3 ,
.Xr xpc_array_set_fd 3 ,
.Xr xpc_array_dup_fd 3
.It
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_get_connection 3 ,
.Xr xpc_array_set_connection 3 ,
.Xr xpc_array_get_connection 3
.El
.Pp
When the requested key or index is not present in the collection, or if the
value for the requested key or index is not of the expected type, these
functions will return sensible default values:
.Pp
.Bl -tag -width "XXconnection" -compact -offset indent
.It \(bu bool
false
.It \(bu int64
0
.It \(bu uint64
0
.It \(bu double
NAN
.It \(bu date
0
.It \(bu data
NULL
.It \(bu uuid
NULL
.It \(bu string
NULL
.It \(bu fd
-1
.It \(bu connection
NULL
.El
.Pp
.Sh COPYING
Objects may be copied using the
.Fn xpc_copy
function. The result of
.Fn xpc_copy
may or may not be a brand new object (i.e. a different pointer). The system may
choose to return the same object with an additional reference rather than doing
a complete copy for efficiency reasons.
.Sh EQUALITY
Two objects may be compared for equality using the
.Fn xpc_equal
function.
Objects must be of the same type as returned by
.Fn xpc_get_type
in order to be considered equal. No casting or transformation is performed
on the underlying value in order to determine equality.
.Pp
Collection types are compared for deep equality, that is to say, two arrays
are equal only if they contain the same values in the same order, and two
dictionaries are equal only if they contain the same values for the same keys.
.Pp
.Em Important :
File descriptors and shared memory objects cannot be reliably compared for
equality, and therefore the
.Fn xpc_equal
function will only perform a simple pointer-equality check for these objects.
.Pp
Objects may be hashed using the
.Fn xpc_hash
function. The result of the hash function is guaranteed to be identical for
objects which compare to be equal using
.Fn xpc_equal .
.Pp
.Em Important :
The hash value for a given object should not be considered portable across
multiple processes or releases of the operating system and as a result should
not be stored in a permanent fashion.
.Sh OBJECT DESCRIPTIONS
The
.Fn xpc_copy_description
function may be used to produce a human-readable description of an object.
The returned C-string must be freed by the caller using
.Xr free 3 .
.Pp
.Em Important :
The format of this description is not guaranteed to remain consistent across
releases, and the output should only be used for debugging purposes.
.Sh SEE ALSO
.Xr dispatch_async 3 ,
.Xr xpc_abort 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_cancel 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_endpoint_create 3 ,
.Xr xpc_objects 3
                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_copy_description.3                       0100644 0001750 0001750 00000022304 12566166531 025177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011-2012 Apple Inc. All rights reserved.
.Dd 1 March, 2012
.Dt xpc_object 3
.Os Darwin
.Sh NAME
.Nm xpc_object
.Nd XPC object protocol
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_retain
.Fa "xpc_object_t object"
.Fc
.Ft void
.Fo xpc_release
.Fa "xpc_object_t object"
.Fc
.Ft xpc_type_t
.Fo xpc_get_type
.Fa "xpc_object_t object"
.Fc
.Ft xpc_object_t
.Fo xpc_copy
.Fa "xpc_object_t object"
.Fc
.Ft bool
.Fo xpc_equal
.Fa "xpc_object_t object1"
.Fa "xpc_object_t object2"
.Fc
.Ft size_t
.Fo xpc_hash
.Fa "xpc_object_t object"
.Fc
.Ft char *
.Fo xpc_copy_description
.Fa "xpc_object_t object"
.Fc
.Sh DESCRIPTION
XPC objects share functions for coordinating memory management, type checking,
comparing for equality, and hashing.
.Sh MEMORY MANAGEMENT
Objects returned by creation functions in the XPC framework may be uniformly
retained and released with the functions
.Fn xpc_retain
and
.Fn xpc_release
respectively.
.Pp
The XPC framework does not guarantee that any given client has the last or only
reference to a given object. Objects may be retained internally by the system.
.Pp
Functions which return objects follow the conventional create, copy and get
naming rules:
.Bl -tag -width "XXcreate" -compact -offset indent
.It \(bu create
A new object with a single reference is returned. This reference should be
released by the caller.
.It \(bu copy
A copy or retained object reference is returned. This reference should be
released by the caller.
.It \(bu get
An unretained reference to an existing object is returned. The caller
.Em must not
release this reference, and is responsible for retaining the object for later
use if necessary.
.El
.Ss INTEGRATION WITH OBJECTIVE-C
.Bd -filled -offset indent
When building with an Objective-C or Objective-C++ compiler, XPC objects are
declared as Objective-C types. This results in the following differences
compared to building as plain C/C++:
.Bl -dash
.It
if Objective-C Automated Reference Counting is enabled, XPC objects are
memory managed by the Objective-C runtime and explicit calls to the
.Fn xpc_retain
and
.Fn xpc_release
functions will produce build errors.
.Pp
.Em Note :
when ARC is enabled, care needs to be taken with XPC API returning an interior
pointer that is only valid as long as an associated object has not been
released. If that object is held in a variable with automatic storage, it may
need to be annotated with the
.Li objc_precise_lifetime
attribute, or stored in a
.Li __strong
instance variable instead, to ensure that the object is not prematurely
released. The functions returning interior pointers are:
.Bl -bullet -compact -offset indent
.It
.Xr xpc_data_get_bytes_ptr 3 ,
.Xr xpc_string_get_string_ptr 3 ,
.Xr xpc_uuid_get_bytes 3
.It
.Xr xpc_array_get_data 3 ,
.Xr xpc_array_get_string 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_dictionary_get_uuid 3
.El
.It
the Blocks runtime automatically retains and releases XPC objects captured by
blocks upon
.Fn Block_copy
and
.Fn Block_release ,
e.g.\& as performed during asynchronous execution of a block via
.Xr dispatch_async 3 .
.Pp
.Em Note :
retain cycles may be encountered if XPC connection objects are captured by
their handler blocks; these cycles can be broken by declaring the captured
object
.Li __weak
or by calling
.Xr xpc_connection_cancel 3
to cause its handler blocks to be released explicitly.
.It
XPC objects can be added directly to Cocoa collections, and their
lifetime is tracked by the Objective-C static analyzer.
.El
.Pp
Integration of XPC objects with Objective-C requires targeting Mac\ OS\ X
10.8 or later, and is disabled when building with Objective-C Garbage
Collection or for the legacy Objective-C runtime. It can also be disabled
manually by using compiler options to define the
.Dv OS_OBJECT_USE_OBJC
preprocessor macro to
.Li 0 .
.Ed
.Pp
.Em Important :
When building with a plain C/C++ compiler or when integration with Objective-C
is disabled, XPC objects are
.Em not
automatically retained and released when captured by a block. Therefore, when a
XPC object is captured by a block that will be executed asynchronously, the
object must be manually retained and released:
.Pp
.Bd -literal -offset indent
xpc_retain(object);
dispatch_async(queue, ^{
	do_something_with_object(object);
	xpc_release(object);
});
.Ed
.Sh TYPES
The
.Fn xpc_get_type
function returns the type of an XPC object as a pointer of type
.Ft xpc_type t .
The returned type may be compared against the type constants defined by the
XPC framework with simple pointer equality.
.Pp
Type constants:
.Bl -bullet -compact -offset indent
.It
XPC_TYPE_CONNECTION
.It
XPC_TYPE_ENDPOINT
.It
XPC_TYPE_NULL
.It
XPC_TYPE_BOOL
.It
XPC_TYPE_INT64
.It
XPC_TYPE_UINT64
.It
XPC_TYPE_DOUBLE
.It
XPC_TYPE_DATE
.It
XPC_TYPE_DATA
.It
XPC_TYPE_STRING
.It
XPC_TYPE_UUID
.It
XPC_TYPE_FD
.It
XPC_TYPE_SHMEM
.It
XPC_TYPE_ARRAY
.It
XPC_TYPE_DICTIONARY
.El
.Sh BOXED OBJECTS AND COLLECTIONS
Most XPC object types are boxed representations of primitive C language types
or low-level operating system handles. These boxed objects are immutable.
.Pp
The XPC framework provides two collection types: dictionaries and arrays.
These types are mutable and may have boxed objects added or removed from the
collection.
.Pp
A suite of primitive get and set functions are available for the dictionary
and array types. These functions allow for the insertion and extraction of
primitive values from the collection directly, without the need for
intermediate boxed objects.
.Pp
The following is a list of primitive get and set functions for the dictionary
collection type:
.Pp
.Bl -bullet -compact -offset indent
.It
.Xr xpc_dictionary_set_bool 3 ,
.Xr xpc_dictionary_get_bool 3 ,
.Xr xpc_array_set_bool 3 ,
.Xr xpc_array_get_bool 3
.It
.Xr xpc_dictionary_set_int64 3 ,
.Xr xpc_dictionary_get_int64 3 ,
.Xr xpc_array_set_int64 3 ,
.Xr xpc_array_get_int64 3
.It
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_array_set_uint64 3 ,
.Xr xpc_array_get_uint64 3
.It
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_array_set_double 3 ,
.Xr xpc_array_get_double 3
.It
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_array_set_date 3 ,
.Xr xpc_array_get_date 3
.It
.Xr xpc_dictionary_set_data 3 ,
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_array_set_data 3 ,
.Xr xpc_array_get_data 3
.It
.Xr xpc_dictionary_set_string 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_array_set_string 3 ,
.Xr xpc_array_get_string 3
.It
.Xr xpc_dictionary_set_uuid 3 ,
.Xr xpc_dictionary_get_uuid 3 ,
.Xr xpc_array_set_uuid 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_set_fd 3 ,
.Xr xpc_dictionary_dup_fd 3 ,
.Xr xpc_array_set_fd 3 ,
.Xr xpc_array_dup_fd 3
.It
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_get_connection 3 ,
.Xr xpc_array_set_connection 3 ,
.Xr xpc_array_get_connection 3
.El
.Pp
When the requested key or index is not present in the collection, or if the
value for the requested key or index is not of the expected type, these
functions will return sensible default values:
.Pp
.Bl -tag -width "XXconnection" -compact -offset indent
.It \(bu bool
false
.It \(bu int64
0
.It \(bu uint64
0
.It \(bu double
NAN
.It \(bu date
0
.It \(bu data
NULL
.It \(bu uuid
NULL
.It \(bu string
NULL
.It \(bu fd
-1
.It \(bu connection
NULL
.El
.Pp
.Sh COPYING
Objects may be copied using the
.Fn xpc_copy
function. The result of
.Fn xpc_copy
may or may not be a brand new object (i.e. a different pointer). The system may
choose to return the same object with an additional reference rather than doing
a complete copy for efficiency reasons.
.Sh EQUALITY
Two objects may be compared for equality using the
.Fn xpc_equal
function.
Objects must be of the same type as returned by
.Fn xpc_get_type
in order to be considered equal. No casting or transformation is performed
on the underlying value in order to determine equality.
.Pp
Collection types are compared for deep equality, that is to say, two arrays
are equal only if they contain the same values in the same order, and two
dictionaries are equal only if they contain the same values for the same keys.
.Pp
.Em Important :
File descriptors and shared memory objects cannot be reliably compared for
equality, and therefore the
.Fn xpc_equal
function will only perform a simple pointer-equality check for these objects.
.Pp
Objects may be hashed using the
.Fn xpc_hash
function. The result of the hash function is guaranteed to be identical for
objects which compare to be equal using
.Fn xpc_equal .
.Pp
.Em Important :
The hash value for a given object should not be considered portable across
multiple processes or releases of the operating system and as a result should
not be stored in a permanent fashion.
.Sh OBJECT DESCRIPTIONS
The
.Fn xpc_copy_description
function may be used to produce a human-readable description of an object.
The returned C-string must be freed by the caller using
.Xr free 3 .
.Pp
.Em Important :
The format of this description is not guaranteed to remain consistent across
releases, and the output should only be used for debugging purposes.
.Sh SEE ALSO
.Xr dispatch_async 3 ,
.Xr xpc_abort 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_cancel 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_endpoint_create 3 ,
.Xr xpc_objects 3
                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_data_create.3                            0100644 0001750 0001750 00000031100 12566166531 024050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_data_create_with_dispatch_data.3         0100644 0001750 0001750 00000031100 12566166531 027753  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_data_get_bytes.3                         0100644 0001750 0001750 00000031100 12566166531 024572  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_data_get_bytes_ptr.3                     0100644 0001750 0001750 00000031100 12566166531 025457  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_data_get_length.3                        0100644 0001750 0001750 00000031100 12566166531 024725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_date_create.3                            0100644 0001750 0001750 00000031100 12566166531 024054  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_date_create_from_current.3               0100644 0001750 0001750 00000031100 12566166531 026641  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_date_get_value.3                         0100644 0001750 0001750 00000031100 12566166531 024564  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_debugger.3                               0100644 0001750 0001750 00000005703 12566166531 023412  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_abort 3
.Os Darwin
.Sh NAME
.Nm xpc_abort
.Nd conditions which cause XPC to abort
.Sh DESCRIPTION
The XPC API will aggressively defend itself against perceived misuse. Wherever 
XPC can definitively detect misuse of its APIs or data corruption, it will
abort. For example, if the retain count of an object underflows by calling
.Xr xpc_release 3
on it too many times, XPC will abort the process.
.Pp
Many frameworks opt to keep the program limping along in such a state (and will
perhaps print a warning message to the system log), but aborting upon detection
provides unmistakable warning that there is a bug present in the application
which should be fixed before shipping.
.Pp
When XPC aborts a process, it will place information about the condition which
triggered the abort in the
.Em Application Specific Information
section of the crash report. The message will be human-readable, prefixed with
"XPC API Misuse:", and the crash report will indicate the stack trace which
caused the abort.
.Pp
XPC will also abort if it detects unrecoverable data corruption in its internal
state. The messages for these conditions will be prefixd with "Bug in libxpc:".
If you come across such a crash, please file a bug and include the generated
crash log, system log and steps to reproduce (if there are any identifiable
steps).
.Pp
Currently, the manner in which XPC aborts the process will result in termination
due to SIGILL (illegal instruction). The exact signal raised may change from
release to release (or platform to platform). But on OS X Lion, SIGILL may be
used as a hint that the process was terminated intentionally.
.Sh DEBUGGING
When debugging in Xcode or at the gdb command prompt, the debugger acts as the
exception handler for the process being debugged. As a result, if the process
is aborted by XPC, no crash report will be generated, and thus it may not be
obvious why the program was terminated.
.Pp
As mentioned before, SIGILL is an indication that the process was terminated
intentionally. If you observe the last frame in the crashing stack to be
.Fn _xpc_api_misuse ,
you may use the
.Fn xpc_debugger_api_misuse_info
API from within the debugger to obtain a human-readable string describing why
the process was aborted. For example:
.Pp
.Bd -literal -offset indent
Program received signal EXC_BAD_INSTRUCTION, Illegal instruction/operand.
0x000000010012b25e in _xpc_api_misuse ()
(gdb) p (char *)xpc_debugger_api_misuse_info()
$1 = 0x7fff5fbff908 "XPC API Misuse: Over-release of object."
(gdb)
.Ed
.Pp
This message indicates that
.Xr xpc_release 3
was called too many times on an object.
.Pp
.Em IMPORTANT :
The
.Fn xpc_debugger_api_misuse_info
API can ONLY be called from within a debugger. It is not meant to be called
directly from the program. Do not call it directly from your code, and do not
rely on the address of the result for any reason.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_object 3 ,
.Xr xpc_objects 3
                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_debugger_api_misuse_info.3               0100644 0001750 0001750 00000005703 12566166531 026643  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_abort 3
.Os Darwin
.Sh NAME
.Nm xpc_abort
.Nd conditions which cause XPC to abort
.Sh DESCRIPTION
The XPC API will aggressively defend itself against perceived misuse. Wherever 
XPC can definitively detect misuse of its APIs or data corruption, it will
abort. For example, if the retain count of an object underflows by calling
.Xr xpc_release 3
on it too many times, XPC will abort the process.
.Pp
Many frameworks opt to keep the program limping along in such a state (and will
perhaps print a warning message to the system log), but aborting upon detection
provides unmistakable warning that there is a bug present in the application
which should be fixed before shipping.
.Pp
When XPC aborts a process, it will place information about the condition which
triggered the abort in the
.Em Application Specific Information
section of the crash report. The message will be human-readable, prefixed with
"XPC API Misuse:", and the crash report will indicate the stack trace which
caused the abort.
.Pp
XPC will also abort if it detects unrecoverable data corruption in its internal
state. The messages for these conditions will be prefixd with "Bug in libxpc:".
If you come across such a crash, please file a bug and include the generated
crash log, system log and steps to reproduce (if there are any identifiable
steps).
.Pp
Currently, the manner in which XPC aborts the process will result in termination
due to SIGILL (illegal instruction). The exact signal raised may change from
release to release (or platform to platform). But on OS X Lion, SIGILL may be
used as a hint that the process was terminated intentionally.
.Sh DEBUGGING
When debugging in Xcode or at the gdb command prompt, the debugger acts as the
exception handler for the process being debugged. As a result, if the process
is aborted by XPC, no crash report will be generated, and thus it may not be
obvious why the program was terminated.
.Pp
As mentioned before, SIGILL is an indication that the process was terminated
intentionally. If you observe the last frame in the crashing stack to be
.Fn _xpc_api_misuse ,
you may use the
.Fn xpc_debugger_api_misuse_info
API from within the debugger to obtain a human-readable string describing why
the process was aborted. For example:
.Pp
.Bd -literal -offset indent
Program received signal EXC_BAD_INSTRUCTION, Illegal instruction/operand.
0x000000010012b25e in _xpc_api_misuse ()
(gdb) p (char *)xpc_debugger_api_misuse_info()
$1 = 0x7fff5fbff908 "XPC API Misuse: Over-release of object."
(gdb)
.Ed
.Pp
This message indicates that
.Xr xpc_release 3
was called too many times on an object.
.Pp
.Em IMPORTANT :
The
.Fn xpc_debugger_api_misuse_info
API can ONLY be called from within a debugger. It is not meant to be called
directly from the program. Do not call it directly from your code, and do not
rely on the address of the result for any reason.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_object 3 ,
.Xr xpc_objects 3
                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_apply.3                       0100644 0001750 0001750 00000020611 12566166531 025173  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_create.3                      0100644 0001750 0001750 00000020611 12566166531 025311  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_create_reply.3                0100644 0001750 0001750 00000020611 12566166531 026524  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_dup_fd.3                      0100644 0001750 0001750 00000020611 12566166531 025307  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_bool.3                    0100644 0001750 0001750 00000020611 12566166531 025640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_connection.3              0100644 0001750 0001750 00000020611 12566166531 027044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_count.3                   0100644 0001750 0001750 00000020611 12566166531 026035  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_data.3                    0100644 0001750 0001750 00000020611 12566166531 025616  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_date.3                    0100644 0001750 0001750 00000020611 12566166531 025622  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_double.3                  0100644 0001750 0001750 00000020611 12566166531 026157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_int64.3                   0100644 0001750 0001750 00000020611 12566166531 025651  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_remote_connection.3       0100644 0001750 0001750 00000020611 12566166531 030417  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_string.3                  0100644 0001750 0001750 00000020611 12566166531 026213  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_uint64.3                  0100644 0001750 0001750 00000020611 12566166531 026036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_uuid.3                    0100644 0001750 0001750 00000020611 12566166531 025653  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_get_value.3                   0100644 0001750 0001750 00000020611 12566166531 026021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_set_bool.3                    0100644 0001750 0001750 00000020611 12566166531 025654  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_set_connection.3              0100644 0001750 0001750 00000020611 12566166531 027060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_set_data.3                    0100644 0001750 0001750 00000020611 12566166531 025632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_set_date.3                    0100644 0001750 0001750 00000020611 12566166531 025636  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_set_double.3                  0100644 0001750 0001750 00000020611 12566166531 026173  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_set_fd.3                      0100644 0001750 0001750 00000020611 12566166531 025312  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_set_int64.3                   0100644 0001750 0001750 00000020611 12566166531 025665  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_set_string.3                  0100644 0001750 0001750 00000020611 12566166531 026227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_set_uint64.3                  0100644 0001750 0001750 00000020611 12566166531 026052  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_set_uuid.3                    0100644 0001750 0001750 00000020611 12566166531 025667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_dictionary_set_value.3                   0100644 0001750 0001750 00000020611 12566166531 026035  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_dictionary_create 3
.Os Darwin
.Sh NAME
.Nm xpc_dictionary_create
.Nd creation and management of XPC messages
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_dictionary_create
.Fa "const char * const *keys"
.Fa "const xpc_object_t *values"
.Fa "size_t count"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_create_reply
.Fa "xpc_object_t original"
.Fc
.Ft void
.Fo xpc_dictionary_set_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_object_t value"
.Fc
.Ft xpc_object_t
.Fo xpc_dictionary_get_value
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft size_t
.Fo xpc_dictionary_get_count
.Fa "xpc_object_t dictionary"
.Fc
.Ft bool
.Fo xpc_dictionary_apply
.Fa "xpc_object_t dictionary"
.Fa "xpc_dictionary_applier_t applier"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_remote_connection
.Fa "xpc_object_t dictionary"
.Fc
.Ft void
.Fo xpc_dictionary_set_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "bool value"
.Fc
.Ft void
.Fo xpc_dictionary_set_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "uint64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "double value"
.Fc
.Ft void
.Fo xpc_dictionary_set_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int64_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const void *value"
.Fa "size_t length"
.Fc
.Ft void
.Fo xpc_dictionary_set_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const char *value"
.Fc
.Ft void
.Fo xpc_dictionary_set_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "const uuid_t value"
.Fc
.Ft void
.Fo xpc_dictionary_set_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "int value"
.Fc
.Ft void
.Fo xpc_dictionary_set_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "xpc_connection_t connection"
.Fc
.Ft bool
.Fo xpc_dictionary_get_bool
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_int64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft uint64_t
.Fo xpc_dictionary_get_uint64
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft double
.Fo xpc_dictionary_get_double
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int64_t
.Fo xpc_dictionary_get_date
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const void *
.Fo xpc_dictionary_get_data
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fa "size_t *length"
.Fc
.Ft const uint8_t *
.Fo xpc_dictionary_get_uuid
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft const char *
.Fo xpc_dictionary_get_string
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft int
.Fo xpc_dictionary_dup_fd
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Ft xpc_connection_t
.Fo xpc_dictionary_get_connection
.Fa "xpc_object_t dictionary"
.Fa "const char *key"
.Fc
.Sh DICTIONARIES
XPC dictionaries are collections of XPC objects that map keys (expressed as C
strings) to values.
.Pp
Objects of dictionary collection type are mutable and will automatically
expand to accommodate new keys and values that are inserted into the dictionary.
.Ss CREATION
The
.Fn xpc_dictionary_create
function returns a newly created dictionary.
The caller may optionally provide corresponding C arrays of
.Fa keys
and
.Fa values
to initialize the dictionary.
All
.Fa values
must be XPC objects and are automatically retained by the XPC framework as they
are inserted into the dictionary.
The
.Fa count
is used to specify the size of the C arrays. Both arrays must be of the same
size. The behavior when
.Fa count
is greater than the number of elements in either of the C arrays is undefined.
These arguments are optional and NULL may be passed to both
.Fa keys
and
.Fa values
with a 
.Fa count
of zero, resulting in an empty dictionary.
.Ss GETTING AND SETTING VALUES
The
.Fn xpc_dictionary_set_value
function may be used to insert or replace the
.Fa value
of a specified
.Fa key
in a
.Fa dictionary .
The XPC framework will retain a reference to the
.Fa value
while it is present in the
.Fa dictionary ,
and will release the reference when it is removed.
The
.Fa value
provided may be NULL, in which case the
.Fa key
will be removed from the dictionary.
.Pp
The value of a specific
.Fa key
in the
.Fa dictionary
may be retrieved using the
.Fn xpc_dictionary_get_value
function. This function returns the value for the specified
.Fa key
if it exists or NULL if it does not.
.Ss PRIMITIVE GET AND SET FUNCTIONS
Various functions exist for retrieving primitive C and operating system types
directly from a dictionary without the need for an intermediate boxed object.
See
.Xr xpc_object 3
for more information.
.Ss ITERATION
The
.Fn xpc_dictionary_apply
function may be used to iterate the
.Fa key
and
.Fa value
pairs of a
.Fa dictionary
using an
.Fa applier
callback block. The callback block is invoked for each pair and must return a
.Ft bool
indicating whether the iteration should continue (true if it should continue,
false if it should not).
The
.Fn xpc_dictionary_apply
function will return true if the
.Fa applier
block was called for all pairs, or false if it was not (i.e. the
.Fa applier
returned false during the iteration).
.Pp
Note that the C language does not require an explicit return type to be declared
for a block when the return expression is unambigous. Therefore the formal block
declaration
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^ bool (const char *key, xpc_object_t value) {
	// Do iteration.
	return true;
});
.Ed
.Pp
may instead be written as follows (omitting the declared return type, and
explicitly casting the return value to the desired type):
.Bd -literal -offset indent
(void)xpc_dictionary_apply(dictionary, ^(const char *key, xpc_object_t value) {
	// Do iteration.
	return (bool)true;
});
.Ed
.Pp
.Em Important :
the behavior of modifying the contents of an XPC dictionary during iteration
is undefined.
.Sh DICTIONARIES AS MESSAGES
All messages sent and received by XPC connections are dictionaries. As a result,
several functions are available to assist with the use of dictionaries as XPC
messages.
.Pp
The
.Fn xpc_dictionary_get_remote_connection
function may be used to return the underlying XPC connection through which a
message was received.
.Pp
When a client sends a message using the
.Xr xpc_connection_send_message_with_reply 3
function, a specific reply message must be created with
.Fn xpc_dictionary_create_reply .
This function returns a new dictionary which shares the underlying remote
connection as the
.Fa original
message. A reply dictionary may be used the same as any other dictionary, but it
must be sent to the connection returned by
.Fn xpc_dictionary_get_remote_connection ,
at which point the sender's reply block will be invoked when the reply message
is received.
.Pp
.Em Note :
Message dictionaries have side effects attached to their lifetimes and the
lifetimes of reply messages created from them, so close attention should be paid
to the lifetimes of such dictionaries. For details, see
.Xr xpc_transaction_begin 3 .
.Sh DICTIONARIES AS ERRORS
Errors encountered by the XPC framework are delivered to the event handler
of a connection as a dictionary of type
.Ft XPC_TYPE_ERROR .
See
.Xr xpc_get_type 3
for more information about XPC object types.
These error dictionaries may be directly compared against the following
constants:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
.It
.Ft XPC_ERROR_CONNECTION_INVALID
.It
.Ft XPC_ERROR_CONNECTION_TERMINATION_IMMINENT
.El
.Pp
.Em Important :
these dictionaries are constant singletons and must not be modified.
.Pp
Error dictionaries contain a single
.Ft XPC_ERROR_KEY_DESCRIPTION
key. The value of this key is a string object which encapsulates a
human-readable description of the error condition. This value is guaranteed
to be a string type and it is safe to use the
.Fn xpc_dictionary_get_string
function directly to obtain a C string representation of the description.
The contents of this string is intended for diagnostic use and is subject to
change in future releases.
.Pp
Additional keys and values may be added to the error dictionaries over time.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_objects 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_array_create 3
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_double_create.3                          0100644 0001750 0001750 00000031100 12566166531 024411  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_double_get_value.3                       0100644 0001750 0001750 00000031100 12566166531 025121  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_endpoint_create.3                        0100644 0001750 0001750 00000064614 12566166531 024777  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 20 June, 2012
.Dt xpc_connection_create 3
.Os Darwin
.Sh NAME
.Nm xpc_connection_create
.Nd creation and management of XPC connections
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_connection_t
.Fo xpc_connection_create
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_mach_service
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "uint64_t flags"
.Fc
.Ft xpc_connection_t
.Fo xpc_connection_create_from_endpoint
.Fa "xpc_endpoint_t endpoint"
.Fc
.Ft void
.Fo xpc_connection_set_target_queue
.Fa "xpc_connection_t connection"
.Fa "dispatch_queue_t targetq"
.Fc
.Ft void
.Fo xpc_connection_set_event_handler
.Fa "xpc_connection_t connection"
.Fa "xpc_handler_t handler"
.Fc
.Ft void
.Fo xpc_connection_suspend
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_resume
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_send_message
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_send_barrier
.Fa "xpc_connection_t connection"
.Fa "dispatch_block_t barrier"
.Fc
.Ft void
.Fo xpc_connection_send_message_with_reply
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Ft xpc_object_t
.Fo xpc_connection_send_message_with_reply_sync
.Fa "xpc_connection_t connection"
.Fa "xpc_object_t message"
.Fc
.Ft void
.Fo xpc_connection_cancel
.Fa "xpc_connection_t connection"
.Fc
.Ft const char *
.Fo xpc_connection_get_name
.Fa "xpc_connection_t connection"
.Fc
.Ft uid_t
.Fo xpc_connection_get_euid
.Fa "xpc_connection_t connection"
.Fc
.Ft gid_t
.Fo xpc_connection_get_guid
.Fa "xpc_connection_t connection"
.Fc
.Ft pid_t
.Fo xpc_connection_get_pid
.Fa "xpc_connection_t connection"
.Fc
.Ft au_asid_t
.Fo xpc_connection_get_asid
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_context
.Fa "xpc_connection_t connection"
.Fa "void *ctx"
.Fc
.Ft void *
.Fo xpc_connection_get_context
.Fa "xpc_connection_t connection"
.Fc
.Ft void
.Fo xpc_connection_set_finalizer_f
.Fa "xpc_connection_t connection"
.Fa "xpc_finalizer_t finalizer"
.Fc
.Ft xpc_endpoint_t
.Fo xpc_endpoint_create
.Fa "xpc_connection_t connection"
.Fc
.Sh DESCRIPTION
Connections are the fundamental primitives for sending and receiving messages.
Connections also inform the caller of certain non-message events through
errors.
.Pp
Messages sent to a connection are sent in FIFO order, and message-send
operations over a connection are non-blocking. When a message is sent over a
connection, it is atomically enqueued on a queue which is managed by the XPC
runtime. As it becomes possible to successfully deliver messages to the remote
end of the connection, messages will be dequeued from the queue and delivered.
.Pp
Connections may either be used to communicate with XPC services residing within
an application bundle or with a MachService advertised by a launchd job in its
.Xr launchd.plist 5 .
XPC connections maintain a one-to-one relationship between the local and remote
ends of the connection. Therefore, for every connection created to a service,
the remote end will see a distinct peer connection object. This model is
semantically similar to the
.Xr accept 3
model, whereby the server listens on a single file descriptor, and that
listening descriptor emits new file descriptors for each connection that
occurs. 
.Sh EVENT HANDLERS
Each connection must have an event handler associated with it. The event handler
block takes one argument of type
.Fa xpc_object_t .
The event handler block will deliver different types of objects depending on
the nature of the event.
.Pp
The type of object can be queried using
.Xr xpc_get_type 3 .
If the event handler block delivers an object of type
.Ft XPC_TYPE_DICTIONARY ,
the event is a message that needs processing. If the event handler delivers an
object of type
.Ft XPC_TYPE_ERROR ,
an error has occurred on the connection that must be handled.
.Pp
Regardless of the type of object passed to the event handler, the caller will
NOT implicitly gain a reference to the object. Therefore, if the caller wishes
to work with the object after the event handler has returned, it should call
.Xr xpc_retain 3
to keep a reference on the object for itself from within the event handler. It
is unsafe to retain the object after the event handler has returned.
.Pp
The event handler of a connection may be changed while the connection is
processing events using the
.Fn xpc_connection_set_event_handler
API. Calls to this API will
.Em not
interrupt currently-executing invocations of the connection's event handler.
Once the currently-executing event handler returns, the new event handler will
take effect. If called from within the event handler itself, the next invocation
of the event handler will honor the new one set.
.Sh TARGET QUEUES
Each connection has an associated target queue. All connection-related activity
will happen on an internal queue which is synchronized with the target queue.
Event handler invocations are included in connection-related activity. The
target queue may be changed while the connection is processing events using the
.Fn xpc_connection_set_target_queue
API. Setting of the target queue on a connection is asynchronous, and the caller
should not assume that when this API returns, the new target queue is in effect.
The actual change will take place at a later time.
.Pp
By default, all connections target the
.Xr DISPATCH_TARGET_QUEUE_DEFAULT 3
queue. This queue will be used if NULL is given as the
.Fa targetq
argument to
.Fn xpc_connection_set_target_queue ,
.Fn xpc_connection_create
or
.Fn xpc_connection_create_mach_service .
Note that connections received either through the
.Xr xpc_main 3
event handler or the handler given to a connection created with the
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag do not inherit the target queue of that connection. It must always be set
explicitly.
.Pp
.Em Important :
The result of calling
.Xr dispatch_get_current_queue 3
from within a connection's event handler is undefined and should not be
considered reliable for attempting to avoid deadlocks.
.Sh LAUNCH-ON-DEMAND
When the caller obtains a connection to a named service, the fact that it has a
connection does not imply anything about whether the remote end is alive and
running. Connections are virtual, and if the remote end is not yet running, the
act of sending a message will cause it to launch on-demand.
.Pp
If the caller has a connection to a named service, then the remote process
closing the connection or crashing will deliver the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to the event handler. This error is recoverable, and after receiving it,
the connection is still usable. If the caller had previously sent state over the
connection, this error indicates that that state should be updated, if needed,
and resent.
.Pp
.Em NOTE :
Services work best when they are as stateless as possible. Even if you write
perfectly bug-free code, the libraries and frameworks your service links against
may have bugs that could crash the service. So a service must be able to recover
from such abnormal exits.
.Pp
One strategy for implementing a robust and recoverable service is to have each
client of the service maintain state for the service. If the service crashes,
then each client will detect that condition and resend the needed state to the
service so that it can resume any interrupted operations.
.Sh PEERING
The local and remote ends of a connection have a one-to-one association. So when
a new connection to a service is created and has a message sent over it, the
service will receive a new connection in the event handler it specified to
.Xr xpc_main 3 .
If the service is a MachService advertised by
.Xr launchd 8 ,
then the listener connection for the named service will receive the new
connection in its event handler.
.Pp
Even if the same process creates multiple connections to the same service, each
connection will be distinct. The peer connection received by the service will
deliver
.Ft XPC_ERROR_CONNECTION_INVALID
to its event handler when the connection has been closed. These peer connections
cannot be re-created by the XPC runtime, and therefore they will never deliver
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error to their event handlers.
.Sh SUSPEND AND RESUME
All connections are created in a suspended state. Therefore, they will not begin
processing messages or events until an initial call to
.Fn xpc_connection_resume .
Before making this first call to resume the connection, the caller must set an
event handler using
.Fn xpc_connection_set_event_handler .
Note that the initial resume does not need to immediately follow setting the
event handler. The caller is free to delay the initial resume as long as it
chooses.
.Pp
Once a connection has been resumed, it may be suspended to halt the processing
of incoming events and outgoing messages. This behavior is useful to rate-limit
or throttle over-active clients who are sending too many messages or to allow
certain synchronization behaviors with the internal state engine.
.Pp
Each connection maintains a suspend count, so
.Fn xpc_connection_suspend
may be called multiple times on the same connection. The connection will resume
processing events when an equal number of calls to
.Fn xpc_connection_resume
have been performed on the connection, resetting the suspend count to zero.
.Pp
.Em Important :
.Em All
calls to
.Fn xpc_connection_suspend
must be balanced by a call to
.Fn xpc_connection_resume
before the final reference on a connection is released. It is not valid to
release the last reference on a suspended connection.
.Pp
.Em Important :
It is invalid to underflow the suspend count by calling
.Fn xpc_connection_resume
more times than
.Fn xpc_connection_suspend
has been called.
.Sh CONTEXT
Connections may have associated context that can be set and retrieved using the
.Fn xpc_connection_set_context
and
.Fn xpc_connection_get_context
APIs, respectively. When setting context on a connection, an optional finalizer
may be specified using
.Fn xpc_connection_set_finalizer_f .
The function given as the
.Fa finalizer
argument will be invoked just before the connection's memory is being
deallocated. For simple context structures allocated through
.Xr malloc 3 ,
this provides a convenient shortcut. For example:
.Bd -literal -offset indent
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
.Ed
.Pp
.Em Important :
The connection object itself should
.Em not
be referenced or modified in any way within the context of the finalizer.
.Sh MESSAGE SENDING
Messages are sent to the remote end of a connection with the
.Fn xpc_connection_send_message
API. This API will enqueue the
.Fa message
in a FIFO queue which will be drained asynchronously by the XPC runtime. The
caller should not assume that, when this API returns, the message has been
delivered to the remote end. If the caller needs to know when the message has
been processed by the runtime, it should call the
.Fn xpc_connection_send_barrier
API directly after calling
.Fn xpc_connection_send_message .
The supplied
.Fa barrier
block will be invoked by the connection when the runtime has finished processing
the message.
.Pp
.Ss Execution Ordering
.Pp
Send barriers are NOT immediately enqueued on the connection's target queue and
therefore has no guaranteed execution order with respect to other blocks
scheduled on that queue. The following code illustrates this anti-pattern:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
.Ed
.Pp
To achieve the desired effect of deferring the second block's execution until
after the barrier has completed, the caller can use a dispatch group
.Xr (dispatch_group_create 3)
as follows:
.Bd -literal -offset indent
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
.Ed
.Pp
Alternatively, the caller can also
.Xr dispatch_async 3
the second block from within the barrier block.
.Pp
.Em Important :
The caller should not assume that the remote end of the connection has received
the message when a barrier is invoked. Even though the message has been
delivered to the remote end, the remote end may not have yet been scheduled for
execution or may have suspended its end of the connection. The only way for
the sender to know whether the remote end has received the message is to specify
in its message protocol that the remote end must send a message back to the
sender acknowledging receipt of the message.
.Sh REPLY MESSAGES
By default, all messages sent to a connection will result in an invocation of
the remote end's connection's event handler with that message as the argument.
If the caller wishes to tie the invocation of a particular block to a reply
to a particular message, however, it may use the
.Fn xpc_connection_send_message_with_reply
API. Like
.Fn xpc_connection_send_message ,
this API will return immediately and, when the remote end sends a reply back,
the supplied
.Fa handler
block will be submitted to the supplied
.Fa targetq
instead of causing the connection's event handler to be invoked. The reply
handler block may deliver an error to the caller, which indicates that the
remote end will never send a reply.
.Pp The remote end must create the reply message by calling
.Xr xpc_dictionary_create_reply 3
and sending it to its peer connection as it normally would. The caller must,
in turn, specify in the message itself whether it expects a reply to be
delivered.
.Pp
.Em CLIENT SIDE
.Bd -literal -offset indent
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
.Ed
.Pp
.Em SERVICE SIDE
.Bd -literal -offset indent
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, "ExpectsReply")) {
		// Sender has set the protocol-defined "ExpectsReply" key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
.Ed
.Pp
.Em Important :
The invocations of reply handlers are independent of the connection's normal
incoming message stream. Therefore, reply messages are delivered to the
recipient independently of the connection's normal FIFO semantics.
.Sh SYNCHRONOUS OPERATION
If the caller needs to block execution until a reply to a message is received,
it should use the
.Fn xpc_connection_send_message_with_reply_sync
API. This result of this API will be the reply sent by the server. Like the
handler given to
.Fn xpc_connection_send_message_with_reply ,
this API may return errors indicating that the remote end of the connection will
never deliver a reply.
.Pp
.Em Important :
This API is primarily intended for allowing existing synchronous API to be re-
implemented in terms of XPC. But in cases where the you are designing a new API
that calls  out to a service to retrieve a value, we strongly encourage you to
have the API return the value asynchronously using a queue/block pair rather
than blocking the caller until the service returns the requested value:
.Pp
.Bd -literal -offset indent
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, "RetrieveValue", "uint64");

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, "Value");
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
.Ed
.Pp
However, such a scheme may introduce unwanted complexity in the API. The trade-
off for making the example implementation above synchronous involves factors
such as where the data for the response comes from and how likely it is that the
API will be called on the main thread.
.Pp
If the response will be constructed with data that exists in-memory in the
server, it is usually safe to make the API synchronous. But if constructing the
response requires I/O, and it is likely to be called from the main thread (or a
thread which synchronizes with the main thread), we highly encourage that you
take the asynchronous route to avoid the risk of blocking the UI.
.Sh CREDENTIALS
Identifying information about the sending processs can be obtained from a
connection. Available credential information includes the sending
process identifer (PID), effective user identifier (EUID),
effective group identifier (EGID) and audit session identifier (ASID).
These values can be obtained with the functions
.Fn xpc_connection_get_pid ,
.Fn xpc_connection_get_euid ,
.Fn xpc_connection_get_egid
and
.Fn xpc_connection_get_asid 
respectively.
.Pp
Credentials for a connection may not be immediately available. For example, when
creating a new connection with
.Fn xpc_connection_create ,
XPC will not know the credentials of the remote end of the connection until it
has actually exchanged messages with it. Until this credential information is
filled in, these methods will return sensible values to indicate absence of
crucial information.
.Fn xpc_connection_get_pid
will return 0,
.Fn xpc_connection_get_euid
and
.Fn xpc_connection_get_egid
will return -1 and
.Fn xpc_connection_get_asid
will return AU_ASSIGN_ASID (see
.Xr setaudit_addr 2) .
.Pp
For peer connections received through a listener's event handler or through the
handler given to
.Xr xpc_main 3 ,
credentials will be immediately available.
.Pp
Connection credentials have similar semantics to file descriptor credentials.
That is, the credentials that the connection was created with are "baked in" to
it and do not change as a result of calls to
.Xr setuid 3
and friends. Use of these APIs is heavily discouraged in IPC protocols due to
the inherently racy nature of credential checking.
.Pp
.Em Important :
PIDs on OS X roll over when they reach a relatively small value, and a given PID
cannot be assumed to be unique for a given boot session. For services bundled
with an application, this is not a practical concern because the application is
the only process capable of looking up its services. But MachServices advertised
through launchd have a much higher visibility, so extra care should be taken
when checking credentials to mitigate
.Xr fork 2
bomb-style attacks.
.Sh CANCELLATION
A connection may be canceled when it is no longer needed. Once canceled, a
connection will receive the
.Ft XPC_ERROR_CONNECTION_INVALID
error in its event handler, and no further events will be delivered.
Cancellation does not affect the reference count of the connection, so if you
hold references to the connection, they must still be released in order for all
of the connection's associated resources to be freed.
.Pp
Note that, if a connection receives
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler due to other circumstances, it is already in a canceled
state, and therefore a call to
.Fn xpc_connection_cancel
is unnecessary (but harmless) in this case.
.Pp
Canceling a connection on one side has effects on the other side of a
connection. For example, if you cancel a connection received through a listener
connection's event handler, the remote peer connection will receive
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
in its event handler. Even though the connection was canceled, the remote end is
still able to send messages to the connection.
.Pp
If, on the other hand, the creator of a named connection cancels the connection,
the peer connection given to the remote end through a listener connection will
receive
.Ft XPC_ERROR_CONNECTION_INVALID
in its event handler.
.Pp
.Em Important :
As discussed previously, some connections (such as named connections created
through
.Fn xpc_connection_create )
will not receive
.Ft XPC_ERROR_CONNECTION_INVALID
in the normal course of their operation. But if another part of your code can
end up calling
.Fn xpc_connection_cancel ,
then the connection's event handler must handle this error.
.Sh BUNDLED SERVICES
Applications may include XPC service bundles in their own bundle. When the
application is run, the XPC runtime automatically recognizes each bundled
service and makes it accessible to the application through the
.Fn xpc_connection_create
API. To connect to a bundled service, the caller must pass the
CFBundleIdentifier specified in the service's Info.plist as the
.Fa name
argument. The service itself will call
.Xr xpc_main 3
to initialize its runtime, and the provided event handler function will be
invoked with any incoming connections.
.Pp
Services bundled with an application are
.Em only
accessible to that application. An external process cannot connect to those
services.
.Sh MACH SERVICES
If a caller wishes to connect to a MachService advertised in a
.Xr launchd.plist 5 ,
it should pass the MachService name to which it wishes to connect with
.Fn xpc_connection_create_mach_service .
If the destination service is advertised in the root Mach bootstrap (i.e. the
.Xr launchd.plist 5
lives in /Library/LaunchDaemons), the caller may ensure that the service that it
connects to is privileged and not being spoofed through a man-in-the-middle
attack by OR'ing the
.Ft XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag into the
.Fa flags
argument. This flag will cause
.Ft XPC_ERROR_CONNECTION_INVALID
to be given to the event handler if the service name was not found in the root
Mach bootstrap. If the 
.Xr launchd.plist 5
lives in /Library/LaunchAgents or ~/Library/LaunchAgents, then this flag should
not be passed.
.Pp
The launchd job using XPC is required to create a listener connection manually
by calling
.Fn xpc_connection_create_mach_service
with the 
.Ft XPC_CONNECTION_MACH_SERVICE_LISTENER
flag OR'ed into the
.Fa flags
argument. The
.Fa XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
flag has no effect on these connections. If the service name for the connection
is not present in your launchd.plist's MachServices dictionary, your listener
connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID error,
as XPC disallows ad-hoc service name registrations.  However, assuming your
configuration is correct, the listener connection will only ever deliver new
peer connections to its event handler. The connections received by the event
handler must have an event hander set on them and resumed along with an optional
target queue, just like the peer
connections delivered to the handler given to
.Xr xpc_main 3 .
Note connections received through listener connection's event handler do not
inherit the target queue of the listener.
.Pp
.Bd -literal -offset indent
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service("com.apple.myservice", NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_resume(peer);
	});
	xpc_connection_resume(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
.Ed
.Pp
.Em Important :
New service names may
.Em NOT
be dynamically registered using
.Fn xpc_connection_create_mach_service .
Only launchd jobs may listen on certain service names, and any service name that
the job wishes to listen on must be declared in its
.Xr launchd.plist 5 .
XPC may make allowances for dynamic name registration in debug scenarios, but
these allowances absolutely will
.Em NOT
be made in the production scenario.
.Sh UNLOADING
An XPC connection to a MachService advertised by a
.Xr launchd 8
job will receive the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
error followed by the
.Ft XPC_ERROR_CONNECTION_INVALID
error if the job is unloaded. There will be no indication of when the job has
been loaded again. Using job loading and unloading as a normal part of your
job's operation is highly discouraged.
.Sh ANONYMOUS CONNECTIONS
If a caller wishes to create a listener connection that is not bound to a
particular service name, it may create an anonymous listener connection by
calling
.Fn xpc_connection_create
and passing NULL as the
.Fa name .
This connection may be given to
.Xr xpc_endpoint_create 3 ,
and the result may be embedded in a message. The recipient of that message will
then be able to create a connection from that endpoint using
.Fn xpc_connection_create_from_endpoint .
.Pp
The resulting connection will behave like a connection to a named service
created using
.Fn xpc_connection_create .
The fundamental difference is that an anonymous connection is not backed a name
that can be looked up. Therefore, if an connection created from an endpoint is
closed, there is no guarantee that it can be re-established. So anonymous
connections' event handlers must always handle
.Em both
the
.Ft XPC_ERROR_CONNECTION_INTERRUPTED
and
.Ft XPC_ERROR_CONNECTION_INVALID
errors.
.Pp
The
.Ft endpoint
type may be thought of as a boxed connection, in the same way that
the 
.Ft uint64
type is a boxed
.Ft uint64_t .
Like other types, the collection APIs provide primitive setters and getters for
connections, so instead of first boxing a connection in an endpoint, the
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_create_connection 3 ,
.Xr xpc_array_set_connection 3 ,
and
.Xr xpc_array_create_connection 3
APIs may be used.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_main 3 ,
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_objects 3 ,
.Xr setaudit_addr 2 ,
.Xr dispatch_group_create 3
                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_equal.3                                  0100644 0001750 0001750 00000022304 12566166531 022731  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011-2012 Apple Inc. All rights reserved.
.Dd 1 March, 2012
.Dt xpc_object 3
.Os Darwin
.Sh NAME
.Nm xpc_object
.Nd XPC object protocol
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_retain
.Fa "xpc_object_t object"
.Fc
.Ft void
.Fo xpc_release
.Fa "xpc_object_t object"
.Fc
.Ft xpc_type_t
.Fo xpc_get_type
.Fa "xpc_object_t object"
.Fc
.Ft xpc_object_t
.Fo xpc_copy
.Fa "xpc_object_t object"
.Fc
.Ft bool
.Fo xpc_equal
.Fa "xpc_object_t object1"
.Fa "xpc_object_t object2"
.Fc
.Ft size_t
.Fo xpc_hash
.Fa "xpc_object_t object"
.Fc
.Ft char *
.Fo xpc_copy_description
.Fa "xpc_object_t object"
.Fc
.Sh DESCRIPTION
XPC objects share functions for coordinating memory management, type checking,
comparing for equality, and hashing.
.Sh MEMORY MANAGEMENT
Objects returned by creation functions in the XPC framework may be uniformly
retained and released with the functions
.Fn xpc_retain
and
.Fn xpc_release
respectively.
.Pp
The XPC framework does not guarantee that any given client has the last or only
reference to a given object. Objects may be retained internally by the system.
.Pp
Functions which return objects follow the conventional create, copy and get
naming rules:
.Bl -tag -width "XXcreate" -compact -offset indent
.It \(bu create
A new object with a single reference is returned. This reference should be
released by the caller.
.It \(bu copy
A copy or retained object reference is returned. This reference should be
released by the caller.
.It \(bu get
An unretained reference to an existing object is returned. The caller
.Em must not
release this reference, and is responsible for retaining the object for later
use if necessary.
.El
.Ss INTEGRATION WITH OBJECTIVE-C
.Bd -filled -offset indent
When building with an Objective-C or Objective-C++ compiler, XPC objects are
declared as Objective-C types. This results in the following differences
compared to building as plain C/C++:
.Bl -dash
.It
if Objective-C Automated Reference Counting is enabled, XPC objects are
memory managed by the Objective-C runtime and explicit calls to the
.Fn xpc_retain
and
.Fn xpc_release
functions will produce build errors.
.Pp
.Em Note :
when ARC is enabled, care needs to be taken with XPC API returning an interior
pointer that is only valid as long as an associated object has not been
released. If that object is held in a variable with automatic storage, it may
need to be annotated with the
.Li objc_precise_lifetime
attribute, or stored in a
.Li __strong
instance variable instead, to ensure that the object is not prematurely
released. The functions returning interior pointers are:
.Bl -bullet -compact -offset indent
.It
.Xr xpc_data_get_bytes_ptr 3 ,
.Xr xpc_string_get_string_ptr 3 ,
.Xr xpc_uuid_get_bytes 3
.It
.Xr xpc_array_get_data 3 ,
.Xr xpc_array_get_string 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_dictionary_get_uuid 3
.El
.It
the Blocks runtime automatically retains and releases XPC objects captured by
blocks upon
.Fn Block_copy
and
.Fn Block_release ,
e.g.\& as performed during asynchronous execution of a block via
.Xr dispatch_async 3 .
.Pp
.Em Note :
retain cycles may be encountered if XPC connection objects are captured by
their handler blocks; these cycles can be broken by declaring the captured
object
.Li __weak
or by calling
.Xr xpc_connection_cancel 3
to cause its handler blocks to be released explicitly.
.It
XPC objects can be added directly to Cocoa collections, and their
lifetime is tracked by the Objective-C static analyzer.
.El
.Pp
Integration of XPC objects with Objective-C requires targeting Mac\ OS\ X
10.8 or later, and is disabled when building with Objective-C Garbage
Collection or for the legacy Objective-C runtime. It can also be disabled
manually by using compiler options to define the
.Dv OS_OBJECT_USE_OBJC
preprocessor macro to
.Li 0 .
.Ed
.Pp
.Em Important :
When building with a plain C/C++ compiler or when integration with Objective-C
is disabled, XPC objects are
.Em not
automatically retained and released when captured by a block. Therefore, when a
XPC object is captured by a block that will be executed asynchronously, the
object must be manually retained and released:
.Pp
.Bd -literal -offset indent
xpc_retain(object);
dispatch_async(queue, ^{
	do_something_with_object(object);
	xpc_release(object);
});
.Ed
.Sh TYPES
The
.Fn xpc_get_type
function returns the type of an XPC object as a pointer of type
.Ft xpc_type t .
The returned type may be compared against the type constants defined by the
XPC framework with simple pointer equality.
.Pp
Type constants:
.Bl -bullet -compact -offset indent
.It
XPC_TYPE_CONNECTION
.It
XPC_TYPE_ENDPOINT
.It
XPC_TYPE_NULL
.It
XPC_TYPE_BOOL
.It
XPC_TYPE_INT64
.It
XPC_TYPE_UINT64
.It
XPC_TYPE_DOUBLE
.It
XPC_TYPE_DATE
.It
XPC_TYPE_DATA
.It
XPC_TYPE_STRING
.It
XPC_TYPE_UUID
.It
XPC_TYPE_FD
.It
XPC_TYPE_SHMEM
.It
XPC_TYPE_ARRAY
.It
XPC_TYPE_DICTIONARY
.El
.Sh BOXED OBJECTS AND COLLECTIONS
Most XPC object types are boxed representations of primitive C language types
or low-level operating system handles. These boxed objects are immutable.
.Pp
The XPC framework provides two collection types: dictionaries and arrays.
These types are mutable and may have boxed objects added or removed from the
collection.
.Pp
A suite of primitive get and set functions are available for the dictionary
and array types. These functions allow for the insertion and extraction of
primitive values from the collection directly, without the need for
intermediate boxed objects.
.Pp
The following is a list of primitive get and set functions for the dictionary
collection type:
.Pp
.Bl -bullet -compact -offset indent
.It
.Xr xpc_dictionary_set_bool 3 ,
.Xr xpc_dictionary_get_bool 3 ,
.Xr xpc_array_set_bool 3 ,
.Xr xpc_array_get_bool 3
.It
.Xr xpc_dictionary_set_int64 3 ,
.Xr xpc_dictionary_get_int64 3 ,
.Xr xpc_array_set_int64 3 ,
.Xr xpc_array_get_int64 3
.It
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_array_set_uint64 3 ,
.Xr xpc_array_get_uint64 3
.It
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_array_set_double 3 ,
.Xr xpc_array_get_double 3
.It
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_array_set_date 3 ,
.Xr xpc_array_get_date 3
.It
.Xr xpc_dictionary_set_data 3 ,
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_array_set_data 3 ,
.Xr xpc_array_get_data 3
.It
.Xr xpc_dictionary_set_string 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_array_set_string 3 ,
.Xr xpc_array_get_string 3
.It
.Xr xpc_dictionary_set_uuid 3 ,
.Xr xpc_dictionary_get_uuid 3 ,
.Xr xpc_array_set_uuid 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_set_fd 3 ,
.Xr xpc_dictionary_dup_fd 3 ,
.Xr xpc_array_set_fd 3 ,
.Xr xpc_array_dup_fd 3
.It
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_get_connection 3 ,
.Xr xpc_array_set_connection 3 ,
.Xr xpc_array_get_connection 3
.El
.Pp
When the requested key or index is not present in the collection, or if the
value for the requested key or index is not of the expected type, these
functions will return sensible default values:
.Pp
.Bl -tag -width "XXconnection" -compact -offset indent
.It \(bu bool
false
.It \(bu int64
0
.It \(bu uint64
0
.It \(bu double
NAN
.It \(bu date
0
.It \(bu data
NULL
.It \(bu uuid
NULL
.It \(bu string
NULL
.It \(bu fd
-1
.It \(bu connection
NULL
.El
.Pp
.Sh COPYING
Objects may be copied using the
.Fn xpc_copy
function. The result of
.Fn xpc_copy
may or may not be a brand new object (i.e. a different pointer). The system may
choose to return the same object with an additional reference rather than doing
a complete copy for efficiency reasons.
.Sh EQUALITY
Two objects may be compared for equality using the
.Fn xpc_equal
function.
Objects must be of the same type as returned by
.Fn xpc_get_type
in order to be considered equal. No casting or transformation is performed
on the underlying value in order to determine equality.
.Pp
Collection types are compared for deep equality, that is to say, two arrays
are equal only if they contain the same values in the same order, and two
dictionaries are equal only if they contain the same values for the same keys.
.Pp
.Em Important :
File descriptors and shared memory objects cannot be reliably compared for
equality, and therefore the
.Fn xpc_equal
function will only perform a simple pointer-equality check for these objects.
.Pp
Objects may be hashed using the
.Fn xpc_hash
function. The result of the hash function is guaranteed to be identical for
objects which compare to be equal using
.Fn xpc_equal .
.Pp
.Em Important :
The hash value for a given object should not be considered portable across
multiple processes or releases of the operating system and as a result should
not be stored in a permanent fashion.
.Sh OBJECT DESCRIPTIONS
The
.Fn xpc_copy_description
function may be used to produce a human-readable description of an object.
The returned C-string must be freed by the caller using
.Xr free 3 .
.Pp
.Em Important :
The format of this description is not guaranteed to remain consistent across
releases, and the output should only be used for debugging purposes.
.Sh SEE ALSO
.Xr dispatch_async 3 ,
.Xr xpc_abort 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_cancel 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_endpoint_create 3 ,
.Xr xpc_objects 3
                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_events.3                                 0100644 0001750 0001750 00000011267 12566166531 023134  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_events 3
.Os Darwin
.Sh NAME
.Nm xpc_events
.Nd launch-on-demand for high-level events
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft void
.Fo xpc_set_event_stream_handler
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Sh DESCRIPTION
XPC provides a mechanism by which launchd jobs may launch on-demand for certain
higher-level events, such as IOKit events or BSD Notifications. These events are
delivered to the job through a handler that is set early in its execution. The
period between when the event is delivered to the job and when a handler is set
is race-free, and any pending events will be queued up for consumption by the
job. An event is consumed when it is delivered to the handler.
.Sh EVENT STREAMS
Providers of events are known as streams. Two example event streams are the
IOKit stream and the BSD Notifications stream. Streams are denoted by a
reverse-DNS naming scheme. For the aforementioned examples, the stream names are
"com.apple.iokit.matching" and "com.apple.notifyd.matching", respectively. These
are currently the only two supported event streams.
.Sh EVENT NAMES
A launchd job may be interested in multiple events from different event streams.
Each of these events has a name provided by the job in the
.Xr launchd.plist 5 .
.Pp
The occurrence of any of these events will launch the job on-demand if it is not
already running.
.Sh PLIST SCHEMA
Events are specified through the
.Xr launchd.plist 5
with the LaunchEvents key. The value for this key is a dictionary. Each value of
this dictionary is itself a dictionary corresponding to an event stream. The
values of this inner dictionary are events that may cause the job to be launched
on-demand.
.Pp
.Bd -literal -offset indent
<key>LaunchEvents</key>
<dict>
	<key>com.apple.iokit.matching</key>
	<dict>
		<key>com.apple.device-attach</key>
		<dict>
			<key>idProduct</key>
			<integer>2794</integer>
			<key>idVendor</key>
			<integer>725</integer>
			<key>IOProviderClass</key>
			<string>IOUSBDevice</string>
			<key>IOMatchLaunchStream</key>
			<true/>
		</dict>
	</dict>
	<key>com.apple.notifyd.matching</key>
	<dict>
		<key>com.apple.interesting-notification</key>
		<dict>
			<key>Notification</key>
			<string>com.apple.interesting-notification</string>
		</dict>
	</dict>
</dict>
.Ed
.Pp
The above specifies that the job will be launched when a node matching the given
matching dictionary appears in the IORegistry or when a notification named
"com.apple.interesting-notification" is posted using
.Xr notify_post 3 .
.Pp
.Em NOTE :
The IOMatchLaunchStream key is required to be present and be a Boolean set to
.Ft true
for use with XPC Events. It will be filtered out of the rest of the dictionary
when given to IOKit to match. The reasons for this are historical and not
applicable to other event streams.
.Pp
Each event stream has a different plist schema.
.Sh EVENT CONSUMPTION
Events are consumed with the
.Fn xpc_set_event_stream_handler
API. The
.Fa stream
argument specifies from which event stream the given
.Fa handler
will receive events. The
.Fa targetq
parameter specifies on which queue the handler will be synchronized.
The
.Fa handler
will only ever receive dictionaries. Each dictionary is guaranteed to have the
.Ft XPC_EVENT_KEY_NAME
key set. The value for this key is the string that was given as the name for the
event in the
.Xr launchd.plist 5 .
So if the IOKit event in the above example was received, the value of this key
would be "com.apple.device-attach".
.Pp
In addition to the standard payload, events from the IOKit stream also have the
"IOMatchLaunchServiceID" key set to a
.Ft uint64_t
which specifies the unique IORegistry ID of the node which matched the given
dictionary as obtained by
.Fn IORegistryEntryGetRegistryEntryID .
This value may be given to
.Fn IORegistryEntryIDMatching
to obtain the registry entry which caused the event to fire.
.Pp
BSD Notfication events have no additional payload.
.Bd -literal -offset indent
xpc_set_event_stream_handler("com.apple.iokit.matching", q, ^(xpc_object_t event) {
	const char *name = xpc_dictionary_get_string(event, XPC_EVENT_KEY_NAME);
	uint64_t id = xpc_dictionary_get_uint64(event, "IOMatchLaunchServiceID");

	CFMutableDictionaryRef matching = IORegistryEntryIDMatching(id);
	// Pass to IOServiceGetMatchingServices() or IOServiceAddNotification().
});
.Ed
.Pp
.Em IMPORTANT :
.Fn xpc_set_event_stream_handler
is NOT shareable. Two different subsystems in a process cannot safely both
register for events from the same event stream. Therefore, libraries and
frameworks should
.Em NEVER
call this API.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr notify 3
                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_fd_create.3                              0100644 0001750 0001750 00000031100 12566166531 023530  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_fd_dup.3                                 0100644 0001750 0001750 00000031100 12566166531 023055  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_get_type.3                               0100644 0001750 0001750 00000022304 12566166531 023442  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011-2012 Apple Inc. All rights reserved.
.Dd 1 March, 2012
.Dt xpc_object 3
.Os Darwin
.Sh NAME
.Nm xpc_object
.Nd XPC object protocol
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_retain
.Fa "xpc_object_t object"
.Fc
.Ft void
.Fo xpc_release
.Fa "xpc_object_t object"
.Fc
.Ft xpc_type_t
.Fo xpc_get_type
.Fa "xpc_object_t object"
.Fc
.Ft xpc_object_t
.Fo xpc_copy
.Fa "xpc_object_t object"
.Fc
.Ft bool
.Fo xpc_equal
.Fa "xpc_object_t object1"
.Fa "xpc_object_t object2"
.Fc
.Ft size_t
.Fo xpc_hash
.Fa "xpc_object_t object"
.Fc
.Ft char *
.Fo xpc_copy_description
.Fa "xpc_object_t object"
.Fc
.Sh DESCRIPTION
XPC objects share functions for coordinating memory management, type checking,
comparing for equality, and hashing.
.Sh MEMORY MANAGEMENT
Objects returned by creation functions in the XPC framework may be uniformly
retained and released with the functions
.Fn xpc_retain
and
.Fn xpc_release
respectively.
.Pp
The XPC framework does not guarantee that any given client has the last or only
reference to a given object. Objects may be retained internally by the system.
.Pp
Functions which return objects follow the conventional create, copy and get
naming rules:
.Bl -tag -width "XXcreate" -compact -offset indent
.It \(bu create
A new object with a single reference is returned. This reference should be
released by the caller.
.It \(bu copy
A copy or retained object reference is returned. This reference should be
released by the caller.
.It \(bu get
An unretained reference to an existing object is returned. The caller
.Em must not
release this reference, and is responsible for retaining the object for later
use if necessary.
.El
.Ss INTEGRATION WITH OBJECTIVE-C
.Bd -filled -offset indent
When building with an Objective-C or Objective-C++ compiler, XPC objects are
declared as Objective-C types. This results in the following differences
compared to building as plain C/C++:
.Bl -dash
.It
if Objective-C Automated Reference Counting is enabled, XPC objects are
memory managed by the Objective-C runtime and explicit calls to the
.Fn xpc_retain
and
.Fn xpc_release
functions will produce build errors.
.Pp
.Em Note :
when ARC is enabled, care needs to be taken with XPC API returning an interior
pointer that is only valid as long as an associated object has not been
released. If that object is held in a variable with automatic storage, it may
need to be annotated with the
.Li objc_precise_lifetime
attribute, or stored in a
.Li __strong
instance variable instead, to ensure that the object is not prematurely
released. The functions returning interior pointers are:
.Bl -bullet -compact -offset indent
.It
.Xr xpc_data_get_bytes_ptr 3 ,
.Xr xpc_string_get_string_ptr 3 ,
.Xr xpc_uuid_get_bytes 3
.It
.Xr xpc_array_get_data 3 ,
.Xr xpc_array_get_string 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_dictionary_get_uuid 3
.El
.It
the Blocks runtime automatically retains and releases XPC objects captured by
blocks upon
.Fn Block_copy
and
.Fn Block_release ,
e.g.\& as performed during asynchronous execution of a block via
.Xr dispatch_async 3 .
.Pp
.Em Note :
retain cycles may be encountered if XPC connection objects are captured by
their handler blocks; these cycles can be broken by declaring the captured
object
.Li __weak
or by calling
.Xr xpc_connection_cancel 3
to cause its handler blocks to be released explicitly.
.It
XPC objects can be added directly to Cocoa collections, and their
lifetime is tracked by the Objective-C static analyzer.
.El
.Pp
Integration of XPC objects with Objective-C requires targeting Mac\ OS\ X
10.8 or later, and is disabled when building with Objective-C Garbage
Collection or for the legacy Objective-C runtime. It can also be disabled
manually by using compiler options to define the
.Dv OS_OBJECT_USE_OBJC
preprocessor macro to
.Li 0 .
.Ed
.Pp
.Em Important :
When building with a plain C/C++ compiler or when integration with Objective-C
is disabled, XPC objects are
.Em not
automatically retained and released when captured by a block. Therefore, when a
XPC object is captured by a block that will be executed asynchronously, the
object must be manually retained and released:
.Pp
.Bd -literal -offset indent
xpc_retain(object);
dispatch_async(queue, ^{
	do_something_with_object(object);
	xpc_release(object);
});
.Ed
.Sh TYPES
The
.Fn xpc_get_type
function returns the type of an XPC object as a pointer of type
.Ft xpc_type t .
The returned type may be compared against the type constants defined by the
XPC framework with simple pointer equality.
.Pp
Type constants:
.Bl -bullet -compact -offset indent
.It
XPC_TYPE_CONNECTION
.It
XPC_TYPE_ENDPOINT
.It
XPC_TYPE_NULL
.It
XPC_TYPE_BOOL
.It
XPC_TYPE_INT64
.It
XPC_TYPE_UINT64
.It
XPC_TYPE_DOUBLE
.It
XPC_TYPE_DATE
.It
XPC_TYPE_DATA
.It
XPC_TYPE_STRING
.It
XPC_TYPE_UUID
.It
XPC_TYPE_FD
.It
XPC_TYPE_SHMEM
.It
XPC_TYPE_ARRAY
.It
XPC_TYPE_DICTIONARY
.El
.Sh BOXED OBJECTS AND COLLECTIONS
Most XPC object types are boxed representations of primitive C language types
or low-level operating system handles. These boxed objects are immutable.
.Pp
The XPC framework provides two collection types: dictionaries and arrays.
These types are mutable and may have boxed objects added or removed from the
collection.
.Pp
A suite of primitive get and set functions are available for the dictionary
and array types. These functions allow for the insertion and extraction of
primitive values from the collection directly, without the need for
intermediate boxed objects.
.Pp
The following is a list of primitive get and set functions for the dictionary
collection type:
.Pp
.Bl -bullet -compact -offset indent
.It
.Xr xpc_dictionary_set_bool 3 ,
.Xr xpc_dictionary_get_bool 3 ,
.Xr xpc_array_set_bool 3 ,
.Xr xpc_array_get_bool 3
.It
.Xr xpc_dictionary_set_int64 3 ,
.Xr xpc_dictionary_get_int64 3 ,
.Xr xpc_array_set_int64 3 ,
.Xr xpc_array_get_int64 3
.It
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_array_set_uint64 3 ,
.Xr xpc_array_get_uint64 3
.It
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_array_set_double 3 ,
.Xr xpc_array_get_double 3
.It
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_array_set_date 3 ,
.Xr xpc_array_get_date 3
.It
.Xr xpc_dictionary_set_data 3 ,
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_array_set_data 3 ,
.Xr xpc_array_get_data 3
.It
.Xr xpc_dictionary_set_string 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_array_set_string 3 ,
.Xr xpc_array_get_string 3
.It
.Xr xpc_dictionary_set_uuid 3 ,
.Xr xpc_dictionary_get_uuid 3 ,
.Xr xpc_array_set_uuid 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_set_fd 3 ,
.Xr xpc_dictionary_dup_fd 3 ,
.Xr xpc_array_set_fd 3 ,
.Xr xpc_array_dup_fd 3
.It
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_get_connection 3 ,
.Xr xpc_array_set_connection 3 ,
.Xr xpc_array_get_connection 3
.El
.Pp
When the requested key or index is not present in the collection, or if the
value for the requested key or index is not of the expected type, these
functions will return sensible default values:
.Pp
.Bl -tag -width "XXconnection" -compact -offset indent
.It \(bu bool
false
.It \(bu int64
0
.It \(bu uint64
0
.It \(bu double
NAN
.It \(bu date
0
.It \(bu data
NULL
.It \(bu uuid
NULL
.It \(bu string
NULL
.It \(bu fd
-1
.It \(bu connection
NULL
.El
.Pp
.Sh COPYING
Objects may be copied using the
.Fn xpc_copy
function. The result of
.Fn xpc_copy
may or may not be a brand new object (i.e. a different pointer). The system may
choose to return the same object with an additional reference rather than doing
a complete copy for efficiency reasons.
.Sh EQUALITY
Two objects may be compared for equality using the
.Fn xpc_equal
function.
Objects must be of the same type as returned by
.Fn xpc_get_type
in order to be considered equal. No casting or transformation is performed
on the underlying value in order to determine equality.
.Pp
Collection types are compared for deep equality, that is to say, two arrays
are equal only if they contain the same values in the same order, and two
dictionaries are equal only if they contain the same values for the same keys.
.Pp
.Em Important :
File descriptors and shared memory objects cannot be reliably compared for
equality, and therefore the
.Fn xpc_equal
function will only perform a simple pointer-equality check for these objects.
.Pp
Objects may be hashed using the
.Fn xpc_hash
function. The result of the hash function is guaranteed to be identical for
objects which compare to be equal using
.Fn xpc_equal .
.Pp
.Em Important :
The hash value for a given object should not be considered portable across
multiple processes or releases of the operating system and as a result should
not be stored in a permanent fashion.
.Sh OBJECT DESCRIPTIONS
The
.Fn xpc_copy_description
function may be used to produce a human-readable description of an object.
The returned C-string must be freed by the caller using
.Xr free 3 .
.Pp
.Em Important :
The format of this description is not guaranteed to remain consistent across
releases, and the output should only be used for debugging purposes.
.Sh SEE ALSO
.Xr dispatch_async 3 ,
.Xr xpc_abort 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_cancel 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_endpoint_create 3 ,
.Xr xpc_objects 3
                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_hash.3                                   0100644 0001750 0001750 00000022304 12566166531 022545  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011-2012 Apple Inc. All rights reserved.
.Dd 1 March, 2012
.Dt xpc_object 3
.Os Darwin
.Sh NAME
.Nm xpc_object
.Nd XPC object protocol
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_retain
.Fa "xpc_object_t object"
.Fc
.Ft void
.Fo xpc_release
.Fa "xpc_object_t object"
.Fc
.Ft xpc_type_t
.Fo xpc_get_type
.Fa "xpc_object_t object"
.Fc
.Ft xpc_object_t
.Fo xpc_copy
.Fa "xpc_object_t object"
.Fc
.Ft bool
.Fo xpc_equal
.Fa "xpc_object_t object1"
.Fa "xpc_object_t object2"
.Fc
.Ft size_t
.Fo xpc_hash
.Fa "xpc_object_t object"
.Fc
.Ft char *
.Fo xpc_copy_description
.Fa "xpc_object_t object"
.Fc
.Sh DESCRIPTION
XPC objects share functions for coordinating memory management, type checking,
comparing for equality, and hashing.
.Sh MEMORY MANAGEMENT
Objects returned by creation functions in the XPC framework may be uniformly
retained and released with the functions
.Fn xpc_retain
and
.Fn xpc_release
respectively.
.Pp
The XPC framework does not guarantee that any given client has the last or only
reference to a given object. Objects may be retained internally by the system.
.Pp
Functions which return objects follow the conventional create, copy and get
naming rules:
.Bl -tag -width "XXcreate" -compact -offset indent
.It \(bu create
A new object with a single reference is returned. This reference should be
released by the caller.
.It \(bu copy
A copy or retained object reference is returned. This reference should be
released by the caller.
.It \(bu get
An unretained reference to an existing object is returned. The caller
.Em must not
release this reference, and is responsible for retaining the object for later
use if necessary.
.El
.Ss INTEGRATION WITH OBJECTIVE-C
.Bd -filled -offset indent
When building with an Objective-C or Objective-C++ compiler, XPC objects are
declared as Objective-C types. This results in the following differences
compared to building as plain C/C++:
.Bl -dash
.It
if Objective-C Automated Reference Counting is enabled, XPC objects are
memory managed by the Objective-C runtime and explicit calls to the
.Fn xpc_retain
and
.Fn xpc_release
functions will produce build errors.
.Pp
.Em Note :
when ARC is enabled, care needs to be taken with XPC API returning an interior
pointer that is only valid as long as an associated object has not been
released. If that object is held in a variable with automatic storage, it may
need to be annotated with the
.Li objc_precise_lifetime
attribute, or stored in a
.Li __strong
instance variable instead, to ensure that the object is not prematurely
released. The functions returning interior pointers are:
.Bl -bullet -compact -offset indent
.It
.Xr xpc_data_get_bytes_ptr 3 ,
.Xr xpc_string_get_string_ptr 3 ,
.Xr xpc_uuid_get_bytes 3
.It
.Xr xpc_array_get_data 3 ,
.Xr xpc_array_get_string 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_dictionary_get_uuid 3
.El
.It
the Blocks runtime automatically retains and releases XPC objects captured by
blocks upon
.Fn Block_copy
and
.Fn Block_release ,
e.g.\& as performed during asynchronous execution of a block via
.Xr dispatch_async 3 .
.Pp
.Em Note :
retain cycles may be encountered if XPC connection objects are captured by
their handler blocks; these cycles can be broken by declaring the captured
object
.Li __weak
or by calling
.Xr xpc_connection_cancel 3
to cause its handler blocks to be released explicitly.
.It
XPC objects can be added directly to Cocoa collections, and their
lifetime is tracked by the Objective-C static analyzer.
.El
.Pp
Integration of XPC objects with Objective-C requires targeting Mac\ OS\ X
10.8 or later, and is disabled when building with Objective-C Garbage
Collection or for the legacy Objective-C runtime. It can also be disabled
manually by using compiler options to define the
.Dv OS_OBJECT_USE_OBJC
preprocessor macro to
.Li 0 .
.Ed
.Pp
.Em Important :
When building with a plain C/C++ compiler or when integration with Objective-C
is disabled, XPC objects are
.Em not
automatically retained and released when captured by a block. Therefore, when a
XPC object is captured by a block that will be executed asynchronously, the
object must be manually retained and released:
.Pp
.Bd -literal -offset indent
xpc_retain(object);
dispatch_async(queue, ^{
	do_something_with_object(object);
	xpc_release(object);
});
.Ed
.Sh TYPES
The
.Fn xpc_get_type
function returns the type of an XPC object as a pointer of type
.Ft xpc_type t .
The returned type may be compared against the type constants defined by the
XPC framework with simple pointer equality.
.Pp
Type constants:
.Bl -bullet -compact -offset indent
.It
XPC_TYPE_CONNECTION
.It
XPC_TYPE_ENDPOINT
.It
XPC_TYPE_NULL
.It
XPC_TYPE_BOOL
.It
XPC_TYPE_INT64
.It
XPC_TYPE_UINT64
.It
XPC_TYPE_DOUBLE
.It
XPC_TYPE_DATE
.It
XPC_TYPE_DATA
.It
XPC_TYPE_STRING
.It
XPC_TYPE_UUID
.It
XPC_TYPE_FD
.It
XPC_TYPE_SHMEM
.It
XPC_TYPE_ARRAY
.It
XPC_TYPE_DICTIONARY
.El
.Sh BOXED OBJECTS AND COLLECTIONS
Most XPC object types are boxed representations of primitive C language types
or low-level operating system handles. These boxed objects are immutable.
.Pp
The XPC framework provides two collection types: dictionaries and arrays.
These types are mutable and may have boxed objects added or removed from the
collection.
.Pp
A suite of primitive get and set functions are available for the dictionary
and array types. These functions allow for the insertion and extraction of
primitive values from the collection directly, without the need for
intermediate boxed objects.
.Pp
The following is a list of primitive get and set functions for the dictionary
collection type:
.Pp
.Bl -bullet -compact -offset indent
.It
.Xr xpc_dictionary_set_bool 3 ,
.Xr xpc_dictionary_get_bool 3 ,
.Xr xpc_array_set_bool 3 ,
.Xr xpc_array_get_bool 3
.It
.Xr xpc_dictionary_set_int64 3 ,
.Xr xpc_dictionary_get_int64 3 ,
.Xr xpc_array_set_int64 3 ,
.Xr xpc_array_get_int64 3
.It
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_array_set_uint64 3 ,
.Xr xpc_array_get_uint64 3
.It
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_array_set_double 3 ,
.Xr xpc_array_get_double 3
.It
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_array_set_date 3 ,
.Xr xpc_array_get_date 3
.It
.Xr xpc_dictionary_set_data 3 ,
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_array_set_data 3 ,
.Xr xpc_array_get_data 3
.It
.Xr xpc_dictionary_set_string 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_array_set_string 3 ,
.Xr xpc_array_get_string 3
.It
.Xr xpc_dictionary_set_uuid 3 ,
.Xr xpc_dictionary_get_uuid 3 ,
.Xr xpc_array_set_uuid 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_set_fd 3 ,
.Xr xpc_dictionary_dup_fd 3 ,
.Xr xpc_array_set_fd 3 ,
.Xr xpc_array_dup_fd 3
.It
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_get_connection 3 ,
.Xr xpc_array_set_connection 3 ,
.Xr xpc_array_get_connection 3
.El
.Pp
When the requested key or index is not present in the collection, or if the
value for the requested key or index is not of the expected type, these
functions will return sensible default values:
.Pp
.Bl -tag -width "XXconnection" -compact -offset indent
.It \(bu bool
false
.It \(bu int64
0
.It \(bu uint64
0
.It \(bu double
NAN
.It \(bu date
0
.It \(bu data
NULL
.It \(bu uuid
NULL
.It \(bu string
NULL
.It \(bu fd
-1
.It \(bu connection
NULL
.El
.Pp
.Sh COPYING
Objects may be copied using the
.Fn xpc_copy
function. The result of
.Fn xpc_copy
may or may not be a brand new object (i.e. a different pointer). The system may
choose to return the same object with an additional reference rather than doing
a complete copy for efficiency reasons.
.Sh EQUALITY
Two objects may be compared for equality using the
.Fn xpc_equal
function.
Objects must be of the same type as returned by
.Fn xpc_get_type
in order to be considered equal. No casting or transformation is performed
on the underlying value in order to determine equality.
.Pp
Collection types are compared for deep equality, that is to say, two arrays
are equal only if they contain the same values in the same order, and two
dictionaries are equal only if they contain the same values for the same keys.
.Pp
.Em Important :
File descriptors and shared memory objects cannot be reliably compared for
equality, and therefore the
.Fn xpc_equal
function will only perform a simple pointer-equality check for these objects.
.Pp
Objects may be hashed using the
.Fn xpc_hash
function. The result of the hash function is guaranteed to be identical for
objects which compare to be equal using
.Fn xpc_equal .
.Pp
.Em Important :
The hash value for a given object should not be considered portable across
multiple processes or releases of the operating system and as a result should
not be stored in a permanent fashion.
.Sh OBJECT DESCRIPTIONS
The
.Fn xpc_copy_description
function may be used to produce a human-readable description of an object.
The returned C-string must be freed by the caller using
.Xr free 3 .
.Pp
.Em Important :
The format of this description is not guaranteed to remain consistent across
releases, and the output should only be used for debugging purposes.
.Sh SEE ALSO
.Xr dispatch_async 3 ,
.Xr xpc_abort 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_cancel 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_endpoint_create 3 ,
.Xr xpc_objects 3
                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_int64_create.3                           0100644 0001750 0001750 00000031100 12566166531 024103  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_int64_get_value.3                        0100644 0001750 0001750 00000031100 12566166531 024613  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_main.3                                   0100644 0001750 0001750 00000013011 12566166531 022541  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_main 3
.Os Darwin
.Sh NAME
.Nm xpc_main
.Nd XPC service runtime
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft void
.Fo xpc_main
.Fa "xpc_connection_handler_t handler"
.Fc
.Ft void
.Fo xpc_transaction_begin
.Fa "void"
.Fc
.Ft void
.Fo xpc_transaction_end
.Fa "void"
.Fc
.Sh DESCRIPTION
The
.Fn xpc_main
function is called by an XPC service to initialize the runtime and start
listening for incoming connections.
.Sh HANDLER
The
.Fa handler
provided to
.Fn xpc_main
will be invoked when a new connection has been established with the service.
For each new connection, an
.Ft xpc_connection_t
will be passed as the parameter to the
.Fa handler .
Each connection corresponds to a call to
.Xr xpc_connection_create 3
made by a client of the service.
.Pp
The service is responsible for setting an event handler on the new connection
and resuming it in the same fashion as new connections returned by
.Xr xpc_connection_create 3 .
.Pp
.Em Important :
The new connection passed to
.Fn handler
must be retained using
.Xr xpc_retain 3
if it will be stored in data structures that persist beyond the scope of that
function.
.Pp
.Bd -literal -offset indent
static void
new_connection_handler(xpc_connection_t peer)
{
	xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
		// Handle messages and errors.
	});
	xpc_connection_resume(peer);
}

int
main(void)
{
	xpc_main(new_connection_handler);
	exit(EXIT_FAILURE);
}
.Ed
.Pp
launchd jobs which advertise MachServices may
.Em not
call
.Fn xpc_main .
.Sh RUNTIME MANAGEMENT
The XPC runtime automatically keeps track of message activity to determine
whether a service is busy or idle. If the service remains idle after a period
of inactivity (defined by the system),
.Fn xpc_main
will exit the process. This behavior is automatically enabled for XPC services,
but
.Xr launchd 8
jobs wishing to opt into the same behavior may do so by adding the
EnablePressuredExit key to their
.Xr launchd.plist 5 .
.Pp
Activity is tracked with a transaction count maintained by the XPC runtime.
A service is deemed idle when its transaction count is zero.
The transaction count is incremented immediately before the receipt and
delivery of a message to a peer connection's event handler. The transaction
count is correspondingly decremented when the event handler returns.
.Pp
The transaction count is also incremented when a reply message is created with
.Xr xpc_dictionary_create_reply 3 ,
and decremented when the reply is sent. As a result, a service with outstanding
reply messages is not considered idle.
.Pp
Services may extend the default behavior using
.Fn xpc_transaction_begin
and
.Fn xpc_transaction_end ,
which increment and decrement the transaction count respectivley. This may be
necessary for services that send periodic messages to their clients, not in
direct reply to a received message.
.Pp
If the service has a non-zero transaction count at a time when the system deems
it necessary to terminate the service, all peer connections in the service will
receive the
.Ft XPC_ERROR_TERMINATION_IMMINENT
event. This event indicates that the service should unwind all outstanding work
as quickly as possible and not begin any new work, as the system will terminate
the process if it does not exit in a timely fashion. After this event is
received, no further messages will be delivered to the peers, and the end of the
service's last outstanding transaction will automatically terminate the process.
.Pp
The XPC runtime will also automatically manage the service's priority based on
where a message came from. If an app sends a message to the service, the
act of sending that message will boost the destination service's priority and
resource limits so that it can more quickly fill the request. If, however, a
service gets a message from a background process, the service stays at a lower
priority so as not to interfere with work initiated as a direct result of user
interaction.
.Pp
The lifetime of these boosts is tied to the lifetime of the message or reply
object, just like transactions. So while the service maintains a reference to
a message which boosted it, the boost will remain. If a reply message is
created using
.Xr xpc_dictionary_create_reply 3 ,
the boost transfers to the reply object and will remain with the process until
until the reply has been sent or deallocated.
.Pp
Note that boosts happen as a result of a message-send operation. So even if the
service isn't running when a boosting message is sent, it will be launched
on-demand at the elevated priority necessary to receive the message in a timely
fashion.
.Pp
launchd jobs which use XPC for their IPC may opt into priority boosting by
specifying their ProcessType as Adaptive. This will apply priority boosting
behavior only to the MachServices that are in the launchd.plist. See
.Xr launchd.plist 5
for more details.
.Sh DEFAULT ENVIRONMENT
The execution environment for XPC services bundled with applications is tightly
controlled. By default, services are executed in a new security audit session
and therefore do not have access to the current user's keychain or the ability
to draw UI.
This behavior may be overridden with the
.Ft JoinExistingSession
key in the service's
.Pa Info.plist .
.Pp
By default, the
.Fn xpc_main
function will call the 
.Xr dispatch_main 3
function to manage the service's main event loop.
This behavior may be overridden with the
.Ft RunLoopType
key in the service's
.Pa Info.plist .
.Pp
See 
.Xr xpcservice.plist 5
for more information about these keys.
.Sh SEE ALSO
.Xr xpc 3 ,
.Xr xpc_connection_create 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_object.3                                 0100644 0001750 0001750 00000022304 12566166531 023070  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011-2012 Apple Inc. All rights reserved.
.Dd 1 March, 2012
.Dt xpc_object 3
.Os Darwin
.Sh NAME
.Nm xpc_object
.Nd XPC object protocol
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_retain
.Fa "xpc_object_t object"
.Fc
.Ft void
.Fo xpc_release
.Fa "xpc_object_t object"
.Fc
.Ft xpc_type_t
.Fo xpc_get_type
.Fa "xpc_object_t object"
.Fc
.Ft xpc_object_t
.Fo xpc_copy
.Fa "xpc_object_t object"
.Fc
.Ft bool
.Fo xpc_equal
.Fa "xpc_object_t object1"
.Fa "xpc_object_t object2"
.Fc
.Ft size_t
.Fo xpc_hash
.Fa "xpc_object_t object"
.Fc
.Ft char *
.Fo xpc_copy_description
.Fa "xpc_object_t object"
.Fc
.Sh DESCRIPTION
XPC objects share functions for coordinating memory management, type checking,
comparing for equality, and hashing.
.Sh MEMORY MANAGEMENT
Objects returned by creation functions in the XPC framework may be uniformly
retained and released with the functions
.Fn xpc_retain
and
.Fn xpc_release
respectively.
.Pp
The XPC framework does not guarantee that any given client has the last or only
reference to a given object. Objects may be retained internally by the system.
.Pp
Functions which return objects follow the conventional create, copy and get
naming rules:
.Bl -tag -width "XXcreate" -compact -offset indent
.It \(bu create
A new object with a single reference is returned. This reference should be
released by the caller.
.It \(bu copy
A copy or retained object reference is returned. This reference should be
released by the caller.
.It \(bu get
An unretained reference to an existing object is returned. The caller
.Em must not
release this reference, and is responsible for retaining the object for later
use if necessary.
.El
.Ss INTEGRATION WITH OBJECTIVE-C
.Bd -filled -offset indent
When building with an Objective-C or Objective-C++ compiler, XPC objects are
declared as Objective-C types. This results in the following differences
compared to building as plain C/C++:
.Bl -dash
.It
if Objective-C Automated Reference Counting is enabled, XPC objects are
memory managed by the Objective-C runtime and explicit calls to the
.Fn xpc_retain
and
.Fn xpc_release
functions will produce build errors.
.Pp
.Em Note :
when ARC is enabled, care needs to be taken with XPC API returning an interior
pointer that is only valid as long as an associated object has not been
released. If that object is held in a variable with automatic storage, it may
need to be annotated with the
.Li objc_precise_lifetime
attribute, or stored in a
.Li __strong
instance variable instead, to ensure that the object is not prematurely
released. The functions returning interior pointers are:
.Bl -bullet -compact -offset indent
.It
.Xr xpc_data_get_bytes_ptr 3 ,
.Xr xpc_string_get_string_ptr 3 ,
.Xr xpc_uuid_get_bytes 3
.It
.Xr xpc_array_get_data 3 ,
.Xr xpc_array_get_string 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_dictionary_get_uuid 3
.El
.It
the Blocks runtime automatically retains and releases XPC objects captured by
blocks upon
.Fn Block_copy
and
.Fn Block_release ,
e.g.\& as performed during asynchronous execution of a block via
.Xr dispatch_async 3 .
.Pp
.Em Note :
retain cycles may be encountered if XPC connection objects are captured by
their handler blocks; these cycles can be broken by declaring the captured
object
.Li __weak
or by calling
.Xr xpc_connection_cancel 3
to cause its handler blocks to be released explicitly.
.It
XPC objects can be added directly to Cocoa collections, and their
lifetime is tracked by the Objective-C static analyzer.
.El
.Pp
Integration of XPC objects with Objective-C requires targeting Mac\ OS\ X
10.8 or later, and is disabled when building with Objective-C Garbage
Collection or for the legacy Objective-C runtime. It can also be disabled
manually by using compiler options to define the
.Dv OS_OBJECT_USE_OBJC
preprocessor macro to
.Li 0 .
.Ed
.Pp
.Em Important :
When building with a plain C/C++ compiler or when integration with Objective-C
is disabled, XPC objects are
.Em not
automatically retained and released when captured by a block. Therefore, when a
XPC object is captured by a block that will be executed asynchronously, the
object must be manually retained and released:
.Pp
.Bd -literal -offset indent
xpc_retain(object);
dispatch_async(queue, ^{
	do_something_with_object(object);
	xpc_release(object);
});
.Ed
.Sh TYPES
The
.Fn xpc_get_type
function returns the type of an XPC object as a pointer of type
.Ft xpc_type t .
The returned type may be compared against the type constants defined by the
XPC framework with simple pointer equality.
.Pp
Type constants:
.Bl -bullet -compact -offset indent
.It
XPC_TYPE_CONNECTION
.It
XPC_TYPE_ENDPOINT
.It
XPC_TYPE_NULL
.It
XPC_TYPE_BOOL
.It
XPC_TYPE_INT64
.It
XPC_TYPE_UINT64
.It
XPC_TYPE_DOUBLE
.It
XPC_TYPE_DATE
.It
XPC_TYPE_DATA
.It
XPC_TYPE_STRING
.It
XPC_TYPE_UUID
.It
XPC_TYPE_FD
.It
XPC_TYPE_SHMEM
.It
XPC_TYPE_ARRAY
.It
XPC_TYPE_DICTIONARY
.El
.Sh BOXED OBJECTS AND COLLECTIONS
Most XPC object types are boxed representations of primitive C language types
or low-level operating system handles. These boxed objects are immutable.
.Pp
The XPC framework provides two collection types: dictionaries and arrays.
These types are mutable and may have boxed objects added or removed from the
collection.
.Pp
A suite of primitive get and set functions are available for the dictionary
and array types. These functions allow for the insertion and extraction of
primitive values from the collection directly, without the need for
intermediate boxed objects.
.Pp
The following is a list of primitive get and set functions for the dictionary
collection type:
.Pp
.Bl -bullet -compact -offset indent
.It
.Xr xpc_dictionary_set_bool 3 ,
.Xr xpc_dictionary_get_bool 3 ,
.Xr xpc_array_set_bool 3 ,
.Xr xpc_array_get_bool 3
.It
.Xr xpc_dictionary_set_int64 3 ,
.Xr xpc_dictionary_get_int64 3 ,
.Xr xpc_array_set_int64 3 ,
.Xr xpc_array_get_int64 3
.It
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_array_set_uint64 3 ,
.Xr xpc_array_get_uint64 3
.It
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_array_set_double 3 ,
.Xr xpc_array_get_double 3
.It
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_array_set_date 3 ,
.Xr xpc_array_get_date 3
.It
.Xr xpc_dictionary_set_data 3 ,
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_array_set_data 3 ,
.Xr xpc_array_get_data 3
.It
.Xr xpc_dictionary_set_string 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_array_set_string 3 ,
.Xr xpc_array_get_string 3
.It
.Xr xpc_dictionary_set_uuid 3 ,
.Xr xpc_dictionary_get_uuid 3 ,
.Xr xpc_array_set_uuid 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_set_fd 3 ,
.Xr xpc_dictionary_dup_fd 3 ,
.Xr xpc_array_set_fd 3 ,
.Xr xpc_array_dup_fd 3
.It
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_get_connection 3 ,
.Xr xpc_array_set_connection 3 ,
.Xr xpc_array_get_connection 3
.El
.Pp
When the requested key or index is not present in the collection, or if the
value for the requested key or index is not of the expected type, these
functions will return sensible default values:
.Pp
.Bl -tag -width "XXconnection" -compact -offset indent
.It \(bu bool
false
.It \(bu int64
0
.It \(bu uint64
0
.It \(bu double
NAN
.It \(bu date
0
.It \(bu data
NULL
.It \(bu uuid
NULL
.It \(bu string
NULL
.It \(bu fd
-1
.It \(bu connection
NULL
.El
.Pp
.Sh COPYING
Objects may be copied using the
.Fn xpc_copy
function. The result of
.Fn xpc_copy
may or may not be a brand new object (i.e. a different pointer). The system may
choose to return the same object with an additional reference rather than doing
a complete copy for efficiency reasons.
.Sh EQUALITY
Two objects may be compared for equality using the
.Fn xpc_equal
function.
Objects must be of the same type as returned by
.Fn xpc_get_type
in order to be considered equal. No casting or transformation is performed
on the underlying value in order to determine equality.
.Pp
Collection types are compared for deep equality, that is to say, two arrays
are equal only if they contain the same values in the same order, and two
dictionaries are equal only if they contain the same values for the same keys.
.Pp
.Em Important :
File descriptors and shared memory objects cannot be reliably compared for
equality, and therefore the
.Fn xpc_equal
function will only perform a simple pointer-equality check for these objects.
.Pp
Objects may be hashed using the
.Fn xpc_hash
function. The result of the hash function is guaranteed to be identical for
objects which compare to be equal using
.Fn xpc_equal .
.Pp
.Em Important :
The hash value for a given object should not be considered portable across
multiple processes or releases of the operating system and as a result should
not be stored in a permanent fashion.
.Sh OBJECT DESCRIPTIONS
The
.Fn xpc_copy_description
function may be used to produce a human-readable description of an object.
The returned C-string must be freed by the caller using
.Xr free 3 .
.Pp
.Em Important :
The format of this description is not guaranteed to remain consistent across
releases, and the output should only be used for debugging purposes.
.Sh SEE ALSO
.Xr dispatch_async 3 ,
.Xr xpc_abort 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_cancel 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_endpoint_create 3 ,
.Xr xpc_objects 3
                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_objects.3                                0100644 0001750 0001750 00000031100 12566166531 023245  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_release.3                                0100644 0001750 0001750 00000022304 12566166531 023242  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011-2012 Apple Inc. All rights reserved.
.Dd 1 March, 2012
.Dt xpc_object 3
.Os Darwin
.Sh NAME
.Nm xpc_object
.Nd XPC object protocol
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_retain
.Fa "xpc_object_t object"
.Fc
.Ft void
.Fo xpc_release
.Fa "xpc_object_t object"
.Fc
.Ft xpc_type_t
.Fo xpc_get_type
.Fa "xpc_object_t object"
.Fc
.Ft xpc_object_t
.Fo xpc_copy
.Fa "xpc_object_t object"
.Fc
.Ft bool
.Fo xpc_equal
.Fa "xpc_object_t object1"
.Fa "xpc_object_t object2"
.Fc
.Ft size_t
.Fo xpc_hash
.Fa "xpc_object_t object"
.Fc
.Ft char *
.Fo xpc_copy_description
.Fa "xpc_object_t object"
.Fc
.Sh DESCRIPTION
XPC objects share functions for coordinating memory management, type checking,
comparing for equality, and hashing.
.Sh MEMORY MANAGEMENT
Objects returned by creation functions in the XPC framework may be uniformly
retained and released with the functions
.Fn xpc_retain
and
.Fn xpc_release
respectively.
.Pp
The XPC framework does not guarantee that any given client has the last or only
reference to a given object. Objects may be retained internally by the system.
.Pp
Functions which return objects follow the conventional create, copy and get
naming rules:
.Bl -tag -width "XXcreate" -compact -offset indent
.It \(bu create
A new object with a single reference is returned. This reference should be
released by the caller.
.It \(bu copy
A copy or retained object reference is returned. This reference should be
released by the caller.
.It \(bu get
An unretained reference to an existing object is returned. The caller
.Em must not
release this reference, and is responsible for retaining the object for later
use if necessary.
.El
.Ss INTEGRATION WITH OBJECTIVE-C
.Bd -filled -offset indent
When building with an Objective-C or Objective-C++ compiler, XPC objects are
declared as Objective-C types. This results in the following differences
compared to building as plain C/C++:
.Bl -dash
.It
if Objective-C Automated Reference Counting is enabled, XPC objects are
memory managed by the Objective-C runtime and explicit calls to the
.Fn xpc_retain
and
.Fn xpc_release
functions will produce build errors.
.Pp
.Em Note :
when ARC is enabled, care needs to be taken with XPC API returning an interior
pointer that is only valid as long as an associated object has not been
released. If that object is held in a variable with automatic storage, it may
need to be annotated with the
.Li objc_precise_lifetime
attribute, or stored in a
.Li __strong
instance variable instead, to ensure that the object is not prematurely
released. The functions returning interior pointers are:
.Bl -bullet -compact -offset indent
.It
.Xr xpc_data_get_bytes_ptr 3 ,
.Xr xpc_string_get_string_ptr 3 ,
.Xr xpc_uuid_get_bytes 3
.It
.Xr xpc_array_get_data 3 ,
.Xr xpc_array_get_string 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_dictionary_get_uuid 3
.El
.It
the Blocks runtime automatically retains and releases XPC objects captured by
blocks upon
.Fn Block_copy
and
.Fn Block_release ,
e.g.\& as performed during asynchronous execution of a block via
.Xr dispatch_async 3 .
.Pp
.Em Note :
retain cycles may be encountered if XPC connection objects are captured by
their handler blocks; these cycles can be broken by declaring the captured
object
.Li __weak
or by calling
.Xr xpc_connection_cancel 3
to cause its handler blocks to be released explicitly.
.It
XPC objects can be added directly to Cocoa collections, and their
lifetime is tracked by the Objective-C static analyzer.
.El
.Pp
Integration of XPC objects with Objective-C requires targeting Mac\ OS\ X
10.8 or later, and is disabled when building with Objective-C Garbage
Collection or for the legacy Objective-C runtime. It can also be disabled
manually by using compiler options to define the
.Dv OS_OBJECT_USE_OBJC
preprocessor macro to
.Li 0 .
.Ed
.Pp
.Em Important :
When building with a plain C/C++ compiler or when integration with Objective-C
is disabled, XPC objects are
.Em not
automatically retained and released when captured by a block. Therefore, when a
XPC object is captured by a block that will be executed asynchronously, the
object must be manually retained and released:
.Pp
.Bd -literal -offset indent
xpc_retain(object);
dispatch_async(queue, ^{
	do_something_with_object(object);
	xpc_release(object);
});
.Ed
.Sh TYPES
The
.Fn xpc_get_type
function returns the type of an XPC object as a pointer of type
.Ft xpc_type t .
The returned type may be compared against the type constants defined by the
XPC framework with simple pointer equality.
.Pp
Type constants:
.Bl -bullet -compact -offset indent
.It
XPC_TYPE_CONNECTION
.It
XPC_TYPE_ENDPOINT
.It
XPC_TYPE_NULL
.It
XPC_TYPE_BOOL
.It
XPC_TYPE_INT64
.It
XPC_TYPE_UINT64
.It
XPC_TYPE_DOUBLE
.It
XPC_TYPE_DATE
.It
XPC_TYPE_DATA
.It
XPC_TYPE_STRING
.It
XPC_TYPE_UUID
.It
XPC_TYPE_FD
.It
XPC_TYPE_SHMEM
.It
XPC_TYPE_ARRAY
.It
XPC_TYPE_DICTIONARY
.El
.Sh BOXED OBJECTS AND COLLECTIONS
Most XPC object types are boxed representations of primitive C language types
or low-level operating system handles. These boxed objects are immutable.
.Pp
The XPC framework provides two collection types: dictionaries and arrays.
These types are mutable and may have boxed objects added or removed from the
collection.
.Pp
A suite of primitive get and set functions are available for the dictionary
and array types. These functions allow for the insertion and extraction of
primitive values from the collection directly, without the need for
intermediate boxed objects.
.Pp
The following is a list of primitive get and set functions for the dictionary
collection type:
.Pp
.Bl -bullet -compact -offset indent
.It
.Xr xpc_dictionary_set_bool 3 ,
.Xr xpc_dictionary_get_bool 3 ,
.Xr xpc_array_set_bool 3 ,
.Xr xpc_array_get_bool 3
.It
.Xr xpc_dictionary_set_int64 3 ,
.Xr xpc_dictionary_get_int64 3 ,
.Xr xpc_array_set_int64 3 ,
.Xr xpc_array_get_int64 3
.It
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_array_set_uint64 3 ,
.Xr xpc_array_get_uint64 3
.It
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_array_set_double 3 ,
.Xr xpc_array_get_double 3
.It
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_array_set_date 3 ,
.Xr xpc_array_get_date 3
.It
.Xr xpc_dictionary_set_data 3 ,
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_array_set_data 3 ,
.Xr xpc_array_get_data 3
.It
.Xr xpc_dictionary_set_string 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_array_set_string 3 ,
.Xr xpc_array_get_string 3
.It
.Xr xpc_dictionary_set_uuid 3 ,
.Xr xpc_dictionary_get_uuid 3 ,
.Xr xpc_array_set_uuid 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_set_fd 3 ,
.Xr xpc_dictionary_dup_fd 3 ,
.Xr xpc_array_set_fd 3 ,
.Xr xpc_array_dup_fd 3
.It
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_get_connection 3 ,
.Xr xpc_array_set_connection 3 ,
.Xr xpc_array_get_connection 3
.El
.Pp
When the requested key or index is not present in the collection, or if the
value for the requested key or index is not of the expected type, these
functions will return sensible default values:
.Pp
.Bl -tag -width "XXconnection" -compact -offset indent
.It \(bu bool
false
.It \(bu int64
0
.It \(bu uint64
0
.It \(bu double
NAN
.It \(bu date
0
.It \(bu data
NULL
.It \(bu uuid
NULL
.It \(bu string
NULL
.It \(bu fd
-1
.It \(bu connection
NULL
.El
.Pp
.Sh COPYING
Objects may be copied using the
.Fn xpc_copy
function. The result of
.Fn xpc_copy
may or may not be a brand new object (i.e. a different pointer). The system may
choose to return the same object with an additional reference rather than doing
a complete copy for efficiency reasons.
.Sh EQUALITY
Two objects may be compared for equality using the
.Fn xpc_equal
function.
Objects must be of the same type as returned by
.Fn xpc_get_type
in order to be considered equal. No casting or transformation is performed
on the underlying value in order to determine equality.
.Pp
Collection types are compared for deep equality, that is to say, two arrays
are equal only if they contain the same values in the same order, and two
dictionaries are equal only if they contain the same values for the same keys.
.Pp
.Em Important :
File descriptors and shared memory objects cannot be reliably compared for
equality, and therefore the
.Fn xpc_equal
function will only perform a simple pointer-equality check for these objects.
.Pp
Objects may be hashed using the
.Fn xpc_hash
function. The result of the hash function is guaranteed to be identical for
objects which compare to be equal using
.Fn xpc_equal .
.Pp
.Em Important :
The hash value for a given object should not be considered portable across
multiple processes or releases of the operating system and as a result should
not be stored in a permanent fashion.
.Sh OBJECT DESCRIPTIONS
The
.Fn xpc_copy_description
function may be used to produce a human-readable description of an object.
The returned C-string must be freed by the caller using
.Xr free 3 .
.Pp
.Em Important :
The format of this description is not guaranteed to remain consistent across
releases, and the output should only be used for debugging purposes.
.Sh SEE ALSO
.Xr dispatch_async 3 ,
.Xr xpc_abort 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_cancel 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_endpoint_create 3 ,
.Xr xpc_objects 3
                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_retain.3                                 0100644 0001750 0001750 00000022304 12566166531 023104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011-2012 Apple Inc. All rights reserved.
.Dd 1 March, 2012
.Dt xpc_object 3
.Os Darwin
.Sh NAME
.Nm xpc_object
.Nd XPC object protocol
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_retain
.Fa "xpc_object_t object"
.Fc
.Ft void
.Fo xpc_release
.Fa "xpc_object_t object"
.Fc
.Ft xpc_type_t
.Fo xpc_get_type
.Fa "xpc_object_t object"
.Fc
.Ft xpc_object_t
.Fo xpc_copy
.Fa "xpc_object_t object"
.Fc
.Ft bool
.Fo xpc_equal
.Fa "xpc_object_t object1"
.Fa "xpc_object_t object2"
.Fc
.Ft size_t
.Fo xpc_hash
.Fa "xpc_object_t object"
.Fc
.Ft char *
.Fo xpc_copy_description
.Fa "xpc_object_t object"
.Fc
.Sh DESCRIPTION
XPC objects share functions for coordinating memory management, type checking,
comparing for equality, and hashing.
.Sh MEMORY MANAGEMENT
Objects returned by creation functions in the XPC framework may be uniformly
retained and released with the functions
.Fn xpc_retain
and
.Fn xpc_release
respectively.
.Pp
The XPC framework does not guarantee that any given client has the last or only
reference to a given object. Objects may be retained internally by the system.
.Pp
Functions which return objects follow the conventional create, copy and get
naming rules:
.Bl -tag -width "XXcreate" -compact -offset indent
.It \(bu create
A new object with a single reference is returned. This reference should be
released by the caller.
.It \(bu copy
A copy or retained object reference is returned. This reference should be
released by the caller.
.It \(bu get
An unretained reference to an existing object is returned. The caller
.Em must not
release this reference, and is responsible for retaining the object for later
use if necessary.
.El
.Ss INTEGRATION WITH OBJECTIVE-C
.Bd -filled -offset indent
When building with an Objective-C or Objective-C++ compiler, XPC objects are
declared as Objective-C types. This results in the following differences
compared to building as plain C/C++:
.Bl -dash
.It
if Objective-C Automated Reference Counting is enabled, XPC objects are
memory managed by the Objective-C runtime and explicit calls to the
.Fn xpc_retain
and
.Fn xpc_release
functions will produce build errors.
.Pp
.Em Note :
when ARC is enabled, care needs to be taken with XPC API returning an interior
pointer that is only valid as long as an associated object has not been
released. If that object is held in a variable with automatic storage, it may
need to be annotated with the
.Li objc_precise_lifetime
attribute, or stored in a
.Li __strong
instance variable instead, to ensure that the object is not prematurely
released. The functions returning interior pointers are:
.Bl -bullet -compact -offset indent
.It
.Xr xpc_data_get_bytes_ptr 3 ,
.Xr xpc_string_get_string_ptr 3 ,
.Xr xpc_uuid_get_bytes 3
.It
.Xr xpc_array_get_data 3 ,
.Xr xpc_array_get_string 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_dictionary_get_uuid 3
.El
.It
the Blocks runtime automatically retains and releases XPC objects captured by
blocks upon
.Fn Block_copy
and
.Fn Block_release ,
e.g.\& as performed during asynchronous execution of a block via
.Xr dispatch_async 3 .
.Pp
.Em Note :
retain cycles may be encountered if XPC connection objects are captured by
their handler blocks; these cycles can be broken by declaring the captured
object
.Li __weak
or by calling
.Xr xpc_connection_cancel 3
to cause its handler blocks to be released explicitly.
.It
XPC objects can be added directly to Cocoa collections, and their
lifetime is tracked by the Objective-C static analyzer.
.El
.Pp
Integration of XPC objects with Objective-C requires targeting Mac\ OS\ X
10.8 or later, and is disabled when building with Objective-C Garbage
Collection or for the legacy Objective-C runtime. It can also be disabled
manually by using compiler options to define the
.Dv OS_OBJECT_USE_OBJC
preprocessor macro to
.Li 0 .
.Ed
.Pp
.Em Important :
When building with a plain C/C++ compiler or when integration with Objective-C
is disabled, XPC objects are
.Em not
automatically retained and released when captured by a block. Therefore, when a
XPC object is captured by a block that will be executed asynchronously, the
object must be manually retained and released:
.Pp
.Bd -literal -offset indent
xpc_retain(object);
dispatch_async(queue, ^{
	do_something_with_object(object);
	xpc_release(object);
});
.Ed
.Sh TYPES
The
.Fn xpc_get_type
function returns the type of an XPC object as a pointer of type
.Ft xpc_type t .
The returned type may be compared against the type constants defined by the
XPC framework with simple pointer equality.
.Pp
Type constants:
.Bl -bullet -compact -offset indent
.It
XPC_TYPE_CONNECTION
.It
XPC_TYPE_ENDPOINT
.It
XPC_TYPE_NULL
.It
XPC_TYPE_BOOL
.It
XPC_TYPE_INT64
.It
XPC_TYPE_UINT64
.It
XPC_TYPE_DOUBLE
.It
XPC_TYPE_DATE
.It
XPC_TYPE_DATA
.It
XPC_TYPE_STRING
.It
XPC_TYPE_UUID
.It
XPC_TYPE_FD
.It
XPC_TYPE_SHMEM
.It
XPC_TYPE_ARRAY
.It
XPC_TYPE_DICTIONARY
.El
.Sh BOXED OBJECTS AND COLLECTIONS
Most XPC object types are boxed representations of primitive C language types
or low-level operating system handles. These boxed objects are immutable.
.Pp
The XPC framework provides two collection types: dictionaries and arrays.
These types are mutable and may have boxed objects added or removed from the
collection.
.Pp
A suite of primitive get and set functions are available for the dictionary
and array types. These functions allow for the insertion and extraction of
primitive values from the collection directly, without the need for
intermediate boxed objects.
.Pp
The following is a list of primitive get and set functions for the dictionary
collection type:
.Pp
.Bl -bullet -compact -offset indent
.It
.Xr xpc_dictionary_set_bool 3 ,
.Xr xpc_dictionary_get_bool 3 ,
.Xr xpc_array_set_bool 3 ,
.Xr xpc_array_get_bool 3
.It
.Xr xpc_dictionary_set_int64 3 ,
.Xr xpc_dictionary_get_int64 3 ,
.Xr xpc_array_set_int64 3 ,
.Xr xpc_array_get_int64 3
.It
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_dictionary_set_uint64 3 ,
.Xr xpc_array_set_uint64 3 ,
.Xr xpc_array_get_uint64 3
.It
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_dictionary_set_double 3 ,
.Xr xpc_array_set_double 3 ,
.Xr xpc_array_get_double 3
.It
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_dictionary_set_date 3 ,
.Xr xpc_array_set_date 3 ,
.Xr xpc_array_get_date 3
.It
.Xr xpc_dictionary_set_data 3 ,
.Xr xpc_dictionary_get_data 3 ,
.Xr xpc_array_set_data 3 ,
.Xr xpc_array_get_data 3
.It
.Xr xpc_dictionary_set_string 3 ,
.Xr xpc_dictionary_get_string 3 ,
.Xr xpc_array_set_string 3 ,
.Xr xpc_array_get_string 3
.It
.Xr xpc_dictionary_set_uuid 3 ,
.Xr xpc_dictionary_get_uuid 3 ,
.Xr xpc_array_set_uuid 3 ,
.Xr xpc_array_get_uuid 3
.It
.Xr xpc_dictionary_set_fd 3 ,
.Xr xpc_dictionary_dup_fd 3 ,
.Xr xpc_array_set_fd 3 ,
.Xr xpc_array_dup_fd 3
.It
.Xr xpc_dictionary_set_connection 3 ,
.Xr xpc_dictionary_get_connection 3 ,
.Xr xpc_array_set_connection 3 ,
.Xr xpc_array_get_connection 3
.El
.Pp
When the requested key or index is not present in the collection, or if the
value for the requested key or index is not of the expected type, these
functions will return sensible default values:
.Pp
.Bl -tag -width "XXconnection" -compact -offset indent
.It \(bu bool
false
.It \(bu int64
0
.It \(bu uint64
0
.It \(bu double
NAN
.It \(bu date
0
.It \(bu data
NULL
.It \(bu uuid
NULL
.It \(bu string
NULL
.It \(bu fd
-1
.It \(bu connection
NULL
.El
.Pp
.Sh COPYING
Objects may be copied using the
.Fn xpc_copy
function. The result of
.Fn xpc_copy
may or may not be a brand new object (i.e. a different pointer). The system may
choose to return the same object with an additional reference rather than doing
a complete copy for efficiency reasons.
.Sh EQUALITY
Two objects may be compared for equality using the
.Fn xpc_equal
function.
Objects must be of the same type as returned by
.Fn xpc_get_type
in order to be considered equal. No casting or transformation is performed
on the underlying value in order to determine equality.
.Pp
Collection types are compared for deep equality, that is to say, two arrays
are equal only if they contain the same values in the same order, and two
dictionaries are equal only if they contain the same values for the same keys.
.Pp
.Em Important :
File descriptors and shared memory objects cannot be reliably compared for
equality, and therefore the
.Fn xpc_equal
function will only perform a simple pointer-equality check for these objects.
.Pp
Objects may be hashed using the
.Fn xpc_hash
function. The result of the hash function is guaranteed to be identical for
objects which compare to be equal using
.Fn xpc_equal .
.Pp
.Em Important :
The hash value for a given object should not be considered portable across
multiple processes or releases of the operating system and as a result should
not be stored in a permanent fashion.
.Sh OBJECT DESCRIPTIONS
The
.Fn xpc_copy_description
function may be used to produce a human-readable description of an object.
The returned C-string must be freed by the caller using
.Xr free 3 .
.Pp
.Em Important :
The format of this description is not guaranteed to remain consistent across
releases, and the output should only be used for debugging purposes.
.Sh SEE ALSO
.Xr dispatch_async 3 ,
.Xr xpc_abort 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_cancel 3 ,
.Xr xpc_connection_create 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_endpoint_create 3 ,
.Xr xpc_objects 3
                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_set_event_stream_handler.3               0100644 0001750 0001750 00000011267 12566166531 026674  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_events 3
.Os Darwin
.Sh NAME
.Nm xpc_events
.Nd launch-on-demand for high-level events
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft void
.Fo xpc_set_event_stream_handler
.Fa "const char *name"
.Fa "dispatch_queue_t targetq"
.Fa "xpc_handler_t handler"
.Fc
.Sh DESCRIPTION
XPC provides a mechanism by which launchd jobs may launch on-demand for certain
higher-level events, such as IOKit events or BSD Notifications. These events are
delivered to the job through a handler that is set early in its execution. The
period between when the event is delivered to the job and when a handler is set
is race-free, and any pending events will be queued up for consumption by the
job. An event is consumed when it is delivered to the handler.
.Sh EVENT STREAMS
Providers of events are known as streams. Two example event streams are the
IOKit stream and the BSD Notifications stream. Streams are denoted by a
reverse-DNS naming scheme. For the aforementioned examples, the stream names are
"com.apple.iokit.matching" and "com.apple.notifyd.matching", respectively. These
are currently the only two supported event streams.
.Sh EVENT NAMES
A launchd job may be interested in multiple events from different event streams.
Each of these events has a name provided by the job in the
.Xr launchd.plist 5 .
.Pp
The occurrence of any of these events will launch the job on-demand if it is not
already running.
.Sh PLIST SCHEMA
Events are specified through the
.Xr launchd.plist 5
with the LaunchEvents key. The value for this key is a dictionary. Each value of
this dictionary is itself a dictionary corresponding to an event stream. The
values of this inner dictionary are events that may cause the job to be launched
on-demand.
.Pp
.Bd -literal -offset indent
<key>LaunchEvents</key>
<dict>
	<key>com.apple.iokit.matching</key>
	<dict>
		<key>com.apple.device-attach</key>
		<dict>
			<key>idProduct</key>
			<integer>2794</integer>
			<key>idVendor</key>
			<integer>725</integer>
			<key>IOProviderClass</key>
			<string>IOUSBDevice</string>
			<key>IOMatchLaunchStream</key>
			<true/>
		</dict>
	</dict>
	<key>com.apple.notifyd.matching</key>
	<dict>
		<key>com.apple.interesting-notification</key>
		<dict>
			<key>Notification</key>
			<string>com.apple.interesting-notification</string>
		</dict>
	</dict>
</dict>
.Ed
.Pp
The above specifies that the job will be launched when a node matching the given
matching dictionary appears in the IORegistry or when a notification named
"com.apple.interesting-notification" is posted using
.Xr notify_post 3 .
.Pp
.Em NOTE :
The IOMatchLaunchStream key is required to be present and be a Boolean set to
.Ft true
for use with XPC Events. It will be filtered out of the rest of the dictionary
when given to IOKit to match. The reasons for this are historical and not
applicable to other event streams.
.Pp
Each event stream has a different plist schema.
.Sh EVENT CONSUMPTION
Events are consumed with the
.Fn xpc_set_event_stream_handler
API. The
.Fa stream
argument specifies from which event stream the given
.Fa handler
will receive events. The
.Fa targetq
parameter specifies on which queue the handler will be synchronized.
The
.Fa handler
will only ever receive dictionaries. Each dictionary is guaranteed to have the
.Ft XPC_EVENT_KEY_NAME
key set. The value for this key is the string that was given as the name for the
event in the
.Xr launchd.plist 5 .
So if the IOKit event in the above example was received, the value of this key
would be "com.apple.device-attach".
.Pp
In addition to the standard payload, events from the IOKit stream also have the
"IOMatchLaunchServiceID" key set to a
.Ft uint64_t
which specifies the unique IORegistry ID of the node which matched the given
dictionary as obtained by
.Fn IORegistryEntryGetRegistryEntryID .
This value may be given to
.Fn IORegistryEntryIDMatching
to obtain the registry entry which caused the event to fire.
.Pp
BSD Notfication events have no additional payload.
.Bd -literal -offset indent
xpc_set_event_stream_handler("com.apple.iokit.matching", q, ^(xpc_object_t event) {
	const char *name = xpc_dictionary_get_string(event, XPC_EVENT_KEY_NAME);
	uint64_t id = xpc_dictionary_get_uint64(event, "IOMatchLaunchServiceID");

	CFMutableDictionaryRef matching = IORegistryEntryIDMatching(id);
	// Pass to IOServiceGetMatchingServices() or IOServiceAddNotification().
});
.Ed
.Pp
.Em IMPORTANT :
.Fn xpc_set_event_stream_handler
is NOT shareable. Two different subsystems in a process cannot safely both
register for events from the same event stream. Therefore, libraries and
frameworks should
.Em NEVER
call this API.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr notify 3
                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_shmem_create.3                           0100644 0001750 0001750 00000031100 12566166531 024250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared memory object out of the region. For this reason, it is recommended
that any such operations be delayed until after the shared memory object has
been created, as the existence of the object will hint to the VM that the
region's internal representation should be kept contiguous. Note that this will
necessarily defeat these optimizations and force physical copies of subranges.
.Sh SEE ALSO
.Xr xpc_object 3 ,
.Xr xpc_dictionary_create 3 ,
.Xr xpc_array_create 3 ,
.Xr xpc_connection_create 3 ,
.Xr dispatch_data_create 3 ,
.Xr printf 3 ,
.Xr uuid 3 ,
.Xr dup 2 ,
.Xr close 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/xpc_shmem_map.3                              0100644 0001750 0001750 00000031100 12566166531 023562  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2011 Apple Inc. All rights reserved.
.Dd 1 July, 2011
.Dt xpc_objects 3
.Os Darwin
.Sh NAME
.Nm xpc_objects
.Nd boxed XPC objects reference
.Sh SYNOPSIS
.Fd #include <xpc/xpc.h>
.Ft xpc_object_t
.Fo xpc_null_create
.Fa "void"
.Fc
.Ft xpc_object_t
.Fo xpc_bool_create
.Fa "bool value"
.Fc
.Ft bool
.Fo xpc_bool_get_value
.Fa "xpc_object_t xbool"
.Fc
.Ft xpc_object_t
.Fo xpc_int64_create
.Fa "int64_t value"
.Fc
.Ft int64_t
.Fo xpc_int64_get_value
.Fa "xpc_object_t xint"
.Fc
.Ft xpc_object_t
.Fo xpc_uint64_create
.Fa "uint64_t value"
.Fc
.Ft uint64_t
.Fo xpc_uint64_get_value
.Fa "xpc_object_t xuint"
.Fc
.Ft xpc_object_t
.Fo xpc_double_create
.Fa "double value"
.Fc
.Ft double
.Fo xpc_double_get_value
.Fa "xpc_object_t xdouble"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create
.Fa "int64_t interval"
.Fc
.Ft xpc_object_t
.Fo xpc_date_create_from_current
.Fa "void"
.Fc
.Ft int64_t
.Fo xpc_date_get_value
.Fa "xpc_object_t xdate"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create
.Fa "const void *bytes"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_data_create_with_dispatch_data
.Fa "dispatch_data_t ddata"
.Fc
.Ft size_t
.Fo xpc_data_get_length
.Fa "xpc_object_t xdata"
.Fc
.Ft const void *
.Fo xpc_data_get_bytes_ptr
.Fa "xpc_object_t xdata"
.Fc
.Ft size_t
.Fo xpc_data_get_bytes
.Fa "xpc_object_t xdata"
.Fa "void *buffer"
.Fa "size_t off"
.Fa "size_t length"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create
.Fa "const char *string"
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format
.Fa "const char *fmt"
.Fa "..."
.Fc
.Ft xpc_object_t
.Fo xpc_string_create_with_format_and_arguments
.Fa "const char *fmt"
.Fa "va_list ap"
.Fc
.Ft size_t
.Fo xpc_string_get_length
.Fa "xpc_object_t xstring"
.Fc
.Ft const char *
.Fo xpc_string_get_string_ptr
.Fa "xpc_object_t xstring"
.Fc
.Ft xpc_object_t
.Fo xpc_uuid_create
.Fa "const uuid_t uuid"
.Fc
.Ft const uint8_t *
.Fo xpc_uuid_get_bytes
.Fa "xpc_object_t xuuid"
.Fc
.Ft xpc_object_t
.Fo xpc_fd_create
.Fa "int fd"
.Fc
.Ft int
.Fo xpc_fd_dup
.Fa "xpc_object_t xfd"
.Fc
.Ft xpc_object_t
.Fo xpc_shmem_create
.Fa "void *region"
.Fa "size_t length"
.Fc
.Ft size_t
.Fo xpc_shmem_map
.Fa "xpc_object_t xshmem"
.Fa "void **region"
.Fc
.Sh DESCRIPTION
Most XPC objects are boxed representations of primitive C language types or
low-level operating system handles. These boxed objects are immutable. In
general, the getter methods for each object type will check to see if the given
object is of the proper type and, if it is not, will return a sensible default
value as described in
.Xr xpc_object 3 .
If an improper object is given to another type of method, the behavior is
undefined.
.Pp
See
.Xr xpc_object 3
for information about functions common to all XPC objects.
.Pp
.Sh PRIMITIVE TYPES
XPC objects can encapsulate a wide variety of primitive C language types:
.Ss INTEGERS
Boxed representations of 64-bit wide signed and unsigned integer types may be
created with
.Fn xpc_int64_create
and
.Fn xpc_uint64_create
respectively. The boxed values may be retrieved using
.Fn xpc_int64_get_value
and
.Fn xpc_uint64_get_value .
.Ss FLOATING POINT
Boxed representations of double-precision floating point value representations
may be created with the
.Fn xpc_double_create
function and retrieved with the
.Fn xpc_double_get_value
function.
.Ss DATES
Boxed representations of date and time values, expressed as an integral
number of nanoseconds before or after the Unix epoch, can be created with the
.Fn xpc_date_create
function and retrieved with the
.Fn xpc_date_get_value
function.
A date object representing the current date may be created with 
.Fn xpc_date_create_from_current
convenience function.
.Ss NULL AND BOOLEAN SINGLETONS
Boxed representations of null and Boolean values are expressed as XPC object
singletons. The 
.Fn xpc_bool_create
function returns one of two constant singleton Boolean values:
.Bl -bullet -compact -offset indent
.It
.Ft XPC_BOOL_TRUE
.It
.Ft XPC_BOOL_FALSE
.El
.Pp
The singleton values may be compared using direct pointer equality. Similarly,
no type checking is required when retreiving these values from collections:
.Pp
.Bd -literal -offset indent
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, "key");
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key "key".
}
.Ed
.Pp
The
.Fn xpc_null_create
function returns a constant singleton representation of a null value.
There is currently no defined constant for this singleton.
.Pp
It is safe to call
.Xr xpc_retain 3
and
.Xr xpc_release 3
on Boolean and null objects.
.Sh DATA, STRINGS AND UUIDS
.Ss DATA
Boxed representations of arbitrary byte values may be created with the
.Fn xpc_data_create
function which takes a pointer to a
.Fa buffer
and
.Fa length .
A pointer to the underlying storage of the data object may be obtained using
.Fn xpc_data_get_bytes_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the data object. The underlying
storage of the pointer value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the data object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The contents of a data object may be copied to an external buffer using the
.Fn xpc_data_get_bytes
function. This function takes a pointer to a
.Fa buffer
of size
.Fa length
to which the data will be copied.
The caller may also specify a non-zero
.Fa offset
into the source data at which to start the copy. The return value of this
function is the number of bytes that were copied into the
.Fa buffer .
If the destination
.Fa buffer
is smaller than the size of the source data, as many bytes as possible will be
copied and the return value will be equal to the number of bytes specified in
.Fa length .
.Pp
The underlying size of the data value may be determined using the
.Fn xpc_data_get_length 
function.
.Pp
When creating a data object, the contents of the provided buffer are copied into
internal storage. If the caller wishes to avoid a copy, the buffer may first be
encapsulated in a
.Ft dispatch_data_t
object and passed to
.Fn xpc_data_create_with_dispatch_data .
See
.Xr dispatch_data_create 3
for more information.
.Pp
.Em Note :
When the time comes to send a message, the XPC runtime will serialize
the object graph, which will result in a copy of any data objects contained
therein. This can be very costly for large amounts of data. To completely avoid
any copying in the message-send path for large data objects (where "large" is
defined by the system), you may create a data object using
.Xr dispatch_data_create 3
with the
.Ft DISPATCH_DATA_DESTRUCTOR_MUNMAP
destructor specified. This will hint to the system that the data buffer may be
safely shared copy-on-write with the recipient of the message.
.Pp
.Em Important :
Data objects created with the intention of eliminating copies can
.Em only
be safely created VM objects that the caller owns. Buffers returned by
.Xr malloc 3
do NOT satisfy this condition as the caller does not own the underlying VM
object associated with an allocation returned by
.Xr malloc 3 .
Similarly, if the caller receives a buffer from an external subsystem across an
API boundary, this buffer is not owned by the caller unless part of the API
contract specifies how the buffer should have been created. Sending buffers not
owned by the caller in this way can result in information leakage from elsewhere
on the heap.
.Ss STRINGS
Boxed representations of C string values may be created using the
.Fn xpc_string_create
function.
The XPC framework assumes all strings are encoded as UTF-8 and does not
support any other encodings. A pointer to the C string representation of a
value may be obtained using
.Fn xpc_string_get_string_ptr .
.Pp
.Em Important :
This pointer is only valid for the lifetime of the string object. The underlying
storage of the pointer value must not be modified by the caller.  When ARC is
enabled, care needs to be taken that the string object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The length of the C string value may be determined using the
.Fn xpc_string_get_length
function. This length is does not include the NUL terminator character,
similar to
.Xr strlen 3 .
.Pp
String objects may also be constructed from
.Xr printf 3 -style
format strings using the
.Fn xpc_string_create_with_format
function.
Additionally, the
.Fn xpc_string_create_with_format_and_arguments
function allows the caller to pass an existing
.Ft va_list
argument with which to construct the formatted string.
.Ss UUIDs
Boxed representations of UUID byte values may be created using
.Fn xpc_uuid_create .
See
.Xr uuid 3
for more information.
A pointer to storage for the underlying UUID value may be obtained using
.Fn xpc_uuid_get_bytes .
The returned pointer may be safely passed to the relevant
.Xr uuid 3
functions.
.Pp
.Em Important :
This pointer is only valid for the lifetime of the UUID object. The underlying
storage of the UUID value must not be modified by the caller. When ARC is
enabled, care needs to be taken that the UUID object is not released
prematurely, see
.Xr xpc_object 3
for details.
.Pp
The pattern of returning a pointer instead of copying the result into a
.Ft uuid_t
enables some convenient code simplification. For example:
.Pp
.Bd -literal -offset indent
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
.Ed
.Sh OUT-OF-LINE TYPES
Boxed representations of low-level operating system primitives such as file
descriptors and shared memory regions may be created and shared between
processes as part of an XPC dictionary that is sent as a message.
.Ss FILE DESCRIPTORS
Boxed representations of file descriptors may be created using the
.Fn xpc_fd_create
function.
Once created, there is no way to retrieve the original file descriptor from
the boxed representation. Instead, the
.Fn xpc_fd_dup
function can be used to create a new file descriptor in a similar manner to
.Xr dup 2 .
The caller is responsible for calling
.Xr close 2
on the descriptor returned by this function.
Multiple calls to
.Fn xpc_fd_dup
will produce multiple unique file descriptor values.
If a failure occurs (i.e. process file descriptor table is full), the invalid
file descriptor value -1 will be returned.
.Ss SHARED MEMORY
Boxed representations of shared memory regions allocated using
.Xr mmap 2
with the
.Ft MAP_SHARED
flag passed in the
.Fa flags
argument may be created using the 
.Fn xpc_shmem_create
function. Memory objects created using
.Xr malloc 3
are not supported.
The
.Fa region
argument is a pointer to the beginning of the shared region and the
.Fa length
argument specifies the length of the shared region.
.Pp
The recipient of a shared memory object may map the underlying region into its
address space using the
.Fn xpc_shmem_map
function.
As with file descriptor objects, each call to this function returns a distinct
but equivalent mapping. On output, the
.Fa region
argument will point to the address of the new mapping, and the return value will
be the size of that mapping. This size will always be an integral page size, as
it is not possible to share memory regions at less than page granularity. The
caller is responsible for unmapping the region
with
.Xr munmap 2 .
If the mapping operation failed, 0 will be returned.
.Pp
New mappings will be created with the maximum permission as specified by the
creator of the region. Currently, there is no direct way to modify the
permissions that the recipient of a region will have. If the caller wishes to
maintain read-write permissions to a region, for example, while giving others
read-only access, it can create an equivalent mapping with the desired 
permissions using a combination of
.Fn mach_make_memory_entry_64
and
.Fn mach_vm_remap .
The details of this procedure are left as an exercise to the reader.
.Pp
Certain operations that can operate on subranges of a region, such as
.Fn vm_copy ,
.Fn vm_read ,
and
.Fn vm_write ,
may fragment the underlying representation of a memory region in order to avoid
physical copies. After this fragmentation has occurred, it is not safe to create
a shared 